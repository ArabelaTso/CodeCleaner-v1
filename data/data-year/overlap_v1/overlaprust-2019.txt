--- 0 --
Question ID: 41d0d3de6eac7746cda3976054e9eb26c415cdf0_2
Original Code:
```
pub fn mgf1(sha: usize,z: &[u8],olen: usize,k: &mut [u8]) {
	let hlen=sha;

	let mut j=0;
	for i in 0..k.len() {k[i]=0}

	let mut cthreshold=olen/hlen; 
	if olen%hlen!=0 {cthreshold+=1}
	for counter in 0..cthreshold {
		let mut b:[u8;64]=[0;64];		
		hashit(sha,Some(z),counter as isize,&mut b);

		if j+hlen>olen {
			for i in 0..(olen%hlen) {k[j]=b[i]; j+=1}
		} else {
			for i in 0..hlen {k[j]=b[i]; j+=1}
		}
	}	
}
```


Overlapping Code:
```
: usize,k: &mut [u8]) {
let hlen=sha;
let mut j=0;
for i in 0..k.len() {k[i]=0}
let mut cthreshold=olen/hlen; 
if olen%hlen!=0 {cthreshold+=1}
for counter in 0..cthreshold {
let mut b:[u8;64]=[0;64]; 
hashit(sha,Some(z),counter as isize,&mut b);
if j+hlen>olen {
for i in 0..(olen%hlen) {k[j]=b[i]; j+=1}
} else {
for i in 0..hlen {k[j]=b[i]; j+=1}
}
```
<Overlap Ratio: 0.8951406649616368>

---

--- 1 --
Question ID: ce0119bedcd43a5a6bdb3fbb8df4c1ba4c3567b7_0
Original Code:
```
pub fn main() -> Result<(), String> {
    let elc = EventLoopContext::new();
    run(elc);
    Ok(())
}
```


Overlapping Code:
```
-> Result<(), String> {
let elc = EventLoopContext
```
<Overlap Ratio: 0.5494505494505495>

---

--- 2 --
Question ID: 3bdcb1c594668692dcccd7d9aa194c7568a33d51_3
Original Code:
```
fn chunk2x2_sum_uget1(bench: &mut Bencher) {
    let a = Array::<f32, _>::zeros((256, 256));
    let chunksz = (2, 2);
    let mut sum = Array::<f32, _>::zeros(a.exact_chunks(chunksz).raw_dim());
    bench.iter(|| {
        let (m, n) = a.dim();
        for i in 0..m {
            for j in 0..n {
                unsafe {
                    *sum.uget_mut([i / 2, j / 2]) += *a.uget([i, j]);
                }
            }
        }
    });
}
```


Overlapping Code:
```
bench: &mut Bencher) {
let a = Array::<f32, _>::zeros((256, 256));
let chunksz = (2, 2);
let mut sum = Array::<f32, _>::zeros(a.exact_chunks(chunksz).raw_dim());
bench.iter(|| {
let (m, n) = a.dim();
for i in 0..m {
for j in 0..n {
unsafe {
*sum.uget_mut([i / 2, j / 2]) += 
```
<Overlap Ratio: 0.845679012345679>

---

--- 3 --
Question ID: f2c37ea2a950ce027aef3faab5e285be074f7e15_0
Original Code:
```
pub fn list(client: &PeripherioClient, matches: &ArgMatches) -> Result<(), Error> {
    let conf: protos::Config = matches
        .values_of("config")
        .map(|confs| util::parse_config_list(confs))
        .unwrap_or(Ok(protos::Config::new()))?;
    let mut req = protos::FindRequest::new();
    req.set_config(conf);
    let spec = util::get_driver_spec_from_matches(matches);
    req.set_spec(spec);
    let reply = client.find_drivers(&req)?;
    println!("NAME VENDOR PATH CATEGORIES");
    for res in reply.get_results() {
        let name = res.get_name();
        let vendor = res.get_vendor();
        let path = res.get_path();
        let categories = res.get_category();
        println!("{} {} {} {}", name, vendor, path, categories.join(","));
    }
    Ok(())
}
```


Overlapping Code:
```
 list(client: &PeripherioClient, matches: &ArgMatches) -> Result<(), Error> {
let conf: protos::Config = matches
.values_of("config")
.map(|confs| util::parse_config_list(confs))
.unwrap_or(Ok(protos::Config::new()))?;
let mut req = protos::FindRequest::new();
req.set_config(conf);
let spec = util::get_driver_spec_from_matches(matches);
req.set_spec(spec);
let reply = client.find_drivers(&req)?;
println!("NAME VENDOR PATH CATEGORIES");
for res in reply.get_results() {
let name = res.get_name();
let vendor = res.get_vendor();
let path = res.get_path();
let categories = res.get_category();
println!("{} {} {} {}", name, vendor, path, categories.join(","));
}
Ok(()
```
<Overlap Ratio: 0.9867256637168141>

---

--- 4 --
Question ID: 6732bab6ef6e85f86e1639ba6b2f9d8be63dbb63_38
Original Code:
```
pub fn vector_bitand_assign_bool_broadcast() {
    let mut a = vector![true, true, false, false];
    let b = true;

    let exp = vector![true, true, false, false];

    a &= &b;
    assert_eq!(a, exp);

    let mut a = vector![true, true, false, false];

    a &= b;
    assert_eq!(a, exp);
}
```


Overlapping Code:
```
assign_bool_broadcast() {
let mut a = vector![true, true, false, false];
let b = true;
let exp = vector![true, true, false, false];
a &= &b;
assert_eq!(a, exp);
let mut a = vector![true, true, false, false];
a &= b;
```
<Overlap Ratio: 0.8333333333333334>

---

--- 5 --
Question ID: 689bb07b9139a9851ee649f181679cd88e95af6e_3
Original Code:
```
pub unsafe fn _get_bool_config(sz_setting: *const c_char) -> SettingBool {
    let mut setting: SettingBool = SettingBool {
        value: false,
        source: SettingSource::Default,
    };
    let mut sz_line = [0u8; 256];
    let mut psz_name: *mut c_char;
    let mut psz_value: *mut c_char;
    let mut sz_name = [0u8; 256];
    let mut sz_value = [0u8; 256];

    let pf = fopen(
        b"/etc/yubico/yubikeypiv.conf\0".as_ptr() as *const c_char,
        b"r\0".as_ptr() as *const c_char,
    );

    if pf.is_null() {
        return setting;
    }

    while feof(pf) == 0 {
        if fgets(
            sz_line.as_mut_ptr() as *mut c_char,
            sz_line.len() as c_int,
            pf,
        )
        .is_null()
        {
            continue;
        }

        if sz_line[0] == b'#' {
            continue;
        }

        if sz_line[0] == b'\r' {
            continue;
        }

        if sz_line[0] == b'\n' {
            continue;
        }

        if sscanf(
            sz_line.as_ptr() as *const c_char,
            b"%255[^=]=%255s\0".as_ptr() as *const c_char,
            sz_name.as_mut_ptr(),
            sz_value.as_mut_ptr(),
        ) != 2
        {
            continue;
        }

        psz_name = _strip_ws(sz_name.as_mut_ptr() as *mut c_char);

        if strcasecmp(psz_name, sz_setting) != 0 {
            continue;
        }

        psz_value = _strip_ws(sz_value.as_mut_ptr() as *mut c_char);
        setting.source = SettingSource::Admin;
        setting.value = strcmp(psz_value, b"1\0".as_ptr() as *const c_char) == 0
            || strcasecmp(psz_value, b"true\0".as_ptr() as *const c_char) == 0;
    }

    fclose(pf);
    setting
}
```


Overlapping Code:
```
fn _get_bool_config(sz_setting: *const c_char) -> SettingBool {
let mut setting: SettingBool = SettingBool {
value: false,
source: SettingSource::Default,
};
let mut sz_line = [0u8; 256];
let mut psz_name: *mut c_char;
let mut psz_value: *mut c_char;
let mut sz_name = [0u8; 256];
let mut sz_value = [0u8; 256];
let pf = fopen(
b"/etc/yubico/yubikeypiv.conf\0".as_ptr() as *const c_char,
b"r\0".as_ptr() as *const c_char,
);
if pf.is_null() {
return setting;
}
while feof(pf) == 0 {
if fgets(
sz_line.as_mut_ptr() as *mut c_char,
sz_line.len() as c_int,
pf,
)
.is_null()
{
continue;
}
if sz_line[0] == b'#' {
continue;
}
if sz_line[0] == b'\r' {
continue;
}
if sz_line[0] == b'\n' {
continue;
}
if sscanf(
sz_line.as_ptr() as *const c_char,
b"%255[^=]=%255s\0".as_ptr() as *const c_char,
sz_name.as_mut_ptr(),
sz_value.as_mut_ptr(),
) != 2
{
continue;
}
psz_name = _strip_ws(sz_name.as_mut_ptr() as *mut c_char);
if strcasecmp(psz_name, sz_setting) != 0 {
continue;
}
psz_value = _strip_ws(sz_value.as_mut_ptr() as *mut c_char);
setting.source = SettingSource::Admin;
setting.value = strcmp(psz_value, b"1\0".as_ptr() as *const c_char) == 0
|| strcasecmp(psz_value, b"true\0".as_ptr() as *const c_char) == 0;
}
fclose(pf
```
<Overlap Ratio: 0.9814963797264682>

---

--- 6 --
Question ID: 6d056f9b5880c8e6f933ab4571208896692720e6_10
Original Code:
```
fn _get_members(group: &rdkafka::groups::GroupInfo) -> Vec<dto::GroupMemberMetadata> {
    let mut members = Vec::with_capacity(group.members().len());
    for member in group.members() {
        let assignment = match member.assignment() {
            None => "",
            Some(assgn) => match std::str::from_utf8(assgn) {
                Ok(v) => v,
                Err(_) => "Non-Utf8",
            }
        };
        let meta = match member.metadata() {
            None => "",
            Some(data) => match std::str::from_utf8(data) {
                Ok(v) => v,
                Err(_) => "Non-Utf8",
            }
        };
        members.push(
            dto::GroupMemberMetadata{
                member_id: member.id().to_string(),
                client_id: member.client_id().to_string(),
                client_host: member.client_host().to_string(),
                metadata: meta.to_string(),
                assignment: assignment.to_string(),
            })
    }
    members
}
```


Overlapping Code:
```
dkafka::groups::GroupInfo) -> Vec<dto::GroupMemberMetadata> {
let mut members = Vec::with_capacity(group.members().len());
for member in group.members() {
let assignment = match member.assignment() {
None => "",
Some(assgn) => match std::str::from_utf8(assgn) {
Ok(v) => v,
Err(_) => "Non-Utf8",
}
};
let meta = match member.metadata() {
None => "",
Some(data) => match std::str::from_utf8(data) {
Ok(v) => v,
Err(_) => "Non-Utf8",
}
};
members.push(
dto::GroupMemberMetadata{
member_id: member.id().to_string(),
client_id: member.client_id().to_string(),
client_host: member.client_host().to_string(),
metadata: meta.to_string(),
assignment: assignm
```
<Overlap Ratio: 0.9206798866855525>

---

--- 7 --
Question ID: 41d1761a011505fc8993d495cd1c79ded6a693a8_86
Original Code:
```
fn test_not_b() {
        let mut cpu: CPU = CPU::new();
        cpu.memory.write_8bit(0, 0b00111011);

        cpu = cpu.set_b(Register { value: 0 });

        cpu = executor::execute(cpu);

        assert_eq!(cpu.pc.value, 1);
        assert_eq!(cpu.f.value, 0);
        assert_eq!(cpu.b.value, u64::max_value());
    }
```


Overlapping Code:
```
b() {
let mut cpu: CPU = CPU::new();
cpu.memory.write_8bit(0, 0b00111011);
cpu = cpu.set_b(Register { value: 0 });
cpu = executor::execute(cpu);
assert_eq!(cpu.pc.value, 1);
assert_eq!(cpu.f.value, 0);
assert_eq!(cpu.b.value, u64::max
```
<Overlap Ratio: 0.9069767441860465>

---

--- 8 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_626
Original Code:
```
fn spec_test_627() {
    let original = r##"foo <a href="&ouml;">
"##;
    let expected = r##"<p>foo <a href="&ouml;"></p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
() {
let original = r##"foo <a href="&ouml;">
"##;
let expected = r##"<p>foo <a href="&ouml;"></p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9006211180124224>

---

--- 9 --
Question ID: 129ad04d63bb6f1759b4ff452fc1ab726b26815b_0
Original Code:
```
pub fn request(bus: &Bus<Missive>, topic: Topic) -> RpcResult<Missive> {
    let (tx, rx) = bounded(1);
    trace!("making {:?} request to data service", topic);
    bus.send_top(Missive::DataRequest { topic, tx });
    rx.recv()
        .map_err(|_| app_error(68, "data service channel disconnect", None))?
}
```


Overlapping Code:
```
 fn request(bus: &Bus<Missive>, topic: Topic) -> RpcResult<Missive> {
let (tx, rx) = bounded(1);
trace!("making {:?} request to data service", topic);
bus.send_top(Missive::DataRequest { topic, tx });
rx.recv()
.map_err(|_| app_error(68, "data servic
```
<Overlap Ratio: 0.8771929824561403>

---

--- 10 --
Question ID: 0f124613f688d15139b709202c0eb1be80b79c77_0
Original Code:
```
pub fn main() -> () {
	let mut window = connect!();
	let mut queue = InputQueue::create();

	'mainloop: loop {
		window.update(&mut queue);

		for input in queue.iter() {
			use window::Input::*;
			use window::Msg::*;

			match *input {
				Msg(Quit) | Msg(Back) => break 'mainloop,
	//			Input::Redraw => redraw(&mut context),
				_ => {},
			}
		}
	}
}
```


Overlapping Code:
```
pub fn main() -> () {
let mut window = connect!();
let mut queue = InputQueue::create();
'mainloop: loop {
window.update(&mut queue);
for input in queue.iter() {
use window::Input::*;
use window::Msg::*;
match *input {
Msg(Quit) | Msg(Back) => break 'mainloop,
// Input::Redraw => redraw(&mut context
```
<Overlap Ratio: 0.9404388714733543>

---

--- 11 --
Question ID: afc255f62ac60f15d10841fcb2b606dfdc700761_1
Original Code:
```
fn test_pointers_bitfield() {
        let mut bitfield = PointersBitfield::default();

        bitfield.set(0);
        bitfield.set(1);
        bitfield.set(3);
        bitfield.set(4);
        bitfield.set(8);
        bitfield.set(30);
        bitfield.set(31);

        assert_eq!(bitfield.get_index_for(0).unwrap(), 0);
        assert_eq!(bitfield.get_index_for(1).unwrap(), 1);
        assert_eq!(bitfield.get_index_for(3).unwrap(), 2);
        assert_eq!(bitfield.get_index_for(4).unwrap(), 3);
        assert_eq!(bitfield.get_index_for(8).unwrap(), 4);
        assert_eq!(bitfield.get_index_for(30).unwrap(), 5);
        assert_eq!(bitfield.get_index_for(31).unwrap(), 6);

        assert!(bitfield.get_index_for(15).is_none());
        assert!(bitfield.get_index_for(29).is_none());

        assert_eq!(bitfield.count(), 7);

        let mut bitfield = PointersBitfield::default();

        bitfield.set(5);
        bitfield.set(30);
        bitfield.set(31);

        assert_eq!(bitfield.get_index_for(5).unwrap(), 0);
        assert_eq!(bitfield.get_index_for(30).unwrap(), 1);
        assert_eq!(bitfield.get_index_for(31).unwrap(), 2);

        assert_eq!(bitfield.count(), 3);
    }
```


Overlapping Code:
```
est_pointers_bitfield() {
let mut bitfield = PointersBitfield::default();
bitfield.set(0);
bitfield.set(1);
bitfield.set(3);
bitfield.set(4);
bitfield.set(8);
bitfield.set(30);
bitfield.set(31);
assert_eq!(bitfield.get_index_for(0).unwrap(), 0);
assert_eq!(bitfield.get_index_for(1).unwrap(), 1);
assert_eq!(bitfield.get_index_for(3).unwrap(), 2);
assert_eq!(bitfield.get_index_for(4).unwrap(), 3);
assert_eq!(bitfield.get_index_for(8).unwrap(), 4);
assert_eq!(bitfield.get_index_for(30).unwrap(), 5);
assert_eq!(bitfield.get_index_for(31).unwrap(), 6);
assert!(bitfield.get_index_for(15).is_none());
assert!(bitfield.get_index_for(29).is_none());
assert_eq!(bitfield.count(), 7);
let mut bitfield = PointersBitfield::default();
bitfield.set(5);
bitfield.set(30);
bitfield.set(31);
assert_eq!(bitfield.get_index_for(5).unwrap(), 0);
assert_eq!(bitfield.get_index_for(30).unwrap(), 1);
assert_eq!(bitfield.get_index_for(31).unwrap(), 2);
assert_eq!(bi
```
<Overlap Ratio: 0.9743589743589743>

---

--- 12 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_87
Original Code:
```
fn spec_test_88() {
    let original = r##"    foo  
"##;
    let expected = r##"<pre><code>foo  
</code></pre>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
 spec_test_88() {
let original = r##" foo 
"##;
let expected = r##"<pre><code>foo 
</code></pre>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9862068965517241>

---

--- 13 --
Question ID: dacb2e04b07e5e2b6da0be51cd33e4c7689e0ffe_0
Original Code:
```
pub fn handle_reset_password(
    password_data: Form<PasswordData>
) -> Box<dyn Future<Item=HttpResponse, Error=Error>> {
    let response: &str;
    if check_email_format(password_data.email.as_str()) {
        if check_password_format(password_data.password.as_str()) &&
            check_password_format(password_data.confirm_password.as_str()) {
            response = validate_reset_password(password_data.email.as_str(),
                                               password_data.password.as_str(),
                                               password_data.confirm_password.as_str())
        } else {
            error!("{}", WRONG_PASSWORD_FORMAT);
            response = WRONG_PASSWORD_FORMAT;
        }
    } else {
        error!("{}", WRONG_EMAIL_FORMAT);
        response = WRONG_EMAIL_FORMAT;
    }
    result(Ok(HttpResponse::Ok()
        .json(json!({RESPONSE: response}))))
        .responder()
}
```


Overlapping Code:
```
m<PasswordData>
) -> Box<dyn Future<Item=HttpResponse, Error=Error>> {
let response: &str;
if check_email_format(password_data.email.as_str()) {
if check_password_format(password_data.password.as_str()) &&
check_password_format(password_data.confirm_password.as_str()) {
response = validate_reset_password(password_data.email.as_str(),
password_data.password.as_str(),
password_data.confirm_password.as_str())
} else {
error!("{}", WRONG_PASSWORD_FORMAT);
response = WRONG_PASSWORD_FORMAT;
}
} else {
error!("{}", WRONG_EMAIL_FORMAT);
response = WRONG_EMAIL_FORMAT;
}
result(Ok(HttpResponse::Ok()
.json(json!({RESPONSE: response}))))
.responder(
```
<Overlap Ratio: 0.9267241379310345>

---

--- 14 --
Question ID: dc94ca414ec24537d2f06e7bb0d3e640fa8d32ce_3
Original Code:
```
fn check_accumulator_op(
            state: &mut ComputerState,
            operation: Operation,
            initial_value: Option<u8>,
            operand_value: Option<u8>,
            expected_value: u8,
            expected_flags: Vec<StatusFlag>,
        ) {
            match initial_value {
                Some(value) => state.registers.accumulator = value,
                None => (),
            };

            let operand = match operand_value {
                Some(val) => Operand::Immediate(val),
                None => Operand::Accumulator,
            };

            state.execute_operation(operation, operand).unwrap();
            assert_eq!(state.registers.accumulator, expected_value);
            check_status_flags(&state, &expected_flags);
        }
```


Overlapping Code:
```
te,
operation: Operation,
initial_value: Option<u8>,
operand_value: Option<u8>,
expected_value: u8,
expected_flags: Vec<StatusFlag>,
) {
match initial_value {
Some(value) => state.registers.accumulator = value,
None => (),
};
let operand = match operand_value {
Some(val) => Operand::Immediate(val),
None => Operand::Accumulator,
};
state.execute_operation(operation, operand).unwrap();
assert_eq!(state.registers.accumulator, expected_value);
check_
```
<Overlap Ratio: 0.8364312267657993>

---

--- 15 --
Question ID: 6732965205dbb9584f0f035768b7132c4c3ad828_0
Original Code:
```
fn gzencoder_read_hello_world() -> io::Result<Vec<u8>> {
    let mut ret_vec = [0; 100];
    let c = b"hello world";
    let mut z = GzEncoder::new(&c[..], Compression::fast());
    let count = z.read(&mut ret_vec)?;
    Ok(ret_vec[0..count].to_vec())
}
```


Overlapping Code:
```
read_hello_world() -> io::Result<Vec<u8>> {
let mut ret_vec = [0; 100];
let c = b"hello world";
let mut z = GzEncoder::new(&c[..], Compression::fast());
let count = z.read(&mu
```
<Overlap Ratio: 0.7510729613733905>

---

--- 16 --
Question ID: 58c23ad09deb2dc100c9a062a5d8021d1cad94e4_0
Original Code:
```
fn test_backup() {
        let db = SqliteConnection::open_in_memory().unwrap();
        let sql = "BEGIN;
                CREATE TABLE foo(x INTEGER);
                INSERT INTO foo VALUES(42);
                END;";
        db.execute_batch(sql).unwrap();
        db.backup("main", &":memory:").unwrap();
        assert!(db.close().is_ok());
    }
```


Overlapping Code:
```

let db = SqliteConnection::open_in_memory().unwrap();
let sql = "BEGIN;
CREATE TABLE foo(x INTEGER);
INSERT INTO foo VALUES(42);
END;";
db.execute_batch(sql).unwrap();
db.backup("main", &":memory:").unwrap();
assert!(d
```
<Overlap Ratio: 0.8488372093023255>

---

--- 17 --
Question ID: ee307021413d7a66cdee779f8c0a7c58c1e90d1e_2
Original Code:
```
fn test_unify_tag() {
        let tags = "a,#b";
        let tags = Recipe::unify_tags(tags);

        let tag_a = "#a".to_string();
        assert!(tags.contains(&tag_a));

        let tag_b = "#b".to_string();
        assert!(tags.contains(&tag_b));
    }
```


Overlapping Code:
```
 "a,#b";
let tags = Recipe::unify_tags(tags);
let tag_a = "#a".to_string();
assert!(tags.contains(&tag_a));
let tag_b = "#b".to_string();
assert!(tags.contains
```
<Overlap Ratio: 0.7832512315270936>

---

--- 18 --
Question ID: eac8d866a7e8fa72bd61398904001386f1a07ba8_3
Original Code:
```
fn mine_cuckatoo_lean_cpu_19() {
	let mut config = PluginConfig::new("cuckatoo_lean_cpu_19").unwrap();
	config.params.nthreads = 4;
	mine_async_for_duration(&vec![config], 20);
}
```


Overlapping Code:
```
 {
let mut config = PluginConfig::new("cuckatoo_lean_cpu_19").unwrap();
config.params.nthreads = 4;
mine_async_for_duration(&vec![config], 20);
```
<Overlap Ratio: 0.8171428571428572>

---

--- 19 --
Question ID: e3db959b6939aacb3fd4ba6e78bab7943a36f1f8_0
Original Code:
```
fn main() {
  // ...handle just one enum variant specially
  if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); }

  // ...run some code only if a table lookup succeeds
  if let Some(document) = cache_map.get(&id) { return send_cached_response(document); }

  // ...repeatedly try something until it succeeds
  while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err);
    // let the user try again (it might still be a human)
  }

  // ...manually loop over an iterator
  while let Some(_) = lines.peek() {
      read_paragraph(&mut lines);
  }
}
```


Overlapping Code:
```
main() {
// ...handle just one enum variant specially
if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); }
// ...run some code only if a table lookup succeeds
if let Some(document) = cache_map.get(&id) { return send_cached_response(document); }
// ...repeatedly try something until it succeeds
while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err);
// let the user try again (it might still be a human)
}
// ...manually loop over an iterator
while let Some(_) = lines.peek() {
read_par
```
<Overlap Ratio: 0.9548611111111112>

---

--- 20 --
Question ID: bf7fba5b4cafdd53b35d36aec525c4d622721384_1
Original Code:
```
fn permissions() {
        use nix::sys::stat::{self, Mode};
        let path = std::path::Path::new("./test_pipe_2");
        let assert_stats_eq = |input| {
            super::create_pipe(path, input).expect("Failed to create pipe");
            let file_stat = stat::stat(path).expect("Failed to get file stat");
            let mode = Mode::from_bits_truncate(file_stat.st_mode);
            if let Some(new_mode) = input {
                assert_eq!(mode, new_mode);
            } else {
                assert_eq!(mode, Mode::from_bits_truncate(0o660));
            }
            block_on(super::remove_pipe(path)).expect("Failed to remove pipe");
        };
        // Defaults
        assert_stats_eq(None);
        // Custom mode
        assert_stats_eq(Some(Mode::from_bits_truncate(0o644)));
    }
```


Overlapping Code:
```
lf, Mode};
let path = std::path::Path::new("./test_pipe_2");
let assert_stats_eq = |input| {
super::create_pipe(path, input).expect("Failed to create pipe");
let file_stat = stat::stat(path).expect("Failed to get file stat");
let mode = Mode::from_bits_truncate(file_stat.st_mode);
if let Some(new_mode) = input {
assert_eq!(mode, new_mode);
} else {
assert_eq!(mode, Mode::from_bits_truncate(0o660));
}
block_on(super::remove_pipe(path)).expect("Failed to remove pipe");
};
// Defaults
assert_stats_eq(None);
// Custom mode
assert_stats_eq(Some(Mode
```
<Overlap Ratio: 0.8814102564102564>

---

--- 21 --
Question ID: af0d17a5364b49e50bfb038555efe03a2d80bbbf_5
Original Code:
```
fn spawn_with_handle(cmd: &mut Command) -> io::Result<(Child, ProcessHandle)> {
        use self::spawn_task_port::CommandSpawnWithTask;
        let (child, mach_port_name) = cmd.spawn_get_task_port()?;

        let handle = ProcessHandle::try_from(mach_port_name)?;
        Ok((child, handle))
    }
```


Overlapping Code:
```
fn spawn_with_handle(cmd: &mut Command) -> io::Result<(Child, ProcessHandle)> {
use self::spawn_task_port::CommandSpawnWithTask;
let (child, mach_port_name) = cmd.spawn_get_task_port()?;
let handle = ProcessHandle::tr
```
<Overlap Ratio: 0.8250950570342205>

---

--- 22 --
Question ID: b55f3757e31b3470f618ee22cd5a891f077f27a3_0
Original Code:
```
fn encode(input: String, output: String) -> io::Result<()> {
    let mut input_file = File::open(input)?;
    let output_file = File::create(output)?;
    let mut output_writer = io::BufWriter::new(output_file);

    let input_copy = input_file.try_clone()?;
    let freqs = coding::Frequencies::count_bytes(input_copy.bytes())?;
    freqs.write(&mut output_writer)?;

    let tree = coding::HuffTree::from_freqs(&freqs);
    let mut encoder = coding::HuffWriter::from_tree(&tree);
    input_file.seek(io::SeekFrom::Start(0))?;
    for maybe_byte in input_file.bytes() {
        let byte = maybe_byte?;
        encoder.write_byte(byte, &mut output_writer)?;
    }
    encoder.end_transmission(&mut output_writer)
}
```


Overlapping Code:
```
, output: String) -> io::Result<()> {
let mut input_file = File::open(input)?;
let output_file = File::create(output)?;
let mut output_writer = io::BufWriter::new(output_file);
let input_copy = input_file.try_clone()?;
let freqs = coding::Frequencies::count_bytes(input_copy.bytes())?;
freqs.write(&mut output_writer)?;
let tree = coding::HuffTree::from_freqs(&freqs);
let mut encoder = coding::HuffWriter::from_tree(&tree);
input_file.seek(io::SeekFrom::Start(0))?;
for maybe_byte in input_file.bytes() {
let byte = maybe_byte?;
encoder.write_byte(byte, &mut output_writer)?;
}
encoder.end_transmiss
```
<Overlap Ratio: 0.9259259259259259>

---

--- 23 --
Question ID: 6e382b8d17efcf9d32903c1c8bbea7c312aa7d8c_0
Original Code:
```
fn trade_payload_deserialize() {
        let json1 = r##"{"e":"trade","E":1539264159120,"s":"BNBBTC","t":29661698,"p":"0.00152100","q":"1.00000000","b":84391627,"a":84391631,"T":1539264159104,"m":true,"M":true}"##;

        let payload: Payload = serde_json::from_str(json1).unwrap();
        let back = serde_json::to_string(&payload).unwrap();
        assert_eq!(back.as_str(), json1);
    }
```


Overlapping Code:
```
serialize() {
let json1 = r##"{"e":"trade","E":1539264159120,"s":"BNBBTC","t":29661698,"p":"0.00152100","q":"1.00000000","b":84391627,"a":84391631,"T":1539264159104,"m":true,"M":true}"##;
let payload: Payload = serde_json::from_str(json1).unwrap();
let back = serde_json::to_string(&payload).unwrap()
```
<Overlap Ratio: 0.8426966292134831>

---

--- 24 --
Question ID: 171528595e8411d168912ec7ceac499215efacc7_0
Original Code:
```
fn read_varint<R: Read>(r: &mut R) -> std::io::Result<u64> {
    let mut b = [0_u8];
    r.read_exact(&mut b)?;
    Ok(match b[0] {
        0xff => {
            let mut b = [0_u8; 8];
            r.read_exact(&mut b)?;
            u64::from_be_bytes(b)
        }
        0xfe => {
            let mut b = [0_u8; 4];
            r.read_exact(&mut b)?;
            u32::from_be_bytes(b) as u64
        }
        0xfd => {
            let mut b = [0_u8; 2];
            r.read_exact(&mut b)?;
            u16::from_be_bytes(b) as u64
        }
        n => n as u64,
    })
}
```


Overlapping Code:
```
td::io::Result<u64> {
let mut b = [0_u8];
r.read_exact(&mut b)?;
Ok(match b[0] {
0xff => {
let mut b = [0_u8; 8];
r.read_exact(&mut b)?;
u64::from_be_bytes(b)
}
0xfe => {
let mut b = [0_u8; 4];
r.read_exact(&mut b)?;
u32::from_be_bytes(b) as u64
}
0xfd => {
let mut b = [0_u8; 2];
r.read_exact(&mut b)?;
u16::from_be_bytes(b) as u64
}
n => n as u64,

```
<Overlap Ratio: 0.8905852417302799>

---

--- 25 --
Question ID: 044c972a94bac860ba918be56fce5a72a4aa0bf4_3
Original Code:
```
fn find_node_string() {
    let expr = compile_expression(r#" "ok" "#);
    assert_eq!(expr.find_node(0), None);
    assert_eq!(expr.find_node(1), Some(&expr));
    assert_eq!(expr.find_node(4), Some(&expr));
    assert_eq!(expr.find_node(5), None);
}
```


Overlapping Code:
```
et expr = compile_expression(r#" "ok" "#);
assert_eq!(expr.find_node(0), None);
assert_eq!(expr.find_node(1), Some(&expr));
assert_eq!(expr.find_node(4), Some(&expr));
assert_eq!(expr.find_node(5), No
```
<Overlap Ratio: 0.8658008658008658>

---

--- 26 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_400
Original Code:
```
fn spec_test_401() {
    let original = r##"__foo__bar__baz__
"##;
    let expected = r##"<p><strong>foo__bar__baz</strong></p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
c_test_401() {
let original = r##"__foo__bar__baz__
"##;
let expected = r##"<p><strong>foo__bar__baz</strong></p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.963855421686747>

---

--- 27 --
Question ID: 70ba18680993cec11915b7c1db8bad71851303be_0
Original Code:
```
fn main() {
    env_logger::init();
    let server = TcpListener::bind("127.0.0.1:3012").unwrap();
    for stream in server.incoming() {
        spawn(move || {
            let callback = |req: &Request| {
                println!("Received a new ws handshake");
                println!("The request's path is: {}", req.path);
                println!("The request's headers are:");
                for &(ref header, _ /* value */) in req.headers.iter() {
                    println!("* {}", header);
                }

                // Let's add an additional header to our response to the client.
                let extra_headers = vec![
                    (String::from("MyCustomHeader"), String::from(":)")),
                    (
                        String::from("SOME_TUNGSTENITE_HEADER"),
                        String::from("header_value"),
                    ),
                ];
                Ok(Some(extra_headers))
            };
            let mut websocket = accept_hdr(stream.unwrap(), callback).unwrap();

            loop {
                let msg = websocket.read_message().unwrap();
                if msg.is_binary() || msg.is_text() {
                    websocket.write_message(msg).unwrap();
                }
            }
        });
    }
}
```


Overlapping Code:
```
n() {
env_logger::init();
let server = TcpListener::bind("127.0.0.1:3012").unwrap();
for stream in server.incoming() {
spawn(move || {
let callback = |req: &Request| {
println!("Received a new ws handshake");
println!("The request's path is: {}", req.path);
println!("The request's headers are:");
for &(ref header, _ /* value */) in req.headers.iter() {
println!("* {}", header);
}
// Let's add an additional header to our response to the client.
let extra_headers = vec![
(String::from("MyCustomHeader"), String::from(":)")),
(
String::from("SOME_TUNGSTENITE_HEADER"),
String::from("header_value"),
),
];
Ok(Some(extra_headers))
};
let mut websocket = accept_hdr(stream.unwrap(), callback).unwrap();
loop {
let msg = websocket.read_message().unwrap();
if msg.is_binary() || msg.is_text() {
websocket.write_message(msg).unwrap();
}
}
});
}
```
<Overlap Ratio: 0.9905660377358491>

---

--- 28 --
Question ID: 05a8e3d209a834b128c7405ce0187866ee65df72_12
Original Code:
```
fn basic_parsing() {
        assert_eq!(super::Version::from_str("0.1.2").unwrap(), super::Version::new(&[0,1,2]));
        assert_eq!(super::Version::from_str("120.1.2").unwrap(), super::Version::new(&[120,1,2]));
        assert_eq!(super::Version::from_str("1.12.2").unwrap(), super::Version::new(&[1,12,2]));
        assert_eq!(super::Version::from_str("1.1.132").unwrap(), super::Version::new(&[1,1,132]));
        assert_eq!(super::Version::from_str("0.0.2").unwrap(), super::Version::new(&[0,0,2]));
        assert_eq!(super::Version::from_str("0132.1.2").unwrap(), super::Version::new(&[132,1,2]));
        assert_eq!(super::Version::from_str("1.2.3.12.123.231.111").unwrap(), super::Version::new(&[1,2,3,12,123,231,111]));
        assert_eq!(super::Version::from_str("1.2").unwrap(), super::Version::new(&[1,2]));
        assert_eq!(super::Version::from_str("1").unwrap(), super::Version::new(&[1]));
    }
```


Overlapping Code:
```
rt_eq!(super::Version::from_str("0.1.2").unwrap(), super::Version::new(&[0,1,2]));
assert_eq!(super::Version::from_str("120.1.2").unwrap(), super::Version::new(&[120,1,2]));
assert_eq!(super::Version::from_str("1.12.2").unwrap(), super::Version::new(&[1,12,2]));
assert_eq!(super::Version::from_str("1.1.132").unwrap(), super::Version::new(&[1,1,132]));
assert_eq!(super::Version::from_str("0.0.2").unwrap(), super::Version::new(&[0,0,2]));
assert_eq!(super::Version::from_str("0132.1.2").unwrap(), super::Version::new(&[132,1,2]));
assert_eq!(super::Version::from_str("1.2.3.12.123.231.111").unwrap(), super::Version::new(&[1,2,3,12,123,231,111]));
assert_eq!(super::Version::from_str("1.2").unwrap(), super::Version::new(&[1,2]));
assert_eq!(super::Version::from_str("1").unwrap(), super::Version::
```
<Overlap Ratio: 0.954653937947494>

---

--- 29 --
Question ID: 2ac950027523cdd0b783cf904f7a2f788318e32b_2
Original Code:
```
unsafe fn test_mm_add_pi32() {
        let a = _mm_setr_pi32(1, -1);
        let b = _mm_setr_pi32(i32::MAX - 1, i32::MIN + 1);
        let e = _mm_setr_pi32(i32::MAX, i32::MIN);
        assert_eq_m64(e, _mm_add_pi32(a, b));
        assert_eq_m64(e, _m_paddd(a, b));
    }
```


Overlapping Code:
```
test_mm_add_pi32() {
let a = _mm_setr_pi32(1, -1);
let b = _mm_setr_pi32(i32::MAX - 1, i32::MIN + 1);
let e = _mm_setr_pi32(i32::MAX, i32::MIN);
assert_eq_m64(e, _mm_add_pi32(a, b));
assert_eq_m64(e, 
```
<Overlap Ratio: 0.8771929824561403>

---

--- 30 --
Question ID: c69be8ce7ea790a7130a3a0e58140a8bb5541808_2
Original Code:
```
fn update_number_of_confirmations<F1: Fn() -> H256, F2: Fn(H256) -> Option<u64>>(latest_block: &F1, confirmations: &F2, future_new_set: &mut Option<FutureNewSet>, snapshot: &mut KeyServerSetSnapshot) {
	match future_new_set.as_mut() {
		// no future new set is scheduled => do nothing,
		None => return,
		// else we should calculate number of confirmations for future new set
		Some(future_new_set) => match confirmations(future_new_set.block.clone()) {
			// we have enough confirmations => should move new_set from future to snapshot
			Some(confirmations) if confirmations >= MIGRATION_CONFIRMATIONS_REQUIRED => (),
			// not enough confirmations => do nothing
			Some(_) => return,
			// if number of confirmations is None, then reorg has happened && we need to reset block
			// (some more intelligent strategy is possible, but let's stick to simplest one)
			None => {
				future_new_set.block = latest_block();
				return;
			}
		}
	}

	let future_new_set = future_new_set.take()
		.expect("we only pass through match above when future_new_set is some; qed");
	snapshot.new_set = future_new_set.new_set;
}
```


Overlapping Code:
```
er_of_confirmations<F1: Fn() -> H256, F2: Fn(H256) -> Option<u64>>(latest_block: &F1, confirmations: &F2, future_new_set: &mut Option<FutureNewSet>, snapshot: &mut KeyServerSetSnapshot) {
match future_new_set.as_mut() {
// no future new set is scheduled => do nothing,
None => return,
// else we should calculate number of confirmations for future new set
Some(future_new_set) => match confirmations(future_new_set.block.clone()) {
// we have enough confirmations => should move new_set from future to snapshot
Some(confirmations) if confirmations >= MIGRATION_CONFIRMATIONS_REQUIRED => (),
// not enough confirmations => do nothing
Some(_) => return,
// if number of confirmations is None, then reorg has happened && we need to reset block
// (some more intelligent strategy is possible, but let's stick to simplest one)
None => {
future_new_set.block = latest_block();
return;
}
}
}
let future_new_set = future_new_set.take()
.expect("we only pass through match above when future_new_set is some; qed");
snapshot.new_set = future_new_set.new_set;
}
```
<Overlap Ratio: 0.9868421052631579>

---

--- 31 --
Question ID: 51f8d22c1d59a1668b8cf2d7106c201e02df9d69_0
Original Code:
```
fn size(args: CommandArgs, _registry: &CommandRegistry) -> Result<OutputStream, ShellError> {
    let input = args.input;
    let tag = args.call_info.name_tag;
    Ok(input
        .values
        .map(move |v| match v.item {
            Value::Primitive(Primitive::String(ref s)) => ReturnSuccess::value(count(s, v.tag())),
            _ => Err(ShellError::labeled_error_with_secondary(
                "Expected a string from pipeline",
                "requires string input",
                tag,
                "value originates from here",
                v.tag(),
            )),
        })
        .to_output_stream())
}
```


Overlapping Code:
```
s: CommandArgs, _registry: &CommandRegistry) -> Result<OutputStream, ShellError> {
let input = args.input;
let tag = args.call_info.name_tag;
Ok(input
.values
.map(move |v| match v.item {
Value::Primitive(Primitive::String(ref s)) => ReturnSuccess::value(count(s, v.tag())),
_ => Err(ShellError::labeled_error_with_secondary(
"Expected a string from pipeline",
"requires string input",
tag,
"value originates from here",
v.tag(),
)),
})
.to_output_stre
```
<Overlap Ratio: 0.9617021276595744>

---

--- 32 --
Question ID: b2e35c1ba2adbadd63fbaffbff67b375dac31e14_4
Original Code:
```
fn b_letter<G: Graphics>(
    polygon: &graphics::Polygon, c: &Context, gl: &mut G
) {
    let mut draw = |poly| polygon.draw(poly, &c.draw_state, c.transform, gl);
    draw(top_capped_right);
    draw(upper_left_face_right);
    draw(upper_right_face_left_capped_right);
    draw(middle);
    draw(lower_left_face_right);
    draw(lower_right_face_left_capped_right);
    draw(bottom_capped_right);
}
```


Overlapping Code:
```
_letter<G: Graphics>(
polygon: &graphics::Polygon, c: &Context, gl: &mut G
) {
let mut draw = |poly| polygon.draw(poly, &c.draw_state, c.transform, gl);
draw(top_capped_right);
draw(upper_left_face_right);
draw(upper_right_face_left_capped_right);
draw(middle);
draw(lower_left_face_right);
draw(lower_right_face_left_capped_right);
draw(bottom_capped_rig
```
<Overlap Ratio: 0.9726027397260274>

---

--- 33 --
Question ID: 5cb84beea124480ed2fce88c87e31da1965ff14a_0
Original Code:
```
pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {
    alignment_check(pc)?;

    let instr = instr_mem.read_u32(pc as usize)?;
    let next_pc = pc + 4;
    Ok((instr, next_pc))
}
```


Overlapping Code:
```
 &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {
alignment_check(pc)?;
let instr = instr_mem.read_u32(pc as usize)?;
let next_pc = pc 
```
<Overlap Ratio: 0.75>

---

--- 34 --
Question ID: f07fbe0fa8f606927d7cf56e306c4f3bee05d7b9_18
Original Code:
```
fn can_parse_command_statement_with_empty_tuple_parameter() {
        let statement   = "some-command ()";
        let parsed      = parse(statement);

        assert!(parsed.is_ok());

        let result = parsed.unwrap();
        assert!(result.len() == 1);

        let ref cmd = result[0];
        assert!(match applies_to(cmd) { Some((Expression::Identifier(_), Expression::Tuple(_))) => true, _ => false });
    }
```


Overlapping Code:
```
y_tuple_parameter() {
let statement = "some-command ()";
let parsed = parse(statement);
assert!(parsed.is_ok());
let result = parsed.unwrap();
assert!(result.len() == 1);
let ref cmd = result[0];
assert!(match applies_to(cmd) { Some((Expression::Identifier(_), Expression::Tuple(_))) => true, _ => fa
```
<Overlap Ratio: 0.8595988538681948>

---

--- 35 --
Question ID: d70c00feb034c08e7df1e706ca60e83f1fc05eab_2
Original Code:
```
fn create_bitmap_metadata(glyph_tab: &GlyphTable, spec: AtlasSpec) -> HashMap<usize, GlyphMetadata> {
    let mut metadata = HashMap::new();
    let glyph_metadata_space = GlyphMetadata::new(32, 0, 0, 0.5, 1.0, 0.0, 0.0, 0.0);
    metadata.insert(32, glyph_metadata_space);
    for i in glyph_tab.buffer.keys() {
        let order = i - 32;
        let col = order % spec.columns;
        let row = order % spec.columns;

        // Glyph metadata parameters.
        let x_min = (col * spec.slot_glyph_size) as f32 / spec.width as f32;
        let y_min = (row * spec.slot_glyph_size) as f32 / spec.height as f32;
        let width = (glyph_tab.width[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;
        let height = (glyph_tab.rows[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;
        let y_offset = -(spec.padding as f32 - glyph_tab.y_min[*i] as f32) / spec.slot_glyph_size as f32;

        let row = order / spec.rows;
        let column = order % spec.columns;
        let glyph_metadata_i = GlyphMetadata::new(*i, row, column, width, height, x_min, y_min, y_offset);
        metadata.insert(*i, glyph_metadata_i);
    }

    metadata
}
```


Overlapping Code:
```
e_bitmap_metadata(glyph_tab: &GlyphTable, spec: AtlasSpec) -> HashMap<usize, GlyphMetadata> {
let mut metadata = HashMap::new();
let glyph_metadata_space = GlyphMetadata::new(32, 0, 0, 0.5, 1.0, 0.0, 0.0, 0.0);
metadata.insert(32, glyph_metadata_space);
for i in glyph_tab.buffer.keys() {
let order = i - 32;
let col = order % spec.columns;
let row = order % spec.columns;
// Glyph metadata parameters.
let x_min = (col * spec.slot_glyph_size) as f32 / spec.width as f32;
let y_min = (row * spec.slot_glyph_size) as f32 / spec.height as f32;
let width = (glyph_tab.width[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;
let height = (glyph_tab.rows[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;
let y_offset = -(spec.padding as f32 - glyph_tab.y_min[*i] as f32) / spec.slot_glyph_size as f32;
let row = order / spec.rows;
let column = order % spec.columns;
let glyph_metadata_i = GlyphMetadata::new(*i, row, column, width, height, x_min, y_min, y_offset);
metadata.
```
<Overlap Ratio: 0.9523809523809523>

---

--- 36 --
Question ID: 7c2a7d6f4de2da70cba9dcbcb8f1e0fad82fafda_6
Original Code:
```
fn test_qc_smalln() {
    quick_check_occurs!(|n: SmallN| *n == 0);
    quick_check_occurs!(|n: SmallN| *n == 1);
    quick_check_occurs!(|n: SmallN| *n > 10);
}
```


Overlapping Code:
```
check_occurs!(|n: SmallN| *n == 0);
quick_check_occurs!(|n: SmallN| *n == 1);
quick_check_occurs!(|n
```
<Overlap Ratio: 0.6711409395973155>

---

--- 37 --
Question ID: 0fa397177e2a1fb9d612b3f22749867c27890f90_0
Original Code:
```
fn main() {
    
    let mut io = IoHandler::new();

    io.add_method("verify_transaction", |params: Params| {
        let parsed: Transaction = params.parse().unwrap();
        let is_self = verify_raw(parsed.defunc_hash(), &parsed.signature, &parsed.sender);
        Ok(Value::String(format!("{}", is_self)))
    });

    
    
    let server = ServerBuilder::new(io)
    .start_http(&"127.0.0.1:3030".parse().unwrap())
    .expect("Unable to start RPC server");
    server.wait();
}
```


Overlapping Code:
```
ew();
io.add_method("verify_transaction", |params: Params| {
let parsed: Transaction = params.parse().unwrap();
let is_self = verify_raw(parsed.defunc_hash(), &parsed.signature, &parsed.sender);
Ok(Value::String(format!("{}", is_self)))
});


let server = ServerBuilder::new(io)
.start_http(&"127.0.0.1:3030".parse().unwrap())
.expect("Unable to start RPC server");
server.wait()
```
<Overlap Ratio: 0.9023809523809524>

---

--- 38 --
Question ID: 5f2555ba435ae4886b42755019de8cf1eab75942_10
Original Code:
```
pub fn learning_summary_upage(db: DB, ip: Ip, pg: i64, user: User) -> Template {
	log_to_db(&db, ip, user.0);
	let category = "LearningSummary";
	let (articles, total_article) = Article::pagination_query_by_category(db.conn(), &category, pg);
	let mut context = user_context(&db, user);
	let total_page = (total_article - 1) / 10 + 1;
	context.insert("articles", &articles);
	context.insert("total_page", &total_page);
	context.insert("pg", &pg);
	context.insert("category", "Learning Summary");
	Template::render("article_list", &context)
}
```


Overlapping Code:
```
B, ip: Ip, pg: i64, user: User) -> Template {
log_to_db(&db, ip, user.0);
let category = "LearningSummary";
let (articles, total_article) = Article::pagination_query_by_category(db.conn(), &category, pg);
let mut context = user_context(&db, user);
let total_page = (total_article - 1) / 10 + 1;
context.insert("articles", &articles);
context.insert("total_page", &total_page);
context.insert("pg", &pg);
context.insert("category", "Learning Summary");
Temp
```
<Overlap Ratio: 0.8587570621468926>

---

--- 39 --
Question ID: 5c725bead6867b9d04e5c3081fa4be81fbf89284_0
Original Code:
```
fn prev_grapheme_boundary(slice: &RopeSlice, char_idx: usize) -> usize {
    // Bounds check
    debug_assert!(char_idx <= slice.len_chars());

    // We work with bytes for this, so convert.
    let byte_idx = slice.char_to_byte(char_idx);

    // Get the chunk with our byte index in it.
    let (mut chunk, mut chunk_byte_idx, mut chunk_char_idx, _) = slice.chunk_at_byte(byte_idx);

    // Set up the grapheme cursor.
    let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);

    // Find the previous grapheme cluster boundary.
    loop {
        match gc.prev_boundary(chunk, chunk_byte_idx) {
            Ok(None) => return 0,
            Ok(Some(n)) => {
                let tmp = byte_to_char_idx(chunk, n - chunk_byte_idx);
                return chunk_char_idx + tmp;
            }
            Err(GraphemeIncomplete::PrevChunk) => {
                let (a, b, c, _) = slice.chunk_at_byte(chunk_byte_idx - 1);
                chunk = a;
                chunk_byte_idx = b;
                chunk_char_idx = c;
            }
            Err(GraphemeIncomplete::PreContext(n)) => {
                let ctx_chunk = slice.chunk_at_byte(n - 1).0;
                gc.provide_context(ctx_chunk, n - ctx_chunk.len());
            }
            _ => unreachable!(),
        }
    }
}
```


Overlapping Code:
```
apheme_boundary(slice: &RopeSlice, char_idx: usize) -> usize {
// Bounds check
debug_assert!(char_idx <= slice.len_chars());
// We work with bytes for this, so convert.
let byte_idx = slice.char_to_byte(char_idx);
// Get the chunk with our byte index in it.
let (mut chunk, mut chunk_byte_idx, mut chunk_char_idx, _) = slice.chunk_at_byte(byte_idx);
// Set up the grapheme cursor.
let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);
// Find the previous grapheme cluster boundary.
loop {
match gc.prev_boundary(chunk, chunk_byte_idx) {
Ok(None) => return 0,
Ok(Some(n)) => {
let tmp = byte_to_char_idx(chunk, n - chunk_byte_idx);
return chunk_char_idx + tmp;
}
Err(GraphemeIncomplete::PrevChunk) => {
let (a, b, c, _) = slice.chunk_at_byte(chunk_byte_idx - 1);
chunk = a;
chunk_byte_idx = b;
chunk_char_idx = c;
}
Err(GraphemeIncomplete::PreContext(n)) => {
let ctx_chunk = slice.chunk_at_byte(n - 1).0;
gc.provide_context(ctx_chunk, n - ctx_chunk.len());
}
_ => unreach
```
<Overlap Ratio: 0.9762611275964391>

---

--- 40 --
Question ID: b42923d62f9cdb5f0cdd8dd2b1816d7bdbdb7969_0
Original Code:
```
fn create_tx_since_absolute_epoch(node: &Node, number: u64, index: u64) -> TransactionView {
    let epoch_length = GENESIS_EPOCH_LENGTH;
    let epoch = EpochNumberWithFraction::new(number, index, epoch_length);
    let since = since_from_absolute_epoch_number(epoch);
    let cellbase = node.get_tip_block().transactions()[0].clone();
    node.new_transaction_with_since(cellbase.hash(), since)
}
```


Overlapping Code:
```
lute_epoch(node: &Node, number: u64, index: u64) -> TransactionView {
let epoch_length = GENESIS_EPOCH_LENGTH;
let epoch = EpochNumberWithFraction::new(number, index, epoch_length);
let since = since_from_absolute_epoch_number(epoch);
let cellbase = node.get_tip_block().transactions()[0].clone();
node.new_transaction_with_since(cellbase.hash(), sin
```
<Overlap Ratio: 0.9259259259259259>

---

--- 41 --
Question ID: 2d759d4904794c2914d55296f9c1b68ef997e488_6
Original Code:
```
fn king() {
	log();
    let moves = setup((3,3), &WHITE[5]);

    assert_eq!(moves.len(), 8);

    let mut game = Game::new_empty();
    game.set_at_pos((1, 2), Some(&WHITE[4]));
    game.set_at_pos((0, 0), Some(&BLACK[5]));
    game.set_at_pos((6, 7), Some(&WHITE[5]));

    assert_eq!(game.valid_moves((0,0)).len(), 0);

    let mut found = false;
    game = Game::new();
    game.set_at_pos((5, 0), None);

    for v in game.valid_moves((4, 0)) {
        assert_eq!(v.len(), 1);
    }

    game.set_at_pos((6, 0), None);
    for v in game.valid_moves((4, 0)) {
        if v.len() == 3 {
            found = true;
            break;
        }
    }
    assert!(found);

    found = false;
    game.set_at_pos((3, 0), None);
    game.set_at_pos((2, 0), None);
    game.set_at_pos((6, 0), Some(&WHITE[2]));
    for v in game.valid_moves((4, 0)) {
        assert_eq!(v.len(), 1);
    }

    game.set_at_pos((1, 0), None);
    for v in game.valid_moves((4, 0)) {
        if v.len() == 3 {
            found = true;
            break;
        }
    }
    assert!(found);

    game.set_at_pos((3, 1), None);
    game.set_at_pos((3, 5), Some(&BLACK[4]));
    for v in game.valid_moves((4, 0)) {
        assert_eq!(v.len(), 1);
    }
}
```


Overlapping Code:
```
);
let moves = setup((3,3), &WHITE[5]);
assert_eq!(moves.len(), 8);
let mut game = Game::new_empty();
game.set_at_pos((1, 2), Some(&WHITE[4]));
game.set_at_pos((0, 0), Some(&BLACK[5]));
game.set_at_pos((6, 7), Some(&WHITE[5]));
assert_eq!(game.valid_moves((0,0)).len(), 0);
let mut found = false;
game = Game::new();
game.set_at_pos((5, 0), None);
for v in game.valid_moves((4, 0)) {
assert_eq!(v.len(), 1);
}
game.set_at_pos((6, 0), None);
for v in game.valid_moves((4, 0)) {
if v.len() == 3 {
found = true;
break;
}
}
assert!(found);
found = false;
game.set_at_pos((3, 0), None);
game.set_at_pos((2, 0), None);
game.set_at_pos((6, 0), Some(&WHITE[2]));
for v in game.valid_moves((4, 0)) {
assert_eq!(v.len(), 1);
}
game.set_at_pos((1, 0), None);
for v in game.valid_moves((4, 0)) {
if v.len() == 3 {
found = true;
break;
}
}
assert!(found);
game.set_at_pos((3, 1), None);
game.set_at_pos((3, 5), Some(&BLACK[4]));
for v in game.valid_moves((4, 0)) {
assert_eq!(v.len
```
<Overlap Ratio: 0.9728643216080402>

---

--- 42 --
Question ID: 89e4089c0a7dd1189fd2b5eee7bba650eded0a39_6
Original Code:
```
fn test_update_ts_activity() {
        let (mut conn, _guard) = setup_db();

        let data = vec![
            TsActivity {
                client: 1,
                time: 1,
                channel: 1,
            },
            TsActivity {
                client: 1,
                time: 2,
                channel: 2,
            },
            TsActivity {
                client: 2,
                time: 3,
                channel: 1,
            },
        ];
        let date = NaiveDate::from_ymd(2020, 03, 29);
        update_ts_activity(&mut conn, date, &data).unwrap();

        let res = get_ts_activity_ordered(&mut conn).unwrap();
        for i in 0..res.len() {
            let (r_date, act) = &res[i];
            assert_eq!(*r_date, date);
            assert_eq!(act, &data[i]);
        }

        // now update it
        let data = vec![
            TsActivity {
                client: 1,
                time: 10,
                channel: 1,
            },
            TsActivity {
                client: 2,
                time: 10,
                channel: 1,
            },
        ];
        update_ts_activity(&mut conn, date, &data).unwrap();
        let res = get_ts_activity_ordered(&mut conn).unwrap();
        let expected: Vec<_> = vec![
            TsActivity {
                client: 1,
                time: 11,
                channel: 1,
            },
            TsActivity {
                client: 1,
                time: 2,
                channel: 2,
            },
            TsActivity {
                client: 2,
                time: 13,
                channel: 1,
            },
        ]
        .drain(..)
        .map(|v| (date.clone(), v))
        .collect();
        assert_eq!(expected, res);
    }
```


Overlapping Code:
```
ivity() {
let (mut conn, _guard) = setup_db();
let data = vec![
TsActivity {
client: 1,
time: 1,
channel: 1,
},
TsActivity {
client: 1,
time: 2,
channel: 2,
},
TsActivity {
client: 2,
time: 3,
channel: 1,
},
];
let date = NaiveDate::from_ymd(2020, 03, 29);
update_ts_activity(&mut conn, date, &data).unwrap();
let res = get_ts_activity_ordered(&mut conn).unwrap();
for i in 0..res.len() {
let (r_date, act) = &res[i];
assert_eq!(*r_date, date);
assert_eq!(act, &data[i]);
}
// now update it
let data = vec![
TsActivity {
client: 1,
time: 10,
channel: 1,
},
TsActivity {
client: 2,
time: 10,
channel: 1,
},
];
update_ts_activity(&mut conn, date, &data).unwrap();
let res = get_ts_activity_ordered(&mut conn).unwrap();
let expected: Vec<_> = vec![
TsActivity {
client: 1,
time: 11,
channel: 1,
},
TsActivity {
client: 1,
time: 2,
channel: 2,
},
TsActivity {
client: 2,
time: 13,
channel: 1,
},
]
.drain(..)
.map(|v| (date.clone(), v))
.collect();
asser
```
<Overlap Ratio: 0.9557344064386318>

---

--- 43 --
Question ID: 2c478637fdfd8fa877b4ed05be953f3a34c4a251_0
Original Code:
```
fn decode_png(png_data: &[u8]) -> Box<[u8]> {
    let decoder = png::Decoder::new(png_data);
    let (info, mut reader) = decoder.read_info().unwrap();
    let mut buf = vec![0; info.buffer_size()];
    reader.next_frame(&mut buf).unwrap();
    buf.into_boxed_slice()
}
```


Overlapping Code:
```
g(png_data: &[u8]) -> Box<[u8]> {
let decoder = png::Decoder::new(png_data);
let (info, mut reader) = decoder.read_info().unwrap();
let mut buf = vec![0; info.buffer_size()];
reader.next_frame(&mut buf).unwrap();
buf.into_boxed_slice()
```
<Overlap Ratio: 0.9437751004016064>

---

--- 44 --
Question ID: c384b864cc14b2d84c3295275e9b7deb881dbb21_0
Original Code:
```
fn project_first_column() -> Result<()> {
        let schema = Arc::new(Schema::new(vec![
            Field::new("c1", DataType::Utf8, false),
            Field::new("c2", DataType::UInt32, false),
            Field::new("c3", DataType::Int8, false),
            Field::new("c3", DataType::Int16, false),
            Field::new("c4", DataType::Int32, false),
            Field::new("c5", DataType::Int64, false),
            Field::new("c6", DataType::UInt8, false),
            Field::new("c7", DataType::UInt16, false),
            Field::new("c8", DataType::UInt32, false),
            Field::new("c9", DataType::UInt64, false),
            Field::new("c10", DataType::Float32, false),
            Field::new("c11", DataType::Float64, false),
            Field::new("c12", DataType::Utf8, false),
        ]));

        let partitions = 4;
        let path = create_partitioned_csv("aggregate_test_100.csv", partitions)?;

        let csv = CsvExec::try_new(&path, schema, true, None, 1024)?;

        let projection =
            ProjectionExec::try_new(vec![Arc::new(Column::new(0))], Arc::new(csv))?;

        let mut partition_count = 0;
        let mut row_count = 0;
        for partition in projection.partitions()? {
            partition_count += 1;
            let iterator = partition.execute()?;
            let mut iterator = iterator.lock().unwrap();
            while let Some(batch) = iterator.next()? {
                assert_eq!(1, batch.num_columns());
                row_count += batch.num_rows();
            }
        }
        assert_eq!(partitions, partition_count);
        assert_eq!(100, row_count);

        Ok(())
    }
```


Overlapping Code:
```
umn() -> Result<()> {
let schema = Arc::new(Schema::new(vec![
Field::new("c1", DataType::Utf8, false),
Field::new("c2", DataType::UInt32, false),
Field::new("c3", DataType::Int8, false),
Field::new("c3", DataType::Int16, false),
Field::new("c4", DataType::Int32, false),
Field::new("c5", DataType::Int64, false),
Field::new("c6", DataType::UInt8, false),
Field::new("c7", DataType::UInt16, false),
Field::new("c8", DataType::UInt32, false),
Field::new("c9", DataType::UInt64, false),
Field::new("c10", DataType::Float32, false),
Field::new("c11", DataType::Float64, false),
Field::new("c12", DataType::Utf8, false),
]));
let partitions = 4;
let path = create_partitioned_csv("aggregate_test_100.csv", partitions)?;
let csv = CsvExec::try_new(&path, schema, true, None, 1024)?;
let projection =
ProjectionExec::try_new(vec![Arc::new(Column::new(0))], Arc::new(csv))?;
let mut partition_count = 0;
let mut row_count = 0;
for partition in projection.partitions()? {
partition_count += 1;
let iterator = partition.execute()?;
let mut iterator = iterator.lock().unwrap();
while let Some(batch) = iterator.next()? {
assert_eq!(1, batch.num_columns());
row_count += batch.num_rows();
}
}
assert_eq!(partitions, partition_count);
assert_eq!(100, row_count);

```
<Overlap Ratio: 0.9780907668231612>

---

--- 45 --
Question ID: 001470d48999b54fd5a702510d1753e28c2e3bd4_1
Original Code:
```
fn set_key_from_u256(key: u32, val: U256) {
	let mut full_key = [0u8; 32];
	write_u32(&mut full_key[0..4], key);

	let _ = ext::write(&H256::from(full_key), &val.into());
}
```


Overlapping Code:
```
et_key_from_u256(key: u32, val: U256) {
let mut full_key = [0u8; 32];
write_u32(&mut full_key[0..4], key);
let _ = ext::write(&H256::from(full_key), &
```
<Overlap Ratio: 0.8928571428571429>

---

--- 46 --
Question ID: 1cbfc6d1db5e9a40c6e82b16bc6ebcb958ba15f9_3
Original Code:
```
fn hello_extension_protocol_version() {
            let bytes = rustls_bytes(r_ServerHelloPayload {
                legacy_version: r_ProtocolVersion::TLSv1_2,
                random: r_Random::from_slice(&[0; 32]),
                session_id: r_SessionId::new(&[]),
                cipher_suite: r_CipherSuite::TLS13_AES_128_GCM_SHA256,
                compression_method: r_Compression::Null,
                extensions: vec![r_ServerExtension::SupportedVersions(
                    r_ProtocolVersion::TLSv1_3,
                )],
            });
            let mut dec = Decoder::new(&bytes);
            let payload = ServerHelloPayload::decode(&mut dec).unwrap();

            assert_eq!(
                payload.extensions,
                Extensions::from(arr![ServerExtension::from(ProtocolVersion::TLSv1_3)]),
            );
        }
```


Overlapping Code:
```
 hello_extension_protocol_version() {
let bytes = rustls_bytes(r_ServerHelloPayload {
legacy_version: r_ProtocolVersion::TLSv1_2,
random: r_Random::from_slice(&[0; 32]),
session_id: r_SessionId::new(&[]),
cipher_suite: r_CipherSuite::TLS13_AES_128_GCM_SHA256,
compression_method: r_Compression::Null,
extensions: vec![r_ServerExtension::SupportedVersions(
r_ProtocolVersion::TLSv1_3,
)],
});
let mut dec = Decoder::new(&bytes);
let payload = ServerHelloPayload::decode(&mut dec).unwrap();
assert_eq!(
payload.extensions,
Extensions::from(arr![ServerE
```
<Overlap Ratio: 0.9166666666666666>

---

--- 47 --
Question ID: cd1fef1155dc9f5367ec66296326ca2c1202a43b_0
Original Code:
```
pub fn cached_expand_impl(input: TokenStream) -> TokenStream {
    if let Ok(val) = env::var("IN_DOCKER") {
        if val == "1" {
            println!("Running in Docker, so just returning original input-tokens.");
            return input;
        }
    }

    let _input_str = input.to_string();
    //println!("Input: {:?}", input);

    let mut group_id = "".to_owned();
    let mut exclude_lines_with = "NEVER_MATCHING".to_owned();
    {
        let mut past_token_strings: Vec<String> = Vec::new();
        for token in input.clone() {
            println!("Got token:{token}");
            let token_str = format!("{token}");

            /*if token_str.starts_with("CEID_") && last_token_str.is_some() && last_token_str.unwrap() == "struct" {
                result = token_str["CEID_".len()..].to_string();
                break;
            }*/
            if let Some(token_5_back) = past_token_strings.get((past_token_strings.len() as isize - 5) as usize) {
                if token_5_back == "ce_args" {
                    let mut lines = token_str.split("\n");
                    // example line: id = "access_policies"
                    if let Some(id_line) = lines.find(|a| a.contains("id = ")) {
                        group_id = id_line.split("\"").collect::<Vec<&str>>()[1].to_owned();
                    }
                    // example line: excludeLinesWith = "#[graphql(name"
                    if let Some(exclude_lines_with_0line) = lines.find(|a| a.contains("excludeLinesWith = ")) {
                        exclude_lines_with = exclude_lines_with_0line.split("\"").collect::<Vec<&str>>()[1].to_owned();
                    }
                    break;
                }
            }

            past_token_strings.push(token_str);
            /*if past_token_strings.len() > 3 {
                past_token_strings.pop_front();
            }*/

            // if we've processed 30 tokens, and still haven't reached a ce_args string, give up (it should be at the very top)
            if past_token_strings.len() > 30 {
                break;
            }
        }
    }
    if group_id == "" {
        panic!("Could not cached_expand args. Provide it using pattern: const ce_args: &str = r#\"id = \"<group name here>\"\"#;");
    }
    println!("Found args. @id:{group_id} @excludeLinesWith:{exclude_lines_with}");
    let cache_folder_path = env::current_dir().unwrap().join("target").join("cached_expand").join("expansions");
    let cache_input_path = cache_folder_path.join(group_id.clone() + "_Input");
    let cache_output_path = cache_folder_path.join(group_id.clone() + "_Output");

    //if env::var("FOR_CACHED_EXPAND").is_ok_with(|a| a == "1") {
    //if let Ok(val) = env::var("FOR_CACHED_EXPAND") && val == "1" {
    const SPECIAL_MESSAGE_1: &str = "FOR_CACHED_EXPAND is true, so only adding markers.";
    const SPECIAL_MESSAGE_2: &str = "FOR_RUST_ANALYZER is true, so only adding markers.";
    let only_add_markers = {
        let mut temp = false;
        // if this macro is running as part of the "cargo expand" command (of a parent instance of this macro), then...
        if let Ok(val) = env::var("FOR_CACHED_EXPAND") {
            if val == "1" {
                println!("{}", SPECIAL_MESSAGE_1);
                temp = true;
            }
        }
        // if this macro is running as part of rust-analyzer, then...
        // todo: find alternative (one I didn't hard-code into settings.json)
        if let Ok(val) = env::var("FOR_RUST_ANALYZER") {
            if val == "1" {
                println!("{}", SPECIAL_MESSAGE_2);
                temp = true;
            }
        }
        temp
    };
    if only_add_markers {
        /*let pre_tokens = TokenStream::from(quote! { struct StartMarker {} });*/
        let pre_tokens = TokenStream::from_str(format!("struct StartMarker_{group_id} {{}}").as_str()).unwrap();
        //println!("PreTokens:{}", pre_tokens);
        //let post_tokens = TokenStream::from(quote! { struct EndMarker {} });
        let post_tokens = TokenStream::from_str(format!("struct EndMarker_{group_id} {{}}").as_str()).unwrap();
        return pre_tokens.into_iter()
            .chain(input)
            .chain(post_tokens.into_iter())
            .collect();
    }

    // check for a cache-hit
    if cache_input_path.exists() && fs::read_to_string(cache_input_path.clone()).unwrap() == input.to_string() && cache_output_path.exists() {
        let cached_output = fs::read_to_string(cache_output_path.clone()).unwrap();
        println!("Cache hit! Cached-output length: {}", cached_output.len());
        return TokenStream::from_str(&cached_output).unwrap();
    }

    //println!("Env-vars:{}", env::vars().map(|(var_name, var_value)| format!("{var_name}: {var_value}")).collect::<Vec<String>>().join("\n"));

    let working_dir = env::current_dir().unwrap();
    let working_dir_str = working_dir.as_path().display().to_string();
    println!("Working-dir:{}", working_dir_str);
    
    let mut cmd =
        // todo: fix that the user must call "cargo +nightly build" instead of just "cargo build" (for the initial command to start things off)
        Command::new("cargo")//.arg("+nightly")
        .arg("expand")
        //.arg("::".to_owned() + &struct_id)
        //.arg("::sub1") // temp
        .arg("--target-dir").arg("/tmp/cargo-expand-for-cached-expand")
        .env("FOR_CACHED_EXPAND", "1")
        //.current_dir(working_dir)
        .current_dir(working_dir_str + "/Packages/app-server-rs")
        
        //.output()
        .stdout(Stdio::piped())
        //.stderr(Stdio::piped())
        .spawn()

        .unwrap();

    //String::from_utf8_lossy(&expand_command_output.stderr)
    let mut expanded_code = "".to_owned();
    {
        /*let stderr = cmd.stderr.as_mut().unwrap();
        let stderr_reader = BufReader::new(stderr);
        let stderr_lines = stderr_reader.lines();
        for (i, line) in stderr_lines.enumerate() {
            let line_str = line.unwrap().to_string();
            println!("Err({i}): {line_str}");
        }*/

        let stdout = cmd.stdout.as_mut().unwrap();
        let stdout_reader = BufReader::new(stdout);
        let stdout_lines = stdout_reader.lines();

        let mut start_marker_hit = false;
        let mut end_marker_hit = false;
        for (_i, line) in stdout_lines.enumerate() {
            let line_str = line.unwrap().to_string();
            //println!("Read({i}): {line_str}");

            if line_str.contains(format!("StartMarker_{group_id}").as_str()) {
                start_marker_hit = true;
            }

            if start_marker_hit && !end_marker_hit && line_str != SPECIAL_MESSAGE_1 && line_str != SPECIAL_MESSAGE_2 {
                if line_str.contains(exclude_lines_with.as_str()) {
                    println!("Ignoring line, based on excludeLinesWith setting:{}", line_str);
                } else {
                    //println!("FoundExpanded({i}): {line_str}");
                    expanded_code += &line_str;
                }
            }

            // run this after, so end-marker is still included
            if line_str.contains(format!("EndMarker_{group_id}").as_str()) {
                end_marker_hit = true;
            }
        }
    }

    cmd.wait().unwrap();
        
    //println!("Expanded code:[[[{}]]]", expanded_code);
    println!("Expanded code length:{}", expanded_code.len());
    if expanded_code.is_empty() {
        panic!("Expanded-code is empty! Terminating...");
    }

    println!("Caching input-code and expanded-code to:{}", cache_folder_path.as_path().display().to_string());
    fs::create_dir_all(cache_folder_path).unwrap();
    fs::write(cache_input_path.clone(), input.to_string()).unwrap();
    fs::write(cache_output_path.clone(), expanded_code.clone()).unwrap();
    println!("Writes done! Proofs:[{}, {}]",
        fs::read_to_string(cache_input_path.clone()).unwrap().len(),
        fs::read_to_string(cache_output_path.clone()).unwrap().len());

    return TokenStream::from_str(&expanded_code).unwrap();
}
```


Overlapping Code:
```
ed_expand_impl(input: TokenStream) -> TokenStream {
if let Ok(val) = env::var("IN_DOCKER") {
if val == "1" {
println!("Running in Docker, so just returning original input-tokens.");
return input;
}
}
let _input_str = input.to_string();
//println!("Input: {:?}", input);
let mut group_id = "".to_owned();
let mut exclude_lines_with = "NEVER_MATCHING".to_owned();
{
let mut past_token_strings: Vec<String> = Vec::new();
for token in input.clone() {
println!("Got token:{token}");
let token_str = format!("{token}");
/*if token_str.starts_with("CEID_") && last_token_str.is_some() && last_token_str.unwrap() == "struct" {
result = token_str["CEID_".len()..].to_string();
break;
}*/
if let Some(token_5_back) = past_token_strings.get((past_token_strings.len() as isize - 5) as usize) {
if token_5_back == "ce_args" {
let mut lines = token_str.split("\n");
// example line: id = "access_policies"
if let Some(id_line) = lines.find(|a| a.contains("id = ")) {
group_id = id_line.split("\"").collect::<Vec<&str>>()[1].to_owned();
}
// example line: excludeLinesWith = "#[graphql(name"
if let Some(exclude_lines_with_0line) = lines.find(|a| a.contains("excludeLinesWith = ")) {
exclude_lines_with = exclude_lines_with_0line.split("\"").collect::<Vec<&str>>()[1].to_owned();
}
break;
}
}
past_token_strings.push(token_str);
/*if past_token_strings.len() > 3 {
past_token_strings.pop_front();
}*/
// if we've processed 30 tokens, and still haven't reached a ce_args string, give up (it should be at the very top)
if past_token_strings.len() > 30 {
break;
}
}
}
if group_id == "" {
panic!("Could not cached_expand args. Provide it using pattern: const ce_args: &str = r#\"id = \"<group name here>\"\"#;");
}
println!("Found args. @id:{group_id} @excludeLinesWith:{exclude_lines_with}");
let cache_folder_path = env::current_dir().unwrap().join("target").join("cached_expand").join("expansions");
let cache_input_
```
<Overlap Ratio: 0.9885535900104059>

---

--- 48 --
Question ID: 8c6723109c04419ec61890636bd5c8f173f8934d_6
Original Code:
```
fn output_symbol_is_none_by_default() {
        let ndfa: Ndfa<u32, u32> = Ndfa::new();

        assert!(ndfa.output_symbol_for_state(0) == None);
        assert!(ndfa.output_symbol_for_state(1) == None);
    }
```


Overlapping Code:
```
ne_by_default() {
let ndfa: Ndfa<u32, u32> = Ndfa::new();
assert!(ndfa.output_symbol_for_state(0) == None);
assert!(ndfa.output_symbol_for_state(1) == N
```
<Overlap Ratio: 0.8397790055248618>

---

--- 49 --
Question ID: 97b42a47dea1a408fb0df18381b985264a485878_7
Original Code:
```
pub fn tree_policy(
    current_state : &game_state::GameState,
    visisted_states : &HashSet<game_state::GameState>,
    stats : &HashMap<game_state::GameState, UCTData>
    ) -> TreePolicyResult{
    
    //represents the states we went through to get to the selected node
    //used for backpropogation without an actual tree structure
    let mut path : Vec<game_state::GameState> = Vec::new();

    let mut current_node = current_state.clone();

    loop{

        path.push(current_node);

        let possible_moves = current_node.legal_moves(current_node.player);

        if possible_moves.len() < 1 || victory(current_node.win()){
            //no legal moves or game ends
            return TreePolicyResult::new(path, current_node);
        }
        
        //has every possible move been explored?
        let fully_explored = possible_moves.iter().fold(true, 
            |acc, x| 
            acc && visisted_states.contains(&current_node.place(x))
        );

        //if not, exploration
        if !fully_explored {
            //for a node with number played of 0, ucb1 returns infinity
            //in other words unexplored child nodes are always explored at least once
            let not_explored = possible_moves.into_iter().filter(
                |x| !visisted_states.contains(&current_node.place(x))
                ).collect::<Vec<_>>();
            let random_choice = choose_random(&not_explored);
            let chosen_node = current_node.place(&random_choice);
            path.push(chosen_node);
            let result = TreePolicyResult::new(path, chosen_node);
            return result; 
        }

        //all child nodes have been simulated at least once, so use ucb1 to select best
        else{
            //sort 
            let mut best_move = possible_moves.last().unwrap();
            let mut best_uct = 0f64;
            let total_played = stats.get(&current_node).unwrap().num_plays;
            for possibility in possible_moves.iter(){
                
                //TODO: switch to pattern matching
                let data = stats.get(&current_node.place(&possibility)).unwrap();
                let uct = ucb1(data.wins, data.num_plays as f64, total_played as f64);
                if(uct > best_uct){
                    best_uct = uct;
                    best_move = possibility;
                }
            }
            let chosen_node = current_node.place(&best_move);
            current_node = chosen_node;
        }
    }
}
```


Overlapping Code:
```
_state : &game_state::GameState,
visisted_states : &HashSet<game_state::GameState>,
stats : &HashMap<game_state::GameState, UCTData>
) -> TreePolicyResult{

//represents the states we went through to get to the selected node
//used for backpropogation without an actual tree structure
let mut path : Vec<game_state::GameState> = Vec::new();
let mut current_node = current_state.clone();
loop{
path.push(current_node);
let possible_moves = current_node.legal_moves(current_node.player);
if possible_moves.len() < 1 || victory(current_node.win()){
//no legal moves or game ends
return TreePolicyResult::new(path, current_node);
}

//has every possible move been explored?
let fully_explored = possible_moves.iter().fold(true, 
|acc, x| 
acc && visisted_states.contains(&current_node.place(x))
);
//if not, exploration
if !fully_explored {
//for a node with number played of 0, ucb1 returns infinity
//in other words unexplored child nodes are always explored at least once
let not_explored = possible_moves.into_iter().filter(
|x| !visisted_states.contains(&current_node.place(x))
).collect::<Vec<_>>();
let random_choice = choose_random(&not_explored);
let chosen_node = current_node.place(&random_choice);
path.push(chosen_node);
let result = TreePolicyResult::new(path, chosen_node);
return result; 
}
//all child nodes have been simulated at least once, so use ucb1 to select best
else{
//sort 
let mut best_move = possible_moves.last().unwrap();
let mut best_uct = 0f64;
let total_played = stats.get(&current_node).unwrap().num_plays;
for possibility in possible_moves.iter(){

//TODO: switch to pattern matching
let data = stats.get(&current_node.place(&possibility)).unwrap();
let uct = ucb1(data.wins, data.num_plays as f64, total_played as f64);
if(uct > best_uct){
best_uct = uct;
best_move = possibility;
}
}
let chosen_node = current_node.place(&best_move);
current_node = chosen_node;
}
}

```
<Overlap Ratio: 0.9854771784232366>

---

--- 50 --
Question ID: 0b18c5df7300dd5100bdb673063d5ab9c517417b_0
Original Code:
```
pub fn create_new_ledger(ledger_path: &str, genesis_block: &GenesisBlock) -> Result<Hash> {
    let ticks_per_slot = genesis_block.ticks_per_slot;
    Blocktree::destroy(ledger_path)?;
    genesis_block.write(&ledger_path)?;

    // Fill slot 0 with ticks that link back to the genesis_block to bootstrap the ledger.
    let blocktree = Blocktree::open(ledger_path)?;
    let entries = crate::entry::create_ticks(ticks_per_slot, genesis_block.hash());
    blocktree.write_entries(0, 0, 0, ticks_per_slot, &entries)?;

    Ok(entries.last().unwrap().hash)
}
```


Overlapping Code:
```
is_block: &GenesisBlock) -> Result<Hash> {
let ticks_per_slot = genesis_block.ticks_per_slot;
Blocktree::destroy(ledger_path)?;
genesis_block.write(&ledger_path)?;
// Fill slot 0 with ticks that link back to the genesis_block to bootstrap the ledger.
let blocktree = Blocktree::open(ledger_path)?;
let entries = crate::entry::create_ticks(ticks_per_slot, genesis_block.hash());
blocktree.write_entries(0, 0, 0, ticks_per_slot, &entries)?;
Ok(entries.last().un
```
<Overlap Ratio: 0.8793103448275862>

---

--- 51 --
Question ID: 0d6ffc9b0cc03c08591f656a92233bcf1aca6fea_1
Original Code:
```
fn parse_time_param(time: &str, mult_param: u64) -> Duration {
    let re = Regex::new(r"[0-9]+").unwrap();
    let time_parsed = re.find(time).unwrap();
    Duration::new(time[time_parsed.start()..time_parsed.end()].parse::<u64>().unwrap()*mult_param,0)
}
```


Overlapping Code:
```
am: u64) -> Duration {
let re = Regex::new(r"[0-9]+").unwrap();
let time_parsed = re.find(time).unwrap();
Duration::new(time[time_parsed.start()..time_parsed.end()].parse::<u64>().unwrap()*mult_param,
```
<Overlap Ratio: 0.819672131147541>

---

--- 52 --
Question ID: 83310b584c1263b665f6548706cb87d445c7cd85_0
Original Code:
```
pub fn mutate<'a, T, R>(a: &'a T, rng: &mut R) -> T where 
    T: Visitable<'a>+Copyable,
    R: rand::Rng+Sized
{
    let mut nodes = BucketCollector::new();
    a.visit(&mut nodes);

    let t_nodes = nodes.get_counts().into_iter()
        .filter(|&(_, nc)| nc > 0)
        .map(|(t, _)| t)
        .collect::<Vec<NodeType>>();

    let picked_type = rng.choose(&t_nodes).unwrap();

    match *picked_type {
        NodeType::Program    => mut_program(a, rng.choose(&nodes.programs).unwrap(), rng),
        NodeType::Expression => mut_expression(a, rng.choose(&nodes.expressions).unwrap(), rng),
        NodeType::Condition  => mut_condition(a, rng.choose(&nodes.conditions).unwrap(), rng),
        NodeType::Sensor     => mut_sensor(a, rng.choose(&nodes.sensors).unwrap(), rng),
        NodeType::Command    => mut_command(a, rng.choose(&nodes.commands).unwrap(), rng)
    }
}
```


Overlapping Code:
```
T, R>(a: &'a T, rng: &mut R) -> T where 
T: Visitable<'a>+Copyable,
R: rand::Rng+Sized
{
let mut nodes = BucketCollector::new();
a.visit(&mut nodes);
let t_nodes = nodes.get_counts().into_iter()
.filter(|&(_, nc)| nc > 0)
.map(|(t, _)| t)
.collect::<Vec<NodeType>>();
let picked_type = rng.choose(&t_nodes).unwrap();
match *picked_type {
NodeType::Program => mut_program(a, rng.choose(&nodes.programs).unwrap(), rng),
NodeType::Expression => mut_expression(a, rng.choose(&nodes.expressions).unwrap(), rng),
NodeType::Condition => mut_condition(a, rng.choose(&nodes.conditions).unwrap(), rng),
NodeType::Sensor => mut_sensor(a, rng.choose(&nodes.sensors).unwrap(), rng),
NodeType::Command => mut_command(a, rng.choose(&nodes.commands).unwrap(), rng)
}
```
<Overlap Ratio: 0.974025974025974>

---

--- 53 --
Question ID: 2bd6b627d5874983aee1b3f01a96e738bb064529_12
Original Code:
```
async fn iterate_over_logarray() {
        let store = MemoryBackedStore::new();
        let mut builder = LogArrayFileBuilder::new(store.open_write().await.unwrap(), 5);
        let original = vec![1, 3, 2, 5, 12, 31, 18];
        block_on(async {
            builder.push_all(stream_iter_ok(original.clone())).await?;
            builder.finalize().await?;

            Ok::<_, io::Error>(())
        })
        .unwrap();

        let content = block_on(store.map()).unwrap();

        let logarray = LogArray::parse(content).unwrap();

        let result: Vec<u64> = logarray.iter().collect();

        assert_eq!(original, result);
    }
```


Overlapping Code:
```
 store = MemoryBackedStore::new();
let mut builder = LogArrayFileBuilder::new(store.open_write().await.unwrap(), 5);
let original = vec![1, 3, 2, 5, 12, 31, 18];
block_on(async {
builder.push_all(stream_iter_ok(original.clone())).await?;
builder.finalize().await?;
Ok::<_, io::Error>(())
})
.unwrap();
let content = block_on(store.map()).unwrap();
let logarray = LogArray::parse(content).unwrap();
let result: Vec<u64> = logarray.iter().collect();
asser
```
<Overlap Ratio: 0.8762088974854932>

---

--- 54 --
Question ID: c1e9fc9d50b4c9a0d563639e4f4cf3b1e87754fd_1
Original Code:
```
fn init() {
    let vec = new_empty_vec::<i32>();
    assert_eq!(vec.len(), 0);
    assert_eq!(vec.is_empty(), true);
    assert_eq!(vec.iter().next(), None);
}
```


Overlapping Code:
```
t vec = new_empty_vec::<i32>();
assert_eq!(vec.len(), 0);
assert_eq!(vec.is_empty(), true);
assert_e
```
<Overlap Ratio: 0.6944444444444444>

---

--- 55 --
Question ID: 6294c5752e18359c58f9cb995f0587e746d15dbd_8
Original Code:
```
pub fn commit_at(ptr: Address, size: usize, executable: bool) {
    debug_assert!(ptr.is_page_aligned());
    debug_assert!(mem::is_page_aligned(size));

    use winapi::um::memoryapi::VirtualAlloc;
    use winapi::um::winnt::{MEM_COMMIT, PAGE_EXECUTE_READWRITE, PAGE_READWRITE};

    let prot = if executable {
        PAGE_EXECUTE_READWRITE
    } else {
        PAGE_READWRITE
    };

    let result = unsafe { VirtualAlloc(ptr.to_mut_ptr(), size, MEM_COMMIT, prot) };

    if result != ptr.to_mut_ptr() {
        panic!("VirtualAlloc failed");
    }
}
```


Overlapping Code:
```
t_at(ptr: Address, size: usize, executable: bool) {
debug_assert!(ptr.is_page_aligned());
debug_assert!(mem::is_page_aligned(size));
use winapi::um::memoryapi::VirtualAlloc;
use winapi::um::winnt::{MEM_COMMIT, PAGE_EXECUTE_READWRITE, PAGE_READWRITE};
let prot = if executable {
PAGE_EXECUTE_READWRITE
} else {
PAGE_READWRITE
};
let result = unsafe { VirtualAlloc(ptr.to_mut_ptr(), size, MEM_COMMIT, prot) };
if result != ptr.to_mut_ptr() {
panic!("VirtualAlloc failed")
```
<Overlap Ratio: 0.9650205761316872>

---

--- 56 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_586
Original Code:
```
fn spec_test_587() {
    let original = r##"![Foo]

[foo]: /url "title"
"##;
    let expected = r##"<p><img src="/url" alt="Foo" title="title" /></p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
n spec_test_587() {
let original = r##"![Foo]
[foo]: /url "title"
"##;
let expected = r##"<p><img src="/url" alt="Foo" title="title" /></p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9946524064171123>

---

--- 57 --
Question ID: 6794c0e1c9e16196a23cb7ecb4003ffa8f3dfa95_2
Original Code:
```
fn image_for_address(report: &CrashReport, address: u64) -> Option<&CrashReport_BinaryImage> {
    for image in report.get_binary_images() {
        let base_address = image.get_base_address();
        if base_address <= address && address < (base_address + image.get_size()) {
            return Some(image);
        }
    }

    /* Not found */
    None
}
```


Overlapping Code:
```
age_for_address(report: &CrashReport, address: u64) -> Option<&CrashReport_BinaryImage> {
for image in report.get_binary_images() {
let base_address = image.get_base_address();
if base_address <= address && address < (base_address + image.get_size())
```
<Overlap Ratio: 0.8223684210526315>

---

--- 58 --
Question ID: e24c2a009f438fb0d893e36b3e90c9d67639c771_20
Original Code:
```
pub unsafe fn mailmime_single_fields_init(
    mut single_fields: *mut mailmime_single_fields,
    mut fld_fields: *mut mailmime_fields,
    mut fld_content: *mut mailmime_content,
) {
    let mut cur: *mut clistiter = 0 as *mut clistiter;
    memset(
        single_fields as *mut libc::c_void,
        0i32,
        ::std::mem::size_of::<mailmime_single_fields>() as libc::size_t,
    );
    if !fld_content.is_null() {
        mailmime_content_single_fields_init(single_fields, fld_content);
    }
    if fld_fields.is_null() {
        return;
    }
    cur = (*(*fld_fields).fld_list).first;
    while !cur.is_null() {
        let mut field: *mut mailmime_field = 0 as *mut mailmime_field;
        field = (if !cur.is_null() {
            (*cur).data
        } else {
            0 as *mut libc::c_void
        }) as *mut mailmime_field;
        match (*field).fld_type {
            1 => {
                mailmime_content_single_fields_init(single_fields, (*field).fld_data.fld_content);
            }
            2 => (*single_fields).fld_encoding = (*field).fld_data.fld_encoding,
            3 => (*single_fields).fld_id = (*field).fld_data.fld_id,
            4 => (*single_fields).fld_description = (*field).fld_data.fld_description,
            5 => (*single_fields).fld_version = (*field).fld_data.fld_version,
            6 => {
                mailmime_disposition_single_fields_init(
                    single_fields,
                    (*field).fld_data.fld_disposition,
                );
            }
            7 => (*single_fields).fld_language = (*field).fld_data.fld_language,
            8 => (*single_fields).fld_location = (*field).fld_data.fld_location,
            _ => {}
        }
        cur = if !cur.is_null() {
            (*cur).next
        } else {
            0 as *mut clistcell
        }
    }
}
```


Overlapping Code:
```
ime_single_fields_init(
mut single_fields: *mut mailmime_single_fields,
mut fld_fields: *mut mailmime_fields,
mut fld_content: *mut mailmime_content,
) {
let mut cur: *mut clistiter = 0 as *mut clistiter;
memset(
single_fields as *mut libc::c_void,
0i32,
::std::mem::size_of::<mailmime_single_fields>() as libc::size_t,
);
if !fld_content.is_null() {
mailmime_content_single_fields_init(single_fields, fld_content);
}
if fld_fields.is_null() {
return;
}
cur = (*(*fld_fields).fld_list).first;
while !cur.is_null() {
let mut field: *mut mailmime_field = 0 as *mut mailmime_field;
field = (if !cur.is_null() {
(*cur).data
} else {
0 as *mut libc::c_void
}) as *mut mailmime_field;
match (*field).fld_type {
1 => {
mailmime_content_single_fields_init(single_fields, (*field).fld_data.fld_content);
}
2 => (*single_fields).fld_encoding = (*field).fld_data.fld_encoding,
3 => (*single_fields).fld_id = (*field).fld_data.fld_id,
4 => (*single_fields).fld_description = (*field).fld_data.fld_description,
5 => (*single_fields).fld_version = (*field).fld_data.fld_version,
6 => {
mailmime_disposition_single_fields_init(
single_fields,
(*field).fld_data.fld_disposition,
);
}
7 => (*single_fields).fld_language = (*field).fld_data.fld_language,
8 => (*single_fields).fld_location = (*field).fld_data.fld_location,
_ => {}
}
cur = if !cur.is_null() {
(*cur).next
} else {
0 as *mut clistcell
}
}

```
<Overlap Ratio: 0.9857853589196873>

---

--- 59 --
Question ID: c1326ad899b048ecdd81838676f8b0657335b588_8
Original Code:
```
fn object_identifier() {
        use core::types::ObjectIdentifier;

        let just_root: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![1, 2]).unwrap()).unwrap();
        let itu: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![2, 999, 3]).unwrap()).unwrap();
        let rsa: Vec<u8> =
            to_vec(&ObjectIdentifier::new(vec![1, 2, 840, 113549]).unwrap()).unwrap();

        assert_eq!(&[0x6, 0x1, 0x2a][..], &*just_root);
        assert_eq!(&[0x6, 0x3, 0x88, 0x37, 0x03][..], &*itu);
        assert_eq!(&[0x6, 0x6, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d][..], &*rsa);
    }
```


Overlapping Code:
```
es::ObjectIdentifier;
let just_root: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![1, 2]).unwrap()).unwrap();
let itu: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![2, 999, 3]).unwrap()).unwrap();
let rsa: Vec<u8> =
to_vec(&ObjectIdentifier::new(vec![1, 2, 840, 113549]).unwrap()).unwrap();
assert_eq!(&[0x6, 0x1, 0x2a][..], &*just_root);
assert_eq!(&[0x6, 0x3, 0x88, 0x37, 0x03][..], &*itu);
assert_eq!(&[0x6, 0x6, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d][
```
<Overlap Ratio: 0.896414342629482>

---

--- 60 --
Question ID: c344fa3db7b65c0e0ee11fb74ac3c1959837b23b_0
Original Code:
```
fn key_setup(key : &[u8], subkeys : &mut[u32; 100]) {
    let mut full_key : [u8; 32] = [0; 32];
    if key.len() < 32 {
        copy_memory(&key, &mut full_key[0..key.len()]);
        full_key[key.len()] = 0x01;
    } else {
        copy_memory(&key[0..32], &mut full_key[0..32]);
    }

    let mut w0 = read_u32_le(&full_key[0..4]);
    let mut w1 = read_u32_le(&full_key[4..8]);
    let mut w2 = read_u32_le(&full_key[8..12]);
    let mut w3 = read_u32_le(&full_key[12..16]);
    let mut w4 = read_u32_le(&full_key[16..20]);
    let mut w5 = read_u32_le(&full_key[20..24]);
    let mut w6 = read_u32_le(&full_key[24..28]);
    let mut w7 = read_u32_le(&full_key[28..32]);
    let mut r0 : u32;
    let mut r1 : u32;
    let mut r2 : u32;
    let mut r3 : u32;
    let mut r4 : u32;
    let mut tt : u32;
    let mut i = 0;

    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (0));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (0 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (0 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (0 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r0;
    r0 |= r3;
    r3 ^= r1;
    r1 &= r4;
    r4 ^= r2;
    r2 ^= r3;
    r3 &= r0;
    r4 |= r1;
    r3 ^= r4;
    r0 ^= r1;
    r4 &= r0;
    r1 ^= r3;
    r4 ^= r2;
    r1 |= r0;
    r1 ^= r2;
    r0 ^= r3;
    r2 = r1;
    r1 |= r3;
    r1 ^= r0;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (4));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (4 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (4 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (4 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r4 = r0;
    r0 &= r2;
    r0 ^= r3;
    r2 ^= r1;
    r2 ^= r0;
    r3 |= r4;
    r3 ^= r1;
    r4 ^= r2;
    r1 = r3;
    r3 |= r4;
    r3 ^= r0;
    r0 &= r1;
    r4 ^= r0;
    r1 ^= r3;
    r1 ^= r4;
    r4 = !r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (8));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (8 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (8 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (8 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 = !r0;
    r2 = !r2;
    r4 = r0;
    r0 &= r1;
    r2 ^= r0;
    r0 |= r3;
    r3 ^= r2;
    r1 ^= r0;
    r0 ^= r4;
    r4 |= r1;
    r1 ^= r3;
    r2 |= r0;
    r2 &= r4;
    r0 ^= r1;
    r1 &= r2;
    r1 ^= r0;
    r0 &= r2;
    r0 ^= r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (12));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (12 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (12 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (12 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r4 ^= r2;
    r1 ^= r0;
    r0 |= r3;
    r0 ^= r4;
    r4 ^= r3;
    r3 ^= r2;
    r2 |= r1;
    r2 ^= r4;
    r4 = !r4;
    r4 |= r1;
    r1 ^= r3;
    r1 ^= r4;
    r3 |= r0;
    r1 ^= r3;
    r4 ^= r3;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (16));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (16 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (16 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (16 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r1;
    r1 |= r2;
    r1 ^= r3;
    r4 ^= r2;
    r2 ^= r1;
    r3 |= r4;
    r3 &= r0;
    r4 ^= r2;
    r3 ^= r1;
    r1 |= r4;
    r1 ^= r0;
    r0 |= r4;
    r0 ^= r2;
    r1 ^= r4;
    r2 ^= r1;
    r1 &= r0;
    r1 ^= r4;
    r2 = !r2;
    r2 |= r0;
    r4 ^= r2;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (20));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (20 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (20 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (20 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r2 = !r2;
    r4 = r3;
    r3 &= r0;
    r0 ^= r4;
    r3 ^= r2;
    r2 |= r4;
    r1 ^= r3;
    r2 ^= r0;
    r0 |= r1;
    r2 ^= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r4 ^= r3;
    r4 ^= r0;
    r3 = !r3;
    r2 &= r4;
    r2 ^= r3;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (24));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (24 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (24 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (24 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 ^= r1;
    r1 ^= r3;
    r3 = !r3;
    r4 = r1;
    r1 &= r0;
    r2 ^= r3;
    r1 ^= r2;
    r2 |= r4;
    r4 ^= r3;
    r3 &= r1;
    r3 ^= r0;
    r4 ^= r1;
    r4 ^= r2;
    r2 ^= r0;
    r0 &= r3;
    r2 = !r2;
    r0 ^= r4;
    r4 |= r3;
    r2 ^= r4;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (28));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (28 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (28 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (28 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r1 ^= r3;
    r3 = !r3;
    r2 ^= r3;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r1 ^= r2;
    r4 ^= r3;
    r0 ^= r4;
    r2 &= r4;
    r2 ^= r0;
    r0 &= r1;
    r3 ^= r0;
    r4 |= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r2 &= r3;
    r0 = !r0;
    r4 ^= r2;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (32));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (32 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (32 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (32 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r0;
    r0 |= r3;
    r3 ^= r1;
    r1 &= r4;
    r4 ^= r2;
    r2 ^= r3;
    r3 &= r0;
    r4 |= r1;
    r3 ^= r4;
    r0 ^= r1;
    r4 &= r0;
    r1 ^= r3;
    r4 ^= r2;
    r1 |= r0;
    r1 ^= r2;
    r0 ^= r3;
    r2 = r1;
    r1 |= r3;
    r1 ^= r0;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (36));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (36 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (36 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (36 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r4 = r0;
    r0 &= r2;
    r0 ^= r3;
    r2 ^= r1;
    r2 ^= r0;
    r3 |= r4;
    r3 ^= r1;
    r4 ^= r2;
    r1 = r3;
    r3 |= r4;
    r3 ^= r0;
    r0 &= r1;
    r4 ^= r0;
    r1 ^= r3;
    r1 ^= r4;
    r4 = !r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (40));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (40 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (40 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (40 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 = !r0;
    r2 = !r2;
    r4 = r0;
    r0 &= r1;
    r2 ^= r0;
    r0 |= r3;
    r3 ^= r2;
    r1 ^= r0;
    r0 ^= r4;
    r4 |= r1;
    r1 ^= r3;
    r2 |= r0;
    r2 &= r4;
    r0 ^= r1;
    r1 &= r2;
    r1 ^= r0;
    r0 &= r2;
    r0 ^= r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (44));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (44 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (44 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (44 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r4 ^= r2;
    r1 ^= r0;
    r0 |= r3;
    r0 ^= r4;
    r4 ^= r3;
    r3 ^= r2;
    r2 |= r1;
    r2 ^= r4;
    r4 = !r4;
    r4 |= r1;
    r1 ^= r3;
    r1 ^= r4;
    r3 |= r0;
    r1 ^= r3;
    r4 ^= r3;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (48));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (48 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (48 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (48 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r1;
    r1 |= r2;
    r1 ^= r3;
    r4 ^= r2;
    r2 ^= r1;
    r3 |= r4;
    r3 &= r0;
    r4 ^= r2;
    r3 ^= r1;
    r1 |= r4;
    r1 ^= r0;
    r0 |= r4;
    r0 ^= r2;
    r1 ^= r4;
    r2 ^= r1;
    r1 &= r0;
    r1 ^= r4;
    r2 = !r2;
    r2 |= r0;
    r4 ^= r2;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (52));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (52 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (52 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (52 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r2 = !r2;
    r4 = r3;
    r3 &= r0;
    r0 ^= r4;
    r3 ^= r2;
    r2 |= r4;
    r1 ^= r3;
    r2 ^= r0;
    r0 |= r1;
    r2 ^= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r4 ^= r3;
    r4 ^= r0;
    r3 = !r3;
    r2 &= r4;
    r2 ^= r3;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (56));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (56 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (56 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (56 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 ^= r1;
    r1 ^= r3;
    r3 = !r3;
    r4 = r1;
    r1 &= r0;
    r2 ^= r3;
    r1 ^= r2;
    r2 |= r4;
    r4 ^= r3;
    r3 &= r1;
    r3 ^= r0;
    r4 ^= r1;
    r4 ^= r2;
    r2 ^= r0;
    r0 &= r3;
    r2 = !r2;
    r0 ^= r4;
    r4 |= r3;
    r2 ^= r4;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (60));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (60 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (60 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (60 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r1 ^= r3;
    r3 = !r3;
    r2 ^= r3;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r1 ^= r2;
    r4 ^= r3;
    r0 ^= r4;
    r2 &= r4;
    r2 ^= r0;
    r0 &= r1;
    r3 ^= r0;
    r4 |= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r2 &= r3;
    r0 = !r0;
    r4 ^= r2;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (64));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (64 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (64 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (64 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r0;
    r0 |= r3;
    r3 ^= r1;
    r1 &= r4;
    r4 ^= r2;
    r2 ^= r3;
    r3 &= r0;
    r4 |= r1;
    r3 ^= r4;
    r0 ^= r1;
    r4 &= r0;
    r1 ^= r3;
    r4 ^= r2;
    r1 |= r0;
    r1 ^= r2;
    r0 ^= r3;
    r2 = r1;
    r1 |= r3;
    r1 ^= r0;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (68));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (68 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (68 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (68 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r4 = r0;
    r0 &= r2;
    r0 ^= r3;
    r2 ^= r1;
    r2 ^= r0;
    r3 |= r4;
    r3 ^= r1;
    r4 ^= r2;
    r1 = r3;
    r3 |= r4;
    r3 ^= r0;
    r0 &= r1;
    r4 ^= r0;
    r1 ^= r3;
    r1 ^= r4;
    r4 = !r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (72));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (72 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (72 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (72 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 = !r0;
    r2 = !r2;
    r4 = r0;
    r0 &= r1;
    r2 ^= r0;
    r0 |= r3;
    r3 ^= r2;
    r1 ^= r0;
    r0 ^= r4;
    r4 |= r1;
    r1 ^= r3;
    r2 |= r0;
    r2 &= r4;
    r0 ^= r1;
    r1 &= r2;
    r1 ^= r0;
    r0 &= r2;
    r0 ^= r4;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (76));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (76 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (76 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (76 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r4 ^= r2;
    r1 ^= r0;
    r0 |= r3;
    r0 ^= r4;
    r4 ^= r3;
    r3 ^= r2;
    r2 |= r1;
    r2 ^= r4;
    r4 = !r4;
    r4 |= r1;
    r1 ^= r3;
    r1 ^= r4;
    r3 |= r0;
    r1 ^= r3;
    r4 ^= r3;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (80));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (80 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (80 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (80 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r1;
    r1 |= r2;
    r1 ^= r3;
    r4 ^= r2;
    r2 ^= r1;
    r3 |= r4;
    r3 &= r0;
    r4 ^= r2;
    r3 ^= r1;
    r1 |= r4;
    r1 ^= r0;
    r0 |= r4;
    r0 ^= r2;
    r1 ^= r4;
    r2 ^= r1;
    r1 &= r0;
    r1 ^= r4;
    r2 = !r2;
    r2 |= r0;
    r4 ^= r2;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r0; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (84));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (84 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (84 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (84 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r2 = !r2;
    r4 = r3;
    r3 &= r0;
    r0 ^= r4;
    r3 ^= r2;
    r2 |= r4;
    r1 ^= r3;
    r2 ^= r0;
    r0 |= r1;
    r2 ^= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r4 ^= r3;
    r4 ^= r0;
    r3 = !r3;
    r2 &= r4;
    r2 ^= r3;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (88));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (88 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (88 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (88 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r0 ^= r1;
    r1 ^= r3;
    r3 = !r3;
    r4 = r1;
    r1 &= r0;
    r2 ^= r3;
    r1 ^= r2;
    r2 |= r4;
    r4 ^= r3;
    r3 &= r1;
    r3 ^= r0;
    r4 ^= r1;
    r4 ^= r2;
    r2 ^= r0;
    r0 &= r3;
    r2 = !r2;
    r0 ^= r4;
    r4 |= r3;
    r2 ^= r4;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r2; i+=1;
    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (92));
    w4 = tt.rotate_left(11);
    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (92 + 1));
    w5 = tt.rotate_left(11);
    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (92 + 2));
    w6 = tt.rotate_left(11);
    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (92 + 3));
    w7 = tt.rotate_left(11);
    r0 = w4;
    r1 = w5;
    r2 = w6;
    r3 = w7;
    r1 ^= r3;
    r3 = !r3;
    r2 ^= r3;
    r3 ^= r0;
    r4 = r1;
    r1 &= r3;
    r1 ^= r2;
    r4 ^= r3;
    r0 ^= r4;
    r2 &= r4;
    r2 ^= r0;
    r0 &= r1;
    r3 ^= r0;
    r4 |= r1;
    r4 ^= r0;
    r0 |= r3;
    r0 ^= r2;
    r2 &= r3;
    r0 = !r0;
    r4 ^= r2;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r4; i+=1;
    subkeys[i] = r0; i+=1;
    subkeys[i] = r3; i+=1;
    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (96));
    w0 = tt.rotate_left(11);
    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (96 + 1));
    w1 = tt.rotate_left(11);
    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (96 + 2));
    w2 = tt.rotate_left(11);
    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (96 + 3));
    w3 = tt.rotate_left(11);
    r0 = w0;
    r1 = w1;
    r2 = w2;
    r3 = w3;
    r4 = r0;
    r0 |= r3;
    r3 ^= r1;
    r1 &= r4;
    r4 ^= r2;
    r2 ^= r3;
    r3 &= r0;
    r4 |= r1;
    r3 ^= r4;
    r0 ^= r1;
    r4 &= r0;
    r1 ^= r3;
    r4 ^= r2;
    r1 |= r0;
    r1 ^= r2;
    r0 ^= r3;
    r2 = r1;
    r1 |= r3;
    r1 ^= r0;
    subkeys[i] = r1; i+=1;
    subkeys[i] = r2; i+=1;
    subkeys[i] = r3; i+=1;
    subkeys[i] = r4;
}
```


Overlapping Code:
```
y_setup(key : &[u8], subkeys : &mut[u32; 100]) {
let mut full_key : [u8; 32] = [0; 32];
if key.len() < 32 {
copy_memory(&key, &mut full_key[0..key.len()]);
full_key[key.len()] = 0x01;
} else {
copy_memory(&key[0..32], &mut full_key[0..32]);
}
let mut w0 = read_u32_le(&full_key[0..4]);
let mut w1 = read_u32_le(&full_key[4..8]);
let mut w2 = read_u32_le(&full_key[8..12]);
let mut w3 = read_u32_le(&full_key[12..16]);
let mut w4 = read_u32_le(&full_key[16..20]);
let mut w5 = read_u32_le(&full_key[20..24]);
let mut w6 = read_u32_le(&full_key[24..28]);
let mut w7 = read_u32_le(&full_key[28..32]);
let mut r0 : u32;
let mut r1 : u32;
let mut r2 : u32;
let mut r3 : u32;
let mut r4 : u32;
let mut tt : u32;
let mut i = 0;
tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (0));
w0 = tt.rotate_left(11);
tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (0 + 1));
w1 = tt.rotate_left(11);
tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (0 + 2));
w2 = tt.rotate_left(11);
tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (0 + 3));
w3 = tt.rotate_left(11);
r0 = w0;
r1 = w1;
r2 = w2;
r3 = w3;
r4 = r0;
r0 |= r3;
r3 ^= r1;
r1 &= r4;
r4 ^= r2;
r2 ^= r3;
r3 &= r0;
r4 |= r1;
r3 ^= r4;
r0 ^= r1;
r4 &= r0;
r1 ^= r3;
r4 ^= r2;
r1 |= r0;
r1 ^= r2;
r0 ^= r3;
r2 = r1;
r1 |= r3;
r1 ^= r0;
subkeys[i] = r1; i+=1;
subkeys[i] = r2; i+=1;
subkeys[i] = r3; i+=1;
subkeys[i] = r4; i+=1;
tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (4));
w4 = tt.rotate_left(11);
tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (4 + 1));
w5 = tt.rotate_left(11);
tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (4 + 2));
w6 = tt.rotate_left(11);
tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (4 + 3));
w7 = tt.rotate_left(11);
r0 = w4;
r1 = w5;
r2 = w6;
r3 = w7;
r4 = r0;
r0 &= r2;
r0 ^= r3;
r2 ^= r1;
r2 ^= r0;
r3 |= r4;
r3 ^= r1;
r4 ^= r2;
r1 = r3;
r3 |= r4;
r3 ^= r0;
r0 &= r1;
r4 ^= r0;
r1 ^= r3;
r1 ^= r4;
r4 = !r4;
subkeys[i] = r2; i+=1;
subkeys[i] = r3; i+=1;
subkeys[i] = r1; i+=1;
subkeys[i] = r4; i+=1;
tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (8));
w0 = tt.rotate_left(11);
tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (8 + 1));
w1 = tt.rotate_left(11);
tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ 
```
<Overlap Ratio: 0.9933460076045627>

---

--- 61 --
Question ID: 5d810dfc3fb38aa1d745632ba2beb5ec1334ab6b_5
Original Code:
```
fn callsite_disabled_includes_directive_field_no_value() {
        let filter = EnvFilter::from("app[mySpan{field}]=debug");
        let store = Store::with_capacity(1);
        let ctx = Context::new(&store, &NewRecorder);
        let meta = Metadata::new(
            "mySpan",
            "app",
            Level::TRACE,
            None,
            None,
            None,
            FieldSet::new(&["field=\"value\""], identify_callsite!(&Cs)),
            Kind::SPAN,
        );

        let interest = filter.callsite_enabled(&meta, &ctx);
        assert!(interest.is_always());
    }
```


Overlapping Code:
```
udes_directive_field_no_value() {
let filter = EnvFilter::from("app[mySpan{field}]=debug");
let store = Store::with_capacity(1);
let ctx = Context::new(&store, &NewRecorder);
let meta = Metadata::new(
"mySpan",
"app",
Level::TRACE,
None,
None,
None,
FieldSet::new(&["field=\"value\""], identify_callsite!(&Cs)),
Kind::SPAN,
);
let interest = filter.callsite_enabled(&meta, &ctx);
assert!(interest.is_always(
```
<Overlap Ratio: 0.931350114416476>

---

--- 62 --
Question ID: e77b4e98187704a1639d9a1b15181777a2dc337b_7
Original Code:
```
fn bit_hl_is_zero() {
        let mut mem: Memory = Memory::new();
        let addr = 1;
        mem.write_byte(addr, 0b10);
        let mut cpu: CPU = CPU::new(&mut mem);
        cpu.registers.write_16b(&Register16bits::HL, addr);

        bit_hl(&mut cpu, 2);

        assert_eq!(cpu.registers.read_z_flag(), true);
        assert_eq!(cpu.registers.read_s_flag(), false);
        assert_eq!(cpu.registers.read_hc_flag(), true);
        assert_eq!(cpu.registers.read_c_flag(), false);
    }
```


Overlapping Code:
```
) {
let mut mem: Memory = Memory::new();
let addr = 1;
mem.write_byte(addr, 0b10);
let mut cpu: CPU = CPU::new(&mut mem);
cpu.registers.write_16b(&Register16bits::HL, addr);
bit_hl(&mut cpu, 2);
assert_eq!(cpu.registers.read_z_flag(), true);
assert_eq!(cpu.registers.read_s_flag(), false);
assert_eq!(cpu.registers.read_hc_flag(), true);
assert_eq!(cpu.registers.read_c_flag(), false);
}
```
<Overlap Ratio: 0.9555555555555556>

---

--- 63 --
Question ID: 9497e53cee4b782f8881996dd18888c313d8c29b_13
Original Code:
```
pub extern "C" fn vmovd_freg_mem(buf: &mut Assembler, dst: XMMRegister, src: Mem) {
    emit_vex_prefixfm(buf,
                      dst,
                      XMM0,
                      unsafe { mem::transmute(src) },
                      VectorLength::kL128,
                      SIMDPrefix::k0x66,
                      LeadingOpcode::k0F,
                      VexW::W0);
    buf.emit(0x6e);
    emit_sse_mem_f(buf, dst, src);
}
```


Overlapping Code:
```
_freg_mem(buf: &mut Assembler, dst: XMMRegister, src: Mem) {
emit_vex_prefixfm(buf,
dst,
XMM0,
unsafe { mem::transmute(src) },
VectorLength::kL128,
SIMDPrefix::k0x66,
LeadingOpcode::k0F,
VexW::W0);
buf.emit(0x6e);
emit
```
<Overlap Ratio: 0.8104089219330854>

---

--- 64 --
Question ID: 443cd06dadc9a483fa457e12f92c295f60d92484_15
Original Code:
```
fn test_bitand() {
        let a = BooleanBitfield::from_bytes(&vec![2, 8, 1][..]);
        let b = BooleanBitfield::from_bytes(&vec![4, 8, 16][..]);
        let c = BooleanBitfield::from_bytes(&vec![6, 8, 17][..]);
        assert_eq!(c, a & b);
    }
```


Overlapping Code:
```
a = BooleanBitfield::from_bytes(&vec![2, 8, 1][..]);
let b = BooleanBitfield::from_bytes(&vec![4, 8, 16][..]);
let c = BooleanBitfield::from_bytes(&vec![6, 8, 17][
```
<Overlap Ratio: 0.7581395348837209>

---

--- 65 --
Question ID: 3db6c68cfd3edc063954f520f11b22883d49e17c_5
Original Code:
```
fn dotted_field_name() {
    let (collector, handle) = collector::mock()
        .event(
            event::mock().with_fields(
                field::mock("foo.bar")
                    .with_value(&true)
                    .and(field::mock("foo.baz").with_value(&false))
                    .only(),
            ),
        )
        .done()
        .run_with_handle();
    with_default(collector, || {
        tracing::event!(Level::INFO, foo.bar = true, foo.baz = false);
    });

    handle.assert_finished();
}
```


Overlapping Code:
```
dotted_field_name() {
let (collector, handle) = collector::mock()
.event(
event::mock().with_fields(
field::mock("foo.bar")
.with_value(&true)
.and(field::mock("foo.baz").with_value(&false))
.only(),
),
)
.done()
.run_with_handle();
with_default(collector, || {
tracing::event!(Level::INFO, foo.bar = true, foo.baz = false);
});
handle.assert_finishe
```
<Overlap Ratio: 0.9749303621169917>

---

--- 66 --
Question ID: e1b0338243deafb7b412b723e51281aaed1afe82_9
Original Code:
```
unsafe extern "C" fn xwayland_surface_destroy(mut xsurface:
                                                  *mut wlr_xwayland_surface) {
    xsurface_unmap(xsurface);
    wlr_signal_emit_safe(&mut (*xsurface).events.destroy,
                         xsurface as *mut libc::c_void);
    if xsurface == (*(*xsurface).xwm).focus_surface {
        xwm_surface_activate((*xsurface).xwm, 0 as *mut wlr_xwayland_surface);
    }
    wl_list_remove(&mut (*xsurface).link);
    wl_list_remove(&mut (*xsurface).parent_link);
    let mut child: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;
    let mut next: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;
    child =
        ((*xsurface).children.next as *mut libc::c_char).offset(-144) as
            *mut wlr_xwayland_surface;
    next =
        ((*child).parent_link.next as *mut libc::c_char).offset(-144) as
            *mut wlr_xwayland_surface;
    while &mut (*child).parent_link as *mut wl_list !=
              &mut (*xsurface).children as *mut wl_list {
        wl_list_remove(&mut (*child).parent_link);
        wl_list_init(&mut (*child).parent_link);
        (*child).parent = 0 as *mut wlr_xwayland_surface;
        child = next;
        next =
            ((*child).parent_link.next as *mut libc::c_char).offset(-144) as
                *mut wlr_xwayland_surface
    }
    if (*xsurface).surface_id != 0 {
        wl_list_remove(&mut (*xsurface).unpaired_link);
    }
    if !(*xsurface).surface.is_null() {
        wl_list_remove(&mut (*xsurface).surface_destroy.link);
        (*(*xsurface).surface).role_data = 0 as *mut libc::c_void
    }
    wl_event_source_remove((*xsurface).ping_timer);
    free((*xsurface).title as *mut libc::c_void);
    free((*xsurface).class as *mut libc::c_void);
    free((*xsurface).instance as *mut libc::c_void);
    free((*xsurface).role as *mut libc::c_void);
    free((*xsurface).window_type as *mut libc::c_void);
    free((*xsurface).protocols as *mut libc::c_void);
    free((*xsurface).hints as *mut libc::c_void);
    free((*xsurface).size_hints as *mut libc::c_void);
    free(xsurface as *mut libc::c_void);
}
```


Overlapping Code:
```
e extern "C" fn xwayland_surface_destroy(mut xsurface:
*mut wlr_xwayland_surface) {
xsurface_unmap(xsurface);
wlr_signal_emit_safe(&mut (*xsurface).events.destroy,
xsurface as *mut libc::c_void);
if xsurface == (*(*xsurface).xwm).focus_surface {
xwm_surface_activate((*xsurface).xwm, 0 as *mut wlr_xwayland_surface);
}
wl_list_remove(&mut (*xsurface).link);
wl_list_remove(&mut (*xsurface).parent_link);
let mut child: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;
let mut next: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;
child =
((*xsurface).children.next as *mut libc::c_char).offset(-144) as
*mut wlr_xwayland_surface;
next =
((*child).parent_link.next as *mut libc::c_char).offset(-144) as
*mut wlr_xwayland_surface;
while &mut (*child).parent_link as *mut wl_list !=
&mut (*xsurface).children as *mut wl_list {
wl_list_remove(&mut (*child).parent_link);
wl_list_init(&mut (*child).parent_link);
(*child).parent = 0 as *mut wlr_xwayland_surface;
child = next;
next =
((*child).parent_link.next as *mut libc::c_char).offset(-144) as
*mut wlr_xwayland_surface
}
if (*xsurface).surface_id != 0 {
wl_list_remove(&mut (*xsurface).unpaired_link);
}
if !(*xsurface).surface.is_null() {
wl_list_remove(&mut (*xsurface).surface_destroy.link);
(*(*xsurface).surface).role_data = 0 as *mut libc::c_void
}
wl_event_source_remove((*xsurface).ping_timer);
free((*xsurface).title as *mut libc::c_void);
free((*xsurface).class as *mut libc::c_void);
free((*xsurface).instance as *mut libc::c_void);
free((*xsurface).role as *mut libc::c_void);
free((*xsurface).window_type as *mut libc::c_void);
free((*xsurface).protocols as *mut libc::c_void);
free((*xsurface).hints as *mut libc::c_void);
free((*xsurface).size_hints as *mut libc::c_void);
free(xsurface as *mut libc::c_void);
}
```
<Overlap Ratio: 0.997229916897507>

---

--- 67 --
Question ID: 983199c8fd73bfa4646d6f830a2d2bf49d343f56_1
Original Code:
```
fn prepare_integration_test(code: &str, filename: &str) -> (Connection, StoppableHandle<()>) {
    let (server, client) = Connection::memory();

    // Manually handle LSP communications here. This is needed in order to not wait
    // indefinetely for a message to be able to exit as soon as the test is finished
    // and the thread is stopped.
    let h = spawn(move |stopped| {
        let mut app = App { files: HashMap::new(), conn: server };

        loop {
            if let Ok(msg) = app.conn.receiver.recv_timeout(Duration::from_millis(100)) {
                match msg {
                    Message::Request(req) => app.handle_request(req),
                    Message::Notification(notification) => {
                        let _ = app.handle_notification(notification);
                    }
                    Message::Response(_) => (),
                }
            }
            if stopped.get() {
                break;
            }
        }
    });

    let open = Notification {
        method: String::from("textDocument/didOpen"),
        params: json!({
            "textDocument": { "uri": filename, "text": code, "version": 1, "languageId": "nix" }
        })
    };
    client.sender.send(open.into()).expect("Cannot send didOpen!");

    (client, h)
}
```


Overlapping Code:
```
filename: &str) -> (Connection, StoppableHandle<()>) {
let (server, client) = Connection::memory();
// Manually handle LSP communications here. This is needed in order to not wait
// indefinetely for a message to be able to exit as soon as the test is finished
// and the thread is stopped.
let h = spawn(move |stopped| {
let mut app = App { files: HashMap::new(), conn: server };
loop {
if let Ok(msg) = app.conn.receiver.recv_timeout(Duration::from_millis(100)) {
match msg {
Message::Request(req) => app.handle_request(req),
Message::Notification(notification) => {
let _ = app.handle_notification(notification);
}
Message::Response(_) => (),
}
}
if stopped.get() {
break;
}
}
});
let open = Notification {
method: String::from("textDocument/didOpen"),
params: json!({
"textDocument": { "uri": filename, "text": code, "version": 1, "languageId": "nix" }
})
};
client.sender.send(open.into()).expec
```
<Overlap Ratio: 0.9183673469387755>

---

--- 68 --
Question ID: 1b2d9b5f363aeb33f36f312a4d6fddaddb2ce611_3
Original Code:
```
fn test_newton_gravitational_field() {
        let grav_result = newton_gravitational_field(
            &Array3d {
                x: 1.0,
                z: 1.0,
                y: 1.0,
            },
            1e15f64,
        );

        assert!(-12845.0 < grav_result.x && grav_result.x < -12843.0);
        assert!(-12845.0 < grav_result.y && grav_result.y < -12843.0);
        assert!(-12845.0 < grav_result.z && grav_result.z < -12843.0);
    }
```


Overlapping Code:
```
result = newton_gravitational_field(
&Array3d {
x: 1.0,
z: 1.0,
y: 1.0,
},
1e15f64,
);
assert!(-12845.0 < grav_result.x && grav_result.x < -12843.0);
assert!(-12845.0 < grav_result.y && grav_result.y < -12843.0);
assert!(-12845.0 < grav_result.z && g
```
<Overlap Ratio: 0.7692307692307693>

---

--- 69 --
Question ID: 40ec2526cd056075e8da11b41ee7afd67fd91c90_7
Original Code:
```
fn test_sort_stakes_basic() {
        let pubkey0 = Pubkey::new_rand();
        let pubkey1 = Pubkey::new_rand();
        let mut stakes = vec![(pubkey0, 1), (pubkey1, 2)];
        sort_stakes(&mut stakes);
        assert_eq!(stakes, vec![(pubkey1, 2), (pubkey0, 1)]);
    }
```


Overlapping Code:
```
ubkey0 = Pubkey::new_rand();
let pubkey1 = Pubkey::new_rand();
let mut stakes = vec![(pubkey0, 1), (pubkey1, 2)];
sort_stakes(&mut stakes);
assert_eq!(stakes, vec![(pubkey1, 2), (pubkey0, 1)]);
}
```
<Overlap Ratio: 0.8478260869565217>

---

--- 70 --
Question ID: f9520156218e9bcfb79679b0e5b28646d0ebfa83_1
Original Code:
```
fn main() -> io::Result<()> {
    let file = File::open("input.txt")?;
    let reader = BufReader::new(file);
    let mut asteroids = reader
        .lines()
        .map(|line| line.map(|l| l.bytes().map(|b| b == b'#').collect()))
        .collect::<io::Result<Vec<Vec<bool>>>>()?;
    let width = asteroids[0].len();
    let height = asteroids.len();
    let mut remaining = 199;
    loop {
        let mut visible = get_visible_asteroids(&mut asteroids, BASE_X, BASE_Y, width, height);
        // visible.sort();
        // for (i, v) in visible.iter().enumerate() {
        //     println!("{}: {}", i, v);
        // }
        if visible.len() < remaining {
            remaining -= visible.len();
        } else {
            visible.sort();

            let target = &visible[remaining];
            println!("200th asteroid: {}", (BASE_X as isize + target.x) * 100 + (BASE_Y as isize + target.y));
            break;
        }
    }

    Ok(())
}
```


Overlapping Code:
```
main() -> io::Result<()> {
let file = File::open("input.txt")?;
let reader = BufReader::new(file);
let mut asteroids = reader
.lines()
.map(|line| line.map(|l| l.bytes().map(|b| b == b'#').collect()))
.collect::<io::Result<Vec<Vec<bool>>>>()?;
let width = asteroids[0].len();
let height = asteroids.len();
let mut remaining = 199;
loop {
let mut visible = get_visible_asteroids(&mut asteroids, BASE_X, BASE_Y, width, height);
// visible.sort();
// for (i, v) in visible.iter().enumerate() {
// println!("{}: {}", i, v);
// }
if visible.len() < remaining {
remaining -= visible.len();
} else {
visible.sort();
let target = &visible[remaining];
println!("200th asteroid: {}", (BASE_X as isize + target.x) * 100 + (BASE_Y as isize +
```
<Overlap Ratio: 0.9541884816753927>

---

--- 71 --
Question ID: 5c449da2b98037d891558adc36493ab6f1016c1a_22
Original Code:
```
fn returns_err() {
                let value = "value";
                let mut args = args!(Occur::Multi, None);
                args.parse(&vec!("-o", "0", "-o", value));

                assert!(args.values_of::<i32>("option").is_err());
            }
```


Overlapping Code:
```
fn returns_err() {
let value = "value";
let mut args = args!(Occur::Multi, None);
args.parse(&vec!("-o", "0", "-o", value));
assert!(args.
```
<Overlap Ratio: 0.7796610169491526>

---

--- 72 --
Question ID: add605204ef1c4b6e3127eb877c762171bfb3509_12
Original Code:
```
fn return_from_block() {
        let mut lang = Lang::new(Some(
            "
        fn test() -> i32 {
            {
                return 100;
            }
        }
        let value: i32 = test();
        assert(value == 100);
        ",
        ));
        let result = lang.run();
        if let Err(ref error) = result {
            println!("{}", error);
        }
        assert_eq!(result.is_ok(), true)
    }
```


Overlapping Code:
```
turn_from_block() {
let mut lang = Lang::new(Some(
"
fn test() -> i32 {
{
return 100;
}
}
let value: i32 = test();
assert(value == 100);
",
));
let result = lang.run();
if let Err(ref error) = result {
println!("{}", error);
}
assert_eq!(result.is_ok(), true)

```
<Overlap Ratio: 0.9774436090225563>

---

--- 73 --
Question ID: 4f407509350c506c0bf501c2d75a4cd2e75dc4de_1
Original Code:
```
fn main() -> Result<(), Box<dyn Error>> {
    let config_file = match std::env::args_os().nth(1) {
        Some(x) => x,
        None => {
            eprintln!("Config file argument required.");
            std::process::exit(1);
        }
    };

    let config_file = std::fs::File::open(config_file)?;
    let config: Box<HashMap<String, Endpoint>> = Box::new(serde_yaml::from_reader(config_file)?);

    let route = warp::put2()
        .and(warp::path::param())
        .and(warp::path::end())
        .and(warp::query::raw())
        .and(warp::body::concat())
        .map(move |f, a, b| file_sink_wrapper(f, a, b, &*config));

    warp::serve(route).run(([0, 0, 0, 0], 8228));
    Ok(())
}
```


Overlapping Code:
```
fn main() -> Result<(), Box<dyn Error>> {
let config_file = match std::env::args_os().nth(1) {
Some(x) => x,
None => {
eprintln!("Config file argument required.");
std::process::exit(1);
}
};
let config_file = std::fs::File::open(config_file)?;
let config: Box<HashMap<String, Endpoint>> = Box::new(serde_yaml::from_reader(config_file)?);
let route = warp::put2()
.and(warp::path::param())
.and(warp::path::end())
.and(warp::query::raw())
.and(warp::body::concat())
.map(move |f, a, b| file_sink_wrapper(f, a, b, &*config));
warp::serve(
```
<Overlap Ratio: 0.927461139896373>

---

--- 74 --
Question ID: f017aa46723fb74d6f27790b365aae9b5c0969ca_0
Original Code:
```
pub fn ProgressDelay(props: &Props) -> Html {
    let Props { duration_ms, .. } = props.clone();

    let value = {
        let props = props.clone();
        use_reducer(move || ValueState {
            start: Instant::now(),
            value: 0.0,

            props,
        })
    };

    {
        let value = value.clone();
        use_effect_with_deps(
            move |_| {
                let interval = (duration_ms / RESOLUTION).min(MIN_INTERVAL_MS);
                let interval =
                    Interval::new(interval as u32, move || value.dispatch(ValueAction::Tick));

                || {
                    let _interval = interval;
                }
            },
            (),
        );
    }

    {
        let value = value.clone();
        use_effect_with_deps(
            move |props| {
                value.dispatch(ValueAction::Props(props.clone()));
                || {}
            },
            props.clone(),
        );
    }

    let value = &value.value;

    html! {
        <progress class="progress is-primary" value={value.to_string()} max=1.0>
            { format!("{:.0}%", 100.0 * value) }
        </progress>
    }
}
```


Overlapping Code:
```
ps: &Props) -> Html {
let Props { duration_ms, .. } = props.clone();
let value = {
let props = props.clone();
use_reducer(move || ValueState {
start: Instant::now(),
value: 0.0,
props,
})
};
{
let value = value.clone();
use_effect_with_deps(
move |_| {
let interval = (duration_ms / RESOLUTION).min(MIN_INTERVAL_MS);
let interval =
Interval::new(interval as u32, move || value.dispatch(ValueAction::Tick));
|| {
let _interval = interval;
}
},
(),
);
}
{
let value = value.clone();
use_effect_with_deps(
move |props| {
value.dispatch(ValueAction::Props(props.clone()));
|| {}
},
props.clone(),
);
}
let value = &value.value;
html! {
<progress class="progress is-primary" value={value.to_string()} max=1.0>
{ format!("{:.0}%", 100.0 * value) }
</progre
```
<Overlap Ratio: 0.9603072983354674>

---

--- 75 --
Question ID: b66a82070f0cdb39812b5d4f11a4e6a29ad4b761_4
Original Code:
```
fn bench_functional_curl_par(num_hashes: usize) {
    print_title(&format!("Functional Curl ({} threads)", num_cpus::get()));

    let transactions_as_trits = get_random_tx_balanced_trits(num_hashes);
    let num_threads = num_cpus::get();
    let pool = Pool::new(num_threads);
    let chunk_length = transactions_as_trits.len() / num_threads;
    let index = AtomicUsize::new(0);

    let start = Instant::now();
    pool.scoped(|scope| {
        for _ in 0..num_threads {
            scope.execute(|| {
                let i = index.fetch_add(1, Ordering::SeqCst);
                //
                let offset = i * chunk_length;
                //println!("offset {} = {}", i, offset);
                for j in offset..offset + chunk_length {
                    let _hash_trits =
                        curl_func(&transactions_as_trits[j], NUM_CURL_ROUNDS);
                }
            })
        }
    });

    print_timing(start.elapsed(), num_hashes);
}
```


Overlapping Code:
```
_par(num_hashes: usize) {
print_title(&format!("Functional Curl ({} threads)", num_cpus::get()));
let transactions_as_trits = get_random_tx_balanced_trits(num_hashes);
let num_threads = num_cpus::get();
let pool = Pool::new(num_threads);
let chunk_length = transactions_as_trits.len() / num_threads;
let index = AtomicUsize::new(0);
let start = Instant::now();
pool.scoped(|scope| {
for _ in 0..num_threads {
scope.execute(|| {
let i = index.fetch_add(1, Ordering::SeqCst);
//
let offset = i * chunk_length;
//println!("offset {} = {}", i, offset);
for j in offset..offset + chunk_length {
let _hash_trits =
curl_func(&transactions_as_trits[j], NUM_CURL_ROUNDS);
}
})
}
});
print_timing(start.elapsed
```
<Overlap Ratio: 0.9433962264150944>

---

--- 76 --
Question ID: 7a0e9db013523aab2c0587d722219ac766744a48_11
Original Code:
```
fn test_apply_infix_op_scalar_vector() -> Result<(), YolkError> {
    let lhs = Value::Scalar("a".parse()?);
    let rhs = Value::Vector(Vector::from_expanded_ident("b", 3));
    lhs.apply_infix_op(&InfixOp::Add, &rhs)?;
    Ok(())
}
```


Overlapping Code:
```
 -> Result<(), YolkError> {
let lhs = Value::Scalar("a".parse()?);
let rhs = Value::Vector(Vector::from_expanded_ident("b", 3));
lhs.apply_infix_op(&InfixOp::Add, &rhs)?;
Ok((
```
<Overlap Ratio: 0.8064516129032258>

---

--- 77 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_344
Original Code:
```
fn spec_test_345() {
    let original = r##"`<http://foo.bar.`baz>`
"##;
    let expected = r##"<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
45() {
let original = r##"`<http://foo.bar.`baz>`
"##;
let expected = r##"<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9230769230769231>

---

--- 78 --
Question ID: 4175d22e2afd1cb11deda7649e64e8a015760b19_25
Original Code:
```
fn remove_overlay_keep_discard_overwritten_env() {
    let inp = &[
        r#"overlay add samples/spam.nu"#,
        r#"let-env BAZ = "bagr""#,
        r#"overlay remove --keep-custom spam"#,
        r#"$env.BAZ"#,
    ];

    let actual = nu!(cwd: "tests/overlays", pipeline(&inp.join("; ")));
    let actual_repl = nu_repl("tests/overlays", inp);

    assert!(actual.err.contains("did you mean"));
    assert!(actual_repl.err.contains("DidYouMean"));
}
```


Overlapping Code:
```
card_overwritten_env() {
let inp = &[
r#"overlay add samples/spam.nu"#,
r#"let-env BAZ = "bagr""#,
r#"overlay remove --keep-custom spam"#,
r#"$env.BAZ"#,
];
let actual = nu!(cwd: "tests/overlays", pipeline(&inp.join("; ")));
let actual_repl = nu_repl("tests/overlays", inp);
assert!(actual.err.contains("did you mean"));
assert!(actual_repl.err.contains("DidYouMean"));

```
<Overlap Ratio: 0.9319899244332494>

---

--- 79 --
Question ID: 04562bc524c57cfa42238858b057083cee8d7295_0
Original Code:
```
fn main() {
    let args: Vec<_> = env::args().collect();

    let opts = Opts::parse_args_default(&args[1..]).unwrap_or_else(|e| {
        match e.to_string().as_ref() {
            // Show usage if no command name is given or if "help" is given
            "missing command name" => help(&[]),
            string => eprintln!("{}: {}", args[0], string),
        }

        exit(2);
    });

    match opts {
        Opts::Help(opts) => help(&opts.commands),
        Opts::Check(_) => check(),
    }

    exit(0);
}
```


Overlapping Code:
```
fn main() {
let args: Vec<_> = env::args().collect();
let opts = Opts::parse_args_default(&args[1..]).unwrap_or_else(|e| {
match e.to_string().as_ref() {
// Show usage if no command name is given or if "help" is given
"missing command name" => help(&[]),
string => eprintln!("{}: {}", args[0], string),
}
exit(2);
});
match opts {
Opts::Help(opts) => help(&opts.commands),
Opts::Chec
```
<Overlap Ratio: 0.9296116504854369>

---

--- 80 --
Question ID: 3184a53b98aeeabc5cd4886b8149ea3bf52266b1_1
Original Code:
```
pub fn openssl_find() -> &'static str {
    // We need a homebrew openssl, because OSX comes with
    // 0.9.8y or something equally ancient!
    if cfg!(target_os = "macos") {
        return "/usr/local/opt/openssl/bin/openssl";
    }

    "openssl"
}
```


Overlapping Code:
```
&'static str {
// We need a homebrew openssl, because OSX comes with
// 0.9.8y or something equally ancient!
if cfg!(target_os = "macos") {
return "/u
```
<Overlap Ratio: 0.672645739910314>

---

--- 81 --
Question ID: 1df1be4ce7f6a5fb76415b5ebe3f6a95ace12a41_16
Original Code:
```
fn should_move_transactions_to_future_if_gap_introduced() {
	// given
	let txq = new_queue();
	let (tx, tx2) = Tx::default().signed_pair();
	let hash = tx.hash();
	let tx3 = Tx::default().signed();

	let res = txq.import(TestClient::new(), vec![tx3, tx2].local());
	assert_eq!(res, vec![Ok(()), Ok(())]);
	assert_eq!(txq.status().status.transaction_count, 2);
	assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);

	let res = txq.import(TestClient::new(), vec![tx].local());
	assert_eq!(res, vec![Ok(())]);
	assert_eq!(txq.status().status.transaction_count, 3);
	assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 3);

	// when
	txq.remove(vec![&hash], true);

	// then
	assert_eq!(txq.status().status.transaction_count, 2);
	assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);
}
```


Overlapping Code:
```
ntroduced() {
// given
let txq = new_queue();
let (tx, tx2) = Tx::default().signed_pair();
let hash = tx.hash();
let tx3 = Tx::default().signed();
let res = txq.import(TestClient::new(), vec![tx3, tx2].local());
assert_eq!(res, vec![Ok(()), Ok(())]);
assert_eq!(txq.status().status.transaction_count, 2);
assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);
let res = txq.import(TestClient::new(), vec![tx].local());
assert_eq!(res, vec![Ok(())]);
assert_eq!(txq.status().status.transaction_count, 3);
assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 3);
// when
txq.remove(vec![&hash], true);
// then
assert_eq!(txq.status().status.transaction_count, 2);
assert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0,
```
<Overlap Ratio: 0.928082191780822>

---

--- 82 --
Question ID: 99a092f8c4cb9df6e0904979a07d187bf51da5de_0
Original Code:
```
fn compress_decompress() {
    let source = vec![0,1,2,4, 100, 123412, 1543245423];
    let compressed = Compressed::from(source.iter().map(|&x|x));
    let decompressor = compressed.decompress();
    let result = decompressor.collect::<Vec<_>>();
    assert_eq!(result, source);
}
```


Overlapping Code:
```
ompress_decompress() {
let source = vec![0,1,2,4, 100, 123412, 1543245423];
let compressed = Compressed::from(source.iter().map(|&x|x));
let decompressor = compressed.decompress();
let result = decompressor.collect::<Vec<_>>();
assert_eq!(result, sou
```
<Overlap Ratio: 0.9578544061302682>

---

--- 83 --
Question ID: ce67a888bc467015393e20315440f93e728daa41_1
Original Code:
```
fn trailing_zero_should_work() {
		let mut t = super::TrailingZeroInput(&[1, 2, 3]);
		assert_eq!(t.remaining_len(), Ok(None));
		let mut buffer = [0u8; 2];
		assert_eq!(t.read(&mut buffer), Ok(()));
		assert_eq!(t.remaining_len(), Ok(None));
		assert_eq!(buffer, [1, 2]);
		assert_eq!(t.read(&mut buffer), Ok(()));
		assert_eq!(t.remaining_len(), Ok(None));
		assert_eq!(buffer, [3, 0]);
		assert_eq!(t.read(&mut buffer), Ok(()));
		assert_eq!(t.remaining_len(), Ok(None));
		assert_eq!(buffer, [0, 0]);
	}
```


Overlapping Code:
```
ro_should_work() {
let mut t = super::TrailingZeroInput(&[1, 2, 3]);
assert_eq!(t.remaining_len(), Ok(None));
let mut buffer = [0u8; 2];
assert_eq!(t.read(&mut buffer), Ok(()));
assert_eq!(t.remaining_len(), Ok(None));
assert_eq!(buffer, [1, 2]);
assert_eq!(t.read(&mut buffer), Ok(()));
assert_eq!(t.remaining_len(), Ok(None));
assert_eq!(buffer, [3, 0]);
assert_eq!(t.read(&mut buffer), Ok(()));
assert_eq!(t.remaining_len(), Ok(None));
assert_eq!(
```
<Overlap Ratio: 0.9336099585062241>

---

--- 84 --
Question ID: c6633fc301d67b960002674286f7e2e8307d1abf_1
Original Code:
```
fn get_replays_dir_path() -> PathBuf {
    let mut replays_path = files::get_path();
    replays_path.push("replays");
    replays_path
}
```


Overlapping Code:
```
n get_replays_dir_path() -> PathBuf {
let mut replays_path = files::get_path();
replays_path.push("r
```
<Overlap Ratio: 0.8>

---

--- 85 --
Question ID: de3c1c02c98f9bfc3c051149e02907f25afd8e5d_1
Original Code:
```
pub unsafe extern "C" fn sr_sign(
	message: *const u8,
	len: usize,
	random: *const u8,
	keypair: *const u8,
    sig_out: *mut u8,
) -> u32 {
	let context = signing_context(b"substrate");
	let keypair =
		match Keypair::from_bytes(slice::from_raw_parts(keypair, SR_PUBLIC_LEN + SR_SECRET_LEN)) {
			Ok(pair) => pair,
			Err(_) => {
				return {SR_PAIR_FAIL};
			}
		};
	let message_bytes = slice::from_raw_parts(message, len);
	let trng_bytes = slice::from_raw_parts(random, SR_PUBLIC_LEN);
    let signature: Signature = keypair.sign(
        attach_rng(
            context.bytes(&message_bytes[..]), 
            ExternalRng{
                rng_bytes:ExternalRng::copy_into_array(trng_bytes),
                len:32}
                ));
     ptr::copy(signature.to_bytes().as_ptr(), sig_out, SR_SIGNATURE_LEN as usize);  
    { SR_OK }
}
```


Overlapping Code:
```
fe extern "C" fn sr_sign(
message: *const u8,
len: usize,
random: *const u8,
keypair: *const u8,
sig_out: *mut u8,
) -> u32 {
let context = signing_context(b"substrate");
let keypair =
match Keypair::from_bytes(slice::from_raw_parts(keypair, SR_PUBLIC_LEN + SR_SECRET_LEN)) {
Ok(pair) => pair,
Err(_) => {
return {SR_PAIR_FAIL};
}
};
let message_bytes = slice::from_raw_parts(message, len);
let trng_bytes = slice::from_raw_parts(random, SR_PUBLIC_LEN);
let signature: Signature = keypair.sign(
attach_rng(
context.bytes(&message_bytes[..]), 
ExternalRng{
rng_bytes:ExternalRng::copy_into_array(trng_bytes),
len:32}
));
ptr::copy(signature.to_bytes().as_ptr(), sig_out, SR_SIGNATURE_LEN as usize); 
{
```
<Overlap Ratio: 0.9749303621169917>

---

--- 86 --
Question ID: b53fa495947627f8fe136b0812c1f9507e751d06_1
Original Code:
```
fn parse_output(src: &OsStr) -> Result<Output, OsString> {
    let mut chunks = src.as_bytes().splitn(2, |&b| b == b':');
    let ports = String::from_utf8(chunks.next().unwrap().to_vec())
        .map_err(Into::into)
        .and_then(|ports| parse_ports(ports.as_str()))
        .map_err(|err| err.to_string())?;
    let path = chunks.next().map(|path| OsStr::from_bytes(path).into());
    Ok(Output { ports, path })
}
```


Overlapping Code:
```
output(src: &OsStr) -> Result<Output, OsString> {
let mut chunks = src.as_bytes().splitn(2, |&b| b == b':');
let ports = String::from_utf8(chunks.next().unwrap().to_vec())
.map_err(Into::into)
.and_then(|ports| parse_ports(ports.as_str()))
.map_err(|err| err.to_string())?;
let path = chunks.next().map(|path| OsStr::from_bytes(path).into());
Ok(Outp
```
<Overlap Ratio: 0.9210526315789473>

---

--- 87 --
Question ID: 9d5af356183cde7875f69aef72ca78ad2a84fde0_1
Original Code:
```
fn reachable_with_relation_join(edges: &[(u32, u32)]) -> Relation<(u32, u32)> {
    let edges: Relation<_> = edges.iter().collect();
    let mut iteration = Iteration::new();

    // NB. Changed from `reachable_with_var_join`:
    let edges_by_successor: Relation<_> = edges.iter().map(|&(n1, n2)| (n2, n1)).collect();

    let reachable = iteration.variable::<(u32, u32)>("reachable");
    reachable.insert(edges);

    while iteration.changed() {
        // reachable(N1, N3) :- edges(N1, N2), reachable(N2, N3).
        reachable.from_join(&reachable, &edges_by_successor, |&_, &n3, &n1| (n1, n3));
    }

    reachable.complete()
}
```


Overlapping Code:
```
le_with_relation_join(edges: &[(u32, u32)]) -> Relation<(u32, u32)> {
let edges: Relation<_> = edges.iter().collect();
let mut iteration = Iteration::new();
// NB. Changed from `reachable_with_var_join`:
let edges_by_successor: Relation<_> = edges.iter().map(|&(n1, n2)| (n2, n1)).collect();
let reachable = iteration.variable::<(u32, u32)>("reachable");
reachable.insert(edges);
while iteration.changed() {
// reachable(N1, N3) :- edges(N1, N2), reachable(N2, N3).
reachable.from_join(&reachable, &edges_by_successor, |&_, &n3, &n1| (n1, n3));
}
rea
```
<Overlap Ratio: 0.9499136442141624>

---

--- 88 --
Question ID: cecc5e6436200924337c7cfa7fdd23457615fe0a_4
Original Code:
```
fn test_notify() {
        let (tx1, rx1) = super::unbounded();
        let (tx2, rx2) = mpsc::unbounded();
        let mut rx2 = rx2.wait();
        let j = thread::spawn(move || {
            rx1.map_err(|_| ())
                .forward(tx2.sink_map_err(|_| ()))
                .wait()
                .unwrap();
        });
        tx1.send(2).unwrap();
        assert_eq!(rx2.next().unwrap(), Ok(2));
        for i in 0..100 {
            tx1.send(i).unwrap();
        }
        for i in 0..100 {
            assert_eq!(rx2.next().unwrap(), Ok(i));
        }
        thread::spawn(move || {
            for i in 100..10000 {
                tx1.send(i).unwrap();
            }
        });
        for i in 100..10000 {
            assert_eq!(rx2.next().unwrap(), Ok(i));
        }
        // j should automatically stop when tx1 is dropped.
        j.join().unwrap();
    }
```


Overlapping Code:
```
per::unbounded();
let (tx2, rx2) = mpsc::unbounded();
let mut rx2 = rx2.wait();
let j = thread::spawn(move || {
rx1.map_err(|_| ())
.forward(tx2.sink_map_err(|_| ()))
.wait()
.unwrap();
});
tx1.send(2).unwrap();
assert_eq!(rx2.next().unwrap(), Ok(2));
for i in 0..100 {
tx1.send(i).unwrap();
}
for i in 0..100 {
assert_eq!(rx2.next().unwrap(), Ok(i));
}
thread::spawn(move || {
for i in 100..10000 {
tx1.send(i).unwrap();
}
});
for i in 100..10000 {
assert_eq!(rx2.next().unwrap(), Ok(i));
}
// j should automatically stop when tx1 is dropped.
j.join
```
<Overlap Ratio: 0.9136212624584718>

---

--- 89 --
Question ID: 3644b9a5c5feb3422d0fbcbee5941eff000fc54e_0
Original Code:
```
fn main() {
    let mut client = ClientBuilder::new(CONNECTION)
        .expect("address parse fail")
        .connect(None)
        .expect("connect failed");

    println!("{:?}", client.recv_message());

    client
        .send_message(&Message::close())
        .expect("failed to close connection");
}
```


Overlapping Code:
```
 mut client = ClientBuilder::new(CONNECTION)
.expect("address parse fail")
.connect(None)
.expect("connect failed");
println!("{:?}", client.recv_message());
client
.send_message(&Message::close())
.expec
```
<Overlap Ratio: 0.8063241106719368>

---

--- 90 --
Question ID: a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_7
Original Code:
```
fn hit_with_location(input: &str) -> IResult<&str, PlayModifier> {
    let (input, hit_type) = alt((
        value(HitType::PopFly, tag("P")),
        value(HitType::PopUpBunt, tag("BP")),
        value(HitType::Fly, tag("F")),
        value(HitType::GroundBall, tag("G")),
        value(HitType::GroundBallBunt, tag("BG")),
        value(HitType::LineDrive, tag("L")),
    ))(input)?;
    let (input, hit_location) = opt(hit_location)(input)?;
    Ok((input, PlayModifier::HitWithLocation(hit_type, hit_location)))
}
```


Overlapping Code:
```
&str, PlayModifier> {
let (input, hit_type) = alt((
value(HitType::PopFly, tag("P")),
value(HitType::PopUpBunt, tag("BP")),
value(HitType::Fly, tag("F")),
value(HitType::GroundBall, tag("G")),
value(HitType::GroundBallBunt, tag("BG")),
value(HitType::LineDrive, tag("L")),
))(input)?;
let (input, hit_location) = opt(hit_location)(input)?;
Ok((input, PlayModifier::HitWithLocation(hit_type, hit_locat
```
<Overlap Ratio: 0.8830022075055187>

---

--- 91 --
Question ID: e6b1432668cf5fcb3e0d437d0afcc02a65b1c4f7_0
Original Code:
```
unsafe extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
 -> *mut wl_registry {
    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
    registry =
        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
                                     1i32 as uint32_t,
                                     &wl_registry_interface as
                                         *const wl_interface,
                                     0 as *mut libc::c_void);
    return registry as *mut wl_registry;
}
```


Overlapping Code:
```
e extern "C" fn wl_display_get_registry(mut wl_display: *mut wl_display)
-> *mut wl_registry {
let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;
registry =
wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,
1i32 as uint32_t,
&wl_registry_interface as
*const wl_interface,
0 as *mut libc::c_void);
return registry as *mut wl_registr
```
<Overlap Ratio: 0.9743589743589743>

---

--- 92 --
Question ID: c3d594204f413de24eeeb0ab860a88c37a52170a_0
Original Code:
```
fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],
                       lvl: &Level,
                       dst: &mut Destination,
                       short_message: bool)
                       -> io::Result<()> {
    use crate::lock;

    let mut dst = dst.writable();

    // In order to prevent error message interleaving, where multiple error lines get intermixed
    // when multiple compiler processes error simultaneously, we emit errors with additional
    // steps.
    //
    // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When
    // the .flush() is called we take the buffer created from the buffered writes and write it at
    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling
    // scheme, this buffered approach works and maintains the styling.
    //
    // On Windows, styling happens through calls to a terminal API. This prevents us from using the
    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long
    // enough to output the full error message, then we release.
    let _buffer_lock = lock::acquire_global_lock("rustc_errors");
    for (pos, line) in rendered_buffer.iter().enumerate() {
        for part in line {
            dst.apply_style(lvl.clone(), part.style)?;
            write!(dst, "{}", part.text)?;
            dst.reset()?;
        }
        if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {
            write!(dst, "\n")?;
        }
    }
    dst.flush()?;
    Ok(())
}
```


Overlapping Code:
```
r: &[Vec<StyledString>],
lvl: &Level,
dst: &mut Destination,
short_message: bool)
-> io::Result<()> {
use crate::lock;
let mut dst = dst.writable();
// In order to prevent error message interleaving, where multiple error lines get intermixed
// when multiple compiler processes error simultaneously, we emit errors with additional
// steps.
//
// On Unix systems, we write into a buffered terminal rather than directly to a terminal. When
// the .flush() is called we take the buffer created from the buffered writes and write it at
// one shot. Because the Unix systems use ANSI for the colors, which is a text-based styling
// scheme, this buffered approach works and maintains the styling.
//
// On Windows, styling happens through calls to a terminal API. This prevents us from using the
// same buffering approach. Instead, we use a global Windows mutex, which we acquire long
// enough to output the full error message, then we release.
let _buffer_lock = lock::acquire_global_lock("rustc_errors");
for (pos, line) in rendered_buffer.iter().enumerate() {
for part in line {
dst.apply_style(lvl.clone(), part.style)?;
write!(dst, "{}", part.text)?;
dst.reset()?;
}
if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {
write!(dst, "\n")?;
}
}
dst.flush()?;
Ok(())
}
```
<Overlap Ratio: 0.9723261032161555>

---

--- 93 --
Question ID: 3d9c204ab5e87806b487b1e18376ede4b321b8a6_11
Original Code:
```
pub fn find_best_release(
    data: &[WarehouseRelease],
    name: &str,
    version: &Version,
    os: Os,
    python_vers: &Version,
) -> (WarehouseRelease, PackageType) {
    // Find which release we should download. Preferably wheels, and if so, for the right OS and
    // Python version.
    let mut compatible_releases = vec![];
    // Store source releases as a fallback, for if no wheels are found.
    let mut source_releases = vec![];

    for rel in data.iter() {
        let mut compatible = true;
        match rel.packagetype.as_ref() {
            "bdist_wheel" => {
                // Now determine if this wheel is appropriate for the Os and Python version.
                if let Some(py_ver) = &rel.requires_python {
                    // If a version constraint exists, make sure it's compatible.
                    let py_constrs = Constraint::from_str_multiple(py_ver)
                        .expect("Problem parsing constraint from requires_python");

                    for constr in &py_constrs {
                        if !constr.is_compatible(python_vers) {
                            compatible = false;
                        }
                    }
                }

                let wheel_os =
                    os_from_wheel_fname(&rel.filename).expect("Problem getting os from wheel name");
                if wheel_os != os && wheel_os != Os::Any {
                    compatible = false;
                }

                // Packages that use C code(eg numpy) may fail to load C extensions if installing
                // for the wrong version of python (eg  cp35 when python 3.7 is installed), even
                // if `requires_python` doesn't indicate an incompatibility. Check `python_version`
                // instead of `requires_python`.
                // Note that the result of this parse is an any match.
                if let Ok(constrs) = Constraint::from_wh_py_vers(&rel.python_version) {
                    let mut compat_py_v = false;
                    for constr in &constrs {
                        if constr.is_compatible(python_vers) {
                            compat_py_v = true;
                        }
                    }
                    if !compat_py_v {
                        compatible = false;
                    }
                } else {
                    println!(
                        "Unable to match python version from python_version: {}",
                        &rel.python_version
                    )
                };

                if compatible {
                    compatible_releases.push(rel.clone());
                }
            }
            "sdist" => source_releases.push(rel.clone()),
            "bdist_wininst" | "bdist_msi" | "bdist_egg" => (), // Don't execute Windows installers
            _ => {
                println!("Found surprising package type: {}", rel.packagetype);
                continue;
            }
        }
    }

    let best_release;
    let package_type;
    // todo: Sort further / try to match exact python_version if able.
    if compatible_releases.is_empty() {
        if source_releases.is_empty() {
            abort(&format!(
                "Unable to find a compatible release for {}: {}",
                name,
                version.to_string_color()
            ))
        } else {
            best_release = source_releases[0].clone();
            package_type = install::PackageType::Source;
        }
    } else {
        best_release = compatible_releases[0].clone();
        package_type = install::PackageType::Wheel;
    }

    (best_release, package_type)
}
```


Overlapping Code:
```
lease(
data: &[WarehouseRelease],
name: &str,
version: &Version,
os: Os,
python_vers: &Version,
) -> (WarehouseRelease, PackageType) {
// Find which release we should download. Preferably wheels, and if so, for the right OS and
// Python version.
let mut compatible_releases = vec![];
// Store source releases as a fallback, for if no wheels are found.
let mut source_releases = vec![];
for rel in data.iter() {
let mut compatible = true;
match rel.packagetype.as_ref() {
"bdist_wheel" => {
// Now determine if this wheel is appropriate for the Os and Python version.
if let Some(py_ver) = &rel.requires_python {
// If a version constraint exists, make sure it's compatible.
let py_constrs = Constraint::from_str_multiple(py_ver)
.expect("Problem parsing constraint from requires_python");
for constr in &py_constrs {
if !constr.is_compatible(python_vers) {
compatible = false;
}
}
}
let wheel_os =
os_from_wheel_fname(&rel.filename).expect("Problem getting os from wheel name");
if wheel_os != os && wheel_os != Os::Any {
compatible = false;
}
// Packages that use C code(eg numpy) may fail to load C extensions if installing
// for the wrong version of python (eg cp35 when python 3.7 is installed), even
// if `requires_python` doesn't indicate an incompatibility. Check `python_version`
// instead of `requires_python`.
// Note that the result of this parse is an any match.
if let Ok(constrs) = Constraint::from_wh_py_vers(&rel.python_version) {
let mut compat_py_v = false;
for constr in &constrs {
if constr.is_compatible(python_vers) {
compat_py_v = true;
}
}
if !compat_py_v {
compatible = false;
}
} else {
println!(
"Unable to match python version from python_version: {}",
&rel.python_ver
```
<Overlap Ratio: 0.9866511897852582>

---

--- 94 --
Question ID: aaa085a889c7cc296732b54441d7e7fec703a8f8_0
Original Code:
```
fn skip_bom(mut reader: BufReader<File>) -> Result<BufReader<File>> {
    let buf = reader.fill_buf()?;
    if buf.len() >= 3 && buf[0] == 0xEF && buf[1] == 0xBB && buf[2] == 0xBF {
        reader.read_exact(&mut [0; 3])?;
    }
    Ok(reader)
}
```


Overlapping Code:
```
der: BufReader<File>) -> Result<BufReader<File>> {
let buf = reader.fill_buf()?;
if buf.len() >= 3 && buf[0] == 0xEF && buf[1] == 0xBB && buf[2] == 0xBF {
reader.read_exact(&mut [0; 3])?;
}
Ok(reader)
```
<Overlap Ratio: 0.9049773755656109>

---

--- 95 --
Question ID: 8a6f298c413813ccbbfc54ef647dd6fcc232100e_0
Original Code:
```
pub fn initialize() -> Option<&'static Reference> {
    static mut CLUSTER: Option<Reference> = None;

    if unsafe { CLUSTER.is_none() } {
        unsafe {
            CLUSTER = js! {
                return @{ super::js_private() }.cluster = require("cluster");
            }.into_reference()
        };
    }

    unsafe { CLUSTER.as_ref() }
}
```


Overlapping Code:
```
itialize() -> Option<&'static Reference> {
static mut CLUSTER: Option<Reference> = None;
if unsafe { CLUSTER.is_none() } {
unsafe {
CLUSTER = js! {
return @{ super::js_private() }.cluster = require("cluster");
}.into_reference()
};
}
unsafe { CLUSTER.as_ref() 
```
<Overlap Ratio: 0.9558823529411765>

---

--- 96 --
Question ID: 9a979beb3aa2c43c90ae9366df5d52fb3ad55958_24
Original Code:
```
fn number_01() {
    let mut b = "#define SYSTEM_FUNCT_CONTROL    (4'hf)".as_bytes();
    let mut l = Lexer::new(&mut b);

    assert_eq!(
        l.next(true),
        Token::new(TokenClass::Symbol(Symbol::Sharp), 1, 1)
    );
    assert_eq!(
        l.next(true),
        Token::new(TokenClass::Macro(Macro::Define), 1, 2)
    );
    assert_eq!(
        l.next(true),
        Token::new(
            TokenClass::Identifire("SYSTEM_FUNCT_CONTROL".to_string()),
            1,
            3
        )
    );
    assert_eq!(
        l.next(true),
        Token::new(TokenClass::Symbol(Symbol::LeftParen), 1, 4)
    );
    assert_eq!(
        l.next(true),
        Token::new(TokenClass::Number("4'hf".to_string()), 1, 5)
    );
    assert_eq!(
        l.next(true),
        Token::new(TokenClass::Symbol(Symbol::RightParen), 1, 6)
    );
}
```


Overlapping Code:
```
 {
let mut b = "#define SYSTEM_FUNCT_CONTROL (4'hf)".as_bytes();
let mut l = Lexer::new(&mut b);
assert_eq!(
l.next(true),
Token::new(TokenClass::Symbol(Symbol::Sharp), 1, 1)
);
assert_eq!(
l.next(true),
Token::new(TokenClass::Macro(Macro::Define), 1, 2)
);
assert_eq!(
l.next(true),
Token::new(
TokenClass::Identifire("SYSTEM_FUNCT_CONTROL".to_string()),
1,
3
)
);
assert_eq!(
l.next(true),
Token::new(TokenClass::Symbol(Symbol::LeftParen), 1, 4)
);
assert_eq!(
l.next(true),
Token::new(TokenClass::Number("4'hf".to_string()), 1, 5)
);
assert_eq!(
l.next(true),
Token::new(TokenClass::Symbol(Symbol::RightParen
```
<Overlap Ratio: 0.957680250783699>

---

--- 97 --
Question ID: 8bc8f45004c4d25f677dad56db1a20032fa502ec_0
Original Code:
```
fn main() {
    println!("VALUE: {}", VALUE);
    println!("{}", env!("CARGO_MANIFEST_DIR"));
    println!("{}", src_file!("foo.rs"));
}
```


Overlapping Code:
```
VALUE);
println!("{}", env!("CARGO_MANIFEST_DIR"))
```
<Overlap Ratio: 0.4032258064516129>

---

--- 98 --
Question ID: f7ae5f9680f23adb5272273c5c3ddcb768c21af0_7
Original Code:
```
fn can_read_full_type_3_chunk() {
        let csid = 50;
        let timestamp = 20;
        let delta1 = 10;
        let delta2 = 12;
        let message_stream_id = 52;
        let type_id = 3;
        let payload1 = vec![1, 2, 3];
        let payload2 = vec![1, 2, 3];
        let payload3 = vec![2, 2, 2];
        let payload4 = vec![4, 4, 4];

        let chunk_0_bytes = get_type_0_chunk(csid, timestamp, message_stream_id, type_id, payload1);        
        let chunk_1_bytes = get_type_1_chunk(csid, delta1, type_id, payload2);
        let chunk_2_bytes = get_type_2_chunk(csid, delta2, payload3);
        let chunk_3_bytes = get_type_3_chunk(csid, payload4);

        let mut deserializer = Deserializer::new();
        deserializer.process_bytes(&chunk_0_bytes).unwrap();
        deserializer.process_bytes(&chunk_1_bytes).unwrap();
        deserializer.process_bytes(&chunk_2_bytes).unwrap();

        let result = deserializer.process_bytes(&chunk_3_bytes).unwrap();

        assert_eq!(1, result.len());
        assert_eq!(timestamp + delta1 + delta2 + delta2, result[0].timestamp);
        assert_eq!(type_id, result[0].type_id);
        assert_eq!(message_stream_id, result[0].stream_id);
        assert_eq!(vec![4, 4, 4], result[0].data);
    }
```


Overlapping Code:
```
ead_full_type_3_chunk() {
let csid = 50;
let timestamp = 20;
let delta1 = 10;
let delta2 = 12;
let message_stream_id = 52;
let type_id = 3;
let payload1 = vec![1, 2, 3];
let payload2 = vec![1, 2, 3];
let payload3 = vec![2, 2, 2];
let payload4 = vec![4, 4, 4];
let chunk_0_bytes = get_type_0_chunk(csid, timestamp, message_stream_id, type_id, payload1); 
let chunk_1_bytes = get_type_1_chunk(csid, delta1, type_id, payload2);
let chunk_2_bytes = get_type_2_chunk(csid, delta2, payload3);
let chunk_3_bytes = get_type_3_chunk(csid, payload4);
let mut deserializer = Deserializer::new();
deserializer.process_bytes(&chunk_0_bytes).unwrap();
deserializer.process_bytes(&chunk_1_bytes).unwrap();
deserializer.process_bytes(&chunk_2_bytes).unwrap();
let result = deserializer.process_bytes(&chunk_3_bytes).unwrap();
assert_eq!(1, result.len());
assert_eq!(timestamp + delta1 + delta2 + delta2, result[0].timestamp);
assert_eq!(type_id, result[0].type_id);
assert_eq!(message_stream_id, result[0].stream_id);
assert_eq!(
```
<Overlap Ratio: 0.961100569259962>

---

--- 99 --
Question ID: 0f873cdf896e80d85368b960a5b5a0b02b84feb4_0
Original Code:
```
pub fn main(matches: &ArgMatches) {
    let input_files: Vec<String> = match values_t!(matches, "input-files", String) {
        Ok(v) => v,
        Err(e) => {
            eprintln!("binstore: invalid input file: {}", e);
            process::exit(1)
        }
    };

    let output_files: Vec<String> = match values_t!(matches, "output-files", String) {
        Ok(v) => v,
        Err(e) => {
            eprintln!("binstore: invalid output file: {}", e);
            process::exit(1)
        }
    };

    let values: Vec<Value> = match values_t!(matches, "values", Value) {
        Ok(v) => v,
        Err(e) => {
            eprintln!("hydroxyde: invalid values: {}", e);
            process::exit(1);
        }
    };

    if input_files.len() != output_files.len() {
        eprintln!("binstore: number of input files does not match number of output files");
        process::exit(1)
    }

    let files: Vec<(String, String)> = input_files.into_iter().zip(output_files).collect();

    let mut ret = 0;
    for (input, output) in &files {
        if let Err(e) = binstore::bucket::delete(input, output, &values) {
            ret = 1;
            eprintln!("binstore: {}: {}", input, e);
        }
    }
    process::exit(ret);
}
```


Overlapping Code:
```
s: &ArgMatches) {
let input_files: Vec<String> = match values_t!(matches, "input-files", String) {
Ok(v) => v,
Err(e) => {
eprintln!("binstore: invalid input file: {}", e);
process::exit(1)
}
};
let output_files: Vec<String> = match values_t!(matches, "output-files", String) {
Ok(v) => v,
Err(e) => {
eprintln!("binstore: invalid output file: {}", e);
process::exit(1)
}
};
let values: Vec<Value> = match values_t!(matches, "values", Value) {
Ok(v) => v,
Err(e) => {
eprintln!("hydroxyde: invalid values: {}", e);
process::exit(1);
}
};
if input_files.len() != output_files.len() {
eprintln!("binstore: number of input files does not match number of output files");
process::exit(1)
}
let files: Vec<(String, String)> = input_files.into_iter().zip(output_files).collect();
let mut ret = 0;
for (input, output) in &files {
if let Err(e) = binstore::bucket::delete(input, output, &values) {
ret = 1;
eprintln!("binstore: {}: {}", input, e);
}
}
proces
```
<Overlap Ratio: 0.9664292980671414>

---

--- 100 --
Question ID: 63c03229343ca2d9c2ae27790dbf3c681fde5aad_17
Original Code:
```
fn test_parse_comment_two_spaces() {
    SETUP_READER!(
        reader,
        " //  Hello world
 //  Ciao mondo"
    );

    assert_eq!(reader.lines.len(), 2);

    assert_eq!(reader.lines[0].type_, LineType::Comment);
    assert_eq!(reader.lines[1].type_, LineType::Comment);
}
```


Overlapping Code:
```
comment_two_spaces() {
SETUP_READER!(
reader,
" // Hello world
// Ciao mondo"
);
assert_eq!(reader.lines.len(), 2);
assert_eq!(reader.lines[0].type_, LineType::Comment);
assert_eq!(reader.lines[1].type_, LineType:
```
<Overlap Ratio: 0.891213389121339>

---

--- 101 --
Question ID: 2ac950027523cdd0b783cf904f7a2f788318e32b_4
Original Code:
```
unsafe fn test_mm_adds_pi16() {
        let a = _mm_setr_pi16(-32000, 32000, 4, 0);
        let b = _mm_setr_pi16(-32000, 32000, -5, 1);
        let e = _mm_setr_pi16(i16::MIN, i16::MAX, -1, 1);
        assert_eq_m64(e, _mm_adds_pi16(a, b));
        assert_eq_m64(e, _m_paddsw(a, b));
    }
```


Overlapping Code:
```
nsafe fn test_mm_adds_pi16() {
let a = _mm_setr_pi16(-32000, 32000, 4, 0);
let b = _mm_setr_pi16(-32000, 32000, -5, 1);
let e = _mm_setr_pi16(i16::MIN, i16::MAX, -1, 1);
assert_eq_m64(e, _mm_adds_pi16
```
<Overlap Ratio: 0.8130081300813008>

---

--- 102 --
Question ID: a4feb9df9e7ec15f97abed630c88e5d9be189159_0
Original Code:
```
pub fn run(data: &Data, issue: &Issue, args: RunArgs) -> Result<()> {
    let name = get_name(&data.db, issue, args.name)?;

    if data.experiments.exists(&name)? {
        bail!("an experiment named **`{}`** already exists!", name);
    }

    data.experiments.create(
        &name,
        &args.start.ok_or_else(|| "missing start toolchain")?,
        &args.end.ok_or_else(|| "missing end toolchain")?,
        args.mode.unwrap_or(ExMode::BuildAndTest),
        args.crates.unwrap_or(ExCrateSelect::Full),
        args.cap_lints.unwrap_or(ExCapLints::Forbid),
        &data.config,
        Some(&issue.url),
        Some(&issue.html_url),
        Some(issue.number),
        args.priority.unwrap_or(0),
    )?;

    Message::new()
        .line(
            "ok_hand",
            format!("Experiment **`{}`** created and queued.", name),
        )
        .set_label(Label::ExperimentQueued)
        .send(&issue.url, data)?;

    Ok(())
}
```


Overlapping Code:
```
 fn run(data: &Data, issue: &Issue, args: RunArgs) -> Result<()> {
let name = get_name(&data.db, issue, args.name)?;
if data.experiments.exists(&name)? {
bail!("an experiment named **`{}`** already exists!", name);
}
data.experiments.create(
&name,
&args.start.ok_or_else(|| "missing start toolchain")?,
&args.end.ok_or_else(|| "missing end toolchain")?,
args.mode.unwrap_or(ExMode::BuildAndTest),
args.crates.unwrap_or(ExCrateSelect::Full),
args.cap_lints.unwrap_or(ExCapLints::Forbid),
&data.config,
Some(&issue.url),
Some(&issue.html_url),
Some(issue.number),
args.priority.unwrap_or(0),
)?;
Message::new()
.line(
"ok_hand",
format!("Experiment **`{}`** created and queued.", name),
)
.set_label(Label::ExperimentQueued)
.send(&issue.url, data)?;

```
<Overlap Ratio: 0.985545335085414>

---

--- 103 --
Question ID: 388ae2ff921b6696053c375108e34e169c32e862_0
Original Code:
```
fn primitive_type() {
    let mut i = 0;
    let mut v = 0;
    observable::from_iter(100..101)
      .tap(|i| v = *i)
      .subscribe(|v| i += v);
    assert_eq!(i, 100);
    assert_eq!(v, 100);
  }
```


Overlapping Code:
```
t i = 0;
let mut v = 0;
observable::from_iter(100..101)
.tap(|i| v = *i)
.subscribe(|v| i += v);
ass
```
<Overlap Ratio: 0.6024096385542169>

---

--- 104 --
Question ID: e0761de80413ea19c8171a9211ada7b4e48e35e5_26
Original Code:
```
fn delta_list(conn: State<DbReadWrite>, mut auth: auth::Auth, auth_rules: State<auth::CustomAuth>) ->  Result<Json, status::Custom<Json>> {
    let conn = conn.get()?;

    auth_rules.allows_delta_list(&mut auth, &conn)?;

    match delta::list_by_offset(&conn, None, None) {
        Ok(deltas) => Ok(Json(deltas)),
        Err(err) => Err(status::Custom(HTTPStatus::InternalServerError, Json(json!(err.to_string()))))
    }
}
```


Overlapping Code:
```
a_list(conn: State<DbReadWrite>, mut auth: auth::Auth, auth_rules: State<auth::CustomAuth>) -> Result<Json, status::Custom<Json>> {
let conn = conn.get()?;
auth_rules.allows_delta_list(&mut auth, &conn)?;
match delta::list_by_offset(&conn, None, None) {
Ok(deltas) => Ok(Json(deltas)),
Err(err) => Err(status::Custom(HTTPStatus::InternalServerError, Json(json!(err.to_string()))))
}
}
```
<Overlap Ratio: 0.9820971867007673>

---

--- 105 --
Question ID: 81b12bb3bff77651943ad50a3c36a227c2851fc6_0
Original Code:
```
pub unsafe extern fn kstart_ap(args_ptr: *const KernelArgsAp) -> ! {
    let cpu_id = {
        let args = &*args_ptr;
        let cpu_id = args.cpu_id as usize;
        let bsp_table = args.page_table as usize;
        let stack_start = args.stack_start as usize;
        let stack_end = args.stack_end as usize;

        assert_eq!(BSS_TEST_ZERO, 0);
        assert_eq!(DATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);

        // Set up GDT before paging
        gdt::init();

        // Set up IDT before paging
        idt::init();

        // Initialize paging
        let tcb_offset = paging::init_ap(cpu_id, bsp_table, stack_start, stack_end);

        // Set up GDT with TLS
        gdt::init_paging(tcb_offset, stack_end);

        // Set up IDT for AP
        idt::init_paging();

        // Test tdata and tbss
        {
            assert_eq!(TBSS_TEST_ZERO, 0);
            TBSS_TEST_ZERO += 1;
            assert_eq!(TBSS_TEST_ZERO, 1);
            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);
            TDATA_TEST_NONZERO -= 1;
            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFE);
        }

        // Initialize devices (for AP)
        device::init_ap();

        AP_READY.store(true, Ordering::SeqCst);

        cpu_id
    };

    while ! BSP_READY.load(Ordering::SeqCst) {
        interrupt::pause();
    }

    ::kmain_ap(cpu_id);
}
```


Overlapping Code:
```
n fn kstart_ap(args_ptr: *const KernelArgsAp) -> ! {
let cpu_id = {
let args = &*args_ptr;
let cpu_id = args.cpu_id as usize;
let bsp_table = args.page_table as usize;
let stack_start = args.stack_start as usize;
let stack_end = args.stack_end as usize;
assert_eq!(BSS_TEST_ZERO, 0);
assert_eq!(DATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);
// Set up GDT before paging
gdt::init();
// Set up IDT before paging
idt::init();
// Initialize paging
let tcb_offset = paging::init_ap(cpu_id, bsp_table, stack_start, stack_end);
// Set up GDT with TLS
gdt::init_paging(tcb_offset, stack_end);
// Set up IDT for AP
idt::init_paging();
// Test tdata and tbss
{
assert_eq!(TBSS_TEST_ZERO, 0);
TBSS_TEST_ZERO += 1;
assert_eq!(TBSS_TEST_ZERO, 1);
assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);
TDATA_TEST_NONZERO -= 1;
assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFE);
}
// Initialize devices (for AP)
device::init_ap();
AP_READY.store(true, Ordering::SeqCst);
cpu_id
};
while ! BSP_READY.load(Ordering::SeqCst) {
interrupt::pause();
}
::kmain_ap(cpu_id);
}
```
<Overlap Ratio: 0.9850467289719627>

---

--- 106 --
Question ID: c98722bdeae8e2e99256969c4c0af456b787ca7c_1
Original Code:
```
fn load_graph_test() {
        let f = File::open("testdata/parser.graph.gz").expect("Cannot open test graph.");
        let mut decoder = GzDecoder::new(BufReader::new(f));
        let mut data = Vec::new();
        decoder
            .read_to_end(&mut data)
            .expect("Cannot decompress test graph.");

        let system = StackProjectiveSystem::new();
        let vectorizer = InputVectorizer::new(
            LayerLookups::new(),
            AddressedValues(Vec::new()),
            HashMap::new(),
            Vec::new()
        );

        let mut op_names = LayerOps::new();
        op_names.insert(
            Layer::Token,
            LayerOp::Embedding {
                op: "model/tokens",
                embed_op: "model/token_embeds",
            },
        );
        op_names.insert(
            Layer::Tag,
            LayerOp::Embedding {
                op: "model/tags",
                embed_op: "model/tag_embeds",
            },
        );
        op_names.insert(
            Layer::DepRel,
            LayerOp::Table {
                op: "model/deprels",
            },
        );
        op_names.insert(
            Layer::Feature,
            LayerOp::Table {
                op: "model/features",
            },
        );
        op_names.insert(
            Layer::Char,
            LayerOp::Embedding {
                op: "model/chars",
                embed_op: "model/char_embeds",
            },
        );

        TensorflowModel::load_graph(&[], &data, system, vectorizer, &op_names)
            .expect("Cannot load graph.");
    }
```


Overlapping Code:
```
 f = File::open("testdata/parser.graph.gz").expect("Cannot open test graph.");
let mut decoder = GzDecoder::new(BufReader::new(f));
let mut data = Vec::new();
decoder
.read_to_end(&mut data)
.expect("Cannot decompress test graph.");
let system = StackProjectiveSystem::new();
let vectorizer = InputVectorizer::new(
LayerLookups::new(),
AddressedValues(Vec::new()),
HashMap::new(),
Vec::new()
);
let mut op_names = LayerOps::new();
op_names.insert(
Layer::Token,
LayerOp::Embedding {
op: "model/tokens",
embed_op: "model/token_embeds",
},
);
op_names.insert(
Layer::Tag,
LayerOp::Embedding {
op: "model/tags",
embed_op: "model/tag_embeds",
},
);
op_names.insert(
Layer::DepRel,
LayerOp::Table {
op: "model/deprels",
},
);
op_names.insert(
Layer::Feature,
LayerOp::Table {
op: "model/features",
},
);
op_names.insert(
Layer::Char,
LayerOp::Embedding {
op: "model/chars",
embed_op: "model/char_embeds",
},
);
TensorflowModel::load_graph(&[], &data, system, vectorizer, &op_names)
.
```
<Overlap Ratio: 0.9449275362318841>

---

--- 107 --
Question ID: b15cb133f18ab2b10e59882e4af5ced68b32f928_0
Original Code:
```
fn parse_align() {
        assert_eq!(Align::parse("auto"), Ok(Align::Auto));
        //assert_eq!(Align::parse("start"), Ok(Align::Start));

        assert_eq!(Align::parse("flex-start"), Ok(Align::FlexStart));
        assert_eq!(Align::parse("center"), Ok(Align::Center));
        //assert_eq!(Align::parse("end"), Ok(Align::End));

        assert_eq!(Align::parse("flex-end"), Ok(Align::FlexEnd));
        assert_eq!(Align::parse("stretch"), Ok(Align::Stretch));
        assert_eq!(Align::parse("baseline"), Ok(Align::Baseline));
        assert_eq!(Align::parse("space-between"), Ok(Align::SpaceBetween));
        assert_eq!(Align::parse("space-around"), Ok(Align::SpaceAround));
        //assert_eq!(Align::parse("space-evenly"), Ok(Align::SpaceEvenly));
    }
```


Overlapping Code:
```
align() {
assert_eq!(Align::parse("auto"), Ok(Align::Auto));
//assert_eq!(Align::parse("start"), Ok(Align::Start));
assert_eq!(Align::parse("flex-start"), Ok(Align::FlexStart));
assert_eq!(Align::parse("center"), Ok(Align::Center));
//assert_eq!(Align::parse("end"), Ok(Align::End));
assert_eq!(Align::parse("flex-end"), Ok(Align::FlexEnd));
assert_eq!(Align::parse("stretch"), Ok(Align::Stretch));
assert_eq!(Align::parse("baseline"), Ok(Align::Baseline));
assert_eq!(Align::parse("space-between"), Ok(Align::SpaceBetween));
assert_eq!(Align::parse("space-around"), Ok(Align::SpaceAround));
//assert_eq!(Align::parse("space-evenly"), Ok(Align::Space
```
<Overlap Ratio: 0.9701492537313433>

---

--- 108 --
Question ID: 3fde9932d414d213fcba06a5184b8dd1a357c5e7_0
Original Code:
```
fn test_function_directory() {
    let formatter = Formatter::new();
    // tests with functions
    {
        let test_metadata = test::MetadataProvider::new(HashMap::new());
        {
            let expression = formatter
                .parser()
                .parse("$directory('/home/test/Music/hello world.mp3')")
                .unwrap();
            let s = expression.apply(&test_metadata);
            assert_eq!("Music", s.to_string().as_str());
        }
        {
            let expression = formatter
                .parser()
                .parse("$directory('/home/test/Music/hello world.mp3', 1)")
                .unwrap();
            let s = expression.apply(&test_metadata);
            assert_eq!("test", s.to_string().as_str());
        }
        {
            let expression = formatter
                .parser()
                .parse("$directory('/home/test/Music/hello world.mp3', 2)")
                .unwrap();
            let s = expression.apply(&test_metadata);
            assert_eq!("home", s.to_string().as_str());
        }
        {
            let expression = formatter
                .parser()
                .parse("$directory('/home/test/Music/hello world.mp3', 5)")
                .unwrap();
            let s = expression.apply(&test_metadata);
            assert_eq!("", s.to_string().as_str());
        }
    }
}
```


Overlapping Code:
```
 test_function_directory() {
let formatter = Formatter::new();
// tests with functions
{
let test_metadata = test::MetadataProvider::new(HashMap::new());
{
let expression = formatter
.parser()
.parse("$directory('/home/test/Music/hello world.mp3')")
.unwrap();
let s = expression.apply(&test_metadata);
assert_eq!("Music", s.to_string().as_str());
}
{
let expression = formatter
.parser()
.parse("$directory('/home/test/Music/hello world.mp3', 1)")
.unwrap();
let s = expression.apply(&test_metadata);
assert_eq!("test", s.to_string().as_str());
}
{
let expression = formatter
.parser()
.parse("$directory('/home/test/Music/hello world.mp3', 2)")
.unwrap();
let s = expression.apply(&test_metadata);
assert_eq!("home", s.to_string().as_str());
}
{
let expression = formatter
.parser()
.parse("$directory('/home/test/Music/hello world.mp3', 5)")
.unwrap();
let s = expression.apply(&test_metadata);
assert_eq!("", s.to_string().as_str());
}

```
<Overlap Ratio: 0.9947089947089947>

---

--- 109 --
Question ID: eafee5552fec09ab40e3dc80effd66bf763c7af4_0
Original Code:
```
fn test_origin() {
        let r: Raw = vec![b"http://foo.com".to_vec()].into();
        let origin : Origin = Header::parse_header(&r).unwrap();
        assert_eq!(&origin, &Origin::new("http", "foo.com", None));
        assert_borrowed!(origin.scheme().unwrap().into());

        let r: Raw = vec![b"https://foo.com:443".to_vec()].into();
        let origin : Origin = Header::parse_header(&r).unwrap();
        assert_eq!(&origin, &Origin::new("https", "foo.com", Some(443)));
        assert_borrowed!(origin.scheme().unwrap().into());
    }
```


Overlapping Code:
```
o.com".to_vec()].into();
let origin : Origin = Header::parse_header(&r).unwrap();
assert_eq!(&origin, &Origin::new("http", "foo.com", None));
assert_borrowed!(origin.scheme().unwrap().into());
let r: Raw = vec![b"https://foo.com:443".to_vec()].into();
let origin : Origin = Header::parse_header(&r).unwrap();
assert_eq!(&origin, &Origin::new("https", "foo.com", Some(443)));
assert_borrowed!(origin.s
```
<Overlap Ratio: 0.8421052631578947>

---

--- 110 --
Question ID: fab26e2a226a61ed3ccd6449a05f8250e59f797b_4
Original Code:
```
fn test_extract_surveydata() {
    let str = "Survey data from wlan0
    frequency:            2412 MHz
Survey data from wlan0
    frequency:            2417 MHz
Survey data from wlan0
    frequency:            2422 MHz
Survey data from wlan0
    frequency:            2427 MHz
Survey data from wlan0
    frequency:            2432 MHz
Survey data from wlan0
    frequency:            2437 MHz
Survey data from wlan0
    frequency:            2442 MHz
Survey data from wlan0
    frequency:            2447 MHz
Survey data from wlan0
    frequency:            2452 MHz
Survey data from wlan0
    frequency:            2457 MHz
Survey data from wlan0
    frequency:            2462 MHz [in use]
    noise:                -102 dBm
    channel active time:        4172127 ms
    channel busy time:        828107 ms
    channel receive time:        1448 ms
    channel transmit time:        20225 ms
Survey data from wlan0
    frequency:            24062 MHz [in use]
    noise:                -1002 dBm
    channel active time:        5127 ms
    channel busy time:        5 ms
    channel receive time:        5 ms
    channel transmit time:        5 ms";

    let ret = extract_wifi_survey_data(str, "wlan0");

    println!("{:?}", ret);
}
```


Overlapping Code:
```
surveydata() {
let str = "Survey data from wlan0
frequency: 2412 MHz
Survey data from wlan0
frequency: 2417 MHz
Survey data from wlan0
frequency: 2422 MHz
Survey data from wlan0
frequency: 2427 MHz
Survey data from wlan0
frequency: 2432 MHz
Survey data from wlan0
frequency: 2437 MHz
Survey data from wlan0
frequency: 2442 MHz
Survey data from wlan0
frequency: 2447 MHz
Survey data from wlan0
frequency: 2452 MHz
Survey data from wlan0
frequency: 2457 MHz
Survey data from wlan0
frequency: 2462 MHz [in use]
noise: -102 dBm
channel active time: 4172127 ms
channel busy time: 828107 ms
channel receive time: 1448 ms
channel transmit time: 20225 ms
Survey data from wlan0
frequency: 24062 MHz [in use]
noise: -1002 dBm
channel active time: 5127 ms
channel busy time: 5 ms
channel receive time: 5 ms
channel transmit time: 5 ms";
let ret = extract_wifi_survey_data(str, "wlan0");
println!("{:?}", ret);

```
<Overlap Ratio: 0.9814612868047983>

---

--- 111 --
Question ID: cf3e338740762f28621308c6cfbf7ad647da243d_6
Original Code:
```
unsafe extern "C" fn notify_domain_trampoline<P>(this: *mut ffi::GMountOperation, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<MountOperation> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&MountOperation::from_glib_borrow(this).downcast_unchecked())
}
```


Overlapping Code:
```
" fn notify_domain_trampoline<P>(this: *mut ffi::GMountOperation, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)
where P: IsA<MountOperation> {
callback_guard!();
let f: &&(Fn(&P) + 'static) = transmute(f);
f(&MountOperation::from_glib_borrow(this).downcast_unchecked())
}
```
<Overlap Ratio: 0.9461279461279462>

---

--- 112 --
Question ID: 000b92362b685d3dc681038680bd5f4b70ad0463_0
Original Code:
```
fn assert_contracts() {
        let (_, _r) = crate::unbounded::<i32>(Duration::from_millis(100));

        assert_send::<Receiver<i32>>();
        assert_sync::<Receiver<i32>>();
    }
```


Overlapping Code:
```
crate::unbounded::<i32>(Duration::from_millis(100));
assert_send::<Receiver<i32>>();
assert_sync::<R
```
<Overlap Ratio: 0.6410256410256411>

---

--- 113 --
Question ID: fa07feab815556d8b81911272007935b4eed7a7c_1
Original Code:
```
fn pack_sorted(rectangles: &[PackInput], options: &PackOptions) -> Vec<Bin> {
  let mut bins: Vec<Bin> = vec![new_bin(options)];
  let insert_fn: &'static Fn(&mut Bin, &Dimension, u32, &PackOptions) -> bool =
    if options.atlas_compact_steps == 0 { &try_insert } else { &try_insert_with_growth };

  for &input in rectangles {
    let packed = bins.iter_mut().any(|bin| insert_fn(bin, &input.dim, input.id, options));
    if !packed {
      let mut new_bin = new_bin(options);
      new_bin.insert(&input.dim, input.id, options.flipping);
      bins.push(new_bin);
    }
  }
  bins
}
```


Overlapping Code:
```
fn pack_sorted(rectangles: &[PackInput], options: &PackOptions) -> Vec<Bin> {
let mut bins: Vec<Bin> = vec![new_bin(options)];
let insert_fn: &'static Fn(&mut Bin, &Dimension, u32, &PackOptions) -> bool =
if options.atlas_compact_steps == 0 { &try_insert } else { &try_insert_with_growth };
for &input in rectangles {
let packed = bins.iter_mut().any(|bin| insert_fn(bin, &input.dim, input.id, options));
if !packed {
let mut new_bin = new_bin(options);
new_bin.insert(&input.dim, input.id, options.f
```
<Overlap Ratio: 0.9259259259259259>

---

--- 114 --
Question ID: f4f4547468a8f440cc427f66c3b41987d275b23b_1
Original Code:
```
fn create_colormap() {
        // We will make a vector. This is in R, G, B, A order.
        // We will make it with linearly ramping R, 255 A, and 0 elsewhere.
        let rgba_map = linear_ramp_cmap();
        let _cm = Colormap::new(rgba_map);
        // Test that our pixels are in the right order.
        for (i, rgba) in _cm.table.iter().enumerate() {
            assert_eq!(i as u8, rgba.red);
            assert_eq!(0, rgba.green);
            assert_eq!(0, rgba.blue);
            assert_eq!(255, rgba.alpha);
        }
    }
```


Overlapping Code:
```
 will make a vector. This is in R, G, B, A order.
// We will make it with linearly ramping R, 255 A, and 0 elsewhere.
let rgba_map = linear_ramp_cmap();
let _cm = Colormap::new(rgba_map);
// Test that our pixels are in the right order.
for (i, rgba) in _cm.table.iter().enumerate() {
assert_eq!(i as u8, rgba.red);
assert_eq!(0, rgba.green);
assert_eq!(0, rgba.blue);
assert_eq!(255, rgba.alpha);
}
}
```
<Overlap Ratio: 0.9345794392523364>

---

--- 115 --
Question ID: db5258f2c3fd0077c3c83991672dc06fb4c06544_3
Original Code:
```
fn parse_toplevel<T>(ctx: &mut Context, tokens: &mut Peekable<T>) -> Result<Option<Ast>>
where
    T: Iterator<Item = Token>,
{
    debug!("parse_toplevel --");

    let (ty, mut loc) = consume_type_name(tokens)?;
    let mut ty = ty.into();
    while let Some(TokenKind::Asterisk) = tokens.peek().map(|token| &token.value) {
        loc = loc.merge(&consume(tokens, TokenKind::Asterisk)?);
        ty = Type::ptr(ty);
    }
    let (name, ident_loc) = consume_ident(tokens)?;
    loc = loc.merge(&ident_loc);

    let ret = if let Some(TokenKind::LParen) = tokens.peek().map(|token| &token.value) {
        // function

        ctx.env.create_scope();
        let mut args = Vec::new();

        consume(tokens, TokenKind::LParen)?;
        loop {
            if let Some(TokenKind::RParen) = tokens.peek().map(|token| &token.value) {
                break;
            }
            if args.len() > 0 {
                consume(tokens, TokenKind::Comma)?;
            }
            let (type_name, _) = consume_type_name(tokens)?;
            // TODO: support default arguments
            let (_assign, arg, ty, d_loc) = parse_declarator(ctx, tokens, type_name.into())?;
            let ty = match ty {
                Type::Array(ty, _len) => Type::Ptr(ty),
                _ => ty,
            };
            let var = Var {
                name: arg.clone(),
                ty,
                is_local: true,
            };
            args.push(var.clone());
            if ctx.add_lvar(var).is_some() {
                return Err(ParseError::Redefinition(Token::ident(&arg, d_loc)));
            }
        }
        loc = loc.merge(&consume(tokens, TokenKind::RParen)?);

        match ctx.add_func(&name, ty.clone()) {
            Some(ret_ty) => {
                if ty != ret_ty {
                    return Err(ParseError::ConflictingTypes(Token::ident(
                        &name,
                        loc.clone(),
                    )));
                }
                // TODO: check duplicate declaration
            }
            None => {}
        };

        let ret = match tokens.peek().map(|token| &token.value) {
            Some(TokenKind::Semicolon) => {
                tokens.next().unwrap();
                Ok(None)
            }
            _ => {
                let block = parse_block(ctx, tokens)?;
                loc = loc.merge(&block.loc);
                let lvars = ctx.lvars.take().unwrap_or_else(|| HashMap::new());
                Ok(Some(Ast::func(name, args, lvars, ty, block, loc)))
            }
        };
        ctx.env.pop_scope();
        ret
    } else {
        // global var

        let (ty, _loc) = read_array(tokens, ty)?;
        consume(tokens, TokenKind::Semicolon)?;

        let var = Var {
            name: name,
            ty,
            is_local: false,
        };
        ctx.add_gvar(var);

        Ok(None)
    };

    debug!("parse_toplevel: {:?}", ret);
    ret
}
```


Overlapping Code:
```
x: &mut Context, tokens: &mut Peekable<T>) -> Result<Option<Ast>>
where
T: Iterator<Item = Token>,
{
debug!("parse_toplevel --");
let (ty, mut loc) = consume_type_name(tokens)?;
let mut ty = ty.into();
while let Some(TokenKind::Asterisk) = tokens.peek().map(|token| &token.value) {
loc = loc.merge(&consume(tokens, TokenKind::Asterisk)?);
ty = Type::ptr(ty);
}
let (name, ident_loc) = consume_ident(tokens)?;
loc = loc.merge(&ident_loc);
let ret = if let Some(TokenKind::LParen) = tokens.peek().map(|token| &token.value) {
// function
ctx.env.create_scope();
let mut args = Vec::new();
consume(tokens, TokenKind::LParen)?;
loop {
if let Some(TokenKind::RParen) = tokens.peek().map(|token| &token.value) {
break;
}
if args.len() > 0 {
consume(tokens, TokenKind::Comma)?;
}
let (type_name, _) = consume_type_name(tokens)?;
// TODO: support default arguments
let (_assign, arg, ty, d_loc) = parse_declarator(ctx, tokens, type_name.into())?;
let ty = match ty {
Type::Array(ty, _len) => Type::Ptr(ty),
_ => ty,
};
let var = Var {
name: arg.clone(),
ty,
is_local: true,
};
args.push(var.clone());
if ctx.add_lvar(var).is_some() {
return Err(ParseError::Redefinition(Token::ident(&arg, d_loc)));
}
}
loc = loc.merge(&consume(tokens, TokenKind::RParen)?);
match ctx.add_func(&name, ty.clone()) {
Some(ret_ty) => {
if ty != ret_ty {
return Err(ParseError::ConflictingTypes(Token::ident(
&name,
loc.clone(),
)));
}
// TODO: check duplicate declaration
}
None => {}
};
let ret = match tokens.peek().map(|token| &token.value) {
Some(TokenKind::Semicolon) => {
tokens.next().unwrap();
Ok(None)
}
_ => {
let block = parse_block(ctx, tokens)?;
loc = loc.merge(&block.loc);
let lvars = ctx.lvars.take().unwrap_or_else(|
```
<Overlap Ratio: 0.9676320272572402>

---

--- 116 --
Question ID: ad84b11866a7b759ac492cdb7ce138623325404c_26
Original Code:
```
pub unsafe extern "C" fn wlr_xdg_toplevel_v6_set_resizing(mut surface:
                                                              *mut wlr_xdg_surface_v6,
                                                          mut resizing: bool)
 -> uint32_t {
    if (*surface).role as libc::c_uint ==
           WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(b"surface->role == WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/xdg_shell_v6/wlr_xdg_toplevel_v6.c\x00" as
                          *const u8 as *const libc::c_char,
                      532i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 78],
                                                &[libc::c_char; 78]>(b"uint32_t wlr_xdg_toplevel_v6_set_resizing(struct wlr_xdg_surface_v6 *, _Bool)\x00")).as_ptr());
    };
    (*(*surface).c2rust_unnamed.toplevel).server_pending.resizing = resizing;
    return schedule_xdg_surface_v6_configure(surface);
}
```


Overlapping Code:
```
r_xdg_toplevel_v6_set_resizing(mut surface:
*mut wlr_xdg_surface_v6,
mut resizing: bool)
-> uint32_t {
if (*surface).role as libc::c_uint ==
WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL as libc::c_int as libc::c_uint {
} else {
__assert_fail(b"surface->role == WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL\x00"
as *const u8 as *const libc::c_char,
b"../types/xdg_shell_v6/wlr_xdg_toplevel_v6.c\x00" as
*const u8 as *const libc::c_char,
532i32 as libc::c_uint,
(*::std::mem::transmute::<&[u8; 78],
&[libc::c_char; 78]>(b"uint32_t wlr_xdg_toplevel_v6_set_resizing(struct wlr_xdg_surface_v6 *, _Bool)\x00")).as_ptr());
};
(*(*surface).c2rust_unnamed.toplevel).server_pending.resizing = resizing;
return schedule_xdg_surface_v6_
```
<Overlap Ratio: 0.9358288770053476>

---

--- 117 --
Question ID: e611f1ab455078c81fca0e23255d860706740bd3_0
Original Code:
```
fn main() {
    env_logger::init();

    let args: Vec<_> = env::args().collect();
    
    if args.len() != 2 { // main.rs INPUT_FILE
        println!("Wrong number of arguments!");
        println!("Format: INPUT_FILE");

        process::abort();
    }

    let in_file = &args[1];

    let program = fs::read_to_string(in_file).expect("Failed to read input file");

    let mut computer: Computer = Computer::new();
    computer = computer.read_program(program);

    while !computer.is_stopped() {
        computer = computer.cycle();
    }
}
```


Overlapping Code:
```
main() {
env_logger::init();
let args: Vec<_> = env::args().collect();

if args.len() != 2 { // main.rs INPUT_FILE
println!("Wrong number of arguments!");
println!("Format: INPUT_FILE");
process::abort();
}
let in_file = &args[1];
let program = fs::read_to_string(in_file).expect("Failed to read input file");
let mut computer: Computer = Computer::new();
computer = computer.read_program(program);
while !computer.is_stopped() {
computer = computer.cycle();
}
```
<Overlap Ratio: 0.989247311827957>

---

--- 118 --
Question ID: eeb9ebd9e83e5060cf92d257badc608ec4e98992_0
Original Code:
```
fn get_precision(qualifiers: &Option<syntax::TypeQualifier>) -> Option<PrecisionQualifier>{
    let mut precision = None;
    for qual in qualifiers.iter().flat_map(|x| x.qualifiers.0.iter()) {
        match qual {
            syntax::TypeQualifierSpec::Precision(p) => {
                if precision.is_some() {
                    panic!("Multiple precisions");
                }
                precision = Some(p.clone());
            }
            _ => {}
        }
    }
    precision
}
```


Overlapping Code:
```
peQualifier>) -> Option<PrecisionQualifier>{
let mut precision = None;
for qual in qualifiers.iter().flat_map(|x| x.qualifiers.0.iter()) {
match qual {
syntax::TypeQualifierSpec::Precision(p) => {
if precision.is_some() {
panic!("Multiple precisions");
}
precision = Some(p.clone());
}
_ => {}
}
}
pr
```
<Overlap Ratio: 0.8426966292134831>

---

--- 119 --
Question ID: 687da4c5b9686d9cf5f2174c50edd696678e64fe_0
Original Code:
```
fn test_entityarray() {
        let data = vec![
            System::builder()
                .location(Point::origin())
                .name("Sol")
                .build(),
            System::builder()
                .location(Point::origin())
                .name("Alpha Centauri")
                .build(),
        ];

        // Test indexing and insert.
        let mut array = EntityArray::new();
        for item in &data {
            let idx = array.insert(item.clone());
            assert_eq!(array[idx], *item);
        }
        assert_eq!(array.len(), data.len());

        // Test iterator.
        for (index, entity) in array.into_iter().enumerate() {
            assert_eq!(entity, data[index]);
        }
    }
```


Overlapping Code:
```
ystem::builder()
.location(Point::origin())
.name("Sol")
.build(),
System::builder()
.location(Point::origin())
.name("Alpha Centauri")
.build(),
];
// Test indexing and insert.
let mut array = EntityArray::new();
for item in &data {
let idx = array.insert(item.clone());
assert_eq!(array[idx], *item);
}
assert_eq!(array.len(), data.len());
// Test iterator.
for (index, entity) in array.into_iter().enumerate() {
assert_eq!(entity, data[index]);
}

```
<Overlap Ratio: 0.9127789046653144>

---

--- 120 --
Question ID: efe145d6a2d9d1af77e27122a4c7ea32df3fcd27_0
Original Code:
```
pub fn fiat_p384_addcarryx_u32(out1: &mut u32, out2: &mut fiat_p384_u1, arg1: fiat_p384_u1, arg2: u32, arg3: u32) -> () {
  let x1: u64 = (((arg1 as u64) + (arg2 as u64)) + (arg3 as u64));
  let x2: u32 = ((x1 & (0xffffffff as u64)) as u32);
  let x3: fiat_p384_u1 = ((x1 >> 32) as fiat_p384_u1);
  *out1 = x2;
  *out2 = x3;
}
```


Overlapping Code:
```
arryx_u32(out1: &mut u32, out2: &mut fiat_p384_u1, arg1: fiat_p384_u1, arg2: u32, arg3: u32) -> () {
let x1: u64 = (((arg1 as u64) + (arg2 as u64)) + (arg3 as u64));
let x2: u32 = ((x1 & (0xffffffff as u64)) as u32);
let x3: fiat_p384_u1 = ((x1 >> 32) as fiat_p384_u1)
```
<Overlap Ratio: 0.8481012658227848>

---

--- 121 --
Question ID: 93c07f610f1c99849ac5975a8746c9b9bf775afe_1
Original Code:
```
fn flags_from_vec(args: Vec<String>) -> DenoFlags {
    let cli_app = create_cli_app();
    let matches = cli_app.get_matches_from(args);
    parse_flags(matches)
  }
```


Overlapping Code:
```
String>) -> DenoFlags {
let cli_app = create_cli_app();
let matches = cli_app.get_matches_from(args)
```
<Overlap Ratio: 0.6578947368421053>

---

--- 122 --
Question ID: eeea6b71e888e2b308ff376f4e25e5a3658e27dd_10
Original Code:
```
fn test_eigen_left_eigenvectors() {
        let (m, n) = (6, 8);
        let a = Matrix::randsn(m, n);
        let b = a.t() * a;

        eigen_test_driver(b, EigenOptions::LeftEigenvectorsOnly).unwrap();
    }
```


Overlapping Code:
```
) {
let (m, n) = (6, 8);
let a = Matrix::randsn(m, n);
let b = a.t() * a;
eigen_test_driver(b, Eigen
```
<Overlap Ratio: 0.5747126436781609>

---

--- 123 --
Question ID: 25153499df4821da586a8505bd3fa879ea84ea20_5
Original Code:
```
fn test_push() {
        let mut heap = Heap::new();
        heap.push(-2);
        heap.push(-4);
        heap.push(-9);
        assert!(*heap.peek().unwrap() == -9);
        heap.push(-11);
        assert!(*heap.peek().unwrap() == -11);
        heap.push(-5);
        assert!(*heap.peek().unwrap() == -11);
        heap.push(-27);
        assert!(*heap.peek().unwrap() == -27);
        heap.push(-3);
        assert!(*heap.peek().unwrap() == -27);
        heap.push(-103);
        assert!(*heap.peek().unwrap() == -103);
    }
```


Overlapping Code:
```
 mut heap = Heap::new();
heap.push(-2);
heap.push(-4);
heap.push(-9);
assert!(*heap.peek().unwrap() == -9);
heap.push(-11);
assert!(*heap.peek().unwrap() == -11);
heap.push(-5);
assert!(*heap.peek().unwrap() == -11);
heap.push(-27);
assert!(*heap.peek().unwrap() == -27);
heap.push(-3);
assert!(*heap.peek().unwrap() == -27);
heap.push(-103);
assert!(*heap.peek().unwrap() == 
```
<Overlap Ratio: 0.9306930693069307>

---

--- 124 --
Question ID: e8f1df1fcc4fb8ee3fe36c57f9e8adb3b0f8dca4_1
Original Code:
```
pub(crate) fn write(path: &Path, contents: TokenStream) -> Result<()> {
    let mut out = header().into_bytes();
    out.extend_from_slice(prettyplease::unparse(&syn::parse2(contents).unwrap()).as_bytes());
    if path.is_file() && fs::read(&path)? == out {
        return Ok(());
    }
    fs::write(path, out)?;
    Ok(())
}
```


Overlapping Code:
```
b(crate) fn write(path: &Path, contents: TokenStream) -> Result<()> {
let mut out = header().into_bytes();
out.extend_from_slice(prettyplease::unparse(&syn::parse2(contents).unwrap()).as_bytes());
if path.is_file() && fs::read(&path)? == out {
return Ok(());
}
fs::write(path, out)?;
Ok(())
}
```
<Overlap Ratio: 0.9931972789115646>

---

--- 125 --
Question ID: 6a6683404adcff3d9c623ffb7de7de2d2e2629fd_5
Original Code:
```
pub fn test_display_formatting_precision() {
    let our_matrix = matrix![1.2, 1.23, 1.234;
                             1.2345, 1.23456, 1.234567];
    let expectations = vec!["⎡1.2 1.2 1.2⎤\n⎣1.2 1.2 1.2⎦",

                            "⎡1.20 1.23 1.23⎤\n⎣1.23 1.23 1.23⎦",

                            "⎡1.200 1.230 1.234⎤\n⎣1.234 1.235 1.235⎦",

                            "⎡1.2000 1.2300 1.2340⎤\n⎣1.2345 1.2346 1.2346⎦"];

    for (places, &expectation) in (1..5).zip(expectations.iter()) {
        assert_eq!(expectation, format!("{:.1$}", our_matrix, places));
    }
}
```


Overlapping Code:
```
ting_precision() {
let our_matrix = matrix![1.2, 1.23, 1.234;
1.2345, 1.23456, 1.234567];
let expectations = vec!["⎡1.2 1.2 1.2⎤\n⎣1.2 1.2 1.2⎦",
"⎡1.20 1.23 1.23⎤\n⎣1.23 1.23 1.23⎦",
"⎡1.200 1.230 1.234⎤\n⎣1.234 1.235 1.235⎦",
"⎡1.2000 1.2300 1.2340⎤\n⎣1.2345 1.2346 1.2346⎦"];
for (places, &expectation) in (1..5).zip(expectations.iter()) {
assert_eq!(expectation, format!("{:.1$}", our_matrix, places))
```
<Overlap Ratio: 0.9288990825688074>

---

--- 126 --
Question ID: 918f2eeb9cbd57c26e281ee6f0c9b936907401cc_0
Original Code:
```
pub extern "C" fn call() {
    let contract_key: Key = contract_api::get_uref("hello_ext")
        .unwrap_or_else(|| contract_api::revert(Error::HelloExtNotFound as u32));
    let contract_pointer: ContractPointer = match contract_key {
        Key::Hash(hash) => ContractPointer::Hash(hash),
        _ => contract_api::revert(Error::InvalidURef as u32),
    };

    let extra_urefs = [].to_vec();

    let result: URef = contract_api::call_contract(contract_pointer, &(), &extra_urefs);

    let value: String = contract_api::read(TURef::from_uref(result).unwrap());

    assert_eq!("Hello, world!", &value);
}
```


Overlapping Code:
```
fn call() {
let contract_key: Key = contract_api::get_uref("hello_ext")
.unwrap_or_else(|| contract_api::revert(Error::HelloExtNotFound as u32));
let contract_pointer: ContractPointer = match contract_key {
Key::Hash(hash) => ContractPointer::Hash(hash),
_ => contract_api::revert(Error::InvalidURef as u32),
};
let extra_urefs = [].to_vec();
let result: URef = contract_api::call_contract(contract_pointer, &(), &extra_urefs);
let value: String = contract_api::read(TURef::from_uref(result).unwrap()
```
<Overlap Ratio: 0.8992805755395683>

---

--- 127 --
Question ID: a093d1ae8fc9854446f95a48e277505f7c83482c_5
Original Code:
```
fn test_scan() {
        let table_id = 1;
        let pk = table::encode_row_key(table_id, b"key1");
        let pv = b"value1";
        let test_data = vec![
            (pk.clone(), pv.to_vec()),
            (table::encode_row_key(table_id, b"key2"), b"value2".to_vec()),
        ];
        let mut statistics = Statistics::default();
        let mut test_store = TestStore::new(&test_data);
        let (snapshot, start_ts) = test_store.get_snapshot();
        let store = SnapshotStore::new(snapshot, start_ts, IsolationLevel::SI, true);
        let mut scanner = Scanner::new(store, false, false, &mut statistics);
        let range = get_range(table_id, i64::MIN, i64::MAX);
        for &(ref k, ref v) in &test_data {
            let (key, value) = scanner.next_row(&range).unwrap().unwrap();
            let seek_key = prefix_next(&key);
            scanner.set_seek_key(Some(seek_key));
            assert_eq!(*k, key);
            assert_eq!(*v, value);
        }
        assert!(scanner.next_row(&range).unwrap().is_none());
    }
```


Overlapping Code:
```
n test_scan() {
let table_id = 1;
let pk = table::encode_row_key(table_id, b"key1");
let pv = b"value1";
let test_data = vec![
(pk.clone(), pv.to_vec()),
(table::encode_row_key(table_id, b"key2"), b"value2".to_vec()),
];
let mut statistics = Statistics::default();
let mut test_store = TestStore::new(&test_data);
let (snapshot, start_ts) = test_store.get_snapshot();
let store = SnapshotStore::new(snapshot, start_ts, IsolationLevel::SI, true);
let mut scanner = Scanner::new(store, false, false, &mut statistics);
let range = get_range(table_id, i64::MIN, i64::MAX);
for &(ref k, ref v) in &test_data {
let (key, value) = scanner.next_row(&range).unwrap().unwrap();
let seek_key = prefix_next(&key);
scanner.set_seek_key(Some(seek_key));
assert_eq!(*k, key);
assert_eq!(*v, value);
}
assert!(scanner.next_row(&ra
```
<Overlap Ratio: 0.9667458432304038>

---

--- 128 --
Question ID: 3cb4507dc281365e2ae4798fce6f9bfcdbaa2731_0
Original Code:
```
fn main() -> AocResult<()> {
    let input = fs::read_to_string("input.txt")?;
    let lines: Vec<&str> = input.lines().collect();
    let wire1 = Wire::new(lines[0])?;
    let wire2 = Wire::new(lines[1])?;
    println!("{:?}", solve(&wire1, &wire2)?);
    Ok(())
}
```


Overlapping Code:
```
n main() -> AocResult<()> {
let input = fs::read_to_string("input.txt")?;
let lines: Vec<&str> = input.lines().collect();
let wire1 = Wire::new(lines[0])?;
let wire2 = Wire::new(lines[1])?;
println!("{:?}", solve(&wi
```
<Overlap Ratio: 0.8962655601659751>

---

--- 129 --
Question ID: 43968cb5bf5aa2079bf3e4a0ebebb609aa6819f7_0
Original Code:
```
fn test_rotate_with_wallkick() {
        let field = Field::new();
        let mut block = Block::new(block::Id::S, &field);
        let wk = wallkick::SRS::new();

        block.shift(&field, Direction::Down);

        // Non-reference `wk` is slightly annoying.
        block.rotate_with_wallkick(&field, wk, Rotation::R90);
    }
```


Overlapping Code:
```
rotate_with_wallkick() {
let field = Field::new();
let mut block = Block::new(block::Id::S, &field);
let wk = wallkick::SRS::new();
block.shift(&field, Direction::Down);
// Non-reference `wk` is slightly annoying.
block.rotate_with_wallkick(&field, w
```
<Overlap Ratio: 0.8992805755395683>

---

--- 130 --
Question ID: 52855b44587cc0959d108f7862ad0b3b277606e9_0
Original Code:
```
fn nop() {
    let uni_orig = universe();
    let (mut memory, mut ports, mut registers, mut pc, mut sp, mut adr, mut ins) = universe();
    let mut stack = vec![];

    assert_eq!(MicroOp::Nop.perform(&mut stack, &mut memory, &mut ports, &mut registers, &mut pc, &mut sp, &mut adr, &mut ins),
               Ok(true));

    assert_eq!((memory, ports, registers, pc, sp, adr, ins), uni_orig);

    assert_eq!(stack, vec![]);
}
```


Overlapping Code:
```
 {
let uni_orig = universe();
let (mut memory, mut ports, mut registers, mut pc, mut sp, mut adr, mut ins) = universe();
let mut stack = vec![];
assert_eq!(MicroOp::Nop.perform(&mut stack, &mut memory, &mut ports, &mut registers, &mut pc, &mut sp, &mut adr, &mut ins),
Ok(true));
assert_eq!((memory, ports, registers, pc, sp, adr, ins), uni_orig);
assert_eq!(sta
```
<Overlap Ratio: 0.9427083333333334>

---

--- 131 --
Question ID: 72a5da63e57c036abb84e0762d6a85bef40559a3_4
Original Code:
```
pub fn find_char_3(b: &mut Bencher) {
    let haystack = black_box(LONG);
    let needle = black_box('α');
    b.iter(|| {
        let t = haystack.find(needle);
        t
    });
    b.bytes = haystack.len() as u64;
}
```


Overlapping Code:
```
r) {
let haystack = black_box(LONG);
let needle = black_box('α');
b.iter(|| {
let t = haystack.find(needle);
t
});
b
```
<Overlap Ratio: 0.6373626373626373>

---

--- 132 --
Question ID: 23346562ba02b4c39ebc9fff19ce56e065849f7f_1
Original Code:
```
unsafe fn unalign_slice(slice: &mut [u8]) -> &mut [u8] {
    let ptr = slice.as_mut_ptr();
    let offset_buffer = core::slice::from_raw_parts(ptr.offset(-2), 2);
    let offset = read_u16(offset_buffer);
    let orig_ptr = ptr.offset(-(offset as isize));
    core::slice::from_raw_parts_mut(orig_ptr, slice.len() + offset as usize)
}
```


Overlapping Code:
```
nalign_slice(slice: &mut [u8]) -> &mut [u8] {
let ptr = slice.as_mut_ptr();
let offset_buffer = core::slice::from_raw_parts(ptr.offset(-2), 2);
let offset = read_u16(offset_buffer);
let orig_ptr = ptr.offset(-(offset as isize));
core::slice::from_raw_parts_mut(orig_ptr, slice.len() + offset as usize
```
<Overlap Ratio: 0.9554140127388535>

---

--- 133 --
Question ID: 3ea220d29184a0a8e2e8d27279ea0a0f05f6f451_2
Original Code:
```
fn bytecode_xor() {
    let mut state1 = AbstractState::new();
    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));
    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));
    let state2 = common::run_instruction(Bytecode::Xor, state1);
    assert_eq!(
        state2.stack_peek(0),
        Some(AbstractValue::new_primitive(SignatureToken::U64)),
        "stack type postcondition not met"
    );
}
```


Overlapping Code:
```
ode_xor() {
let mut state1 = AbstractState::new();
state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));
state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));
let state2 = common::run_instruction(Bytecode::Xor, state1);
assert_eq!(
state2.stack_peek(0),
Some(AbstractValue::new_primitive(SignatureToken::U64)),
"stack type postcondition not 
```
<Overlap Ratio: 0.9564102564102565>

---

--- 134 --
Question ID: e95801833f5ef16ff1c262b5a4cce30b9469635b_5
Original Code:
```
fn template_decomposition() {
        let title = "";
        let labels: Vec<String> = vec!();
        let body: Option<String> = None;
        let assignee: Option<String> = None;
        let milestone: Option<u64> = None;
        let mut issue = IssueOptions::new(title, body, assignee, milestone, labels);

        populate_metadata(&mut issue, &mut template());

        assert_eq!("Test title", issue.title);
        assert_eq!(vec!["new", "bug"], issue.labels);
        assert_eq!(Some(raw_body()), issue.body);
    }
```


Overlapping Code:
```
"";
let labels: Vec<String> = vec!();
let body: Option<String> = None;
let assignee: Option<String> = None;
let milestone: Option<u64> = None;
let mut issue = IssueOptions::new(title, body, assignee, milestone, labels);
populate_metadata(&mut issue, &mut template());
assert_eq!("Test title", issue.title);
assert_eq!(vec!["new", "bug"], issue.labels
```
<Overlap Ratio: 0.7990867579908676>

---

--- 135 --
Question ID: 9730e4a3c465bb45b9385794979fe4f7291213e6_1
Original Code:
```
pub fn is_prime(x: u128) -> bool {
    if x==2 {
        return true
    }
    let help = integer_sqrt(x);
    if x<2 || x%2==0 {
        false
    } else {
        let mut i: u128 = 3;
        while i<=help {
            if x%i==0 {
                return false
            }
            i = i+2;
        };
        true
    }
}
```


Overlapping Code:
```
fn is_prime(x: u128) -> bool {
if x==2 {
return true
}
let help = integer_sqrt(x);
if x<2 || x%2==0 {
false
} else {
let mut i: u128 = 3;
while i<=help {
if x%i==0 {
return false
}
i = i+2;
};
true
}

```
<Overlap Ratio: 0.975609756097561>

---

--- 136 --
Question ID: 0f71508e0e6f428e625cec06bc478640105e0c30_10
Original Code:
```
fn update_clone_randomly(criterion: &mut Criterion) {
    macro_rules! bench {
        ($n:ident, $rnd:ident) => {
            |vec| {
                let mut vec_1 = vec;
                let mut vec_2 = vec_1.clone();
                let mut vec_3 = vec_2.clone();

                for _ in 0..*$n {
                    vec_3 = vec_1;
                    vec_1 = vec_2;

                    let j = ($rnd.next_u32() as usize) % *$n;
                    (*vec_1.get_mut(j).unwrap()) += 1;

                    vec_2 = vec_1.clone();
                }

                (vec_1, vec_2, vec_3)
            }
        };
    }

    let mut group = criterion.benchmark_group("update_clone_randomly");
    group.plot_config(PlotConfiguration::default().summary_scale(AxisScale::Logarithmic));

    macro_rules! bench_balanced {
        ($name:ident, $p:ident, $new_vec:expr, $push:ident) => {
            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {
                let mut rnd = rnd();

                b.iter_batched(
                    vec_balanced!(n, $new_vec, $push),
                    bench!(n, rnd),
                    SmallInput,
                )
            });
        };
    }

    macro_rules! bench_relaxed {
        ($name:ident, $p:ident, $new_vec:expr, $push:ident, $append:path) => {
            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {
                let mut rnd = rnd();

                b.iter_batched(
                    vec_relaxed!(n, $new_vec, $push, $append),
                    bench!(n, rnd),
                    SmallInput,
                )
            });
        };
    }

    let params = vec![
        20, 40, 60, 80, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000, 20000,
    ];

    for p in params.iter() {
        bench_balanced!(STD_VEC, p, || Vec::new(), push);

        bench_balanced!(IM_RS_VECTOR_BALANCED, p, || IVec::new(), push_back);
        bench_relaxed!(
            IM_RS_VECTOR_RELAXED,
            p,
            || IVec::new(),
            push_back,
            append::ivec
        );

        bench_balanced!(RBVEC, p, || RbVec::new(), push);
        bench_relaxed!(RRBVEC, p, || RrbVec::new(), push, append::rrbvec);

        bench_balanced!(PVEC_STD, p, || PVec::new(), push);
        bench_balanced!(PVEC_RRBVEC_BALANCED, p, || PVec::new_with_tree(), push);
        bench_relaxed!(
            PVEC_RRBVEC_RELAXED,
            p,
            || PVec::new_with_tree(),
            push,
            append::pvec
        );
    }

    group.finish();
}
```


Overlapping Code:
```
criterion: &mut Criterion) {
macro_rules! bench {
($n:ident, $rnd:ident) => {
|vec| {
let mut vec_1 = vec;
let mut vec_2 = vec_1.clone();
let mut vec_3 = vec_2.clone();
for _ in 0..*$n {
vec_3 = vec_1;
vec_1 = vec_2;
let j = ($rnd.next_u32() as usize) % *$n;
(*vec_1.get_mut(j).unwrap()) += 1;
vec_2 = vec_1.clone();
}
(vec_1, vec_2, vec_3)
}
};
}
let mut group = criterion.benchmark_group("update_clone_randomly");
group.plot_config(PlotConfiguration::default().summary_scale(AxisScale::Logarithmic));
macro_rules! bench_balanced {
($name:ident, $p:ident, $new_vec:expr, $push:ident) => {
group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {
let mut rnd = rnd();
b.iter_batched(
vec_balanced!(n, $new_vec, $push),
bench!(n, rnd),
SmallInput,
)
});
};
}
macro_rules! bench_relaxed {
($name:ident, $p:ident, $new_vec:expr, $push:ident, $append:path) => {
group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {
let mut rnd = rnd();
b.iter_batched(
vec_relaxed!(n, $new_vec, $push, $append),
bench!(n, rnd),
SmallInput,
)
});
};
}
let params = vec![
20, 40, 60, 80, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000, 20000,
];
for p in params.iter() {
bench_balanced!(STD_VEC, p, || Vec::new(), push);
bench_balanced!(IM_RS_VECTOR_BALANCED, p, || IVec::new(), push_back);
bench_relaxed!(
IM_RS_VECTOR_RELAXED,
p,
|| IVec::new(),
push_back,
append::ivec
);
bench_balanced!(RBVEC, p, || RbVec::new(), push);
bench_relaxed!(RRBVEC, p, || RrbVec::new(), push, append::rrbvec);
bench_balanced!(PVEC_STD, p, || PVec::new(), push);
bench_balanced!(PVEC_RRBVEC_BALANCED, p, || PVec::new_with_tree(), push);
bench_relaxed!(
PVEC_RRBVEC_RELAXED,
p,
|| PVec::new_with_tree(),

```
<Overlap Ratio: 0.9848925043579314>

---

--- 137 --
Question ID: 655d82be0bf7ebbe15359c10e8e19cc6beaf60ff_7
Original Code:
```
fn keep_inhabited_variant(_self: &syn::Ident, variant: syn::Variant)
    -> Option<(u32, syn::Ident, Vec<syn::Field>, ParsedAttributes)>
{
    use void::IsUninhabited;

    let attrs = parse_attributes(variant.attrs);
    let fields = variant_data_to_fields(variant.data);

    if attrs.skip {
        // We've been ordered to skip this variant!
        // Check that all other attributes are not set.
        ensure_has_only_skip_attr(attrs, error::ENUM_VARIANT);
        fields.into_iter().for_each(|field| {
            let f_attrs = parse_attributes(field.attrs);
            error::if_skip_present(&f_attrs, error::ENUM_VARIANT_FIELD);
            ensure_has_only_skip_attr(f_attrs, error::ENUM_VARIANT_FIELD);
        });

        return None
    }

    // If the variant is uninhabited, we can't generate it, so skip it.
    if (&*fields).is_uninhabited() { return None }

    // Compute the weight:
    let weight = attrs.weight.unwrap_or(1);

    Some((weight, variant.ident, fields, attrs))
}
```


Overlapping Code:
```
ed_variant(_self: &syn::Ident, variant: syn::Variant)
-> Option<(u32, syn::Ident, Vec<syn::Field>, ParsedAttributes)>
{
use void::IsUninhabited;
let attrs = parse_attributes(variant.attrs);
let fields = variant_data_to_fields(variant.data);
if attrs.skip {
// We've been ordered to skip this variant!
// Check that all other attributes are not set.
ensure_has_only_skip_attr(attrs, error::ENUM_VARIANT);
fields.into_iter().for_each(|field| {
let f_attrs = parse_attributes(field.attrs);
error::if_skip_present(&f_attrs, error::ENUM_VARIANT_FIELD);
ensure_has_only_skip_attr(f_attrs, error::ENUM_VARIANT_FIELD);
});
return None
}
// If the variant is uninhabited, we can't generate it, so skip it.
if (&*fields).is_uninhabited() { return None }
// Compute the weight:
let weight = attrs.weight.unwrap_or(1);
Some((weight, variant.ident, fields, attrs)
```
<Overlap Ratio: 0.9792626728110599>

---

--- 138 --
Question ID: f474ebe4ad94cfcaa9b4192a0257bde388ea136f_1
Original Code:
```
fn ego(args: &Vec<String>, cases: &mut BTreeMap<String, Case>) -> Result<i32, TestaError> {
    if args.iter().any(|x| {x == "-h" || x == "--help"}) {
        return Result::Err(TestaError::Help);
    };
    match args.len() {
        2 => {
            let a = &args[1];
            if a == "--show-cases" {
                for x in cases.keys() {
                    println!("{}", x);
                }
            } else {
                match cases.remove(a) {
                    None => {
                        return Result::Err(TestaError::ArgsError(
                            std::fmt::format(format_args!("unknown arg: {}", a))))
                    },
                    Some(c) => {
                        if let Some(msg) = c() {
                            return Result::Err(TestaError::CaseFail(msg));
                        }
                    }
                }
            }
        },
        _ => {
            return Result::Err(TestaError::ArgsError("want exactly one arg".to_owned()));
        }
    };
    Ok(0)
}
```


Overlapping Code:
```
ap<String, Case>) -> Result<i32, TestaError> {
if args.iter().any(|x| {x == "-h" || x == "--help"}) {
return Result::Err(TestaError::Help);
};
match args.len() {
2 => {
let a = &args[1];
if a == "--show-cases" {
for x in cases.keys() {
println!("{}", x);
}
} else {
match cases.remove(a) {
None => {
return Result::Err(TestaError::ArgsError(
std::fmt::format(format_args!("unknown arg: {}", a))))
},
Some(c) => {
if let Some(msg) = c() {
return Result::Err(TestaError::CaseFail(msg));
}
}
}
}
},
_ => {
return Result::Err(TestaError::ArgsError("want 
```
<Overlap Ratio: 0.8620689655172413>

---

--- 139 --
Question ID: a5201ec3af959eda63b49a7592dd407ddd518af6_0
Original Code:
```
fn get_and_notify(
    cache: &Cache,
    installation_allowed: bool,
    name: &str,
    url: &str,
) -> Result<Option<PathBuf>, failure::Error> {
    if let Some(dl) = cache.download(false, name, &[name], &url)? {
        return Ok(Some(dl.binary(name)?));
    }
    if installation_allowed {
        PBAR.info(&format!("Getting {}...", name));
    }
    match cache.download(installation_allowed, name, &[name], &url)? {
        Some(dl) => Ok(Some(dl.binary(name)?)),
        None => Ok(None),
    }
}
```


Overlapping Code:
```
ache: &Cache,
installation_allowed: bool,
name: &str,
url: &str,
) -> Result<Option<PathBuf>, failure::Error> {
if let Some(dl) = cache.download(false, name, &[name], &url)? {
return Ok(Some(dl.binary(name)?));
}
if installation_allowed {
PBAR.info(&format!("Getting {}...", name));
}
match cache.download(installation_allowed, name, &[name], &url)? {
Some(dl) => Ok(Some(dl.binary(name)?)),
None => 
```
<Overlap Ratio: 0.9237875288683602>

---

--- 140 --
Question ID: c69be8ce7ea790a7130a3a0e58140a8bb5541808_5
Original Code:
```
fn future_set_is_updated_to_none_when_no_migration_is_required() {
		let node_id = Default::default();
		let address1 = "127.0.0.1:12000".parse().unwrap();
		let address2 = "127.0.0.1:12001".parse().unwrap();

		// addresses are different, but node set is the same => no migration is required
		let mut future_new_set = Some(Default::default());
		let mut new_snapshot = KeyServerSetSnapshot {
			current_set: vec![(node_id, address1)].into_iter().collect(),
			new_set: vec![(node_id, address2)].into_iter().collect(),
			..Default::default()
		};
		let new_snapshot_copy = new_snapshot.clone();
		update_future_set(&mut future_new_set, &mut new_snapshot, Default::default());
		assert_eq!(future_new_set, None);
		assert_eq!(new_snapshot, new_snapshot_copy);

		// everything is the same => no migration is required
		let mut future_new_set = Some(Default::default());
		let mut new_snapshot = KeyServerSetSnapshot {
			current_set: vec![(node_id, address1)].into_iter().collect(),
			new_set: vec![(node_id, address1)].into_iter().collect(),
			..Default::default()
		};
		let new_snapshot_copy = new_snapshot.clone();
		update_future_set(&mut future_new_set, &mut new_snapshot, Default::default());
		assert_eq!(future_new_set, None);
		assert_eq!(new_snapshot, new_snapshot_copy);
	}
```


Overlapping Code:
```
o_migration_is_required() {
let node_id = Default::default();
let address1 = "127.0.0.1:12000".parse().unwrap();
let address2 = "127.0.0.1:12001".parse().unwrap();
// addresses are different, but node set is the same => no migration is required
let mut future_new_set = Some(Default::default());
let mut new_snapshot = KeyServerSetSnapshot {
current_set: vec![(node_id, address1)].into_iter().collect(),
new_set: vec![(node_id, address2)].into_iter().collect(),
..Default::default()
};
let new_snapshot_copy = new_snapshot.clone();
update_future_set(&mut future_new_set, &mut new_snapshot, Default::default());
assert_eq!(future_new_set, None);
assert_eq!(new_snapshot, new_snapshot_copy);
// everything is the same => no migration is required
let mut future_new_set = Some(Default::default());
let mut new_snapshot = KeyServerSetSnapshot {
current_set: vec![(node_id, address1)].into_iter().collect(),
new_set: vec![(node_id, address1)].into_iter().collect(),
..Default::default()
};
let new_snapshot_copy = new_snapshot.clone();
update_future_set(&mut future_new_set, &mut new_snapshot, Default::default());
assert_eq!(future_new_set, None);
assert_eq!(new_snapshot, new_snapshot_copy);
```
<Overlap Ratio: 0.9666395443449959>

---

--- 141 --
Question ID: 8edd37c0ed0f70f332508fdca256a7cc63accd1f_1
Original Code:
```
fn test_generate_response() {
        // Test OK Empty response from VMM.
        let vmm_resp = Ok(VmmData::Empty);
        let hyper_resp = vmm_resp.generate_response();
        assert_eq!(hyper_resp.status(), StatusCode::NoContent);
        // assert that the body is empty. When the JSON is empty, serde returns and EOF error.
        let body_err = get_body(hyper_resp).unwrap_err();
        assert_eq!(
            body_err.to_string(),
            "EOF while parsing a value at line 1 column 0"
        );

        // Test OK response from VMM that contains the Machine Configuration.
        let vmm_resp = Ok(VmmData::MachineConfiguration(VmConfig::default()));
        let hyper_resp = vmm_resp.generate_response();
        assert_eq!(hyper_resp.status(), StatusCode::Ok);
        let vm_config_json = r#"{
            "vcpu_count": 1,
            "mem_size_mib": 128,
            "ht_enabled": false,
            "cpu_template": "Uninitialized"
        }"#;
        let vm_config_json: serde_json::Value = serde_json::from_str(vm_config_json).unwrap();
        assert_eq!(get_body(hyper_resp).unwrap(), vm_config_json);

        // Tests Error Cases
        // Tests for BootSource Errors.
        let vmm_resp =
            VmmActionError::BootSource(ErrorKind::User, BootSourceConfigError::InvalidKernelPath);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::BootSource(
            ErrorKind::User,
            BootSourceConfigError::InvalidKernelCommandLine,
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::BootSource(
            ErrorKind::User,
            BootSourceConfigError::UpdateNotAllowedPostBoot,
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);

        // Tests for DriveConfig Errors.
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::CannotOpenBlockDevice);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDeviceID);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDevicePath);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::BlockDevicePathAlreadyExists);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::OperationNotAllowedPreBoot);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::RootBlockDeviceAlreadyAdded);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::DriveConfig(ErrorKind::User, DriveError::UpdateNotAllowedPostBoot);
        check_error_response(vmm_resp, StatusCode::BadRequest);

        // Tests for Logger Errors.
        let vmm_resp = VmmActionError::Logger(
            ErrorKind::User,
            LoggerConfigError::InitializationFailure(
                "Could not open logging fifo: dummy".to_string(),
            ),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);

        // Tests for MachineConfig Errors.
        let vmm_resp =
            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidVcpuCount);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidMemorySize);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::UpdateNotAllowedPostBoot);
        check_error_response(vmm_resp, StatusCode::BadRequest);

        // Tests for NetworkConfig Errors.
        let vmm_resp = VmmActionError::NetworkConfig(
            ErrorKind::User,
            NetworkInterfaceError::OpenTap(TapError::OpenTun(io::Error::from_raw_os_error(22))),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::NetworkConfig(
            ErrorKind::User,
            NetworkInterfaceError::GuestMacAddressInUse(String::from("12:34:56:78:9a:bc")),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::NetworkConfig(
            ErrorKind::User,
            NetworkInterfaceError::UpdateNotAllowedPostBoot,
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::NetworkConfig(
            ErrorKind::User,
            NetworkInterfaceError::HostDeviceNameInUse(String::from("tap_name")),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);

        // Tests for MicrovmStart Errors.
        // RegisterBlockDevice, RegisterNetDevice, and LegacyIOBus cannot be tested because the
        // device manager is a private module in the vmm crate.
        // ConfigureVm, Vcpu and VcpuConfigure cannot be tested because vstate is a private module
        // in the vmm crate.
        let vmm_resp =
            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MicroVMAlreadyRunning);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp =
            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MissingKernelConfig);
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::GuestMemory(GuestMemoryError::MemoryNotInitialized),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::KernelCmdline(String::from("dummy error.")),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::CreateBlockDevice(io::Error::from_raw_os_error(22)),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::OpenBlockDevice(io::Error::from_raw_os_error(22)),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::NetDeviceNotConfigured,
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::CreateNetDevice(VirtioNetError::TapOpen(TapError::OpenTun(
                io::Error::from_raw_os_error(22),
            ))),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::DeviceVmRequest(io::Error::from_raw_os_error(22)),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        #[cfg(target_arch = "x86_64")]
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::ConfigureSystem(arch::Error::X86_64Setup(
                arch::x86_64::Error::ZeroPagePastRamEnd,
            )),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp =
            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::EventFd);
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp =
            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::RegisterEvent);
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::VcpusNotConfigured,
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::Internal,
            StartMicrovmError::VcpuSpawn(std::io::Error::from_raw_os_error(11)),
        );
        check_error_response(vmm_resp, StatusCode::InternalServerError);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::BigEndianElfOnLittle),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineCopy),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineOverflow),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidElfMagicNumber),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidEntryAddress),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderSize),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderOffset),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderAddress),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadElfHeader),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadKernelImage),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadProgramHeader),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekKernelStart),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekElfStart),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
        let vmm_resp = VmmActionError::StartMicrovm(
            ErrorKind::User,
            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekProgramHeader),
        );
        check_error_response(vmm_resp, StatusCode::BadRequest);
    }
```


Overlapping Code:
```
se() {
// Test OK Empty response from VMM.
let vmm_resp = Ok(VmmData::Empty);
let hyper_resp = vmm_resp.generate_response();
assert_eq!(hyper_resp.status(), StatusCode::NoContent);
// assert that the body is empty. When the JSON is empty, serde returns and EOF error.
let body_err = get_body(hyper_resp).unwrap_err();
assert_eq!(
body_err.to_string(),
"EOF while parsing a value at line 1 column 0"
);
// Test OK response from VMM that contains the Machine Configuration.
let vmm_resp = Ok(VmmData::MachineConfiguration(VmConfig::default()));
let hyper_resp = vmm_resp.generate_response();
assert_eq!(hyper_resp.status(), StatusCode::Ok);
let vm_config_json = r#"{
"vcpu_count": 1,
"mem_size_mib": 128,
"ht_enabled": false,
"cpu_template": "Uninitialized"
}"#;
let vm_config_json: serde_json::Value = serde_json::from_str(vm_config_json).unwrap();
assert_eq!(get_body(hyper_resp).unwrap(), vm_config_json);
// Tests Error Cases
// Tests for BootSource Errors.
let vmm_resp =
VmmActionError::BootSource(ErrorKind::User, BootSourceConfigError::InvalidKernelPath);
check_error_response(vmm_resp, StatusCode::BadRequest);
let vmm_resp = VmmActionError::BootSource(
ErrorKind::User,
BootSourceConfigError::InvalidKernelCommandLine,
);
check_error_response(vmm_resp, StatusCode::BadRequest);
let vmm_resp = VmmActionError::BootSource(
ErrorKind::User,
BootSourceConfigError::UpdateNotAllowedPostBoot,
);
check_error_response(vmm_resp, StatusCode::BadRequest);
// Tests for DriveConfig Errors.
let vmm_resp =
VmmActionError::DriveConfig(ErrorKind::User, DriveError::CannotOpenBlockDevice);
check_error_response(vmm_resp, StatusCode::BadRequest);
let vmm_resp =
VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDeviceID);
check_error_response(vmm_resp, StatusCode::BadRequest);
let vmm_resp =
VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDevicePath);
check_error_response(vmm_resp, StatusCode::BadRequest);
let vmm_resp =
VmmActionError::DriveConfig(ErrorKind::User, Dri
```
<Overlap Ratio: 0.9814090019569471>

---

--- 142 --
Question ID: e1b0338243deafb7b412b723e51281aaed1afe82_49
Original Code:
```
unsafe extern "C" fn handle_compositor_destroy(mut listener: *mut wl_listener,
                                               mut data: *mut libc::c_void) {
    let mut xwm: *mut wlr_xwm =
        (listener as *mut libc::c_char).offset(-904) as *mut wlr_xwm;
    wl_list_remove(&mut (*xwm).compositor_new_surface.link);
    wl_list_remove(&mut (*xwm).compositor_destroy.link);
    wl_list_init(&mut (*xwm).compositor_new_surface.link);
    wl_list_init(&mut (*xwm).compositor_destroy.link);
}
```


Overlapping Code:
```
destroy(mut listener: *mut wl_listener,
mut data: *mut libc::c_void) {
let mut xwm: *mut wlr_xwm =
(listener as *mut libc::c_char).offset(-904) as *mut wlr_xwm;
wl_list_remove(&mut (*xwm).compositor_new_surface.link);
wl_list_remove(&mut (*xwm).compositor_destroy.link);
wl_list_init(&mut (*xwm).compositor_new_surface.link);
wl_list_init(&mut (*xwm).composi
```
<Overlap Ratio: 0.8585131894484412>

---

--- 143 --
Question ID: 36856a3ce25f672182e1bac99c3afb2ae51c2b25_12
Original Code:
```
fn parse_regcmd_stmt(hash: PToken, px: &mut Px) -> PRegCmdStmt {
    assert_eq!(px.next_token().body_text(), "regcmd");

    let keyword = px.bump();
    let args = parse_args(px);
    parse_end_of_preproc(px);

    PRegCmdStmt {
        hash,
        keyword,
        args,
    }
}
```


Overlapping Code:
```
md_stmt(hash: PToken, px: &mut Px) -> PRegCmdStmt {
assert_eq!(px.next_token().body_text(), "regcmd");
let keyword = px.bump();
let args = parse_args(px);
parse_end_of_preproc(px);
PRegCmdStmt {
hash,
```
<Overlap Ratio: 0.8620689655172413>

---

--- 144 --
Question ID: f1611a42999396da85535c1b551efb06595e8fea_18
Original Code:
```
pub unsafe extern "C" fn _mi_segment_try_reclaim_abandoned(mut heap:
                                                               *mut mi_heap_t,
                                                           mut try_all: bool,
                                                           mut tld:
                                                               &mut mi_segments_tld_t)
 -> bool {
    let mut reclaimed = 0;
    let mut atmost: usize;
    if try_all != 0 {
        atmost = abandoned_count + 16;
    } else { atmost = abandoned_count / 8; if atmost < 8 { atmost = 8; }; }
    // for `atmost` `reclaimed` abandoned segments...
    while atmost > reclaimed
          { // try to claim the head of the abandoned segments
        let mut segment:
                *mut mi_segment_t; // stop early if no more segments available
        loop  {
            segment = abandoned as *mut mi_segment_t; // got it.
            if !(!segment.is_null() &&
                     !mi_atomic_compare_exchange_ptr(&mut abandoned as
                                                         *mut *mut c_void,
                                                     segment.abandoned_next as
                                                         *mut _,
                                                     segment as *mut _)) {
                break
            }; // add its free pages to the the current thread
        } // add its abandoned pages to the current thread
        if segment.is_null() {
            break ; // if everything free by now, free the page
        } // otherwise reclaim it
        mi_atomic_decrement(&mut abandoned_count); // due to page_clear
        segment.thread_id = _mi_thread_id();
        segment.abandoned_next = ptr::null_mut();
        mi_segments_count_add(1, tld);
        _mi_stat_decrease(&mut (tld.stats.segments_abandoned), 1);
        if segment.page_kind == MI_PAGE_SMALL &&
               mi_segment_has_free(segment) != 0 {
            mi_segment_enqueue(&mut tld.small_free, segment);
        }
        if segment.abandoned == segment.used {
            0
        } else {
            _mi_assert_fail("segment->abandoned == segment->used",
                            "src/segment.c", 548,
                            "_mi_segment_try_reclaim_abandoned")
        }
        for mut i in 0..segment.capacity {
            let mut page = &mut segment.pages[i];
            if page.segment_in_use != 0 {
                segment.abandoned -= 1;
                if page.next.is_null() {
                    0
                } else {
                    _mi_assert_fail("page->next == NULL", "src/segment.c",
                                    553, "_mi_segment_try_reclaim_abandoned")
                }
                _mi_stat_decrease(&mut (tld.stats.pages_abandoned), 1);
                if mi_page_all_free(page) {
                    mi_segment_page_clear(segment, page, tld.stats);
                } else { _mi_page_reclaim(heap, page); };
            };
        }
        if segment.abandoned == 0 {
            0
        } else {
            _mi_assert_fail("segment->abandoned == 0", "src/segment.c", 565,
                            "_mi_segment_try_reclaim_abandoned")
        }
        if segment.used == 0 {
            mi_segment_free(segment, false, tld);
        } else { reclaimed += 1; };
    }
    return (reclaimed > 0);
}
```


Overlapping Code:
```
xtern "C" fn _mi_segment_try_reclaim_abandoned(mut heap:
*mut mi_heap_t,
mut try_all: bool,
mut tld:
&mut mi_segments_tld_t)
-> bool {
let mut reclaimed = 0;
let mut atmost: usize;
if try_all != 0 {
atmost = abandoned_count + 16;
} else { atmost = abandoned_count / 8; if atmost < 8 { atmost = 8; }; }
// for `atmost` `reclaimed` abandoned segments...
while atmost > reclaimed
{ // try to claim the head of the abandoned segments
let mut segment:
*mut mi_segment_t; // stop early if no more segments available
loop {
segment = abandoned as *mut mi_segment_t; // got it.
if !(!segment.is_null() &&
!mi_atomic_compare_exchange_ptr(&mut abandoned as
*mut *mut c_void,
segment.abandoned_next as
*mut _,
segment as *mut _)) {
break
}; // add its free pages to the the current thread
} // add its abandoned pages to the current thread
if segment.is_null() {
break ; // if everything free by now, free the page
} // otherwise reclaim it
mi_atomic_decrement(&mut abandoned_count); // due to page_clear
segment.thread_id = _mi_thread_id();
segment.abandoned_next = ptr::null_mut();
mi_segments_count_add(1, tld);
_mi_stat_decrease(&mut (tld.stats.segments_abandoned), 1);
if segment.page_kind == MI_PAGE_SMALL &&
mi_segment_has_free(segment) != 0 {
mi_segment_enqueue(&mut tld.small_free, segment);
}
if segment.abandoned == segment.used {
0
} else {
_mi_assert_fail("segment->abandoned == segment->used",
"src/segment.c", 548,
"_mi_segment_try_reclaim_abandoned")
}
for mut i in 0..segment.capacity {
let mut page = &mut segment.pages[i];
if page.segment_in_
```
<Overlap Ratio: 0.9693558474046279>

---

--- 145 --
Question ID: e7c71b95b528baf35e23a357ace4bcdd25f22836_12
Original Code:
```
fn test_rol_zero_page_carry() {
    let mut ram = Ram::new(1024);
    ram.fill(vec![0x26, 0x02, 0x80], 0);
    let mut cpu = MOS6502::new(ram);
    cpu.set_flag(CARRY, true);
    cpu.step();
    assert_eq!(cpu.read(0x0002), 1);
    assert_eq!(cpu.get_flag(CARRY), true);
    assert_eq!(cpu.get_flag(ZERO), false);
    assert_eq!(cpu.get_flag(SIGN), false);
}
```


Overlapping Code:
```
et mut ram = Ram::new(1024);
ram.fill(vec![0x26, 0x02, 0x80], 0);
let mut cpu = MOS6502::new(ram);
cpu.set_flag(CARRY, true);
cpu.step();
assert_eq!(cpu.read(0x0002), 1);
assert_eq!(cpu.get_flag(CARRY), true);
assert_eq!(cpu.get_flag(ZERO), false);
assert_eq!(cpu.get_flag(SIGN), false);

```
<Overlap Ratio: 0.8944099378881988>

---

--- 146 --
Question ID: 12de4f73542f765810aac7e57fde9ff38f487d01_6
Original Code:
```
fn write_untyped_local(key_bytes: &[u8], value: &Value) {
    let key_bytes_ptr = key_bytes.as_ptr();
    let key_bytes_size = key_bytes.len();
    let (value_ptr, value_size, _bytes2) = to_ptr(value);
    unsafe {
        ext_ffi::write_local(key_bytes_ptr, key_bytes_size, value_ptr, value_size);
    }
}
```


Overlapping Code:
```
ped_local(key_bytes: &[u8], value: &Value) {
let key_bytes_ptr = key_bytes.as_ptr();
let key_bytes_size = key_bytes.len();
let (value_ptr, value_size, _bytes2) = to_ptr(value);
unsafe {
ext_ffi::write_local(key_bytes_ptr, key_bytes_size, value_ptr, value_size
```
<Overlap Ratio: 0.9316546762589928>

---

--- 147 --
Question ID: ddfeb1d44158fd0079ee1727c3457335017f470e_1
Original Code:
```
fn reverse_order() {
    let mut array = vec![5, 4, 3, 2, 1];
    let array = insertion_sort(&mut array);
    let val = vec![1, 2, 3, 4, 5];
    assert_eq!(array.as_slice(), val.as_slice());
}
```


Overlapping Code:
```
mut array = vec![5, 4, 3, 2, 1];
let array = insertion_sort(&mut array);
let val = vec![1, 2, 3, 4, 5];
assert_eq!(array.as_slice(), val.as_slice());

```
<Overlap Ratio: 0.8522727272727273>

---

--- 148 --
Question ID: a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_18
Original Code:
```
fn play_desc_pickoff_cs(input: &str) -> IResult<&str, PlayDescription> {
    let (input, _) = tag("POCS")(input)?;
    let (input, base) = base(input)?;
    let (input, _) = tag("(")(input)?;
    let (input, throws) = many1(complete(fielder))(input)?;
    let (input, _) = tag(")")(input)?;

    Ok((input, PlayDescription::PickOffCaughtStealing(base, throws)))
}
```


Overlapping Code:
```
off_cs(input: &str) -> IResult<&str, PlayDescription> {
let (input, _) = tag("POCS")(input)?;
let (input, base) = base(input)?;
let (input, _) = tag("(")(input)?;
let (input, throws) = many1(complete(fielder))(input)?;
let (input, _) = tag(")")(input)?;
Ok((input, PlayDescription::PickOffCaughtSteal
```
<Overlap Ratio: 0.8875739644970414>

---

--- 149 --
Question ID: 5b09ca6344446c6fac292af222f8e56143a65779_2
Original Code:
```
fn main() {
    let mut buf = BufReader::new(stdin());
    let mut out = BufWriter::new(stdout());
    let mut buffer = String::new();

    buf.read_line(&mut buffer).unwrap();
    let mut values: Vec<usize>;
    let n: usize;
    let m: usize;
    values = buffer
        .split_whitespace()
        .map(|x| x.parse::<usize>().unwrap())
        .collect();
    n = values[0];
    m = values[1];

    let mut graph = Graph::new();

    for _ in 0..m {
        buffer.clear();
        buf.read_line(&mut buffer).unwrap();
        values.clear();
        values = buffer
            .split_whitespace()
            .map(|x| x.parse::<usize>().unwrap())
            .collect();

        graph.add_node(&values[0]);
        graph.add_node(&values[1]);
        graph.add_edge(&values[0], &values[1]);
    }
    writeln!(out, "{}", solution(n, &graph)).unwrap();
    out.flush().unwrap();
}
```


Overlapping Code:
```
::new(stdin());
let mut out = BufWriter::new(stdout());
let mut buffer = String::new();
buf.read_line(&mut buffer).unwrap();
let mut values: Vec<usize>;
let n: usize;
let m: usize;
values = buffer
.split_whitespace()
.map(|x| x.parse::<usize>().unwrap())
.collect();
n = values[0];
m = values[1];
let mut graph = Graph::new();
for _ in 0..m {
buffer.clear();
buf.read_line(&mut buffer).unwrap();
values.clear();
values = buffer
.split_whitespace()
.map(|x| x.parse::<usize>().unwrap())
.collect();
graph.add_node(&values[0]);
graph.add_node(&values[1]);
graph.add_edge(&values[0], &values[1]);
}
writeln!(out, "{}", solution(n, &graph)).unwrap();
out.flush().unw
```
<Overlap Ratio: 0.9390070921985816>

---

--- 150 --
Question ID: 8c7a2e373f5af33d321be5c1639cda1a637927f5_6
Original Code:
```
async fn apply_a_base_delta() {
        let store = open_memory_store();
        let builder = store.create_base_layer().await.unwrap();

        builder
            .add_string_triple(StringTriple::new_value("cow", "says", "moo"))
            .unwrap();

        let layer = builder.commit().await.unwrap();

        let builder2 = layer.open_write().await.unwrap();

        builder2
            .add_string_triple(StringTriple::new_value("dog", "says", "woof"))
            .unwrap();

        let layer2 = builder2.commit().await.unwrap();

        let delta_builder_1 = store.create_base_layer().await.unwrap();

        delta_builder_1
            .add_string_triple(StringTriple::new_value("dog", "says", "woof"))
            .unwrap();
        delta_builder_1
            .add_string_triple(StringTriple::new_value("cat", "says", "meow"))
            .unwrap();

        let delta_1 = delta_builder_1.commit().await.unwrap();

        let delta_builder_2 = delta_1.open_write().await.unwrap();

        delta_builder_2
            .add_string_triple(StringTriple::new_value("crow", "says", "caw"))
            .unwrap();
        delta_builder_2
            .remove_string_triple(StringTriple::new_value("cat", "says", "meow"))
            .unwrap();

        let delta = delta_builder_2.commit().await.unwrap();

        let rebase_builder = layer2.open_write().await.unwrap();

        let _ = rebase_builder.apply_delta(&delta).await.unwrap();

        let rebase_layer = rebase_builder.commit().await.unwrap();

        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("cow", "says", "moo")));
        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("crow", "says", "caw")));
        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("dog", "says", "woof")));
        assert!(!rebase_layer.string_triple_exists(&StringTriple::new_value("cat", "says", "meow")));
    }
```


Overlapping Code:
```
ync fn apply_a_base_delta() {
let store = open_memory_store();
let builder = store.create_base_layer().await.unwrap();
builder
.add_string_triple(StringTriple::new_value("cow", "says", "moo"))
.unwrap();
let layer = builder.commit().await.unwrap();
let builder2 = layer.open_write().await.unwrap();
builder2
.add_string_triple(StringTriple::new_value("dog", "says", "woof"))
.unwrap();
let layer2 = builder2.commit().await.unwrap();
let delta_builder_1 = store.create_base_layer().await.unwrap();
delta_builder_1
.add_string_triple(StringTriple::new_value("dog", "says", "woof"))
.unwrap();
delta_builder_1
.add_string_triple(StringTriple::new_value("cat", "says", "meow"))
.unwrap();
let delta_1 = delta_builder_1.commit().await.unwrap();
let delta_builder_2 = delta_1.open_write().await.unwrap();
delta_builder_2
.add_string_triple(StringTriple::new_value("crow", "says", "caw"))
.unwrap();
delta_builder_2
.remove_string_triple(StringTriple::new_value("cat", "says", "meow"))
.unwrap();
let delta = delta_builder_2.commit().await.unwrap();
let rebase_builder = layer2.open_write().await.unwrap();
let _ = rebase_builder.apply_delta(&delta).await.unwrap();
let rebase_layer = rebase_builder.commit().await.unwrap();
assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("cow", "says", "moo")));
assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("crow", "says", "caw")));
assert!(rebase_layer.string_triple_exists(&StringTriple::new_value("dog", "says", "woof")));
assert!(!rebase_layer.string_triple_exists(&StringTriple::new_value("
```
<Overlap Ratio: 0.9824231010671689>

---

--- 151 --
Question ID: ea157e62bd72244c04d7ebe0067b7960a3693723_1
Original Code:
```
pub fn public_decrypt(key: &Rsa<openssl::pkey::Public>, bytes: Tomb) -> Result<Tomb, Error> {
    let mut sym = vec![0; key.size() as usize];
    let mut iv = vec![0; key.size() as usize];
    let len_sym = key.public_decrypt(
        &decode(&bytes.aes_key)?,
        &mut sym,
        openssl::rsa::Padding::PKCS1,
    )?;
    let len_iv = key.public_decrypt(
        &decode(&bytes.aes_iv)?,
        &mut iv,
        openssl::rsa::Padding::PKCS1,
    )?;
    let sym = encode(&sym[..len_sym].to_vec());
    let iv = encode(&iv[..len_iv].to_vec());
    let text = sym_dec(sym.clone(), iv.clone(), bytes.value)?;
    Ok(Tomb {
        aes_key: sym,
        aes_iv: iv,
        value: encode(&text),
    })
}
```


Overlapping Code:
```
::pkey::Public>, bytes: Tomb) -> Result<Tomb, Error> {
let mut sym = vec![0; key.size() as usize];
let mut iv = vec![0; key.size() as usize];
let len_sym = key.public_decrypt(
&decode(&bytes.aes_key)?,
&mut sym,
openssl::rsa::Padding::PKCS1,
)?;
let len_iv = key.public_decrypt(
&decode(&bytes.aes_iv)?,
&mut iv,
openssl::rsa::Padding::PKCS1,
)?;
let sym = encode(&sym[..len_sym].to_vec());
let iv = encode(&iv[..len_iv].to_vec());
let text = sym_dec(sym.clone(), iv.clone(), bytes.value)?;
Ok(Tomb {
aes_key: sym,
aes_iv: iv,
value: encode(&text),
}
```
<Overlap Ratio: 0.9290540540540541>

---

--- 152 --
Question ID: d353aab467ce9d2579c72ac83df3bff28b8029c3_12
Original Code:
```
fn add_assign_with_ovfl_3_works() {
        let expected = {
            let mut expected = [0x00; 32];
            expected[24] = 0x01;
            expected
        };
        let mut key = Key::from(OVERFLOW_3_TEST_BYTES);
        key.add_assign(1u64);
        assert_eq!(key.as_ref(), &expected);
    }
```


Overlapping Code:
```
_3_works() {
let expected = {
let mut expected = [0x00; 32];
expected[24] = 0x01;
expected
};
let mut key = Key::from(OVERFLOW_3_TEST_BYTES);
key.add_assign(1u64);
assert_eq!(key.as_ref(), &expected);
```
<Overlap Ratio: 0.8888888888888888>

---

--- 153 --
Question ID: df587fdcb935b657c6ea6572e74ce98542967f7f_3
Original Code:
```
fn upgrade_entity18(entity: &mut Value, file_name: &str) {
    let item_action_names = ["Spawn", "Idle", "Fall", "Held", "Thrown", "Dropped"];

    let projectile_action_names = ["Spawn", "Travel", "Hit"];

    let fighter_action_names = [
        "Spawn",
        "ReSpawn",
        "ReSpawnIdle",
        "Idle",
        "Crouch",
        "LedgeIdle",
        "Teeter",
        "TeeterIdle",
        "MissedTechIdle",
        // Movement
        "Fall",
        "AerialFall",
        "Land",
        "JumpSquat",
        "JumpF",
        "JumpB",
        "JumpAerialF",
        "JumpAerialB",
        "TiltTurn",
        "RunTurn",
        "SmashTurn",
        "Dash",
        "Run",
        "RunEnd",
        "Walk",
        "PassPlatform",
        "Damage",
        "DamageFly",
        "DamageFall",
        "LedgeGrab",
        "LedgeJump",
        "LedgeJumpSlow",
        "LedgeGetup",
        "LedgeGetupSlow",
        "LedgeIdleChain",
        // Defense
        "PowerShield",
        "ShieldOn",
        "Shield",
        "ShieldOff",
        "RollF",
        "RollB",
        "SpotDodge",
        "AerialDodge",
        "SpecialFall",
        "SpecialLand",
        "TechF",
        "TechN",
        "TechB",
        "MissedTechGetupF",
        "MissedTechGetupN",
        "MissedTechGetupB",
        "Rebound",
        "LedgeRoll",
        "LedgeRollSlow",
        // Vulnerable
        "ShieldBreakFall",
        "ShieldBreakGetup",
        "Stun",
        "MissedTechStart",
        // Attack",
        "Jab",
        "Jab2",
        "Jab3",
        "Utilt",
        "Dtilt",
        "Ftilt",
        "DashAttack",
        "Usmash",
        "Dsmash",
        "Fsmash",
        // Grabs
        "Grab",
        "DashGrab",
        "GrabbingIdle",
        "GrabbingEnd",
        "GrabbedIdleAir",
        "GrabbedIdle",
        "GrabbedEnd",
        // Throws
        "Uthrow",
        "Dthrow",
        "Fthrow",
        "Bthrow",
        // Items
        "ItemGrab",
        "ItemEat",
        "ItemThrowU",
        "ItemThrowD",
        "ItemThrowF",
        "ItemThrowB",
        "ItemThrowAirU",
        "ItemThrowAirD",
        "ItemThrowAirF",
        "ItemThrowAirB",
        // Getup attacks
        "LedgeAttack",
        "LedgeAttackSlow",
        "MissedTechAttack",
        // Aerials
        "Uair",
        "Dair",
        "Fair",
        "Bair",
        "Nair",
        "UairLand",
        "DairLand",
        "FairLand",
        "BairLand",
        "NairLand",
        // Taunts
        "TauntUp",
        "TauntDown",
        "TauntLeft",
        "TauntRight",
        // Crouch
        "CrouchStart",
        "CrouchEnd",
        "Eliminated",
        "DummyFramePreStart",
    ];

    let action_names = match file_name {
        "PerfectlyGenericProjectile.cbor" => projectile_action_names.as_ref(),
        "PerfectlyGenericObject.cbor" => item_action_names.as_ref(),
        "TorielFireball.cbor" => projectile_action_names.as_ref(),
        _ => fighter_action_names.as_ref(),
    };

    if let Some(actions) = get_vec(entity, "actions") {
        let mut new_actions = BTreeMap::new();
        new_actions.insert(
            Value::Text("keys".into()),
            Value::Array(
                action_names
                    .iter()
                    .map(|x| Value::Text(x.to_string()))
                    .collect(),
            ),
        );
        new_actions.insert(
            Value::Text("vector".into()),
            Value::Array(actions[0..action_names.len()].to_vec()),
        );

        if let Value::Map(entity) = entity {
            entity.insert(Value::Text("actions".into()), Value::Map(new_actions));
        }
    }
}
```


Overlapping Code:
```
de_entity18(entity: &mut Value, file_name: &str) {
let item_action_names = ["Spawn", "Idle", "Fall", "Held", "Thrown", "Dropped"];
let projectile_action_names = ["Spawn", "Travel", "Hit"];
let fighter_action_names = [
"Spawn",
"ReSpawn",
"ReSpawnIdle",
"Idle",
"Crouch",
"LedgeIdle",
"Teeter",
"TeeterIdle",
"MissedTechIdle",
// Movement
"Fall",
"AerialFall",
"Land",
"JumpSquat",
"JumpF",
"JumpB",
"JumpAerialF",
"JumpAerialB",
"TiltTurn",
"RunTurn",
"SmashTurn",
"Dash",
"Run",
"RunEnd",
"Walk",
"PassPlatform",
"Damage",
"DamageFly",
"DamageFall",
"LedgeGrab",
"LedgeJump",
"LedgeJumpSlow",
"LedgeGetup",
"LedgeGetupSlow",
"LedgeIdleChain",
// Defense
"PowerShield",
"ShieldOn",
"Shield",
"ShieldOff",
"RollF",
"RollB",
"SpotDodge",
"AerialDodge",
"SpecialFall",
"SpecialLand",
"TechF",
"TechN",
"TechB",
"MissedTechGetupF",
"MissedTechGetupN",
"MissedTechGetupB",
"Rebound",
"LedgeRoll",
"LedgeRollSlow",
// Vulnerable
"ShieldBreakFall",
"ShieldBreakGetup",
"Stun",
"MissedTechStart",
// Attack",
"Jab",
"Jab2",
"Jab3",
"Utilt",
"Dtilt",
"Ftilt",
"DashAttack",
"Usmash",
"Dsmash",
"Fsmash",
// Grabs
"Grab",
"DashGrab",
"GrabbingIdle",
"GrabbingEnd",
"GrabbedIdleAir",
"GrabbedIdle",
"GrabbedEnd",
// Throws
"Uthrow",
"Dthrow",
"Fthrow",
"Bthrow",
// Items
"ItemGrab",
"ItemEat",
"ItemThrowU",
"ItemThrowD",
"ItemThrowF",
"ItemThrowB",
"ItemThrowAirU",
"ItemThrowAirD",
"ItemThrowAirF",
"ItemThrowAirB",
// Getup attacks
"LedgeAttack",
"LedgeAttackSlow",
"MissedTechAttack",
// Aerials
"Uair",
"Dair",
"Fair",
"Bair",
"Nair",
"UairLand",
"DairLan
```
<Overlap Ratio: 0.9705698184095178>

---

--- 154 --
Question ID: 929d0e4e2dca7b13138bc8a1f95780ecec935cf7_5
Original Code:
```
fn program() {
        assert_program(
            r#"BEGIN { print "start" } END { print "end" }"#,
            Program::new(vec![
                Item::PatternAction(
                    Some(Pattern::Begin),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("start".to_owned())]),
                        None,
                    )]),
                ),
                Item::PatternAction(
                    Some(Pattern::End),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("end".to_owned())]),
                        None,
                    )]),
                ),
            ]),
        );
        assert_program(
            r#"BEGIN { print "start" }; ; END { print "end" }"#,
            Program::new(vec![
                Item::PatternAction(
                    Some(Pattern::Begin),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("start".to_owned())]),
                        None,
                    )]),
                ),
                Item::PatternAction(
                    Some(Pattern::End),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("end".to_owned())]),
                        None,
                    )]),
                ),
            ]),
        );
        assert_program(
            r#"
            BEGIN { print "start" }
            END { print "end" }"#,
            Program::new(vec![
                Item::PatternAction(
                    Some(Pattern::Begin),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("start".to_owned())]),
                        None,
                    )]),
                ),
                Item::PatternAction(
                    Some(Pattern::End),
                    StmtList(vec![Stmt::Print(
                        ExprList(vec![Expr::String("end".to_owned())]),
                        None,
                    )]),
                ),
            ]),
        );
        assert_program("", Program::new(vec![]));
    }
```


Overlapping Code:
```

r#"BEGIN { print "start" } END { print "end" }"#,
Program::new(vec![
Item::PatternAction(
Some(Pattern::Begin),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("start".to_owned())]),
None,
)]),
),
Item::PatternAction(
Some(Pattern::End),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("end".to_owned())]),
None,
)]),
),
]),
);
assert_program(
r#"BEGIN { print "start" }; ; END { print "end" }"#,
Program::new(vec![
Item::PatternAction(
Some(Pattern::Begin),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("start".to_owned())]),
None,
)]),
),
Item::PatternAction(
Some(Pattern::End),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("end".to_owned())]),
None,
)]),
),
]),
);
assert_program(
r#"
BEGIN { print "start" }
END { print "end" }"#,
Program::new(vec![
Item::PatternAction(
Some(Pattern::Begin),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("start".to_owned())]),
None,
)]),
),
Item::PatternAction(
Some(Pattern::End),
StmtList(vec![Stmt::Print(
ExprList(vec![Expr::String("end".to_owned())]),
None,
)]),
),
]),
);
assert_program("", Program::new(vec![]));
}
```
<Overlap Ratio: 0.9734513274336283>

---

--- 155 --
Question ID: c4c344049bf2ae99456a3241210d1b016f5e299b_1
Original Code:
```
fn get_total_input_amount(inputs: &[TransactionInput]) -> Result<Option<Coin>> {
    if inputs.is_empty() {
        return Ok(None);
    }

    let mut amount = Coin::zero();

    for input in inputs.iter() {
        if let Some(ref output) = input.output {
            amount = (amount + output.value).chain(|| {
                (
                    ErrorKind::IllegalInput,
                    "Total input amount exceeded maximum allowed value",
                )
            })?;
        } else {
            return Ok(None);
        }
    }

    Ok(Some(amount))
}
```


Overlapping Code:
```
unt(inputs: &[TransactionInput]) -> Result<Option<Coin>> {
if inputs.is_empty() {
return Ok(None);
}
let mut amount = Coin::zero();
for input in inputs.iter() {
if let Some(ref output) = input.output {
amount = (amount + output.value).chain(|| {
(
ErrorKind::IllegalInput,
"Total input amount exceeded maximum allowed value",
)
})?;
} else {
return O
```
<Overlap Ratio: 0.8684863523573201>

---

--- 156 --
Question ID: 2767f034058e4eab7db9b94e2327cf06ccbce530_0
Original Code:
```
fn matches(word: &str, search: &str) -> bool {
    let mut search = search.chars();
    for ch in word.chars().skip_while(|ch| !ch.is_alphabetic()) {
        match search.next() {
            None => {
                return !ch.is_alphabetic();
            }
            Some(expect) => {
                if ch.to_lowercase().next() != Some(expect) {
                    return false;
                }
            }
        }
    }
    return search.next().is_none();
}
```


Overlapping Code:
```
s(word: &str, search: &str) -> bool {
let mut search = search.chars();
for ch in word.chars().skip_while(|ch| !ch.is_alphabetic()) {
match search.next() {
None => {
return !ch.is_alphabetic();
}
Some(expect) => {
if ch.to_lowercase().next() != Some(expect) {
return false;
}
}
}
}
return search.next(
```
<Overlap Ratio: 0.9287925696594427>

---

--- 157 --
Question ID: 288857f932a01df49cd36640e03ea4769e361ab4_34
Original Code:
```
fn projection_onto_zero_vector_is_zero_vector() {
        let vector = Vector {
            x: 1_000.0,
            y: -2_000.0,
        };
        let zero_vector = Vector::default();
        let expected_projection = zero_vector;
        let projection = vector.project_onto(zero_vector);

        assert_eq!(expected_projection, projection);
    }
```


Overlapping Code:
```
o_vector() {
let vector = Vector {
x: 1_000.0,
y: -2_000.0,
};
let zero_vector = Vector::default();
let expected_projection = zero_vector;
let projection = vector.project_onto(zero_vector);
assert_eq!(expected_projection, project
```
<Overlap Ratio: 0.8388278388278388>

---

--- 158 --
Question ID: 0e7e7760255ed40fe8810ab91f682be552e8fbd8_1
Original Code:
```
unsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
                                      mut name: uint32_t,
                                      mut interface: *const wl_interface,
                                      mut version: uint32_t)
 -> *mut libc::c_void {
    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
    id =
        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
                                               0i32 as uint32_t, interface,
                                               version, name,
                                               (*interface).name, version,
                                               0 as *mut libc::c_void);
    return id as *mut libc::c_void;
}
```


Overlapping Code:
```
nsafe extern "C" fn wl_registry_bind(mut wl_registry: *mut wl_registry,
mut name: uint32_t,
mut interface: *const wl_interface,
mut version: uint32_t)
-> *mut libc::c_void {
let mut id: *mut wl_proxy = 0 as *mut wl_proxy;
id =
wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,
0i32 as uint32_t, interface,
version, name,
(*interface).name, version,
0 as *mut libc::c_void);
return id as *mut libc::c_void;
```
<Overlap Ratio: 0.9929742388758782>

---

--- 159 --
Question ID: c0580b0cfe479ade43d0b13e676989c13f359740_3
Original Code:
```
fn test_scan_comments() {
    let text = r#"// this is a comment.
a
// comment with // nested comment.
// one more.
// last but not least.
1
// ok, that's it."#;
    let cdata = CString::new(text).expect("CString::new failed");
    let mut s = Scanner::new(cdata);
    assert_eq!(
        s.scan(),
        Token {
            tok: T_IDENT,
            lit: String::from("a"),
            pos: 22,
        }
    );
    assert_eq!(
        s.scan(),
        Token {
            tok: T_INT,
            lit: String::from("1"),
            pos: 95,
        }
    );
    assert_eq!(
        s.scan(),
        Token {
            tok: T_EOF,
            lit: String::from(""),
            pos: 114,
        }
    );

    // with regex
    let cdata = CString::new(text).expect("CString::new failed");
    let mut s = Scanner::new(cdata);
    assert_eq!(
        s.scan_with_regex(),
        Token {
            tok: T_IDENT,
            lit: String::from("a"),
            pos: 22,
        }
    );
    assert_eq!(
        s.scan_with_regex(),
        Token {
            tok: T_INT,
            lit: String::from("1"),
            pos: 95,
        }
    );
    assert_eq!(
        s.scan_with_regex(),
        Token {
            tok: T_EOF,
            lit: String::from(""),
            pos: 114,
        }
    );
}
```


Overlapping Code:
```
_scan_comments() {
let text = r#"// this is a comment.
a
// comment with // nested comment.
// one more.
// last but not least.
1
// ok, that's it."#;
let cdata = CString::new(text).expect("CString::new failed");
let mut s = Scanner::new(cdata);
assert_eq!(
s.scan(),
Token {
tok: T_IDENT,
lit: String::from("a"),
pos: 22,
}
);
assert_eq!(
s.scan(),
Token {
tok: T_INT,
lit: String::from("1"),
pos: 95,
}
);
assert_eq!(
s.scan(),
Token {
tok: T_EOF,
lit: String::from(""),
pos: 114,
}
);
// with regex
let cdata = CString::new(text).expect("CString::new failed");
let mut s = Scanner::new(cdata);
assert_eq!(
s.scan_with_regex(),
Token {
tok: T_IDENT,
lit: String::from("a"),
pos: 22,
}
);
assert_eq!(
s.scan_with_regex(),
Token {
tok: T_INT,
lit: String::from("1"),
pos: 95,
}
);
assert_eq!(
s.scan_with_regex(),
Token {
tok: T_EOF,
lit: String::from(""),
pos: 114,
}

```
<Overlap Ratio: 0.9875>

---

--- 160 --
Question ID: 332db6f049736fc458aa677ffa25250a36f1c7ea_9
Original Code:
```
unsafe fn mailmime_id_write_driver(
    mut do_write: Option<
        unsafe fn(_: *mut libc::c_void, _: *const libc::c_char, _: size_t) -> libc::c_int,
    >,
    mut data: *mut libc::c_void,
    mut col: *mut libc::c_int,
    mut id: *mut libc::c_char,
) -> libc::c_int {
    let mut r: libc::c_int = 0;
    r = mailimf_string_write_driver(
        do_write,
        data,
        col,
        b"Content-ID: \x00" as *const u8 as *const libc::c_char,
        12i32 as size_t,
    );
    if r != MAILIMF_NO_ERROR as libc::c_int {
        return r;
    }
    r = mailimf_string_write_driver(
        do_write,
        data,
        col,
        b"<\x00" as *const u8 as *const libc::c_char,
        1i32 as size_t,
    );
    if r != MAILIMF_NO_ERROR as libc::c_int {
        return r;
    }
    r = mailimf_string_write_driver(do_write, data, col, id, strlen(id));
    if r != MAILIMF_NO_ERROR as libc::c_int {
        return r;
    }
    r = mailimf_string_write_driver(
        do_write,
        data,
        col,
        b">\x00" as *const u8 as *const libc::c_char,
        1i32 as size_t,
    );
    if r != MAILIMF_NO_ERROR as libc::c_int {
        return r;
    }
    r = mailimf_string_write_driver(
        do_write,
        data,
        col,
        b"\r\n\x00" as *const u8 as *const libc::c_char,
        2i32 as size_t,
    );
    if r != MAILIMF_NO_ERROR as libc::c_int {
        return r;
    }
    return MAILIMF_NO_ERROR as libc::c_int;
}
```


Overlapping Code:
```
write_driver(
mut do_write: Option<
unsafe fn(_: *mut libc::c_void, _: *const libc::c_char, _: size_t) -> libc::c_int,
>,
mut data: *mut libc::c_void,
mut col: *mut libc::c_int,
mut id: *mut libc::c_char,
) -> libc::c_int {
let mut r: libc::c_int = 0;
r = mailimf_string_write_driver(
do_write,
data,
col,
b"Content-ID: \x00" as *const u8 as *const libc::c_char,
12i32 as size_t,
);
if r != MAILIMF_NO_ERROR as libc::c_int {
return r;
}
r = mailimf_string_write_driver(
do_write,
data,
col,
b"<\x00" as *const u8 as *const libc::c_char,
1i32 as size_t,
);
if r != MAILIMF_NO_ERROR as libc::c_int {
return r;
}
r = mailimf_string_write_driver(do_write, data, col, id, strlen(id));
if r != MAILIMF_NO_ERROR as libc::c_int {
return r;
}
r = mailimf_string_write_driver(
do_write,
data,
col,
b">\x00" as *const u8 as *const libc::c_char,
1i32 as size_t,
);
if r != MAILIMF_NO_ERROR as libc::c_int {
return r;
}
r = mailimf_string_write_driver(
do_write,
data,
col,
b"\r\n\x00" as *const u8 as *const libc::c_char,
2i32 as size_t,
);
if r != MAILIMF_NO_ERROR as libc::c_int {
return r;
}
return MAILIMF_NO_ERROR as libc::c_int;
}
```
<Overlap Ratio: 0.9808027923211169>

---

--- 161 --
Question ID: 40fa2c4fe904294809879b6efd9ffb69549288d2_3
Original Code:
```
fn test_percentage_flex_basis() {
	let mut root = Node::new();
	root.set_flex_direction(FlexDirection::Row);
	root.set_width(StyleUnit::Point(200.0.into()));
	root.set_height(StyleUnit::Point(200.0.into()));

	let mut root_child0 = Node::new();
	root_child0.set_flex_grow(1.0);
	root_child0.set_flex_basis(StyleUnit::Percent(50.0.into()));
	root.insert_child(&mut root_child0, 0);

	let mut root_child1 = Node::new();
	root_child1.set_flex_grow(1.0);
	root_child1.set_flex_basis(StyleUnit::Percent(25.0.into()));
	root.insert_child(&mut root_child1, 1);
	root.calculate_layout(Undefined, Undefined, Direction::LTR);

	assert_eq!(0, root.get_layout_left() as i32);
	assert_eq!(0, root.get_layout_top() as i32);
	assert_eq!(200, root.get_layout_width() as i32);
	assert_eq!(200, root.get_layout_height() as i32);

	assert_eq!(0, root_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0.get_layout_top() as i32);
	assert_eq!(125, root_child0.get_layout_width() as i32);
	assert_eq!(200, root_child0.get_layout_height() as i32);

	assert_eq!(125, root_child1.get_layout_left() as i32);
	assert_eq!(0, root_child1.get_layout_top() as i32);
	assert_eq!(75, root_child1.get_layout_width() as i32);
	assert_eq!(200, root_child1.get_layout_height() as i32);

	root.calculate_layout(Undefined, Undefined, Direction::RTL);

	assert_eq!(0, root.get_layout_left() as i32);
	assert_eq!(0, root.get_layout_top() as i32);
	assert_eq!(200, root.get_layout_width() as i32);
	assert_eq!(200, root.get_layout_height() as i32);

	assert_eq!(75, root_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0.get_layout_top() as i32);
	assert_eq!(125, root_child0.get_layout_width() as i32);
	assert_eq!(200, root_child0.get_layout_height() as i32);

	assert_eq!(0, root_child1.get_layout_left() as i32);
	assert_eq!(0, root_child1.get_layout_top() as i32);
	assert_eq!(75, root_child1.get_layout_width() as i32);
	assert_eq!(200, root_child1.get_layout_height() as i32);
}
```


Overlapping Code:
```
() {
let mut root = Node::new();
root.set_flex_direction(FlexDirection::Row);
root.set_width(StyleUnit::Point(200.0.into()));
root.set_height(StyleUnit::Point(200.0.into()));
let mut root_child0 = Node::new();
root_child0.set_flex_grow(1.0);
root_child0.set_flex_basis(StyleUnit::Percent(50.0.into()));
root.insert_child(&mut root_child0, 0);
let mut root_child1 = Node::new();
root_child1.set_flex_grow(1.0);
root_child1.set_flex_basis(StyleUnit::Percent(25.0.into()));
root.insert_child(&mut root_child1, 1);
root.calculate_layout(Undefined, Undefined, Direction::LTR);
assert_eq!(0, root.get_layout_left() as i32);
assert_eq!(0, root.get_layout_top() as i32);
assert_eq!(200, root.get_layout_width() as i32);
assert_eq!(200, root.get_layout_height() as i32);
assert_eq!(0, root_child0.get_layout_left() as i32);
assert_eq!(0, root_child0.get_layout_top() as i32);
assert_eq!(125, root_child0.get_layout_width() as i32);
assert_eq!(200, root_child0.get_layout_height() as i32);
assert_eq!(125, root_child1.get_layout_left() as i32);
assert_eq!(0, root_child1.get_layout_top() as i32);
assert_eq!(75, root_child1.get_layout_width() as i32);
assert_eq!(200, root_child1.get_layout_height() as i32);
root.calculate_layout(Undefined, Undefined, Direction::RTL);
assert_eq!(0, root.get_layout_left() as i32);
assert_eq!(0, root.get_layout_top() as i32);
assert_eq!(200, root.get_layout_width() as i32);
assert_eq!(200, root.get_layout_height() as i32);
assert_eq!(75, root_child0.get_layout_left() as i32);
assert_eq!(0, root_child0.get_layout_top() as i32);
assert_eq!(125, root_child0.get_layout_width() as i32);
assert_eq!(200, root_child0.get_layout_height() as i32);
assert_eq!(0, root_child1.get_layout_left() as i32);
assert_eq!(0, root_child1.get_layout_top() as i32);
assert_eq!(75, root_child1.get_layout_width() as i32);
assert_eq!(200, root_child1.get_layout_height() as i3
```
<Overlap Ratio: 0.9822546972860126>

---

--- 162 --
Question ID: 07282abc447bc6ea6b051c04fc4143cdd0bd1220_8
Original Code:
```
fn test_patch() {
    setup();
    let body = get_body(mrq::patch(url("/i")).with_body("O").send());
    assert_eq!(body, "r: O");
}
```


Overlapping Code:
```
test_patch() {
setup();
let body = get_body(mrq::patch(url("/i")).with_body("O").send());
assert_eq!
```
<Overlap Ratio: 0.8333333333333334>

---

--- 163 --
Question ID: 177534a9ff288c0aef4797a0bc6a71cad8e13514_5
Original Code:
```
fn test_undefined_conts() {
    let errs = parse_check(
      "(program halt
        (letfun (f r () (a b) (cont r 100))
          (letcont (bad-call () (call f cc1 1 2))
                   (bad-ext-call () (extern-call ext_add cc2 1 2))
                   (bad-cont () (cont cc3 3))
                   (bad-branch () (branch (is-true 1) cc4 cc5))
            (cont halt 0))))");
    assert_eq!(errs.len(), 5);
    assert!(errs[0].contains("return to undefined cont: 'cc1'"));
    assert!(errs[1].contains("extern return to undefined cont: 'cc2'"));
    assert!(errs[2].contains("continue to undefined cont: 'cc3'"));
    assert!(errs[3].contains("then-branch to undefined cont: 'cc4'"));
    assert!(errs[4].contains("else-branch to undefined cont: 'cc5'"));
  }
```


Overlapping Code:
```
test_undefined_conts() {
let errs = parse_check(
"(program halt
(letfun (f r () (a b) (cont r 100))
(letcont (bad-call () (call f cc1 1 2))
(bad-ext-call () (extern-call ext_add cc2 1 2))
(bad-cont () (cont cc3 3))
(bad-branch () (branch (is-true 1) cc4 cc5))
(cont halt 0))))");
assert_eq!(errs.len(), 5);
assert!(errs[0].contains("return to undefined cont: 'cc1'"));
assert!(errs[1].contains("extern return to undefined cont: 'cc2'"));
assert!(errs[2].contains("continue to undefined cont: 'cc3'"));
assert!(errs[3].contains("then-branch to undefined cont: 'cc4'"));
assert!(errs[4].contains("else-branch to undefined cont: 'cc5'")
```
<Overlap Ratio: 0.9890625>

---

--- 164 --
Question ID: 2973364ce34d6141d42d75ae46ab7551f160c1dc_1
Original Code:
```
pub fn sync_drive_items<DriveItem: 'static>(
    client: &Client,
    reset_link: String,
    link: String,
    handler: &mut impl DriveItemHandler<DriveItem>,
) -> Result<String>
where
    DriveItem: Send + serde::de::DeserializeOwned,
{
    let (sender, receiver) = mpsc::channel::<Option<Vec<DriveItem>>>();
    let client = client.clone();
    let t = std::thread::spawn(move || fetch_items(&client, reset_link, link, sender));
    loop {
        match receiver.recv() {
            Ok(Some(items)) => {
                for item in items.into_iter() {
                    handler.handle(item);
                }
            }
            Ok(None) => {
                // None indicates that the sender thread has had to restart the sync from the beginning.
                handler.reset();
            }
            Err(mpsc::RecvError) => {
                // RecvError means that the sender has closed the channel. This only happens
                // when there are no more pages or the sending thread has panicked.
                break;
            }
        }
    }
    match t.join() {
        Ok(delta_link) => Ok(delta_link),
        Err(err) => {
            match err.downcast::<&str>() {
                Ok(s) => {
                    Err(eyre!(s))
                }
                Err(err) => {
                    panic::resume_unwind(err)
                }
            }
        }
    }
}
```


Overlapping Code:
```
tic>(
client: &Client,
reset_link: String,
link: String,
handler: &mut impl DriveItemHandler<DriveItem>,
) -> Result<String>
where
DriveItem: Send + serde::de::DeserializeOwned,
{
let (sender, receiver) = mpsc::channel::<Option<Vec<DriveItem>>>();
let client = client.clone();
let t = std::thread::spawn(move || fetch_items(&client, reset_link, link, sender));
loop {
match receiver.recv() {
Ok(Some(items)) => {
for item in items.into_iter() {
handler.handle(item);
}
}
Ok(None) => {
// None indicates that the sender thread has had to restart the sync from the beginning.
handler.reset();
}
Err(mpsc::RecvError) => {
// RecvError means that the sender has closed the channel. This only happens
// when there are no more pages or the sending thread has panicked.
break;
}
}
}
match t.join() {
Ok(delta_link) => Ok(delta_link),
Err(err) => {
match err.downcast::<&str>() {
Ok(s) => {
Err(eyre!(s))
}

```
<Overlap Ratio: 0.9109311740890689>

---

--- 165 --
Question ID: afc32c6487a6bb37e86efce5225b760f10e4bd17_1
Original Code:
```
unsafe fn set_hw_params_from_format(
    pcm_handle: *mut alsa::snd_pcm_t,
    hw_params: &HwParams,
    format: &Format,
) -> Result<(), String> {
    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_any(pcm_handle, hw_params.0)) {
        return Err(format!("errors on pcm handle: {}", e));
    }
    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_access(pcm_handle,
                                                    hw_params.0,
                                                    alsa::SND_PCM_ACCESS_RW_INTERLEAVED)) {
        return Err(format!("handle not acessible: {}", e));
    }

    let data_type = if cfg!(target_endian = "big") {
        match format.data_type {
            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_BE,
            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_BE,
            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_BE,
        }
    } else {
        match format.data_type {
            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_LE,
            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_LE,
            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_LE,
        }
    };

    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_format(pcm_handle,
                                                    hw_params.0,
                                                    data_type)) {
        return Err(format!("format could not be set: {}", e));
    }
    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_rate(pcm_handle,
                                                  hw_params.0,
                                                  format.sample_rate.0 as libc::c_uint,
                                                  0)) {
        return Err(format!("sample rate could not be set: {}", e));
    }
    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_channels(pcm_handle,
                                                      hw_params.0,
                                                      format.channels as
                                                                      libc::c_uint)) {
        return Err(format!("channel count could not be set: {}", e));
    }

    // If this isn't set manually a overlarge buffer may be used causing audio delay
    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_buffer_time_near(
        pcm_handle,
        hw_params.0,
        &mut 100_000,
        &mut 0,
    )) {
        return Err(format!("buffer time could not be set: {}", e));
    }

    if let Err(e) = check_errors(alsa::snd_pcm_hw_params(pcm_handle, hw_params.0)) {
        return Err(format!("hardware params could not be set: {}", e));
    }

    Ok(())
}
```


Overlapping Code:
```
m_handle: *mut alsa::snd_pcm_t,
hw_params: &HwParams,
format: &Format,
) -> Result<(), String> {
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_any(pcm_handle, hw_params.0)) {
return Err(format!("errors on pcm handle: {}", e));
}
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_access(pcm_handle,
hw_params.0,
alsa::SND_PCM_ACCESS_RW_INTERLEAVED)) {
return Err(format!("handle not acessible: {}", e));
}
let data_type = if cfg!(target_endian = "big") {
match format.data_type {
SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_BE,
SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_BE,
SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_BE,
}
} else {
match format.data_type {
SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_LE,
SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_LE,
SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_LE,
}
};
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_format(pcm_handle,
hw_params.0,
data_type)) {
return Err(format!("format could not be set: {}", e));
}
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_rate(pcm_handle,
hw_params.0,
format.sample_rate.0 as libc::c_uint,
0)) {
return Err(format!("sample rate could not be set: {}", e));
}
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_channels(pcm_handle,
hw_params.0,
format.channels as
libc::c_uint)) {
return Err(format!("channel count could not be set: {}", e));
}
// If this isn't set manually a overlarge buffer may be used causing audio delay
if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_buffer_time_near(
pcm_handle,
hw_params.0,
&mut 100_000,
&mut 0,
)) {
return Err(format!("buffer time could not be set: {}", e));
}
```
<Overlap Ratio: 0.9769230769230769>

---

--- 166 --
Question ID: 63002339256b5b3b228ded2b86ff3153e0921cd3_0
Original Code:
```
fn compile_resources() -> BuildResult<()> {
    const VERSION: &str = env!("CARGO_PKG_VERSION");

    let template = fs::read_to_string("assets/miniraw.rc.in")?;
    let parts = VERSION.split('.').collect::<Vec<_>>();
    let app_version_windows = if parts.len() >= 3 {
        format!("{},{},{},0", parts[0], parts[1], parts[2])
    } else {
        "0,0,0,0".to_owned()
    };
    let rc = template
        .replace("@APP_VERSION_WINDOWS@", &app_version_windows)
        .replace("@APP_VERSION@", VERSION)
        .replace(
            "@ROOT@",
            &env::var("CARGO_MANIFEST_DIR")?.replace('\\', "/"),
        );

    let rc_path = Path::new(&env::var("OUT_DIR")?).join("miniraw.rc");
    fs::write(&rc_path, rc.as_bytes())?;

    embed_resource::compile(rc_path);

    Ok(())
}
```


Overlapping Code:
```
rces() -> BuildResult<()> {
const VERSION: &str = env!("CARGO_PKG_VERSION");
let template = fs::read_to_string("assets/miniraw.rc.in")?;
let parts = VERSION.split('.').collect::<Vec<_>>();
let app_version_windows = if parts.len() >= 3 {
format!("{},{},{},0", parts[0], parts[1], parts[2])
} else {
"0,0,0,0".to_owned()
};
let rc = template
.replace("@APP_VERSION_WINDOWS@", &app_version_windows)
.replace("@APP_VERSION@", VERSION)
.replace(
"@ROOT@",
&env::var("CARGO_MANIFEST_DIR")?.replace('\\', "/"),
);
let rc_path = Path::new(&env::var("OUT_DIR")?).join("miniraw.rc");
fs::write(&rc_path, rc.as_bytes())?;
embed_resource::compile(rc_path);
Ok(()
```
<Overlap Ratio: 0.9715994020926756>

---

--- 167 --
Question ID: b2b437f22354245840eca3e6e498291427c5015f_3
Original Code:
```
fn parse_note_no_accidentals() {
        let result = parser(note).parse("A");
        assert_eq!(result, Ok((Note::new(A, 0), "")));

        let result = parser(note).parse("G");
        assert_eq!(result, Ok((Note::new(G, 0), "")));
    }
```


Overlapping Code:
```
rse_note_no_accidentals() {
let result = parser(note).parse("A");
assert_eq!(result, Ok((Note::new(A, 0), "")));
let result = parser(note).parse("G");
```
<Overlap Ratio: 0.7352941176470589>

---

--- 168 --
Question ID: 148a32529711b4917d13f4af8a1c511d85d510a4_3
Original Code:
```
fn make_weight_accessors(weights: &FSkinWeightVertexBuffer, buffer: &mut Vec<u8>, mesh_data: &mut GLTFItem, section: &FSkelMeshRenderSection, off: usize) 
    -> ParserResult<(Rc<RefCell<GLTFAccessor>>, Rc<RefCell<GLTFAccessor>>)> {
    let joint_buffer_view = mesh_data.add_buffer_view({
        let startpos = buffer.len();
        let length = write_joints_buffer(weights, buffer, section, off)?;
        GLTFBufferView::new(startpos as u32, length)
    });
    let joint_accessor = mesh_data.add_accessor(GLTFAccessor::new(
        joint_buffer_view,
        GLTFComponentType::UnsignedShort, section.get_num_verts() as u32,
        "VEC4", GLTFAccessorValue::None, GLTFAccessorValue::None
    ));

    let weight_buffer_view = mesh_data.add_buffer_view({
        let startpos = buffer.len();
        let length = write_weights_buffer(weights, buffer, section, off)?;
        GLTFBufferView::new(startpos as u32, length)
    });
    let weight_accessor = mesh_data.add_accessor(GLTFAccessor::new(
        weight_buffer_view,
        GLTFComponentType::UnsignedByte, section.get_num_verts() as u32,
        "VEC4", GLTFAccessorValue::None, GLTFAccessorValue::None
    ).set_normalized(true));

    Ok((joint_accessor, weight_accessor))
}
```


Overlapping Code:
```
eights: &FSkinWeightVertexBuffer, buffer: &mut Vec<u8>, mesh_data: &mut GLTFItem, section: &FSkelMeshRenderSection, off: usize) 
-> ParserResult<(Rc<RefCell<GLTFAccessor>>, Rc<RefCell<GLTFAccessor>>)> {
let joint_buffer_view = mesh_data.add_buffer_view({
let startpos = buffer.len();
let length = write_joints_buffer(weights, buffer, section, off)?;
GLTFBufferView::new(startpos as u32, length)
});
let joint_accessor = mesh_data.add_accessor(GLTFAccessor::new(
joint_buffer_view,
GLTFComponentType::UnsignedShort, section.get_num_verts() as u32,
"VEC4", GLTFAccessorValue::None, GLTFAccessorValue::None
));
let weight_buffer_view = mesh_data.add_buffer_view({
let startpos = buffer.len();
let length = write_weights_buffer(weights, buffer, section, off)?;
GLTFBufferView::new(startpos as u32, length)
});
let weight_accessor = mesh_data.add_accessor(GLTFAccessor::new(
weight_buffer_view,
GLTFComponentType::UnsignedByte, section.get_num_verts() as u32,
"VEC4", GLTFAccessorValue::None, GLTFAccessorValue::None
).set_normalized(true));
Ok((joint_acce
```
<Overlap Ratio: 0.9537205081669692>

---

--- 169 --
Question ID: 81f0c7bdc33aa7a47e1522a9dc8ed63589fc8278_0
Original Code:
```
pub fn get_rdkafka_version() -> (u16, String) {
    let version_number = unsafe { rdsys::rd_kafka_version() } as u16;
    let c_str = unsafe { CStr::from_ptr(rdsys::rd_kafka_version_str()) };
    (version_number, c_str.to_string_lossy().into_owned())
}
```


Overlapping Code:
```
u16, String) {
let version_number = unsafe { rdsys::rd_kafka_version() } as u16;
let c_str = unsafe { CStr::from_ptr(rdsys::rd_kafka_version_str()) };
(version_number, c_str.to_string_lossy().into_owned())

```
<Overlap Ratio: 0.8583333333333333>

---

--- 170 --
Question ID: 05216473848c00ceff74ec3f9ad623dd59bf324a_2
Original Code:
```
fn setting_getting_caller() {
    // given
    let mut engine = Engine::new();
    let account_id = vec![1; 32];

    // when
    engine.set_caller(account_id.clone());

    // then
    let mut output = get_buffer();
    engine.caller(&mut &mut output[..]);
    assert_eq!(&output[..account_id.len()], &account_id);
}
```


Overlapping Code:
```
ller() {
// given
let mut engine = Engine::new();
let account_id = vec![1; 32];
// when
engine.set_caller(account_id.clone());
// then
let mut output = get_buffer();
engine.caller(&mut &mut output[..]);
assert_eq!(&output[..account_id.len()], &accoun
```
<Overlap Ratio: 0.8960573476702509>

---

--- 171 --
Question ID: 3de5849ae4ee3680df1543cd530ce9b5fb349dcb_2
Original Code:
```
fn test_shift_pos() {
        let a: Int32Array = vec![Some(1), None, Some(4)].into();
        let res = shift(&a, 1).unwrap();

        let expected: Int32Array = vec![None, Some(1), None].into();

        assert_eq!(res.as_ref(), &expected);
    }
```


Overlapping Code:
```
 {
let a: Int32Array = vec![Some(1), None, Some(4)].into();
let res = shift(&a, 1).unwrap();
let expected: Int32Array = vec![None, Some(1), None].into();
assert_eq!(res.as_ref(), &expected);
}
```
<Overlap Ratio: 0.909952606635071>

---

--- 172 --
Question ID: 621ce1e81b5205f9e5a8f4ed6cdbac020637a641_2
Original Code:
```
fn get_target_file_header(filepath: &str) -> Option<Header> {
    let mut file = File::open(format!("{}.cache", filepath)).ok()?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).ok()?;
    let header: Header = serde_json::from_str(contents.trim()).ok()?;
    Some(header)
}
```


Overlapping Code:
```
arget_file_header(filepath: &str) -> Option<Header> {
let mut file = File::open(format!("{}.cache", filepath)).ok()?;
let mut contents = String::new();
file.read_to_string(&mut contents).ok()?;
let header: Header = serde_json::from_str(contents.trim(
```
<Overlap Ratio: 0.8865248226950354>

---

--- 173 --
Question ID: 3eeb5f3f4ecb0c8ac6444551d55612497a0e0580_11
Original Code:
```
fn test_parse_valid_ses_verify_domain_dkim() {
        let mock_response = MockResponseReader::read_response("test_resources/generated/valid",
                                                              "ses-verify-domain-dkim.xml");
        let mock = MockRequestDispatcher::with_status(200).with_body(&mock_response);
        let client = SesClient::new(mock, MockCredentialsProvider, rusoto_region::UsEast1);
        let request = VerifyDomainDkimRequest::default();
        let result = client.verify_domain_dkim(&request);
        assert!(result.is_ok(), "parse error: {:?}", result);
    }
```


Overlapping Code:
```

let mock_response = MockResponseReader::read_response("test_resources/generated/valid",ml");
let mock = MockRequestDispatcher::with_status(200).with_body(&mock_response);
let client =lient::new(mock, MockCredentialsProvider, rusoto_region::UsEast1);
let request (&request);
assert!(result.is_ok(), "parse error: {:?}", result);
```
<Overlap Ratio: 0.6790890269151139>

---

--- 174 --
Question ID: 814f424c5a62e828e2da1367fe7f0b9dbcbafec3_9
Original Code:
```
fn parent() {
        let bitvec = bit_vec![true, true, false, false];
        let tree: LOUDSTree<String> = LOUDSTree::from_bitvec(bitvec.clone()).unwrap();
        assert_eq!(tree.parent(3).unwrap(), 1)
    }
```


Overlapping Code:
```
 {
let bitvec = bit_vec![true, true, false, false];
let tree: LOUDSTree<String> = LOUDSTree::from_bitvec(bitvec.clone()).unwrap();
assert_eq!(tree.
```
<Overlap Ratio: 0.8076923076923077>

---

--- 175 --
Question ID: 9e39d8f82fe31b0658e57ea626596d2de50ea866_3
Original Code:
```
fn no_version_returns_none() {
        let mut installs = SystemLabviewInstalls::new();

        let install = LabviewInstall {
            version: String::from("2011"),
            bitness: Bitness::X64,
            path: PathBuf::from("C:\\LV2011_64"),
        };

        installs.add_install(install);

        // Non-existant version
        assert_eq!(installs.get_version("2012", Bitness::X64), None);
    }
```


Overlapping Code:
```
let mut installs = SystemLabviewInstalls::new();
let install = LabviewInstall {
version: String::from("2011"),
bitness: Bitness::X64,
path: PathBuf::from("C:\\LV2011_64"),
};
installs.add_install(install);
// Non-existant version
assert_eq!(installs.
```
<Overlap Ratio: 0.7716049382716049>

---

--- 176 --
Question ID: 6c421ef40e41eb38a8a331c1c4bac35636e5c39b_2
Original Code:
```
fn make_fixture(size: usize, cos: bool) -> Vec<f32> {
        let step = f32::consts::PI * 2.0 / size as f32;
        let mut data = Vec::new();
        let mut value = 0.0f32;
        for _ in 0..size {
            data.push(value.sin());
            if cos { data.push(value.cos()); }
            value += step;
        }
        data
    }
```


Overlapping Code:
```
32> {
let step = f32::consts::PI * 2.0 / size as f32;
let mut data = Vec::new();
let mut value = 0.0f32;
for _ in 0..size {
data.push(value.sin());
if cos { data.push(value.cos()); }
value += step;
}

```
<Overlap Ratio: 0.7874015748031497>

---

--- 177 --
Question ID: 862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e_29
Original Code:
```
fn resolve_and_backtracking() {
    let p = project("foo")
        .file("Cargo.toml", r#"
            [project]
            name = "bar"
            version = "0.5.0"
            authors = []

            [dependencies]
            foo = "*"
        "#)
        .file("src/main.rs", "fn main() {}")
        .build();

    Package::new("foo", "0.1.1")
            .feature_dep("bar", "0.1", &["a", "b"])
            .publish();
    Package::new("foo", "0.1.0").publish();

    assert_that(p.cargo("build"),
                execs().with_status(0));
}
```


Overlapping Code:
```
() {
let p = project("foo")
.file("Cargo.toml", r#"
[project]
name = "bar"
version = "0.5.0"
authors = []
[dependencies]
foo = "*"
"#)
.file("src/main.rs", "fn main() {}")
.build();
Package::new("foo", "0.1.1")
.feature_dep("bar", "0.1", &["a", "b"])
.publish();
Package::new("foo", "0.1.0").publish();
assert_that(p.cargo("build"),
execs().with_status(0));

```
<Overlap Ratio: 0.927461139896373>

---

--- 178 --
Question ID: 46cad70abb82cb9bad097e96f56ef7fbce047205_4
Original Code:
```
fn mul() {
        assert_eq!(
            ScalarWitness::from(5u64) * ScalarWitness::from(6u64),
            ScalarWitness::from(30u64)
        );

        assert_eq!(
            -ScalarWitness::from(2u64) * ScalarWitness::from(7u64),
            -ScalarWitness::from(14u64)
        );

        assert_eq!(
            ScalarWitness::from(100u64) * ScalarWitness::from(Scalar::from(0xffu64)),
            ScalarWitness::from(Scalar::from(100u64) * Scalar::from(0xffu64))
        );

        assert_eq!(
            ScalarWitness::from(Scalar::from(0xffu64)) * ScalarWitness::from(Scalar::from(0xfeu64)),
            ScalarWitness::from(Scalar::from(0xffu64) * Scalar::from(0xfeu64))
        );
    }
```


Overlapping Code:
```
) {
assert_eq!(
ScalarWitness::from(5u64) * ScalarWitness::from(6u64),
ScalarWitness::from(30u64)
);
assert_eq!(
-ScalarWitness::from(2u64) * ScalarWitness::from(7u64),
-ScalarWitness::from(14u64)
);
assert_eq!(
ScalarWitness::from(100u64) * ScalarWitness::from(Scalar::from(0xffu64)),
ScalarWitness::from(Scalar::from(100u64) * Scalar::from(0xffu64))
);
assert_eq!(
ScalarWitness::from(Scalar::from(0xffu64)) * ScalarWitness::from(Scalar::from(0xfeu64)),
ScalarWitness::from(Scalar::from(0xffu64) * 
```
<Overlap Ratio: 0.9363295880149812>

---

--- 179 --
Question ID: 26caec3b68200965c1ae496817ad5becc02735bf_0
Original Code:
```
fn encrypt_decrypt_lossless() {
        let mut henon = HenonMap{parameters: HenonMapParametersBuilder::default()
                .build()
                .unwrap()};
        match fs::create_dir_all("assets/lossless") {
            Ok(f) => f,
            Err(e) => println!("Error: {}.", e),
        };
        henon.transform(&"assets/lenna.png".to_string(), &"assets/lossless/lenna_encrypted.png".to_string()).unwrap();
        henon.transform(&"assets/lossless/lenna_encrypted.png".to_string(), &"assets/lossless/lenna_decrypted.png".to_string()).unwrap();
        assert_eq!(image_diff(&"assets/lenna.png".to_string(), &"assets/lossless/lenna_decrypted.png".to_string()), 0 as f64);
        match fs::remove_dir_all("assets/lossless") {
            Ok(f) => f,
            Err(e) => println!("Error: {}.", e),
        };
    }
```


Overlapping Code:
```
n encrypt_decrypt_lossless() {
let mut henon = HenonMap{parameters: HenonMapParametersBuilder::default()
.build()
.unwrap()};
match fs::create_dir_all("assets/lossless") {
Ok(f) => f,
Err(e) => println!("Error: {}.", e),
};
henon.transform(&"assets/lenna.png".to_string(), &"assets/lossless/lenna_encrypted.png".to_string()).unwrap();
henon.transform(&"assets/lossless/lenna_encrypted.png".to_string(), &"assets/lossless/lenna_decrypted.png".to_string()).unwrap();
assert_eq!(image_diff(&"assets/lenna.png".to_string(), &"assets/lossless/lenna_decrypted.png".to_string()), 0 as f64);
match fs::remove_dir_all("assets/lossless") {
Ok(f) => f,
Err(e) => println!("Error: {}.", e),
```
<Overlap Ratio: 0.9912280701754386>

---

--- 180 --
Question ID: 3deac005077f7c70c346c676b2f9596a2b4440d9_22
Original Code:
```
fn difference_with_a_lhs_xml_value() {
        let expected = expected_values(
            r#"SELECT "users".* FROM "users" WHERE $1 <> "xmlField"::text"#,
            vec![Value::xml("<salad>wurst</salad>")],
        );

        let value_expr: Expression = Value::xml("<salad>wurst</salad>").into();
        let query = Select::from_table("users").so_that(value_expr.not_equals(Column::from("xmlField")));
        let (sql, params) = Postgres::build(query).unwrap();

        assert_eq!(expected.0, sql);
        assert_eq!(expected.1, params);
    }
```


Overlapping Code:
```
e_with_a_lhs_xml_value() {
let expected = expected_values(
r#"SELECT "users".* FROM "users" WHERE $1 <> "xmlField"::text"#,
vec![Value::xml("<salad>wurst</salad>")],
);
let value_expr: Expression = Value::xml("<salad>wurst</salad>").into();
let query = Select::from_table("users").so_that(value_expr.not_equals(Column::from("xmlField")));
let (sql, params) = Postgres::build(query).unwrap();
assert_eq!(expected.0, sql);
assert_eq!(expected.1, params);
}
```
<Overlap Ratio: 0.9742489270386266>

---

--- 181 --
Question ID: b58d5fdb9b9ccd968c297d727f1f4aeeb81a12f9_0
Original Code:
```
pub fn subactions(tokens: &[&str], character: &str) -> Vec<&'static str> {
    // TODO: This should be made a vector to contain all the subactions related to the action. (multiple jabs, smash attack startup/attack)
    // TODO: Manually handle character specific stuff such as jabs, glides, etc
    let mut subactions = vec!();

    // common movement
    if tokens.contains(&"dash")                              { subactions = vec!("Dash") }
    if tokens.contains(&"run")                               { subactions = vec!("Run") }
    if tokens.contains(&"teeter")                            { subactions = vec!("OttottoWait") }
    if tokens.contains(&"crouch")                            { subactions = vec!("SquatWait") }
    if tokens.contains(&"idle")                              { subactions = vec!("Wait1") }
    if tokens.contains(&"jump") && tokens.contains(&"squat") { subactions = vec!("JumpSquat") }
    if tokens.contains(&"jumpsquat")                         { subactions = vec!("JumpSquat") }

    // jabs
    if tokens.contains(&"jab") { subactions = vec!("Attack11") }

    // dash attack
    if tokens.contains(&"dash") && tokens.contains(&"attack") { subactions = vec!("AttackDash") }
    if tokens.contains(&"dashattack")                         { subactions = vec!("AttackDash") }

    // grabs
    if tokens.contains(&"grab")                              { subactions = vec!("Catch") }
    if tokens.contains(&"dash")  && tokens.contains(&"grab") { subactions = vec!("CatchDash") }
    if tokens.contains(&"dashgrab")                          { subactions = vec!("CatchDash") }
    if tokens.contains(&"pivot") && tokens.contains(&"grab") { subactions = vec!("CatchTurn") }
    if tokens.contains(&"pivotgrab")                         { subactions = vec!("CatchTurn") }
    if tokens.contains(&"turn")  && tokens.contains(&"grab") { subactions = vec!("CatchTurn") }
    if tokens.contains(&"turngrab")                          { subactions = vec!("CatchTurn") }
    if tokens.contains(&"pummel")                            { subactions = vec!("CatchAttack") }

    //throws
    if tokens.contains(&"up")      && tokens.contains(&"throw") { subactions = vec!("ThrowHi") }
    if tokens.contains(&"upthrow")                              { subactions = vec!("ThrowHi") }
    if tokens.contains(&"uthrow")                               { subactions = vec!("ThrowHi") }
    if tokens.contains(&"down")    && tokens.contains(&"throw") { subactions = vec!("ThrowLw") }
    if tokens.contains(&"downthrow")                            { subactions = vec!("ThrowLw") }
    if tokens.contains(&"dthrow")                               { subactions = vec!("ThrowLw") }
    if tokens.contains(&"back")    && tokens.contains(&"throw") { subactions = vec!("ThrowB") }
    if tokens.contains(&"backthrow")                            { subactions = vec!("ThrowB") }
    if tokens.contains(&"bthrow")                               { subactions = vec!("ThrowB") }
    if tokens.contains(&"forward") && tokens.contains(&"throw") { subactions = vec!("ThrowF") }
    if tokens.contains(&"forwardthrow")                         { subactions = vec!("ThrowF") }
    if tokens.contains(&"fthrow")                               { subactions = vec!("ThrowF") }

    // tilts
    if tokens.contains(&"up")      && tokens.contains(&"tilt") { subactions = vec!("AttackHi3") }
    if tokens.contains(&"uptilt")                              { subactions = vec!("AttackHi3") }
    if tokens.contains(&"utilt")                               { subactions = vec!("AttackHi3") }
    if tokens.contains(&"down")    && tokens.contains(&"tilt") { subactions = vec!("AttackLw3") }
    if tokens.contains(&"downtilt")                            { subactions = vec!("AttackLw3") }
    if tokens.contains(&"dtilt")                               { subactions = vec!("AttackLw3") }
    if tokens.contains(&"forward") && tokens.contains(&"tilt") { subactions = vec!("AttackS3S") }
    if tokens.contains(&"forwardtilt")                         { subactions = vec!("AttackS3S") }
    if tokens.contains(&"ftilt")                               { subactions = vec!("AttackS3S") }
    if tokens.contains(&"side")    && tokens.contains(&"tilt") { subactions = vec!("AttackS3S") }
    if tokens.contains(&"sidetilt")                            { subactions = vec!("AttackS3S") }
    if tokens.contains(&"stilt")                               { subactions = vec!("AttackS3S") }

    // ledge getup
    let ledge = tokens.contains(&"ledge") || tokens.contains(&"edge") || tokens.contains(&"cliff");
    if ledge && tokens.contains(&"attack") && tokens.contains(&"slow")  { subactions = vec!("CliffAttackSlow") }
    if ledge && tokens.contains(&"attack") && tokens.contains(&"quick") { subactions = vec!("CliffAttackQuick") }
    if ledge && tokens.contains(&"roll")   && tokens.contains(&"slow")  { subactions = vec!("CliffEscapeSlow") }
    if ledge && tokens.contains(&"roll")   && tokens.contains(&"quick") { subactions = vec!("CliffEscapeQuick") }
    if ledge && tokens.contains(&"getup")  && tokens.contains(&"slow")  { subactions = vec!("CliffClimbSlow") }
    if ledge && tokens.contains(&"getup")  && tokens.contains(&"quick") { subactions = vec!("CliffClimbQuick") }

    // getup
    let facedown = tokens.contains(&"facedown") || tokens.contains(&"down") || tokens.contains(&"d");
    if tokens.contains(&"getup") && tokens.contains(&"attack")             { subactions = vec!("DownAttackU") }
    if tokens.contains(&"getup") && tokens.contains(&"attack") && facedown { subactions = vec!("DownAttackD") }
    if tokens.contains(&"getup") && tokens.contains(&"stand")              { subactions = vec!("DownStandU") }
    if tokens.contains(&"getup") && tokens.contains(&"stand")  && facedown { subactions = vec!("DownStandD") }

    // trip
    if tokens.contains(&"trip") || tokens.contains(&"slip")   { subactions = vec!("Slip") }
    if tokens.contains(&"trip") && tokens.contains(&"attack") { subactions = vec!("DownAttackU") }
    if tokens.contains(&"trip") && tokens.contains(&"stand")  { subactions = vec!("DownStandU") }

    // escape
    if tokens.contains(&"spotdodge")                                { subactions = vec!("EscapeN") }
    if tokens.contains(&"spot")    && tokens.contains(&"dodge")     { subactions = vec!("EscapeN") }
    if tokens.contains(&"airdodge")                                 { subactions = vec!("EscapeAir") }
    if tokens.contains(&"air")     && tokens.contains(&"dodge")     { subactions = vec!("EscapeAir") }
    if tokens.contains(&"roll")    && tokens.contains(&"forward")   { subactions = vec!("EscapeF") }
    if tokens.contains(&"roll")    && tokens.contains(&"forwards")  { subactions = vec!("EscapeF") }
    if tokens.contains(&"roll")    && tokens.contains(&"backward")  { subactions = vec!("EscapeB") }
    if tokens.contains(&"roll")    && tokens.contains(&"backwards") { subactions = vec!("EscapeB") }
    if tokens.contains(&"roll")    && tokens.contains(&"back")      { subactions = vec!("EscapeB") }

    // yeet
    if tokens.contains(&"yeet") && "Ness" == character {
        subactions = vec!("ThrowB");
    }

    // crawl attack
    if (tokens.contains(&"crawl") && tokens.contains(&"attack")) ||
        (tokens.contains(&"crawl") && tokens.contains(&"tilt"))  ||
        tokens.contains(&"ctilt") {
        match character {
            "Lucario"  => subactions = vec!("AttackSquat"),
            "Squirtle" => subactions = vec!("AttackSquat"),
            "Snake"    => subactions = vec!("AttackLwShank"),
            "Samus"    => subactions = vec!("SpecialSDash"),
            _ => { }
        }
    }

    // Smashes
    if tokens.contains(&"up")      && tokens.contains(&"smash") { subactions = vec!("AttackHi4Start", "AttackHi4") }
    if tokens.contains(&"upsmash")                              { subactions = vec!("AttackHi4Start", "AttackHi4") }
    if tokens.contains(&"usmash")                               { subactions = vec!("AttackHi4Start", "AttackHi4") }
    if tokens.contains(&"down")    && tokens.contains(&"smash") { subactions = vec!("AttackLw4Start", "AttackLw4") }
    if tokens.contains(&"downsmash")                            { subactions = vec!("AttackLw4Start", "AttackLw4") }
    if tokens.contains(&"dsmash")                               { subactions = vec!("AttackLw4Start", "AttackLw4") }
    if tokens.contains(&"forward") && tokens.contains(&"smash") { subactions = vec!("AttackS4Start", "AttackS4S") }
    if tokens.contains(&"forwardsmash")                         { subactions = vec!("AttackS4Start", "AttackS4S") }
    if tokens.contains(&"fsmash")                               { subactions = vec!("AttackS4Start", "AttackS4S") }
    if tokens.contains(&"side")    && tokens.contains(&"smash") { subactions = vec!("AttackS4Start", "AttackS4S") }
    if tokens.contains(&"sidesmash")                            { subactions = vec!("AttackS4Start", "AttackS4S") }
    if tokens.contains(&"ssmash")                               { subactions = vec!("AttackS4Start", "AttackS4S") }

    // aerials
    if tokens.contains(&"up")      && tokens.contains(&"air") { subactions = vec!("AttackAirHi") }
    if tokens.contains(&"upair")                              { subactions = vec!("AttackAirHi") }
    if tokens.contains(&"uair")                               { subactions = vec!("AttackAirHi") }
    if tokens.contains(&"down")    && tokens.contains(&"air") { subactions = vec!("AttackAirLw") }
    if tokens.contains(&"downair")                            { subactions = vec!("AttackAirLw") }
    if tokens.contains(&"dair")                               { subactions = vec!("AttackAirLw") }
    if tokens.contains(&"forward") && tokens.contains(&"air") { subactions = vec!("AttackAirF") }
    if tokens.contains(&"forwardair")                         { subactions = vec!("AttackAirF") }
    if tokens.contains(&"fair")                               { subactions = vec!("AttackAirF") }
    if tokens.contains(&"unfair")                             { subactions = vec!("AttackAirF") }
    if tokens.contains(&"back")    && tokens.contains(&"air") { subactions = vec!("AttackAirB") }
    if tokens.contains(&"backair")                            { subactions = vec!("AttackAirB") }
    if tokens.contains(&"bair")                               { subactions = vec!("AttackAirB") }
    if tokens.contains(&"neutral") && tokens.contains(&"air") { subactions = vec!("AttackAirN") }
    if tokens.contains(&"neutralair")                         { subactions = vec!("AttackAirN") }
    if tokens.contains(&"nair")                               { subactions = vec!("AttackAirN") }

    // specials
    if tokens.contains(&"u")       && tokens.contains(&"special") { subactions = vec!("SpecialHi") }
    if tokens.contains(&"up")      && tokens.contains(&"special") { subactions = vec!("SpecialHi") }
    if tokens.contains(&"up")      && tokens.contains(&"b")       { subactions = vec!("SpecialHi") }
    if tokens.contains(&"upspecial")                              { subactions = vec!("SpecialHi") }
    if tokens.contains(&"uspecial")                               { subactions = vec!("SpecialHi") }
    if tokens.contains(&"upb")                                    { subactions = vec!("SpecialHi") }
    if tokens.contains(&"d")       && tokens.contains(&"special") { subactions = vec!("SpecialLw") }
    if tokens.contains(&"down")    && tokens.contains(&"special") { subactions = vec!("SpecialLw") }
    if tokens.contains(&"down")    && tokens.contains(&"b")       { subactions = vec!("SpecialLw") }
    if tokens.contains(&"downspecial")                            { subactions = vec!("SpecialLw") }
    if tokens.contains(&"dspecial")                               { subactions = vec!("SpecialLw") }
    if tokens.contains(&"downb")                                  { subactions = vec!("SpecialLw") }
    if tokens.contains(&"n")       && tokens.contains(&"special") { subactions = vec!("SpecialN") }
    if tokens.contains(&"neutral") && tokens.contains(&"special") { subactions = vec!("SpecialN") }
    if tokens.contains(&"neutral") && tokens.contains(&"b")       { subactions = vec!("SpecialN") }
    if tokens.contains(&"neutralspecial")                         { subactions = vec!("SpecialN") }
    if tokens.contains(&"nspecial")                               { subactions = vec!("SpecialN") }
    if tokens.contains(&"neutralb")                               { subactions = vec!("SpecialN") }
    if tokens.contains(&"f")       && tokens.contains(&"special") { subactions = vec!("SpecialS") }
    if tokens.contains(&"forward") && tokens.contains(&"special") { subactions = vec!("SpecialS") }
    if tokens.contains(&"forward") && tokens.contains(&"b")       { subactions = vec!("SpecialS") }
    if tokens.contains(&"forwardspecial")                         { subactions = vec!("SpecialS") }
    if tokens.contains(&"fspecial")                               { subactions = vec!("SpecialS") }
    if tokens.contains(&"forwardb")                               { subactions = vec!("SpecialS") }
    if tokens.contains(&"s")       && tokens.contains(&"special") { subactions = vec!("SpecialS") }
    if tokens.contains(&"side")    && tokens.contains(&"special") { subactions = vec!("SpecialS") }
    if tokens.contains(&"side")    && tokens.contains(&"b")       { subactions = vec!("SpecialS") }
    if tokens.contains(&"sidespecial")                            { subactions = vec!("SpecialS") }
    if tokens.contains(&"sspecial")                               { subactions = vec!("SpecialS") }
    if tokens.contains(&"sideb")                                  { subactions = vec!("SpecialS") }

    // specials air
    if tokens.contains(&"air") && tokens.contains(&"u")       && tokens.contains(&"special") { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"up")      && tokens.contains(&"special") { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"up")      && tokens.contains(&"b")       { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"upspecial")                              { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"uspecial")                               { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"upb")                                    { subactions = vec!("SpecialAirHi") }
    if tokens.contains(&"air") && tokens.contains(&"d")       && tokens.contains(&"special") { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"down")    && tokens.contains(&"special") { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"down")    && tokens.contains(&"b")       { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"downspecial")                            { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"dspecial")                               { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"downb")                                  { subactions = vec!("SpecialAirLw") }
    if tokens.contains(&"air") && tokens.contains(&"n")       && tokens.contains(&"special") { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"neutral") && tokens.contains(&"special") { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"neutral") && tokens.contains(&"b")       { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"neutralspecial")                         { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"nspecial")                               { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"neutralb")                               { subactions = vec!("SpecialAirN") }
    if tokens.contains(&"air") && tokens.contains(&"f")       && tokens.contains(&"special") { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"forward") && tokens.contains(&"special") { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"forward") && tokens.contains(&"b")       { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"forwardspecial")                         { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"fspecial")                               { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"forwardb")                               { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"s")       && tokens.contains(&"special") { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"side")    && tokens.contains(&"special") { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"side")    && tokens.contains(&"b")       { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"sidespecial")                            { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"sspecial")                               { subactions = vec!("SpecialAirS") }
    if tokens.contains(&"air") && tokens.contains(&"sideb")                                  { subactions = vec!("SpecialAirS") }

    // taunts
    if tokens.contains(&"utaunt") { subactions = vec!("AppealHiR") }
    if tokens.contains(&"dtaunt") { subactions = vec!("AppealLwR") }
    if tokens.contains(&"staunt") { subactions = vec!("AppealS") }
    if tokens.contains(&"up")   && tokens.contains(&"taunt") { subactions = vec!("AppealHi") }
    if tokens.contains(&"down") && tokens.contains(&"taunt") { subactions = vec!("AppealLw") }
    if tokens.contains(&"side") && tokens.contains(&"taunt") { subactions = vec!("AppealS") }
    if tokens.contains(&"lose")                              { subactions = vec!("Lose") }
    if (tokens.contains(&"1") && tokens.contains(&"win")) || tokens.contains(&"win1") { subactions = vec!("Win1") }
    if (tokens.contains(&"2") && tokens.contains(&"win")) || tokens.contains(&"win2") { subactions = vec!("Win2") }
    if (tokens.contains(&"3") && tokens.contains(&"win")) || tokens.contains(&"win3") { subactions = vec!("Win3") }

    subactions
}
```


Overlapping Code:
```
, character: &str) -> Vec<&'static str> {
// TODO: This should be made a vector to contain all the subactions related to the action. (multiple jabs, smash attack startup/attack)
// TODO: Manually handle character specific stuff such as jabs, glides, etc
let mut subactions = vec!();
// common movement
if tokens.contains(&"dash") { subactions = vec!("Dash") }
if tokens.contains(&"run") { subactions = vec!("Run") }
if tokens.contains(&"teeter") { subactions = vec!("OttottoWait") }
if tokens.contains(&"crouch") { subactions = vec!("SquatWait") }
if tokens.contains(&"idle") { subactions = vec!("Wait1") }
if tokens.contains(&"jump") && tokens.contains(&"squat") { subactions = vec!("JumpSquat") }
if tokens.contains(&"jumpsquat") { subactions = vec!("JumpSquat") }
// jabs
if tokens.contains(&"jab") { subactions = vec!("Attack11") }
// dash attack
if tokens.contains(&"dash") && tokens.contains(&"attack") { subactions = vec!("AttackDash") }
if tokens.contains(&"dashattack") { subactions = vec!("AttackDash") }
// grabs
if tokens.contains(&"grab") { subactions = vec!("Catch") }
if tokens.contains(&"dash") && tokens.contains(&"grab") { subactions = vec!("CatchDash") }
if tokens.contains(&"dashgrab") { subactions = vec!("CatchDash") }
if tokens.contains(&"pivot") && tokens.contains(&"grab") { subactions = vec!("CatchTurn") }
if tokens.contains(&"pivotgrab") { subactions = vec!("CatchTurn") }
if tokens.contains(&"turn") && tokens.contains(&"grab") { subactions = vec!("CatchTurn") }
if tokens.contains(&"turngrab") { subactions = vec!("CatchTurn") }
if tokens.contains(&"pummel") { subactions = vec!("CatchAttack") }
//throws
if tokens.contains(&"up") && tokens.contains(&"throw") { subactions = vec!("ThrowHi") }
if tokens.contains(&"upthrow") { subactions = vec!("ThrowHi") }
if tokens.contains(&"uthrow") { subactions = vec!("ThrowHi") }
if tokens.contains(&"down") && tokens.contains(&"throw") { subactions = vec!("ThrowLw") }
if toke
```
<Overlap Ratio: 0.9828369510348309>

---

--- 182 --
Question ID: 7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d_53
Original Code:
```
fn cp_equals_0() {
        let mut mem: Memory = Memory::new();
        let mut cpu: CPU = CPU::new(&mut mem);

        cp(&mut cpu, Register8bits::B);

        assert_eq!(cpu.registers.read_z_flag(), true)
    }
```


Overlapping Code:
```
equals_0() {
let mut mem: Memory = Memory::new();
let mut cpu: CPU = CPU::new(&mut mem);
cp(&mut cpu, Register8bits::B);
assert_eq!(cpu.registers.read
```
<Overlap Ratio: 0.8620689655172413>

---

--- 183 --
Question ID: fca020326a46bc5abaad26abc848d7a31fc8aa39_0
Original Code:
```
pub fn colors(input: &str) -> model::R<view::Colors> {
    if input == "simple" {
        // Add colorscheme presets here
        return Ok(view::Colors {
            ok: Some(Color::Fixed(2)),
            high: Some(Color::Fixed(1)),
            normal: Some(Color::Fixed(3)),
        });
    }

    let parts: Vec<u8> = input
        .split(',')
        .map(|s| s.parse::<u8>().unwrap_or(0))
        .collect();

    match parts.len() {
        3 => Ok(view::Colors {
            ok: Some(Color::Fixed(parts[0])),
            high: Some(Color::Fixed(parts[1])),
            normal: Some(Color::Fixed(parts[2])),
        }),
        l => Err(format!(
            "Unknown custom color input: {}. Expected 4 terms, but got {}.",
            input, l
        )),
    }
}
```


Overlapping Code:
```
 &str) -> model::R<view::Colors> {
if input == "simple" {
// Add colorscheme presets here
return Ok(view::Colors {
ok: Some(Color::Fixed(2)),
high: Some(Color::Fixed(1)),
normal: Some(Color::Fixed(3)),
});
}
let parts: Vec<u8> = input
.split(',')
.map(|s| s.parse::<u8>().unwrap_or(0))
.collect();
match parts.len() {
3 => Ok(view::Colors {
ok: Some(Color::Fixed(parts[0])),
high: Some(Color::Fixed(parts[1])),
normal: Some(Color::Fixed(parts[2])),
}),
l => Err(format!(
"Unknown custom color input: {}. Expected 4 terms, but got {}.",
input, l
)),
}
```
<Overlap Ratio: 0.9615384615384616>

---

--- 184 --
Question ID: 826fcce4520871552dc7894082787c6104e5acf8_13
Original Code:
```
fn test_validate_phase_rejects_partial_def() {
        let good_value: Option<f64> = Some(0.0);
        let good_units: Option<AngleType> = Some(AngleType::Degrees);
        assert!(validate_phase(&good_value, &None).is_err());
        assert!(validate_phase(&None, &good_units).is_err());
    }
```


Overlapping Code:
```
t_validate_phase_rejects_partial_def() {
let good_value: Option<f64> = Some(0.0);
let good_units: Option<AngleType> = Some(AngleType::Degrees);
assert!(validate_phase(&good_value, &None).is_err());
assert!(validate_phase(&None, &good_units).is_err())
```
<Overlap Ratio: 0.9652509652509652>

---

--- 185 --
Question ID: 008e5912f49bcf34bed169ddffc5f10575f28b1d_4
Original Code:
```
fn test_memorydb_threading() {
        let col_name: &str = BLOCKS_DB_COLUMN;

        let db = Arc::new(MemoryDB::open());

        let thread_count = 10;
        let write_count = 10;

        // We're execting the product of these numbers to fit in one byte.
        assert!(thread_count * write_count <= 255);

        let mut handles = vec![];
        for t in 0..thread_count {
            let wc = write_count;
            let db = db.clone();
            let col = col_name.clone();
            let handle = thread::spawn(move || {
                for w in 0..wc {
                    let key = (t * w) as u8;
                    let val = 42;
                    db.put(&col, &vec![key], &vec![val]).unwrap();
                }
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().unwrap();
        }

        for t in 0..thread_count {
            for w in 0..write_count {
                let key = (t * w) as u8;
                let val = db.get(&col_name, &vec![key]).unwrap().unwrap();
                assert_eq!(vec![42], val);
            }
        }
    }
```


Overlapping Code:
```
ame: &str = BLOCKS_DB_COLUMN;
let db = Arc::new(MemoryDB::open());
let thread_count = 10;
let write_count = 10;
// We're execting the product of these numbers to fit in one byte.
assert!(thread_count * write_count <= 255);
let mut handles = vec![];
for t in 0..thread_count {
let wc = write_count;
let db = db.clone();
let col = col_name.clone();
let handle = thread::spawn(move || {
for w in 0..wc {
let key = (t * w) as u8;
let val = 42;
db.put(&col, &vec![key], &vec![val]).unwrap();
}
});
handles.push(handle);
}
for handle in handles {
handle.join().unwrap();
}
for t in 0..thread_count {
for w in 0..write_count {
let key = (t * w) as u8;
let val = db.get(&col_name, &vec![key]).unwrap().unwrap();

```
<Overlap Ratio: 0.9072164948453608>

---

--- 186 --
Question ID: d3a3b6d708be4c157507c35f97cb917d50b278b3_6
Original Code:
```
fn upsample_multioutput(&mut self, img: &dyn core::ToInputArray, imgs_new: &mut core::Vector<core::Mat>, scale_factors: &core::Vector<i32>, node_names: &core::Vector<String>) -> Result<()> {
		input_array_arg!(img);
		return_send!(via ocvrs_return);
		unsafe { sys::cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayR_vector_Mat_R_const_vector_int_R_const_vector_String_R(self.as_raw_mut_DnnSuperResImpl(), img.as_raw__InputArray(), imgs_new.as_raw_mut_VectorOfMat(), scale_factors.as_raw_VectorOfi32(), node_names.as_raw_VectorOfString(), ocvrs_return.as_mut_ptr()) };
		return_receive!(unsafe ocvrs_return => ret);
		let ret = ret.into_result()?;
		Ok(ret)
	}
```


Overlapping Code:
```
ultioutput(&mut self, img: &dyn core::ToInputArray, imgs_new: &mut core::Vector<core::Mat>, scale_factors: &core::Vector<i32>, node_names: &core::Vector<String>) -> Result<()> {
input_array_arg!(img);
return_send!(via ocvrs_return);
unsafe { sys::cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayR_vector_Mat_R_const_vector_int_R_const_vector_String_R(self.as_raw_mut_DnnSuperResImpl(), img.as_raw__InputArray(), imgs_new.as_raw_mut_VectorOfMat(), scale_factors.as_raw_VectorOfi32(), node_names.as_raw_VectorOfString(), ocvrs_return.as_mut_ptr()) };
return_receive!(unsafe ocvrs_return => ret);
let ret = ret.into_result()?;
Ok(ret)
}
```
<Overlap Ratio: 0.9805097451274363>

---

--- 187 --
Question ID: 72a69f0c391af9a5778bb8c66ad58f96b6f980f7_1
Original Code:
```
fn it_works_string() {
        let mut lexer = Document::new("\"test\"");
        assert_eq!(lexer.next(), Some(Token::String { start: 0, end: 5 }));
        assert_eq!(lexer.next(), None);

        let mut lexer = Document::new("\"test");
        assert_eq!(lexer.next(), Some(Token::InvalidJSON { index: 0 }));
        assert_eq!(lexer.next(), None);
    }
```


Overlapping Code:
```
t lexer = Document::new("\"test\"");
assert_eq!(lexer.next(), Some(Token::String { start: 0, end: 5 }));
assert_eq!(lexer.next(), None);
let mut lexer = Document::new("\"test");
assert_eq!(lexer.next(), Some(Token::InvalidJSON { index: 0 }));
assert_
```
<Overlap Ratio: 0.819672131147541>

---

--- 188 --
Question ID: dbc2a3e87800e15f1c7dd681947024518bd95164_5
Original Code:
```
pub extern "C" fn dmtr_connect(
    qtok_out: *mut dmtr_qtoken_t,
    qd: c_int,
    saddr: *const sockaddr,
    size: socklen_t,
) -> c_int {
    trace!("dmtr_connect()");

    // Check if socket address is invalid.
    if saddr.is_null() {
        return libc::EINVAL;
    }

    // Check if socket address length is invalid.
    if size as usize != mem::size_of::<libc::sockaddr_in>() {
        return libc::EINVAL;
    }

    // Get socket address.
    let endpoint: Ipv4Endpoint = match sockaddr_to_ipv4endpoint(saddr) {
        Ok(endpoint) => endpoint,
        Err(e) => {
            warn!("connect() failed: {:?}", e);
            return e.errno;
        },
    };

    // Issue connect operation.
    with_libos(|libos| match libos.connect(qd.into(), endpoint) {
        Ok(qt) => {
            unsafe { *qtok_out = qt.into() };
            0
        },
        Err(e) => {
            warn!("connect() failed: {:?}", e);
            e.errno
        },
    })
}
```


Overlapping Code:
```
" fn dmtr_connect(
qtok_out: *mut dmtr_qtoken_t,
qd: c_int,
saddr: *const sockaddr,
size: socklen_t,
) -> c_int {
trace!("dmtr_connect()");
// Check if socket address is invalid.
if saddr.is_null() {
return libc::EINVAL;
}
// Check if socket address length is invalid.
if size as usize != mem::size_of::<libc::sockaddr_in>() {
return libc::EINVAL;
}
// Get socket address.
let endpoint: Ipv4Endpoint = match sockaddr_to_ipv4endpoint(saddr) {
Ok(endpoint) => endpoint,
Err(e) => {
warn!("connect() failed: {:?}", e);
return e.errno;
},
};
// Issue connect operation.
with_libos(|libos| match libos.connect(qd.into(), endpoint) {
Ok(qt) => {
unsafe { *qtok_out = qt.into() };
0
},
Err(e) => {
warn!("co
```
<Overlap Ratio: 0.9271523178807947>

---

--- 189 --
Question ID: 3d092515e8fcb817d274bfd5a9df7fcf8a1d28bc_1
Original Code:
```
pub unsafe extern "C" fn roots(mut servers: *mut u8, mut q: *mut u8) -> i32 {
    let mut r: i32;
    r = roots_find(q);
    if r == -1i32 {
        0i32
    } else {
        byte::copy(servers, 64u32, data.s.offset(r as (isize)));
        1i32
    }
}
```


Overlapping Code:
```
rn "C" fn roots(mut servers: *mut u8, mut q: *mut u8) -> i32 {
let mut r: i32;
r = roots_find(q);
if r == -1i32 {
0i32
} else {
byte::copy(servers, 64
```
<Overlap Ratio: 0.7211538461538461>

---

--- 190 --
Question ID: fb594ff611a0feacfdbc0a6ac79665c149b46b6b_0
Original Code:
```
pub fn start_logging(config: &LoggingConfig){
    let root_and_loggers: String = match &config.loggers {
        None => config.root_level.clone(),
        Some (loggers) => {
            let mut accumul: String = config.root_level.clone();
            for (log_name, level) in loggers {
                accumul.push_str(&format!(", {}={}", log_name, level));
            }
            accumul
        }
    };
    let mut logger = Logger::with_env_or_str(root_and_loggers).format(opt_format);
    if config.log_to_file{
        logger = logger.log_to_file();
        let dir = match &config.directory{
            Some(dir) => dir,
            None => panic!("A logging directory needs to be provided to log to a file"),
        };
        let rotate = match &config.rotate_size_mb{
            Some(size) => *size as u64 * MEGA_BYTE,
            None => MEGA_BYTE,            
        };
        let cleanup = match &config.num_keep_files{
            Some(num) => Cleanup::KeepLogFiles(*num as usize),
            None => Cleanup::KeepLogFiles(5),
        };
        logger = logger.directory(dir)
                       .rotate(rotate as usize, cleanup);
    }
    logger.start().expect("Unable to configure logging!!");
    info!("Logging system started")
}
```


Overlapping Code:
```
ng(config: &LoggingConfig){
let root_and_loggers: String = match &config.loggers {
None => config.root_level.clone(),
Some (loggers) => {
let mut accumul: String = config.root_level.clone();
for (log_name, level) in loggers {
accumul.push_str(&format!(", {}={}", log_name, level));
}
accumul
}
};
let mut logger = Logger::with_env_or_str(root_and_loggers).format(opt_format);
if config.log_to_file{
logger = logger.log_to_file();
let dir = match &config.directory{
Some(dir) => dir,
None => panic!("A logging directory needs to be provided to log to a file"),
};
let rotate = match &config.rotate_size_mb{
Some(size) => *size as u64 * MEGA_BYTE,
None => MEGA_BYTE, 
};
let cleanup = match &config.num_keep_files{
Some(num) => Cleanup::KeepLogFiles(*num as usize),
None => Cleanup::KeepLogFiles(5),
};
logger = logger.directory(dir)
.rotate(rotate as usize, cleanup);
}
logger.start().expect("Unable to configure logging!!");
info!("Logging system sta
```
<Overlap Ratio: 0.9733606557377049>

---

--- 191 --
Question ID: e77e2d5f4ada4fa31f95fec71754c0282a221614_12
Original Code:
```
fn test_edge_clipping_intersects_opposite_edges() {
        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: 0.664013}) as PointUVW).intersects_opposite_edges() == false);
        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: -0.664013}) as PointUVW).intersects_opposite_edges() == false);
        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: -(4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);
        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: (4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);
        assert!((Point(r3::vector::Vector{x: -(2.0_f64 / 3.0_f64).sqrt(), y: -(2.0_f64 / 3.0_f64).sqrt(), z: 1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);
        assert!((Point(r3::vector::Vector{x: (2.0_f64 / 3.0_f64).sqrt(), y: (2.0_f64 / 3.0_f64).sqrt(), z: -1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);
    }
```


Overlapping Code:
```
st_edge_clipping_intersects_opposite_edges() {
assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: 0.664013}) as PointUVW).intersects_opposite_edges() == false);
assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: -0.664013}) as PointUVW).intersects_opposite_edges() == false);
assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: -(4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);
assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: (4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);
assert!((Point(r3::vector::Vector{x: -(2.0_f64 / 3.0_f64).sqrt(), y: -(2.0_f64 / 3.0_f64).sqrt(), z: 1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);
assert!((Point(r3::vector::Vector{x: (2.0_f64 / 3.0_f64).sqrt(), y: (2.0_f64 / 3.0_f64).sqrt(), z: -1.66533453694e-16}) as PointUVW).intersects_opposite
```
<Overlap Ratio: 0.972972972972973>

---

--- 192 --
Question ID: 99ec1b268c51c3421dd383fb23681b4c110262f0_133
Original Code:
```
fn make_xhp_close(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {
        let s = State::next(s, &[&arg0, &arg1, &arg2]);
        let r = Self::R::make_xhp_close(&s, arg0, arg1, arg2);
        (s, r)
    }
```


Overlapping Code:
```
(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {
let s = State::next(s, &[&arg0, &arg1, &arg2]);
let r = Self::R::make_xh
```
<Overlap Ratio: 0.7320574162679426>

---

--- 193 --
Question ID: 56013aa6660245fa103909bf0708f9fb545181ff_0
Original Code:
```
pub(crate) fn iterate_component_events<T, D>(
    tracked_storage: &Storage<T, D>,
    reader_id: &mut ReaderId<ComponentEvent>,
) -> (BitSet, BitSet, BitSet)
where
    T: Component,
    T::Storage: Tracked,
    D: Deref<Target = MaskedStorage<T>>,
{
    let (mut inserted, mut modified, mut removed) = (BitSet::new(), BitSet::new(), BitSet::new());
    for component_event in tracked_storage.channel().read(reader_id) {
        match component_event {
            ComponentEvent::Inserted(id) => {
                debug!("Got Inserted event with id: {}", id);
                inserted.add(*id);
            }
            ComponentEvent::Modified(id) => {
                debug!("Got Modified event with id: {}", id);
                modified.add(*id);
            }
            ComponentEvent::Removed(id) => {
                debug!("Got Removed event with id: {}", id);
                removed.add(*id);
            }
        }
    }

    (inserted, modified, removed)
}
```


Overlapping Code:
```
_component_events<T, D>(
tracked_storage: &Storage<T, D>,
reader_id: &mut ReaderId<ComponentEvent>,
) -> (BitSet, BitSet, BitSet)
where
T: Component,
T::Storage: Tracked,
D: Deref<Target = MaskedStorage<T>>,
{
let (mut inserted, mut modified, mut removed) = (BitSet::new(), BitSet::new(), BitSet::new());
for component_event in tracked_storage.channel().read(reader_id) {
match component_event {
ComponentEvent::Inserted(id) => {
debug!("Got Inserted event with id: {}", id);
inserted.add(*id);
}
ComponentEvent::Modified(id) => {
debug!("Got Modified event with id: {}", id);
modified.add(*id);
}
ComponentEvent::Removed(id) => {
debug!("Got Removed event with id: {}", id);
removed.add(*id);
}
}
}
(inserted, mod
```
<Overlap Ratio: 0.949468085106383>

---

--- 194 --
Question ID: 12f79b4c00c01abedbe5232c1bedeba5410c64f4_1
Original Code:
```
pub fn matrix_macro_empty_mat() {
    let mat: Matrix<f64> = matrix![];

    assert_eq!(0, mat.rows());
    assert_eq!(0, mat.cols());
}
```


Overlapping Code:
```
_empty_mat() {
let mat: Matrix<f64> = matrix![];
assert_eq!(0, mat.rows());
assert_eq!(0, mat.cols()
```
<Overlap Ratio: 0.8130081300813008>

---

--- 195 --
Question ID: 28a61e0ae694670963b9349442b4f33323959f7e_2
Original Code:
```
fn read_str_utf8_lossy(&mut self, len: usize) -> io::Result<String> {
        let mut buf = vec![0u8; len];
        self.read_exact(&mut buf[..])?;
        Ok(String::from_utf8_lossy(&buf).into_owned())
    }
```


Overlapping Code:
```
tr_utf8_lossy(&mut self, len: usize) -> io::Result<String> {
let mut buf = vec![0u8; len];
self.read_exact(&mut buf[..])?;
Ok(String::from_utf8_lossy(&buf).into_owned())
```
<Overlap Ratio: 0.9388888888888889>

---

--- 196 --
Question ID: 7d44227546f4f02f7d051a52e64b5949b042485a_2
Original Code:
```
fn lookup_bool() {
        let rxvt: TermInfoBuf = TermInfo::parse(RXVT_INFO).unwrap().into();
        let xterm: TermInfoBuf = TermInfo::parse(XTERM_INFO).unwrap().into();
        let l16c: TermInfoBuf = TermInfo::parse(LINUX_16COLOR_INFO).unwrap().into();

        assert_eq!(rxvt.boolean(BooleanField::LinefeedIsNewline), false);
        assert_eq!(rxvt.boolean(BooleanField::AutoRightMargin), true);

        assert_eq!(xterm.boolean(BooleanField::AutoLeftMargin), false);
        assert_eq!(xterm.boolean(BooleanField::LinefeedIsNewline), false);

        assert_eq!(l16c.boolean(BooleanField::HardCursor), false);
        assert_eq!(l16c.boolean(BooleanField::AutoRightMargin), true);
    }
```


Overlapping Code:
```
 TermInfoBuf = TermInfo::parse(RXVT_INFO).unwrap().into();
let xterm: TermInfoBuf = TermInfo::parse(XTERM_INFO).unwrap().into();
let l16c: TermInfoBuf = TermInfo::parse(LINUX_16COLOR_INFO).unwrap().into();
assert_eq!(rxvt.boolean(BooleanField::LinefeedIsNewline), false);
assert_eq!(rxvt.boolean(BooleanField::AutoRightMargin), true);
assert_eq!(xterm.boolean(BooleanField::AutoLeftMargin), false);
assert_eq!(xterm.boolean(BooleanField::LinefeedIsNewline), false);
assert_eq!(l16c.boolean(BooleanField::HardCursor), false);
assert_eq!(l16c.boolean(BooleanFiel
```
<Overlap Ratio: 0.9076175040518638>

---

--- 197 --
Question ID: 16054c5616c4a0085995cca3221f2b6f10cea7e9_2
Original Code:
```
fn print_fat16() {
    let f = OpenOptions::new().read(true).write(true).open("images/fat16.img").expect("Failed to open fat16.img");
    let mut fs = redox_fatfs::FileSystem::from_offset(0, f).expect("Parsing Error");
    let max_cluster = fs.max_cluster_number();
    let root_sec = fs.bpb.rsvd_sec_cnt as u64 + (fs.bpb.num_fats as u64 * fs.bpb.fat_size_16 as u64);
    let root_clus = Cluster::new(root_sec / fs.bpb.sectors_per_cluster as u64);
    println!("Root Cluster = {:?}", fs.clusters(root_clus));
    println!("First Data Sec = {}", fs.first_data_sec);
    // Cluster 2 starts from first_data_sec sector onwards

    let mut buf = [0; 32];
    fs.read_sector(root_sec, &mut buf);
    println!("Buffer = {:?}", buf);
    println!("BPB = {:?}", fs.bpb);
    println!("FsInfo = {:?}", fs.fs_info.borrow());
    println!("Mirroring Enabled = {:?}", fs.mirroring_enabled());

    fs.read_cluster(Cluster::new(5), &mut buf);
    println!("somefile.txt = {:?}", buf);

    let free = get_free_cluster(&mut fs, Cluster::new(5), Cluster::new(100));
    println!("Free Cluster = {:?}", free);
    println!("Num free Cluster = {:?}", get_free_count(&mut fs, max_cluster));
    println!("Cluster Chain of longFile.txt = {:?}", fs.clusters(Cluster::new(3)));
    let root_dir : Vec<DirEntry> = fs.root_dir().to_iter(&mut fs).collect();
    for entry in root_dir  {
        println!("Dir Entry : {:?}\n", entry);
    }
}
```


Overlapping Code:
```

let f = OpenOptions::new().read(true).write(true).open("images/fat16.img").expect("Failed to open fat16.img");
let mut fs = redox_fatfs::FileSystem::from_offset(0, f).expect("Parsing Error");
let max_cluster = fs.max_cluster_number();
let root_sec = fs.bpb.rsvd_sec_cnt as u64 + (fs.bpb.num_fats as u64 * fs.bpb.fat_size_16 as u64);
let root_clus = Cluster::new(root_sec / fs.bpb.sectors_per_cluster as u64);
println!("Root Cluster = {:?}", fs.clusters(root_clus));
println!("First Data Sec = {}", fs.first_data_sec);
// Cluster 2 starts from first_data_sec sector onwards
let mut buf = [0; 32];
fs.read_sector(root_sec, &mut buf);
println!("Buffer = {:?}", buf);
println!("BPB = {:?}", fs.bpb);
println!("FsInfo = {:?}", fs.fs_info.borrow());
println!("Mirroring Enabled = {:?}", fs.mirroring_enabled());
fs.read_cluster(Cluster::new(5), &mut buf);
println!("somefile.txt = {:?}", buf);
let free = get_free_cluster(&mut fs, Cluster::new(5), Cluster::new(100));
println!("Free Cluster = {:?}", free);
println!("Num free Cluster = {:?}", get_free_count(&mut fs, max_cluster));
println!("Cluster Chain of longFile.txt = {:?}", fs.clusters(Cluster::new(3)));
let root_dir : Vec<DirEntry> = fs.root_dir().to_iter(&mut fs).collect();
for entry in root_dir {
println!("D
```
<Overlap Ratio: 0.9627092846270928>

---

--- 198 --
Question ID: 8a4504989d5a3208514b06723b5bdf36fcdf6aa3_10
Original Code:
```
fn test_simple_operator_gt_plaintext_parse() {
        let name1 = _random_string(10);
        let value1 = _random_string(10);

        let json = format!(r#"{{"~{}":{{"$gt":"{}"}}}}"#, name1, value1);

        let query = parse_from_json(&json).unwrap();

        let expected = Operator::Gt(
            TagName::PlainTagName(name1.to_vec()),
            TargetValue::Unencrypted(value1.clone())
        );

        assert_eq!(query, expected);
    }
```


Overlapping Code:
```
plaintext_parse() {
let name1 = _random_string(10);
let value1 = _random_string(10);
let json = format!(r#"{{"~{}":{{"$gt":"{}"}}}}"#, name1, value1);
let query = parse_from_json(&json).unwrap();
let expected = Operator::Gt(
TagName::PlainTagName(name1.to_vec()),
TargetValue::Unencrypted(value1.clone())
);
assert_eq!(query, 
```
<Overlap Ratio: 0.8931506849315068>

---

--- 199 --
Question ID: cc43ac73689f0af0c58a101f178c1c084da8e0a4_2
Original Code:
```
fn gen_colors() -> Result<()> {
    let map_name = "COLORS";
    let struct_name = "Color";

    let mut spec = String::new();
    fs::File::open("spec/colors.txt")?.read_to_string(&mut spec)?;

    let mut map = phf_codegen::Map::new();
    for (line1, line2) in spec.split('\n').filter(|s| !s.is_empty()).tuples() {
        let rgb: Vec<&str> = line2.split(',').collect();
        map.entry(line1, &format!("{} {{ red: {}, green: {}, blue: {} }}",
                                  struct_name, rgb[0], rgb[1], rgb[2]));
    }

    let mut map_data = Vec::new();
    map.build(&mut map_data)?;
    let map_data = str::from_utf8(&map_data)?;


    let f = &mut fs::File::create("../src/color/colors.rs")?;

    write_header(f)?;

    writeln!(f, "use {};\n", struct_name)?;

    writeln!(f, "static {}: ::phf::Map<&'static str, {}> = {};\n", map_name, struct_name, map_data)?;

    writeln!(f, "pub fn from_str(text: &str) -> Option<{}> {{", struct_name)?;
    writeln!(f, "    {}.get(text).cloned()", map_name)?;
    writeln!(f, "}}")?;

    Ok(())
}
```


Overlapping Code:
```
_name = "COLORS";
let struct_name = "Color";
let mut spec = String::new();
fs::File::open("spec/colors.txt")?.read_to_string(&mut spec)?;
let mut map = phf_codegen::Map::new();
for (line1, line2) in spec.split('\n').filter(|s| !s.is_empty()).tuples() {
let rgb: Vec<&str> = line2.split(',').collect();
map.entry(line1, &format!("{} {{ red: {}, green: {}, blue: {} }}",
struct_name, rgb[0], rgb[1], rgb[2]));
}
let mut map_data = Vec::new();
map.build(&mut map_data)?;
let map_data = str::from_utf8(&map_data)?;
let f = &mut fs::File::create("../src/color/colors.rs")?;
write_header(f)?;
writeln!(f, "use {};\n", struct_name)?;
writeln!(f, "static {}: ::phf::Map<&'static str, {}> = {};\n", map_name, struct_name, map_data)?;
writeln!(f, "pub fn from_str(text: &str) -> Option<{}> {{", struct_name)?;
writeln!(f, " {}.get(text).cloned()", map_name)?;
writeln!(f, "
```
<Overlap Ratio: 0.9411123227917121>

---

--- 200 --
Question ID: 2e70a62330b5d3b9ea1fc2683957d7ca04479b4d_3
Original Code:
```
fn test_tile_to_wgs84() {
    assert_eq!((0.0, 66.51326044311186), tile_to_wgs84(2, 1, 2));
    assert_eq!((270.0, -85.0511287798066), tile_to_wgs84(5, 4, 2));
    assert_eq!((-9.140625, 53.33087298301705), tile_to_wgs84(486, 332, 10));
}
```


Overlapping Code:
```
fn test_tile_to_wgs84() {
assert_eq!((0.0, 66.51326044311186), tile_to_wgs84(2, 1, 2));
assert_eq!((270.0, -85.0511287798066), tile_to_wgs84(5, 4, 2));
assert_eq!((-9.140625, 53.33087298301705), tile_to_wgs8
```
<Overlap Ratio: 0.915929203539823>

---

--- 201 --
Question ID: 63c03229343ca2d9c2ae27790dbf3c681fde5aad_18
Original Code:
```
fn test_parse_comment_and_text() {
    SETUP_READER!(
        reader,
        "// Hello world
Ciao mondo"
    );

    assert_eq!(reader.lines.len(), 2);

    assert_eq!(reader.lines[0].type_, LineType::Comment);
    assert_eq!(reader.lines[1].type_, LineType::Text);
}
```


Overlapping Code:
```
mment_and_text() {
SETUP_READER!(
reader,
"// Hello world
Ciao mondo"
);
assert_eq!(reader.lines.len(), 2);
assert_eq!(reader.lines[0].type_, LineType::Comment);
assert_eq!(reader.lines[1].type_, LineType::Te
```
<Overlap Ratio: 0.9043478260869565>

---

--- 202 --
Question ID: 5a6392e2dcffd27633f9d2c79ed11b872ef7f9f9_11
Original Code:
```
fn swap_fields2() {
    let int = TypeInfo::new_fundamental::<i64>();
    let float = TypeInfo::new_fundamental::<f64>();

    let struct1 = TypeInfo::new_struct(
        STRUCT1_NAME,
        STRUCT1_GUID,
        StructInfo::new(&[("a", &float), ("b", &int), ("c", &float), ("d", &int)]),
    );
    let struct2 = TypeInfo::new_struct(
        STRUCT1_NAME,
        STRUCT2_GUID,
        StructInfo::new(&[("d", &int), ("c", &float), ("b", &int), ("a", &float)]),
    );

    let old = &[&struct1];
    let new = &[&struct2];

    let diff = diff(old, new);
    assert_eq!(
        diff,
        vec![Diff::Edit {
            diff: vec![
                FieldDiff::Move {
                    old_index: 0,
                    new_index: 3,
                    edit: None,
                },
                FieldDiff::Move {
                    old_index: 1,
                    new_index: 2,
                    edit: None,
                },
                FieldDiff::Move {
                    old_index: 2,
                    new_index: 1,
                    edit: None,
                }
            ],
            old_index: 0,
            new_index: 0
        }]
    );
    assert_eq_struct(&apply_diff(old, new, diff), &[struct2.clone()]);
}
```


Overlapping Code:
```
swap_fields2() {
let int = TypeInfo::new_fundamental::<i64>();
let float = TypeInfo::new_fundamental::<f64>();
let struct1 = TypeInfo::new_struct(
STRUCT1_NAME,
STRUCT1_GUID,
StructInfo::new(&[("a", &float), ("b", &int), ("c", &float), ("d", &int)]),
);
let struct2 = TypeInfo::new_struct(
STRUCT1_NAME,
STRUCT2_GUID,
StructInfo::new(&[("d", &int), ("c", &float), ("b", &int), ("a", &float)]),
);
let old = &[&struct1];
let new = &[&struct2];
let diff = diff(old, new);
assert_eq!(
diff,
vec![Diff::Edit {
diff: vec![
FieldDiff::Move {
old_index: 0,
new_index: 3,
edit: None,
},
FieldDiff::Move {
old_index: 1,
new_index: 2,
edit: None,
},
FieldDiff::Move {
old_index: 2,
new_index: 1,
edit: None,
}
],
old_index: 0,
new_index: 0
}]
);
assert_eq_struct(&apply_diff(old, new, diff), &[struct2.clone()]);

```
<Overlap Ratio: 0.9950433705080545>

---

--- 203 --
Question ID: b98228e9b240c63b992bdedf9aff1a639eed4fc4_5
Original Code:
```
fn prove_execution_and_proof_check_works() {
		let executor = DummyCodeExecutor {
			change_changes_trie_config: false,
			native_available: true,
			native_succeeds: true,
			fallback_succeeds: true,
		};

		// fetch execution proof from 'remote' full node
		let remote_backend = trie_backend::tests::test_trie();
		let remote_root = remote_backend.storage_root(::std::iter::empty()).0;
		let (remote_result, remote_proof) = prove_execution(remote_backend,
			&mut Default::default(), &executor, "test", &[]).unwrap();

		// check proof locally
		let local_result = execution_proof_check::<Blake2Hasher, _>(remote_root, remote_proof,
			&mut Default::default(), &executor, "test", &[]).unwrap();

		// check that both results are correct
		assert_eq!(remote_result, vec![66]);
		assert_eq!(remote_result, local_result);
	}
```


Overlapping Code:
```
 prove_execution_and_proof_check_works() {
let executor = DummyCodeExecutor {
change_changes_trie_config: false,
native_available: true,
native_succeeds: true,
fallback_succeeds: true,
};
// fetch execution proof from 'remote' full node
let remote_backend = trie_backend::tests::test_trie();
let remote_root = remote_backend.storage_root(::std::iter::empty()).0;
let (remote_result, remote_proof) = prove_execution(remote_backend,
&mut Default::default(), &executor, "test", &[]).unwrap();
// check proof locally
let local_result = execution_proof_check::<Blake2Hasher, _>(remote_root, remote_proof,
&mut Default::default(), &executor, "test", &[]).unwrap();
// check that both results are correct
assert_eq!(remote_result, vec![66]);
assert_eq!(remo
```
<Overlap Ratio: 0.962772785622593>

---

--- 204 --
Question ID: 0ad09fd0f7dfba492e8146a64a17ed0a25eb1f69_1
Original Code:
```
fn test_is_empty() {
        let test0 = TokenStream::from_tts(Vec::new());
        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),
                                                                Token::Ident(str_to_ident("a")))]);
        let test2 = TokenStream::from_tts(string_to_tts("foo(bar::baz)".to_string()));

        assert_eq!(test0.is_empty(), true);
        assert_eq!(test1.is_empty(), false);
        assert_eq!(test2.is_empty(), false);
    }
```


Overlapping Code:
```
est_is_empty() {
let test0 = TokenStream::from_tts(Vec::new());
let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),
Token::Ident(str_to_ident("a")))]);
let test2 = TokenStream::from_tts(string_to_tts("foo(bar::baz)".to_string()));
assert_eq!(test0.is_empty(), true);
assert_eq!(test1.is_empty(), false);
assert_eq!(test2.is_empty(), fal
```
<Overlap Ratio: 0.9722222222222222>

---

--- 205 --
Question ID: 46841c61f445d80c26a7c5ae2f23d153f10c9a62_0
Original Code:
```
fn get_field_1_test(){
        assert_eq!(*get_field_1(&(2,8)), 8);
        assert_eq!(*get_field_1(&(2,5,8)), 5);
        assert_eq!(*get_field_1(&(2,3,5,8)), 3);
        assert_eq!(*get_field_1(&(1,2,3,5,8)), 2);
        assert_eq!(*get_field_1(&(1,1,2,3,5,8)), 1);
        assert_eq!(*get_field_1(&(11,13,17,19,23,29,31)), 13);
        assert_eq!(*get_field_1(&(7,11,13,17,19,23,29,31)), 11);
        assert_eq!(*get_field_1(&(5,7,11,13,17,19,23,29,31)), 7);
        assert_eq!(*get_field_1(&(3,5,7,11,13,17,19,23,29,31)), 5);
    }
```


Overlapping Code:
```
(){
assert_eq!(*get_field_1(&(2,8)), 8);
assert_eq!(*get_field_1(&(2,5,8)), 5);
assert_eq!(*get_field_1(&(2,3,5,8)), 3);
assert_eq!(*get_field_1(&(1,2,3,5,8)), 2);
assert_eq!(*get_field_1(&(1,1,2,3,5,8)), 1);
assert_eq!(*get_field_1(&(11,13,17,19,23,29,31)), 13);
assert_eq!(*get_field_1(&(7,11,13,17,19,23,29,31)), 11);
assert_eq!(*get_field_1(&(5,7,11,13,17,19,23,29,31)), 7);
assert_eq!(*get_field
```
<Overlap Ratio: 0.8714596949891068>

---

--- 206 --
Question ID: 31f3415b1ecd026424e2de1baf2444e0e7edbe7f_0
Original Code:
```
fn find_msvc_latest(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {
        let vcdir = otry!(get_vc_dir(ver));
        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));
        let sub = otry!(lib_subdir(arch));
        let ucrt = otry!(get_ucrt_dir());
        debug!("Found Universal CRT {:?}", ucrt);
        add_lib(&mut cmd, &ucrt.join("ucrt").join(sub));
        if let Some(dir) = get_sdk10_dir() {
            debug!("Found Win10 SDK {:?}", dir);
            add_lib(&mut cmd, &dir.join("um").join(sub));
        } else if let Some(dir) = get_sdk81_dir() {
            debug!("Found Win8.1 SDK {:?}", dir);
            add_lib(&mut cmd, &dir.join("um").join(sub));
        } else {
            return None
        }
        Some((cmd, host))
    }
```


Overlapping Code:
```
test(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {
let vcdir = otry!(get_vc_dir(ver));
let (mut cmd, host) = otry!(get_linker(&vcdir, arch));
let sub = otry!(lib_subdir(arch));
let ucrt = otry!(get_ucrt_dir());
debug!("Found Universal CRT {:?}", ucrt);
add_lib(&mut cmd, &ucrt.join("ucrt").join(sub));
if let Some(dir) = get_sdk10_dir() {
debug!("Found Win10 SDK {:?}", dir);
add_lib(&mut cmd, &dir.join("um").join(sub));
} else if let Some(dir) = get_sdk81_dir() {
debug!("Found Win8.1 SDK {:?}", dir);
add_lib(&mut cmd, &dir.join("um").join(sub));
} else {
return None
}
Some((cmd, host))

```
<Overlap Ratio: 0.974025974025974>

---

--- 207 --
Question ID: b61fc7149166a71ee05df261c035f637aa80ac79_17
Original Code:
```
pub unsafe extern "C" fn wlr_xdg_surface_from_resource(mut resource:
                                                           *mut wl_resource)
 -> *mut wlr_xdg_surface {
    // TODO: Double check that all of the callers can deal with NULL
    if resource.is_null() { return 0 as *mut wlr_xdg_surface }
    if wl_resource_instance_of(resource, &xdg_surface_interface,
                               &xdg_surface_implementation as
                                   *const xdg_surface_interface as
                                   *const libc::c_void) != 0 {
    } else {
        __assert_fail(b"wl_resource_instance_of(resource, &xdg_surface_interface, &xdg_surface_implementation)\x00"
                          as *const u8 as *const libc::c_char,
                      b"../types/xdg_shell/wlr_xdg_surface.c\x00" as *const u8
                          as *const libc::c_char, 510i32 as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 76],
                                                &[libc::c_char; 76]>(b"struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *)\x00")).as_ptr());
    };
    return wl_resource_get_user_data(resource) as *mut wlr_xdg_surface;
}
```


Overlapping Code:
```
e extern "C" fn wlr_xdg_surface_from_resource(mut resource:
*mut wl_resource)
-> *mut wlr_xdg_surface {
// TODO: Double check that all of the callers can deal with NULL
if resource.is_null() { return 0 as *mut wlr_xdg_surface }
if wl_resource_instance_of(resource, &xdg_surface_interface,
&xdg_surface_implementation as
*const xdg_surface_interface as
*const libc::c_void) != 0 {
} else {
__assert_fail(b"wl_resource_instance_of(resource, &xdg_surface_interface, &xdg_surface_implementation)\x00"
as *const u8 as *const libc::c_char,
b"../types/xdg_shell/wlr_xdg_surface.c\x00" as *const u8
as *const libc::c_char, 510i32 as libc::c_uint,
(*::std::mem::transmute::<&[u8; 76],
&[libc::c_char; 76]>(b"struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *)\x00")).as_ptr());
};
return wl_resource_get_user_data(resource) as *mut wlr
```
<Overlap Ratio: 0.9725400457665904>

---

--- 208 --
Question ID: 14a42b31bf71bea4f1d7cc5a8752b44573a611d9_10
Original Code:
```
fn test_transfer_for_store() {
        let keypair = KeyPair::gen_keypair();
        let data_len = 4096;
        let provided_gas = U256::from(100_000);
        let t = Transaction {
            action: Action::Store,
            value: U256::from(0),
            data: vec![0; data_len],
            gas: provided_gas,
            gas_price: U256::one(),
            nonce: U256::zero().to_string(),
            block_limit: 100u64,
            chain_id: 1.into(),
            version: 2,
        }
        .fake_sign(keypair.address().clone());

        let sender = t.sender();
        let mut state = get_temp_state();
        state
            .add_balance(&sender, U256::from(18 + 100_000))
            .unwrap();

        let mut context = Context::default();
        context.block_quota_limit = U256::from(100_000);

        let block_data_provider = EVMBlockDataProvider::new(context.clone());

        let state = Arc::new(RefCell::new(state));

        let result = {
            CitaExecutive::new(
                Arc::new(block_data_provider),
                state,
                &context,
                EconomicalModel::Charge,
            )
            .exec(&t, &BlockSysConfig::default())
        };

        let expected = ExecutionError::NotEnoughBaseGas;

        assert!(result.is_err());
        assert_eq!(result.err().unwrap(), expected);
    }
```


Overlapping Code:
```
or_store() {
let keypair = KeyPair::gen_keypair();
let data_len = 4096;
let provided_gas = U256::from(100_000);
let t = Transaction {
action: Action::Store,
value: U256::from(0),
data: vec![0; data_len],
gas: provided_gas,
gas_price: U256::one(),
nonce: U256::zero().to_string(),
block_limit: 100u64,
chain_id: 1.into(),
version: 2,
}
.fake_sign(keypair.address().clone());
let sender = t.sender();
let mut state = get_temp_state();
state
.add_balance(&sender, U256::from(18 + 100_000))
.unwrap();
let mut context = Context::default();
context.block_quota_limit = U256::from(100_000);
let block_data_provider = EVMBlockDataProvider::new(context.clone());
let state = Arc::new(RefCell::new(state));
let result = {
CitaExecutive::new(
Arc::new(block_data_provider),
state,
&context,
EconomicalModel::Charge,
)
.exec(&t, &BlockSysConfig::default())
};
let expected = ExecutionError::NotEnoughBaseGas;
assert!(result.is_err());
assert_eq!(result.err().unwrap(), expe
```
<Overlap Ratio: 0.9736842105263158>

---

--- 209 --
Question ID: 3cc3abdbe648d794c9de45ec027650a38bacbd4e_6
Original Code:
```
unsafe extern "C" fn compositor_bind(mut wl_client: *mut wl_client,
                                     mut data: *mut libc::c_void,
                                     mut version: uint32_t,
                                     mut id: uint32_t) {
    let mut compositor: *mut wlr_compositor = data as *mut wlr_compositor;
    let mut resource: *mut wl_resource =
        wl_resource_create(wl_client, &wl_compositor_interface,
                           version as libc::c_int, id);
    if resource.is_null() { wl_client_post_no_memory(wl_client); return }
    wl_resource_set_implementation(resource,
                                   &compositor_impl as
                                       *const wl_compositor_interface as
                                       *const libc::c_void,
                                   compositor as *mut libc::c_void, None);
}
```


Overlapping Code:
```
r_bind(mut wl_client: *mut wl_client,
mut data: *mut libc::c_void,
mut version: uint32_t,
mut id: uint32_t) {
let mut compositor: *mut wlr_compositor = data as *mut wlr_compositor;
let mut resource: *mut wl_resource =
wl_resource_create(wl_client, &wl_compositor_interface,
version as libc::c_int, id);
if resource.is_null() { wl_client_post_no_memory(wl_client); return }
wl_resource_set_implementation(resource,
&compositor_impl as
*const wl_compositor_interface as
*const libc::c_void,
compositor as *mut li
```
<Overlap Ratio: 0.9107142857142857>

---

--- 210 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_394
Original Code:
```
fn spec_test_395() {
    let original = r##"**foo**bar
"##;
    let expected = r##"<p><strong>foo</strong>bar</p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
ec_test_395() {
let original = r##"**foo**bar
"##;
let expected = r##"<p><strong>foo</strong>bar</p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9671052631578947>

---

--- 211 --
Question ID: 2beab526c50deb5dd572d1a7e311921b71bac838_2
Original Code:
```
fn codec_basic_get() {
    let mut enc_table = DynamicTable::new();
    let mut dec_table = DynamicTable::new();

    let mut block_buf = vec![];
    let mut enc_buf = vec![];
    let mut dec_buf = vec![];

    let header = vec![
        HeaderField::new(":method", "GET"),
        HeaderField::new(":path", "/"),
        HeaderField::new("foo", "bar"),
    ];

    encode(
        &mut enc_table.encoder(42),
        &mut block_buf,
        &mut enc_buf,
        header.clone().into_iter(),
    )
    .unwrap();

    let mut enc_cur = Cursor::new(&mut enc_buf);
    on_encoder_recv(&mut dec_table.inserter(), &mut enc_cur, &mut dec_buf).unwrap();

    let mut block_cur = Cursor::new(&mut block_buf);
    assert_eq!(decode_header(&dec_table, &mut block_cur), Ok(header));

    let mut dec_cur = Cursor::new(&mut dec_buf);
    on_decoder_recv(&mut enc_table, &mut dec_cur).unwrap();
}
```


Overlapping Code:
```
ic_get() {
let mut enc_table = DynamicTable::new();
let mut dec_table = DynamicTable::new();
let mut block_buf = vec![];
let mut enc_buf = vec![];
let mut dec_buf = vec![];
let header = vec![
HeaderField::new(":method", "GET"),
HeaderField::new(":path", "/"),
HeaderField::new("foo", "bar"),
];
encode(
&mut enc_table.encoder(42),
&mut block_buf,
&mut enc_buf,
header.clone().into_iter(),
)
.unwrap();
let mut enc_cur = Cursor::new(&mut enc_buf);
on_encoder_recv(&mut dec_table.inserter(), &mut enc_cur, &mut dec_buf).unwrap();
let mut block_cur = Cursor::new(&mut block_buf);
assert_eq!(decode_header(&dec_table, &mut block_cur), Ok(header));
let mut dec_cur = Cursor::new(&mut dec_buf);
on_decoder_recv(&mut enc_table, &mut dec_cur).unwr
```
<Overlap Ratio: 0.974934036939314>

---

--- 212 --
Question ID: 583f304981d2cd49da188a06c00c0a8a0abc4250_0
Original Code:
```
fn it_signs_data() {
        let wallet = Wallet::new();
        let message = hash("This is a test message to be signed".as_bytes(), 32);
        let secp_message = Message::from_slice(&message[..]).unwrap();
        let recoverable_signature = wallet.sign(&message.to_vec()).unwrap();
        let secp = Secp256k1::verification_only();
        let signature = recoverable_signature.to_standard(&secp);
        let pubkey = secp.recover(&secp_message, &recoverable_signature).unwrap();
        assert_eq!(pubkey, wallet.public_key);
        secp.verify(&secp_message, &signature, &wallet.public_key)
            .unwrap();
    }
```


Overlapping Code:
```
ns_data() {
let wallet = Wallet::new();
let message = hash("This is a test message to be signed".as_bytes(), 32);
let secp_message = Message::from_slice(&message[..]).unwrap();
let recoverable_signature = wallet.sign(&message.to_vec()).unwrap();
let secp = Secp256k1::verification_only();
let signature = recoverable_signature.to_standard(&secp);
let pubkey = secp.recover(&secp_message, &recoverable_signature).unwrap();
assert_eq!(pubkey, wallet.public_key);
secp.verify(&secp_message, &signature, 
```
<Overlap Ratio: 0.9242144177449169>

---

--- 213 --
Question ID: 7b2292310199ea4863139fbaac2fb2b7234078fb_0
Original Code:
```
fn activate(ctx: Context) -> Result<Box<Activator>> {
    println!("I'm started (provider)");
    println!(
        "My Component def: {:?}",
        <SimpleGreeter as Component>::get_definition()
    );

    let srv = Box::new(SimpleGreeter::new());
    let srv_reg = ctx.register_service_typed::<Greeter>(srv)?;
    Ok(Box::new(SimpleActivator::new(srv_reg)))
}
```


Overlapping Code:
```
vate(ctx: Context) -> Result<Box<Activator>> {
println!("I'm started (provider)");
println!(
"My Component def: {:?}",
<SimpleGreeter as Component>::get_definition()
);
let srv = Box::new(SimpleGreeter::new());
let srv_reg = ctx.register_service_typed::<Greeter>(srv)?;
Ok(Box::new(SimpleActivator::n
```
<Overlap Ratio: 0.9316770186335404>

---

--- 214 --
Question ID: 29bd81d0aa810bf8b8ee38a2428e054b9a5f4924_0
Original Code:
```
pub fn polling() {
        let spec = Arc::new(ChainSpec::foundation());
        let duties_map = Arc::new(EpochDutiesMap::new(spec.slots_per_epoch));
        let keypair = Keypair::random();
        let slot_clock = Arc::new(TestingSlotClock::new(0));
        let beacon_node = Arc::new(TestBeaconNode::default());

        let manager = DutiesManager {
            spec: spec.clone(),
            pubkey: keypair.pk.clone(),
            duties_map: duties_map.clone(),
            slot_clock: slot_clock.clone(),
            beacon_node: beacon_node.clone(),
        };

        // Configure response from the BeaconNode.
        let duties = EpochDuties {
            validator_index: 0,
            block_production_slot: Some(Slot::new(10)),
        };
        beacon_node.set_next_shuffling_result(Ok(Some(duties)));

        // Get the duties for the first time...
        assert_eq!(
            manager.poll(),
            Ok(PollOutcome::NewDuties(Epoch::new(0), duties))
        );
        // Get the same duties again...
        assert_eq!(manager.poll(), Ok(PollOutcome::NoChange(Epoch::new(0))));

        // Return new duties.
        let duties = EpochDuties {
            validator_index: 0,
            block_production_slot: Some(Slot::new(11)),
        };
        beacon_node.set_next_shuffling_result(Ok(Some(duties)));
        assert_eq!(
            manager.poll(),
            Ok(PollOutcome::DutiesChanged(Epoch::new(0), duties))
        );

        // Return no duties.
        beacon_node.set_next_shuffling_result(Ok(None));
        assert_eq!(
            manager.poll(),
            Ok(PollOutcome::UnknownValidatorOrEpoch(Epoch::new(0)))
        );
    }
```


Overlapping Code:
```
t spec = Arc::new(ChainSpec::foundation());
let duties_map = Arc::new(EpochDutiesMap::new(spec.slots_per_epoch));
let keypair = Keypair::random();
let slot_clock = Arc::new(TestingSlotClock::new(0));
let beacon_node = Arc::new(TestBeaconNode::default());
let manager = DutiesManager {
spec: spec.clone(),
pubkey: keypair.pk.clone(),
duties_map: duties_map.clone(),
slot_clock: slot_clock.clone(),
beacon_node: beacon_node.clone(),
};
// Configure response from the BeaconNode.
let duties = EpochDuties {
validator_index: 0,
block_production_slot: Some(Slot::new(10)),
};
beacon_node.set_next_shuffling_result(Ok(Some(duties)));
// Get the duties for the first time...
assert_eq!(
manager.poll(),
Ok(PollOutcome::NewDuties(Epoch::new(0), duties))
);
// Get the same duties again...
assert_eq!(manager.poll(), Ok(PollOutcome::NoChange(Epoch::new(0))));
// Return new duties.
let duties = EpochDuties {
validator_index: 0,
block_production_slot: Some(Slot::new(11)),
};
beacon_node.set_next_shuffling_result(Ok(Some(duties)));
assert_eq!(
manager.poll(),
Ok(PollOutcome::DutiesChanged(Epoch::new(0), duties))
);
// Return no duties.
beacon_node.set_next_shuffling_result(Ok(None));
assert_eq!(
manager.poll(),
Ok(PollOutcome::UnknownValidatorOrEpoch(Epoch::new(0)))
);
}
```
<Overlap Ratio: 0.9836956521739131>

---

--- 215 --
Question ID: c353ad1ff9a32675118aa026e45a741a35429f84_3
Original Code:
```
fn test_load_module() {
        let path = Path::new("./test/test1.xm");

        let context = Context::new();

        if let Ok(x) = load_module(&context, &path) {
            assert_eq!(x, ());
        }

        if let Ok(x) = load_module(&context, &path) {
            assert_eq!(x, ());
        }

    }
```


Overlapping Code:
```
 {
let path = Path::new("./test/test1.xm");
let context = Context::new();
if let Ok(x) = load_module(&context, &path) {
assert_eq!(x, ());
}
if let Ok(x) = load_module(&context, &path) {
assert_eq!(x,
```
<Overlap Ratio: 0.8695652173913043>

---

--- 216 --
Question ID: ca451efece603a7494b6d1e98cb568ca3ef3d174_8
Original Code:
```
fn cipher_encrypt_ecb_invalid_data_size() {
    let key_name = auto_test_keyname!();
    let mut client = TestClient::new();

    if !client.is_operation_supported(Opcode::PsaCipherEncrypt) {
        return;
    }

    client
        .import_aes_key_cipher(key_name.clone(), KEY_DATA.to_vec(), Cipher::EcbNoPadding)
        .unwrap();

    let invalid_plaintext = vec![0u8; INVALID_DATA_SIZE];

    assert_eq!(
        client
            .cipher_encrypt_message(key_name, Cipher::EcbNoPadding, &invalid_plaintext[..])
            .unwrap_err(),
        ResponseStatus::PsaErrorInvalidArgument
    );
}
```


Overlapping Code:
```
ypt_ecb_invalid_data_size() {
let key_name = auto_test_keyname!();
let mut client = TestClient::new();
if !client.is_operation_supported(Opcode::PsaCipherEncrypt) {
return;
}
client
.import_aes_key_cipher(key_name.clone(), KEY_DATA.to_vec(), Cipher::EcbNoPadding)
.unwrap();
let invalid_plaintext = vec![0u8; INVALID_DATA_SIZE];
assert_eq!(
client
.cipher_encrypt_message(key_name, Cipher::EcbNoPadding, &invalid_plaintext[..])
.unwrap_err(),
ResponseStatus::PsaErrorInvalidArgument
);

```
<Overlap Ratio: 0.9700598802395209>

---

--- 217 --
Question ID: f7ae5f9680f23adb5272273c5c3ddcb768c21af0_0
Original Code:
```
fn get_format(byte: &u8) -> ChunkHeaderFormat {
    const TYPE_0_MASK: u8 = 0b00000000;
    const TYPE_1_MASK: u8 = 0b01000000;
    const TYPE_2_MASK: u8 = 0b10000000;
    const FORMAT_MASK: u8 = 0b11000000;    

    let format_id = *byte & FORMAT_MASK;

    match format_id {
        TYPE_0_MASK => ChunkHeaderFormat::Full,
        TYPE_1_MASK => ChunkHeaderFormat::TimeDeltaWithoutMessageStreamId,
        TYPE_2_MASK => ChunkHeaderFormat::TimeDeltaOnly,
        _ => ChunkHeaderFormat::Empty
    }
}
```


Overlapping Code:
```
&u8) -> ChunkHeaderFormat {
const TYPE_0_MASK: u8 = 0b00000000;
const TYPE_1_MASK: u8 = 0b01000000;
const TYPE_2_MASK: u8 = 0b10000000;
const FORMAT_MASK: u8 = 0b11000000; 
let format_id = *byte & FORMAT_MASK;
match format_id {
TYPE_0_MASK => ChunkHeaderFormat::Full,
TYPE_1_MASK => ChunkHeaderFormat::TimeDeltaWithoutMessageStreamId,
TYPE_2_MASK => ChunkHeaderFormat::TimeDeltaOnly,
_ => ChunkHeaderF
```
<Overlap Ratio: 0.9176201372997712>

---

--- 218 --
Question ID: c75afb5f19a284ebd979979d7ff68fda1a67d5e2_19
Original Code:
```
fn read_coils() {
            assert!(Request::try_from(Bytes::from(vec![0x01])).is_err());
            assert!(Request::try_from(Bytes::from(vec![0x01, 0x0, 0x0, 0x22])).is_err());

            let bytes = Bytes::from(vec![0x01, 0x00, 0x12, 0x0, 0x4]);
            let req = Request::try_from(bytes).unwrap();
            assert_eq!(req, Request::ReadCoils(0x12, 4));
        }
```


Overlapping Code:
```
_coils() {
assert!(Request::try_from(Bytes::from(vec![0x01])).is_err());
assert!(Request::try_from(Bytes::from(vec![0x01, 0x0, 0x0, 0x22])).is_err());
let bytes = Bytes::from(vec![0x01, 0x00, 0x12, 0x0, 0x4]);
let req = Request::try_from(bytes).unwrap();
assert_eq!(req, Request::ReadCoils(0x12, 4));
```
<Overlap Ratio: 0.970873786407767>

---

--- 219 --
Question ID: a7466e590879380d07d3ad6d5da420fca494bece_0
Original Code:
```
pub async fn update_track_title(
    active_user: Option<User>,
    track_id: i32,
    title: String,
    channel: tonic::transport::Channel,
) -> Result<Track, GatewayError> {
    let mut client = CoursesClient::new(channel);
    let request = tonic::Request::new(UpdateTrackTitleRequest {
        active_user,
        track_id,
        title,
    });
    let response = client.update_track_title(request).await?.into_inner();
    let track = response.track.unwrap();
    Ok(Track {
        id: track.id,
        track_number: track.track_number,
        audio_path: track.audio_path,
        title: track.title,
        document_id: track.document_id,
    })
}
```


Overlapping Code:
```
tive_user: Option<User>,
track_id: i32,
title: String,
channel: tonic::transport::Channel,
) -> Result<Track, GatewayError> {
let mut client = CoursesClient::new(channel);
let request = tonic::Request::new(UpdateTrackTitleRequest {
active_user,
track_id,
title,
});
let response = client.update_track_title(request).await?.into_inner();
let track = response.track.unwrap();
Ok(Track {
id: track.id,
track_number: track.track_number,
audio_path: track.audio_path,
title: track.title,
document_id: trac
```
<Overlap Ratio: 0.9025270758122743>

---

--- 220 --
Question ID: b10e281f4bf8905b7685a364741537a3b4a8522e_1
Original Code:
```
fn compare_similar() {
        let a = Hash::hash(FOX).unwrap();
        let b = Hash::hash(FOX1).unwrap();
        let score = Hash::compare(&a, &b);
        println!("{}", score);
        assert!(score == 10);
    }
```


Overlapping Code:
```
nwrap();
let b = Hash::hash(FOX1).unwrap();
let score = Hash::compare(&a, &b);
println!("{}", score)
```
<Overlap Ratio: 0.5780346820809249>

---

--- 221 --
Question ID: c7e4f42c1fba857dd562a9de4cbd8146360fb480_0
Original Code:
```
fn main() {
    let xsize = 5760;
    let ysize = 3240;
    let view = Viewport::new(
        Point::new(0.0, 10.0, 10.0),
        Vector3::new(0.0, -2.0, -1.0),
        Vector3::new(0.0, 0.0, 1.0),
        std::f64::consts::PI / 2.0,
        (xsize, ysize),
    );
    // Example isometries. This is the way you express position of an object-- Collision is
    // checked between a ray (our camera's light ray) and a RayCast object (ie a
    // sphere, cuboid, etc) under a certain isometry.
    // The UnitQuaternion means no rotation. Quaternions are used widely in computer graphics to
    // represent rotation. The Wikipedia: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
    let cube = Polyhedron::new(
        Box::new(Cuboid::new(Vector3::new(1.0, 1.0, 1.0))),
        image::Rgb([255, 0, 255]),
        Isometry3::from_parts(
            Translation3::from(Vector3::new(-4.0, 0.0, 0.0)),
            UnitQuaternion::identity(),
        ),
    );
    let ground = Polyhedron::new(
        Box::new(Cuboid::new(Vector3::new(20.0, 20.0, 0.0))),
        image::Rgb([0, 0, 255]),
        Isometry3::from_parts(
            Translation3::from(Vector3::new(0.0, 0.0, -1.0)),
            UnitQuaternion::identity(),
        ),
    );
    let sphere = Polyhedron::new(
        Box::new(Ball::new(2.0)),
        image::Rgb([0, 120, 0]),
        Isometry3::from_parts(
            Translation3::from(Vector3::new(6.0, 0.0, 9.0)),
            UnitQuaternion::identity(),
        ),
    );
    let sphere2 = Polyhedron::new(
        Box::new(Ball::new(2.0)),
        image::Rgb([0, 0, 0]),
        Isometry3::from_parts(
            Translation3::from(Vector3::new(0.0, 3.0, 9.0)),
            UnitQuaternion::identity(),
        ),
    );
    // This is an example scene
    let scene = Scene::new(
        vec![ground, sphere, sphere2, cube],
        view,
        image::Rgb([120, 120, 120]),
        2.0,
        vec![],
    );
    // Render the scene, consuming it.
    scene.render("output.png".to_string());
}
```


Overlapping Code:
```
() {
let xsize = 5760;
let ysize = 3240;
let view = Viewport::new(
Point::new(0.0, 10.0, 10.0),
Vector3::new(0.0, -2.0, -1.0),
Vector3::new(0.0, 0.0, 1.0),
std::f64::consts::PI / 2.0,
(xsize, ysize),
);
// Example isometries. This is the way you express position of an object-- Collision is
// checked between a ray (our camera's light ray) and a RayCast object (ie a
// sphere, cuboid, etc) under a certain isometry.
// The UnitQuaternion means no rotation. Quaternions are used widely in computer graphics to
// represent rotation. The Wikipedia: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
let cube = Polyhedron::new(
Box::new(Cuboid::new(Vector3::new(1.0, 1.0, 1.0))),
image::Rgb([255, 0, 255]),
Isometry3::from_parts(
Translation3::from(Vector3::new(-4.0, 0.0, 0.0)),
UnitQuaternion::identity(),
),
);
let ground = Polyhedron::new(
Box::new(Cuboid::new(Vector3::new(20.0, 20.0, 0.0))),
image::Rgb([0, 0, 255]),
Isometry3::from_parts(
Translation3::from(Vector3::new(0.0, 0.0, -1.0)),
UnitQuaternion::identity(),
),
);
let sphere = Polyhedron::new(
Box::new(Ball::new(2.0)),
image::Rgb([0, 120, 0]),
Isometry3::from_parts(
Translation3::from(Vector3::new(6.0, 0.0, 9.0)),
UnitQuaternion::identity(),
),
);
let sphere2 = Polyhedron::new(
Box::new(Ball::new(2.0)),
image::Rgb([0, 0, 0]),
Isometry3::from_parts(
Translation3::from(Vector3::new(0.0, 3.0, 9.0)),
UnitQuaternion::identity(),
),
);
// This is an example scene
let scene = Scene::new(
vec![ground, sphere, sphere2, cube],
view,
image::Rgb([120, 120, 120]),
2.0,
vec![],
);
// Render the scene, consuming it.
scene.rend
```
<Overlap Ratio: 0.9768009768009768>

---

--- 222 --
Question ID: 22dd84ba6cc61592110b2559221a4e52b0c7844c_4
Original Code:
```
fn duplicate_includes() {
    let src = indoc!(
        r#"
        #include "A.glsl"
        #include "A.glsl"
        #include <A.glsl>
        void main() {}"#
    );
    let expand_src = Context::new()
        .include("A.glsl", "void A() {}")
        .expand(src)
        .unwrap();
    let expected = indoc!(
        r#"
        void A() {}
        #line 4 0
        void main() {}"#
    );
    assert_eq!(expected, expand_src);
}
```


Overlapping Code:
```
uplicate_includes() {
let src = indoc!(
r#"
#include "A.glsl"
#include "A.glsl"
#include <A.glsl>
void main() {}"#
);
let expand_src = Context::new()
.include("A.glsl", "void A() {}")
.expand(src)
.unwrap();
let expected = indoc!(
r#"
void A() {}
#line 4 0
void main() {}"#
);
assert_eq!(expected, expand_src);
```
<Overlap Ratio: 0.9810126582278481>

---

--- 223 --
Question ID: e60b73fa0f73d27208b54c78ca955583cf8801f9_8
Original Code:
```
pub unsafe extern "C" fn wlr_input_method_v2_send_done(mut input_method:
                                                           *mut wlr_input_method_v2) {
    zwp_input_method_v2_send_done((*input_method).resource);
    (*input_method).client_active = (*input_method).active;
    (*input_method).current_serial =
        (*input_method).current_serial.wrapping_add(1);
}
```


Overlapping Code:
```
od_v2_send_done(mut input_method:
*mut wlr_input_method_v2) {
zwp_input_method_v2_send_done((*input_method).resource);
(*input_method).client_active = (*input_method).active;
(*input_method).current_serial =
(*input_method).current_serial.wrapping_ad
```
<Overlap Ratio: 0.8445945945945946>

---

--- 224 --
Question ID: 87cb1786258851c4332c6427e21a561f3fc5a20d_7
Original Code:
```
fn is_used_in_encryption() {
        let tmp_dir = TempDir::new("emerald-global-key-test").unwrap();
        let vault = VaultStorage::create(tmp_dir.path()).unwrap();

        let global_store = vault.global_key();
        global_store.create("test-1").unwrap();
        let global = Some(global_store.get().unwrap());

        let seed_id = vault.seeds().add(
            Seed::test_generate(None, "test-1".as_bytes(), global.clone()).unwrap()
        ).unwrap();

        let seed_source = vault.seeds().get(seed_id).unwrap().source;

        let get_no_global = seed_source.get_addresses::<EthereumAddress>(
            Some("test-1".to_string()),
            None,
            &vec![StandardHDPath::from_str("m/44'/60'/0'/0/0").unwrap()],
            Blockchain::Ethereum,
        );

        assert!(get_no_global.is_err());

        let get_w_global = seed_source.get_addresses::<EthereumAddress>(
            Some("test-1".to_string()),
            global,
            &vec![StandardHDPath::from_str("m/44'/60'/0'/0/0").unwrap()],
            Blockchain::Ethereum,
        );

        println!("Result: {:?}", get_w_global);

        assert!(get_w_global.is_ok());
    }
```


Overlapping Code:
```
() {
let tmp_dir = TempDir::new("emerald-global-key-test").unwrap();
let vault = VaultStorage::create(tmp_dir.path()).unwrap();
let global_store = vault.global_key();
global_store.create("test-1").unwrap();
let global = Some(global_store.get().unwrap());
let seed_id = vault.seeds().add(
Seed::test_generate(None, "test-1".as_bytes(), global.clone()).unwrap()
).unwrap();
let seed_source = vault.seeds().get(seed_id).unwrap().source;
let get_no_global = seed_source.get_addresses::<EthereumAddress>(
Some("test-1".to_string()),
None,
&vec![StandardHDPath::from_str("m/44'/60'/0'/0/0").unwrap()],
Blockchain::Ethereum,
);
assert!(get_no_global.is_err());
let get_w_global = seed_source.get_addresses::<EthereumAddress>(
Some("test-1".to_string()),
global,
&vec![StandardHDPath::from_str("m/44'/60'/0'/0/0").unwrap()],
Blockchain::Ethereum,
);
println!("Result: {:?}", get_w
```
<Overlap Ratio: 0.929637526652452>

---

--- 225 --
Question ID: f04f9b01cfeb6576029f2cb76f20a60949516539_3
Original Code:
```
fn test_parse_slow_warning_data() {
    let o = exec("--warnings=tests/data/idmap-warnings/verbose.log.gz");
    assert_eq!(o.status.code(), Some(0xff));

    let o = exec("--warnings=tests/data/idmap-both-errors-and-warnings/verbose.log.gz");
    assert_eq!(o.status.code(), Some(0xff));

    let o = exec("--warnings=tests/data/idmap-errors/verbose.log.gz");
    assert_eq!(o.status.code(), Some(0));
}
```


Overlapping Code:
```
let o = exec("--warnings=tests/data/idmap-warnings/verbose.log.gz");
assert_eq!(o.status.code(), Some(0xff));
let o = exec("--warnings=tests/data/idmap-both-errors-and-warnings/verbose.log.gz");
assert_eq!(o.status.code(), Some(0xff));
let o = exec("--warnings=tests/data/idmap-errors/verbose.log.gz");
assert_eq!(o.status.code(), Some
```
<Overlap Ratio: 0.8862433862433863>

---

--- 226 --
Question ID: 46ca2e4cf6900a338f6f55ef8f15c6b3e89df3f4_2
Original Code:
```
pub fn profile_upage(db: DB, id: i32, user: auth::User) -> Template {
	let result = User::query_by_id(db.conn(), id);
	let mut context = user_context(&db, user);
	if let Some(profile) = result.first() {
		context.insert("profile", profile);
	}
	Template::render("profile", &context)
}
```


Overlapping Code:
```
th::User) -> Template {
let result = User::query_by_id(db.conn(), id);
let mut context = user_context(&db, user);
if let Some(profile) = result.first() {
context.insert("profile", profile);
}
Template
```
<Overlap Ratio: 0.7220216606498195>

---

--- 227 --
Question ID: 4bc1869e862a7d4d4629c46b2325f19453e5f2e4_52
Original Code:
```
fn assert_multiple(json: String, expected: Vec<serde_json::Value>) {
        let dids: Vec<serde_json::Value> = serde_json::from_str(&json).unwrap();

        assert_eq!(expected.len(), dids.len());

        for did in expected {
            assert!(dids.contains(&did));
        }
    }
```


Overlapping Code:
```
ssert_multiple(json: String, expected: Vec<serde_json::Value>) {
let dids: Vec<serde_json::Value> = serde_json::from_str(&json).unwrap();
assert_eq!(expected.len(), dids.len());
for did in expected {

```
<Overlap Ratio: 0.8438818565400844>

---

--- 228 --
Question ID: 0ea3f28bf591ffea3729aec61c156bd215a88317_0
Original Code:
```
fn destruct_vector_2<T>(vec: Vec<T>) -> (T, T)
where
    T: Default,
{
    let mut a = T::default();
    let mut b = T::default();
    for (i, item) in vec.into_iter().enumerate() {
        match i {
            0 => a = item,
            1 => b = item,
            _ => (),
        }
    }

    (a, b)
}
```


Overlapping Code:
```
>) -> (T, T)
where
T: Default,
{
let mut a = T::default();
let mut b = T::default();
for (i, item) in vec.into_iter().enumerate() {
match i {
0 => a =
```
<Overlap Ratio: 0.6607929515418502>

---

--- 229 --
Question ID: a47c5012bd0bf5d51aeedf3e847c3d718a818abb_6
Original Code:
```
fn ints8() {
        eq(5i8, vec![0, 3, 4]);
        eq(-5i8, vec![5, 0, -3, -4]);
        eq(0i8, vec![]);
    }
```


Overlapping Code:
```
ints8() {
eq(5i8, vec![0, 3, 4]);
eq(-5i8, vec![5, 0, -3, -4]);
```
<Overlap Ratio: 0.7411764705882353>

---

--- 230 --
Question ID: e049f4062c0057693c0c90e18fb5d6b5ec44bb92_90
Original Code:
```
fn problem_2016_21_1() {
    #![allow(clippy::unwrap_used)]
    let input = read_to_string("src/year2016/day21_input.txt").unwrap();
    solve(2016, 21, 1, &input).unwrap();
}
```


Overlapping Code:
```
blem_2016_21_1() {
#![allow(clippy::unwrap_used)]
let input = read_to_string("src/year2016/day21_input.txt").unwrap();
solve(2016, 21, 1, &input).unwr
```
<Overlap Ratio: 0.9202453987730062>

---

--- 231 --
Question ID: 73f99e784fdf86e9e522844ec5659c19688be32e_2
Original Code:
```
fn slufigy_replaces_url_punctuation() {
        assert_eq!("foo-bar", slugify("foo&bar"));
        assert_eq!("foo-bar", slugify("foo\"bar"));
        assert_eq!("foo-bar", slugify("foo?bar"));
        assert_eq!("foo-bar", slugify("foo=bar"));
    }
```


Overlapping Code:
```
ssert_eq!("foo-bar", slugify("foo&bar"));
assert_eq!("foo-bar", slugify("foo\"bar"));
assert_eq!("foo-bar", slugify("foo?bar"));
assert_eq!("foo-bar",
```
<Overlap Ratio: 0.7009345794392523>

---

--- 232 --
Question ID: 8a1db5bbb64701d67faaec6060244b687ae6608d_1
Original Code:
```
fn run_all_thursters(
    phase_sequence: Vec<i32>,
    program: &Vec<i32>,
) -> Result<i32, Box<dyn error::Error>> {
    let mut input_signal = 0;
    for phase_setting in phase_sequence {
        input_signal = run_thruster_computer(phase_setting, input_signal, program)?;
    }
    Ok(input_signal)
}
```


Overlapping Code:
```
32>,
program: &Vec<i32>,
) -> Result<i32, Box<dyn error::Error>> {
let mut input_signal = 0;
for phase_setting in phase_sequence {
input_signal = run_thruster_computer(phase_setting, input_signal, pro
```
<Overlap Ratio: 0.7380073800738007>

---

--- 233 --
Question ID: 3f2d70445a38a9b70f445d6c911e276c010565e2_1
Original Code:
```
fn secure_hash(master: &[u8], domain: &[u8]) -> [u8; 64] {
    let mut hasher = Sha512::new();
    //Hash the master password a few thousand times
    hasher.input(SALT);
    hasher.input(master);
    let mut master_hash = get_hash(&mut hasher);
    for i in 0..25_000_u32 {
        //Generate salt
        hasher.input(SALT);
        hasher.input(&i.to_le_bytes()[..]);
        let salt = get_hash(&mut hasher);
        //Feed in previous hash, salt and master password to modify hash
        hasher.input(&salt[..]);
        hasher.input(&master_hash[..]);
        hasher.input(master);
        master_hash = get_hash(&mut hasher);
    }
    //Hash both master and domain a few thousand times
    hasher.input(SALT);
    hasher.input(domain);
    hasher.input(master);
    let mut final_hash = get_hash(&mut hasher);
    for i in 0..25_000_u32 {
        //Generate salt for this iteration
        hasher.input(&i.to_be_bytes());
        hasher.input(SALT);
        let salt = get_hash(&mut hasher);
        //Feed in previous hash, salt and both master and domain in order to modify hash
        hasher.input(&salt[..]);
        hasher.input(&final_hash[..]);
        hasher.input(&master_hash[..]);
        hasher.input(master);
        hasher.input(domain);
        final_hash = get_hash(&mut hasher);
    }
    //Hopefully this algorithm is slow enough
    final_hash
}
```


Overlapping Code:
```
 &[u8], domain: &[u8]) -> [u8; 64] {
let mut hasher = Sha512::new();
//Hash the master password a few thousand times
hasher.input(SALT);
hasher.input(master);
let mut master_hash = get_hash(&mut hasher);
for i in 0..25_000_u32 {
//Generate salt
hasher.input(SALT);
hasher.input(&i.to_le_bytes()[..]);
let salt = get_hash(&mut hasher);
//Feed in previous hash, salt and master password to modify hash
hasher.input(&salt[..]);
hasher.input(&master_hash[..]);
hasher.input(master);
master_hash = get_hash(&mut hasher);
}
//Hash both master and domain a few thousand times
hasher.input(SALT);
hasher.input(domain);
hasher.input(master);
let mut final_hash = get_hash(&mut hasher);
for i in 0..25_000_u32 {
//Generate salt for this iteration
hasher.input(&i.to_be_bytes());
hasher.input(SALT);
let salt = get_hash(&mut hasher);
//Feed in previous hash, salt and both master and domain in order to modify hash
hasher.input(&salt[..]);
hasher.input(&final_hash[..]);
hasher.input(&master_hash[..]);
hasher.input(master);
hasher.input(domain);
final_hash = get_hash(&mut hasher);
}
//Hopefully this algorithm
```
<Overlap Ratio: 0.9565217391304348>

---

--- 234 --
Question ID: 4945796b0f67484b227519adebc25a57ebe2a8df_0
Original Code:
```
fn create_fastfield_bitpacker(len: usize, num_bits: u8) -> (BitUnpacker<Vec<u8>>, Vec<u64>) {
        let mut data = Vec::new();
        let mut bitpacker = BitPacker::new();
        let max_val: u64 = (1u64 << num_bits as u64) - 1u64;
        let vals: Vec<u64> = (0u64..len as u64)
            .map(|i| if max_val == 0 { 0 } else { i % max_val })
            .collect();
        for &val in &vals {
            bitpacker.write(val, num_bits, &mut data).unwrap();
        }
        bitpacker.close(&mut data).unwrap();
        assert_eq!(data.len(), ((num_bits as usize) * len + 7) / 8 + 7);
        let bitunpacker = BitUnpacker::new(data, num_bits);
        (bitunpacker, vals)
    }
```


Overlapping Code:
```
bitpacker(len: usize, num_bits: u8) -> (BitUnpacker<Vec<u8>>, Vec<u64>) {
let mut data = Vec::new();
let mut bitpacker = BitPacker::new();
let max_val: u64 = (1u64 << num_bits as u64) - 1u64;
let vals: Vec<u64> = (0u64..len as u64)
.map(|i| if max_val == 0 { 0 } else { i % max_val })
.collect();
for &val in &vals {
bitpacker.write(val, num_bits, &mut data).unwrap();
}
bitpacker.close(&mut data).unwrap();
assert_eq!(data.len(), ((num_bits as usize) * len + 7) / 8 + 7);
let bitunpacker = BitUnpacke
```
<Overlap Ratio: 0.8851590106007067>

---

--- 235 --
Question ID: 7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d_25
Original Code:
```
fn inc_with_hc() {
        let mut mem: Memory = Memory::new();
        let mut cpu: CPU = CPU::new(&mut mem);
        cpu.registers.write(&Register8bits::B, 15);

        inc(&mut cpu, Register8bits::B);

        assert_eq!(cpu.registers.read(&Register8bits::B), 16);
        assert_eq!(cpu.registers.read_hc_flag(), true)
    }
```


Overlapping Code:
```
_with_hc() {
let mut mem: Memory = Memory::new();
let mut cpu: CPU = CPU::new(&mut mem);
cpu.registers.write(&Register8bits::B, 15);
inc(&mut cpu, Register8bits::B);
assert_eq!(cpu.registers.read(&Register8bits::B), 16);
assert_eq!(cpu.registers.read_hc_flag(), t
```
<Overlap Ratio: 0.9563636363636364>

---

--- 236 --
Question ID: c06910b5192a29097bb166d93be686624985f051_2
Original Code:
```
fn mv_ll<P: AsRef<Path>>(old: P, new: P) {
	rmdir(&new);
	mkdir(&new);
	fs::rename(old, new).unwrap();
}
```


Overlapping Code:
```
old: P, new: P) {
rmdir(&new);
mkdir(&new);
fs::re
```
<Overlap Ratio: 0.49504950495049505>

---

--- 237 --
Question ID: 8ad40a073520dbaa4b6acc84644721085c98f77e_0
Original Code:
```
fn i32_overflow() {
        let max = std::i32::MAX;
        let min = std::i32::MIN;

        let apply_overflow = Transform::AddInt32(1).apply(max.into());
        let apply_underflow = Transform::AddInt32(-1).apply(min.into());

        let transform_overflow = Transform::AddInt32(max) + Transform::AddInt32(1);
        let transform_underflow = Transform::AddInt32(min) + Transform::AddInt32(-1);

        assert_eq!(apply_overflow.expect("Unexpected overflow"), min.into());
        assert_eq!(apply_underflow.expect("Unexpected underflow"), max.into());

        assert_eq!(transform_overflow, min.into());
        assert_eq!(transform_underflow, max.into());
    }
```


Overlapping Code:
```
max = std::i32::MAX;
let min = std::i32::MIN;
let apply_overflow = Transform::AddInt32(1).apply(max.into());
let apply_underflow = Transform::AddInt32(-1).apply(min.into());
let transform_overflow = Transform::AddInt32(max) + Transform::AddInt32(1);
let transform_underflow = Transform::AddInt32(min) + Transform::AddInt32(-1);
assert_eq!(apply_overflow.expect("Unexpected overflow"), min.into());
assert_eq!(apply_underflow.expect("Unexpected underflow"), max.into());
assert_eq!(transform_overflow, min.into());
assert_eq!(transform_underflow, max.into(
```
<Overlap Ratio: 0.9503424657534246>

---

--- 238 --
Question ID: 9f93a5606ae682304267c246e5b42734d38a78a9_0
Original Code:
```
pub fn compile_read(mv: &mut MustacheVisitor, reader: &mut Read, file: &str) -> Result<(), String> {
    let mut buf = &mut BufReader::new(reader).chars();
    let iter = &mut buf.take_while(|c| {
        c.is_ok()
    }).map(|c| {
        c.ok().unwrap()
    });
    let chars = Lookahead::new(iter);

    compile_internal(mv, &chars, None, &Cell::new(0), file, DEFAULT_SM, DEFAULT_EM, true)
}
```


Overlapping Code:
```
 MustacheVisitor, reader: &mut Read, file: &str) -> Result<(), String> {
let mut buf = &mut BufReader::new(reader).chars();
let iter = &mut buf.take_while(|c| {
c.is_ok()
}).map(|c| {
c.ok().unwrap()
});
let chars = Lookahead::new(iter);
compile_internal(mv, &chars, None, &Cell::new(0), file, DEFAUL
```
<Overlap Ratio: 0.8498583569405099>

---

--- 239 --
Question ID: aca57c29143659cbac6350849918fd439a686969_1
Original Code:
```
async fn main() {
    env_logger::init();

    let opts = Opt::parse();

    let index_html_s = tokio::fs::read_to_string(opts.dir.join("index.html"))
        .await
        .expect("failed to read index.html");

    let handle_error = |e| async move {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("error occurred: {}", e),
        )
    };

    let app = Router::new()
        .route("/api/test", get(|| async move { "Hello World" }))
        // needed because https://github.com/tower-rs/tower-http/issues/262
        .route("/", get(render))
        .fallback(HandleError::new(
            ServeDir::new(opts.dir)
                .append_index_html_on_directories(false)
                .fallback(
                    render
                        .layer(Extension(index_html_s))
                        .into_service()
                        .map_err(|err| -> std::io::Error { match err {} }),
                ),
            handle_error,
        ));

    println!("You can view the website at: http://localhost:8080/");

    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```


Overlapping Code:
```
fn main() {
env_logger::init();
let opts = Opt::parse();
let index_html_s = tokio::fs::read_to_string(opts.dir.join("index.html"))
.await
.expect("failed to read index.html");
let handle_error = |e| async move {
(
StatusCode::INTERNAL_SERVER_ERROR,
format!("error occurred: {}", e),
)
};
let app = Router::new()
.route("/api/test", get(|| async move { "Hello World" }))
// needed because https://github.com/tower-rs/tower-http/issues/262
.route("/", get(render))
.fallback(HandleError::new(
ServeDir::new(opts.dir)
.append_index_html_on_directories(false)
.fallback(
render
.layer(Extension(index_html_s))
.into_service()
.map_err(|err| -> std::io::Error { match err {} }),
),
handle_error,
));
println!("You can view the website at: http://localhost:8080/");
axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
.serve(app.into_make_service())
.await
.unwrap();
}
```
<Overlap Ratio: 0.993103448275862>

---

--- 240 --
Question ID: 01eb19df7b2b2680259e3d4ce64ff154926f277f_0
Original Code:
```
pub fn parse_ruleset<I: 'static>(
    tokens: &mut Peekable<I>,
    selector_group: Option<&SelectorGroup>,
) -> Option<RulesetNode>
where
    I: Iterator<Item = TokenTree>,
{
    let mut declarations = Vec::<DeclarationNode>::new();
    let mut nested_rulesets = Vec::<RulesetNode>::new();
    let mut root_metadatas = Vec::<MetadataNode>::new();
    let mut rule_metadatas = Vec::<MetadataNode>::new();
    let mut first = None;
    let mut last = None;

    let mut parse_declaration = |rule_metadatas: &mut Vec<MetadataNode>,
                                 declarations: &mut Vec<DeclarationNode>,
                                 tokens: &mut Peekable<I>| {
        let parsed = parse_declaration(rule_metadatas.to_vec(), tokens);

        if let Some(node) = parsed {
            if first.is_none() {
                first = Some(node.range);
            }
            last = Some(node.range);

            declarations.push(node);
        }
    };

    loop {
        let token = tokens.peek().cloned();
        match token {
            Some(TokenTree::Punct(ref token)) if token.as_char() == '#' => {
                let sharp = tokens.next().expect("Guaranteed by match");

                let parsed = parse_metadata(sharp, tokens);

                match parsed {
                    Some(node @ MetadataNode {
                        metadata_type: MetadataType::Root,
                        ..
                    }) => {
                        if !rule_metadatas.is_empty() || !declarations.is_empty() {
                            node.range.warning("Put root metadata on the first of ruleset").emit();
                        }
                        if selector_group.is_some() {
                            node.range.error("Put root metadata on the root of ruleset").emit();
                            continue;
                        }
                        root_metadatas.push(node);
                    },
                    Some(node @ MetadataNode {
                        metadata_type: MetadataType::Rule,
                        ..
                    }) => {
                        rule_metadatas.push(node);
                    }
                    _ => {
                        // todo: unwrap_or(parse_selector())
                        panic!("Not Implemented")
                    }
                }
                continue;
            }
            Some(TokenTree::Punct(ref punct))
            // class selector
            if punct.as_char() == '.'
            // itself selector
            || punct.as_char() == '&'
            // universal selector
            || punct.as_char() == '*'
            // state selector
            || punct.as_char() == ':'
            // adjacent sibling selector
            || punct.as_char() == '+'
            // general sibling selector
            || punct.as_char() == '~'
            // child selector
            || punct.as_char() == '>' =>
            {
                if let Some((parsed_selector_group, stream)) = parse_selector_group(vec!(), tokens) {
                    let mut joined = Vec::<Selector>::new();
                    if let Some(selector_group) = selector_group.cloned() {
                        for selector in selector_group {
                            joined.push(selector);
                        }
                    }
                    for selector in parsed_selector_group {
                        joined.push(selector);
                    }

                    if let Some(ruleset) = parse_ruleset(&mut stream.into_iter().peekable(), Some(&joined)) {
                        nested_rulesets.push(ruleset);
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            Some(TokenTree::Group(ref token)) if token.delimiter() == Delimiter::Bracket => {
                // todo: parse_selector()
                break;
            }
            Some(TokenTree::Ident(_))  => {
                parse_declaration(&mut rule_metadatas, &mut declarations, tokens);
            }
            Some(TokenTree::Punct(ref token)) if token.as_char() == '-' => {
                parse_declaration(&mut rule_metadatas,&mut declarations, tokens);
            }
            Some(TokenTree::Punct(ref token)) if token.as_char() == ';' => {
                parse_declaration(&mut rule_metadatas, &mut declarations,tokens);
            }
            None => {
                break;
            }
            Some(token) => {
                token.span().error(format!("Unacceptable token {:?}", token.to_string())).emit();
                return None;
            }
        }
    }

    if declarations.is_empty() {
        None
    } else {
        Some(RulesetNode {
            range: first.map(|first| first.join(last.unwrap_or(first)).expect("In the same file")),
            declarations: declarations,
            metadatas: root_metadatas,
            nested_rulesets: nested_rulesets,
            ruleset_type: selector_group.map_or(RulesetType::Root, |selector_group| {
                RulesetType::Selector(selector_group.to_vec())
            }),
        })
    }
}
```


Overlapping Code:
```
fn parse_ruleset<I: 'static>(
tokens: &mut Peekable<I>,
selector_group: Option<&SelectorGroup>,
) -> Option<RulesetNode>
where
I: Iterator<Item = TokenTree>,
{
let mut declarations = Vec::<DeclarationNode>::new();
let mut nested_rulesets = Vec::<RulesetNode>::new();
let mut root_metadatas = Vec::<MetadataNode>::new();
let mut rule_metadatas = Vec::<MetadataNode>::new();
let mut first = None;
let mut last = None;
let mut parse_declaration = |rule_metadatas: &mut Vec<MetadataNode>,
declarations: &mut Vec<DeclarationNode>,
tokens: &mut Peekable<I>| {
let parsed = parse_declaration(rule_metadatas.to_vec(), tokens);
if let Some(node) = parsed {
if first.is_none() {
first = Some(node.range);
}
last = Some(node.range);
declarations.push(node);
}
};
loop {
let token = tokens.peek().cloned();
match token {
Some(TokenTree::Punct(ref token)) if token.as_char() == '#' => {
let sharp = tokens.next().expect("Guaranteed by match");
let parsed = parse_metadata(sharp, tokens);
match parsed {
Some(node @ MetadataNode {
metadata_type: MetadataType::Root,
..
}) => {
if !rule_metadatas.is_empty() || !declarations.is_empty() {
node.range.warning("Put root metadata on the first of ruleset").emit();
}
if selector_group.is_some() {
node.range.error("Put root metadata on the root of ruleset").emit();
continue;
}
root_metadatas.push(node);
},
Some(node @ MetadataNode {
metadata_type: MetadataType::Rule,
..
}) => {
rule_metadatas.push(node);
}
_ => {
// todo: unwrap_or(parse_selector())
panic!("Not Implemented")
}
}
continue;
}
Some(TokenTree::Punct(re
```
<Overlap Ratio: 0.9669369931378665>

---

--- 241 --
Question ID: 3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743_2
Original Code:
```
fn valid_render_config_is_parsed() {
        let input = r##"config:
        step = 8
        angle = 45
        "##;

        let (actual, _rem) = render_config().parse(input).expect("to parse a configuration");

        let expected = RenderConfig { step: 8, angle: 45 };
        assert_eq!(actual, expected);
    }
```


Overlapping Code:
```
put = r##"config:
step = 8
angle = 45
"##;
let (actual, _rem) = render_config().parse(input).expect("to parse a configuration");
let expected = RenderConfig { step: 8, angle: 45 };
assert_eq!(actual, 
```
<Overlap Ratio: 0.7843137254901961>

---

--- 242 --
Question ID: 1f75caedcb552cf7f55f3e067b517ba2a9e251fe_3
Original Code:
```
fn test_spaces() {
        let s = "( a + 2 - \t b \t^ 2 ) == 5";
        let mut lexer = Lexer::new();
        assert_eq!(lexer.parse_string(s), Ok(()));

        let variable_result: VecDeque<Exp> = vec![Exp::Variable("a".to_owned()),
                                                  Exp::Lit(Lit::Number(2)),
                                                  Exp::Variable("b".to_owned()),
                                                  Exp::Lit(Lit::Number(2)),
                                                  Exp::Lit(Lit::Number(5))]
            .into_iter()
            .rev()
            .collect();
        assert_eq!(lexer.state.variables, variable_result);

        let operator_result: VecDeque<String> = vec!["(", "+", "-", "^", ")", "=="]
            .into_iter()
            .rev()
            .map(|s| s.to_owned())
            .collect();
        assert_eq!(lexer.state.operators, operator_result);
    }
```


Overlapping Code:
```
- \t b \t^ 2 ) == 5";
let mut lexer = Lexer::new();
assert_eq!(lexer.parse_string(s), Ok(()));
let variable_result: VecDeque<Exp> = vec![Exp::Variable("a".to_owned()),
Exp::Lit(Lit::Number(2)),
Exp::Variable("b".to_owned()),
Exp::Lit(Lit::Number(2)),
Exp::Lit(Lit::Number(5))]
.into_iter()
.rev()
.collect();
assert_eq!(lexer.state.variables, variable_result);
let operator_result: VecDeque<String> = vec!["(", "+", "-", "^", ")", "=="]
.into_iter()
.rev()
.map(|s| s.to_owned())
.collect();
assert_eq!(lexer.state.operators, operator_result
```
<Overlap Ratio: 0.9311531841652324>

---

--- 243 --
Question ID: 198fbbebfea1a34dc7c7289b20b4b10882195892_3
Original Code:
```
fn rsa_shadower1_test () {
  let smode = ASymSymMode::None;
  let input_length = 256;
  let write_buffer_length = 256;
  let read_buffer_length = 256;
  rsa_shadower_test (input_length, write_buffer_length, read_buffer_length, smode);
}
```


Overlapping Code:
```
adower1_test () {
let smode = ASymSymMode::None;
let input_length = 256;
let write_buffer_length = 256;
let read_buffer_length = 256;
rsa_shadower_test (input_length, write_buffer_length, read_buffer_length, smode);
}
```
<Overlap Ratio: 0.9601769911504425>

---

--- 244 --
Question ID: 3984f9bbb71389b81b6d19c6b0ac07e3b485b9b9_1
Original Code:
```
pub fn fission_to(filled: &V3<bool>, to: &Vec<P>) -> (Vec<usize>, Vec<Command>)  {
    eprintln!("fission: started");
    let mut log_bots = Vec::new();
    let mut log_cmds = Vec::new();
    {
        let fusion_cmds = postproc::fusion_all(filled, to.clone());
        let mut sim = sim::SimState::from_positions(filled.clone(), to.clone());

        let mut ip = 0;
        while ip < fusion_cmds.len() {
            log_bots.push(sim.bots.clone());
            let n = sim.bots.len();
            let mut cmds_step = Vec::new();
            for i in ip..ip+n {
                cmds_step.push(fusion_cmds[i]);
            }
            // eprintln!("{:?}", cmds_step);
            log_cmds.push(cmds_step.clone());
            sim.step(cmds_step);
            ip += n;
        }
        assert_eq!(ip, fusion_cmds.len());
        assert_eq!(sim.bots.len(), 0);
        let last_cmds = log_cmds.pop();
        assert_eq!(last_cmds, Some(vec![Command::Halt]));
    }
    let mut bots = log_bots.pop().unwrap(); //.into_iter().collect();

    let mut fission_cmds = Vec::new();
    let mut sim = sim::SimState::new(filled.len(), to.len());

    while let Some(cmds) = log_cmds.pop() {
        let next_bots = bots;
        bots = log_bots.pop().unwrap(); //.into_iter().collect();
        // eprintln!("fusion: {:?} <- {:?}", next_bots, bots);
        // eprintln!("fission: {:?} -> ", sim.bots);

        let mut back_cmds = BTreeMap::new();
        for (bot, &cmd) in bots.iter().zip(cmds.iter()) {
            // if let Command::FusionS(nd) = cmd {
            //     continue;
            // }
            if let Some(next_bot) = next_bots.iter().find(|&b| b.bid == bot.bid) {
                let back_bot = sim.bots.iter().find(|&b| b.p == next_bot.p).unwrap();
                let back_cmd = match cmd {
                    Command::Wait => Command::Wait,
                    Command::SMove(d) => Command::SMove(-d),
                    Command::LMove(d1, d2) => Command::LMove(-d2, -d1),
                    Command::FusionP(nd) => Command::Fission(nd, next_bot.seeds.len() - bot.seeds.len() - 1),
                    _ => panic!(),
                };
                back_cmds.insert(back_bot.bid, back_cmd);
            }
        }
        let back_cmds: Vec<_> = back_cmds.values().cloned().collect();
        fission_cmds.append(&mut back_cmds.clone());
        sim.step(back_cmds);
    }

    let mut bids = Vec::new();
    for &pos in to.iter() {
        let bot = sim.bots.iter().find(|&b| b.p == pos).unwrap();
        bids.push(bot.bid);
    }
    eprintln!("fission: finished!");
    (bids, fission_cmds)
}
```


Overlapping Code:
```
bool>, to: &Vec<P>) -> (Vec<usize>, Vec<Command>) {
eprintln!("fission: started");
let mut log_bots = Vec::new();
let mut log_cmds = Vec::new();
{
let fusion_cmds = postproc::fusion_all(filled, to.clone());
let mut sim = sim::SimState::from_positions(filled.clone(), to.clone());
let mut ip = 0;
while ip < fusion_cmds.len() {
log_bots.push(sim.bots.clone());
let n = sim.bots.len();
let mut cmds_step = Vec::new();
for i in ip..ip+n {
cmds_step.push(fusion_cmds[i]);
}
// eprintln!("{:?}", cmds_step);
log_cmds.push(cmds_step.clone());
sim.step(cmds_step);
ip += n;
}
assert_eq!(ip, fusion_cmds.len());
assert_eq!(sim.bots.len(), 0);
let last_cmds = log_cmds.pop();
assert_eq!(last_cmds, Some(vec![Command::Halt]));
}
let mut bots = log_bots.pop().unwrap(); //.into_iter().collect();
let mut fission_cmds = Vec::new();
let mut sim = sim::SimState::new(filled.len(), to.len());
while let Some(cmds) = log_cmds.pop() {
let next_bots = bots;
bots = log_bots.pop().unwrap(); //.into_iter().collect();
// eprintln!("fusion: {:?} <- {:?}", next_bots, bots);
// eprintln!("fission: {:?} -> ", sim.bots);
let mut back_cmds = BTreeMap::new();
for (bot, &cmd) in bots.iter().zip(cmds.iter()) {
// if let Command::FusionS(nd) = cmd {
// continue;
// }
if let Some(next_bot) = next_bots.iter().find(|&b| b.bid == bot.bid) {
let back_bot = sim.bots.iter().find(|&b| b.p == next_bot.p).unwrap();
let back_cmd = match cmd {
Command::Wait => Command::Wait,
Command::SMove(d) => Command::SMove(-d),
Command::LMove(d1, d2) => Command::LMove(-d2, -d1),
Command::FusionP(nd) => Command::Fission(nd, next_bot.seeds.len() - bot.seeds.len() - 1),
_ => panic!(),
};
back_cmds.insert(back_bot.bid, back_cmd);
}
}
let back_cmds: Vec<_> = back_cmds.values().cloned().collect();
fission_cmds.append(&mut back_cmds.clone());
sim.step(back_cmds);
}
let mut bids = Vec::new();
for &pos in to.iter() {
let bot = sim.bots.iter().fin
```
<Overlap Ratio: 0.9829280910501811>

---

--- 245 --
Question ID: 8b8f8095a6e61a9e5c6f93e1186ec020d71b62c2_1
Original Code:
```
fn get_pos(value: i64, mode: i64, base: i64) -> i64 {
    let mut pos = 0;
    if mode == 0 {
        pos = value
    } else if mode == 2 {
        pos = value + base;
    } else {
        assert!(false);
    }
    return pos;
}
```


Overlapping Code:
```
n get_pos(value: i64, mode: i64, base: i64) -> i64 {
let mut pos = 0;
if mode == 0 {
pos = value
} else if mode == 2 {
pos = value + base;
} else {
assert!(false);
}
return 
```
<Overlap Ratio: 0.9611111111111111>

---

--- 246 --
Question ID: 2b4ca688137df6eb0e2d7aff08555f29ac133807_8
Original Code:
```
fn test_insufficient_funds() {
        let (genesis_block, mint_keypair) = GenesisBlock::new(11_000);
        let bank = Bank::new(&genesis_block);
        let pubkey = Pubkey::new_rand();
        bank.transfer(1_000, &mint_keypair, &pubkey).unwrap();
        assert_eq!(bank.transaction_count(), 1);
        assert_eq!(bank.get_balance(&pubkey), 1_000);
        assert_eq!(
            bank.transfer(10_001, &mint_keypair, &pubkey),
            Err(TransactionError::InstructionError(
                0,
                InstructionError::new_result_with_negative_lamports(),
            ))
        );
        assert_eq!(bank.transaction_count(), 1);

        let mint_pubkey = mint_keypair.pubkey();
        assert_eq!(bank.get_balance(&mint_pubkey), 10_000);
        assert_eq!(bank.get_balance(&pubkey), 1_000);
    }
```


Overlapping Code:
```
) {
let (genesis_block, mint_keypair) = GenesisBlock::new(11_000);
let bank = Bank::new(&genesis_block);
let pubkey = Pubkey::new_rand();
bank.transfer(1_000, &mint_keypair, &pubkey).unwrap();
assert_eq!(bank.transaction_count(), 1);
assert_eq!(bank.get_balance(&pubkey), 1_000);
assert_eq!(
bank.transfer(10_001, &mint_keypair, &pubkey),
Err(TransactionError::InstructionError(
0,
InstructionError::new_result_with_negative_lamports(),
))
);
assert_eq!(bank.transaction_count(), 1);
let mint_pubkey = mint_keypair.pubkey();
assert_eq!(bank.get_balance(&mint_pubkey), 10_000);
assert_eq!(bank.get_balance(&pubkey), 1_00
```
<Overlap Ratio: 0.9508448540706606>

---

--- 247 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_566
Original Code:
```
fn spec_test_567() {
    let original = r##"[foo][bar][baz]

[baz]: /url1
[foo]: /url2
"##;
    let expected = r##"<p>[foo]<a href="/url1">bar</a></p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
) {
let original = r##"[foo][bar][baz]
[baz]: /url1
[foo]: /url2
"##;
let expected = r##"<p>[foo]<a href="/url1">bar</a></p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.9095744680851063>

---

--- 248 --
Question ID: d84e321bc09376b4b1f71df5104cb5c54a74cfe9_0
Original Code:
```
pub fn link_csfml(lib_name: &str) {
    // Figure out the path to libraries within the CSFML base folder
    // based on the operating system
    let lib_path = if cfg!(target_family = "windows") {
        if cfg!(target_env = "msvc") {
            "lib/msvc"
        } else {
            "lib/gcc"
        }
    } else {
        "lib"
    };

    // CSFML_HOME points to the base CSFML directory
    // Let cargo find the CSFML library files there
    if let Ok(csfml_home) = var("CSFML_HOME") {
        println!("cargo:rustc-link-search=native={}/{}", csfml_home, lib_path);
    }

    // Link to the csfml library
    println!("cargo:rustc-link-lib=csfml-{}", lib_name);
}
```


Overlapping Code:
```
 Figure out the path to libraries within the CSFML base folder
// based on the operating system
let lib_path = if cfg!(target_family = "windows") {
if cfg!(target_env = "msvc") {
"lib/msvc"
} else {
"lib/gcc"
}
} else {
"lib"
};
// CSFML_HOME points to the base CSFML directory
// Let cargo find the CSFML library files there
if let Ok(csfml_home) = var("CSFML_HOME") {
println!("cargo:rustc-link-search=native={}/{}", csfml_home, lib_path);
}
// Link to the csfml library
println!("cargo:rustc-link-
```
<Overlap Ratio: 0.8849557522123894>

---

--- 249 --
Question ID: 5dda8b3b908d7f02794840548a7243891299bd94_1
Original Code:
```
fn fib_i64 (limit: i64) -> Vec<i64> {
    let mut out: Vec<i64> = Vec::new();
    let mut a = 0;
    let mut b = 1;
    while a <= limit {
        out.push(a);
        if b <= limit {
            out.push(b);
        }
        a = a + b;
        b = a + b;
    }
    out
}
```


Overlapping Code:
```
ib_i64 (limit: i64) -> Vec<i64> {
let mut out: Vec<i64> = Vec::new();
let mut a = 0;
let mut b = 1;
while a <= limit {
out.push(a);
if b <= limit {
ou
```
<Overlap Ratio: 0.7653061224489796>

---

--- 250 --
Question ID: 8691f2177b5582024fe89f22192a6e4837a3e713_2
Original Code:
```
async fn test_azblob_storage() {
        use futures_util::stream;
        let mut input = InputConfig::default();
        input.set_account_name("devstoreaccount1".to_owned());
        input.set_bucket("test".to_owned());
        input.set_shared_key("Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==".to_owned());
        input.set_endpoint("http://127.0.0.1:10000/devstoreaccount1".to_owned());
        input.set_prefix("backup 01/prefix/".to_owned());

        let storage = AzureStorage::from_input(input).unwrap();
        assert_eq!(storage.maybe_prefix_key("t"), "backup 01/prefix/t");
        let mut magic_contents = String::new();
        for _ in 0..4096 {
            // 4 KiB
            magic_contents
                .push_str("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\n");
        }
        let size = magic_contents.len() as u64;
        let stream = stream::once(async move { Ok(magic_contents) })
            .boxed()
            .into_async_read();
        storage
            .put("t", PutResource(Box::new(stream)), size)
            .await
            .unwrap();

        let mut reader = storage.get("t");
        let mut buf = Vec::new();
        let get_size = reader.read_to_end(&mut buf).await.unwrap() as u64;
        assert_eq!(get_size, size);
    }
```


Overlapping Code:
```
ures_util::stream;
let mut input = InputConfig::default();
input.set_account_name("devstoreaccount1".to_owned());
input.set_bucket("test".to_owned());Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw=="t("http://127.0.0.1:10000/devstoreaccount1".to_owned());
input.set_prefix("backup 01/prefix/".to_owned());
let storage = AzureStorage::from_input(input).unwrap();
assert_eq!(storage.maybe_prefix_key("t"), "backup 01/prefix/t");
let mut magic_contents = String::new();
for _ in 0..4096 {
// 4 KiB
magic_contents
.push_str("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\n");
}
let size = magic_contents.len() as u64;
let stream = stream::once(async move { Ok(magic_contents) })
.boxed()
.into_async_read();
storage
.put("t", PutResource(Box::new(stream)), size)
.await
.unwrap();
let mut reader = storage.get("t");
let mut buf = Vec::new();
let get_size = reader.read_to_end(&mut buf).await.unwrap() as u64;
assert_eq!(get_size, size);
```
<Overlap Ratio: 0.911520737327189>

---

--- 251 --
Question ID: 34c52df3a8af957ca975e35de99cfc539cdf4af0_0
Original Code:
```
fn main() -> std::io::Result<()> {
    let filename = r"C:\Users\Attila\Downloads\input1.txt";
    // Open the file in read-only mode (ignoring errors).
    let file = File::open(filename).unwrap();
    let reader = BufReader::new(file);

    let mut sum = 0u32;
    // Read the file line by line using the lines() iterator from std::io::BufRead.
    for (index, line) in reader.lines().enumerate() {
        let line = line.unwrap(); // Ignore errors.
                                  // Show the line and its number.

        let value = line.parse::<u32>().unwrap();
        sum += (value / 3) - 2;
        println!("{0}. {1}", index + 1, line);
    }

    println!("sum: {}", sum);

    //println!("{}", contents);
    Ok(())
}
```


Overlapping Code:
```
esult<()> {
let filename = r"C:\Users\Attila\Downloads\input1.txt";
// Open the file in read-only mode (ignoring errors).
let file = File::open(filename).unwrap();
let reader = BufReader::new(file);
let mut sum = 0u32;
// Read the file line by line using the lines() iterator from std::io::BufRead.
for (index, line) in reader.lines().enumerate() {
let line = line.unwrap(); // Ignore errors.
// Show the line and its number.
let value = line.parse::<u32>().unwrap();
sum += (value / 3) - 2;
println!("{0}. {1}", index + 1, line);
}
println!("sum: {}", sum);
```
<Overlap Ratio: 0.9029126213592233>

---

--- 252 --
Question ID: 19cecf477208fb902565e29bf7954a7ba15ae90b_26
Original Code:
```
fn js_node_height(mut cx: FunctionContext) -> JsResult<JsString> {
    let path = cx.argument::<JsString>(0)?.value();
    let password = cx.argument::<JsString>(1)?.value();

    match node_height(&path, &password) {
        Ok(res) => {
            Ok(cx.string(res))
        }
        Err(e) => {
            Ok(cx.string(serde_json::to_string(&format!("{}",e)).unwrap()))
        }
    }
}
```


Overlapping Code:
```
(mut cx: FunctionContext) -> JsResult<JsString> {
let path = cx.argument::<JsString>(0)?.value();
let password = cx.argument::<JsString>(1)?.value();
match node_height(&path, &password) {
Ok(res) => {
Ok(cx.string(res))
}
Err(e) => {
Ok(cx.string(serde_json::to_string(&format!("{}",e)).unwrap()))
}
}
}
```
<Overlap Ratio: 0.946875>

---

--- 253 --
Question ID: 902691511daa064a7d1f43f98f73b957650de43d_0
Original Code:
```
pub fn load_dump(
    meta: Metadata,
    src: impl AsRef<Path>,
    dst: impl AsRef<Path>,
    index_db_size: usize,
    meta_env_size: usize,
    indexing_options: &IndexerOpts,
) -> anyhow::Result<()> {
    info!("Patching dump V3 to dump V4...");

    let patched_dir = tempdir()?;

    let options = CopyOptions::default();
    dir::copy(src.as_ref().join("indexes"), patched_dir.path(), &options)?;
    dir::copy(
        src.as_ref().join("index_uuids"),
        patched_dir.path(),
        &options,
    )?;

    let uuid_map = patch_index_meta(
        src.as_ref().join("index_uuids/data.jsonl"),
        patched_dir.path(),
    )?;

    fs::copy(
        src.as_ref().join("metadata.json"),
        patched_dir.path().join("metadata.json"),
    )?;

    patch_updates(&src, patched_dir.path(), uuid_map)?;

    super::v4::load_dump(
        meta,
        patched_dir.path(),
        dst,
        index_db_size,
        meta_env_size,
        indexing_options,
    )
}
```


Overlapping Code:
```
 fn load_dump(
meta: Metadata,
src: impl AsRef<Path>,
dst: impl AsRef<Path>,
index_db_size: usize,
meta_env_size: usize,
indexing_options: &IndexerOpts,
) -> anyhow::Result<()> {
info!("Patching dump V3 to dump V4...");
let patched_dir = tempdir()?;
let options = CopyOptions::default();
dir::copy(src.as_ref().join("indexes"), patched_dir.path(), &options)?;
dir::copy(
src.as_ref().join("index_uuids"),
patched_dir.path(),
&options,
)?;
let uuid_map = patch_index_meta(
src.as_ref().join("index_uuids/data.jsonl"),
patched_dir.path(),
)?;
fs::copy(
src.as_ref().join("metadata.json"),
patched_dir.path().join("metadata.json"),
)?;
patch_updates(&src, patched_dir.path(), uuid_map)?;
super::v4::load_dump(
meta,
patched_dir.path(),
dst,
index_db_size,
meta_env_size,
indexing_options,
```
<Overlap Ratio: 0.9911616161616161>

---

--- 254 --
Question ID: 6d4fe79fd24dcb9be3481f875857c2f1a7fcc843_2
Original Code:
```
fn main() -> Result<(), Box<Error>> {
    env_logger::init();
    let opt = Opt::from_args();

    let schema = kobuta::schema::parse(&opt.schema)?;

    let stdout = std::io::stdout();
    let mut stdout = stdout.lock();

    output_csv(opt.records, &schema, &mut stdout)?;

    Ok(())
}
```


Overlapping Code:
```
in() -> Result<(), Box<Error>> {
env_logger::init();
let opt = Opt::from_args();
let schema = kobuta::schema::parse(&opt.schema)?;
let stdout = std::io::stdout();
let mut stdout = stdout.lock();
output_csv(opt.records, &schema, &mut stdout)?;
Ok(())

```
<Overlap Ratio: 0.9765625>

---

--- 255 --
Question ID: e4e38acf3a7a5b13173f28b25bbf959d8dde15d4_2
Original Code:
```
fn test_return() {
    let mut cpu = CPU::new(&vec![], None);
    cpu.stack.push(0x400);
    cpu.do_instruction(&Instruction::Return).unwrap();
    assert_eq!(cpu.stack.len(), 0);
    assert_eq!(cpu.pc, 0x402);
}
```


Overlapping Code:
```
&vec![], None);
cpu.stack.push(0x400);
cpu.do_instruction(&Instruction::Return).unwrap();
assert_eq!(cpu.stack.len(), 0);
assert_eq!(cpu.pc, 0x402);
}
```
<Overlap Ratio: 0.78125>

---

--- 256 --
Question ID: 8628c4805e8c53308825a02fc09c4a329058da0b_0
Original Code:
```
async fn test_metadata() {
    let _r = env_logger::try_init();

    let topic_name = rand_test_topic();
    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(0), None).await;
    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(1), None).await;
    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(2), None).await;
    let consumer = create_consumer(&rand_test_group());

    let metadata = consumer
        .fetch_metadata(None, Duration::from_secs(5))
        .unwrap();
    let orig_broker_id = metadata.orig_broker_id();
    // The orig_broker_id may be -1 if librdkafka's bootstrap "broker" handles
    // the request.
    if orig_broker_id != -1 && orig_broker_id != 0 {
        panic!(
            "metadata.orig_broker_id = {}, not 0 or 1 as expected",
            orig_broker_id
        )
    }
    assert!(!metadata.orig_broker_name().is_empty());

    let broker_metadata = metadata.brokers();
    assert_eq!(broker_metadata.len(), 1);
    assert_eq!(broker_metadata[0].id(), 0);
    assert!(!broker_metadata[0].host().is_empty());
    assert_eq!(broker_metadata[0].port(), 9092);

    let topic_metadata = metadata
        .topics()
        .iter()
        .find(|m| m.name() == topic_name)
        .unwrap();

    let mut ids = topic_metadata
        .partitions()
        .iter()
        .map(|p| {
            assert_eq!(p.error(), None);
            p.id()
        })
        .collect::<Vec<_>>();
    ids.sort();

    assert_eq!(ids, vec![0, 1, 2]);
    assert_eq!(topic_metadata.error(), None);
    assert_eq!(topic_metadata.partitions().len(), 3);
    assert_eq!(topic_metadata.partitions()[0].leader(), 0);
    assert_eq!(topic_metadata.partitions()[1].leader(), 0);
    assert_eq!(topic_metadata.partitions()[2].leader(), 0);
    assert_eq!(topic_metadata.partitions()[0].replicas(), &[0]);
    assert_eq!(topic_metadata.partitions()[0].isr(), &[0]);

    let metadata_one_topic = consumer
        .fetch_metadata(Some(&topic_name), Duration::from_secs(5))
        .unwrap();
    assert_eq!(metadata_one_topic.topics().len(), 1);
}
```


Overlapping Code:
```
st_metadata() {
let _r = env_logger::try_init();
let topic_name = rand_test_topic();
populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(0), None).await;
populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(1), None).await;
populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(2), None).await;
let consumer = create_consumer(&rand_test_group());
let metadata = consumer
.fetch_metadata(None, Duration::from_secs(5))
.unwrap();
let orig_broker_id = metadata.orig_broker_id();
// The orig_broker_id may be -1 if librdkafka's bootstrap "broker" handles
// the request.
if orig_broker_id != -1 && orig_broker_id != 0 {
panic!(
"metadata.orig_broker_id = {}, not 0 or 1 as expected",
orig_broker_id
)
}
assert!(!metadata.orig_broker_name().is_empty());
let broker_metadata = metadata.brokers();
assert_eq!(broker_metadata.len(), 1);
assert_eq!(broker_metadata[0].id(), 0);
assert!(!broker_metadata[0].host().is_empty());
assert_eq!(broker_metadata[0].port(), 9092);
let topic_metadata = metadata
.topics()
.iter()
.find(|m| m.name() == topic_name)
.unwrap();
let mut ids = topic_metadata
.partitions()
.iter()
.map(|p| {
assert_eq!(p.error(), None);
p.id()
})
.collect::<Vec<_>>();
ids.sort();
assert_eq!(ids, vec![0, 1, 2]);
assert_eq!(topic_metadata.error(), None);
assert_eq!(topic_metadata.partitions().len(), 3);
assert_eq!(topic_metadata.partitions()[0].leader(), 0);
assert_eq!(topic_metadata.partitions()[1].leader(), 0);
assert_eq!(topic_metadata.partitions()[2].leader(), 0);
assert_eq!(topic_metadata.partitions()[0].replicas(), &[0]);
assert_eq!(topic_metadata.partitions()[0].isr(), &[0]);
let metadata_one_topic = consumer
.fetch_metadata(Some(&topic_name), Duration::from_secs(5))
.unwrap();
assert_eq!(metadata_one_topic.topics().len(), 
```
<Overlap Ratio: 0.9909808342728298>

---

--- 257 --
Question ID: 1dd214dcc0a65b6e7269dcb8fb9fba695a030496_11
Original Code:
```
fn net_fee_dynamic_increase() {
    let minter = Arc::new(TestMinter::new());
    let from_acc = minter.genesis_info().owner_id;
    {
        // Create enough funds for all the accounts being created in quick succession
        let mut tx = TxVariant::V0(TxVariantV0::MintTx(MintTx {
            base: create_tx_header("0.00000 TEST"),
            to: from_acc,
            amount: get_asset("5000.00000 TEST"),
            attachment: vec![],
            attachment_name: "".to_string(),
        }));

        tx.append_sign(&minter.genesis_info().wallet_keys[1]);
        tx.append_sign(&minter.genesis_info().wallet_keys[0]);

        let res = minter.send_req(rpc::Request::Broadcast(tx));
        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));
        minter.produce_block().unwrap();
    }

    let accs = Arc::new(
        (1..100)
            .map(|id| {
                let key = KeyPair::gen();
                let mut acc = Account::create_default(
                    id,
                    Permissions {
                        threshold: 1,
                        keys: vec![key.0.clone()],
                    },
                );
                let owner_acc = minter.minter().get_account_info(from_acc).unwrap();
                let fee = owner_acc
                    .total_fee()
                    .unwrap()
                    .checked_mul(GRAEL_ACC_CREATE_FEE_MULT)
                    .unwrap();
                acc.balance = fee.checked_mul(GRAEL_ACC_CREATE_MIN_BAL_MULT).unwrap();

                // Minor optimization to reduce the number of blocks being produced
                if acc.balance.amount > 500_00000 {
                    // Reset the fee window
                    for _ in 0..=NETWORK_FEE_AVG_WINDOW {
                        minter.produce_block().unwrap();
                    }
                }
                (minter.create_account(acc, &fee.to_string(), false), key)
            })
            .collect::<Vec<_>>(),
    );

    for (acc, _) in accs.as_ref() {
        let tx = {
            let amount = Asset::new(100000);
            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {
                base: create_tx_header("1.00000 TEST"),
                from: from_acc,
                call_fn: 1,
                args: {
                    let mut args = vec![];
                    args.push_u64(acc.id);
                    args.push_asset(amount);
                    args
                },
                amount,
                memo: vec![],
            }));
            tx.append_sign(&minter.genesis_info().wallet_keys[3]);
            tx.append_sign(&minter.genesis_info().wallet_keys[0]);
            tx
        };

        let req = rpc::Request::Broadcast(tx);
        let res = minter.send_req(req.clone()).unwrap();
        let exp = Err(net::ErrorKind::TxValidation(
            blockchain::TxErr::InvalidFeeAmount,
        ));
        if res == exp {
            for _ in 0..=FEE_RESET_WINDOW {
                minter.produce_block().unwrap();
            }
            let res = minter.send_req(req).unwrap();
            assert_eq!(res, Ok(rpc::Response::Broadcast));
        } else {
            assert_eq!(res, Ok(rpc::Response::Broadcast));
        }
    }

    for (acc, key) in accs.as_ref() {
        let tx = {
            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {
                base: create_tx_header("1.00000 TEST"),
                from: acc.id,
                call_fn: 0,
                args: {
                    let mut args = vec![];
                    args.push_u64(from_acc);
                    args.push_asset(Asset::default());
                    args
                },
                amount: Asset::default(),
                memo: vec![],
            }));
            tx.append_sign(&key);
            tx
        };

        let res = minter.send_req(rpc::Request::Broadcast(tx));
        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));
    }

    // Ensure the network fee gets updated
    for _ in 0..5 {
        minter.produce_block().unwrap();
    }

    {
        let res = minter.send_req(rpc::Request::GetProperties).unwrap();
        let props = match res {
            Ok(rpc::Response::GetProperties(props)) => props,
            unexp @ _ => panic!("Expected GetProperties response: {:?}", unexp),
        };

        let chain = minter.chain();
        let max_height = props.height - (props.height % 5);
        let min_height = max_height - NETWORK_FEE_AVG_WINDOW;
        assert!(min_height < max_height);

        let receipt_count = (min_height..=max_height).fold(1u64, |receipt_count, height| {
            let block = chain.get_block(height).unwrap();
            receipt_count + block.receipts().len() as u64
        });
        let receipt_count = (receipt_count / NETWORK_FEE_AVG_WINDOW) as u16;
        assert!(receipt_count > 10);

        let fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT.checked_pow(receipt_count).unwrap());
        assert_eq!(Some(props.network_fee), fee);
    }

    for _ in 0..=NETWORK_FEE_AVG_WINDOW {
        minter.produce_block().unwrap();
    }

    // Test network delta fee reset
    let expected_fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT);
    assert_eq!(minter.chain().get_network_fee(), expected_fee);
}
```


Overlapping Code:
```
= Arc::new(TestMinter::new());
let from_acc = minter.genesis_info().owner_id;
{
// Create enough funds for all the accounts being created in quick succession
let mut tx = TxVariant::V0(TxVariantV0::MintTx(MintTx {
base: create_tx_header("0.00000 TEST"),
to: from_acc,
amount: get_asset("5000.00000 TEST"),
attachment: vec![],
attachment_name: "".to_string(),
}));
tx.append_sign(&minter.genesis_info().wallet_keys[1]);
tx.append_sign(&minter.genesis_info().wallet_keys[0]);
let res = minter.send_req(rpc::Request::Broadcast(tx));
assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));
minter.produce_block().unwrap();
}
let accs = Arc::new(
(1..100)
.map(|id| {
let key = KeyPair::gen();
let mut acc = Account::create_default(
id,
Permissions {
threshold: 1,
keys: vec![key.0.clone()],
},
);
let owner_acc = minter.minter().get_account_info(from_acc).unwrap();
let fee = owner_acc
.total_fee()
.unwrap()
.checked_mul(GRAEL_ACC_CREATE_FEE_MULT)
.unwrap();
acc.balance = fee.checked_mul(GRAEL_ACC_CREATE_MIN_BAL_MULT).unwrap();
// Minor optimization to reduce the number of blocks being produced
if acc.balance.amount > 500_00000 {
// Reset the fee window
for _ in 0..=NETWORK_FEE_AVG_WINDOW {
minter.produce_block().unwrap();
}
}
(minter.create_account(acc, &fee.to_string(), false), key)
})
.collect::<Vec<_>>(),
);
for (acc, _) in accs.as_ref() {
let tx = {
let amount = Asset::new(100000);
let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {
base: create_tx_header("1.00000 TEST"),
from: from_acc,
call_fn: 1,
args: {
let mut args = vec![];
args.push_u64(acc.id);
args.push_asset(amount);
```
<Overlap Ratio: 0.9650180940892642>

---

--- 258 --
Question ID: 3606d2c00a03802dc158028a6f2e7b76639aeade_37
Original Code:
```
fn testOP_TAY() {
        let mut cpu = super::CPU::new_empty();

        cpu.a = 0;
        cpu.TAY();
        assert_eq!(cpu.y, 0); //Changes 'Z, N'
        assert_eq!(cpu.get_status("Z"), true);
    }
```


Overlapping Code:
```
w_empty();
cpu.a = 0;
cpu.TAY();
assert_eq!(cpu.y, 0); //Changes 'Z, N'
assert_eq!(cpu.get_status("Z
```
<Overlap Ratio: 0.6329113924050633>

---

--- 259 --
Question ID: 386571ca246b0caad7784540804701b761513959_3
Original Code:
```
fn reverse_id_comparator_correct_order() -> Result<(), Error> {
        let a = ContextActionByContractIndexKey {
            contract_address: hex::decode("0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50")?,
            id: 6548,
        }.encode()?;
        let b = ContextActionByContractIndexKey {
            contract_address: hex::decode("0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50")?,
            id: 6546,
        }.encode()?;

        Ok(assert_eq!(Ordering::Less, ContextActionByContractIndexKey::reverse_id_comparator(&a, &b)))
    }
```


Overlapping Code:
```
omparator_correct_order() -> Result<(), Error> {
let a = ContextActionByContractIndexKey {
contract_address: hex::decode("0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50")?,
id: 6548,
}.encode()?;
let b = ContextActionByContractIndexKey {
contract_address: hex::decode("0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50")?,
id: 6546,
}.encode()?;
Ok(assert_eq!(Ordering::Less, ContextActionByContractIndexKey::reverse_id_com
```
<Overlap Ratio: 0.9244444444444444>

---

--- 260 --
Question ID: 7be6eedc2704db183a29bd11d07026a157fde6da_1
Original Code:
```
pub fn root() -> PathBuf {
    let idx = IDX.with(|x| *x);

    let mut me = env::current_exe().unwrap();
    me.pop(); // chop off exe name
    me.pop(); // chop off `deps`
    me.pop(); // chop off `debug` / `release`
    me.push("generated-tests");
    me.push(&format!("test{}", idx));
    return me
}
```


Overlapping Code:
```
PathBuf {
let idx = IDX.with(|x| *x);
let mut me = env::current_exe().unwrap();
me.pop(); // chop off exe name
me.pop(); // chop off `deps`
me.pop(); // chop off `debug` / `release`
me.push("generated-tests");
me.push(&format!
```
<Overlap Ratio: 0.8308823529411765>

---

--- 261 --
Question ID: 1d67ca4254ee2e57907b6ccb5129e8c67dc5275b_5
Original Code:
```
fn error_type() {
            use serde_tagged::de::WithTag;
            use serde_tagged::de::external::deserialize as de;

            let json = "[]";

            let mut jde = serde_json::Deserializer::from_str(json);
            let (_t, _v): (&str, &str) = de(&mut jde, WithTag::new()).unwrap();
        }
```


Overlapping Code:
```
fn error_type() {
use serde_tagged::de::WithTag;
use serde_tagged::de::external::deserialize as de;
let json = "[]";
let mut jde = serde_json::Deserializer::from_str(json);
let (_t, _v): (&str, &str) = de(&mut jde, WithTag::new()).unwrap();

```
<Overlap Ratio: 0.9958677685950413>

---

--- 262 --
Question ID: c02aa149c14839a8741c508920f5a7d9a7d06a01_2
Original Code:
```
fn load_key(key_path: &str) -> Result<String, Box<dyn Error>> {
    let mut key_file = File::open(key_path)?;
    let mut key = String::new();
    key_file.read_to_string(&mut key)?;
    Ok(key.trim_end_matches(|c| c == '\r' || c == '\n').to_string())
}
```


Overlapping Code:
```
ath: &str) -> Result<String, Box<dyn Error>> {
let mut key_file = File::open(key_path)?;
let mut key = String::new();
key_file.read_to_string(&mut key)?;
Ok(key.trim_end_matches(|c| c == '\r' || c == '\n').to_string())

```
<Overlap Ratio: 0.9240506329113924>

---

--- 263 --
Question ID: dcf6af63c26c1d9a64727846887b2d85c665e24d_2
Original Code:
```
pub fn split_odd_even(n: u64) -> (u64, u64) {
	let mut even_power = 0;
	let mut n_shift = n;

	loop {
		if n_shift & 1 == 0 {
			even_power += 1;
			n_shift = n_shift.rotate_right(1)
		} else {
			return (n_shift, even_power)
		}
	}
}
```


Overlapping Code:
```
-> (u64, u64) {
let mut even_power = 0;
let mut n_shift = n;
loop {
if n_shift & 1 == 0 {
even_power += 1;
n_shift = n_shift.rotate_right(1)
} else {

```
<Overlap Ratio: 0.7009345794392523>

---

--- 264 --
Question ID: 63184879b73d4e89a77a8104511ad617cb023a5a_2
Original Code:
```
fn wrapping_sub_generation() {
        let zero = Generation::zero();

        for i in 1..20 {
            assert_eq!(zero.wrapping_sub(i), Generation::from(128 - i));
        }
        assert_eq!(zero.wrapping_sub(1), Generation::from(127));
        assert_eq!(zero.wrapping_sub(2), Generation::from(126));
        assert_eq!(zero.wrapping_sub(3), Generation::from(125));

        let one = zero.wrapping_increment();
        assert_eq!(one, Generation::from(1));

        for i in 2..20 {
            assert_eq!(one.wrapping_sub(i), Generation::from(128 - i + 1));
        }
        assert_eq!(one.wrapping_sub(1), Generation::from(0));
        assert_eq!(one.wrapping_sub(2), Generation::from(127));
        assert_eq!(one.wrapping_sub(3), Generation::from(126));

        let two = one.wrapping_increment();
        assert_eq!(two, Generation::from(2));

        for i in 3..20 {
            assert_eq!(two.wrapping_sub(i), Generation::from(128 - i + 2));
        }
        assert_eq!(two.wrapping_sub(1), Generation::from(1));
        assert_eq!(two.wrapping_sub(2), Generation::from(0));
        assert_eq!(two.wrapping_sub(3), Generation::from(127));
        assert_eq!(two.wrapping_sub(4), Generation::from(126));

        let n = Generation::from(127);

        for i in 0..20 {
            assert_eq!(n.wrapping_sub(i), Generation::from(127 - i));
        }
    }
```


Overlapping Code:
```
ero = Generation::zero();
for i in 1..20 {
assert_eq!(zero.wrapping_sub(i), Generation::from(128 - i));
}
assert_eq!(zero.wrapping_sub(1), Generation::from(127));
assert_eq!(zero.wrapping_sub(2), Generation::from(126));
assert_eq!(zero.wrapping_sub(3), Generation::from(125));
let one = zero.wrapping_increment();
assert_eq!(one, Generation::from(1));
for i in 2..20 {
assert_eq!(one.wrapping_sub(i), Generation::from(128 - i + 1));
}
assert_eq!(one.wrapping_sub(1), Generation::from(0));
assert_eq!(one.wrapping_sub(2), Generation::from(127));
assert_eq!(one.wrapping_sub(3), Generation::from(126));
let two = one.wrapping_increment();
assert_eq!(two, Generation::from(2));
for i in 3..20 {
assert_eq!(two.wrapping_sub(i), Generation::from(128 - i + 2));
}
assert_eq!(two.wrapping_sub(1), Generation::from(1));
assert_eq!(two.wrapping_sub(2), Generation::from(0));
assert_eq!(two.wrapping_sub(3), Generation::from(127));
assert_eq!(two.wrapping_sub(4), Generation::from(126));
let n = Generation::from(127);
for i in 0..20 {
assert_eq!(n.wrapping_su
```
<Overlap Ratio: 0.9349955476402493>

---

--- 265 --
Question ID: 351fb60051510e6e6812bd55755fcd77e3cf5b1e_7
Original Code:
```
fn test_compile_push_f() {
    let compiled = miscellaneous::compile_push("F".to_string());

    assert_eq!(compiled.len(), 1);
    assert_eq!(compiled[0], 0b11001101);
}
```


Overlapping Code:
```
iscellaneous::compile_push("F".to_string());
assert_eq!(compiled.len(), 1);
assert_eq!(compiled[0], 0b11
```
<Overlap Ratio: 0.6624203821656051>

---

--- 266 --
Question ID: 519540d5655f412771175dcf4028b061d08cbe9e_11
Original Code:
```
fn bindgen_test_layout_NVIC_Type() {
    assert_eq!(::core::mem::size_of::<NVIC_Type>() , 800usize , concat ! (
               "Size of: " , stringify ! ( NVIC_Type ) ));
    assert_eq! (::core::mem::align_of::<NVIC_Type>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( NVIC_Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . ISER as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( ISER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED0 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( RESERVED0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . ICER as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( ICER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . RSERVED1 as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( RSERVED1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . ISPR as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( ISPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED2 as * const _ as
                usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( RESERVED2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . ICPR as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( ICPR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED3 as * const _ as
                usize } , 388usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( RESERVED3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED4 as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( RESERVED4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NVIC_Type ) ) . IP as * const _ as usize
                } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
                stringify ! ( IP ) ));
}
```


Overlapping Code:
```
ssert_eq!(::core::mem::size_of::<NVIC_Type>() , 800usize , concat ! (
"Size of: " , stringify ! ( NVIC_Type ) ));
assert_eq! (::core::mem::align_of::<NVIC_Type>() , 4usize , concat ! (
"Alignment of " , stringify ! ( NVIC_Type ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . ISER as * const _ as
usize } , 0usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( ISER ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . RESERVED0 as * const _ as
usize } , 4usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( RESERVED0 ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . ICER as * const _ as
usize } , 128usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( ICER ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . RSERVED1 as * const _ as
usize } , 132usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( RSERVED1 ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . ISPR as * const _ as
usize } , 256usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( ISPR ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . RESERVED2 as * const _ as
usize } , 260usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( RESERVED2 ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . ICPR as * const _ as
usize } , 384usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( ICPR ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const NVIC_Type ) ) . RESERVED3 as * const _ as
usize } , 388usize , concat ! (
"Alignment of field: " , stringify ! ( NVIC_Type ) , "::" ,
stringify ! ( RESERVED3 ) ));
assert_eq! (unsafe {
&
```
<Overlap Ratio: 0.9799472295514512>

---

--- 267 --
Question ID: 28be31fdab926ee2f934b2f9d1a00757e8b486b4_3
Original Code:
```
fn block_stretch(
    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,
    rng: &mut rand_xoshiro::Xoshiro256StarStar,
    size: u32,
    range: u32,
) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {
    println!("BlockStretch FX");

    let mut output = input.clone();
    let (width, height) = input.dimensions();
    let times = 128;
    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };

    for _ in 0..times {
        let noise_x = rng.gen_range(0, width);
        let noise_y = rng.gen_range(0, range) + range_begin;

        // Snap
        let noise_x = (noise_x as f32 / size as f32).round() as u32 * size;
        let noise_y = (noise_y as f32 / size as f32).round() as u32 * size;

        let direction = rng.gen_range(0, 2);

        if direction == 0 {
            for i in 0..size {
                let dst_x = noise_x + i;
                let dst_y = noise_y;

                if dst_x >= width { continue; }

                for j in 0..size {
                    if dst_y + j >= height { continue; }

                    output.put_pixel(dst_x, dst_y + j, *input.get_pixel(noise_x, noise_y + j));
                }
            }
        } else {
            for i in 0..size {
                let dst_x = noise_x;
                let dst_y = noise_y + i;

                if dst_y >= height { continue; }

                for j in 0..size {
                    if dst_x + j >= width { continue; }

                    output.put_pixel(dst_x + j, dst_y, *input.get_pixel(noise_x + j, noise_y));
                }
            }
        }
    }

    output
}
```


Overlapping Code:
```
fn block_stretch(
input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,
rng: &mut rand_xoshiro::Xoshiro256StarStar,
size: u32,
range: u32,
) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {
println!("BlockStretch FX");
let mut output = input.clone();
let (width, height) = input.dimensions();
let times = 128;
let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };
for _ in 0..times {
let noise_x = rng.gen_range(0, width);
let noise_y = rng.gen_range(0, range) + range_begin;
// Snap
let noise_x = (noise_x as f32 / size as f32).round() as u32 * size;
let noise_y = (noise_y as f32 / size as f32).round() as u32 * size;
let direction = rng.gen_range(0, 2);
if direction == 0 {
for i in 0..size {
let dst_x = noise_x + i;
let dst_y = noise_y;
if dst_x >= width { continue; }
for j in 0..size {
if dst_y + j >= height { continue; }
output.put_pixel(dst_x, dst_y + j, *input.get_pixel(noise_x, noise_y + j));
}
}
} else {
for i in 0..size {
let dst_x = noise_x;
let dst_y = noise_y + i;
if dst_y >= height { continue; }
for j in 0..size {
if dst_x + j >= width { continue; }
output.put_pixel(dst_x + j, dst_y, *input.get_pixel(noise_x + j, noise_y
```
<Overlap Ratio: 0.9836065573770492>

---

--- 268 --
Question ID: b54b272ada64b327872d8ddb397b5309707a3565_0
Original Code:
```
pub fn read_next_spendable_mc_index(
    db: &Connection,
    kind: &str,
    address: &str,
    conflict_units: &[String],
) -> Result<u32> {
    let sql = if !conflict_units.is_empty() {
        let conflict_units_list = conflict_units
            .iter()
            .map(|s| format!("'{}'", s))
            .collect::<Vec<_>>()
            .join(", ");
        format!(
            "SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \
             WHERE type={} AND address={} AND sequence='good' \
             AND unit NOT IN({}) \
             ORDER BY to_main_chain_index DESC LIMIT 1",
            kind, address, conflict_units_list
        )
    } else {
        format!(
            "SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \
             WHERE type={} AND address={} AND sequence='good' \
             ORDER BY to_main_chain_index DESC LIMIT 1",
            kind, address
        )
    };

    let mut stmt = db.prepare(&sql)?;
    let mut rows = stmt.query_map(&[], |row| row.get::<_, u32>(0))?;
    let row = rows.next();
    if row.is_none() {
        Ok(0)
    } else {
        Ok(row.unwrap()? + 1)
    }
}
```


Overlapping Code:
```
b: &Connection,
kind: &str,
address: &str,
conflict_units: &[String],
) -> Result<u32> {
let sql = if !conflict_units.is_empty() {
let conflict_units_list = conflict_units
.iter()
.map(|s| format!("'{}'", s))
.collect::<Vec<_>>()
.join(", ");
format!(
"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \
WHERE type={} AND address={} AND sequence='good' \
AND unit NOT IN({}) \
ORDER BY to_main_chain_index DESC LIMIT 1",
kind, address, conflict_units_list
)
} else {
format!(
"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \
WHERE type={} AND address={} AND sequence='good' \
ORDER BY to_main_chain_index DESC LIMIT 1",
kind, address
)
};
let mut stmt = db.prepare(&sql)?;
let mut rows = stmt.query_map(&[], |row| row.get::<_, u32>(0))?;
let row = rows.next();
if row.is_none() {
Ok(0)
} else {
Ok(row.unwrap(
```
<Overlap Ratio: 0.9454949944382648>

---

--- 269 --
Question ID: 2d774b1052fbf4c2ce861a46e60c60e05411930e_4
Original Code:
```
fn test_channel_last_same_padding() {
            let input = test_utils::get_input_channel_last();
            let output = max_pool2d(
                &input,
                (2, 2),
                (2, 2),
                Padding::Same,
                DataFormat::ChannelsLast
            ).unwrap();
            let exp_output_1: Array3<f64> = array![
                [[2., 4., 2.], [5., 6., 5.], [2., 6., 7.]],
                [[7., 3., 6.], [4., 5., 7.], [2., 5., 5.]],
                [[7., 4., 3.], [5., 6., 2.], [1., 1., 2.]]
            ];
            let exp_output_2: Array3<f64> = array![
                [[5., 6., 4.], [3., 5., 2.], [5., 7., 1.]],
                [[4., 3., 7.], [7., 7., 6.], [3., 5., 5.]],
                [[7., 5., 5.], [4., 6., 5.], [6., 3., 1.]]
            ];
            let exp_output = join_new_axis(vec![exp_output_1, exp_output_2]).unwrap();
            assert_eq!(output.shape(), &[2, 3, 3, 3]);
            assert_eq!(output, exp_output);
        }
```


Overlapping Code:
```
channel_last_same_padding() {
let input = test_utils::get_input_channel_last();
let output = max_pool2d(
&input,
(2, 2),
(2, 2),
Padding::Same,
DataFormat::ChannelsLast
).unwrap();
let exp_output_1: Array3<f64> = array![
[[2., 4., 2.], [5., 6., 5.], [2., 6., 7.]],
[[7., 3., 6.], [4., 5., 7.], [2., 5., 5.]],
[[7., 4., 3.], [5., 6., 2.], [1., 1., 2.]]
];
let exp_output_2: Array3<f64> = array![
[[5., 6., 4.], [3., 5., 2.], [5., 7., 1.]],
[[4., 3., 7.], [7., 7., 6.], [3., 5., 5.]],
[[7., 5., 5.], [4., 6., 5.], [6., 3., 1.]]
];
let exp_output = join_new_axis(vec![exp_output_1, exp_output_2]).unwrap();
assert_eq!(output.shape(), &[2, 3, 3, 3]);
assert_eq!(ou
```
<Overlap Ratio: 0.9593023255813954>

---

--- 270 --
Question ID: b7279b45356e24b72bd5321e19bff9273ae0acd2_0
Original Code:
```
fn test_epoll_create1() {
  assert!(epoll_create1(0) >= 0);
  assert!(epoll_create1(EPOLL_CLOEXEC) >= 0);
  assert!(epoll_create1(-1) == -1);
}
```


Overlapping Code:
```
epoll_create1(0) >= 0);
assert!(epoll_create1(EPOLL_CLOEXEC) >= 0);
assert!(epoll_create1(-1) == -1)
```
<Overlap Ratio: 0.7299270072992701>

---

--- 271 --
Question ID: ad4654f855115397598b90dbca1e2c0da3950c3e_8
Original Code:
```
fn serialize_deserialize_works_for_point_g1() {
        let structure = TestPointG1Structure {
            field: PointG1::from_string("false 6556E08075C674 EE6E05C6A17E67 20E189DE31926E DD41F2F92026FC 9181F00 BEC671398C0F1 25D98934EA6B2D 9600760C4F9729 51F977993486B1 9BC9712 FFFFFF7D07A8A8 FFFF7888802F07 FFC63D474548B7 F417D05FB10933 95E45DD").unwrap()
        };

        let deserialized: TestPointG1Structure = serde_json::from_str(&serde_json::to_string(&structure).unwrap()).unwrap();

        assert_eq!(structure, deserialized);
    }
```


Overlapping Code:
```
lize_deserialize_works_for_point_g1() {
let structure = TestPointG1Structure {
field: PointG1::from_string("false 6556E08075C674 EE6E05C6A17E67 20E189DE31926E DD41F2F92026FC 9181F00 BEC671398C0F1 25D98934EA6B2D 9600760C4F9729 51F977993486B1 9BC9712 FFFFFF7D07A8A8 FFFF7888802F07 FFC63D474548B7 F417D05FB10933 95E45DD").unwrap()
};
let deserialized: TestPointG1Structure = serde_json::from_str(&serde_json::to_string(&structure).unwrap()).unwrap();
assert_eq!(
```
<Overlap Ratio: 0.9291497975708503>

---

--- 272 --
Question ID: d749a804fa24c468a7add811d430483e8a35f6e9_0
Original Code:
```
fn main() {
    use std::collections::{HashMap, HashSet};

    let input = adventofcode::read_input_file();

    let mut dists = HashMap::<(&str, &str), u32>::new();
    let mut places = HashSet::<&str>::new();

    for line in input.lines() {
        let words: Vec<&str> = line.split_whitespace().collect();
        match words[..] {
            [a, "to", b, "=", dist] => {
                let dist = dist.parse::<u32>().expect("not an integer");
                dists.insert((a, b), dist);
                dists.insert((b, a), dist);
                places.insert(a);
                places.insert(b);
            }
            _ => panic!("Unrecognized line {:?}", line),
        }
    }

    let mut min_dist = std::u32::MAX;
    let mut max_dist = 0;

    let mut places: Vec<_> = places.iter().collect();

    adventofcode::each_perm(&mut places, |path| {
        let dist = path
            .iter()
            .zip(path.iter().skip(1))
            .map(|(&&a, &&b)| dists[&(a, b)])
            .sum::<u32>();
        if dist < min_dist {
            min_dist = dist;
        }
        if dist > max_dist {
            max_dist = dist;
        }
    });

    println!("{}", min_dist);
    println!("{}", max_dist);
}
```


Overlapping Code:
```
fn main() {
use std::collections::{HashMap, HashSet};
let input = adventofcode::read_input_file();
let mut dists = HashMap::<(&str, &str), u32>::new();
let mut places = HashSet::<&str>::new();
for line in input.lines() {
let words: Vec<&str> = line.split_whitespace().collect();
match words[..] {
[a, "to", b, "=", dist] => {
let dist = dist.parse::<u32>().expect("not an integer");
dists.insert((a, b), dist);
dists.insert((b, a), dist);
places.insert(a);
places.insert(b);
}
_ => panic!("Unrecognized line {:?}", line),
}
}
let mut min_dist = std::u32::MAX;
let mut max_dist = 0;
let mut places: Vec<_> = places.iter().collect();
adventofcode::each_perm(&mut places, |path| {
let dist = path
.iter()
.zip(path.iter().skip(1))
.map(|(&&a, &&b)| dists[&(a, b)])
.sum::<u32>();
if dist < min_dist {
min_dist = dist;
}
if dist > max_dist {
max_dist = dist;
}
});
println!("{}", min_dist);
println!("{}"
```
<Overlap Ratio: 0.9846827133479212>

---

--- 273 --
Question ID: 624a0d351ed2e6d8bae2b933511189877adfdd2b_5
Original Code:
```
fn name_checks_database() {
    let mut client = common::setup_with_db("name_checks_database");
    client.send(1, ".r SWAGGINGi'mSWAGGINGOUT yo yo");
    client.send(2, ".n SWAGGINGi'mSWAGGINGOUT");
    client.read_all();
    assert_eq!(
        client.last(2),
        "yo that name exists ya gotta pick something else aight?"
    );
}
```


Overlapping Code:
```
= common::setup_with_db("name_checks_database");
client.send(1, ".r SWAGGINGi'mSWAGGINGOUT yo yo");
client.send(2, ".n SWAGGINGi'mSWAGGINGOUT");
client.read_all();
assert_eq!(
client.last(2),
"yo that name exists ya gotta pick something else aight?"

```
<Overlap Ratio: 0.8417508417508418>

---

--- 274 --
Question ID: cdbc92eeeb7c3a60ce671ea88b40c91a547b18d6_1
Original Code:
```
fn main() {
    pretty_env_logger::init();

    let tileset_image = image::load_from_memory(TILESET_IMAGE_DATA)
        .unwrap()
        .to_rgba();
    
    let glyph_lib = create_glyph_lib();

    let mut canvas = CellBuffer::new(80, 50, Cell::default());
    let mut console = tcrab_console_gl::Console::new(tcrab_console_gl::Settings {
        title: "tcrab example".into(),
        texture_width: tileset_image.width(),
        texture_height: tileset_image.height(),
        texture_data: tileset_image.into_vec(),
        cell_width: TILESET_CELL_WIDTH,
        cell_height: TILESET_CELL_HEIGHT,
    }).unwrap();

    let mut player_pos = (5, 10);
    let mut is_running = true;
    while is_running {
        let (canvas_width, canvas_height) = canvas.size();
        draw(&mut canvas, player_pos);
        console.present(&canvas, &glyph_lib);
        console.wait_for_events_forever(|event| match event {
            Event::Quit |
            Event::KeyboardInput { key_code: Some(KeyCode::Escape), .. } => {
                is_running = false;
                ControlFlow::Break
            }
            Event::KeyboardInput { key_code: Some(key_code), key_state: ButtonState::Pressed } => {
                let mut moved = false;
                let mut move_player = |x, y| {
                    let mut new_pos = player_pos;
                    new_pos.0 += x;
                    new_pos.1 += y;
                    if new_pos.0 < 0 {
                        new_pos.0 = 0;
                    }
                    if new_pos.0 > canvas_width as i32 - 1 {
                        new_pos.0 = canvas_width as i32 - 1;
                    }
                    if new_pos.1 < 0 {
                        new_pos.1 = 0;
                    }
                    if new_pos.1 > canvas_height as i32 - 1 {
                        new_pos.1 = canvas_height as i32 - 1;
                    }
                    if new_pos != player_pos {
                        moved = true;
                        player_pos = new_pos;
                        ControlFlow::Break
                    } else { ControlFlow::Continue }
                };
                match key_code {
                    KeyCode::Up => move_player(0, -1),
                    KeyCode::Down => move_player(0, 1),
                    KeyCode::Left => move_player(-1, 0),
                    KeyCode::Right => move_player(1, 0),
                    _ => ControlFlow::Continue,
                }
            }
            _ => ControlFlow::Continue,
        });
    }
}
```


Overlapping Code:
```
pretty_env_logger::init();
let tileset_image = image::load_from_memory(TILESET_IMAGE_DATA)
.unwrap()
.to_rgba();

let glyph_lib = create_glyph_lib();
let mut canvas = CellBuffer::new(80, 50, Cell::default());
let mut console = tcrab_console_gl::Console::new(tcrab_console_gl::Settings {
title: "tcrab example".into(),
texture_width: tileset_image.width(),
texture_height: tileset_image.height(),
texture_data: tileset_image.into_vec(),
cell_width: TILESET_CELL_WIDTH,
cell_height: TILESET_CELL_HEIGHT,
}).unwrap();
let mut player_pos = (5, 10);
let mut is_running = true;
while is_running {
let (canvas_width, canvas_height) = canvas.size();
draw(&mut canvas, player_pos);
console.present(&canvas, &glyph_lib);
console.wait_for_events_forever(|event| match event {
Event::Quit |
Event::KeyboardInput { key_code: Some(KeyCode::Escape), .. } => {
is_running = false;
ControlFlow::Break
}
Event::KeyboardInput { key_code: Some(key_code), key_state: ButtonState::Pressed } => {
let mut moved = false;
let mut move_player = |x, y| {
let mut new_pos = player_pos;
new_pos.0 += x;
new_pos.1 += y;
if new_pos.0 < 0 {
new_pos.0 = 0;
}
if new_pos.0 > canvas_width as i32 - 1 {
new_pos.0 = canvas_width as i32 - 1;
}
if new_pos.1 < 0 {
new_pos.1 = 0;
}
if new_pos.1 > canvas_height as i32 - 1 {
new_pos.1 = canvas_height as i32 - 1;
}
if new_pos != player_pos {
moved = true;
player_pos = new_pos;
ControlFlow::Break
} else { ControlFlow::Continue }
};
match key_code {
KeyCode::Up => move_player(0, -1),
KeyCode::Down => move_player(0, 1),
KeyCode::Left => move_player(-1, 0),
KeyCode::Right => move_player(1, 
```
<Overlap Ratio: 0.9714632665452337>

---

--- 275 --
Question ID: eabe9ebed14fff6b92d6c17cecc752bf9299288e_0
Original Code:
```
pub fn nucleotide_counts(code :&str) -> Result<HashMap<char,usize>, &str>{
    let mut h: HashMap<char,usize> = HashMap::new();
    for c in ['G','T','A','C'].iter(){
        match count(*c,code){
            Ok(x) => h.insert(*c,x),
            Err(x) => return Err(x),
        };
    }
    Ok(h)
}
```


Overlapping Code:
```
ounts(code :&str) -> Result<HashMap<char,usize>, &str>{
let mut h: HashMap<char,usize> = HashMap::new();
for c in ['G','T','A','C'].iter(){
match count(*c,code){
Ok(x) => h.insert(*c,x),
Err(x) => ret
```
<Overlap Ratio: 0.823045267489712>

---

--- 276 --
Question ID: a09c5db65b675b5df4a637a255b612f6fa39d966_4
Original Code:
```
fn test_sign_bytes() {
        let good: &[u8] = b"test message";
        let good_bytes = good.to_vec();
        let private_key = PrivateKey::generate();
        let sign = private_key.sign_bytes(&good_bytes);

        let public_key = private_key.generate_public_key();
        assert_eq!(true, public_key.verify_bytes(&good_bytes, &sign))
    }
```


Overlapping Code:
```
_bytes() {
let good: &[u8] = b"test message";
let good_bytes = good.to_vec();
let private_key = PrivateKey::generate();
let sign = private_key.sign_bytes(&good_bytes);
let public_key = private_key.generate_public_key();
assert_eq!(true, public_key.ve
```
<Overlap Ratio: 0.847457627118644>

---

--- 277 --
Question ID: 35fa58ab4c3b5656012cb431e9999bf1e8870b6f_2
Original Code:
```
fn parse_input(s: &str) -> Result<Grid> {
    let mut g = Grid::default();

    for (y, l) in s.lines().enumerate() {
        for (x, c) in l.chars().enumerate() {
            g.insert(Point::new(x as i64, 0 - y as i64), c.try_into()?)
        }
    }

    Ok(g)
}
```


Overlapping Code:
```
{
let mut g = Grid::default();
for (y, l) in s.lines().enumerate() {
for (x, c) in l.chars().enumerate() {
g.insert(Point::new(x as i64, 0 - y as i64), c.
```
<Overlap Ratio: 0.7064220183486238>

---

--- 278 --
Question ID: 0df75b08c2e8741e8f59697eb443e21bc7ad471f_14
Original Code:
```
fn two_params(k1: &str, v1: &str, k2: &str, v2: &str) -> Params {
        let mut map = Params::new();
        map.insert(k1.to_string(), v1.to_string());
        map.insert(k2.to_string(), v2.to_string());
        map
    }
```


Overlapping Code:
```
 two_params(k1: &str, v1: &str, k2: &str, v2: &str) -> Params {
let mut map = Params::new();
map.insert(k1.to_string(), v1.to_string());
map.insert(k2.to_string(), v
```
<Overlap Ratio: 0.8776595744680851>

---

--- 279 --
Question ID: 3b69d7c8b9787cb21010f351c85a54d8e9376ae1_0
Original Code:
```
pub fn run() {
    print!("Hello from print.rs: ");
    println!("sponsored by the numbers {1:e} {0:010b}", 42, 2);
    println!("{name} is learning {language}", name="James", language="Rust");
}
```


Overlapping Code:
```
run() {
print!("Hello from print.rs: ");
println!("sponsored by the numbers {1:e} {0:010b}", 42, 2);
println!("{name} is learning {language}", name="J
```
<Overlap Ratio: 0.819672131147541>

---

--- 280 --
Question ID: 99ec1b268c51c3421dd383fb23681b4c110262f0_2
Original Code:
```
fn make_qualified_name(s: State, arg0 : Self::R) -> (State, Self::R) {
        let s = State::next(s, &[&arg0]);
        let r = Self::R::make_qualified_name(&s, arg0);
        (s, r)
    }
```


Overlapping Code:
```
 State, arg0 : Self::R) -> (State, Self::R) {
let s = State::next(s, &[&arg0]);
let r = Self::R::make_qualified_name(&s,
```
<Overlap Ratio: 0.7453416149068323>

---

--- 281 --
Question ID: 1f50e7f1250bee8348568faf50ea5f0cf659fb4b_0
Original Code:
```
pub async fn hunt(ctx: &Context, msg: &Message, mut args: Args) -> CommandResult {
	// Get the guild ID.
	let guild = match msg.guild(&ctx.cache).await {
		Some(c) => c.id,
		None => {
			return confused(&ctx, &msg).await;
		},
	};

	let gs = {
		let data = ctx.data.read().await;
		Arc::clone(data.get::<GuildStates>().unwrap())
	};

	// Turn first arg (hopefully a channel mention) into a real channel
	voicehunt_control(
		&ctx,
		guild,
		match args.single::<u64>().ok() {
			Some(c) => {
				if let Some(state) = gs.get(&guild) {
					let mut lock = state.write().await;
					lock.set_join(Join::DirectedHunt(ChannelId(c))).await;
				}

				VoiceHuntCommand::DirectedHunt(ChannelId(c))
			},
			None => {
				if let Some(state) = gs.get(&guild) {
					let mut lock = state.write().await;
					lock.set_join(Join::Hunt).await;
				}

				VoiceHuntCommand::BraveHunt
			},
		},
	)
	.await;

	check_msg(msg.channel_id.say(&ctx.http, "Mrowr!").await);

	Ok(())
}
```


Overlapping Code:
```
t(ctx: &Context, msg: &Message, mut args: Args) -> CommandResult {
// Get the guild ID.
let guild = match msg.guild(&ctx.cache).await {
Some(c) => c.id,
None => {
return confused(&ctx, &msg).await;
},
};
let gs = {
let data = ctx.data.read().await;
Arc::clone(data.get::<GuildStates>().unwrap())
};
// Turn first arg (hopefully a channel mention) into a real channel
voicehunt_control(
&ctx,
guild,
match args.single::<u64>().ok() {
Some(c) => {
if let Some(state) = gs.get(&guild) {
let mut lock = state.write().await;
lock.set_join(Join::DirectedHunt(ChannelId(c))).await;
}
VoiceHuntCommand::DirectedHunt(ChannelId(c))
},
None => {
if let Some(state) = gs.get(&guild) {
let mut lock = state.write().await;
lock.set_join(Join::Hunt).await;
}
VoiceHuntCommand::BraveHunt
},
},
)
.await;
check_msg(msg.channel_i
```
<Overlap Ratio: 0.9321839080459771>

---

--- 282 --
Question ID: e9cd8cc8fcfeb87718edb509a63b4746f9bbbcf5_0
Original Code:
```
fn main() {
	println!("");
	println!("Enter it in the terminal !!");
	println!();
	println!("=====================");
	println!("cargo bench --example bench");
	println!("=====================");
}
```


Overlapping Code:
```
intln!("");
println!("Enter it in the terminal !!");
println!();
println!("=====================");
println!("cargo bench --example bench");
println!(
```
<Overlap Ratio: 0.7853403141361257>

---

--- 283 --
Question ID: 8438b4da320daa7bd880a52a633b27dbffeb7f6b_1
Original Code:
```
fn test_solc() {
        let executor = init_executor();

        // Test all_accounts
        let permission_management = PermissionManagement::new(&executor);
        let all_accounts: Vec<Address> = permission_management
            .all_accounts(BlockTag::Tag(Tag::Pending))
            .unwrap();

        assert_eq!(
            all_accounts,
            vec![
                Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap(),
                Address::from_str(reserved_addresses::GROUP).unwrap(),
            ]
        );

        // Test permissions
        let super_admin_address = Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap();

        let mut permissions: Vec<Address> = permission_management
            .permissions(
                &(H256::from(super_admin_address)),
                BlockTag::Tag(Tag::Pending),
            )
            .unwrap();
        permissions.sort();

        let mut expected_permissions = vec![
            Address::from_str(reserved_addresses::PERMISSION_NEW_PERMISSION).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_DELETE_PERMISSION).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_UPDATE_PERMISSION).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_SET_AUTH).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_CANCEL_AUTH).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_NEW_ROLE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_DELETE_ROLE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_UPDATE_ROLE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_SET_ROLE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_CANCEL_ROLE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_NEW_GROUP).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_DELETE_GROUP).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_UPDATE_GROUP).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_NEW_NODE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_DELETE_NODE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_UPDATE_NODE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_ACCOUNT_QUOTA).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_BLOCK_QUOTA).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_BATCH_TX).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_EMERGENCY_INTERVENTION).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_QUOTA_PRICE).unwrap(),
            Address::from_str(reserved_addresses::PERMISSION_VERSION).unwrap(),
        ];
        expected_permissions.sort();

        assert_eq!(permissions, expected_permissions);

        // Test account permissions
        let account_permissions: HashMap<Address, Vec<Resource>> =
            permission_management.load_account_permissions(BlockTag::Tag(Tag::Pending));
        assert_eq!(account_permissions.contains_key(&super_admin_address), true);

        let mut resources = (*account_permissions.get(&super_admin_address).unwrap()).clone();
        resources.sort();

        let mut expected_resources = vec![
            // newPermission
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(NEW_PERMISSION),
            },
            // deletePermission
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_PERMISSION),
            },
            // updatePermission
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(ADD_RESOURCES),
            },
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_RESOURCES),
            },
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(UPDATE_PERMISSIONNAME),
            },
            // setAuth
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_AUTHORIZATION),
            },
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_AUTHORIZATIONS),
            },
            // cancelAuth
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATION),
            },
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(CLEAR_AUTHORIZATION),
            },
            Resource {
                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATIONS),
            },
            // newRole
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(NEW_ROLE),
            },
            // deleteRole
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_ROLE),
            },
            // updateRole
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(ADD_PERMISSIONS),
            },
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_PERMISSIONS),
            },
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(UPDATE_ROLENAME),
            },
            // setRole
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_ROLE),
            },
            // cancelRole
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(CANCEL_ROLE),
            },
            Resource {
                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(CLEAR_ROLE),
            },
            // newGroup
            Resource {
                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(NEW_GROUP),
            },
            // deleteGroup
            Resource {
                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_GROUP),
            },
            // updateGroup
            Resource {
                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(ADD_ACCOUNTS),
            },
            Resource {
                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(DELETE_ACCOUNTS),
            },
            Resource {
                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(UPDATE_GROUPNAME),
            },
            // senTx
            Resource {
                cont: H160::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),
                func: vec![0, 0, 0, 0],
            },
            // createContract
            Resource {
                cont: H160::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),
                func: vec![0, 0, 0, 0],
            },
            // approveNode
            Resource {
                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(APPROVE_NODE),
            },
            // deleteNode
            Resource {
                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(DELETE_NODE),
            },
            // setStake
            Resource {
                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(SET_STAKE),
            },
            // defaultAQL
            Resource {
                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(SET_DEFAULTAQL),
            },
            // AQL
            Resource {
                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(SET_AQL),
            },
            // BQL
            Resource {
                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),
                func: method_tools::encode_to_vec(SET_BQL),
            },
            // batchTx
            Resource {
                cont: H160::from_str(reserved_addresses::BATCH_TX).unwrap(),
                func: method_tools::encode_to_vec(MULTI_TXS),
            },
            // emergencyIntervention
            Resource {
                cont: H160::from_str(reserved_addresses::EMERGENCY_INTERVENTION).unwrap(),
                func: method_tools::encode_to_vec(SET_STATE),
            },
            // quotaPrice
            Resource {
                cont: H160::from_str(reserved_addresses::PRICE_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_QUOTA_PRICE),
            },
            // setVersion(Will deprecated)
            Resource {
                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_VERSION),
            },
            // setProtocolVersion
            Resource {
                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),
                func: method_tools::encode_to_vec(SET_PROTOCOL_VERSION),
            },
        ];
        expected_resources.sort();

        assert_eq!(resources, expected_resources);
    }
```


Overlapping Code:
```
solc() {
let executor = init_executor();
// Test all_accounts
let permission_management = PermissionManagement::new(&executor);
let all_accounts: Vec<Address> = permission_management
.all_accounts(BlockTag::Tag(Tag::Pending))
.unwrap();
assert_eq!(
all_accounts,
vec![
Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap(),
Address::from_str(reserved_addresses::GROUP).unwrap(),
]
);
// Test permissions
let super_admin_address = Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap();
let mut permissions: Vec<Address> = permission_management
.permissions(
&(H256::from(super_admin_address)),
BlockTag::Tag(Tag::Pending),
)
.unwrap();
permissions.sort();
let mut expected_permissions = vec![
Address::from_str(reserved_addresses::PERMISSION_NEW_PERMISSION).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_DELETE_PERMISSION).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_UPDATE_PERMISSION).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_SET_AUTH).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_CANCEL_AUTH).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_NEW_ROLE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_DELETE_ROLE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_UPDATE_ROLE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_SET_ROLE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_CANCEL_ROLE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_NEW_GROUP).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_DELETE_GROUP).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_UPDATE_GROUP).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_NEW_NODE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_DELETE_NODE).unwrap(),
Address::from_str(reserved_addresses::PERMISSION_UPDATE_NODE).unwrap(),
Address::from_str(r
```
<Overlap Ratio: 0.9910802775024777>

---

--- 284 --
Question ID: 3140f68555fc3fe4de664a89b6fc66d189062d27_1
Original Code:
```
fn test_rate_limit_basic() {
        let mut core = Core::new().unwrap();
        let handle = core.handle();

        let (rl_sender, rl_receiver) = rate_limit_channel(5, 1, &handle);
        let source_stream = stream::iter_ok(0 .. 100u32);

        handle.spawn(
            source_stream.forward(rl_sender)
            .map_err(|_e: mpsc::SendError<u32>| ())
            .and_then(|_| Ok(()))
        );

        let mut res_vec = Vec::new();
        {
            let recv_future = rl_receiver.for_each(|item| {
                res_vec.push(item);
                Ok(())
            }); 
            core.run(recv_future).unwrap();
        }

        let expected_vec = (0 .. 100).collect::<Vec<u32>>();
        assert_eq!(res_vec, expected_vec);
    }
```


Overlapping Code:
```
_limit_basic() {
let mut core = Core::new().unwrap();
let handle = core.handle();
let (rl_sender, rl_receiver) = rate_limit_channel(5, 1, &handle);
let source_stream = stream::iter_ok(0 .. 100u32);
handle.spawn(
source_stream.forward(rl_sender)
.map_err(|_e: mpsc::SendError<u32>| ())
.and_then(|_| Ok(()))
);
let mut res_vec = Vec::new();
{
let recv_future = rl_receiver.for_each(|item| {
res_vec.push(item);
Ok(())
}); 
core.run(recv_future).unwrap();
}
let expected_vec = (0 .. 100).collect::<Vec<
```
<Overlap Ratio: 0.8976660682226212>

---

--- 285 --
Question ID: 75dd36fa694fd983b0edab7acdb1eac57405ff32_0
Original Code:
```
pub async fn create_user(
    data: NewUser,
    channel: tonic::transport::Channel,
) -> Result<User, GatewayError> {
    let mut client = UsersClient::new(channel);
    let request = tonic::Request::new(CreateUserRequest {
        username: data.username,
        password: data.password,
    });
    let response = client.create_user(request).await?.into_inner();
    Ok(response.user.unwrap().into())
}
```


Overlapping Code:
```
e_user(
data: NewUser,
channel: tonic::transport::Channel,
) -> Result<User, GatewayError> {
let mut client = UsersClient::new(channel);
let request = tonic::Request::new(CreateUserRequest {
username:onse = client.create_user(request).await?.into_inn
```
<Overlap Ratio: 0.6906077348066298>

---

--- 286 --
Question ID: 91c38625693e1daa59748c39e7988adfa088614d_0
Original Code:
```
fn main() {
    let mut machine = Machine::new();
    println!("{:?}", machine);
    
    machine.execute_instruction(&Instruction::NOP{});
    println!("{:?}", machine);

    machine.execute_instruction(&Instruction::ADD{
        source: Operand::Immediate(3),
        dest: Operand::Register(Register::ZERO)
    });
    println!("{:?}", machine);
}
```


Overlapping Code:
```
t mut machine = Machine::new();
println!("{:?}", machine);

machine.execute_instruction(&Instruction::NOP{});
println!("{:?}", machine);
machine.execute_instruction(&Instruction::ADD{
source: Operand::Immediate(3),
dest: Operand::Register(Register::Z
```
<Overlap Ratio: 0.8305647840531561>

---

--- 287 --
Question ID: 2cf05c9fa1c0f36fadf892b626e7a18bc381f371_8
Original Code:
```
pub fn concat_with_file_separator<S1: Into<String>, S2: AsRef<str>>(s1: S1, s2: S2) -> String {
    #[cfg(unix)]
    {
        crate::concat_with_slash(s1, s2)
    }

    #[cfg(windows)]
    {
        crate::concat_with_backslash(s1, s2)
    }
}
```


Overlapping Code:
```
_with_file_separator<S1: Into<String>, S2: AsRef<str>>(s1: S1, s2: S2) -> String {
#[cfg(unix)]
{
crate::concat_with_slash(s1, s2)
}
#[cfg(windows)]
{
```
<Overlap Ratio: 0.7352941176470589>

---

--- 288 --
Question ID: 300fab5baeffe749309470c739d4cf6d822f7522_1
Original Code:
```
pub fn do_report(settings: Settings) -> impl Future<Item = (), Error = Error> + Send {
    info!("Beginning report run");

    let report = Arc::new(Mutex::new(Report::new(format!("{}", settings.build_id()))));
    let timestamp = Utc::now().timestamp();

    // collect docker logs from all running containers
    let add_log_files = {
        let report = report.clone();
        let report_copy = report.clone();
        let settings_copy = settings.clone();
        get_module_logs(&settings)
            .and_then(move |module_logs| {
                info!("Fetched module logs.");

                // add each log as a file into the report
                for (container_name, logs) in module_logs {
                    report
                        .lock()
                        .unwrap()
                        .add_file(&format!("./{}.log", container_name), logs.as_bytes());
                }

                // write all the files in the report into blob storage
                info!("Compressing module logs");
                let buffer = Vec::new();
                let report = report.lock().unwrap();
                report.write_files(buffer.writer()).into_future()
            })
            .and_then(move |writer| {
                info!("Uploading module logs to blob storage");
                let buffer = writer.into_inner();
                let report_copy = report_copy.lock().unwrap();
                upload_file(
                    report_copy.id(),
                    &settings_copy,
                    &format!("{}/{}", timestamp, LOGS_FILE_NAME),
                    &buffer,
                )
            })
            .map(|_| info!("Module logs uploaded to blob storage"))
    };

    // collect report from analyzer module
    let get_analysis = {
        let report = report.clone();
        fetch_message_analysis(&settings).map(move |analysis| {
            info!("Got message analysis from analyzer");

            if let Some(analysis) = analysis {
                report.lock().unwrap().set_message_analysis(analysis);
            }
        })
    };

    // wait for all the bits to get done and then build report and alert
    let all_futures: Vec<Box<Future<Item = (), Error = Error> + Send>> =
        vec![Box::new(add_log_files), Box::new(get_analysis)];
    let report_copy = report.clone();
    future::join_all(all_futures)
        .and_then(move |_| {
            info!("Preparing report");
            let report = &mut *report_copy.lock().unwrap();
            debug!(
                "alert url: {:?}, report: {:?}",
                &settings.alert().url(),
                report
            );
            let report_id = report.id().to_string();
            report.add_attachment(
                LOGS_FILE_NAME,
                &format!(
                    "https://{}.blob.core.windows.net/{}/{}/{}",
                    settings.blob_storage_account(),
                    report_id,
                    timestamp,
                    LOGS_FILE_NAME
                ),
            );
            report.add_notes(format!(
                "Test report generated at: {}",
                Utc::now().to_rfc3339()
            ));

            info!("Serialize report to json");
            serde_json::to_value(report)
                .map_err(Error::from)
                .map(|report_json| Either::A(raise_alert(&settings, report_json)))
                .unwrap_or_else(|err| Either::B(future::err(err)))
        })
        .map(|_| info!("Report run complete"))
}
```


Overlapping Code:
```
do_report(settings: Settings) -> impl Future<Item = (), Error = Error> + Send {
info!("Beginning report run");
let report = Arc::new(Mutex::new(Report::new(format!("{}", settings.build_id()))));
let timestamp = Utc::now().timestamp();
// collect docker logs from all running containers
let add_log_files = {
let report = report.clone();
let report_copy = report.clone();
let settings_copy = settings.clone();
get_module_logs(&settings)
.and_then(move |module_logs| {
info!("Fetched module logs.");
// add each log as a file into the report
for (container_name, logs) in module_logs {
report
.lock()
.unwrap()
.add_file(&format!("./{}.log", container_name), logs.as_bytes());
}
// write all the files in the report into blob storage
info!("Compressing module logs");
let buffer = Vec::new();
let report = report.lock().unwrap();
report.write_files(buffer.writer()).into_future()
})
.and_then(move |writer| {
info!("Uploading module logs to blob storage");
let buffer = writer.into_inner();
let report_copy = report_copy.lock().unwrap();
upload_file(
report_copy.id(),
&settings_copy,
&format!("{}/{}", timestamp, LOGS_FILE_NAME),
&buffer,
)
})
.map(|_| info!("Module logs uploaded to blob storage"))
};
// collect report from analyzer module
let get_analysis = {
let report = report.clone();
fetch_message_analysis(&settings).map(move |analysis| {
info!("Got message analysis from analyzer");
if let Some(analysis) = analysis {
report.lock().unwrap().set_message_analysis(analysis);
}
})
};
// wait for all the bits to get done and then build report and alert
let all_futures: Vec<Box<Future<Item = (), Error = Error> + Send>> =
vec![Box::new(add_log_files), Box::new(get_analysis)];
let report_copy = report.clone();
future::join_all(all_futures)
.and_then(move |_| {
info!("Preparing report");
let r
```
<Overlap Ratio: 0.9803921568627451>

---

--- 289 --
Question ID: 7bf6a0cbb2541ae427e37193226a18baebb4fdaf_0
Original Code:
```
fn start_by_sending_rpc_to_known_peers() {
        let random_id = PeerId::random();
        let target = PeerId::random();

        let mut query = QueryState::new(QueryConfig {
            target,
            known_closest_peers: iter::once(random_id.clone()),
            parallelism: 3,
            num_results: 100,
            rpc_timeout: Duration::from_secs(10),
        });

        tokio::run(futures::future::poll_fn(move || {
            match try_ready!(Ok(query.poll())) {
                QueryStatePollOut::SendRpc { peer_id, .. } if peer_id == &random_id => {
                    Ok(Async::Ready(()))
                }
                _ => panic!(),
            }
        }));
    }
```


Overlapping Code:
```
n_peers() {
let random_id = PeerId::random();
let target = PeerId::random();
let mut query = QueryState::new(QueryConfig {
target,
known_closest_peers: iter::once(random_id.clone()),
parallelism: 3,
num_results: 100,
rpc_timeout: Duration::from_secs(10),
});
tokio::run(futures::future::poll_fn(move || {
match try_ready!(Ok(query.poll())) {
QueryStatePollOut::SendRpc { peer_id, .. } if peer_id == &random_id => {
Ok(Async::Ready(()))
}
_ => panic!(),
```
<Overlap Ratio: 0.9186991869918699>

---

--- 290 --
Question ID: 86e276cf73aeebbd84207b9fb5d96c9fb1160eb4_32
Original Code:
```
fn protover_all_supported_should_exclude_versions_we_actually_do_support_complex2() {
    let proto: UnvalidatedProtoEntry = "Link=1-3,5-12".parse().unwrap();
    let result: String = proto.all_supported().unwrap().to_string();

    assert_eq!(result, "Link=6-12".to_string());
}
```


Overlapping Code:
```
fn protover_all_supported_should_exclude_versions_we_actually_do_support_complex2() {
let proto: UnvalidatedProtoEntry = "Link=1-3,5-12".parse().unwrap();
let result: String = proto.all_supported().unwrap().to_string();
assert_eq!(result, "Link=
```
<Overlap Ratio: 0.9210526315789473>

---

--- 291 --
Question ID: b182c96428d3cea258dfcf413950acc17aed17e0_2
Original Code:
```
fn no_digits() {
        let input = "verify\nthis";
        let expected = "    verify\n    this";
        let mut output = String::new();

        Indented {
            inner: &mut output,
            ind: None,
            started: false,
        }
        .write_str(input)
        .unwrap();

        assert_eq!(expected, output);
    }
```


Overlapping Code:
```
fn no_digits() {
let input = "verify\nthis";
let expected = " verify\n this";
let mut output = String::new();
Indented {
inner: &mut output,
ind: None,
started: false,
}
.write_str(input)
.unwrap();
assert_eq!(expected,
```
<Overlap Ratio: 0.9521739130434783>

---

--- 292 --
Question ID: e66322ea0c5706d174a77c18be0da46364ad01c8_2
Original Code:
```
pub unsafe extern "C" fn xwm_handle_selection_event(mut xwm: *mut wlr_xwm,
                                                    mut event:
                                                        *mut xcb_generic_event_t)
 -> libc::c_int {
    if (*xwm).seat.is_null() {
        _wlr_log(WLR_DEBUG,
                 b"[%s:%d] not handling selection events: no seat assigned to xwayland\x00"
                     as *const u8 as *const libc::c_char,
                 b"../xwayland/selection/selection.c\x00" as *const u8 as
                     *const libc::c_char, 118i32);
        return 0i32
    }
    match (*event).response_type as libc::c_int & 0x7fi32 {
        31 => {
            xwm_handle_selection_notify(xwm,
                                        event as
                                            *mut xcb_selection_notify_event_t);
            return 1i32
        }
        28 => {
            return xwm_handle_selection_property_notify(xwm,
                                                        event as
                                                            *mut xcb_property_notify_event_t)
        }
        30 => {
            xwm_handle_selection_request(xwm,
                                         event as
                                             *mut xcb_selection_request_event_t);
            return 1i32
        }
        _ => { }
    }
    match (*event).response_type as libc::c_int -
              (*(*xwm).xfixes).first_event as libc::c_int {
        0 => {
            // an X11 window has copied something to the clipboard
            return xwm_handle_xfixes_selection_notify(xwm,
                                                      event as
                                                          *mut xcb_xfixes_selection_notify_event_t)
        }
        _ => { }
    }
    return 0i32;
}
```


Overlapping Code:
```
extern "C" fn xwm_handle_selection_event(mut xwm: *mut wlr_xwm,
mut event:
*mut xcb_generic_event_t)
-> libc::c_int {
if (*xwm).seat.is_null() {
_wlr_log(WLR_DEBUG,
b"[%s:%d] not handling selection events: no seat assigned to xwayland\x00"
as *const u8 as *const libc::c_char,
b"../xwayland/selection/selection.c\x00" as *const u8 as
*const libc::c_char, 118i32);
return 0i32
}
match (*event).response_type as libc::c_int & 0x7fi32 {
31 => {
xwm_handle_selection_notify(xwm,
event as
*mut xcb_selection_notify_event_t);
return 1i32
}
28 => {
return xwm_handle_selection_property_notify(xwm,
event as
*mut xcb_property_notify_event_t)
}
30 => {
xwm_handle_selection_request(xwm,
event as
*mut xcb_selection_request_event_t);
return 1i32
}
_ => { }
}
match (*event).response_type as libc::c_int -
(*(*xwm).xfixes).first_event as libc::c_int {
0 => {
// an X11 window has copied something to the clipboard
return xwm_handle_xfixes_selection_notify(xwm,
event as
*mut xcb_xfixes_selection_notify_event_t)
```
<Overlap Ratio: 0.9624639076034649>

---

--- 293 --
Question ID: 9b41b9d444481b80f15c61050cd7267d0b972dba_9
Original Code:
```
fn _to_db_passwd(plain_password: String, salt: i32) -> Blake2bResult {
	 let salted_pwd = plain_password + &salt.to_string();
	 let res = blake2b(64, &[], salted_pwd.as_bytes());
	 return res;
}
```


Overlapping Code:
```
_passwd(plain_password: String, salt: i32) -> Blak&salt.to_string();
let res = blake2b(64, &[], salt
```
<Overlap Ratio: 0.5319148936170213>

---

--- 294 --
Question ID: 5cebbf5a247289a67b185006a954d337d4a18fd4_7
Original Code:
```
fn it_strips_comments() {
        assert_eq!(
            strip_comment(String::from("Foobar")),
            String::from("Foobar"),
        );

        assert_eq!(strip_comment(String::from("Foo#bar")), String::from("Foo"),);

        assert_eq!(
            strip_comment(String::from(" Complicated # oh yes!! # another one")),
            String::from("Complicated"),
        );

        assert_eq!(
            strip_comment(String::from("# Just a comment")),
            String::from(""),
        );

        assert_eq!(
            strip_comment(String::from("  \t# Just a comment")),
            String::from(""),
        );
    }
```


Overlapping Code:
```
omment(String::from("Foobar")),
String::from("Foobar"),
);
assert_eq!(strip_comment(String::from("Foo#bar")), String::from("Foo"),);
assert_eq!(
strip_comment(String::from(" Complicated # oh yes!! # another one")),
String::from("Complicated"),
);
assert_eq!(
strip_comment(String::from("# Just a comment")),
String::from(""),
);
assert_eq!(
strip_comment(String::from(" \t# Just a comment")),
String:
```
<Overlap Ratio: 0.8695652173913043>

---

--- 295 --
Question ID: 7e531c3bdea1ac61d9c878887639024900ad84fb_0
Original Code:
```
fn main() {
    pretty_env_logger::init().unwrap();

    let url = match env::args().nth(1) {
        Some(url) => url,
        None => {
            println!("Usage: client <url>");
            return;
        }
    };

    infinite_request(url)
}
```


Overlapping Code:
```
fn main() {
pretty_env_logger::init().unwrap();
let url = match env::args().nth(1) {
Some(url) => url,
None => {
println!("Usage: client <url>");
return;
}
};
```
<Overlap Ratio: 0.8681318681318682>

---

--- 296 --
Question ID: b27f4ea621e611566b5fbb0e8bbcce089ef8c7a2_2
Original Code:
```
fn format_dft_counterclockwise(omega: i64, n: i64) -> String {
    let has_halves = 0 == n % 2;
    let has_quarters = 0 == n % 4;

    let i = n / 4;
    let neg_one = n / 2;
    let neg_i = 3 * n / 4;

    let q2 = i..neg_one;
    let q3 = neg_one..neg_i;
    let q4 = neg_i..n;

    if omega == 0 { " 1".to_string() }
    else if has_quarters && omega == i          { " i".to_string() }
    else if has_halves   && omega == neg_one    { "-1".to_string() } 
    else if has_quarters && omega == neg_i      { "-i".to_string() }
    else if has_quarters && q2.contains(&omega) { format_omega(" i", omega - i)       }
    else if has_halves   && q3.contains(&omega) { format_omega(" -", omega - neg_one) }
    else if has_quarters && q4.contains(&omega) { format_omega("-i", omega - neg_i)   }
    else { format_omega("", omega) }
}
```


Overlapping Code:
```
ise(omega: i64, n: i64) -> String {
let has_halves = 0 == n % 2;
let has_quarters = 0 == n % 4;
let i = n / 4;
let neg_one = n / 2;
let neg_i = 3 * n / 4;
let q2 = i..neg_one;
let q3 = neg_one..neg_i;
let q4 = neg_i..n;
if omega == 0 { " 1".to_string() }
else if has_quarters && omega == i { " i".to_string() }
else if has_halves && omega == neg_one { "-1".to_string() } 
else if has_quarters && omega == neg_i { "-i".to_string() }
else if has_quarters && q2.contains(&omega) { format_omega(" i", omega - i) }
else if has_halves && q3.contains(&omega) { format_omega(" -", omega - neg_one) }
else if has_quarters && q4.contains(&omega) { format_omega("-i", omega - neg_i) }
else { format_omega("", om
```
<Overlap Ratio: 0.9523809523809523>

---

--- 297 --
Question ID: 347963d1618b9b928197154aec004580113b30f7_31
Original Code:
```
fn two_variables_for_two_froms() {
    let mut p = Parser::new(
        r#"howdy = from()
			doody = from()
			howdy|>count()
			doody|>sum()"#,
    );
    let parsed = p.parse_file("".to_string());
    assert_eq!(
        parsed,
        File {
            base: BaseNode { errors: vec![] },
            name: "".to_string(),
            package: None,
            imports: vec![],
            body: vec![
                Var(VariableAssignment {
                    base: BaseNode { errors: vec![] },
                    id: Identifier {
                        base: BaseNode { errors: vec![] },
                        name: "howdy".to_string()
                    },
                    init: Call(Box::new(CallExpression {
                        base: BaseNode { errors: vec![] },
                        arguments: vec![],
                        callee: Idt(Identifier {
                            base: BaseNode { errors: vec![] },
                            name: "from".to_string()
                        })
                    })),
                }),
                Var(VariableAssignment {
                    base: BaseNode { errors: vec![] },
                    id: Identifier {
                        base: BaseNode { errors: vec![] },
                        name: "doody".to_string()
                    },
                    init: Call(Box::new(CallExpression {
                        base: BaseNode { errors: vec![] },
                        arguments: vec![],
                        callee: Idt(Identifier {
                            base: BaseNode { errors: vec![] },
                            name: "from".to_string()
                        })
                    })),
                }),
                Expr(ExpressionStatement {
                    base: BaseNode { errors: vec![] },
                    expression: Pipe(Box::new(PipeExpression {
                        base: BaseNode { errors: vec![] },
                        argument: Idt(Identifier {
                            base: BaseNode { errors: vec![] },
                            name: "howdy".to_string()
                        }),
                        call: CallExpression {
                            base: BaseNode { errors: vec![] },
                            callee: Idt(Identifier {
                                base: BaseNode { errors: vec![] },
                                name: "count".to_string()
                            }),
                            arguments: vec![]
                        }
                    }))
                }),
                Expr(ExpressionStatement {
                    base: BaseNode { errors: vec![] },
                    expression: Pipe(Box::new(PipeExpression {
                        base: BaseNode { errors: vec![] },
                        argument: Idt(Identifier {
                            base: BaseNode { errors: vec![] },
                            name: "doody".to_string()
                        }),
                        call: CallExpression {
                            base: BaseNode { errors: vec![] },
                            callee: Idt(Identifier {
                                base: BaseNode { errors: vec![] },
                                name: "sum".to_string()
                            }),
                            arguments: vec![]
                        }
                    }))
                })
            ]
        },
    )
}
```


Overlapping Code:
```
two_variables_for_two_froms() {
let mut p = Parser::new(
r#"howdy = from()
doody = from()
howdy|>count()
doody|>sum()"#,
);
let parsed = p.parse_file("".to_string());
assert_eq!(
parsed,
File {
base: BaseNode { errors: vec![] },
name: "".to_string(),
package: None,
imports: vec![],
body: vec![
Var(VariableAssignment {
base: BaseNode { errors: vec![] },
id: Identifier {
base: BaseNode { errors: vec![] },
name: "howdy".to_string()
},
init: Call(Box::new(CallExpression {
base: BaseNode { errors: vec![] },
arguments: vec![],
callee: Idt(Identifier {
base: BaseNode { errors: vec![] },
name: "from".to_string()
})
})),
}),
Var(VariableAssignment {
base: BaseNode { errors: vec![] },
id: Identifier {
base: BaseNode { errors: vec![] },
name: "doody".to_string()
},
init: Call(Box::new(CallExpression {
base: BaseNode { errors: vec![] },
arguments: vec![],
callee: Idt(Identifier {
base: BaseNode { errors: vec![] },
name: "from".to_string()
})
})),
}),
Expr(ExpressionStatement {
base: BaseNode { errors: vec![] },
expression: Pipe(Box::new(PipeExpression {
base: BaseNode { errors: vec![] },
argument: Idt(Identifier {
base: BaseNode { errors: vec![] },
name: "howdy".to_string()
}),
call: CallExpression {
base: BaseNode { errors: vec![] },
callee: Idt(Identifier {
base: BaseNode { errors: vec![] },
name: "count".to_string()
})
```
<Overlap Ratio: 0.9918032786885246>

---

--- 298 --
Question ID: c8d111cdabacd5de9555b2f36a8e04a6c22c5c99_0
Original Code:
```
pub fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("common.rs");
    let mut fout = File::create(&dest_path).unwrap();

    let src_dir = env::current_dir().unwrap();
    let msg_dr = src_dir.join("msg");

    let mut parso = parser::Parser::new();
    let _res = parso.process_msg_directory(&msg_dr, &mut fout);

    println!("output path: {:?}", dest_path);

    //TODO verify this works if we add new files OR updated files
    println!("cargo:rerun-if-changed=msg/");
}
```


Overlapping Code:
```
 fn main() {
let out_dir = env::var("OUT_DIR").unwrap();
let dest_path = Path::new(&out_dir).join("common.rs");
let mut fout = File::create(&dest_path).unwrap();
let src_dir = env::current_dir().unwrap();
let msg_dr = src_dir.join("msg");
let mut parso = parser::Parser::new();
let _res = parso.process_msg_directory(&msg_dr, &mut fout);
println!("output path: {:?}", dest_path);
//TODO verify this works if we add new files OR updated files
println!("cargo:rerun-if-changed=msg
```
<Overlap Ratio: 0.9815195071868583>

---

--- 299 --
Question ID: 3deac005077f7c70c346c676b2f9596a2b4440d9_18
Original Code:
```
fn difference_with_a_lhs_json_value() {
        let expected = expected_values(
            r#"SELECT "users".* FROM "users" WHERE $1 <> "jsonField"::jsonb"#,
            vec![serde_json::json!({"a": "b"})],
        );

        let value_expr: Expression = Value::json(serde_json::json!({"a":"b"})).into();
        let query = Select::from_table("users").so_that(value_expr.not_equals(Column::from("jsonField")));
        let (sql, params) = Postgres::build(query).unwrap();

        assert_eq!(expected.0, sql);
        assert_eq!(expected.1, params);
    }
```


Overlapping Code:
```
n difference_with_a_lhs_json_value() {
let expected = expected_values(
r#"SELECT "users".* FROM "users" WHERE $1 <> "jsonField"::jsonb"#,
vec![serde_json::json!({"a": "b"})],
);
let value_expr: Expression = Value::json(serde_json::json!({"a":"b"})).into();
let query = Select::from_table("users").so_that(value_expr.not_equals(Column::from("jsonField")));
let (sql, params) = Postgres::build(query).unwrap();
assert_eq!(expected.0, sql);
assert_eq!(expected.1, params);
}
```
<Overlap Ratio: 0.9978813559322034>

---

--- 300 --
Question ID: 0290ddf9aafc22c2dc4b8339bd5b722287a7f25c_3
Original Code:
```
fn small_example() {
        let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];
        let numbers = calculate_next_phase(numbers);
        assert_eq!(vec![4, 8, 2, 2, 6, 1, 5, 8], numbers);

        let numbers = calculate_next_phase(numbers);
        assert_eq!(vec![3, 4, 0, 4, 0, 4, 3, 8], numbers);

        let numbers = calculate_next_phase(numbers);
        assert_eq!(vec![0, 3, 4, 1, 5, 5, 1, 8], numbers);

        let numbers = calculate_next_phase(numbers);
        assert_eq!(vec![0, 1, 0, 2, 9, 4, 9, 8], numbers);
    }
```


Overlapping Code:
```
 small_example() {
let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];
let numbers = calculate_next_phase(numbers);
assert_eq!(vec![4, 8, 2, 2, 6, 1, 5, 8], numbers);
let numbers = calculate_next_phase(numbers);
assert_eq!(vec![3, 4, 0, 4, 0, 4, 3, 8], numbers);
let numbers = calculate_next_phase(numbers);
assert_eq!(vec![0, 3, 4, 1, 5, 5, 1, 8], numbers);
let numbers = calculate_next_phase(numbers);
asse
```
<Overlap Ratio: 0.8888888888888888>

---

--- 301 --
Question ID: 41445f7e7713b22a4f3c28baea17f96cd2e21df7_8
Original Code:
```
fn test_tx_persist_cooldown_refresh() {
		let mut machine = TimedMachine::new(TestState::A);
		let cd = Cooldown::new(Duration::from_secs(200).into(), false, false);

		machine
			.add_priority_transition(TestState::A, TestState::B, TestAlpha::A, 1, Some(cd))
			.add_transition(TestState::A, TestState::C, TestAlpha::A);

		let s1 = machine.advance(TestAlpha::A);
		machine.refresh();

		assert_eq!(s1, Some(TestState::B));
		assert_eq!(machine.advance(TestAlpha::A), Some(TestState::C));
	}
```


Overlapping Code:
```
down_refresh() {
let mut machine = TimedMachine::new(TestState::A);
let cd = Cooldown::new(Duration::from_secs(200).into(), false, false);
machine
.add_priority_transition(TestState::A, TestState::B, TestAlpha::A, 1, Some(cd))
.add_transition(TestState::A, TestState::C, TestAlpha::A);
let s1 = machine.advance(TestAlpha::A);
machine.refresh();
assert_eq!(s1, Some(TestState::B));
assert_eq!(machine.
```
<Overlap Ratio: 0.8547008547008547>

---

--- 302 --
Question ID: 2020ce2c4691d5730c8c919047a729dcab5da224_1
Original Code:
```
async fn happy_path() {
    let conn_pool = crate::db::ConnectionPool::new();
    let session = conn_pool.start_session();

    let user = session.create_user(UserBuilder::default().password("dummy password"));
    let records = session.create_records2(user.id, 1);

    let query = UpdateRecord {
        amount: BigDecimal::from(10.0),
        amount_currency: "CAD".into(),
        tags: vec![],
        transaction_type: "INC".into(),
        user_id: user.id.into(),
        id: records[0].id,
        comment: "".into(),
    };

    let res = conn_pool.execute(query).await;

    assert!(res.is_ok(), "result is not Ok, {:?}", res);
    assert_eq!((), res.unwrap());
}
```


Overlapping Code:
```
n happy_path() {
let conn_pool = crate::db::ConnectionPool::new();
let session = conn_pool.start_session();
let user = session.create_user(UserBuilder::default(). session.create_records2(user.id, 1);
let query = UpdateRecord {
amount: BigDecimal::from(10.0),
amount_currency: "CAD".into(),
tags: vec![],
transaction_type: "INC".into(),
user_id: user.id.into(),
id: records[0].id,
comment: "".into(),
};
let res = conn_pool.execute(query).await;
assert!(res.is_ok(), "result is not Ok, {:?}", res);
assert_eq!((),
```
<Overlap Ratio: 0.8858131487889274>

---

--- 303 --
Question ID: d353aab467ce9d2579c72ac83df3bff28b8029c3_3
Original Code:
```
fn encode_works() {
        let bytes = TEST_BYTES;
        let encoded = Key::from(bytes).encode();
        assert_eq!(encoded, bytes);
    }
```


Overlapping Code:
```
encode_works() {
let bytes = TEST_BYTES;
let encoded = Key::from(bytes).encode();
assert_eq!(encoded
```
<Overlap Ratio: 0.8771929824561403>

---

--- 304 --
Question ID: af2e026e82ee3123ac95af923430a05f9022694c_1
Original Code:
```
fn scan_cf<F>(
        &self,
        cf: &str,
        start_key: &[u8],
        end_key: &[u8],
        fill_cache: bool,
        f: F,
    ) -> Result<()>
    where
        F: FnMut(&[u8], &[u8]) -> Result<bool>,
    {
        let start = KeyBuilder::from_slice(start_key, DATA_KEY_PREFIX_LEN, 0);
        let end = KeyBuilder::from_slice(end_key, DATA_KEY_PREFIX_LEN, 0);
        let iter_opt = IterOption::new(Some(start), Some(end), fill_cache);
        scan_impl(self.new_iterator_cf(cf, iter_opt)?, start_key, f)
    }
```


Overlapping Code:
```
scan_cf<F>(
&self,
cf: &str,
start_key: &[u8],
end_key: &[u8],
fill_cache: bool,
f: F,
) -> Result<()>
where
F: FnMut(&[u8], &[u8]) -> Result<bool>,
{
let start = KeyBuilder::from_slice(start_key, DATA_KEY_PREFIX_LEN, 0);
let end = KeyBuilder::from_slice(end_key, DATA_KEY_PREFIX_LEN, 0);
let iter_opt = IterOption::new(Some(start), Some(end), fill_cache);
scan_impl(self.new_iterator_cf(cf, iter_opt)?, star
```
<Overlap Ratio: 0.966824644549763>

---

--- 305 --
Question ID: 6ecb0a9b415432be05860208284480440e5203c2_3
Original Code:
```
fn make_phf<I, K>(s: I, ident: Ident) -> proc_macro2::TokenStream
where
    K: AsRef<[u8]>,
    I: ExactSizeIterator<Item = (usize, K)> + Clone,
{
    let phf = internal::Hash::generate(s);

    let name_phf = Ident::new(&format!("{}_derive_phf", ident), ident.span());
    let phf_static = Ident::new(
        &format!("{}_derive_phf", ident).TO_SHOUTY_SNEK_CASE(),
        ident.span(),
    );

    let (left_len, left) = (phf.left.len(), phf.left);
    let (right_len, right) = (phf.right.len(), phf.right);
    let (graph_len, graph) = (phf.graph.len(), phf.graph);

    quote! {
        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        struct #name_phf {
            left: [u8; #left_len],
            right: [u8; #right_len],
            graph: [u8; #graph_len],
        }

        use PerfectHash as _;
        impl PerfectHash for #name_phf {
            fn left(&self) -> &[u8] { &self.left }
            fn right(&self) -> &[u8] { &self.right }
            fn graph(&self) -> &[u8] { &self.graph }
        }

        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        static #phf_static: #name_phf = #name_phf {
            left: [#(#left,)*],
            right: [#(#right,)*],
            graph: [#(#graph,)*],
        };
    }
}
```


Overlapping Code:
```
t: Ident) -> proc_macro2::TokenStream
where
K: AsRef<[u8]>,
I: ExactSizeIterator<Item = (usize, K)> + Clone,
{
let phf = internal::Hash::generate(s);
let name_phf = Ident::new(&format!("{}_derive_phf", ident), ident.span());
let phf_static = Ident::new(
&format!("{}_derive_phf", ident).TO_SHOUTY_SNEK_CASE(),
ident.span(),
);
let (left_len, left) = (phf.left.len(), phf.left);
let (right_len, right) = (phf.right.len(), phf.right);
let (graph_len, graph) = (phf.graph.len(), phf.graph);
quote! {
#[doc(hidden)]
#[allow(non_camel_case_types)]
struct #name_phf {
left: [u8; #left_len],
right: [u8; #right_len],
graph: [u8; #graph_len],
}
use PerfectHash as _;
impl PerfectHash for #name_phf {
fn left(&self) -> &[u8] { &self.left }
fn right(&self) -> &[u8] { &self.right }
fn graph(&self) -> &[u8] { &self.graph }
}
#[doc(hidden)]
#[allow(non_camel_case_types)]
static #phf_static: #name_phf = #name_phf {
left: [#(#left,)*],
right: [#(#right,)*],
gra
```
<Overlap Ratio: 0.9471585244267199>

---

--- 306 --
Question ID: 2689e05a0a702b59b9509a058be334d8a8302bc3_3
Original Code:
```
pub fn gen_mr_builder_types(grammar: &structs::Grammar) -> String {
    let kinds = &grammar.operand_kinds;
    // Generate build methods for all types.
    let elements: Vec<String> = grammar.instructions.iter().filter(|inst| {
        inst.class == "Type" && inst.opname != "OpTypeForwardPointer" &&
            inst.opname != "OpTypePointer" && inst.opname != "OpTypeOpaque"
    }).map(|inst| {
        // Parameter list for this build method.
        let (param_list, type_generics) = get_param_list(&inst.operands, false, kinds);
        // Initializer list for constructing the operands parameter
        // for Instruction.
        let init_list = get_init_list(&inst.operands[1..]).join(", ");
        // Parameters that are not single values thus need special treatment.
        let extras = get_push_extras(&inst.operands[1..],
                                     kinds,
                                     "self.module.types_global_values.last_mut()\
                                     .expect(\"interal error\").operands").join(";\n");
        format!("{s:4}/// Appends an Op{opcode} instruction and returns the result id.\n\
                 {s:4}pub fn {name}{generic}(&mut self{sep}{param}) -> spirv::Word {{\n\
                 {s:8}let id = self.id();\n\
                 {s:8}self.module.types_global_values.push(\
                     mr::Instruction::new(spirv::Op::{opcode}, \
                     None, Some(id), vec![{init}]));\n\
                 {extras}{x}\
                 {s:8}id\n\
                 {s:4}}}",
                s = "",
                sep = if param_list.len() != 0 { ", " } else { "" },
                opcode = &inst.opname[2..],
                name = snake_casify(&inst.opname[2..]),
                generic = type_generics,
                param = param_list,
                init = init_list,
                extras = extras,
                x = if extras.len() != 0 { ";\n" } else { "" })
    }).collect();
    format!("impl Builder {{\n{}\n}}", elements.join("\n\n"))
}
```


Overlapping Code:
```
ammar: &structs::Grammar) -> String {
let kinds = &grammar.operand_kinds;
// Generate build methods for all types.
let elements: Vec<String> = grammar.instructions.iter().filter(|inst| {
inst.class == "Type" && inst.opname != "OpTypeForwardPointer" &&
inst.opname != "OpTypePointer" && inst.opname != "OpTypeOpaque"
}).map(|inst| {
// Parameter list for this build method.
let (param_list, type_generics) = get_param_list(&inst.operands, false, kinds);
// Initializer list for constructing the operands parameter
// for Instruction.
let init_list = get_init_list(&inst.operands[1..]).join(", ");
// Parameters that are not single values thus need special treatment.
let extras = get_push_extras(&inst.operands[1..],
kinds,
"self.module.types_global_values.last_mut()\
.expect(\"interal error\").operands").join(";\n");
format!("{s:4}/// Appends an Op{opcode} instruction and returns the result id.\n\
{s:4}pub fn {name}{generic}(&mut self{sep}{param}) -> spirv::Word {{\n\
{s:8}let id = self.id();\n\
{s:8}self.module.types_global_values.push(\
mr::Instruction::new(spirv::Op::{opcode}, \
None, Some(id), vec![{init}]));\n\
{extras}{x}\
{s:8}id\n\
{s:4}}}",
s = "",
sep = if param_list.len() != 0 { ", " } else { "" },
opcode = &inst.opname[2..],
name = snake_casify(&inst.opname[2..]),
generic = type_generics,
param = param_list,
init = init_list,
extras = extras,
x = if extras.len() != 0 { ";\n" } else { "" })
}).collect();
format!("impl Builder {{\n{}\n}}", elements.join("\n\n"))
```
<Overlap Ratio: 0.9789196310935442>

---

--- 307 --
Question ID: 9b9e9f65e1cf531c72ddcaf1ded2a4d1a6bce82e_0
Original Code:
```
fn main() {
    #[cfg(not(target_os = "wasi"))]
    let mut base = PathBuf::from("wasitests/test_fs/hamlet");
    #[cfg(target_os = "wasi")]
    let mut base = PathBuf::from(".");

    base.push("act1/scene3.txt");

    let mut file = fs::File::open(&base).expect("Could not open file");

    let mut buffer = [0u8; 32];

    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);

    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);

    assert_eq!(file.seek(SeekFrom::Start(123)).unwrap(), 123);
    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);

    assert_eq!(file.seek(SeekFrom::End(-123)).unwrap(), 6617);
    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);

    assert_eq!(file.seek(SeekFrom::Current(-250)).unwrap(), 6399);
    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);

    assert_eq!(file.seek(SeekFrom::Current(50)).unwrap(), 6481);
    assert_eq!(file.read(&mut buffer).unwrap(), 32);
    let str_val = std::str::from_utf8(&buffer[..]).unwrap();
    println!("{}", str_val);
}
```


Overlapping Code:
```
n main() {
#[cfg(not(target_os = "wasi"))]
let mut base = PathBuf::from("wasitests/test_fs/hamlet");
#[cfg(target_os = "wasi")]
let mut base = PathBuf::from(".");
base.push("act1/scene3.txt");
let mut file = fs::File::open(&base).expect("Could not open file");
let mut buffer = [0u8; 32];
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val);
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val);
assert_eq!(file.seek(SeekFrom::Start(123)).unwrap(), 123);
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val);
assert_eq!(file.seek(SeekFrom::End(-123)).unwrap(), 6617);
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val);
assert_eq!(file.seek(SeekFrom::Current(-250)).unwrap(), 6399);
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val);
assert_eq!(file.seek(SeekFrom::Current(50)).unwrap(), 6481);
assert_eq!(file.read(&mut buffer).unwrap(), 32);
let str_val = std::str::from_utf8(&buffer[..]).unwrap();
println!("{}", str_val
```
<Overlap Ratio: 0.9962092494313874>

---

--- 308 --
Question ID: 67c57f38931704a9fbeca6791665a83f9eadfa4a_2
Original Code:
```
fn setup_watch_test() {
        setup();

        let cfg = test_config();
        let (tx, rx) = channel();

        // Launch write_to_file after 1 second delay
        thread::spawn(|| {
            thread::sleep(Duration::from_secs(1));
            write_to_file();
        });

        // The shutdown task after a 3 second delay
        thread::spawn(move || {
            thread::sleep(Duration::from_secs(3));
            tx.send(true).unwrap();
        });

        // Start the watch
        setup_watch(rx, cfg);
        assert!(path::Path::new(GEN_FILE).exists());

        teardown();
    }
```


Overlapping Code:
```
setup();
let cfg = test_config();
let (tx, rx) = channel();
// Launch write_to_file after 1 second delay
thread::spawn(|| {
thread::sleep(Duration::from_secs(1));
write_to_file();
});
// The shutdown task after a 3 second delay
thread::spawn(move || {
thread::sleep(Duration::from_secs(3));
tx.send(true).unwrap();
});
// Start the watch
setup_watch(rx, cfg);
assert!(path::Path::new(GEN_FILE).exists
```
<Overlap Ratio: 0.9049773755656109>

---

--- 309 --
Question ID: 8dfe4a1dd336f402669a8a09515a1398934f5b0e_4
Original Code:
```
fn challenge5() -> errors::Result<()> {
  let expected = from_hex_string("0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f")?;

  let input_string = b"Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal";
  let key = b"ICE";
  let actual = encrypt_repeating_key(input_string, key);

  println!("expected : {}", to_hex_string(&expected));
  println!("actual   : {}", to_hex_string(&actual));

  assert_eq!(expected, actual);

  Ok(())
}
```


Overlapping Code:
```
() -> errors::Result<()> {
let expected = from_hex_string("0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f")?;
let input_string = b"Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal";
let key = b"ICE";
let actual = encrypt_repeating_key(input_string, key);
println!("expected : {}", to_hex_string(&expected));
println!("actual : {}", to_hex_string(&actual));
assert_eq!(exp
```
<Overlap Ratio: 0.931098696461825>

---

--- 310 --
Question ID: c4d4de40d0b7e2bd6b1ad76079cf70286537b751_1
Original Code:
```
fn test_lastcache() {
        let mut lc = LastCache::new(10);
        for i in 0 .. 10 {
            lc.push(1);
        }
        assert_eq!(lc.iter().all(|i| *i == 1), true);
        lc.push(2);
        lc.push(2);
        let mut i = 0;
        for item in &lc {
            if i == 0 || i == 1 {
                assert_eq!(*item, 2);
            } else {
                assert_eq!(*item, 1);
            }
            i += 1;
        }
    }
```


Overlapping Code:
```
lastcache() {
let mut lc = LastCache::new(10);
for i in 0 .. 10 {
lc.push(1);
}
assert_eq!(lc.iter().all(|i| *i == 1), true);
lc.push(2);
lc.push(2);
let mut i = 0;
for item in &lc {
if i == 0 || i == 1 {
assert_eq!(*item, 2);
} else {
assert_eq!(*it
```
<Overlap Ratio: 0.8960573476702509>

---

--- 311 --
Question ID: 4961bda800c51f4d13c02881316f0ad045dba647_13
Original Code:
```
fn foreign_keys_nested_alias() {
        let columns = vec![
            "id".to_string(),
            "parent_id.company_id.name AS parent_company".to_string(),
        ];
        let fks = [ForeignKeyReference {
            original_refs: vec!["parent_id.company_id.name".to_string()],
            referring_table: "child".to_string(),
            referring_column: "parent_id".to_string(),
            referring_column_type: "int8",
            foreign_key_table: "adult".to_string(),
            foreign_key_table_stats: vec![],
            foreign_key_column: "id".to_string(),
            foreign_key_column_type: "int8",
            nested_fks: vec![ForeignKeyReference {
                original_refs: vec!["company_id.name".to_string()],
                referring_table: "adult".to_string(),
                referring_column: "company_id".to_string(),
                referring_column_type: "int8",
                foreign_key_table: "company".to_string(),
                foreign_key_table_stats: vec![],
                foreign_key_column: "id".to_string(),
                foreign_key_column_type: "int8",
                nested_fks: vec![],
            }],
        }];
        let table = "child";

        let column_str = get_columns_str(&columns, table, &fks).unwrap().join("");
        assert_eq!(
            column_str,
            r#"child.id AS "id", company.name AS "parent_company""#
        );
    }
```


Overlapping Code:
```
lumns = vec![
"id".to_string(),
"parent_id.company_id.name AS parent_company".to_string(),
];
let fks = [ForeignKeyReference {
original_refs: vec!["parent_id.company_id.name".to_string()],
referring_table: "child".to_string(),
referring_column: "parent_id".to_string(),
referring_column_type: "int8",
foreign_key_table: "adult".to_string(),
foreign_key_table_stats: vec![],
foreign_key_column: "id".to_string(),
foreign_key_column_type: "int8",
nested_fks: vec![ForeignKeyReference {
original_refs: vec!["company_id.name".to_string()],
referring_table: "adult".to_string(),
referring_column: "company_id".to_string(),
referring_column_type: "int8",
foreign_key_table: "company".to_string(),
foreign_key_table_stats: vec![],
foreign_key_column: "id".to_string(),
foreign_key_column_type: "int8",
nested_fks: vec![],
}],
}];
let table = "child";
let column_str = get_columns_str(&columns, table, &fks).unwrap().join("");
assert_eq!(
column_str,
r#"child.id AS "id", company.name AS "parent_company""#
)
```
<Overlap Ratio: 0.9596928982725528>

---

--- 312 --
Question ID: ecd632c89fd5050b93d64aea0587b471224a2f20_1
Original Code:
```
pub fn tokenize(input: &str) -> Vec<Token> {
    let mut state = TokenizerState::Default;
    let mut tokens: Vec<Token> = vec![];
    let mut current_token: String = String::new();
    for chr in input.chars() {
        state = match state {
            TokenizerState::DoubleQuoted => {
                process_character_double_quoted(&mut tokens, &mut current_token, chr)
            }
            TokenizerState::SingleQuoted => {
                process_character_single_quoted(&mut tokens, &mut current_token, chr)
            }
            TokenizerState::Commented => {
                process_character_comment(&mut tokens, &mut current_token, chr)
            }
            _ => process_character_default(&mut tokens, &mut current_token, chr),
        }
    }
    if !current_token.is_empty() {
        tokens.push(Token::Word(current_token.clone()));
    }
    tokens.push(Token::End);
    tokens
}
```


Overlapping Code:
```

let mut state = TokenizerState::Default;
let mut tokens: Vec<Token> = vec![];
let mut current_token: String = String::new();
for chr in input.chars() {
state = match state {
TokenizerState::DoubleQuoted => {
process_character_double_quoted(&mut tokens, &mut current_token, chr)
}
TokenizerState::SingleQuoted => {
process_character_single_quoted(&mut tokens, &mut current_token, chr)
}
TokenizerState::Commented => {
process_character_comment(&mut tokens, &mut current_token, chr)
}
_ => process_character_default(&mut tokens, &mut current_token, chr),
}
}
if !current_token.is_empty() {
tokens.push(Token::Word(current_token.clone()));
}
tokens.pus
```
<Overlap Ratio: 0.9065550906555091>

---

--- 313 --
Question ID: a08423d010cf4e3f2c3d54afedefe29db74f8bfc_0
Original Code:
```
fn test0() {
    let mut node = Node::new().unwrap();
    node.init();
    node.create_environment("X").unwrap();
    node.create_entity().unwrap();
    node.run().unwrap();
}
```


Overlapping Code:
```
{
let mut node = Node::new().unwrap();
node.init();
node.create_environment("X").unwrap();
node.crea
```
<Overlap Ratio: 0.6451612903225806>

---

--- 314 --
Question ID: 41d0d3de6eac7746cda3976054e9eb26c415cdf0_7
Original Code:
```
pub fn encrypt(pbc: &RsaPublicKey,f: &[u8],g: &mut [u8]) {
	let m=pbc.n.getlen();
	let mut r=FF::new_int(m);

	FF::frombytes(&mut r,f);
	r.power(pbc.e,&pbc.n);
	r.tobytes(g);
}
```


Overlapping Code:
```
rypt(pbc: &RsaPublicKey,f: &[u8],g: &mut [u8]) {
let m=pbc.n.getlen();
let mut r=FF::new_int(m);
FF::frombytes(&mut r,f);
r.power(pbc.e,&pbc.n);
r.tob
```
<Overlap Ratio: 0.8823529411764706>

---

--- 315 --
Question ID: 554ea24a982ed06686ab286aa2b63066542e978e_3
Original Code:
```
fn test_phys_dist() {
        let sf = Coordinate {
            latitude: 37.774929,
            longitude: -122.419416,
        };
        let nyc = Coordinate {
            latitude: 40.730610,
            longitude: -73.935242,
        };
        assert_eq!(CityData::find_distance_earth(sf, nyc), 4135.694);
    }
```


Overlapping Code:
```
f = Coordinate {
latitude: 37.774929,
longitude: -122.419416,
};
let nyc = Coordinate {
latitude: 40.730610,
longitude: -73.935242,
};
assert_eq!(City
```
<Overlap Ratio: 0.6666666666666666>

---

--- 316 --
Question ID: 8f1ad55d2f879a1462289feedaf7c669bf023b74_8
Original Code:
```
fn data_integrity_f64_test() {
        let vec: Vec<Rc<f64>> = vec![1f64, -3.0, 10.02, -23.1, 32e-1]
            .into_iter()
            .map(Rc::new)
            .collect();
        let buf = VecClone::from(vec.clone()); // Convert into buffer
        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec
        assert_eq!(vec, nu_vec);

        let vec: Vec<Rc<f64>> = vec![1f64, -3.1, 100.2, -2.31, 3.2, 4e2, -1e23]
            .into_iter()
            .map(Rc::new)
            .collect();
        let buf = VecClone::from(vec.clone()); // Convert into buffer
        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec
        assert_eq!(vec, nu_vec);
    }
```


Overlapping Code:
```
64_test() {
let vec: Vec<Rc<f64>> = vec![1f64, -3.0, 10.02, -23.1, 32e-1]
.into_iter()
.map(Rc::new)
.collect();
let buf = VecClone::from(vec.clone()); // Convert into buffer
let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec
assert_eq!(vec, nu_vec);
let vec: Vec<Rc<f64>> = vec![1f64, -3.1, 100.2, -2.31, 3.2, 4e2, -1e23]
.into_iter()
.map(Rc::new)
.collect();
let buf = VecClone::from(vec.clone()); // Convert into buffer
let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec
assert_eq!(vec, nu_vec);

```
<Overlap Ratio: 0.9657534246575342>

---

--- 317 --
Question ID: fce6576991161de1986c215c5426470d4dd65720_10
Original Code:
```
fn highest_equivalent_value() {
    let histogram = Histogram::<u64>::with_low_high_sigvdig(1024, HIGHEST_TRACKABLE, SIG_V_DIGITS).unwrap();
    assert_eq!(
        8183 * 1024 + 1023,
        histogram.highest_equivalent_value(8180 * 1024),
        "The highest equivalent value to 8180 * 1024 is 8183 * 1024 + 1023"
    );
    assert_eq!(
        8191 * 1024 + 1023,
        histogram.highest_equivalent_value(8191 * 1024),
        "The highest equivalent value to 8187 * 1024 is 8191 * 1024 + 1023"
    );
    assert_eq!(
        8199 * 1024 + 1023,
        histogram.highest_equivalent_value(8193 * 1024),
        "The highest equivalent value to 8193 * 1024 is 8199 * 1024 + 1023"
    );
    assert_eq!(
        9999 * 1024 + 1023,
        histogram.highest_equivalent_value(9995 * 1024),
        "The highest equivalent value to 9995 * 1024 is 9999 * 1024 + 1023"
    );
    assert_eq!(
        10007 * 1024 + 1023,
        histogram.highest_equivalent_value(10007 * 1024),
        "The highest equivalent value to 10007 * 1024 is 10007 * 1024 + 1023"
    );
    assert_eq!(
        10015 * 1024 + 1023,
        histogram.highest_equivalent_value(10008 * 1024),
        "The highest equivalent value to 10008 * 1024 is 10015 * 1024 + 1023"
    );
    verify_max_value(histogram);
}
```


Overlapping Code:
```
_value() {
let histogram = Histogram::<u64>::with_low_high_sigvdig(1024, HIGHEST_TRACKABLE, SIG_V_DIGITS).unwrap();
assert_eq!(
8183 * 1024 + 1023,
histogram.highest_equivalent_value(8180 * 1024),
"The highest equivalent value to 8180 * 1024 is 8183 * 1024 + 1023"
);
assert_eq!(
8191 * 1024 + 1023,
histogram.highest_equivalent_value(8191 * 1024),
"The highest equivalent value to 8187 * 1024 is 8191 * 1024 + 1023"
);
assert_eq!(
8199 * 1024 + 1023,
histogram.highest_equivalent_value(8193 * 1024),
"The highest equivalent value to 8193 * 1024 is 8199 * 1024 + 1023"
);
assert_eq!(
9999 * 1024 + 1023,
histogram.highest_equivalent_value(9995 * 1024),
"The highest equivalent value to 9995 * 1024 is 9999 * 1024 + 1023"
);
assert_eq!(
10007 * 1024 + 1023,
histogram.highest_equivalent_value(10007 * 1024),
"The highest equivalent value to 10007 * 1024 is 10007 * 1024 + 1023"
);
assert_eq!(
10015 * 1024 + 1023,
histogram.highest_equivalent_value(10008 * 1024),
"The highest equivalent value to 10008 * 1024 is 10015 * 1024 + 1023"
);
verify_max_value(
```
<Overlap Ratio: 0.968721251149954>

---

--- 318 --
Question ID: a4eeb1b00416106473e403e4ddafbb71c5bbe0f0_2
Original Code:
```
fn test_label_order() {
    let vec = CounterVec::new(Opts::new("foo", "bar"), &["product", "method"]).unwrap();
    let metric = SimpleCounterVec::from(&vec);
    assert_eq!(get_labels(&metric.post.foo), vec!["post", "foo"]);
    assert_eq!(get_labels(&metric.put.bar), vec!["put", "bar"]);
}
```


Overlapping Code:
```
 test_label_order() {
let vec = CounterVec::new(Opts::new("foo", "bar"), &["product", "method"]).unwrap();
let metric = SimpleCounterVec::from(&vec);
assert_eq!(get_labels(&metric.post.foo), vec!["post", "foo"]);
assert_eq!(get_labels(&metric.put.bar
```
<Overlap Ratio: 0.9025270758122743>

---

--- 319 --
Question ID: c75afb5f19a284ebd979979d7ff68fda1a67d5e2_42
Original Code:
```
fn read_discrete_inputs_max_quantity() {
            let quantity = 2000;
            let byte_count = quantity / 8;
            let mut raw: Vec<u8> = vec![2, byte_count as u8];
            let mut values: Vec<u8> = (0..byte_count).map(|_| 0b_1111_1111).collect();
            raw.append(&mut values);
            let bytes = Bytes::from(raw);
            let rsp = Response::try_from(bytes).unwrap();
            assert_eq!(rsp, Response::ReadDiscreteInputs(vec![true; quantity]));
        }
```


Overlapping Code:
```
n read_discrete_inputs_max_quantity() {
let quantity = 2000;
let byte_count = quantity / 8;
let mut raw: Vec<u8> = vec![2, byte_count as u8];
let mut values: Vec<u8> = (0..byte_count).map(|_| 0b_1111_1111).collect();
raw.append(&mut values);
let bytes = Bytes::from(raw);
let rsp = Response::try_from(bytes).unwrap();
assert_eq!(rsp, Response::ReadDi
```
<Overlap Ratio: 0.8997429305912596>

---

--- 320 --
Question ID: d0add26fda6317ed9502f6dddb6b8abe038328d6_1
Original Code:
```
fn it_makes_a_raw_header() {
        let merkle_root = vec![
            218, 175, 98, 56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157,
            79, 238, 83, 118, 209, 92, 202, 25, 32, 246, 230, 153, 39,
        ];
        let state_root = vec![
            121, 132, 139, 154, 165, 229, 182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1,
            181, 107, 19, 130, 67, 220, 241, 192, 46, 94, 69, 215, 134, 11,
        ];
        let time_stamp = 1515003305000;
        let difficulty = 0 as f64;
        let miner = Address::from_string(&"H3yGUaF38TxQxoFrqCqPdB2pN9jyBHnaj".to_string()).unwrap();
        let previous_hash = vec!["G4qXusbRyXmf62c8Tsha7iZoyLsVGfka7ynkvb3Esd1d"
            .from_base58()
            .unwrap()];
        let nonce = 0;
        let header = Header::new(
            merkle_root.clone(),
            time_stamp,
            difficulty,
            state_root.clone(),
            previous_hash.clone(),
            nonce,
            miner,
        );
        let encoding = header.encode().unwrap();
        let expected_encoding = vec![
            10, 32, 223, 218, 236, 54, 245, 118, 35, 75, 80, 237, 79, 63, 61, 46, 46, 228, 77, 128,
            114, 163, 92, 252, 73, 201, 159, 108, 48, 48, 86, 233, 136, 20, 18, 32, 218, 175, 98,
            56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157, 79, 238, 83,
            118, 209, 92, 202, 25, 32, 246, 230, 153, 39, 26, 32, 121, 132, 139, 154, 165, 229,
            182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1, 181, 107, 19, 130, 67, 220,
            241, 192, 46, 94, 69, 215, 134, 11, 33, 0, 0, 0, 0, 0, 0, 0, 0, 40, 168, 184, 239, 233,
            139, 44, 48, 0, 58, 20, 213, 49, 13, 190, 194, 137, 35, 119, 16, 249, 57, 125, 207, 78,
            117, 246, 36, 136, 151, 210,
        ];
        let prehash = header.prehash().unwrap();
        let expected_prehash = vec![
            213, 155, 184, 6, 160, 192, 238, 37, 190, 172, 89, 224, 41, 36, 132, 38, 46, 5, 70,
            193, 159, 49, 130, 25, 220, 56, 238, 148, 167, 135, 240, 158, 162, 189, 223, 13, 85,
            156, 251, 105, 34, 21, 90, 14, 21, 248, 16, 183, 136, 77, 231, 102, 80, 183, 192, 177,
            184, 19, 75, 226, 188, 134, 38, 218,
        ];

        assert_eq!(encoding, expected_encoding);
        assert_eq!(prehash, expected_prehash);
    }
```


Overlapping Code:
```
header() {
let merkle_root = vec![
218, 175, 98, 56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157,
79, 238, 83, 118, 209, 92, 202, 25, 32, 246, 230, 153, 39,
];
let state_root = vec![
121, 132, 139, 154, 165, 229, 182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1,
181, 107, 19, 130, 67, 220, 241, 192, 46, 94, 69, 215, 134, 11,
];
let time_stamp = 1515003305000;
let difficulty = 0 as f64;
let miner = Address::from_string(&"H3yGUaF38TxQxoFrqCqPdB2pN9jyBHnaj".to_string()).unwrap();
let previous_hash = vec!["G4qXusbRyXmf62c8Tsha7iZoyLsVGfka7ynkvb3Esd1d"
.from_base58()
.unwrap()];
let nonce = 0;
let header = Header::new(
merkle_root.clone(),
time_stamp,
difficulty,
state_root.clone(),
previous_hash.clone(),
nonce,
miner,
);
let encoding = header.encode().unwrap();
let expected_encoding = vec![
10, 32, 223, 218, 236, 54, 245, 118, 35, 75, 80, 237, 79, 63, 61, 46, 46, 228, 77, 128,
114, 163, 92, 252, 73, 201, 159, 108, 48, 48, 86, 233, 136, 20, 18, 32, 218, 175, 98,
56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157, 79, 238, 83,
118, 209, 92, 202, 25, 32, 246, 230, 153, 39, 26, 32, 121, 132, 139, 154, 165, 229,
182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1, 181, 107, 19, 130, 67, 220,
241, 192, 46, 94, 69, 215, 134, 11, 33, 0, 0, 0, 0, 0, 0, 0, 0, 40, 168, 184, 239, 233,
139, 44, 48, 0, 58, 20, 213, 49, 13, 190, 194, 137, 35, 119, 16, 249, 57, 125, 207, 78,
117, 246, 36, 136, 151, 210,
];
let prehash = header.prehash().unwrap();
let expected_prehash = vec![
213, 155, 184, 6, 160, 192, 238, 37, 190, 172, 89, 224, 41, 36, 132, 38, 46, 5, 70,
193, 159, 49, 130, 25, 220, 56, 238, 148, 167, 135, 240, 158, 162, 189, 223, 13, 85,
156, 251, 105, 34, 21, 90, 14, 21, 248, 16, 183, 136, 77, 231, 102, 80, 183, 192, 177,
184, 19, 75, 226, 188, 134, 38, 218,
];
assert_eq!(encoding, expected_encoding);
asser
```
<Overlap Ratio: 0.9725246241575947>

---

--- 321 --
Question ID: 474cfdaebd1e7049d631e0a9ce53ec815892756b_21
Original Code:
```
fn can_evaluate_map_with_duplicate_keys() {
        let map_expr            = Expression::Map(vec![ (Expression::string("\"Foo\""), Expression::number("1")), (Expression::string("\"Foo\""), Expression::number("2")) ]);
        let empty_environment   = EmptyEnvironment::new();
        let mut env             = ScriptExecutionEnvironment::new();
        let result              = evaluate_unbound_expression(&map_expr, &empty_environment, &mut env);

        assert!(result == Ok(json![ { "Foo": 2 } ]));
    }
```


Overlapping Code:
```
n_evaluate_map_with_duplicate_keys() {
let map_expr = Expression::Map(vec![ (Expression::string("\"Foo\""), Expression::number("1")), (Expression::string("\"Foo\""), Expression::number("2")) ]);
let empty_environment = EmptyEnvironment::new();
let mut env = ScriptExecutionEnvironment::new();
let result = evaluate_unbound_expression(&map_expr, &empty_environment, &mut env);
assert!(result == Ok(json![ { "Foo
```
<Overlap Ratio: 0.9579439252336449>

---

--- 322 --
Question ID: 247e428dce046f1d72875b8da595f240a61b333d_0
Original Code:
```
pub fn highlight<S: AsRef<str>>(ty: &str, text: S) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_nonewlines();
    let ts = ThemeSet::load_defaults();

    let syntax = ps.find_syntax_by_extension(ty)
        .expect("Unable to find highlighting grammar");
    let mut theme = ts.themes["base16-eighties.dark"].clone();
    theme.settings.background.as_mut().map(|color| {
        color.r = 0x2c;
        color.g = 0x2c;
        color.b = 0x2c;
        color.a = 0xff;
    });

    let mut h = HighlightLines::new(syntax, &theme);
    for line in text.as_ref().lines() {
        let ranges: Vec<(Style, &str)> = h.highlight(line);
        let escaped = as_24_bit_terminal_escaped(&ranges[..], true);
        println!("{}", escaped);
    }

    println!("\x1b[0m");
}
```


Overlapping Code:
```
tr>>(ty: &str, text: S) {
// Load these once at the start of your program
let ps = SyntaxSet::load_defaults_nonewlines();
let ts = ThemeSet::load_defaults();
let syntax = ps.find_syntax_by_extension(ty)
.expect("Unable to find highlighting grammar");
let mut theme = ts.themes["base16-eighties.dark"].clone();
theme.settings.background.as_mut().map(|color| {
color.r = 0x2c;
color.g = 0x2c;
color.b = 0x2c;
color.a = 0xff;
});
let mut h = HighlightLines::new(syntax, &theme);
for line in text.as_ref().lines() {
let ranges: Vec<(Style, &str)> = h.highlight(line);
let escaped = as_24_bit_terminal_escaped(&ranges[..], true);
println!("{}", escaped);
}

```
<Overlap Ratio: 0.9300998573466477>

---

--- 323 --
Question ID: 094ea5430fdb1987e60e6113a2a2d2007ad90c51_5
Original Code:
```
fn test_python_matches() {
        let python = Python {
            location: String::new(),
            version: (1, 2, 3),
            order: 0,
        };
        assert!(python.matches(&Major(1)));
        assert!(python.matches(&Minor(1, 2)));
        assert!(!python.matches(&Major(2)));
        assert!(!python.matches(&Minor(2, 2)));
    }
```


Overlapping Code:
```
test_python_matches() {
let python = Python {
location: String::new(),
version: (1, 2, 3),
order: 0,
};
assert!(python.matches(&Major(1)));
assert!(python.matches(&Minor(1, 2)));
assert!(!python.matches(&Major(2)));
assert!(!python.matches(&Minor(2, 
```
<Overlap Ratio: 0.9615384615384616>

---

--- 324 --
Question ID: ebe2142122059ad0ed019626e7520ad3ad7a8aa0_9
Original Code:
```
fn test_version_spec_1() {
        let v1 = VersionSpec::try_from("1.7.1").unwrap();
        let v2 = VersionSpec::try_from("1.7.1*").unwrap();
        let v3 = VersionSpec::try_from("1.7.1").unwrap();
        assert!(v1.is_exact());
        assert_ne!(v2.is_exact(), true);
        assert!(v3.is_exact());
        // right now, VersionSpec instance are not orderable nor equal by value. Versions are, though.
        // assert_eq!(v1, v3);
        // assert_ne!(v1, v2);
        // assert_ne!(v3, v2);
        // assert_ne!(v1, 1.0);
        // pointer tests here are testing caching - are equal values created as just one object?
        // https://users.rust-lang.org/t/is-any-way-to-know-references-are-referencing-the-same-object/9716/6
        assert_eq!(&v1 as *const _, &v3 as *const _);
        assert_ne!(&v1 as *const _, &v2 as *const _);
    }
```


Overlapping Code:
```
= VersionSpec::try_from("1.7.1").unwrap();
let v2 = VersionSpec::try_from("1.7.1*").unwrap();
let v3 = VersionSpec::try_from("1.7.1").unwrap();
assert!(v1.is_exact());
assert_ne!(v2.is_exact(), true);
assert!(v3.is_exact());
// right now, VersionSpec instance are not orderable nor equal by value. Versions are, though.
// assert_eq!(v1, v3);
// assert_ne!(v1, v2);
// assert_ne!(v3, v2);
// assert_ne!(v1, 1.0);
// pointer tests here are testing caching - are equal values created as just one object?
// https://users.rust-lang.org/t/is-any-way-to-know-references-are-referencing-the-same-object/9716/6
assert_eq!(&v1 as *const _, &v3 as *const _);

```
<Overlap Ratio: 0.8891928864569083>

---

--- 325 --
Question ID: ada541d03d501f3f49006046587dfaeaa1e3f73b_4
Original Code:
```
fn lcm(v1: usize, v2: usize) -> usize {
    v1 * v2 / gcd(v1, v2)
    // while v1 != 0 {
    //     let old_v1 = v1;
    //     v1 = v2 % v1;
    //     v2 = old_v1;
    // }
    // v2
}
```


Overlapping Code:
```
> usize {
v1 * v2 / gcd(v1, v2)
// while v1 != 0 {
// let old_v1 = v1;
// v1 = v2 % v1;
// v2 = old_
```
<Overlap Ratio: 0.684931506849315>

---

--- 326 --
Question ID: 0ee6bd124be69d29ecc638e42424432315dc1129_1
Original Code:
```
fn main() {
    let mut builtins = vec![
        expr_decl!(Add as '+', #slots a b, |_, k| AstExpr::Add(k[0], k[1])),
        expr_decl!(If as '?', #slots cond t f, |_, k| AstExpr::If(k[0], k[1], k[2])),
        expr_decl!(True as 't', |_, _| AstExpr::Constant(Value::Bool(true))),
        expr_decl!(False as 'f', |_, _| AstExpr::Constant(Value::Bool(false))),
        expr_decl!(Repeat as '#', #slots count body, |_, k| AstExpr::Repeat(k[0], k[1])),
    ];

    let functions = vec![
        func_decl! {
            name "Print", symbol 'P', args 1,
            type [ExprType::Int] => ExprType::Int,
            type [ExprType::String] => ExprType::String,
            type [ExprType::Bool] => ExprType::Bool,
            |builder, store, children| {
                let t = builder.build_instructions(store, children[0])?;
                builder.push(Instruction::Print(t.into_value_type()));
                Ok(t)
            }
        },
        func_decl! {
            name "ReadLine", symbol 'R', args 0,
            type [] => ExprType::String,
            |builder, _store, _children| {
                builder.push(Instruction::ReadLine);
                Ok(ExprType::String)
            }
        },
        func_decl! {
            name "CompareLT", symbol '<', args 2,
            type [ExprType::Int, ExprType::Int] => ExprType::Bool,
            |builder, store, children| {
                use Instruction::*;
                builder.build_instructions(store, children[0])?;
                builder.build_instructions(store, children[1])?;
                builder.push(SubInt);
                builder.push(CompareZero(Ordering::Less));
                builder.push(PushRegister(Register::Bool(0)));
                Ok(ExprType::Bool)
            }
        },
        func_decl! {
            name "CompareGT", symbol '>', args 2,
            type [ExprType::Int, ExprType::Int] => ExprType::Bool,
            |builder, store, children| {
                use Instruction::*;
                builder.build_instructions(store, children[0])?;
                builder.build_instructions(store, children[1])?;
                builder.push(SubInt);
                builder.push(CompareZero(Ordering::Greater));
                builder.push(PushRegister(Register::Bool(0)));
                Ok(ExprType::Bool)
            }
        },
        func_decl! {
            name "Equal", symbol '=', args 2,
            type [ExprType::Int, ExprType::Int] => ExprType::Bool,
            type [ExprType::String, ExprType::String] => ExprType::Bool,
            type [ExprType::Bool, ExprType::Bool] => ExprType::Bool,
            |builder, store, children| {
                use Instruction::*;
                builder.build_instructions(store, children[0])?;
                let t = builder.build_instructions(store, children[1])?;
                builder.push(CompareEqual(t.into_value_type()));
                builder.push(PushRegister(Register::Bool(0)));
                Ok(ExprType::Bool)
            }
        },
        func_decl! {
            name "Void", symbol 'V', args 0,
            type [] => ExprType::Void,
            |_builder, _store, _children| {
                Ok(ExprType::Void)
            }
        },
    ];

    for func in functions {
        let func = Rc::new(func);
        builtins.push(ExprDecl {
            name: func.name,
            symbol: func.symbol,
            shapes: vec![ExprShape {
                slots: std::iter::repeat(ExprSlot::Value { name: "" })
                    .take(func.param_count)
                    .collect(),
                build_expr: Box::new(move |_, k| AstExpr::CallBuiltin(func.clone(), k.into())),
            }],
        })
    }

    let mut parser = Parser::new();
    let code = std::env::args()
        .nth(1)
        .unwrap_or_else(|| r#"P"Hello, world""#.to_owned());
    let context = ParserContext::new(builtins, &code);

    let (res, total_time) = measure(|| -> VMResult<()> {
        let (keys, parsing_time) = measure(|| parser.read_all_expressions(&context));

        let keys = match keys {
            Ok(keys) => keys,
            Err(e) => {
                println!(
                    "Error at position {}",
                    if let Some(p) = e.position {
                        p.to_string()
                    } else {
                        "EOF".to_owned()
                    }
                );
                println!("  {:?}", e.reason);
                return Ok(());
            }
        };

        println!("Code: {}", code);
        println!("\nParsing duration: {:?}", parsing_time);
        println!(
            "Ast:\n{}\n",
            keys.iter()
                .map(|key| parser.ast_store.get(*key).print(&parser.ast_store, 0))
                .join("\n")
        );

        let (res, bb_build_time) = measure(|| -> Result<_, Box<TypeError>> {
            let mut blocks = BasicBlockBuilder::new();
            keys.iter()
                .try_for_each(|k| blocks.build_statement(&parser.ast_store, *k).map(|_| ()))?;
            Ok(blocks.blocks)
        });
        let mut blocks = res?;

        println!("BlockSet build duration: {:?}", bb_build_time);
        println!("BlockSet (unoptimized)");
        for (i, block) in blocks.iter().enumerate() {
            println!("  #{} -> {:?}", i, block.end);
            for ins in &block.instructions {
                println!("    {:?}", ins);
            }
        }

        let (_, optimize_time) = measure(|| {
            remove_unnecessary_register_loads(&mut blocks);
            remove_duplicates(&mut blocks);
            remove_empty(&mut blocks);
        });

        println!("BlockSet optimization duration: {:?}", optimize_time);
        println!("BlockSet");
        for (i, block) in blocks.iter().enumerate() {
            println!("  #{} -> {:?}", i, block.end);
            for ins in &block.instructions {
                println!("    {:?}", ins);
            }
        }

        let (instructions, inst_build_time) =
            measure(move || InstructionSetBuilder::from_bb(blocks).into_instructions());

        println!("InstructionSet build duration: {:?}", inst_build_time);
        println!("InstructionSet");
        for (i, ins) in instructions.iter().enumerate() {
            println!("  {:04}: {:?}", i, ins);
        }

        println!("\nExecution:");
        let mut vm = VM::<UncheckedValues>::new(instructions);
        let (res, exec_time) = measure(|| {
            vm.run(
                std::env::args()
                    .nth(2)
                    .map(|x| x.chars().nth(0) == Some('y'))
                    .unwrap_or(false),
            )
        });
        res?;

        println!("\n\nTrace:");
        for frame in &vm.stack_frames {
            println!(
                "{: <3} {: <30} -> Int: {:?}, Bool: {:?}, String: {:?}, T: {:?}",
                frame.execution_pointer,
                format!("{:?}", &vm.instructions[frame.execution_pointer]),
                frame.val_stack.int_values,
                frame.val_stack.bool_values,
                frame.val_stack.string_values,
                frame.registers.bools,
            );
        }

        println!("\nInstructions executed:        {}", vm.instruction_counter);
        println!(
            "Execution duration:           {:?} ({:.3} ns/op)",
            exec_time,
            exec_time.as_nanos() as f64 / vm.instruction_counter as f64
        );
        println!(
            "Total duration (excl. debug): {:?}",
            parsing_time + bb_build_time + optimize_time + inst_build_time + exec_time
        );

        Ok(())
    });
    match res.map_err(|v| *v) {
        Ok(()) => {}
        Err(VMError::IO(e)) => {
            println!("IO error: {:?}", e);
        }
        Err(VMError::TypeError(e)) => {
            print_type_error(&code, &e);
        }
    }

    println!("Total duration:               {:?}", total_time);
}
```


Overlapping Code:
```
ltins = vec![
expr_decl!(Add as '+', #slots a b, |_, k| AstExpr::Add(k[0], k[1])),
expr_decl!(If as '?', #slots cond t f, |_, k| AstExpr::If(k[0], k[1], k[2])),
expr_decl!(True as 't', |_, _| AstExpr::Constant(Value::Bool(true))),
expr_decl!(False as 'f', |_, _| AstExpr::Constant(Value::Bool(false))),
expr_decl!(Repeat as '#', #slots count body, |_, k| AstExpr::Repeat(k[0], k[1])),
];
let functions = vec![
func_decl! {
name "Print", symbol 'P', args 1,
type [ExprType::Int] => ExprType::Int,
type [ExprType::String] => ExprType::String,
type [ExprType::Bool] => ExprType::Bool,
|builder, store, children| {
let t = builder.build_instructions(store, children[0])?;
builder.push(Instruction::Print(t.into_value_type()));
Ok(t)
}
},
func_decl! {
name "ReadLine", symbol 'R', args 0,
type [] => ExprType::String,
|builder, _store, _children| {
builder.push(Instruction::ReadLine);
Ok(ExprType::String)
}
},
func_decl! {
name "CompareLT", symbol '<', args 2,
type [ExprType::Int, ExprType::Int] => ExprType::Bool,
|builder, store, children| {
use Instruction::*;
builder.build_instructions(store, children[0])?;
builder.build_instructions(store, children[1])?;
builder.push(SubInt);
builder.push(CompareZero(Ordering::Less));
builder.push(PushRegister(Register::Bool(0)));
Ok(ExprType::Bool)
}
},
func_decl! {
name "CompareGT", symbol '>', args 2,
type [ExprType::Int, ExprType::Int] => ExprType::Bool,
|builder, store, children| {
use Instruction::*;
builder.build_instructions(store, children[0])?;
builder.build_instructions(store, children[1])?;
builder.push(SubInt);
builder.push(CompareZero(Ordering::Greater));
builder.push(PushRegister(Register::Bool(0)));
Ok(ExprType::Bool)
}
},
func_decl! {
name "Equal", symbol '=', args 2,
type [ExprType::Int, ExprType::Int] => ExprType::Bool
```
<Overlap Ratio: 0.9840396257567419>

---

--- 327 --
Question ID: aa2bc3b4d4bef9d9b0519addc895a09484449321_0
Original Code:
```
pub extern "C" fn create() {
    let reference: URef = storage::new_uref(DATA);
    let read_only_reference: URef = URef::new(reference.addr(), AccessRights::READ);
    let return_value = CLValue::from_t(read_only_reference).unwrap_or_revert();
    runtime::ret(return_value)
}
```


Overlapping Code:
```
ub extern "C" fn create() {
let reference: URef = storage::new_uref(DATA);
let read_only_reference: URef = URef::new(reference.addr(), AccessRights::READ);
let return_value = CLValue::from_t(read_only_reference).unwrap_or_revert();
runtime::ret(retur
```
<Overlap Ratio: 0.9578544061302682>

---

--- 328 --
Question ID: 93c28e8e074c403d1d9e704fd396a0f10b3d6c75_2
Original Code:
```
fn solve(from: &Vec<i64>, to: &Vec<i64>) -> i64 {
  let roads = from.len();
  let mut cities: Vec<bool> = vec![false; roads + 1];
  for city in to.iter() {
    cities[*city as usize] = true;
  }
  for city in from.iter() {
    cities[*city as usize] = false;
  }
  let mut result: i64 = -1;
  for (city, is_rome) in cities.iter().enumerate() {
    if *is_rome {
      if result < 0 {
        result = city as i64;
      } else {
        return -1;
      }
    }
  }
  return result;
}
```


Overlapping Code:
```
Vec<i64>, to: &Vec<i64>) -> i64 {
let roads = from.len();
let mut cities: Vec<bool> = vec![false; roads + 1];
for city in to.iter() {
cities[*city as usize] = true;
}
for city in from.iter() {
cities[*city as usize] = false;
}
let mut result: i64 = -1;
for (city, is_rome) in cities.iter().enumerate() {
if *is_rome {
if result < 0 {
result = city as
```
<Overlap Ratio: 0.8454106280193237>

---

--- 329 --
Question ID: bcf21bfed2654741d2a5676fa297cc74ab3f6c2d_1
Original Code:
```
pub fn serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let struct_name = &ast.ident;
    
    proc_macro::TokenStream::from(quote! {
        #[doc(hidden)]
        #[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates,clippy::useless_attribute)]
            extern crate serde as _serde;

            #[automatically_derived]
            impl _serde::Serialize for #struct_name {
                fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {
                    Err(_serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
                }
            }
        };
    })
}
```


Overlapping Code:
```
serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
let ast = parse_macro_input!(input as DeriveInput);
let struct_name = &ast.ident;

proc_macro::TokenStream::from(quote! {
#[doc(hidden)]
#[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
const _: () = {
#[allow(unused_extern_crates,clippy::useless_attribute)]
extern crate serde as _serde;
#[automatically_derived]
impl _serde::Serialize for #struct_name {
fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {
Err(_serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
}
}
};
})

```
<Overlap Ratio: 0.9897304236200257>

---

--- 330 --
Question ID: 6ed3822fabee84a2449771b7cb685bb729c4f58d_0
Original Code:
```
fn verify(tree: &sled::Tree) -> (u32, u32) {
    // key 0 should always be the highest value, as that's where we increment
    // at some point, it might go down by one
    // it should never return, or go down again after that
    let mut iter = tree.iter();
    let highest = match iter.next() {
        Some(Ok((_k, v))) => slice_to_u32(&*v),
        Some(Err(e)) => panic!("{:?}", e),
        None => return (0, 0),
    };

    let highest_vec = u32_to_vec(highest);

    // find how far we got
    let mut contiguous: u32 = 0;
    let mut lowest = 0;
    for res in iter {
        let (mut k, v) = res.unwrap();
        if &v[..4] == &highest_vec[..4] {
            contiguous += 1;
        } else {
            k.reverse();
            let expected = if highest == 0 {
                CYCLE as u32 - 1
            } else {
                (highest - 1) % CYCLE as u32
            };
            let actual = slice_to_u32(&*v);
            assert_eq!(expected, actual);
            lowest = actual;
            break;
        }
    }

    let lowest_vec = u32_to_vec(lowest);

    // ensure nothing changes after this point
    let low_beginning = u32_to_vec(contiguous + 1);

    for res in tree.scan(&*low_beginning) {
        let (mut k, v) = res.unwrap();
        if v != lowest_vec {
            k.reverse();
        }
        assert_eq!(
            v,
            lowest_vec,
            "expected key {} to have value {}, instead it had value {}",
            slice_to_u32(&*k),
            lowest,
            slice_to_u32(&*v)
        );
    }

    (contiguous, highest)
}
```


Overlapping Code:
```
fn verify(tree: &sled::Tree) -> (u32, u32) {
// key 0 should always be the highest value, as that's where we increment
// at some point, it might go down by one
// it should never return, or go down again after that
let mut iter = tree.iter();
let highest = match iter.next() {
Some(Ok((_k, v))) => slice_to_u32(&*v),
Some(Err(e)) => panic!("{:?}", e),
None => return (0, 0),
};
let highest_vec = u32_to_vec(highest);
// find how far we got
let mut contiguous: u32 = 0;
let mut lowest = 0;
for res in iter {
let (mut k, v) = res.unwrap();
if &v[..4] == &highest_vec[..4] {
contiguous += 1;
} else {
k.reverse();
let expected = if highest == 0 {
CYCLE as u32 - 1
} else {
(highest - 1) % CYCLE as u32
};
let actual = slice_to_u32(&*v);
assert_eq!(expected, actual);
lowest = actual;
break;
}
}
let lowest_vec = u32_to_vec(lowest);
// ensure nothing changes after this point
let low_beginning = u32_to_vec(contiguous + 1);
for res in tree.scan(&*low_beginning) {
let (mut k, v) = res.unwrap();
if v != lowest_vec {
k.reverse();
}
assert_eq!(
v,
lowest_vec,
"expected key {} to have value {}, instead it had value {}",
slice_to_u32(&*k),
lowest,
slice_to_u32(&*v)
);
}
(contiguous, hi
```
<Overlap Ratio: 0.9932716568544996>

---

--- 331 --
Question ID: 382aead3de860442cd78c6d05287f34dd63c6f9c_0
Original Code:
```
fn test_canvas_passing_syntax() {
    use crate::utils::new_null_canvas;
    use crate::Surface;

    let mut null_canvas = new_null_canvas();
    let view = View3D::default();
    // as mutable reference
    view.apply_to_canvas(&mut null_canvas);
    // moved
    view.apply_to_canvas(null_canvas);

    // and one with a mutable reference to a shared Canvas:
    let mut surface = Surface::new_raster_n32_premul((100, 100)).unwrap();
    view.apply_to_canvas(surface.canvas());
}
```


Overlapping Code:
```
est_canvas_passing_syntax() {
use crate::utils::new_null_canvas;
use crate::Surface;
let mut null_canvas = new_null_canvas();
let view = View3D::default();
// as mutable reference
view.apply_to_canvas(&mut null_canvas);
// moved
view.apply_to_canvas(null_canvas);
// and one with a mutable reference to a shared Canvas:
let mut surface = Surface::new_raster_n32_premul((100, 100)).unwrap();
view.apply_to_c
```
<Overlap Ratio: 0.9311926605504587>

---

--- 332 --
Question ID: 2b10ebecdeb13f24ccb41040b2ca5224c82736db_1
Original Code:
```
fn retrieving_a_peer_is_none_if_peer_is_missing_or_not_connected() {
    let mut cs = TestCollectionStream::new();
    let peer_id = PeerId::random();
    assert!(cs.peer_mut(&peer_id).is_none());

    let handler = Handler::default();
    let fut = future::ok((peer_id.clone(), DummyMuxer::new()));
    cs.add_reach_attempt(fut, handler);
    assert!(cs.peer_mut(&peer_id).is_none()); // task is pending
}
```


Overlapping Code:
```
eving_a_peer_is_none_if_peer_is_missing_or_not_connected() {
let mut cs = TestCollectionStream::new();
let peer_id = PeerId::random();
assert!(cs.peer_mut(&peer_id).is_none());
let handler = Handler::default();
let fut = future::ok((peer_id.clone(), DummyMuxer::new()));
cs.add_reach_attempt(fut, handler);
assert!(cs.peer_mut(&peer_id).is_none()); /
```
<Overlap Ratio: 0.9283819628647215>

---

--- 333 --
Question ID: 637390b2c7ff458be9db22fd032ece68d03c4cd5_11
Original Code:
```
fn offchain_local_storage_should_work() {
		use substrate_client::backend::OffchainStorage;

		let mut ext = TestExternalities::<Blake2Hasher>::default();
		let (offchain, state) = testing::TestOffchainExt::new();
		ext.set_offchain_externalities(offchain);
		let test_code = WASM_BINARY;
		assert_eq!(
			WasmExecutor::new().call(&mut ext, 8, &test_code[..], "test_offchain_local_storage", &[]).unwrap(),
			vec![0]
		);
		assert_eq!(state.read().persistent_storage.get(b"", b"test"), Some(vec![]));
	}
```


Overlapping Code:
```
bstrate_client::backend::OffchainStorage;
let mut ext = TestExternalities::<Blake2Hasher>::default();
let (offchain, state) = testing::TestOffchainExt::new();
ext.set_offchain_externalities(offchain);
let test_code = WASM_BINARY;
assert_eq!(
WasmExecutor::new().call(&mut ext, 8, &test_code[..], "test_offchain_local_storage", &[]).unwrap(),
vec![0]
);
assert_eq!(state.read().persistent_storage.get(
```
<Overlap Ratio: 0.8350730688935282>

---

--- 334 --
Question ID: 3d04a24ccc60e218d2ba1fd7d36833082eed6fc1_1
Original Code:
```
fn ctrl_c_kills_everyone() {
    if !enabled() {
        return
    }

    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();

    let p = project("foo")
        .file("Cargo.toml", r#"
            [package]
            name = "foo"
            version = "0.0.1"
            authors = []
            build = "build.rs"
        "#)
        .file("src/lib.rs", "")
        .file("build.rs", &format!(r#"
            use std::net::TcpStream;
            use std::io::Read;

            fn main() {{
                let mut socket = TcpStream::connect("{}").unwrap();
                let _ = socket.read(&mut [0; 10]);
                panic!("that read should never return");
            }}
        "#, addr))
        .build();

    let mut cargo = p.cargo("build").build_command();
    cargo.stdin(Stdio::piped())
         .stdout(Stdio::piped())
         .stderr(Stdio::piped())
         .env("__CARGO_TEST_SETSID_PLEASE_DONT_USE_ELSEWHERE", "1");
    let mut child = cargo.spawn().unwrap();

    let mut sock = listener.accept().unwrap().0;
    ctrl_c(&mut child);

    assert!(!child.wait().unwrap().success());
    match sock.read(&mut [0; 10]) {
        Ok(n) => assert_eq!(n, 0),
        Err(e) => assert_eq!(e.kind(), io::ErrorKind::ConnectionReset),
    }

    // Ok so what we just did was spawn cargo that spawned a build script, then
    // we killed cargo in hopes of it killing the build script as well. If all
    // went well the build script is now dead. On Windows, however, this is
    // enforced with job objects which means that it may actually be in the
    // *process* of being torn down at this point.
    //
    // Now on Windows we can't completely remove a file until all handles to it
    // have been closed. Including those that represent running processes. So if
    // we were to return here then there may still be an open reference to some
    // file in the build directory. What we want to actually do is wait for the
    // build script to *complete* exit. Take care of that by blowing away the
    // build directory here, and panicking if we eventually spin too long
    // without being able to.
    for i in 0..10 {
        match fs::remove_dir_all(&p.root().join("target")) {
            Ok(()) => return,
            Err(e) => println!("attempt {}: {}", i, e),
        }
        thread::sleep(Duration::from_millis(100));
    }

    panic!("couldn't remove build directory after a few tries, seems like \
            we won't be able to!");
}
```


Overlapping Code:
```
e() {
if !enabled() {
return
}
let listener = TcpListener::bind("127.0.0.1:0").unwrap();
let addr = listener.local_addr().unwrap();
let p = project("foo")
.file("Cargo.toml", r#"
[package]
name = "foo"
version = "0.0.1"
authors = []
build = "build.rs"
"#)
.file("src/lib.rs", "")
.file("build.rs", &format!(r#"
use std::net::TcpStream;
use std::io::Read;
fn main() {{
let mut socket = TcpStream::connect("{}").unwrap();
let _ = socket.read(&mut [0; 10]);
panic!("that read should never return");
}}
"#, addr))
.build();
let mut cargo = p.cargo("build").build_command();
cargo.stdin(Stdio::piped())
.stdout(Stdio::piped())
.stderr(Stdio::piped())
.env("__CARGO_TEST_SETSID_PLEASE_DONT_USE_ELSEWHERE", "1");
let mut child = cargo.spawn().unwrap();
let mut sock = listener.accept().unwrap().0;
ctrl_c(&mut child);
assert!(!child.wait().unwrap().success());
match sock.read(&mut [0; 10]) {
Ok(n) => assert_eq!(n, 0),
Err(e) => assert_eq!(e.kind(), io::ErrorKind::ConnectionReset),
}
// Ok so what we just did was spawn cargo that spawned a build script, then
// we killed cargo in hopes of it killing the build script as well. If all
// went well the build script is now dead. On Windows, however, this is
// enforced with job objects which means that it may actually be in the
// *process* of being torn down at this point.
//
// Now on Windows we can't completely remove a file until all handles to it
// have been closed. Including those that represent running processes. So if
// we were to return here then there may still be an open reference to some
// file in the build directory. What we want to actually do is wait for the
// build script to *complete* exit. Take care of that by blowing away the
// build directory here, and panicking if we eventually spin too long
// without being able to.
for i in 0..10 {
match fs::remove_dir_all(&p.root().join("target")) {
Ok(()) => return,
Err(e) => println!("attempt {}: {}", i, e),
}
thread::sleep(Duration::from_millis(100));
}
panic!("couldn't remov
```
<Overlap Ratio: 0.9652509652509652>

---

--- 335 --
Question ID: d955e186b4b6c88b16b55a9851ba51f929615645_5
Original Code:
```
async fn read_continuation_frames() {
    h2_support::trace_init!();
    let (io, mut srv) = mock::new();

    let large = build_large_headers();
    let frame = large
        .iter()
        .fold(
            frames::headers(1).response(200),
            |frame, &(name, ref value)| frame.field(name, &value[..]),
        )
        .eos();

    let srv = async move {
        let settings = srv.assert_client_handshake().await;
        assert_default_settings!(settings);
        srv.recv_frame(
            frames::headers(1)
                .request("GET", "https://http2.akamai.com/")
                .eos(),
        )
        .await;
        srv.send_frame(frame).await;
    };

    let client = async move {
        let (mut client, mut conn) = client::handshake(io).await.expect("handshake");

        let request = Request::builder()
            .uri("https://http2.akamai.com/")
            .body(())
            .unwrap();

        let req = async {
            let res = client
                .send_request(request, true)
                .expect("send_request")
                .0
                .await
                .expect("response");
            assert_eq!(res.status(), StatusCode::OK);
            let (head, _body) = res.into_parts();
            let expected = large
                .iter()
                .fold(HeaderMap::new(), |mut map, &(name, ref value)| {
                    map.append(name, value.parse().unwrap());
                    map
                });
            assert_eq!(head.headers, expected);
        };

        conn.drive(req).await;
        conn.await.expect("client");
    };

    join(srv, client).await;
}
```


Overlapping Code:
```
support::trace_init!();
let (io, mut srv) = mock::new();
let large = build_large_headers();
let frame = large
.iter()
.fold(
frames::headers(1).response(200),
|frame, &(name, ref value)| frame.field(name, &value[..]),
)
.eos();
let srv = async move {
let settings = srv.assert_client_handshake().await;
assert_default_settings!(settings);
srv.recv_frame(
frames::headers(1)
.request("GET", "https://http2.akamai.com/")
.eos(),
)
.await;
srv.send_frame(frame).await;
};
let client = async move {
let (mut client, mut conn) = client::handshake(io).await.expect("handshake");
let request = Request::builder()
.uri("https://http2.akamai.com/")
.body(())
.unwrap();
let req = async {
let res = client
.send_request(request, true)
.expect("send_request")
.0
.await
.expect("response");
assert_eq!(res.status(), StatusCode::OK);
let (head, _body) = res.into_parts();
let expected = large
.iter()
.fold(HeaderMap::new(), |mut map, &(name, ref value)| {
map.append(name, value.parse().unwrap());
map
});
assert_eq!(head.headers, expected);
};
conn.drive(req).await;
conn.await.expect("client");
};
join(srv, client).awai
```
<Overlap Ratio: 0.9610726643598616>

---

--- 336 --
Question ID: 6eca1beef00d0196dc32d05050d7dd673c20c177_5
Original Code:
```
fn test_get_nweights() {
        let xornet = build_small_network();
        let nweights = xornet.nweights();
        assert_eq!(nweights, (2 * 4) + (4 * 4) + (4 * 2));
    }
```


Overlapping Code:
```
_nweights() {
let xornet = build_small_network();
let nweights = xornet.nweights();
assert_eq!(nweig
```
<Overlap Ratio: 0.6802721088435374>

---

--- 337 --
Question ID: e95c9c0c731d1cfd82297bb9c368dab29e5e0369_1
Original Code:
```
fn write() {
        let p: &Path = &TestPath::new().path;
        let f: TestFile = TestFile::new(p);
        let s: String = String::from("Hello, world!");
        let mut c: ConfigFile<StringFormat> = ConfigFile::new(p, StringFormat::new());

        c.content = Some(s.clone());
        c.write().unwrap();

        assert_eq!(f.read(), s);
    }
```


Overlapping Code:
```
{
let p: &Path = &TestPath::new().path;
let f: TestFile = TestFile::new(p);
let s: String = String::from("Hello, world!");
let mut c: ConfigFile<StringFormat> = ConfigFile::new(p, StringFormat::new());
c.content = Some(s.clone());
c.write().unwrap();
assert
```
<Overlap Ratio: 0.8923611111111112>

---

--- 338 --
Question ID: 6d056f9b5880c8e6f933ab4571208896692720e6_2
Original Code:
```
pub fn get_topic(topic: &str) -> Result<Json<dto::GetTopicResult>, String> {
    let offsets = _get_offsets(topic)?;
    let groups = _get_topic_consumer_groups(topic, &offsets, false)?;
    Ok(Json(dto::GetTopicResult{
        offsets: offsets,
        consumer_groups: groups,
    }))
}
```


Overlapping Code:
```
 get_topic(topic: &str) -> Result<Json<dto::GetTopicResult>, String> {
let offsets = _get_offsets(topic)?;
let groups = _get_topic_consumer_groups(topic, &offsets, false)?;
Ok(Json(dto::GetTopicResult{
offsets: offsets,
consumer_groups: groups,
}))
}
```
<Overlap Ratio: 0.9765625>

---

--- 339 --
Question ID: a7d963b47a8c9db4df321781695097a1333e6961_0
Original Code:
```
fn main() {
    let mut deck = Deck::new(10007);
    let mut actions = Vec::new();
    for line in read_file("input.txt") {
        if line.starts_with("deal into") {
            actions.push(Deal)
        } else if line.starts_with("deal with") {
            let split = line.split(' ');
            let last = split.last().unwrap();
            let num = last.parse::<usize>().unwrap();
            actions.push(DealN(num));
        } else if line.starts_with("cut") {
            let split = line.split(' ');
            let last = split.last().unwrap();
            let num = last.parse::<i64>().unwrap();
            actions.push(Cut(num));
        }
    }

    for action in &actions {
        deck.do_action(*action);
    }

    let pos = deck.cards.iter().position(|n| *n == 2019).unwrap();
    println!("part 1 pos:{}", pos);

    let mut deck = PosDeck::new(119315717514047, 2020);
    let end : u64 = 101741582076661;
    for i in 1..end {
        for action in &actions {
            deck.do_action(*action);
        }
        if deck.pos == 2020 {
            println!("repeat at {}",i);
            break;
        }
        if i % 1_000_000 == 0 {
            println!("{}%",i as f64/end as f64);
        }
    }
   // println!("part2 test pos:{}", deck.pos);
}
```


Overlapping Code:
```
mut actions = Vec::new();
for line in read_file("input.txt") {
if line.starts_with("deal into") {
actions.push(Deal)
} else if line.starts_with("deal with") {
let split = line.split(' ');
let last = split.last().unwrap();
let num = last.parse::<usize>().unwrap();
actions.push(DealN(num));
} else if line.starts_with("cut") {
let split = line.split(' ');
let last = split.last().unwrap();
let num = last.parse::<i64>().unwrap();
actions.push(Cut(num));
}
}
for action in &actions {
deck.do_action(*action);
}
let pos = deck.cards.iter().position(|n| *n == 2019).unwrap();
println!("part 1 pos:{}", pos);
let mut deck = PosDeck::new(119315717514047, 2020);
let end : u64 = 101741582076661;
for i in 1..end {
for action in &actions {
deck.do_action(*action);
}
if deck.pos == 2020 {
println!("repeat at {}",i);
break;
}
if i % 1_000_000 == 0 {
println!("{}%",i as f64/end as f64);
}
}
// println!("part
```
<Overlap Ratio: 0.9211873080859775>

---

--- 340 --
Question ID: c416d347d6b9c6efb4a793877160b912b93a0fef_3
Original Code:
```
fn poll_until_sync(&mut self) -> Async<()> {
		self.poll();

		// Return `NotReady` if there's a mismatch in the highest block number.
		let mut highest = None;
		for peer in self.peers().iter() {
			match (highest, peer.client.info().chain.best_number) {
				(None, b) => highest = Some(b),
				(Some(ref a), ref b) if a == b => {},
				(Some(_), _) => return Async::NotReady,
			}
		}
		Async::Ready(())
	}
```


Overlapping Code:
```
l_until_sync(&mut self) -> Async<()> {
self.poll();
// Return `NotReady` if there's a mismatch in the highest block number.
let mut highest = None;
for peer in self.peers().iter() {
match (highest, peer.client.info().chain.best_number) {
(None, b) => highest = Some(b),
(Some(ref a), ref b) if a == b => {},
(Some(_), _) => return Async::NotReady,
}

```
<Overlap Ratio: 0.9308510638297872>

---

--- 341 --
Question ID: 0ebfaaf2747abc0df43c3fc555667b942b1ca34f_19
Original Code:
```
fn empty_string() {
        let mut d = String::from(r#""""#);
        let mut d1 = d.clone();
        let mut d1 = unsafe { d1.as_bytes_mut() };
        let mut d = unsafe { d.as_bytes_mut() };
        let v_serde: serde_json::Value = serde_json::from_slice(d).expect("");
        let v_simd: serde_json::Value = from_slice(&mut d).expect("");
        assert_eq!(to_value(&mut d1), Ok(Value::from("")));
        assert_eq!(v_simd, v_serde);
    }
```


Overlapping Code:
```
tring::from(r#""""#);
let mut d1 = d.clone();
let mut d1 = unsafe { d1.as_bytes_mut() };
let mut d = unsafe { d.as_bytes_mut() };
let v_serde: serde_json::Value = serde_json::from_slice(d).expect("");
let v_simd: serde_json::Value = from_slice(&mut d).expect("");
assert_eq!(to_value(&mut d1), Ok(Value::from(
```
<Overlap Ratio: 0.8153034300791556>

---

--- 342 --
Question ID: d206f1f57a6f8f4cfd67220d6340d32183703b69_1
Original Code:
```
fn get_response<T, R>(
    server: &mut test::TestServer,
    path: &str,
    method: Method,
    json: T,
) -> (StatusCode, R)
where
    T: Serialize,
    R: DeserializeOwned + 'static,
{
    let request = server
        .client(method, &format!("api/v1/{}", path))
        .content_type("application/json")
        .json(json)
        .unwrap();
    let response = server.execute(request.send()).unwrap();
    (response.status(), response.json::<R>().wait().unwrap())
}
```


Overlapping Code:
```
erver,
path: &str,
method: Method,
json: T,
) -> (StatusCode, R)
where
T: Serialize,
R: DeserializeOwned + 'static,
{
let request = server
.client(method, &format!("api/v1/{}", path))
.content_type("application/json")
.json(json)
.unwrap();
let response = server.execute(request.send()).unwrap();
(response.status(), response.json::<R>().wait().unwra
```
<Overlap Ratio: 0.8684863523573201>

---

--- 343 --
Question ID: 3e319eb06ec5d4f48b6b885940d3ac2c7ceba3d7_4
Original Code:
```
fn test_compile_set_e() {
    let compiled = register::compile_set("E".to_string(), "10".to_string());

    assert_eq!(compiled.len(), 9);
    assert_eq!(compiled[0], 0b00001100);
    assert_eq!(compiled[1], 0);
    assert_eq!(compiled[2], 0);
    assert_eq!(compiled[3], 0);
    assert_eq!(compiled[4], 0);
    assert_eq!(compiled[5], 0);
    assert_eq!(compiled[6], 0);
    assert_eq!(compiled[7], 0);
    assert_eq!(compiled[8], 10);
}
```


Overlapping Code:
```
ompiled = register::compile_set("E".to_string(), "10".to_string());
assert_eq!(compiled.len(), 9);
assert_eq!(compiled[0], 0b00001100);
assert_eq!(compiled[1], 0);
assert_eq!(compiled[2], 0);
assert_eq!(compiled[3], 0);
assert_eq!(compiled[4], 0);
assert_eq!(compiled[5], 0);
assert_eq!(compiled[6], 0);
assert_eq!(compiled[7], 0);
assert_eq!(compiled[8], 10
```
<Overlap Ratio: 0.910941475826972>

---

--- 344 --
Question ID: 5d81362a1ce240ef1552832e89445ee1765cb6b4_1
Original Code:
```
pub fn register() -> Resp!() {
    #[derive(Debug, Deserialize)]
    struct Form {
        email: String,
        username: String,
    }

    warp::body::content_length_limit(2 * 1024)
        .and(warp::ext::get::<DB>())
        .and(warp::ext::get::<Mailer>())
        .and(warp::body::form())
        .and_then(|db, mailer, form: Form| {
            logic::auth::register(db, mailer, form.username, form.email).err_to_rejection()
        })
        .untuple_one()
        .and(simple_page("login-ok.html"))
        .recover_with_template("register.html", |err: &Compat<Error>| {
            let err = err.to_string();
            match coerce!(&err => &str) {
                r#"new row for relation "users" violates check constraint "name_fmt""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_username"],
                    vec!["Your username must contain only ASCII letters and digits"],
                )),
                r#"new row for relation "users" violates check constraint "name_len""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_username"],
                    vec!["Your username must be at least 3 characters"],
                )),
                r#"duplicate key value violates unique constraint "users_name_key""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_username"],
                    vec!["This username is already taken"],
                )),
                r#"new row for relation "users" violates check constraint "email_fmt""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_email"],
                    vec!["That doesn't look like an email address..."],
                )),
                r#"new row for relation "users" violates check constraint "email_len""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_email"],
                    vec!["That doesn't look like an email address..."],
                )),
                r#"duplicate key value violates unique constraint "users_email_key""# => Some((
                    StatusCode::BAD_REQUEST,
                    vec!["bad_email"],
                    vec!["This email is already registered"],
                )),
                _ => None,
            }
        })
}
```


Overlapping Code:
```
b fn register() -> Resp!() {
#[derive(Debug, Deserialize)]
struct Form {
email: String,
username: String,
}
warp::body::content_length_limit(2 * 1024)
.and(warp::ext::get::<DB>())
.and(warp::ext::get::<Mailer>())
.and(warp::body::form())
.and_then(|db, mailer, form: Form| {
logic::auth::register(db, mailer, form.username, form.email).err_to_rejection()
})
.untuple_one()
.and(simple_page("login-ok.html"))
.recover_with_template("register.html", |err: &Compat<Error>| {
let err = err.to_string();
match coerce!(&err => &str) {
r#"new row for relation "users" violates check constraint "name_fmt""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_username"],
vec!["Your username must contain only ASCII letters and digits"],
)),
r#"new row for relation "users" violates check constraint "name_len""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_username"],
vec!["Your username must be at least 3 characters"],
)),
r#"duplicate key value violates unique constraint "users_name_key""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_username"],
vec!["This username is already taken"],
)),
r#"new row for relation "users" violates check constraint "email_fmt""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_email"],
vec!["That doesn't look like an email address..."],
)),
r#"new row for relation "users" violates check constraint "email_len""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_email"],
vec!["That doesn't look like an email address..."],
)),
r#"duplicate key value violates unique constraint "users_email_key""# => Some((
StatusCode::BAD_REQUEST,
vec!["bad_email"],
vec!["This email is alr
```
<Overlap Ratio: 0.9743119266055046>

---

--- 345 --
Question ID: 64d453f90c5f0322b90a2e56396bff644c17bbdd_0
Original Code:
```
fn modifiers_to_gdk_modifier_type(modifiers: Modifiers) -> gdk::ModifierType {
    let mut result = ModifierType::empty();

    result.set(ModifierType::MOD1_MASK, modifiers & M_ALT == M_ALT);
    result.set(ModifierType::CONTROL_MASK, modifiers & M_CTRL == M_CTRL);
    result.set(ModifierType::SHIFT_MASK, modifiers & M_SHIFT == M_SHIFT);
    result.set(ModifierType::META_MASK, modifiers & M_META == M_META);

    result
}
```


Overlapping Code:
```
modifiers: Modifiers) -> gdk::ModifierType {
let mut result = ModifierType::empty();
result.set(ModifierType::MOD1_MASK, modifiers & M_ALT == M_ALT);
result.set(ModifierType::CONTROL_MASK, modifiers & M_CTRL == M_CTRL);
result.set(ModifierType::SHIFT_MASK, modifiers & M_SHIFT == M_SHIFT);
result.set(ModifierType::META_MASK, modifiers & M_META == M_
```
<Overlap Ratio: 0.8771929824561403>

---

--- 346 --
Question ID: 19ceb2daabf7e79eee4b2c2210bf2643a08eb52c_0
Original Code:
```
pub fn files<'a>(args: &ArgMatches<'a>) -> Result<LogStream, Error> {
    let files = args
        .values_of("input")
        .ok_or_else(|| err_msg("Missing input argument"))?
        .map(PathBuf::from)
        .collect::<Vec<PathBuf>>();

    let f = iter_ok::<_, Error>(files)
        .map(|f| {
            File::open(f.clone())
                .map(|s| Decoder::framed(LossyLinesCodec::new(), s))
                .flatten_stream()
                .map(StreamData::Line)
                .map_err(move |e| format_err!("Failed to open {}: {}", f.display(), e))
        })
        .flatten();

    Ok(Box::new(f))
}
```


Overlapping Code:
```
) -> Result<LogStream, Error> {
let files = args
.values_of("input")
.ok_or_else(|| err_msg("Missing input argument"))?
.map(PathBuf::from)
.collect::<Vec<PathBuf>>();
let f = iter_ok::<_, Error>(files)
.map(|f| {
File::open(f.clone())
.map(|s| Decoder::framed(LossyLinesCodec::new(), s))
.flatten_stream()
.map(StreamData::Line)
.map_err(move |e| format_err!("Failed to open {}: {}", f.display(), e)
```
<Overlap Ratio: 0.847457627118644>

---

--- 347 --
Question ID: c10ed2ed122f6a4542f1d037cce05602f68c8c04_3
Original Code:
```
pub fn parse_lambda(args: &List<LispObject>) -> GenResult<ParsedLambda> {
    let no_arglist = || SyntaxError::new("no arglist in lambda");

    let name_or_arglist = args.first().ok_or_else(no_arglist)?;

    let mut name = None;
    let arglist;
    let body;

    if let Ok(sym) = object::to_symbol(name_or_arglist) {
        name = Some(sym.clone());
        arglist = args.iter().nth(1).ok_or_else(no_arglist)?;
        body = args.tailn(2);
    } else {
        arglist = name_or_arglist;
        body = args.tail()
    }

    let arglist =
        object::to_list(arglist).map_err(|_e| SyntaxError::new("lambda arglist in not a list"))?;
    let arglist = arglist
        .iter()
        .map(|lo| {
            object::to_symbol(lo)
                .map(|s| s.clone())
                .map_err(|_e| SyntaxError::new("expected symbol in arglist"))
        })
        .collect::<Result<Vec<_>, _>>()?;

    let (simple_args, restarg) = parse_arglist(arglist)?;

    Ok(ParsedLambda {
        name: name,
        simple_args: simple_args,
        restarg: restarg,
        body: body,
    })
}
```


Overlapping Code:
```
lambda(args: &List<LispObject>) -> GenResult<ParsedLambda> {
let no_arglist = || SyntaxError::new("no arglist in lambda");
let name_or_arglist = args.first().ok_or_else(no_arglist)?;
let mut name = None;
let arglist;
let body;
if let Ok(sym) = object::to_symbol(name_or_arglist) {
name = Some(sym.clone());
arglist = args.iter().nth(1).ok_or_else(no_arglist)?;
body = args.tailn(2);
} else {
arglist = name_or_arglist;
body = args.tail()
}
let arglist =
object::to_list(arglist).map_err(|_e| SyntaxError::new("lambda arglist in not a list"))?;
let arglist = arglist
.iter()
.map(|lo| {
object::to_symbol(lo)
.map(|s| s.clone())
.map_err(|_e| SyntaxError::new("expected symbol in arglist"))
})
.collect::<Result<Vec<_>, _>>()?;
let (simple_args, restarg) = parse_arglist(arglist)?;
Ok(ParsedLambda {
name: name,
simple_args: simple_args,
restarg: rest
```
<Overlap Ratio: 0.9615384615384616>

---

--- 348 --
Question ID: 707201530c4d90617d12d9c9ffeb66d1ca2dbc1a_8
Original Code:
```
pub fn set_option_max_crawl_states(
    service: &ZapService,
    integer: String,
) -> Result<Value, ZapApiError> {
    let mut params = HashMap::new();
    params.insert("Integer".to_string(), integer);
    super::call(
        service,
        "ajaxSpider",
        "action",
        "setOptionMaxCrawlStates",
        params,
    )
}
```


Overlapping Code:
```
_max_crawl_states(
service: &ZapService,
integer: String,
) -> Result<Value, ZapApiError> {
let mut params = HashMap::new();
params.insert("Integer".to_string(), integer);
super::call(
service,
"ajaxSpider",
"action",
"setOptionMaxCrawlStates",
param
```
<Overlap Ratio: 0.9157509157509157>

---

--- 349 --
Question ID: 54b8beb75521418242ccb9c0a2fe6112a22fca18_12
Original Code:
```
fn broken_assert() {
		let mut jdb = new_db();

		// history is 1
		let foo = jdb.insert(EMPTY_PREFIX, b"foo");
		commit_batch(&mut jdb, 1, &keccak(b"1"), Some((0, keccak(b"0")))).unwrap();
		assert!(jdb.can_reconstruct_refs());

		// foo is ancient history.

		jdb.remove(&foo, EMPTY_PREFIX);
		commit_batch(&mut jdb, 2, &keccak(b"2"), Some((1, keccak(b"1")))).unwrap();
		assert!(jdb.can_reconstruct_refs());

		jdb.insert(EMPTY_PREFIX, b"foo");
		commit_batch(&mut jdb, 3, &keccak(b"3"), Some((2, keccak(b"2")))).unwrap();	// BROKEN
		assert!(jdb.can_reconstruct_refs());
		assert!(jdb.contains(&foo, EMPTY_PREFIX));

		jdb.remove(&foo, EMPTY_PREFIX);
		commit_batch(&mut jdb, 4, &keccak(b"4"), Some((3, keccak(b"3")))).unwrap();
		assert!(jdb.can_reconstruct_refs());

		commit_batch(&mut jdb, 5, &keccak(b"5"), Some((4, keccak(b"4")))).unwrap();
		assert!(jdb.can_reconstruct_refs());
		assert!(!jdb.contains(&foo, EMPTY_PREFIX));
	}
```


Overlapping Code:
```
);
// history is 1
let foo = jdb.insert(EMPTY_PREFIX, b"foo");
commit_batch(&mut jdb, 1, &keccak(b"1"), Some((0, keccak(b"0")))).unwrap();
assert!(jdb.can_reconstruct_refs());
// foo is ancient history.
jdb.remove(&foo, EMPTY_PREFIX);
commit_batch(&mut jdb, 2, &keccak(b"2"), Some((1, keccak(b"1")))).unwrap();
assert!(jdb.can_reconstruct_refs());
jdb.insert(EMPTY_PREFIX, b"foo");
commit_batch(&mut jdb, 3, &keccak(b"3"), Some((2, keccak(b"2")))).unwrap(); // BROKEN
assert!(jdb.can_reconstruct_refs());
assert!(jdb.contains(&foo, EMPTY_PREFIX));
jdb.remove(&foo, EMPTY_PREFIX);
commit_batch(&mut jdb, 4, &keccak(b"4"), Some((3, keccak(b"3")))).unwrap();
assert!(jdb.can_reconstruct_refs());
commit_batch(&mut jdb, 5, &keccak(b"5"), Some((4, keccak(b"4")))).unwrap();
assert!(jdb.can_reconstruct_refs());
assert!(!jdb.contains(&foo, EMPTY_PREFIX));
}
```
<Overlap Ratio: 0.9529675251959686>

---

--- 350 --
Question ID: 738d566614aa665f09309550580c3db3be969668_17
Original Code:
```
fn given_u8_byte_then_get_bits_values() {
        let a: u8 = 0xff;
        let b: u8 = 0x00;
        let c: u8 = 0x3a;

        assert_eq!(
            bits_of_byte(a),
            [true, true, true, true, true, true, true, true]
        );
        assert_eq!(
            bits_of_byte(b),
            [false, false, false, false, false, false, false, false]
        );
        assert_eq!(
            bits_of_byte(c),
            [false, false, true, true, true, false, true, false]
        );
    }
```


Overlapping Code:
```
n_u8_byte_then_get_bits_values() {
let a: u8 = 0xff;
let b: u8 = 0x00;
let c: u8 = 0x3a;
assert_eq!(
bits_of_byte(a),
[true, true, true, true, true, true, true, true]
);
assert_eq!(
bits_of_byte(b),
[false, false, false, false, false, false, false, false]
);
assert_eq!(
bits_of_byte(c),
[false, false, true, true, true, false, true, false
```
<Overlap Ratio: 0.9630681818181818>

---

--- 351 --
Question ID: 1d789524c5f4c8e73ac67b243a7f7e4d0d845ffa_28
Original Code:
```
pub fn parse_any_text(
    token_iter: &mut std::iter::Peekable<std::slice::Iter<'_, TokenInfo>>,
) -> bool {
    let token = token_iter.peek();
    if token.is_none() {
        return false;
    }

    match token.unwrap().token_type {
        TokenType::Text(_) => {
            token_iter.next();
            true
        }

        _ => false,
    }
}
```


Overlapping Code:
```
er: &mut std::iter::Peekable<std::slice::Iter<'_, TokenInfo>>,
) -> bool {
let token = token_iter.peek();
if token.is_none() {
return false;
}
match token.unwrap().token_type {
TokenType::Text(_) => {
token_
```
<Overlap Ratio: 0.7582417582417582>

---

--- 352 --
Question ID: 0653e56e889588dca5cd052a94bf4a102e2e4f57_3
Original Code:
```
fn test_register_output_file() {
    let url = Url::parse("https://external-storage.com/filepath?presigned_token").unwrap();
    let crypto_info = FileCrypto::default();

    let request = RegisterOutputFileRequest::new(url.clone(), crypto_info);
    let response = authorized_client().register_output_file(request);
    assert!(response.is_ok());

    let request = RegisterOutputFileRequest::new(url, crypto_info);
    let response = unauthorized_client().register_output_file(request);
    assert!(response.is_err());
}
```


Overlapping Code:
```
gister_output_file() {
let url = Url::parse("https://external-storage.com/filepath?presigned_token").unwrap();
let crypto_info = FileCrypto::default();
let request = RegisterOutputFileRequest::new(url.clone(), crypto_info);
let response = authorized_client().register_output_file(request);
assert!(response.is_ok());
let request = RegisterOutputFileRequest::new(url, crypto_info);
let response = unauthorized_client().register_output_file(request);
assert!(response.is_e
```
<Overlap Ratio: 0.9631147540983607>

---

--- 353 --
Question ID: ed627a81b771f108689e6b15271a322fd57e21ca_0
Original Code:
```
fn main() {
    let args: Vec<String> = ::std::env::args().collect();
    println!("Args: {}", args.len());
    if args.len() >= 2 {
        match &args[1][..] {
            "server" => return server::server::run(args).unwrap(),
            _ => (),
        }
    }

    println!("usage: {} [client | server] ADDRESS", args[0]);
}
```


Overlapping Code:
```
main() {
let args: Vec<String> = ::std::env::args().collect();
println!("Args: {}", args.len());
if args.len() >= 2 {
match &args[1][..] {
"server" => return server::server::run(args).unwrap(),
_ => (),
}
}
println!("usage: {} [client | server] ADDRESS", args[0
```
<Overlap Ratio: 0.9702602230483272>

---

--- 354 --
Question ID: f449b5f70b0618999aa9fc59bcf54fe9477f4b7a_0
Original Code:
```
fn record_intro() {
    let mut codemap = CodeMap::new();
    let context = Context::default();

    let expected_ty = r"Record { t : Type; x : String }";
    let given_expr = r#"record { t = String; x = "hello" }"#;

    let expected_ty = support::parse_nf_term(&mut codemap, &context, expected_ty);
    support::parse_check_term(&mut codemap, &context, given_expr, &expected_ty);
}
```


Overlapping Code:
```
fn record_intro() {
let mut codemap = CodeMap::new();
let context = Context::default();
let expected_ty = r"Record { t : Type; x : String }";
let given_expr = r#"record { t = String; x = "hello" }"#;
let expected_ty = support::parse_nf_term(&mut codemap, &context, expected_ty);
support::parse_check_term(&mut codemap, &context, given_expr, &expected_ty);

```
<Overlap Ratio: 0.9971988795518207>

---

--- 355 --
Question ID: 54f8eee53c19dc6c34a6e481e7b741d565b59d65_3
Original Code:
```
fn test_get_frame_info_loaded() {
        let context = Context::new();
        let path = Path::new("./test/test0.mod");

        load_module(&context, &path);
        start_player(&context, Rate::new(44100), Format::Auto);

        match get_frame_info(&context) {
            Ok(x) => {
                assert_eq!(x.bpm, 125)
            },
            Err(x) => assert_eq!(x.kind, ErrorKind::SelfType(SelfErrorKind::Other))
        }
    }
```


Overlapping Code:
```
_info_loaded() {
let context = Context::new();
let path = Path::new("./test/test0.mod");
load_module(&context, &path);
start_player(&context, Rate::new(44100), Format::Auto);
match get_frame_info(&context) {
Ok(x) => {
assert_eq!(x.bpm, 125)
},
Err(x) => assert_eq!(x.kind, ErrorKind::SelfType(SelfEr
```
<Overlap Ratio: 0.8902077151335311>

---

--- 356 --
Question ID: af2a630995c0e2d564b4d37c8a10b3b0b3deee7d_0
Original Code:
```
fn api_get_response() -> ResponseFuture {
    let data = vec!["foo", "bar"];
    let res = match serde_json::to_string(&data) {
        Ok(json) => {
            Response::builder()
                .header(header::CONTENT_TYPE, "application/json")
                .body(Body::from(json))
                .unwrap()
        }
        Err(_) => {
            Response::builder()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .body(Body::from("Internal Server Error"))
                .unwrap()
        }
    };

    Box::new(future::ok(res))
}
```


Overlapping Code:
```
e() -> ResponseFuture {
let data = vec!["foo", "bar"];
let res = match serde_json::to_string(&data) {
Ok(json) => {
Response::builder()
.header(header::CONTENT_TYPE, "application/json")
.body(Body::from(json))
.unwrap()
}
Err(_) => {
Response::builder()
.status(StatusCode::INTERNAL_SERVER_ERROR)
.body(Body::from("Internal Server Error"))
.unwrap()
}
};
Box::new(future::ok(res)
```
<Overlap Ratio: 0.9475>

---

--- 357 --
Question ID: ad0bba81d73aab9eccc18d3b02aaf45f1cbd9170_0
Original Code:
```
pub(crate) fn generate_include_guard(
    uri: &Url,
    range: Range,
    docs: &Docs,
    wa: &mut WorkspaceAnalysis,
) -> Option<Vec<CodeAction>> {
    let (doc, pos) = from_document_position(&uri, range.start, &docs)?;
    let version = docs.get_version(doc);

    let DocSyntax { text, tokens, .. } = wa.get_syntax(doc)?;

    // カーソルが行頭にあって、最初のトークン以前にあって、文字列やコメントの外であって、インクルードガードがまだないとき。
    let ok = pos.column == 0
        && pos <= tokens.first()?.body_pos16()
        && !wa.in_str_or_comment(doc, pos).unwrap_or(true)
        && !wa.has_include_guard(doc);
    if !ok {
        return None;
    }

    // ファイル名からシンボルを生成する。
    let name = {
        let path = docs.get_uri(doc)?.clone().into_url().to_file_path().ok()?;
        let name = path.file_name()?.to_str()?;
        name.replace(".", "_") + "_included"
    };
    let eol = if text.contains("\r\n") { "\r\n" } else { "\n" };
    let new_text = format!(
        "#ifndef {name}{eol}#define {name}{eol}{eol}#endif{eol}",
        name = name,
        eol = eol,
    );

    Some(vec![CodeAction {
        title: "インクルードガードを生成する".into(),
        kind: Some("refactor.rewrite".into()),
        edit: Some(WorkspaceEdit {
            document_changes: Some(DocumentChanges::Edits(vec![TextDocumentEdit {
                text_document: OptionalVersionedTextDocumentIdentifier {
                    uri: uri.clone(),
                    version,
                },
                edits: vec![OneOf::Left(TextEdit { range, new_text })],
            }])),
            ..WorkspaceEdit::default()
        }),
        ..Default::default()
    }])
}
```


Overlapping Code:
```
clude_guard(
uri: &Url,
range: Range,
docs: &Docs,
wa: &mut WorkspaceAnalysis,
) -> Option<Vec<CodeAction>> {
let (doc, pos) = from_document_position(&uri, range.start, &docs)?;
let version = docs.get_version(doc);
let DocSyntax { text, tokens, .. } = wa.get_syntax(doc)?;
// カーソルが行頭にあって、最初のトークン以前にあって、文字列やコメントの外であって、インクルードガードがまだないとき。
let ok = pos.column == 0
&& pos <= tokens.first()?.body_pos16()
&& !wa.in_str_or_comment(doc, pos).unwrap_or(true)
&& !wa.has_include_guard(doc);
if !ok {
return None;
}
// ファイル名からシンボルを生成する。
let name = {
let path = docs.get_uri(doc)?.clone().into_url().to_file_path().ok()?;
let name = path.file_name()?.to_str()?;
name.replace(".", "_") + "_included"
};
let eol = if text.contains("\r\n") { "\r\n" } else { "\n" };
let new_text = format!(
"#ifndef {name}{eol}#define {name}{eol}{eol}#endif{eol}",
name = name,
eol = eol,
);
Some(vec![CodeAction {
title: "インクルードガードを生成する".into(),
kind: Some("refactor.rewrite".into()),
edit: Some(WorkspaceEdit {
document_changes: Some(DocumentChanges::Edits(vec![TextDocumentEdit {
text_document: OptionalVersionedTextDocumentIdentifier {
uri: uri.clone(),
version,
},
edits: vec![OneOf::Left(TextEdit { range, new_text })],
}])),
..WorkspaceEdit::default()
}),
..Default::default(
```
<Overlap Ratio: 0.9750390015600624>

---

--- 358 --
Question ID: 96c41d09acad5146cfdf35724a2db6aa8f836d1c_1
Original Code:
```
pub fn add_bindings() {
        let out_dir = env::var("OUT_DIR").unwrap();
        let out_path = PathBuf::from(out_dir).join("bindings.rs");
        fs::copy("bindings/yara-3.7.rs", out_path)
            .expect("Could not copy bindings to output directory");
    }
```


Overlapping Code:
```
ings() {
let out_dir = env::var("OUT_DIR").unwrap();
let out_path = PathBuf::from(out_dir).join("bindings.rs");
fs::copy("bindings/yara-3.7.rs", out_path)
.expect("Could not copy bindings to output directory");
```
<Overlap Ratio: 0.9251101321585903>

---

--- 359 --
Question ID: 1d7255d5eb579d7e77aea14b18a2241ab7db1e66_7
Original Code:
```
fn edge_of_unicode_in_utf8() {
        // U+10FFFF is the highest character in unicode. It is in a private use area.
        colored::control::set_override(false);
        let decoding = DecodedString::decode(&[0xF4, 0x8f, 0xBF, 0xBF], UTF_8).unwrap();
        assert_eq!(decoding.format_bytes(), "f4 8f bf bf ");
        assert_eq!(decoding.format_characters(), "10ffff      ");
    }
```


Overlapping Code:
```
the highest character in unicode. It is in a private use area.
colored::control::set_override(false);
let decoding = DecodedString::decode(&[0xF4, 0x8f, 0xBF, 0xBF], UTF_8).unwrap();
assert_eq!(decoding.format_bytes(), "f4 8f bf bf ");
assert_eq!(dec
```
<Overlap Ratio: 0.7440476190476191>

---

--- 360 --
Question ID: 7b350788bb594d096c9ec534f6ed57c1e148fea9_0
Original Code:
```
pub fn public_to_address(public: &Public) -> Address {
	let hash = public.keccak256();
	let mut result = Address::zero();
	result.as_bytes_mut().copy_from_slice(&hash[12..]);
	result
}
```


Overlapping Code:
```
ic_to_address(public: &Public) -> Address {
let hash = public.keccak256();
let mut result = Address::zero();
result.as_bytes_mut().copy_from_slice(&hash[12..]);

```
<Overlap Ratio: 0.8944444444444445>

---

--- 361 --
Question ID: 8c5b3fdbbe30d409022c932d316af6f8511066c9_2
Original Code:
```
fn check_withdraw_unbonded_stake_transaction() {
        let name = "name";
        let passphrase = &SecUtf8::from("passphrase");

        let storage = MemoryStorage::default();
        let signer_manager = WalletSignerManager::new(storage.clone());

        let fee_algorithm = UnitFeeAlgorithm::default();

        let wallet_client = DefaultWalletClient::new_read_only(storage.clone());

        let tendermint_client = MockClient::default();
        let network_ops_client = DefaultNetworkOpsClient::new(
            wallet_client,
            signer_manager,
            tendermint_client,
            fee_algorithm,
            MockTransactionCipher,
        );

        network_ops_client
            .get_wallet_client()
            .new_wallet(name, passphrase, WalletKind::Basic)
            .unwrap();

        let from_address = network_ops_client
            .get_wallet_client()
            .new_staking_address(name, passphrase)
            .unwrap();

        let transaction = network_ops_client
            .create_withdraw_unbonded_stake_transaction(
                name,
                passphrase,
                &from_address,
                vec![TxOut::new(ExtendedAddr::OrTree([0; 32]), Coin::unit())],
                TxAttributes::new(171),
            )
            .unwrap();

        match transaction {
            TxAux::EnclaveTx(TxEnclaveAux::WithdrawUnbondedStakeTx {
                payload: TxObfuscated { txid, .. },
                witness,
                ..
            }) => {
                let account_address = verify_tx_recover_address(&witness, &txid)
                    .expect("Unable to verify transaction");

                assert_eq!(account_address, from_address)
            }
            _ => unreachable!(
                "`create_withdraw_unbonded_stake_transaction()` created invalid transaction type"
            ),
        }
    }
```


Overlapping Code:
```
ithdraw_unbonded_stake_transaction() {
let name = "name";
let passphrase = &SecUtf8::from("passphrase");
let storage = MemoryStorage::default();
let signer_manager = WalletSignerManager::new(storage.clone());
let fee_algorithm = UnitFeeAlgorithm::default();
let wallet_client = DefaultWalletClient::new_read_only(storage.clone());
let tendermint_client = MockClient::default();
let network_ops_client = DefaultNetworkOpsClient::new(
wallet_client,
signer_manager,
tendermint_client,
fee_algorithm,
MockTransactionCipher,
);
network_ops_client
.get_wallet_client()
.new_wallet(name, passphrase, WalletKind::Basic)
.unwrap();
let from_address = network_ops_client
.get_wallet_client()
.new_staking_address(name, passphrase)
.unwrap();
let transaction = network_ops_client
.create_withdraw_unbonded_stake_transaction(
name,
passphrase,
&from_address,
vec![TxOut::new(ExtendedAddr::OrTree([0; 32]), Coin::unit())],
TxAttributes::new(171),
)
.unwrap();
match transaction {
TxAux::EnclaveTx(TxEnclaveAux::WithdrawUnbondedStakeTx {
payload: TxObfuscated { txid, .. },
witness,
..
}) => {
let account_address = verify_tx_recover_address(&witness, &txid)
.expect("Unable to verify transaction");
assert_eq!(account_address, from_address)
}
_ => unreachable!(
"`create_withdraw_unbonded_stake_transaction()` created invalid t
```
<Overlap Ratio: 0.9755192878338279>

---

--- 362 --
Question ID: 2fd7524533968e072b1e6140e86783e83581253d_26
Original Code:
```
fn let_shift_universes_literals() {
    let mut codemap = CodeMap::new();
    let context = Context::default();

    let given_expr = r#"
        let
            id : (a : Type) -> a -> a;
            id a x = x;

            test2 = "hello" : id^1 Type String;
        in
            record {}
    "#;

    support::parse_infer_term(&mut codemap, &context, given_expr);
}
```


Overlapping Code:
```
ls() {
let mut codemap = CodeMap::new();
let context = Context::default();
let given_expr = r#"
let
id : (a : Type) -> a -> a;
id a x = x;
test2 = "hello" : id^1 Type String;
in
record {}
"#;
support::parse_infer_term(&mut codemap, &context, given_expr)
```
<Overlap Ratio: 0.887719298245614>

---

--- 363 --
Question ID: 90c5fc352a93b1bebb27db239274be41b3720df7_1
Original Code:
```
pub fn decrypt_cms(smime: &[u8], pkey: &PKey, x509: &X509) -> Result<Vec<u8>> {
    // now we need to read in that mime file
    let cms = CmsContentInfo::smime_read_cms(smime)
        .chain_err(|| "failed to read cms file")?;

    // and decrypt it's contents
    let p12_der = cms.decrypt(pkey, x509)
        .chain_err(|| "failed to decrypt cms file")?;

    Ok(p12_der)
}
```


Overlapping Code:
```
: &PKey, x509: &X509) -> Result<Vec<u8>> {
// now we need to read in that mime file
let cms = CmsContentInfo::smime_read_cms(smime)
.chain_err(|| "failed to read cms file")?;
// and decrypt it's contents
let p12_der = cms.decrypt(pkey, x509)
.chain_err(|| "failed to decrypt cms file")?;
Ok(p12_der)

```
<Overlap Ratio: 0.8875739644970414>

---

--- 364 --
Question ID: ce8a5b1822c93fa2108de6f1558fa5e22a6dc46f_1
Original Code:
```
fn table_exists_test() {
        let log_context = "table_exists_test";

        tracer(&log_context, "fixtures");
        let local_client = local_client();
        let table_name = table_name_fresh();
        let key_schema = key_schema_a();
        let attribute_definitions = attribute_definitions_a();

        // not exists
        assert!(!table_exists(&log_context, &local_client, &table_name)
            .expect("could not check if table exists"));

        // ensure table
        match ensure_table(
            &log_context,
            &local_client,
            &table_name,
            &key_schema,
            &attribute_definitions,
        ) {
            Ok(_) => {}
            Err(err) => panic!("{:?}", err),
        };

        // exists
        assert!(table_exists(&log_context, &local_client, &table_name)
            .expect("could not check if table exists"));

        // delete
        assert!(delete_table(&log_context, &local_client, &table_name).is_ok());

        // not exists
        assert!(!table_exists(&log_context, &local_client, &table_name)
            .expect("could not check if table exists"));
    }
```


Overlapping Code:
```
sts_test() {
let log_context = "table_exists_test";
tracer(&log_context, "fixtures");
let local_client = local_client();
let table_name = table_name_fresh();
let key_schema = key_schema_a();
let attribute_definitions = attribute_definitions_a();
// not exists
assert!(!table_exists(&log_context, &local_client, &table_name)
.expect("could not check if table exists"));
// ensure table
match ensure_table(
&log_context,
&local_client,
&table_name,
&key_schema,
&attribute_definitions,
) {
Ok(_) => {}
Err(err) => panic!("{:?}", err),
};
// exists
assert!(table_exists(&log_context, &local_client, &table_name)
.expect("could not check if table exists"));
// delete
assert!(delete_table(&log_context, &local_client, &table_name).is_ok());
// not exists
assert!(!table_exists(&log_context, &local_client, &table_name)
.expect("could not check if table exists"
```
<Overlap Ratio: 0.9805269186712485>

---

--- 365 --
Question ID: 8a85ec39c4873751b0aee8e0beea8647338a30fb_24
Original Code:
```
fn decrypt_server_initial_draft28() {
        let mut pkt = [
            0xc9, 0xff, 0x00, 0x00, 0x1c, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50,
            0x2a, 0x42, 0x62, 0xb5, 0x00, 0x40, 0x74, 0x16, 0x8b, 0xf2, 0x2b,
            0x70, 0x02, 0x59, 0x6f, 0x99, 0xae, 0x67, 0xab, 0xf6, 0x5a, 0x58,
            0x52, 0xf5, 0x4f, 0x58, 0xc3, 0x7c, 0x80, 0x86, 0x82, 0xe2, 0xe4,
            0x04, 0x92, 0xd8, 0xa3, 0x89, 0x9f, 0xb0, 0x4f, 0xc0, 0xaf, 0xe9,
            0xaa, 0xbc, 0x87, 0x67, 0xb1, 0x8a, 0x0a, 0xa4, 0x93, 0x53, 0x74,
            0x26, 0x37, 0x3b, 0x48, 0xd5, 0x02, 0x21, 0x4d, 0xd8, 0x56, 0xd6,
            0x3b, 0x78, 0xce, 0xe3, 0x7b, 0xc6, 0x64, 0xb3, 0xfe, 0x86, 0xd4,
            0x87, 0xac, 0x7a, 0x77, 0xc5, 0x30, 0x38, 0xa3, 0xcd, 0x32, 0xf0,
            0xb5, 0x00, 0x4d, 0x9f, 0x57, 0x54, 0xc4, 0xf7, 0xf2, 0xd1, 0xf3,
            0x5c, 0xf3, 0xf7, 0x11, 0x63, 0x51, 0xc9, 0x2b, 0xda, 0x5b, 0x23,
            0xc8, 0x10, 0x34, 0xab, 0x74, 0xf5, 0x4c, 0xb1, 0xbd, 0x72, 0x95,
            0x12, 0x56,
        ];

        let dcid = [0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08];

        let frames = [
            0x0d, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x0a, 0x02, 0x00, 0x00,
            0x56, 0x03, 0x03, 0xee, 0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1,
            0x63, 0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39, 0x88, 0xcf,
            0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d, 0xc5, 0x43, 0x0b, 0x9a, 0x04,
            0x5a, 0x12, 0x00, 0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,
            0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94, 0x0d, 0x89, 0x69,
            0x0b, 0x84, 0xd0, 0x8a, 0x60, 0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68,
            0x4d, 0x10, 0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc, 0xf3,
            0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00, 0x02, 0x03, 0x04,
        ];

        assert_decrypt_initial_pkt(&mut pkt, &dcid, false, &frames, 1, 2);
    }
```


Overlapping Code:
```
pkt = [
0xc9, 0xff, 0x00, 0x00, 0x1c, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50,
0x2a, 0x42, 0x62, 0xb5, 0x00, 0x40, 0x74, 0x16, 0x8b, 0xf2, 0x2b,
0x70, 0x02, 0x59, 0x6f, 0x99, 0xae, 0x67, 0xab, 0xf6, 0x5a, 0x58,
0x52, 0xf5, 0x4f, 0x58, 0xc3, 0x7c, 0x80, 0x86, 0x82, 0xe2, 0xe4,
0x04, 0x92, 0xd8, 0xa3, 0x89, 0x9f, 0xb0, 0x4f, 0xc0, 0xaf, 0xe9,
0xaa, 0xbc, 0x87, 0x67, 0xb1, 0x8a, 0x0a, 0xa4, 0x93, 0x53, 0x74,
0x26, 0x37, 0x3b, 0x48, 0xd5, 0x02, 0x21, 0x4d, 0xd8, 0x56, 0xd6,
0x3b, 0x78, 0xce, 0xe3, 0x7b, 0xc6, 0x64, 0xb3, 0xfe, 0x86, 0xd4,
0x87, 0xac, 0x7a, 0x77, 0xc5, 0x30, 0x38, 0xa3, 0xcd, 0x32, 0xf0,
0xb5, 0x00, 0x4d, 0x9f, 0x57, 0x54, 0xc4, 0xf7, 0xf2, 0xd1, 0xf3,
0x5c, 0xf3, 0xf7, 0x11, 0x63, 0x51, 0xc9, 0x2b, 0xda, 0x5b, 0x23,
0xc8, 0x10, 0x34, 0xab, 0x74, 0xf5, 0x4c, 0xb1, 0xbd, 0x72, 0x95,
0x12, 0x56,
];
let dcid = [0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08];
let frames = [
0x0d, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x0a, 0x02, 0x00, 0x00,
0x56, 0x03, 0x03, 0xee, 0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1,
0x63, 0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39, 0x88, 0xcf,
0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d, 0xc5, 0x43, 0x0b, 0x9a, 0x04,
0x5a, 0x12, 0x00, 0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,
0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94, 0x0d, 0x89, 0x69,
0x0b, 0x84, 0xd0, 0x8a, 0x60, 0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68,
0x4d, 0x10, 0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc, 0xf3,
0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00, 0x02, 0x03, 0x04,
];
assert_decrypt_initial_pkt(&mut pkt, &dcid, false, &frames, 1, 2);
}
```
<Overlap Ratio: 0.9711779448621554>

---

--- 366 --
Question ID: ddfa5c7090f7a002f54a5495b9709a608fa6affe_10
Original Code:
```
fn read_inner_header_field<R: Read>(input: &mut R, database: &mut PwDatabase, kdbx: &mut Kdbx, buffer: &mut Vec<u8>) -> Result<bool, Error> {
    let field_id = ioutil::io_read_u8(input)?;
    let size = ioutil::io_read_i32(input)?;

    println!("INNER HEADER ITEM: {}, {} ({})", field_id, size, size as usize);

    if size < 0 {
        return Err(Error::BadFormat("File Corrupted (inner header field size)"));
    } else {
        buffer.resize(size as usize, 0);
        input.read_exact(&mut buffer[0..(size as usize)]).map_err(|e| Error::IO(e))?;
    }

    let data = &buffer[0..(size as usize)];

    let mut result = true;

    match KdbxInnerHeaderFieldID::from_bits(field_id) {
        Some(KdbxInnerHeaderFieldID::END_OF_HEADER) => {
            result = false; // returning false indicates the end of the header
        },

        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_ID) => {
            let stream_id = memutil::bytes_to_u32(data);
            if let Some(alg) = CrsAlgorithm::from_int(stream_id) {
                kdbx.inner_random_stream_algorithm = alg;
            } else {
                return Err(Error::BadFormat("Unknown stream cipher algorithm."));
            }
            debug_println!("Set InnerRandomStreamID. (inner header)");
        },

        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_KEY) => {
            kdbx.inner_random_stream_key = ProtectedBinary::copy_slice(data);
            debug_println!("Set InnerRandomStreamKey. (inner header)");
            database.context.crypto_random.add_entropy(data);
        },

        Some(KdbxInnerHeaderFieldID::BINARY) => {
            debug_println!("Added binary with length: {}", data.len());
            kdbx.binaries.push(ProtectedBinary::copy_slice(data));
        },

        Some(_) => {
            debug_println!("Unhandled Known Inner Header ID: {:b}", field_id);
        },

        _ => {
            debug_println!("Unknown Inner Header ID: {:b}", field_id);
        }
    }

    Ok(result)
}
```


Overlapping Code:
```
R: Read>(input: &mut R, database: &mut PwDatabase, kdbx: &mut Kdbx, buffer: &mut Vec<u8>) -> Result<bool, Error> {
let field_id = ioutil::io_read_u8(input)?;
let size = ioutil::io_read_i32(input)?;
println!("INNER HEADER ITEM: {}, {} ({})", field_id, size, size as usize);
if size < 0 {
return Err(Error::BadFormat("File Corrupted (inner header field size)"));
} else {
buffer.resize(size as usize, 0);
input.read_exact(&mut buffer[0..(size as usize)]).map_err(|e| Error::IO(e))?;
}
let data = &buffer[0..(size as usize)];
let mut result = true;
match KdbxInnerHeaderFieldID::from_bits(field_id) {
Some(KdbxInnerHeaderFieldID::END_OF_HEADER) => {
result = false; // returning false indicates the end of the header
},
Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_ID) => {
let stream_id = memutil::bytes_to_u32(data);
if let Some(alg) = CrsAlgorithm::from_int(stream_id) {
kdbx.inner_random_stream_algorithm = alg;
} else {
return Err(Error::BadFormat("Unknown stream cipher algorithm."));
}
debug_println!("Set InnerRandomStreamID. (inner header)");
},
Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_KEY) => {
kdbx.inner_random_stream_key = ProtectedBinary::copy_slice(data);
debug_println!("Set InnerRandomStreamKey. (inner header)");
database.context.crypto_random.add_entropy(data);
},
Some(KdbxInnerHeaderFieldID::BINARY) => {
debug_println!("Added binary with length: {}", data.len());
kdbx.binaries.push(ProtectedBinary::copy_slice(data));
},
Some(_) => {
debug_println!("Unhandled Known Inner Header ID: {:b}", field_id);
},
_ => {
debug_println!("Unknown Inner Header ID: {:b}", field_id);
}
}
Ok
```
<Overlap Ratio: 0.9775212636695019>

---

--- 367 --
Question ID: aef2ef5c2b69a79c8bd960a4d436d5edb1a15ab5_2
Original Code:
```
fn test_put_with_err() {
        let config = Config::new();
        // New engine lack of some column families.
        let engine = engine::new_local_engine(&config.path, &["default"]).unwrap();
        let mut storage = Storage::from_engine(engine, &config).unwrap();
        storage.start(&config).unwrap();
        let (tx, rx) = channel();
        storage.async_prewrite(Context::new(),
                            vec![
            Mutation::Put((make_key(b"a"), b"aa".to_vec())),
            Mutation::Put((make_key(b"b"), b"bb".to_vec())),
            Mutation::Put((make_key(b"c"), b"cc".to_vec())),
            ],
                            b"a".to_vec(),
                            1,
                            Options::default(),
                            expect_fail(tx.clone()))
            .unwrap();
        rx.recv().unwrap();
        storage.stop().unwrap();
    }
```


Overlapping Code:
```
_with_err() {
let config = Config::new();
// New engine lack of some column families.
let engine = engine::new_local_engine(&config.path, &["default"]).unwrap();
let mut storage = Storage::from_engine(engine, &config).unwrap();
storage.start(&config).unwrap();
let (tx, rx) = channel();
storage.async_prewrite(Context::new(),
vec![
Mutation::Put((make_key(b"a"), b"aa".to_vec())),
Mutation::Put((make_key(b"b"), b"bb".to_vec())),
Mutation::Put((make_key(b"c"), b"cc".to_vec())),
],
b"a".to_vec(),
1,
Options::default(),
expect_fail(tx.clone()))
.unwrap();
rx.recv().unwrap();
storage.stop().unwrap();
```
<Overlap Ratio: 0.9787928221859706>

---

--- 368 --
Question ID: b45b03cd956ff41ab46eea2227102a13d91b54a4_0
Original Code:
```
fn test_fetch_problem_list() {
        let client = CodeChefClient::default();
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Beginner)).is_ok());
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Easy)).is_ok());
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Medium)).is_ok());
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Hard)).is_ok());
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Challenge)).is_ok());
        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Peer)).is_ok());
    }
```


Overlapping Code:
```
etch_problem_list() {
let client = CodeChefClient::default();
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Beginner)).is_ok());
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Easy)).is_ok());
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Medium)).is_ok());
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Hard)).is_ok());
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Challenge)).is_ok());
assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Peer)).i
```
<Overlap Ratio: 0.9666080843585237>

---

--- 369 --
Question ID: 771d01cffd9eed813c254422d7edf92b8f5f8dd7_0
Original Code:
```
fn test_types_are_creatable() {
    let i = number!(3);
    assert_eq!("3".to_string(), format!("{:?}", i));
    assert_eq!(false, i.is_reducible());

    let i = add!(number!(3), number!(4));
    assert_eq!("3 + 4".to_string(), format!("{:?}", i));
    assert_eq!(true, i.is_reducible());

    let i = multiply!(
        add!(number!(3), number!(4)),
        number!(2));
    assert_eq!("3 + 4 * 2".to_string(), format!("{:?}", i));
    assert_eq!(true, i.is_reducible());

    let i = boolean!(true);
    assert_eq!("true".to_string(), format!("{:?}", i));
    assert_eq!(false, i.is_reducible());

    let i = less_than!(number!(2), number!(3));
    assert_eq!("2 < 3".to_string(), format!("{:?}", i));
    assert_eq!(true, i.is_reducible());
}
```


Overlapping Code:
```
n test_types_are_creatable() {
let i = number!(3);
assert_eq!("3".to_string(), format!("{:?}", i));
assert_eq!(false, i.is_reducible());
let i = add!(number!(3), number!(4));
assert_eq!("3 + 4".to_string(), format!("{:?}", i));
assert_eq!(true, i.is_reducible());
let i = multiply!(
add!(number!(3), number!(4)),
number!(2));
assert_eq!("3 + 4 * 2".to_string(), format!("{:?}", i));
assert_eq!(true, i.is_reducible());
let i = boolean!(true);
assert_eq!("true".to_string(), format!("{:?}", i));
assert_eq!(false, i.is_reducible());
let i = less_than!(number!(2), number!(3));
assert_eq!("2 < 3".to_string(), format!("{:?}", i));
assert_eq!(true, i.is_
```
<Overlap Ratio: 0.9760119940029985>

---

--- 370 --
Question ID: b4dd3973523698a0f050c7f709a7bd07349d8f78_3
Original Code:
```
pub unsafe extern "C" fn mi_heap_malloc(mut heap: *mut mi_heap_t,
                                        mut size: usize) -> *mut c_void {
    if !heap.is_null() {
        0
    } else {
        _mi_assert_fail("heap!=NULL", "src/alloc.c", 66, "mi_heap_malloc")
    } // heaps are thread local
    if heap.thread_id == 0 || heap.thread_id == _mi_thread_id() {
        0
    } else {
        _mi_assert_fail("heap->thread_id == 0 || heap->thread_id == _mi_thread_id()",
                        "src/alloc.c", 67, "mi_heap_malloc")
    } // overestimate for aligned sizes
    let mut p: *mut c_void;
    if __builtin_expect((size <= MI_SMALL_SIZE_MAX), 1) != 0 {
        p = mi_heap_malloc_small(heap, size);
    } else { p = _mi_malloc_generic(heap, size); }
    if !p.is_null() {
        if !mi_heap_is_initialized(heap) { heap = mi_get_default_heap(); }
        _mi_stat_increase(&mut ((heap).tld.stats.malloc), mi_good_size(size));
    }
    return p;
}
```


Overlapping Code:
```
ap_malloc(mut heap: *mut mi_heap_t,
mut size: usize) -> *mut c_void {
if !heap.is_null() {
0
} else {
_mi_assert_fail("heap!=NULL", "src/alloc.c", 66, "mi_heap_malloc")
} // heaps are thread local
if heap.thread_id == 0 || heap.thread_id == _mi_thread_id() {
0
} else {
_mi_assert_fail("heap->thread_id == 0 || heap->thread_id == _mi_thread_id()",
"src/alloc.c", 67, "mi_heap_malloc")
} // overestimate for aligned sizes
let mut p: *mut c_void;
if __builtin_expect((size <= MI_SMALL_SIZE_MAX), 1) != 0 {
p = mi_heap_malloc_small(heap, size);
} else { p = _mi_malloc_generic(heap, size); }
if !p.is_null() {
if !mi_heap_is_initialized(heap) { heap = mi_get_default_heap(); }
_mi_stat_increase(&mut ((heap).tld.stats.malloc), mi_good_size(size));
}
ret
```
<Overlap Ratio: 0.9517766497461929>

---

--- 371 --
Question ID: 54fab6b6c5be235d38e2ca03ba98a85d03f5e074_0
Original Code:
```
fn find_best_phase_setting(run: fn(&IntcodeMachine, &Vec<Value>) -> Value, range: std::ops::Range<Value>, template: &IntcodeMachine) -> (Value, Vec<Value>) {
    let mut max = 0;
    let mut best_phase_setting = vec![];
    for perm in range.permutations(5) {
        let output = run(&template, &perm);
        if output > max {
            max = output;
            best_phase_setting = perm;
        }
    }
    (max, best_phase_setting)
}
```


Overlapping Code:
```
n find_best_phase_setting(run: fn(&IntcodeMachine, &Vec<Value>) -> Value, range: std::ops::Range<Value>, template: &IntcodeMachine) -> (Value, Vec<Value>) {
let mut max = 0;
let mut best_phase_setting = vec![];
for perm in range.permutations(5) {
let output = run(&template, &perm);
if output > max {
max = output;
best_phase_setting = perm;
}
}
(max
```
<Overlap Ratio: 0.9358288770053476>

---

--- 372 --
Question ID: feefd8a0a21a9cfdbf9578926fbaebfe0518c14c_6
Original Code:
```
fn test_ecp_mul_add() {
        let mut group1 = EcGroup::new(EcGroupId::SecP256R1).unwrap();
        let mut group2 = group1.clone();

        let g = group1.generator().unwrap();

        let k1 = Mpi::new(1212238156).unwrap();
        let k2 = Mpi::new(1163020627).unwrap();

        // Test that k1*g + k2*g == k2*g + k1*g
        let pt1 = EcPoint::muladd(&mut group1, &g, &k2, &g, &k1).unwrap();
        let pt2 = EcPoint::muladd(&mut group2, &g, &k1, &g, &k2).unwrap();
        assert_eq!(pt1.eq(&pt2).unwrap(), true);

        let pt3 = pt1.clone();
        assert_eq!(pt2.eq(&pt3).unwrap(), true);
    }
```


Overlapping Code:
```
add() {
let mut group1 = EcGroup::new(EcGroupId::SecP256R1).unwrap();
let mut group2 = group1.clone();
let g = group1.generator().unwrap();
let k1 = Mpi::new(1212238156).unwrap();
let k2 = Mpi::new(1163020627).unwrap();
// Test that k1*g + k2*g == k2*g + k1*g
let pt1 = EcPoint::muladd(&mut group1, &g, &k2, &g, &k1).unwrap();
let pt2 = EcPoint::muladd(&mut group2, &g, &k1, &g, &k2).unwrap();
assert_eq!(pt1.eq(&pt2).unwrap(), true);
let pt3 = pt1.clone();
assert_eq!(pt2.eq(&pt3).unwrap(), true);
}
```
<Overlap Ratio: 0.9689922480620154>

---

--- 373 --
Question ID: 1d788a0244e453936f43adcf7a42c031a678d1c8_0
Original Code:
```
pub fn get_test_config() -> (NodeConfig, KeyPair<Ed25519PrivateKey, Ed25519PublicKey>) {
    let mut config = NodeConfig::random();
    config.randomize_ports();

    // Get a deterministic seed per process, as many tests expect the same genesis keys
    let base_seed = process::id().to_be_bytes();
    let mut seed = [0u8; 32];
    seed[..base_seed.len()].clone_from_slice(&base_seed[..]);
    let mut rng = StdRng::from_seed(seed);

    let private_key = Ed25519PrivateKey::generate_for_testing(&mut rng);
    let keypair: KeyPair<Ed25519PrivateKey, Ed25519PublicKey> = KeyPair::from(private_key);
    let network_peers = &config.validator_network.as_ref().unwrap().network_peers;

    config.execution.genesis = Some(Transaction::UserTransaction(
        vm_genesis::encode_genesis_transaction_with_validator(
            &keypair.private_key,
            keypair.public_key.clone(),
            config
                .consensus
                .consensus_peers
                .get_validator_set(network_peers),
        )
        .into_inner(),
    ));

    (config, keypair)
}
```


Overlapping Code:
```
 fn get_test_config() -> (NodeConfig, KeyPair<Ed25519PrivateKey, Ed25519PublicKey>) {
let mut config = NodeConfig::random();
config.randomize_ports();
// Get a deterministic seed per process, as many tests expect the same genesis keys
let base_seed = process::id().to_be_bytes();
let mut seed = [0u8; 32];
seed[..base_seed.len()].clone_from_slice(&base_seed[..]);
let mut rng = StdRng::from_seed(seed);
let private_key = Ed25519PrivateKey::generate_for_testing(&mut rng);
let keypair: KeyPair<Ed25519PrivateKey, Ed25519PublicKey> = KeyPair::from(private_key);
let network_peers = &config.validator_network.as_ref().unwrap().network_peers;
config.execution.genesis = Some(Transaction::UserTransaction(
vm_genesis::encode_genesis_transaction_with_validator(
&keypair.private_key,
keypair.public_key.clone(),
config
.consensus
.consensus_peers
.get_validator_set(network_peers),
)
.into_inner(),
));
(config
```
<Overlap Ratio: 0.9836779107725789>

---

--- 374 --
Question ID: 8e91021cb3f6a08dd98a933c36ee5026f00bfba4_3
Original Code:
```
fn lengths() {
    let mut s: LendingLibrary<i64, i64> = LendingLibrary::new();
    assert_eq!(s.len(), 0);
    assert!(s.is_empty());
    s.insert(1, 1);
    s.insert(2, 1);
    assert_eq!(s.len(), 2);
    assert!(!s.is_empty());
    {
        let _v = s.lend(&1);
        assert_eq!(s.len(), 2);
        assert!(!s.is_empty());
        s.remove(&1);
        assert_eq!(s.len(), 1);
        assert!(!s.is_empty());
        s.clear();
    }
    assert_eq!(s.len(), 0);
    assert!(s.is_empty());
}
```


Overlapping Code:
```
 mut s: LendingLibrary<i64, i64> = LendingLibrary::new();
assert_eq!(s.len(), 0);
assert!(s.is_empty());
s.insert(1, 1);
s.insert(2, 1);
assert_eq!(s.len(), 2);
assert!(!s.is_empty());
{
let _v = s.lend(&1);
assert_eq!(s.len(), 2);
assert!(!s.is_empty());
s.remove(&1);
assert_eq!(s.len(), 1);
assert!(!s.is_empty());
s.clear();
}
assert_eq!(s.len(),
```
<Overlap Ratio: 0.8816120906801007>

---

--- 375 --
Question ID: 84bf3aac3bc463604d597c6390aa6a7eafcf7749_0
Original Code:
```
fn new_should_assign_origin_and_direction() {
        let origin = Xyz::new(3.0, 4.4, 1.0);
        let direction = Xyz::new(5.0, -2.1, 2.0);

        let ray = Ray::new(origin.clone(), direction.clone());

        assert_eq!(ray.origin, origin);
        assert_eq!(ray.direction, direction);
        assert_eq!("Ray { origin: Xyz { x: 3.0, y: 4.4, z: 1.0 }, direction: Xyz { x: 5.0, y: -2.1, z: 2.0 } }",
            format!("{:?}", ray));
    }
```


Overlapping Code:
```
_direction() {
let origin = Xyz::new(3.0, 4.4, 1.0);
let direction = Xyz::new(5.0, -2.1, 2.0);
let ray = Ray::new(origin.clone(), direction.clone());
assert_eq!(ray.origin, origin);
assert_eq!(ray.direction, direction);
assert_eq!("Ray { origin: Xyz { x: 3.0, y: 4.4, z: 1.0 }, direction: Xyz { x: 5.
```
<Overlap Ratio: 0.7894736842105263>

---

--- 376 --
Question ID: 41c90c2cd1d2cd60d973394720f52d1df142125d_0
Original Code:
```
fn test_non_bmp() {
        let gil = Python::acquire_gil();
        let py = gil.python();
        let s = "\u{1F30F}";
        let py_string = s.to_object(py);
        assert_eq!(s, py_string.extract::<String>(py).unwrap());
    }
```


Overlapping Code:
```
_bmp() {
let gil = Python::acquire_gil();
let py = gil.python();
let s = "\u{1F30F}";
let py_string = s.to_object(py);
assert_eq!(s, py_string.extract::<String>(py
```
<Overlap Ratio: 0.8670212765957447>

---

--- 377 --
Question ID: a7c8edf50102a79a2cd1e1106b5eb3ae8f8add54_2
Original Code:
```
fn splice<'a>(env: &'a Env, this: Value<'a, Object>, args: &[Value<'a, Any>]) -> Result<Option<Value<'a, Any>>> {
        let start: usize = args[0].try_into()?.into();
        let count: usize = args[1].try_into()?.into();
        let new_text: Vec<u16> = args[2].try_into()?.into();

        let buffer: &Rc<RefCell<Buffer>> = env.unwrap(&this)?;
        buffer.borrow_mut().splice(start..(start + count), new_text);

        Ok(None)
    }
```


Overlapping Code:
```
splice<'a>(env: &'a Env, this: Value<'a, Object>, args: &[Value<'a, Any>]) -> Result<Option<Value<'a, Any>>> {
let start: usize = args[0].try_into()?.into();
let count: usize = args[1].try_into()?.into();
let new_text: Vec<u16> = args[2].try_into()?.into();
let buffer: &Rc<RefCell<Buffer>> = env.unwrap(&this)?;
buffer.borrow_mut().splice(start..(start + count), new_t
```
<Overlap Ratio: 0.9510309278350515>

---

--- 378 --
Question ID: e1deaebe3f255077e6cb2fda6b0daeb0a45c3ba8_1
Original Code:
```
fn main() {
    let matches = App::new("Raytracer")
        .about("Raytracer in Rust from Peter Shirley's Raytracing in One Weekend")
        .arg(
            Arg::with_name("output")
                .short("o")
                .long("output")
                .value_name("FILE")
                .takes_value(true)
                .help("Output file. If not specified, wrties to stdout."),
        )
        .arg(
            Arg::with_name("samples")
                .short("s")
                .long("samples")
                .takes_value(true)
                .help("Number of samples per pixel")
                .default_value("100"),
        )
        .arg(
            Arg::with_name("threads")
                .short("t")
                .long("threads")
                .takes_value(true)
                .help("Number of threads to run")
                .default_value("1"),
        )
        .arg(
            Arg::with_name("x_res")
                .short("x")
                .long("x_res")
                .takes_value(true)
                .help("Width of trace in pixels")
                .default_value("200"),
        )
        .arg(
            Arg::with_name("y_res")
                .short("y")
                .long("y_res")
                .takes_value(true)
                .help("Height of trace in pixels")
                .default_value("100"),
        )
        .get_matches();

    let x_res: u32 = matches.value_of("x_res").unwrap().parse().unwrap();
    let y_res: u32 = matches.value_of("y_res").unwrap().parse().unwrap();
    let num_samples: u32 = matches.value_of("samples").unwrap().parse().unwrap();
    let num_threads: u32 = matches.value_of("threads").unwrap().parse().unwrap();
    let output = matches.value_of("output");

    let lookfrom = Vector3::new(13.0, 2.0, 3.0);
    let lookat = Vector3::new(0.0, 0.0, 0.0);
    let vup = Vector3::new(0.0, 1.0, 0.0);
    let dist_to_focus = (lookfrom - lookat).length();
    let aperture = 0.1;
    let cam = Camera::new(
        lookfrom,
        lookat,
        vup,
        30.0,
        x_res as f32 / y_res as f32,
        aperture,
        dist_to_focus,
    );

    let hitable_list = random_scene();
    let bvh = BVHNode::new(hitable_list.hitables.clone());

    let mut thread_handles = Vec::new();
    let result = Arc::new(Mutex::new(Vec::new()));
    let samples_per_thread = num_samples / num_threads;

    for _ in 0..num_threads {
        let mut thread_output = Vec::new();
        let bvh_clone = bvh.clone();
        let result = Arc::clone(&result);
        // TODO Handle exceptions + num_samples not divisible by num_threads
        thread_handles.push(thread::spawn(move || {
            for j in (0..y_res).rev() {
                for i in 0..x_res {
                    let mut col = Vector3::new(0.0, 0.0, 0.0);
                    for _s in 0..samples_per_thread {
                        let u_rand = random::random_in_unit_interval();
                        let v_rand = random::random_in_unit_interval();
                        let u = (i as f32 + u_rand) / x_res as f32;
                        let v = (j as f32 + v_rand) / y_res as f32;
                        let ray = cam.get_ray(u, v);
                        col = col + color(&ray, &bvh_clone, 0);
                    }
                    col = col / num_samples as f32;
                    thread_output.push(col);
                    // Do averaging in th thread
                    // Then the final average at the end
                }
            }
            let mut l_result = result.lock().unwrap();
            if l_result.len() == 0 {
                *l_result = thread_output;
            } else {
                *l_result = l_result
                    .iter()
                    .zip(thread_output.iter())
                    .map(|(a, b)| a + b)
                    .collect();
            }
        }));
    }

    for thread in thread_handles {
        thread.join().unwrap();
    }

    let mut output_buffer: Vec<u8> = Vec::with_capacity(x_res as usize * y_res as usize * 3);

    // Should buffer and only write to the file at the end
    for col in result.lock().unwrap().iter() {
        let out_colour = Vector3::new(
            (255.99 * col.r().sqrt()).floor(),
            (255.99 * col.g().sqrt()).floor(),
            (255.99 * col.b().sqrt()).floor(),
        );

        output_buffer.push(out_colour.r() as u8);
        output_buffer.push(out_colour.g() as u8);
        output_buffer.push(out_colour.b() as u8);
    }

    image_out::write_image(output, &output_buffer, x_res, y_res);
}
```


Overlapping Code:
```
es = App::new("Raytracer")
.about("Raytracer in Ru)
.arg(
Arg::with_name("output")
.short("o")
.long("output")
.value_name("FILE")
.takes_value(true)
.help("Output file. If not specified, wrties to stdout."),
)
.arg(
Arg::with_name("samples")
.short("s")
.long("samples")
.takes_value(true)
.help("Number of samples per pixel")
.default_value("100"),
)
.arg(
Arg::with_name("threads")
.short("t")
.long("threads")
.takes_value(true)
.help("Number of threads to run")
.default_value("1"),
)
.arg(
Arg::with_name("x_res")
.short("x")
.long("x_res")
.takes_value(true)
.help("Width of trace in pixels")
.default_value("200"),
)
.arg(
Arg::with_name("y_res")
.short("y")
.long("y_res")
.takes_value(true)
.help("Height of trace in pixels")
.default_value("100"),
)
.get_matches();
let x_res: u32 = matches.value_of("x_res").unwrap().parse().unwrap();
let y_res: u32 = matches.value_of("y_res").unwrap().parse().unwrap();
let num_samples: u32 = matches.value_of("samples").unwrap().parse().unwrap();
let num_threads: u32 = matches.value_of("threads").unwrap().parse().unwrap();
let output = matches.value_of("output");
let lookfrom = Vector3::new(13.0, 2.0, 3.0);
let lookat = Vector3::new(0.0, 0.0, 0.0);
let vup = Vector3::new(0.0, 1.0, 0.0);
let dist_to_focus = (lookfrom - lookat).length();
let aperture = 0.1;
let cam = Camera::new(
lookfrom,
lookat,
vup,
30.0,
x_res as f32 / y_res as f32,
aperture,
dist_to_focus,
);
let hitable_list = random_scene();
let bvh = BVHNode::new(hitable_list.hitables.clone());
let mut thread_handles = Vec::new();
let result = Arc::new(Mutex::new(Vec::new()));
let samples_per_thread = num_samples / num_threads;
for _ in 0..num_threads {
let mut thread_output = Vec::new();

```
<Overlap Ratio: 0.9536312849162011>

---

--- 379 --
Question ID: 6b7315f81f184920c72a1f75fe6e92f1832af6e7_2
Original Code:
```
pub fn part2(lines: &Vec<String>) -> i64 {
    assert_eq!(lines.len(), 2);
    let grid1 = follow_line(&lines[0]);
    let grid2 = follow_line(&lines[1]);

    let mut best = -1;
    for (xy, v1) in grid1 {
        match grid2.get(&xy) {
            Some(&v2) => {
                let dist = v1 + v2;
                if best == -1 || dist < best {
                    best = dist;
                }
            }
            _ => {}
        }
    }
    return best;
}
```


Overlapping Code:
```
ines: &Vec<String>) -> i64 {
assert_eq!(lines.len(), 2);
let grid1 = follow_line(&lines[0]);
let grid2 = follow_line(&lines[1]);
let mut best = -1;
for (xy, v1) in grid1 {
match grid2.get(&xy) {
Some(&v2) => {
let dist = v1 + v2;
if best == -1 || dist < best {
best = dist;
}
}
_ => {}
}
}
return bes
```
<Overlap Ratio: 0.9433962264150944>

---

--- 380 --
Question ID: ad1c4145b2bbc700d25cc902d5247fcd981d6f2c_3
Original Code:
```
fn test_get_current_url() {
    let mut driver = WebDriver::new(Browser::Chrome);
    driver.start_session();
    driver.navigate("http://google.com");
    let url = driver.get_current_url().unwrap();
    assert!(
        driver.get_current_url().unwrap() == String::from("https://www.google.com/?gws_rd=ssl")
    );
}
```


Overlapping Code:
```
t_current_url() {
let mut driver = WebDriver::new(Browser::Chrome);
driver.start_session();
driver.navigate("http://google.com");
let url = driver.get_current_url().unwrap();
assert!(
driver.get_current_url().unwrap() == String::from("https://www.google.com/?gws_rd=
```
<Overlap Ratio: 0.9300699300699301>

---

--- 381 --
Question ID: 21a036a24be53e507c8f939654a8bc32af1477a1_0
Original Code:
```
fn on_visibility_change() {
    let window = window().unwrap();
    let document = window.document().unwrap();

    if document.visibility_state() == VisibilityState::Visible {
        document.set_title(DEFAULT_TITLE);
    }
}
```


Overlapping Code:
```

let window = window().unwrap();
let document = window.document().unwrap();
if document.visibility_state() == VisibilityState::Visible {
document.set_title(DEFAULT_T
```
<Overlap Ratio: 0.8168316831683168>

---

--- 382 --
Question ID: 6327e1705088064d49c202c7f7c32ea0df70277d_0
Original Code:
```
pub fn verify_marking(
    young: &YoungGen,
    old_protected: &OldGenProtected,
    large: &LargeSpace,
    heap: Region,
) {
    for region in &old_protected.regions {
        let active = region.active_region();
        verify_marking_region(active, heap);
    }

    let eden = young.eden_active();
    verify_marking_region(eden, heap);

    let from = young.from_active();
    verify_marking_region(from, heap);

    let to = young.to_active();
    verify_marking_region(to, heap);

    large.visit_objects(|obj_address| {
        verify_marking_object(obj_address, heap);
    });
}
```


Overlapping Code:
```
rking(
young: &YoungGen,
old_protected: &OldGenProtected,
large: &LargeSpace,
heap: Region,
) {
for region in &old_protected.regions {
let active = region.active_region();
verify_marking_region(active, heap);
}
let eden = young.eden_active();
verify_marking_region(eden, heap);
let from = young.from_active();
verify_marking_region(from, heap);
let to = young.to_active();
verify_marking_region(to, heap);
large.visit_objects(|obj_address| {
verify_m
```
<Overlap Ratio: 0.8910891089108911>

---

--- 383 --
Question ID: ce0e2c840fb308e77b8479ebf63837c612040a52_0
Original Code:
```
pub fn add_two_numbers(
    l1: Option<Box<ListNode>>,
    l2: Option<Box<ListNode>>,
) -> Option<Box<ListNode>> {
    let mut dummy = Box::new(ListNode::new(0));
    // Secondary pointer
    let mut cur = &mut dummy;
    let mut sum = 0;

    let mut l1 = l1.as_ref();
    let mut l2 = l2.as_ref();
    while l1.is_some() || l2.is_some() {
        match l1 {
            Some(ref node) => {
                sum += node.val;
                l1 = l1.unwrap().next.as_ref();
                // or
                // l1 = l1.map(|n| n.next.as_ref()).unwrap_or(None);
            }
            None => {}
        }

        match l2 {
            Some(ref node) => {
                sum += node.val;
                l2 = l2.unwrap().next.as_ref();
            }
            None => {}
        }

        cur.next = Some(Box::new(ListNode::new(sum % 10)));
        sum /= 10;
        cur = cur.next.as_mut().unwrap();
    }

    if sum != 0 {
        cur.next = Some(Box::new(ListNode::new(1)));
    }

    dummy.next
}
```


Overlapping Code:
```
pub fn add_two_numbers(
l1: Option<Box<ListNode>>,
l2: Option<Box<ListNode>>,
) -> Option<Box<ListNode>> {
let mut dummy = Box::new(ListNode::new(0));
// Secondary pointer
let mut cur = &mut dummy;
let mut sum = 0;
let mut l1 = l1.as_ref();
let mut l2 = l2.as_ref();
while l1.is_some() || l2.is_some() {
match l1 {
Some(ref node) => {
sum += node.val;
l1 = l1.unwrap().next.as_ref();
// or
// l1 = l1.map(|n| n.next.as_ref()).unwrap_or(None);
}
None => {}
}
match l2 {
Some(ref node) => {
sum += node.val;
l2 = l2.unwrap().next.as_ref();
}
None => {}
}
cur.next = Some(Box::new(ListNode::new(sum % 10)));
sum /= 10;
cur = cur.next.as_mut().unwrap();
}
if sum != 0 {
cur.next = Some(Box::
```
<Overlap Ratio: 0.9475862068965517>

---

