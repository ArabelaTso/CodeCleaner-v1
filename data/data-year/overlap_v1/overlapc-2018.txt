--- 0 --
Question ID: 8a9fa109cb725cdbe8db5306a784001c3d1c1dce_0
Original Code:
```
int main(void)
{

	parent_pid = getpid();
	printf("Parent PID=%d\n", parent_pid);
	if (fork() == 0) {
		child_pid = getpid();
		printf("Child PID=%d\n", child_pid);
		return 0;
	}
	sleep(1);
	return 0;
}
```


Overlapping Code:
```
in(void)
{
parent_pid = getpid();
printf("Parent PID=%d\n", parent_pid);
if (fork() == 0) {
child_pid = getpid();
printf("Child PID=%d\n", child_pid);
```
<Overlap Ratio: 0.7894736842105263>

---

--- 1 --
Question ID: 66dc99495ba4a8aa3f108e866fea970eed5ffa82_60
Original Code:
```
ssize_t
virStorageFileReadHeader(virStorageSourcePtr src,
                         ssize_t max_len,
                         char **buf)
{
    ssize_t ret;

    if (!virStorageFileIsInitialized(src)) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                       _("storage file backend not initialized"));
        return -1;
    }

    if (!src->drv->backend->storageFileReadHeader) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _("storage file header reading is not supported for "
                         "storage type %s (protocol: %s)"),
                       virStorageTypeToString(src->type),
                       virStorageNetProtocolTypeToString(src->protocol));
        return -2;
    }

    ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);

    VIR_DEBUG("read of storage header %p: ret=%zd", src, ret);

    return ret;
}
```


Overlapping Code:
```
rStorageFileReadHeader(virStorageSourcePtr src,
ssize_t max_len,
char **buf)
{
ssize_t ret;
if (!virStorageFileIsInitialized(src)) {
virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
_("storage file backend not initialized"));
return -1;
}
if (!src->drv->backend->storageFileReadHeader) {
virReportError(VIR_ERR_INTERNAL_ERROR,
_("storage file header reading is not supported for "
"storage type %s (protocol: %s)"),
virStorageTypeToString(src->type),
virStorageNetProtocolTypeToString(src->protocol));
return -2;
}
ret = src->drv->backend->storageFileReadHeader(src, max_len, buf);
VIR_DEBUG("read of stor
```
<Overlap Ratio: 0.9106060606060606>

---

--- 2 --
Question ID: 10c519fae7b4655a4b159bf6f43e87d0583e98dc_227
Original Code:
```
static int remoteDispatchStorageVolLookupByKey(
    virNetServerPtr server ATTRIBUTE_UNUSED,
    virNetServerClientPtr client,
    virNetMessagePtr msg ATTRIBUTE_UNUSED,
    virNetMessageErrorPtr rerr,
    remote_storage_vol_lookup_by_key_args *args,
    remote_storage_vol_lookup_by_key_ret *ret)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;
    struct daemonClientPrivate *priv =
        virNetServerClientGetPrivateData(client);

    if (!priv->conn) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)
        goto cleanup;

    make_nonnull_storage_vol(&ret->vol, vol);
    rv = 0;

cleanup:
    if (rv < 0)
        virNetMessageSaveError(rerr);
    virObjectUnref(vol);
    return rv;
}
```


Overlapping Code:
```
ookupByKey(
virNetServerPtr server ATTRIBUTE_UNUSED,
virNetServerClientPtr client,
virNetMessagePtr msg ATTRIBUTE_UNUSED,
virNetMessageErrorPtr rerr,
remote_storage_vol_lookup_by_key_args *args,
remote_storage_vol_lookup_by_key_ret *ret)
{
int rv = -1;
virStorageVolPtr vol = NULL;
struct daemonClientPrivate *priv =
virNetServerClientGetPrivateData(client);
if (!priv->conn) {
virReportError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
goto cleanup;
}
if ((vol = virStorageVolLookupByKey(priv->conn, args->key)) == NULL)
goto cleanup;
make_nonnull_storage_vol(&ret->vol, vol);
rv = 0;
cleanup:
if (rv < 0)
virNetMessageSaveError(rerr);
virObjectUnref(vol);
return rv
```
<Overlap Ratio: 0.9457579972183588>

---

--- 3 --
Question ID: 18ab999bbfb0f1fc1d7c6aa7f47251006cd66572_0
Original Code:
```
static void assert_bip32_assumptions(void)
{
#define key_off(member) offsetof(struct ext_key,  member)
#define key_size(member) sizeof(((struct ext_key *)0)->member)

    /* Our ripend buffers must be uint32_t aligned and the correct size */
    BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);
    BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);
    BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));
    BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));
    BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);

    /* Our keys following the parity byte must be uint64_t aligned */
    BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);
    BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);

    /* child_num must be contigous after priv_key */
    BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));

    /* We use priv_key[0] to determine if this extended key is public or
     * private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private
     * with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then
     * this is a public key with no private key (A BIP32 'neutered' key).
     *
     * For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte
     * private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be
     * 2 or 3 as they are valid parity bytes for public keys.
     */
    BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);
    BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&
                 BIP32_FLAG_KEY_PUBLIC != 2u &&
                 BIP32_FLAG_KEY_PUBLIC != 3u);
}
```


Overlapping Code:
```
_assumptions(void)
{
#define key_off(member) offsetof(struct ext_key, member)
#define key_size(member) sizeof(((struct ext_key *)0)->member)
/* Our ripend buffers must be uint32_t aligned and the correct size */
BUILD_ASSERT(key_off(parent160) % sizeof(uint32_t) == 0);
BUILD_ASSERT(key_off(hash160) % sizeof(uint32_t) == 0);
BUILD_ASSERT(key_size(parent160) == sizeof(struct ripemd160));
BUILD_ASSERT(key_size(hash160) == sizeof(struct ripemd160));
BUILD_ASSERT(key_size(priv_key) == EC_PRIVATE_KEY_LEN + 1);
/* Our keys following the parity byte must be uint64_t aligned */
BUILD_ASSERT((key_off(priv_key) + 1) % sizeof(uint64_t) == 0);
BUILD_ASSERT((key_off(pub_key) + 1) % sizeof(uint64_t) == 0);
/* child_num must be contigous after priv_key */
BUILD_ASSERT((key_off(priv_key) + key_size(priv_key)) == key_off(child_num));
/* We use priv_key[0] to determine if this extended key is public or
* private, If priv_key[0] is BIP32_FLAG_KEY_PRIVATE then this key is private
* with a computed public key present. If set to BIP32_FLAG_KEY_PUBLIC then
* this is a public key with no private key (A BIP32 'neutered' key).
*
* For this to work BIP32_FLAG_KEY_PRIVATE must be zero so the whole 33 byte
* private key is valid when serialized, and BIP32_FLAG_KEY_PUBLIC cannot be
* 2 or 3 as they are valid parity bytes for public keys.
*/
BUILD_ASSERT(BIP32_FLAG_KEY_PRIVATE == 0);
BUILD_ASSERT(BIP32_FLAG_KEY_PUBLIC != BIP32_FLAG_KEY_PRIVATE &&
BIP32_FLAG_KEY_PUBLIC != 2u &&
BIP32_FLAG_KEY_PUBLIC != 3u);

```
<Overlap Ratio: 0.9836065573770492>

---

--- 4 --
Question ID: 0c114c6d73450c3b69405ae74a3c6a13e4fee696_8
Original Code:
```
static void callback_recv(void *p_cookie, int status, const struct mdns_entry *entries)
{
    int ret = 0;
    struct mdns_entry *entry = NULL;
    service_state_t *state = NULL;
    service_t *service = NULL;

    service_t *node, *next;
    int find = 0;
    uint8_t required = 0;
    if (p_cookie == NULL) {
        return;
    }
    if (status < 0) {
        log_e("get entries err, status = %d", status);
        return;
    }

    state = (service_state_t *)p_cookie;
    service = hal_malloc(sizeof(service_t));
    memset(service, 0, sizeof(service_t));

    if (service == NULL) {
        return ;
    }
    entry = (struct mdns_entry *)entries;
    while (entry != NULL) {
        switch (entry->type) {
            case RR_A:
                break;
            case RR_PTR:
                /*
                                if (entry->data.PTR.domain != NULL) {
                                    strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);
                                }
                */
                break;
            case RR_TXT: {
                txt_item_t *txt_next = entry->data.TXT;
                while (txt_next != NULL) {
                    txt_item_t *txt;
                    txt = hal_malloc(sizeof(txt_item_t));
                    memset(txt, 0, sizeof(txt_item_t));
                    if (txt == NULL) {
                        goto err;
                    }
                    memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));
                    txt->next = service->txt_items;
                    service->txt_items = txt;
                    txt_next = txt_next->next;
                };
            }
            break;
            case RR_AAAA:
                required |= 0x01;
                memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));
                break;
            case RR_SRV: {
                char *name = NULL;
                char *type = NULL;
                char *last = NULL;
                int num = get_char_num(entry->name, '.');
                if (num == 2) {
                    name = UMESH_SRV_DEFAULT_NANE;
                    char *type = (char *)strtok_r(entry->name, ".", &last);
                    if (type == NULL || strlen(type) == 0) {
                        break;
                    }
                } else if (num == 3) {
                    name = (char *)strtok_r(entry->name, ".", &last);
                    type = (char *)strtok_r(NULL, ".", &last);
                    if (name == NULL || strlen(name) == 0) {
                        break;
                    }
                    if (type == NULL || strlen(type) == 0) {
                        break;
                    }
                } else {
                    log_w("mdns srv: unknow format!");
                    break;
                }

                required |= 0x02;

                strncpy(service->srv_name, name, SERVICE_NAME_LEN_MAX);
                strncpy(service->srv_type, type, SERVICE_TYPE_LEN_MAX);
                service->ttl = entry->ttl;
                log_d(" srv type = %s,TTL = %d", type, service->ttl);
                if (service->ttl == 0) {
                    service->ttl = SERVICE_TTL;
                }
                service->id.port = entry->data.SRV.port;
            }
            break;
            default:
                break;
        }

        entry = entry->next;
    };

    if ((required & 0x03) != 0x03) {
        log_e("service not complete");
        ret = UMESH_SRV_ERR_SERVICE_INCOMPLETE;
        goto err;
    }
    hal_mutex_lock(state->lock);
    list_for_each_entry_safe(node, next, &state->found_service_list, linked_list, service_t) {
        if (!strcmp(node->srv_name, service->srv_name) && !strcmp(node->srv_type, service->srv_type)) {
            node->last_update = hal_now_ms();
            find = 1;
            break;
        }
    }

    if (!find && list_entry_number(&state->found_service_list) < SERVICE_MAX_FOUND_NUM) {
        log_d("add serivce to found list:%s-%s", service->srv_type, service->srv_name);
        service->last_update = hal_now_ms();
        list_add_tail(&service->linked_list, &state->found_service_list);
        if (state->found_cb) {
            state->found_cb(service, PEER_FOUND, state->found_cb_ctx);
        }
    }  else {
        ret = umesh_service_free(service);
    }
    hal_mutex_unlock(state->lock);
    return;
err:
    log_e("service incomplete, discarded! ret = %d", ret);
    if (service != NULL) {
        umesh_service_free(service);
    }
    return;
}
```


Overlapping Code:
```
cv(void *p_cookie, int status, const struct mdns_entry *entries)
{
int ret = 0;
struct mdns_entry *entry = NULL;
service_state_t *state = NULL;
service_t *service = NULL;
service_t *node, *next;
int find = 0;
uint8_t required = 0;
if (p_cookie == NULL) {
return;
}
if (status < 0) {
log_e("get entries err, status = %d", status);
return;
}
state = (service_state_t *)p_cookie;
service = hal_malloc(sizeof(service_t));
memset(service, 0, sizeof(service_t));
if (service == NULL) {
return ;
}
entry = (struct mdns_entry *)entries;
while (entry != NULL) {
switch (entry->type) {
case RR_A:
break;
case RR_PTR:
/*
if (entry->data.PTR.domain != NULL) {
strncpy(service->srv_name, entry->data.PTR.domain, SERVICE_NAME_LEN_MAX);
}
*/
break;
case RR_TXT: {
txt_item_t *txt_next = entry->data.TXT;
while (txt_next != NULL) {
txt_item_t *txt;
txt = hal_malloc(sizeof(txt_item_t));
memset(txt, 0, sizeof(txt_item_t));
if (txt == NULL) {
goto err;
}
memcpy(txt->txt, txt_next->txt, strlen(txt_next->txt));
txt->next = service->txt_items;
service->txt_items = txt;
txt_next = txt_next->next;
};
}
break;
case RR_AAAA:
required |= 0x01;
memcpy(&service->id.ip6, entry->data.AAAA.addr.s6_addr, sizeof(service->id.ip6));
break;
case RR_SRV: {
char *name = NULL;
char *type = NULL;
char *last = NULL;
int num = get_char_num(entry->name, '.');
if (num == 2) {
name = UMESH_SRV_DEFAULT_NANE;
char *type = (char *)strtok_r(entry->name, ".", &last);
if (type == NULL || strlen(type) == 0) {
break;
}
} else if (num == 3) {
name = (char *)strtok_r(entry->name, ".", &last)
```
<Overlap Ratio: 0.9711779448621554>

---

--- 5 --
Question ID: 8de8a1b9c31024d009a1f11b0a4fee426c49e677_6
Original Code:
```
static void shell_cp( int argc, char **argv )
{
  FILE *fps = NULL, *fpd = NULL;
  void *buf = NULL;
  size_t datalen, datawrote, total = 0;

  if( argc != 3 )
  {
    printf( "Usage: cp <source> <destination>\n" );
    return;
  }
  if( ( fps = fopen( argv[ 1 ], "rb" ) ) == NULL )
    printf( "Unable to open %s for reading\n", argv[ 1 ] );
  else
  {
    if( ( fpd = fopen( argv[ 2 ], "wb" ) ) == NULL )
      printf( "Unable to open %s for writing\n", argv[ 2 ] );
    else
    {
      // Alloc memory
      if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )
        printf( "Not enough memory\n" );
      else
      {
        // Do the actual copy
        while( 1 )
        {
          datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );
          datawrote = fwrite( buf, 1, datalen, fpd );
          if( datawrote < datalen )
          {
            printf( "Copy error (no space left on target?)\n" );
            break;
          }
          total += datalen;
          if( datalen < SHELL_COPY_BUFSIZE )
            break;
        }
        fflush( fpd );
        printf( "%u bytes copied\n", ( unsigned int )total );
      }
    }
  }
  if( fps )
    fclose( fps );
  if( fpd )
    fclose( fpd );
  if( buf )
    free( buf );
}
```


Overlapping Code:
```
 char **argv )
{
FILE *fps = NULL, *fpd = NULL;
void *buf = NULL;
size_t datalen, datawrote, total = 0;
if( argc != 3 )
{
printf( "Usage: cp <source> <destination>\n" );
return;
}
if( ( fps = fopen( argv[ 1 ], "rb" ) ) == NULL )
printf( "Unable to open %s for reading\n", argv[ 1 ] );
else
{
if( ( fpd = fopen( argv[ 2 ], "wb" ) ) == NULL )
printf( "Unable to open %s for writing\n", argv[ 2 ] );
else
{
// Alloc memory
if( ( buf = malloc( SHELL_COPY_BUFSIZE ) ) == NULL )
printf( "Not enough memory\n" );
else
{
// Do the actual copy
while( 1 )
{
datalen = fread( buf, 1, SHELL_COPY_BUFSIZE, fps );
datawrote = fwrite( buf, 1, datalen, fpd );
if( datawrote < datalen )
{
printf( "Copy error (no space left on target?)\n" );
break;
}
total += datalen;
if( datalen < SHELL_COPY_BUFSIZE )
break;
}
fflush( fpd );
printf( "%u bytes copied\n", ( unsigned int )total );
}
}
}
if( fps )
fclose( fps );
if( fpd )
fclose( fpd );
if(
```
<Overlap Ratio: 0.9467213114754098>

---

--- 6 --
Question ID: c38eef505d75b7a5eb8727c5e4c4a786682398d8_20
Original Code:
```
int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)
{
    unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

#if defined(USE_CRYPTO_OPENSSL)
    AES_KEY aes;
    AES_set_encrypt_key((unsigned char*)key, 128, &aes);
    AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);

#elif defined(USE_CRYPTO_MBEDTLS)
    mbedtls_aes_context aes;

    unsigned char output[16];

    mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );
    mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );

    memcpy(out_data, output, 16);
#else

    aes_context aes;

    unsigned char output[16];

    aes_setkey_enc( &aes, (unsigned char *)key, 128 );
    aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );

    memcpy(out_data, output, 16);
#endif

    return 0;
}
```


Overlapping Code:
```
t ss_aes_128_cbc(char *encrypt, char *out_data, char *key)
{
unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
#if defined(USE_CRYPTO_OPENSSL)
AES_KEY aes;
AES_set_encrypt_key((unsigned char*)key, 128, &aes);
AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);
#elif defined(USE_CRYPTO_MBEDTLS)
mbedtls_aes_context aes;
unsigned char output[16];
mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );
mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
memcpy(out_data, output, 16);
#else
aes_context aes;
unsigned char output[16];
aes_setkey_enc( &aes, (unsigned char *)key, 128 );
aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
memcpy(out_data, output, 
```
<Overlap Ratio: 0.9699879951980792>

---

--- 7 --
Question ID: ea5a0ad4946ded29145c2bd5514b9379b4a85101_50
Original Code:
```
static int
rp_event_notif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)
{
    /* specific subscription for this notification */
    if (!strcmp(ntf_xpath, subscr_xpath)) {
        return 1;
    }

    /* whole module subscription */
    if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, "*//.") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {
        return 1;
    }

    return 0;
}
```


Overlapping Code:
```
tif_match_subscr(const char *ntf_xpath, const char *subscr_xpath)
{
/* specific subscription for this notification */
if (!strcmp(ntf_xpath, subscr_xpath)) {
return 1;
}
/* whole module subscription */
if (!strcmp(subscr_xpath + strlen(subscr_xpath) - 4, "*//.") && !strncmp(ntf_xpath, subscr_xpath, strlen(subscr_xpath) - 4)) {
return 1;
}
return 0;
```
<Overlap Ratio: 0.9358288770053476>

---

--- 8 --
Question ID: 201f7c63ea5c12a2abaa53263ade88d3a2624fe5_8
Original Code:
```
static int
dmsg_relay_scan_cmp(h2span_relay_t *relay, void *arg)
{
	struct relay_scan_info *info = arg;

	if ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)
		return(-1);
	if ((intptr_t)relay->source_rt->any.link->node > (intptr_t)info->node)
		return(1);
	return(0);
}
```


Overlapping Code:
```
span_relay_t *relay, void *arg)
{
struct relay_scan_info *info = arg;
if ((intptr_t)relay->source_rt->any.link->node < (intptr_t)info->node)
return(-1);
if ((intptr_t)relay->source_rt->any.link->node > (intptr_t)
```
<Overlap Ratio: 0.7571428571428571>

---

--- 9 --
Question ID: b85ba71a6f77e974d82ccdd635109f36d0ddaac8_50
Original Code:
```
static int
remoteDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)
{
    int rv = -1;
    struct private_data *priv = dom->conn->privateData;
    remote_domain_detach_device_flags_args args;

    remoteDriverLock(priv);

    make_nonnull_domain(&args.dom, dom);
    args.xml = (char *)xml;
    args.flags = flags;

    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,
             (xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,
             (xdrproc_t)xdr_void, (char *)NULL) == -1) {
        goto done;
    }

    rv = 0;

done:
    remoteDriverUnlock(priv);
    return rv;
}
```


Overlapping Code:
```
eDomainDetachDeviceFlags(virDomainPtr dom, const char *xml, unsigned int flags)
{
int rv = -1;
struct private_data *priv = dom->conn->privateData;
remote_domain_detach_device_flags_args args;
remoteDriverLock(priv);
make_nonnull_domain(&args.dom, dom);
args.xml = (char *)xml;
args.flags = flags;
if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_DETACH_DEVICE_FLAGS,
(xdrproc_t)xdr_remote_domain_detach_device_flags_args, (char *)&args,
(xdrproc_t)xdr_void, (char *)NULL) == -1) {
goto done;
}
rv = 0;
done:
remoteDriverUnlock(priv);
return rv;
}
```
<Overlap Ratio: 0.9714795008912656>

---

--- 10 --
Question ID: d70d925d8edfce36b50331ebabef78a01c90528e_2
Original Code:
```
void RCC_Configuration(void)
{
    /* Enable peripheral clocks */
    /* Enable DMA1 clock */
    RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE);

}
```


Overlapping Code:
```
oid RCC_Configuration(void)
{
/* Enable peripheral clocks */
/* Enable DMA1 clock */
RCC_AHBPeriphClock_Enable(RCC_AHBPERIPH_DMA1, ENABLE)
```
<Overlap Ratio: 0.971830985915493>

---

--- 11 --
Question ID: ab98a3da709534dacefa70125230269da8c56f09_3
Original Code:
```
void k_uart_console_init(void)
{
    KUARTConf conf = k_uart_conf_defaults();
    conf.baud_rate = K_UART_CONSOLE_BAUDRATE;
    // TODO: allow more configuration of console UART device

    k_uart_init(K_UART_CONSOLE, &conf);
}
```


Overlapping Code:
```
k_uart_console_init(void)
{
KUARTConf conf = k_uart_conf_defaults();
conf.baud_rate = K_UART_CONSOLE_BAUDRATE;
// TODO: allow more configuration of console UART device
k_uart_init(K_UART_CONSOLE, &con
```
<Overlap Ratio: 0.9523809523809523>

---

--- 12 --
Question ID: 22a4745258654e16e2a04ebe2d10bf669a9162f7_0
Original Code:
```
class CivilianImgPathManager
{
public:

    static const char* getRandomCivilianImgPathBegin();

private:
    CivilianImgPathManager(void);
    ~CivilianImgPathManager(void);
}
```


Overlapping Code:
```
:
static const char* getRandomCivilianImgPathBegin();
private:
CivilianImgPathManager(void);
~Civili
```
<Overlap Ratio: 0.6172839506172839>

---

--- 13 --
Question ID: b77ff66e5a2465fd9182441562e417e4d968ffc3_7
Original Code:
```
es_result_e
set_callback_for_userdata(es_read_userdata_cb readcb,
                          es_write_userdata_cb writecb,
                          es_free_userdata free_userdata)
{
  if (!g_enrollee) {
    OC_ERR("Enrollee is not initialized!");
    return ES_ERROR;
  }

  if (!readcb && !writecb) {
    OC_ERR("Invalid user attributes read/write callback!");
    return ES_ERROR;
  }

  g_enrollee->read_cb = readcb;
  g_enrollee->write_cb = writecb;
  g_enrollee->free_userdata = free_userdata;
  return ES_OK;
}
```


Overlapping Code:
```
_callback_for_userdata(es_read_userdata_cb readcb,
es_write_userdata_cb writecb,
es_free_userdata free_userdata)
{
if (!g_enrollee) {
OC_ERR("Enrollee is not initialized!");
return ES_ERROR;
}
if (!readcb && !writecb) {
OC_ERR("Invalid user attributes read/write callback!");
return ES_ERROR;
}
g_enrollee->read_cb = readcb;
g_enrollee->write_cb = writecb;
g_enrollee
```
<Overlap Ratio: 0.8534883720930233>

---

--- 14 --
Question ID: bbd97466b6d9cca41438ea793ee4772a2366211a_16
Original Code:
```
void Manage_Series(REBSER *series)
/*
**		When a series is first created, it is in a state of being
**		manually memory managed.  Thus, you can call Free_Series on
**		it if you are sure you do not need it.  This will transition
**		a manually managed series to be one managed by the GC.  There
**		is no way to transition it back--once a series has become
**		managed, only the GC can free it.
**
**		All series that wind up in user-visible values *must* be
**		managed, because the user can make copies of values
**		containing that series.  When these copies are made, it's
**		no longer safe to assume it's okay to free the original.
**
***********************************************************************/
{
	REBSER ** const last_ptr
		= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];

	assert(!SERIES_GET_FLAG(series, SER_MANAGED));
	SERIES_SET_FLAG(series, SER_MANAGED);

	// Note: Code repeated in Free_Series()
	assert(GC_Manuals->tail >= 1);
	if (*last_ptr != series) {
		// If the series is not the last manually added series, then
		// find where it is, then move the last manually added series
		// to that position to preserve it when we chop off the tail
		// (instead of keeping the series we want to free).
		REBSER **current_ptr = last_ptr - 1;
		while (*current_ptr != series) {
			assert(current_ptr > cast(REBSER**, GC_Manuals->data));
			--current_ptr;
		}
		*current_ptr = *last_ptr;
	}
	GC_Manuals->tail--; // !!! Should it ever shrink or save memory?
}
```


Overlapping Code:
```
* When a series is first created, it is in a state of being
** manually memory managed. Thus, you can call Free_Series on
** it if you are sure you do not need it. This will transition
** a manually managed series to be one managed by the GC. There
** is no way to transition it back--once a series has become
** managed, only the GC can free it.
**
** All series that wind up in user-visible values *must* be
** managed, because the user can make copies of values
** containing that series. When these copies are made, it's
** no longer safe to assume it's okay to free the original.
**
***********************************************************************/
{
REBSER ** const last_ptr
= &cast(REBSER**, GC_Manuals->data)[GC_Manuals->tail - 1];
assert(!SERIES_GET_FLAG(series, SER_MANAGED));
SERIES_SET_FLAG(series, SER_MANAGED);
// Note: Code repeated in Free_Series()
assert(GC_Manuals->tail >= 1);
if (*last_ptr != series) {
// If the series is not the last manually added series, then
// find where it is, then move the last manually added series
// to that position to preserve it when we chop off the tail
// (instead of keeping the series we want to free).
REBSER **current_ptr = last_ptr - 1;
while (*current_ptr != series) {
assert(current_ptr > cast(REBSER**, GC_Manuals->data));
--current_ptr;
}
*current_ptr = *last_ptr;
}
GC_Manuals->tail--; // !!! Should it ever shrink or save memory
```
<Overlap Ratio: 0.970873786407767>

---

--- 15 --
Question ID: 774ed3fc9c97140400eba133562eac4e551115c4_6
Original Code:
```
void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)
{
    if (!gDvm.ddmThreadNotification)
        return;

    size_t stringLen = dvmStringLen(newName);
    const u2* chars = dvmStringChars(newName);

    /*
     * Output format:
     *  (4b) thread ID
     *  (4b) stringLen
     *  (xb) string chars
     */
    int bufLen = 4 + 4 + (stringLen * 2);
    u1 buf[bufLen];

    set4BE(&buf[0x00], threadId);
    set4BE(&buf[0x04], stringLen);
    u2* outChars = (u2*) &buf[0x08];
    while (stringLen--)
        set2BE((u1*) (outChars++), *chars++);

    dvmDbgDdmSendChunk(CHUNK_TYPE("THNM"), bufLen, buf);
}
```


Overlapping Code:
```
void dvmDdmSendThreadNameChange(int threadId, StringObject* newName)
{
if (!gDvm.ddmThreadNotification)
return;
size_t stringLen = dvmStringLen(newName);
const u2* chars = dvmStringChars(newName);
/*
* Output format:
* (4b) thread ID
* (4b) stringLen
* (xb) string chars
*/
int bufLen = 4 + 4 + (stringLen * 2);
u1 buf[bufLen];
set4BE(&buf[0x00], threadId);
set4BE(&buf[0x04], stringLen);
u2* outChars = (u2*) &buf[0x08];
while (stringLen--)
set2BE((u1*) (outChars++), *chars++);
dvmDbgDdmSendChunk(CHUNK_TYPE("THNM"), bufLen, buf
```
<Overlap Ratio: 0.9925093632958801>

---

--- 16 --
Question ID: dcf766ae070622959503b15bfca548995f80dcaf_0
Original Code:
```
static int stxReadThread(StxThread* thread, EmbFile* file)
{
    int j, colorNameLength, sectionNameLength;
    int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */
    int codeLength = 0;
    char* codeBuff = 0;
    char* codeNameBuff = 0;
    char* sectionNameBuff = 0;
    EmbColor col;
    unsigned char whatIsthis; /* TODO: determine what this represents */

    if(!thread) { embLog_error("format-stx.c stxReadThread(), thread argument is null\n"); return 0; }
    if(!file) { embLog_error("format-stx.c stxReadThread(), file argument is null\n"); return 0; }

    codeLength = binaryReadUInt8(file);
    codeBuff = (char*)malloc(codeLength);
    if(!codeBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for codeBuff\n"); return 0; }
    binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */
    thread->colorCode = codeBuff;
    colorNameLength = binaryReadUInt8(file);
    codeNameBuff = (char*)malloc(colorNameLength);
    if(!codeNameBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\n"); return 0; }
    binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */
    thread->colorName = codeNameBuff;

    col.r = binaryReadUInt8(file);
    col.b = binaryReadUInt8(file);
    col.g = binaryReadUInt8(file);

    whatIsthis = binaryReadUInt8(file);

    sectionNameLength = binaryReadUInt8(file);
    sectionNameBuff = (char*)malloc(sectionNameLength);
    if(!sectionNameBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\n"); return 0; }
    binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */
    thread->sectionName = sectionNameBuff;

    somethingSomething = binaryReadInt32(file);
    somethingSomething2 = binaryReadInt32(file);
    somethingElse = binaryReadInt32(file);
    numberOfOtherDescriptors = binaryReadInt16(file);

    thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);
    if(!thread->subDescriptors) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\n"); return 0; }
    for(j = 0; j < numberOfOtherDescriptors; j++)
    {
        SubDescriptor sd;
        char* subCodeBuff, *subColorNameBuff;
        int subCodeLength, subColorNameLength;

        sd.someNum = binaryReadInt16(file);
        /* Debug.Assert(sd.someNum == 1); TODO: review */
        sd.someInt = binaryReadInt32(file);
        subCodeLength = binaryReadUInt8(file);
        subCodeBuff = (char*)malloc(subCodeLength);
        if(!subCodeBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for subCodeBuff\n"); return 0; }
        binaryReadBytes(file, (unsigned char*)subCodeBuff, subCodeLength); /* TODO: check return value */
        sd.colorCode = subCodeBuff;
        subColorNameLength = binaryReadUInt8(file);
        subColorNameBuff = (char*)malloc(subColorNameLength);
        if(!subColorNameBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for subColorNameBuff\n"); return 0; }
        binaryReadBytes(file, (unsigned char*)subColorNameBuff, subColorNameLength); /* TODO: check return value */
        sd.colorName = subColorNameBuff;
        sd.someOtherInt = binaryReadInt32(file);
        thread->subDescriptors[j] = sd;
    }
    return 1;
}
```


Overlapping Code:
```
read* thread, EmbFile* file)
{
int j, colorNameLength, sectionNameLength;
int somethingSomething, somethingSomething2, somethingElse, numberOfOtherDescriptors; /* TODO: determine what these represent */
int codeLength = 0;
char* codeBuff = 0;
char* codeNameBuff = 0;
char* sectionNameBuff = 0;
EmbColor col;
unsigned char whatIsthis; /* TODO: determine what this represents */
if(!thread) { embLog_error("format-stx.c stxReadThread(), thread argument is null\n"); return 0; }
if(!file) { embLog_error("format-stx.c stxReadThread(), file argument is null\n"); return 0; }
codeLength = binaryReadUInt8(file);
codeBuff = (char*)malloc(codeLength);
if(!codeBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for codeBuff\n"); return 0; }
binaryReadBytes(file, (unsigned char*)codeBuff, codeLength); /* TODO: check return value */
thread->colorCode = codeBuff;
colorNameLength = binaryReadUInt8(file);
codeNameBuff = (char*)malloc(colorNameLength);
if(!codeNameBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for codeNameBuff\n"); return 0; }
binaryReadBytes(file, (unsigned char*)codeNameBuff, colorNameLength); /* TODO: check return value */
thread->colorName = codeNameBuff;
col.r = binaryReadUInt8(file);
col.b = binaryReadUInt8(file);
col.g = binaryReadUInt8(file);
whatIsthis = binaryReadUInt8(file);
sectionNameLength = binaryReadUInt8(file);
sectionNameBuff = (char*)malloc(sectionNameLength);
if(!sectionNameBuff) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for sectionNameBuff\n"); return 0; }
binaryReadBytes(file, (unsigned char*)sectionNameBuff, sectionNameLength); /* TODO: check return value */
thread->sectionName = sectionNameBuff;
somethingSomething = binaryReadInt32(file);
somethingSomething2 = binaryReadInt32(file);
somethingElse = binaryReadInt32(file);
numberOfOtherDescriptors = binaryReadInt16(file);
thread->subDescriptors = (SubDescriptor*)malloc(sizeof(SubDescriptor) * numberOfOtherDescriptors);
if(!thread->subDescriptors) { embLog_error("format-stx.c stxReadThread(), unable to allocate memory for thread->subDescriptors\n"); return 0; }
for(j = 0; j < numberOfOtherDescriptors; j++)
{
SubDescriptor sd;
char* subCodeBuff, *subColorNameBu
```
<Overlap Ratio: 0.9698275862068966>

---

--- 17 --
Question ID: 4f3e7642740bc08ef0dbbfd9f04d03fb4be60715_0
Original Code:
```
svm_msg_q_t *
svm_msg_q_alloc (svm_msg_q_cfg_t * cfg)
{
  svm_msg_q_ring_t *ring;
  svm_msg_q_t *mq;
  uword size;
  int i;

  if (!cfg)
    return 0;

  mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);
  memset (mq, 0, sizeof (*mq));
  mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),
			  cfg->consumer_pid, 0);
  vec_validate (mq->rings, cfg->n_rings - 1);
  for (i = 0; i < cfg->n_rings; i++)
    {
      ring = &mq->rings[i];
      ring->elsize = cfg->ring_cfgs[i].elsize;
      ring->nitems = cfg->ring_cfgs[i].nitems;
      if (cfg->ring_cfgs[i].data)
	ring->data = cfg->ring_cfgs[i].data;
      else
	{
	  size = (uword) ring->nitems * ring->elsize;
	  ring->data = clib_mem_alloc_aligned (size, CLIB_CACHE_LINE_BYTES);
	}
    }

  return mq;
}
```


Overlapping Code:
```
m_msg_q_alloc (svm_msg_q_cfg_t * cfg)
{
svm_msg_q_ring_t *ring;
svm_msg_q_t *mq;
uword size;
int i;
if (!cfg)
return 0;
mq = clib_mem_alloc_aligned (sizeof (svm_msg_q_t), CLIB_CACHE_LINE_BYTES);
memset (mq, 0, sizeof (*mq));
mq->q = svm_queue_init (cfg->q_nitems, sizeof (svm_msg_q_msg_t),
cfg->consumer_pid, 0);
vec_validate (mq->rings, cfg->n_rings - 1);
for (i = 0; i < cfg->n_rings; i++)
{
ring = &mq->rings[i];
ring->elsize = cfg->ring_cfgs[i].elsize;
ring->nitems = cfg->ring_cfgs[i].nitems;
if (cfg->ring_cfgs[i].data)
ring->data = cfg->ring_cfgs[i].data;
else
{
size = (uword) ring->nitems * ring->elsize;
ring->data = clib_mem_alloc_aligned (size
```
<Overlap Ratio: 0.9186535764375876>

---

--- 18 --
Question ID: 01bd50efd8cfcab981b9784c6335cc672a115272_0
Original Code:
```
class AppObject 
{
public:
	AppObject() :  mesh(NULL),  cage(NULL), meshSelection(NULL), 
		 hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)
	{
		//fileSeparator = "\\";
	}

	void unloadMesh();
		
	~AppObject() 
	{
		--(*refCount);
		if (*refCount == 0)
		{
			delete mesh;
			delete cage;
			delete meshSelection;
			delete refCount;
		}
	}
```


Overlapping Code:
```
 mesh(NULL), cage(NULL), meshSelection(NULL), 
hasSdfFacets(false), refCount(new int(1)), m_myWo(NULL)
{
//fileSeparator = "\\";
}
void unloadMesh();

~AppObject() 
{
--(*refCount);
if (*refCount == 0)
{
delete mesh;
delete cage;
delete meshSelection
```
<Overlap Ratio: 0.8012820512820513>

---

--- 19 --
Question ID: 509b1de5ef7b6fc73ea40b96701359f0e02f739c_13
Original Code:
```
bool uart_hal_is_receiver_enabled(uint32_t uartInstance)
{
    assert(uartInstance < UART_INSTANCE_COUNT);

    /* get the receiver config based on the uart instance*/
#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT
    if (uartInstance == 0)
    {
        return HW_UART0_C2.B.RE;
    }
    else
#endif
    {
        return HW_UART_C2(uartInstance).B.RE;
    }
}
```


Overlapping Code:
```
l_is_receiver_enabled(uint32_t uartInstance)
{
assert(uartInstance < UART_INSTANCE_COUNT);
/* get the receiver config based on the uart instance*/
#if FSL_FEATURE_UART_HAS_LOW_POWER_UART_SUPPORT
if (uartInstance == 0)
{
return HW_UART0_C2.B.RE;
}
else
#endif
{
return HW_UART_C2(uartInstance).B.RE;
}
```
<Overlap Ratio: 0.9554140127388535>

---

--- 20 --
Question ID: eef69a4cab424bea5dfdd197756362ccbde9a183_3
Original Code:
```
static int
worker_wrapper(void *arg)
{
	struct worker_data *w  = arg;
	const bool burst = evt_has_burst_mode(w->dev_id);

	if (burst)
		return order_queue_worker_burst(arg);
	else
		return order_queue_worker(arg);
}
```


Overlapping Code:
```
int
worker_wrapper(void *arg)
{
struct worker_data *w = arg;
const bool burst = evt_has_burst_mode(w->dev_id);
if (burst)
return order_queue_worker_burst(arg);
e
```
<Overlap Ratio: 0.7853658536585366>

---

--- 21 --
Question ID: 836f998db7a6e5c204f73097460edde865bbbf6b_61
Original Code:
```
void BTSH_Op_FMOV_RegLdR0m_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)
{
	cpu->ptcpc=op->pc;
	cpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,
		cpu->regs[op->rm]+cpu->regs[op->ro]+0);
	cpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,
		cpu->regs[op->rm]+cpu->regs[op->ro]+4);
}
```


Overlapping Code:
```
_DR(BTESH2_CpuState *cpu, BTESH2_Opcode *op)
{
cpu->ptcpc=op->pc;
cpu->fregs[op->rn^0]=BTESH2_GetAddrDWord(cpu,
cpu->regs[op->rm]+cpu->regs[op->ro]+0);
cpu->fregs[op->rn^1]=BTESH2_GetAddrDWord(cpu,
cpu->
```
<Overlap Ratio: 0.7660377358490567>

---

--- 22 --
Question ID: f4de8b84c5c25188503c2672b3818a474ad0db9c_14
Original Code:
```
int lov_fini_setattr_set(struct lov_request_set *set)
{
	int rc = 0;

	if (set == NULL)
		return 0;
	LASSERT(set->set_exp);
	if (atomic_read(&set->set_completes)) {
		rc = common_attr_done(set);
		/* FIXME update qos data here */
	}

	lov_put_reqset(set);
	return rc;
}
```


Overlapping Code:
```
struct lov_request_set *set)
{
int rc = 0;
if (set == NULL)
return 0;
LASSERT(set->set_exp);
if (atomic_read(&set->set_completes)) {
rc = common_attr_done(set);
/* FIXME update qos data here */
}
lov_put_reqset(set);
re
```
<Overlap Ratio: 0.8622047244094488>

---

--- 23 --
Question ID: 1ddb3fc1772b04a2265a9ea2b20c298ee4f30163_5
Original Code:
```
static int _set_status_v1(domid_t  domid,
                          int readonly,
                          int mapflag,
                          grant_entry_header_t *shah, 
                          struct active_grant_entry *act)
{
    int rc = GNTST_okay;
    union grant_combo scombo, prev_scombo, new_scombo;
    uint16_t mask = GTF_type_mask;

    /*
     * We bound the number of times we retry CMPXCHG on memory locations that
     * we share with a guest OS. The reason is that the guest can modify that
     * location at a higher rate than we can read-modify-CMPXCHG, so the guest
     * could cause us to livelock. There are a few cases where it is valid for
     * the guest to race our updates (e.g., to change the GTF_readonly flag),
     * so we allow a few retries before failing.
     */
    int retries = 0;

    /* if this is a grant mapping operation we should ensure GTF_sub_page
       is not set */
    if (mapflag)
        mask |= GTF_sub_page;

    scombo.word = *(u32 *)shah;

    /*
     * This loop attempts to set the access (reading/writing) flags
     * in the grant table entry.  It tries a cmpxchg on the field
     * up to five times, and then fails under the assumption that 
     * the guest is misbehaving.
     */
    for ( ; ; )
    {
        /* If not already pinned, check the grant domid and type. */
        if ( !act->pin &&
             (((scombo.shorts.flags & mask) !=
               GTF_permit_access) ||
              (scombo.shorts.domid != domid)) )
            PIN_FAIL(done, GNTST_general_error,
                     "Bad flags (%x) or dom (%d). (expected dom %d)\n",
                     scombo.shorts.flags, scombo.shorts.domid,
                     domid);

        new_scombo = scombo;
        new_scombo.shorts.flags |= GTF_reading;

        if ( !readonly )
        {
            new_scombo.shorts.flags |= GTF_writing;
            if ( unlikely(scombo.shorts.flags & GTF_readonly) )
                PIN_FAIL(done, GNTST_general_error,
                         "Attempt to write-pin a r/o grant entry.\n");
        }

        prev_scombo.word = cmpxchg((u32 *)shah,
                                   scombo.word, new_scombo.word);
        if ( likely(prev_scombo.word == scombo.word) )
            break;

        if ( retries++ == 4 )
            PIN_FAIL(done, GNTST_general_error,
                     "Shared grant entry is unstable.\n");

        scombo = prev_scombo;
    }

done:
    return rc;
}
```


Overlapping Code:
```
set_status_v1(domid_t domid,
int readonly,
int mapflag,
grant_entry_header_t *shah, 
struct active_grant_entry *act)
{
int rc = GNTST_okay;
union grant_combo scombo, prev_scombo, new_scombo;
uint16_t mask = GTF_type_mask;
/*
* We bound the number of times we retry CMPXCHG on memory locations that
* we share with a guest OS. The reason is that the guest can modify that
* location at a higher rate than we can read-modify-CMPXCHG, so the guest
* could cause us to livelock. There are a few cases where it is valid for
* the guest to race our updates (e.g., to change the GTF_readonly flag),
* so we allow a few retries before failing.
*/
int retries = 0;
/* if this is a grant mapping operation we should ensure GTF_sub_page
is not set */
if (mapflag)
mask |= GTF_sub_page;
scombo.word = *(u32 *)shah;
/*
* This loop attempts to set the access (reading/writing) flags
* in the grant table entry. It tries a cmpxchg on the field
* up to five times, and then fails under the assumption that 
* the guest is misbehaving.
*/
for ( ; ; )
{
/* If not already pinned, check the grant domid and type. */
if ( !act->pin &&
(((scombo.shorts.flags & mask) !=
GTF_permit_access) ||
(scombo.shorts.domid != domid)) )
PIN_FAIL(done, GNTST_general_error,
"Bad flags (%x) or dom (%d). (expected dom %d)\n",
scombo.shorts.flags, scombo.shorts.domid,
domid);
new_scombo = scombo;
new_scombo.shorts.flags |= GTF_reading;
if ( !readonly )
{
new_scombo.shorts.flags |= GTF_writing;
if ( unlikely(scombo.shorts.flags & GTF_readonly) )
PIN_FAIL(done, GNTST_general_error,
"Attempt to write-pin a r/o grant entry.\n");
}
prev_scombo.word = cmpxchg((u32 *)shah,
scombo.word, new_scombo.word);
if ( likely(prev_scombo.word == scombo.word) )
break;
if ( retries++ == 4 )
PIN_FAIL(done, GNTST_general_error,
"Shared grant entry is unstable.\n");
scombo = prev_scombo;
}
done:
return rc;
```
<Overlap Ratio: 0.9925253603844101>

---

--- 24 --
Question ID: 33a414b4ebe05992543d49bda2717e96d4a88215_6
Original Code:
```
const char *region_file_name(int n) 
{  
  region *r;
  r = id_to_region(n);
  if (r) 
    return(r->name); 
  return(NULL);
}
```


Overlapping Code:
```
ion_file_name(int n) 
{ 
region *r;
r = id_to_region(n);
if (r
```
<Overlap Ratio: 0.5486725663716814>

---

--- 25 --
Question ID: eb91c016cb7866a84c654e97ea1e6dbc2f17805f_9
Original Code:
```
void
_Tick ( Context * cntx, int32 findWordFlag )
{
    byte * token = ( byte* ) _DataStack_Pop ( ) ;
    if ( token )
    {
        Word * word = 0 ;
        if ( findWordFlag ) 
        {
            word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;
        }
        if ( word )
        {
            token = ( byte * ) word ;
        }
        else
        {
            Lexer * lexer = cntx->Lexer0 ;
            Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token
            if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;
        }
        //if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;
    }
    DSP_Push ( ( int32 ) token ) ;
}
```


Overlapping Code:
```
Flag )
{
byte * token = ( byte* ) _DataStack_Pop ( ) ;
if ( token )
{
Word * word = 0 ;
if ( findWordFlag ) 
{
word = Finder_FindQualifiedIDWord ( cntx->Finder0, token ) ;
}
if ( word )
{
token = ( byte * ) word ;
}
else
{
Lexer * lexer = cntx->Lexer0 ;
Lexer_ParseObject ( lexer, token ) ; // create a string from a 'raw' token
if ( GetState ( lexer, KNOWN_OBJECT ) ) token = ( byte* ) lexer->Literal ;
}
//if ( ! Compiling ) __CfrTil_SourceCode_Init ( _CfrTil_ ) ;
}
DSP_Push ( ( int32 ) token ) ;

```
<Overlap Ratio: 0.9191176470588235>

---

--- 26 --
Question ID: 4e2870d3c26c76b83261f2ba834f4420335c7950_4
Original Code:
```
static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,
    FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,
    DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,
    RECT *blackbox_rect)
{
    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
    FIXME("(%p)->(%f %f %d %p %p 0x%08x %p): stub\n", This, baselineOriginX, baselineOriginY,
        measuring_mode, glyph_run, params, textColor, blackbox_rect);
    return E_NOTIMPL;
}
```


Overlapping Code:
```
tatic HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,
FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,
DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,
RECT *blackbox_rect)
{
struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
FIXME("(%p)->(%f %f %d %p %p 0x%08x %p): stub\n", This, baselineOriginX, baselineOriginY,
measuring_mode, glyph_run, params, textColor, blackbox_rect);
```
<Overlap Ratio: 0.9596928982725528>

---

--- 27 --
Question ID: 351055def70884d31f01045490c93ee0a26be39a_1
Original Code:
```
class IFWL_CustomPanel : public IFWL_Widget {
 public:
  static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,
                                  IFWL_Widget* pOuter);

  IFWL_Content* GetContent();
  FWL_ERR SetContent(IFWL_Content* pContent);
  FWL_ERR SetProxy(IFWL_Proxy* pProxy);

 protected:
  IFWL_CustomPanel();
}
```


Overlapping Code:
```
lic IFWL_Widget {
public:
static IFWL_CustomPanel* Create(CFWL_WidgetImpProperties& properties,
IFWL_Widget* pOuter);
IFWL_Content* GetContent();
FWL_ERR SetContent(IFWL_Content* pContent);
FWL_ERR SetProxy(IFWL_Proxy* pProxy);
protected:
IFWL_CustomPanel();
}
```
<Overlap Ratio: 0.9027777777777778>

---

--- 28 --
Question ID: 312b1f8c47cb4836dd8f195a9d9e1aa98bf0acef_12
Original Code:
```
void
nls_decrypt(nls_ctx *c, UCHAR *buf, int nbytes)
{
    WORD	t = 0, t3 = 0;
    int		i;

    /* handle any previously buffered bytes */
    if (c->nbuf != 0) {
	while (c->nbuf != 0 && nbytes != 0) {
	    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;
	    c->mbuf ^= *buf << (32 - c->nbuf);
	    ++buf;
	    c->nbuf -= 8;
	    --nbytes;
	}
	if (c->nbuf != 0) /* not a whole word yet */
	    return;
	/* LFSR already cycled */
	macfunc(c, c->mbuf);
    }

    /* now do lots at a time, if there's enough */
    while (4*N <= nbytes)
    {
#if NLS_LONG_OUTPUT
	if (c->CtrModF16 < (F16-18)) {
#endif /*NLS_LONG_OUTPUT*/
	    DROUND( 0,A,B,C,D,E,F,G,H);
	    DROUND( 1,H,A,B,C,D,E,F,G);
	    DROUND( 2,G,H,A,B,C,D,E,F);
	    DROUND( 3,F,G,H,A,B,C,D,E);
	    DROUND( 4,E,F,G,H,A,B,C,D);
	    DROUND( 5,D,E,F,G,H,A,B,C);
	    DROUND( 6,C,D,E,F,G,H,A,B);
	    DROUND( 7,B,C,D,E,F,G,H,A);
	    DROUND( 8,A,B,C,D,E,F,G,H);
	    DROUND( 9,H,A,B,C,D,E,F,G);
	    DROUND(10,G,H,A,B,C,D,E,F);
	    DROUND(11,F,G,H,A,B,C,D,E);
	    DROUND(12,E,F,G,H,A,B,C,D);
	    DROUND(13,D,E,F,G,H,A,B,C);
	    DROUND(14,C,D,E,F,G,H,A,B);
	    DROUND(15,B,C,D,E,F,G,H,A);
	    DROUND(16,A,B,C,D,E,F,G,H);
	    buf += 4*N;
	    nbytes -= 4*N;
	    /* fix alignment of MAC buffer */
	    t = c->M[7];
	    for (i = NMAC-1; i > 0; --i)
		c->M[i] = c->M[i-1];
	    c->M[0] = t;
	    /* fix alignment of CRC buffer */
	    t = c->CRC[0];
	    for (i = 1; i < NMAC; ++i)
		c->CRC[i-1] = c->CRC[i];
	    c->CRC[NMAC-1] = t;
#if NLS_LONG_OUTPUT
	    c->CtrModF16 += 17;
	}
	else {
	    do {
		cycle(c);
		t = nltap(c);
		t3 = BYTE2WORD(buf);
		t ^= t3;
		macfunc(c, t);
		WORD2BYTE(t, buf);
		buf += 4;
		nbytes -= 4;
	    } while (F16-18 < c->CtrModF16);
	}
#endif /*NLS_LONG_OUTPUT*/
    }

    /* do small or odd size buffers the slow way */
    while (4 <= nbytes) {
	cycle(c);
	t = nltap(c);
	t3 = BYTE2WORD(buf);
	t ^= t3;
	macfunc(c, t);
	WORD2BYTE(t, buf);
	nbytes -= 4;
	buf += 4;
    }

    /* handle any trailing bytes */
    if (nbytes != 0) {
	cycle(c);
	c->sbuf = nltap(c);
	c->mbuf = 0;
	c->nbuf = 32;
	while (c->nbuf != 0 && nbytes != 0) {
	    *buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;
	    c->mbuf ^= *buf << (32 - c->nbuf);
	    ++buf;
	    c->nbuf -= 8;
	    --nbytes;
	}
    }
}
```


Overlapping Code:
```
ecrypt(nls_ctx *c, UCHAR *buf, int nbytes)
{
WORD t = 0, t3 = 0;
int i;
/* handle any previously buffered bytes */
if (c->nbuf != 0) {
while (c->nbuf != 0 && nbytes != 0) {
*buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;
c->mbuf ^= *buf << (32 - c->nbuf);
++buf;
c->nbuf -= 8;
--nbytes;
}
if (c->nbuf != 0) /* not a whole word yet */
return;
/* LFSR already cycled */
macfunc(c, c->mbuf);
}
/* now do lots at a time, if there's enough */
while (4*N <= nbytes)
{
#if NLS_LONG_OUTPUT
if (c->CtrModF16 < (F16-18)) {
#endif /*NLS_LONG_OUTPUT*/
DROUND( 0,A,B,C,D,E,F,G,H);
DROUND( 1,H,A,B,C,D,E,F,G);
DROUND( 2,G,H,A,B,C,D,E,F);
DROUND( 3,F,G,H,A,B,C,D,E);
DROUND( 4,E,F,G,H,A,B,C,D);
DROUND( 5,D,E,F,G,H,A,B,C);
DROUND( 6,C,D,E,F,G,H,A,B);
DROUND( 7,B,C,D,E,F,G,H,A);
DROUND( 8,A,B,C,D,E,F,G,H);
DROUND( 9,H,A,B,C,D,E,F,G);
DROUND(10,G,H,A,B,C,D,E,F);
DROUND(11,F,G,H,A,B,C,D,E);
DROUND(12,E,F,G,H,A,B,C,D);
DROUND(13,D,E,F,G,H,A,B,C);
DROUND(14,C,D,E,F,G,H,A,B);
DROUND(15,B,C,D,E,F,G,H,A);
DROUND(16,A,B,C,D,E,F,G,H);
buf += 4*N;
nbytes -= 4*N;
/* fix alignment of MAC buffer */
t = c->M[7];
for (i = NMAC-1; i > 0; --i)
c->M[i] = c->M[i-1];
c->M[0] = t;
/* fix alignment of CRC buffer */
t = c->CRC[0];
for (i = 1; i < NMAC; ++i)
c->CRC[i-1] = c->CRC[i];
c->CRC[NMAC-1] = t;
#if NLS_LONG_OUTPUT
c->CtrModF16 += 17;
}
else {
do {
cycle(c);
t = nltap(c);
t3 = BYTE2WORD(buf);
t ^= t3;
macfunc(c, t);
WORD2BYTE(t, buf);
buf += 4;
nbytes -= 4;
} while (F16-18 < c->CtrModF16);
}
#endif /*NLS_LONG_OUTPUT*/
}
/* do small or odd size buffers the slow way */
while (4 <= nbytes) {
cycle(c);
t = nltap(c);
t3 = BYTE2WORD(buf);
t ^= t3;
macfunc(c, t);
WORD2BYTE(t, buf);
nbytes -= 4;
buf += 4;
}
/* handle any trailing bytes */
if (nbytes != 0) {
cycle(c);
c->sbuf = nltap(c);
c->mbuf = 0;
c->nbuf = 32;
while (c->nbuf != 0 && nbytes != 0) {
*buf ^= (c->sbuf >> (32 - c->nbuf)) & 0xFF;
c->mbuf ^= *buf << (32 - c->nbuf);
++buf;
c->nbuf -= 8;
--nbytes;
}
}

```
<Overlap Ratio: 0.9943676395289298>

---

--- 29 --
Question ID: 3f37565a6090a282ad57626de8cc5f592d921aac_0
Original Code:
```
void print_pfxt(const struct pfx_record *pfx_record, void *data)
{
  char ip_pfx[INET6_ADDRSTRLEN];
  char rec[TEST_BUF_LEN];
  lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));
  snprintf(rec, sizeof(rec), "%" PRIu32 ",%s/%" PRIu8 ",%" PRIu8 "\n",
           (*pfx_record).asn, ip_pfx, (*pfx_record).min_len,
           (*pfx_record).max_len);
  strcat((char *)data, rec);
}
```


Overlapping Code:
```
t pfx_record *pfx_record, void *data)
{
char ip_pfx[INET6_ADDRSTRLEN];
char rec[TEST_BUF_LEN];
lrtr_ip_addr_to_str(&(*pfx_record).prefix, ip_pfx, sizeof(ip_pfx));
snprintf(rec, sizeof(rec), "%" PRIu32 ",%s/%" PRIu8 ",%" PRIu8 "\n",
(*pfx_record).asn, ip_pfx, (*pfx_record).min_len,
(*pfx_record).max_len);
strcat((
```
<Overlap Ratio: 0.8698060941828255>

---

--- 30 --
Question ID: 9b7d5cea8f348e7e27b709472eae0851e70d7836_8
Original Code:
```
__interrupt void USER2_ISR(void)     // User Defined trap 2
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
 __asm ("      ESTOP0");
  for(;;);

}
```


Overlapping Code:
```
nterrupt void USER2_ISR(void) // User Defined trap 2
{
// Insert ISR Code here
// Next two lines for debug only to halt the processor here
// Remove after inserting ISR Code
__asm (" ESTOP0");
for(;;);
}
```
<Overlap Ratio: 0.9854368932038835>

---

--- 31 --
Question ID: 54fe4f710c588207604d8fe76a71f4b670855025_1
Original Code:
```
ER
eOutput_getOffset(CELLIDX idx, T_OFF_BUF* offset)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* ここに処理本体を記述します #_TEFB_# */
	offset->iphdrlen = IP4_HDR_SIZE;
	offset->ipmss 	 = TCP_MSS;

	if(is_cEthernetOutput_joined()) {			//mikan いまいち未完
		offset->protocolflag |= FLAG_USE_ETHER;
		offset->ifhdrlen 	  = ETHER_HDR_SIZE;
		offset->ifalign 	  = NETBUFFER_ALIGN;
		return E_OK;
	}

	return E_ID;
}
```


Overlapping Code:
```
DX idx, T_OFF_BUF* offset)
{
ER ercd = E_OK;
CELLCB *p_cellcb;
if (VALID_IDX(idx)) {
p_cellcb = GET_CELLCB(idx);
}
else {
return(E_ID);
} /* end if VALID_IDX(idx) */
/* ここに処理本体を記述します #_TEFB_# */
offset->iphdrlen = IP4_HDR_SIZE;
offset->ipmss = TCP_MSS;
if(is_cEthernetOutput_joined()) { //mikan いまいち未完
offset->protocolflag |= FLAG_USE_ETHER;
offset->ifhdrlen = ETHER_HDR_SIZE;
offset->ifalign = NETBU
```
<Overlap Ratio: 0.8565310492505354>

---

--- 32 --
Question ID: 6c8defc2e7afa02ff5ac85d420cd06384601919f_38
Original Code:
```
static PyObject *
Vec2Array_longest(polypaths_planar_overrideSeq2Object *self)
{
	double max_len = -1.0;
	double L;
	Py_ssize_t max_i = -1;
	Py_ssize_t i;

	for (i = 0; i < Py_SIZE(self); ++i) {
		L = self->vec[i].x * self->vec[i].x + 
			self->vec[i].y * self->vec[i].y;
		if (L > max_len) {
			max_len = L;
			max_i = i;
		}
	}
	if (max_i > -1) {
		return (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);
	} else {
		Py_RETURN_NONE;
	}
}
```


Overlapping Code:
```
bject *
Vec2Array_longest(polypaths_planar_overrideSeq2Object *self)
{
double max_len = -1.0;
double L;
Py_ssize_t max_i = -1;
Py_ssize_t i;
for (i = 0; i < Py_SIZE(self); ++i) {
L = self->vec[i].x * self->vec[i].x + 
self->vec[i].y * self->vec[i].y;
if (L > max_len) {
max_len = L;
max_i = i;
}
}
if (max_i > -1) {
return (PyObject *)polypaths_planar_overrideVec2_FromStruct(&self->vec[max_i]);
} el
```
<Overlap Ratio: 0.9216589861751152>

---

--- 33 --
Question ID: 45b4e415a1ae5f8837cef7ee0b35c3debdb4754c_0
Original Code:
```
int mystricmp(const char *s1, const char *s2)
{
   int c1, c2;

   do {
      c1 = mytolower(*(s1++));
      c2 = mytolower(*(s2++));
   } while ((c1) && (c1 == c2));

   return c1 - c2;
}
```


Overlapping Code:
```
nt mystricmp(const char *s1, const char *s2)
{
int c1, c2;
do {
c1 = mytolower(*(s1++));
c2 = mytolower(*(s2++));
} while ((c1) && (c1 == c2));
return c1 -
```
<Overlap Ratio: 0.9567901234567902>

---

--- 34 --
Question ID: 154e35644c750239d8b26b3b469042a5d1d97c5a_49
Original Code:
```
TEST_FUNCTION(wsio_dowork_with_NULL_handle_does_nothing)
{
    // arrange

    // act
    wsio_get_interface_description()->concrete_io_dowork(NULL);

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
}
```


Overlapping Code:
```
TION(wsio_dowork_with_NULL_handle_does_nothing)
{
// arrange
// act
wsio_get_interface_description()->concrete_io_dowork(NULL);
// assert
ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
}
```
<Overlap Ratio: 0.9615384615384616>

---

--- 35 --
Question ID: 95ec526571ef8fe7db6e3d4a8d5459965cc668eb_223
Original Code:
```
static inline void hri_nvmctrl_clear_NONSEC_WRITE_bit(const void *const hw)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
NONSEC_WRITE_bit(const void *const hw)
{
NVMCTRL_CRITICAL_SECTION_ENTER();
((Nvmctrl *)hw)->NONSEC.reg &= ~NVMCTRL_NONSEC_WRITE_Msk;
NVMCTRL_CRITICAL_SECTION_LEAV
```
<Overlap Ratio: 0.7902439024390244>

---

--- 36 --
Question ID: 02a113cae40488f23acabe7f0714840b3b481ffd_0
Original Code:
```
int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)
{
	struct TreeNode** queue;
	int front, rear;
	int QueueSize;
	struct TreeNode** stack;
	int top;
	int level, i;
    int j, k;
	int** result;
	struct TreeNode* T;
	*returnSize = 0;

	if(root == NULL)
		return NULL;

	front = 0;
	rear = -1;
	top = -1;
	level = 0;
    j = 1;
    k = 0;
	*columnSizes = (int*)malloc(sizeof(int));
	result = (int**)malloc(sizeof(int*));
    queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));
    stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));
	queue[++rear] = root;
	QueueSize= rear - front + 1;
	while(QueueSize > 0)
	{
		i = 0;
        
        result = (int**)realloc(result, (level+1)*sizeof(int*));
        result[level] = (int*)malloc(sizeof(int));
		if(level % 2 == 0)
		{
			while(QueueSize > 0)
			{
				T = queue[front++];
                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));
				result[level][i++] = T->val;
				if(T->left)
                {
                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
                    queue[++rear] = T->left;
                }
				if(T->right)
                {
                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
                    queue[++rear] = T->right;
                }
				QueueSize--;
			}
		}
		else
		{
			while(QueueSize > 0)
			{
				T = queue[front++];
                stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));
				stack[++top] = T;
				if(T->left)
                {
                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
                    queue[++rear] = T->left;
                }
				if(T->right)
                {
                    queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
                    queue[++rear] = T->right;
                }
				QueueSize--;
			}
			while(top != -1)
			{
				T = stack[top--];
                result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));
				result[level][i++] = T->val;
			}
		}
        (*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));
		(*columnSizes)[level++] = i;
		QueueSize = rear - front + 1;
	}

	*returnSize = level;
	return result;
}
```


Overlapping Code:
```
* zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize)
{
struct TreeNode** queue;
int front, rear;
int QueueSize;
struct TreeNode** stack;
int top;
int level, i;
int j, k;
int** result;
struct TreeNode* T;
*returnSize = 0;
if(root == NULL)
return NULL;
front = 0;
rear = -1;
top = -1;
level = 0;
j = 1;
k = 0;
*columnSizes = (int*)malloc(sizeof(int));
result = (int**)malloc(sizeof(int*));
queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*));
stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*));
queue[++rear] = root;
QueueSize= rear - front + 1;
while(QueueSize > 0)
{
i = 0;

result = (int**)realloc(result, (level+1)*sizeof(int*));
result[level] = (int*)malloc(sizeof(int));
if(level % 2 == 0)
{
while(QueueSize > 0)
{
T = queue[front++];
result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));
result[level][i++] = T->val;
if(T->left)
{
queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
queue[++rear] = T->left;
}
if(T->right)
{
queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
queue[++rear] = T->right;
}
QueueSize--;
}
}
else
{
while(QueueSize > 0)
{
T = queue[front++];
stack = (struct TreeNode**)realloc(stack, (++k)*sizeof(struct TreeNode*));
stack[++top] = T;
if(T->left)
{
queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
queue[++rear] = T->left;
}
if(T->right)
{
queue = (struct TreeNode**)realloc(queue, (++j)*sizeof(struct TreeNode*));
queue[++rear] = T->right;
}
QueueSize--;
}
while(top != -1)
{
T = stack[top--];
result[level] = (int*)realloc(result[level], (i+1)*sizeof(int));
result[level][i++] = T->val;
}
}
(*columnSizes) = (int*)realloc((*columnSizes), (level+1)*sizeof(int));
(*columnSizes)[level++] = i;
QueueSize = rear - front + 1;
}
*returnSize = level;
r
```
<Overlap Ratio: 0.9895947426067908>

---

--- 37 --
Question ID: b71717ce3358f1f1db43661e002a0fc0c57dff92_7
Original Code:
```
int8_t mpack_expect_i8(mpack_reader_t* reader) {
    mpack_tag_t var = mpack_read_tag(reader);
    if (var.type == mpack_type_uint) {
        if (var.v.u <= INT8_MAX)
            return (int8_t)var.v.u;
    } else if (var.type == mpack_type_int) {
        if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)
            return (int8_t)var.v.i;
    }
    mpack_reader_flag_error(reader, mpack_error_type);
    return 0;
}
```


Overlapping Code:
```
_expect_i8(mpack_reader_t* reader) {
mpack_tag_t var = mpack_read_tag(reader);
if (var.type == mpack_type_uint) {
if (var.v.u <= INT8_MAX)
return (int8_t)var.v.u;
} else if (var.type == mpack_type_int) {
if (var.v.i >= INT8_MIN && var.v.i <= INT8_MAX)
return (int8_t)var.v.i;
}
mpack_reader_flag_error(reader, mpack_error_type);
return 0;
}
```
<Overlap Ratio: 0.9659090909090909>

---

--- 38 --
Question ID: 6cd6842f459f98b6364b6a9620cda589ecd06443_1
Original Code:
```
TSS2_RC
iesys_MU_BYTE_array_Unmarshal(
    const uint8_t *buffer,
    size_t size,
    size_t *offset,
    size_t count,
    BYTE *dst)
{
    LOG_TRACE("called: count=%zu buffer=%p size=%zu offset=%p dst=%p",
        count, buffer, size, offset, dst);
    return_if_null(buffer, "src=NULL", TSS2_ESYS_RC_BAD_REFERENCE);

    size_t offset_loc = (offset != NULL)? *offset : 0;
    if (dst != NULL)
        memset(dst, 0, sizeof(*dst));

    if (count > size || size - count < offset_loc) {
        LOG_ERROR("not enough space in target buffer");
        return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;
    }

    if (dst != NULL)
        memcpy(dst, &buffer[offset_loc], count);
    offset_loc += count;

    if (offset != NULL)
        *offset = offset_loc;
    return TSS2_RC_SUCCESS;
}
```


Overlapping Code:
```
TSS2_RC
iesys_MU_BYTE_array_Unmarshal(
const uint8_t *buffer,
size_t size,
size_t *offset,
size_t count,
BYTE *dst)
{
LOG_TRACE("called: count=%zu buffer=%p size=%zu offset=%p dst=%p",
count, buffer, size, offset, dst);
return_if_null(buffer, "src=NULL", TSS2_ESYS_RC_BAD_REFERENCE);
size_t offset_loc = (offset != NULL)? *offset : 0;
if (dst != NULL)
memset(dst, 0, sizeof(*dst));
if (count > size || size - count < offset_loc) {
LOG_ERROR("not enough space in target buffer");
return TSS2_ESYS_RC_INSUFFICIENT_BUFFER;
}
if (dst != NULL)
memcpy(dst, &buffer[offset_loc], count);
offset_loc += count;
if (offset != NULL)
*offset = offset_loc;
return TS
```
<Overlap Ratio: 0.9760479041916168>

---

--- 39 --
Question ID: 19fca939331151c84921e15fa45f4ad7cf30d950_3
Original Code:
```
const char *
bcmptm_rm_alpm_kt_name(int u, alpm_key_type_t kt)
{
    char *name;
    switch (kt) {
    case KEY_TYPE_INVALID:
        name = "Invalid";
        break;
    case KEY_IPV4:
        name = "IPv4";
        break;
    case KEY_IPV6_32:
        name = "IPv6-32";
        break;
    case KEY_IPV6_64:
        name = "IPv6-64";
        break;
    case KEY_IPV6_128:
        name = "IPv6-128";
        break;
    default:
        name = "?";
        break;
    }
    return name;
}
```


Overlapping Code:
```
_name(int u, alpm_key_type_t kt)
{
char *name;
switch (kt) {
case KEY_TYPE_INVALID:
name = "Invalid";
break;
case KEY_IPV4:
name = "IPv4";
break;
case KEY_IPV6_32:
name = "IPv6-32";
break;
case KEY_IPV6_64:
name = "IPv6-64";
break;
case KEY_IPV6_128:
name = "IPv6-128";
break;
default:
name = "?";
br
```
<Overlap Ratio: 0.8547008547008547>

---

--- 40 --
Question ID: b4207079b33c970f60153b65d55f237207e07daf_1
Original Code:
```
int b16_decode( char *buf, size_t sz, const void *s, size_t len, size_t *errcnt )
{
    const uint8_t *p = s;
    int c, d;
    size_t i, n, e, err = 0;
    int st = 0;

    for ( i = n = e = 0; i < len; ++i )
    {
        if ( 0 == st )
        {
            c = XTOD( p[i] );
            if ( 0 >  c )
            {
                ++err;
                continue;
            }
        }
        else
        {
            d = XTOD( p[i] );
            if ( 0 >  d )
                ++err;
            else if ( n + 1 < sz )
            {
                buf[n++] = (c << 4) | d;
                e = n;
            }
            else
                ++n;
        }
        st = !st;
    }
    buf[e] = '\0';
    if ( errcnt )
        *errcnt = err;
    return n;
}
```


Overlapping Code:
```
d *s, size_t len, size_t *errcnt )
{
const uint8_t *p = s;
int c, d;
size_t i, n, e, err = 0;
int st = 0;
for ( i = n = e = 0; i < len; ++i )
{
if ( 0 == st )
{
c = XTOD( p[i] );
if ( 0 > c )
{
++err;
continue;
}
}
else
{
d = XTOD( p[i] );
if ( 0 > d )
++err;
else if ( n + 1 < sz )
{
buf[n++] = (c << 4) | d;
e = n;
}
else
++n;
}
st = !st;
}
buf[e] 
```
<Overlap Ratio: 0.7865168539325843>

---

--- 41 --
Question ID: 607734e8c18df708d48b0c15378e6575b6cfe0c8_6
Original Code:
```
int OSPPCommGetTimeout(
    OSPTCOMM *ospvComm,
    unsigned *ospvTimeout)
{
    int errorcode = OSPC_ERR_NO_ERROR;

    if (ospvComm == OSPC_OSNULL) {
        errorcode = OSPC_ERR_COMM_INVALID_ARG;
        OSPM_DBGERRORLOG(errorcode, "ospvComm is NULL");
    } else
        *ospvTimeout = ospvComm->HttpTimeout;

    return errorcode;
}
```


Overlapping Code:
```
Comm,
unsigned *ospvTimeout)
{
int errorcode = OSPC_ERR_NO_ERROR;
if (ospvComm == OSPC_OSNULL) {
errorcode = OSPC_ERR_COMM_INVALID_ARG;
OSPM_DBGERRORLOG(errorcode, "ospvComm is NULL");
} else
*ospvTim
```
<Overlap Ratio: 0.6968641114982579>

---

--- 42 --
Question ID: c1ba92b1192de5d2ab3937aca1a51e42136a1a6b_0
Original Code:
```
auto sieve(unsigned int limit) {
    std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());
    std::vector<unsigned int> out; 
    out.push_back(2);
    for(auto i = 3u; i < limit; i += 2){
       if(candidates[i] == 0) { continue; }
        out.push_back(i);
        for(auto j = 2*i; j < limit; j += i) {
            candidates[j] = 0u;
        }
    }

    return out;
}
```


Overlapping Code:
```
auto sieve(unsigned int limit) {
std::vector<unsigned int> candidates(limit, 1u, std::vector<unsigned int>::allocator_type());
std::vector<unsigned int> out; 
out.push_back(2);
for(auto i = 3u; i < limit; i += 2){
if(candidates[i] == 0) { continue; }
out.push_back(i);
for(auto j = 2*i; j < limit; j 
```
<Overlap Ratio: 0.8695652173913043>

---

--- 43 --
Question ID: db2740a1711889c6c3b617b5fc7947353ca868ea_1
Original Code:
```
void   LSM6DS3_X_GetAxesRaw( int16_t *pData )
{
    /*Here we could add the check if the parameters are valid*/
  
    uint8_t tempReg[2] = {0,0};

    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);
    pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);

    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);
    pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);

    LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);
    pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);
    
}
```


Overlapping Code:
```
xesRaw( int16_t *pData )
{
/*Here we could add the check if the parameters are valid*/

uint8_t tempReg[2] = {0,0};
LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_X_L_XL, 2);
pData[0] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);
LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Y_L_XL, 2);
pData[1] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);
LSM6DS3_IO_Read(&tempReg[0], LSM6DS3_XG_MEMS_ADDRESS, LSM6DS3_XG_OUT_Z_L_XL, 2);
pData[2] = ((((int16_t)tempReg[1]) << 8)+(int16_t)tempReg[0]);

}
```
<Overlap Ratio: 0.9666080843585237>

---

--- 44 --
Question ID: ff73cfa5e7ea8d95165ed0e6c722f3199c3bf2a8_1
Original Code:
```
void SystemInit (void)
{
#if CORTEX_VECTORS_RAM
	// Then assume need to map vectors to RAM
	LPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;
#else
     //	LPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash
#endif
    	
#if (CLOCK_SETUP)                                 /* Clock Setup              */
#if (SYSCLK_SETUP)                                /* System Clock Setup       */
#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */
  uint32_t i;

  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */
  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;
  for (i = 0; i < 200; i++) __NOP();
  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */
  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;
  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */
#if (SYSPLL_SETUP)                                /* System PLL Setup         */
  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */
  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));	      /* Wait Until PLL Locked    */
#endif
#endif
#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/
  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */
#endif
  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */
  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */
  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */
  LPC_SYSCON->MAINCLKUEN    = 0x01;
  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */
#endif

  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;
  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;
  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;
#endif


#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */
  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;
#endif
  SystemCoreClockUpdate();
}
```


Overlapping Code:
```
RAM
// Then assume need to map vectors to RAM
LPC_SYSCON->SYSMEMREMAP = ((LPC_SYSCON->SYSMEMREMAP)& ~3) | 1;
#else
// LPC_SYSCON->SYSMEMREMAP |= 3; // Map to flash
#endif

#if (CLOCK_SETUP) /* Clock Setup */
#if (SYSCLK_SETUP) /* System Clock Setup */
#if (SYSOSC_SETUP) /* System Oscillator Setup */
uint32_t i;
LPC_SYSCON->PDRUNCFG &= ~(1 << 5); /* Power-up System Osc */
LPC_SYSCON->SYSOSCCTRL = SYSOSCCTRL_Val;
for (i = 0; i < 200; i++) __NOP();
LPC_SYSCON->SYSPLLCLKSEL = SYSPLLCLKSEL_Val; /* Select PLL Input */
LPC_SYSCON->SYSPLLCLKUEN = 0x01; /* Update Clock Source */
LPC_SYSCON->SYSPLLCLKUEN = 0x00; /* Toggle Update Register */
LPC_SYSCON->SYSPLLCLKUEN = 0x01;
while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01)); /* Wait Until Updated */
#if (SYSPLL_SETUP) /* System PLL Setup */
LPC_SYSCON->SYSPLLCTRL = SYSPLLCTRL_Val;
LPC_SYSCON->PDRUNCFG &= ~(1 << 7); /* Power-up SYSPLL */
while (!(LPC_SYSCON->SYSPLLSTAT & 0x01)); /* Wait Until PLL Locked */
#endif
#endif
#if (WDTOSC_SETUP) /* Watchdog Oscillator Setup*/
LPC_SYSCON->WDTOSCCTRL = WDTOSCCTRL_Val;
LPC_SYSCON->PDRUNCFG &= ~(1 << 6); /* Power-up WDT Clock */
#endif
LPC_SYSCON->MAINCLKSEL = MAINCLKSEL_Val; /* Select PLL Clock Output */
LPC_SYSCON->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
LPC_SYSCON->MAINCLKUEN = 0x00; /* Toggle Update Register */
LPC_SYSCON->MAINCLKUEN = 0x01;
while (!(LPC_SYSCON->MAINCLKUEN & 0x01)); /* Wait Until Updated */
#endif
LPC_SYSCON->SYSAHBCLKDIV = SYSAHBCLKDIV_Val;
LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
LPC_SYSCON->SSP0CLKDIV = SSP0CLKDIV_Val;
LPC_SYSCON->UARTCLKDIV = UARTCLKDIV_Val;
LPC_SYSCON->SSP1CLKDIV = SSP1CLKDIV_Val;
#endif
#if (MEMMAP_SETUP || MEMMAP_INIT) /* Memory Mapping Setup */
LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;
#endif
```
<Overlap Ratio: 0.9610104338275672>

---

--- 45 --
Question ID: 428a5c9457d7574e03b03de7b267e80bff3f2e26_29
Original Code:
```
void vmx_update_debug_state(struct vcpu *v)
{
    unsigned long mask;

    ASSERT(v == current);

    mask = 1u << TRAP_int3;
    if ( !cpu_has_monitor_trap_flag )
        mask |= 1u << TRAP_debug;

    if ( v->arch.hvm_vcpu.debug_state_latch )
        v->arch.hvm_vmx.exception_bitmap |= mask;
    else
        v->arch.hvm_vmx.exception_bitmap &= ~mask;
    vmx_update_exception_bitmap(v);
}
```


Overlapping Code:
```
unsigned long mask;
ASSERT(v == current);
mask = 1u << TRAP_int3;
if ( !cpu_has_monitor_trap_flag )
mask |= 1u << TRAP_debug;
if ( v->arch.hvm_vcpu.debug_state_latch )
v->arch.hvm_vmx.exception_bitmap |= mask;
else
v->arch.hvm_vmx.exception_bitmap &=
```
<Overlap Ratio: 0.7418397626112759>

---

--- 46 --
Question ID: 3115662c93eee0506e2f89c81b2686ba98005201_24
Original Code:
```
static void emit_rebox_value(lily_emit_state *emit, lily_type *new_type,
        lily_ast *ast)
{
    lily_storage *storage = get_storage(emit, new_type);

    /* Don't allow a bare variant to be thrown into an any until it's thrown
       into an enum box first. */
    if (new_type->cls->id == SYM_CLASS_ANY &&
        ast->result->type->cls->flags & CLS_VARIANT_CLASS) {
        rebox_variant_to_enum(emit, ast);
    }

    write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,
            storage->reg_spot);

    ast->result = (lily_sym *)storage;
}
```


Overlapping Code:
```
_value(lily_emit_state *emit, lily_type *new_type,
lily_ast *ast)
{
lily_storage *storage = get_storage(emit, new_type);
/* Don't allow a bare variant to be thrown into an any until it's thrown
into an enum box first. */
if (new_type->cls->id == SYM_CLASS_ANY &&
ast->result->type->cls->flags & CLS_VARIANT_CLASS) {
rebox_variant_to_enum(emit, ast);
}
write_4(emit, o_assign, ast->line_num, ast->result->reg_spot,
storage->reg_spot);
ast->result = (l
```
<Overlap Ratio: 0.9146341463414634>

---

--- 47 --
Question ID: 5963ac12be07e41ca5ebe0ea8de94b8e2f55f0eb_0
Original Code:
```
eye_buf_t *eye_create_buf(eye_pool_t *pool, size_t size)
{
	eye_buf_t *b;

	b = eye_calloc_buf(pool);
	if (b == NULL) {
		return NULL;
	}

	b->start = eye_palloc(pool, size);
	if (b->start == NULL) {
		return NULL;
	}

	b->pos = b->start;
	b->last = b->start;
	b->end = b->last+size;

	return b;
}
```


Overlapping Code:
```
e_pool_t *pool, size_t size)
{
eye_buf_t *b;
b = eye_calloc_buf(pool);
if (b == NULL) {
return NULL;
}
b->start = eye_palloc(pool, size);
if (b->start == NULL) {
return NULL;
}
b->pos = b->start;
b->last = b->start;
b->end = b->last+size;
return b;
}
```
<Overlap Ratio: 0.8992805755395683>

---

--- 48 --
Question ID: 52041092ea22f29a5386520d8f56251651b5062c_99
Original Code:
```
void smt2_set_info(const char *name, aval_t value) {
  smt2_globals_t *g;
  smt2_keyword_t kw;
  uint32_t n, version;

  g = &__smt2_globals;

  n = kwlen(name);
  kw = smt2_string_to_keyword(name, n);

  switch (kw) {
  case SMT2_KW_ERROR_BEHAVIOR:
  case SMT2_KW_NAME:
  case SMT2_KW_AUTHORS:
  case SMT2_KW_VERSION:
  case SMT2_KW_REASON_UNKNOWN:
  case SMT2_KW_ALL_STATISTICS:
    print_error("can't overwrite %s", name);
    break;

  case SMT2_KW_SMT_LIB_VERSION:
    // quick hack to switch parser if 2.5 is selected
    if (g->smtlib_version != 0) {
      print_error("can't set :smt-lib-version twice");
    } else if (aval_is_known_version(g->avtbl, value, &version)) {
      assert(version == 2000 || version == 2500);
      g->smtlib_version = version;
      if (version == 2500) {
	smt2_lexer_activate_two_dot_five();
      }
      report_success();
    } else {
      print_error("unsupported :smt-lib-version");
    }
    break;

  default:
    add_info(g, name, value);
    report_success();
    break;
  }
}
```


Overlapping Code:
```
t char *name, aval_t value) {
smt2_globals_t *g;
smt2_keyword_t kw;
uint32_t n, version;
g = &__smt2_globals;
n = kwlen(name);
kw = smt2_string_to_keyword(name, n);
switch (kw) {
case SMT2_KW_ERROR_BEHAVIOR:
case SMT2_KW_NAME:
case SMT2_KW_AUTHORS:
case SMT2_KW_VERSION:
case SMT2_KW_REASON_UNKNOWN:
case SMT2_KW_ALL_STATISTICS:
print_error("can't overwrite %s", name);
break;
case SMT2_KW_SMT_LIB_VERSION:
// quick hack to switch parser if 2.5 is selected
if (g->smtlib_version != 0) {
print_error("can't set :smt-lib-version twice");
} else if (aval_is_known_version(g->avtbl, value, &version)) {
assert(version == 2000 || version == 2500);
g->smtlib_version = version;
if (version == 2500) {
smt2_lexer_activate_two_dot_five();
}
report_success();
} else {
print_error("unsupported :smt-lib-version");
}
break;
default:
add_info(g, name, value);
repo
```
<Overlap Ratio: 0.9477777777777778>

---

--- 49 --
Question ID: 6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_32
Original Code:
```
void set_current_particle_texture(ParticleSettings *part, Tex *newtex)
{
	int act = part->texact;

	if (part->mtex[act] && part->mtex[act]->tex)
		id_us_min(&part->mtex[act]->tex->id);

	if (newtex) {
		if (!part->mtex[act]) {
			part->mtex[act] = BKE_texture_mtex_add();
			part->mtex[act]->texco = TEXCO_ORCO;
			part->mtex[act]->blendtype = MTEX_MUL;
		}
		
		part->mtex[act]->tex = newtex;
		id_us_plus(&newtex->id);
	}
	else if (part->mtex[act]) {
		MEM_freeN(part->mtex[act]);
		part->mtex[act] = NULL;
	}
}
```


Overlapping Code:
```
current_particle_texture(ParticleSettings *part, Tex *newtex)
{
int act = part->texact;
if (part->mtex[act] && part->mtex[act]->tex)
id_us_min(&part->mtex[act]->tex->id);
if (newtex) {
if (!part->mtex[act]) {
part->mtex[act] = BKE_texture_mtex_add();
part->mtex[act]->texco = TEXCO_ORCO;
part->mtex[act]->blendtype = MTEX_MUL;
}

part->mtex[act]->tex = newtex;
id_us_plus(&newtex->id);
}
else if (part->mtex[act]) {
MEM_freeN(part->mtex[act]);
part->mtex[act]
```
<Overlap Ratio: 0.95625>

---

--- 50 --
Question ID: 3c91d3ab18514d926a8787931b798035fe031cb5_2
Original Code:
```
void JNICALL testNativeMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,
                      jthread thread, jmethodID mid, void* func, void** func_ptr) {
    jvmtiPhase phase;
    char *mname;
    char *signature;
    jint ret;

    ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);
    if (ret != JVMTI_ERROR_NONE) {
      printf("Error: GetPhase %d\n", ret);
      iGlobalStatus = 2;
      return;
    }

    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)
        return;

    debug_printf("bind event: \n");
    print_method_name(mid);

    ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);
    if (ret == JVMTI_ERROR_NONE) {
      if (strcmp(mname, "findLoadedClass") == 0) {
        findLoadedClass_func = (findLoadClass_type)func;
        *func_ptr = (void*)my_findLoadedClass;
        debug_printf("REDIRECTED findLoadedClass\n");
      }
    }
}
```


Overlapping Code:
```
tiveMethodBind(jvmtiEnv* jvmti_env, JNIEnv *jni_env,
jthread thread, jmethodID mid, void* func, void** func_ptr) {
jvmtiPhase phase;
char *mname;
char *signature;
jint ret;
ret = (*jvmti_env)->GetPhase(jvmti_env, &phase);
if (ret != JVMTI_ERROR_NONE) {
printf("Error: GetPhase %d\n", ret);
iGlobalStatus = 2;
return;
}
if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE)
return;
debug_printf("bind event: \n");
print_method_name(mid);
ret = (*jvmti_env)->GetMethodName(jvmti_env, mid, &mname, &signature, NULL);
if (ret == JVMTI_ERROR_NONE) {
if (strcmp(mname, "findLoadedClass") == 0) {
findLoadedClass_func = (findLoadClass_type)func;
*func_ptr = (void*)my_findLoadedClass;
debug_printf("R
```
<Overlap Ratio: 0.9271523178807947>

---

--- 51 --
Question ID: 9eea3a10a7307de6b68ff5398cc80c651c6a7a2d_2
Original Code:
```
static void
rndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)
{
	if (ob->size) hoedown_buffer_putc(ob, '\n');

	if (lang) {
		HOEDOWN_BUFPUTSL(ob, "<pre><code class=\"language-");
		escape_html(ob, lang->data, lang->size);
		HOEDOWN_BUFPUTSL(ob, "\">");
	} else {
		HOEDOWN_BUFPUTSL(ob, "<pre><code>");
	}

	if (text)
		escape_html(ob, text->data, text->size);

	HOEDOWN_BUFPUTSL(ob, "</code></pre>\n");
}
```


Overlapping Code:
```
ndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)
{
if (ob->size) hoedown_buffer_putc(ob, '\n');
if (lang) {
HOEDOWN_BUFPUTSL(ob, "<pre><code class=\"language-");
escape_html(ob, lang->data, lang->size);
HOEDOWN_BUFPUTSL(ob, "\">");
} else {
HOEDOWN_BUFPUTSL(ob, "<pre><code>");
}
if (text)
escape_html(ob, text->data, text->size);
HOEDOWN_BUFPUTSL(ob, "</code></pre>\n");
```
<Overlap Ratio: 0.9675324675324676>

---

--- 52 --
Question ID: df356c375ba004290f2c4a213f5291ad70995822_1
Original Code:
```
static void tscpu_fast_initial_sw_workaround(void)
{
	int i = 0;
	unsigned long flags;
	/* tscpu_printk("tscpu_fast_initial_sw_workaround\n"); */

	/* tscpu_thermal_clock_on(); */

	mt_ptp_lock(&flags);

	for (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {
		tscpu_switch_bank(i);
		tscpu_thermal_fast_init();
	}

	mt_ptp_unlock(&flags);

}
```


Overlapping Code:
```
tic void tscpu_fast_initial_sw_workaround(void)
{
int i = 0;
unsigned long flags;
/* tscpu_printk("tscpu_fast_initial_sw_workaround\n"); */
/* tscpu_thermal_clock_on(); */
mt_ptp_lock(&flags);
for (i = 0; i < TS_LEN_ARRAY(tscpu_g_bank); i++) {
tscpu_switch_bank(i);
tscpu_thermal_fast_init();
}
mt_pt
```
<Overlap Ratio: 0.9316770186335404>

---

--- 53 --
Question ID: fd1867128f756754c01e89d416b432f573e59ede_2
Original Code:
```
bool dble_less_than(double x, double y, int precision)
{
	// LOCAL VARIABLES
	bool retVal = false;  // Prove this wrong
	bool success = true;  // Set this to false if anything fails
	double dbleMask = 0;  // "Mask" to remove undesired values of doubles
	double xVal = truncate_double(x, precision);
	double yVal = truncate_double(y, precision);
	
	// INPUT VALIDATION
	if (precision < 1)
	{
		HARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);
		success = false;
	}
	
	// CALC PRECISION
	if (true == success)
	{
		dbleMask = calc_precision(precision);
		
		if (!dbleMask)
		{
			HARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);
			success = false;
		}
		// fprintf(stdout, "\nx == %.15f\ty == %.15f\tdbleMask == %.15f\n", x, y, dbleMask);  // DEBUGGING
		// fprintf(stdout, "\nxTrunc == %.15f\tyTrunc == %.15f\tprecision == %d\n\t\t", xVal, yVal, precision);  // DEBUGGING
	}
	
	// COMPARE DOUBLES
	if (true == success)
	{
		// fprintf(stdout, "\nx == %.15f\ty == %.15f\tdbleMask == %.15f\n", x, y, dbleMask);  // DEBUGGING
		// fprintf(stdout, "x < y == %.15f < %.15f == %s\n", x, y, (x < y) ? "true" : "false");  // DEBUGGING
		// fprintf(stdout, "(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\n", \
		// 	x + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? "true" : "false");  // DEBUGGING
		// fprintf(stdout, "(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\n\t\t", \
		// 	x - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? "true" : "false");  // DEBUGGING
		if (xVal < yVal)
		// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))
		{
			retVal = true;	
		}		
	}	
	
	// DONE
	return retVal;
}
```


Overlapping Code:
```
n(double x, double y, int precision)
{
// LOCAL VARIABLES
bool retVal = false; // Prove this wrong
bool success = true; // Set this to false if anything fails
double dbleMask = 0; // "Mask" to remove undesired values of doubles
double xVal = truncate_double(x, precision);
double yVal = truncate_double(y, precision);

// INPUT VALIDATION
if (precision < 1)
{
HARKLE_ERROR(Harklemath, dble_greater_than, Invalid precision);
success = false;
}

// CALC PRECISION
if (true == success)
{
dbleMask = calc_precision(precision);

if (!dbleMask)
{
HARKLE_ERROR(Harklemath, dble_greater_than, calc_precision failed);
success = false;
}
// fprintf(stdout, "\nx == %.15f\ty == %.15f\tdbleMask == %.15f\n", x, y, dbleMask); // DEBUGGING
// fprintf(stdout, "\nxTrunc == %.15f\tyTrunc == %.15f\tprecision == %d\n\t\t", xVal, yVal, precision); // DEBUGGING
}

// COMPARE DOUBLES
if (true == success)
{
// fprintf(stdout, "\nx == %.15f\ty == %.15f\tdbleMask == %.15f\n", x, y, dbleMask); // DEBUGGING
// fprintf(stdout, "x < y == %.15f < %.15f == %s\n", x, y, (x < y) ? "true" : "false"); // DEBUGGING
// fprintf(stdout, "(x + dbleMask) < (y + dbleMask) == %.15f < %.15f == %s\n", \
// x + dbleMask, y + dbleMask, ((x + dbleMask) < (y + dbleMask)) ? "true" : "false"); // DEBUGGING
// fprintf(stdout, "(x - dbleMask) < (y - dbleMask) == %.15f < %.15f == %s\n\t\t", \
// x - dbleMask, y - dbleMask, ((x - dbleMask) < (y - dbleMask)) ? "true" : "false"); // DEBUGGING
if (xVal < yVal)
// if (x < y && (x + dbleMask) < (y + dbleMask) && (x - dbleMask) < (y - dbleMask))
{
retVal = true; 
} 
} 

// DONE
return retVal;

```
<Overlap Ratio: 0.9882643607164917>

---

--- 54 --
Question ID: 3d1a1307259533a4e9010bd1bc617353da07e815_0
Original Code:
```
NS_SCRIPTABLE nsIRDFXMLParser : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)

  /**
     * Create a stream listener that can be used to asynchronously
     * parse RDF/XML.
     * @param aSink the RDF datasource the will receive the data
     * @param aBaseURI the base URI used to resolve relative
     *   references in the RDF/XML
     * @return an nsIStreamListener object to handle the data
     */
  /* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */
  NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;

  /**
     * Parse a string of RDF/XML
     * @param aSink the RDF datasource that will receive the data
     * @param aBaseURI the base URI used to resolve relative
     *   references in the RDF/XML
     * @param aSource a UTF8 string containing RDF/XML data.
     */
  /* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */
  NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSource) = 0;

}
```


Overlapping Code:
```
E nsIRDFXMLParser : public nsISupports {
public: 
NS_DECLARE_STATIC_IID_ACCESSOR(NS_IRDFXMLPARSER_IID)
/**
* Create a stream listener that can be used to asynchronously
* parse RDF/XML.
* @param aSink the RDF datasource the will receive the data
* @param aBaseURI the base URI used to resolve relative
* references in the RDF/XML
* @return an nsIStreamListener object to handle the data
*/
/* nsIStreamListener parseAsync (in nsIRDFDataSource aSink, in nsIURI aBaseURI); */
NS_SCRIPTABLE NS_IMETHOD ParseAsync(nsIRDFDataSource *aSink, nsIURI *aBaseURI, nsIStreamListener **_retval NS_OUTPARAM) = 0;
/**
* Parse a string of RDF/XML
* @param aSink the RDF datasource that will receive the data
* @param aBaseURI the base URI used to resolve relative
* references in the RDF/XML
* @param aSource a UTF8 string containing RDF/XML data.
*/
/* void parseString (in nsIRDFDataSource aSink, in nsIURI aBaseURI, in AUTF8String aSource); */
NS_SCRIPTABLE NS_IMETHOD ParseString(nsIRDFDataSource *aSink, nsIURI *aBaseURI, const nsACString & aSo
```
<Overlap Ratio: 0.9772942289498581>

---

--- 55 --
Question ID: 9e57b77ecd34ef3367ed64b4105c5ce65e3c724f_10
Original Code:
```
static struct f71805f_data *f71805f_update_device(struct device *dev)
{
	struct f71805f_data *data = dev_get_drvdata(dev);
	int nr, apnr;

	mutex_lock(&data->update_lock);

	/* Limit registers cache is refreshed after 60 seconds */
	if (time_after(jiffies, data->last_updated + 60 * HZ)
	 || !data->valid) {
		for (nr = 0; nr < 11; nr++) {
			if (!(data->has_in & (1 << nr)))
				continue;
			data->in_high[nr] = f71805f_read8(data,
					    F71805F_REG_IN_HIGH(nr));
			data->in_low[nr] = f71805f_read8(data,
					   F71805F_REG_IN_LOW(nr));
		}
		for (nr = 0; nr < 3; nr++) {
			data->fan_low[nr] = f71805f_read16(data,
					    F71805F_REG_FAN_LOW(nr));
			data->fan_target[nr] = f71805f_read16(data,
					       F71805F_REG_FAN_TARGET(nr));
			data->pwm_freq[nr] = f71805f_read8(data,
					     F71805F_REG_PWM_FREQ(nr));
		}
		for (nr = 0; nr < 3; nr++) {
			data->temp_high[nr] = f71805f_read8(data,
					      F71805F_REG_TEMP_HIGH(nr));
			data->temp_hyst[nr] = f71805f_read8(data,
					      F71805F_REG_TEMP_HYST(nr));
		}
		data->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);
		for (nr = 0; nr < 3; nr++) {
			for (apnr = 0; apnr < 3; apnr++) {
				data->auto_points[nr].temp[apnr] =
					f71805f_read8(data,
					F71805F_REG_PWM_AUTO_POINT_TEMP(nr,
									apnr));
				data->auto_points[nr].fan[apnr] =
					f71805f_read16(data,
					F71805F_REG_PWM_AUTO_POINT_FAN(nr,
								       apnr));
			}
		}

		data->last_limits = jiffies;
	}

	/* Measurement registers cache is refreshed after 1 second */
	if (time_after(jiffies, data->last_updated + HZ)
	 || !data->valid) {
		for (nr = 0; nr < 11; nr++) {
			if (!(data->has_in & (1 << nr)))
				continue;
			data->in[nr] = f71805f_read8(data,
				       F71805F_REG_IN(nr));
		}
		for (nr = 0; nr < 3; nr++) {
			data->fan[nr] = f71805f_read16(data,
					F71805F_REG_FAN(nr));
			data->fan_ctrl[nr] = f71805f_read8(data,
					     F71805F_REG_FAN_CTRL(nr));
			data->pwm[nr] = f71805f_read8(data,
					F71805F_REG_PWM_DUTY(nr));
		}
		for (nr = 0; nr < 3; nr++) {
			data->temp[nr] = f71805f_read8(data,
					 F71805F_REG_TEMP(nr));
		}
		data->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))
			+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)
			+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);

		data->last_updated = jiffies;
		data->valid = 1;
	}

	mutex_unlock(&data->update_lock);

	return data;
}
```


Overlapping Code:
```
1805f_data *f71805f_update_device(struct device *dev)
{
struct f71805f_data *data = dev_get_drvdata(dev);
int nr, apnr;
mutex_lock(&data->update_lock);
/* Limit registers cache is refreshed after 60 seconds */
if (time_after(jiffies, data->last_updated + 60 * HZ)
|| !data->valid) {
for (nr = 0; nr < 11; nr++) {
if (!(data->has_in & (1 << nr)))
continue;
data->in_high[nr] = f71805f_read8(data,
F71805F_REG_IN_HIGH(nr));
data->in_low[nr] = f71805f_read8(data,
F71805F_REG_IN_LOW(nr));
}
for (nr = 0; nr < 3; nr++) {
data->fan_low[nr] = f71805f_read16(data,
F71805F_REG_FAN_LOW(nr));
data->fan_target[nr] = f71805f_read16(data,
F71805F_REG_FAN_TARGET(nr));
data->pwm_freq[nr] = f71805f_read8(data,
F71805F_REG_PWM_FREQ(nr));
}
for (nr = 0; nr < 3; nr++) {
data->temp_high[nr] = f71805f_read8(data,
F71805F_REG_TEMP_HIGH(nr));
data->temp_hyst[nr] = f71805f_read8(data,
F71805F_REG_TEMP_HYST(nr));
}
data->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);
for (nr = 0; nr < 3; nr++) {
for (apnr = 0; apnr < 3; apnr++) {
data->auto_points[nr].temp[apnr] =
f71805f_read8(data,
F71805F_REG_PWM_AUTO_POINT_TEMP(nr,
apnr));
data->auto_points[nr].fan[apnr] =
f71805f_read16(data,
F71805F_REG_PWM_AUTO_POINT_FAN(nr,
apnr));
}
}
data->last_limits = jiffies;
}
/* Measurement registers cache is refreshed after 1 second */
if (time_after(jiffies, data->last_updated + HZ)
|| !data->valid) {
for (nr = 0; nr < 11; nr++) {
if (!(data->has_in & (1 << nr)))
continue;
data->in[nr] = f71805f_read8(data,
F71805F_REG_IN(nr));
}
for (nr = 0; nr < 3; nr++) {
data->fan[nr] = f71805f_read16(data,
F71805F_REG_FAN(nr));
data->fan_ctrl[nr] = f71805f_read8(data,
F71805F_REG_FAN_CTRL(nr));
data->pwm[nr] = f71805f_read8(data,
F71805F_REG_PWM_DUTY(nr));
}
for (nr = 0; nr < 3; nr++) {
data->temp[nr] = f71805f_read8(data,
F71805F_REG_TEMP(nr));
}
data->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))
+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)
+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);
data->last_updated = jiffies;
data->valid = 1;
}
mutex_unlock(&data->update_lock);
return data;
}
```
<Overlap Ratio: 0.9924026590693258>

---

--- 56 --
Question ID: 0ea925238d379dc010b281b4b60e34536a1eb9c5_0
Original Code:
```
interface _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {
    long long  _activityType;
    NSArray * _modules;
    id /* block */  _objectHandler;
    NSOperationQueue * _operationQueue;
    HKQuantity * _speed;
}
```


Overlapping Code:
```
face _HDDataFaker : NSObject <_HDDemoDataModuleDelegate> {
long long _activityType;
NSArray * _modules;
id /* block */ _objectHandler;
NSOperationQueue * _operationQue
```
<Overlap Ratio: 0.8434343434343434>

---

--- 57 --
Question ID: 2a511de37361d5dd5980337de8f35cb5e4df4314_1
Original Code:
```
size_t wcstombs(char* mbstr, const wchar_t *wcstr, size_t max)
{
  int count = 0;

  while ((count < max) && (*wcstr != 0))
  {
    *mbstr++ = *wcstr++;
    count++;
  }
  return count;
}
```


Overlapping Code:
```
stombs(char* mbstr, const wchar_t *wcstr, size_t max)
{
int count = 0;
while ((count < max) && (*wcstr != 0))
{
*mbstr++ = *wcstr++;
count++;
}
return count
```
<Overlap Ratio: 0.9285714285714286>

---

--- 58 --
Question ID: ce62987c67acf5f3c9afa731f3cda369023a60b9_51
Original Code:
```
JNICALL Java_com_mylexz_utils_PrimitiveData_addStrArray
  (JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){
	  jint __desc = __getDescriptor(env, thiz);
	  if(__desc == -1)return;
	  PDATA *pdata = __content(__current, __desc);
	  const char *elem = (*env)->GetStringUTFChars(env, element, 0);
	  if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){
	  	(*env)->ReleaseStringUTFChars(env, element, elem);
	  	return;
	  }
	  extern int checkExistsElem(char *, FILE *, char *, off_t);
	  extern void __passToFile(char *, FILE *, int, int);
	  
	// Copying pointers from pdata to temp and rdfiles
	  FILE* rd = pdata->rd;
	  char* temp = pdata->temp;
	  int* errnum = &(pdata->errnum);
	  off_t offset = ftell(rd);
	  if(checkExistsElem(temp, rd, elem, offset)){
		  fseek(rd, offset, 0);
		  *errnum = -2;
		  (*env)->ReleaseStringUTFChars(env, element, elem);
		  return;
	}
	// writing first content
	fprintf(rd, "%c%c%s%c", ID_ARR, STR, elem, BUKA);
	// writing content array
	size_t x = 0;
	for (; x < size; x++){
		jstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);
		const char *n = (*env)->GetStringUTFChars(env, a, 0);
		strcpy(temp, n);
		edStr(temp, ENC);
		__passToFile(temp, rd, x, size);
		(*env)->ReleaseStringUTFChars(env, a, n);
	}
    fseek(rd, offset, 0);
	*errnum = 0;
	(*env)->ReleaseStringUTFChars(env, element, elem);
	return;
	  
  }
```


Overlapping Code:
```
ddStrArray
(JNIEnv *env, jobject thiz, jstring element, jobjectArray arrStr, jint size){
jint __desc = __getDescriptor(env, thiz);
if(__desc == -1)return;
PDATA *pdata = __content(__current, __desc);
const char *elem = (*env)->GetStringUTFChars(env, element, 0);
if(((jint)(*env)->GetArrayLength(env, arrStr)) < size){
(*env)->ReleaseStringUTFChars(env, element, elem);
return;
}
extern int checkExistsElem(char *, FILE *, char *, off_t);
extern void __passToFile(char *, FILE *, int, int);

// Copying pointers from pdata to temp and rdfiles
FILE* rd = pdata->rd;
char* temp = pdata->temp;
int* errnum = &(pdata->errnum);
off_t offset = ftell(rd);
if(checkExistsElem(temp, rd, elem, offset)){
fseek(rd, offset, 0);
*errnum = -2;
(*env)->ReleaseStringUTFChars(env, element, elem);
return;
}
// writing first content
fprintf(rd, "%c%c%s%c", ID_ARR, STR, elem, BUKA);
// writing content array
size_t x = 0;
for (; x < size; x++){
jstring a = (jstring) (*env)->GetObjectArrayElement(env, arrStr, x);
const char *n = (*env)->GetStringUTFChars(env, a, 0);
strcpy(temp, n);
edStr(temp, ENC);
__passToFile(temp, rd, x, size);
(*env)->ReleaseStringUTFChars(env, a, n);
}
fseek(rd, offset, 0);
*errnum = 0;
(*env)->ReleaseStringUTFChars(env, element, elem);
r
```
<Overlap Ratio: 0.9585889570552147>

---

--- 59 --
Question ID: db9152239f9d403fcd42c93ed2f63fc51c367351_0
Original Code:
```
ZEPHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {

	ZEPHIR_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("dialectType"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("type"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;

}
```


Overlapping Code:
```
PHIR_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite) {
ZEPHIR_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Sqlite, phalcon, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);
zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("dialectType"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);
zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("type"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);
return SUCCESS;
}
```
<Overlap Ratio: 0.9957805907172996>

---

--- 60 --
Question ID: 48dc05815cd8d08cc9c305eda4489aa53a919a18_9
Original Code:
```
static int
bcmtm_egr_sp_thd_init(int unit)
{
    bcmdrd_sid_t sid = 0;
    bcmdrd_fid_t fid;
    bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;
    size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;
    size_t count = 0;
    bcmbd_pt_dyn_info_t pt_dyn_info;
    uint32_t limit = 0;
    uint32_t ltmbuf = 0;
    uint32_t fval = 0;
    int pipe = 0;

    SHR_FUNC_ENTER(unit);

    limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;
    while(count < num_fid) {
        if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {
            count++;
            continue;
        }
        ltmbuf = 0;
        switch(count) {
            case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_SHARED_LIMITr;
                fid = SHARED_LIMITf;
                fval = limit;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_RESUME_LIMITr;
                fid = RESUME_LIMITf;
                fval = limit/8;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;
                fid = YELLOW_SHARED_LIMITf;
                fval = limit/8;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;
                fid = YELLOW_RESUME_LIMITf;
                fval = limit/8;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;
                fid = RED_SHARED_LIMITf;
                fval = limit/8;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:
                sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;
                fid = RED_RESUME_LIMITf;
                fval = limit/8;
                SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
                break;
            default:
                sid = 0;
                break;
        }
        for (pipe = 0; pipe < 4 && sid != 0 ; pipe++) {
            BCMTM_PT_DYN_INFO(pt_dyn_info, 0, pipe);
                SHR_IF_ERR_EXIT(bcmtm_pt_indexed_write(unit, sid, ltid,
                            (void*)&pt_dyn_info, &ltmbuf));
        }
        count++;
    }
exit:
    SHR_FUNC_EXIT();
}
```


Overlapping Code:
```
nt unit)
{
bcmdrd_sid_t sid = 0;
bcmdrd_fid_t fid;
bcmltd_sid_t ltid = TM_THD_EGR_SERVICE_POOLt;
size_t num_fid = TM_THD_EGR_SERVICE_POOLt_FIELD_COUNT;
size_t count = 0;
bcmbd_pt_dyn_info_t pt_dyn_info;
uint32_t limit = 0;
uint32_t ltmbuf = 0;
uint32_t fval = 0;
int pipe = 0;
SHR_FUNC_ENTER(unit);
limit = bcmtm_device_info[unit].num_cells - (44 + bcmtm_dev_buf_info.asf_rsvd) - 44;
while(count < num_fid) {
if (count == TM_THD_EGR_SERVICE_POOLt_TM_THD_SERVICE_POOL_IDf) {
count++;
continue;
}
ltmbuf = 0;
switch(count) {
case TM_THD_EGR_SERVICE_POOLt_SHARED_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_SHARED_LIMITr;
fid = SHARED_LIMITf;
fval = limit;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break;
case TM_THD_EGR_SERVICE_POOLt_SHARED_RESUME_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_RESUME_LIMITr;
fid = RESUME_LIMITf;
fval = limit/8;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break;
case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;
fid = YELLOW_SHARED_LIMITf;
fval = limit/8;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break;
case TM_THD_EGR_SERVICE_POOLt_YELLOW_SHARED_RESUME_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr;
fid = YELLOW_RESUME_LIMITf;
fval = limit/8;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break;
case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;
fid = RED_SHARED_LIMITf;
fval = limit/8;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break;
case TM_THD_EGR_SERVICE_POOLt_RED_SHARED_RESUME_LIMIT_CELLSf:
sid = MMU_THDM_DB_POOL_RED_RESUME_LIMITr;
fid = RED_RESUME_LIMITf;
fval = limit/8;
SHR_IF_ERR_EXIT(bcmtm_field_set(unit, sid, fid, &ltmbuf, &fval));
break
```
<Overlap Ratio: 0.9809264305177112>

---

--- 61 --
Question ID: bde7fdb25304bec4c2eb661993c355f21401164d_18
Original Code:
```
void* dR_list_next(dR_List* list)
{
    void* ret;
    if(list->iterator!=NULL)
    {
        if(list->iterator->next == NULL)
        {
            list->iterator = NULL;
            ret = NULL;
        }
        else
        {
            list->iterator = list->iterator->next;
            ret = list->iterator->element;
        }
    }
    else
    {
        list->iterator = list->first;
        if(list->iterator!=NULL)
        {
            ret = list->iterator->element;
        }
        else
        {
            ret = NULL;
        }
    }
    return ret;
}
```


Overlapping Code:
```

{
void* ret;
if(list->iterator!=NULL)
{
if(list->iterator->next == NULL)
{
list->iterator = NULL;
ret = NULL;
}
else
{
list->iterator = list->iterator->next;
ret = list->iterator->element;
}
}
else
{
list->iterator = list->first;
if(list->iterator!=NULL)
{
ret = list->iterator->element;
}
else
{
re
```
<Overlap Ratio: 0.8333333333333334>

---

--- 62 --
Question ID: 3e0596414bff363fd84683ef6318e53f7a3abc1d_24
Original Code:
```
static void ROL() {
    BYTE result = cpu.operand << 1;
    result |= GET_FLAG(FLAG_C);
    CALC_C(cpu.operand & 0x80);
    CALC_Z(result);
    CALC_N(result);
    Memory_WriteByte(MAP_CPU, cpu.operaddr, result);
}
```


Overlapping Code:
```
perand << 1;
result |= GET_FLAG(FLAG_C);
CALC_C(cpu.operand & 0x80);
CALC_Z(result);
CALC_N(result);
Memory_WriteByte(MAP_CPU, cpu.operaddr, result);

```
<Overlap Ratio: 0.7894736842105263>

---

--- 63 --
Question ID: 63ecf77d31e5552017e09759b47aeb1545443ee5_9
Original Code:
```
void musb_start(struct musb *musb)
{
	u8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);

	dev_dbg(musb->controller, "<== devctl %02x\n", devctl);

	os_printk(K_INFO, "%s\n", __func__);

	if (musb->is_clk_on == 0) {
#ifndef CONFIG_MTK_FPGA
		/* Recovert PHY. And turn on CLK. */
		usb_phy_recover(musb->is_clk_on);
		musb->is_clk_on = 1;

		/* USB 2.0 slew rate calibration */
		u3phy_ops->u2_slew_rate_calibration(u3phy);
#endif

		/* disable IP reset and power down, disable U2/U3 ip power down */
		_ex_mu3d_hal_ssusb_en();

		/* USB PLL Force settings */
#ifdef CONFIG_PROJECT_PHY
		usb20_pll_settings(false, false);
#endif

		/* reset U3D all dev module. */
		mu3d_hal_rst_dev();

		/*
		 * SW workaround of SSUSB device mode fake disable interrupt
		 * 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()
		 * 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()
		 * 3. Delay 50us
		 * 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()
		 * Recommended value : 50us
		 */
		udelay(20);

		musb_restore_context(musb);
	}

	/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */
	os_writel(U3D_LV1IESR, 0xFFFFFFFF);

	/* Initialize the default interrupts */
	_ex_mu3d_hal_system_intr_en();

#ifdef USB_GADGET_SUPERSPEED
	/* HS/FS detected by HW */
	/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */
	os_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));

	/* set LPM remote wake up enable by HW */
	os_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));
	os_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));
	os_writel(U3D_USB2_EPCTL_LPM_FC_CHK,
		  (L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));

#ifdef CONFIG_USBIF_COMPLIANCE
	/* Accept LGO_U1/U2 at beginning */
	os_writel(U3D_LINK_POWER_CONTROL,
		  os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);

	/* 3us timeout for PENDING HP */
	os_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);

	/* set vbus force enable */
	os_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));
#endif

	/* device responses to u3_exit from host automatically */
	os_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);

#else
#ifdef USB_GADGET_DUALSPEED
	/* HS/FS detected by HW */
	os_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);
#else
	/* FS only */
	os_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) & ~HS_ENABLE);
#endif
	/* disable U3 port */
	mu3d_hal_u3dev_dis();
#endif

#ifndef CONFIG_MTK_FPGA
	/*if (mt_get_chip_hw_code() == 0x6595) */
	{
		os_printk(K_INFO, "%s Set Clock to 62.4MHz+\n", __func__);
		/* sys_ck = OSC 124.8MHz/2 = 62.4MHz */
		os_setmsk(U3D_SSUSB_SYS_CK_CTRL, SSUSB_SYS_CK_DIV2_EN);
		/* U2 MAC sys_ck = ceil(62.4) = 63 */
		os_writelmsk(U3D_USB20_TIMING_PARAMETER, 63, TIME_VALUE_1US);
#ifdef SUPPORT_U3
		/* U3 MAC sys_ck = ceil(62.4) = 63 */
		os_writelmsk(U3D_TIMING_PULSE_CTRL, 63, CNT_1US_VALUE);
#endif
		os_printk(K_INFO, "%s Set Clock to 62.4MHz-\n", __func__);
	}
#endif

	os_writel(U3D_LINK_RESET_INFO, os_readl(U3D_LINK_RESET_INFO) & ~WTCHRP);

	/* U2/U3 detected by HW */
	os_writel(U3D_DEVICE_CONF, 0);

	musb->is_active = 1;

	musb_platform_enable(musb);

#ifdef EP_PROFILING
	if (is_prof != 0)
		schedule_delayed_work(&musb->ep_prof_work, msecs_to_jiffies(POLL_INTERVAL * 1000));
#endif

	if (musb->softconnect)
		mu3d_hal_u3dev_en();
}
```


Overlapping Code:
```
usb)
{
u8 devctl = (u8) os_readl(U3D_DEVICE_CONTROL);
dev_dbg(musb->controller, "<== devctl %02x\n", devctl);
os_printk(K_INFO, "%s\n", __func__);
if (musb->is_clk_on == 0) {
#ifndef CONFIG_MTK_FPGA
/* Recovert PHY. And turn on CLK. */
usb_phy_recover(musb->is_clk_on);
musb->is_clk_on = 1;
/* USB 2.0 slew rate calibration */
u3phy_ops->u2_slew_rate_calibration(u3phy);
#endif
/* disable IP reset and power down, disable U2/U3 ip power down */
_ex_mu3d_hal_ssusb_en();
/* USB PLL Force settings */
#ifdef CONFIG_PROJECT_PHY
usb20_pll_settings(false, false);
#endif
/* reset U3D all dev module. */
mu3d_hal_rst_dev();
/*
* SW workaround of SSUSB device mode fake disable interrupt
* 1. Clear SSUSB_U3_PORT_DIS @ _ex_mu3d_hal_ssusb_en()
* 2. Wait SSUSB_U3_MAC_RST_B_STS change to 1. @ mu3d_hal_check_clk_sts()
* 3. Delay 50us
* 4. Clear U3 interrupt @ mu3d_hal_check_clk_sts()
* Recommended value : 50us
*/
udelay(20);
musb_restore_context(musb);
}
/*Enable Level 1 interrupt (BMU, QMU, MAC3, DMA, MAC2, EPCTL) */
os_writel(U3D_LV1IESR, 0xFFFFFFFF);
/* Initialize the default interrupts */
_ex_mu3d_hal_system_intr_en();
#ifdef USB_GADGET_SUPERSPEED
/* HS/FS detected by HW */
/* USB2.0 controller will negotiate for HS mode when the device is reset by the host */
os_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE));
/* set LPM remote wake up enable by HW */
os_writel(U3D_POWER_MANAGEMENT, (os_readl(U3D_POWER_MANAGEMENT) | LPM_HRWE));
os_writel(U3D_USB2_EPCTL_LPM, (L1_EXIT_EP0_CHK | L1_EXIT_EP_IN_CHK | L1_EXIT_EP_OUT_CHK));
os_writel(U3D_USB2_EPCTL_LPM_FC_CHK,
(L1_EXIT_EP0_FC_CHK | L1_EXIT_EP_IN_FC_CHK | L1_EXIT_EP_OUT_FC_CHK));
#ifdef CONFIG_USBIF_COMPLIANCE
/* Accept LGO_U1/U2 at beginning */
os_writel(U3D_LINK_POWER_CONTROL,
os_readl(U3D_LINK_POWER_CONTROL) | SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);
/* 3us timeout for PENDING HP */
os_writel(U3D_LINK_HP_TIMER, (os_readl(U3D_LINK_HP_TIMER) & ~(PHP_TIMEOUT_VALUE)) | 0x6);
/* set vbus force enable */
os_setmsk(U3D_MISC_CTRL, (VBUS_FRC_EN | VBUS_ON));
#endif
/* device responses to u3_exit from host automatically */
os_writel(U3D_LTSSM_CTRL, os_readl(U3D_LTSSM_CTRL) & ~SOFT_U3_EXIT_EN);
#else
#ifdef USB_GADGET_DUALSPEED
/* HS/FS detected by HW */
os_writel(U3D_POWER_MANAGEMENT, os_readl(U3D_POWER_MANAGEMENT) | HS_ENABLE);
#else
/* FS only */
os_writel(U3
```
<Overlap Ratio: 0.9808013355592654>

---

--- 64 --
Question ID: d01d311d0d5449114c65b2eae1b8d1415421293e_13
Original Code:
```
static VALUE keychain_item_port(VALUE self)
{
	VALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);
	VALUE integer_obj = rb_funcall(integer_str, rb_intern("to_i"), 0);
	return integer_obj;
}
```


Overlapping Code:
```
port(VALUE self)
{
VALUE integer_str = keychain_item_get_attribute(self, kSecPortItemAttr);
VALUE integer_obj = rb_funcall(integer_str, rb_intern("to_
```
<Overlap Ratio: 0.7246376811594203>

---

--- 65 --
Question ID: c484712e6e0aefb1754328829f5e967684ff8ffc_0
Original Code:
```
interface _MFMessageMediaPayload : NSObject <NSSecureCoding> {
    NSString * _accessibilityLabel;
    UIImage * _image;
    bool  _isSticker;
    NSURL * _mediaURL;
    NSString * _text;
}
```


Overlapping Code:
```
nterface _MFMessageMediaPayload : NSObject <NSSecureCoding> {
NSString * _accessibilityLabel;
UIImage * _image;
bool _isSticker;
NSURL * _mediaURL;
NS
```
<Overlap Ratio: 0.8928571428571429>

---

--- 66 --
Question ID: 580b8d3488ff6c54622c01ff6ac51fb360b15fad_2
Original Code:
```
void
wrap_restore_saved()
{
    if(!wrap_saved_list)
	return;

    wrap_kill();

    free(wrap_list);

    wrap_list=wrap_saved_list;
    wrap_count=wrap_saved_count;
    wrap_tempcount=wrap_saved_tempcount;

    wrap_saved_list=NULL;
    wrap_saved_count=0;
    wrap_saved_tempcount=0;
}
```


Overlapping Code:
```

if(!wrap_saved_list)
return;
wrap_kill();
free(wrap_list);
wrap_list=wrap_saved_list;
wrap_count=wrap_saved_count;
wrap_tempcount=wrap_saved_tempcount;
wrap_saved_list=NULL;
wrap_saved_count=0;
wrap_saved_tempcount=
```
<Overlap Ratio: 0.8744939271255061>

---

--- 67 --
Question ID: 168b79695ed5d43bcb40a595fde3d855454980fa_0
Original Code:
```
static void sigchld(int, siginfo_t* sinfo, void*)
    {
        assert(sinfo);
        assert(sinfo->si_signo == SIGCHLD);
        int status = 0;
        ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);

        switch (sinfo->si_code)
        {
        case CLD_EXITED:
        case CLD_KILLED:
        case CLD_DUMPED:
        #if DEBUG
            std::clog << __func__<< ": si_pid=" << sinfo->si_pid;
            std::clog << " si_code=" << sinfo->si_code << std::endl;
        #endif
            if (i != children_.end())
            {
                children_.erase(i);
                waitpid(sinfo->si_pid, &status, 0);
            }
            break;
        }
    }
```


Overlapping Code:
```
 siginfo_t* sinfo, void*)
{
assert(sinfo);
assert(sinfo->si_signo == SIGCHLD);
int status = 0;
ext::hash_set<pid_t>::iterator i = children_.find(sinfo->si_pid);
switch (sinfo->si_code)
{
case CLD_EXITED:
case CLD_KILLED:
case CLD_DUMPED:
#if DEBUG
std::clog << __func__<< ": si_pid=" << sinfo->si_pid;
std::clog << " si_code=" << sinfo->si_code << std::endl;
#endif
if (i != children_.end())
{
children_.erase(i);
waitpid(sinfo->si_pid, &status, 0);

```
<Overlap Ratio: 0.9259259259259259>

---

--- 68 --
Question ID: fa4036a6385d29ce156de559c4829e71ef49a055_3
Original Code:
```
static uint32_t
blockmix_xor(const salsa20_blk_t *restrict Bin1,
    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,
    size_t r, int Bin2_in_ROM, const __m128i *restrict S)
{
	const uint8_t * S0, * S1;
	__m128i X0, X1, X2, X3;
	size_t i;

	if (!S)
		return blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);

	S0 = (const uint8_t *)S;
	S1 = (const uint8_t *)S + S_SIZE_ALL / 2;

	/* Convert 128-byte blocks to 64-byte blocks */
	r *= 2;

	r--;
	if (Bin2_in_ROM) {
		PREFETCH(&Bin2[r], _MM_HINT_NTA)
		PREFETCH(&Bin1[r], _MM_HINT_T0)
		for (i = 0; i < r; i++) {
			PREFETCH(&Bin2[i], _MM_HINT_NTA)
			PREFETCH(&Bin1[i], _MM_HINT_T0)
			PREFETCH_OUT(&Bout[i], _MM_HINT_T0)
		}
	} else {
		PREFETCH(&Bin2[r], _MM_HINT_T0)
		PREFETCH(&Bin1[r], _MM_HINT_T0)
		for (i = 0; i < r; i++) {
			PREFETCH(&Bin2[i], _MM_HINT_T0)
			PREFETCH(&Bin1[i], _MM_HINT_T0)
			PREFETCH_OUT(&Bout[i], _MM_HINT_T0)
		}
	}
	PREFETCH_OUT(&Bout[r], _MM_HINT_T0);

	/* X <-- B_{r1 - 1} */
	XOR4_2(Bin1[r].q, Bin2[r].q)

	/* for i = 0 to r1 - 1 do */
	for (i = 0; i < r; i++) {
		/* X <-- H'(X \xor B_i) */
		XOR4(Bin1[i].q)
		XOR4(Bin2[i].q)
		PWXFORM
		/* B'_i <-- X */
		OUT(Bout[i].q)
	}

	/* Last iteration of the loop above */
	XOR4(Bin1[i].q)
	XOR4(Bin2[i].q)
	PWXFORM

	/* B'_i <-- H(B'_i) */
	SALSA20_8(Bout[i].q)

	return _mm_cvtsi128_si32(X0);
}
```


Overlapping Code:
```
ic uint32_t
blockmix_xor(const salsa20_blk_t *restrict Bin1,
const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,
size_t r, int Bin2_in_ROM, const __m128i *restrict S)
{
const uint8_t * S0, * S1;
__m128i X0, X1, X2, X3;
size_t i;
if (!S)
return blockmix_salsa8_xor(Bin1, Bin2, Bout, r, Bin2_in_ROM);
S0 = (const uint8_t *)S;
S1 = (const uint8_t *)S + S_SIZE_ALL / 2;
/* Convert 128-byte blocks to 64-byte blocks */
r *= 2;
r--;
if (Bin2_in_ROM) {
PREFETCH(&Bin2[r], _MM_HINT_NTA)
PREFETCH(&Bin1[r], _MM_HINT_T0)
for (i = 0; i < r; i++) {
PREFETCH(&Bin2[i], _MM_HINT_NTA)
PREFETCH(&Bin1[i], _MM_HINT_T0)
PREFETCH_OUT(&Bout[i], _MM_HINT_T0)
}
} else {
PREFETCH(&Bin2[r], _MM_HINT_T0)
PREFETCH(&Bin1[r], _MM_HINT_T0)
for (i = 0; i < r; i++) {
PREFETCH(&Bin2[i], _MM_HINT_T0)
PREFETCH(&Bin1[i], _MM_HINT_T0)
PREFETCH_OUT(&Bout[i], _MM_HINT_T0)
}
}
PREFETCH_OUT(&Bout[r], _MM_HINT_T0);
/* X <-- B_{r1 - 1} */
XOR4_2(Bin1[r].q, Bin2[r].q)
/* for i = 0 to r1 - 1 do */
for (i = 0; i < r; i++) {
/* X <-- H'(X \xor B_i) */
XOR4(Bin1[i].q)
XOR4(Bin2[i].q)
PWXFORM
/* B'_i <-- X */
OUT(Bout[i].q)
}
/* Last iteration of the loop above */
XOR4(Bin1[i].q)
XOR4(Bin2[i].q)
PWXFORM
/* B'_i <-- H(B'_i) */
SALSA20
```
<Overlap Ratio: 0.9611111111111111>

---

--- 69 --
Question ID: c3131f38387e6eec8ac71ff8a468250c6273b9d2_1
Original Code:
```
int sum(int a, int b)
{
	int c;
	c = a + b;
	return c;
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 70 --
Question ID: f2104d16e7b028e38ae3b04a9ee950e63eb8aaf6_1
Original Code:
```
void LBF_Disable_EXTI_ExtPort( uint16_t  GPIO_Pin)
{
    if ( GPIO_Pin == CONN_POS2_PIN )  //PA6 --> EXTI5_9
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); 
    }
    // CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)
    // as it also uses pin6 (PC6)

    if ( GPIO_Pin == CONN_POS3_PIN )  //PA4 --> EXTI4
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); 
    }

    if ( GPIO_Pin == CONN_POS4_PIN )  //PA3 --> EXTI3
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); 
    }

    if ( GPIO_Pin == CONN_POS5_PIN )  //PA2 --> EXTI2
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); 
    }

    if ( GPIO_Pin == CONN_POS7_PIN )  //PA1 --> EXTI1
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); 
    }

    if ( GPIO_Pin == CONN_POS8_PIN )  //PA0 --> EXTI0
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); 
    }

    if ( GPIO_Pin == CONN_POS10_PIN )  //PB8 --> EXTI5_9
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); 
    }

    if ( GPIO_Pin == CONN_POS11_PIN )  //PB9 --> EXTI5_9
    {
        LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); 
        LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); 
        LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_9); 
    }

}
```


Overlapping Code:
```
t( uint16_t GPIO_Pin)
{
if ( GPIO_Pin == CONN_POS2_PIN ) //PA6 --> EXTI5_9
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_6); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_6); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_6); 
}
// CAUTION: Conflict if also using INT1_ACC_GYR_PIN (from LSM6DS3)
// as it also uses pin6 (PC6)
if ( GPIO_Pin == CONN_POS3_PIN ) //PA4 --> EXTI4
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_4); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_4); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_4); 
}
if ( GPIO_Pin == CONN_POS4_PIN ) //PA3 --> EXTI3
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_3); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_3); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_3); 
}
if ( GPIO_Pin == CONN_POS5_PIN ) //PA2 --> EXTI2
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_2); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_2); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_2); 
}
if ( GPIO_Pin == CONN_POS7_PIN ) //PA1 --> EXTI1
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_1); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_1); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_1); 
}
if ( GPIO_Pin == CONN_POS8_PIN ) //PA0 --> EXTI0
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_0); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_0); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_0); 
}
if ( GPIO_Pin == CONN_POS10_PIN ) //PB8 --> EXTI5_9
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_8); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_8); 
LL_EXTI_DisableFallingTrig_0_31(LL_EXTI_LINE_8); 
}
if ( GPIO_Pin == CONN_POS11_PIN ) //PB9 --> EXTI5_9
{
LL_EXTI_DisableIT_0_31(LL_EXTI_LINE_9); 
LL_EXTI_DisableRisingTrig_0_31(LL_EXTI_LINE_9); 
LL_EXTI_DisableFallingTrig_0_
```
<Overlap Ratio: 0.9694477085781433>

---

--- 71 --
Question ID: 870c67cf1c637cfc78715bd3d821a55195db7d24_0
Original Code:
```
static int isn_decode_op1(struct sparc_isn *isn)
{
	struct sparc_ifmt_op1 *i = to_ifmt(op1, isn);

	/* Only Call instruction is of op1 type */
	i->isn.id = SI_CALL;
	i->isn.fmt = SIF_OP1;
	i->disp30 = ISN_OP1_DISP(isn->op);
	return 0;
}
```


Overlapping Code:
```
*isn)
{
struct sparc_ifmt_op1 *i = to_ifmt(op1, isn);
/* Only Call instruction is of op1 type */
i->isn.id = SI_CALL;
i->isn.fmt = SIF_OP1;
i->disp30 
```
<Overlap Ratio: 0.6550218340611353>

---

--- 72 --
Question ID: 03d33d89fbfea75238f3c892cc1a929ab751579d_3
Original Code:
```
void sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)
{
    int j;
    size_t i;

    j = sb->l;
    for (i = 0; i < len; i++) {
        if (j == SBOB_RATE) {
            sb->s.b[SBOB_RATE] ^= pad;
            SBOB_PI(&sb->s);
            j = 0;
        }
        ((uint8_t *) out)[i] = sb->s.b[j++];
    }
    sb->l = j;
}
```


Overlapping Code:
```
sbob_get(sbob_t *sb, sbob_pad_t pad, void *out, size_t len)
{
int j;
size_t i;
j = sb->l;
for (i = 0; i < len; i++) {
if (j == SBOB_RATE) {
sb->s.b[SBOB_RATE] ^= pad;
SBOB_PI(&sb->s);
j = 0;
}
((uint8_t *) out)[i] = sb->s.b[j++];
}
sb->l = 
```
<Overlap Ratio: 0.963855421686747>

---

--- 73 --
Question ID: a2f85868afaa0f14a2b41f159db57e10a5cab4f2_1
Original Code:
```
void SendDataCPU(void)
{
    // Send data to Computer via USB
    for (kk = 0; kk < 6; kk++)
    {
        U1TXREG = varCPU[kk];
        while(!U1STAbits.TRMT);
        
        Nop();
        Nop();
        Nop();
        Nop();
        Nop();
        Nop();
    }
    for (kk = 0; kk < 30; kk++)
        Nop();
}
```


Overlapping Code:
```
id SendDataCPU(void)
{
// Send data to Computer via USB
for (kk = 0; kk < 6; kk++)
{
U1TXREG = varCPU[kk];
while(!U1STAbits.TRMT);

Nop();
Nop();
Nop();
Nop();
Nop();
Nop();
}
for (kk = 0; kk < 30; kk++)
Nop();
}
```
<Overlap Ratio: 0.9906542056074766>

---

--- 74 --
Question ID: 2f44617c4687e7c91e628440ca23b94a7610af92_4
Original Code:
```
int16_t st_ulaw2linear16(
	unsigned char	u_val)
{
	int16_t		t;

	/* Complement to obtain normal u-law value. */
	u_val = ~u_val;

	/*
	 * Extract and bias the quantization bits. Then
	 * shift up by the segment number and subtract out the bias.
	 */
	t = ((u_val & QUANT_MASK) << 3) + BIAS;
	t <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;

	return ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));
}
```


Overlapping Code:
```
u_val)
{
int16_t t;
/* Complement to obtain normal u-law value. */
u_val = ~u_val;
/*
* Extract and bias the quantization bits. Then
* shift up by the segment number and subtract out the bias.
*/
t = ((u_val & QUANT_MASK) << 3) + BIAS;
t <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;
return ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));
}
```
<Overlap Ratio: 0.89501312335958>

---

--- 75 --
Question ID: a9c8e628093f64c31dbc89666b04a3121549a9f3_30
Original Code:
```
static svn_error_t *
git_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,
            apr_pool_t *result_pool, apr_pool_t *scratch_pool)
{
  SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL("copy to "),
                        result_pool, scratch_pool));

  patch->operation = svn_diff_op_copied;

  *new_state = state_git_tree_seen;
  return SVN_NO_ERROR;
}
```


Overlapping Code:
```
n_error_t *
git_copy_to(enum parse_state *new_state, char *line, svn_patch_t *patch,
apr_pool_t *result_pool, apr_pool_t *scratch_pool)
{
SVN_ERR(grab_filename(&patch->new_filename, line + STRLEN_LITERAL("copy to "),
result_pool, scratch_pool));
patch->operation = svn_diff_op_copied;
*new_state = state_git_tree_seen;
return SVN_NO_ERROR;

```
<Overlap Ratio: 0.9714285714285714>

---

--- 76 --
Question ID: cf1fe79b9a833586a14663a1bdd856cb721c3ff8_7
Original Code:
```
uint_t
tcp_read_rwbuf_ncs (T_TCP_CEP *cep, void *data, uint_t len)
{
	uint_t	offset;

	/* 通信端点をロックする。*/
	syscall(wai_sem(cep->semid_lock));

	/* len と受信ウィンドバッファのデータ数の小さい方を取り出すデータ数にする。*/
	if (len > cep->rwbuf_count)
		len = cep->rwbuf_count;

	/* 読み出しポインタがラウンドするときの処理 */
	if (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {
		offset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));
		memcpy(data, cep->rbuf_rptr, (size_t)offset);
		cep->rwbuf_count -= offset;
		cep->rbuf_rptr   = (uint8_t*)cep->rbuf;
		}
	else
		offset = 0;

	memcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));
	cep->rwbuf_count -= len - offset;
	cep->rbuf_rptr  += len - offset;

	/* 通信端点のロックを解除する。*/
	syscall(sig_sem(cep->semid_lock));

	return len;
	}
```


Overlapping Code:
```
ep, void *data, uint_t len)
{
uint_t offset;
/* 通信端点をロックする。*/
syscall(wai_sem(cep->semid_lock));
/* len と受信ウィンドバッファのデータ数の小さい方を取り出すデータ数にする。*/
if (len > cep->rwbuf_count)
len = cep->rwbuf_count;
/* 読み出しポインタがラウンドするときの処理 */
if (len > cep->rbufsz - (cep->rbuf_rptr - (uint8_t*)cep->rbuf)) {
offset = (uint_t)(cep->rbufsz - (cep->rbuf_rptr -(uint8_t*)cep->rbuf));
memcpy(data, cep->rbuf_rptr, (size_t)offset);
cep->rwbuf_count -= offset;
cep->rbuf_rptr = (uint8_t*)cep->rbuf;
}
else
offset = 0;
memcpy((void*)((uint8_t*)data + offset), cep->rbuf_rptr, (size_t)(len - offset));
cep->rwbuf_count -= len - offset;
cep->rbuf_rptr += len - offset;
/* 通信端点のロックを解除する。*/
syscall(sig_sem(cep->semid_lock));
return 
```
<Overlap Ratio: 0.9395161290322581>

---

--- 77 --
Question ID: 6e1db8554c1eb81709bba7f8c8f212d1d50ca0e9_21
Original Code:
```
Tex *give_current_object_texture(Object *ob)
{
	Material *ma, *node_ma;
	Tex *tex = NULL;
	
	if (ob == NULL) return NULL;
	if (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;
	
	if (ob->type == OB_LAMP) {
		tex = give_current_lamp_texture(ob->data);
	}
	else {
		ma = give_current_material(ob, ob->actcol);

		if ((node_ma = give_node_material(ma)))
			ma = node_ma;

		tex = give_current_material_texture(ma);
	}
	
	return tex;
}
```


Overlapping Code:
```
_texture(Object *ob)
{
Material *ma, *node_ma;
Tex *tex = NULL;

if (ob == NULL) return NULL;
if (ob->totcol == 0 && !(ob->type == OB_LAMP)) return NULL;

if (ob->type == OB_LAMP) {
tex = give_current_lamp_texture(ob->data);
}
else {
ma = give_current_material(ob, ob->actcol);
if ((node_ma = give_node_material(ma)))
ma = node_ma;
tex = give_current
```
<Overlap Ratio: 0.847457627118644>

---

--- 78 --
Question ID: cf3648d1487a2fe7ce0715ef99991e781036c64f_27
Original Code:
```
static void iface_stat_create(struct net_device *net_dev,
			      struct in_ifaddr *ifa)
{
	struct in_device *in_dev = NULL;
	const char *ifname;
	struct iface_stat *entry;
	__be32 ipaddr = 0;
	struct iface_stat *new_iface;

	IF_DEBUG("qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\n",
		 net_dev ? net_dev->name : "?",
		 ifa, net_dev);
	if (!net_dev) {
		pr_err("qtaguid: iface_stat: create(): no net dev\n");
		return;
	}

	ifname = net_dev->name;
	if (!ifa) {
		in_dev = in_dev_get(net_dev);
		if (!in_dev) {
			pr_err("qtaguid: iface_stat: create(%s): no inet dev\n",
			       ifname);
			return;
		}
		IF_DEBUG("qtaguid: iface_stat: create(%s): in_dev=%p\n",
			 ifname, in_dev);
		for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
			IF_DEBUG("qtaguid: iface_stat: create(%s): "
				 "ifa=%p ifa_label=%s\n",
				 ifname, ifa,
				 ifa->ifa_label ? ifa->ifa_label : "(null)");
			if (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))
				break;
		}
	}

	if (!ifa) {
		IF_DEBUG("qtaguid: iface_stat: create(%s): no matching IP\n",
			 ifname);
		goto done_put;
	}
	ipaddr = ifa->ifa_local;

	spin_lock_bh(&iface_stat_list_lock);
	entry = get_iface_entry(ifname);
	if (entry != NULL) {
		IF_DEBUG("qtaguid: iface_stat: create(%s): entry=%p\n",
			 ifname, entry);
		iface_check_stats_reset_and_adjust(net_dev, entry);
		_iface_stat_set_active(entry, net_dev, true);
		IF_DEBUG("qtaguid: %s(%s): "
			 "tracking now %d on ip=%pI4\n", __func__,
			 entry->ifname, true, &ipaddr);
		goto done_unlock_put;
	}

	new_iface = iface_alloc(net_dev);
	IF_DEBUG("qtaguid: iface_stat: create(%s): done "
		 "entry=%p ip=%pI4\n", ifname, new_iface, &ipaddr);
done_unlock_put:
	spin_unlock_bh(&iface_stat_list_lock);
done_put:
	if (in_dev)
		in_dev_put(in_dev);
}
```


Overlapping Code:
```
e(struct net_device *net_dev,
struct in_ifaddr *ifa)
{
struct in_device *in_dev = NULL;
const char *ifname;
struct iface_stat *entry;
__be32 ipaddr = 0;
struct iface_stat *new_iface;
IF_DEBUG("qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\n",
net_dev ? net_dev->name : "?",
ifa, net_dev);
if (!net_dev) {
pr_err("qtaguid: iface_stat: create(): no net dev\n");
return;
}
ifname = net_dev->name;
if (!ifa) {
in_dev = in_dev_get(net_dev);
if (!in_dev) {
pr_err("qtaguid: iface_stat: create(%s): no inet dev\n",
ifname);
return;
}
IF_DEBUG("qtaguid: iface_stat: create(%s): in_dev=%p\n",
ifname, in_dev);
for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
IF_DEBUG("qtaguid: iface_stat: create(%s): "
"ifa=%p ifa_label=%s\n",
ifname, ifa,
ifa->ifa_label ? ifa->ifa_label : "(null)");
if (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))
break;
}
}
if (!ifa) {
IF_DEBUG("qtaguid: iface_stat: create(%s): no matching IP\n",
ifname);
goto done_put;
}
ipaddr = ifa->ifa_local;
spin_lock_bh(&iface_stat_list_lock);
entry = get_iface_entry(ifname);
if (entry != NULL) {
IF_DEBUG("qtaguid: iface_stat: create(%s): entry=%p\n",
ifname, entry);
iface_check_stats_reset_and_adjust(net_dev, entry);
_iface_stat_set_active(entry, net_dev, true);
IF_DEBUG("qtaguid: %s(%s): "
"tracking now %d on ip=%pI4\n", __func__,
entry->ifname, true, &ipaddr);
goto done_unlock_put;
}
new_iface = iface_alloc(net_dev);
IF_DEBUG("qtaguid: iface_stat: create(%s): done "
"entry=%p ip=%pI4\n", ifname, new_iface, &ipaddr);
done_unlock_put:
spin_unlock_bh(&iface_stat_list_lock);

```
<Overlap Ratio: 0.9564417177914111>

---

--- 79 --
Question ID: 9f0b8bfebddea4407f83f39269459204a2fd2dae_0
Original Code:
```
interface GEOCompanionRouteStatus : PBCodable <NSCopying> {
    unsigned int  _distanceRemainingOnRoute;
    unsigned int  _distanceToManeuver;
    unsigned int  _distanceToRoute;
    int  _feedbackType;
    bool  _guidancePromptsEnabled;
    struct { 
        unsigned int timestamp : 1; 
        unsigned int distanceRemainingOnRoute : 1; 
        unsigned int distanceToManeuver : 1; 
        unsigned int distanceToRoute : 1; 
        unsigned int feedbackType : 1; 
        unsigned int remainingTime : 1; 
        unsigned int routeLocationIndex : 1; 
        unsigned int routeLocationOffset : 1; 
        unsigned int stepID : 1; 
        unsigned int guidancePromptsEnabled : 1; 
    }  _has;
    GEOLocation * _location;
    unsigned int  _remainingTime;
    NSData * _routeID;
    unsigned int  _routeLocationIndex;
    float  _routeLocationOffset;
    GEOLatLng * _routeMatchCoordinate;
    struct { 
        unsigned int *list; 
        unsigned long long count; 
        unsigned long long size; 
    }  _selectedRideIndexs;
    unsigned int  _stepID;
    double  _timestamp;
}
```


Overlapping Code:
```
OCompanionRouteStatus : PBCodable <NSCopying> {
unsigned int _distanceRemainingOnRoute;
unsigned int _distanceToManeuver;
unsigned int _distanceToRoute;
int _feedbackType;
bool _guidancePromptsEnabled;
struct { 
unsigned int timestamp : 1; 
unsigned int distanceRemainingOnRoute : 1; 
unsigned int distanceToManeuver : 1; 
unsigned int distanceToRoute : 1; 
unsigned int feedbackType : 1; 
unsigned int remainingTime : 1; 
unsigned int routeLocationIndex : 1; 
unsigned int routeLocationOffset : 1; 
unsigned int stepID : 1; 
unsigned int guidancePromptsEnabled : 1; 
} _has;
GEOLocation * _location;
unsigned int _remainingTime;
NSData * _routeID;
unsigned int _routeLocationIndex;
float _routeLocationOffset;
GEOLatLng * _routeMatchCoordinate;
struct { 
unsigned int *list; 
unsigned long long count; 
unsigned long long size; 
} _selectedRideIndexs;
unsigned int _stepID;
double
```
<Overlap Ratio: 0.9713340683572216>

---

--- 80 --
Question ID: 862cecb3338cbd440646299c9de25c205ae84a8e_17
Original Code:
```
Status EXC_OP_NIP(CStack *stack)
{
	if (stack->is_empty(stack)) return CSTACK_EMPTY;
	size_t top_size;
	void *top_type;
	void *top = stack->pop(stack, &top_size, &top_type, NULL);
	void *second = stack->pop(stack, NULL, NULL, NULL);
	if (second != NULL) free(second);
	stack->push(stack, top, top_size, top_type, true);
	return OPERATION_EXECUTED;
}
```


Overlapping Code:
```
stack)
{
if (stack->is_empty(stack)) return CSTACK_EMPTY;
size_t top_size;
void *top_type;
void *top = stack->pop(stack, &top_size, &top_type, NULL);
void *second = stack->pop(stack, NULL, NULL, NULL);
if (second != NULL) free(second);
stack->push(stack, top, top_size, top_type, true);
return OPERATION_
```
<Overlap Ratio: 0.8914956011730205>

---

--- 81 --
Question ID: 72ff10a4de7baffd8adb3a0195cad67ba439e179_0
Original Code:
```
double operator[](size_t i) const
    {
        assert(i < 3);
        double* res = (double*)&m_v;
        return res[i];
    }
```


Overlapping Code:
```
nst
{
assert(i < 3);
double* res = (double*)&m_v;

```
<Overlap Ratio: 0.5208333333333334>

---

--- 82 --
Question ID: aaa17f4d65b538f54670a5d2213ae24f45955977_2
Original Code:
```
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
	err_t err = ERR_OK;
	u8_t first_msg = 0;
	u32_t tmp = 0;
	sys_arch_sem_wait(&(mbox->mutex), 0);

	LWIP_DEBUGF(SYS_DEBUG, ("mbox %p msg %p\n", (void *)mbox, (void *)msg));
	/* Check if the queue is full */
	tmp = (mbox->rear + 1) % mbox->queue_size;
	if (tmp == mbox->front) {
		LWIP_DEBUGF(SYS_DEBUG, ("Queue Full, returning error\n"));
		err = ERR_MEM;
		goto errout_with_mutex;
	}

	if (mbox->rear == mbox->front) {
		first_msg = 1;
	} else {
		first_msg = 0;
	}

	mbox->rear = tmp;
	mbox->msgs[mbox->rear] = msg;
	LWIP_DEBUGF(SYS_DEBUG, ("Post SUCCESS\n"));

	/* If msg was posted to an empty queue, Release semaphore for
	   some fetch api blocked on this sem due to Empty queue. */
	if (first_msg && mbox->wait_fetch) {
		sys_sem_signal(&(mbox->mail));
	}

errout_with_mutex:
	sys_sem_signal(&(mbox->mutex));

	return err;
}
```


Overlapping Code:
```
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
err_t err = ERR_OK;
u8_t first_msg = 0;
u32_t tmp = 0;
sys_arch_sem_wait(&(mbox->mutex), 0);
LWIP_DEBUGF(SYS_DEBUG, ("mbox %p msg %p\n", (void *)mbox, (void *)msg));
/* Check if the queue is full */
tmp = (mbox->rear + 1) % mbox->queue_size;
if (tmp == mbox->front) {
LWIP_DEBUGF(SYS_DEBUG, ("Queue Full, returning error\n"));
err = ERR_MEM;
goto errout_with_mutex;
}
if (mbox->rear == mbox->front) {
first_msg = 1;
} else {
first_msg = 0;
}
mbox->rear = tmp;
mbox->msgs[mbox->rear] = msg;
LWIP_DEBUGF(SYS_DEBUG, ("Post SUCCESS\n"));
/* If msg was posted to an empty queue, Release semaphore for
some fetch api blocked on this sem due to Empty queue. */
if (first_msg && mbox->wait_fetch) {
sys_sem_signal(&(mbox->mail));
}
errout_with_mutex:
sys_sem_signal(&(mbox->mutex));
return
```
<Overlap Ratio: 0.9916864608076009>

---

--- 83 --
Question ID: e5fb162a96cef8750c1185fe9b8bef4303bc4e60_25
Original Code:
```
static void gpsculpt_brush_apply(bContext *C, wmOperator *op, PointerRNA *itemptr)
{
	tGP_BrushEditData *gso = op->customdata;
	const int radius = gso->brush->size;
	float mousef[2];
	int mouse[2];
	bool changed = false;
	
	/* Get latest mouse coordinates */
	RNA_float_get_array(itemptr, "mouse", mousef);
	gso->mval[0] = mouse[0] = (int)(mousef[0]);
	gso->mval[1] = mouse[1] = (int)(mousef[1]);
	
	gso->pressure = RNA_float_get(itemptr, "pressure");
	
	if (RNA_boolean_get(itemptr, "pen_flip"))
		gso->flag |= GP_EDITBRUSH_FLAG_INVERT;
	else
		gso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;
	
	
	/* Store coordinates as reference, if operator just started running */
	if (gso->first) {
		gso->mval_prev[0]  = gso->mval[0];
		gso->mval_prev[1]  = gso->mval[1];
		gso->pressure_prev = gso->pressure;
	}
	
	/* Update brush_rect, so that it represents the bounding rectangle of brush */
	gso->brush_rect.xmin = mouse[0] - radius;
	gso->brush_rect.ymin = mouse[1] - radius;
	gso->brush_rect.xmax = mouse[0] + radius;
	gso->brush_rect.ymax = mouse[1] + radius;
	
	
	/* Apply brush */
	if (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {
		changed = gpsculpt_brush_apply_clone(C, gso);
	}
	else {
		changed = gpsculpt_brush_apply_standard(C, gso);
	}
	
	
	/* Updates */
	if (changed) {
		WM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);
	}
	
	/* Store values for next step */
	gso->mval_prev[0]  = gso->mval[0];
	gso->mval_prev[1]  = gso->mval[1];
	gso->pressure_prev = gso->pressure;
	gso->first = false;
}
```


Overlapping Code:
```
ext *C, wmOperator *op, PointerRNA *itemptr)
{
tGP_BrushEditData *gso = op->customdata;
const int radius = gso->brush->size;
float mousef[2];
int mouse[2];
bool changed = false;

/* Get latest mouse coordinates */
RNA_float_get_array(itemptr, "mouse", mousef);
gso->mval[0] = mouse[0] = (int)(mousef[0]);
gso->mval[1] = mouse[1] = (int)(mousef[1]);

gso->pressure = RNA_float_get(itemptr, "pressure");

if (RNA_boolean_get(itemptr, "pen_flip"))
gso->flag |= GP_EDITBRUSH_FLAG_INVERT;
else
gso->flag &= ~GP_EDITBRUSH_FLAG_INVERT;


/* Store coordinates as reference, if operator just started running */
if (gso->first) {
gso->mval_prev[0] = gso->mval[0];
gso->mval_prev[1] = gso->mval[1];
gso->pressure_prev = gso->pressure;
}

/* Update brush_rect, so that it represents the bounding rectangle of brush */
gso->brush_rect.xmin = mouse[0] - radius;
gso->brush_rect.ymin = mouse[1] - radius;
gso->brush_rect.xmax = mouse[0] + radius;
gso->brush_rect.ymax = mouse[1] + radius;


/* Apply brush */
if (gso->brush_type == GP_EDITBRUSH_TYPE_CLONE) {
changed = gpsculpt_brush_apply_clone(C, gso);
}
else {
changed = gpsculpt_brush_apply_standard(C, gso);
}


/* Updates */
if (changed) {
WM_event_add_notifier(C, NC_GPENCIL | ND_DATA | NA_EDITED, NULL);
}

/* Store values for next step */
gso->mval_prev[0] = gso->mval[0];
gso->mval_prev[1] = gso->mval[1];
gso->pressure_prev = gso->pressure;
gso->first = false
```
<Overlap Ratio: 0.9716459197786999>

---

--- 84 --
Question ID: c8f90929df14fcdef90c13c04c0c5a9e503bf47e_12
Original Code:
```
static int fpc1020_supply_init(fpc1020_data_t *fpc1020)
{
	int error = 0;

	/*Determine is we should use external regulator for
	power sully to the bezel. */
	if (fpc1020->use_regulator_for_bezel) {
		/*error = fpc1020_regulator_configure(fpc1020); */
		if (error) {
			dev_err(&fpc1020->spi->dev,
					"fpc1020_probe - regulator configuration failed.\n");
			goto err;
		}

		/*error = fpc1020_regulator_set(fpc1020, true);*/
		if (error) {
			dev_err(&fpc1020->spi->dev,
					"fpc1020_probe - regulator enable failed.\n");
			goto err;
		}
	 }

err:
	return error;
}
```


Overlapping Code:
```
t fpc1020_supply_init(fpc1020_data_t *fpc1020)
{
int error = 0;
/*Determine is we should use external regulator for
power sully to the bezel. */
if (fpc1020->use_regulator_for_bezel) {
/*error = fpc1020_regulator_configure(fpc1020); */
if (error) {
dev_err(&fpc1020->spi->dev,
"fpc1020_probe - regulator configuration failed.\n");
goto err;
}
/*error = fpc1020_regulator_set(fpc1020, true);*/
if (error) {
dev_err(&fpc1020->spi->dev,
"fpc1020_probe - regulator enable failed.\n");
goto err;
}
}
err:

```
<Overlap Ratio: 0.9541984732824428>

---

--- 85 --
Question ID: c6019705f7fc09fa7f066201c8b3319375bed2ca_3
Original Code:
```
static int handle_unrecognized_command(context_t *context)
{
    log_write(context->log, "[%s] received unrecognized command %s at state %s",
        context->uuid, context->command, state_string(context->state));

    if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {
        return -1;
    }

    return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,
        "500 Syntax error, command unrecognized" CRLF);
}
```


Overlapping Code:
```
ic int handle_unrecognized_command(context_t *context)
{
log_write(context->log, "[%s] received unrecognized command %s at state %s",
context->uuid, context->command, state_string(context->state));
if (buffer_shift_read_after(&context->in_message, CRLF, sizeof(CRLF) - 1) < 0) {
return -1;
}
return BUFFER_TAILQ_PUSH_BACK_STRING(&context->out_message_queue,
"500 Syntax error, command unrecognized" C
```
<Overlap Ratio: 0.9732360097323601>

---

--- 86 --
Question ID: 077ade691ebc998d455a13f561b09ece94a1f115_0
Original Code:
```
class ModApiHttp : public ModApiBase {
private:
#if USE_CURL
	// Helpers for HTTP fetch functions
	static void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);
	static void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);

	// http_fetch_async({url=, timeout=, post_data=})
	static int l_http_fetch_async(lua_State *L);

	// http_fetch_async_get(handle)
	static int l_http_fetch_async_get(lua_State *L);

	// request_http_api()
	static int l_request_http_api(lua_State *L);
#endif

public:
	static void Initialize(lua_State *L, int top);
}
```


Overlapping Code:
```
 ModApiHttp : public ModApiBase {
private:
#if USE_CURL
// Helpers for HTTP fetch functions
static void read_http_fetch_request(lua_State *L, HTTPFetchRequest &req);
static void push_http_fetch_result(lua_State *L, HTTPFetchResult &res, bool completed = true);
// http_fetch_async({url=, timeout=, post_data=})
static int l_http_fetch_async(lua_State *L);
// http_fetch_async_get(handle)
static int l_http_fetch_async_get(lua_State *L);
// request_http_api()
static int l_request_http_api(lua_State *L);
#endif
public:
static void Initialize(lua_State *L, int 
```
<Overlap Ratio: 0.9790209790209791>

---

--- 87 --
Question ID: 12fd50a0d39f350216a7bf29648ed4493444da7d_5
Original Code:
```
PUBLIC FILE *sys_driver_1(FILE *output, int lines, char *file_name)
{
    char path[80];

    if(!(_input_file = fopen(file_name, "r"))){
        sys_searchenv(file_name, "CGKLIB", path);   /*Library to be modified....*/
        if(!*path) {
            errno = ENOENT;
            return NULL;
        }

        if(!(_input_file = fopen(path, "r"))){
            return NULL;
        }
    }

    strncpy(_file_name, file_name, sizeof(_file_name));
    _input_line = 0;
    sys_driver_2(output, lines);

    return _input_file;
}
```


Overlapping Code:
```
s_driver_1(FILE *output, int lines, char *file_name)
{
char path[80];
if(!(_input_file = fopen(file_name, "r"))){
sys_searchenv(file_name, "CGKLIB", path); /*Library to be modified....*/
if(!*path) {
errno = ENOENT;
return NULL;
}
if(!(_input_file = fopen(path, "r"))){
return NULL;
}
}
strncpy(_file_name, file_name, sizeof(_file_name));
_input_line = 0;
sys_driver_2(output, lines);
return _input_f
```
<Overlap Ratio: 0.9501187648456056>

---

--- 88 --
Question ID: 8acdcbebba2fface54ed7136d24bf1f38162fb8d_30
Original Code:
```
int pcap_thread_set_callback_ipv4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)
{
    if (!pcap_thread) {
        return PCAP_THREAD_EINVAL;
    }
    if (pcap_thread->callback_linux_sll
        || pcap_thread->callback_ether
        || pcap_thread->callback_null
        || pcap_thread->callback_loop
        || pcap_thread->callback_ieee802
        || pcap_thread->callback_gre
        || pcap_thread->callback_ip
        || pcap_thread->callback_icmp
        || pcap_thread->callback_icmpv6
        || pcap_thread->callback_udp
        || pcap_thread->callback_tcp) {
        return PCAP_THREAD_ELAYERCB;
    }
    if (pcap_thread->running) {
        return PCAP_THREAD_ERUNNING;
    }

    pcap_thread->callback_ipv4 = callback_ipv4;

    return PCAP_THREAD_OK;
}
```


Overlapping Code:
```
v4(pcap_thread_t* pcap_thread, pcap_thread_layer_callback_t callback_ipv4)
{
if (!pcap_thread) {
return PCAP_THREAD_EINVAL;
}
if (pcap_thread->callback_linux_sll
|| pcap_thread->callback_ether
|| pcap_thread->callback_null
|| pcap_thread->callback_loop
|| pcap_thread->callback_ieee802
|| pcap_thread->callback_gre
|| pcap_thread->callback_ip
|| pcap_thread->callback_icmp
|| pcap_thread->callback_icmpv6
|| pcap_thread->callback_udp
|| pcap_thread->callback_tcp) {
return PCAP_THREAD_ELAYERCB;
}
if (pcap_thread->running) {
return PCAP_THREAD_ERUNNING;
}
pcap_thread->callback_ipv4 = callback_ipv4;

```
<Overlap Ratio: 0.916030534351145>

---

--- 89 --
Question ID: f93e4c05d1772227b8a5334da8f209b89ec62807_0
Original Code:
```
TT_TEST_ROUTINE_DEFINE(case_ptr_stack)
{
    // tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);
    tt_u32_t v[__q_size] = {0};
    tt_u32_t i, n;
    tt_result_t ret;
    tt_ptrstk_t q;

    TT_TEST_CASE_ENTER()
    // test start

    for (i = 0; i < __q_size; ++i) {
        v[i] = i;
    }

    tt_ptrstk_init(&q, NULL);
    tt_ptrstk_clear(&q);
    TT_UT_EQUAL(tt_ptrstk_count(&q), 0, "");
    TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, "");
    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, "");

    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, "");

    {
        tt_ptrstk_iter_t pos;
        tt_ptrstk_iter(&q, &pos);
        i = 0;
        while (tt_ptrstk_iter_next(&pos) != NULL) {
            ++i;
        }
        TT_UT_EQUAL(i, 0, "");
    }

    for (i = 0; i < __q_size; ++i) {
        ret = tt_ptrstk_push(&q, &v[i]);
        TT_UT_SUCCESS(ret, "");
        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], "");
    }
    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, "");

    {
        tt_ptrstk_iter_t pos;
        tt_ptr_t p;

        tt_ptrstk_iter(&q, &pos);
        i = 0;
        while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {
            TT_UT_EQUAL(p, &v[i++], "");
        }
        TT_UT_EQUAL(i, __q_size, "");
    }

    n = tt_rand_u32() % __q_size;
    for (i = __q_size - 1; i >= (__q_size - n); --i) {
        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], "");
        TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], "");
    }
    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, "");

    for (i = __q_size - n; i < __q_size; ++i) {
        ret = tt_ptrstk_push(&q, &v[i]);
        TT_UT_SUCCESS(ret, "");
    }
    TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, "");

    for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {
        TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], "");
    }
    TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), "");

    tt_ptrstk_clear(&q);
    TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, "");
    TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, "");

    tt_ptrstk_destroy(&q);

    // test end
    TT_TEST_CASE_LEAVE()
}
```


Overlapping Code:
```
)
{
// tt_u32_t param = TT_TEST_ROUTINE_PARAM(tt_u32_t);
tt_u32_t v[__q_size] = {0};
tt_u32_t i, n;
tt_result_t ret;
tt_ptrstk_t q;
TT_TEST_CASE_ENTER()
// test start
for (i = 0; i < __q_size; ++i) {
v[i] = i;
}
tt_ptrstk_init(&q, NULL);
tt_ptrstk_clear(&q);
TT_UT_EQUAL(tt_ptrstk_count(&q), 0, "");
TT_UT_EQUAL(tt_ptrstk_empty(&q), TT_TRUE, "");
TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, "");
TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, "");
{
tt_ptrstk_iter_t pos;
tt_ptrstk_iter(&q, &pos);
i = 0;
while (tt_ptrstk_iter_next(&pos) != NULL) {
++i;
}
TT_UT_EQUAL(i, 0, "");
}
for (i = 0; i < __q_size; ++i) {
ret = tt_ptrstk_push(&q, &v[i]);
TT_UT_SUCCESS(ret, "");
TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i], "");
}
TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, "");
{
tt_ptrstk_iter_t pos;
tt_ptr_t p;
tt_ptrstk_iter(&q, &pos);
i = 0;
while ((p = tt_ptrstk_iter_next(&pos)) != NULL) {
TT_UT_EQUAL(p, &v[i++], "");
}
TT_UT_EQUAL(i, __q_size, "");
}
n = tt_rand_u32() % __q_size;
for (i = __q_size - 1; i >= (__q_size - n); --i) {
TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], "");
TT_UT_EQUAL(tt_ptrstk_top(&q), &v[i - 1], "");
}
TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size - n, "");
for (i = __q_size - n; i < __q_size; ++i) {
ret = tt_ptrstk_push(&q, &v[i]);
TT_UT_SUCCESS(ret, "");
}
TT_UT_EQUAL(tt_ptrstk_count(&q), __q_size, "");
for (i = __q_size - 1; i >= (__q_size - q.ptr_per_frame); --i) {
TT_UT_EQUAL(tt_ptrstk_pop(&q), &v[i], "");
}
TT_UT_EQUAL(tt_ptrstk_count(&q), (__q_size - q.ptr_per_frame), "");
tt_ptrstk_clear(&q);
TT_UT_EQUAL(tt_ptrstk_pop(&q), NULL, "");
TT_UT_EQUAL(tt_ptrstk_top(&q), NULL, "");
tt_ptrstk_destroy
```
<Overlap Ratio: 0.9542211652794292>

---

--- 90 --
Question ID: f9ea73c7054e98e3305565e3cd943fb03427030f_0
Original Code:
```
static inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const         hw,
                                                                    hri_oscctrl_intflag_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Oscctrl *)hw)->INTFLAG.reg;
	tmp &= mask;
	return tmp;
}
```


Overlapping Code:
```
 inline hri_oscctrl_intflag_reg_t hri_oscctrl_get_INTFLAG_reg(const void *const hw,
hri_oscctrl_intflag_reg_t mask)
{
uint32_t tmp;
tmp = ((Oscctrl *)hw)->INTFLAG.reg;
tmp &= mask;
retu
```
<Overlap Ratio: 0.925>

---

--- 91 --
Question ID: 80574feb01fb1c6b8bde23b18b39b4436b316cbf_3
Original Code:
```
static inline UWord ROLW ( UWord w, Int n )
{
   Int bpw = 8 * sizeof(UWord);
   w = (w << n) | (w >> (bpw-n));
   return w;
}
```


Overlapping Code:
```
 UWord ROLW ( UWord w, Int n )
{
Int bpw = 8 * sizeof(UWord);
w = (w << n) | (w >> (bpw-n));
return 
```
<Overlap Ratio: 0.8547008547008547>

---

--- 92 --
Question ID: a29aec400085a6a10fb93ec306d1caa0c6ee84dc_15
Original Code:
```
VALUE
rb_rational_uminus(VALUE self)
{
    const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);
    get_dat1(self);
    (void)unused;
    return f_rational_new2(CLASS_OF(self), rb_int_uminus(dat->num), dat->den);
}
```


Overlapping Code:
```
(VALUE self)
{
const int unused = (assert(RB_TYPE_P(self, T_RATIONAL)), 0);
get_dat1(self);
(void)unused;
return f_rational_new2(CLASS_OF(self), rb_in
```
<Overlap Ratio: 0.7281553398058253>

---

--- 93 --
Question ID: a95399562d50d74c079bf3135fae936946b14f30_25
Original Code:
```
void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)
{
	IMB_moviecache_free(accessor->cache);
	libmv_FrameAccessorDestroy(accessor->libmv_accessor);
	MEM_freeN(accessor);
}
```


Overlapping Code:
```
void tracking_image_accessor_destroy(TrackingImageAccessor *accessor)
{
IMB_moviecache_free(accessor->cache);
libmv_FrameAccessorDestroy(accessor->lib
```
<Overlap Ratio: 0.8064516129032258>

---

--- 94 --
Question ID: 28aede9073a119d79e469097384f8e23204ddf12_0
Original Code:
```
int main(){
        char s1[MAXLEN];
        char s2[MAXLEN];
        char *res;
        int pos, status;
        
        while (1){
                printf("Please input string to squeeze s1: ");
                res = fgets(s1, MAXLEN, stdin);
                if (res == NULL)
                        return 0;
                printf("Please input the reference string s2: ");
                res = fgets(s2, MAXLEN, stdin);
                if (res == NULL)
                        return 0;
                eliminate_newline(s1);
                eliminate_newline(s2);
                pos = any(s1, s2);
                if (pos > 0)
                        printf("First position of s2 chars in s1: %d\n", pos);
                else
                        printf("s2 chars not found in s1\n. ");
                                
                status = squeeze(s1, s2);
                if (status == 0)
                        printf("String after squeezing is: %s\n", s1);
        }
        
        return -1;
}
```


Overlapping Code:
```
;
char s2[MAXLEN];
char *res;
int pos, status;

while (1){
printf("Please input string to squeeze s1: ");
res = fgets(s1, MAXLEN, stdin);
if (res == NULL)
return 0;
printf("Please input the reference string s2: ");
res = fgets(s2, MAXLEN, stdin);
if (res == NULL)
return 0;
eliminate_newline(s1);
eliminate_newline(s2);
pos = any(s1, s2);
if (pos > 0)
printf("First position of s2 chars in s1: %d\n", pos);
else
printf("s2 chars not found in s1\n. ");

status = squeeze(s1, s2);
if (status == 0)
printf("String after squeezing is: %s\n", s1);
}

retu
```
<Overlap Ratio: 0.9401709401709402>

---

--- 95 --
Question ID: 5a5ce4e0ca764a9b0333d41085a4a154262ce591_3
Original Code:
```
inline void InsertTailList(
	plist_entry ListHead,
	plist_entry Entry
)
{
	plist_entry Blink;

	Blink = ListHead->Blink;
	Entry->Flink = ListHead;
	Entry->Blink = Blink;
	Blink->Flink = Entry;
	ListHead->Blink = Entry;
	return;
}
```


Overlapping Code:
```

plist_entry ListHead,
plist_entry Entry
)
{
plist_entry Blink;
Blink = ListHead->Blink;
Entry->Flink = ListHead;
Entry->Blink = Blink;
Blink->Flink = Entry;
ListHead->Blink = Entry;
return;
}
```
<Overlap Ratio: 0.8767123287671232>

---

--- 96 --
Question ID: 975b78e6bb712e43333475591cfa8b98746d155a_0
Original Code:
```
class ClosedCube_TCA9538 {
public:
	ClosedCube_TCA9538();

	void begin(uint8_t address);
	void init(TCA9538_Registers regs);

	TCA9538_Input readInput();

	void writePolarity(TCA9538_PolarityInversion polarity);
	
	void writeOutput(TCA9538_Output output);
	TCA9538_Output readOutput();

	void writeConfig(TCA9538_Config config);

private:

	uint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);
	uint8_t _address;
}
```


Overlapping Code:
```
class ClosedCube_TCA9538 {
public:
ClosedCube_TCA9538();
void begin(uint8_t address);
void init(TCA9538_Registers regs);
TCA9538_Input readInput();
void writePolarity(TCA9538_PolarityInversion polarity);

void writeOutput(TCA9538_Output output);
TCA9538_Output readOutput();
void writeConfig(TCA9538_Config config);
private:
uint8_t writeData(TCA9538_Commands cmd, uint8_t rawData);
uint8_t _address;
```
<Overlap Ratio: 0.9950248756218906>

---

--- 97 --
Question ID: 038e918cdf95482a81a8134fbac34db19ce67685_11
Original Code:
```
unt camellia_decenc_cbc_pad(uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, 
                            uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)
{
	uchar foo[CM_BLOCKSIZE];
	unt Byte, pByte;

	//前回の詰め物をfoo[]にかき出す。
	camellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);
	Byte = foo[CM_BLOCKSIZE-1] & 0x0f;
	pByte = CM_BLOCKSIZE - Byte;

	//新たに詰め物を用意
	camellia_padding(&foo[Byte], pByte);
	foo[CM_BLOCKSIZE-1] &= 0x0f;
	foo[CM_BLOCKSIZE-1] |= Byte;
	camellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);

	return 1;
}
```


Overlapping Code:
```
uchar *newc, uchar *newiv, CAMELLIA_KEY *cmNEWkey, 
uchar *oldc, uchar *oldiv, CAMELLIA_KEY *cmOLDkey)
{
uchar foo[CM_BLOCKSIZE];
unt Byte, pByte;
//前回の詰め物をfoo[]にかき出す。
camellia_decrypt_cbc(foo, oldc, oldiv, cmOLDkey);
Byte = foo[CM_BLOCKSIZE-1] & 0x0f;
pByte = CM_BLOCKSIZE - Byte;
//新たに詰め物を用意
camellia_padding(&foo[Byte], pByte);
foo[CM_BLOCKSIZE-1] &= 0x0f;
foo[CM_BLOCKSIZE-1] |= Byte;
camellia_encrypt_cbc(newc, foo, newiv, cmNEWkey);
return 1;
}
```
<Overlap Ratio: 0.9414225941422594>

---

--- 98 --
Question ID: 18dd4b7fb18f09455bd9953e6900c5c3159d110c_7
Original Code:
```
struct circle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) 
{
	int k;
	double signed_distance, circle_radius;
	double circle_center[3], circle_atom_vector[3], circle_axis[3];
	struct circle *circle_ptr;
	struct sphere *atm_ptr;

	atm_ptr = torus_ptr -> atm[which_side];

	/* computations for circle */
	circle_radius =
		torus_ptr -> radius * atm_ptr -> radius /
		(atm_ptr -> radius + this_srf -> probe_radius);
	for (k = 0; k < 3; k++) {
		circle_center[k] =
			(atm_ptr -> radius * torus_ptr -> center[k] +
			this_srf -> probe_radius * atm_ptr -> center[k])
			/ (atm_ptr -> radius + this_srf -> probe_radius);
		circle_atom_vector[k] =
			circle_center[k] - atm_ptr -> center[k];
		circle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];
	}

	/* allocate memory, setup fields */
	circle_ptr = new_circle (circle_center, circle_radius, circle_axis);
	if (error()) return(NULL);
	link_circle (this_srf, circle_ptr);
	circle_ptr -> subtype = CONTACT_SUBTYPE;
	signed_distance = (-dot_product (circle_axis, circle_atom_vector));
	circle_ptr -> theta = atan2 (signed_distance, circle_radius);
	circle_ptr -> atm = atm_ptr;
	torus_ptr -> cir[which_side] = circle_ptr;
	return (circle_ptr);
}
```


Overlapping Code:
```
rcle *new_contact_circle (struct surface *this_srf, struct torus *torus_ptr, int which_side) 
{
int k;
double signed_distance, circle_radius;
double circle_center[3], circle_atom_vector[3], circle_axis[3];
struct circle *circle_ptr;
struct sphere *atm_ptr;
atm_ptr = torus_ptr -> atm[which_side];
/* computations for circle */
circle_radius =
torus_ptr -> radius * atm_ptr -> radius /
(atm_ptr -> radius + this_srf -> probe_radius);
for (k = 0; k < 3; k++) {
circle_center[k] =
(atm_ptr -> radius * torus_ptr -> center[k] +
this_srf -> probe_radius * atm_ptr -> center[k])
/ (atm_ptr -> radius + this_srf -> probe_radius);
circle_atom_vector[k] =
circle_center[k] - atm_ptr -> center[k];
circle_axis[k] = (2 * which_side - 1) * torus_ptr -> axis[k];
}
/* allocate memory, setup fields */
circle_ptr = new_circle (circle_center, circle_radius, circle_axis);
if (error()) return(NULL);
link_circle (this_srf, circle_ptr);
circle_ptr -> subtype = CONTACT_SUBTYPE;
signed_distance = (-dot_product (circle_axis, circle_atom_vector));
circle_ptr -> theta = atan2 (signed_distance, circle_radius);
circle_ptr -> atm = atm_ptr;
torus_ptr -> cir[which_side] =
```
<Overlap Ratio: 0.9631490787269682>

---

--- 99 --
Question ID: 748e427bc2b13e6a6444ebe2c9f1c3ea93aab6b4_8
Original Code:
```
int mip_lpwg_enable_sensing(struct i2c_client *client, bool enable)
{
	u8 wbuf[4];

	wbuf[0] = MIP_R0_LPWG;
	wbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;
	wbuf[2] = enable;

	if (FT8707_I2C_Write(client, wbuf, 3)) {
		TOUCH_ERR("mip_lpwg_enable_sensing failed\n");
		return TOUCH_FAIL;
	}

	return 0;
}
```


Overlapping Code:
```
e_sensing(struct i2c_client *client, bool enable)
{
u8 wbuf[4];
wbuf[0] = MIP_R0_LPWG;
wbuf[1] = MIP_R1_LPWG_ENABLE_SENSING;
wbuf[2] = enable;
if (FT8707_I2C_Write(client, wbuf, 3)) {
TOUCH_ERR("mip_lpwg_enable_sensing failed\n");
return TOUCH_FAIL;
}
ret
```
<Overlap Ratio: 0.9074733096085409>

---

--- 100 --
Question ID: 7985ebbb69cd8587569a95ffc9b524311651bd4c_0
Original Code:
```
interface TSKernelClock : TSClock {

	unsigned _service;
	unsigned _connection;
	IONotificationPortRef _notificationPort;

}
```


Overlapping Code:
```
 TSKernelClock : TSClock {
unsigned _service;
unsigned _connection;
IONotificationPortRef _notification
```
<Overlap Ratio: 0.865546218487395>

---

--- 101 --
Question ID: 8876e7f3bfa35524c53cdb237e34bf62c286cfd7_0
Original Code:
```
static int
port_imirror_lt_fields_parse(int unit,
                             const bcmltd_field_t *key,
                             const bcmltd_field_t *data,
                             port_imirror_t *imirror)
{
    const bcmltd_field_t *gen_field;
    uint32_t fid;
    uint64_t fval;

    SHR_FUNC_ENTER(unit);

    sal_memset(imirror, 0, sizeof(*imirror));

    /* Parse key field */
    gen_field = key;
    while (gen_field) {
        fid = gen_field->id;
        fval = gen_field->data;

        switch (fid) {
        case PORT_ING_MIRRORt_PORT_IDf:
            imirror->port = fval;
            SHR_BITSET(imirror->fbmp, fid);
            break;
        case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:
            imirror->instance_id = fval;
            SHR_BITSET(imirror->fbmp, fid);
            break;
        default:
            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);
        }
        gen_field = gen_field->next;
    }

    /* Parse data field */
    gen_field = data;
    while (gen_field) {
        fid = gen_field->id;
        fval = gen_field->data;

        switch (fid) {
        case PORT_ING_MIRRORt_MIRROR_ENABLEf:
            imirror->enable = fval;
            SHR_BITSET(imirror->fbmp, fid);
            break;
        default:
            SHR_RETURN_VAL_EXIT(SHR_E_PARAM);
        }
        gen_field = gen_field->next;
    }

exit:
    SHR_FUNC_EXIT();
}
```


Overlapping Code:
```
ic int
port_imirror_lt_fields_parse(int unit,
const bcmltd_field_t *key,
const bcmltd_field_t *data,
port_imirror_t *imirror)
{
const bcmltd_field_t *gen_field;
uint32_t fid;
uint64_t fval;
SHR_FUNC_ENTER(unit);
sal_memset(imirror, 0, sizeof(*imirror));
/* Parse key field */
gen_field = key;
while (gen_field) {
fid = gen_field->id;
fval = gen_field->data;
switch (fid) {
case PORT_ING_MIRRORt_PORT_IDf:
imirror->port = fval;
SHR_BITSET(imirror->fbmp, fid);
break;
case PORT_ING_MIRRORt_MIRROR_INSTANCE_IDf:
imirror->instance_id = fval;
SHR_BITSET(imirror->fbmp, fid);
break;
default:
SHR_RETURN_VAL_EXIT(SHR_E_PARAM);
}
gen_field = gen_field->next;
}
/* Parse data field */
gen_field = data;
while (gen_field) {
fid = gen_field->id;
fval = gen_field->data;
switch (fid) {
case PORT_ING_MIRRORt_MIRROR_ENABLEf:
imirror->enable = fval;
SHR_BITSET(imirror->fbmp, fid);
break;
default:
SHR_RETURN_VAL_EXIT(SHR_E_PARAM);
}
gen_field = gen_field->next;
}
exit:
SHR_FUNC_EXIT();
}
```
<Overlap Ratio: 0.9959141981613892>

---

--- 102 --
Question ID: 9977ee713654e075e81c0392d1ffe82b6d65ca4e_5
Original Code:
```
int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)
{
	void *tlv_buf = &msg->svc.tlv;
	unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
	struct tlv *tlv;
	int i;
	uint32_t found[1] = {};

	memset(res, 0, sizeof(*res));

	__qmi_alloc_reset();
	while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
		unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
		unsigned int ofs = 0;

		switch(tlv->type) {
		case 0x01:
			if (found[0] & (1 << 1))
				break;

			found[0] |= (1 << 1);
			res->set.state = 1;
			res->data.state.gps_service_state = *(uint8_t *) get_next(1);
			res->data.state.tracking_session_state = *(uint8_t *) get_next(1);
			break;

		default:
			break;
		}
	}

	return 0;

error_len:
	fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
	        __func__, tlv->type, le16_to_cpu(tlv->len));
	return QMI_ERROR_INVALID_DATA;
}
```


Overlapping Code:
```
int qmi_parse_pds_get_gps_service_state_response(struct qmi_msg *msg, struct qmi_pds_get_gps_service_state_response *res)
{
void *tlv_buf = &msg->svc.tlv;
unsigned int tlv_len = le16_to_cpu(msg->svc.tlv_len);
struct tlv *tlv;
int i;
uint32_t found[1] = {};
memset(res, 0, sizeof(*res));
__qmi_alloc_reset();
while ((tlv = tlv_get_next(&tlv_buf, &tlv_len)) != NULL) {
unsigned int cur_tlv_len = le16_to_cpu(tlv->len);
unsigned int ofs = 0;
switch(tlv->type) {
case 0x01:
if (found[0] & (1 << 1))
break;
found[0] |= (1 << 1);
res->set.state = 1;
res->data.state.gps_service_state = *(uint8_t *) get_next(1);
res->data.state.tracking_session_state = *(uint8_t *) get_next(1);
break;
default:
break;
}
}
return 0;
error_len:
fprintf(stderr, "%s: Invalid TLV length in message, tlv=0x%02x, len=%d\n",
__func__, tlv->type, le16_to_cpu(tlv->len));
return QMI_ERROR_INVALID_DATA;
}
```
<Overlap Ratio: 1.0>

---

--- 103 --
Question ID: 1912d2b54f9c18bf78cd92c9dcd6a0fbe5beab90_8
Original Code:
```
void
test__parseGPHDUri__NegativeTestMissingValue(void **state)
{
	char* uri_missing_value = "pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=";

	/* Setting the test -- code omitted -- */
	PG_TRY();
	{
		/* This will throw a ereport(ERROR).*/
		GPHDUri* parsed = parseGPHDUri(uri_missing_value);
	}
	PG_CATCH();
	{
		CurrentMemoryContext = 1;
		ErrorData *edata = CopyErrorData();

		/*Validate the type of expected error */
		assert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);
		assert_true(edata->elevel == ERROR);
		assert_string_equal(edata->message, "Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='");
		elog_dismiss(INFO);
		return;
	}
	PG_END_TRY();

	assert_true(false);
}
```


Overlapping Code:
```
id
test__parseGPHDUri__NegativeTestMissingValue(void **state)
{
char* uri_missing_value = "pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=";
/* Setting the test -- code omitted -- */
PG_TRY();
{
/* This will throw a ereport(ERROR).*/
GPHDUri* parsed = parseGPHDUri(uri_missing_value);
}
PG_CATCH();
{
CurrentMemoryContext = 1;
ErrorData *edata = CopyErrorData();
/*Validate the type of expected error */
assert_true(edata->sqlerrcode == ERRCODE_SYNTAX_ERROR);
assert_true(edata->elevel == ERROR);
assert_string_equal(edata->message, "Invalid URI pxf://1.2.3.4:5678/some/path/and/table.tbl?FRAGMENTER=: option 'FRAGMENTER=' missing value after '='");
elog_dismiss(INFO);
return;
}
PG_END_TRY();
assert_true(false
```
<Overlap Ratio: 0.9917127071823204>

---

--- 104 --
Question ID: f7b44a0ee40879b665b2e27418bba86e01140acc_23
Original Code:
```
int libxl__enum_from_string(const libxl_enum_string_table *t,
                            const char *s, int *e)
{
    if (!t) return ERROR_INVAL;

    for( ; t->s; t++) {
        if (!strcasecmp(t->s, s)) {
                *e = t->v;
                return 0;
        }
    }
    return ERROR_FAIL;
}
```


Overlapping Code:
```
m_string(const libxl_enum_string_table *t,
const char *s, int *e)
{
if (!t) return ERROR_INVAL;
for( ; t->s; t++) {
if (!strcasecmp(t->s, s)) {
*e = t-
```
<Overlap Ratio: 0.7259615384615384>

---

--- 105 --
Question ID: ec9a327c7e46d6d141f24f194b60533824ec5a4f_70
Original Code:
```
void
mono_gc_add_memory_pressure (gint64 value)
{
	/* FIXME: Use interlocked functions */
	LOCK_GC;
	memory_pressure += value;
	UNLOCK_GC;
}
```


Overlapping Code:
```
o_gc_add_memory_pressure (gint64 value)
{
/* FIXME: Use interlocked functions */
LOCK_GC;
memory_pressure += value;
UNLOCK
```
<Overlap Ratio: 0.8970588235294118>

---

--- 106 --
Question ID: 9c7ca375ff660a322422d65fb1ae12349978085a_22
Original Code:
```
static void
linevector_add (vec, text, len, vers, pos)
    struct linevector *vec;
    char *text;
    size_t len;
    RCSVers *vers;
    unsigned int pos;
{
    char *textend;
    unsigned int i;
    unsigned int nnew;
    char *p;
    struct line *lines;

    if (len == 0)
	return;

    textend = text + len;

    /* Count the number of lines we will need to add.  */
    nnew = 1;
    for (p = text; p < textend; ++p)
	if (*p == '\n' && p + 1 < textend)
	    ++nnew;
    /* Allocate the struct line's.  */
    lines = block_alloc (nnew * sizeof (struct line));

    /* Expand VEC->VECTOR if needed.  */
    if (vec->nlines + nnew >= vec->lines_alloced)
    {
	if (vec->lines_alloced == 0)
	    vec->lines_alloced = 10;
	while (vec->nlines + nnew >= vec->lines_alloced)
	    vec->lines_alloced *= 2;
	vec->vector = xrealloc (vec->vector,
				vec->lines_alloced * sizeof (*vec->vector));
    }

    /* Make room for the new lines in VEC->VECTOR.  */
    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)
	vec->vector[i] = vec->vector[i - nnew];

    if (pos > vec->nlines)
	error (1, 0, "invalid rcs file: line to add out of range");

    /* Actually add the lines, to LINES and VEC->VECTOR.  */
    i = pos;
    lines[0].text = text;
    lines[0].vers = vers;
    lines[0].has_newline = 0;
    vec->vector[i++] = &lines[0];
    for (p = text; p < textend; ++p)
	if (*p == '\n')
	{
	    *p = '\0';
	    lines[i - pos - 1].has_newline = 1;
	    if (p + 1 == textend)
		/* If there are no characters beyond the last newline, we
		   don't consider it another line.  */
		break;
	    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
	    lines[i - pos].text = p + 1;
	    lines[i - pos].vers = vers;
	    lines[i - pos].has_newline = 0;
	    vec->vector[i] = &lines[i - pos];
	    ++i;
	}
    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
    vec->nlines += nnew;
}
```


Overlapping Code:
```
void
linevector_add (vec, text, len, vers, pos)
struct linevector *vec;
char *text;
size_t len;
RCSVers *vers;
unsigned int pos;
{
char *textend;
unsigned int i;
unsigned int nnew;
char *p;
struct line *lines;
if (len == 0)
return;
textend = text + len;
/* Count the number of lines we will need to add. */
nnew = 1;
for (p = text; p < textend; ++p)
if (*p == '\n' && p + 1 < textend)
++nnew;
/* Allocate the struct line's. */
lines = block_alloc (nnew * sizeof (struct line));
/* Expand VEC->VECTOR if needed. */
if (vec->nlines + nnew >= vec->lines_alloced)
{
if (vec->lines_alloced == 0)
vec->lines_alloced = 10;
while (vec->nlines + nnew >= vec->lines_alloced)
vec->lines_alloced *= 2;
vec->vector = xrealloc (vec->vector,
vec->lines_alloced * sizeof (*vec->vector));
}
/* Make room for the new lines in VEC->VECTOR. */
for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)
vec->vector[i] = vec->vector[i - nnew];
if (pos > vec->nlines)
error (1, 0, "invalid rcs file: line to add out of range");
/* Actually add the lines, to LINES and VEC->VECTOR. */
i = pos;
lines[0].text = text;
lines[0].vers = vers;
lines[0].has_newline = 0;
vec->vector[i++] = &lines[0];
for (p = text; p < textend; ++p)
if (*p == '\n')
{
*p = '\0';
lines[i - pos - 1].has_newline = 1;
if (p + 1 == textend)
/* If there are no characters beyond the last newline, we
don't consider it another line. */
break;
lines[i - pos - 1].len = p - lines[i - pos - 1].text;
lines[i - pos].text = p + 1;
lines[i - pos].vers = vers;
lines[i - pos].has_newline = 0;
vec->vector[i] = &lines[i - pos];
++i;
}
lines[i - pos - 1].len = p - 
```
<Overlap Ratio: 0.9673518742442564>

---

--- 107 --
Question ID: c825ffcc91a581d35f2e33ba86676e2933016dca_3
Original Code:
```
void* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {
    GLFWwindow* win;

    /* set flags */
    glfwWindowHint(GLFW_SAMPLES, samples);
    glfwWindowHint(GLFW_RESIZABLE, resizable);
#ifdef USE_RETINA
    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);
#else
    glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);
#endif

    /* create window */
    win = glfwCreateWindow(width, height, "", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);
    glfwMakeContextCurrent(win);

    /* set vsync */
    glfwSwapInterval(vsync ? 1 : 0);

    return win;
}
```


Overlapping Code:
```
d* p_OpenScreen(int width, int height, bool_t fullscreen, int samples, bool_t vsync, bool_t resizable) {
GLFWwindow* win;
/* set flags */
glfwWindowHint(GLFW_SAMPLES, samples);
glfwWindowHint(GLFW_RESIZABLE, resizable);
#ifdef USE_RETINA
glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);
#else
glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE);
#endif
/* create window */
win = glfwCreateWindow(width, height, "", fullscreen ? glfwGetPrimaryMonitor() : NULL, NULL);
glfwMakeContextCurrent(win);
/* set vsync */
glfwSwapInterval(vsync 
```
<Overlap Ratio: 0.9548611111111112>

---

--- 108 --
Question ID: 333231c508fa3033cf5491ed4647ab6d1aa7be86_24
Original Code:
```
static jboolean
PCPathDone(PathConsumerVec *consumer)
{
    pathData *pd = (pathData *) consumer;
    jboolean oom = JNI_FALSE;

    HANDLEENDPATH(pd, {oom = JNI_TRUE;});

    return oom;
}
```


Overlapping Code:
```

PCPathDone(PathConsumerVec *consumer)
{
pathData *pd = (pathData *) consumer;
jboolean oom = JNI_FALSE;
HANDLEENDPATH(pd, {oom = JNI_TRUE;});
return 
```
<Overlap Ratio: 0.8771929824561403>

---

--- 109 --
Question ID: 875e51e2b094d0bfb9e94c43de6f86c080198e93_0
Original Code:
```
VOID
WriteA2NMailbox(
    IN VOID *pNFCAdapte
)
{
    PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;
    u8 i = 0;
    u32 RegTemp;

    if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {
        pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = 
            (pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));
        pNFCAdp->A2NSeq++;
    }    
    
    for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {
        HalDelayUs(30);
        HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);
    }
    
    HalDelayUs(30);
    RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;
    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);
    
    RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));
    HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);
}
```


Overlapping Code:
```
(
IN VOID *pNFCAdapte
)
{
PNFC_ADAPTER pNFCAdp = (PNFC_ADAPTER) pNFCAdapte;
u8 i = 0;
u32 RegTemp;
if (!(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Response)) {
pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0] = 
(pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[0]|(pNFCAdp->A2NSeq << 8));
pNFCAdp->A2NSeq++;
} 

for(i = 0; i < pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Length; i++) {
HalDelayUs(30);
HAL_WRITE32(NFC_INTERFACE_BASE, 0x10, pNFCAdp->A2NMAILQ[pNFCAdp->A2NWQRIdx].Content[i]);
}

HalDelayUs(30);
RegTemp = HAL_READ32(NFC_INTERFACE_BASE,0x24)|BIT1;
HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);

RegTemp = (HAL_READ32(NFC_INTERFACE_BASE,0x24)&(~BIT1));
HAL_WRITE32(NFC_INTERFACE_BASE, 0x24, RegTemp);

```
<Overlap Ratio: 0.9710344827586207>

---

--- 110 --
Question ID: 172a1c9ac13998f5cda3279364e0cdeb2042635c_0
Original Code:
```
VOID DriverSetInfo(
    _In_ PROP_OBJECT_INFO *Context,
    _In_ HWND hwndDlg
)
{
    BOOL                    cond = FALSE, bResult = FALSE, fGroup, bRet;
    INT                     nEndOfList, nEnd, nStart;
    DWORD                   i, bytesNeeded, dwServices, dwGroups;
    LPWSTR                  lpType;
    SC_HANDLE               SchSCManager = NULL, schService = NULL;
    LPENUM_SERVICE_STATUS   lpDependencies = NULL;
    LPQUERY_SERVICE_CONFIG  psci = NULL;
    LPSERVICE_DESCRIPTION   psd;
    SERVICE_STATUS_PROCESS  ssp;
    ENUM_SERVICE_STATUS     ess;
    WCHAR                   szBuffer[MAX_PATH + 1];

    __try {

        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);

        do {
            SchSCManager = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

            if (SchSCManager == NULL)
                break;

            schService = OpenService(
                SchSCManager,
                Context->lpObjectName,
                SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);

            if (schService == NULL)
                break;

            bytesNeeded = 0;
            bResult = QueryServiceConfig(
                schService,
                NULL,
                0,
                &bytesNeeded);

            if ((bResult == FALSE) && (bytesNeeded == 0))
                break;

            psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);
            if (psci == NULL)
                break;

            //disable comboboxes
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);

            bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);
            if (bResult) {
                //set key name (identical to object name)
                SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);
                //set image path info
                SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);
                //set display name
                SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);
                //set load order group
                SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup);

                //Service Type
                lpType = T_UnknownType;
                switch (psci->dwServiceType) {
                case SERVICE_KERNEL_DRIVER:
                    lpType = TEXT("Kernel-Mode Driver");
                    break;
                case SERVICE_FILE_SYSTEM_DRIVER:
                    lpType = TEXT("File System Driver");
                    break;
                case SERVICE_ADAPTER:
                    lpType = TEXT("Adapter");
                    break;
                case SERVICE_RECOGNIZER_DRIVER:
                    lpType = TEXT("File System Recognizer");
                    break;
                case SERVICE_WIN32_OWN_PROCESS:
                    lpType = TEXT("Own Process");
                    break;
                case SERVICE_WIN32_SHARE_PROCESS:
                    lpType = TEXT("Share Process");
                    break;
                case (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS):
                    lpType = TEXT("Own Process (Interactive)");
                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);
                    break;
                case (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS):
                    lpType = TEXT("Share Process (Interactive)");
                    SetDlgItemText(hwndDlg, ID_SERVICE_NAME, psci->lpServiceStartName);
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_TYPE, lpType);

                //Start Type
                lpType = T_UnknownType;
                switch (psci->dwStartType) {
                case SERVICE_AUTO_START:
                    lpType = TEXT("Auto");
                    break;
                case SERVICE_BOOT_START:
                    lpType = TEXT("Boot");
                    break;
                case SERVICE_DEMAND_START:
                    lpType = TEXT("On Demand");
                    break;
                case SERVICE_DISABLED:
                    lpType = TEXT("Disabled");
                    break;
                case SERVICE_SYSTEM_START:
                    lpType = TEXT("System");
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_START, lpType);

                //Error Control
                lpType = T_Unknown;
                switch (psci->dwErrorControl) {
                case SERVICE_ERROR_CRITICAL:
                    lpType = TEXT("Critical");
                    break;
                case SERVICE_ERROR_IGNORE:
                    lpType = TEXT("Ignore");
                    break;
                case SERVICE_ERROR_NORMAL:
                    lpType = TEXT("Normal");
                    break;
                case SERVICE_ERROR_SEVERE:
                    lpType = TEXT("Severe");
                    break;
                }
                SetDlgItemText(hwndDlg, ID_SERVICE_ERROR, lpType);

                //dwTagId
                if (psci->dwTagId) {
                    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
                    ultostr(psci->dwTagId, szBuffer);
                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, szBuffer);
                }
                else {
                    //not assigned tag
                    SetDlgItemText(hwndDlg, ID_SERVICE_TAG, L"");
                }

                //State
                RtlSecureZeroMemory(&ssp, sizeof(ssp));
                if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,
                    (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded))
                {
                    lpType = T_Unknown;
                    switch (ssp.dwCurrentState) {
                    case SERVICE_STOPPED:
                        lpType = TEXT("Stopped");
                        break;
                    case SERVICE_START_PENDING:
                        lpType = TEXT("Start Pending");
                        break;
                    case SERVICE_STOP_PENDING:
                        lpType = TEXT("Stop Pending");
                        break;
                    case SERVICE_RUNNING:
                        lpType = TEXT("Running");
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        lpType = TEXT("Continue Pending");
                        break;
                    case SERVICE_PAUSE_PENDING:
                        lpType = TEXT("Pause Pending");
                        break;
                    case SERVICE_PAUSED:
                        lpType = TEXT("Paused");
                        break;
                    }
                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, lpType);
                }
                else {
                    SetDlgItemText(hwndDlg, ID_SERVICE_CURRENT, T_CannotQuery);
                }

                //Service Description
                bRet = FALSE;
                SetDlgItemText(hwndDlg, ID_SERVICE_DESCRIPTION, L"");
                bytesNeeded = 0x1000;
                psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);
                if (psd) {

                    bRet = QueryServiceConfig2(
                        schService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (LPBYTE)psd,
                        bytesNeeded,
                        &bytesNeeded);

                    if ((bRet == FALSE) && (bytesNeeded != 0)) {
                        supHeapFree(psd);
                        psd = (LPSERVICE_DESCRIPTION)supHeapAlloc(bytesNeeded);
                    }
                    if (psd) {
                        //set description or hide window
                        bRet = QueryServiceConfig2(
                            schService,
                            SERVICE_CONFIG_DESCRIPTION,
                            (LPBYTE)psd,
                            bytesNeeded,
                            &bytesNeeded);

                        if (bRet) {
                            SetDlgItemText(hwndDlg, IDC_SERVICE_DESCRIPTION, psd->lpDescription);
                        }
                        supHeapFree(psd);
                    }
                }
                if (bRet == FALSE) {
                    //not enough memory, hide description window
                    ShowWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DESCRIPTION), SW_HIDE);
                }


                //Service Dependencies
                if (psci->lpDependencies) {

                    //first list DependsOnService, DependsOnGroup

                    nEndOfList = 0;
                    nEnd = 0;
                    nStart = 0;
                    dwGroups = 0;
                    dwServices = 0;

                    //calc total number of symbols
                    while ((psci->lpDependencies[nEndOfList] != L'\0') || (psci->lpDependencies[nEndOfList + 1] != L'\0'))
                        nEndOfList++;

                    if (nEndOfList > 0) {

                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                        SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

                        //iterate through MULTI_SZ string
                        do {
                            while (psci->lpDependencies[nEnd] != TEXT('\0')) {
                                nEnd++;
                            }

                            RtlSecureZeroMemory(&szBuffer, sizeof(szBuffer));
                            //maximum bytes that can be copied is sizeof(szBuffer)
                            _strncpy(szBuffer, sizeof(szBuffer), &psci->lpDependencies[nStart], nEnd);

                            //check if dependency is a group (has "+" before name)
                            fGroup = (szBuffer[0] == SC_GROUP_IDENTIFIER);
                            if (fGroup) {
                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_ADDSTRING,
                                    (WPARAM)0, (LPARAM)&szBuffer[1]);
                                dwGroups++;
                            }
                            else {
                                SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_ADDSTRING,
                                    (WPARAM)0, (LPARAM)&szBuffer);
                                dwServices++;
                            }
                            nEnd++;
                            nStart = nEnd;
                        } while (nEnd < nEndOfList);

                        //group present, enable combobox
                        if (dwGroups > 0) {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), TRUE);
                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONGROUP, CB_SETCURSEL,
                                (WPARAM)0, (LPARAM)0);
                        }
                        //service present, enable combobox
                        if (dwServices > 0) {
                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), TRUE);
                            SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE, CB_SETCURSEL,
                                (WPARAM)0, (LPARAM)0);
                        }
                    } //if (nEndOfList > 0)

                    //second list services that depends on this service
                    SendDlgItemMessage(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES, CB_RESETCONTENT,
                        (WPARAM)0, (LPARAM)0);

                    dwServices = 0;
                    bytesNeeded = 1024;
                    bRet = FALSE;

                    //avoid SCM unexpected behaviour by using preallocated buffer
                    lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc(bytesNeeded);
                    if (lpDependencies) {

                        bRet = EnumDependentServices(
                            schService,
                            SERVICE_STATE_ALL,
                            lpDependencies,
                            bytesNeeded,
                            &bytesNeeded,
                            &dwServices);

                        if (bRet && (GetLastError() == ERROR_MORE_DATA)) {
                            //more memory needed for enum
                            supHeapFree(lpDependencies);
                            dwServices = 0;
                            lpDependencies = (LPENUM_SERVICE_STATUS)supHeapAlloc((SIZE_T)bytesNeeded);
                            if (lpDependencies) {

                                bRet = EnumDependentServices(
                                    schService,
                                    SERVICE_STATE_ALL,
                                    lpDependencies,
                                    bytesNeeded,
                                    &bytesNeeded,
                                    &dwServices);

                            }
                        }

                        if (lpDependencies) {
                            //list dependents
                            if (bRet && dwServices) {
                                for (i = 0; i < dwServices; i++) {
                                    ess = *(lpDependencies + i);

                                    SendDlgItemMessage(
                                        hwndDlg,
                                        IDC_SERVICE_DEPENDENTSERVICES,
                                        CB_ADDSTRING,
                                        (WPARAM)0,
                                        (LPARAM)ess.lpServiceName);
                                }
                                //enable combobox and set current selection to the first item
                                EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), TRUE);

                                SendDlgItemMessage(
                                    hwndDlg,
                                    IDC_SERVICE_DEPENDENTSERVICES,
                                    CB_SETCURSEL,
                                    (WPARAM)0,
                                    (LPARAM)0);
                            }
                            supHeapFree(lpDependencies);
                        }
                    }
                } //if (psi->lpDependencies)
            } //bResult != FALSE

            CloseServiceHandle(schService);
            schService = NULL;
        } while (cond);

        if (psci != NULL)
            supHeapFree(psci);

        if (schService)
            CloseServiceHandle(schService);

        if (SchSCManager)
            CloseServiceHandle(SchSCManager);

        if (bResult == FALSE) {
            EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);
        }
        else {
            SetFocus(GetDlgItem(hwndDlg, ID_SERVICE_JUMPTOKEY));
        }

    }
    __except (exceptFilter(GetExceptionCode(), GetExceptionInformation())) {
        EnumChildWindows(hwndDlg, DriverShowChildWindows, SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), SW_SHOW);
        return;
    }
}
```


Overlapping Code:
```
iverSetInfo(
_In_ PROP_OBJECT_INFO *Context,
_In_ HWND hwndDlg
)
{
BOOL cond = FALSE, bResult = FALSE, fGroup, bRet;
INT nEndOfList, nEnd, nStart;
DWORD i, bytesNeeded, dwServices, dwGroups;
LPWSTR lpType;
SC_HANDLE SchSCManager = NULL, schService = NULL;
LPENUM_SERVICE_STATUS lpDependencies = NULL;
LPQUERY_SERVICE_CONFIG psci = NULL;
LPSERVICE_DESCRIPTION psd;
SERVICE_STATUS_PROCESS ssp;
ENUM_SERVICE_STATUS ess;
WCHAR szBuffer[MAX_PATH + 1];
__try {
ShowWindow(GetDlgItem(hwndDlg, IDC_QUERYFAIL), FALSE);
do {
SchSCManager = OpenSCManager(
NULL,
NULL,
SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
if (SchSCManager == NULL)
break;
schService = OpenService(
SchSCManager,
Context->lpObjectName,
SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS);
if (schService == NULL)
break;
bytesNeeded = 0;
bResult = QueryServiceConfig(
schService,
NULL,
0,
&bytesNeeded);
if ((bResult == FALSE) && (bytesNeeded == 0))
break;
psci = (LPQUERY_SERVICE_CONFIG)supHeapAlloc(bytesNeeded);
if (psci == NULL)
break;
//disable comboboxes
EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDENTSERVICES), FALSE);
EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONSERVICE), FALSE);
EnableWindow(GetDlgItem(hwndDlg, IDC_SERVICE_DEPENDSONGROUP), FALSE);
bResult = QueryServiceConfig(schService, psci, bytesNeeded, &bytesNeeded);
if (bResult) {
//set key name (identical to object name)
SetDlgItemText(hwndDlg, IDC_SERVICE_KEYNAME, Context->lpObjectName);
//set image path info
SetDlgItemText(hwndDlg, IDC_SERVICE_IMAGEPATH, psci->lpBinaryPathName);
//set display name
SetDlgItemText(hwndDlg, IDC_SERVICE_DISPLAYNAME, psci->lpDisplayName);
//set load order group
SetDlgItemText(hwndDlg, IDC_SERVICE_LOADORDERGROUP, psci->lpLoadOrderGroup
```
<Overlap Ratio: 0.9948834565093804>

---

--- 111 --
Question ID: a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_16
Original Code:
```
static void waitOnOne(struct pipeline *pl)
/* wait on one process to finish */
{
int status;
pid_t pid = waitpid(-pl->groupLeader, &status, 0);
if (pid < 0)
    errnoAbort("waitpid failed");
plProcHandleTerminate(pipelineFindProc(pl, pid), status);
pl->numRunning--;
assert(pl->numRunning >= 0);
}
```


Overlapping Code:
```
nOne(struct pipeline *pl)
/* wait on one process to finish */
{
int status;
pid_t pid = waitpid(-pl->groupLeader, &status, 0);
if (pid < 0)
errnoAbort("waitpid failed");
plProcHandleTerminate(pipelineFindProc(pl, pid), status);
pl->numRunning--;
asse
```
<Overlap Ratio: 0.8532423208191127>

---

--- 112 --
Question ID: bf08d10d8529fbb86a5090068765fc936794e1c3_3
Original Code:
```
static void clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {
  uint32_t i;

  assert(set->ndeleted == 0 && set->nelems < set->size);
  i = set->nelems;
  set->data[i] = p;
  set->nelems = i + 1;
}
```


Overlapping Code:
```
 clean_add_ptr_to_seq_set2(ptr_set2_t *set, void *p) {
uint32_t i;
assert(set->ndeleted == 0 && set->nelems < set->size);
i = set->nelems;
set->data[i
```
<Overlap Ratio: 0.7894736842105263>

---

--- 113 --
Question ID: 2a824f95e117a6a79ab2516dacaab3dc31cfad35_2
Original Code:
```
static inline u32
inl (u16 port)
{
  port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };
  if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)
    return 0;
  return (u32)args.value;
}
```


Overlapping Code:
```
ort)
{
port_io_args args = { POKE_SIGNATURE, port, sizeof(u32), 0 };
if (ioctl(poke_driver_fd, POKE_PORT_READ, &args, sizeof(args)) < 0)
return 0;
return (u32)args.va
```
<Overlap Ratio: 0.83>

---

--- 114 --
Question ID: ecf01cd97c44c1ae60dac30466fdb8b722512bc7_1
Original Code:
```
class TOutputFiles {
public:
    TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,
                 const TString& namesPrefix) {
        InitializeFiles(params, namesPrefix);
    }
    TString NamesPrefix;
    TString TimeLeftLogFile;
    TString LearnErrorLogFile;
    TString TestErrorLogFile;
    TString SnapshotFile;
    TString MetaFile;
    static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = "");

private:
    void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPrefix);
}
```


Overlapping Code:
```
lic:
TOutputFiles(const NCatboostOptions::TOutputFilesOptions& params,
const TString& namesPrefix) {
InitializeFiles(params, namesPrefix);
}
TString NamesPrefix;
TString TimeLeftLogFile;
TString LearnErrorLogFile;
TString TestErrorLogFile;
TString SnapshotFile;
TString MetaFile;
static TString AlignFilePath(const TString& baseDir, const TString& fileName, const TString& namePrefix = "");
private:
void InitializeFiles(const NCatboostOptions::TOutputFilesOptions& params, const TString& namesPre
```
<Overlap Ratio: 0.9412878787878788>

---

--- 115 --
Question ID: e9c675999b8322c312bdbe7bfa3b3bcd2d0b6130_4
Original Code:
```
static int
gattm_att_get_permission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,
        kernel_task_id_t const dest_id, kernel_task_id_t const src_id)
{
    struct attm_elmt elmt = ATT_ELEMT_INIT;
    struct gattm_att_get_permission_rsp *get_att_perm_rsp =
    KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);

    /* Retrieve attribute permissions */
    get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);
    get_att_perm_rsp->ext_perm  = (elmt.info.att->info.max_length & PERM_MASK_EKS);

    /* update handle */
    get_att_perm_rsp->handle = param->handle;

    /* send command response message. */
    kernel_msg_send(get_att_perm_rsp);

    /* message is consumed */
    return (KERNEL_MSG_CONSUMED);
}
```


Overlapping Code:
```
ission_req_handler(kernel_msg_id_t const msgid, struct gattm_att_get_permission_req *param,
kernel_task_id_t const dest_id, kernel_task_id_t const src_id)
{
struct attm_elmt elmt = ATT_ELEMT_INIT;
struct gattm_att_get_permission_rsp *get_att_perm_rsp =
KERNEL_MSG_ALLOC(GATTM_ATT_GET_PERMISSION_RSP, src_id, dest_id, gattm_att_get_permission_rsp);
/* Retrieve attribute permissions */
get_att_perm_rsp->status = attmdb_att_get_permission(param->handle, &(get_att_perm_rsp->perm), PERM_MASK_ALL, 0, &elmt);
get_att_perm_rsp->ext_perm = (elmt.info.att->info.max_length & PERM_MASK_EKS);
/* update handle */
get_att_perm_rsp->handle = param->handle;
/* send command response message. */
kernel_msg_send(get_att_perm_rsp);
/* message is consumed */
return (KERNEL_MSG_CONSUMED);
}
```
<Overlap Ratio: 0.9639751552795031>

---

--- 116 --
Question ID: 9d2255f856edc9b70b053da580eed33bada01390_2
Original Code:
```
void
Ideq_clearData (
   Ideq   *deq
) {
if ( deq == NULL ) {
   fprintf(stderr, "\n fatal error in Ideq_clearData(%p)"
           "\n deq is NULL\n", deq) ;
   exit(-1) ;
}
IV_clearData(&deq->iv) ;
Ideq_setDefaultFields(deq) ;

return ; }
```


Overlapping Code:
```
ata (
Ideq *deq
) {
if ( deq == NULL ) {
fprintf(stderr, "\n fatal error in Ideq_clearData(%p)"
"\n deq is NULL\n", deq) ;
exit(-1) ;
}
IV_clearData(&deq->iv) ;
Ideq_setDefaultFields(deq) ;
return ; }
```
<Overlap Ratio: 0.9259259259259259>

---

--- 117 --
Question ID: 762f91c85ddd2c54584a4f1c7b0c2f0f87ce3840_2
Original Code:
```
jobject Tuple_internalCreate(HeapTuple ht, bool mustCopy)
{
	jobject jht;
	Ptr2Long htH;

	if(mustCopy)
		ht = heap_copytuple(ht);

	htH.longVal = 0L; /* ensure that the rest is zeroed out */
	htH.ptrVal = ht;
	jht = JNI_newObject(s_Tuple_class, s_Tuple_init, htH.longVal);
	return jht;
}
```


Overlapping Code:
```
(HeapTuple ht, bool mustCopy)
{
jobject jht;
Ptr2Long htH;
if(mustCopy)
ht = heap_copytuple(ht);
htH.longVal = 0L; /* ensure that the rest is zeroed out */
htH.ptrVal = ht;
jht = JNI_newObject(s_Tuple
```
<Overlap Ratio: 0.7220216606498195>

---

--- 118 --
Question ID: 73a09de66a4167fe7510b6d84e1e153a61e6ee64_0
Original Code:
```
int main(int argc, char **argv)
{


    int fd_out, i;
    int oflags = O_CREAT | O_WRONLY | O_TRUNC;
    mode_t mode = S_IRUSR | S_IWUSR;
    int flag_same = 0;


    if(argc < 3){
        printf("Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\n");
        return(2);
    }
    else if (argc > 3) {

        for (i=1; i < argc-1; i++){
            if (!(strcmp(argv[i],argv[argc-1]))) {
                flag_same = 1;
                break;
            }
        }

        if(flag_same == 1) {
            printf("Warning: The requested output file matches one of the input files. File will be overwritten.\n");
        }

        fd_out = open("output_file", oflags, mode);

        for (i = 1; i < argc - 1; i++) {
            write_file(fd_out, argv[i]);
        }

        fd_out = open(argv[argc - 1], oflags, mode);
        write_file(fd_out, "output_file");
    	remove("output_file");
    }
    else {
        fd_out = open("fconc.out", oflags, mode);
        if (fd_out == -1) {
            perror("Open");
            exit(1);
        }
        for (i = 1; i < argc; i++) {
            write_file(fd_out, argv[i]);
        }
    }
    return 0;
}
```


Overlapping Code:
```
nt main(int argc, char **argv)
{
int fd_out, i;
int oflags = O_CREAT | O_WRONLY | O_TRUNC;
mode_t mode = S_IRUSR | S_IWUSR;
int flag_same = 0;
if(argc < 3){
printf("Usage: ./fconc.out infile1 infile2 [outfile (default:fconc.out.out)]\n");
return(2);
}
else if (argc > 3) {
for (i=1; i < argc-1; i++){
if (!(strcmp(argv[i],argv[argc-1]))) {
flag_same = 1;
break;
}
}
if(flag_same == 1) {
printf("Warning: The requested output file matches one of the input files. File will be overwritten.\n");
}
fd_out = open("output_file", oflags, mode);
for (i = 1; i < argc - 1; i++) {
write_file(fd_out, argv[i]);
}
fd_out = open(argv[argc - 1], oflags, mode);
write_file(fd_out, "output_file");
remove("output_file");
}
else {
fd_out = open("fconc.out", oflags, mode);
if (fd_out == -1) {
perror("Open");
exit(1);
}
for (i = 1; i < argc; i++) {
write_file(fd_out
```
<Overlap Ratio: 0.9681093394077449>

---

--- 119 --
Question ID: 049d707753abcbd3e6e024b1d920784bb56d039e_0
Original Code:
```
interface _DKEventIntersection : NSObject {

	NSDate* _startDate;
	NSDate* _endDate;
	NSArray* _events;

}
```


Overlapping Code:
```
nterface _DKEventIntersection : NSObject {
NSDate* _startDate;
NSDate* _endDate;
NSArray* _events;
}
```
<Overlap Ratio: 0.9900990099009901>

---

--- 120 --
Question ID: ef1571ef0753a638cfdedef0d904069aa73b75cd_3
Original Code:
```
static int UartMon_readPolling(UART_Handle handle, void *buffer, size_t size)
{
    UartMon_Object *obj = handle->object;

    int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);
    if (bytes_read > 0) {
        /* We should forward with polling functionality too, since this function
         * may be called while interrupts are disabled
         */
        UART_writePolling(obj->hUart_debug, buffer, bytes_read);
    }
    return bytes_read;
}
```


Overlapping Code:
```
eadPolling(UART_Handle handle, void *buffer, size_t size)
{
UartMon_Object *obj = handle->object;
int bytes_read = UART_readPolling(obj->hUart_in, buffer, size);
if (bytes_read > 0) {
/* We should forward with polling functionality too, since this function
* may be called while interrupts are disabled
*/
UART_writePolling(obj->hUart_debug, buffer, 
```
<Overlap Ratio: 0.8641975308641975>

---

--- 121 --
Question ID: 960624e1518955a53d27cd7ddb71a3be8731398b_1
Original Code:
```
static void
arc4_randomstir (void)
{
	u_int8_t key[256];
	int r, n;
	struct timeval tv_now;

	/*
	 * XXX read_random() returns unsafe numbers if the entropy
	 * device is not loaded -- MarkM.
	 */
	r = read_random(key, ARC4_KEYBYTES);
	getmicrouptime(&tv_now);
	mtx_lock(&arc4_mtx);
	/* If r == 0 || -1, just use what was on the stack. */
	if (r > 0) {
		for (n = r; n < sizeof(key); n++)
			key[n] = key[n % r];
	}

	for (n = 0; n < 256; n++) {
		arc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;
		arc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);
	}
	arc4_i = arc4_j = 0;

	/* Reset for next reseed cycle. */
	arc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;
	arc4_numruns = 0;

	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	for (n = 0; n < 256*4; n++)
		arc4_randbyte();
	mtx_unlock(&arc4_mtx);
}
```


Overlapping Code:
```

arc4_randomstir (void)
{
u_int8_t key[256];
int r, n;
struct timeval tv_now;
/*
* XXX read_random() returns unsafe numbers if the entropy
* device is not loaded -- MarkM.
*/
r = read_random(key, ARC4_KEYBYTES);
getmicrouptime(&tv_now);
mtx_lock(&arc4_mtx);
/* If r == 0 || -1, just use what was on the stack. */
if (r > 0) {
for (n = r; n < sizeof(key); n++)
key[n] = key[n % r];
}
for (n = 0; n < 256; n++) {
arc4_j = (arc4_j + arc4_sbox[n] + key[n]) % 256;
arc4_swap(&arc4_sbox[n], &arc4_sbox[arc4_j]);
}
arc4_i = arc4_j = 0;
/* Reset for next reseed cycle. */
arc4_t_reseed = tv_now.tv_sec + ARC4_RESEED_SECONDS;
arc4_numruns = 0;
/*
* Throw away the first N words of output, as suggested in the
* paper "Weaknesses in the Key Scheduling Algorithm of RC4"
* by Fluher, Mantin, and Shamir. (N = 256 in our case.)
*/
for (n = 0; n < 256*4; n++)
arc4_randbyte();
mtx_unlock(&arc4_mtx);
```
<Overlap Ratio: 0.985539488320356>

---

--- 122 --
Question ID: e7cd28714534062c473f49c8139e25a0ca4f2333_172
Original Code:
```
static void create_branch_atom(simplex_solver_t *solver, thvar_t x) {
  xrational_t *bound;
  int32_t new_idx, lb, ub;
  literal_t l;

  assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));

  bound = &solver->bound;
  lb = arith_var_lower_index(&solver->vtbl, x);
  ub = arith_var_upper_index(&solver->vtbl, x);
  if (lb >= 0 && ub >= 0) {
    xq_set(bound, solver->bstack.bound + lb);
    xq_add(bound, solver->bstack.bound + ub);
    q_set32(&solver->aux, 2);
    xq_div(bound, &solver->aux);
  } else {
    xq_set(bound, arith_var_value(&solver->vtbl, x));
  }
  xq_ceil(bound);
  assert(xq_is_integer(bound));

#if 0
  printf("\n---> Branch & bound\n\n");
  print_simplex_matrix(stdout, solver);
  print_simplex_bounds(stdout, solver);
  printf("\n");
  print_simplex_assignment(stdout, solver);
#endif

  l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);
  solver->last_branch_atom = var_of(l);

  /*
   * If support periodic calls to make_integer_feasible is enabled,
   * then the branch atom may not be new.
   */
  // assert(new_idx >= 0);
  if (new_idx >= 0) {
    build_binary_lemmas_for_atom(solver, x, new_idx);
    attach_atom_to_arith_var(&solver->vtbl, x, new_idx);

#if TRACE_BB || TRACE_INTFEAS
    //    printf("---> Branch & bound: create ");
    print_simplex_atomdef(stdout, solver, var_of(l));
#endif

    solver->stats.num_branch_atoms ++;
  }
}
```


Overlapping Code:
```
ver_t *solver, thvar_t x) {
xrational_t *bound;
int32_t new_idx, lb, ub;
literal_t l;
assert(arith_var_is_int(&solver->vtbl, x) & ! arith_var_value_is_int(&solver->vtbl, x));
bound = &solver->bound;
lb = arith_var_lower_index(&solver->vtbl, x);
ub = arith_var_upper_index(&solver->vtbl, x);
if (lb >= 0 && ub >= 0) {
xq_set(bound, solver->bstack.bound + lb);
xq_add(bound, solver->bstack.bound + ub);
q_set32(&solver->aux, 2);
xq_div(bound, &solver->aux);
} else {
xq_set(bound, arith_var_value(&solver->vtbl, x));
}
xq_ceil(bound);
assert(xq_is_integer(bound));
#if 0
printf("\n---> Branch & bound\n\n");
print_simplex_matrix(stdout, solver);
print_simplex_bounds(stdout, solver);
printf("\n");
print_simplex_assignment(stdout, solver);
#endif
l = get_literal_for_ge_atom(&solver->atbl, x, true, &bound->main, &new_idx);
solver->last_branch_atom = var_of(l);
/*
* If support periodic calls to make_integer_feasible is enabled,
* then the branch atom may not be new.
*/
// assert(new_idx >= 0);
if (new_idx >= 0) {
build_binary_lemmas_for_atom(solver, x, new_idx);
attach_atom_to_arith_var(&solver->vtbl, x, new_idx);
#if TRACE_BB || TRACE_INTFEAS
// printf("---> Branch & bound: create ");
print_simplex_atomdef(stdout, solver, var_of(l));
#endif
so
```
<Overlap Ratio: 0.9412650602409639>

---

--- 123 --
Question ID: ae58658fd0c92c187a5c72421e32cabfd92c22ac_6
Original Code:
```
int func6()
{
	hash(6);
	led_data ++ ;
	XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
	for (int Delay = 0; Delay < 3*LED_DELAY; Delay++);
	led_data -- ;
	XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
	for (int Delay = 0; Delay < LED_DELAY; Delay++);
	for(int x=0 ; x<=3 ; x++)
	{
	led_data ++ ;
	XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
	for (int Delay = 0; Delay < LED_DELAY; Delay++);
	led_data -- ;
	XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
	for (int Delay = 0; Delay < LED_DELAY; Delay++);
	}
	for (int Delay = 0; Delay < 2*LED_DELAY; Delay++);
}
```


Overlapping Code:
```
data ++ ;
XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
for (int Delay = 0; Delay < 3*LED_DELAY; Delay++);
led_data -- ;
XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
for (int Delay = 0; Delay < LED_DELAY; Delay++);
for(int x=0 ; x<=3 ; x++)
{
led_data ++ ;
XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
for (int Delay = 0; Delay < LED_DELAY; Delay++);
led_data -- ;
XGpio_DiscreteWrite(&LED_Gpio, 1, led_data);
for (int Delay = 0; Delay < LED_DELAY; Delay++);
}
for (int Delay = 0; Delay < 2*LED_DELAY; Delay++
```
<Overlap Ratio: 0.9424860853432282>

---

--- 124 --
Question ID: a7e5de57ad5b4c5a5a06f6b07600b247ced65621_13
Original Code:
```
ggsea_fill_pair_s ggsea_extend(
	struct ggsea_ctx_s *ctx,
	struct gref_gid_pos_s rpos,
	struct gref_gid_pos_s qpos)
{
	/* forward section */
	debug("forward extend");
	struct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);
	struct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);
	gaba_fill_t const *fw_max = ggsea_extend_intl(ctx,
		rfsec, rpos.pos,
		qfsec, qpos.pos);

	/* reverse section */
	debug("reverse extend");
	struct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));
	struct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));
	gaba_fill_t const *rv_max = ggsea_extend_intl(ctx,
		rrsec, rrsec->len - rpos.pos,
		qrsec, qrsec->len - qpos.pos);

	debug("fw_max(%lld), rv_max(%lld), max(%lld)",
		fw_max->max, rv_max->max, fw_max->max + rv_max->max);
	/* return max pair */
	return((struct ggsea_fill_pair_s){
		.fw = fw_max,
		.rv = rv_max
	});
}
```


Overlapping Code:
```
pair_s ggsea_extend(
struct ggsea_ctx_s *ctx,
struct gref_gid_pos_s rpos,
struct gref_gid_pos_s qpos)
{
/* forward section */
debug("forward extend");
struct gref_section_s const *rfsec = gref_get_section(ctx->r, rpos.gid);
struct gref_section_s const *qfsec = gref_get_section(ctx->q, qpos.gid);
gaba_fill_t const *fw_max = ggsea_extend_intl(ctx,
rfsec, rpos.pos,
qfsec, qpos.pos);
/* reverse section */
debug("reverse extend");
struct gref_section_s const *rrsec = gref_get_section(ctx->r, gref_rev_gid(rpos.gid));
struct gref_section_s const *qrsec = gref_get_section(ctx->q, gref_rev_gid(qpos.gid));
gaba_fill_t const *rv_max = ggsea_extend_intl(ctx,
rrsec, rrsec->len - rpos.pos,
qrsec, qrsec->len - qpos.pos);
debug("fw_max(%lld), rv_max(%lld), max(%lld)",
fw_max->max, rv_max->max, fw_max->max + rv_max->max);
/* return max pair */
return((struct ggsea_fill_pair_s){
.fw = fw_max,
.rv = rv_max
```
<Overlap Ratio: 0.9814612868047983>

---

--- 125 --
Question ID: f904eded3ae3337eb05a9dc97e8e8745e9615f5c_0
Original Code:
```
Drand *
Drand_new ( 
   void 
) {
Drand   *drand ;

ALLOCATE(drand, struct _Drand, 1) ;
Drand_setDefaultFields(drand) ;

return(drand) ; }
```


Overlapping Code:
```
id 
) {
Drand *drand ;
ALLOCATE(drand, struct _Drand, 1) ;
Drand_setDefaultFields(drand) ;
return(dr
```
<Overlap Ratio: 0.7633587786259542>

---

--- 126 --
Question ID: fa037a9c89ffeefd5c1454547a59f7e6e7f9128b_1
Original Code:
```
void BUTTONS_init()
{
    BUTTON_OUTPORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO
    BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input

    BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO
    BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_BIT); // configure RIGHT_BUTTON_IO as input
}
```


Overlapping Code:
```
ORT |= (1 << LEFT_BUTTON_BIT); // pull up LEFT_BUTTON_IO
BUTTON_DDRPORT &= ~(1 << LEFT_BUTTON_BIT); // configure LEFT_BUTTON_IO as input
BUTTON_OUTPORT |= (1 << RIGHT_BUTTON_BIT); // pull up the RIGHT_BUTTON_IO
BUTTON_DDRPORT &= ~(1 << RIGHT_BUTTON_B
```
<Overlap Ratio: 0.764525993883792>

---

--- 127 --
Question ID: 7591d8901f9a24ddd61d035500116c617e4df3f6_0
Original Code:
```
static int tegra_sor_dp_train_fast(struct tegra_sor *sor,
				   struct drm_dp_link *link)
{
	unsigned int i;
	u8 pattern;
	u32 value;
	int err;

	/* setup lane parameters */
	value = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |
		SOR_LANE_DRIVE_CURRENT_LANE2(0x40) |
		SOR_LANE_DRIVE_CURRENT_LANE1(0x40) |
		SOR_LANE_DRIVE_CURRENT_LANE0(0x40);
	tegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);

	value = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |
		SOR_LANE_PREEMPHASIS_LANE2(0x0f) |
		SOR_LANE_PREEMPHASIS_LANE1(0x0f) |
		SOR_LANE_PREEMPHASIS_LANE0(0x0f);
	tegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);

	value = SOR_LANE_POST_CURSOR_LANE3(0x00) |
		SOR_LANE_POST_CURSOR_LANE2(0x00) |
		SOR_LANE_POST_CURSOR_LANE1(0x00) |
		SOR_LANE_POST_CURSOR_LANE0(0x00);
	tegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);

	/* disable LVDS mode */
	tegra_sor_writel(sor, 0, SOR_LVDS);

	value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
	value |= SOR_DP_PADCTL_TX_PU_ENABLE;
	value &= ~SOR_DP_PADCTL_TX_PU_MASK;
	value |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */
	tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);

	value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
	value |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |
		 SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;
	tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);

	usleep_range(10, 100);

	value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
	value &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |
		   SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);
	tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);

	err = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);
	if (err < 0)
		return err;

	for (i = 0, value = 0; i < link->num_lanes; i++) {
		unsigned long lane = SOR_DP_TPG_CHANNEL_CODING |
				     SOR_DP_TPG_SCRAMBLER_NONE |
				     SOR_DP_TPG_PATTERN_TRAIN1;
		value = (value << 8) | lane;
	}

	tegra_sor_writel(sor, value, SOR_DP_TPG);

	pattern = DP_TRAINING_PATTERN_1;

	err = tegra_dpaux_train(sor->dpaux, link, pattern);
	if (err < 0)
		return err;

	value = tegra_sor_readl(sor, SOR_DP_SPARE_0);
	value |= SOR_DP_SPARE_SEQ_ENABLE;
	value &= ~SOR_DP_SPARE_PANEL_INTERNAL;
	value |= SOR_DP_SPARE_MACRO_SOR_CLK;
	tegra_sor_writel(sor, value, SOR_DP_SPARE_0);

	for (i = 0, value = 0; i < link->num_lanes; i++) {
		unsigned long lane = SOR_DP_TPG_CHANNEL_CODING |
				     SOR_DP_TPG_SCRAMBLER_NONE |
				     SOR_DP_TPG_PATTERN_TRAIN2;
		value = (value << 8) | lane;
	}

	tegra_sor_writel(sor, value, SOR_DP_TPG);

	pattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;

	err = tegra_dpaux_train(sor->dpaux, link, pattern);
	if (err < 0)
		return err;

	for (i = 0, value = 0; i < link->num_lanes; i++) {
		unsigned long lane = SOR_DP_TPG_CHANNEL_CODING |
				     SOR_DP_TPG_SCRAMBLER_GALIOS |
				     SOR_DP_TPG_PATTERN_NONE;
		value = (value << 8) | lane;
	}

	tegra_sor_writel(sor, value, SOR_DP_TPG);

	pattern = DP_TRAINING_PATTERN_DISABLE;

	err = tegra_dpaux_train(sor->dpaux, link, pattern);
	if (err < 0)
		return err;

	return 0;
}
```


Overlapping Code:
```
t tegra_sor *sor,
struct drm_dp_link *link)
{
unsigned int i;
u8 pattern;
u32 value;
int err;
/* setup lane parameters */
value = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |
SOR_LANE_DRIVE_CURRENT_LANE2(0x40) |
SOR_LANE_DRIVE_CURRENT_LANE1(0x40) |
SOR_LANE_DRIVE_CURRENT_LANE0(0x40);
tegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);
value = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |
SOR_LANE_PREEMPHASIS_LANE2(0x0f) |
SOR_LANE_PREEMPHASIS_LANE1(0x0f) |
SOR_LANE_PREEMPHASIS_LANE0(0x0f);
tegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);
value = SOR_LANE_POST_CURSOR_LANE3(0x00) |
SOR_LANE_POST_CURSOR_LANE2(0x00) |
SOR_LANE_POST_CURSOR_LANE1(0x00) |
SOR_LANE_POST_CURSOR_LANE0(0x00);
tegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);
/* disable LVDS mode */
tegra_sor_writel(sor, 0, SOR_LVDS);
value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
value |= SOR_DP_PADCTL_TX_PU_ENABLE;
value &= ~SOR_DP_PADCTL_TX_PU_MASK;
value |= SOR_DP_PADCTL_TX_PU(2); /* XXX: don't hardcode? */
tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);
value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
value |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |
SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;
tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);
usleep_range(10, 100);
value = tegra_sor_readl(sor, SOR_DP_PADCTL_0);
value &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |
SOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);
tegra_sor_writel(sor, value, SOR_DP_PADCTL_0);
err = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);
if (err < 0)
return err;
for (i = 0, value = 0; i < link->num_lanes; i++) {
unsigned long lane = SOR_DP_TPG_CHANNEL_CODING |
SOR_DP_TPG_SCRAMBLER_NONE |
SOR_DP_TPG_PATTERN_TRAIN1;
value = (value << 8) | lane;
}
tegra_sor_writel(sor, value, SOR_DP_TPG);
pattern = DP_TRAINING_PATTERN_1;
err = tegra_dpaux_train(sor->dpaux, link, pattern);
if (err < 0)
return err;
value = tegra_sor_readl(sor, SOR_DP_SPARE_0);
value |= SOR_DP_SPARE_SEQ_ENABLE;
value &= ~SOR_DP_SPARE_PANEL_INTERNAL;
value |= SOR_DP_SPARE_MACRO_SOR_CLK;
tegra_sor_writel(sor, value, SOR_DP_SPARE_0);
for (i = 0, value = 0; i < link->num_lanes; i++) {
unsigned long lane = SOR_DP_TPG_CHANNEL_CODING |
SOR_DP_TPG_SCRAMBLER_NONE |
SOR_DP_TPG_PATTERN_TRAIN2;
value = (value << 8) | lane;
}
tegra_sor_writel(sor, value, SOR_DP_TPG);
patt
```
<Overlap Ratio: 0.9779567613395507>

---

--- 128 --
Question ID: d792299f737c1b6f19106a711f2cf3827b4eab3b_1
Original Code:
```
char* get_self_executable_directory()
{
	int rval;
	char link_target[1024];
	char* last_slash;
	size_t result_length;
	char* result;
	/* get program name */
	rval = readlink("/proc/self/exe",link_target,sizeof(link_target));
	if (rval == -1)
		abort();
	else
		link_target[rval] = '\0';
	/* get last '/' */
	last_slash = strrchr(link_target,'/');
	if (last_slash == NULL || last_slash == link_target)
		abort();
	result_length = last_slash - link_target;
	result = (char*)xmalloc(result_length + 1);
	strncpy(result,link_target,result_length);
	result[result_length] = '\0';
	return result;
}
```


Overlapping Code:
```
nt rval;
char link_target[1024];
char* last_slash;
size_t result_length;
char* result;
/* get program name */
rval = readlink("/proc/self/exe",link_target,sizeof(link_target));
if (rval == -1)
abort();
else
link_target[rval] = '\0';
/* get last '/' */
last_slash = strrchr(link_target,'/');
if (last_slash == NULL || last_slash == link_target)
abort();
result_length = last_slash - link_target;
result = (char*)xmalloc(result_length + 1);
strncpy(result,link_target,result_length);
result[result_leng
```
<Overlap Ratio: 0.8787346221441125>

---

--- 129 --
Question ID: 2abd326fe504166fb44429f64f93ae57aadcd94f_1
Original Code:
```
class MenuLayer2 : public CCLayer
{
	public :

		CREATE_FUNC ( MenuLayer2 );

	protected :

		virtual KDbool		init ( KDvoid );

		KDvoid				menuCallback        ( CCObject* pSender );
		KDvoid				menuCallbackOpacity ( CCObject* pSender );
		KDvoid				menuCallbackAlign   ( CCObject* pSender );

		KDvoid				alignMenusH ( KDvoid );
		KDvoid				alignMenusV ( KDvoid );

	protected :

		CCPoint				m_tCenteredMenu;
		KDbool				m_bAlignedH; 
}
```


Overlapping Code:
```
lic :
CREATE_FUNC ( MenuLayer2 );
protected :
virtual KDbool init ( KDvoid );
KDvoid menuCallback ( CCObject* pSender );
KDvoid menuCallbackOpacity ( CCObject* pSender );
KDvoid menuCallbackAlign ( CCObject* pSender );
KDvoid alignMenusH ( KDvoid );
KDvoid alignMenusV ( KDvoid );
protected :
CCPoint
```
<Overlap Ratio: 0.7915567282321899>

---

--- 130 --
Question ID: 54b53744b84b1c82076a9295782044e0936a95a7_4
Original Code:
```
static void
handle_rx_char(char ch)
{
	switch(ch) {
		case 0:
			return;
		case 0x07:	// BEL
			return;
		case 0x0f:	// LTRS
			return;
		case 0x0e:	// FIGS
			return;
	}
	if (log_file != NULL)
		fwrite(&ch, 1, 1, log_file);
	fldigi_add_rx(ch);
}
```


Overlapping Code:
```
ic void
handle_rx_char(char ch)
{
switch(ch) {
case 0:
return;
case 0x07: // BEL
return;
case 0x0f: // LTRS
return;
case 0x0e: // FIGS
return;
}
if (log_file != NULL)
fwrite(&ch, 1, 1, log_file);
fldi
```
<Overlap Ratio: 0.9090909090909091>

---

--- 131 --
Question ID: 595fd4e4d662637c48068d1689c2e5498f906458_22
Original Code:
```
void  test_pavgw_xmm1xmm2()
{
	int foo[4] = { 10, 20, 30, 40 };
	clock_t t1 = clock();
	for (int iterator = 0; iterator < 1000000; iterator++)
	{
		run_pavgw_xmm1xmm2_5_times(foo);
	}
	clock_t t2 = clock();
	for (int iterator = 0; iterator < 1000000; iterator++)
	{
		run_pavgw_xmm1xmm2_105_times(foo);
	}
	clock_t t3 = clock();
	clock_t clk = (t3 - t2) - (t2 - t1);
	std::cout << "pavgw takes " << clk << std::endl;
}
```


Overlapping Code:
```
_xmm1xmm2()
{
int foo[4] = { 10, 20, 30, 40 };
clock_t t1 = clock();
for (int iterator = 0; iterator < 1000000; iterator++)
{
run_pavgw_xmm1xmm2_5_times(foo);
}
clock_t t2 = clock();
for (int iterator = 0; iterator < 1000000; iterator++)
{
run_pavgw_xmm1xmm2_105_times(foo);
}
clock_t t3 = clock();
clock_t clk = (t3 - t2) - (t2 - t1);
std::cout << "pa
```
<Overlap Ratio: 0.8778054862842892>

---

--- 132 --
Question ID: ce75e0481e95ff417ab4d85498e3dbcc7c80f829_0
Original Code:
```
interface IMBookshelfBackgroundView : UIView
{
    UIImageView *_topShelfImageView;	// 8 = 0x8
    struct CGPoint _offset;	// 16 = 0x10
    double _shelfHeight;	// 32 = 0x20
    _Bool _useAlternateSize;	// 40 = 0x28
    IMBookshelfImageGenerator *_imageGenerator;	// 48 = 0x30
    IMLibraryTiledBackgroundView *_shelves;	// 56 = 0x38
    IMBookshelfImageConfiguration *_imageConfiguration;	// 64 = 0x40
    IMLibraryTileView *_topGradientView;	// 72 = 0x48
}
```


Overlapping Code:
```
ndView : UIView
{
UIImageView *_topShelfImageView; // 8 = 0x8
struct CGPoint _offset; // 16 = 0x10
double _shelfHeight; // 32 = 0x20
_Bool _useAlternateSize; // 40 = 0x28
IMBookshelfImageGenerator *_imageGenerator; // 48 = 0x30
IMLibraryTiledBackgroundView *_shelves; // 56 = 0x38
IMBookshelfImageConfiguration *_imageConfiguration; // 64 = 0x40
IMLi
```
<Overlap Ratio: 0.8215962441314554>

---

--- 133 --
Question ID: 99adea3b455e4d978d45150b9835dd540e41a000_14
Original Code:
```
static int set_outfile(char *outfile, char addfile) {
    int flags = O_WRONLY;
    if (addfile == TRUE) {
        flags |= O_APPEND | O_CREAT;
    } else {
        flags |= O_CREAT | O_TRUNC;
    }

    int output;
    output = open(outfile, flags, (mode_t) 0644);
    CHECK_ON_ERROR(output, BAD_RESULT, "Couldn't open output file")

    return use_dup2(output, STDOUT_FILENO, "Couldn't redirect output");
}
```


Overlapping Code:
```
 *outfile, char addfile) {
int flags = O_WRONLY;
if (addfile == TRUE) {
flags |= O_APPEND | O_CREAT;
} else {
flags |= O_CREAT | O_TRUNC;
}
int output;
output = open(outfile, flags, (mode_t) 0644);
CHECK_ON_ERROR(output, BAD_RESULT, "Couldn't open output file")
return use_dup2(output, STDOUT_FILENO,
```
<Overlap Ratio: 0.8379888268156425>

---

--- 134 --
Question ID: d94c67fed9b7ac99fdd48fbbef4055dac9fe7c0c_0
Original Code:
```
interface UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {

	id<UIDocumentPickerDelegate> _weak_delegate;
	BOOL _ignoreApplicationEntitlementForImport;
	BOOL _sourceIsManaged;
	id<UIDocumentPickerDelegate> _delegate;
	unsigned long long _documentPickerMode;
	_UIResilientRemoteViewContainerViewController* _childViewController;
	_UIRemoteViewService* _remoteViewService;
	NSURL* _uploadURL;

}
```


Overlapping Code:
```
e UIDocumentPickerViewController : UIViewController <_UIDocumentPickerRemoteViewControllerContaining> {
id<UIDocumentPickerDelegate> _weak_delegate;
BOOL _ignoreApplicationEntitlementForImport;
BOOL _sourceIsManaged;
id<UIDocumentPickerDelegate> _delegate;
unsigned long long _documentPickerMode;
_UIResilientRemoteViewContainerViewController* _childViewController;
_UIRemoteViewService* _remoteViewService;
```
<Overlap Ratio: 0.9334862385321101>

---

--- 135 --
Question ID: f0f5d657ffbdba29fcd65c553f69f3cf5db3f342_0
Original Code:
```
stack * createstack (){
	stack * new = malloc(sizeof(stack));
	new->top = -1;
	return new;
}
```


Overlapping Code:
```
 malloc(sizeof(stack));
new->top = -1;
return new;
```
<Overlap Ratio: 0.5617977528089888>

---

--- 136 --
Question ID: e6a1cffdd2d94d9d9b7f9e2dcbde1d53970dc202_11
Original Code:
```
void
svn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,
                                 string_table_t **st)
{
  apr_size_t i, k;
  string_table_t *string_table = *st;
  if (string_table == NULL)
    return;

  /* string table struct */
  svn_temp_serializer__push(context,
                            (const void * const *)st,
                            sizeof(*string_table));

  /* sub-table array (all structs in a single memory block) */
  svn_temp_serializer__push(context,
                            (const void * const *)&string_table->sub_tables,
                            sizeof(*string_table->sub_tables) *
                            string_table->size);

  /* sub-elements of all sub-tables */
  for (i = 0; i < string_table->size; ++i)
    {
      string_sub_table_t *sub_table = &string_table->sub_tables[i];
      svn_temp_serializer__add_leaf(context,
                                    (const void * const *)&sub_table->data,
                                    sub_table->data_size);
      svn_temp_serializer__add_leaf(context,
                    (const void * const *)&sub_table->short_strings,
                    sub_table->short_string_count * sizeof(string_header_t));

      /* all "long string" instances form a single memory block */
      svn_temp_serializer__push(context,
                    (const void * const *)&sub_table->long_strings,
                    sub_table->long_string_count * sizeof(svn_string_t));

      /* serialize actual long string contents */
      for (k = 0; k < sub_table->long_string_count; ++k)
        {
          svn_string_t *string = &sub_table->long_strings[k];
          svn_temp_serializer__add_leaf(context,
                                        (const void * const *)&string->data,
                                        string->len + 1);
        }

      svn_temp_serializer__pop(context);
    }

  /* back to the caller's nesting level */
  svn_temp_serializer__pop(context);
  svn_temp_serializer__pop(context);
}
```


Overlapping Code:
```
oid
svn_fs_x__serialize_string_table(svn_temp_serializer__context_t *context,
string_table_t **st)
{
apr_size_t i, k;
string_table_t *string_table = *st;
if (string_table == NULL)
return;
/* string table struct */
svn_temp_serializer__push(context,
(const void * const *)st,
sizeof(*string_table));
/* sub-table array (all structs in a single memory block) */
svn_temp_serializer__push(context,
(const void * const *)&string_table->sub_tables,
sizeof(*string_table->sub_tables) *
string_table->size);
/* sub-elements of all sub-tables */
for (i = 0; i < string_table->size; ++i)
{
string_sub_table_t *sub_table = &string_table->sub_tables[i];
svn_temp_serializer__add_leaf(context,
(const void * const *)&sub_table->data,
sub_table->data_size);
svn_temp_serializer__add_leaf(context,
(const void * const *)&sub_table->short_strings,
sub_table->short_string_count * sizeof(string_header_t));
/* all "long string" instances form a single memory block */
svn_temp_serializer__push(context,
(const void * const *)&sub_table->long_strings,
sub_table->long_string_count * sizeof(svn_string_t));
/* serialize actual long string contents */
for (k = 0; k < sub_table->long_string_count; ++k)
{
svn_string_t *string = &sub_table->long_strings[k];
svn_temp_serializer__add_leaf(context,
(const void * const *)&string->data,
string->len + 1);
}
svn_temp_serializer__pop(context);
}
/* back to the caller's nesting level */
svn_temp_serializer__pop(context);
svn_temp_serializer__pop(context);

```
<Overlap Ratio: 0.9986522911051213>

---

--- 137 --
Question ID: 8998689299fdc270786615c8a2402528f6850ecc_10
Original Code:
```
u32 bq24261_get_minsys_status(void)
{
	u32 ret = 0;
	u8 val = 0;

	ret = bq24261_read_interface((u8) (bq24261_CON5),
				     (&val),
				     (u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIFT)
	    );
	return val;
}
```


Overlapping Code:
```
(void)
{
u32 ret = 0;
u8 val = 0;
ret = bq24261_read_interface((u8) (bq24261_CON5),
(&val),
(u8) (CON5_MINSYS_STATUS_MASK), (u8) (CON5_MINSYS_STATUS_SHIF
```
<Overlap Ratio: 0.7611940298507462>

---

--- 138 --
Question ID: acdea7d84dbadf50e03f33dece646ce6a8cc9293_0
Original Code:
```
class idCompiler
{
private:
	static bool		punctuationValid[ 256 ];
	// RB begin
	static const char*		punctuation[];
	// RB end
	
	idParser		parser;
	idParser*		parserPtr;
	idToken			token;
	
	idTypeDef*		immediateType;
	eval_t			immediate;
	
	bool			eof;
	bool			console;
	bool			callthread;
	int				braceDepth;
	int				loopDepth;
	int				currentLineNumber;
	int				currentFileNumber;
	int				errorCount;
	
	idVarDef*		scope;				// the function being parsed, or NULL
	const idVarDef*	basetype;			// for accessing fields
	
	float			Divide( float numerator, float denominator );
	void			Error( VERIFY_FORMAT_STRING const char* error, ... ) const;
	void			Warning( VERIFY_FORMAT_STRING const char* message, ... ) const;
	idVarDef*		OptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );
	idVarDef*		EmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );
	idVarDef*		EmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );
	bool			EmitPush( idVarDef* expression, const idTypeDef* funcArg );
	void			NextToken();
	void			ExpectToken( const char* string );
	bool			CheckToken( const char* string );
	void			ParseName( idStr& name );
	void			SkipOutOfFunction();
	void			SkipToSemicolon();
	idTypeDef*		CheckType();
	idTypeDef*		ParseType();
	idVarDef*		FindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;
	idVarDef*		GetImmediate( idTypeDef* type, const eval_t* eval, const char* string );
	idVarDef*		VirtualFunctionConstant( idVarDef* func );
	idVarDef*		SizeConstant( int size );
	idVarDef*		JumpConstant( int value );
	idVarDef*		JumpDef( int jumpfrom, int jumpto );
	idVarDef*		JumpTo( int jumpto );
	idVarDef*		JumpFrom( int jumpfrom );
	idVarDef*		ParseImmediate();
	idVarDef*		EmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );
	idVarDef*		ParseFunctionCall( idVarDef* func );
	idVarDef*		ParseObjectCall( idVarDef* object, idVarDef* func );
	idVarDef*		ParseEventCall( idVarDef* object, idVarDef* func );
	idVarDef*		ParseSysObjectCall( idVarDef* func );
	idVarDef*		LookupDef( const char* name, const idVarDef* baseobj );
	idVarDef*		ParseValue();
	idVarDef*		GetTerm();
	bool			TypeMatches( etype_t type1, etype_t type2 ) const;
	idVarDef*		GetExpression( int priority );
	idTypeDef*		GetTypeForEventArg( char argType );
	void			PatchLoop( int start, int continuePos );
	void			ParseReturnStatement();
	void			ParseWhileStatement();
	void			ParseForStatement();
	void			ParseDoWhileStatement();
	void			ParseIfStatement();
	void			ParseStatement();
	void			ParseObjectDef( const char* objname );
	idTypeDef*		ParseFunction( idTypeDef* returnType, const char* name );
	void			ParseFunctionDef( idTypeDef* returnType, const char* name );
	void			ParseVariableDef( idTypeDef* type, const char* name );
	void			ParseEventDef( idTypeDef* type, const char* name );
	void			ParseDefs();
	void			ParseNamespace( idVarDef* newScope );
	
public :
	// RB: added const
	static const opcode_t	opcodes[];
	// RB end
	
	idCompiler();
	void			CompileFile( const char* text, const char* filename, bool console );
}
```


Overlapping Code:
```
ass idCompiler
{
private:
static bool punctuationValid[ 256 ];
// RB begin
static const char* punctuation[];
// RB end

idParser parser;
idParser* parserPtr;
idToken token;

idTypeDef* immediateType;
eval_t immediate;

bool eof;
bool console;
bool callthread;
int braceDepth;
int loopDepth;
int currentLineNumber;
int currentFileNumber;
int errorCount;

idVarDef* scope; // the function being parsed, or NULL
const idVarDef* basetype; // for accessing fields

float Divide( float numerator, float denominator );
void Error( VERIFY_FORMAT_STRING const char* error, ... ) const;
void Warning( VERIFY_FORMAT_STRING const char* message, ... ) const;
idVarDef* OptimizeOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );
idVarDef* EmitOpcode( const opcode_t* op, idVarDef* var_a, idVarDef* var_b );
idVarDef* EmitOpcode( int op, idVarDef* var_a, idVarDef* var_b );
bool EmitPush( idVarDef* expression, const idTypeDef* funcArg );
void NextToken();
void ExpectToken( const char* string );
bool CheckToken( const char* string );
void ParseName( idStr& name );
void SkipOutOfFunction();
void SkipToSemicolon();
idTypeDef* CheckType();
idTypeDef* ParseType();
idVarDef* FindImmediate( const idTypeDef* type, const eval_t* eval, const char* string ) const;
idVarDef* GetImmediate( idTypeDef* type, const eval_t* eval, const char* string );
idVarDef* VirtualFunctionConstant( idVarDef* func );
idVarDef* SizeConstant( int size );
idVarDef* JumpConstant( int value );
idVarDef* JumpDef( int jumpfrom, int jumpto );
idVarDef* JumpTo( int jumpto );
idVarDef* JumpFrom( int jumpfrom );
idVarDef* ParseImmediate();
idVarDef* EmitFunctionParms( int op, idVarDef* func, int startarg, int startsize, idVarDef* object );
idVarDef* ParseFunctionCall( idVarDef* func );
idVarDef* ParseObjectCall( idVarDef* object, idVarDef* func );
idVarDef* ParseEventCall( idVarDef* object, idVarDef* func );
idVarDef* ParseSysObjectCall( idVarDef* func );
idVarDef* LookupDef( const char* name, const idVarDef* baseobj );
idVarDef* ParseValue();
idVarDef* GetTerm();
bool TypeMatches( etype_t type1, etype_t type2 ) const;
idVarDef* GetExpression( int priority );
idTypeDef* GetTypeForEventArg( char argType );
void PatchLoop( int start, int continuePos );
void ParseReturnStatement();
void ParseWhileStatement();
void Pars
```
<Overlap Ratio: 0.9816474605207>

---

--- 139 --
Question ID: 8c898955d4ab7621c3ef57b0340db119fe3ec01e_0
Original Code:
```
namespace mlperf {

/// \addtogroup LoadgenAPI
/// @{

/// \brief Represents a unique identifier for a sample of an issued query.
/// \details As currently implemented, the id is a pointer to an internal
/// loadgen struct.
typedef uintptr_t ResponseId;

/// \brief An index into the QuerySampleLibrary corresponding to a
/// single sample.
typedef size_t QuerySampleIndex;

/// \brief Represents the smallest unit of input inference can run on.
/// A query consists of one or more samples.
struct QuerySample {
  ResponseId id;
  QuerySampleIndex index;
};

/// \brief Represents a single response to QuerySample
struct QuerySampleResponse {
  ResponseId id;
  uintptr_t data;
  size_t size;  ///< Size in bytes.
};

/// \brief A latency in nanoseconds, as recorded by the loadgen.
typedef int64_t QuerySampleLatency;

/// @}

}
```


Overlapping Code:
```
ce mlperf {
/// \addtogroup LoadgenAPI
/// @{
/// \brief Represents a unique identifier for a sample of an issued query.
/// \details As currently implemented, the id is a pointer to an internal
/// loadgen struct.
typedef uintptr_t ResponseId;
/// \brief An index into the QuerySampleLibrary corresponding to a
/// single sample.
typedef size_t QuerySampleIndex;
/// \brief Represents the smallest unit of input inference can run on.
/// A query consists of one or more samples.
struct QuerySample {
ResponseId id;
QuerySampleIndex index;
};
/// \brief Represents a single response to QuerySample
struct QuerySampleResponse {
ResponseId id;
uintptr_t data;
size_t size; ///< Size in bytes.
};
/// \brief A latency in nanoseconds, as recorded by the loadgen.
typedef in
```
<Overlap Ratio: 0.9493827160493827>

---

--- 140 --
Question ID: 925706c7558daa5e3c4c508659d201d0ddf3885a_1
Original Code:
```
const struct exec_info *get_exec_info(const struct exec_info *exec_infos,
				      const char *arg0)
{
	const char *name = path_base(arg0);
	const struct exec_info *ret = NULL;

	for (size_t i = 0; exec_infos[i].name != NULL; ++i) {
		// Exact matches always come first
		if (strcmp(name, exec_infos[i].name) == 0)
			return &exec_infos[i];

		// Fallback to {exe}.{type} matching
		const size_t name_len = strlen(name);
		if (name_len > strlen(exec_infos[i].name))
			continue;
		if (exec_infos[i].name[name_len] != '.')
			continue;
		if (strncmp(name, exec_infos[i].name, name_len) != 0)
			continue;
		if (ret == NULL || ret->prefer < exec_infos[i].prefer)
			ret = &exec_infos[i];
	}

	return ret;
}
```


Overlapping Code:
```
xec_info *get_exec_info(const struct exec_info *exec_infos,
const char *arg0)
{
const char *name = path_base(arg0);
const struct exec_info *ret = NULL;
for (size_t i = 0; exec_infos[i].name != NULL; ++i) {
// Exact matches always come first
if (strcmp(name, exec_infos[i].name) == 0)
return &exec_infos[i];
// Fallback to {exe}.{type} matching
const size_t name_len = strlen(name);
if (name_len > strlen(exec_infos[i].name))
continue;
if (exec_infos[i].name[name_len] != '.')
continue;
if (strncmp(name, exec_infos[i].name, name_len) != 0)
continue;
if (ret == NULL || ret->prefer < exec_infos[i].pre
```
<Overlap Ratio: 0.9146341463414634>

---

--- 141 --
Question ID: be2bfb86925c9e0e8c5d6ce8f63fe00a5e074c4b_161
Original Code:
```
SWIGINTERN PyObject *_wrap_gsl_matrix_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "IN", NULL 
  };
  double result;
  
  
  PyArrayObject * _PyMatrix1 = NULL;
  TYPE_VIEW_gsl_matrix_long _matrix1;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:gsl_matrix_long_min",kwnames,&obj0)) SWIG_fail;
  
  {
    PyGSL_array_index_t stride;
    if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,
        PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)
    goto fail;	  
  }
  
  result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);
  resultobj = SWIG_From_double((double)(result));
  {
    Py_XDECREF(_PyMatrix1);
    _PyMatrix1 = NULL;
    FUNC_MESS_END();
  }
  return resultobj;
fail:
  {
    Py_XDECREF(_PyMatrix1);
    _PyMatrix1 = NULL;
    FUNC_MESS_END();
  }
  return NULL;
}
```


Overlapping Code:
```
_long_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
PyObject *resultobj = 0;
gsl_matrix_long *arg1 = (gsl_matrix_long *) 0 ;
PyObject * obj0 = 0 ;
char * kwnames[] = {
(char *) "IN", NULL 
};
double result;


PyArrayObject * _PyMatrix1 = NULL;
TYPE_VIEW_gsl_matrix_long _matrix1;

if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:gsl_matrix_long_min",kwnames,&obj0)) SWIG_fail;

{
PyGSL_array_index_t stride;
if(PyGSL_MATRIX_CONVERT(obj0, arg1, _PyMatrix1, _matrix1,
PyGSL_INPUT_ARRAY, gsl_matrix_long, 1, &stride) != GSL_SUCCESS)
goto fail; 
}

result = (double)gsl_matrix_long_min((gsl_matrix_long const *)arg1);
resultobj = SWIG_From_double((double)(result));
{
Py_XDECREF(_PyMatrix1);
_PyMatrix1 = NULL;
FUNC_MESS_END();
}
return resultobj;
fail:
{
Py_XDECREF(_PyMatrix1);
_PyMatrix1 = NULL;
FUNC_MESS_END();
}
return NULL;
}
```
<Overlap Ratio: 0.9588431590656284>

---

--- 142 --
Question ID: ced9697a9812676ec762fc4fd38d0b7764fd006e_9
Original Code:
```
SSH_PACKET_CALLBACK(channel_rcv_eof) {
  ssh_channel channel;
  (void)user;
  (void)type;

  channel = channel_from_msg(session,packet);
  if (channel == NULL) {
    SSH_LOG(SSH_LOG_FUNCTIONS, "%s", ssh_get_error(session));

    return SSH_PACKET_USED;
  }

  SSH_LOG(SSH_LOG_PACKET,
      "Received eof on channel (%d:%d)",
      channel->local_channel,
      channel->remote_channel);
  /* channel->remote_window = 0; */
  channel->remote_eof = 1;

  if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {
      channel->callbacks->channel_eof_function(channel->session,
                                               channel,
                                               channel->callbacks->userdata);
  }

  return SSH_PACKET_USED;
}
```


Overlapping Code:
```
H_PACKET_CALLBACK(channel_rcv_eof) {
ssh_channel channel;
(void)user;
(void)type;
channel = channel_from_msg(session,packet);
if (channel == NULL) {
SSH_LOG(SSH_LOG_FUNCTIONS, "%s", ssh_get_error(session));
return SSH_PACKET_USED;
}
SSH_LOG(SSH_LOG_PACKET,
"Received eof on channel (%d:%d)",
channel->local_channel,
channel->remote_channel);
/* channel->remote_window = 0; */
channel->remote_eof = 1;
if(ssh_callbacks_exists(channel->callbacks, channel_eof_function)) {
channel->callbacks->channel_eof_function(channel->session,
channel,
channel->callbacks->userdata);
}
return SSH_PACKET_USED;
```
<Overlap Ratio: 0.9933110367892977>

---

--- 143 --
Question ID: a51cb20e5631590d58e66e9be1161734fde421e2_33
Original Code:
```
int
xenDaemonDomainPinVcpu(virConnectPtr conn,
                       virDomainDefPtr minidef,
                       unsigned int vcpu,
                       unsigned char *cpumap,
                       int maplen)
{
    char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];
    size_t i, j;
    int ret;
    xenUnifiedPrivatePtr priv = conn->privateData;
    virDomainDefPtr def = NULL;

    if (maplen > (int)sizeof(cpumap_t)) {
        virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);
        return -1;
    }

    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {
        mapstr[0] = '[';
        mapstr[1] = 0;
    } else {
        mapstr[0] = 0;
    }

    /* from bit map, build character string of mapped CPU numbers */
    for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)
     if (cpumap[i] & (1 << j)) {
        snprintf(buf, sizeof(buf), "%zu,", (8 * i) + j);
        strcat(mapstr, buf);
    }
    if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)
        mapstr[strlen(mapstr) - 1] = ']';
    else
        mapstr[strlen(mapstr) - 1] = 0;

    snprintf(buf, sizeof(buf), "%d", vcpu);

    ret = xend_op(conn, minidef->name, "op", "pincpu", "vcpu", buf,
                  "cpumap", mapstr, NULL);

    if (!(def = xenDaemonDomainFetch(conn,
                                     minidef->id,
                                     minidef->name,
                                     NULL)))
        goto cleanup;

    if (ret == 0) {
        if (!def->cputune.vcpupin) {
            if (VIR_ALLOC(def->cputune.vcpupin) < 0)
                goto cleanup;
            def->cputune.nvcpupin = 0;
        }
        if (virDomainVcpuPinAdd(&def->cputune.vcpupin,
                                &def->cputune.nvcpupin,
                                cpumap,
                                maplen,
                                vcpu) < 0) {
            virReportError(VIR_ERR_INTERNAL_ERROR,
                           "%s", _("failed to add vcpupin xml entry"));
            return -1;
        }
    }

    return ret;

 cleanup:
    virDomainDefFree(def);
    return -1;
}
```


Overlapping Code:
```
nDomainPinVcpu(virConnectPtr conn,
virDomainDefPtr minidef,
unsigned int vcpu,
unsigned char *cpumap,
int maplen)
{
char buf[VIR_UUID_BUFLEN], mapstr[sizeof(cpumap_t) * 64];
size_t i, j;
int ret;
xenUnifiedPrivatePtr priv = conn->privateData;
virDomainDefPtr def = NULL;
if (maplen > (int)sizeof(cpumap_t)) {
virReportError(VIR_ERR_INVALID_ARG, __FUNCTION__);
return -1;
}
if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4) {
mapstr[0] = '[';
mapstr[1] = 0;
} else {
mapstr[0] = 0;
}
/* from bit map, build character string of mapped CPU numbers */
for (i = 0; i < maplen; i++) for (j = 0; j < 8; j++)
if (cpumap[i] & (1 << j)) {
snprintf(buf, sizeof(buf), "%zu,", (8 * i) + j);
strcat(mapstr, buf);
}
if (priv->xendConfigVersion < XEND_CONFIG_VERSION_3_0_4)
mapstr[strlen(mapstr) - 1] = ']';
else
mapstr[strlen(mapstr) - 1] = 0;
snprintf(buf, sizeof(buf), "%d", vcpu);
ret = xend_op(conn, minidef->name, "op", "pincpu", "vcpu", buf,
"cpumap", mapstr, NULL);
if (!(def = xenDaemonDomainFetch(conn,
minidef->id,
minidef->name,
NULL)))
goto cleanup;
if (ret == 0) {
if (!def->cputune.vcpupin) {
if (VIR_ALLOC(def->cputune.vcpupin) < 0)
goto cleanup;
def->cputune.nvcpupin = 0;
}
if (virDomainVcpuPinAdd(&def->cputune.vcpupin,
&def->cputune.nvcpupin,
cpumap,
maplen,
vcpu) < 0) {
virReportError(VIR_ERR_INTERNAL_ERROR,
"%s", _("failed to add vcpupin xml entry"));
return -1;
}
}
return ret;
cleanu
```
<Overlap Ratio: 0.9655172413793104>

---

--- 144 --
Question ID: ca8ce3141cd6ceacd8760b28d4149c04f8e5519c_22
Original Code:
```
void FactVarSlotErrorMessage2(
  Environment *theEnv,
  Fact *theFact,
  const char *varSlot)
  {
   char tempBuffer[20];
   
   PrintErrorID(theEnv,"PRNTUTIL",13,false);
   
   WriteString(theEnv,STDERR,"The variable/slot reference ?");
   WriteString(theEnv,STDERR,varSlot);
   WriteString(theEnv,STDERR," is invalid because the referenced fact ");
   gensprintf(tempBuffer,"f-%lld",theFact->factIndex);
   WriteString(theEnv,STDERR,tempBuffer);
   WriteString(theEnv,STDERR," does not contain the specified slot.\n");
  }
```


Overlapping Code:
```
(
Environment *theEnv,
Fact *theFact,
const char *varSlot)
{
char tempBuffer[20];

PrintErrorID(theEnv,"PRNTUTIL",13,false);

WriteString(theEnv,STDERR,"The variable/slot reference ?");
WriteString(theEnv,STDERR,varSlot);
WriteString(theEnv,STDERR," is invalid because the referenced fact ");
gensprintf(tempBuffer,"f-%lld",theFact->factIndex);
WriteString(theEnv,STDERR,tempBuffer);
WriteString(theEnv,STDERR," does not contain the specified slot.\n"
```
<Overlap Ratio: 0.9318181818181818>

---

--- 145 --
Question ID: cd850e652da89f9db13c39af1ce0189f9fbdba9c_10
Original Code:
```
int DrawFrame(const VulkanDevice *device, float dt)
{
   VkRect2D backBufferRect = {
      .offset = {
         .x = 0,
         .y = 0,
      },
      .extent = {
         .width = device->surfaceWidth,
         .height = device->surfaceHeight,
      },
   };

   uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);
   VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));
   VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));

   VkFence nullFence = VK_NULL_HANDLE;
   uint32_t imageIdx;
   VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,
      device->frames[curFrame].imageAcquired, nullFence, &imageIdx);
   if (result == VK_ERROR_OUT_OF_DATE_KHR) {
      return 0;
   }
   ASSERT(result == VK_SUCCESS);

   VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;

   VkCommandBufferBeginInfo beginInfo = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
      .pNext = NULL,
      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
      .pInheritanceInfo = NULL,
   };

   VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));

   VkClearValue clearValue = {
      .color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },
   };
   VkRenderPassBeginInfo passInfo = {
      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
      .pNext = NULL,
      .renderPass = s_resources.renderPass,
      .framebuffer = s_resources.framebuffers[imageIdx].framebuffer,
      .renderArea = backBufferRect,
      .clearValueCount = 1,
      .pClearValues = &clearValue,
   };
   device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);

   device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);

   s_cubeRot += dt * CUBE_SPIN_SPEED;
   s_cubeRot -= floorf(s_cubeRot);

   ShaderMatrices matrices;
   Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;
   mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));

   Vec3 eye = { 0.0f, 1.5f, -3.0f };
   Vec3 target = { 0.0f, 0.0f, 0.0f };
   Vec3 up = { 0.0f, 1.0f, 0.0f };
   mat4LookAt(&viewFromWorld, eye, target, up);
   mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);

   mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);
   mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLocal);

   device->vkCmdPushConstants(commandBuffer, s_resources.pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(matrices), &matrices);

   device->vkCmdDraw(commandBuffer, 36, 1, 0, 0);

   device->vkCmdEndRenderPass(commandBuffer);
   VK_VERIFY(device->vkEndCommandBuffer(commandBuffer));

   VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
   VkSubmitInfo submitInfo = {
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
      .pNext = NULL,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &device->frames[curFrame].imageAcquired,
      .pWaitDstStageMask = &stageFlags,
      .commandBufferCount = 1,
      .pCommandBuffers = &commandBuffer,
      .signalSemaphoreCount = 1,
      .pSignalSemaphores = &device->frames[curFrame].drawComplete,
   };

   VK_VERIFY(device->vkQueueSubmit(device->queue, 1, &submitInfo, device->frames[curFrame].frameComplete));

   VkResult presentResult;
   VkPresentInfoKHR presentInfo = { 
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .pNext = NULL,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores = &device->frames[curFrame].drawComplete,
      .swapchainCount = 1,
      .pSwapchains = &device->swapchain,
      .pImageIndices = &imageIdx,
      .pResults = &presentResult,
   };

   VK_VERIFY(device->vkQueuePresentKHR(device->queue, &presentInfo));
   VK_VERIFY(presentResult);

   return 1;
}
```


Overlapping Code:
```
ice, float dt)
{
VkRect2D backBufferRect = {
.offset = {
.x = 0,
.y = 0,
},
.extent = {
.width = device->surfaceWidth,
.height = device->surfaceHeight,
},
};
uint32_t curFrame = s_frameNum++ % ARRAY_COUNT(device->frames);
VK_VERIFY(device->vkWaitForFences(device->device, 1, &device->frames[curFrame].frameComplete, VK_TRUE, UINT64_MAX));
VK_VERIFY(device->vkResetFences(device->device, 1, &device->frames[curFrame].frameComplete));
VkFence nullFence = VK_NULL_HANDLE;
uint32_t imageIdx;
VkResult result = device->vkAcquireNextImageKHR(device->device, device->swapchain, UINT64_MAX,
device->frames[curFrame].imageAcquired, nullFence, &imageIdx);
if (result == VK_ERROR_OUT_OF_DATE_KHR) {
return 0;
}
ASSERT(result == VK_SUCCESS);
VkCommandBuffer commandBuffer = device->frames[curFrame].commandBuffer;
VkCommandBufferBeginInfo beginInfo = {
.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
.pNext = NULL,
.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
.pInheritanceInfo = NULL,
};
VK_VERIFY(device->vkBeginCommandBuffer(commandBuffer, &beginInfo));
VkClearValue clearValue = {
.color.float32 = { 0.086f, 0.086f, 0.1137f, 1.0f, },
};
VkRenderPassBeginInfo passInfo = {
.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
.pNext = NULL,
.renderPass = s_resources.renderPass,
.framebuffer = s_resources.framebuffers[imageIdx].framebuffer,
.renderArea = backBufferRect,
.clearValueCount = 1,
.pClearValues = &clearValue,
};
device->vkCmdBeginRenderPass(commandBuffer, &passInfo, VK_SUBPASS_CONTENTS_INLINE);
device->vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, s_resources.pipeline);
s_cubeRot += dt * CUBE_SPIN_SPEED;
s_cubeRot -= floorf(s_cubeRot);
ShaderMatrices matrices;
Mat4 worldFromLocal, viewFromWorld, viewFromLocal, clipFromView;
mat4RotY(&worldFromLocal, s_cubeRot * (2.0f * PI));
Vec3 eye = { 0.0f, 1.5f, -3.0f };
Vec3 target = { 0.0f, 0.0f, 0.0f };
Vec3 up = { 0.0f, 1.0f, 0.0f };
mat4LookAt(&viewFromWorld, eye, target, up);
mat4Mul(&viewFromLocal, &viewFromWorld, &worldFromLocal);
mat4PerspectiveFov(&clipFromView, PI / 2.0f, device->surfaceWidth / (float)device->surfaceHeight, 1.0f, 100.0f);
mat4Mul(&matrices.clipFromLocal, &clipFromView, &viewFromLoca
```
<Overlap Ratio: 0.9821428571428571>

---

--- 146 --
Question ID: f6a0693d54ba910af58c43c633f4acfb62ca837f_41
Original Code:
```
struct hedvtx *getVertex (struct hedron *hed, long number) {
	struct hedvtx *vtx = NULL;
	long idx = 0;
	idx = number - 1;
	if (idx < 0) return (NULL);
	if (idx >= hed -> maxvtx) return (NULL);
	vtx = *(hed -> vertices + idx);
	return (vtx);
}
```


Overlapping Code:
```
 long number) {
struct hedvtx *vtx = NULL;
long idx = 0;
idx = number - 1;
if (idx < 0) return (NULL);
if (idx >= hed -> maxvtx) return (NULL);
vtx = 
```
<Overlap Ratio: 0.635593220338983>

---

--- 147 --
Question ID: 5a6331acc75a41db4102022dbe2ae9259f3a8633_5
Original Code:
```
PUBLIC int process_ksig(endpoint_t proc_nr_e, int signo)
{
  register struct mproc *rmp;
  int proc_nr;
  pid_t proc_id, id;

  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {
	printf("PM: process_ksig: %d?? not ok\n", proc_nr_e);
	return EDEADSRCDST; /* process is gone. */
  }
  rmp = &mproc[proc_nr];
  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {
#if 0
	printf("PM: process_ksig: %d?? exiting / not in use\n", proc_nr_e);
#endif
	return EDEADSRCDST; /* process is gone. */
  }
  proc_id = rmp->mp_pid;
  mp = &mproc[0];			/* pretend signals are from PM */
  mp->mp_procgrp = rmp->mp_procgrp;	/* get process group right */

  /* For SIGVTALRM and SIGPROF, see if we need to restart a
   * virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0
   * to indicate a broadcast to the recipient's process group.  For
   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.
   */
  switch (signo) {
      case SIGINT:
      case SIGQUIT:
      case SIGWINCH:
  	id = 0; break;	/* broadcast to process group */
      case SIGVTALRM:
      case SIGPROF:
      	check_vtimer(proc_nr, signo);
      	/* fall-through */
      default:
  	id = proc_id;
  	break;
  }
  check_sig(id, signo, TRUE /* ksig */);

  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was
   * still sending, and the kernel hereby tells us that the process is now done
   * with that. We can now try to resume what we planned to do in the first
   * place: set up a signal handler. However, the process's message may have
   * been a call to PM, in which case the process may have changed any of its
   * signal settings. The process may also have forked, exited etcetera.
   */
  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {
	rmp->mp_flags &= ~DELAY_CALL;

	/*
	 * If the FS_CALL flag is still set we have a process which is stopped
	 * and we only need to wait for a reply from VFS. We are going to check
	 * the pending signal then
	 */
	if (rmp->mp_flags & FS_CALL)
		return OK;
	if (rmp->mp_flags & PM_SIG_PENDING)
		panic("process_ksig: bad process state");

	/* Process as many normal signals as possible. */
	check_pending(rmp);

	if (rmp->mp_flags & DELAY_CALL)
		panic("process_ksig: multiple delay calls?");
  }
  
  /* See if the process is still alive */
  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {
      return OK; /* signal has been delivered */
  }
  else {
      return EDEADSRCDST; /* process is gone */
  }
}
```


Overlapping Code:
```
_t proc_nr_e, int signo)
{
register struct mproc *rmp;
int proc_nr;
pid_t proc_id, id;
if(pm_isokendpt(proc_nr_e, &proc_nr) != OK || proc_nr < 0) {
printf("PM: process_ksig: %d?? not ok\n", proc_nr_e);
return EDEADSRCDST; /* process is gone. */
}
rmp = &mproc[proc_nr];
if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {
#if 0
printf("PM: process_ksig: %d?? exiting / not in use\n", proc_nr_e);
#endif
return EDEADSRCDST; /* process is gone. */
}
proc_id = rmp->mp_pid;
mp = &mproc[0]; /* pretend signals are from PM */
mp->mp_procgrp = rmp->mp_procgrp; /* get process group right */
/* For SIGVTALRM and SIGPROF, see if we need to restart a
* virtual timer. For SIGINT, SIGWINCH and SIGQUIT, use proc_id 0
* to indicate a broadcast to the recipient's process group. For
* SIGKILL, use proc_id -1 to indicate a systemwide broadcast.
*/
switch (signo) {
case SIGINT:
case SIGQUIT:
case SIGWINCH:
id = 0; break; /* broadcast to process group */
case SIGVTALRM:
case SIGPROF:
check_vtimer(proc_nr, signo);
/* fall-through */
default:
id = proc_id;
break;
}
check_sig(id, signo, TRUE /* ksig */);
/* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was
* still sending, and the kernel hereby tells us that the process is now done
* with that. We can now try to resume what we planned to do in the first
* place: set up a signal handler. However, the process's message may have
* been a call to PM, in which case the process may have changed any of its
* signal settings. The process may also have forked, exited etcetera.
*/
if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {
rmp->mp_flags &= ~DELAY_CALL;
/*
* If the FS_CALL flag is still set we have a process which is stopped
* and we only need to wait for a reply from VFS. We are going to check
* the pending signal then
*/
if (rmp->mp_flags & FS_CALL)
return OK;
if (rmp->mp_flags & PM_SIG_PENDING)
panic("process_ksig: bad process state");
/* Process as many normal signals as possible. */
check_pending(rmp);
if (rmp->mp_flags & DELAY_CALL)
panic("process_ksig: multiple delay calls?");
}

/* See if the process is still alive */
if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE) {
return OK; /* signal has b
```
<Overlap Ratio: 0.9787139689578714>

---

--- 148 --
Question ID: 9e364f9e4de2f93c694cae0b58beb6f8f68c3d8a_49
Original Code:
```
static int
bce_init_tx_chain(struct bce_tx_ring *txr)
{
	struct tx_bd *txbd;
	int i, rc = 0;

	/* Set the initial TX producer/consumer indices. */
	txr->tx_prod = 0;
	txr->tx_cons = 0;
	txr->tx_prod_bseq = 0;
	txr->used_tx_bd = 0;
	txr->max_tx_bd = USABLE_TX_BD(txr);

	/*
	 * The NetXtreme II supports a linked-list structre called
	 * a Buffer Descriptor Chain (or BD chain).  A BD chain
	 * consists of a series of 1 or more chain pages, each of which
	 * consists of a fixed number of BD entries.
	 * The last BD entry on each page is a pointer to the next page
	 * in the chain, and the last pointer in the BD chain
	 * points back to the beginning of the chain.
	 */

	/* Set the TX next pointer chain entries. */
	for (i = 0; i < txr->tx_pages; i++) {
		int j;

		txbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];

		/* Check if we've reached the last page. */
		if (i == (txr->tx_pages - 1))
			j = 0;
		else
			j = i + 1;

		txbd->tx_bd_haddr_hi =
		    htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));
		txbd->tx_bd_haddr_lo =
		    htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j]));
	}
	bce_init_tx_context(txr);

	return(rc);
}
```


Overlapping Code:
```
chain(struct bce_tx_ring *txr)
{
struct tx_bd *txbd;
int i, rc = 0;
/* Set the initial TX producer/consumer indices. */
txr->tx_prod = 0;
txr->tx_cons = 0;
txr->tx_prod_bseq = 0;
txr->used_tx_bd = 0;
txr->max_tx_bd = USABLE_TX_BD(txr);
/*
* The NetXtreme II supports a linked-list structre called
* a Buffer Descriptor Chain (or BD chain). A BD chain
* consists of a series of 1 or more chain pages, each of which
* consists of a fixed number of BD entries.
* The last BD entry on each page is a pointer to the next page
* in the chain, and the last pointer in the BD chain
* points back to the beginning of the chain.
*/
/* Set the TX next pointer chain entries. */
for (i = 0; i < txr->tx_pages; i++) {
int j;
txbd = &txr->tx_bd_chain[i][USABLE_TX_BD_PER_PAGE];
/* Check if we've reached the last page. */
if (i == (txr->tx_pages - 1))
j = 0;
else
j = i + 1;
txbd->tx_bd_haddr_hi =
htole32(BCE_ADDR_HI(txr->tx_bd_chain_paddr[j]));
txbd->tx_bd_haddr_lo =
htole32(BCE_ADDR_LO(txr->tx_bd_chain_paddr[j
```
<Overlap Ratio: 0.9354536950420954>

---

--- 149 --
Question ID: 2fcdb078fe71a8925f78b63496c09123444f8888_5
Original Code:
```
int crypto_hash(unsigned char *hashval,
		const unsigned char *data,
		unsigned long long databytelen)
{
  uint8_t state[SIZE512];
  uint8_t message_block[SIZE512];
  uint32_t i, j, w;
  uint32_t bytes_remaining;
  uint64_t full_message_blocks = databytelen/64;



  //Setting initial state
  for(i=0;i<(SIZE512/sizeof(uint32_t));i++)
  {
    ((uint32_t*)state)[i] = 0;
  }

  //256BIT_HASH_SPECIFIC line
  state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!

  while(full_message_blocks--)
  {
    for (i = 0; i < SIZE512; i++) {
      message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
  }
		
  P((uint32_t*)state, (uint32_t*)message_block);

  for (i = 0; i < SIZE512; i++) {
    message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
  }
  Q((uint32_t*)state, (uint32_t*)message_block);
    data += SIZE512;
  }
	

	//Padding
  bytes_remaining = ((uint32_t)databytelen)%64;
  if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)
  {
    for(j=0;j<2;j++)
    {  
      for(i=0;i<bytes_remaining;i++)
      {
    	  message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
      }    	
    	//setting padding bit 1
  
  		message_block[(i%8)*8+i/8] = 0x80;
      i++;
      for(;i<SIZE512;i++)
      {
        message_block[(i%8)*8+i/8] = 0;
      }

      if(j==0)
      {
        P((uint32_t*)state, (uint32_t*)message_block);
      }
      else
      {
        Q((uint32_t*)state, (uint32_t*)message_block);
      }
    }
  }

  w = (-((uint32_t)8*databytelen)-65)&0x1FF;
  databytelen = (8*databytelen+w+65)/(SIZE512*8);
  

  for(j=0;j<2;j++)     //j is 2 at this moment
  {
    i=0;
    if(bytes_remaining <= (SIZE512-64/8-1))
    {
      for(;i<bytes_remaining;i++)
      {
    	message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
	  }
      message_block[(i%8)*8+i/8] = 0x80;
      i++;
    }

    for(;i<(SIZE512-(64/8));i++)
  	{
  	  message_block[(i%8)*8+i/8] = 0;
  	}

    full_message_blocks = databytelen; //temp copy of padding value
    for(i=SIZE512-1;i>=(SIZE512-64/8);i--)
    {
      message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;
      full_message_blocks >>= 8;
    }

    if(j==0)
    {
      P((uint32_t*)state, (uint32_t*)message_block);
    }
    else
    {
      Q((uint32_t*)state, (uint32_t*)message_block);
    }
  }

  for (i = 0; i < SIZE512/sizeof(uint32_t); i++) {
    ((uint32_t*)message_block)[i] = ((uint32_t*)state)[i];
  }

  w = 0;     //round constant
  

  for(i=0;i<10;i++)
  {
  	RND512P((uint32_t*)state, w);
  	w += 0x01010101;
  }

  for (i = 0; i < 2*COLS512; i++) {
    ((uint32_t*)state)[i] ^= ((uint32_t*)message_block)[i];
  }

  for (i = SIZE512-HASH_BIT_LEN/8; i < SIZE512; i++) {
    hashval[i-(SIZE512-HASH_BIT_LEN/8)] = state[(i%8)*8+i/8]; //zeilenweise speichern
  }


  return 0;
}
```


Overlapping Code:
```
o_hash(unsigned char *hashval,
const unsigned char *data,
unsigned long long databytelen)
{
uint8_t state[SIZE512];
uint8_t message_block[SIZE512];
uint32_t i, j, w;
uint32_t bytes_remaining;
uint64_t full_message_blocks = databytelen/64;
//Setting initial state
for(i=0;i<(SIZE512/sizeof(uint32_t));i++)
{
((uint32_t*)state)[i] = 0;
}
//256BIT_HASH_SPECIFIC line
state[55] = 1; //Initial value for hash length 256 bit when saving state in row order!
while(full_message_blocks--)
{
for (i = 0; i < SIZE512; i++) {
message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
}

P((uint32_t*)state, (uint32_t*)message_block);
for (i = 0; i < SIZE512; i++) {
message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
}
Q((uint32_t*)state, (uint32_t*)message_block);
data += SIZE512;
}

//Padding
bytes_remaining = ((uint32_t)databytelen)%64;
if(bytes_remaining > (SIZE512-64/8-1)) //if only one padding block is needed (64 bit w + 1 byte for appending bit 1)
{
for(j=0;j<2;j++)
{ 
for(i=0;i<bytes_remaining;i++)
{
message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
} 
//setting padding bit 1

message_block[(i%8)*8+i/8] = 0x80;
i++;
for(;i<SIZE512;i++)
{
message_block[(i%8)*8+i/8] = 0;
}
if(j==0)
{
P((uint32_t*)state, (uint32_t*)message_block);
}
else
{
Q((uint32_t*)state, (uint32_t*)message_block);
}
}
}
w = (-((uint32_t)8*databytelen)-65)&0x1FF;
databytelen = (8*databytelen+w+65)/(SIZE512*8);

for(j=0;j<2;j++) //j is 2 at this moment
{
i=0;
if(bytes_remaining <= (SIZE512-64/8-1))
{
for(;i<bytes_remaining;i++)
{
message_block[(i%8)*8+i/8] = data[i]; //zeilenweise speichern
}
message_block[(i%8)*8+i/8] = 0x80;
i++;
}
for(;i<(SIZE512-(64/8));i++)
{
message_block[(i%8)*8+i/8] = 0;
}
full_message_blocks = databytelen; //temp copy of padding value
for(i=SIZE512-1;i>=(SIZE512-64/8);i--)
{
message_block[(i%8)*8+i/8] = (uint8_t)full_message_blocks;
full_message_blocks >>= 8;
}
if(j==0)
{
P((uint32_t*)state, (uint32_t*)message_block);
}
else
{
Q((uint32_t*)state, (uint32_t*)mes
```
<Overlap Ratio: 0.9876543209876543>

---

--- 150 --
Question ID: 9681a7cb7e4eef11575b3e6e38fc7168eda43f0a_13
Original Code:
```
TEST_CASE(mktime_1)
{
  struct tm tm;
  time_t t = 0;
  TEST_FAIL_IF(mktime(localtime(&t)) != 0);
  t = time(NULL);
  TEST_FAIL_IF(time(NULL) - mktime(localtime(&t)) > 1);
  TEST(1);
}
```


Overlapping Code:
```
EST_CASE(mktime_1)
{
struct tm tm;
time_t t = 0;
TEST_FAIL_IF(mktime(localtime(&t)) != 0);
t = time(NULL);
TEST_FAIL_IF(time(NULL) - mktime(localtime(
```
<Overlap Ratio: 0.872093023255814>

---

--- 151 --
Question ID: 3a343eb658ba44692072715f6c9e97703a458355_11
Original Code:
```
void
NC_hashmap_verify(NC_hashmap* hash, NC_dim** dims)
{
    unsigned long i;
    if(hash->count == 0) {
	fprintf(stderr,"<empty>\n");
	goto done;
    }
    for(i=0;i<hash->size;i++) {
	hEntry* e = &hash->table[i];
	if(e->flags == ACTIVE) {
           fprintf(stderr,"[%d] key=%lu data=%ld",(int)i,e->key,e->data-1);
	    if(dims != NULL) {
	        fprintf(stderr," name=%s",dims[e->data-1]->name->cp);
	    }	
	    fprintf(stderr,"\n");
	}
    }

done:
    fflush(stderr);
}
```


Overlapping Code:
```
erify(NC_hashmap* hash, NC_dim** dims)
{
unsigned long i;
if(hash->count == 0) {
fprintf(stderr,"<empty>\n");
goto done;
}
for(i=0;i<hash->size;i++) {
hEntry* e = &hash->table[i];
if(e->flags == ACTIVE) {
fprintf(stderr,"[%d] key=%lu data=%ld",(int)i,e->key,e->data-1);
if(dims != NULL) {
fprintf(stderr," name=%s",dims[e->data-1]->name->cp);
} 
fpri
```
<Overlap Ratio: 0.8495145631067961>

---

--- 152 --
Question ID: 7f58c735d745049025407806e972bb4c7f124888_5
Original Code:
```
static int bpf_fill_maxinsns6(struct bpf_test *self)
{
	unsigned int len = BPF_MAXINSNS;
	struct sock_filter *insn;
	int i;

	insn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);
	if (!insn)
		return -ENOMEM;

	for (i = 0; i < len - 1; i++)
		insn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +
				     SKF_AD_VLAN_TAG_PRESENT);

	insn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);

	self->u.ptr.insns = insn;
	self->u.ptr.len = len;

	return 0;
}
```


Overlapping Code:
```
fill_maxinsns6(struct bpf_test *self)
{
unsigned int len = BPF_MAXINSNS;
struct sock_filter *insn;
int i;
insn = kmalloc_array(len, sizeof(*insn), GFP_KERNEL);
if (!insn)
return -ENOMEM;
for (i = 0; i < len - 1; i++)
insn[i] = __BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SKF_AD_OFF +
SKF_AD_VLAN_TAG_PRESENT);
insn[len - 1] = __BPF_STMT(BPF_RET | BPF_A, 0);
self->u.ptr.insns = insn;
self->u.ptr.len = len;
return
```
<Overlap Ratio: 0.9530516431924883>

---

--- 153 --
Question ID: ecc2fc0bed423de59ae0c245442703afd1aa8e0d_0
Original Code:
```
class rioreceive
{
	public:
		void init();
		void get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);
		void test();

	private:
		int sockfd;
		struct sockaddr_in addr;
}
```


Overlapping Code:
```

void init();
void get(std::vector<int> &centre_xs, std::vector<double> &angles, std::vector<double> &distances, std::string& message);
void test();
p
```
<Overlap Ratio: 0.6756756756756757>

---

--- 154 --
Question ID: 5a5c0aa596461e158761df79396b8ebe48584b92_0
Original Code:
```
off_t lseek(int fd, off_t offset, int whence) {
	union {
		off_t o64;
		uint32 u32[2];
	} arg, ret;
	arg.o64 = offset;
	asm volatile("int $0x80" : "=a" (ret.u32[0]), "=d" (ret.u32[1]) : "0" (13), "b" (fd), "c" (arg.u32[0]), "d"(arg.u32[1]), "S"(whence));
	return ret.o64;
}
```


Overlapping Code:
```
ff_t lseek(int fd, off_t offset, int whence) {
union {
off_t o64;
uint32 u32[2];
} arg, ret;
arg.o64 = offset;
asm volatile("int $0x80" : "=a" (ret.u32[0]), "=d" (ret.u32[1]) : "0" (13), "b" (fd), "c" (arg.u32[0]), "d"(arg.u32[1]), "S"(whence));
retu
```
<Overlap Ratio: 0.946969696969697>

---

--- 155 --
Question ID: 4fab89f5c5c43003240da57d138c4dae953e3b7f_1
Original Code:
```
static void report_error (gravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {
    // just one error for each line
    if (parser->last_error_lineno == token.lineno) return;
    parser->last_error_lineno = token.lineno;

    // increment internal error counter
    if (error_type != GRAVITY_WARNING) ++parser->nerrors;

    // get error callback (if any)
    void *data = (parser->delegate) ? parser->delegate->xdata : NULL;
    gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;

    // build error message
    char        buffer[1024];
    va_list        arg;
    if (format) {
        va_start (arg, format);
        vsnprintf(buffer, sizeof(buffer), format, arg);
        va_end (arg);
    }

    // setup error struct
    error_desc_t error_desc = {
        .lineno = token.lineno,
        .colno = token.colno,
        .fileid = token.fileid,
        .offset = token.position
    };

    // finally call error callback
    if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);
    else printf("%s\n", buffer);
}
```


Overlapping Code:
```
ravity_parser_t *parser, error_type_t error_type, gtoken_s token, const char *format, ...) {
// just one error for each line
if (parser->last_error_lineno == token.lineno) return;
parser->last_error_lineno = token.lineno;
// increment internal error counter
if (error_type != GRAVITY_WARNING) ++parser->nerrors;
// get error callback (if any)
void *data = (parser->delegate) ? parser->delegate->xdata : NULL;
gravity_error_callback error_fn = (parser->delegate) ? ((gravity_delegate_t *)parser->delegate)->error_callback : NULL;
// build error message
char buffer[1024];
va_list arg;
if (format) {
va_start (arg, format);
vsnprintf(buffer, sizeof(buffer), format, arg);
va_end (arg);
}
// setup error struct
error_desc_t error_desc = {
.lineno = token.lineno,
.colno = token.colno,
.fileid = token.fileid,
.offset = token.position
};
// finally call error callback
if (error_fn) error_fn(NULL, error_type, buffer, error_desc, data);
else printf("%s\n", buffer);
```
<Overlap Ratio: 0.9707070707070707>

---

--- 156 --
Question ID: 9ee39c8d1010cda660950bc599d23b0060a97ea2_0
Original Code:
```
static int parse_mntr_flags(int *_argc, char ***_argv,
			    struct nl_msg *msg)
{
	struct nl_msg *flags;
	int err = -ENOBUFS;
	enum nl80211_mntr_flags flag;
	int argc = *_argc;
	char **argv = *_argv;

	flags = nlmsg_alloc();
	if (!flags)
		return -ENOMEM;

	while (argc) {
		int ok = 0;
		for (flag = __NL80211_MNTR_FLAG_INVALID;
		     flag <= NL80211_MNTR_FLAG_MAX; flag++) {
			if (strcmp(*argv, mntr_flags[flag]) == 0) {
				ok = 1;
				/*
				 * This shouldn't be adding "flag" if that is
				 * zero, but due to a problem in the kernel's
				 * nl80211 code (using NLA_NESTED policy) it
				 * will reject an empty nested attribute but
				 * not one that contains an invalid attribute
				 */
				NLA_PUT_FLAG(flags, flag);
				break;
			}
		}
		if (!ok) {
			err = -EINVAL;
			goto out;
		}
		argc--;
		argv++;
	}

	nla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);
	err = 0;
 nla_put_failure:
 out:
	nlmsg_free(flags);

	*_argc = argc;
	*_argv = argv;

	return err;
}
```


Overlapping Code:
```
tic int parse_mntr_flags(int *_argc, char ***_argv,
struct nl_msg *msg)
{
struct nl_msg *flags;
int err = -ENOBUFS;
enum nl80211_mntr_flags flag;
int argc = *_argc;
char **argv = *_argv;
flags = nlmsg_alloc();
if (!flags)
return -ENOMEM;
while (argc) {
int ok = 0;
for (flag = __NL80211_MNTR_FLAG_INVALID;
flag <= NL80211_MNTR_FLAG_MAX; flag++) {
if (strcmp(*argv, mntr_flags[flag]) == 0) {
ok = 1;
/*
* This shouldn't be adding "flag" if that is
* zero, but due to a problem in the kernel's
* nl80211 code (using NLA_NESTED policy) it
* will reject an empty nested attribute but
* not one that contains an invalid attribute
*/
NLA_PUT_FLAG(flags, flag);
break;
}
}
if (!ok) {
err = -EINVAL;
goto out;
}
argc--;
argv++;
}
nla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);
err = 0;
nla_put_failure:
out:
nlmsg_free(flags);
*_argc = argc;
*_argv = argv;
return e
```
<Overlap Ratio: 0.9908151549942594>

---

--- 157 --
Question ID: 0f194c9edfcff7cfcda3a35e7c16f20a562fd35a_32
Original Code:
```
static void
logMaterialf (GLenum  face,
	      GLenum  pname,
	      GLfloat param)
{
    vCnt[materialfIndex].n++;
    if (logVertexAttribs)
	fprintf (logFp, "glMaterialf (0x%x, 0x%x, %f)\n", face, pname, param);
    (*nativeRenderTable->Materialf) (face, pname, param);
}
```


Overlapping Code:
```
void
logMaterialf (GLenum face,
GLenum pname,
GLfloat param)
{
vCnt[materialfIndex].n++;
if (logVertexAttribs)
fprintf (logFp, "glMaterialf (0x%x, 0x%x, %f)\n", face, pname, param);
(*nativeRenderTabl
```
<Overlap Ratio: 0.819672131147541>

---

--- 158 --
Question ID: 64655db5ced32871a85d4f40915dfefc2a7c8712_4
Original Code:
```
static int
memset_init(struct benchmark *bench, struct benchmark_args *args)
{
	assert(bench != NULL);
	assert(args != NULL);
	assert(args->opts != NULL);

	int ret = 0;

	struct memset_bench *mb = malloc(sizeof (struct memset_bench));
	if (!mb) {
		perror("malloc");
		return -1;
	}

	mb->pargs = args->opts;
	mb->pargs->chunk_size = args->dsize;

	enum operation_mode op_mode = parse_op_mode(mb->pargs->mode);
	if (op_mode == OP_MODE_UNKNOWN) {
		fprintf(stderr, "Invalid operation mode argument '%s'",
			mb->pargs->mode);
		ret = -1;
		goto err_free_mb;
	}

	size_t size = MAX_OFFSET + mb->pargs->chunk_size;
	size_t large = size * args->n_ops_per_thread * args->n_threads;

	size_t small = size * args->n_threads;

	mb->fsize = (op_mode == OP_MODE_STAT) ? small : large;

	mb->n_randoms = args->n_ops_per_thread * args->n_threads;
	mb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));
	if (!mb->randoms) {
		perror("malloc");
		ret = -1;
		goto err_free_mb;
	}

	unsigned int seed = mb->pargs->seed;
	for (int i = 0; i < mb->n_randoms; i++)
		mb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;

	mb->flags = O_CREAT | O_EXCL | O_RDWR;

	/* create a pmem file */
	mb->fd = open(args->fname, mb->flags, args->fmode);
	if (mb->fd == -1) {
		perror(args->fname);
		ret = -1;
		goto err_free_randoms;
	}

	/* allocate the pmem */
	if ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {
		perror("posix_fallocate");
		ret = -1;
		goto err_close_file;
	}

	/* memory map it */
	mb->pmem_addr = pmem_map(mb->fd);
	if (mb->pmem_addr == NULL) {
		perror("pmem_map");
		ret = -1;
		goto err_close_file;
	}

	/* set proper func_dest() depending on benchmark args */
	mb->func_dest = assign_mode_func(mb->pargs->mode);
	if (mb->func_dest == NULL) {
		fprintf(stderr, "wrong mode parameter -- '%s'",
				mb->pargs->mode);
		ret = -1;
		goto err_unmap;
	}

	if (mb->pargs->memset)
		mb->func_op = (mb->pargs->persist) ?
				libc_memset_persist : libc_memset;
	else
		mb->func_op = (mb->pargs->persist) ?
				libpmem_memset_persist : libpmem_memset_nodrain;

	if (!mb->pargs->no_warmup) {
		if (do_warmup(
			mb, args->n_threads * args->n_ops_per_thread) != 0) {
			fprintf(stderr, "do_warmup() function failed.");
			ret = -1;
			goto err_unmap;
		}
	}

	close(mb->fd);

	pmembench_set_priv(bench, mb);

	return 0;

err_unmap:
	munmap(mb->pmem_addr, mb->fsize);
err_close_file:
	close(mb->fd);
err_free_randoms:
	free(mb->randoms);
err_free_mb:
	free(mb);

	return ret;
}
```


Overlapping Code:
```
_init(struct benchmark *bench, struct benchmark_args *args)
{
assert(bench != NULL);
assert(args != NULL);
assert(args->opts != NULL);
int ret = 0;
struct memset_bench *mb = malloc(sizeof (struct memset_bench));
if (!mb) {
perror("malloc");
return -1;
}
mb->pargs = args->opts;
mb->pargs->chunk_size = args->dsize;
enum operation_mode op_mode = parse_op_mode(mb->pargs->mode);
if (op_mode == OP_MODE_UNKNOWN) {
fprintf(stderr, "Invalid operation mode argument '%s'",
mb->pargs->mode);
ret = -1;
goto err_free_mb;
}
size_t size = MAX_OFFSET + mb->pargs->chunk_size;
size_t large = size * args->n_ops_per_thread * args->n_threads;
size_t small = size * args->n_threads;
mb->fsize = (op_mode == OP_MODE_STAT) ? small : large;
mb->n_randoms = args->n_ops_per_thread * args->n_threads;
mb->randoms = malloc(mb->n_randoms * sizeof (*mb->randoms));
if (!mb->randoms) {
perror("malloc");
ret = -1;
goto err_free_mb;
}
unsigned int seed = mb->pargs->seed;
for (int i = 0; i < mb->n_randoms; i++)
mb->randoms[i] = rand_r(&seed) % args->n_ops_per_thread;
mb->flags = O_CREAT | O_EXCL | O_RDWR;
/* create a pmem file */
mb->fd = open(args->fname, mb->flags, args->fmode);
if (mb->fd == -1) {
perror(args->fname);
ret = -1;
goto err_free_randoms;
}
/* allocate the pmem */
if ((errno = posix_fallocate(mb->fd, 0, mb->fsize)) != 0) {
perror("posix_fallocate");
ret = -1;
goto err_close_file;
}
/* memory map it */
mb->pmem_addr = pmem_map(mb->fd);
if (mb->pmem_addr == NULL) {
perror("pmem_map");
ret = -1;
goto err_close_file;
}
/* set proper func_dest() depending on benchmark args */
mb->func_dest = assign_mode_func(mb->pargs->mode);
if (mb->func_dest == NULL) {
fprintf(stderr, "wrong mode parameter -- '%s'",
mb->pargs->mode);
ret = -1;
goto err_unmap;
}
if (mb->pargs->memset)
mb->func_op = (mb->pargs->persist) ?
libc_memset_persist : libc_memset;
else
mb->func_op = (mb->pargs->persist) ?
libpmem_memset_persist : libpmem_memset_nodrain;
if (!mb->pargs->no_warmup) {
if (do_warmup(
mb, args->n_threads * args->n_ops_per_thread) != 0) {
fprintf(stderr, "do_warmup() function failed.");
ret = -1;
goto err_unmap;
}
}
close(mb->fd);
pmembench_set_priv(bench, mb);
return 0;
err_unmap:
munmap(mb->pmem_addr, mb->fsize);
err_close_file:
close(mb->fd);
err_free_randoms:
free(m
```
<Overlap Ratio: 0.9716981132075472>

---

--- 159 --
Question ID: ad4b773448d270891e962d3e0e55bac46816639b_37
Original Code:
```
void
eventHandler_initialize(jbyte sessionID)
{
    jvmtiError error;
    jint i;

    requestIdCounter = 1;
    currentSessionID = sessionID;

    /* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this
     *   is done while none of these callbacks are active.
     */
    active_callbacks = 0;
    vm_death_callback_active = JNI_FALSE;
    callbackLock = debugMonitorCreate("JDWP Callback Lock");
    callbackBlock = debugMonitorCreate("JDWP Callback Block");

    handlerLock = debugMonitorCreate("JDWP Event Handler Lock");

    for (i = EI_min; i <= EI_max; ++i) {
        getHandlerChain(i)->first = NULL;
    }

    /*
     * Permanently enabled some events.
     */
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                      EI_VM_INIT, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable vm init events");
    }
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                      EI_VM_DEATH, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable vm death events");
    }
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                      EI_THREAD_START, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable thread start events");
    }
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                       EI_THREAD_END, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable thread end events");
    }
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                       EI_CLASS_PREPARE, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable class prepare events");
    }
    error = threadControl_setEventMode(JVMTI_ENABLE,
                                       EI_GC_FINISH, NULL);
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't enable garbage collection finish events");
    }

    (void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));
    /* Event callback for JVMTI_EVENT_SINGLE_STEP */
    gdata->callbacks.SingleStep                 = &cbSingleStep;
    /* Event callback for JVMTI_EVENT_BREAKPOINT */
    gdata->callbacks.Breakpoint                 = &cbBreakpoint;
    /* Event callback for JVMTI_EVENT_FRAME_POP */
    gdata->callbacks.FramePop                   = &cbFramePop;
    /* Event callback for JVMTI_EVENT_EXCEPTION */
    gdata->callbacks.Exception                  = &cbException;
    /* Event callback for JVMTI_EVENT_THREAD_START */
    gdata->callbacks.ThreadStart                = &cbThreadStart;
    /* Event callback for JVMTI_EVENT_THREAD_END */
    gdata->callbacks.ThreadEnd                  = &cbThreadEnd;
    /* Event callback for JVMTI_EVENT_CLASS_PREPARE */
    gdata->callbacks.ClassPrepare               = &cbClassPrepare;
    /* Event callback for JVMTI_EVENT_CLASS_LOAD */
    gdata->callbacks.ClassLoad                  = &cbClassLoad;
    /* Event callback for JVMTI_EVENT_FIELD_ACCESS */
    gdata->callbacks.FieldAccess                = &cbFieldAccess;
    /* Event callback for JVMTI_EVENT_FIELD_MODIFICATION */
    gdata->callbacks.FieldModification          = &cbFieldModification;
    /* Event callback for JVMTI_EVENT_EXCEPTION_CATCH */
    gdata->callbacks.ExceptionCatch             = &cbExceptionCatch;
    /* Event callback for JVMTI_EVENT_METHOD_ENTRY */
    gdata->callbacks.MethodEntry                = &cbMethodEntry;
    /* Event callback for JVMTI_EVENT_METHOD_EXIT */
    gdata->callbacks.MethodExit                 = &cbMethodExit;
    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTER */
    gdata->callbacks.MonitorContendedEnter      = &cbMonitorContendedEnter;
    /* Event callback for JVMTI_EVENT_MONITOR_CONTENDED_ENTERED */
    gdata->callbacks.MonitorContendedEntered    = &cbMonitorContendedEntered;
    /* Event callback for JVMTI_EVENT_MONITOR_WAIT */
    gdata->callbacks.MonitorWait                = &cbMonitorWait;
    /* Event callback for JVMTI_EVENT_MONITOR_WAITED */
    gdata->callbacks.MonitorWaited              = &cbMonitorWaited;
    /* Event callback for JVMTI_EVENT_VM_INIT */
    gdata->callbacks.VMInit                     = &cbVMInit;
    /* Event callback for JVMTI_EVENT_VM_DEATH */
    gdata->callbacks.VMDeath                    = &cbVMDeath;
    /* Event callback for JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */
    gdata->callbacks.GarbageCollectionFinish    = &cbGarbageCollectionFinish;

    error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventCallbacks)
                (gdata->jvmti, &(gdata->callbacks), sizeof(gdata->callbacks));
    if (error != JVMTI_ERROR_NONE) {
        EXIT_ERROR(error,"Can't set event callbacks");
    }

    /* Notify other modules that the event callbacks are in place */
    threadControl_onHook();

    /* Get the event helper thread initialized */
    eventHelper_initialize(sessionID);
}
```


Overlapping Code:
```
ialize(jbyte sessionID)
{
jvmtiError error;
jint i;
requestIdCounter = 1;
currentSessionID = sessionID;
/* This is for BEGIN_CALLBACK/END_CALLBACK handling, make sure this
* is done while none of these callbacks are active.
*/
active_callbacks = 0;
vm_death_callback_active = JNI_FALSE;
callbackLock = debugMonitorCreate("JDWP Callback Lock");
callbackBlock = debugMonitorCreate("JDWP Callback Block");
handlerLock = debugMonitorCreate("JDWP Event Handler Lock");
for (i = EI_min; i <= EI_max; ++i) {
getHandlerChain(i)->first = NULL;
}
/*
* Permanently enabled some events.
*/
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_VM_INIT, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable vm init events");
}
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_VM_DEATH, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable vm death events");
}
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_THREAD_START, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable thread start events");
}
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_THREAD_END, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable thread end events");
}
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_CLASS_PREPARE, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable class prepare events");
}
error = threadControl_setEventMode(JVMTI_ENABLE,
EI_GC_FINISH, NULL);
if (error != JVMTI_ERROR_NONE) {
EXIT_ERROR(error,"Can't enable garbage collection finish events");
}
(void)memset(&(gdata->callbacks),0,sizeof(gdata->callbacks));
/* Event callback for JVMTI_EVENT_SINGLE_STEP */
gdata->callbacks.SingleStep = &cbSingleStep;
/* Event callback for JVMTI_EVENT_BREAKPOINT */
gdata->callbacks.Breakpoint = &cbBreakpoint;
/* Event callback for JVMTI_EVENT_FRAME_POP */
gdata->callbacks.FramePop = &cbFramePop;
/* Event callback for JVMTI_EVENT_EXCEPTION */
gdata->callbacks.Exception
```
<Overlap Ratio: 0.9888438133874239>

---

--- 160 --
Question ID: c886a8cb0ed9d168be8fd96a1a5e0317bf0fc3fe_41
Original Code:
```
bool ica_at_complianceTest(uint8_t *at_cmd, int16_t at_cmd_len)
{
    bool        ret = true;
    uint8_t     idx;

    if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&
        strcmp(&at_cmd[strlen(LORA_AT_CTEST)], "=?") == 0) {
        snprintf(atcmd, ATCMD_SIZE,
                 "\r\n%s:[idx]\r\n", LORA_AT_CTEST);
    } else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&
               at_cmd[strlen(LORA_AT_CTEST)] == '=') {
        idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);
        ret = lora_compliance_test(idx);
        if (ret == true) {
            snprintf(atcmd, ATCMD_SIZE, "\r\nOK\r\n");
        }
    } else {
        ret = false;
    }

    return ret;
}
```


Overlapping Code:
```
(uint8_t *at_cmd, int16_t at_cmd_len)
{
bool ret = true;
uint8_t idx;
if (at_cmd_len == (strlen(LORA_AT_CTEST) + 2) &&
strcmp(&at_cmd[strlen(LORA_AT_CTEST)], "=?") == 0) {
snprintf(atcmd, ATCMD_SIZE,
"\r\n%s:[idx]\r\n", LORA_AT_CTEST);
} else if (at_cmd_len >= (strlen(LORA_AT_CTEST) + 2) &&
at_cmd[strlen(LORA_AT_CTEST)] == '=') {
idx = strtol(&at_cmd[strlen(LORA_AT_CTEST) + 1], NULL, 16);
ret = lora_compliance_test(idx);
if (ret == true) {
snprintf(atcmd, ATCMD_SIZE, "\r\nOK\r\n");
}
} else {
ret = false;
}
r
```
<Overlap Ratio: 0.9311594202898551>

---

--- 161 --
Question ID: c4671dfd971444beb4b46dc8c97ddbceafa3ecdf_0
Original Code:
```
class People{
public:
	People(Mediator *mediator);
	~People();
public:
	Mediator *mediator_;
}
```


Overlapping Code:
```
le{
public:
People(Mediator *mediator);
~People();
```
<Overlap Ratio: 0.5494505494505495>

---

--- 162 --
Question ID: 36cd278e68c04b98eb1ffa068e9fe4ba097cb7a9_53
Original Code:
```
static void
_virtio_scsi_dev_unregister_cb(void *io_device)
{
	struct virtio_scsi_dev *svdev = io_device;
	struct virtio_dev *vdev = &svdev->vdev;
	bool finish_module;
	bdev_virtio_remove_cb remove_cb;
	void *remove_ctx;

	assert(spdk_ring_count(svdev->ctrlq_ring) == 0);
	spdk_ring_free(svdev->ctrlq_ring);
	spdk_poller_unregister(&svdev->mgmt_poller);

	virtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);
	virtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);

	virtio_dev_stop(vdev);
	virtio_dev_destruct(vdev);

	pthread_mutex_lock(&g_virtio_scsi_mutex);
	TAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);
	pthread_mutex_unlock(&g_virtio_scsi_mutex);

	remove_cb = svdev->remove_cb;
	remove_ctx = svdev->remove_ctx;
	spdk_dma_free(svdev->eventq_ios);
	free(svdev);

	if (remove_cb) {
		remove_cb(remove_ctx, 0);
	}

	finish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);

	if (g_bdev_virtio_finish && finish_module) {
		spdk_bdev_module_finish_done();
	}
}
```


Overlapping Code:
```
irtio_scsi_dev_unregister_cb(void *io_device)
{
struct virtio_scsi_dev *svdev = io_device;
struct virtio_dev *vdev = &svdev->vdev;
bool finish_module;
bdev_virtio_remove_cb remove_cb;
void *remove_ctx;
assert(spdk_ring_count(svdev->ctrlq_ring) == 0);
spdk_ring_free(svdev->ctrlq_ring);
spdk_poller_unregister(&svdev->mgmt_poller);
virtio_dev_release_queue(vdev, VIRTIO_SCSI_EVENTQ);
virtio_dev_release_queue(vdev, VIRTIO_SCSI_CONTROLQ);
virtio_dev_stop(vdev);
virtio_dev_destruct(vdev);
pthread_mutex_lock(&g_virtio_scsi_mutex);
TAILQ_REMOVE(&g_virtio_scsi_devs, svdev, tailq);
pthread_mutex_unlock(&g_virtio_scsi_mutex);
remove_cb = svdev->remove_cb;
remove_ctx = svdev->remove_ctx;
spdk_dma_free(svdev->eventq_ios);
free(svdev);
if (remove_cb) {
remove_cb(remove_ctx, 0);
}
finish_module = TAILQ_EMPTY(&g_virtio_scsi_devs);
if (g_bdev_virtio_finish && finish_module) {
spdk_bdev_module_finis
```
<Overlap Ratio: 0.9706521739130435>

---

--- 163 --
Question ID: 9a7ad5c738de91170f8a66d181e30c28492947a6_67
Original Code:
```
static PyObject* gsl_sf_debye_3_e_wrap(PyObject *self, PyObject *args) {
PyObject* returned_object;
int int_result;
double x=0.0;
gsl_sf_result result;

if (!PyArg_ParseTuple(args, "d", &x)) {
  /* say a little bit more */
  return NULL;
}
int_result=gsl_sf_debye_3_e(x, &result);

if (int_result!=GSL_SUCCESS) {
  const char* message;
  message=gsl_strerror(int_result);
  /* raise exception */
  PyErr_SetString(gsl_module_error,message);
  return NULL;
}
returned_object=Py_BuildValue("(dd)",result.val, result.err);
return returned_object;
}
```


Overlapping Code:
```
_e_wrap(PyObject *self, PyObject *args) {
PyObject* returned_object;
int int_result;
double x=0.0;
gsl_sf_result result;
if (!PyArg_ParseTuple(args, "d", &x)) {
/* say a little bit more */
return NULL;
}
int_result=gsl_sf_debye_3_e(x, &result);
if (int_result!=GSL_SUCCESS) {
const char* message;
message=gsl_strerror(int_result);
/* raise exception */
PyErr_SetString(gsl_module_error,message);
return NULL;
}
returned_object=Py_BuildValue("(dd)",result.val, result.err);
return returned_object;
}
```
<Overlap Ratio: 0.941398865784499>

---

--- 164 --
Question ID: 53f763e6a174d8f5a27fa5c3c54624423cdf8917_2
Original Code:
```
static boolean __wss_ping()
{
	/* Disable CODEC operations first */
	__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);
	/* Now put some harmless values in registers and check them */
	__wss_outreg(WSSR_COUNT_LOW, 0xaa);
	__wss_outreg(WSSR_COUNT_HIGH, 0x55);
	return (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)
	  && (__wss_inreg(WSSR_COUNT_HIGH) == 0x55);
}
```


Overlapping Code:
```
/* Disable CODEC operations first */
__wss_regbit_reset(WSSR_IFACE_CTRL, WSSM_PLAYBACK_ENABLE);
/* Now put some harmless values in registers and check them */
__wss_outreg(WSSR_COUNT_LOW, 0xaa);
__wss_outreg(WSSR_COUNT_HIGH, 0x55);
return (__wss_inreg(WSSR_COUNT_LOW) == 0xaa)
&& (__wss_inreg(WSSR_CO
```
<Overlap Ratio: 0.8547008547008547>

---

--- 165 --
Question ID: 56b89f9ca944a79b3e7fa9bc393c471b09a0134f_74
Original Code:
```
static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}
```


Overlapping Code:
```
static int __Pyx_modinit_function_export_code(void) {
__Pyx_RefNannyDeclarations
__Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
/*--- Function export code ---*/
__Pyx_RefNannyFinishContext();
return 0;
}
```
<Overlap Ratio: 1.0>

---

--- 166 --
Question ID: c03997e33ffd6e6a6f377f305763b867d87ff445_0
Original Code:
```
class Att_relay : public TinyMachine {
  
    public:
      Att_relay( void ) : TinyMachine() {};
  
      short relay_pin;
      short led_pin;
             
      enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; 
      enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; 
      enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; 
      // store prev relay state while blinking, so after blink know to blink on or off.
      bool prev_relay_state;

      short on_blink = 3;
      short off_blink = 5;
      atm_timer_millis timer;
      atm_counter counter_on, counter_off;  
      
      Att_relay & begin( short relay_pin, short l_pin);

      Att_relay & setBlink( short repeat, bool on_off ) ;

  
      int event( int id );
  
      void action( int id ); 
  
  }
```


Overlapping Code:
```
ic TinyMachine {

public:
Att_relay( void ) : TinyMachine() {};

short relay_pin;
short led_pin;

enum { OFF, ON, BLINK_ON, BLINK_OFF } STATES; 
enum { EVT_TIMER, EVT_COUNTER_ON,EVT_COUNTER_OFF, EVT_TOGGLE, ELSE } EVENTS; 
enum { ACT_LED_OFF, ACT_LED_ON, ACT_RELAY_ON, ACT_RELAY_OFF } ACTIONS; 
// store prev relay state while blinking, so after blink know to blink on or off.
bool prev_relay_state;
short on_blink = 3;
short off_blink = 5;
atm_timer_millis timer;
atm_counter counter_on, counter_off; 

Att_relay & begin( short relay_pin, short l_pin);
Att_relay & setBlink( short repeat, bool on_off ) ;

int event( int id );

void action( int id )
```
<Overlap Ratio: 0.9601181683899557>

---

--- 167 --
Question ID: 7eb4c80fa9defa43b05514893caa0815195555fa_189
Original Code:
```
SWIGINTERN PyObject *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  float result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:get_XE_YIELD_IFBA_DIFF_1",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_float(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "get_XE_YIELD_IFBA_DIFF_1" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = (float)(val1);
  ecode2 = SWIG_AsVal_float(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "get_XE_YIELD_IFBA_DIFF_1" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);
  resultobj = SWIG_From_float((float)(result));
  return resultobj;
fail:
  return NULL;
}
```


Overlapping Code:
```
ect *_wrap_get_XE_YIELD_IFBA_DIFF_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
PyObject *resultobj = 0;
float arg1 ;
float arg2 ;
float val1 ;
int ecode1 = 0 ;
float val2 ;
int ecode2 = 0 ;
PyObject * obj0 = 0 ;
PyObject * obj1 = 0 ;
float result;

if (!PyArg_ParseTuple(args,(char *)"OO:get_XE_YIELD_IFBA_DIFF_1",&obj0,&obj1)) SWIG_fail;
ecode1 = SWIG_AsVal_float(obj0, &val1);
if (!SWIG_IsOK(ecode1)) {
SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "get_XE_YIELD_IFBA_DIFF_1" "', argument " "1"" of type '" "float""'");
} 
arg1 = (float)(val1);
ecode2 = SWIG_AsVal_float(obj1, &val2);
if (!SWIG_IsOK(ecode2)) {
SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "get_XE_YIELD_IFBA_DIFF_1" "', argument " "2"" of type '" "float""'");
} 
arg2 = (float)(val2);
result = (float)get_XE_YIELD_IFBA_DIFF_1(arg1,arg2);
resultobj = SWIG_From_float((float)(result));
return resultobj;
fail:
return NULL;
}
```
<Overlap Ratio: 0.9829242262540021>

---

--- 168 --
Question ID: fecd166f4c24431102ac68587ad03086e10c5612_0
Original Code:
```
void runScheduler(){
	if(currentProcess->process.PID == 0 && allProcess > 1 && allProcessForeground > 0){
		currentProcess->process.status = LOCKED;
	}

	if(numberOfTicks < QUANTUM) {
			
		numberOfTicks++;
		disableTickInter();
		checkIfThreadChange();
		enableTickInter();
		return;
	}
	
	
	numberOfTicks = 0;


	if(currentProcess->process.status == RUNNING){
		currentProcess->process.status = READY;
	}

	currentProcess = currentProcess->next;

	while(currentProcess->process.status != READY){
		currentProcess = currentProcess->next;
	}
	
	currentProcess->process.status = RUNNING;
}
```


Overlapping Code:
```
ess.PID == 0 && allProcess > 1 && allProcessForeground > 0){
currentProcess->process.status = LOCKED;
}
if(numberOfTicks < QUANTUM) {

numberOfTicks++;
disableTickInter();
checkIfThreadChange();
enableTickInter();
return;
}


numberOfTicks = 0;
if(currentProcess->process.status == RUNNING){
currentProcess->process.status = READY;
}
currentProcess = currentProcess->next;
while(currentProcess->process.status != READY){
currentProcess = currentProcess->next;
}

currentProcess->process.status = RUNN
```
<Overlap Ratio: 0.9090909090909091>

---

--- 169 --
Question ID: 15c4552fd1af99b1fdb7d8a2dc39e8abcf921c68_7
Original Code:
```
static void files_plugin_start(struct plugin_t * plugin)
{
  struct file_server_t * file_server = plugin->data;

  size_t cwd_capacity = 256;
  char * cwd = malloc(cwd_capacity);

  while (getcwd(cwd, cwd_capacity) == NULL) {
    cwd_capacity *= 2;
    cwd = realloc(cwd, cwd_capacity);
  }

  size_t cwd_length = strlen(cwd);

  if (cwd_length + 1 >= cwd_capacity) {
    cwd = realloc(cwd, cwd_capacity + 1);
  }

  cwd_length++;
  cwd[cwd_length - 1] = '/';
  cwd[cwd_length] = 0;

  file_server->cwd = cwd;
  file_server->cwd_length = cwd_length;

  hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);
  file_server->open_files_count = 0;

  void * root = server_config_plugin_get(plugin->config_context, "push_files");
  if (root) {
    server_config_plugin_each(file_server, root, init_push_file);
  }

  log_append(plugin->log, LOG_INFO, "Files plugin started");
}
```


Overlapping Code:
```
ic void files_plugin_start(struct plugin_t * plugin)
{
struct file_server_t * file_server = plugin->data;
size_t cwd_capacity = 256;
char * cwd = malloc(cwd_capacity);
while (getcwd(cwd, cwd_capacity) == NULL) {
cwd_capacity *= 2;
cwd = realloc(cwd, cwd_capacity);
}
size_t cwd_length = strlen(cwd);
if (cwd_length + 1 >= cwd_capacity) {
cwd = realloc(cwd, cwd_capacity + 1);
}
cwd_length++;
cwd[cwd_length - 1] = '/';
cwd[cwd_length] = 0;
file_server->cwd = cwd;
file_server->cwd_length = cwd_length;
hash_table_init_with_string_keys(&file_server->open_files, open_file_removed_from_hash);
file_server->open_files_count = 0;
void * root = server_config_plugin_get(plugin->config_context, "push_files");
if (root) {
server_config_plugin_each(file_server, root, init_push_file);
}
log_append(plugin->l
```
<Overlap Ratio: 0.9478672985781991>

---

--- 170 --
Question ID: 02a4eefdf6e7c43b8e8acd9a87d69f33c2546654_2
Original Code:
```
void PI_calcMachin3(PBF calcPI, int arctan_mode){
    PBF operand1 = BF_create(calcPI->size);
    PBF operand2 = BF_create(calcPI->size);
    PBF operand3 = BF_create(calcPI->size);
    PBF operand4 = BF_create(calcPI->size);
    PBF operand5 = BF_create(calcPI->size);
    PBF operand6 = BF_create(calcPI->size);
    
    BF_initializeInt(operand1, 239, 0);
    BF_initializeInt(operand2, 1023, 0);
    BF_initializeInt(operand3, 5832, 0);
    BF_initializeInt(operand4, 110443, 0);
    BF_initializeInt(operand5, 4841182, 0);
    BF_initializeInt(operand6, 6826318, 0);
    
    BF_inv(operand1, operand1);
    BF_inv(operand2, operand2);
    BF_inv(operand3, operand3);
    BF_inv(operand4, operand4);
    BF_inv(operand5, operand5);
    BF_inv(operand6, operand6);
    
    if(arctan_mode == SERIES){
        arctan_series(operand1, operand1);
        arctan_series(operand2, operand2);
        arctan_series(operand3, operand3);
        arctan_series(operand4, operand4);
        arctan_series(operand5, operand5);
        arctan_series(operand6, operand6);
    }else if(arctan_mode == EULER){
        arctan_euler(operand1, operand1);
        arctan_euler(operand2, operand2);
        arctan_euler(operand3, operand3);
        arctan_euler(operand4, operand4);
        arctan_euler(operand5, operand5);
        arctan_euler(operand6, operand6);
    }
    
    BF_mulInteger(operand1, operand1, 732);
    BF_mulInteger(operand2, operand2, 128);
    BF_mulInteger(operand3, operand3, 272);
    BF_mulInteger(operand4, operand4, 48);
    BF_mulInteger(operand5, operand5, 48);
    BF_mulInteger(operand6, operand6, 400);
    
    BF_add(operand1, operand2);
    BF_sub(operand1, operand3);
    BF_add(operand1, operand4);
    BF_sub(operand1, operand5);
    BF_sub(operand1, operand6);
    
    BF_copy(calcPI, operand1);
    
    BF_delete(operand1);
    BF_delete(operand2);
    BF_delete(operand3);
    BF_delete(operand4);
    BF_delete(operand5);
    BF_delete(operand6);
}
```


Overlapping Code:
```
(PBF calcPI, int arctan_mode){
PBF operand1 = BF_create(calcPI->size);
PBF operand2 = BF_create(calcPI->size);
PBF operand3 = BF_create(calcPI->size);
PBF operand4 = BF_create(calcPI->size);
PBF operand5 = BF_create(calcPI->size);
PBF operand6 = BF_create(calcPI->size);

BF_initializeInt(operand1, 239, 0);
BF_initializeInt(operand2, 1023, 0);
BF_initializeInt(operand3, 5832, 0);
BF_initializeInt(operand4, 110443, 0);
BF_initializeInt(operand5, 4841182, 0);
BF_initializeInt(operand6, 6826318, 0);

BF_inv(operand1, operand1);
BF_inv(operand2, operand2);
BF_inv(operand3, operand3);
BF_inv(operand4, operand4);
BF_inv(operand5, operand5);
BF_inv(operand6, operand6);

if(arctan_mode == SERIES){
arctan_series(operand1, operand1);
arctan_series(operand2, operand2);
arctan_series(operand3, operand3);
arctan_series(operand4, operand4);
arctan_series(operand5, operand5);
arctan_series(operand6, operand6);
}else if(arctan_mode == EULER){
arctan_euler(operand1, operand1);
arctan_euler(operand2, operand2);
arctan_euler(operand3, operand3);
arctan_euler(operand4, operand4);
arctan_euler(operand5, operand5);
arctan_euler(operand6, operand6);
}

BF_mulInteger(operand1, operand1, 732);
BF_mulInteger(operand2, operand2, 128);
BF_mulInteger(operand3, operand3, 272);
BF_mulInteger(operand4, operand4, 48);
BF_mulInteger(operand5, operand5, 48);
BF_mulInteger(operand6, operand6, 400);

BF_add(operand1, operand2);
BF_sub(operand1, operand3);
BF_add(operand1, operand4);
BF_sub(operand1, operand5);
BF_sub(operand1, operand6);

BF_copy(calcPI, operand1);

BF_delete(operand1);
BF_delete(operand2);
BF_delete(operand3);
BF_delete(operand4);
BF_delete(operand5);
BF_delete(operan
```
<Overlap Ratio: 0.9853027630805409>

---

--- 171 --
Question ID: 8e7df5daef45c7ee46c2898f834e917629ebe323_0
Original Code:
```
interface RCWeakRef : NSObject {
    bool  _useWeakStorage;
    id  _weakPointer;
    id  _weakStorage;
}
```


Overlapping Code:
```
_useWeakStorage;
id _weakPointer;
id _weakStorage;
```
<Overlap Ratio: 0.5555555555555556>

---

--- 172 --
Question ID: f137cbe98ad9927271ef0e85122efb8b856d3018_26
Original Code:
```
void __glXDispSwap_TexImage2D(GLbyte * pc)
{
    const GLvoid * const pixels = (const GLvoid *) (pc + 52);
    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);

    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );

    CALL_TexImage2D( GET_DISPATCH(), (
         (GLenum  )bswap_ENUM   ( pc + 20 ),
         (GLint   )bswap_CARD32 ( pc + 24 ),
         (GLint   )bswap_CARD32 ( pc + 28 ),
         (GLsizei )bswap_CARD32 ( pc + 32 ),
         (GLsizei )bswap_CARD32 ( pc + 36 ),
         (GLint   )bswap_CARD32 ( pc + 40 ),
         (GLenum  )bswap_ENUM   ( pc + 44 ),
         (GLenum  )bswap_ENUM   ( pc + 48 ),
        pixels
    ) );
}
```


Overlapping Code:
```
XDispSwap_TexImage2D(GLbyte * pc)
{
const GLvoid * const pixels = (const GLvoid *) (pc + 52);
__GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES, hdr->swapBytes) );
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST, hdr->lsbFirst) );
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32( & hdr->rowLength )) );
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32( & hdr->skipRows )) );
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS, (GLint) bswap_CARD32( & hdr->skipPixels )) );
CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32( & hdr->alignment )) );
CALL_TexImage2D( GET_DISPATCH(), (
(GLenum )bswap_ENUM ( pc + 20 ),
(GLint )bswap_CARD32 ( pc + 24 ),
(GLint )bswap_CARD32 ( pc + 28 ),
(GLsizei )bswap_CARD32 ( pc + 32 ),
(GLsizei )bswap_CARD32 ( pc + 36 ),
(GLint )bswap_CARD32 ( pc + 40 ),
(GLenum )bswap_ENUM ( pc + 44 ),
(GLenum )bswap_ENUM ( pc + 
```
<Overlap Ratio: 0.9730250481695568>

---

--- 173 --
Question ID: 651b4b2ad6d22f4cb2a2bdb0a7f74b626cbaa118_4
Original Code:
```
static void
sock_send (anidb_session_t *session, char *msg, char *out)
{
	int n;

//	printf("send: '%s'\n", msg);

	send(session->socket, msg, strlen(msg) + 1, 0);
	n = recv(session->socket, out, 1000, 0);

	out[n-1] = '\0';

//	printf("recv: '%s'\n", out);
}
```


Overlapping Code:
```
session_t *session, char *msg, char *out)
{
int n;
// printf("send: '%s'\n", msg);
send(session->socket, msg, strlen(msg) + 1, 0);
n = recv(session->socket, out, 1000, 0);
out[n-1] = '\0';
// printf("
```
<Overlap Ratio: 0.796812749003984>

---

--- 174 --
Question ID: 87a485c65a80ec2f246d08c28cec28ad3a0b6666_48
Original Code:
```
static AccCache *CreateAccCache(XFInfo *xfinfo, const int b)
{
   AccCache *ac;
   IntVec size;
   int vsize, bl;

   size = GetBlockSize(xfinfo,b),
   
   vsize = 0;
   for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];
   
   ac = (AccCache *)New(&obcaStack,sizeof(AccCache));
   ac->baseclass = b;
   ac->bVector  = CreateDVector(&obcaStack,vsize); 
   ZeroDVector(ac->bVector);
   ac->bTriMat = CreateBlockTriMat(&obcaStack,size);    
   ZeroBlockTriMat(ac->bTriMat);
   ac->next = xfinfo->headac;
   xfinfo->headac = ac;
   return(ac);
}
```


Overlapping Code:
```
o *xfinfo, const int b)
{
AccCache *ac;
IntVec size;
int vsize, bl;
size = GetBlockSize(xfinfo,b),

vsize = 0;
for (bl=1;bl<=IntVecSize(size);bl++) vsize += size[bl];

ac = (AccCache *)New(&obcaStack,sizeof(AccCache));
ac->baseclass = b;
ac->bVector = CreateDVector(&obcaStack,vsize); 
ZeroDVector(ac->bVector);
ac->bTriMat = CreateBlockTriMat(&obcaStack,size); 
ZeroBlockTriMat(ac->bTriMat);
ac->next = xfinfo->headac;
xfinfo->headac = ac;
return(ac
```
<Overlap Ratio: 0.9164969450101833>

---

--- 175 --
Question ID: 0a4b98ae675417a93b8984c8e57d0303e06e0168_44
Original Code:
```
VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,
            FixPoint1616_t CalDistanceMilliMeter,
            int32_t* pOffsetMicroMeter) {
    VL53L0_Error Status = VL53L0_ERROR_NONE;
    uint16_t sum_ranging = 0;
    FixPoint1616_t total_count = 0;
    VL53L0_RangingMeasurementData_t RangingMeasurementData;
    FixPoint1616_t StoredMeanRange;
    uint32_t StoredMeanRangeAsInt;
    VL53L0_DeviceParameters_t CurrentParameters;
    uint32_t CalDistanceAsInt_mm;
    int meas = 0;
    LOG_FUNCTION_START("");

    if (CalDistanceMilliMeter<=0) {
        Status = VL53L0_ERROR_INVALID_PARAMS;
    }

    if (Status == VL53L0_ERROR_NONE) {
        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);
    }

    /* Perform 50 measurements and compute the averages */
    if (Status == VL53L0_ERROR_NONE) {
        sum_ranging = 0;
        total_count = 0;
        for(meas=0;meas<50;meas++)
        {
            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);

            if (Status != VL53L0_ERROR_NONE) {
                break;
            }

            /* The range is valid when RangeStatus = 0 */
            if (RangingMeasurementData.RangeStatus == 0) {
                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;
                total_count = total_count + 1;
            }
        }

        if (total_count == 0) {
            /* no valid values found */
            Status = VL53L0_ERROR_RANGE_ERROR;
        }
    }


    if (Status == VL53L0_ERROR_NONE) {
        /* FixPoint1616_t / uint16_t = FixPoint1616_t */
        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);

        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;

        /* Round Cal Distance to Whole Number.
         * Note that the cal distance is in mm, therefore no resolution is lost.*/
         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;

         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;

        /* Apply the calculated offset */
        if (Status == VL53L0_ERROR_NONE) {
            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);
            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);
        }

    }

    LOG_FUNCTION_END(Status);
    return Status;
}
```


Overlapping Code:
```
_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,
FixPoint1616_t CalDistanceMilliMeter,
int32_t* pOffsetMicroMeter) {
VL53L0_Error Status = VL53L0_ERROR_NONE;
uint16_t sum_ranging = 0;
FixPoint1616_t total_count = 0;
VL53L0_RangingMeasurementData_t RangingMeasurementData;
FixPoint1616_t StoredMeanRange;
uint32_t StoredMeanRangeAsInt;
VL53L0_DeviceParameters_t CurrentParameters;
uint32_t CalDistanceAsInt_mm;
int meas = 0;
LOG_FUNCTION_START("");
if (CalDistanceMilliMeter<=0) {
Status = VL53L0_ERROR_INVALID_PARAMS;
}
if (Status == VL53L0_ERROR_NONE) {
VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);
}
/* Perform 50 measurements and compute the averages */
if (Status == VL53L0_ERROR_NONE) {
sum_ranging = 0;
total_count = 0;
for(meas=0;meas<50;meas++)
{
Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);
if (Status != VL53L0_ERROR_NONE) {
break;
}
/* The range is valid when RangeStatus = 0 */
if (RangingMeasurementData.RangeStatus == 0) {
sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;
total_count = total_count + 1;
}
}
if (total_count == 0) {
/* no valid values found */
Status = VL53L0_ERROR_RANGE_ERROR;
}
}
if (Status == VL53L0_ERROR_NONE) {
/* FixPoint1616_t / uint16_t = FixPoint1616_t */
StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);
StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;
/* Round Cal Distance to Whole Number.
* Note that the cal distance is in mm, therefore no resolution is lost.*/
CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;
*pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;
/* Apply the calculated offset */
if (Status == VL53L0_ERROR_NONE) {
VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);
Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);
}
}
LOG_FUNC
```
<Overlap Ratio: 0.9783728115345005>

---

--- 176 --
Question ID: 2fd8c1a81231480b907abbc4ae86eea3f771c31a_3
Original Code:
```
UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)
    ParityError(pReadIoPort, pLsr);

  if (RAND()%2 > 0)
    FrameError(pReadIoPort, pLsr);

  return (UCHAR)RAND();
}
```


Overlapping Code:
```
ageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)
ParityError(pReadIoPort, pLsr);
if (RAND()%2 > 0)
FrameError
```
<Overlap Ratio: 0.7898832684824902>

---

--- 177 --
Question ID: 336b06586c00d14f8cfa7f189181d6dd35b54f08_0
Original Code:
```
int olio_socket_create(olio_socket * sock)
{
  sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);
  if (sock->socket < 0)
    return 1;
  if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) != 0)
    return 1;

  SO_KEEPALIVE
SO_REUSEADDR

}
```


Overlapping Code:
```
ket * sock)
{
sock->socket = socket(PF_INET, SOCK_STREAM|SOCK_DGRAM, 0);
if (sock->socket < 0)
return 1;
if (fcntl(sock->socket, F_SETFL, O_NONBLOCK) 
```
<Overlap Ratio: 0.6696428571428571>

---

--- 178 --
Question ID: 9c42be634291d497602a530f758d2e21569bf53a_5
Original Code:
```
char* inputEmail(){
        static char typedEmail[SHORT_STRING_SIZE];
        scanf(" %[^\n]%*c",typedEmail);
        while (checkEmail(typedEmail)==0) {
                printf("\t\tThat's not an email. Please type in another email: ");
                scanf(" %[^\n]%*c",typedEmail);
        }
        int n=strlen(typedEmail);
        for (int i=0; i<n;) {
                if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {
                        for (int j=i+1; j<n; j++) {
                                typedEmail[j]=typedEmail[j+1];
                        }
                        n--;
                } else i++;
        }
        return typedEmail;
}
```


Overlapping Code:
```

static char typedEmail[SHORT_STRING_SIZE];
scanf(" %[^\n]%*c",typedEmail);
while (checkEmail(typedEmail)==0) {
printf("\t\tThat's not an email. Please type in another email: ");
scanf(" %[^\n]%*c",typedEmail);
}
int n=strlen(typedEmail);
for (int i=0; i<n;) {
if ((typedEmail[i]==' ') && (typedEmail[i+1]==' ')) {
for (int j=i+1; j<n; j++) {
typedEmail[j]=typedEmail[j+1];
}
n--;
} else i++;
}
retur
```
<Overlap Ratio: 0.9216589861751152>

---

--- 179 --
Question ID: c8f4fd03545e3ae97891921e1d8c918d317db6a6_0
Original Code:
```
char* get_end(char *p)
{
	if (!p) return p;
	char c = *p;
	if (('p' <= c) && (c <= 'z'))
		return p + 1;
	else switch (c)
	{
	case 'N':	return get_end(p + 1);
	case 'C':
	case 'D':
	case 'E':
	case 'I':	return get_end(get_end(p + 1));
	}
	return NULL;
}
```


Overlapping Code:
```
 (!p) return p;
char c = *p;
if (('p' <= c) && (c <= 'z'))
return p + 1;
else switch (c)
{
case 'N': return get_end(p + 1);
case 'C':
case 'D':
case 'E':
case 'I': return get_end(get_end(p + 1));
}
re
```
<Overlap Ratio: 0.8368200836820083>

---

--- 180 --
Question ID: 32040ace00ea2431a18428dca5c34c0c4ebde10c_3
Original Code:
```
int hypfs_vm_create_files(struct dentry *root)
{
	struct dentry *dir, *file;
	struct diag2fc_data *data;
	unsigned int count = 0;
	int rc, i;

	data = diag2fc_store(guest_query, &count, 0);
	if (IS_ERR(data))
		return PTR_ERR(data);

	/* Hpervisor Info */
	dir = hypfs_mkdir(root, "hyp");
	if (IS_ERR(dir)) {
		rc = PTR_ERR(dir);
		goto failed;
	}
	file = hypfs_create_str(dir, "type", "z/VM Hypervisor");
	if (IS_ERR(file)) {
		rc = PTR_ERR(file);
		goto failed;
	}

	/* physical cpus */
	dir = hypfs_mkdir(root, "cpus");
	if (IS_ERR(dir)) {
		rc = PTR_ERR(dir);
		goto failed;
	}
	file = hypfs_create_u64(dir, "count", data->lcpus);
	if (IS_ERR(file)) {
		rc = PTR_ERR(file);
		goto failed;
	}

	/* guests */
	dir = hypfs_mkdir(root, "systems");
	if (IS_ERR(dir)) {
		rc = PTR_ERR(dir);
		goto failed;
	}

	for (i = 0; i < count; i++) {
		rc = hpyfs_vm_create_guest(dir, &(data[i]));
		if (rc)
			goto failed;
	}
	diag2fc_free(data);
	return 0;

failed:
	diag2fc_free(data);
	return rc;
}
```


Overlapping Code:
```
hypfs_vm_create_files(struct dentry *root)
{
struct dentry *dir, *file;
struct diag2fc_data *data;
unsigned int count = 0;
int rc, i;
data = diag2fc_store(guest_query, &count, 0);
if (IS_ERR(data))
return PTR_ERR(data);
/* Hpervisor Info */
dir = hypfs_mkdir(root, "hyp");
if (IS_ERR(dir)) {
rc = PTR_ERR(dir);
goto failed;
}
file = hypfs_create_str(dir, "type", "z/VM Hypervisor");
if (IS_ERR(file)) {
rc = PTR_ERR(file);
goto failed;
}
/* physical cpus */
dir = hypfs_mkdir(root, "cpus");
if (IS_ERR(dir)) {
rc = PTR_ERR(dir);
goto failed;
}
file = hypfs_create_u64(dir, "count", data->lcpus);
if (IS_ERR(file)) {
rc = PTR_ERR(file);
goto failed;
}
/* guests */
dir = hypfs_mkdir(root, "systems");
if (IS_ERR(dir)) {
rc = PTR_ERR(dir);
goto failed;
}
for (i = 0; i < count; i++) {
rc = hpyfs_vm_create_guest(dir, &(data[i]));
if (rc)
goto failed;
}
diag2fc_free(data);
return 0;
failed:
diag2fc_fre
```
<Overlap Ratio: 0.972972972972973>

---

--- 181 --
Question ID: a49eb7146e56465cb03867f5af5bd5db3686b85e_1
Original Code:
```
const std::string AddNode(const std::string label)
    {
        std::string name = "name" + std::to_string(NodeCounter);
        Dot << "\"" << name << "\" [\n"
               "label = " << "\"<f0> " << label << "\"\n"
               "shape = \"record\"\n"
               "];" << std::endl;
        NodeCounter += 1;
        return name;
    }
```


Overlapping Code:
```
st std::string label)
{
std::string name = "name" + std::to_string(NodeCounter);
Dot << "\"" << name << "\" [\n"
"label = " << "\"<f0> " << label << "\"\n"
"shape = \"record\"\n"
"];" << std::endl;
No
```
<Overlap Ratio: 0.7722007722007722>

---

--- 182 --
Question ID: e7ec6e86c60a44ef3c227784777a281297d77697_5
Original Code:
```
static void print_element_names(xmlDoc *doc, xmlNode * a_node)
{
  xmlNode *cur_node = NULL;
  xmlAttr *cur_attr = NULL;
  xmlChar *attr;
  
  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {
    if (cur_node->type == XML_ELEMENT_NODE) {
      Log(DEBUG,"node type: Element, name: %s, VALUE %s",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));
    }
    print_element_names(doc, cur_node->children);
  }
}
```


Overlapping Code:
```
t_names(xmlDoc *doc, xmlNode * a_node)
{
xmlNode *cur_node = NULL;
xmlAttr *cur_attr = NULL;
xmlChar *attr;

for (cur_node = a_node; cur_node; cur_node = cur_node->next) {
if (cur_node->type == XML_ELEMENT_NODE) {
Log(DEBUG,"node type: Element, name: %s, VALUE %s",cur_node->name, xmlNodeListGetString(doc, cur_node->xmlChildrenNode, 1));
}
print_ele
```
<Overlap Ratio: 0.8454106280193237>

---

--- 183 --
Question ID: ab976c859304a6318dd57f177fea481456397267_2
Original Code:
```
static struct allocator *find_allocator(const struct allocator_vtable *vtable)
{
	/* Loop through allocators in list */
	struct allocator *ap = head.next;
	while (ap->next != NULL) {
		/* Exit now if this is the allocator we are looking for */
		if (ap->vtable == vtable)
			return ap;

		/* Check next allocator in list */
		ap = ap->next;
	}

	/* Create new allocator */
	ap = new_allocator(vtable);
	if (!ap)
		return NULL;

	/* Add allocator to end of list */
	ap->next = &tail;
	ap->prev = tail.prev;
	tail.prev->next = ap;
	tail.prev = ap;
	return ap;
}
```


Overlapping Code:
```
t struct allocator_vtable *vtable)
{
/* Loop through allocators in list */
struct allocator *ap = head.next;
while (ap->next != NULL) {
/* Exit now if this is the allocator we are looking for */
if (ap->vtable == vtable)
return ap;
/* Check next allocator in list */
ap = ap->next;
}
/* Create new allocator */
ap = new_allocator(vtable);
if (!ap)
return NULL;
/* Add allocator to end of list */
ap->next = &tail;
ap->prev = tail.prev;
tail.prev->nex
```
<Overlap Ratio: 0.8490566037735849>

---

--- 184 --
Question ID: 38a035809c1e923864c05d95e9fa6f60df89ea89_9
Original Code:
```
static void destroyDepsInfo(const vdexDeps_010 *pVdexDeps) {
  for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {
    free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);
    free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);
    free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);
    free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);
    free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);
    free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);
    free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);
  }
  free((void *)pVdexDeps->pVdexDepData);
  free((void *)pVdexDeps);
}
```


Overlapping Code:
```
DepsInfo(const vdexDeps_010 *pVdexDeps) {
for (u4 i = 0; i < pVdexDeps->numberOfDexFiles; ++i) {
free((void *)pVdexDeps->pVdexDepData[i].extraStrings.strings);
free((void *)pVdexDeps->pVdexDepData[i].assignTypeSets.pVdexDepSets);
free((void *)pVdexDeps->pVdexDepData[i].unassignTypeSets.pVdexDepSets);
free((void *)pVdexDeps->pVdexDepData[i].classes.pVdexDepClasses);
free((void *)pVdexDeps->pVdexDepData[i].fields.pVdexDepFields);
free((void *)pVdexDeps->pVdexDepData[i].methods.pVdexDepMethods);
free((void *)pVdexDeps->pVdexDepData[i].unvfyClasses.pVdexDepUnvfyClasses);
}
free((void *)pVdexDeps->pVdexDepData);
free((void *)pVdexD
```
<Overlap Ratio: 0.9606060606060606>

---

--- 185 --
Question ID: 5706fdf060ecdef7ef541b71b9c1ca2c95dd2181_16
Original Code:
```
ssh_string pki_signature_to_blob(const ssh_signature sig)
{
    ssh_string sig_blob = NULL;

    switch(sig->type) {
        case SSH_KEYTYPE_DSS:
            sig_blob = pki_dsa_signature_to_blob(sig);
            break;
        case SSH_KEYTYPE_RSA:
        case SSH_KEYTYPE_RSA1:
            sig_blob = ssh_string_copy(sig->rsa_sig);
            break;
        case SSH_KEYTYPE_ECDSA:
#ifdef HAVE_OPENSSL_ECC
        {
            ssh_string r;
            ssh_string s;
            ssh_buffer b;
            int rc;

            b = ssh_buffer_new();
            if (b == NULL) {
                return NULL;
            }

            r = make_bignum_string(sig->ecdsa_sig->r);
            if (r == NULL) {
                ssh_buffer_free(b);
                return NULL;
            }
            rc = buffer_add_ssh_string(b, r);
            ssh_string_free(r);
            if (rc < 0) {
                ssh_buffer_free(b);
                return NULL;
            }

            s = make_bignum_string(sig->ecdsa_sig->s);
            if (s == NULL) {
                ssh_buffer_free(b);
                return NULL;
            }
            rc = buffer_add_ssh_string(b, s);
            ssh_string_free(s);
            if (rc < 0) {
                ssh_buffer_free(b);
                return NULL;
            }

            sig_blob = ssh_string_new(buffer_get_rest_len(b));
            if (sig_blob == NULL) {
                ssh_buffer_free(b);
                return NULL;
            }

            ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));
            ssh_buffer_free(b);
            break;
        }
#endif
        case SSH_KEYTYPE_ED25519:
            sig_blob = pki_ed25519_sig_to_blob(sig);
            break;
        default:
        case SSH_KEYTYPE_UNKNOWN:
            ssh_pki_log("Unknown signature key type: %s", sig->type_c);
            return NULL;
    }

    return sig_blob;
}
```


Overlapping Code:
```
sh_string pki_signature_to_blob(const ssh_signature sig)
{
ssh_string sig_blob = NULL;
switch(sig->type) {
case SSH_KEYTYPE_DSS:
sig_blob = pki_dsa_signature_to_blob(sig);
break;
case SSH_KEYTYPE_RSA:
case SSH_KEYTYPE_RSA1:
sig_blob = ssh_string_copy(sig->rsa_sig);
break;
case SSH_KEYTYPE_ECDSA:
#ifdef HAVE_OPENSSL_ECC
{
ssh_string r;
ssh_string s;
ssh_buffer b;
int rc;
b = ssh_buffer_new();
if (b == NULL) {
return NULL;
}
r = make_bignum_string(sig->ecdsa_sig->r);
if (r == NULL) {
ssh_buffer_free(b);
return NULL;
}
rc = buffer_add_ssh_string(b, r);
ssh_string_free(r);
if (rc < 0) {
ssh_buffer_free(b);
return NULL;
}
s = make_bignum_string(sig->ecdsa_sig->s);
if (s == NULL) {
ssh_buffer_free(b);
return NULL;
}
rc = buffer_add_ssh_string(b, s);
ssh_string_free(s);
if (rc < 0) {
ssh_buffer_free(b);
return NULL;
}
sig_blob = ssh_string_new(buffer_get_rest_len(b));
if (sig_blob == NULL) {
ssh_buffer_free(b);
return NULL;
}
ssh_string_fill(sig_blob, buffer_get_rest(b), buffer_get_rest_len(b));
ssh_buffer_free(b);
break;
}
#endif
case SSH_KEYTYPE_ED25519:
sig_blob = pki_ed25519_sig_to_blob(sig);
break;
default:
case SSH_KEYTYPE_UNKNOWN:
ssh_pki_log("Unknown signature key type: %s", sig->type_c);
return NULL;
}
ret
```
<Overlap Ratio: 0.9871279163314561>

---

--- 186 --
Question ID: 5d9c804e9b3caeb80be46cb8cb59b21ad4f48d66_18
Original Code:
```
static int
checkaddfile (file, repository, tag, options, rcsnode)
    char *file;
    char *repository;
    char *tag;
    char *options;
    RCSNode **rcsnode;
{
    char rcs[PATH_MAX];
    char fname[PATH_MAX];
    mode_t omask;
    int retcode = 0;
    int newfile = 0;
    RCSNode *rcsfile = NULL;

    if (tag)
    {
        (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	if (! isreadable (rcs))
	{
	    (void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcs);;
	    (void) umask (omask);
	    (void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
			    RCSEXT);
	}
    }
    else
	locate_rcs (file, repository, rcs);

    if (isreadable(rcs))
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char oldfile[PATH_MAX];
	char *rev;

	if ((rcsfile = *rcsnode) == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    return (1);
	}

	if (tag == NULL)
	{
	    /* we are adding on the trunk, so move the file out of the
	       Attic. */
	    strcpy (oldfile, rcs);
	    sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	    
	    if (strcmp (oldfile, rcs) == 0
		|| CVS_RENAME (oldfile, rcs) != 0
		|| isreadable (oldfile)
		|| !isreadable (rcs))
	    {
		error (0, 0, "failed to move `%s' out of the attic.",
		       file);
		return (1);
	    }
	    free (rcsfile->path);
	    rcsfile->path = xstrdup (rcs);
	}

	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
	/* and lock it */
	if (lock_RCS (file, rcsfile, rev, repository)) {
	    error (0, 0, "cannot lock `%s'.", rcs);
	    free (rev);
	    return (1);
	}

	free (rev);
    } else {
	/* this is the first time we have ever seen this file; create
	   an rcs file.  */
	run_setup ("%s%s -x,v/ -i", Rcsbin, RCS);

	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
	    run_args ("-t%s/%s%s", CVSADM, file, CVSEXT_LOG);

	/* Set RCS keyword expansion options.  */
	if (options && options[0] == '-' && options[1] == 'k')
	    run_arg (options);
	run_arg (rcs);
	if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
	{
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "could not create %s", rcs);
	    return (1);
	}
	newfile = 1;
    }

    /* when adding a file for the first time, and using a tag, we need
       to create a dead revision on the trunk.  */
    if (tag && newfile)
    {
	char *tmp;

	/* move the new file out of the way. */
	(void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	rename_file (file, fname);
	copy_file (DEVNULL, file);

	tmp = xmalloc (strlen (file) + strlen (tag) + 80);
	/* commit a dead revision. */
	(void) sprintf (tmp, "file %s was initially added on branch %s.",
			file, tag);
	retcode = RCS_checkin (rcs, NULL, tmp, NULL,
			       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
	free (tmp);
	if (retcode != 0)
	{
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "could not create initial dead revision %s", rcs);
	    return (1);
	}

	/* put the new file back where it was */
	rename_file (fname, file);

	assert (rcsfile == NULL);
	rcsfile = RCS_parse (file, repository);
	if (rcsfile == NULL)
	{
	    error (0, 0, "could not read %s", rcs);
	    return (1);
	}
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}

	/* and lock it once again. */
	if (lock_RCS (file, rcsfile, NULL, repository)) {
	    error (0, 0, "cannot lock `%s'.", rcs);
	    return (1);
	}
    }

    if (tag != NULL)
    {
	/* when adding with a tag, we need to stub a branch, if it
	   doesn't already exist.  */

	if (rcsfile == NULL)
	{
	    if (rcsnode != NULL && *rcsnode != NULL)
		rcsfile = *rcsnode;
	    else
	    {
		rcsfile = RCS_parse (file, repository);
		if (rcsfile == NULL)
		{
		    error (0, 0, "could not read %s", rcs);
		    return (1);
		}
	    }
	}

	if (!RCS_nodeisbranch (rcsfile, tag)) {
	    /* branch does not exist.  Stub it.  */
	    char *head;
	    char *magicrev;
	    
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcsfile, head);

	    retcode = RCS_settag (rcsfile, tag, magicrev);

	    free (head);
	    free (magicrev);

	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not stub branch %s for %s", tag, rcs);
		return (1);
	    }
	}
	else
	{
	    /* lock the branch. (stubbed branches need not be locked.)  */
	    if (lock_RCS (file, rcsfile, NULL, repository)) {
		error (0, 0, "cannot lock `%s'.", rcs);
		return (1);
	    }
	} 

	if (rcsnode && *rcsnode != rcsfile)
	{
	    freercsnode(rcsnode);
	    *rcsnode = rcsfile;
	}
    }

    fileattr_newfile (file);

    fix_rcs_modes (rcs, file);
    return (0);
}
```


Overlapping Code:
```
ddfile (file, repository, tag, options, rcsnode)
char *file;
char *repository;
char *tag;
char *options;
RCSNode **rcsnode;
{
char rcs[PATH_MAX];
char fname[PATH_MAX];
mode_t omask;
int retcode = 0;
int newfile = 0;
RCSNode *rcsfile = NULL;
if (tag)
{
(void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
if (! isreadable (rcs))
{
(void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
omask = umask (cvsumask);
if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
error (1, errno, "cannot make directory `%s'", rcs);;
(void) umask (omask);
(void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
RCSEXT);
}
}
else
locate_rcs (file, repository, rcs);
if (isreadable(rcs))
{
/* file has existed in the past. Prepare to resurrect. */
char oldfile[PATH_MAX];
char *rev;
if ((rcsfile = *rcsnode) == NULL)
{
error (0, 0, "could not find parsed rcsfile %s", file);
return (1);
}
if (tag == NULL)
{
/* we are adding on the trunk, so move the file out of the
Attic. */
strcpy (oldfile, rcs);
sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);

if (strcmp (oldfile, rcs) == 0
|| CVS_RENAME (oldfile, rcs) != 0
|| isreadable (oldfile)
|| !isreadable (rcs))
{
error (0, 0, "failed to move `%s' out of the attic.",
file);
return (1);
}
free (rcsfile->path);
rcsfile->path = xstrdup (rcs);
}
rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
/* and lock it */
if (lock_RCS (file, rcsfile, rev, repository)) {
error (0, 0, "cannot lock `%s'.", rcs);
free (rev);
return (1);
}
free (rev);
} else {
/* this is the first time we have ever seen this file; create
an rcs file. */
run_setup ("%s%s -x,v/ -i", Rcsbin, RCS);
(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
/* If the file does not exist, no big deal. In particular, the
server does not (yet at least) create CVSEXT_LOG files. */
if (isfile (fname))
run_args ("-t%s/%s%s", CVSADM, file, CVSEXT_LOG);
/* Set RCS keyword expansion options. */
if (options && options[0] == '-' && options[1] == 'k')
run_arg (options);
run_arg (rcs);
if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
{
error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
"could not crea
```
<Overlap Ratio: 0.9741730856366108>

---

--- 187 --
Question ID: a5c7ff8abd59458ac67e174b927373247ef12d87_0
Original Code:
```
void cwrt_task(void *pvParameter)
{
    configASSERT(configUSE_RECURSIVE_MUTEXES);
    vTaskDelay(10);
    rt_init();
	cwrt_setup();
    unsigned long last = 0;
    while(1) {
		cwrt_process(&last);
        unsigned long now = upTime();
        if (now < last || now - last > 50) {
            taskYIELD();
            last = now;
        }
    }
}
```


Overlapping Code:
```
arameter)
{
configASSERT(configUSE_RECURSIVE_MUTEXES);
vTaskDelay(10);
rt_init();
cwrt_setup();
unsigned long last = 0;
while(1) {
cwrt_process(&last);
unsigned long now = upTime();
if (now < last || 
```
<Overlap Ratio: 0.7326007326007326>

---

--- 188 --
Question ID: fc0a92ef6cd26feaa8c872f843b1d960bf8f2e90_4
Original Code:
```
void peturb(double *lvParam) {
	//printf("Starting peturb...\n");

	const double SIGMA = 0.01;
	//printf("lvParam_before %f, %f, %f\n", lvParam[0], lvParam[1], lvParam[2]);
	lvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));
	lvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));
	lvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));
	//printf("lvParam_after  %f, %f, %f\n", lvParam[0], lvParam[1], lvParam[2]);
}
```


Overlapping Code:
```
eturb(double *lvParam) {
//printf("Starting peturb...\n");
const double SIGMA = 0.01;
//printf("lvParam_before %f, %f, %f\n", lvParam[0], lvParam[1], lvParam[2]);
lvParam[0] = lvParam[0] * exp(gsl_ran_gaussian(r, SIGMA));
lvParam[1] = lvParam[1] * exp(gsl_ran_gaussian(r, SIGMA));
lvParam[2] = lvParam[2] * exp(gsl_ran_gaussian(r, SIGMA));
//printf("lvParam_after %f, %f, %f\n", lvParam[0], lvParam[1
```
<Overlap Ratio: 0.9456264775413712>

---

--- 189 --
Question ID: 751529a0216635b6d41da94bb4662327459fd5b6_0
Original Code:
```
namespace MediaPlayer
{
    /// Service offer player widget for video content.
    ///
    class ServiceInterface : public QObject, public Foundation::ServiceInterface 
    {
        Q_OBJECT
    public:
        virtual ~ServiceInterface() {};
    public slots:
        virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;

        /// Gives player widget playing given media in eternal loop.
        /// If player is asked more than once for same url only one instance of player 
        /// widget is created and returned.
        /// @param url url of video content
        /// @return pointer to player widget if success otherwise return 0.
        virtual QWidget* GetPlayerWidget(const QString &url) = 0;

        /// Delete existing video widget associated with given url.
        /// Be sure that you are not using the player widget after you have called this method.
        /// @param url url of video content
        virtual void DeletePlayerWidget(const QString &url) = 0;
    }
```


Overlapping Code:
```
Service offer player widget for video content.
///
class ServiceInterface : public QObject, public Foundation::ServiceInterface 
{
Q_OBJECT
public:
virtual ~ServiceInterface() {};
public slots:
virtual bool IsMimeTypeSupported(const QString &mime_type) = 0;
/// Gives player widget playing given media in eternal loop.
/// If player is asked more than once for same url only one instance of player 
/// widget is created and returned.
/// @param url url of video content
/// @return pointer to player widget if success otherwise return 0.
virtual QWidget* GetPlayerWidget(const QString &url) = 0;
/// Delete existing video widget associated with given url.
/// Be sure that you are not using the player widget after you have called this method.
/// @param url url of video content
virtual void Delete
```
<Overlap Ratio: 0.922722029988466>

---

--- 190 --
Question ID: 0cbfbbd3294da2ab5ef285bffc8cf9b09e9e1932_3
Original Code:
```
int make_FOOD(BOX** b, SNAKE* left, SNAKE* right)
{
    *b = (BOX*) malloc(sizeof(BOX));
    int startx,starty;

    // we don't want food to be placed in the snake
    while(TRUE)
    {
        startx = 2 * (rand() % (COLS / 2 - 2)) + 1;
        starty = rand() % (LINES - 2 - 2) + 1;
        if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))
            break;
    }
   
    (*b)->startx = startx;
    (*b)->starty = starty;
    (*b)->width = 2;
    (*b)->height = 1;
    (*b)->content = ' ' | A_REVERSE;
    return 0;
}
```


Overlapping Code:
```
** b, SNAKE* left, SNAKE* right)
{
*b = (BOX*) malloc(sizeof(BOX));
int startx,starty;
// we don't want food to be placed in the snake
while(TRUE)
{
startx = 2 * (rand() % (COLS / 2 - 2)) + 1;
starty = rand() % (LINES - 2 - 2) + 1;
if(!check_SNAKE(left, startx, starty) && !check_SNAKE(right, startx, starty))
break;
}

(*b)->startx = startx;
(*b)->starty = starty;
(*b)->width = 2;
(*b)->height = 1;
(*b)->content = ' ' | A_RE
```
<Overlap Ratio: 0.9242424242424242>

---

--- 191 --
Question ID: 018df08a8d269752e6dbbfd82436fd59cb429831_21
Original Code:
```
static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}
```


Overlapping Code:
```
static int yy_init_globals (void)
{
/* Initialization is the same as for the non-reentrant scanner.
* This function is called from yylex_destroy(), so don't allocate here.
*/
(yy_buffer_stack) = 0;
(yy_buffer_stack_top) = 0;
(yy_buffer_stack_max) = 0;
(yy_c_buf_p) = (char *) 0;
(yy_init) = 0;
(yy_start) = 0;
/* Defined in main.c */
#ifdef YY_STDINIT
yyin = stdin;
yyout = stdout;
#else
yyin = (FILE *) 0;
yyout = (FILE *) 0;
#endif
/* For future reference: Set errno on error, since we are called by
* yylex_init()
*/
return 0;
}
```
<Overlap Ratio: 1.0>

---

--- 192 --
Question ID: 6830c84fa7de231061b7cbc7a0e6b49a89f28bd3_3
Original Code:
```
static value redirect( value s ) {
	mcontext *c = CONTEXT();
	val_check(s,string);
	HEADERS_NOT_SENT("Redirection");
	ap_table_set(c->r->headers_out,"Location",val_string(s));
	c->r->status = REDIRECT;
	return val_true;
}
```


Overlapping Code:
```
rect( value s ) {
mcontext *c = CONTEXT();
val_check(s,string);
HEADERS_NOT_SENT("Redirection");
ap_table_set(c->r->headers_out,"Location",val_string(s));
c->r->status =
```
<Overlap Ratio: 0.786046511627907>

---

--- 193 --
Question ID: 92f861d3700ce961f7d437bd91b58ed41318148d_8
Original Code:
```
void crc16_final(crc16_ctx *inCtx, unsigned short *outResult )
{
    inCtx->crc = update_crc16(inCtx->crc, 0);
    inCtx->crc = update_crc16(inCtx->crc, 0);
    *outResult = inCtx->crc & 0xffffu;
}
```


Overlapping Code:
```
6_final(crc16_ctx *inCtx, unsigned short *outResult )
{
inCtx->crc = update_crc16(inCtx->crc, 0);
inCtx->crc = update_crc16(inCtx->crc, 0);
*outResult = inCtx->crc & 0xfff
```
<Overlap Ratio: 0.9243243243243243>

---

--- 194 --
Question ID: b18178fdf4a5eaa7c8a706b2e32c3770a4db863c_0
Original Code:
```
namespace AvalonTools {
static int avalonSSSBits = 0x007FFF;
static int avalonSimilarityBits = 0xF07FFF;
std::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);
void getAvalonCountFP(const RDKit::ROMol &mol,
                      RDKit::SparseIntVect<boost::uint32_t> &res,
                      unsigned int nBits = 512, bool isQuery = false,
                      bool resetVect = true,
                      unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,
                 unsigned int nBits = 512, bool isQuery = false,
                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,
                 unsigned int nBits = 512, bool isQuery = false,
                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
unsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);

std::string getCanonSmiles(const std::string &data, bool isSmiles,
                           int flags = -1);
void getAvalonCountFP(const std::string &data, bool isSmiles,
                      RDKit::SparseIntVect<boost::uint32_t> &res,
                      unsigned int nBits = 512, bool isQuery = false,
                      unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,
                 unsigned int nBits = 512, bool isQuery = false,
                 bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const std::string &data, bool isSmiles,
                 std::vector<boost::uint32_t> &res, unsigned int nBits = 512,
                 bool isQuery = false, bool resetVect = true,
                 unsigned int bitFlags = avalonSSSBits);

std::string set2DCoords(const std::string &data, bool isSmiles);

int initCheckMol(const std::string &optString);
RDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);
RDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);
std::pair<std::string, int> checkMolString(const std::string &data,
                                           bool isSmiles);
std::string getCheckMolLog();

void closeCheckMolFiles();
}
```


Overlapping Code:
```
static int avalonSSSBits = 0x007FFF;
static int avalonSimilarityBits = 0xF07FFF;
std::string getCanonSmiles(RDKit::ROMol &mol, int flags = -1);
void getAvalonCountFP(const RDKit::ROMol &mol,
RDKit::SparseIntVect<boost::uint32_t> &res,
unsigned int nBits = 512, bool isQuery = false,
bool resetVect = true,
unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const RDKit::ROMol &mol, ExplicitBitVect &res,
unsigned int nBits = 512, bool isQuery = false,
bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const RDKit::ROMol &mol, std::vector<boost::uint32_t> &res,
unsigned int nBits = 512, bool isQuery = false,
bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
unsigned int set2DCoords(RDKit::ROMol &mol, bool clearConfs = true);
std::string getCanonSmiles(const std::string &data, bool isSmiles,
int flags = -1);
void getAvalonCountFP(const std::string &data, bool isSmiles,
RDKit::SparseIntVect<boost::uint32_t> &res,
unsigned int nBits = 512, bool isQuery = false,
unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const std::string &data, bool isSmiles, ExplicitBitVect &res,
unsigned int nBits = 512, bool isQuery = false,
bool resetVect = true, unsigned int bitFlags = avalonSSSBits);
void getAvalonFP(const std::string &data, bool isSmiles,
std::vector<boost::uint32_t> &res, unsigned int nBits = 512,
bool isQuery = false, bool resetVect = true,
unsigned int bitFlags = avalonSSSBits);
std::string set2DCoords(const std::string &data, bool isSmiles);
int initCheckMol(const std::string &optString);
RDKit::ROMOL_SPTR checkMol(int &errors, RDKit::ROMol &inMol);
RDKit::ROMOL_SPTR checkMol(int &errors, const std::string &data, bool isSmiles);
std::pair<std::string, int> checkMolString(const std::string &data,
bool isSmiles);
std::string
```
<Overlap Ratio: 0.9620523784072689>

---

--- 195 --
Question ID: 306725ca1144ce776c63feadc8986fa57c557276_7
Original Code:
```
void	q8gr_draw_frame(int x, int y, int sx, int sy, int shadow_type,
			int code, const char *str, void *p)
{
    int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;
    int bg =       Q8GR_PALETTE_BACKGROUND;

    draw_normal_box(x, y, sx, sy, shadow_type);

    q8gr_puts(x+1, y, fg, bg, code, str);
}
```


Overlapping Code:
```
_draw_frame(int x, int y, int sx, int sy, int shadow_type,
int code, const char *str, void *p)
{
int fg = (p) ? Q8GR_PALETTE_FOREGROUND : Q8GR_PALETTE_WHITE;
int bg = Q8GR_PALETTE_BACKGROUND;
draw_normal_box(x, y, sx, sy, shadow_type);
q8gr_puts(x+1, y, f
```
<Overlap Ratio: 0.897887323943662>

---

--- 196 --
Question ID: 8b37518f8cee6b7f60010949cbe78d9edc3fe978_0
Original Code:
```
class RenderManager {
public:
    /**
     * The constructor.
     * @param applicationContext context to bind to this RenderManager
     * @param windowManager user provided manager used for getting window render
     */
    RenderManager(ApplicationContext &applicationContext,
                  WindowManager &windowManager);

    /**
     * Check if RenderManager has been successfully initialized.
     * This usually means if the window has been successfully created.
     * @return whether the constructor failed or not
     */
    bool initialized();
    
    /**
     * Switch current window render (and reload it)
     * @param window window to get render for
     * @return return code. 0 on success, -1 on error
     */
    int switchWindow(Window &window);

    /**
     * Updates internally-held window dimensions.
     * On mobile devices this method is triggered by screen rotation.
     * Note that this method does not change the size of the window.
     * @param width new width of the window
     * @param height new height of the window
     */
    void resize(uint32_t width, uint32_t height);

    /**
     * Render current window render.
     * This is called every tick.
     */
    void render();

    /**
     * The destructor.
     * If SDL2 is used, this destructor destroys the physical window.
     */
    ~RenderManager();

private:
    int initWindow();
    int initGL();

private:
    bool m_initialized = false;
    ApplicationContext &m_applicationContext;
    WindowManager &m_windowManager;
    RenderContext m_renderContext;

#ifdef USES_SDL
    SDL_Window *m_sdlWindow = nullptr;
    SDL_GL_Context *m_sdlContext = nullptr;
#endif // USES_SDL

    Window *m_currentWindow = nullptr;
    WindowRender *m_windowRender = nullptr;
}
```


Overlapping Code:
```
ic:
/**
* The constructor.
* @param applicationContext context to bind to this RenderManager
* @param windowManager user provided manager used for getting window render
*/
RenderManager(ApplicationContext &applicationContext,
WindowManager &windowManager);
/**
* Check if RenderManager has been successfully initialized.
* This usually means if the window has been successfully created.
* @return whether the constructor failed or not
*/
bool initialized();

/**
* Switch current window render (and reload it)
* @param window window to get render for
* @return return code. 0 on success, -1 on error
*/
int switchWindow(Window &window);
/**
* Updates internally-held window dimensions.
* On mobile devices this method is triggered by screen rotation.
* Note that this method does not change the size of the window.
* @param width new width of the window
* @param height new height of the window
*/
void resize(uint32_t width, uint32_t height);
/**
* Render current window render.
* This is called every tick.
*/
void render();
/**
* The destructor.
* If SDL2 is used, this destructor destroys the physical window.
*/
~RenderManager();
private:
int initWindow();
int initGL();
private:
bool m_initialized = false;
ApplicationContext &m_applicationContext;
WindowManager &m_windowManager;
RenderContext m_renderContext;
#ifdef USES_SDL
SDL_Window *m_sdlWindow = nullptr;
SDL_GL_Context *m_sdlContext = nullptr;
#endif // USES_SDL
Window *m_currentWindow = nullptr;
WindowRender *m_windowRender = nullpt
```
<Overlap Ratio: 0.9803921568627451>

---

--- 197 --
Question ID: cab87f5ce6d377d5686937e9025eb3782f85d79e_4
Original Code:
```
static int drv260x_parse_dt(struct device *dev,
			    struct drv260x_data *haptics)
{
	struct device_node *np = dev->of_node;
	unsigned int voltage;
	int error;

	error = of_property_read_u32(np, "mode", &haptics->mode);
	if (error) {
		dev_err(dev, "%s: No entry for mode\n", __func__);
		return error;
	}

	error = of_property_read_u32(np, "library-sel", &haptics->library);
	if (error) {
		dev_err(dev, "%s: No entry for library selection\n",
			__func__);
		return error;
	}

	error = of_property_read_u32(np, "vib-rated-mv", &voltage);
	if (!error)
		haptics->rated_voltage = drv260x_calculate_voltage(voltage);


	error = of_property_read_u32(np, "vib-overdrive-mv", &voltage);
	if (!error)
		haptics->overdrive_voltage = drv260x_calculate_voltage(voltage);

	return 0;
}
```


Overlapping Code:
```
c int drv260x_parse_dt(struct device *dev,
struct drv260x_data *haptics)
{
struct device_node *np = dev->of_node;
unsigned int voltage;
int error;
error = of_property_read_u32(np, "mode", &haptics->mode);
if (error) {
dev_err(dev, "%s: No entry for mode\n", __func__);
return error;
}
error = of_property_read_u32(np, "library-sel", &haptics->library);
if (error) {
dev_err(dev, "%s: No entry for library selection\n",
__func__);
return error;
}
error = of_property_read_u32(np, "vib-rated-mv", &voltage);
if (!error)
haptics->rated_voltage = drv260x_calculate_voltage(voltage);
error = of_property_read_u32(np, "vib-overdrive-mv", &voltage);
if (!error)
haptics->overdrive_voltage = drv260x_calculate_voltage(volta
```
<Overlap Ratio: 0.9714673913043478>

---

--- 198 --
Question ID: 4823676ad6844e731fa8b954793205d99a5fd9e0_12
Original Code:
```
static void do_power()
{
  if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))
  {
    double b = (double)AS_INTEGER(pop())->value;
    double a = (double)AS_INTEGER(pop())->value;

    push(AS_OBJECT(create_integer(pow(a, b))));
    return;
  }

  if(IS_REAL(peek(0)) && IS_REAL(peek(1)))
  {
    double b = AS_REAL(pop())->value;
    double a = AS_REAL(pop())->value;

    push(AS_OBJECT(create_real(pow(a, b))));
    return;
  }

  if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))
  {
    double b = (double)AS_INTEGER(pop())->value;
    double a = AS_REAL(pop())->value;

    push(AS_OBJECT(create_real(pow(a, b))));
    return;
  }

  if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))
  {
    double b = AS_REAL(pop())->value;
    double a = (double)AS_INTEGER(pop())->value;

    push(AS_OBJECT(create_real(pow(a, b))));
    return;
  }
}
```


Overlapping Code:
```

{
if(IS_INTEGER(peek(0)) && IS_INTEGER(peek(1)))
{
double b = (double)AS_INTEGER(pop())->value;
double a = (double)AS_INTEGER(pop())->value;
push(AS_OBJECT(create_integer(pow(a, b))));
return;
}
if(IS_REAL(peek(0)) && IS_REAL(peek(1)))
{
double b = AS_REAL(pop())->value;
double a = AS_REAL(pop())->value;
push(AS_OBJECT(create_real(pow(a, b))));
return;
}
if(IS_INTEGER(peek(0)) && IS_REAL(peek(1)))
{
double b = (double)AS_INTEGER(pop())->value;
double a = AS_REAL(pop())->value;
push(AS_OBJECT(create_real(pow(a, b))));
return;
}
if(IS_REAL(peek(0)) && IS_INTEGER(peek(1)))
{
double b = AS_REAL(pop())->value;
double a = (double)AS_INTEGER(pop())->value;
push(AS_OBJECT(create_real(pow(a, b))));
return;
```
<Overlap Ratio: 0.9645293315143247>

---

--- 199 --
Question ID: bd6433558eb0d8ef557e592dcd1761355c44422c_2
Original Code:
```
static void powerdown_cleanup(int toi_or_resume)
{
	if (!toi_or_resume)
		return;

	CLOSE_FILE(lid_file);
	CLOSE_FILE(alarm_file);
	CLOSE_FILE(epoch_file);
}
```


Overlapping Code:
```
owerdown_cleanup(int toi_or_resume)
{
if (!toi_or_resume)
return;
CLOSE_FILE(lid_file);
CLOSE_FILE(a
```
<Overlap Ratio: 0.6666666666666666>

---

--- 200 --
Question ID: fdc67a8897a4a203be3250eeed2dffb8f8aa02ed_0
Original Code:
```
Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event)
{
	register _XQEvent *prev, *qelt;
	unsigned long qe_serial = 0;
	int n;			/* time through count */

        LockDisplay(dpy);
	prev = NULL;
	for (n = 3; --n >= 0;) {
	    for (qelt = prev ? prev->next : dpy->head;
		 qelt;
		 prev = qelt, qelt = qelt->next) {
		if (qelt->event.type >= LASTEvent
                    || !(_Xevent_to_mask[qelt->event.type] & mask)) {
		    *event = qelt->event;
		    _XDeq(dpy, prev, qelt);
		    UnlockDisplay(dpy);
		    return True;
		}
	    }
	    if (prev)
		qe_serial = prev->qserial_num;
	    switch (n) {
	      case 2:
		_XEventsQueued(dpy, QueuedAfterReading);
		break;
	      case 1:
		_XFlush(dpy);
		break;
	    }
	    if (prev && prev->qserial_num != qe_serial)
		/* another thread has snatched this event */
		prev = NULL;
	}
	UnlockDisplay(dpy);
	return False;
}
```


Overlapping Code:
```
kNotMaskEvent (Display *dpy, long mask, XEvent *event)
{
register _XQEvent *prev, *qelt;
unsigned long qe_serial = 0;
int n; /* time through count */
LockDisplay(dpy);
prev = NULL;
for (n = 3; --n >= 0;) {
for (qelt = prev ? prev->next : dpy->head;
qelt;
prev = qelt, qelt = qelt->next) {
if (qelt->event.type >= LASTEvent
|| !(_Xevent_to_mask[qelt->event.type] & mask)) {
*event = qelt->event;
_XDeq(dpy, prev, qelt);
UnlockDisplay(dpy);
return True;
}
}
if (prev)
qe_serial = prev->qserial_num;
switch (n) {
case 2:
_XEventsQueued(dpy, QueuedAfterReading);
break;
case 1:
_XFlush(dpy);
break;
}
if (prev && prev->qserial_num != qe_serial)
/* another thread has snatched this event */
prev = NULL;
}
UnlockDisplay(dpy);
```
<Overlap Ratio: 0.9651474530831099>

---

--- 201 --
Question ID: 165f7a45f3f88921bc4ed5ca5698e6c5c6d26fb8_3
Original Code:
```
static int MmalGraph_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {

	int display = -1;
	static char *kwlist[] = {"display", NULL};

	if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist, &display)) {

		return -1;
	}

	if (display >= 0) {

		self->display_num = display;
	}

	return 0;
}
```


Overlapping Code:
```
_init(MmalGraphObject *self, PyObject *args, PyObject *kwds) {
int display = -1;
static char *kwlist[] = {"display", NULL};
if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist, &display)) {
return -1;
}
if (display >= 0) {
self->display_num = d
```
<Overlap Ratio: 0.8591065292096219>

---

--- 202 --
Question ID: c0399fc1ac6e4e1b2b58796cdd0ab370d0e9d37d_1
Original Code:
```
int _ArrayListSearch(ArrayList self, void* element){
    //TODO
    printf("ArrayListSearch function\n");
    return 0;
}
```


Overlapping Code:
```
rrayList self, void* element){
//TODO
printf("Arra
```
<Overlap Ratio: 0.45871559633027525>

---

--- 203 --
Question ID: 9d5918d47e841c22f3323e5b03abf87278e87845_1
Original Code:
```
static int lastIndexOf( const char *p_string, char p_search, int start_point )
{
	int loop;
    for ( loop = start_point-1; loop >= 0; -- loop )
	{
		if ( p_string[loop] == p_search )
		{
			return loop;
		}
	}
    return -1;
}
```


Overlapping Code:
```
t lastIndexOf( const char *p_string, char p_search, int start_point )
{
int loop;
for ( loop = start_point-1; loop >= 0; -- loop )
{
if ( p_string[loo
```
<Overlap Ratio: 0.7246376811594203>

---

--- 204 --
Question ID: 04dc117226c117711c4a2e30aa587c772e308908_38
Original Code:
```
CFTypeRef
IORegistryEntryCreateCFProperty(
	io_registry_entry_t	entry,
	CFStringRef		key,
        CFAllocatorRef		allocator,
	IOOptionBits   options __unused )
{
    IOReturn		kr;
    CFTypeRef		type;
    uint32_t	 	size;
    char *	 	propertiesBuffer;
    CFStringRef  	errorString;
    const char *    	cStr;
    char *	    	buffer = NULL;

    cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);
    if( !cStr) {
	CFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),
	       kCFStringEncodingMacRoman) + sizeof('\0');
        buffer = malloc( bufferSize);
        if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))
            cStr = buffer;
    }

    if( cStr)
        kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);
    else
        kr = kIOReturnError;

    if( buffer)
        free( buffer);

    if( kr != kIOReturnSuccess)
        return( NULL );

    type = (CFMutableDictionaryRef)
                        IOCFUnserialize(propertiesBuffer, allocator,
					0, &errorString);
    if (!type && errorString) {

        if ((cStr = CFStringGetCStringPtr(errorString,
					kCFStringEncodingMacRoman)))
            printf("%s\n", cStr);
	CFRelease(errorString);
    }

    // free propertiesBuffer !
    vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);

    return( type );
}
```


Overlapping Code:
```
ef
IORegistryEntryCreateCFProperty(
io_registry_entry_t entry,
CFStringRef key,
CFAllocatorRef allocator,
IOOptionBits options __unused )
{
IOReturn kr;
CFTypeRef type;
uint32_t size;
char * propertiesBuffer;
CFStringRef errorString;
const char * cStr;
char * buffer = NULL;
cStr = CFStringGetCStringPtr( key, kCFStringEncodingMacRoman);
if( !cStr) {
CFIndex bufferSize = CFStringGetMaximumSizeForEncoding( CFStringGetLength(key),
kCFStringEncodingMacRoman) + sizeof('\0');
buffer = malloc( bufferSize);
if( buffer && CFStringGetCString( key, buffer, bufferSize, kCFStringEncodingMacRoman))
cStr = buffer;
}
if( cStr)
kr = io_registry_entry_get_property(entry, (char *) cStr, &propertiesBuffer, &size);
else
kr = kIOReturnError;
if( buffer)
free( buffer);
if( kr != kIOReturnSuccess)
return( NULL );
type = (CFMutableDictionaryRef)
IOCFUnserialize(propertiesBuffer, allocator,
0, &errorString);
if (!type && errorString) {
if ((cStr = CFStringGetCStringPtr(errorString,
kCFStringEncodingMacRoman)))
printf("%s\n", cStr);
CFRelease(errorString);
}
// free propertiesBuffer !
vm_deallocate(mach_task_self(), (vm_address_t)propertiesBuffer, size);
retur
```
<Overlap Ratio: 0.9837467921300257>

---

--- 205 --
Question ID: 9279e491892f6fec20ea72f2810518655dd085b5_0
Original Code:
```
int main()
{
	SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);
    has_lcd_4bitsetup();
    KeyPad_Lcd_Setup();
    KeyPad_Setup();
    while(1)
    {
                KeyPad_wait();
    	        KeyPad_PassWord_Confirm();

    }

}
```


Overlapping Code:
```
int main()
{
SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ| SYSCTL_OSC_MAIN);
has_lcd_4bitsetup();
KeyPad_Lcd_Setup();
KeyPad_Setup();
while(1)
{
KeyPad_wait();
KeyPad_Pa
```
<Overlap Ratio: 0.9014084507042254>

---

--- 206 --
Question ID: 505beecabe729c9b19ad0cb1d30f2f1538377e1c_34
Original Code:
```
static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 800 */

#line 160 "./arch/sdl.ceu"
    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),
                (byte*)((CEU_SDL*)__ceu_this)->title_mem);
/* NODE: Stmts 818 */

#line 160 "./arch/sdl.ceu"
    {/* NODE: Dcl_mode 31 */
/* NODE: Dcl_var 802 */
/* NODE: Dcl_var 805 */
/* NODE: Dcl_var 807 */
/* NODE: Dcl_var 810 */
/* NODE: Dcl_mode 38 */
/* NODE: Dcl_var 813 */
/* NODE: Dcl_var 816 */
/* NODE: Dcl_fun 53 */

#line 160 "./arch/sdl.ceu"
    }}
```


Overlapping Code:
```
tatic void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 800 */
#line 160 "./arch/sdl.ceu"
ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),
(byte*)((CEU_SDL*)__ceu_this)->title_mem);
/* NODE: Stmts 818 */
#line 160 "./arch/sdl.ceu"
{/* NODE: Dcl_mode 31 */
/* NODE: Dcl_var 802 */
/* NODE: Dcl_var 805 */
/* NODE: Dcl_var 807 */
/* NODE: Dcl_var 810 */
/* NODE: Dcl_mode 38 */
/* NODE: Dcl_var 813 */
/* NODE: Dcl_var 816 */
/* NODE: Dcl_fun 53 */
#line 160 ".
```
<Overlap Ratio: 0.9652509652509652>

---

--- 207 --
Question ID: d1e594c3e741e39d8d103b170a6975b463fa4d95_21
Original Code:
```
struct IndexData * IndexDataCreate()
{
	struct IndexData * ret = malloc( sizeof( struct IndexData ) );
	ret->indexcount = 0;
#ifdef USE_IBO
	ret->ido = 0;
#else
	ret->indexdata = 0;
#endif
}
```


Overlapping Code:
```
)
{
struct IndexData * ret = malloc( sizeof( struct IndexData ) );
ret->indexcount = 0;
#ifdef USE_IBO
ret->ido = 0;
#else
ret->indexdata = 0;
#endif

```
<Overlap Ratio: 0.8064516129032258>

---

--- 208 --
Question ID: daeff356501b1cbc3009d3c4c9daa00bc413ad43_1
Original Code:
```
static void check_alloc() {
  frame_t *frame = alloc_frame();

  CU_ASSERT(frame != NULL);

  free_frame(frame);
}
```


Overlapping Code:
```
rame = alloc_frame();
CU_ASSERT(frame != NULL);
fr
```
<Overlap Ratio: 0.4716981132075472>

---

--- 209 --
Question ID: cd55970a730beac9c922670954f3e58beb009dbe_1
Original Code:
```
void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* Enable HSE Oscillator and activate PLL with HSE as source   */
  /* (Default MSI Oscillator enabled at system reset remains ON) */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLP = 7;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    while(1);
  }

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    /* Initialization Error */
    while(1);
  }
}
```


Overlapping Code:
```
void SystemClock_Config(void)
{
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
/* Enable HSE Oscillator and activate PLL with HSE as source */
/* (Default MSI Oscillator enabled at system reset remains ON) */
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 20;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
{
/* Initialization Error */
while(1);
}
/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
clocks dividers */
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
{
/* Initialization Error */
while(1);
}
}
```
<Overlap Ratio: 1.0>

---

--- 210 --
Question ID: 1c043b91bd954aa5b04f5dd18116b5d6ba31c942_0
Original Code:
```
static unsigned int __stdcall _oi_thread_handler(void * args) {
    (*((thread_t*)args)->func)(((thread_t*)args)->data);
    _endthreadex(0);
    return 0;
}
```


Overlapping Code:
```
r(void * args) {
(*((thread_t*)args)->func)(((thre
```
<Overlap Ratio: 0.3448275862068966>

---

--- 211 --
Question ID: 86a3af82daa645cbeb897ddc2d1fe0d8d3b956f1_1
Original Code:
```
static char *test_pc_at_reset_vector_on_init()
{
	memory = MEM_init();

	/* Put something into the reset vector */
	MEM_write(memory, MEM_RESET_VECTOR, 0x0F);
	MEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);

	cpu = CPU_init(memory);

	mu_assert("PC not set to addr in reset vector", cpu->PC == 0x330F);

	CPU_delete(&cpu);
	return 0;
}
```


Overlapping Code:
```
est_pc_at_reset_vector_on_init()
{
memory = MEM_init();
/* Put something into the reset vector */
MEM_write(memory, MEM_RESET_VECTOR, 0x0F);
MEM_write(memory, MEM_RESET_VECTOR + 1, 0x33);
cpu = CPU_init(memory);
mu_assert("PC not set to addr in reset vector", cpu->PC == 0x330F);
CPU_delete(&cpu);
re
```
<Overlap Ratio: 0.9287925696594427>

---

--- 212 --
Question ID: 04b818f8b85cb8b1fcb38f53c8fec2196238b4e9_99
Original Code:
```
static int
store_register_using_P (const struct regcache *regcache, 
			struct packet_reg *reg)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct remote_state *rs = get_remote_state ();
  /* Try storing a single register.  */
  char *buf = rs->buf;
  gdb_byte regp[MAX_REGISTER_SIZE];
  char *p;

  if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)
    return 0;

  if (reg->pnum == -1)
    return 0;

  xsnprintf (buf, get_remote_packet_size (), "P%s=", phex_nz (reg->pnum, 0));
  p = buf + strlen (buf);
  regcache_raw_collect (regcache, reg->regnum, regp);
  bin2hex (regp, p, register_size (gdbarch, reg->regnum));
  putpkt (rs->buf);
  getpkt (&rs->buf, &rs->buf_size, 0);

  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))
    {
    case PACKET_OK:
      return 1;
    case PACKET_ERROR:
      error (_("Could not write register \"%s\"; remote failure reply '%s'"),
	     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);
    case PACKET_UNKNOWN:
      return 0;
    default:
      internal_error (__FILE__, __LINE__, _("Bad result from packet_ok"));
    }
}
```


Overlapping Code:
```
uct regcache *regcache, 
struct packet_reg *reg)
{
struct gdbarch *gdbarch = get_regcache_arch (regcache);
struct remote_state *rs = get_remote_state ();
/* Try storing a single register. */
char *buf = rs->buf;
gdb_byte regp[MAX_REGISTER_SIZE];
char *p;
if (remote_protocol_packets[PACKET_P].support == PACKET_DISABLE)
return 0;
if (reg->pnum == -1)
return 0;
xsnprintf (buf, get_remote_packet_size (), "P%s=", phex_nz (reg->pnum, 0));
p = buf + strlen (buf);
regcache_raw_collect (regcache, reg->regnum, regp);
bin2hex (regp, p, register_size (gdbarch, reg->regnum));
putpkt (rs->buf);
getpkt (&rs->buf, &rs->buf_size, 0);
switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))
{
case PACKET_OK:
return 1;
case PACKET_ERROR:
error (_("Could not write register \"%s\"; remote failure reply '%s'"),
gdbarch_register_name (gdbarch, reg->regnum), rs->buf);
case PACKET_UNKNOWN:
return 0;
default:
internal_error (__FILE__, __LINE__, _("Bad re
```
<Overlap Ratio: 0.930460333006856>

---

--- 213 --
Question ID: e03d1cb10b0402fb4b8ce4af3c90e26ca64ed93f_0
Original Code:
```
interface SSVLoadSoftwareUpdatesOperation : SSVLoadDownloadQueueOperation {
    NSArray * _appMetadata;
    NSLock * _lock;
    long long  _reason;
    NSArray * _specificApps;
    id /* block */  _updatesBlock;
    NSString * _userAgent;
}
```


Overlapping Code:
```
ftwareUpdatesOperation : SSVLoadDownloadQueueOperation {
NSArray * _appMetadata;
NSLock * _lock;
long long _reason;
NSArray * _specificApps;
id /* blo
```
<Overlap Ratio: 0.7009345794392523>

---

--- 214 --
Question ID: bb6da4fce2d7632f3ea07eedd8c087b534314651_4
Original Code:
```
static void test4()
{
	char *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);

	mprotect(m, pgsz, PROT_WRITE);
	VALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */
	m[44] = 'y';		/* OK */

	mprotect(m, pgsz*5, PROT_NONE);
	m[55] = 'x';		/* permission fault, but no tool complaint */
}
```


Overlapping Code:
```
tatic void test4()
{
char *m = mm(0, pgsz * 5, PROT_READ|PROT_WRITE);
mprotect(m, pgsz, PROT_WRITE);
VALGRIND_CHECK_MEM_IS_DEFINED(m, pgsz); /* OK */
m[44] = 'y'; /* OK */
mprotect(m, pgsz*5, PROT_NONE);
m[55] = 'x'; /* permission fault, but no tool 
```
<Overlap Ratio: 0.9433962264150944>

---

--- 215 --
Question ID: 47de56bca06ba2220bbd8f4b99bcb7beedbb3be9_7
Original Code:
```
static void registerlib(lua_State *L, const char *name, lua_CFunction f) {
  lua_getglobal(L, "package");
  lua_getfield(L, -1, "preload");
  lua_pushcfunction(L, f);
  lua_setfield(L, -2, name);
  lua_pop(L, 2);
}
```


Overlapping Code:
```
(lua_State *L, const char *name, lua_CFunction f) {
lua_getglobal(L, "package");
lua_getfield(L, -1, "preload");
lua_pushcfunction(L, f);
lua_setfield(L, -2, name);
lua_pop(L, 2);

```
<Overlap Ratio: 0.8823529411764706>

---

--- 216 --
Question ID: 694e8cddd5c13e1760e7c9cd5fc0170876a9df04_0
Original Code:
```
static bool __power_supply_is_supplied_by(struct power_supply *supplier,
					 struct power_supply *supply)
{
	int i;

	if (!supply->supplied_from && !supplier->supplied_to)
		return false;

	/* Support both supplied_to and supplied_from modes */
	if (supply->supplied_from) {
		if (!supplier->name)
			return false;
		for (i = 0; i < supply->num_supplies; i++)
			if (!strcmp(supplier->name, supply->supplied_from[i]))
				return true;
	} else {
		if (!supply->name)
			return false;
		for (i = 0; i < supplier->num_supplicants; i++)
			if (!strcmp(supplier->supplied_to[i], supply->name))
				return true;
	}

	return false;
}
```


Overlapping Code:
```
atic bool __power_supply_is_supplied_by(struct power_supply *supplier,
struct power_supply *supply)
{
int i;
if (!supply->supplied_from && !supplier->supplied_to)
return false;
/* Support both supplied_to and supplied_from modes */
if (supply->supplied_from) {
if (!supplier->name)
return false;
for (i = 0; i < supply->num_supplies; i++)
if (!strcmp(supplier->name, supply->supplied_from[i]))
return true;
} else {
if (!supply->name)
return false;
for (i = 0; i < supplier->num_supplicants; i++)
if (!strcmp(supplier->supplied_to[i], supply->name))
return t
```
<Overlap Ratio: 0.9587628865979382>

---

--- 217 --
Question ID: 7c7f720cb2b6d920b5eee25af711b5faaf6765bb_4
Original Code:
```
struct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all gv from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with gvFreeList(). */
{
struct gv *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = gvLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}
```


Overlapping Code:
```
uct gv *gvLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all gv from table that satisfy the query given. 
* Where query is of the form 'select * from example where something=something'
* or 'select example.* from example, anotherTable where example.something = 
* anotherTable.something'.
* Dispose of this with gvFreeList(). */
{
struct gv *list = NULL, *el;
struct sqlResult *sr;
char **row;
sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
{
el = gvLoad(row);
slAddHead(&list, el);
}
slReverse(&list);
sqlFreeResult(&sr);
return list;
}
```
<Overlap Ratio: 0.9948096885813149>

---

--- 218 --
Question ID: b747e136a0ae17b2651c7ef73e845960c19132ba_40
Original Code:
```
int gps_v2_get_identity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {
	DevicePrivate *device_p = gps_v2->p;
	GetIdentity_Request request;
	GetIdentity_Response response;
	int ret;

	ret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);

	if (ret < 0) {
		return ret;
	}

	ret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);

	if (ret < 0) {
		return ret;
	}

	memcpy(ret_uid, response.uid, 8);
	memcpy(ret_connected_uid, response.connected_uid, 8);
	*ret_position = response.position;
	memcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));
	memcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));
	*ret_device_identifier = leconvert_uint16_from(response.device_identifier);

	return ret;
}
```


Overlapping Code:
```
dentity(GPSV2 *gps_v2, char ret_uid[8], char ret_connected_uid[8], char *ret_position, uint8_t ret_hardware_version[3], uint8_t ret_firmware_version[3], uint16_t *ret_device_identifier) {
DevicePrivate *device_p = gps_v2->p;
GetIdentity_Request request;
GetIdentity_Response response;
int ret;
ret = packet_header_create(&request.header, sizeof(request), GPS_V2_FUNCTION_GET_IDENTITY, device_p->ipcon_p, device_p);
if (ret < 0) {
return ret;
}
ret = device_send_request(device_p, (Packet *)&request, (Packet *)&response);
if (ret < 0) {
return ret;
}
memcpy(ret_uid, response.uid, 8);
memcpy(ret_connected_uid, response.connected_uid, 8);
*ret_position = response.position;
memcpy(ret_hardware_version, response.hardware_version, 3 * sizeof(uint8_t));
memcpy(ret_firmware_version, response.firmware_version, 3 * sizeof(uint8_t));
*ret_device_identifier = leconvert_uint16_from(response.device_identifier);
return ret;
}
```
<Overlap Ratio: 0.9828877005347594>

---

--- 219 --
Question ID: 6f157363c2b31b14066cf5ef45d92cfbec456031_0
Original Code:
```
int
main (int argc, char * ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)
    CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)
{
  exit (EXIT_STATUS);

  // pmr: csolve needs returns before the ends of function bodies to make the heap
  // constraints work ok
  return 0;
}
```


Overlapping Code:
```
 ARRAY VALIDPTR LOC(PROGRAM_NAME_LOC) * START NONNULL ARRAY SIZE(argc * 4) argv)
CHECK_TYPE GLOBAL(PROGRAM_NAME_LOC)
{
exit (EXIT_STATUS);
// pmr: csolve needs returns before the ends of function bodies to make the heap
// constraints work ok
return 
```
<Overlap Ratio: 0.8928571428571429>

---

--- 220 --
Question ID: 46e47df84691c0495963bb51a7c9d498a0413fb9_1
Original Code:
```
void process_png_file() {
	uint16_t transparent_color=0x0000;

	printf("uint16_t bitmap[%d][%d] ={\n", height, width);
	for(int y = 0; y < height; y++) {
		printf("{ ");
		png_bytep row = row_pointers[y];
		for(int x = 0; x < width; x++) {
			png_bytep px = &(row[x * 4]);
			uint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);
			if (0x0000==px[3]) transparent_color = u16col;
			//printf("%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\n", x, y, px[0], px[1], px[2], px[3], u16col);
			printf("0x%04X, ", u16col);
		}
		printf(" },\n");
	}
	printf("};\nuint16_t transparent_color=0x%04X;\n", transparent_color);
}
```


Overlapping Code:
```
 {
uint16_t transparent_color=0x0000;
printf("uint16_t bitmap[%d][%d] ={\n", height, width);
for(int y = 0; y < height; y++) {
printf("{ ");
png_bytep row = row_pointers[y];
for(int x = 0; x < width; x++) {
png_bytep px = &(row[x * 4]);
uint16_t u16col = (px[2]>>3) + ((px[1]>>2)<<5) + ((px[0]>>3)<<11);
if (0x0000==px[3]) transparent_color = u16col;
//printf("%4d, %4d = RGBA(%3d, %3d, %3d, %3d) = 0x%04X\n", x, y, px[0], px[1], px[2], px[3], u16col);
printf("0x%04X, ", u16col);
}
printf(" },\n");
}
printf("};\nuint16_t transparent_color=0x%04X;\n
```
<Overlap Ratio: 0.9212730318257957>

---

--- 221 --
Question ID: e6d321d22988585c03ffcd9c4b6f0537b44ba5a3_1
Original Code:
```
class CEDFileSelector : public CGUIFileBrowser
{
public:
	CEDFileSelector(float _x, float _y, float _sx, float _sy, char* path="$GAME$", char* label="GAME:");
	virtual ~CEDFileSelector();

	int filterExt;	// pouze jake pripony se budou zobrazovat	(viz. KerServices.h - eEXTensions)

	static int Compare(CGUITreeItem *aa, CGUITreeItem *bb);	// setridi: nejdriv adresare, potom levely
	static int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb);	// setridi: nejdriv adresare, potom levely, potom ostatni soubory
protected:

	virtual int TreeHandler(typeID treeItem, int index, int state);	// nepouzito
	virtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first);	// nepouzito
	virtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);
		// pridavani polozek podle jejich typu voli ikonu, atp.

	virtual int Keyboard(UINT character, UINT state);	// zarizuje zavreni okna po vyberu polozky
}
```


Overlapping Code:
```
owser
{
public:
CEDFileSelector(float _x, float _y, float _sx, float _sy, char* path="$GAME$", char* label="GAME:");
virtual ~CEDFileSelector();
int filterExt; // pouze jake pripony se budou zobrazovat (viz. KerServices.h - eEXTensions)
static int Compare(CGUITreeItem *aa, CGUITreeItem *bb); // setridi: nejdriv adresare, potom levely
static int CompareLevelDIR(CGUITreeItem *aa, CGUITreeItem *bb); // setridi: nejdriv adresare, potom levely, potom ostatni soubory
protected:
virtual int TreeHandler(typeID treeItem, int index, int state); // nepouzito
virtual int Filter(CGUITreeItem* parent, const char *name, int dir, int first); // nepouzito
virtual CGUIFileBrowserItem* AddItem(CGUIFileBrowserItem* fbi, const char* name, int dir);
// pridavani polozek podle jejich typu voli ikonu, atp.
virtual int Keyboard(UINT character, UINT state); // zar
```
<Overlap Ratio: 0.9149623250807319>

---

--- 222 --
Question ID: 7562b9526edd0dbcf7925ed77b06d0420ed0c75b_6
Original Code:
```
int32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)
{
    int32_t ret;

    ret = pwrmgmt_wifi_powersave_suspend(suspend_module);
    return ret;
}
```


Overlapping Code:
```
32_t aos_pwrmgmt_wifi_powersave_suspend(uint32_t suspend_module)
{
int32_t ret;
ret = pwrmgmt_wifi_pow
```
<Overlap Ratio: 0.68>

---

--- 223 --
Question ID: fa66449539d2c49041222f397900aed9c04acb03_11
Original Code:
```
quatd_t
qd_slerp(quatd_t q0, quatd_t q1, double t)
{
  // See http://en.wikipedia.org/wiki/Slerp
  if (t >= 1.0) return q1;
  if (t <= 0.0) return q0;

  double qdot = qd_dot(q0, q1);

  quatd_t q1prim;
  if (qdot < 0.0) {
    q1prim = -q1;
    qdot = -qdot;
  } else {
    q1prim = q1;
  }

  if (qdot < -1.0)  qdot = -1.0;
  if (qdot > 1.0)  qdot = 1.0;
  assert(qdot >= -1.0);
  assert(qdot <= 1.0);

  double qang = acos(qdot);
  double s0 = sin((1.0-t)*qang) / sin(qang);
  double s1 = sin(t*qang) / sin(qang);

  if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.
    quatd_t res = s0 * q0 + s1 * q1prim;
    return res;
  }

  return q0;
}
```


Overlapping Code:
```
t
qd_slerp(quatd_t q0, quatd_t q1, double t)
{
// See http://en.wikipedia.org/wiki/Slerp
if (t >= 1.0) return q1;
if (t <= 0.0) return q0;
double qdot = qd_dot(q0, q1);
quatd_t q1prim;
if (qdot < 0.0) {
q1prim = -q1;
qdot = -qdot;
} else {
q1prim = q1;
}
if (qdot < -1.0) qdot = -1.0;
if (qdot > 1.0) qdot = 1.0;
assert(qdot >= -1.0);
assert(qdot <= 1.0);
double qang = acos(qdot);
double s0 = sin((1.0-t)*qang) / sin(qang);
double s1 = sin(t*qang) / sin(qang);
if (qang) { // If slerping between the same points, qang will be 0, so s0 will be NaN or Inf.
quatd_t res = s0 * q0 + s1 * q1prim;
return 
```
<Overlap Ratio: 0.96>

---

--- 224 --
Question ID: c54f9de1e317817c7aba633dea765002c2ca38c8_0
Original Code:
```
PUBLIC int do_rs_set_priv(message *m)
{
	int r, n, nr;
	struct vmproc *vmp;

	nr = m->VM_RS_NR;

	if ((r = vm_isokendpt(nr, &n)) != OK) {
		printf("do_rs_set_priv: message from strange source %d\n", nr);
		return EINVAL;
	}

	vmp = &vmproc[n];

	if (m->VM_RS_BUF) {
		r = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,
				 SELF, (vir_bytes) vmp->vm_call_mask,
				 sizeof(vmp->vm_call_mask));
		if (r != OK)
			return r;
	}

	return OK;
}
```


Overlapping Code:
```
PUBLIC int do_rs_set_priv(message *m)
{
int r, n, nr;
struct vmproc *vmp;
nr = m->VM_RS_NR;
if ((r = vm_isokendpt(nr, &n)) != OK) {
printf("do_rs_set_priv: message from strange source %d\n", nr);
return EINVAL;
}
vmp = &vmproc[n];
if (m->VM_RS_BUF) {
r = sys_datacopy(m->m_source, (vir_bytes) m->VM_RS_BUF,
SELF, (vir_bytes) vmp->vm_call_mask,
sizeof(vmp->vm_call_mask));
if (r != OK)
return 
```
<Overlap Ratio: 0.9584352078239609>

---

--- 225 --
Question ID: 154bafcb85ab6b3c941e07c9978cdd89bbbeef30_0
Original Code:
```
interface RUILoader : RUIHTTPRequest {

	RUIParser* _parser;
	NSURL* _url;
	BOOL _allowNonSecureHTTP;
	id<RUIParserDelegate> _parserDelegate;
	RUIStyle* _style;

}
```


Overlapping Code:
```
HTTPRequest {
RUIParser* _parser;
NSURL* _url;
BOOL _allowNonSecureHTTP;
id<RUIParserDelegate> _pars
```
<Overlap Ratio: 0.6410256410256411>

---

--- 226 --
Question ID: 65b20a74f691434a8bef1d74d4dc7b5c9dea48d4_0
Original Code:
```
int XIicPs_SetOptions(XIicPs *InstancePtr, u32 Options)
{
	u32 ControlReg;
	unsigned int Index;

	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

	ControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,
				      XIICPS_CR_OFFSET);

	/*
	 * If repeated start option is requested, set the flag.
	 * The hold bit in CR will be written by driver when the next transfer
	 * is initiated.
	 */
	if (Options & XIICPS_REP_START_OPTION) {
		InstancePtr->IsRepeatedStart = 1;
		Options = Options & (~XIICPS_REP_START_OPTION);
	}

	/*
	 * Loop through the options table, turning the option on.
	 */
	for (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {
 		if (Options & OptionsTable[Index].Option) {
			/*
			 * 10-bit option is specially treated, because it is
			 * using the 7-bit option, so turning it on means
			 * turning 7-bit option off.
			 */
			if (OptionsTable[Index].Option &
				XIICPS_10_BIT_ADDR_OPTION) {
				/* Turn 7-bit off */
				ControlReg &= ~OptionsTable[Index].Mask;
 			} else {
				/* Turn 7-bit on */
				ControlReg |= OptionsTable[Index].Mask;
			}
		}
	}

	/*
	 * Now write to the control register. Leave it to the upper layers
	 * to restart the device.
	 */
	XIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,
			  ControlReg);

	/*
	 * Keep a copy of what options this instance has.
	 */
	InstancePtr->Options = XIicPs_GetOptions(InstancePtr);

	return XST_SUCCESS;
}
```


Overlapping Code:
```
s_SetOptions(XIicPs *InstancePtr, u32 Options)
{
u32 ControlReg;
unsigned int Index;
Xil_AssertNonvoid(InstancePtr != NULL);
Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
ControlReg = XIicPs_ReadReg(InstancePtr->Config.BaseAddress,
XIICPS_CR_OFFSET);
/*
* If repeated start option is requested, set the flag.
* The hold bit in CR will be written by driver when the next transfer
* is initiated.
*/
if (Options & XIICPS_REP_START_OPTION) {
InstancePtr->IsRepeatedStart = 1;
Options = Options & (~XIICPS_REP_START_OPTION);
}
/*
* Loop through the options table, turning the option on.
*/
for (Index = 0; Index < XIICPS_NUM_OPTIONS; Index++) {
if (Options & OptionsTable[Index].Option) {
/*
* 10-bit option is specially treated, because it is
* using the 7-bit option, so turning it on means
* turning 7-bit option off.
*/
if (OptionsTable[Index].Option &
XIICPS_10_BIT_ADDR_OPTION) {
/* Turn 7-bit off */
ControlReg &= ~OptionsTable[Index].Mask;
} else {
/* Turn 7-bit on */
ControlReg |= OptionsTable[Index].Mask;
}
}
}
/*
* Now write to the control register. Leave it to the upper layers
* to restart the device.
*/
XIicPs_WriteReg(InstancePtr->Config.BaseAddress, XIICPS_CR_OFFSET,
ControlReg);
/*
* Keep a copy of what options this instance has.
*/
InstancePtr->Options = XIicPs_GetOptions(InstancePtr);
return XST_SU
```
<Overlap Ratio: 0.9874723655121592>

---

--- 227 --
Question ID: 2ae35d143583022965327b11b8aabd9044caef9e_7
Original Code:
```
static void
mgaScreenFini (KdScreenInfo *screen)
{
    MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;

    vesaScreenFini (screen);
    xfree (mgas);
    screen->driver = 0;
}
```


Overlapping Code:
```
en)
{
MgaScreenInfo *mgas = (MgaScreenInfo *) screen->driver;
vesaScreenFini (screen);
xfree (mgas);
```
<Overlap Ratio: 0.5988023952095808>

---

--- 228 --
Question ID: 6a8959b9373cae4321b3da9a46b94332c12fffc0_10
Original Code:
```
void* listen_for_command(void* arg)
{
	int sock = socket(AF_INET, SOCK_DGRAM, 0);       //socket initailization
	struct sockaddr_storage serverAddr;
	char myMsg[1024];
	//char stop = ' ';
	_Bool stopping = false;
	int b;

	//binding 
	struct sockaddr_in sockName;
	memset((char*)&sockName, 0, sizeof(sockName));
	sockName.sin_family = AF_INET;
	sockName.sin_port = htons(SERVER_PORT);
	sockName.sin_addr.s_addr = htonl(INADDR_ANY);
	socklen_t serverAddrSize;

	if(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))
	{
		perror("binding failed");
		exit(1);
	}
	
	serverAddrSize = sizeof(serverAddr);
	
	//send msg to server
	while((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)
	{
		myMsg[b] = '\0';
		printf("%d\n", myMsg[b]);
		char* msgsss = verifyCommand(myMsg, sock, serverAddr);
		if (strcmp(msgsss, "stop\n") == 0)
		{
			stopping = true;
			break;
		}

		sendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);
		free(msgsss);
	}
	
	close(sock);
	pthread_exit(0);
}
```


Overlapping Code:
```
_for_command(void* arg)
{
int sock = socket(AF_INET, SOCK_DGRAM, 0); //socket initailization
struct sockaddr_storage serverAddr;
char myMsg[1024];
//char stop = ' ';
_Bool stopping = false;
int b;
//binding 
struct sockaddr_in sockName;
memset((char*)&sockName, 0, sizeof(sockName));
sockName.sin_family = AF_INET;
sockName.sin_port = htons(SERVER_PORT);
sockName.sin_addr.s_addr = htonl(INADDR_ANY);
socklen_t serverAddrSize;
if(bind(sock, (struct sockaddr *)&sockName, sizeof(sockName)))
{
perror("binding failed");
exit(1);
}

serverAddrSize = sizeof(serverAddr);

//send msg to server
while((b = recvfrom(sock, myMsg, 1024, 0, (struct sockaddr *)&serverAddr, &serverAddrSize)) > 0 && !stopping)
{
myMsg[b] = '\0';
printf("%d\n", myMsg[b]);
char* msgsss = verifyCommand(myMsg, sock, serverAddr);
if (strcmp(msgsss, "stop\n") == 0)
{
stopping = true;
break;
}
sendto(sock, msgsss, 1024, 0, (struct sockaddr *)&serverAddr, serverAddrSize);
free(msgsss)
```
<Overlap Ratio: 0.952047952047952>

---

--- 229 --
Question ID: f6b97381f1199f2248acbfb69603c9f4fcd73b4b_7
Original Code:
```
int BTESH2_SetAddrDWordTMMU(BTESH2_CpuState *cpu,
	btesh2_vaddr addr, u32 val)
{
	btesh2_vaddr addr1;

	if(cpu->status)
		return(-1);

	if(((addr&0x80000000) ||
		!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&
		((addr>>29)<6))
	{
		return(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));
	}

	addr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);
	return(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));
}
```


Overlapping Code:
```
tate *cpu,
btesh2_vaddr addr, u32 val)
{
btesh2_vaddr addr1;
if(cpu->status)
return(-1);
if(((addr&0x80000000) ||
!(BTESH2_GetRegQWord(cpu, BTESH2_REG_MMUCR)&BTESH2_MMUCR_AT)) &&
((addr>>29)<6))
{
return(BTESH2_SetAddrDWordFMMU_NoAT_I(cpu, addr, val));
}
addr1=BTESH2_TMMU_MapVirtToPhys(cpu, addr);
return(BTESH2_SetAddrDWordPhy2(cpu, addr1, val));
}
```
<Overlap Ratio: 0.8997429305912596>

---

--- 230 --
Question ID: 856cfb40305d7f50984efb8527a86f96bb6858cf_30
Original Code:
```
int
libxlDomainStart(libxlDriverPrivatePtr driver, virDomainObjPtr vm,
                 bool start_paused, int restore_fd)
{
    libxl_domain_config d_config;
    virDomainDefPtr def = NULL;
    virObjectEventPtr event = NULL;
    libxlSavefileHeader hdr;
    int ret = -1;
    uint32_t domid = 0;
    char *dom_xml = NULL;
    char *managed_save_path = NULL;
    int managed_save_fd = -1;
    libxlDomainObjPrivatePtr priv = vm->privateData;
    libxlDriverConfigPtr cfg;
#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS
    libxl_domain_restore_params params;
#endif
    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;
    libxl_asyncprogress_how aop_console_how;

    libxl_domain_config_init(&d_config);

    if (libxlDomainObjPrivateInitCtx(vm) < 0)
        return ret;

    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
        return ret;

    cfg = libxlDriverConfigGet(driver);
    /* If there is a managed saved state restore it instead of starting
     * from scratch. The old state is removed once the restoring succeeded. */
    if (restore_fd < 0) {
        managed_save_path = libxlDomainManagedSavePath(driver, vm);
        if (managed_save_path == NULL)
            goto endjob;

        if (virFileExists(managed_save_path)) {

            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,
                                                       managed_save_path,
                                                       &def, &hdr);
            if (managed_save_fd < 0)
                goto endjob;

            restore_fd = managed_save_fd;

            if (STRNEQ(vm->def->name, def->name) ||
                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {
                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];
                char def_uuidstr[VIR_UUID_STRING_BUFLEN];
                virUUIDFormat(vm->def->uuid, vm_uuidstr);
                virUUIDFormat(def->uuid, def_uuidstr);
                virReportError(VIR_ERR_OPERATION_FAILED,
                               _("cannot restore domain '%s' uuid %s from a file"
                                 " which belongs to domain '%s' uuid %s"),
                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);
                goto endjob;
            }

            virDomainObjAssignDef(vm, def, true, NULL);
            def = NULL;

            if (unlink(managed_save_path) < 0)
                VIR_WARN("Failed to remove the managed state %s",
                         managed_save_path);

            vm->hasManagedSave = false;
        }
        VIR_FREE(managed_save_path);
    }

    if (libxlBuildDomainConfig(driver->reservedVNCPorts, vm->def,
                               priv->ctx, &d_config) < 0)
        goto endjob;

    if (cfg->autoballoon && libxlDomainFreeMem(priv, &d_config) < 0) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _("libxenlight failed to get free memory for domain '%s'"),
                       d_config.c_info.name);
        goto endjob;
    }

    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,
                                       vm->def, VIR_HOSTDEV_SP_PCI) < 0)
        goto endjob;

    /* Unlock virDomainObj while creating the domain */
    virObjectUnlock(vm);

    aop_console_how.for_callback = vm;
    aop_console_how.callback = libxlConsoleCallback;
    if (restore_fd < 0) {
        ret = libxl_domain_create_new(priv->ctx, &d_config,
                                      &domid, NULL, &aop_console_how);
    } else {
#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS
        params.checkpointed_stream = 0;
        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,
                                          restore_fd, &params, NULL,
                                          &aop_console_how);
#else
        ret = libxl_domain_create_restore(priv->ctx, &d_config, &domid,
                                          restore_fd, NULL, &aop_console_how);
#endif
    }
    virObjectLock(vm);

    if (ret) {
        if (restore_fd < 0)
            virReportError(VIR_ERR_INTERNAL_ERROR,
                           _("libxenlight failed to create new domain '%s'"),
                           d_config.c_info.name);
        else
            virReportError(VIR_ERR_INTERNAL_ERROR,
                           _("libxenlight failed to restore domain '%s'"),
                           d_config.c_info.name);
        goto endjob;
    }

    /*
     * The domain has been successfully created with libxl, so it should
     * be cleaned up if there are any subsequent failures.
     */
    vm->def->id = domid;
    if (libxlDomainEventsRegister(driver, vm) < 0)
        goto cleanup_dom;

    if ((dom_xml = virDomainDefFormat(vm->def, 0)) == NULL)
        goto cleanup_dom;

    if (libxl_userdata_store(priv->ctx, domid, "libvirt-xml",
                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                       _("libxenlight failed to store userdata"));
        goto cleanup_dom;
    }

    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)
        goto cleanup_dom;

    if (!start_paused) {
        libxl_domain_unpause(priv->ctx, domid);
        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);
    } else {
        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);
    }

    if (virDomainSaveStatus(driver->xmlopt, cfg->stateDir, vm) < 0)
        goto cleanup_dom;

    if (virAtomicIntInc(&driver->nactive) == 1 && driver->inhibitCallback)
        driver->inhibitCallback(true, driver->inhibitOpaque);

    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,
                                     restore_fd < 0 ?
                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :
                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);
    if (event)
        libxlDomainEventQueue(driver, event);

    ret = 0;
    goto endjob;

 cleanup_dom:
    libxl_domain_destroy(priv->ctx, domid, NULL);
    vm->def->id = -1;
    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);

 endjob:
    if (!libxlDomainObjEndJob(driver, vm))
        vm = NULL;

    libxl_domain_config_dispose(&d_config);
    VIR_FREE(dom_xml);
    VIR_FREE(managed_save_path);
    virDomainDefFree(def);
    VIR_FORCE_CLOSE(managed_save_fd);
    virObjectUnref(cfg);
    return ret;
}
```


Overlapping Code:
```
ivatePtr driver, virDomainObjPtr vm,
bool start_paused, int restore_fd)
{
libxl_domain_config d_config;
virDomainDefPtr def = NULL;
virObjectEventPtr event = NULL;
libxlSavefileHeader hdr;
int ret = -1;
uint32_t domid = 0;
char *dom_xml = NULL;
char *managed_save_path = NULL;
int managed_save_fd = -1;
libxlDomainObjPrivatePtr priv = vm->privateData;
libxlDriverConfigPtr cfg;
#ifdef LIBXL_HAVE_DOMAIN_CREATE_RESTORE_PARAMS
libxl_domain_restore_params params;
#endif
virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;
libxl_asyncprogress_how aop_console_how;
libxl_domain_config_init(&d_config);
if (libxlDomainObjPrivateInitCtx(vm) < 0)
return ret;
if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
return ret;
cfg = libxlDriverConfigGet(driver);
/* If there is a managed saved state restore it instead of starting
* from scratch. The old state is removed once the restoring succeeded. */
if (restore_fd < 0) {
managed_save_path = libxlDomainManagedSavePath(driver, vm);
if (managed_save_path == NULL)
goto endjob;
if (virFileExists(managed_save_path)) {
managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,
managed_save_path,
&def, &hdr);
if (managed_save_fd < 0)
goto endjob;
restore_fd = managed_save_fd;
if (STRNEQ(vm->def->name, def->name) ||
memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {
char vm_uuidstr[VIR_UUID_STRING_BUFLEN];
char def_uuidstr[VIR_UUID_STRING_BUFLEN];
virUUIDFormat(vm->def->uuid, vm_uuidstr);
virUUIDFormat(def->uuid, def_uuidstr);
virReportError(VIR_ERR_OPERATION_FAILED,
_("cannot restore domain '%s' uuid %s from a file"
" which belongs to domain '%s' uuid %s"),
vm->def->name, vm_uuidstr, def->name, def_uuidstr);
goto endjob;
}
virDomainObjAssignDef(vm, def, true, NULL);
def = NULL;
if (unlink(managed_save_path) < 0)
VIR_WARN("Failed to remove the managed
```
<Overlap Ratio: 0.9737265415549597>

---

--- 231 --
Question ID: ae95685d3e591be2b22dae3c92e13599823a3e25_74
Original Code:
```
static int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,
				      struct snd_ctl_elem_value *ucontrol)
{
	pr_debug("%s() mAudio_Analog_Mic1_mode = %d\n", __func__, mAudio_Analog_Mic1_mode);
	ucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;
	return 0;
}
```


Overlapping Code:
```
atic int Audio_Mic1_Mode_Select_Get(struct snd_kcontrol *kcontrol,
struct snd_ctl_elem_value *ucontrol)
{
pr_debug("%s() mAudio_Analog_Mic1_mode = %d\n", __func__, mAudio_Analog_Mic1_mode);
ucontrol->value.integer.value[0] = mAudio_Analog_Mic1_mode;
return
```
<Overlap Ratio: 0.973384030418251>

---

--- 232 --
Question ID: 921a0b518ba4d28af3e7c4d7b1274975696a7833_0
Original Code:
```
interface PUPhotosSharingCollectionViewItemSublayout : NSObject {
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _badgesContainerFrame;
    unsigned long long  _badgesCorner;
    struct UIOffset { 
        double horizontal; 
        double vertical; 
    }  _badgesOffset;
    double  _bottomBadgeInset;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _floatingBadgesContainerFrame;
    NSIndexPath * _indexPath;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _itemFrame;
    struct CGPoint { 
        double x; 
        double y; 
    }  _optionBadgeCenter;
    UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;
    struct CGPoint { 
        double x; 
        double y; 
    }  _selectionBadgeCenter;
    UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _visibleItemFrame;
}
```


Overlapping Code:
```
CollectionViewItemSublayout : NSObject {
struct CGRect { 
struct CGPoint { 
double x; 
double y; 
} origin; 
struct CGSize { 
double width; 
double height; 
} size; 
} _badgesContainerFrame;
unsigned long long _badgesCorner;
struct UIOffset { 
double horizontal; 
double vertical; 
} _badgesOffset;
double _bottomBadgeInset;
struct CGRect { 
struct CGPoint { 
double x; 
double y; 
} origin; 
struct CGSize { 
double width; 
double height; 
} size; 
} _floatingBadgesContainerFrame;
NSIndexPath * _indexPath;
struct CGRect { 
struct CGPoint { 
double x; 
double y; 
} origin; 
struct CGSize { 
double width; 
double height; 
} size; 
} _itemFrame;
struct CGPoint { 
double x; 
double y; 
} _optionBadgeCenter;
UICollectionViewLayoutAttributes * _optionBadgeLayoutAttributes;
struct CGPoint { 
double x; 
double y; 
} _selectionBadgeCenter;
UICollectionViewLayoutAttributes * _selectionBadgeLayoutAttributes;
struct CGRect { 
struct CGPoint { 
double x; 
double y; 
} origin; 
struct CGSize { 
double width; 
double height; 
} size; 
} _visibleItemFra
```
<Overlap Ratio: 0.9722222222222222>

---

--- 233 --
Question ID: a3dafbc05a1183cbfa9af243baa2f6526800d173_3
Original Code:
```
int usecSleep(unsigned int dt_us)
{
    static struct timespec s;
    if (dt_us > 0)
    {
        s.tv_sec = (dt_us/1000000);
        s.tv_nsec = (dt_us % 1000000)*1000L;
        while(nanosleep(&s,&s)==-1 && errno == EINTR)
        continue;
    }
    else {
        return sleep(0);
    }
    return 0;
}
```


Overlapping Code:
```
t_us)
{
static struct timespec s;
if (dt_us > 0)
{
s.tv_sec = (dt_us/1000000);
s.tv_nsec = (dt_us % 1000000)*1000L;
while(nanosleep(&s,&s)==-1 && errno == EINTR)
continue;
}
else {
return sleep(0);
}

```
<Overlap Ratio: 0.8368200836820083>

---

--- 234 --
Question ID: aa3b8f1b34d932a90256b13e99b0a6d53ec5c5cc_4
Original Code:
```
static int
isl1208_i2c_get_dtr(struct i2c_client *client)
{
	int dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);
	if (dtr < 0)
		return -EIO;

	/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */
	dtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);

	return dtr;
}
```


Overlapping Code:
```
t
isl1208_i2c_get_dtr(struct i2c_client *client)
{
int dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);
if (dtr < 0)
return -EIO;
/* dtr encodes adjustments of {-60,-40,-20,0,20,40,60} ppm */
dtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);
return dtr;
```
<Overlap Ratio: 0.9601449275362319>

---

--- 235 --
Question ID: d923330e171e5ed9091c639b1a62f0351f74c61c_5
Original Code:
```
void
xcwm_window_remove_damage(xcwm_window_t *window)
{
    xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);
    xcb_rectangle_t rect;
    xcb_void_cookie_t cookie;

    if (!window) {
        return;
    }

    rect.x = window->dmg_bounds.x;
    rect.y = window->dmg_bounds.y;
    rect.width = window->dmg_bounds.width;
    rect.height = window->dmg_bounds.height;

    xcb_xfixes_create_region(window->context->conn,
                             region,
                             1,
                             &rect);

    cookie = xcb_damage_subtract_checked(window->context->conn,
                                         window->damage,
                                         region,
                                         0);

    if (!(_xcwm_request_check(window->context->conn, cookie,
                              "Failed to subtract damage"))) {
        window->dmg_bounds.x = 0;
        window->dmg_bounds.y = 0;
        window->dmg_bounds.width = 0;
        window->dmg_bounds.height = 0;
    }
    return;
}
```


Overlapping Code:
```
amage(xcwm_window_t *window)
{
xcb_xfixes_region_t region = xcb_generate_id(window->context->conn);
xcb_rectangle_t rect;
xcb_void_cookie_t cookie;
if (!window) {
return;
}
rect.x = window->dmg_bounds.x;
rect.y = window->dmg_bounds.y;
rect.width = window->dmg_bounds.width;
rect.height = window->dmg_bounds.height;
xcb_xfixes_create_region(window->context->conn,
region,
1,
&rect);
cookie = xcb_damage_subtract_checked(window->context->conn,
window->damage,
region,
0);
if (!(_xcwm_request_check(window->context->conn, cookie,
"Failed to subtract damage"))) {
window->dmg_bounds.x = 0;
window->dmg_bounds.y = 0;
window->dmg_bounds.width = 0;
window->
```
<Overlap Ratio: 0.9167842031029619>

---

--- 236 --
Question ID: 67c2cee6d2d9eedb91b9cb60846563cef25bc8f4_4
Original Code:
```
void LayerTraverseForArray(BiTree T) {
    if (T == NULL) return;
    BiTree trees[100];
    int in = 0;
    int out = 0;
    trees[in++] = T; // 先保存二叉树根节点
    while (in > out) {
        if (trees[out] != NULL) {
            printf("%d ->", trees[out] -> data);
            if (trees[out] -> lChildNode) {
                trees[in++] = trees[out] -> lChildNode;
            }
            if (trees[out] -> rChildNode) {
                trees[in++] = trees[out] -> rChildNode;
            }
        }
        out++;
    }
}
```


Overlapping Code:
```

if (T == NULL) return;
BiTree trees[100];
int in = 0;
int out = 0;
trees[in++] = T; // 先保存二叉树根节点
while (in > out) {
if (trees[out] != NULL) {
printf("%d ->", trees[out] -> data);
if (trees[out] -> lChildNode) {
trees[in++] = trees[out] -> lChildNode;
}
if (trees[out] -> rChildNode) {
trees[in++] = 
```
<Overlap Ratio: 0.7936507936507936>

---

--- 237 --
Question ID: 4ff722b875c5ef6aad956e53e84f206df760b1c8_0
Original Code:
```
void hal_reboot(void)
{
    printf("reboot!\n");
    vPortETSIntrLock();
    krhino_sched_disable();
    delay();
    delay();
    rom_i2c_writeReg(0x67, 4, 1, 8);
    rom_i2c_writeReg(0x67, 4, 2, 0x81);
    while(1) {
        system_restart();
        aos_msleep(100);
    }
}
```


Overlapping Code:
```
");
vPortETSIntrLock();
krhino_sched_disable();
delay();
delay();
rom_i2c_writeReg(0x67, 4, 1, 8);
rom_i2c_writeReg(0x67, 4, 2, 0x81);
while(1) {
system_r
```
<Overlap Ratio: 0.6844444444444444>

---

--- 238 --
Question ID: 880dcb4ba0c15f4b798521b6a0cdee4897042fb9_103
Original Code:
```
xuintptr *putOrderedObject(Class *class, MethodBlock *mb, xuintptr *ostack) {
    long long offset = *((long long *)&ostack[2]);
    volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);
    xuintptr value = ostack[4];

    *addr = value;
    return ostack;
}
```


Overlapping Code:
```
Object(Class *class, MethodBlock *mb, xuintptr *ostack) {
long long offset = *((long long *)&ostack[2]);
volatile xuintptr *addr = (xuintptr*)((char *)ostack[1] + offset);
xuintptr value = ostack[4];
*addr = value;
return ost
```
<Overlap Ratio: 0.896414342629482>

---

--- 239 --
Question ID: 08a6211832b6c677948136e74c7fea4f3653fe93_0
Original Code:
```
class YOCTO_CLASS_EXPORT YDelayedPulse {
public:
    int             target;
    int             ms;
    int             moving;

    YDelayedPulse()
        :target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
    {}

    bool operator==(const YDelayedPulse& o) const {
         return (target == o.target) && (ms == o.ms) && (moving == o.moving);
    }
}
```


Overlapping Code:
```
RT YDelayedPulse {
public:
int target;
int ms;
int moving;
YDelayedPulse()
:target(YAPI_INVALID_INT), ms(YAPI_INVALID_INT), moving(YAPI_INVALID_UINT)
{}
bool operator==(const YDelayedPulse& o) const {
return (target == o.target) && (ms == o.ms) && (moving == o.moving)
```
<Overlap Ratio: 0.9084745762711864>

---

--- 240 --
Question ID: 56bd2e3833d7189e189358c1dbb5c14ccb1c53c3_0
Original Code:
```
void insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {
    
    if(!fromv || !tov || !e)
        return;
    SET_TE(e);
    
    if(!fromv->pt1) {
        fromv->pt1 = e;
        e->fnext = e->fprev = NULL;
    }
    else {
        e->fnext = fromv->pt1; //place e before fromv's head
        if(fromv->pt1->from == fromv->key)
            fromv->pt1->fprev = e; //set fromv's prev pointer to e
        else
            fromv->pt1->tprev = e;
        e->fprev = NULL; //e's prev is null, because first
        fromv->pt1 = e; //new head is e


    }
    updateTBit_Ins(fromv);
    /*To Vertex part*/
    if(!tov->pt1) {
        tov->pt1 = e;
        e->tnext = e->tprev = NULL;
    }
    else {
        e->tnext = tov->pt1; //place e before tov's head
        if(tov->pt1->from == tov->key) 
            tov->pt1->fprev = e;
        else
            tov->pt1->tprev = e; //set tov's prev pointer to e
        e->tprev = NULL; //e's prev is null, because first
        tov->pt1 = e; //new head is e
        

    }
    updateTBit_Ins(tov);
}
```


Overlapping Code:
```
 insert_treeEdge_to_dlls(struct s_node *fromv,struct s_node *tov,Edge *e) {

if(!fromv || !tov || !e)
return;
SET_TE(e);

if(!fromv->pt1) {
fromv->pt1 = e;
e->fnext = e->fprev = NULL;
}
else {
e->fnext = fromv->pt1; //place e before fromv's head
if(fromv->pt1->from == fromv->key)
fromv->pt1->fprev = e; //set fromv's prev pointer to e
else
fromv->pt1->tprev = e;
e->fprev = NULL; //e's prev is null, because first
fromv->pt1 = e; //new head is e
}
updateTBit_Ins(fromv);
/*To Vertex part*/
if(!tov->pt1) {
tov->pt1 = e;
e->tnext = e->tprev = NULL;
}
else {
e->tnext = tov->pt1; //place e before tov's head
if(tov->pt1->from == tov->key) 
tov->pt1->fprev = e;
else
tov->pt1->tprev = e; //set tov's prev pointer to e
e->tprev = NULL; //e's prev is null, because first
tov->pt1 = e; //new head is e

}

```
<Overlap Ratio: 0.9685230024213075>

---

--- 241 --
Question ID: d7867156a643510e0a32d44d62f95ae5410fc6c1_5
Original Code:
```
LIBXSMM_INLINE void init_buf(float* buf, size_t size, int initPos, int initOne)
{
  int i;
  zero_buf(buf, size);
  for (i = 0; i < (int)size; ++i) {
    buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libxsmm_rand_f64()/10.0)));
  }
}
```


Overlapping Code:
```
t* buf, size_t size, int initPos, int initOne)
{
int i;
zero_buf(buf, size);
for (i = 0; i < (int)size; ++i) {
buf[i] = (float)((initOne != 0) ? 1.0 : ((initPos != 0) ? libxsmm_rand_f64() : (0.05 - libx
```
<Overlap Ratio: 0.7709923664122137>

---

--- 242 --
Question ID: 683ed81ef02eb19dd9facc2d4a0a203fecfa854a_1
Original Code:
```
static int
tdfx_attach(device_t dev) { 
	/*
	 * The attach routine is called after the probe routine successfully says it
	 * supports a given card. We now proceed to initialize this card for use with
	 * the system. I want to map the device memory for userland allocation and
	 * fill an information structure with information on this card. I'd also like
	 * to set Write Combining with the MTRR code so that we can hopefully speed
	 * up memory writes. The last thing is to register the character device
	 * interface to the card, so we can open it from /dev/3dfxN, where N is a
	 * small, whole number.
	 */
	struct tdfx_softc *tdfx_info;
	/* rid value tells bus_alloc_resource where to find the addresses of ports or
	 * of memory ranges in the PCI config space*/
	int rid = PCIR_BAR(0);

	/* Increment the card counter (for the ioctl code) */
	tdfx_count++;

	/* Fill the soft config struct with info about this device*/
	tdfx_info = device_get_softc(dev);
	tdfx_info->dev = dev;
	tdfx_info->vendor = pci_get_vendor(dev);
	tdfx_info->type = pci_get_devid(dev) >> 16;
	tdfx_info->bus = pci_get_bus(dev);
	tdfx_info->dv = pci_get_slot(dev);
	tdfx_info->curFile = NULL;

	/* 
	 *	Get the Memory Location from the PCI Config, mask out lower word, since
	 * the config space register is only one word long (this is nicer than a
	 * bitshift).
	 */
	tdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);
#ifdef DEBUG
	device_printf(dev, "Base0 @ 0x%x\n", tdfx_info->addr0);
#endif
	/* Notify the VM that we will be mapping some memory later */
	tdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,
		&rid, RF_ACTIVE | RF_SHAREABLE);
	if(tdfx_info->memrange == NULL) {
#ifdef DEBUG
		device_printf(dev, "Error mapping mem, won't be able to use mmap()\n");
#endif
		tdfx_info->memrid = 0;
	}
	else {
		tdfx_info->memrid = rid;
#ifdef DEBUG
		device_printf(dev, "Mapped to: 0x%x\n", 
				(unsigned int)rman_get_start(tdfx_info->memrange));
#endif
	}

	/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */
	if(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||
		pci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {
		rid = 0x14;	/* 2nd mem map */
		tdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);
#ifdef DEBUG
		device_printf(dev, "Base1 @ 0x%x\n", tdfx_info->addr1);
#endif
		tdfx_info->memrange2 = bus_alloc_resource_any(dev,
			SYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);
		if(tdfx_info->memrange2 == NULL) {
#ifdef DEBUG
			device_printf(dev, "Mem1 couldn't be allocated, glide may not work.");
#endif
			tdfx_info->memrid2 = 0;
		}
		else {
			tdfx_info->memrid2 = rid;
		}
		/* Now to map the PIO stuff */
		rid = PCIR_IOBASE0_2;
		tdfx_info->pio0 = pci_read_config(dev, 0x2c, 2);
		tdfx_info->pio0max = pci_read_config(dev, 0x30, 2) + tdfx_info->pio0;
		tdfx_info->piorange = bus_alloc_resource_any(dev,
			SYS_RES_IOPORT, &rid, RF_ACTIVE | RF_SHAREABLE);
		if(tdfx_info->piorange == NULL) {
#ifdef DEBUG
			device_printf(dev, "Couldn't map PIO range.");
#endif
			tdfx_info->piorid = 0;
		}
		else {
			tdfx_info->piorid = rid;
		}
	} else {
	  tdfx_info->addr1 = 0;
	  tdfx_info->memrange2 = NULL;
	  tdfx_info->piorange = NULL;
	}

	/* 
	 *	Set Writecombining, or at least Uncacheable for the memory region, if we
	 * are able to
	 */

	if(tdfx_setmtrr(dev) != 0) {
#ifdef DEBUG
		device_printf(dev, "Some weird error setting MTRRs");
#endif
		return -1;
	}

	/* 
	 * make_dev registers the cdev to access the 3dfx card from /dev
	 *	use hex here for the dev num, simply to provide better support if > 10
	 * voodoo cards, for the mad. The user must set the link.
	 * Why would we want that many voodoo cards anyhow? 
	 */
	tdfx_info->devt = make_dev(&tdfx_cdev, device_get_unit(dev),
		UID_ROOT, GID_WHEEL, 0600, "3dfx%x", device_get_unit(dev));
	tdfx_info->devt->si_drv1 = tdfx_info;
	
	return 0;
}
```


Overlapping Code:
```
attach routine is called after the probe routine successfully says it
* supports a given card. We now proceed to initialize this card for use with
* the system. I want to map the device memory for userland allocation and
* fill an information structure with information on this card. I'd also like
* to set Write Combining with the MTRR code so that we can hopefully speed
* up memory writes. The last thing is to register the character device
* interface to the card, so we can open it from /dev/3dfxN, where N is a
* small, whole number.
*/
struct tdfx_softc *tdfx_info;
/* rid value tells bus_alloc_resource where to find the addresses of ports or
* of memory ranges in the PCI config space*/
int rid = PCIR_BAR(0);
/* Increment the card counter (for the ioctl code) */
tdfx_count++;
/* Fill the soft config struct with info about this device*/
tdfx_info = device_get_softc(dev);
tdfx_info->dev = dev;
tdfx_info->vendor = pci_get_vendor(dev);
tdfx_info->type = pci_get_devid(dev) >> 16;
tdfx_info->bus = pci_get_bus(dev);
tdfx_info->dv = pci_get_slot(dev);
tdfx_info->curFile = NULL;
/* 
* Get the Memory Location from the PCI Config, mask out lower word, since
* the config space register is only one word long (this is nicer than a
* bitshift).
*/
tdfx_info->addr0 = (pci_read_config(dev, 0x10, 4) & 0xffff0000);
#ifdef DEBUG
device_printf(dev, "Base0 @ 0x%x\n", tdfx_info->addr0);
#endif
/* Notify the VM that we will be mapping some memory later */
tdfx_info->memrange = bus_alloc_resource_any(dev, SYS_RES_MEMORY,
&rid, RF_ACTIVE | RF_SHAREABLE);
if(tdfx_info->memrange == NULL) {
#ifdef DEBUG
device_printf(dev, "Error mapping mem, won't be able to use mmap()\n");
#endif
tdfx_info->memrid = 0;
}
else {
tdfx_info->memrid = rid;
#ifdef DEBUG
device_printf(dev, "Mapped to: 0x%x\n", 
(unsigned int)rman_get_start(tdfx_info->memrange));
#endif
}
/* Setup for Voodoo3 and Banshee, PIO and an extram Memrange */
if(pci_get_devid(dev) == PCI_DEVICE_3DFX_VOODOO3 ||
pci_get_devid(dev) == PCI_DEVICE_3DFX_BANSHEE) {
rid = 0x14; /* 2nd mem map */
tdfx_info->addr1 = (pci_read_config(dev, 0x14, 4) & 0xffff0000);
#ifdef DEBUG
device_printf(dev, "Base1 @ 0x%x\n", tdfx_info->addr1);
#endif
tdfx_info->memrange2 = bus_alloc_resource_any(dev,
SYS_RES_MEMORY, &rid, RF_ACTIVE | RF_SHAREABLE);
if(tdfx_info->memrange2 == NULL) {
#ifdef DEBUG
device_printf
```
<Overlap Ratio: 0.975103734439834>

---

--- 243 --
Question ID: 1e79be0b322a5cbc6f2a2a24a7e1f4629db74617_11
Original Code:
```
static char *
name_list_to_string(DefElem *def)
{
	StringInfoData string;
	ListCell *lc;
	bool first = true;

	initStringInfo(&string);

	foreach (lc, (List *) def->arg)
	{
		Node *name = (Node *) lfirst(lc);

		if (!first)
			appendStringInfo(&string, ", ");
		else
			first = false;

		if (IsA(name, String))
			appendStringInfoString(&string, quote_identifier(strVal(name)));
		else if (IsA(name, A_Star))
			appendStringInfoChar(&string, '*');
		else
			elog(ERROR, "unexpected node type in name list: %d", (int) nodeTag(name));
	}
	return string.data;
}
```


Overlapping Code:
```
ist_to_string(DefElem *def)
{
StringInfoData string;
ListCell *lc;
bool first = true;
initStringInfo(&string);
foreach (lc, (List *) def->arg)
{
Node *name = (Node *) lfirst(lc);
if (!first)
appendStringInfo(&string, ", ");
else
first = false;
if (IsA(name, String))
appendStringInfoString(&string, quote_identifier(strVal(name)));
else if (IsA(name, A_Star))
appendStringInfoChar(&string, '*');
else
elog(ERROR, "unexpected node type in name list: %d
```
<Overlap Ratio: 0.8689788053949904>

---

--- 244 --
Question ID: 2ac945f52b3aeabfda5cb9ad4ffa04a99e0ac346_122
Original Code:
```
void ED_view3d_distance_set(RegionView3D *rv3d, const float dist)
{
	float viewinv[4];
	float tvec[3];

	BLI_assert(dist >= 0.0f);

	copy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);
	/* rv3d->viewinv isn't always valid */
#if 0
	mul_mat3_m4_v3(rv3d->viewinv, tvec);
#else
	invert_qt_qt_normalized(viewinv, rv3d->viewquat);
	mul_qt_v3(viewinv, tvec);
#endif
	sub_v3_v3(rv3d->ofs, tvec);

	rv3d->dist = dist;
}
```


Overlapping Code:
```
iew3D *rv3d, const float dist)
{
float viewinv[4];
float tvec[3];
BLI_assert(dist >= 0.0f);
copy_v3_fl3(tvec, 0.0f, 0.0f, rv3d->dist - dist);
/* rv3d->viewinv isn't always valid */
#if 0
mul_mat3_m4_v3(rv3d->viewinv, tvec);
#else
invert_qt_qt_normalized(viewinv, rv3d->viewquat);
mul_qt_v3(viewinv, tvec);
#endif
sub_v3_v3(rv3d->ofs, tvec);
rv3d->dis
```
<Overlap Ratio: 0.8838383838383839>

---

--- 245 --
Question ID: f8555e125e8c8657d40cf3baaf0ee970e950877b_7
Original Code:
```
void spu_cdda_pan(int left_pan, int right_pan) {
    if(left_pan < 16)
        left_pan = ~(left_pan - 16);

    left_pan &= 0x1f;

    if(right_pan < 16)
        right_pan = ~(right_pan - 16);

    right_pan &= 0x1f;

    g2_fifo_wait();
    g2_write_32(SNDREGADDR(0x2040),
                (g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));
    g2_write_32(SNDREGADDR(0x2044),
                (g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan << 0));
}
```


Overlapping Code:
```
t left_pan, int right_pan) {
if(left_pan < 16)
left_pan = ~(left_pan - 16);
left_pan &= 0x1f;
if(right_pan < 16)
right_pan = ~(right_pan - 16);
right_pan &= 0x1f;
g2_fifo_wait();
g2_write_32(SNDREGADDR(0x2040),
(g2_read_32(SNDREGADDR(0x2040)) & ~0xff) | (left_pan << 0));
g2_write_32(SNDREGADDR(0x2044),
(g2_read_32(SNDREGADDR(0x2044)) & ~0xff) | (right_pan 
```
<Overlap Ratio: 0.9250645994832042>

---

--- 246 --
Question ID: b14983e5a0f4f2c9b9d92dd41909a6fa9e6f2a99_3
Original Code:
```
EXPORT(sqInt)
primitiveDrawString(void)
{
    sqInt bitmapOop;
    void *bitmapPtr;
    sqInt h;
    sqInt result;
    char *utf8;
    sqInt utf8Length;
    sqInt utf8Oop;
    sqInt w;

	utf8Oop = stackValue(3);
	/* begin asCString: */
	success(isBytes(utf8Oop));
	utf8 = (failed()
		? 0
		: ((char *) (firstIndexableField(utf8Oop))));
	w = stackIntegerValue(2);
	h = stackIntegerValue(1);
	bitmapOop = stackValue(0);
	/* begin cWordsPtr:minSize: */
	success((isWords(bitmapOop))
	 && ((stSizeOf(bitmapOop)) >= (w * h)));
	bitmapPtr = (failed()
		? 0
		: ((void *) (firstIndexableField(bitmapOop))));
	if (failed()) {
		return null;
	}
	utf8Length = stSizeOf(utf8Oop);
	unicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);
	result = makePointwithxValueyValue(w, h);
	popthenPush(5, result);
	return 0;
}
```


Overlapping Code:
```
primitiveDrawString(void)
{
sqInt bitmapOop;
void *bitmapPtr;
sqInt h;
sqInt result;
char *utf8;
sqInt utf8Length;
sqInt utf8Oop;
sqInt w;
utf8Oop = stackValue(3);
/* begin asCString: */
success(isBytes(utf8Oop));
utf8 = (failed()
? 0
: ((char *) (firstIndexableField(utf8Oop))));
w = stackIntegerValue(2);
h = stackIntegerValue(1);
bitmapOop = stackValue(0);
/* begin cWordsPtr:minSize: */
success((isWords(bitmapOop))
&& ((stSizeOf(bitmapOop)) >= (w * h)));
bitmapPtr = (failed()
? 0
: ((void *) (firstIndexableField(bitmapOop))));
if (failed()) {
return null;
}
utf8Length = stSizeOf(utf8Oop);
unicodeDrawString(utf8, utf8Length, &w, &h, bitmapPtr);
result = makePointwithxValueyValue(w, h);
popthen
```
<Overlap Ratio: 0.9435483870967742>

---

--- 247 --
Question ID: a939314a1dc3c74c64cebdfb9eb58237bf8ca9dc_77
Original Code:
```
static int
pthru_info_pt_list_init(int unit, size_t sid_max_count)
{
    unsigned int size;

    SHR_FUNC_ENTER(unit);

    size = sizeof(bcmltm_pt_list_t *) * sid_max_count;

    /* Allocate PT List pointers */
    SHR_ALLOC(PTHRU_PT_LIST(unit), size,
              "LTM PT Pass Thru info pt_list ptrs");
    SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);
    sal_memset(PTHRU_PT_LIST(unit), 0, size);

 exit:
    if (SHR_FUNC_ERR()) {
        pthru_info_pt_list_cleanup(unit);
    }

    SHR_FUNC_EXIT();
}
```


Overlapping Code:
```
e_t sid_max_count)
{
unsigned int size;
SHR_FUNC_ENTER(unit);
size = sizeof(bcmltm_pt_list_t *) * sid_max_count;
/* Allocate PT List pointers */
SHR_ALLOC(PTHRU_PT_LIST(unit), size,
"LTM PT Pass Thru info pt_list ptrs");
SHR_NULL_CHECK(PTHRU_PT_LIST(unit), SHR_E_MEMORY);
sal_memset(PTHRU_PT_LIST(unit), 0, size);
exit:
if (SHR_FUNC_ERR()) {
pthru_info_
```
<Overlap Ratio: 0.795045045045045>

---

--- 248 --
Question ID: be5eab08edc7d9a05186969e889c309ea32eec48_0
Original Code:
```
class SensorData : public Streamable
{
public:
  ENUM(Sensor,
    gyroX,
    gyroY,
    gyroZ,
    accX,
    accY,
    accZ,
    batteryLevel,
    fsrLFL,     //the feetsensors of the Nao-Robot
    fsrLFR,
    fsrLBL,
    fsrLBR,
    fsrRFL,
    fsrRFR,
    fsrRBL,
    fsrRBR,
    usL,
    usR,
    angleX,
    angleY
  );

  enum
  {
    off = JointData::off /**< A special value to indicate that the sensor is missing. */
  };

  ENUM(UsActuatorMode,
    leftToLeft,
    leftToRight,
    rightToLeft,
    rightToRight
  );

  float data[numOfSensors]; /**< The data of all sensors. */
  float currents[JointData::numOfJoints]; /**< The currents of all motors. */
  unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */
  unsigned timeStamp; /**< The time when the sensor data was received. */

  UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \c data[usL] and \c data[usR]. */
  unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */

  /**
  * Default constructor.
  */
  SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)
  {
    for(int i = 0; i < numOfSensors; ++i)
      data[i] = off;
    for(int i = 0; i < JointData::numOfJoints; ++i)
      currents[i] = temperatures[i] = 0;
  }
```


Overlapping Code:
```

public:
ENUM(Sensor,
gyroX,
gyroY,
gyroZ,
accX,
accY,
accZ,
batteryLevel,
fsrLFL, //the feetsensors of the Nao-Robot
fsrLFR,
fsrLBL,
fsrLBR,
fsrRFL,
fsrRFR,
fsrRBL,
fsrRBR,
usL,
usR,
angleX,
angleY
);
enum
{
off = JointData::off /**< A special value to indicate that the sensor is missing. */
};
ENUM(UsActuatorMode,
leftToLeft,
leftToRight,
rightToLeft,
rightToRight
);
float data[numOfSensors]; /**< The data of all sensors. */
float currents[JointData::numOfJoints]; /**< The currents of all motors. */
unsigned char temperatures[JointData::numOfJoints]; /**< The temperature of all motors. */
unsigned timeStamp; /**< The time when the sensor data was received. */
UsActuatorMode usActuatorMode; /**< The ultrasonice measure method which was used for measuring \c data[usL] and \c data[usR]. */
unsigned usTimeStamp; /**< The time when the ultrasonic measurements were taken. */
/**
* Default constructor.
*/
SensorData() : timeStamp(0), usActuatorMode(leftToLeft), usTimeStamp(0)
{
for(int i = 0; i < numOfSensors; ++i)
data[i] = off;
for(int i = 0; i < JointData::numOfJoints; ++i)
currents[i]
```
<Overlap Ratio: 0.945829750644884>

---

--- 249 --
Question ID: 01ba74950a39cb2b41656d82f17565f6521db65e_1
Original Code:
```
unit_t* protobuf_unit_reserved_id_new()
{
    struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));
    unit->super.size    =   sizeof(struct protobuf_unit_reserved_id_t);
    unit->super.prev    =   NULL;
    unit->super.mo      =   NULL;
    unit->super.del     =   free;
    unit->super.accept  =   protobuf_unit_reserved_id_accept;
    unit->state         =   0;
    return (struct unit_t*)(unit);
}
```


Overlapping Code:
```
uf_unit_reserved_id_new()
{
struct protobuf_unit_reserved_id_t* unit = (struct protobuf_unit_reserved_id_t*)malloc(sizeof(struct protobuf_unit_reserved_id_t));
unit->super.size = sizeof(struct protobuf_unit_reserved_id_t);
unit->super.prev = NULL;
unit->super.mo = NULL;
unit->super.del = free;
unit->super.accept = protobuf_unit_reserved_id_accept;
unit->state = 0;
return (struct unit_t*)(un
```
<Overlap Ratio: 0.9515738498789347>

---

--- 250 --
Question ID: 6259df028241962e7e75a58ca1332ecee0f97a39_9
Original Code:
```
int ts_db_get(ts_db * self, char * table, char * key_name, MDB_val * val) {

    // get a value from a given table
    MDB_val key;

    key.mv_size = strlen(key_name);
    key.mv_data = key_name;

    int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);
    return res == MDB_NOTFOUND ? TS_KEY_NOT_FOUND : TS_SUCCESS;
}
```


Overlapping Code:
```
 self, char * table, char * key_name, MDB_val * val) {
// get a value from a given table
MDB_val key;
key.mv_size = strlen(key_name);
key.mv_data = key_name;
int res = mdb_get(self->current_txn->txn, _get_dbi(self, table), &key, val);
return res == MDB_
```
<Overlap Ratio: 0.7981072555205048>

---

--- 251 --
Question ID: 12615d6fdd78bd944ebf9b0af1430871738316dd_3
Original Code:
```
void	game(t_shapes *shapes, t_pars *pars, t_game *game)
{
  char	**board;
  t_pos	*pos;
  int	action;
  int	count;

  init_board(&board, pars, &pos, &count);
  while (check_loss(board))
    {
      pos = rand_next(pos, shapes, pars);
      while (pos->index != -1)
	{
	  if ((action = get_action(pars)))
	    {
	      if (my_pause(game, action))
		if (apply_action(action, board, pos, shapes))
		  return ;
	      display(board, pos, game, pars);
	    }
	  if (count >= 400 && !game->pause.paused)
	    count = falling_time(board, pos, game, pars);
	  while (check_fulline(board, game))
	    display(board, pos, game, pars);
	  one_turn(&count, game);
	}
    }
}
```


Overlapping Code:
```
 *shapes, t_pars *pars, t_game *game)
{
char **board;
t_pos *pos;
int action;
int count;
init_board(&board, pars, &pos, &count);
while (check_loss(board))
{
pos = rand_next(pos, shapes, pars);
while (pos->index != -1)
{
if ((action = get_action(pars)))
{
if (my_pause(game, action))
if (apply_action(action, board, pos, shapes))
return ;
display(board, pos, game, pars);
}
if (count >= 400 && !game->pause.paused)
count = falling_time(board, pos, game, pars);
while (check_fulline(board, game))
display(board, pos, game, pars);
one_turn(&count, game)
```
<Overlap Ratio: 0.9565217391304348>

---

--- 252 --
Question ID: 72705ffb3fb44e73e2627954d282445331a96524_1
Original Code:
```
static PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)
{
#if 0  /* If someone knows how to get a proper 'self' in that case... */
	BPy_StructRNA *pyrna = (BPy_StructRNA *)self;
	Main *bmain = pyrna->ptr.data;
#else
	Main *bmain = G.main;  /* XXX Ugly, but should work! */
#endif

	static const char *kwlist[] = {"subset", "key_types", "value_types", NULL};
	PyObject *subset = NULL;

	PyObject *key_types = NULL;
	PyObject *val_types = NULL;
	BLI_bitmap *key_types_bitmap = NULL;
	BLI_bitmap *val_types_bitmap = NULL;

	PyObject *ret = NULL;


	if (!PyArg_ParseTupleAndKeywords(
	        args, kwds, "|O$O!O!:user_map", (char **)kwlist,
	        &subset,
	        &PySet_Type, &key_types,
	        &PySet_Type, &val_types))
	{
		return NULL;
	}

	if (key_types) {
		key_types_bitmap = pyrna_set_to_enum_bitmap(
		        rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, "key types");
		if (key_types_bitmap == NULL) {
			goto error;
		}
	}

	if (val_types) {
		val_types_bitmap = pyrna_set_to_enum_bitmap(
		        rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, "value types");
		if (val_types_bitmap == NULL) {
			goto error;
		}
	}

	IDUserMapData data_cb = {NULL};

	if (subset) {
		PyObject *subset_fast = PySequence_Fast(subset, "user_map");
		if (subset_fast == NULL) {
			goto error;
		}

		PyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);
		Py_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);

		data_cb.user_map = _PyDict_NewPresized(subset_len);
		data_cb.is_subset = true;
		for (; subset_len; subset_array++, subset_len--) {
			PyObject *set = PySet_New(NULL);
			PyDict_SetItem(data_cb.user_map, *subset_array, set);
			Py_DECREF(set);
		}
		Py_DECREF(subset_fast);
	}
	else {
		data_cb.user_map = PyDict_New();
	}

	data_cb.types_bitmap = key_types_bitmap;

	ListBase *lb_array[MAX_LIBARRAY];
	int lb_index;
	lb_index = set_listbasepointers(bmain, lb_array);

	while (lb_index--) {

		if (val_types_bitmap && lb_array[lb_index]->first) {
			if (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {
				continue;
			}
		}

		for (ID *id = lb_array[lb_index]->first; id; id = id->next) {
			/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback
			 * to avoid having to rebuild a complete bpyrna object each time for the key searching
			 * (where only ID pointer value is used). */
			if (data_cb.py_id_key_lookup_only == NULL) {
				data_cb.py_id_key_lookup_only = pyrna_id_CreatePyObject(id);
			}

			if (!data_cb.is_subset) {
				PyObject *key = data_cb.py_id_key_lookup_only;
				PyObject *set;

				RNA_id_pointer_create(id, &((BPy_StructRNA *)key)->ptr);

				/* We have to insert the key now, otherwise ID unused would be missing from final dict... */
				if ((set = PyDict_GetItem(data_cb.user_map, key)) == NULL) {
					/* Cannot use our placeholder key here! */
					key = pyrna_id_CreatePyObject(id);
					set = PySet_New(NULL);
					PyDict_SetItem(data_cb.user_map, key, set);
					Py_DECREF(set);
					Py_DECREF(key);
				}
			}

			data_cb.id_curr = id;
			BKE_library_foreach_ID_link(NULL, id, foreach_libblock_id_user_map_callback, &data_cb, IDWALK_CB_NOP);

			if (data_cb.py_id_curr) {
				Py_DECREF(data_cb.py_id_curr);
				data_cb.py_id_curr = NULL;
			}
		}
	}

	ret = data_cb.user_map;


error:

	Py_XDECREF(data_cb.py_id_key_lookup_only);

	if (key_types_bitmap) {
		MEM_freeN(key_types_bitmap);
	}

	if (val_types_bitmap) {
		MEM_freeN(val_types_bitmap);
	}

	return ret;

}
```


Overlapping Code:
```
tatic PyObject *bpy_user_map(PyObject *UNUSED(self), PyObject *args, PyObject *kwds)
{
#if 0 /* If someone knows how to get a proper 'self' in that case... */
BPy_StructRNA *pyrna = (BPy_StructRNA *)self;
Main *bmain = pyrna->ptr.data;
#else
Main *bmain = G.main; /* XXX Ugly, but should work! */
#endif
static const char *kwlist[] = {"subset", "key_types", "value_types", NULL};
PyObject *subset = NULL;
PyObject *key_types = NULL;
PyObject *val_types = NULL;
BLI_bitmap *key_types_bitmap = NULL;
BLI_bitmap *val_types_bitmap = NULL;
PyObject *ret = NULL;
if (!PyArg_ParseTupleAndKeywords(
args, kwds, "|O$O!O!:user_map", (char **)kwlist,
&subset,
&PySet_Type, &key_types,
&PySet_Type, &val_types))
{
return NULL;
}
if (key_types) {
key_types_bitmap = pyrna_set_to_enum_bitmap(
rna_enum_id_type_items, key_types, sizeof(short), true, USHRT_MAX, "key types");
if (key_types_bitmap == NULL) {
goto error;
}
}
if (val_types) {
val_types_bitmap = pyrna_set_to_enum_bitmap(
rna_enum_id_type_items, val_types, sizeof(short), true, USHRT_MAX, "value types");
if (val_types_bitmap == NULL) {
goto error;
}
}
IDUserMapData data_cb = {NULL};
if (subset) {
PyObject *subset_fast = PySequence_Fast(subset, "user_map");
if (subset_fast == NULL) {
goto error;
}
PyObject **subset_array = PySequence_Fast_ITEMS(subset_fast);
Py_ssize_t subset_len = PySequence_Fast_GET_SIZE(subset_fast);
data_cb.user_map = _PyDict_NewPresized(subset_len);
data_cb.is_subset = true;
for (; subset_len; subset_array++, subset_len--) {
PyObject *set = PySet_New(NULL);
PyDict_SetItem(data_cb.user_map, *subset_array, set);
Py_DECREF(set);
}
Py_DECREF(subset_fast);
}
else {
data_cb.user_map = PyDict_New();
}
data_cb.types_bitmap = key_types_bitmap;
ListBase *lb_array[MAX_LIBARRAY];
int lb_index;
lb_index = set_listbasepointers(bmain, lb_array);
while (lb_index--) {
if (val_types_bitmap && lb_array[lb_index]->first) {
if (!id_check_type(lb_array[lb_index]->first, val_types_bitmap)) {
continue;
}
}
for (ID *id = lb_array[lb_index]->first; id; id = id->next) {
/* One-time init, ID is just used as placeholder here, we abuse this in iterator callback
* to avoid having to rebuild a complete bpyrna object each time for the key searching
* (where only ID pointer value is used). */
if (data_cb.py_id_key_lookup_only == NULL) {
```
<Overlap Ratio: 0.9939393939393939>

---

--- 253 --
Question ID: 1c51b61ac37e952dd39b79b3b25537a4efea7b9c_0
Original Code:
```
class RenderTangents
{
public:
  RenderTangents(Logger logger, App* app);
  ~RenderTangents();

  void init();

  void update(Vector<Mesh*>& meshes);

  void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);

private:
  Logger logger;
  App* app = nullptr;

  struct MeshData
  {
    Mesh* src = nullptr;
    uint32_t geometryGeneration = 0;
    RenderBufferHandle vtx;
    RenderBufferHandle tan;
    RenderBufferHandle bnm;
    uint32_t triangleCount = 0;
  };
  Vector<MeshData> meshData;
  Vector<MeshData> newMeshData;
  RenderBufferHandle coordSysVtxCol;
  ShaderHandle vertexShader;
  ShaderHandle fragmentShader;
  PipelineHandle pipeline;
  uint32_t viewport[4];

  void buildPipelines(RenderPassHandle pass);
}
```


Overlapping Code:
```
s RenderTangents
{
public:
RenderTangents(Logger logger, App* app);
~RenderTangents();
void init();
void update(Vector<Mesh*>& meshes);
void draw(VkCommandBuffer cmdBuf, RenderPassHandle pass, const Vec4f& viewport, const Mat3f& N, const Mat4f& MVP);
private:
Logger logger;
App* app = nullptr;
struct MeshData
{
Mesh* src = nullptr;
uint32_t geometryGeneration = 0;
RenderBufferHandle vtx;
RenderBufferHandle tan;
RenderBufferHandle bnm;
uint32_t triangleCount = 0;
};
Vector<MeshData> meshData;
Vector<MeshData> newMeshData;
RenderBufferHandle coordSysVtxCol;
ShaderHandle vertexShader;
ShaderHandle fragmentShader;
PipelineHandle pipeline;
uint32_t viewport[4];
void buildPipelines(RenderPassHandle pas
```
<Overlap Ratio: 0.9873949579831933>

---

--- 254 --
Question ID: c342a2bd23d35860aab57193cd695a466621ef0c_3
Original Code:
```
int main(char argc, char **argv)
{
	int retval = 255;

	init_signals();
	init_vars();
	parse_args(argc, argv);
	init_shell();
	retval = ush_main_loop();
	uninit_shell();
	return retval;
}
```


Overlapping Code:
```
t main(char argc, char **argv)
{
int retval = 255;
init_signals();
init_vars();
parse_args(argc, argv);
init_shell();
retval = ush_main_loop();
uninit
```
<Overlap Ratio: 0.8426966292134831>

---

--- 255 --
Question ID: ca469d18395872ad767d38c867a958a18386a443_27
Original Code:
```
void radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)
{
	vm->id = 0;
	vm->fence = NULL;
	sx_init(&vm->mutex, "drm__radeon_vm__mutex");
	INIT_LIST_HEAD(&vm->list);
	INIT_LIST_HEAD(&vm->va);
}
```


Overlapping Code:
```
t(struct radeon_device *rdev, struct radeon_vm *vm)
{
vm->id = 0;
vm->fence = NULL;
sx_init(&vm->mutex, "drm__radeon_vm__mutex");
INIT_LIST_HEAD(&vm->list);
INIT_
```
<Overlap Ratio: 0.8059701492537313>

---

--- 256 --
Question ID: 655175928e7e666dc5dcb7db8a2652bce8102f62_51
Original Code:
```
static struct ieee80211_node *
mwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])
{
	struct ieee80211com *ic = vap->iv_ic;
	struct mwl_softc *sc = ic->ic_ifp->if_softc;
	const size_t space = sizeof(struct mwl_node);
	struct mwl_node *mn;

	mn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);
	if (mn == NULL) {
		/* XXX stat+msg */
		return NULL;
	}
	DPRINTF(sc, MWL_DEBUG_NODE, "%s: mn %p\n", __func__, mn);
	return &mn->mn_node;
}
```


Overlapping Code:
```
tatic struct ieee80211_node *
mwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])
{
struct ieee80211com *ic = vap->iv_ic;
struct mwl_softc *sc = ic->ic_ifp->if_softc;
const size_t space = sizeof(struct mwl_node);
struct mwl_node *mn;
mn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);
if (mn == NULL) {
/* XXX stat+msg */
return NULL;
}
DPRINTF(sc, MWL_DEBUG_NODE, "%s: mn
```
<Overlap Ratio: 0.8968609865470852>

---

--- 257 --
Question ID: 15c90ec3cf839205ea51ea962251a9b87ffa7e7f_7
Original Code:
```
static int acquire_mutex(DDP_SCENARIO_ENUM scenario)
{
/* /: primay use mutex 0 */
	int mutex_id = 0;
	DDP_MANAGER_CONTEXT *content = _get_context();
	int mutex_idx_free = content->mutex_idx;

	ASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);
	while (mutex_idx_free) {
		if (mutex_idx_free & 0x1) {
			content->mutex_idx &= (~(0x1 << mutex_id));
			mutex_id += DISP_MUTEX_DDP_FIRST;
			break;
		}
		mutex_idx_free >>= 1;
		++mutex_id;
	}
	ASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));
	DISP_LOG_I("scenario %s acquire mutex %d , left mutex 0x%x!\n",
		   ddp_get_scenario_name(scenario), mutex_id, content->mutex_idx);
	return mutex_id;
}
```


Overlapping Code:
```
NUM scenario)
{
/* /: primay use mutex 0 */
int mutex_id = 0;
DDP_MANAGER_CONTEXT *content = _get_context();
int mutex_idx_free = content->mutex_idx;
ASSERT(scenario >= 0 && scenario < DDP_SCENARIO_MAX);
while (mutex_idx_free) {
if (mutex_idx_free & 0x1) {
content->mutex_idx &= (~(0x1 << mutex_id));
mutex_id += DISP_MUTEX_DDP_FIRST;
break;
}
mutex_idx_free >>= 1;
++mutex_id;
}
ASSERT(mutex_id < (DISP_MUTEX_DDP_FIRST + DISP_MUTEX_DDP_COUNT));
DISP_LOG_I("scenario %s acquire mutex %d , left mutex 0x%x!\n",
ddp_get_scenario_name(scenario), mutex_id, content->mutex_
```
<Overlap Ratio: 0.9001584786053882>

---

--- 258 --
Question ID: b73e87256982933d096078c5b2655e5361bf94f8_2
Original Code:
```
uint8_t w3d_Map_GetValue(w3d_Map* map, int x, int y) {
	assert(map != NULL);
	uint8_t* value = map->dataWall+((x*map->width)+y); 
	return *value;
}
```


Overlapping Code:
```
lue(w3d_Map* map, int x, int y) {
assert(map != NULL);
uint8_t* value = map->dataWall+((x*map->width)+y
```
<Overlap Ratio: 0.7152777777777778>

---

--- 259 --
Question ID: 635b52a51aefb39eca2232d7510d9b1808c37b25_4
Original Code:
```
static int lua_estop_display(lua_State *L){
  int row = luaL_optnumber(L, 1,1);
  const char * text= luaL_checkstring (L, 2);

  estop_display(row,text);
  return 1;
}
```


Overlapping Code:
```
atic int lua_estop_display(lua_State *L){
int row = luaL_optnumber(L, 1,1);
const char * text= luaL_checkstring (L, 2);
estop_display(row,text);
retur
```
<Overlap Ratio: 0.9493670886075949>

---

--- 260 --
Question ID: 55a23909fad29635c3535f2e947608df579e25bf_1
Original Code:
```
DataType remove( DataType value )
  {
    int n = count + 1;
    DataType* cur = data - 1;
    while (--n)
    {
      if (*(++cur) == value)
      {
        if (--n)
        {
          memmove( cur, cur+1, sizeof(DataType) * n );
        }
        --count;
        return value;
      }
    }
    return value;
  }
```


Overlapping Code:
```

{
int n = count + 1;
DataType* cur = data - 1;
while (--n)
{
if (*(++cur) == value)
{
if (--n)
{
memmove( cur, cur+1, sizeof(DataType) * n );
}
--cou
```
<Overlap Ratio: 0.6818181818181818>

---

--- 261 --
Question ID: 5c9f565ea0e88840c3c3c7a031e20180c3c8025d_14
Original Code:
```
static void iser_free_ib_conn_res(struct iser_conn *iser_conn,
				  bool destroy)
{
	struct ib_conn *ib_conn = &iser_conn->ib_conn;
	struct iser_device *device = ib_conn->device;

	iser_info("freeing conn %p cma_id %p qp %p\n",
		  iser_conn, ib_conn->cma_id, ib_conn->qp);

	if (ib_conn->qp != NULL) {
		ib_conn->comp->active_qps--;
		rdma_destroy_qp(ib_conn->cma_id);
		ib_conn->qp = NULL;
	}

	if (destroy) {
		if (iser_conn->rx_descs)
			iser_free_rx_descriptors(iser_conn);

		if (device != NULL) {
			iser_device_try_release(device);
			ib_conn->device = NULL;
		}
	}
}
```


Overlapping Code:
```
atic void iser_free_ib_conn_res(struct iser_conn *iser_conn,
bool destroy)
{
struct ib_conn *ib_conn = &iser_conn->ib_conn;
struct iser_device *device = ib_conn->device;
iser_info("freeing conn %p cma_id %p qp %p\n",
iser_conn, ib_conn->cma_id, ib_conn->qp);
if (ib_conn->qp != NULL) {
ib_conn->comp->active_qps--;
rdma_destroy_qp(ib_conn->cma_id);
ib_conn->qp = NULL;
}
if (destroy) {
if (iser_conn->rx_descs)
iser_free_rx_descriptors(iser_conn);
if (device != NULL) {
iser_device_try_release(device)
```
<Overlap Ratio: 0.9382022471910112>

---

--- 262 --
Question ID: 3237c2875448890e183441754d4993ba5578d690_0
Original Code:
```
static inline uint16 fold_32bit_checksum (uint32 sum)
{
   /*  Fold 32-bit sum to 16 bits */
   while (sum>>16) {
      sum = (sum & 0xffff) + (sum >> 16);
   }
   sum = ~sum & 0xffff;
   if (sum == 0) {
      sum = 0xffff;
   }
   return (sum);
}
```


Overlapping Code:
```
sum (uint32 sum)
{
/* Fold 32-bit sum to 16 bits */
while (sum>>16) {
sum = (sum & 0xffff) + (sum >> 16);
}
sum = ~sum & 0xffff;
if (sum == 0) {
sum = 
```
<Overlap Ratio: 0.7089201877934272>

---

--- 263 --
Question ID: e2d6015282dadd03c6e74e4c95822f2d21160ac5_14
Original Code:
```
static CDFstatus ValidateAttributeEntryLink (struct CDFstruct *CDF, vFILE *fp, 
                                      Int32 num, Logical zEntry, OFF_T EDRhead,
                                             Int32 numEntries, Int32 maxEntry, 
                                             Logical debug)
{
  CDFstatus status;
  OFF_T offset, nextAEDR;
  Int32 entryNum, lastNum, *visits;
  int ix, iy;
  
  offset = EDRhead;
  lastNum = 0;
  visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);
  if (visits == NULL) return BAD_MALLOC;
  for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;
  ix = 0;
  while (offset != 0) {
    status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);
    if (status != CDF_OK) { 
      cdf_FreeMemory (visits, NULL);
      return status;
    }
    status = ReadAEDR64 (fp, offset,
                         AEDR_NUM, &entryNum,
                         AEDR_AEDRNEXT, &nextAEDR,
                         AEDR_NULL);
    if (ix > 0) {
      for (iy = 0; iy < ix; ++iy) {
        if (visits[iy] == entryNum) {
          cdf_FreeMemory (visits, NULL);
          return QuitCDF ("CDF: entry number is repeating in an attribute entry link: ", (OFF_T) -1,
                          4, 1, &entryNum, 0, debug);
        }
      }
    }
    if (ix == (int) numEntries) {
      cdf_FreeMemory (visits, NULL);
      return QuitCDF ("CDF: number of entries is more than maximum in an attribute entry link: ", (OFF_T) -1,
                      4, 1, &ix, 0, debug);
    }
    visits[ix] = entryNum;
    ++ix;
    if (lastNum < entryNum) lastNum = entryNum;
    offset = nextAEDR;
  }
  if (lastNum != maxEntry) {
    cdf_FreeMemory (visits, NULL);
    return QuitCDF ("CDF: last entry number is not the maximum entry number in  an attribute entry link: ", (OFF_T) -1,
                    4, 2, &lastNum, &maxEntry, debug);
  }
  cdf_FreeMemory (visits, NULL);
  return CDF_OK;
}
```


Overlapping Code:
```
buteEntryLink (struct CDFstruct *CDF, vFILE *fp, 
Int32 num, Logical zEntry, OFF_T EDRhead,
Int32 numEntries, Int32 maxEntry, 
Logical debug)
{
CDFstatus status;
OFF_T offset, nextAEDR;
Int32 entryNum, lastNum, *visits;
int ix, iy;

offset = EDRhead;
lastNum = 0;
visits = (Int32 *) cdf_AllocateMemory ((size_t)numEntries * sizeof(Int32), NULL);
if (visits == NULL) return BAD_MALLOC;
for (ix = 0; ix < numEntries; ++ix) visits[ix] = 0;
ix = 0;
while (offset != 0) {
status = ValidateAEDR (CDF, fp, offset, num, maxEntry, zEntry, debug);
if (status != CDF_OK) { 
cdf_FreeMemory (visits, NULL);
return status;
}
status = ReadAEDR64 (fp, offset,
AEDR_NUM, &entryNum,
AEDR_AEDRNEXT, &nextAEDR,
AEDR_NULL);
if (ix > 0) {
for (iy = 0; iy < ix; ++iy) {
if (visits[iy] == entryNum) {
cdf_FreeMemory (visits, NULL);
return QuitCDF ("CDF: entry number is repeating in an attribute entry link: ", (OFF_T) -1,
4, 1, &entryNum, 0, debug);
}
}
}
if (ix == (int) numEntries) {
cdf_FreeMemory (visits, NULL);
return QuitCDF ("CDF: number of entries is more than maximum in an attribute entry link: ", (OFF_T) -1,
4, 1, &ix, 0, debug);
}
visits[ix] = entryNum;
++ix;
if (lastNum < entryNum) lastNum = entryNum;
offset = nextAEDR;
}
if (lastNum != maxEntry) {
cdf_FreeMemory (visits, NULL);
return QuitCDF ("CDF: last entry number is not the maximum entry number in an attribute entry link: ", (OFF_T) -1,
4, 2, &lastNum, &maxEntry, debug);
}
cdf_FreeMemory (visits, 
```
<Overlap Ratio: 0.9647371922821024>

---

--- 264 --
Question ID: 264c01590be5a4d3c4b170ff9e5c6a10fde26fe6_5
Original Code:
```
static apr_size_t calc_header_size(serf_bucket_t *hdrs)
{
    apr_size_t size = 0;

    serf_bucket_headers_do(hdrs, count_size, &size);

    return size;
}
```


Overlapping Code:
```
apr_size_t calc_header_size(serf_bucket_t *hdrs)
{
apr_size_t size = 0;
serf_bucket_headers_do(hdrs,
```
<Overlap Ratio: 0.704225352112676>

---

--- 265 --
Question ID: f8e559e0665135bd935b5e3a04fe8fe495abe150_4
Original Code:
```
void SimonEncrypt96(uint64_t *SR, uint64_t *SL, const uint64_t *k)
{
	uint64_t x = SL[0]; uint64_t y = SR[0];
	uint64_t tmp = 0;
	int i;

	for (i = 0; i < 52; i++)
	{
		tmp = x;
		x = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];
		y = tmp;
	};
	SL[0] = x & 0xffffffffffff; SR[0] = y & 0xffffffffffff;
}
```


Overlapping Code:
```
*SL, const uint64_t *k)
{
uint64_t x = SL[0]; uint64_t y = SR[0];
uint64_t tmp = 0;
int i;
for (i = 0; i < 52; i++)
{
tmp = x;
x = y ^ ROTL2(1, x, 48) & ROTL2(8, x, 48) ^ ROTL2(2, x, 48) ^ k[i];
y = tmp;
};
SL[0] = x & 0xffffffffffff; SR[0] = y & 0xf
```
<Overlap Ratio: 0.8143322475570033>

---

--- 266 --
Question ID: 6323ef783b9e7c97dfc7c14da3749f0a6e9c7a59_0
Original Code:
```
interface GEOCarInfo : PBCodable <NSCopying> {

	GEOScreenResolution _screenResolution;
	int _deviceConnection;
	int _interactionModel;
	NSString* _manufacturer;
	NSString* _model;
	SCD_Struct_GE20 _has;

}
```


Overlapping Code:
```
<NSCopying> {
GEOScreenResolution _screenResolution;
int _deviceConnection;
int _interactionModel;
NSString* _manufacturer;
NSString* _model;
SCD_Stru
```
<Overlap Ratio: 0.7575757575757576>

---

--- 267 --
Question ID: 4c98b423dd0b870ec55930c4095eb7fb38af3568_57
Original Code:
```
static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
    int number = __Pyx_BufFmt_ParseNumber(ts);
    if (number == -1) 
        PyErr_Format(PyExc_ValueError,\
                     "Does not understand character buffer dtype format string ('%c')", **ts);
    return number;
}
```


Overlapping Code:
```
static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
int number = __Pyx_BufFmt_ParseNumber(ts);
if (number == -1) 
PyErr_Format(PyExc_ValueError,\
"Does not understand character buffer dtype format string ('%c')", **ts);
return number;
}
```
<Overlap Ratio: 1.0>

---

--- 268 --
Question ID: 3c4e95296087bdb9f6d02f3c7d14fb34bcbe2d6d_28
Original Code:
```
void hprdPrimaryRefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)
/* Save hprdPrimaryRef to file. */
{
if (obj == NULL) return;
xapIndent(indent, f);
fprintf(f, "<primaryRef");
fprintf(f, " db=\"%s\"", obj->db);
fprintf(f, " id=\"%s\"", obj->id);
if (obj->dbAc != NULL)
    fprintf(f, " dbAc=\"%s\"", obj->dbAc);
if (obj->refType != NULL)
    fprintf(f, " refType=\"%s\"", obj->refType);
if (obj->refTypeAc != NULL)
    fprintf(f, " refTypeAc=\"%s\"", obj->refTypeAc);
fprintf(f, "/>\n");
}
```


Overlapping Code:
```
RefSave(struct hprdPrimaryRef *obj, int indent, FILE *f)
/* Save hprdPrimaryRef to file. */
{
if (obj == NULL) return;
xapIndent(indent, f);
fprintf(f, "<primaryRef");
fprintf(f, " db=\"%s\"", obj->db);
fprintf(f, " id=\"%s\"", obj->id);
if (obj->dbAc != NULL)
fprintf(f, " dbAc=\"%s\"", obj->dbAc);
if (obj->refType != NULL)
fprintf(f, " refType=\"%s\"", obj->refType);
if (obj->refTypeAc != NULL)
fprintf(f, " refTypeAc=\"%s\"", obj->refTypeAc);
fp
```
<Overlap Ratio: 0.9278350515463918>

---

--- 269 --
Question ID: 37bfcb619ea9766dcc4d299e8139771526faa0d8_2
Original Code:
```
static GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)
{
  TageratorOptions *arguments = tool_arguments;
  GtOptionParser *op;
  GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,
           *optionpckindex, *optionmaxdepth, *optionbest;

  gt_assert(arguments != NULL);
  op = gt_option_parser_new("[options] -q tagfile [-esa|-pck] indexname",
                         "Map short sequence tags in given index.");
  gt_option_parser_set_mailaddress(op,"<kurtz@zbh.uni-hamburg.de>");
  option = gt_option_new_filenamearray("q",
                                    "Specify files containing the short "
                                    "sequence tags",
                                    arguments->tagfiles);
  gt_option_parser_add_option(op, option);
  gt_option_is_mandatory(option);

  option = gt_option_new_long("e",
                           "Specify the allowed number of differences "
                           "(replacements/insertions/deletions)",
                           &arguments->userdefinedmaxdistance,
                           -1L);
  gt_option_parser_add_option(op, option);

  optionesaindex = gt_option_new_string("esa",
                                     "Specify index (enhanced suffix array)",
                                     arguments->indexname, NULL);
  gt_option_parser_add_option(op, optionesaindex);
  arguments->refoptionesaindex = gt_option_ref(optionesaindex);

  optionpckindex = gt_option_new_string("pck",
                                     "Specify index (packed index)",
                                     arguments->indexname, NULL);
  gt_option_parser_add_option(op, optionpckindex);
  arguments->refoptionpckindex = gt_option_ref(optionpckindex);
  gt_option_exclude(optionesaindex,optionpckindex);
  gt_option_is_mandatory_either(optionesaindex,optionpckindex);

  optionmaxdepth = gt_option_new_int("maxdepth",
                                  "Use the data in the .pbt file only up to "
                                  "this depth (only relevant with option -pck)",
                                  &arguments->userdefinedmaxdepth,
                                  -1);
  gt_option_parser_add_option(op, optionmaxdepth);
  gt_option_is_development_option(optionmaxdepth);

  optiononline = gt_option_new_bool("online","Perform online searches",
                                    &arguments->doonline, false);
  gt_option_parser_add_option(op, optiononline);
  gt_option_is_development_option(optiononline);

  optioncmp = gt_option_new_bool("cmp","compare results of offline and online "
                                 "searches",
                                 &arguments->docompare, false);
  gt_option_parser_add_option(op, optioncmp);
  gt_option_exclude(optiononline,optioncmp);
  gt_option_is_development_option(optioncmp);

  optionrw = gt_option_new_bool("rw","Replace wildcard in tag by random char",
                             &arguments->replacewildcard, false);
  gt_option_parser_add_option(op, optionrw);
  gt_option_is_development_option(optionrw);

  option = gt_option_new_bool("nod","Do not compute direct matches",
                           &arguments->nofwdmatch, false);
  gt_option_parser_add_option(op, option);

  option = gt_option_new_bool("nop","Do not compute palindromic matches "
                           "(i.e. no reverse complemented matches.)",
                             &arguments->norcmatch, false);
  gt_option_parser_add_option(op, option);

  optionbest = gt_option_new_bool("best","Compute only best matches, i.e. only "
                                  "for smallest edit distance with matches",
                                  &arguments->best, false);
  gt_option_parser_add_option(op, optionbest);
  gt_option_exclude(optiononline,optionbest);
  gt_option_exclude(optioncmp,optionbest);

  option = gt_option_new_ulong_min("maxocc",
                                   "specify max number of match-occurrences",
                                   &arguments->maxintervalwidth,0,1UL);
  gt_option_parser_add_option(op, option);

  option = gt_option_new_bool("skpp",
                           "Skip prefix of pattern (only in pdiff mode)",
                           &arguments->skpp, false);
  gt_option_parser_add_option(op, option);

  option = gt_option_new_bool("withwildcards","output matches containing "
                              "wildcard characters (e.g. N); only relevant for "
                              "approximate matching",
                              &arguments->nowildcards, true);
  gt_option_parser_add_option(op, option);

  option = gt_option_new_stringarray("output",
                                     gt_str_get(arguments->outputhelp),
                                     arguments->outputspec);
  gt_option_parser_add_option(op, option);

  option = gt_option_new_verbose(&arguments->verbose);
  gt_option_parser_add_option(op, option);

  return op;
}
```


Overlapping Code:
```
c GtOptionParser* gt_tagerator_option_parser_new(void *tool_arguments)
{
TageratorOptions *arguments = tool_arguments;
GtOptionParser *op;
GtOption *option, *optionrw, *optiononline, *optioncmp, *optionesaindex,
*optionpckindex, *optionmaxdepth, *optionbest;
gt_assert(arguments != NULL);
op = gt_option_parser_new("[options] -q tagfile [-esa|-pck] indexname",
"Map short sequence tags in given index>");
option = gt_option_new_filenamearray("q",
"Specify files containing the short "
"sequence tags",
arguments->tagfiles);
gt_option_parser_add_option(op, option);
gt_option_is_mandatory(option);
option = gt_option_new_long("e",
"Specify the allowed number of differences "
"(replacements/insertions/deletions)",
&arguments->userdefinedmaxdistance,
-1L);
gt_option_parser_add_option(op, option);
optionesaindex = gt_option_new_string("esa",
"Specify index (enhanced suffix array)",
arguments->indexname, NULL);
gt_option_parser_add_option(op, optionesaindex);
arguments->refoptionesaindex = gt_option_ref(optionesaindex);
optionpckindex = gt_option_new_string("pck",
"Specify index (packed index)",
arguments->indexname, NULL);
gt_option_parser_add_option(op, optionpckindex);
arguments->refoptionpckindex = gt_option_ref(optionpckindex);
gt_option_exclude(optionesaindex,optionpckindex);
gt_option_is_mandatory_either(optionesaindex,optionpckindex);
optionmaxdepth = gt_option_new_int("maxdepth",
"Use the data in the .pbt file only up to "
"this depth (only relevant with option -pck)",
&arguments->userdefinedmaxdepth,
-1);
gt_option_parser_add_option(op, optionmaxdepth);
gt_option_is_development_option(optionmaxdepth);
optiononline = gt_option_new_bool("online","Perform online searches",
&arguments->doonline, false);
gt_option_parser_add_option(op, optiononlin
```
<Overlap Ratio: 0.9454836985569214>

---

--- 270 --
Question ID: a8a2d773786fd4a6483dec56e197b93241634bdd_60
Original Code:
```
static FILE *checkouthistofile(char *filename, qfits_header **header, qfits_header **hheader)
{
  FILE *checkouthistofile;
  int next;
  int header_startpos;

  /* First check if there is such a file and if it is a fits */
  if (qfits_is_fits(filename) != 1) {
    if (!(checkouthistofile = fopen(filename, "w+"))) {
      return NULL;
    }

    /* The file cannot have a history header */
    *hheader = NULL;

    /* Make a default primary header */
    if ((*header = qfits_header_default()) == NULL)
      return NULL;
    
    qfits_header_add(*header,"BITPIX","32",NULL,NULL);
    qfits_header_add(*header,"NAXIS","2",NULL,NULL);
    qfits_header_add(*header,"NAXIS1","100",NULL,NULL);
    qfits_header_add(*header,"NAXIS2","1",NULL,NULL);
    qfits_header_add(*header,"EXTEND","T",NULL,NULL);
    
    qfits_header_add(*header,"BSCALE","1",NULL,NULL);
    qfits_header_add(*header,"BZERO","0",NULL,NULL);
    qfits_header_add(*header,"BUNIT","'count'",NULL,NULL);
    qfits_header_add(*header,"BTYPE","' '",NULL,NULL);
    
    qfits_header_add(*header,"CDELT1", "0.0",NULL,NULL);
    qfits_header_add(*header,"CRPIX1", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRVAL1", "0.0",NULL,NULL);
    qfits_header_add(*header,"CTYPE1", "' '",NULL,NULL);
    qfits_header_add(*header,"CUNIT1", "' '",NULL,NULL);
    
    qfits_header_add(*header,"CDELT2", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRPIX2", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRVAL2", "0.0",NULL,NULL);
    qfits_header_add(*header,"CTYPE2", "' '",NULL,NULL);
    qfits_header_add(*header,"CUNIT2", "'Y'",NULL,NULL);

    qfits_header_add(*header, "TITLE1", "' '", NULL, NULL);
    qfits_header_add(*header, "TITLE2", "' '", NULL, NULL);
    qfits_header_add(*header, "RADIUS1", "0.0", NULL, NULL);
    qfits_header_add(*header, "RADIUS2", "0.0", NULL, NULL);
    qfits_header_add(*header, "HISTORY", "'Generated by ftstab'", NULL, NULL);
  }
    
  /* It is a fits file */
  else {

    /* Now check for the number of extensions */
    *hheader = checkhheader(filename);

    /* Get the number of extensions */
    next = qfits_query_n_ext(filename);

    /* Do a refresh immediately */
    qfits_cache_purge();

    if (*hheader)
      /* Get the position to put the fileposition */
      qfits_get_hdrinfo(filename, next, &header_startpos, NULL);

    /* Try to open the file */
    if (!(checkouthistofile = fopen(filename, "r+"))) {
      return NULL;
    }
    /* Go to the right position and delete the rest */

    if (*hheader) {
      fseek(checkouthistofile, (long) header_startpos, SEEK_SET);
      if(ftruncate(fileno(stream_), ftell(checkouthistofile)))
	;
      clearerr(stream_);
    }    
    else
      fseek(checkouthistofile, 0L, SEEK_END);

    /* Now make a default extension header */
    if ((*header = qfits_header_new()) == NULL)
      return NULL;

    qfits_header_append(*header,"XTENSION","'IMAGE             '","","");
    qfits_header_append(*header,"END","","","");

    qfits_header_add(*header,"BITPIX","32",NULL,NULL);
    qfits_header_add(*header,"NAXIS","2",NULL,NULL);
    qfits_header_add(*header,"NAXIS1","100",NULL,NULL);
    qfits_header_add(*header,"NAXIS2","1",NULL,NULL);
    qfits_header_add(*header,"EXTEND","T",NULL,NULL);
    
    qfits_header_add(*header,"BSCALE","1",NULL,NULL);
    qfits_header_add(*header,"BZERO","0",NULL,NULL);
    qfits_header_add(*header,"BUNIT","'count'",NULL,NULL);
    qfits_header_add(*header,"BTYPE","' '",NULL,NULL);
    
    qfits_header_add(*header,"CDELT1", "0.0",NULL,NULL);
    qfits_header_add(*header,"CRPIX1", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRVAL1", "0.0",NULL,NULL);
    qfits_header_add(*header,"CTYPE1", "' '",NULL,NULL);
    qfits_header_add(*header,"CUNIT1", "' '",NULL,NULL);
    
    qfits_header_add(*header,"CDELT2", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRPIX2", "1.0",NULL,NULL);
    qfits_header_add(*header,"CRVAL2", "0.0",NULL,NULL);
    qfits_header_add(*header,"CTYPE2", "' '",NULL,NULL);
    qfits_header_add(*header,"CUNIT2", "'Y'",NULL,NULL);

    qfits_header_add(*header, "TITLE1", "' '", NULL, NULL);
    qfits_header_add(*header, "TITLE2", "' '", NULL, NULL);
    qfits_header_add(*header, "RADIUS1", "0.0", NULL, NULL);
    qfits_header_add(*header, "RADIUS2", "0.0", NULL, NULL);
    qfits_header_add(*header, "HISTORY", "'generated by ftstab'", NULL, NULL);
  }

  return checkouthistofile;
}
```


Overlapping Code:
```
le(char *filename, qfits_header **header, qfits_header **hheader)
{
FILE *checkouthistofile;
int next;
int header_startpos;
/* First check if there is such a file and if it is a fits */
if (qfits_is_fits(filename) != 1) {
if (!(checkouthistofile = fopen(filename, "w+"))) {
return NULL;
}
/* The file cannot have a history header */
*hheader = NULL;
/* Make a default primary header */
if ((*header = qfits_header_default()) == NULL)
return NULL;

qfits_header_add(*header,"BITPIX","32",NULL,NULL);
qfits_header_add(*header,"NAXIS","2",NULL,NULL);
qfits_header_add(*header,"NAXIS1","100",NULL,NULL);
qfits_header_add(*header,"NAXIS2","1",NULL,NULL);
qfits_header_add(*header,"EXTEND","T",NULL,NULL);

qfits_header_add(*header,"BSCALE","1",NULL,NULL);
qfits_header_add(*header,"BZERO","0",NULL,NULL);
qfits_header_add(*header,"BUNIT","'count'",NULL,NULL);
qfits_header_add(*header,"BTYPE","' '",NULL,NULL);

qfits_header_add(*header,"CDELT1", "0.0",NULL,NULL);
qfits_header_add(*header,"CRPIX1", "1.0",NULL,NULL);
qfits_header_add(*header,"CRVAL1", "0.0",NULL,NULL);
qfits_header_add(*header,"CTYPE1", "' '",NULL,NULL);
qfits_header_add(*header,"CUNIT1", "' '",NULL,NULL);

qfits_header_add(*header,"CDELT2", "1.0",NULL,NULL);
qfits_header_add(*header,"CRPIX2", "1.0",NULL,NULL);
qfits_header_add(*header,"CRVAL2", "0.0",NULL,NULL);
qfits_header_add(*header,"CTYPE2", "' '",NULL,NULL);
qfits_header_add(*header,"CUNIT2", "'Y'",NULL,NULL);
qfits_header_add(*header, "TITLE1", "' '", NULL, NULL);
qfits_header_add(*header, "TITLE2", "' '", NULL, NULL);
qfits_header_add(*header, "RADIUS1", "0.0", NULL, NULL);
qfits_header_add(*header, "RADIUS2", "0.0", NULL, NULL);
qfits_header_add(*header, "HISTORY", "'Generated by ftstab'", NULL, NULL);
}

/* It is a fits file */
else {
/* Now check for the number of extensions */
*hheader = checkhheader(filename);
/* Get the number of extensions */
next = qfits_query_n_ext(filename);
/* Do a refresh immediately */
qfits_cache_purge();
if (*hheader)
/* Get the position to put the fileposition */
qfits_get_hdrinfo(filename, next, &header_startpos, NULL);
/* Try to open the file */
if (!(checkouthistofile = fopen(filename, "r+"))) {
return NULL;
}
/* Go to the rig
```
<Overlap Ratio: 0.9761061946902655>

---

--- 271 --
Question ID: f8e6e63035d02662a37b037103da54a359aab876_19
Original Code:
```
static void
propagate_follows(grammar_t self, int *changed)
{
    int i, j, k;

    /* Go through the kernels and propagate stuff */
    for (i = 0; i < self->kernel_count; i++) {
        kernel_t kernel = self->kernels[i];

        /* Go through each kernel item */
        for (j = 0; j < kernel->count; j++) {
            /* Go through the productions */
            for (k = -1; k < self->production_count; k++) {
                /* See if we propagate */
                if (k < 0 || kernel->propagates_table[j][k]) {
                    int pi;
                    int offset;

                    /* Work out the production and offset */
                    if (k < 0) {
                        offset = decode(self, kernel->pairs[j], &pi);
                    } else {
                        pi = k;
                        offset = 0;
                    }

                    /* Propagate everything in the follows table */
                    propagate_kernel_item_follows(
                        self, kernel, j,
                        self->productions[pi], offset,
                        changed);
                }
            }
        }
    }
}
```


Overlapping Code:
```
s(grammar_t self, int *changed)
{
int i, j, k;
/* Go through the kernels and propagate stuff */
for (i = 0; i < self->kernel_count; i++) {
kernel_t kernel = self->kernels[i];
/* Go through each kernel item */
for (j = 0; j < kernel->count; j++) {
/* Go through the productions */
for (k = -1; k < self->production_count; k++) {
/* See if we propagate */
if (k < 0 || kernel->propagates_table[j][k]) {
int pi;
int offset;
/* Work out the production and offset */
if (k < 0) {
offset = decode(self, kernel->pairs[j], &pi);
} else {
pi = k;
offset = 0;
}
/* Propagate everything in the follows table */
propagate_kernel_item_follows(
self, kernel, j,
se
```
<Overlap Ratio: 0.8953168044077136>

---

--- 272 --
Question ID: 23af64a6d056ce5014f2bcadea60b5a7af2922de_123
Original Code:
```
static void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)
{
    /* log the debug message */
    char *msg;
    int msglen;

    /* XXX maybe we should actually take notice of the return value */
    ssh2_pkt_getbool(pktin);
    ssh_pkt_getstring(pktin, &msg, &msglen);

    logeventf(ssh, "Remote debug message: %.*s", msglen, msg);
}
```


Overlapping Code:
```
tatic void ssh2_msg_debug(Ssh ssh, struct Packet *pktin)
{
/* log the debug message */
char *msg;
int msglen;
/* XXX maybe we should actually take notice of the return value */
ssh2_pkt_getbool(pktin);
ssh_pkt_getstring(pktin, &msg, &msglen);
logeventf(ssh, "Remote debug message: %.*s", msglen, msg)
```
<Overlap Ratio: 0.9868421052631579>

---

--- 273 --
Question ID: 4cdffa46d401a5ea6120ba5d350e453158166a31_28
Original Code:
```
static
void ufs_qcom_clk_scale_notify(struct ufs_hba *hba)
{
	struct ufs_qcom_host *host = hba->priv;
	struct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;

	if (!dev_req_params)
		return;

	ufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,
				dev_req_params->pwr_rx,
				dev_req_params->hs_rate);
}
```


Overlapping Code:
```
tic
void ufs_qcom_clk_scale_notify(struct ufs_hba *hba)
{
struct ufs_qcom_host *host = hba->priv;
struct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;
if (!dev_req_params)
return;
ufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,
dev_req_params->pwr_rx,
dev_req_params->hs
```
<Overlap Ratio: 0.9595959595959596>

---

--- 274 --
Question ID: fd8754ce9fdfa65fb27a1e98816c674e8691e1f4_24
Original Code:
```
static int
MHD_poll_all (struct MHD_Daemon *daemon,
	      int may_block)
{
  unsigned int num_connections;
  struct MHD_Connection *pos;
  struct MHD_Connection *next;

  if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&
       (MHD_YES == resume_suspended_connections (daemon)) )
    may_block = MHD_NO;

  /* count number of connections and thus determine poll set size */
  num_connections = 0;
  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)
    num_connections++;
  {
    MHD_UNSIGNED_LONG_LONG ltimeout;
    unsigned int i;
    int timeout;
    unsigned int poll_server;
    int poll_listen;
    int poll_pipe;
    struct pollfd *p;

    p = malloc(sizeof (struct pollfd) * (2 + num_connections));
    if (NULL == p)
      {
#ifdef HAVE_MESSAGES
        MHD_DLOG(daemon,
                 "Error allocating memory: %s\n",
                 MHD_strerror_(errno));
#endif
        return MHD_NO;
      }
    memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));
    poll_server = 0;
    poll_listen = -1;
    if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&
	 (daemon->connections < daemon->connection_limit) &&
         (MHD_NO == daemon->at_limit) )
      {
	/* only listen if we are not at the connection limit */
	p[poll_server].fd = daemon->socket_fd;
	p[poll_server].events = POLLIN;
	p[poll_server].revents = 0;
	poll_listen = (int) poll_server;
	poll_server++;
      }
    poll_pipe = -1;
    if (MHD_INVALID_PIPE_ != daemon->wpipe[0])
      {
	p[poll_server].fd = daemon->wpipe[0];
	p[poll_server].events = POLLIN;
	p[poll_server].revents = 0;
        poll_pipe = (int) poll_server;
	poll_server++;
      }
    if (may_block == MHD_NO)
      timeout = 0;
    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||
	      (MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )
      timeout = -1;
    else
      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;

    i = 0;
    for (pos = daemon->connections_head; NULL != pos; pos = pos->next)
      {
	p[poll_server+i].fd = pos->socket_fd;
	switch (pos->event_loop_info)
	  {
	  case MHD_EVENT_LOOP_INFO_READ:
	    p[poll_server+i].events |= POLLIN;
	    break;
	  case MHD_EVENT_LOOP_INFO_WRITE:
	    p[poll_server+i].events |= POLLOUT;
	    if (pos->read_buffer_size > pos->read_buffer_offset)
	      p[poll_server+i].events |= POLLIN;
	    break;
	  case MHD_EVENT_LOOP_INFO_BLOCK:
	    if (pos->read_buffer_size > pos->read_buffer_offset)
	      p[poll_server+i].events |= POLLIN;
	    break;
	  case MHD_EVENT_LOOP_INFO_CLEANUP:
	    timeout = 0; /* clean up "pos" immediately */
	    break;
	  }
	i++;
      }
    if (0 == poll_server + num_connections)
      {
        free(p);
        return MHD_YES;
      }
    if (MHD_sys_poll_(p, poll_server + num_connections, timeout) < 0)
      {
	if (EINTR == MHD_socket_errno_)
      {
        free(p);
        return MHD_YES;
      }
#ifdef HAVE_MESSAGES
	MHD_DLOG (daemon,
		  "poll failed: %s\n",
		  MHD_socket_last_strerr_ ());
#endif
        free(p);
	return MHD_NO;
      }
    /* handle pipe FD */
    /* do it before any other processing so
       new signals will be processed in next loop */
    if ( (-1 != poll_pipe) &&
         (0 != (p[poll_pipe].revents & POLLIN)) )
      MHD_pipe_drain_ (daemon->wpipe[0]);

    /* handle shutdown */
    if (MHD_YES == daemon->shutdown)
      {
        free(p);
        return MHD_NO;
      }
    i = 0;
    next = daemon->connections_head;
    while (NULL != (pos = next))
      {
	next = pos->next;
        /* first, sanity checks */
        if (i >= num_connections)
          continue; /* connection list changed somehow, retry later ... */
        if (p[poll_server+i].fd != pos->socket_fd)
          continue; /* fd mismatch, something else happened, retry later ... */
        call_handlers (pos,
                       0 != (p[poll_server+i].revents & POLLIN),
                       0 != (p[poll_server+i].revents & POLLOUT),
                       MHD_NO);
      }
    /* handle 'listen' FD */
    if ( (-1 != poll_listen) &&
	 (0 != (p[poll_listen].revents & POLLIN)) )
      (void) MHD_accept_connection (daemon);

    free(p);
  }
  return MHD_YES;
}
```


Overlapping Code:
```
tic int
MHD_poll_all (struct MHD_Daemon *daemon,
int may_block)
{
unsigned int num_connections;
struct MHD_Connection *pos;
struct MHD_Connection *next;
if ( (MHD_USE_SUSPEND_RESUME == (daemon->options & MHD_USE_SUSPEND_RESUME)) &&
(MHD_YES == resume_suspended_connections (daemon)) )
may_block = MHD_NO;
/* count number of connections and thus determine poll set size */
num_connections = 0;
for (pos = daemon->connections_head; NULL != pos; pos = pos->next)
num_connections++;
{
MHD_UNSIGNED_LONG_LONG ltimeout;
unsigned int i;
int timeout;
unsigned int poll_server;
int poll_listen;
int poll_pipe;
struct pollfd *p;
p = malloc(sizeof (struct pollfd) * (2 + num_connections));
if (NULL == p)
{
#ifdef HAVE_MESSAGES
MHD_DLOG(daemon,
"Error allocating memory: %s\n",
MHD_strerror_(errno));
#endif
return MHD_NO;
}
memset (p, 0, sizeof (struct pollfd) * (2 + num_connections));
poll_server = 0;
poll_listen = -1;
if ( (MHD_INVALID_SOCKET != daemon->socket_fd) &&
(daemon->connections < daemon->connection_limit) &&
(MHD_NO == daemon->at_limit) )
{
/* only listen if we are not at the connection limit */
p[poll_server].fd = daemon->socket_fd;
p[poll_server].events = POLLIN;
p[poll_server].revents = 0;
poll_listen = (int) poll_server;
poll_server++;
}
poll_pipe = -1;
if (MHD_INVALID_PIPE_ != daemon->wpipe[0])
{
p[poll_server].fd = daemon->wpipe[0];
p[poll_server].events = POLLIN;
p[poll_server].revents = 0;
poll_pipe = (int) poll_server;
poll_server++;
}
if (may_block == MHD_NO)
timeout = 0;
else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||
(MHD_YES != MHD_get_timeout (daemon, &ltimeout)) )
timeout = -1;
else
timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;
i = 0;
for (pos = daemon->connections_head; NULL != pos; pos = pos->next)
{
p[poll_server+i].fd = pos->socket_fd;
switch (pos->event_loop_info)
{
case MHD_EVENT_LOOP_INFO_READ:
p[poll_server+i].events |= POLLIN;
break;
case MHD_EVENT_LOOP_INFO_WRITE:
p[poll_server+i].events |= POLLOUT;
if (pos->read_buffer_size > pos->read_buffer_offset)
p[poll_server+i].events |= POLLIN;
break;
case MHD_EVENT_LOOP_INFO_BLOCK:
if (pos->read_buffer_size > pos->read_buffer_offset)
p[p
```
<Overlap Ratio: 0.9967786470317533>

---

--- 275 --
Question ID: b7ff48652377f2e475020d1609d473a75b52013c_2
Original Code:
```
void
emit_typecode_conversion (from, to)
     enum typecode from, to;
{
  int i;

  DEDUCE_CONVERSION (from, to);
  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)
    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);
}
```


Overlapping Code:
```
sion (from, to)
enum typecode from, to;
{
int i;
DEDUCE_CONVERSION (from, to);
for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)
bc_emit_instruction (conversion_recipe[(int) from]
```
<Overlap Ratio: 0.8>

---

--- 276 --
Question ID: d690d33b2960517c8a01db5579274d0f9cf55728_6
Original Code:
```
M3G_API void m3gSetAlphaThreshold(M3GCompositingMode handle,
                                  M3Gfloat threshold)
{
    CompositingMode *compositingMode = (CompositingMode*)handle;
    M3G_VALIDATE_OBJECT(compositingMode);
    if (!m3gInRangef(threshold, 0.0f, 1.0f)) {
        m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);
        return;
    }
    compositingMode->alphaThreshold = threshold;
}
```


Overlapping Code:
```
PI void m3gSetAlphaThreshold(M3GCompositingMode handle,
M3Gfloat threshold)
{
CompositingMode *compositingMode = (CompositingMode*)handle;
M3G_VALIDATE_OBJECT(compositingMode);
if (!m3gInRangef(threshold, 0.0f, 1.0f)) {
m3gRaiseError(M3G_INTERFACE(compositingMode), M3G_INVALID_VALUE);
return;
}
comp
```
<Overlap Ratio: 0.8645533141210374>

---

--- 277 --
Question ID: a8c52d29ccb5789358b670abeb5ef02944bc4aca_18
Original Code:
```
int qmi_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)
{
	qmi_init_request_message(msg, QMI_SERVICE_WDS);
	msg->svc.message = cpu_to_le16(0x002D);

	if (req->set.requested_settings) {
		void *buf;
		unsigned int ofs;

		__qmi_alloc_reset();
		put_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);

		buf = __qmi_get_buf(&ofs);
		tlv_new(msg, 0x10, ofs, buf);
	}

	return 0;
}
```


Overlapping Code:
```
i_set_wds_get_current_settings_request(struct qmi_msg *msg, struct qmi_wds_get_current_settings_request *req)
{
qmi_init_request_message(msg, QMI_SERVICE_WDS);
msg->svc.message = cpu_to_le16(0x002D);
if (req->set.requested_settings) {
void *buf;
unsigned int ofs;
__qmi_alloc_reset();
put_tlv_var(uint32_t, cpu_to_le32(req->data.requested_settings), 4);
buf = __qmi_get_buf(&ofs);
tlv_new(msg, 0x10, ofs, buf);
}
return 0;
}
```
<Overlap Ratio: 0.986046511627907>

---

--- 278 --
Question ID: 72ae298cf875649244dec08a618d9e0852ff6a94_9
Original Code:
```
static void rxm_handle_sar_comp(struct rxm_ep *rxm_ep,
				struct rxm_tx_buf *tx_buf)
{
	void *app_context;
	uint64_t comp_flags, tx_flags;

	app_context = tx_buf->app_context;
	comp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);
	tx_flags = tx_buf->flags;

	if (!rxm_complete_sar(rxm_ep, tx_buf))
		return;

	rxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);
	ofi_ep_tx_cntr_inc(&rxm_ep->util_ep);
}
```


Overlapping Code:
```
 rxm_handle_sar_comp(struct rxm_ep *rxm_ep,
struct rxm_tx_buf *tx_buf)
{
void *app_context;
uint64_t comp_flags, tx_flags;
app_context = tx_buf->app_context;
comp_flags = ofi_tx_cq_flags(tx_buf->pkt.hdr.op);
tx_flags = tx_buf->flags;
if (!rxm_complete_sar(rxm_ep, tx_buf))
return;
rxm_cq_write_tx_comp(rxm_ep, comp_flags, app_context, tx_flags);
ofi_
```
<Overlap Ratio: 0.8838383838383839>

---

--- 279 --
Question ID: f690ad6e94d23678ec10f30a9f64199e7e29d2a7_41
Original Code:
```
int Yodiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)
{
	char *json = jsonStart, *jsonEnd = json + jsonSize;
	int len;
	json += snprintf(json, jsonEnd - json, "{ \"DefaultValue\" : \""); if (json >= jsonEnd) return -1;
	json += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;
	*json = '\"'; json++;
	json += snprintf(json, jsonEnd - json, ", \"Description\" : \""); if (json >= jsonEnd) return -1;
	json += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;
	*json = '\"'; json++;
	json += snprintf(json, jsonEnd - json, ", \"Label\" : \""); if (json >= jsonEnd) return -1;
	json += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;
	*json = '\"'; json++;
	json += snprintf(json, jsonEnd - json, ", \"Name\" : \""); if (json >= jsonEnd) return -1;
	json += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;
	*json = '\"'; json++;
	json += snprintf(json, jsonEnd - json, ", \"Required\" : %s", (value->Required) ? "true" : "false"); if (json >= jsonEnd) return -1;
	json += snprintf(json, jsonEnd - json, ", \"Type\" : \""); if (json >= jsonEnd) return -1;
	json += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;
	*json = '\"'; json++;
	json += snprintf(json, jsonEnd - json, ", \"Minimum\" : %lf", value->Minimum); if (json >= jsonEnd) return -1;
	json += snprintf(json, jsonEnd - json, ", \"Maximum\" : %lf", value->Maximum); if (json >= jsonEnd) return -1;
	json += snprintf(json, jsonEnd - json, ", \"Stepsize\" : %lf", value->Stepsize); if (json >= jsonEnd) return -1;
	json += snprintf(json, jsonEnd - json, ", \"ReadOnly\" : %s", (value->ReadOnly) ? "true" : "false"); if (json >= jsonEnd) return -1;
	*json = '}'; json++;
	*json = '\0'; json++;
	return json - jsonStart;
}
```


Overlapping Code:
```
odiwo_Plegma_ConfigDescription_ToJson(char* jsonStart, size_t jsonSize, Yodiwo_Plegma_ConfigDescription_t *value)
{
char *json = jsonStart, *jsonEnd = json + jsonSize;
int len;
json += snprintf(json, jsonEnd - json, "{ \"DefaultValue\" : \""); if (json >= jsonEnd) return -1;
json += strcpy_escaped(json, value->DefaultValue); if (json + 1 >= jsonEnd) return -1;
*json = '\"'; json++;
json += snprintf(json, jsonEnd - json, ", \"Description\" : \""); if (json >= jsonEnd) return -1;
json += strcpy_escaped(json, value->Description); if (json + 1 >= jsonEnd) return -1;
*json = '\"'; json++;
json += snprintf(json, jsonEnd - json, ", \"Label\" : \""); if (json >= jsonEnd) return -1;
json += strcpy_escaped(json, value->Label); if (json + 1 >= jsonEnd) return -1;
*json = '\"'; json++;
json += snprintf(json, jsonEnd - json, ", \"Name\" : \""); if (json >= jsonEnd) return -1;
json += strcpy_escaped(json, value->Name); if (json + 1 >= jsonEnd) return -1;
*json = '\"'; json++;
json += snprintf(json, jsonEnd - json, ", \"Required\" : %s", (value->Required) ? "true" : "false"); if (json >= jsonEnd) return -1;
json += snprintf(json, jsonEnd - json, ", \"Type\" : \""); if (json >= jsonEnd) return -1;
json += strcpy_escaped(json, value->Type); if (json + 1 >= jsonEnd) return -1;
*json = '\"'; json++;
json += snprintf(json, jsonEnd - json, ", \"Minimum\" : %lf", value->Minimum); if (json >= jsonEnd) return -1;
json += snprintf(json, jsonEnd - json, ", \"Maximum\" : %lf", value->Maximum); if (json >= jsonEnd) return -1;
json += snprintf(json, jsonEnd - json, ", \"Stepsize\" : %lf", value->Stepsize); if (json >= jsonEnd) return -1;
json += snprintf(json, jsonEnd - json, ", \"ReadOnly\" : %s", (value->ReadOnly) ? "true" : "false"); if (json >= jsonEnd) return -1;
*json = '}'; json++;
*json = '\0'; json++;
return json - jsonStart;
}
```
<Overlap Ratio: 0.9972885032537961>

---

--- 280 --
Question ID: b85ba71a6f77e974d82ccdd635109f36d0ddaac8_97
Original Code:
```
static int
remoteDomainRestore(virConnectPtr conn, const char *from)
{
    int rv = -1;
    struct private_data *priv = conn->privateData;
    remote_domain_restore_args args;

    remoteDriverLock(priv);

    args.from = (char *)from;

    if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,
             (xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,
             (xdrproc_t)xdr_void, (char *)NULL) == -1) {
        goto done;
    }

    rv = 0;

done:
    remoteDriverUnlock(priv);
    return rv;
}
```


Overlapping Code:
```
 int
remoteDomainRestore(virConnectPtr conn, const char *from)
{
int rv = -1;
struct private_data *priv = conn->privateData;
remote_domain_restore_args args;
remoteDriverLock(priv);
args.from = (char *)from;
if (call(conn, priv, 0, REMOTE_PROC_DOMAIN_RESTORE,
(xdrproc_t)xdr_remote_domain_restore_args, (char *)&args,
(xdrproc_t)xdr_void, (char *)NULL) == -1) {
goto done;
}
rv = 0;
done:
remoteDriverUnlock(priv);
return rv;
}
```
<Overlap Ratio: 0.9861431870669746>

---

--- 281 --
Question ID: 3a88ea1647446ebfd247ede85d92ac7e9d8f0720_0
Original Code:
```
const override
	{
		std::vector<FactoryBaseClass*> ret;
		ret.reserve(_factoryMap.size());

		for (const auto& pair : _factoryMap)
		{
			ret.push_back(pair.second);
		}
```


Overlapping Code:
```
e
{
std::vector<FactoryBaseClass*> ret;
ret.reserve(_factoryMap.size());
for (const auto& pair : _fa
```
<Overlap Ratio: 0.6493506493506493>

---

--- 282 --
Question ID: 7951df687eec80e44c89cacad8ffbf2d7048f11d_13
Original Code:
```
int mal_routing_register_consumer_pubsub_handler(
    mal_routing_t *mal_routing,
    mal_ushort_t area, mal_uoctet_t area_version,
    mal_ushort_t service, mal_ushort_t operation,
    mal_routing_on_message_fn *on_register_ack,
    mal_routing_on_message_fn *on_deregister_ack,
    mal_routing_on_message_fn *on_notify) {
  clog_info(mal_logger, " *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\n", area, area_version, service, operation);

  // Allocates a new structure and initialize it
  mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);
  if (handler == NULL) return -1;

  handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;
  handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;
  handler->spec.consumer_pubsub_handler.on_notify = on_notify;
  return mal_routing_register_handler(mal_routing, handler);
}
```


Overlapping Code:
```
nt mal_routing_register_consumer_pubsub_handler(
mal_routing_t *mal_routing,
mal_ushort_t area, mal_uoctet_t area_version,
mal_ushort_t service, mal_ushort_t operation,
mal_routing_on_message_fn *on_register_ack,
mal_routing_on_message_fn *on_deregister_ack,
mal_routing_on_message_fn *on_notify) {
clog_info(mal_logger, " *** mal_routing_register_consumer_pubsub_handler: %hd %hhd %hd %hd\n", area, area_version, service, operation);
// Allocates a new structure and initialize it
mal_routing_handler_t *handler = mal_routing_new_handler(MAL_ACTOR_CONSUMER_PUBSUB_HANDLER, area, area_version, service, operation);
if (handler == NULL) return -1;
handler->spec.consumer_pubsub_handler.on_register_ack = on_register_ack;
handler->spec.consumer_pubsub_handler.on_deregister_ack = on_deregister_ack;
handler->spec.consumer_pubsub_handler.on_notify = on_notify;
return mal_routing_register_handler(mal_routing, ha
```
<Overlap Ratio: 0.9891186071817193>

---

--- 283 --
Question ID: cb1021965680a8dfb38f2fb7db30e98445ee443c_0
Original Code:
```
int main(){
  char str_a[20]; //A 20-element character array
  char *pointer; //A pointer meant for character array
  char *pointer2; //And yet another one

  strcpy(str_a, "Hello, World!\n");
  pointer = str_a; // Set the first pointer to the start of the array.
  printf(pointer); //print it

  pointer2 = pointer + 2; //Set teh second one 2 bytes further in.
  printf(pointer2); //print it
  strcpy(pointer2, "y you guys!\n"); //Copy into that spot.
  printf(pointer); //Print again.
}
```


Overlapping Code:
```

char str_a[20]; //A 20-element character array
char *pointer; //A pointer meant for character array
char *pointer2; //And yet another one
strcpy(str_a, "Hello, World!\n");
pointer = str_a; // Set the first pointer to the start of the array.
printf(pointer); //print it
pointer2 = pointer + 2; //Set teh second one 2 bytes further in.
printf(pointer2); //print it
strcpy(pointer2, "y you guys!\n"); //Copy into that spot.
printf(pointer); //Print aga
```
<Overlap Ratio: 0.9656652360515021>

---

--- 284 --
Question ID: 05594430cb378d518d4a0bd550f3c5613d57fad0_4
Original Code:
```
static void*
build_hpet(void)
{
    struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));
    if (!hpet) {
        warn_noalloc();
        return NULL;
    }

    memset(hpet, 0, sizeof(*hpet));
    /* Note timer_block_id value must be kept in sync with value advertised by
     * emulated hpet
     */
    hpet->timer_block_id = cpu_to_le32(0x8086a201);
    hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);
    build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);

    return hpet;
}
```


Overlapping Code:
```
tatic void*
build_hpet(void)
{
struct acpi_20_hpet *hpet = malloc_high(sizeof(*hpet));
if (!hpet) {
warn_noalloc();
return NULL;
}
memset(hpet, 0, sizeof(*hpet));
/* Note timer_block_id value must be kept in sync with value advertised by
* emulated hpet
*/
hpet->timer_block_id = cpu_to_le32(0x8086a201);
hpet->addr.address = cpu_to_le32(ACPI_HPET_ADDRESS);
build_header((void*)hpet, HPET_SIGNATURE, sizeof(*hpet), 1);
return hpet;

```
<Overlap Ratio: 0.9953917050691244>

---

--- 285 --
Question ID: 6c41e5086e257053d65e89262f44869f3893d6e7_11
Original Code:
```
void Update_Channel_Value (Channel* channel, int value) {
  Serial.println ("Update_Channel_Value");
  
  if (channel != NULL) {
    
    // Set the channel mode corresponding to the specified value
    Update_Channel_Mode (channel, PIN_MODE_OUTPUT);
    
    // Set the channel value
    (*channel).value = value;
    
    // Set the actual hardware's pin's value
    // TODO: Move this to the platform's schema!
    digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));
    
    (*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.
  }
  // TODO: Return "none" if channel not found (if specified channel is NULL)
}
```


Overlapping Code:
```
_Channel_Value (Channel* channel, int value) {
Serial.println ("Update_Channel_Value");

if (channel != NULL) {

// Set the channel mode corresponding to the specified value
Update_Channel_Mode (channel, PIN_MODE_OUTPUT);

// Set the channel value
(*channel).value = value;

// Set the actual hardware's pin's value
// TODO: Move this to the platform's schema!
digitalWrite ((*channel).address, ((*channel).value == PIN_VALUE_HIGH ? HIGH : LOW));

(*channel).isUpdated = true; // TODO: Propagate this change to the platform associated with the channel.
}
// TODO: Return "none" if channel not found (if speci
```
<Overlap Ratio: 0.9470404984423676>

---

--- 286 --
Question ID: ac7d1c381ff1a9b1d12a048c4cfe2ca34db6f197_13
Original Code:
```
static inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)
{
	AON_PWR_SEQ_CRITICAL_SECTION_ENTER();
	((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;
	AON_PWR_SEQ_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
 inline void hri_aonpwrseqpwrseq_clear_AON_ST_WAKEUP_CTRL_ARM_ENABLE_bit(const void *const hw)
{
AON_PWR_SEQ_CRITICAL_SECTION_ENTER();
((AonPwrSeq *)hw)->AON_ST_WAKEUP_CTRL.reg &= ~AON_PWR_SEQ_AON_ST_WAKEUP_CTRL_ARM_ENABLE_Msk;
AON_PWR_SEQ_CRITICAL_SECTION_LEAVE();
}
```
<Overlap Ratio: 0.978021978021978>

---

--- 287 --
Question ID: 5fc47f3e5d3b786f5c45c643fc53f60d9b0858bd_1
Original Code:
```
Bool VG_(maybe_Z_demangle) ( const HChar* sym, 
                             /*OUT*/HChar* so, Int soLen,
                             /*OUT*/HChar* fn, Int fnLen,
                             /*OUT*/Bool* isWrap,
                             /*OUT*/Int*  eclassTag,
                             /*OUT*/Int*  eclassPrio )
{
#  define EMITSO(ch)                           \
      do {                                     \
         if (so) {                             \
            if (soi >= soLen) {                \
               so[soLen-1] = 0; oflow = True;  \
            } else {                           \
               so[soi++] = ch; so[soi] = 0;    \
            }                                  \
         }                                     \
      } while (0)
#  define EMITFN(ch)                           \
      do {                                     \
         if (fni >= fnLen) {                   \
            fn[fnLen-1] = 0; oflow = True;     \
         } else {                              \
            fn[fni++] = ch; fn[fni] = 0;       \
         }                                     \
      } while (0)

   Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;
   Int  soi, fni, i;

   vg_assert(soLen > 0 || (soLen == 0 && so == NULL));
   vg_assert(fnLen > 0);
   error = False;
   oflow = False;
   soi = 0;
   fni = 0;

   valid =     sym[0] == '_'
           &&  sym[1] == 'v'
           &&  sym[2] == 'g'
           && (sym[3] == 'r' || sym[3] == 'w')
           &&  VG_(isdigit)(sym[4])
           &&  VG_(isdigit)(sym[5])
           &&  VG_(isdigit)(sym[6])
           &&  VG_(isdigit)(sym[7])
           &&  VG_(isdigit)(sym[8])
           &&  sym[9] == 'Z'
           && (sym[10] == 'Z' || sym[10] == 'U')
           &&  sym[11] == '_';

   if (valid
       && sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'
       && sym[8] != '0') {
      /* If the eclass tag is 0000 (meaning "no eclass"), the priority
         must be 0 too. */
      valid = False;
   }

   if (!valid)
      return False;

   fn_is_encoded = sym[10] == 'Z';

   if (isWrap)
      *isWrap = sym[3] == 'w';

   if (eclassTag) {
      *eclassTag =    1000 * ((Int)sym[4] - '0')
                   +  100 * ((Int)sym[5] - '0')
                   +  10 * ((Int)sym[6] - '0')
                   +  1 * ((Int)sym[7] - '0');
      vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);
   }

   if (eclassPrio) {
      *eclassPrio = ((Int)sym[8]) - '0';
      vg_assert(*eclassPrio >= 0 && *eclassPrio <= 9);
   }

   /* Now check the soname prefix isn't "VG_Z_", as described in
      pub_tool_redir.h. */
   is_VG_Z_prefixed =
      sym[12] == 'V' &&
      sym[13] == 'G' &&
      sym[14] == '_' &&
      sym[15] == 'Z' &&
      sym[16] == '_';
   if (is_VG_Z_prefixed) {
      vg_assert2(0, "symbol with a 'VG_Z_' prefix: %s.\n"
                    "see pub_tool_redir.h for an explanation.", sym);
   }

   /* Now scan the Z-encoded soname. */
   i = 12;
   while (True) {

      if (sym[i] == '_')
      /* Found the delimiter.  Move on to the fnname loop. */
         break;

      if (sym[i] == 0) {
         error = True;
         goto out;
      }

      if (sym[i] != 'Z') {
         EMITSO(sym[i]);
         i++;
         continue;
      }

      /* We've got a Z-escape. */
      i++;
      switch (sym[i]) {
         case 'a': EMITSO('*'); break;
         case 'c': EMITSO(':'); break;
         case 'd': EMITSO('.'); break;
         case 'h': EMITSO('-'); break;
         case 'p': EMITSO('+'); break;
         case 's': EMITSO(' '); break;
         case 'u': EMITSO('_'); break;
         case 'A': EMITSO('@'); break;
         case 'D': EMITSO('$'); break;
         case 'L': EMITSO('('); break;
         case 'R': EMITSO(')'); break;
         case 'Z': EMITSO('Z'); break;
         default: error = True; goto out;
      }
      i++;
   }

   vg_assert(sym[i] == '_');
   i++;

   /* Now deal with the function name part. */
   if (!fn_is_encoded) {

      /* simple; just copy. */
      while (True) {
         if (sym[i] == 0)
            break;
         EMITFN(sym[i]);
         i++;
      }
      goto out;

   }

   /* else use a Z-decoding loop like with soname */
   while (True) {

      if (sym[i] == 0)
         break;

      if (sym[i] != 'Z') {
         EMITFN(sym[i]);
         i++;
         continue;
      }

      /* We've got a Z-escape. */
      i++;
      switch (sym[i]) {
         case 'a': EMITFN('*'); break;
         case 'c': EMITFN(':'); break;
         case 'd': EMITFN('.'); break;
         case 'h': EMITFN('-'); break;
         case 'p': EMITFN('+'); break;
         case 's': EMITFN(' '); break;
         case 'u': EMITFN('_'); break;
         case 'A': EMITFN('@'); break;
         case 'D': EMITFN('$'); break;
         case 'L': EMITFN('('); break;
         case 'R': EMITFN(')'); break;
         case 'Z': EMITFN('Z'); break;
         default: error = True; goto out;
      }
      i++;
   }

  out:
   EMITSO(0);
   EMITFN(0);

   if (error) {
      /* Something's wrong.  Give up. */
      VG_(message)(Vg_UserMsg,
                   "m_demangle: error Z-demangling: %s\n", sym);
      return False;
   }
   if (oflow) {
      /* It didn't fit.  Give up. */
      VG_(message)(Vg_UserMsg,
                   "m_demangle: oflow Z-demangling: %s\n", sym);
      return False;
   }

   return True;
}
```


Overlapping Code:
```
gle) ( const HChar* sym, 
/*OUT*/HChar* so, Int soLen,
/*OUT*/HChar* fn, Int fnLen,
/*OUT*/Bool* isWrap,
/*OUT*/Int* eclassTag,
/*OUT*/Int* eclassPrio )
{
# define EMITSO(ch) \
do { \
if (so) { \
if (soi >= soLen) { \
so[soLen-1] = 0; oflow = True; \
} else { \
so[soi++] = ch; so[soi] = 0; \
} \
} \
} while (0)
# define EMITFN(ch) \
do { \
if (fni >= fnLen) { \
fn[fnLen-1] = 0; oflow = True; \
} else { \
fn[fni++] = ch; fn[fni] = 0; \
} \
} while (0)
Bool error, oflow, valid, fn_is_encoded, is_VG_Z_prefixed;
Int soi, fni, i;
vg_assert(soLen > 0 || (soLen == 0 && so == NULL));
vg_assert(fnLen > 0);
error = False;
oflow = False;
soi = 0;
fni = 0;
valid = sym[0] == '_'
&& sym[1] == 'v'
&& sym[2] == 'g'
&& (sym[3] == 'r' || sym[3] == 'w')
&& VG_(isdigit)(sym[4])
&& VG_(isdigit)(sym[5])
&& VG_(isdigit)(sym[6])
&& VG_(isdigit)(sym[7])
&& VG_(isdigit)(sym[8])
&& sym[9] == 'Z'
&& (sym[10] == 'Z' || sym[10] == 'U')
&& sym[11] == '_';
if (valid
&& sym[4] == '0' && sym[5] == '0' && sym[6] == '0' && sym[7] == '0'
&& sym[8] != '0') {
/* If the eclass tag is 0000 (meaning "no eclass"), the priority
must be 0 too. */
valid = False;
}
if (!valid)
return False;
fn_is_encoded = sym[10] == 'Z';
if (isWrap)
*isWrap = sym[3] == 'w';
if (eclassTag) {
*eclassTag = 1000 * ((Int)sym[4] - '0')
+ 100 * ((Int)sym[5] - '0')
+ 10 * ((Int)sym[6] - '0')
+ 1 * ((Int)sym[7] - '0');
vg_assert(*eclassTag >= 0 && *eclassTag <= 9999);
}
if (eclassPrio) {
*eclassPr
```
<Overlap Ratio: 0.9647371922821024>

---

--- 288 --
Question ID: 47e987f5f40938c18c24e90791ceebb45ea4030c_172
Original Code:
```
JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  result = crypto_auth_hmacsha512_bytes();
  jresult = (jint)result; 
  return jresult;
}
```


Overlapping Code:
```
JNICALL Java_com_bitmark_cryptography_crypto_sodium_SodiumJNI_crypto_1auth_1hmacsha512_1bytes(JNIEnv *jenv, jclass jcls) {
jint jresult = 0 ;
size_t result;

(void)jenv;
(void)jcls;
result = crypto_auth_hmacsha512_bytes();
jresult = (jint)result; 
return jresult;
}
```
<Overlap Ratio: 1.0>

---

--- 289 --
Question ID: 0d12aaaf2468bdedee26fc3fc1668e1fd4c1c739_5
Original Code:
```
void iotx_ds_common_update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)
{
    HAL_MutexLock(pshadow->mutex);
    pshadow->inner_data.time.base_system_time = utils_time_get_ms();
    pshadow->inner_data.time.epoch_time = new_timestamp;
    HAL_MutexUnlock(pshadow->mutex);

    log_info("update system time");
}
```


Overlapping Code:
```
update_time(iotx_shadow_pt pshadow, uint32_t new_timestamp)
{
HAL_MutexLock(pshadow->mutex);
pshadow->inner_data.time.base_system_time = utils_time_get_ms();
pshadow->inner_data.time.epoch_time = new_timestamp;
HAL_MutexUnlock(pshadow->mutex);
log_info("update syste
```
<Overlap Ratio: 0.8956228956228957>

---

--- 290 --
Question ID: 85723ec87beec8d68c7e1023c556465fb50781af_10
Original Code:
```
int target_ftm_set_bootchart(char status)
{
	int ret;

	ret = ftm_set_item(LGFTM_BOOTCHART, &status);

	if (ret < 0)
		return -1;

	return 0;
}
```


Overlapping Code:
```
t_ftm_set_bootchart(char status)
{
int ret;
ret = ftm_set_item(LGFTM_BOOTCHART, &status);
if (ret < 
```
<Overlap Ratio: 0.746268656716418>

---

--- 291 --
Question ID: bb3f1938bad77ab7fc4811b63dda6cf98311f809_0
Original Code:
```
int32_t KEYSCAN_StructInit(stc_keyscan_init_t *pstcKeyscanInit)
{
    int32_t i32Ret = LL_OK;

    if (NULL == pstcKeyscanInit) {
        i32Ret = LL_ERR_INVD_PARAM;
    } else {
        pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;
        pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;
        pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;
        pstcKeyscanInit->u32KeyOut   = KEYSCAN_OUT_0T1;
        pstcKeyscanInit->u32KeyIn    = KEYSCAN_IN_0;
    }
    return i32Ret;
}
```


Overlapping Code:
```
N_StructInit(stc_keyscan_init_t *pstcKeyscanInit)
{
int32_t i32Ret = LL_OK;
if (NULL == pstcKeyscanInit) {
i32Ret = LL_ERR_INVD_PARAM;
} else {
pstcKeyscanInit->u32HizCycle = KEYSCAN_HIZ_CYCLE_4;
pstcKeyscanInit->u32LowCycle = KEYSCAN_LOW_CYCLE_4;
pstcKeyscanInit->u32KeyClock = KEYSCAN_CLK_HCLK;
pstcKeyscanInit->u32KeyOut = KEYSCAN_OUT_0T1;
pstcKeyscanInit->u32KeyIn = KEYSCAN_I
```
<Overlap Ratio: 0.9112709832134293>

---

--- 292 --
Question ID: a287e4fec8653d91e55bb2765e2379984b65bef5_33
Original Code:
```
static void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)
{
	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
	struct tegra_dc_state *state = to_dc_state(crtc->state);
	struct tegra_dc *dc = to_tegra_dc(crtc);
	u32 value;

	tegra_dc_commit_state(dc, state);

	/* program display mode */
	tegra_dc_set_timings(dc, mode);

	/* interlacing isn't supported yet, so disable it */
	if (dc->soc->supports_interlacing) {
		value = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);
		value &= ~INTERLACE_ENABLE;
		tegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);
	}

	value = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);
	value &= ~DISP_CTRL_MODE_MASK;
	value |= DISP_CTRL_MODE_C_DISPLAY;
	tegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);

	value = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);
	value |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |
		 PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;
	tegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);

	tegra_dc_commit(dc);
}
```


Overlapping Code:
```
_crtc_mode_set_nofb(struct drm_crtc *crtc)
{
struct drm_display_mode *mode = &crtc->state->adjusted_mode;
struct tegra_dc_state *state = to_dc_state(crtc->state);
struct tegra_dc *dc = to_tegra_dc(crtc);
u32 value;
tegra_dc_commit_state(dc, state);
/* program display mode */
tegra_dc_set_timings(dc, mode);
/* interlacing isn't supported yet, so disable it */
if (dc->soc->supports_interlacing) {
value = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);
value &= ~INTERLACE_ENABLE;
tegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);
}
value = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);
value &= ~DISP_CTRL_MODE_MASK;
value |= DISP_CTRL_MODE_C_DISPLAY;
tegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);
value = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);
value |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |
PW4_ENABLE | PM0_ENABLE | PM1_ENABLE;
tegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);
t
```
<Overlap Ratio: 0.9604989604989606>

---

--- 293 --
Question ID: 48f3245153a7d88830fdc5d78cee3561f1d6edeb_3
Original Code:
```
int recordTime(char *time_str) {
  time_t timer;
  struct tm time_struct;

  timer = time(NULL);
  localtime_r(&timer, &time_struct);

  // TIME_FORMAT == "%Y-%m-%d %H:%M:%S" == "yyyy-mm-dd HH:mm:ss"
  strftime(time_str, TIME_STR_LEN, TIME_FORMAT, &time_struct);

  return 0;
}
```


Overlapping Code:
```
r) {
time_t timer;
struct tm time_struct;
timer = time(NULL);
localtime_r(&timer, &time_struct);
// TIME_FORMAT == "%Y-%m-%d %H:%M:%S" == "yyyy-mm-dd HH:mm:ss"
strftime(time_str, TIME_STR_LEN, TIME_FO
```
<Overlap Ratio: 0.7692307692307693>

---

--- 294 --
Question ID: c1ef6abdafe8ab7afa1c51c45d99971beda7fe5f_29
Original Code:
```
void
p6est_coarsen_layers_ext (p6est_t * p6est, int coarsen_recursive,
                          int callback_orphans,
                          p6est_coarsen_layer_t coarsen_fn,
                          p6est_init_t init_fn, p6est_replace_t replace_fn)
{
  p4est_t            *columns = p6est->columns;
  sc_array_t         *layers = p6est->layers;
  sc_array_t          view;
  p4est_topidx_t      jt;
  p4est_tree_t       *tree;
  sc_array_t         *tquadrants;
  p4est_quadrant_t   *col;
  size_t              first, last, zz, count;

  P4EST_GLOBAL_PRODUCTIONF ("Into p6est_coarsen_layers with %lld total layers"
                            " in %lld total columns\n", (long long)
                            p6est->global_first_layer[p6est->mpisize],
                            (long long) p6est->columns->global_num_quadrants);
  p4est_log_indent_push ();

  for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {
    tree = p4est_tree_array_index (columns->trees, jt);
    tquadrants = &tree->quadrants;

    for (zz = 0; zz < tquadrants->elem_count; ++zz) {
      col = p4est_quadrant_array_index (tquadrants, zz);
      P6EST_COLUMN_GET_RANGE (col, &first, &last);

      count = last - first;
      sc_array_init_view (&view, layers, first, count);
      p6est_coarsen_all_layers (p6est, jt, col, 0, &view,
                                coarsen_recursive, callback_orphans,
                                coarsen_fn, init_fn, replace_fn);
      P4EST_ASSERT (view.elem_count > 0);
      P4EST_ASSERT (view.elem_count <= count);
      last = first + view.elem_count;
      P6EST_COLUMN_SET_RANGE (col, first, last);
    }
  }
  p6est_compress_columns (p6est);
  p6est_update_offsets (p6est);
  P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);

  p4est_log_indent_pop ();
  P4EST_GLOBAL_PRODUCTIONF
    ("Done p6est_coarsen_layers with %lld total layers "
     " in %lld total columns\n",
     (long long) p6est->global_first_layer[p6est->mpisize],
     (long long) p6est->columns->global_num_quadrants);
}
```


Overlapping Code:
```
p6est, int coarsen_recursive,
int callback_orphans,
p6est_coarsen_layer_t coarsen_fn,
p6est_init_t init_fn, p6est_replace_t replace_fn)
{
p4est_t *columns = p6est->columns;
sc_array_t *layers = p6est->layers;
sc_array_t view;
p4est_topidx_t jt;
p4est_tree_t *tree;
sc_array_t *tquadrants;
p4est_quadrant_t *col;
size_t first, last, zz, count;
P4EST_GLOBAL_PRODUCTIONF ("Into p6est_coarsen_layers with %lld total layers"
" in %lld total columns\n", (long long)
p6est->global_first_layer[p6est->mpisize],
(long long) p6est->columns->global_num_quadrants);
p4est_log_indent_push ();
for (jt = columns->first_local_tree; jt <= columns->last_local_tree; ++jt) {
tree = p4est_tree_array_index (columns->trees, jt);
tquadrants = &tree->quadrants;
for (zz = 0; zz < tquadrants->elem_count; ++zz) {
col = p4est_quadrant_array_index (tquadrants, zz);
P6EST_COLUMN_GET_RANGE (col, &first, &last);
count = last - first;
sc_array_init_view (&view, layers, first, count);
p6est_coarsen_all_layers (p6est, jt, col, 0, &view,
coarsen_recursive, callback_orphans,
coarsen_fn, init_fn, replace_fn);
P4EST_ASSERT (view.elem_count > 0);
P4EST_ASSERT (view.elem_count <= count);
last = first + view.elem_count;
P6EST_COLUMN_SET_RANGE (col, first, last);
}
}
p6est_compress_columns (p6est);
p6est_update_offsets (p6est);
P4EST_ASSERT (p6est->user_data_pool->elem_count == layers->elem_count);
p4est_log_indent_pop ();
P4EST_GLOBAL_PRODUCTIONF
("Done p6est_coarsen_layers with %lld total layers "
" in %lld total columns\n",
(long long) p6est->global_first_layer[p6est->mpisize],
(long long) p6est->columns->global_num_quadrants);

```
<Overlap Ratio: 0.9745454545454545>

---

--- 295 --
Question ID: 53d650966beca97aaf0ebe62b116b10a5ea32871_27
Original Code:
```
void
FtsGetQDMirrorInfo(char **hostname, uint16 *port)
{
	Assert(hostname != NULL);
	Assert(port != NULL);

	if (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)
	{
		*hostname = NULL;
		*port = 0;
		return;
	}

	*hostname = ftsQDMirrorInfo->name;
	*port = ftsQDMirrorInfo->port;
	return;
}
```


Overlapping Code:
```
ostname, uint16 *port)
{
Assert(hostname != NULL);
Assert(port != NULL);
if (ftsQDMirrorInfo->name[0] == 0 || ftsQDMirrorInfo->port == 0)
{
*hostname = NULL;
*port = 0;
return;
}
*hostname = ftsQDMirrorInfo->name;
*port = ftsQDMirrorInfo->port;
retur
```
<Overlap Ratio: 0.8741258741258742>

---

--- 296 --
Question ID: b85ba71a6f77e974d82ccdd635109f36d0ddaac8_154
Original Code:
```
static virNetworkPtr
remoteNetworkCreateXML(virConnectPtr conn, const char *xml)
{
    virNetworkPtr rv = NULL;
    struct private_data *priv = conn->privateData;
    remote_network_create_xml_args args;
    remote_network_create_xml_ret ret;

    remoteDriverLock(priv);

    args.xml = (char *)xml;

    memset(&ret, 0, sizeof(ret));

    if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,
             (xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,
             (xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {
        goto done;
    }

    rv = get_nonnull_network(conn, ret.net);
    xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);

done:
    remoteDriverUnlock(priv);
    return rv;
}
```


Overlapping Code:
```
tr
remoteNetworkCreateXML(virConnectPtr conn, const char *xml)
{
virNetworkPtr rv = NULL;
struct private_data *priv = conn->privateData;
remote_network_create_xml_args args;
remote_network_create_xml_ret ret;
remoteDriverLock(priv);
args.xml = (char *)xml;
memset(&ret, 0, sizeof(ret));
if (call(conn, priv, 0, REMOTE_PROC_NETWORK_CREATE_XML,
(xdrproc_t)xdr_remote_network_create_xml_args, (char *)&args,
(xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret) == -1) {
goto done;
}
rv = get_nonnull_network(conn, ret.net);
xdr_free((xdrproc_t)xdr_remote_network_create_xml_ret, (char *)&ret);
done:
remoteDriverUnlock(priv);
return rv;
}
```
<Overlap Ratio: 0.9727272727272728>

---

--- 297 --
Question ID: f1efb943b6fec3cfeb67856b03ec15dc11fbd4d2_0
Original Code:
```
class CSampleDlg : public CDialog
{
//
public:
	CSampleDlg(CWnd* pParent = NULL);	// default constractor

	//{{AFX_DATA(CSampleDlg)
	enum { IDD = IDD_SAMPLE_DIALOG };

	//}}AFX_DATA

	//{{AFX_VIRTUAL(CSampleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// support DDX/DDV
	//}}AFX_VIRTUAL

protected:
	HICON m_hIcon;

	//{{AFX_MSG(CSampleDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnPrint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
}
```


Overlapping Code:
```
lic CDialog
{
//
public:
CSampleDlg(CWnd* pParent = NULL); // default constractor
//{{AFX_DATA(CSampleDlg)
enum { IDD = IDD_SAMPLE_DIALOG };
//}}AFX_DATA
//{{AFX_VIRTUAL(CSampleDlg)
protected:
virtual void DoDataExchange(CDataExchange* pDX); // support DDX/DDV
//}}AFX_VIRTUAL
protected:
HICON m_hIcon;
//{{AFX_MSG(CSampleDlg)
virtual BOOL OnInitDialog();
afx_msg void OnPaint();
afx_msg HCURSOR OnQueryDragIcon();
afx_msg void OnPrint();
//}}AFX_MSG
DECLARE_MESSAGE_MAP
```
<Overlap Ratio: 0.9475806451612904>

---

--- 298 --
Question ID: 520d6b876aee995fd379a8d816e32ad6d684b86d_0
Original Code:
```
void hwInit(void)
{
  qbufferInit();
  ledInit();

  uartInit();
  dxlportInit();
  flashInit();
  resetInit();
}
```


Overlapping Code:
```
id)
{
qbufferInit();
ledInit();
uartInit();
dxlpor
```
<Overlap Ratio: 0.5>

---

--- 299 --
Question ID: e9fc79c40cef53289f1618b9bcae35720f39d765_34
Original Code:
```
YY_RULE(int) yy_range()
{  int yypos0= yypos, yythunkpos0= yythunkpos;
  yyprintf((stderr, "%s\n", "range"));
  {  int yypos21= yypos, yythunkpos21= yythunkpos;  if (!yy_char()) goto l22;  if (!yymatchChar('-')) goto l22;  if (!yy_char()) goto l22;  goto l21;
  l22:;	  yypos= yypos21; yythunkpos= yythunkpos21;  if (!yy_char()) goto l20;
  }
  l21:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "range", yybuf+yypos));
  return 1;
  l20:;	  yypos= yypos0; yythunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "range", yybuf+yypos));
  return 0;
}
```


Overlapping Code:
```
_RULE(int) yy_range()
{ int yypos0= yypos, yythunkpos0= yythunkpos;
yyprintf((stderr, "%s\n", "range"));
{ int yypos21= yypos, yythunkpos21= yythunkpos; if (!yy_char()) goto l22; if (!yymatchChar('-')) goto l22; if (!yy_char()) goto l22; goto l21;
l22:; yypos= yypos21; yythunkpos= yythunkpos21; if (!yy_char()) goto l20;
}
l21:; 
yyprintf((stderr, " ok %s @ %s\n", "range", yybuf+yypos));
return 1;
l20:; yypos= yypos0; yythunkpos= yythunkpos0;
yyprintf((stderr, " fail %s @ %s\n", "range", yybuf+yy
```
<Overlap Ratio: 0.9615384615384616>

---

--- 300 --
Question ID: 0286a95c28925856222151785828fd9ee0b15fbc_7
Original Code:
```
JNICALL
Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,
        jclass klass,
        jthread thread) {
    jint state;
    NSK_DISPLAY0("Inside pop_Frame method.....\n");
    if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {
        NSK_DISPLAY0(" Got the state of thread \n");
        if ( state & JVMTI_THREAD_STATE_SUSPENDED) {
            NSK_DISPLAY0(" Thread is already in suspended mode..\n");
            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {
                NSK_COMPLAIN0(" TEST FAILED: UNABLE TO POP FRAME \n");
                nsk_jvmti_setFailStatus();
                return NSK_FALSE;
            } else {
                NSK_DISPLAY0(" Poped frame safely..");
            }
            /* We should resume that thread for next execution.. */
            if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {
                NSK_COMPLAIN0(" TEST FAILED: UNABLE TO Resume thread \n");
                nsk_jvmti_setFailStatus();
                return NSK_FALSE;
            } else {
                NSK_DISPLAY0(" Resumed.. thread for next set of executions...");
            }
        } else {
            NSK_DISPLAY0(" Thread is not in Suspened State for poping its status..");
        }
    }
    return NSK_TRUE;
}
```


Overlapping Code:
```
NICALL
Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,
jclass klass,
jthread thread) {
jint state;
NSK_DISPLAY0("Inside pop_Frame method.....\n");
if (NSK_CPP_STUB3(GetThreadState,jvmti,thread, &state) == JVMTI_ERROR_NONE) {
NSK_DISPLAY0(" Got the state of thread \n");
if ( state & JVMTI_THREAD_STATE_SUSPENDED) {
NSK_DISPLAY0(" Thread is already in suspended mode..\n");
if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(PopFrame, jvmti, thread))) {
NSK_COMPLAIN0(" TEST FAILED: UNABLE TO POP FRAME \n");
nsk_jvmti_setFailStatus();
return NSK_FALSE;
} else {
NSK_DISPLAY0(" Poped frame safely..");
}
/* We should resume that thread for next execution.. */
if (!NSK_JVMTI_VERIFY(NSK_CPP_STUB2(ResumeThread, jvmti, thread))) {
NSK_COMPLAIN0(" TEST FAILED: UNABLE TO Resume thread \n");
nsk_jvmti_setFailStatus();
return NSK_FALSE;
} else {
NSK_DISPLAY0(" Resumed.. thread for next set of executions...");
}
} else {
NSK_DISPLAY0(" Thread is not in Suspened State for poping its 
```
<Overlap Ratio: 0.9661181026137464>

---

--- 301 --
Question ID: 51b1acc11ed44401ca88989699ae999d6b1f28a8_0
Original Code:
```
interface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {
    NSMutableArray * _accountsToAuthenticate;
    NSMutableDictionary * _cachedAuthInfo;
    bool  _cancelledSetupInProgress;
    NSData * _dataToSend;
    NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;
    <TRDeviceSetupServerDelegate> * _delegate;
    int  _notifyToken;
    bool  _notifyTokenIsValid;
    bool  _setupInProgress;
    bool  _started;
    TRTransferServer * _transferServer;
}
```


Overlapping Code:
```
nterface TRDeviceSetupServer : NSObject <TRTransferServerDelegate> {
NSMutableArray * _accountsToAuthenticate;
NSMutableDictionary * _cachedAuthInfo;
bool _cancelledSetupInProgress;
NSData * _dataToSend;
NSObject<OS_dispatch_semaphore> * _dataToSendSemaphore;
<TRDeviceSetupServerDelegate> * _delegate;
int _notifyToken;
bool _notifyTokenIsValid;
bool _setupInProgress;
bool _started;
TRTransferServer
```
<Overlap Ratio: 0.9479905437352246>

---

--- 302 --
Question ID: 931c1bfe92e4796cc96d98227132ec70594d3f37_5
Original Code:
```
void frame_picture_mp_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)
{
  int   rd_pass = 0;
  int   rd_qp = p_Vid->p_curr_frm_struct->qp;
  float rateRatio = 1.0F;
  int   wp_pass=0;
  int   frame_type_pass = 0;
  CodingInfo coding_info;
  FrameCodingMethod best_method = REGULAR; 
  int frame_type = P_SLICE; 
  int apply_wp = 0;
  int selection;

  frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
  store_coding_and_rc_info(p_Vid, &coding_info);

  if(p_Inp->WPIterMC)
    p_Vid->frameOffsetAvail = 1; 

#if (DBG_IMAGE_MP)
    printf("rd_pass = %d: %d (%.0f, %.0f, %.0f)\n", rd_pass, 
      p_Vid->frame_pic[0]->bits_per_picture, 
      p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);
#endif

  rd_pass++;
  if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
  {
    frame_picture_mp_exit(p_Vid, &coding_info);
    return;
  }

  // for P_Slice, consider WP  
  wp_pass = 0;
  if (p_Inp->GenerateMultiplePPS)
  {
    Slice *dummy_slice = NULL;

    InitWP(p_Vid, p_Inp, 0);
    if ( p_Inp->WPMCPrecision )
      p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;
    init_slice_lite(p_Vid, &dummy_slice, 0);

    if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)
    {
      // regular WP pass
      p_Vid->active_pps = p_Vid->PicParSet[1];
      if ( p_Inp->WPMCPrecision )
        p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;
      wp_pass = 1;
    }
    else if ( p_Inp->WPMCPrecision )
    {
      // WPMC pass
      p_Vid->active_pps = p_Vid->PicParSet[1];
      wp_pass = 1;
    }  

    // The way it is, the code would only reach here if prior conditional using 
    // generatemultiplepps is satisfied
    if(wp_pass)
    {
      p_Vid->write_macroblock = FALSE;
      p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
      frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
      selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
      printf("rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif
#if (DBG_IMAGE_MP)
      printf("rd_pass = %d: %d (%.0f, %.0f, %.0f)\n", rd_pass, 
        p_Vid->frame_pic[rd_pass]->bits_per_picture, 
        p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);
#endif

      if (selection)
      {
        swap_frame_buffer(p_Vid, 0, rd_pass); 
        store_coding_and_rc_info(p_Vid, &coding_info);
        best_method = EXP_WP;
        apply_wp = 1;
      }

      if(p_Inp->WPMethod == 0 || p_Inp->WPMCPrecision) 
      {
        wp_pass = 0;
        if ( p_Inp->WPMCPrecision )
          p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 2;
        if (p_Inp->WPMethod == 0 && p_Vid->TestWPPSlice(dummy_slice, 1) == 1)
        {
          // regular WP pass
          p_Vid->active_pps = p_Vid->PicParSet[1];
          if ( p_Inp->WPMCPrecision )
            p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;
          wp_pass = 1;
        }
        else if ( p_Inp->WPMCPrecision )
        {
          // WPMC pass
          p_Vid->active_pps = p_Vid->PicParSet[1];
          wp_pass = 1;
        }

        if(wp_pass)
        {
          p_Vid->write_macroblock = FALSE;
          p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
          free_slice_list(p_Vid->frame_pic[rd_pass]);
          free_storable_picture(p_Vid, p_Vid->enc_frame_picture[rd_pass]);
          frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
          selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
          printf("rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif
#if (DBG_IMAGE_MP)
          printf("rd_pass = %d: %d (%.0f, %.0f, %.0f)\n", rd_pass, 
            p_Vid->frame_pic[rd_pass]->bits_per_picture, 
            p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);
#endif

          if (selection)
          {
            swap_frame_buffer(p_Vid, 0, rd_pass); 
            store_coding_and_rc_info(p_Vid, &coding_info);
            best_method = EXP_WP;
            apply_wp = 1;
          }
        }
      }

      rd_pass++;
      //free_slice(dummy_slice);

      if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
      {
        frame_picture_mp_exit(p_Vid, &coding_info);
        free_slice(dummy_slice);
        return;
      }
    }
    free_slice(dummy_slice);
  }


  // code as I? or maybe as B?
  frame_type_pass = 0;
  if(p_Inp->RDPSliceITest && (coding_info.intras * 100/p_Vid->FrameSizeInMbs) >= 75)
  {
    frame_type = I_SLICE; 
    set_slice_type(p_Vid, p_Inp, I_SLICE);
    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );
    p_Vid->active_pps = p_Vid->PicParSet[0];
    frame_type_pass = 1;
  }
  else if (p_Inp->RDPSliceBTest && p_Vid->active_sps->profile_idc != BASELINE)
  // later need to add some automatic criterion to see if this (coding P as B) may be beneficial 
  {
    frame_type = B_SLICE; 
    set_slice_type(p_Vid, p_Inp, B_SLICE );
    populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, B_SLICE, p_Vid->p_pred->max_num_slices );
    p_Vid->active_pps = p_Vid->PicParSet[0];
    frame_type_pass = 1;
  }

  if(frame_type_pass)
  {
    p_Vid->write_macroblock = FALSE;
    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
  printf("rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif

    if (selection)
    {
      swap_frame_buffer(p_Vid, 0, rd_pass); 
      store_coding_and_rc_info(p_Vid, &coding_info);
      best_method = FRAME_TYPE; 
    }
    // reset frame_type
    else 
      frame_type = P_SLICE;

    rd_pass++;
    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
    {
      frame_picture_mp_exit(p_Vid, &coding_info);
      return;
    }
  }

  if(p_Vid->EvaluateDBOff)
  {
    // Perform DB off coding pass
    p_Vid->active_pps = (best_method == EXP_WP?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);
    if(frame_type != P_SLICE)
    {
      set_slice_type(p_Vid, p_Inp, frame_type);
      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, frame_type, p_Vid->p_pred->max_num_slices );
    }
    p_Vid->TurnDBOff = 1; 
    p_Vid->write_macroblock = FALSE;
    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
  printf("DB OFF, rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif

    if (selection)
    {
      swap_frame_buffer(p_Vid, 0, rd_pass); 
      store_coding_and_rc_info(p_Vid, &coding_info);
      best_method = DB_OFF; 
    }

    rd_pass++;
    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
    {
      frame_picture_mp_exit(p_Vid, &coding_info);
      return;
    }
  }

  if(p_Inp->RDPictureFrameQPPSlice)
  {
    // frame QP pass
    p_Vid->active_pps = (apply_wp?p_Vid->PicParSet[1]:p_Vid->PicParSet[0]);
    if(frame_type != P_SLICE)
    {
      set_slice_type(p_Vid, p_Inp, frame_type);
      populate_frame_slice_type( p_Inp, p_Vid->p_curr_frm_struct, I_SLICE, p_Vid->p_pred->max_num_slices );
    }
    p_Vid->qp = (p_Vid->nal_reference_idc==0 ? rd_qp+1:rd_qp-1);
    p_Vid->qp = iClip3( p_Vid->RCMinQP, p_Vid->RCMaxQP, p_Vid->qp );
    if ( p_Inp->RCEnable )
    {
      rateRatio = p_Vid->nal_reference_idc ? 1.15F : 0.85F;
      rc_init_frame_rdpic( p_Vid, p_Inp, rateRatio );
    }
    p_Vid->TurnDBOff = 0;
    p_Vid->write_macroblock = FALSE;
    p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
    frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
    selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
    printf("rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif

    if (selection)
    {
      swap_frame_buffer(p_Vid, 0, rd_pass); 
      store_coding_and_rc_info(p_Vid, &coding_info);
      best_method = FRAME_QP;
    }

    rd_pass++;
    if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
    {
      frame_picture_mp_exit(p_Vid, &coding_info);
      return;
    }
  }

  frame_picture_mp_exit(p_Vid, &coding_info);
}
```


Overlapping Code:
```
_p_slice(VideoParameters *p_Vid, InputParameters *p_Inp)
{
int rd_pass = 0;
int rd_qp = p_Vid->p_curr_frm_struct->qp;
float rateRatio = 1.0F;
int wp_pass=0;
int frame_type_pass = 0;
CodingInfo coding_info;
FrameCodingMethod best_method = REGULAR; 
int frame_type = P_SLICE; 
int apply_wp = 0;
int selection;
frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
store_coding_and_rc_info(p_Vid, &coding_info);
if(p_Inp->WPIterMC)
p_Vid->frameOffsetAvail = 1; 
#if (DBG_IMAGE_MP)
printf("rd_pass = %d: %d (%.0f, %.0f, %.0f)\n", rd_pass, 
p_Vid->frame_pic[0]->bits_per_picture, 
p_Vid->frame_pic[0]->distortion.value[0], p_Vid->frame_pic[0]->distortion.value[1], p_Vid->frame_pic[0]->distortion.value[2]);
#endif
rd_pass++;
if(rd_pass >= p_Inp->RDPictureMaxPassPSlice)
{
frame_picture_mp_exit(p_Vid, &coding_info);
return;
}
// for P_Slice, consider WP 
wp_pass = 0;
if (p_Inp->GenerateMultiplePPS)
{
Slice *dummy_slice = NULL;
InitWP(p_Vid, p_Inp, 0);
if ( p_Inp->WPMCPrecision )
p_Vid->pWPX->curr_wp_rd_pass = p_Vid->pWPX->wp_rd_passes + 1;
init_slice_lite(p_Vid, &dummy_slice, 0);
if (p_Vid->TestWPPSlice(dummy_slice, 0) == 1)
{
// regular WP pass
p_Vid->active_pps = p_Vid->PicParSet[1];
if ( p_Inp->WPMCPrecision )
p_Vid->pWPX->curr_wp_rd_pass->algorithm = WP_REGULAR;
wp_pass = 1;
}
else if ( p_Inp->WPMCPrecision )
{
// WPMC pass
p_Vid->active_pps = p_Vid->PicParSet[1];
wp_pass = 1;
} 
// The way it is, the code would only reach here if prior conditional using 
// generatemultiplepps is satisfied
if(wp_pass)
{
p_Vid->write_macroblock = FALSE;
p_Vid->p_curr_frm_struct->qp = p_Vid->qp;
frame_picture (p_Vid, p_Vid->frame_pic[rd_pass], &p_Vid->imgData, rd_pass);
selection = picture_coding_decision(p_Vid, p_Vid->frame_pic[0], p_Vid->frame_pic[rd_pass], rd_qp);
#if (DBG_IMAGE_MP)
printf("rd_pass = %d, selection = %d\n", rd_pass, selection);
#endif
#if (DBG_IMAGE_MP)
printf("rd_pass = %d: %d (%.0f, %.0f, %.0f)\n", rd_pass, 
p_Vid->frame_pic[rd_pass]->bits_per_picture, 
p_Vid->frame_pic[rd_pass]->distortion.value[0], p_Vid->frame_pic[rd_pass]->distortion.value[1], p_Vid->frame_pic[rd_pass]->distortion.value[2]);
#end
```
<Overlap Ratio: 0.9894155545329039>

---

--- 303 --
Question ID: cec2808f7a46487741be74664dfa5d8d6b8a532a_2
Original Code:
```
void Auddrv_Set_UnderFlow(void)
{
	unsigned long long underflow_time = sched_clock();	/* in ns (10^9) */

	pr_debug("%s UnderflowCounter = %d\n", __func__, UnderflowCounter);
	UnderflowTime[UnderflowCounter] = underflow_time;
	UnderflowCounter++;
	UnderflowCounter %= UnderflowrecordNumber;
	if (UnderflowCounter > UnderflowThreshold) {
		DumpUnderFlowTime();
		Auddrv_Aee_Dump();
	}
}
```


Overlapping Code:
```
v_Set_UnderFlow(void)
{
unsigned long long underflow_time = sched_clock(); /* in ns (10^9) */
pr_debug("%s UnderflowCounter = %d\n", __func__, UnderflowCounter);
UnderflowTime[UnderflowCounter] = underflow_time;
UnderflowCounter++;
UnderflowCounter %= UnderflowrecordNumber;
if (UnderflowCounter > UnderflowThreshold) {
DumpUnderF
```
<Overlap Ratio: 0.8847184986595175>

---

--- 304 --
Question ID: 8ad56a6769a020960774835f291789709f1c3840_0
Original Code:
```
class GeoLib
{
public:
	GeoLib() {}
	~GeoLib() {}
private:
	friend class CGLPolyline;
	friend class Surface;
}
```


Overlapping Code:
```
oLib
{
public:
GeoLib() {}
~GeoLib() {}
private:
friend class CGLPolyline;
friend class Sur
```
<Overlap Ratio: 0.8584905660377359>

---

--- 305 --
Question ID: ab79fb02978eae62b2787b88284693886a925492_6
Original Code:
```
int iaxc_callback(iaxc_event e)
{
	//printf("Received iaxc event type 0x%x\n", e.type);
	switch ( e.type ) 
	{
	case IAXC_EVENT_LEVELS:
		return levels_callback(e.ev.levels.input, e.ev.levels.output);
	case IAXC_EVENT_NETSTAT:
		return netstat_callback(e.ev.netstats);
	case IAXC_EVENT_TEXT:
		process_text_message(e.ev.text.message);
		break;
	case IAXC_EVENT_STATE:
		return state_callback(e.ev.call);
	case IAXC_EVENT_VIDEO:
		if ( !video )
			return 0;

		if ( !e.ev.video.encoded )
			return display_video(e.ev.video,
					e.ev.video.source == IAXC_SOURCE_REMOTE);
		else
			fprintf(stderr, "We cannot handle encoded video in callbacks yet\n");
		break;

	case IAXC_EVENT_AUDIO:
		fprintf(stderr, "Got %s %s audio\n",
				e.ev.audio.source == IAXC_SOURCE_REMOTE ? "remote" : "local",
				e.ev.audio.encoded ? "encoded" : "raw");
		break;
	case IAXC_EVENT_VIDCAP_ERROR:
		fprintf(stderr, "\nVIDEO CAPTURE DEVICE ERROR\n");
		break;
	default:
		break;
	}

	return 0;
}
```


Overlapping Code:
```
lback(iaxc_event e)
{
//printf("Received iaxc event type 0x%x\n", e.type);
switch ( e.type ) 
{
case IAXC_EVENT_LEVELS:
return levels_callback(e.ev.levels.input, e.ev.levels.output);
case IAXC_EVENT_NETSTAT:
return netstat_callback(e.ev.netstats);
case IAXC_EVENT_TEXT:
process_text_message(e.ev.text.message);
break;
case IAXC_EVENT_STATE:
return state_callback(e.ev.call);
case IAXC_EVENT_VIDEO:
if ( !video )
return 0;
if ( !e.ev.video.encoded )
return display_video(e.ev.video,
e.ev.video.source == IAXC_SOURCE_REMOTE);
else
fprintf(stderr, "We cannot handle encoded video in callbacks yet\n");
break;
case IAXC_EVENT_AUDIO:
fprintf(stderr, "Got %s %s audio\n",
e.ev.audio.source == IAXC_SOURCE_REMOTE ? "remote" : "local",
e.ev.audio.encoded ? "encoded" : "raw");
break;
case IAXC_EVENT_VIDCAP_ERROR:
fprintf(stderr, "\nVIDEO CAPTURE DEVICE ERRO
```
<Overlap Ratio: 0.9392265193370166>

---

--- 306 --
Question ID: adc08a268a5c44d3717836793937f1357b75e06a_2
Original Code:
```
int hrstemc_endswith(char *s, char *what) {
    if (strlen(what) > strlen(s)) {
        return 0;
    }
    if (strcmp(s+strlen(s)-strlen(what), what) == 0) {
        return 1;
    }
    return 0;
}
```


Overlapping Code:
```
char *what) {
if (strlen(what) > strlen(s)) {
return 0;
}
if (strcmp(s+strlen(s)-strlen(what), what)
```
<Overlap Ratio: 0.6172839506172839>

---

--- 307 --
Question ID: 86486e2eb148e3c17909fdf838ee9f9e535353a0_0
Original Code:
```
err long_parse_number(char *str, long *number, int min)
{
	char	*end;
	long	nbr;

	if (*str == '\0')
		return KO;
	nbr = (int)strtol(str, &end, 0);
	if (*end != '\0' || nbr < min)
		return KO;
	*number = nbr;
	return OK;
}
```


Overlapping Code:
```
err long_parse_number(char *str, long *number, int min)
{
char *end;
long nbr;
if (*str == '\0')
return KO;
nbr = (int)strtol(str, &end, 0);
if (*end != '\0' || nbr < min)
return KO;
*number = nbr;

```
<Overlap Ratio: 0.9428571428571428>

---

--- 308 --
Question ID: 17c48ea0d85bb127f7584855f9fabb1eb56b95a7_5
Original Code:
```
static enum cmd_status cmd_decrypto_3des_exec(char *cmd)
{
	int32_t cnt;
	char mode_str[8];
	char key_str[25];
	char *cipher_str;
	uint8_t *plain_buf;
	uint8_t *cipher_buf;
	int8_t key_len = 0;
	uint32_t cipher_len = 0;
	CE_3DES_Config des_cfg;
    enum cmd_status ret = CMD_STATUS_ACKED;

    cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);
    if(cipher_str == NULL) {
        CMD_ERR("malloc failed\n");
        ret = CMD_STATUS_FAIL;
        goto out_cipher;
    }

	/* get param */
	cnt = cmd_sscanf(cmd, "m=%7s k=%s c=%s", mode_str, key_str, cipher_str);

	/* check param */
	if (cnt != 3) {
		CMD_ERR("invalid param number %d\n", cnt);
		ret = CMD_STATUS_INVALID_ARG;
        goto out_cipher;
	}
	memset(&des_cfg, 0, sizeof(des_cfg));
	if (cmd_strcmp(mode_str, "ecb") == 0) {
		des_cfg.mode = CE_CRYPT_MODE_ECB;
	} else if (cmd_strcmp(mode_str, "cbc") == 0) {
		des_cfg.mode = CE_CRYPT_MODE_CBC;
	} else {
		CMD_ERR("invalid mode %s\n", mode_str);
		ret = CMD_STATUS_INVALID_ARG;
        goto out_cipher;
	}

	key_len = cmd_strlen(key_str);
	if(24 != key_len) {
		CMD_ERR("invalid param:  key len %d != 24\n", key_len);
		ret = CMD_STATUS_INVALID_ARG;
        goto out_cipher;
	}
	des_cfg.src = CE_CTL_KEYSOURCE_INPUT;
	memcpy(des_cfg.key, key_str, key_len);
	cipher_len = cmd_strlen(cipher_str);
	cipher_len = cipher_len >> 1;
	cipher_buf = (uint8_t*)cmd_malloc(cipher_len);
	cipher_str_to_arr(cipher_str, cipher_buf);
	plain_buf = (uint8_t*)cmd_malloc(cipher_len);
	if(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {
		CMD_ERR("3DES encrypt failed\n");
		ret =  CMD_STATUS_FAIL;
        goto out_plain;
	}
	printf("plaintest:");
	cmd_raw_mode_enable();
	cmd_raw_mode_write(plain_buf, cipher_len);
	cmd_raw_mode_disable();
	printf("\n\n");

out_plain:
    cmd_free(cipher_buf);
    cmd_free(plain_buf);
out_cipher:
    cmd_free(cipher_str);
    return ret;
}
```


Overlapping Code:
```
enum cmd_status cmd_decrypto_3des_exec(char *cmd)
{
int32_t cnt;
char mode_str[8];
char key_str[25];
char *cipher_str;
uint8_t *plain_buf;
uint8_t *cipher_buf;
int8_t key_len = 0;
uint32_t cipher_len = 0;
CE_3DES_Config des_cfg;
enum cmd_status ret = CMD_STATUS_ACKED;
cipher_str = (char*)cmd_malloc(CE_CIPHER_MAX_LEN);
if(cipher_str == NULL) {
CMD_ERR("malloc failed\n");
ret = CMD_STATUS_FAIL;
goto out_cipher;
}
/* get param */
cnt = cmd_sscanf(cmd, "m=%7s k=%s c=%s", mode_str, key_str, cipher_str);
/* check param */
if (cnt != 3) {
CMD_ERR("invalid param number %d\n", cnt);
ret = CMD_STATUS_INVALID_ARG;
goto out_cipher;
}
memset(&des_cfg, 0, sizeof(des_cfg));
if (cmd_strcmp(mode_str, "ecb") == 0) {
des_cfg.mode = CE_CRYPT_MODE_ECB;
} else if (cmd_strcmp(mode_str, "cbc") == 0) {
des_cfg.mode = CE_CRYPT_MODE_CBC;
} else {
CMD_ERR("invalid mode %s\n", mode_str);
ret = CMD_STATUS_INVALID_ARG;
goto out_cipher;
}
key_len = cmd_strlen(key_str);
if(24 != key_len) {
CMD_ERR("invalid param: key len %d != 24\n", key_len);
ret = CMD_STATUS_INVALID_ARG;
goto out_cipher;
}
des_cfg.src = CE_CTL_KEYSOURCE_INPUT;
memcpy(des_cfg.key, key_str, key_len);
cipher_len = cmd_strlen(cipher_str);
cipher_len = cipher_len >> 1;
cipher_buf = (uint8_t*)cmd_malloc(cipher_len);
cipher_str_to_arr(cipher_str, cipher_buf);
plain_buf = (uint8_t*)cmd_malloc(cipher_len);
if(HAL_3DES_Decrypt(&des_cfg, (uint8_t*)cipher_buf, (uint8_t*)plain_buf, cipher_len) != HAL_OK) {
CMD_ERR("3DES encrypt failed\n");
ret = CMD_STATUS_FAIL;
goto out_plain;
}
printf("plaintest:");
cmd_raw_mode_enable();
cmd_raw_mode_write(plain_buf, cipher_len);
cmd_raw_mode_disable();
printf("\n\n");
out_plain:
cmd_free(cipher_buf);
cmd_free(plain_buf);
out_cipher:
cmd_free(cipher_str);
retur
```
<Overlap Ratio: 0.9915014164305949>

---

--- 309 --
Question ID: 9aaa0eac44e084ee1cb9c31116aa48285ea8377b_66
Original Code:
```
int
target_supports_disable_randomization (void)
{
  struct target_ops *t;

  for (t = &current_target; t != NULL; t = t->beneath)
    if (t->to_supports_disable_randomization)
      return t->to_supports_disable_randomization ();

  return 0;
}
```


Overlapping Code:
```
le_randomization (void)
{
struct target_ops *t;
for (t = &current_target; t != NULL; t = t->beneath)
if (t->to_supports_disable_randomization)
return t->to_supports_disable_randomization ();
return 0;
```
<Overlap Ratio: 0.8810572687224669>

---

--- 310 --
Question ID: e9ad527aaf0ae3e03ce6704bd4e4e01bce483611_0
Original Code:
```
static PyObject *
typecast_INTEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)
{
    char buffer[12];

    if (s == NULL) {Py_INCREF(Py_None); return Py_None;}
    if (s[len] != '\0') {
        strncpy(buffer, s, (size_t) len); buffer[len] = '\0';
        s = buffer;
    }
    return PyInt_FromString((char *)s, NULL, 0);
}
```


Overlapping Code:
```
TEGER_cast(const char *s, Py_ssize_t len, PyObject *curs)
{
char buffer[12];
if (s == NULL) {Py_INCREF(Py_None); return Py_None;}
if (s[len] != '\0') {
strncpy(buffer, s, (size_t) len); buffer[len] = '\0';
s = buffer;
}
return PyInt_FromString((char *)s, NULL, 0);
}
```
<Overlap Ratio: 0.9016949152542373>

---

--- 311 --
Question ID: fe5535ad54bf468756a35ecb6de17b26be4d3057_0
Original Code:
```
void TDF_PS_PK_free(TDF_PS_PK *pk) {
	if (pk == NULL) {
		return;
	}
	BN_free(pk->n);
	BN_free(pk->halfn);
	OPENSSL_free(pk);
}
```


Overlapping Code:
```
(TDF_PS_PK *pk) {
if (pk == NULL) {
return;
}
BN_free(pk->n);
BN_free(pk->halfn);
OPENSSL_free(pk);

```
<Overlap Ratio: 0.8333333333333334>

---

--- 312 --
Question ID: dfab238654a3003a955a6790101ab660b9b1767b_0
Original Code:
```
static int matchString(const char **strptr, const char *against)
{
    const char *str = *strptr;
    while (*against != 0) {
        if (*str != *against)
            return 0;
        str++;
        against++;
    }
    *strptr = str;
    return 1;
}
```


Overlapping Code:
```
tr, const char *against)
{
const char *str = *strptr;
while (*against != 0) {
if (*str != *against)
return 0;
str++;
against++;
}
*strptr = str;
retur
```
<Overlap Ratio: 0.7653061224489796>

---

--- 313 --
Question ID: ed476dc8604ce07efd20e09a32f4cd8f05cdf2e8_8
Original Code:
```
static int feature_node_lua_get_exons(lua_State *L)
{
  GtGenomeNode **gn = check_genome_node(L, 1);
  GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));
  unsigned long i = 0;
  GtFeatureNode *fn;
  /* make sure we get a feature node */
  fn = gt_feature_node_try_cast(*gn);
  luaL_argcheck(L, fn, 1, "not a feature node");
  gt_feature_node_get_exons(fn, exons);
  lua_newtable(L);
  for (i = 0; i < gt_array_size(exons); i++) {
    lua_pushnumber(L, i+1);
    gt_lua_genome_node_push(L, (GtGenomeNode*)
                            gt_genome_node_ref(*(GtGenomeNode**)
                                               gt_array_get(exons, i)));
    lua_rawset(L, -3);
  }
  gt_array_delete(exons);
  return 1;
}
```


Overlapping Code:
```
ic int feature_node_lua_get_exons(lua_State *L)
{
GtGenomeNode **gn = check_genome_node(L, 1);
GtArray *exons = gt_array_new(sizeof (GtGenomeNode*));
unsigned long i = 0;
GtFeatureNode *fn;
/* make sure we get a feature node */
fn = gt_feature_node_try_cast(*gn);
luaL_argcheck(L, fn, 1, "not a feature node");
gt_feature_node_get_exons(fn, exons);
lua_newtable(L);
for (i = 0; i < gt_array_size(exons); i++) {
lua_pushnumber(L, i+1);
gt_lua_genome_node_push(L, (GtGenomeNode*)
gt_genome_node_ref(*(GtGenomeNode**)
gt_array_get(exons, i)));
lua_rawset(L, -3);
}
gt_array_delete(exons);
re
```
<Overlap Ratio: 0.978369384359401>

---

--- 314 --
Question ID: aa59444ad530b940e0f4ef33b94ee6b1ab47d5aa_7
Original Code:
```
int	osd_path_split(const char *path, char dir[], char file[], int size)
{
    int pos = strlen(path);

    /* dir, file は十分なサイズを確保しているはずなので、軽くチェック */
    if (pos == 0 || size <= pos) {
	dir[0]  = '\0';
	file[0] = '\0';
	strncat(file, path, size-1);
	if (pos) fprintf(stderr, "internal overflow %d\n", __LINE__);
	return FALSE;
    }


    if (strcmp(path, "/") == 0) {	/* "/" の場合、別処理	*/
	strcpy(dir, "/");			/* ディレクトリは "/"	*/
	strcpy(file, "");			/* ファイルは ""	*/
	return TRUE;
    }

    if (path[ pos - 1 ] == '/') {	/* path 末尾の / は無視	*/
	pos --;
    }

    do {				/* / を末尾から探す	*/
	if (path[ pos - 1 ] == '/') { break; }
	pos --;
    } while (pos);

    if (pos) {				/* / が見つかったら	*/
	strncpy(dir, path, pos);		/* 先頭〜 / までをコピー*/
	if (pos > 1)
	    dir[ pos - 1 ] = '\0';		/* 末尾の / は削除する	*/
	else					/* ただし		*/ 
	    dir[ pos ] = '\0';			/* "/"の場合は / は残す */

	strcpy(file, &path[pos]);

    } else {				/* / が見つからなかった	*/
	strcpy(dir,  "");			/* ディレクトリは ""	*/
	strcpy(file, path);			/* ファイルは path全て	*/
    }

    pos = strlen(file);			/* ファイル末尾の / は削除 */
    if (pos && file[ pos - 1 ] == '/') { 
	file[ pos - 1 ] = '\0';
    }

    /*printf("SPLT:\"%s\" = \"%s\" + \"%s\")\n",path,dir,file);*/
    return TRUE;
}
```


Overlapping Code:
```
int osd_path_split(const char *path, char dir[], char file[], int size)
{
int pos = strlen(path);
/* dir, file は十分なサイズを確保しているはずなので、軽くチェック */
if (pos == 0 || size <= pos) {
dir[0] = '\0';
file[0] = '\0';
strncat(file, path, size-1);
if (pos) fprintf(stderr, "internal overflow %d\n", __LINE__);
return FALSE;
}
if (strcmp(path, "/") == 0) { /* "/" の場合、別処理 */
strcpy(dir, "/"); /* ディレクトリは "/" */
strcpy(file, ""); /* ファイルは "" */
return TRUE;
}
if (path[ pos - 1 ] == '/') { /* path 末尾の / は無視 */
pos --;
}
do { /* / を末尾から探す */
if (path[ pos - 1 ] == '/') { break; }
pos --;
} while (pos);
if (pos) { /* / が見つかったら */
strncpy(dir, path, pos); /* 先頭〜 / までをコピー*/
if (pos > 1)
dir[ pos - 1 ] = '\0'; /* 末尾の / は削除する */
else /* ただし */ 
dir[ pos ] = '\0'; /* "/"の場合は / は残す */
strcpy(file, &path[pos]);
} else { /* / が見つからなかった */
strcpy(dir, ""); /* ディレクトリは "" */
strcpy(file, path); /* ファイルは path全て */
}
pos = strlen(file); /* ファイル末尾の / は削除 */
if (pos && file[ pos - 1 ] == '/') { 
file[ pos - 1 ] = '\0';
}
/*printf("SPLT:\"%s\" = \"%s\" + \"%s\")\n",path,dir,file);*/
retu
```
<Overlap Ratio: 0.9906803355079217>

---

--- 315 --
Question ID: 7ee707011970a3ed2b3f554e4a47167bedd6b9ce_193
Original Code:
```
static short
FUNC_STDCALL(rb_dl_callback_short_18_3_stdcall)(DLSTACK_TYPE stack0, DLSTACK_TYPE stack1, DLSTACK_TYPE stack2, DLSTACK_TYPE stack3, DLSTACK_TYPE stack4, DLSTACK_TYPE stack5, DLSTACK_TYPE stack6, DLSTACK_TYPE stack7, DLSTACK_TYPE stack8, DLSTACK_TYPE stack9, DLSTACK_TYPE stack10, DLSTACK_TYPE stack11, DLSTACK_TYPE stack12, DLSTACK_TYPE stack13, DLSTACK_TYPE stack14, DLSTACK_TYPE stack15, DLSTACK_TYPE stack16, DLSTACK_TYPE stack17)
{
    VALUE ret, cb, args[18];

    args[0] = PTR2NUM(stack0);
    args[1] = PTR2NUM(stack1);
    args[2] = PTR2NUM(stack2);
    args[3] = PTR2NUM(stack3);
    args[4] = PTR2NUM(stack4);
    args[5] = PTR2NUM(stack5);
    args[6] = PTR2NUM(stack6);
    args[7] = PTR2NUM(stack7);
    args[8] = PTR2NUM(stack8);
    args[9] = PTR2NUM(stack9);
    args[10] = PTR2NUM(stack10);
    args[11] = PTR2NUM(stack11);
    args[12] = PTR2NUM(stack12);
    args[13] = PTR2NUM(stack13);
    args[14] = PTR2NUM(stack14);
    args[15] = PTR2NUM(stack15);
    args[16] = PTR2NUM(stack16);
    args[17] = PTR2NUM(stack17);
    cb = rb_ary_entry(rb_ary_entry(rb_DLStdcallCallbackProcs, 3), 78);
    ret = rb_funcall2(cb, rb_dl_cb_call, 18, args);
    return NUM2INT(ret);
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 316 --
Question ID: a2f9fca1f77fe001b017d5314ebe479483ffd5d2_0
Original Code:
```
interface MPCRadioStreamPing : NSObject {
    double  _timestamp;
    long long  _type;
    NSData * _value;
}
```


Overlapping Code:
```
 : NSObject {
double _timestamp;
long long _type;

```
<Overlap Ratio: 0.5208333333333334>

---

--- 317 --
Question ID: 511fa8678134602823885597f2bcfcfc044108a3_7
Original Code:
```
int16_t retrieveGpsMsg(uint16_t      numBytes,
					   GpsData_t *GPSData,
					   uint8_t       *outBuffer)
{
	BOOL status = 0;
	status = COM_buf_get(&(gGpsUartPtr->rec_buf),
                         outBuffer,
                         numBytes);
	if (status == 0)
		return 0; // bad [0]
	else // return number of bytes left
		return gGpsUartPtr->rec_buf.bytes_in_buffer;
}
```


Overlapping Code:
```
6_t retrieveGpsMsg(uint16_t numBytes,
GpsData_t *GPSData,
uint8_t *outBuffer)
{
BOOL status = 0;
status = COM_buf_get(&(gGpsUartPtr->rec_buf),
outBuffer,
numBytes);
if (status == 0)
return 0; // bad [0]
else // return number of bytes left
return gGps
```
<Overlap Ratio: 0.8650519031141869>

---

--- 318 --
Question ID: 2d26a2ba67bffbc0a509d7c2b62c5bf14fbc2606_13
Original Code:
```
static void cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)
{
	// sis_out_binary("recv", in_, ilen_);

	s_sis_net_class *cls = (s_sis_net_class *)handle_;
	s_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);
	if (!cxt || cxt->status == SIS_NET_DISCONNECT)
	{
		return ;
	}
	if (cxt->status == SIS_NET_WORKING)
	{
		//QQQ 如何处理分包的问题？
		sis_net_mems_push(cxt->recv_nodes, in_, ilen_);
		// 发送通知
		// sis_wait_thread_notice(cls->read_thread);
	}
	else if (cxt->status == SIS_NET_HANDING)
	{
		sis_memory_cat(cxt->recv_memory, in_, ilen_);
		int o = sis_ws_recv_hand_ask(cls, cxt);
		if (o == 1) // 收到正确的握手信息
		{
			LOG(8)("server hand ok. [%d]\n", sid_);
			// 这里发送登录信息 
			if (cls->cb_connected)
			{
				cls->cb_connected(cls->cb_source, sid_);
			}	
			// 设置工作状态		
			cxt->status = SIS_NET_WORKING;
			// 如果握手包后有数据就直接通知处理
			if (sis_memory_get_size(cxt->recv_memory) > 0)
			{
				sis_wait_thread_notice(cls->read_thread);
			}
		}
		else if (o != 0) // 收到错误的握手信息
		{
			// 如果返回<零 就说明数据出错
			// sis_net_class_close_cxt(cls, sid_);
			cxt->status = SIS_NET_DISCONNECT;
		} // == 0 还没有收到数据		
	}
}
```


Overlapping Code:
```
cb_server_recv_after(void *handle_, int sid_, char* in_, size_t ilen_)
{
// sis_out_binary("recv", in_, ilen_);
s_sis_net_class *cls = (s_sis_net_class *)handle_;
s_sis_net_context *cxt = sis_map_kint_get(cls->cxts, sid_);
if (!cxt || cxt->status == SIS_NET_DISCONNECT)
{
return ;
}
if (cxt->status == SIS_NET_WORKING)
{
//QQQ 如何处理分包的问题？
sis_net_mems_push(cxt->recv_nodes, in_, ilen_);
// 发送通知
// sis_wait_thread_notice(cls->read_thread);
}
else if (cxt->status == SIS_NET_HANDING)
{
sis_memory_cat(cxt->recv_memory, in_, ilen_);
int o = sis_ws_recv_hand_ask(cls, cxt);
if (o == 1) // 收到正确的握手信息
{
LOG(8)("server hand ok. [%d]\n", sid_);
// 这里发送登录信息 
if (cls->cb_connected)
{
cls->cb_connected(cls->cb_source, sid_);
} 
// 设置工作状态 
cxt->status = SIS_NET_WORKING;
// 如果握手包后有数据就直接通知处理
if (sis_memory_get_size(cxt->recv_memory) > 0)
{
sis_wait_thread_notice(cls->read_thread);
}
}
else if (o != 0) // 收到错误的握手信息
{
// 如果返回<零 就说明数据出错
// sis_net_class_close_cxt(cls, sid_);
cxt->status = SIS_NET_DISCONNECT;
}
```
<Overlap Ratio: 0.968054211035818>

---

--- 319 --
Question ID: 24735321e895312d09417e6b47aeed787d3b2018_30
Original Code:
```
int
xenHypervisorGetVcpuMax(virConnectPtr conn,
                        virDomainDefPtr def)
{
    xen_getdomaininfo dominfo;
    int ret;
    int maxcpu;
    xenUnifiedPrivatePtr priv = conn->privateData;

    /* inactive domain */
    if (def->id < 0) {
        maxcpu = MAX_VIRT_CPUS;
    } else {
        XEN_GETDOMAININFO_CLEAR(dominfo);
        ret = virXen_getdomaininfo(priv->handle, def->id,
                                   &dominfo);

        if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))
            return -1;
        maxcpu = XEN_GETDOMAININFO_MAXCPUID(dominfo) + 1;
    }

    return maxcpu;
}
```


Overlapping Code:
```
r conn,
virDomainDefPtr def)
{
xen_getdomaininfo dominfo;
int ret;
int maxcpu;
xenUnifiedPrivatePtr priv = conn->privateData;
/* inactive domain */
if (def->id < 0) {
maxcpu = MAX_VIRT_CPUS;
} else {
XEN_GETDOMAININFO_CLEAR(dominfo);
ret = virXen_getdomaininfo(priv->handle, def->id,
&dominfo);
if ((ret < 0) || (XEN_GETDOMAININFO_DOMAIN(dominfo) != def->id))
return -1;
maxcpu = XEN_GETDOMAININFO_MA
```
<Overlap Ratio: 0.8350730688935282>

---

--- 320 --
Question ID: cbae544022a07a67df776c245225634977e661c1_39
Original Code:
```
GT_INLINE gt_status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {
  if (func_params->alignment_info->map == NULL) return -1; // Don't print anything
  gt_attributes *attr=func_params->alignment_info->map->attributes;
  if(attr==NULL) return -1;
  void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);
  if(pp==NULL) return -1;
  uint64_t bis_type=*(uint64_t *)pp;
  if(bis_type>=5 || !bis_type) return -1;
  char XB_char_value="UCGM"[(int)bis_type-1];
  gt_string_clear(func_params->return_s);
  gt_string_append_char(func_params->return_s,XB_char_value);
  gt_string_append_eos(func_params->return_s);
  return 0; // OK
}
```


Overlapping Code:
```
status gt_sam_attribute_generate_XB(gt_sam_attribute_func_params* func_params) {
if (func_params->alignment_info->map == NULL) return -1; // Don't print anything
gt_attributes *attr=func_params->alignment_info->map->attributes;
if(attr==NULL) return -1;
void *pp=gt_attributes_get(attr,GT_ATTR_ID_BIS_TYPE);
if(pp==NULL) return -1;
uint64_t bis_type=*(uint64_t *)pp;
if(bis_type>=5 || !bis_type) return -1;
char XB_char_value="UCGM"[(int)bis_type-1];
gt_string_clear(func_params->return_s);
gt_string_append_char(func_params->return_s,XB_char_value);
gt_string_append_eos(func_params->return_s);
retu
```
<Overlap Ratio: 0.9584664536741214>

---

--- 321 --
Question ID: e7a2c51d3199d3fb5bce34f37f2f52f32e83a636_0
Original Code:
```
int
main(argc, argv)
	int argc;
	register char *argv[];
{
	int ch, errs;

	/* Start disks transferring immediately. */
	sync();

	while ((ch = getopt(argc, argv, "aFft:v")) != EOF)
		switch (ch) {
		case 'a':
			allflag = 1;
			break;
		case 'F':
			fake = 1;
			break;
		case 'f':
#ifdef	notnow
			fflag = MNT_FORCE;
#endif
			break;
		case 't':
			maketypelist(optarg);
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	if (argc == 0 && !allflag || argc != 0 && allflag)
		usage();

	if (allflag) {
		if (setfsent() == 0)
			err(1, "%s", _PATH_FSTAB);
		errs = umountall();
	} else
		for (errs = 0; *argv != NULL; ++argv)
			if (umountfs(*argv) == 0)
				errs = 1;
	exit(errs);
}
```


Overlapping Code:
```
ain(argc, argv)
int argc;
register char *argv[];
{
int ch, errs;
/* Start disks transferring immediately. */
sync();
while ((ch = getopt(argc, argv, "aFft:v")) != EOF)
switch (ch) {
case 'a':
allflag = 1;
break;
case 'F':
fake = 1;
break;
case 'f':
#ifdef notnow
fflag = MNT_FORCE;
#endif
break;
case 't':
maketypelist(optarg);
break;
case 'v':
vflag = 1;
break;
default:
usage();
/* NOTREACHED */
}
argc -= optind;
argv += optind;
if (argc == 0 && !allflag || argc != 0 && allflag)
usage();
if (allflag) {
if (setfsent() == 0)
err(1, "%s", _PATH_FSTAB);
errs = umountall();
} else
for (errs = 0; *argv != NULL; ++argv)
if (umountfs(*argv) == 0)
errs 
```
<Overlap Ratio: 0.9658753709198813>

---

--- 322 --
Question ID: 698bf4f5ac6c9e93098989c5891feb2611385387_33
Original Code:
```
static irqreturn_t tpd_interrupt_handler(int irq, void *dev_id)
{
	TPD_DEBUG_PRINT_INT;
	tpd_flag = 1;
	wake_up_interruptible(&waiter);
	return IRQ_HANDLED;
}
```


Overlapping Code:
```
r(int irq, void *dev_id)
{
TPD_DEBUG_PRINT_INT;
tpd_flag = 1;
wake_up_interruptible(&waiter);
return IRQ_HANDLE
```
<Overlap Ratio: 0.7207792207792207>

---

--- 323 --
Question ID: c570e54f40a3b5fa76324ed92f768954222760fb_4
Original Code:
```
static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)
{
    // check
    tb_single_list_t* list = (tb_single_list_t*)iterator;
    tb_assert(list && itor);

    // data
    return list->element.data(&list->element, (tb_cpointer_t)(((tb_single_list_entry_t*)itor) + 1));
}
```


Overlapping Code:
```
static tb_pointer_t tb_single_list_itor_item(tb_iterator_ref_t iterator, tb_size_t itor)
{
// check
tb_single_list_t* list = (tb_single_list_t*)iterator;
tb_assert(list && itor);
// data
return list->element.data(&list->element, (tb_cpointer_t)(((tb_
```
<Overlap Ratio: 0.8771929824561403>

---

--- 324 --
Question ID: 56dd26ea5d357cfcfd99cb5a5b48278749598a54_2
Original Code:
```
long sys_fcntl(unsigned long fd, long cmd, long arg)
{
	struct file *file;

	if (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))
		return -EBADF;

	switch (cmd) {
	case F_DUPFD:
		return dupfd(fd, arg);
	default:
		return -EIO;
	}
}
```


Overlapping Code:
```
s_fcntl(unsigned long fd, long cmd, long arg)
{
struct file *file;
if (fd > NR_OPEN || !(file = (CURRENT_TASK() )->file[fd]))
return -EBADF;
switch (cmd) {
case F_DUPFD:
return dupfd(fd, arg);
default
```
<Overlap Ratio: 0.8888888888888888>

---

--- 325 --
Question ID: 88f885a5092d38d9d5352b5897953a1b37fe7fb4_0
Original Code:
```
void generic_sendmsg (const char *fmt, ...)
{
	va_list ap;
	fprintf(outstream, "@");
	va_start(ap, fmt);
	vfprintf(outstream, fmt, ap);
	va_end(ap);
	fprintf(outstream, "\n");
}
```


Overlapping Code:
```
d generic_sendmsg (const char *fmt, ...)
{
va_list ap;
fprintf(outstream, "@");
va_start(ap, fmt);
vfprintf(outstream, fmt, ap);
va_end(ap);
fprintf(outstream, "\n");
}
```
<Overlap Ratio: 0.9824561403508771>

---

--- 326 --
Question ID: 11466f7394ed835e3bf4a6318e91cc20f45752cf_4
Original Code:
```
void itoa16bits(uint16_t number, char* ascii) {
	int i, j, k;
	i = 0;
	for (k = 10000; k > 10; k /= 10) {
		j = number/k;
		ascii[i] = j + 48;
		++i;
		number %= k;
	}
	j = number/k;
	ascii[i] = j + 48;
	++i;
	j = number%k;
	ascii[i] = j + 48;
}
```


Overlapping Code:
```
{
int i, j, k;
i = 0;
for (k = 10000; k > 10; k /= 10) {
j = number/k;
ascii[i] = j + 48;
++i;
number %= k;
}
j = number/k;
ascii[i] = j + 48;
++i;
j 
```
<Overlap Ratio: 0.6578947368421053>

---

--- 327 --
Question ID: 3eeb553552b92b26d98cf3cf78de38d0e9549ab3_15
Original Code:
```
static int adb_setup(void)
{
	struct adb_dev *dev;
	int ret;

	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (!dev)
		return -ENOMEM;

	spin_lock_init(&dev->lock);

	spin_lock_init(&open_lock);

	init_waitqueue_head(&dev->read_wq);
	init_waitqueue_head(&dev->write_wq);

	atomic_set(&dev->open_excl, 0);
	atomic_set(&dev->read_excl, 0);
	atomic_set(&dev->write_excl, 0);

	INIT_LIST_HEAD(&dev->tx_idle);

	_adb_dev = dev;

	ret = misc_register(&adb_device);
	if (ret)
		goto err;

	return 0;

 err:
	kfree(dev);
	printk(KERN_ERR "%s %s %d: adb gadget driver failed to initialize\n", __FILE__, __func__,
	       __LINE__);
	return ret;
}
```


Overlapping Code:
```
struct adb_dev *dev;
int ret;
dev = kzalloc(sizeof(*dev), GFP_KERNEL);
if (!dev)
return -ENOMEM;
spin_lock_init(&dev->lock);
spin_lock_init(&open_lock);
init_waitqueue_head(&dev->read_wq);
init_waitqueue_head(&dev->write_wq);
atomic_set(&dev->open_excl, 0);
atomic_set(&dev->read_excl, 0);
atomic_set(&dev->write_excl, 0);
INIT_LIST_HEAD(&dev->tx_idle);
_adb_dev = dev;
ret = misc_register(&adb_device);
if (ret)
goto err;
return 0;
err:
kfree(dev);
printk(KERN_ERR "%s %s %d: adb gadget driver failed to initialize\n", 
```
<Overlap Ratio: 0.8768971332209107>

---

--- 328 --
Question ID: 139f976a5c28f8dd2830fd45366ce3fb9c794544_0
Original Code:
```
interface ICShaderCache : NSObject {
@private
    NSMutableDictionary *_programs;
    ICShaderFactory *_shaderFactory;
}
```


Overlapping Code:
```
 NSObject {
@private
NSMutableDictionary *_program
```
<Overlap Ratio: 0.44642857142857145>

---

--- 329 --
Question ID: 55acd95e4c2ad8dd9ace80d0857bd3a5752bd53e_1
Original Code:
```
Token token_duplicate(Token source)
{
  Token token;

  token.type   = source.type;
  token.line   = source.line;
  token.col    = source.col;

  if(source.lexeme != NULL)
    token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));

  return token;
}
```


Overlapping Code:
```
n source)
{
Token token;
token.type = source.type;
token.line = source.line;
token.col = source.col;
if(source.lexeme != NULL)
token.lexeme = string_copy(source.lexeme, strlen(source.lexeme));
return 
```
<Overlap Ratio: 0.8547008547008547>

---

--- 330 --
Question ID: ec662537837488947ea43e811d65e6b3c12ea304_16
Original Code:
```
static void coroae_int(void) {
	uwsgi_log("Brutally killing worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
	uwsgi.workers[uwsgi.mywid].manage_next_request = 0;
	SvREFCNT_dec(ucoroae.watchers);

	coroae_condvar_call(ucoroae.condvar, "send");
}
```


Overlapping Code:
```
) {
uwsgi_log("Brutally killing worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
uwsgi.workers[uwsgi.mywid].manage_next_request = 0;
SvREFCNT_dec(ucoroae.watchers);
coroae_condvar_call(ucoroae.co
```
<Overlap Ratio: 0.819672131147541>

---

--- 331 --
Question ID: e7ec6e86c60a44ef3c227784777a281297d77697_1
Original Code:
```
int setConnTimeout(int conn_timeout){
  if (conn_timeout <= 0) {
    Log(ERROR, "Connection timout must be greater than zero");
    sprintf(NpsErrDesc, "%s", "Connection timout must be greater than zero");
    return -1;
  }
  NpsConnTimeout=conn_timeout;
  return 0;
}
```


Overlapping Code:
```
timeout){
if (conn_timeout <= 0) {
Log(ERROR, "Connection timout must be greater than zero");
sprintf(NpsErrDesc, "%s", "Connection timout must be greater than zero");
return -1;
}
NpsConnTimeout=conn
```
<Overlap Ratio: 0.8032128514056225>

---

--- 332 --
Question ID: 5ea3afa093a48e3c18921a5a3d433247ce35f4ff_0
Original Code:
```
int nhap() {
  int n;
  printf("Nhap vao so phan tu cua day (n<5): ");
  scanf("%i", &n);
  while (n <= 5) {
    printf("Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): ");
    scanf("%i", &n);
  }
  return n;
}
```


Overlapping Code:
```
 n;
printf("Nhap vao so phan tu cua day (n<5): ");
scanf("%i", &n);
while (n <= 5) {
printf("Du lieu khong hop le. Nhap vao so phan tu cua day (n<5): 
```
<Overlap Ratio: 0.75>

---

--- 333 --
Question ID: 68a020c11880688c831a48272884224ca8c5205e_0
Original Code:
```
class Date {
	private:
		uint_fast16_t _year;
		uint_fast16_t _day;
		uint_fast16_t _month;
	public:
		Date() = default;

		/**
		 * create date based on day, month, year
		 * @param year
		 * @param day
		 * @param month
		 */
		Date(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {
			if (isValidDate(year, day, month)) {
				_year = year ;
				_day = day;
				_month = month;
			}
```


Overlapping Code:
```
rivate:
uint_fast16_t _year;
uint_fast16_t _day;
uint_fast16_t _month;
public:
Date() = default;
/**
* create date based on day, month, year
* @param year
* @param day
* @param month
*/
Date(uint_fast16_t year, uint_fast16_t day, uint_fast16_t month) {
if (isValidDate(year, day, month)) {
_year = ye
```
<Overlap Ratio: 0.8620689655172413>

---

--- 334 --
Question ID: ce9244c6a533db19a5e950b18810a222c17694e7_9
Original Code:
```
static void TestButtons( void )
{
  alt_u8 buttons_tested;
  alt_u8 all_tested;
  /* Variable which holds the last value of edge_capture to avoid 
   * "double counting" button/switch presses
   */
  int last_tested;
  /* Initialize the Buttons/Switches (SW0-SW3) */
  init_button_pio();
  /* Initialize the variables which keep track of which buttons have been tested. */
  buttons_tested = 0x0;
  all_tested = 0xf;

  /* Initialize edge_capture to avoid any "false" triggers from
   * a previous run.
   */
   
  edge_capture = 0;
  
  /* Set last_tested to a value that edge_capture can never equal
   * to avoid accidental equalities in the while() loop below.
   */
    
  last_tested = 0xffff;

  /* Print a quick message stating what is happening */
  
  printf("\nA loop will be run until all buttons/switches have been pressed.\n\n");
  printf("\n\tNOTE:  Once a button press has been detected, for a particular button,\n\tany further presses will be ignored!\n\n");
  
  /* Loop until all buttons have been pressed.
   * This happens when buttons_tested == all_tested.
   */
  
  while (  buttons_tested != all_tested )
  { 
    if (last_tested == edge_capture)
    {
      continue;
    }
    else
    {
      last_tested = edge_capture;
      switch (edge_capture)
      {
        case 0x1:
          if (buttons_tested & 0x1)
          {
            continue;
          }
          else
          {
            printf("\nButton 1 (SW0) Pressed.\n");
            buttons_tested = buttons_tested | 0x1;
          } 
          break;
        case 0x2:
          if (buttons_tested & 0x2)
          {
            continue;
          } 
          else
          {
            printf("\nButton 2 (SW1) Pressed.\n");
            buttons_tested = buttons_tested | 0x2;
          }
          break;
        case 0x4:
          if (buttons_tested & 0x4)
          {
            continue;
          }
          else
          {
            printf("\nButton 3 (SW2) Pressed.\n");
            buttons_tested = buttons_tested | 0x4;
          }
          break;
        case 0x8:
          if (buttons_tested & 0x8)
          {
            continue;
          }
          else
          {
            printf("\nButton 4 (SW3) Pressed.\n");
            buttons_tested = buttons_tested | 0x8;
          }
          break;
      }
    }
  }
  /* Disable the button pio. */
  disable_button_pio();

  printf ("\nAll Buttons (SW0-SW3) were pressed, at least, once.\n");
  usleep(2000000);
  return;
}
```


Overlapping Code:
```
{
alt_u8 buttons_tested;
alt_u8 all_tested;
/* Variable which holds the last value of edge_capture to avoid 
* "double counting" button/switch presses
*/
int last_tested;
/* Initialize the Buttons/Switches (SW0-SW3) */
init_button_pio();
/* Initialize the variables which keep track of which buttons have been tested. */
buttons_tested = 0x0;
all_tested = 0xf;
/* Initialize edge_capture to avoid any "false" triggers from
* a previous run.
*/

edge_capture = 0;

/* Set last_tested to a value that edge_capture can never equal
* to avoid accidental equalities in the while() loop below.
*/

last_tested = 0xffff;
/* Print a quick message stating what is happening */

printf("\nA loop will be run until all buttons/switches have been pressed.\n\n");
printf("\n\tNOTE: Once a button press has been detected, for a particular button,\n\tany further presses will be ignored!\n\n");

/* Loop until all buttons have been pressed.
* This happens when buttons_tested == all_tested.
*/

while ( buttons_tested != all_tested )
{ 
if (last_tested == edge_capture)
{
continue;
}
else
{
last_tested = edge_capture;
switch (edge_capture)
{
case 0x1:
if (buttons_tested & 0x1)
{
continue;
}
else
{
printf("\nButton 1 (SW0) Pressed.\n");
buttons_tested = buttons_tested | 0x1;
} 
break;
case 0x2:
if (buttons_tested & 0x2)
{
continue;
} 
else
{
printf("\nButton 2 (SW1) Pressed.\n");
buttons_tested = buttons_tested | 0x2;
}
break;
case 0x4:
if (buttons_tested & 0x4)
{
continue;
}
else
{
printf("\nButton 3 (SW2) Pressed.\n");
buttons_tested = buttons_tested | 0x4;
}
break;
case 0x8:
if (buttons_tested & 0x8)
{
continue;
}
else
{
printf("\nButton 4 (SW3) Pressed.\n");
buttons_tested = buttons_tested | 0x8;
}
break;
}
}
}
/* Disable the button pio. */
disable_
```
<Overlap Ratio: 0.9711431742508324>

---

--- 335 --
Question ID: 8e6ec8b4781105359a31470e02995ef7cb2a492b_1
Original Code:
```
static int
BBox_init(polypaths_planar_overrideBBoxObject *self, PyObject *args)
{
    assert(polypaths_planar_overrideBBox_Check(self));
    if (PyTuple_GET_SIZE(args) != 1) {
        PyErr_SetString(PyExc_TypeError, 
            "BoundingBox: wrong number of arguments");
        return -1;
    }
    return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 0));
}
```


Overlapping Code:
```
init(polypaths_planar_overrideBBoxObject *self, PyObject *args)
{
assert(polypaths_planar_overrideBBox_Check(self));
if (PyTuple_GET_SIZE(args) != 1) {
PyErr_SetString(PyExc_TypeError, 
"BoundingBox: wrong number of arguments");
return -1;
}
return BBox_init_from_points(self, PyTuple_GET_ITEM(args, 
```
<Overlap Ratio: 0.9316770186335404>

---

--- 336 --
Question ID: a251ddb2edb7ec8f8cc82e043da7f23406efdebf_6
Original Code:
```
static void parseDatabaseLines(struct blastFile *bf, char *line, struct blastQuery *bq)
/* Process something like:
 * Database: chr22.fa 
 *        977 sequences; 95,550,797 total letters
 */
{
static struct dyString *tmpBuf = NULL;
char *words[16];
int wordCount;
if (bq->database != NULL)
    bfError(bf, "already parse Database:");

if (tmpBuf == NULL)
    tmpBuf = dyStringNew(512);

/* parse something like
 * Database: celegans98
 * some versions of blastp include the absolute path, but
 * then split it across lines.
 */
wordCount = chopLine(line, words);
if (wordCount < 2)
    bfError(bf, "Expecting database name");
dyStringClear(tmpBuf);
dyStringAppend(tmpBuf, words[1]);
while (line = bfNeedNextLine(bf), !isspace(line[0]))
    {
    dyStringAppend(tmpBuf, line);
    }
bq->database = cloneString(tmpBuf->string);

/* Process something like:
 *        977 sequences; 95,550,797 total letters
 */
wordCount = chopLine(line, words);
if (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))
    bfError(bf, "Expecting database info");
decomma(words[0]);
decomma(words[2]);
bq->dbSeqCount = atoi(words[0]);
bq->dbBaseCount = atoi(words[2]);
}
```


Overlapping Code:
```
baseLines(struct blastFile *bf, char *line, struct blastQuery *bq)
/* Process something like:
* Database: chr22.fa 
* 977 sequences; 95,550,797 total letters
*/
{
static struct dyString *tmpBuf = NULL;
char *words[16];
int wordCount;
if (bq->database != NULL)
bfError(bf, "already parse Database:");
if (tmpBuf == NULL)
tmpBuf = dyStringNew(512);
/* parse something like
* Database: celegans98
* some versions of blastp include the absolute path, but
* then split it across lines.
*/
wordCount = chopLine(line, words);
if (wordCount < 2)
bfError(bf, "Expecting database name");
dyStringClear(tmpBuf);
dyStringAppend(tmpBuf, words[1]);
while (line = bfNeedNextLine(bf), !isspace(line[0]))
{
dyStringAppend(tmpBuf, line);
}
bq->database = cloneString(tmpBuf->string);
/* Process something like:
* 977 sequences; 95,550,797 total letters
*/
wordCount = chopLine(line, words);
if (wordCount < 3 || !isdigit(words[0][0]) || !isdigit(words[2][0]))
bfError(bf, "Expecting database info");
decomma(words[0]);
decomma(words[2]);
bq->dbSeqCount = atoi(words[0]
```
<Overlap Ratio: 0.9467989179440938>

---

--- 337 --
Question ID: b9fcc45f3d2a0823d7decc621b4c7b1479b58f84_12
Original Code:
```
static  errval_t timer_remaining__lmp_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = timer_remaining__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remaining).time = time;
    FL_DEBUG("lmp TX timer.remaining\n");
    
    // try to send!
    timer_remaining__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}
```


Overlapping Code:
```
_send(struct timer_binding *_binding, struct event_closure _continuation, uint64_t time)
{
// check that we can accept an outgoing message
if ((_binding->tx_msgnum) != 0) {
return(FLOUNDER_ERR_TX_BUSY);
}

// register send continuation
if ((_continuation.handler) != NULL) {
errval_t _err;
_err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
// may fail if previous continuation hasn't fired yet
if (err_is_fail(_err)) {
if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
return(FLOUNDER_ERR_TX_BUSY);
} else {
assert(!("shouldn't happen"));
return(_err);
}
}
}

// store message number and arguments
_binding->tx_msgnum = timer_remaining__msgnum;
_binding->tx_msg_fragment = 0;
((_binding->tx_union).remaining).time = time;
FL_DEBUG("lmp TX timer.remaining\n");

// try to send!
timer_remaining__lmp_send_handler(_binding);

return(SYS_ERR_OK);
}
```
<Overlap Ratio: 0.9617834394904459>

---

--- 338 --
Question ID: 88ce019626ef8aeb971c637606c6eb7aec4e27f6_0
Original Code:
```
class FilterRender {
public:
	static void* render(void *data, uint width, uint height, Config* config);

private:
	static void* doFlip(void *data, uint width, uint height, bool isLR);
	static void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);
	static void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);
	static void* doAuto(void *data, uint width, uint height);
}
```


Overlapping Code:
```
ass FilterRender {
public:
static void* render(void *data, uint width, uint height, Config* config);
private:
static void* doFlip(void *data, uint width, uint height, bool isLR);
static void* doSlice(void *data, uint width, uint height, std::vector<Geometry::Point>);
static void* doColor(void *data, uint width, uint height, u_int8_t r, u_int8_t g, u_int8_t b ,u_int8_t a);
static void* doAuto(void *data, ui
```
<Overlap Ratio: 0.9380733944954128>

---

--- 339 --
Question ID: 0e3beb8a497b19f44113ea931aade6c9a513aae3_3
Original Code:
```
int encuentras(char titulo[])
{
    int encontrado = 0;
    actual = primero;
    while (actual != NULL && encontrado == 0)
    {

        if (strcmp(titulo, actual->titulo) == 0)
        {
            encontrado++;
        }
        else
        {
            anterior = actual;
            actual = actual->next;
        }
    }
    return encontrado;
}
```


Overlapping Code:
```
trado = 0;
actual = primero;
while (actual != NULL && encontrado == 0)
{
if (strcmp(titulo, actual->titulo) == 0)
{
encontrado++;
}
else
{
anterior = actual;
actual = actual->next;
}
}
return encontra
```
<Overlap Ratio: 0.8130081300813008>

---

--- 340 --
Question ID: 107fe8011a1f935551c4cfef6f93b765921af27b_1
Original Code:
```
static int win32_path_to_8(git_buf *dest, const wchar_t *src)
{
	git_win32_utf8_path utf8_path;

	if (git_win32_path_to_utf8(utf8_path, src) < 0) {
		giterr_set(GITERR_OS, "Unable to convert path to UTF-8");
		return -1;
	}

	/* Convert backslashes to forward slashes */
	git_path_mkposix(utf8_path);

	return git_buf_sets(dest, utf8_path);
}
```


Overlapping Code:
```
uf *dest, const wchar_t *src)
{
git_win32_utf8_path utf8_path;
if (git_win32_path_to_utf8(utf8_path, src) < 0) {
giterr_set(GITERR_OS, "Unable to convert path to UTF-8");
return -1;
}
/* Convert backslashes to forward slashes */
git_path_mkposix(utf8
```
<Overlap Ratio: 0.7598784194528876>

---

--- 341 --
Question ID: 9e029e62e46e673107afa1edfe5985addeb5743c_28
Original Code:
```
static int
macip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,
				 u32 acl_list_index)
{
  acl_main_t *am = &acl_main;
  int rv = -1;
  if (is_add)
    {
      rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);
    }
  else
    {
      rv = macip_acl_interface_del_acl (am, sw_if_index);
    }
  return rv;
}
```


Overlapping Code:
```
ip_acl_interface_add_del_acl (u32 sw_if_index, u8 is_add,
u32 acl_list_index)
{
acl_main_t *am = &acl_main;
int rv = -1;
if (is_add)
{
rv = macip_acl_interface_add_acl (am, sw_if_index, acl_list_index);
}
else
{
rv = macip_acl_interface_del_acl (am, sw_if_index);
}
retur
```
<Overlap Ratio: 0.928082191780822>

---

--- 342 --
Question ID: 887339108bfe36faf63e5b4598e4a368dc3af5df_5
Original Code:
```
void matrusseV2_2(matrix_t * A, matrix_t * B, matrix_t * C, int k) {

    uint32_t m = A->m;
    uint32_t blocksize = TAILLE_BLOC;
    uint32_t l = A->n;
    uint32_t n = B->nbColonneInt;
    uint32_t nbits = B->n;

    for (int start = 0; start < m/blocksize; ++start) {
        //progressBar(start,m/blocksize-1);

        for (int i = 0; i < l/k; ++i) {
            //alocating table of 2^k * B->nbColonneInt
            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);
            matrix_t * Bbloc = getBloc(B, i*k, i+k);
            fillTable2(T, Bbloc, k, k);
            for (int s = 0; s < blocksize; ++s) {
                uint64_t j = start*blocksize + s;
                int64_t id = extract(A,j, k*i, k);
                uint64_t * Tline = T+id*n;
                xorMatrixRow(C, j, Tline);
            }
            freeBloc(Bbloc);
            free(T);
        }

        int kReste = l%k;
        if (kReste != 0) {
            calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);
        }
    }

    uint32_t blocksizeReste = m%blocksize;
    if(blocksizeReste != 0) {

        int start = m - blocksizeReste;

        for (int i = 0; i < l/k; ++i) {
            //alocating table of 2^k * B->nbColonneInt
            uint64_t * T = malloc((n*sizeof(uint64_t))<<k);
            matrix_t * Bbloc = getBloc(B, i*k, i+k);
            fillTable(T, Bbloc, k);
            for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block
                uint64_t j = start + s;
                int64_t id = extract(A,j, k*i, k);
                uint64_t * Tline = T+id*n;
                xorMatrixRow(C, j, Tline);
            }
            free(Bbloc);
            Bbloc = NULL;
            free(T);
            T = NULL;
        }
        uint32_t kReste = l%k;
        if (kReste != 0) {
            //not multiplying by blocksize because start is already the beginning of the last bloc
            calculResteK(A, B, C, kReste, n, l, blocksizeReste, start);
        }
    }
}
```


Overlapping Code:
```
 matrix_t * C, int k) {
uint32_t m = A->m;
uint32_t blocksize = TAILLE_BLOC;
uint32_t l = A->n;
uint32_t n = B->nbColonneInt;
uint32_t nbits = B->n;
for (int start = 0; start < m/blocksize; ++start) {
//progressBar(start,m/blocksize-1);
for (int i = 0; i < l/k; ++i) {
//alocating table of 2^k * B->nbColonneInt
uint64_t * T = malloc((n*sizeof(uint64_t))<<k);
matrix_t * Bbloc = getBloc(B, i*k, i+k);
fillTable2(T, Bbloc, k, k);
for (int s = 0; s < blocksize; ++s) {
uint64_t j = start*blocksize + s;
int64_t id = extract(A,j, k*i, k);
uint64_t * Tline = T+id*n;
xorMatrixRow(C, j, Tline);
}
freeBloc(Bbloc);
free(T);
}
int kReste = l%k;
if (kReste != 0) {
calculResteK(A, B, C, kReste, n, l, blocksize, start*blocksize);
}
}
uint32_t blocksizeReste = m%blocksize;
if(blocksizeReste != 0) {
int start = m - blocksizeReste;
for (int i = 0; i < l/k; ++i) {
//alocating table of 2^k * B->nbColonneInt
uint64_t * T = malloc((n*sizeof(uint64_t))<<k);
matrix_t * Bbloc = getBloc(B, i*k, i+k);
fillTable(T, Bbloc, k);
for (int s = 0; s < blocksizeReste; ++s) { //scanning throught the last block
uint64_t j = start + s;
int64_t id = extract(A,j, k*i, k);
uint64_t * Tline = T+id*n;
xorMatrixRow(C, j, Tline);
}
free(Bbloc);
Bbloc = NULL;
free(T);
T = NULL;
}
uint32_t kReste = l%k;
if (kReste != 0) {
//not multiplying by blocksize because start is already the beginning of the last bloc
calculResteK(A, B, C, kReste, n, l, blocksizeRest
```
<Overlap Ratio: 0.9590878604963112>

---

--- 343 --
Question ID: 3d81c505cc9aaa697cfcc48a9f34b78be8e7c71b_0
Original Code:
```
int main(int argc, char* argv[])
{
    char cmd;
    int key1, key2;
    FILE* input;
    Position header = NULL;
    Position tmpPosition = NULL;

    input = fopen(argv[1], "r");
    header = MakeEmpty();

    while(true)
    {
        cmd = fgetc(input);
        if(feof(input)) break;
        switch(cmd)
        {
        case 'i':
            fscanf(input, "%d %d", &key1, &key2);
            tmpPosition = Find(key1, header);
            if(tmpPosition != NULL)
            {
                printf("Insertion failed: there already is an element with key %d.\n", key1);
                break;
            }
            if(key2 == -1)
                tmpPosition = header;
            else
                tmpPosition = Find(key2, header);
            Insert(key1, header, tmpPosition);
//          PrintList(header);
            break;
        case 'd':
            fscanf(input, "%d", &key1);
            Delete(key1, header);
//          PrintList(header);
            break;
        case 'f':
            fscanf(input, "%d", &key1);
            tmpPosition = FindPrevious(key1, header);
            if (tmpPosition == NULL)
                printf("Could not find %d in the list\n", key1);
            else
            {
                if(tmpPosition->element>0)
                    printf("Key of the previous node of %d is %d.\n", key1, tmpPosition->element);
                else
                    printf("Key of the previous node of %d is header.\n", key1);
            }
            break;
        case 'p':
            PrintList(header);
        }
    }
    DeleteList(header);
    fclose(input);
    return 0;
}
```


Overlapping Code:
```
c, char* argv[])
{
char cmd;
int key1, key2;
FILE* input;
Position header = NULL;
Position tmpPosition = NULL;
input = fopen(argv[1], "r");
header = MakeEmpty();
while(true)
{
cmd = fgetc(input);
if(feof(input)) break;
switch(cmd)
{
case 'i':
fscanf(input, "%d %d", &key1, &key2);
tmpPosition = Find(key1, header);
if(tmpPosition != NULL)
{
printf("Insertion failed: there already is an element with key %d.\n", key1);
break;
}
if(key2 == -1)
tmpPosition = header;
else
tmpPosition = Find(key2, header);
Insert(key1, header, tmpPosition);
// PrintList(header);
break;
case 'd':
fscanf(input, "%d", &key1);
Delete(key1, header);
// PrintList(header);
break;
case 'f':
fscanf(input, "%d", &key1);
tmpPosition = FindPrevious(key1, header);
if (tmpPosition == NULL)
printf("Could not find %d in the list\n", key1);
else
{
if(tmpPosition->element>0)
printf("Key of the previous node of %d is %d.\n", key1, tmpPosition->element);
else
printf("Key of the previous node of %d is header.\n", key1);
}
break;
case 'p':
PrintList(header);
}
}
DeleteList(header)
```
<Overlap Ratio: 0.9597806215722121>

---

--- 344 --
Question ID: ca68dfe6d2116c7f479fc425f6e647ac548b866b_0
Original Code:
```
namespace brew {

class VideoContext :
        public Object,
        private ProxyObjectManager<Texture, TextureContextHandle>,
        private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,
        private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,
        private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,
        private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,
        private ProxyObjectManager<Mesh, MeshContextHandle>,
        private ProxyObjectManager<Shader, ShaderContextHandle>,
        private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>
{
public:
    /**
     * Initializes pending context objects. Should not be called manually.
     */
    void processPendingOperations();

public:
    /**
     * Creates a new empty texture.
     * @param width The texture width.
     * @param height The texture height.
     * @param color The initial color.
     * @param format The texture format.
     * @param filtering The texture filtering.
     * @param numMipMaps The number of mip-maps to generate.
     * @return The created texture.
     */
    std::shared_ptr<Texture> createTexture(SizeT width,
                                           SizeT height,
                                           Color color = Color::BLACK,
                                           TextureFormat format = Texture::DefaultTextureFormat,
                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,
                                           u8 numMipMaps = Texture::DefaultMipMaps
    );

    /**
     * Creates a new texture from an existing pixmap.
     * @param pixmap The source pixmap.
     * @param format The texture format.
     * @param filtering The texture filtering.
     * @param numMipMaps The number of mip-maps to generate.
     * @return The created texture.
     */
    std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,
                                           TextureFormat format = Texture::DefaultTextureFormat,
                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,
                                           u8 numMipMaps = Texture::DefaultMipMaps
    );

    /**
     * Creates a new texture from an existing pixmap.
     * @param pixmap The source pixmap.
     * @param format The texture format.
     * @param filtering The texture filtering.
     * @param numMipMaps The number of mip-maps to generate.
     * @return The created texture.
     */
    inline std::shared_ptr<Texture> createTexture(const Pixmap& pixmap,
                                           TextureFormat format = Texture::DefaultTextureFormat,
                                           TextureFiltering filtering = Texture::DefaultTextureFiltering,
                                           u8 numMipMaps = Texture::DefaultMipMaps
    ) {
        return createTexture(std::make_shared<Pixmap>(pixmap), format, filtering, numMipMaps);
    }
```


Overlapping Code:
```
c Object,
private ProxyObjectManager<Texture, TextureContextHandle>,
private ProxyObjectManager<FrameBuffer, FrameBufferContextHandle>,
private ProxyObjectManager<ShaderVariables, ShaderVariablesContextHandle>,
private ProxyObjectManager<VertexBuffer, VertexBufferContextHandle>,
private ProxyObjectManager<IndexBuffer, IndexBufferContextHandle>,
private ProxyObjectManager<Mesh, MeshContextHandle>,
private ProxyObjectManager<Shader, ShaderContextHandle>,
private ProxyObjectManager<ShaderProgram, ShaderProgramContextHandle>
{
public:
/**
* Initializes pending context objects. Should not be called manually.
*/
void processPendingOperations();
public:
/**
* Creates a new empty texture.
* @param width The texture width.
* @param height The texture height.
* @param color The initial color.
* @param format The texture format.
* @param filtering The texture filtering.
* @param numMipMaps The number of mip-maps to generate.
* @return The created texture.
*/
std::shared_ptr<Texture> createTexture(SizeT width,
SizeT height,
Color color = Color::BLACK,
TextureFormat format = Texture::DefaultTextureFormat,
TextureFiltering filtering = Texture::DefaultTextureFiltering,
u8 numMipMaps = Texture::DefaultMipMaps
);
/**
* Creates a new texture from an existing pixmap.
* @param pixmap The source pixmap.
* @param format The texture format.
* @param filtering The texture filtering.
* @param numMipMaps The number of mip-maps to generate.
* @return The created texture.
*/
std::shared_ptr<Texture> createTexture(std::shared_ptr<Pixmap> pixmap,
TextureFormat format = Texture::DefaultTextureFormat,
TextureFiltering filtering = Texture::DefaultTextureFiltering,
u8 numMipMaps = Texture::DefaultMipMaps
);
/**
* Creates a new texture from an existing pixmap.
* @param pixmap The source pixmap.
* @param format The texture format.
* @param filtering The texture filtering.
* @param numMi
```
<Overlap Ratio: 0.9766597510373444>

---

--- 345 --
Question ID: ca1102ef5f7fb30f08d0b73673f2af49d587b80c_20
Original Code:
```
int infra_find_ratelimit(struct infra_cache* infra, uint8_t* name,
	size_t namelen)
{
	int labs = dname_count_labels(name);
	struct domain_limit_data* d = (struct domain_limit_data*)
		name_tree_lookup(&infra->domain_limits, name, namelen, labs,
		LDNS_RR_CLASS_IN);
	if(!d) return infra_dp_ratelimit;

	if(d->node.labs == labs && d->lim != -1)
		return d->lim; /* exact match */

	/* find 'below match' */
	if(d->node.labs == labs)
		d = (struct domain_limit_data*)d->node.parent;
	while(d) {
		if(d->below != -1)
			return d->below;
		d = (struct domain_limit_data*)d->node.parent;
	}
	return infra_dp_ratelimit;
}
```


Overlapping Code:
```
elimit(struct infra_cache* infra, uint8_t* name,
size_t namelen)
{
int labs = dname_count_labels(name);
struct domain_limit_data* d = (struct domain_limit_data*)
name_tree_lookup(&infra->domain_limits, name, namelen, labs,
LDNS_RR_CLASS_IN);
if(!d) return infra_dp_ratelimit;
if(d->node.labs == labs && d->lim != -1)
return d->lim; /* exact match */
/* find 'below match' */
if(d->node.labs == labs)
d = (struct domain_limit_data*)d->node.parent;
while(d) {
if(d->below != -1)
return d->below;
d = (struct domain_limit_data*)d->node.parent;
}
return 
```
<Overlap Ratio: 0.933786078098472>

---

--- 346 --
Question ID: cfb52f18eb22f22d020e63008c943df637f42ffe_4
Original Code:
```
void *
kalloc(usize size)
{
    spin_lock(vm_global_lock);

    void *ret = NULL;
    int16 sector_id = -1;
    if (size <= SECTOR0_BOUND)
    {
        sector_id = 0;
    }
    else if (size <= SECTOR1_BOUND)
    {
        sector_id = 1;
    }
    else if (size < PAGE_SIZE)
    {
        sector_id = 2;
    }

    if (sector_id >= 0)
    { ret = vm_alloc(size, sector_id); }
    else
    { ret = vm_alloc_multpages(size); }
    //void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));
    kprintf("Allocated Virtual: 0x%x Size: %d\n", ret, (uint64) size);
    /* Hack */
    int32 status = ESUCCESS;
    if (ret != NULL)
    {
        // check if the target page is already mapped
        // ret val does not cross page boundries
        if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)
        {
            uintptr frame = (uintptr) pmalloc(PAGE_SIZE);
            uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);
            status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);
        }
    }

    if (status != ESUCCESS)
    {
        ret = NULL;
    }
    else
    {
        flush_tlb();
    }

    spin_unlock(vm_global_lock);
    return ret;
}
```


Overlapping Code:
```
lloc(usize size)
{
spin_lock(vm_global_lock);
void *ret = NULL;
int16 sector_id = -1;
if (size <= SECTOR0_BOUND)
{
sector_id = 0;
}
else if (size <= SECTOR1_BOUND)
{
sector_id = 1;
}
else if (size < PAGE_SIZE)
{
sector_id = 2;
}
if (sector_id >= 0)
{ ret = vm_alloc(size, sector_id); }
else
{ ret = vm_alloc_multpages(size); }
//void *ret = (void *) R_PADDR((paddr) vm_alloc(size, sector_id));
kprintf("Allocated Virtual: 0x%x Size: %d\n", ret, (uint64) size);
/* Hack */
int32 status = ESUCCESS;
if (ret != NULL)
{
// check if the target page is already mapped
// ret val does not cross page boundries
if (get_paddr(read_cr3(), (uintptr) ret) == (uintptr) NULL)
{
uintptr frame = (uintptr) pmalloc(PAGE_SIZE);
uint64 map_stat = map_vmem(read_cr3(), (uintptr) ret, frame);
status = (frame != (uintptr) NULL) && (map_stat != ESUCCESS);
}
}
if (status != ESUCCESS)
{
ret = NULL;
}
else
{
flush_tlb();
}
```
<Overlap Ratio: 0.9453781512605042>

---

--- 347 --
Question ID: d6469d4f8aba819a52bef6ad77c5ef428a5d518a_1
Original Code:
```
class DepthCalibrator
{
public:
  DepthCalibrator(ros::NodeHandle& nh);

  /**
     * @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth
   * correction calculations
     *
     * Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.
     * Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the
     * calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients
   * to be solved for.
     *
     *
     * @param[in] request Empty
     * @param[out] response Empty
     * @return True if the call succeeded
     */
  bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);

  /**
     * @brief Finds the depth error for each pixel in the point cloud
     *
     * Finds the calibration target and compares each pixel depth value to the expected depth value based upon the
     * pose of the target found.  Stores the resulting depth compensation values as a point cloud for use in the
     * depth correction nodelet.
     *
     * @param[in] request Empty
     * @param[out] response Empty
     * @return True if the call succeeded
     */
  bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);

  /**
     * @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction
   * calculations
     *
     * @param[in] request Empty
     * @param[out] response Empty
     * @return True if the call succeeded
     */
  bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);

  /**
     * @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,
   * image, and target pose
     *
     * @param[in] cloud The latest point cloud received
     * @param[in] image The latest RGB image received
     * @return True if the call succeeded
     */
  void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);

private:
  const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package  */

  ros::NodeHandle nh_; /**< @brief ROS node handle */
  bool save_data_;     /**< @brief Flag to determine whether to save calibration results or not */

  typedef message_filters::sync_policies::ApproximateTime< sensor_msgs::PointCloud2, sensor_msgs::Image > PolicyType;
  typedef message_filters::Subscriber< sensor_msgs::PointCloud2 > PointCloudSubscriberType;
  typedef message_filters::Subscriber< sensor_msgs::Image > ImageSubscriberType;
  typedef message_filters::Synchronizer< PolicyType > SynchronizerType;
  boost::shared_ptr< PointCloudSubscriberType > point_cloud_sub_; /**< @brief Point cloud subscriber */
  boost::shared_ptr< ImageSubscriberType > image_sub_;            /**< @brief RGB image subscriber */
  boost::shared_ptr< SynchronizerType > synchronizer_; /**< @brief Syncronizer for point cloud and image data */

  ros::ServiceClient get_target_pose_;       /**< @brief Service to call target locator to get target pose */
  ros::ServiceServer calibrate_depth_;       /**< @brief Service to compute depth coefficients d1 and d2 */
  ros::ServiceServer calibrate_pixel_depth_; /**< @brief Service to calculate pixel depth error */
  ros::ServiceServer set_store_cloud_;       /**< @brief Service to set and store next point cloud available */

  int num_views_;        /**< @brief Number of times to find the calibration target to get average pose */
  int num_attempts_;     /**< @brief Number of attempts allowed for finding calibration target before failing */
  int num_point_clouds_; /**< @brief Number of point clouds to save and check when performing pixel depth error
                            calculations */
  std::string filename_; /**< @brief Name of the calibration files to save */
  std::string filepath_; /**< @brief Pathway to the location to save calibration files */
  geometry_msgs::Pose
      target_initial_pose_; /**< @brief The initial pose guess of the calibration target for the target finder service
                               */

  double std_dev_error_;          /**< @brief The standard deviation error allowed for finding the target pose */
  double depth_error_threshold_;  /**< @brief The depth error allowed for calculating the pixel depth error map */
  boost::mutex data_lock_;        /**< @brief Lock for data subscription */
  sensor_msgs::Image last_image_; /**< @brief The last color image received */
  pcl::PointCloud< pcl::PointXYZ > last_cloud_; /**< @brief The last point cloud received */
  pcl::PointCloud< pcl::PointXYZ >
      correction_cloud_; /**< @brief The point cloud containing the depth correction values */
  std::vector< pcl::PointCloud< pcl::PointXYZ >, Eigen::aligned_allocator< pcl::PointCloud< pcl::PointXYZ > > >
      saved_clouds_;
  /**< @brief The vector of stored point clouds used to compute the distance coefficients */
  std::vector< std::vector< double > >
      plane_equations_;                 /**< @brief A vector of plane equations for each point cloud in saved_clouds_ */
  std::vector< cv::Mat > saved_images_; /**< @brief A vector of rgb images for each point cloud in saved_clouds_ */
  std::vector< geometry_msgs::Pose > saved_target_poses_; /**< @brief A vector of target poses for each point cloud in
                                                             saved_clouds_ */

  /**
     * @brief Stores the calibration results in a YAML formated file
     *
     * @param[in] yaml_file The name and pathway of the file to be saved
     * @param[in] dp The depth correction coefficients to be saved
     */
  void storeCalibration(const std::string& yaml_file, const double dp[2]);

  /**
     * @brief Populates and calls the target finder service
     *
     * @param[in] final_cost The desired final cost for the service call
     * @param[out] target_pose The pose of the target returned from the service call
     * @return True if the service call succeeds
     */
  bool findTarget(const double& final_cost, geometry_msgs::Pose& target_pose);

  /**
     * @brief Calls the findTarget function multiple times (num_views) and returns the average plane equation and the
   * last target pose found
     *
     * @param[out] plane_eq The average plane equation results found from averaging the results from all of the target
   * poses found
     * @param[out] target_pose The pose of the target found from the last service call
     * @return True if the target was successfully found before the number of failures (num_attempts) was reached
     */
  bool findAveragePlane(std::vector< double >& plane_eq, geometry_msgs::Pose& target_pose);

  bool findAveragePointCloud(pcl::PointCloud< pcl::PointXYZ >& final_cloud);
}
```


Overlapping Code:
```
ibrator
{
public:
DepthCalibrator(ros::NodeHandle& nh);
/**
* @brief If pixel depth calibration has been performed, and points clouds have been stored, performs depth
* correction calculations
*
* Calculates the depth correction coefficients d1 and d2 using the point clouds previously stored.
* Depth correction for each pixel is of the form D*e^(d1 + d2 * z), where D is the pixel depth error found from the
* calibrateCameraPixelDepth callback, z is the depth of the given pixel, and d1 and d2 are the depth coefficients
* to be solved for.
*
*
* @param[in] request Empty
* @param[out] response Empty
* @return True if the call succeeded
*/
bool calibrateCameraDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);
/**
* @brief Finds the depth error for each pixel in the point cloud
*
* Finds the calibration target and compares each pixel depth value to the expected depth value based upon the
* pose of the target found. Stores the resulting depth compensation values as a point cloud for use in the
* depth correction nodelet.
*
* @param[in] request Empty
* @param[out] response Empty
* @return True if the call succeeded
*/
bool calibrateCameraPixelDepth(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);
/**
* @brief Sets the flag to store the next point cloud retrieved for later use when performing depth correction
* calculations
*
* @param[in] request Empty
* @param[out] response Empty
* @return True if the call succeeded
*/
bool setStoreCloud(std_srvs::Empty::Request& request, std_srvs::Empty::Response& response);
/**
* @brief Updates the last_cloud_ data, and if the store_point_cloud_ boolean is set, stores the latest cloud,
* image, and target pose
*
* @param[in] cloud The latest point cloud received
* @param[in] image The latest RGB image received
* @return True if the call succeeded
*/
void updateInputData(const sensor_msgs::PointCloud2ConstPtr& cloud, const sensor_msgs::ImageConstPtr& image);
private:
const static unsigned int VERSION_NUMBER_; /**< @brief Version number for the calibration package */
ros::NodeHandle nh_; /**< @brief ROS node handle */
bool save_data_; /**< @brief Flag to determine whether to save calibration results or not */
typedef message_filters:
```
<Overlap Ratio: 0.985545335085414>

---

--- 348 --
Question ID: 9628ceccfa02f195b83f8989a7064f0411bc0ab3_13
Original Code:
```
int						/* error */
xfs_dir2_block_replace(
	xfs_da_args_t		*args)		/* directory operation args */
{
	xfs_dir2_data_hdr_t	*hdr;		/* block header */
	xfs_dir2_leaf_entry_t	*blp;		/* block leaf entries */
	struct xfs_buf		*bp;		/* block buffer */
	xfs_dir2_block_tail_t	*btp;		/* block tail */
	xfs_dir2_data_entry_t	*dep;		/* block data entry */
	xfs_inode_t		*dp;		/* incore inode */
	int			ent;		/* leaf entry index */
	int			error;		/* error return value */
	xfs_mount_t		*mp;		/* filesystem mount point */

	trace_xfs_dir2_block_replace(args);

	/*
	 * Lookup the entry in the directory.  Get buffer and entry index.
	 * This will always succeed since the caller has already done a lookup.
	 */
	if ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {
		return error;
	}
	dp = args->dp;
	mp = dp->i_mount;
	hdr = bp->b_addr;
	btp = xfs_dir2_block_tail_p(args->geo, hdr);
	blp = xfs_dir2_block_leaf_p(btp);
	/*
	 * Point to the data entry we need to change.
	 */
	dep = (xfs_dir2_data_entry_t *)((char *)hdr +
			xfs_dir2_dataptr_to_off(args->geo,
						be32_to_cpu(blp[ent].address)));
	ASSERT(be64_to_cpu(dep->inumber) != args->inumber);
	/*
	 * Change the inode number to the new value.
	 */
	dep->inumber = cpu_to_be64(args->inumber);
	dp->d_ops->data_put_ftype(dep, args->filetype);
	xfs_dir2_data_log_entry(args, bp, dep);
	xfs_dir3_data_check(dp, bp);
	return 0;
}
```


Overlapping Code:
```
 /* error */
xfs_dir2_block_replace(
xfs_da_args_t *args) /* directory operation args */
{
xfs_dir2_data_hdr_t *hdr; /* block header */
xfs_dir2_leaf_entry_t *blp; /* block leaf entries */
struct xfs_buf *bp; /* block buffer */
xfs_dir2_block_tail_t *btp; /* block tail */
xfs_dir2_data_entry_t *dep; /* block data entry */
xfs_inode_t *dp; /* incore inode */
int ent; /* leaf entry index */
int error; /* error return value */
xfs_mount_t *mp; /* filesystem mount point */
trace_xfs_dir2_block_replace(args);
/*
* Lookup the entry in the directory. Get buffer and entry index.
* This will always succeed since the caller has already done a lookup.
*/
if ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {
return error;
}
dp = args->dp;
mp = dp->i_mount;
hdr = bp->b_addr;
btp = xfs_dir2_block_tail_p(args->geo, hdr);
blp = xfs_dir2_block_leaf_p(btp);
/*
* Point to the data entry we need to change.
*/
dep = (xfs_dir2_data_entry_t *)((char *)hdr +
xfs_dir2_dataptr_to_off(args->geo,
be32_to_cpu(blp[ent].address)));
ASSERT(be64_to_cpu(dep->inumber) != args->inumber);
/*
* Change the inode number to the new value.
*/
dep->inumber = cpu_to_be64(args->inumber);
dp->d_ops->data_put_ftype(dep, args->filetype);
xfs_dir2_data_log_entry(args, bp, 
```
<Overlap Ratio: 0.962278675904542>

---

--- 349 --
Question ID: 8d5d24466d16739c61b51b6ca7b560ce09a47251_2
Original Code:
```
void args_usage(args_t *args, FILE *out) {
  fprintf(out, "Usage: %s", args->program_name);
  for (int s = 0; s < args->shortcuts->hsize; s++) {
    hash_element_t *elem = args->shortcuts->htable[s];
    while (elem != NULL) {
      fprintf(out, " [ -%s ]", elem->key);
      elem = elem->p;
    }
  }
  fprintf(out, "\n\n");
  fprintf(out, "Try `%s --help` for more help.\n\n", args->program_name);
}
```


Overlapping Code:
```
args_usage(args_t *args, FILE *out) {
fprintf(out, "Usage: %s", args->program_name);
for (int s = 0; s < args->shortcuts->hsize; s++) {
hash_element_t *elem = args->shortcuts->htable[s];
while (elem != NULL) {
fprintf(out, " [ -%s ]", elem->key);
elem = elem->p;
}
}
fprintf(out, "\n\n");
fprintf(out, "Try `%s --help` for more help.\n\n", args->prog
```
<Overlap Ratio: 0.9536784741144414>

---

--- 350 --
Question ID: 1ecfa9d89747e74a8c5dc7ee15b139f12a480d86_0
Original Code:
```
static int sign(OSSL_LIB_CTX *libctx, unsigned char **sig, size_t *sig_len)
{
    int rv = 0;
    EVP_PKEY *pkey = NULL;
    EVP_PKEY_CTX *ctx = NULL;
    EVP_MD *md = NULL;
    const unsigned char *ppriv_key = NULL;

    *sig = NULL;

    /* Load DER-encoded RSA private key. */
    ppriv_key = rsa_priv_key;
    pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,
                             sizeof(rsa_priv_key), libctx, propq);
    if (pkey == NULL) {
        fprintf(stderr, "Failed to load private key\n");
        goto end;
    }

    /* Fetch hash algorithm we want to use. */
    md = EVP_MD_fetch(libctx, "SHA256", propq);
    if (md == NULL) {
        fprintf(stderr, "Failed to fetch hash algorithm\n");
        goto end;
    }

    /* Create signing context. */
    ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);
    if (ctx == NULL) {
        fprintf(stderr, "Failed to create signing context\n");
        goto end;
    }

    /* Initialize context for signing and set options. */
    if (EVP_PKEY_sign_init(ctx) == 0) {
        fprintf(stderr, "Failed to initialize signing context\n");
        goto end;
    }

    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {
        fprintf(stderr, "Failed to configure padding\n");
        goto end;
    }

    if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {
        fprintf(stderr, "Failed to configure digest type\n");
        goto end;
    }

    /* Determine length of signature. */
    if (EVP_PKEY_sign(ctx, NULL, sig_len,
                      test_digest, sizeof(test_digest)) == 0) {
        fprintf(stderr, "Failed to get signature length\n");
        goto end;
    }

    /* Allocate memory for signature. */
    *sig = OPENSSL_malloc(*sig_len);
    if (*sig == NULL) {
        fprintf(stderr, "Failed to allocate memory for signature\n");
        goto end;
    }

    /* Generate signature. */
    if (EVP_PKEY_sign(ctx, *sig, sig_len,
                      test_digest, sizeof(test_digest)) != 1) {
        fprintf(stderr, "Failed to sign\n");
        goto end;
    }

    rv = 1;
end:
    EVP_PKEY_CTX_free(ctx);
    EVP_PKEY_free(pkey);
    EVP_MD_free(md);

    if (rv == 0)
        OPENSSL_free(*sig);

    return rv;
}
```


Overlapping Code:
```
ned char **sig, size_t *sig_len)
{
int rv = 0;
EVP_PKEY *pkey = NULL;
EVP_PKEY_CTX *ctx = NULL;
EVP_MD *md = NULL;
const unsigned char *ppriv_key = NULL;
*sig = NULL;
/* Load DER-encoded RSA private key. */
ppriv_key = rsa_priv_key;
pkey = d2i_PrivateKey_ex(EVP_PKEY_RSA, NULL, &ppriv_key,
sizeof(rsa_priv_key), libctx, propq);
if (pkey == NULL) {
fprintf(stderr, "Failed to load private key\n");
goto end;
}
/* Fetch hash algorithm we want to use. */
md = EVP_MD_fetch(libctx, "SHA256", propq);
if (md == NULL) {
fprintf(stderr, "Failed to fetch hash algorithm\n");
goto end;
}
/* Create signing context. */
ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);
if (ctx == NULL) {
fprintf(stderr, "Failed to create signing context\n");
goto end;
}
/* Initialize context for signing and set options. */
if (EVP_PKEY_sign_init(ctx) == 0) {
fprintf(stderr, "Failed to initialize signing context\n");
goto end;
}
if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) == 0) {
fprintf(stderr, "Failed to configure padding\n");
goto end;
}
if (EVP_PKEY_CTX_set_signature_md(ctx, md) == 0) {
fprintf(stderr, "Failed to configure digest type\n");
goto end;
}
/* Determine length of signature. */
if (EVP_PKEY_sign(ctx, NULL, sig_len,
test_digest, sizeof(test_digest)) == 0) {
fprintf(stderr, "Failed to get signature length\n");
goto end;
}
/* Allocate memory for signature. */
*sig = OPENSSL_malloc(*sig_len);
if (*sig == NULL) {
fprintf(stderr, "Failed to allocate memory for signature\n");
goto end;
}
/* Generate signature. */
if (EVP_PKEY_sign(ctx, *sig, sig_len,
test_digest, sizeof(test_digest)) != 1) {
fprintf(stderr, "Failed to sign\n");
goto end;
}
rv = 1;
end:
EVP_PKEY_CTX_free(ctx);
EVP_PKEY_free(pkey);
EVP_MD_free(md);
if (rv == 0)
OPENSS
```
<Overlap Ratio: 0.9621503017004936>

---

--- 351 --
Question ID: 855240960056a1c3cc5995c6838084d84c5d33a8_3
Original Code:
```
int BGBCC_SHXC_EmitCompareVRegVRegVRegQLong(
	BGBCC_TransState *ctx,
	BGBCC_SHX_Context *sctx,
	ccxl_type type, ccxl_register dreg, int cmp,
	ccxl_register sreg, ccxl_register treg)
{
	int csreg, ctreg, cdreg;
	s32 imm;
	int nm1, nm2, cmp1;
	int i;
	
	switch(cmp)
	{
	case CCXL_CMP_EQ:
		nm1=BGBCC_SH_NMID_CMPEQ;
		nm2=BGBCC_SH_NMID_BT;
		break;
	case CCXL_CMP_NE:
		nm1=BGBCC_SH_NMID_CMPEQ;
		nm2=BGBCC_SH_NMID_BF;
		break;
	case CCXL_CMP_LT:
		nm1=BGBCC_SH_NMID_CMPGE;
		nm2=BGBCC_SH_NMID_BF;
		break;
	case CCXL_CMP_GT:
		nm1=BGBCC_SH_NMID_CMPGT;
		nm2=BGBCC_SH_NMID_BT;
		break;
	case CCXL_CMP_LE:
		nm1=BGBCC_SH_NMID_CMPGT;
		nm2=BGBCC_SH_NMID_BF;
		break;
	case CCXL_CMP_GE:
		nm1=BGBCC_SH_NMID_CMPGE;
		nm2=BGBCC_SH_NMID_BT;
		break;
	default:
		nm1=-1;
		nm2=-1;
		break;
	}
	
	if((nm1>=0) && (nm2>=0))
	{
		csreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);
		ctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);
		cdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);

		BGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);

		BGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);
		BGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);
		
		if(nm2==BGBCC_SH_NMID_BF)
		{
			BGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);
			BGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);
		}
		
//		BGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);

		BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);
		BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);
		BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);
		return(1);
	}

	BGBCC_CCXL_StubError(ctx);
	return(0);
}
```


Overlapping Code:
```
VRegVRegVRegQLong(
BGBCC_TransState *ctx,
BGBCC_SHX_Context *sctx,
ccxl_type type, ccxl_register dreg, int cmp,
ccxl_register sreg, ccxl_register treg)
{
int csreg, ctreg, cdreg;
s32 imm;
int nm1, nm2, cmp1;
int i;

switch(cmp)
{
case CCXL_CMP_EQ:
nm1=BGBCC_SH_NMID_CMPEQ;
nm2=BGBCC_SH_NMID_BT;
break;
case CCXL_CMP_NE:
nm1=BGBCC_SH_NMID_CMPEQ;
nm2=BGBCC_SH_NMID_BF;
break;
case CCXL_CMP_LT:
nm1=BGBCC_SH_NMID_CMPGE;
nm2=BGBCC_SH_NMID_BF;
break;
case CCXL_CMP_GT:
nm1=BGBCC_SH_NMID_CMPGT;
nm2=BGBCC_SH_NMID_BT;
break;
case CCXL_CMP_LE:
nm1=BGBCC_SH_NMID_CMPGT;
nm2=BGBCC_SH_NMID_BF;
break;
case CCXL_CMP_GE:
nm1=BGBCC_SH_NMID_CMPGE;
nm2=BGBCC_SH_NMID_BT;
break;
default:
nm1=-1;
nm2=-1;
break;
}

if((nm1>=0) && (nm2>=0))
{
csreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, sreg);
ctreg=BGBCC_SHXC_EmitGetRegisterRead(ctx, sctx, treg);
cdreg=BGBCC_SHXC_EmitGetRegisterWrite(ctx, sctx, dreg);
BGBCC_SHXC_CheckSetModeDqSet(ctx, sctx);
BGBCC_SHXC_EmitOpRegReg(ctx, sctx, nm1, ctreg, csreg);
BGBCC_SHXC_EmitOpReg(ctx, sctx, BGBCC_SH_NMID_MOVT, cdreg);

if(nm2==BGBCC_SH_NMID_BF)
{
BGBCC_SHXC_EmitOpRegReg(ctx, sctx, BGBCC_SH_NMID_NEG, cdreg, cdreg);
BGBCC_SHXC_EmitOpRegImm(ctx, sctx, BGBCC_SH_NMID_ADD, cdreg, 1);
}

// BGBCC_SHX_EmitOpLabel(sctx, nm2, lbl);
BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, sreg);
BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, treg);
BGBCC_SHXC_EmitReleaseRegister(ctx, sctx, dreg);
return(1);
}
BGBCC_CCXL_StubError(ctx);
return(0);
}
```
<Overlap Ratio: 0.982420554428668>

---

--- 352 --
Question ID: 9ea019461b76d247624a20142ae092ef7e100b28_16
Original Code:
```
char *RKLastTwoPartsOfPath(const char *path) {
    char *a0 = strchr((char *)path, '/');
    char *a1 = strchr(a0 + 1, '/');
    char *a2 = strchr(a1 + 1, '/');
    if (a0 == NULL) {
        return a0;
    } else if (a1 != NULL) {
        if (a2 == NULL) {
            return a1;
        } else if (a2 != NULL) {
            do {
                a0 = a1;
                a1 = a2;
                a2 = strchr(a2 + 1, '/');
            } while (a2 != NULL);
        }
    }
    return a0 + 1;
}
```


Overlapping Code:
```
sOfPath(const char *path) {
char *a0 = strchr((char *)path, '/');
char *a1 = strchr(a0 + 1, '/');
char *a2 = strchr(a1 + 1, '/');
if (a0 == NULL) {
return a0;
} else if (a1 != NULL) {
if (a2 == NULL) {
return a1;
} else if (a2 != NULL) {
do {
a0 = a1;
a1 = a2;
a2 = strchr(a2 + 1, '/');
} while (a2 !
```
<Overlap Ratio: 0.8620689655172413>

---

--- 353 --
Question ID: 75ad89e0870041af48629ba90d9e4baf8ef9a5b0_0
Original Code:
```
static void ae_test_read(ae_mux_t *self,
                         const struct epoll_event *event,
                         void *ctx)
{
     uint64_t overflows = 0;
     ae_res_t e;
     ae_res_init(&e);
     if(!ae_timer_read(&e, ctx, &overflows))
     {
          AE_LR(&e);
          return;
     }
     
     AE_LD("sup: %"PRIu64"", overflows);
}
```


Overlapping Code:
```
static void ae_test_read(ae_mux_t *self,
const struct epoll_event *event,
void *ctx)
{
uint64_t overflows = 0;
ae_res_t e;
ae_res_init(&e);
if(!ae_timer_read(&e, ctx, &overflows))
{
AE_LR(&e);
return;
```
<Overlap Ratio: 0.8298755186721992>

---

--- 354 --
Question ID: bf3a19ae1a02de45b0131a47263a258d24d439de_0
Original Code:
```
static int
ScanKey(
    const char *s1,
    const char *s2,
    const char *e1,
    const char *e2,
    const char **res1,
    const char **res2)
{
    *res1 = s1;
    *res2 = s2;
    /* Scan word chars until : or $ ends the keyword.
       They must be equal up to that point. */
    while (s1 < e1 && s2 < e2) {
	if ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {
	    /* The keyword part has ended on both sides */

	    /* To be a bit conservative and not confuse keywords with e.g.
	       Tcl namespace variables we only acknowledge these forms:
	       keyword$
	       keyword:$
	       keyword: .*$
	       keyword:: .*$
	    */
	    if (*s1 == ':') {
		s1++;
		if (s1 + 1 >= e1) {
		    return 1;
		}
		/* May be a double colon */
		if (*s1 == ':') {
		    s1++;
		}
		/* Colon must be followed by space or $ */
		if (*s1 != ' ' && *s1 != '$') {
		    return 1;
		}
	    }
	    if (*s2 == ':') {
		s2++;
		if (s2 + 1 >= e2) {
		    return 1;
		}
		if (*s2 == ':') {
		    s2++;
		}
		if (*s2 != ' ' && *s2 != '$') {
		    return 1;
		}
	    }
	    break;
	}
	if (*s1 != *s2) {
	    /* They are not equal keywords */
	    return 0;
	}
	/* Only standard ascii word chars count */
	if ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {
	    s1++;
	    s2++;
	} else {
	    /* This did not count as a keyword but is sofar equal. */
	    *res1 = s1;
	    *res2 = s2;
	    return 1;
	}
    }
    /* Skip all until $ */
    while (s1 < e1) {
	if (*s1 == '$') {
	    break;
	}
	s1++;
    }
    while (s2 < e2) {
	if (*s2 == '$') {
	    break;
	}
	s2++;
    }
    /* At this point s1/2 should point to the dollar ending the keyword. */
    if (s1 == e1 || s2 == e2) {
	/* We reached the end of string without finishing the keyword.
	   If a potential keyword is at the end we don't care. */
	return 1;
    }
    /* Strings are equal up to this point. Skip the last dollar as well. */
    *res1 = s1 + 1;
    *res2 = s2 + 1;
    return 1;
}
```


Overlapping Code:
```
ar *s2,
const char *e1,
const char *e2,
const char **res1,
const char **res2)
{
*res1 = s1;
*res2 = s2;
/* Scan word chars until : or $ ends the keyword.
They must be equal up to that point. */
while (s1 < e1 && s2 < e2) {
if ((*s1 == ':' || *s1 == '$') && (*s2 == ':' || *s2 == '$')) {
/* The keyword part has ended on both sides */
/* To be a bit conservative and not confuse keywords with e.g.
Tcl namespace variables we only acknowledge these forms:
keyword$
keyword:$
keyword: .*$
keyword:: .*$
*/
if (*s1 == ':') {
s1++;
if (s1 + 1 >= e1) {
return 1;
}
/* May be a double colon */
if (*s1 == ':') {
s1++;
}
/* Colon must be followed by space or $ */
if (*s1 != ' ' && *s1 != '$') {
return 1;
}
}
if (*s2 == ':') {
s2++;
if (s2 + 1 >= e2) {
return 1;
}
if (*s2 == ':') {
s2++;
}
if (*s2 != ' ' && *s2 != '$') {
return 1;
}
}
break;
}
if (*s1 != *s2) {
/* They are not equal keywords */
return 0;
}
/* Only standard ascii word chars count */
if ((*s1 >= 'a' && *s1 <= 'z') || (*s1 >= 'A' && *s1 <= 'Z')) {
s1++;
s2++;
} else {
/* This did not count as a keyword but is sofar equal. */
*res1 = s1;
*res2 = s2;
return 1;
}
}
/* Skip all until $ */
while (s1 < e1) {
if (*s1 == '$') {
break;
}
s1++;
}
while (s2 < e2) {
if (*s2 == '$') {
break;
}
s2++;
}
/* At this point s1/2 should point to the dollar ending the keyword. */
if (s1 == e1 || s2 == e2) {
/* We reached the end of string without finishing the keyword.
If a potential keyword is at the end we don't care. */
return 1;
}
/* Strings are equal up to this point. Skip the last dollar as well. */
*res1 = s1 + 1;
*res2 = s2 + 1;
return 1;

```
<Overlap Ratio: 0.9726443768996961>

---

--- 355 --
Question ID: 6c3e3e9185d253fad28e77c74fe76ba930085b8b_25
Original Code:
```
static u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)
{
	u8 regval;
   	 ft5x0x_write_reg(0x00, 0x00); //return to normal mode 
   	 msleep(100);
	
	if(ft5x0x_read_reg(0x00, &regval)<0)
		pr_err("%s ERROR: could not read register\n", __FUNCTION__);
	else
	{
		if((regval & 0x70) != 0x00)
		{
			pr_err("%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\n", __FUNCTION__, regval);
			enable_irq(IRQ_EINT(6));
			return -1;
		}
	}
	enable_irq(IRQ_EINT(6));
	return 0;
}
```


Overlapping Code:
```
ic u8 ft5x0x_enter_work(struct ft5x0x_ts_data *ft5x0x_ts)
{
u8 regval;
ft5x0x_write_reg(0x00, 0x00); //return to normal mode 
msleep(100);

if(ft5x0x_read_reg(0x00, &regval)<0)
pr_err("%s ERROR: could not read register\n", __FUNCTION__);
else
{
if((regval & 0x70) != 0x00)
{
pr_err("%s() - ERROR: The Touch Panel was not put in Work Mode. The Device Mode register contains 0x%02X\n", __FUNCTION__, regval);
enable_irq(IRQ_EINT(6));
return -1
```
<Overlap Ratio: 0.9055441478439425>

---

--- 356 --
Question ID: 1e3a6cfbd50359eab00b8b6c94ab00942d85e644_0
Original Code:
```
class input {
public:
	input(std::string, std::string, std::string, bool);
	~input() {};
	hcube* makeHostCube(long, bool);
	std::vector<long> dim;
	std::valarray<double> data;
	std::string in_fits_filename, in_params_filename, in_config_filename;
	xml_document<> config;
	xml_document<> params;
	std::vector<int> wavelengths;
	std::map<std::string, std::string> config_host;			// dictionary containing all config items related to the host.
	std::map<std::string, std::string> config_device;		// dictionary containing all config items related to the device.
	std::list<process_stages> stages;
	std::map<process_stages, std::map<std::string, std::string>> stage_parameters;
private:
	void readXMLFile(xml_document<>&, string, bool);
	void readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);
	void processConfigFile(string, bool);
	void processSimulationParametersFile(string, bool);
	void processFITSFile(string, bool);
}
```


Overlapping Code:
```
ublic:
input(std::string, std::string, std::string, bool);
~input() {};
hcube* makeHostCube(long, bool);
std::vector<long> dim;
std::valarray<double> data;
std::string in_fits_filename, in_params_filename, in_config_filename;
xml_document<> config;
xml_document<> params;
std::vector<int> wavelengths;
std::map<std::string, std::string> config_host; // dictionary containing all config items related to the host.
std::map<std::string, std::string> config_device; // dictionary containing all config items related to the device.
std::list<process_stages> stages;
std::map<process_stages, std::map<std::string, std::string>> stage_parameters;
private:
void readXMLFile(xml_document<>&, string, bool);
void readFITSFile(std::valarray<double>&, std::vector<long>&, string, bool);
void processConfigFile(string, bool);
void processSimulationParametersFile(string, bool);
void processFITSFile(string, bool)
```
<Overlap Ratio: 0.9803921568627451>

---

--- 357 --
Question ID: ec9a327c7e46d6d141f24f194b60533824ec5a4f_83
Original Code:
```
static int
restart_world (void)
{
	int count, i;
	SgenThreadInfo *info;
	TV_DECLARE (end_sw);
	unsigned long usec;

	for (i = 0; i < THREAD_HASH_SIZE; ++i) {
		for (info = thread_table [i]; info; info = info->next) {
			info->stack_start = NULL;
			info->stopped_regs = NULL;
		}
	}

	count = thread_handshake (restart_signal_num);
	TV_GETTIME (end_sw);
	usec = TV_ELAPSED (stop_world_time, end_sw);
	max_pause_usec = MAX (usec, max_pause_usec);
	DEBUG (2, fprintf (gc_debug_file, "restarted %d thread(s) (pause time: %d usec, max: %d)\n", count, (int)usec, (int)max_pause_usec));
	return count;
}
```


Overlapping Code:
```
genThreadInfo *info;
TV_DECLARE (end_sw);
unsigned long usec;
for (i = 0; i < THREAD_HASH_SIZE; ++i) {
for (info = thread_table [i]; info; info = info->next) {
info->stack_start = NULL;
info->stopped_regs = NULL;
}
}
count = thread_handshake (restart_signal_num);
TV_GETTIME (end_sw);
usec = TV_ELAPSED (stop_world_time, end_sw);
max_pause_usec = MAX (usec, max_pause_usec);
DEBUG (2, fprintf (gc_debug_file, "restarted %d thread(s) (pause time: %d usec, max: %d)\n", count, (int)usec, (int)max_pause
```
<Overlap Ratio: 0.8726003490401396>

---

--- 358 --
Question ID: efdfd1b6782a78bcdf0006425c0e40f83dfa5a71_0
Original Code:
```
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  /*****************************************************************************
  ** this function takes a flag and a variable number of arguments
  ** depending on the value of the flag and returns either a construct 
  ** containing probability estimates, a merged vector or a double value 
  ** representing an entropy or mutual information
  *****************************************************************************/
  
  int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;
  int vectorMismatch, columnMismatch, weightLength, weightWidth;
  double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;
  double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;
  double *numStates, *numJointStates, *numFirstStates, *numSecondStates;
  WeightedProbState state;
  WeightedJointProbState jointState;
  int i;

  switch (nrhs)
  {
    case 3:
    {
        /*printf("Must be H_w(X)\n");*/
        break;
    }
    case 4:
    {
        /*printf("Must be H_w(XY), H_w(X|Y), I_w(X;Y)\n");*/
        break;
    }
    case 5:
    {
        /*printf("Must be I_w(X;Y|Z)\n");*/
        break;
    }
    default:
    {
        printf("Incorrect number of arguments, format is WeightedMIToolbox(\"FLAG\",varargin)\n");
        break;
    }
  }
  
  vectorMismatch = 0;
  columnMismatch = 0;

  /* number to function map
  ** 1 = H(X)
  ** 2 = H(XY)
  ** 3 = H(X|Y)
  ** 4 = I(X;Y)
  ** 5 = I(X;Y|Z)
  ** 6 = calculateWeightedProbability
  ** 7 = calculateWeightedJointProbability
  */
  
  flag = *mxGetPr(prhs[0]);
  weightLength = mxGetM(prhs[1]);
  weightWidth = mxGetN(prhs[1]);
  weightVector = (double *) mxGetPr(prhs[1]);
  
  switch (flag)
  {
    case 1:
    {
      /*
      **H(X)
      */
      numberOfSamples = mxGetM(prhs[2]);
      numberOfFeatures = mxGetN(prhs[2]);
      dataVector = (double *) mxGetPr(prhs[2]);

      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);

      if ((numberOfFeatures == 1) && (weightWidth == 1))
      {
        if (numberOfSamples == weightLength)
        {
          /*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/
          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);
        }
        else
        {
          vectorMismatch = 1;
        }
      }
      else
      {
        columnMismatch = 1;
      }
      
      break;
    }/*case 1 - H(X)*/
    case 2:
    {
      /*
      **H(XY)
      */
      numberOfSamples = mxGetM(prhs[2]);
      checkSamples = mxGetM(prhs[3]);
      
      numberOfFeatures = mxGetN(prhs[2]);
      checkFeatures = mxGetN(prhs[3]);

      firstVector = mxGetPr(prhs[2]);
      secondVector = mxGetPr(prhs[3]);

      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);

      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))
      {
        if ((numberOfSamples == 0) && (checkSamples == 0) && (weightLength == 0))
        {
          *output = 0.0;
        }
        else if ((numberOfSamples == 0) && (weightLength == checkSamples))
        {
          *output = calculateWeightedEntropy(secondVector,weightVector,numberOfSamples);
        }
        else if ((checkSamples == 0) && (weightLength == numberOfSamples))
        {
          *output = calculateWeightedEntropy(firstVector,weightVector,numberOfSamples);
        }
        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))
        {
          /*double calculateWeightedJointEntropy(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/
          *output = calculateWeightedJointEntropy(firstVector,secondVector,weightVector,numberOfSamples);
        }
        else
        {
          vectorMismatch = 1;
        }
      }
      else
      {
        columnMismatch = 1;
      }
      
      break;
    }/*case 2 - H(XY)*/
    case 3:
    {
      /*
      **H(X|Y)
      */
      numberOfSamples = mxGetM(prhs[2]);
      checkSamples = mxGetM(prhs[3]);
      
      numberOfFeatures = mxGetN(prhs[2]);
      checkFeatures = mxGetN(prhs[3]);

      dataVector = mxGetPr(prhs[2]);
      condVector = mxGetPr(prhs[3]);

      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);

      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))
      {
        if (numberOfSamples == 0)
        {
          *output = 0.0;
        }
        else if ((checkSamples == 0) && (weightLength == numberOfSamples))
        {
          *output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamples);
        }
        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))
        {
          /*double calculateWeightedConditionalEntropy(double *dataVector, double *condVector, double *weightVector, int vectorLength);*/
          *output = calculateWeightedConditionalEntropy(dataVector,condVector,weightVector,numberOfSamples);
        }
        else
        {
          vectorMismatch = 1;
        }
      }
      else
      {
        columnMismatch = 1;
      }
      break;
    }/*case 3 - H(X|Y)*/
    case 4:
    {
      /*
      **I(X;Y)
      */
      numberOfSamples = mxGetM(prhs[2]);
      checkSamples = mxGetM(prhs[3]);
      
      numberOfFeatures = mxGetN(prhs[2]);
      checkFeatures = mxGetN(prhs[3]);

      firstVector = mxGetPr(prhs[2]);
      secondVector = mxGetPr(prhs[3]);

      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);

      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))
      {
        if ((numberOfSamples == 0) || (checkSamples == 0))
        {
          *output = 0.0;
        }
        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))
        {
          /*double calculateWeightedMutualInformation(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/
          *output = calculateWeightedMutualInformation(firstVector,secondVector,weightVector,numberOfSamples);
        }
        else
        {
          vectorMismatch = 1;
        }
      }
      else
      {
        columnMismatch = 1;
      }
      break;
    }/*case 4 - I(X;Y)*/
    case 5:
    {
      /*
      **I(X;Y|Z)
      */
      numberOfSamples = mxGetM(prhs[2]);
      checkSamples = mxGetM(prhs[3]);
      thirdCheckSamples = mxGetM(prhs[4]);
      
      numberOfFeatures = mxGetN(prhs[2]);
      checkFeatures = mxGetN(prhs[3]);
      thirdCheckFeatures = mxGetN(prhs[4]);

      firstVector = mxGetPr(prhs[2]);
      targetVector = mxGetPr(prhs[3]);
      condVector = mxGetPr(prhs[4]);

      plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);
      
      if ((numberOfFeatures == 1) && (checkFeatures == 1) && (weightWidth == 1))
      {
        if ((numberOfSamples == 0) || (checkSamples == 0))
        {
          *output = 0.0;
        }
        else if ((numberOfSamples == checkSamples) && (numberOfSamples == weightLength))
        {
          if ((thirdCheckSamples == 0) || (thirdCheckFeatures != 1))
          {
            *output = calculateWeightedMutualInformation(firstVector,targetVector,weightVector,numberOfSamples);
          }
          else if (numberOfSamples == thirdCheckSamples)
          {
            /*double calculateWeightedConditionalMutualInformation(double *firstVector, double *targetVector, double *condVector, double *weightVector, int vectorLength);*/
            *output = calculateWeightedConditionalMutualInformation(firstVector,targetVector,condVector,weightVector,numberOfSamples);
          }
          else
          {
            vectorMismatch = 1;
          }
        }
        else
        {
          vectorMismatch = 1;
        }
      }
      else
      {
        columnMismatch = 1;
      }
      break;
    }/*case 5 - I(X;Y|Z)*/
    case 6:
    {
      /*
      **calculateWeightedProbability
      */
      numberOfSamples = mxGetM(prhs[2]);
      dataVector = (double *) mxGetPr(prhs[2]);

      /*WeightedProbabilityState calculateWeightedProbability(double *dataVector, double *weightVector, int vectorLength);*/
      state = calculateWeightedProbability(dataVector,weightVector,numberOfSamples);
      
      plhs[0] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);
      plhs[1] = mxCreateDoubleMatrix(state.numStates,1,mxREAL);
      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);
      output = (double *)mxGetPr(plhs[0]);
      weightOutput = (double *)mxGetPr(plhs[1]);
      numStates = (double *) mxGetPr(plhs[2]);
      
      *numStates = state.numStates;
      
      for (i = 0; i < state.numStates; i++)
      {
        output[i] = state.probabilityVector[i];
        weightOutput[i] = state.stateWeightVector[i];
      }
      
      break;
    }/*case 6 - calculateWeightedProbability*/
    case 7:
    {
      /*
      **calculateWeightedJointProbability
      */
      numberOfSamples = mxGetM(prhs[2]);
      firstVector = (double *) mxGetPr(prhs[2]);
      secondVector = (double *) mxGetPr(prhs[3]);

      /*JointProbabilityState calculateJointProbability(double *firstVector, double *secondVector, double *weightVector, int vectorLength);*/
      jointState = calculateWeightedJointProbability(firstVector,secondVector,weightVector,numberOfSamples);
      
      plhs[0] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);
      plhs[1] = mxCreateDoubleMatrix(jointState.numJointStates,1,mxREAL);
      plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);
      plhs[3] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);
      plhs[4] = mxCreateDoubleMatrix(jointState.numFirstStates,1,mxREAL);
      plhs[5] = mxCreateDoubleMatrix(1,1,mxREAL);
      plhs[6] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);
      plhs[7] = mxCreateDoubleMatrix(jointState.numSecondStates,1,mxREAL);
      plhs[8] = mxCreateDoubleMatrix(1,1,mxREAL);

      jointOutput = (double *)mxGetPr(plhs[0]);
      jointWeight = (double *)mxGetPr(plhs[1]);
      numJointStates = (double *) mxGetPr(plhs[2]);
      firstOutput = (double *)mxGetPr(plhs[3]);
      firstWeight = (double *)mxGetPr(plhs[4]);
      numFirstStates = (double *) mxGetPr(plhs[5]);
      secondOutput = (double *)mxGetPr(plhs[6]);
      secondWeight = (double *)mxGetPr(plhs[7]);
      numSecondStates = (double *) mxGetPr(plhs[8]);
      
      *numJointStates = jointState.numJointStates;
      *numFirstStates = jointState.numFirstStates;
      *numSecondStates = jointState.numSecondStates;
      
      for (i = 0; i < jointState.numJointStates; i++)
      {
        jointOutput[i] = jointState.jointProbabilityVector[i];
        jointWeight[i] = jointState.jointWeightVector[i];
      }
      for (i = 0; i < jointState.numFirstStates; i++)
      {
        firstOutput[i] = jointState.firstProbabilityVector[i];
        firstWeight[i] = jointState.firstWeightVector[i];
      }
      for (i = 0; i < jointState.numSecondStates; i++)
      {
        secondOutput[i] = jointState.secondProbabilityVector[i];
        secondWeight[i] = jointState.secondWeightVector[i];
      }
      
      break;
    }/*case 7 - calculateWeightedJointProbability */
    default:
    {
      printf("Unrecognised flag\n");
      break;
    }/*default*/
  }/*switch(flag)*/
 
  if (columnMismatch)
  {
    printf("No columns in one or more inputs\n");
    *output = -1.0;
  }
  else if (vectorMismatch)
  {
    printf("Vector lengths do not match, they must all be the same length\n");
    *output = -1.0;
  }

  return;
}
```


Overlapping Code:
```
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
/*****************************************************************************
** this function takes a flag and a variable number of arguments
** depending on the value of the flag and returns either a construct 
** containing probability estimates, a merged vector or a double value 
** representing an entropy or mutual information
*****************************************************************************/

int flag, numberOfSamples, checkSamples, thirdCheckSamples, numberOfFeatures, checkFeatures, thirdCheckFeatures;
int vectorMismatch, columnMismatch, weightLength, weightWidth;
double *dataVector, *condVector, *targetVector, *firstVector, *secondVector, *output, *weightVector;
double *weightOutput, *jointWeight, *firstWeight, *secondWeight, *jointOutput, *firstOutput, *secondOutput;
double *numStates, *numJointStates, *numFirstStates, *numSecondStates;
WeightedProbState state;
WeightedJointProbState jointState;
int i;
switch (nrhs)
{
case 3:
{
/*printf("Must be H_w(X)\n");*/
break;
}
case 4:
{
/*printf("Must be H_w(XY), H_w(X|Y), I_w(X;Y)\n");*/
break;
}
case 5:
{
/*printf("Must be I_w(X;Y|Z)\n");*/
break;
}
default:
{
printf("Incorrect number of arguments, format is WeightedMIToolbox(\"FLAG\",varargin)\n");
break;
}
}

vectorMismatch = 0;
columnMismatch = 0;
/* number to function map
** 1 = H(X)
** 2 = H(XY)
** 3 = H(X|Y)
** 4 = I(X;Y)
** 5 = I(X;Y|Z)
** 6 = calculateWeightedProbability
** 7 = calculateWeightedJointProbability
*/

flag = *mxGetPr(prhs[0]);
weightLength = mxGetM(prhs[1]);
weightWidth = mxGetN(prhs[1]);
weightVector = (double *) mxGetPr(prhs[1]);

switch (flag)
{
case 1:
{
/*
**H(X)
*/
numberOfSamples = mxGetM(prhs[2]);
numberOfFeatures = mxGetN(prhs[2]);
dataVector = (double *) mxGetPr(prhs[2]);
plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
output = (double *)mxGetPr(plhs[0]);
if ((numberOfFeatures == 1) && (weightWidth == 1))
{
if (numberOfSamples == weightLength)
{
/*double calculateWeightedEntropy(double *dataVector, double *weightVector, int vectorLength);*/
*output = calculateWeightedEntropy(dataVector,weightVector,numberOfSamp
```
<Overlap Ratio: 0.9944954128440368>

---

--- 359 --
Question ID: d4e46a36351257641c3bc85db38f2fbdf6396eef_14
Original Code:
```
static inline void ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_64(_dev->b, 0x0, _regval);
}
```


Overlapping Code:
```
ahci_port_clb_wr(__DN(t) *_dev, uint64_t _regval)
{
// No MB0 or RSVD fields present
// No MB1 fields present
// No pre-read of register required
mackerel_write_addr_64(_de
```
<Overlap Ratio: 0.8075117370892019>

---

--- 360 --
Question ID: 8f5450d7db4523c033f5a329ad5ae1fd59048c7d_32
Original Code:
```
static char *
GetMapIntString(struct Mapper mapper[], int state)
{
    struct Mapper *m;    
    for (m = mapper; m->s != NULL; m++) {
        if (m->i == state) {
            return m->s;
        }
    }
    return NULL;
}
```


Overlapping Code:
```
ng(struct Mapper mapper[], int state)
{
struct Mapper *m; 
for (m = mapper; m->s != NULL; m++) {
if (m->i == sta
```
<Overlap Ratio: 0.6363636363636364>

---

--- 361 --
Question ID: 39661e8cbdda950f95dc5083bb4b7b6c042e193f_12
Original Code:
```
TEST test_raster_null_raster()
{
    unsigned char buffer[1];
    ASSERT_EAARLIO_ERR(
        EAARLIO_NULL, eaarlio_tld_unpack_raster(
                          (unsigned char *)&buffer, 1, NULL, NULL, 0, 0));
    PASS();
}
```


Overlapping Code:
```
ull_raster()
{
unsigned char buffer[1];
ASSERT_EAARLIO_ERR(
EAARLIO_NULL, eaarlio_tld_unpack_raster(
(unsigned char *)&buffer, 1, NULL, NULL, 0, 0));

```
<Overlap Ratio: 0.847457627118644>

---

--- 362 --
Question ID: 1a6759498398ede8e1fe2e773c0d7c1f0aa3adf4_7
Original Code:
```
typedcode_t node_lplusplus_read(node_t*n)
{
    READ_HEADER_ONE;
    t = x.t;
    if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {
        int nr = getlocalnr(x.c);
        code_free(x.c);x.c=0;
        if(TYPE_IS_INT(x.t)) {
           c = abc_inclocal_i(c, nr);
           c = abc_getlocal(c, nr);
        } else if(TYPE_IS_NUMBER(x.t)) {
           c = abc_inclocal(c, nr);
           c = abc_getlocal(c, nr);
        } else syntaxerror("internal error");
    } else {
        if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {
            c = abc_increment_i(c);
            t = TYPE_INT;
        } else {
            c = abc_increment(c);
            t = TYPE_NUMBER;
        }
        c = converttype(c, t, x.t);
        c = toreadwrite(x.c, c, 0, 0, 1);
        t = x.t;
    }
    RET
}
```


Overlapping Code:
```
HEADER_ONE;
t = x.t;
if(is_getlocal(x.c) && (TYPE_IS_INT(x.t) || TYPE_IS_NUMBER(x.t))) {
int nr = getlocalnr(x.c);
code_free(x.c);x.c=0;
if(TYPE_IS_INT(x.t)) {
c = abc_inclocal_i(c, nr);
c = abc_getlocal(c, nr);
} else if(TYPE_IS_NUMBER(x.t)) {
c = abc_inclocal(c, nr);
c = abc_getlocal(c, nr);
} else syntaxerror("internal error");
} else {
if(TYPE_IS_INT(x.t) || TYPE_IS_UINT(x.t)) {
c = abc_increment_i(c);
t = TYPE_INT;
} else {
c = abc_increment(c);
t = TYPE_NUMBER;
}
c = converttype(c, t, x.t);
c = toreadwrite(x.c, c, 0, 0, 1);
t = x.t;
}
RET
```
<Overlap Ratio: 0.9151414309484193>

---

--- 363 --
Question ID: 1110d60c11bb50f9c97fb124dc8c7ca92dee5a9a_3
Original Code:
```
void methodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){
      iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();
      method_node -> set_id(mNode -> get_id() );
      method_node -> set_name(mNode -> get_name() );
      proto ->add_methodcallnames(mNode -> get_name() );
      // Iterate through the arguments and add types/id
      const std::vector<DataNode*> & args = mNode -> get_arguments();
      for (const DataNode * dd : args){
        method_node -> add_argumenttypes( dd -> get_data_type()  );
        method_node -> add_argumentids( dd -> get_id());
        //cout << dd -> get_id() << endl;
        extraDataNodes.insert( dd-> get_id());
        assert(dd -> get_type() == DATA_NODE);
      }
      // Add invokee/receiver types
      const DataNode* rcv = mNode -> get_receiver();
      if (rcv != NULL){
        std::cerr << "Debug: invokee type = "<< rcv -> get_name() << endl;
        method_node -> set_invokeetype(rcv -> get_data_type());
        method_node -> set_invokeeid (rcv -> get_id());
        extraDataNodes.insert( rcv -> get_id());
        //cout << rcv -> get_id() << endl;
        assert(rcv -> get_type() == DATA_NODE);
      } else {
        // std::cerr << "Debug: invokee type cleared"<< endl;
        method_node -> clear_invokeetype();
        method_node -> clear_invokeeid();
      }
      // Add assignee types
      const DataNode * assg = mNode -> get_assignee();
      if (assg != NULL){
        method_node -> set_assigneetype(assg -> get_data_type());
        method_node -> set_assigneeid(assg -> get_id());
        extraDataNodes.insert(assg-> get_id());
        //cout << assg -> get_id() <<endl;
        assert(assg -> get_type() == DATA_NODE);
      } else {
        method_node -> clear_assigneetype();
        method_node -> clear_assigneeid();
      }
      // Done!
    }
```


Overlapping Code:
```
hodNodeToProtobuf( MethodNode * mNode, iso_protobuf::Iso* proto, std::set<long> & extraDataNodes){
iso_protobuf::Iso_MethodNode * method_node = proto -> add_method_nodes();
method_node -> set_id(mNode -> get_id() );
method_node -> set_name(mNode -> get_name() );
proto ->add_methodcallnames(mNode -> get_name() );
// Iterate through the arguments and add types/id
const std::vector<DataNode*> & args = mNode -> get_arguments();
for (const DataNode * dd : args){
method_node -> add_argumenttypes( dd -> get_data_type() );
method_node -> add_argumentids( dd -> get_id());
//cout << dd -> get_id() << endl;
extraDataNodes.insert( dd-> get_id());
assert(dd -> get_type() == DATA_NODE);
}
// Add invokee/receiver types
const DataNode* rcv = mNode -> get_receiver();
if (rcv != NULL){
std::cerr << "Debug: invokee type = "<< rcv -> get_name() << endl;
method_node -> set_invokeetype(rcv -> get_data_type());
method_node -> set_invokeeid (rcv -> get_id());
extraDataNodes.insert( rcv -> get_id());
//cout << rcv -> get_id() << endl;
assert(rcv -> get_type() == DATA_NODE);
} else {
// std::cerr << "Debug: invokee type cleared"<< endl;
method_node -> clear_invokeetype();
method_node -> clear_invokeeid();
}
// Add assignee types
const DataNode * assg = mNode -> get_assignee();
if (assg != NULL){
method_node -> set_assigneetype(assg -> get_data_type());
method_node -> set_assigneeid(assg -> get_id());
extraDataNodes.insert(assg-> get_id());
//cout << assg -> get_id() <<endl;
assert(assg -> get_type() == DATA_NODE);
} else {
method_node -> clear_assigneetype();
method_node -> clear_assigneeid();
}
// 
```
<Overlap Ratio: 0.9907120743034056>

---

--- 364 --
Question ID: 9dcf074d205f653f0d2599cbb9c7ba23f2130cdc_1
Original Code:
```
int main(int argc, char const *argv[]) {

  if (argv[1] == 0) {
    printf("Insira o nome de um arquivo.\n");
    return -1;
  }

  FILE * fPointer;
  FILE * fWrite;

  char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));

  int i = 0;
  for(i = 0; i < strlen(argv[1]); i++) {
    file_name[i] = argv[1][i];
  }

  fPointer = fopen(file_name, "r");

  int file_size = fsize(file_name);
  char ch;

  int x = 0,
      new_file = 0,
      file_number = 0;

  while(1) {
    ch = fgetc(fPointer);

    if(ch == '/'){
      if(fgetc(fPointer) == '*') {
        file_number++;

        if(file_number < 9) {
          sprintf(file_name, "0%d.c", file_number);
        } else {
          sprintf(file_name, "%d.c", file_number);
        }

        while(1) {
          fWrite = fopen(file_name, "a");
          ch = fgetc(fPointer);
          fprintf(fWrite, "%c", ch);
          printf("%c\n", ch);
          if(ch == '*'){
            if(fgetc(fPointer) == '/') {
              break;
            }
          }

        }
      }
    }


    if(feof(fPointer)) {
      break;
    }
    x++;
  }

  fclose(fPointer);

  return 0;
}
```


Overlapping Code:
```
 (argv[1] == 0) {
printf("Insira o nome de um arquivo.\n");
return -1;
}
FILE * fPointer;
FILE * fWrite;
char *file_name = (char *) malloc(strlen(argv[1]) * sizeof(char));
int i = 0;
for(i = 0; i < strlen(argv[1]); i++) {
file_name[i] = argv[1][i];
}
fPointer = fopen(file_name, "r");
int file_size = fsize(file_name);
char ch;
int x = 0,
new_file = 0,
file_number = 0;
while(1) {
ch = fgetc(fPointer);
if(ch == '/'){
if(fgetc(fPointer) == '*') {
file_number++;
if(file_number < 9) {
sprintf(file_name, "0%d.c", file_number);
} else {
sprintf(file_name, "%d.c", file_number);
}
while(1) {
fWrite = fopen(file_name, "a");
ch = fgetc(fPointer);
fprintf(fWrite, "%c", ch);
printf("%c\n", ch);
if(ch == '*'){
if(fgetc(fPointer) == '/') {
break;
}
}
}
}
}
if(feof(fPointer)) {
break;
}
x++;
}
fclose(fPointer);

```
<Overlap Ratio: 0.9372093023255814>

---

--- 365 --
Question ID: 087acf4d89284af5607acd0152ce721584243ba5_5
Original Code:
```
int perl_eval(const char *code, char **result) {
  SV* ret_sv = eval_pv(code, FALSE);
  if (SvTRUE(ERRSV))
  {
    STRLEN len;
    char *errmsg = SvPV(ERRSV, len);
    *result = eperl_alloc(len+1);
    memcpy(*result, errmsg, len+1);
    return 0;
  } else if (result != NULL) {
    sv_to_json(ret_sv, result);
  }
  return 1;
}
```


Overlapping Code:
```
t) {
SV* ret_sv = eval_pv(code, FALSE);
if (SvTRUE(ERRSV))
{
STRLEN len;
char *errmsg = SvPV(ERRSV, len);
*result = eperl_alloc(len+1);
memcpy(*result, errmsg, len+1);
return 0;
} else if (result != N
```
<Overlap Ratio: 0.684931506849315>

---

--- 366 --
Question ID: a50d2b5f365996cf5d4f17090130ce9e27fe5e5a_12
Original Code:
```
static struct pipeline* pipelineNew(char ***cmds, unsigned options)
/* create a new pipeline object. Doesn't start processes */
{
static char *memPseudoCmd[] = {"[mem]", NULL};
struct pipeline *pl;
int iCmd;

AllocVar(pl);
pl->groupLeader = -1;
pl->pipeFd = -1;
pl->options = options;
pl->procName = joinCmds(cmds);

if (cmds[0] == NULL)
    errAbort("no commands in pipeline");

if (options & pipelineMemInput)
    {
    /* add proc for forked process to write memory to pipeline */
    slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));
    }

for(iCmd = 0; cmds[iCmd] != NULL; iCmd++)
    slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));

return pl;
}
```


Overlapping Code:
```
* pipelineNew(char ***cmds, unsigned options)
/* create a new pipeline object. Doesn't start processes */
{
static char *memPseudoCmd[] = {"[mem]", NULL};
struct pipeline *pl;
int iCmd;
AllocVar(pl);
pl->groupLeader = -1;
pl->pipeFd = -1;
pl->options = options;
pl->procName = joinCmds(cmds);
if (cmds[0] == NULL)
errAbort("no commands in pipeline");
if (options & pipelineMemInput)
{
/* add proc for forked process to write memory to pipeline */
slAddTail(&pl->procs, plProcNew(memPseudoCmd, pl));
}
for(iCmd = 0; cmds[iCmd] != NULL; iCmd++)
slAddTail(&pl->procs, plProcNew(cmds[iCmd], pl));
return 
```
<Overlap Ratio: 0.9569377990430622>

---

--- 367 --
Question ID: fecd166f4c24431102ac68587ad03086e10c5612_13
Original Code:
```
void nextThread() {
	if(currentProcess->process.currentThread->thread.status == RUNNING) {
		currentProcess->process.currentThread->thread.status = READY;
	}
	
	if(currentProcess->process.currentThread->next == NULL){
		
		currentProcess->process.currentThread = currentProcess->process.threads;
		
		if(currentProcess->process.currentThread->thread.status == READY){
			currentProcess->process.currentThread->thread.status = RUNNING;
			return;
		}
	}
		
	while(currentProcess->process.currentThread->next->thread.status != READY) {
		currentProcess->process.currentThread = currentProcess->process.currentThread->next;	
	}

	currentProcess->process.currentThread = currentProcess->process.currentThread->next;
	currentProcess->process.currentThread->thread.status = RUNNING;

}
```


Overlapping Code:
```
if(currentProcess->process.currentThread->thread.status == RUNNING) {
currentProcess->process.currentThread->thread.status = READY;
}

if(currentProcess->process.currentThread->next == NULL){

currentProcess->process.currentThread = currentProcess->process.threads;

if(currentProcess->process.currentThread->thread.status == READY){
currentProcess->process.currentThread->thread.status = RUNNING;
return;
}
}

while(currentProcess->process.currentThread->next->thread.status != READY) {
currentProcess->process.currentThread = currentProcess->process.currentThread->next; 
}
currentProcess->process.currentThread = currentProcess->process.currentThread->next;
currentProcess->process.currentThread->thread.status 
```
<Overlap Ratio: 0.9571045576407506>

---

--- 368 --
Question ID: a00ad98e9e5bd6a979ca38715790cae6b11c5532_4
Original Code:
```
int wav2adpcm(const char *infile, const char *outfile) {
	struct wavhdr_t wavhdr;
	FILE *in, *out;
	size_t pcmsize, adpcmsize;
	short *pcmbuf;
	unsigned char *adpcmbuf;

	in = fopen(infile, "rb");
	if (in == NULL) {
		printf("can't open %s\n", infile);
		return -1;
	}
	fread(&wavhdr, 1, sizeof(wavhdr), in);

	if (memcmp(wavhdr.hdr1, "RIFF", 4)
		|| memcmp(wavhdr.hdr2, "WAVEfmt ", 8)
		|| memcmp(wavhdr.hdr3, "data", 4)
		|| wavhdr.hdrsize != 0x10
		|| wavhdr.format != 1
		|| (wavhdr.channels != 1 && wavhdr.channels != 2)
		|| wavhdr.bits != 16) {
		printf("unsupport format\n");
		fclose(in);
		return -1;
	}

	pcmsize = wavhdr.datasize;

	adpcmsize = pcmsize / 4;
	pcmbuf = malloc(pcmsize);
	adpcmbuf = malloc(adpcmsize);

	fread(pcmbuf, 1, pcmsize, in);
	fclose(in);

	if (wavhdr.channels == 1) {
		pcm2adpcm(adpcmbuf, pcmbuf, pcmsize);
	}
	else {
		/* For stereo we just deinterleave the input and store the
		left and right channel of the ADPCM data separately. */
		deinterleave(pcmbuf, pcmsize);
		pcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);
		pcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);
	}

	out = fopen(outfile, "wb");
	wavhdr.datasize = adpcmsize;
	wavhdr.format = 20;	/* ITU G.723 ADPCM (Yamaha) */
	wavhdr.bits = 4;
	wavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;
	fwrite(&wavhdr, 1, sizeof(wavhdr), out);
	fwrite(adpcmbuf, 1, adpcmsize, out);
	fclose(out);

	return 0;
}
```


Overlapping Code:
```
pcm(const char *infile, const char *outfile) {
struct wavhdr_t wavhdr;
FILE *in, *out;
size_t pcmsize, adpcmsize;
short *pcmbuf;
unsigned char *adpcmbuf;
in = fopen(infile, "rb");
if (in == NULL) {
printf("can't open %s\n", infile);
return -1;
}
fread(&wavhdr, 1, sizeof(wavhdr), in);
if (memcmp(wavhdr.hdr1, "RIFF", 4)
|| memcmp(wavhdr.hdr2, "WAVEfmt ", 8)
|| memcmp(wavhdr.hdr3, "data", 4)
|| wavhdr.hdrsize != 0x10
|| wavhdr.format != 1
|| (wavhdr.channels != 1 && wavhdr.channels != 2)
|| wavhdr.bits != 16) {
printf("unsupport format\n");
fclose(in);
return -1;
}
pcmsize = wavhdr.datasize;
adpcmsize = pcmsize / 4;
pcmbuf = malloc(pcmsize);
adpcmbuf = malloc(adpcmsize);
fread(pcmbuf, 1, pcmsize, in);
fclose(in);
if (wavhdr.channels == 1) {
pcm2adpcm(adpcmbuf, pcmbuf, pcmsize);
}
else {
/* For stereo we just deinterleave the input and store the
left and right channel of the ADPCM data separately. */
deinterleave(pcmbuf, pcmsize);
pcm2adpcm(adpcmbuf, pcmbuf, pcmsize / 2);
pcm2adpcm(adpcmbuf + adpcmsize / 2, pcmbuf + pcmsize / 4, pcmsize / 2);
}
out = fopen(outfile, "wb");
wavhdr.datasize = adpcmsize;
wavhdr.format = 20; /* ITU G.723 ADPCM (Yamaha) */
wavhdr.bits = 4;
wavhdr.totalsize = wavhdr.datasize + sizeof(wavhdr) - 8;
fwrite(&wavhdr, 1, sizeof(wavhdr), out);
fwrite(adpcmbuf, 1, adpcmsize, out);
fclose(out);
return 0;
}
```
<Overlap Ratio: 0.9925980754996299>

---

--- 369 --
Question ID: b16dbb2c1d4e543c948df336f8715ff2abf06f34_2
Original Code:
```
static int ftm_check_validation(void)
{
	unsigned long long ptn = 0;
	unsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);
	unsigned char data[size];

	if (ftm_valid > FTM_NOT_MATCHED_MAGIC)
		return NO_ERROR;

	if (!target_is_emmc_boot()) {
		dprintf(CRITICAL, "%s: target is not emmc boot\n", __func__);
		goto invalidated;
	}

	ptn = ftm_get_partition_offset();

	if (ptn == 0) {
		dprintf(CRITICAL, "%s: failed get offset\n", __func__);
		goto invalidated;
	}

	/* read first page from ftm partition */
	if (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {
		dprintf(CRITICAL, "%s: mmc read failure\n", __func__);
		goto invalidated;
	}

	if (!strcmp((void *)data, FTM_MAGIC_STRING)) {
		ftm_valid = FTM_VALID;
	} else {
		ftm_valid = FTM_NOT_MATCHED_MAGIC;
		dprintf(CRITICAL, "%s: FTM magic string is not equal. %s\n", __func__, data);
	}

	return NO_ERROR;

invalidated:
	ftm_valid = FTM_INVALID;
	return ERROR;
}
```


Overlapping Code:
```
_check_validation(void)
{
unsigned long long ptn = 0;
unsigned int size = FTM_ROUND_TO_PAGE(strlen(FTM_MAGIC_STRING) + 1, FTM_PAGE_MASK);
unsigned char data[size];
if (ftm_valid > FTM_NOT_MATCHED_MAGIC)
return NO_ERROR;
if (!target_is_emmc_boot()) {
dprintf(CRITICAL, "%s: target is not emmc boot\n", __func__);
goto invalidated;
}
ptn = ftm_get_partition_offset();
if (ptn == 0) {
dprintf(CRITICAL, "%s: failed get offset\n", __func__);
goto invalidated;
}
/* read first page from ftm partition */
if (mmc_read(ptn + (LGFTM_MAGIC_ITEM * FTM_PAGE_SIZE), (unsigned int *)data, size)) {
dprintf(CRITICAL, "%s: mmc read failure\n", __func__);
goto invalidated;
}
if (!strcmp((void *)data, FTM_MAGIC_STRING)) {
ftm_valid = FTM_VALID;
} else {
ftm_valid = FTM_NOT_MATCHED_MAGIC;
dprintf(CRITICAL, "%s: FTM magic string is not equal. %s\n", __func__, data);
}
return NO_ERROR;
invalidated:
ftm_valid = FTM_
```
<Overlap Ratio: 0.9594882729211087>

---

--- 370 --
Question ID: 87e968aceb9ca3266b2a1de9ff1297c7d2f77f7f_51
Original Code:
```
void bvconst_add2(uint32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {
  uint64_t aux;

  assert(k>0);
  aux = 0;
  do {
    aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));
    *bv = (uint32_t) aux;
    aux >>= 32;
    a1 ++;
    a2 ++;
    bv ++;
    k --;
  } while (k > 0);
}
```


Overlapping Code:
```
nt32_t *bv, uint32_t k, uint32_t *a1, uint32_t *a2) {
uint64_t aux;
assert(k>0);
aux = 0;
do {
aux += ((uint64_t) (*a1)) + ((uint64_t) (*a2));
*bv = (uint32_t) aux;
aux >>= 32;
a1 ++;
a2 ++;
bv ++;
k --;

```
<Overlap Ratio: 0.8429752066115702>

---

--- 371 --
Question ID: 9e065a312285ddb6f354910d5188debfec215410_2
Original Code:
```
uint64_t
ar5416GetTsf64(struct ath_hal *ah)
{
	uint32_t low1, low2, u32;

	/* sync multi-word read */
	low1 = OS_REG_READ(ah, AR_TSF_L32);
	u32 = OS_REG_READ(ah, AR_TSF_U32);
	low2 = OS_REG_READ(ah, AR_TSF_L32);
	if (low2 < low1) {	/* roll over */
		/*
		 * If we are not preempted this will work.  If we are
		 * then we re-reading AR_TSF_U32 does no good as the
		 * low bits will be meaningless.  Likewise reading
		 * L32, U32, U32, then comparing the last two reads
		 * to check for rollover doesn't help if preempted--so
		 * we take this approach as it costs one less PCI read
		 * which can be noticeable when doing things like
		 * timestamping packets in monitor mode.
		 */
		u32++;
	}
	return (((uint64_t) u32) << 32) | ((uint64_t) low2);
}
```


Overlapping Code:
```
int64_t
ar5416GetTsf64(struct ath_hal *ah)
{
uint32_t low1, low2, u32;
/* sync multi-word read */
low1 = OS_REG_READ(ah, AR_TSF_L32);
u32 = OS_REG_READ(ah, AR_TSF_U32);
low2 = OS_REG_READ(ah, AR_TSF_L32);
if (low2 < low1) { /* roll over */
/*
* If we are not preempted this will work. If we are
* then we re-reading AR_TSF_U32 does no good as the
* low bits will be meaningless. Likewise reading
* L32, U32, U32, then comparing the last two reads
* to check for rollover doesn't help if preempted--so
* we take this approach as it costs one less PCI read
* which can be noticeable when doing things like
* timestamping packets in monitor mode.
*/
u32++;
}
return (((uint64_t) u32) << 32) | ((uint64_t
```
<Overlap Ratio: 0.9845288326300985>

---

--- 372 --
Question ID: c42ec6f00688d39df0464e1e099ebc5743a7e81c_1
Original Code:
```
static int disassemble(char *Instruction, char *Arg1, char *Arg2)
{
	unsigned int ReferencePC=memory_core.pc+2;
	unsigned int Displacement;
	BCC_Instr Instr;
	Memory_RetrWordFromPC(&Instr.Code);
	Displacement=Instr.Bits.Displacement;
	switch(Instr.Bits.Condition) {
	case 0: /* BRA */
		sprintf(Instruction, "BRA");
		break;
	case 1: /* BSR */
		sprintf(Instruction, "BSR");
		break;
	case 2: /* BHI */
		sprintf(Instruction, "BHI");
		break;
	case 3: /* BLS */
		sprintf(Instruction, "BLS");
		break;
	case 4: /* BCC */
		sprintf(Instruction, "BCC");
		break;
	case 5: /* BCS */
		sprintf(Instruction, "BCS");
		break;
	case 6: /* BNE */
		sprintf(Instruction, "BNE");
		break;
	case 7: /* BEQ */
		sprintf(Instruction, "BEQ");
		break;
	case 8: /* BVC */
		sprintf(Instruction, "BVC");
		break;
	case 9: /* BVS */
		sprintf(Instruction, "BVS");
		break;
	case 10: /* BPL */
		sprintf(Instruction, "BPL");
		break;
	case 11: /* BMI */
		sprintf(Instruction, "BMI");
		break;
	case 12: /* BGE */
		sprintf(Instruction, "BGE");
		break;
	case 13: /* BLT */
		sprintf(Instruction, "BLT");
		break;
	case 14: /* BGT */
		sprintf(Instruction, "BGT");
		break;
	case 15: /* BLE */
		sprintf(Instruction, "BLE");
		break;
	}

	if(Displacement==0) {
		Memory_RetrWordFromPC(&Displacement);
		Displacement = (short)Displacement;
/*		sprintf(&Instruction[3], ".W");*/
	}
/*	else
		sprintf(&Instruction[3], ".B");*/
	sprintf(Arg1, "0x%08lX", ReferencePC+Displacement);
	Arg2[0]=0;	
	return 0;
}
```


Overlapping Code:
```
atic int disassemble(char *Instruction, char *Arg1, char *Arg2)
{
unsigned int ReferencePC=memory_core.pc+2;
unsigned int Displacement;
BCC_Instr Instr;
Memory_RetrWordFromPC(&Instr.Code);
Displacement=Instr.Bits.Displacement;
switch(Instr.Bits.Condition) {
case 0: /* BRA */
sprintf(Instruction, "BRA");
break;
case 1: /* BSR */
sprintf(Instruction, "BSR");
break;
case 2: /* BHI */
sprintf(Instruction, "BHI");
break;
case 3: /* BLS */
sprintf(Instruction, "BLS");
break;
case 4: /* BCC */
sprintf(Instruction, "BCC");
break;
case 5: /* BCS */
sprintf(Instruction, "BCS");
break;
case 6: /* BNE */
sprintf(Instruction, "BNE");
break;
case 7: /* BEQ */
sprintf(Instruction, "BEQ");
break;
case 8: /* BVC */
sprintf(Instruction, "BVC");
break;
case 9: /* BVS */
sprintf(Instruction, "BVS");
break;
case 10: /* BPL */
sprintf(Instruction, "BPL");
break;
case 11: /* BMI */
sprintf(Instruction, "BMI");
break;
case 12: /* BGE */
sprintf(Instruction, "BGE");
break;
case 13: /* BLT */
sprintf(Instruction, "BLT");
break;
case 14: /* BGT */
sprintf(Instruction, "BGT");
break;
case 15: /* BLE */
sprintf(Instruction, "BLE");
break;
}
if(Displacement==0) {
Memory_RetrWordFromPC(&Displacement);
Displacement = (short)Displacement;
/* sprintf(&Instruction[3], ".W");*/
}
/* else
sprintf(&Instruction[3], ".B");*/
sprintf(Arg1, "0x%08lX", ReferencePC+Displaceme
```
<Overlap Ratio: 0.9783236994219653>

---

--- 373 --
Question ID: bf0a24a55c7cf1e26c035c599374d09437969295_0
Original Code:
```
int
m2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,
	      pretty)
     struct type *type;
     char *valaddr;
     CORE_ADDR address;
     FILE *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
{
  extern int
  c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,
		       int, enum val_prettyprint));
  return (c_val_print (type, valaddr, address, stream, format, deref_ref,
		       recurse, pretty));
}
```


Overlapping Code:
```

m2_val_print (type, valaddr, address, stream, format, deref_ref, recurse,
pretty)
struct type *type;
char *valaddr;
CORE_ADDR address;
FILE *stream;
int format;
int deref_ref;
int recurse;
enum val_prettyprint pretty;
{
extern int
c_val_print PARAMS ((struct type *, char *, CORE_ADDR, FILE *, int, int,
int, enum val_prettyprint));
return (c_val_print (type, valaddr, address, stream, format, deref_ref,
recurse, pretty));

```
<Overlap Ratio: 0.9906759906759907>

---

--- 374 --
Question ID: da1610f35a336ac8442985c8798a063e2a6844cf_0
Original Code:
```
interface PKPayment : NSObject <NSSecureCoding> {
    PKContact * _billingContact;
    PKContact * _shippingContact;
    PKShippingMethod * _shippingMethod;
    PKPaymentToken * _token;
}
```


Overlapping Code:
```
Coding> {
PKContact * _billingContact;
PKContact * _shippingContact;
PKShippingMethod * _shippingMet
```
<Overlap Ratio: 0.5847953216374269>

---

--- 375 --
Question ID: 87e8684fbb5ae26011208b1e4e3d02d0b26431a6_4
Original Code:
```
TEST_CASE(hostent_2)
{
  struct hostent *phents[1024], *phent2;
  int i = 0, j = 0;
  sethostent(1);
  while (phents[i] = gethostent()) {
    TEST_FAIL_IF(phents[i]->h_name == NULL);
    TEST_FAIL_IF(phents[i]->h_aliases == NULL);
    TEST_FAIL_IF(phents[i]->h_addr_list == NULL);
    TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);
    phents[i] = dup_hostent(phents[i]);
    ++i;
  }
  sethostent(1);
  for (j = 0; j < i && (phent2 = gethostent()); ++j) {
    TEST_FAIL_IF(!compare_hostent(phents[j], phent2));
    free_hostent(phents[j]);
  }
  endhostent();
  TEST(i == j);
}
```


Overlapping Code:
```
struct hostent *phents[1024], *phent2;
int i = 0, j = 0;
sethostent(1);
while (phents[i] = gethostent()) {
TEST_FAIL_IF(phents[i]->h_name == NULL);
TEST_FAIL_IF(phents[i]->h_aliases == NULL);
TEST_FAIL_IF(phents[i]->h_addr_list == NULL);
TEST_FAIL_IF(phents[i]->h_addr_list[0] == NULL);
phents[i] = dup_hostent(phents[i]);
++i;
}
sethostent(1);
for (j = 0; j < i && (phent2 = gethostent()); ++j) {
TEST_FAIL_IF(!compare_hostent(phents[j], phent2));
free_hostent(phents[j]);
}
endhostent();
TEST(i == 
```
<Overlap Ratio: 0.946969696969697>

---

--- 376 --
Question ID: b547c6aa8c9230d64661ddfcd09bf26ca0a8fd0c_0
Original Code:
```
_pure_ static inline size_t
str_cmp(const char *restrict sa, const char *restrict sb)
{
    if (!sa || !sb)
        return 1;

    size_t i = 0;

    while (sa[i] == sb[i])
        if (!sa[i++])
            return 0;

    return i + 1;
}
```


Overlapping Code:
```
 inline size_t
str_cmp(const char *restrict sa, const char *restrict sb)
{
if (!sa || !sb)
return 1;
size_t i = 0;
while (sa[i] == sb[i])
if (!sa[i++]
```
<Overlap Ratio: 0.7894736842105263>

---

--- 377 --
Question ID: 5c25d22e8ffeb31c8ebe19e811b61c8c4eeb5fa1_1
Original Code:
```
void test_udict_const_str(udict_backend_t backend)
{
    udict_t *d = udict_create_with_backend(backend);
    udict_put(d, G_CSTR("k1"), G_CSTR("v1"));
    udict_put(d, G_CSTR("k2"), G_CSTR("v2"));
    udict_put(d, G_CSTR("k3"), G_CSTR("v3"));

    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k1"), G_CSTR(""))), "v1");
    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k2"), G_CSTR(""))), "v2");
    UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k3"), G_CSTR(""))), "v3");

    udict_clear(d);
    udict_destroy(d);
}
```


Overlapping Code:
```
id test_udict_const_str(udict_backend_t backend)
{
udict_t *d = udict_create_with_backend(backend);
udict_put(d, G_CSTR("k1"), G_CSTR("v1"));
udict_put(d, G_CSTR("k2"), G_CSTR("v2"));
udict_put(d, G_CSTR("k3"), G_CSTR("v3"));
UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k1"), G_CSTR(""))), "v1");
UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k2"), G_CSTR(""))), "v2");
UASSERT_STR_EQ(G_AS_STR(udict_get(d, G_CSTR("k3"), G_CSTR(""))), "v3");
udict_cl
```
<Overlap Ratio: 0.9394572025052192>

---

--- 378 --
Question ID: ec79c49de0975651a5e2cdebdd058fc312308537_5
Original Code:
```
int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)
{
	if (!skb)
		return -1;

	priv->stats.rx_bytes += skb->len;
	priv->stats.rx_packets++;

	skb->dev = priv->netdev;
	skb->protocol = eth_type_trans(skb, priv->netdev);
	skb->ip_summed = CHECKSUM_NONE;

	/* This is required only in case of 11n and USB/PCIE as we alloc
	 * a buffer of 4K only if its 11N (to be able to receive 4K
	 * AMSDU packets). In case of SD we allocate buffers based
	 * on the size of packet and hence this is not needed.
	 *
	 * Modifying the truesize here as our allocation for each
	 * skb is 4K but we only receive 2K packets and this cause
	 * the kernel to start dropping packets in case where
	 * application has allocated buffer based on 2K size i.e.
	 * if there a 64K packet received (in IP fragments and
	 * application allocates 64K to receive this packet but
	 * this packet would almost double up because we allocate
	 * each 1.5K fragment in 4K and pass it up. As soon as the
	 * 64K limit hits kernel will start to drop rest of the
	 * fragments. Currently we fail the Filesndl-ht.scr script
	 * for UDP, hence this fix
	 */
	if ((priv->adapter->iface_type == MWIFIEX_USB ||
	     priv->adapter->iface_type == MWIFIEX_PCIE) &&
	    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))
		skb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);

	if (in_interrupt())
		netif_rx(skb);
	else
		netif_rx_ni(skb);

	return 0;
}
```


Overlapping Code:
```
mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)
{
if (!skb)
return -1;
priv->stats.rx_bytes += skb->len;
priv->stats.rx_packets++;
skb->dev = priv->netdev;
skb->protocol = eth_type_trans(skb, priv->netdev);
skb->ip_summed = CHECKSUM_NONE;
/* This is required only in case of 11n and USB/PCIE as we alloc
* a buffer of 4K only if its 11N (to be able to receive 4K
* AMSDU packets). In case of SD we allocate buffers based
* on the size of packet and hence this is not needed.
*
* Modifying the truesize here as our allocation for each
* skb is 4K but we only receive 2K packets and this cause
* the kernel to start dropping packets in case where
* application has allocated buffer based on 2K size i.e.
* if there a 64K packet received (in IP fragments and
* application allocates 64K to receive this packet but
* this packet would almost double up because we allocate
* each 1.5K fragment in 4K and pass it up. As soon as the
* 64K limit hits kernel will start to drop rest of the
* fragments. Currently we fail the Filesndl-ht.scr script
* for UDP, hence this fix
*/
if ((priv->adapter->iface_type == MWIFIEX_USB ||
priv->adapter->iface_type == MWIFIEX_PCIE) &&
(skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))
skb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);
if (in_interrupt())
netif_rx(skb);
else
netif_rx_ni(skb);
return
```
<Overlap Ratio: 0.9933774834437086>

---

--- 379 --
Question ID: eceba9c2480355dd23601e4ab5eb4cd4f37a44af_2
Original Code:
```
void
gm_tbl_del(gm_tbl_t *t)
{
    int i;

    if (t == NULL) {
        return;
    }

    gm_func_del(t->value);

    for (i = 0; i < ALPHABET_LEN; i++) {
        gm_tbl_del(t->next[i]);
    }

    ndt_free(t);
}
```


Overlapping Code:
```
t i;
if (t == NULL) {
return;
}
gm_func_del(t->value);
for (i = 0; i < ALPHABET_LEN; i++) {
gm_tbl_d
```
<Overlap Ratio: 0.6060606060606061>

---

--- 380 --
Question ID: 208c69870d617204421aac4073f3cc72fd1bab21_0
Original Code:
```
void __gfx_gen_pixels(int c, unsigned int w, unsigned char* pixels)
{
	unsigned int x, y;
	uint8_t* fnt = gfx_font();

	if(c != 0 && w != 0)
  {
    for(y = 0; y < gfx_font_height; y++)
    {
      for(x = 0; x < gfx_font_width; x++)
      {
        if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)
        {
          pixels[x + (y * w)] = 1;
        }
      }
    }
  }
}
```


Overlapping Code:
```
 c, unsigned int w, unsigned char* pixels)
{
unsigned int x, y;
uint8_t* fnt = gfx_font();
if(c != 0 && w != 0)
{
for(y = 0; y < gfx_font_height; y++)
{
for(x = 0; x < gfx_font_width; x++)
{
if(fnt[c * gfx_font_height + y] >> (7 - x) & 1)
{
pixels[x 
```
<Overlap Ratio: 0.8333333333333334>

---

--- 381 --
Question ID: 0dbfa60e1c29bd15177250bd5caf7d90b9874076_34
Original Code:
```
void tdeletechar(int n) {
  int dst, src, size;
  Character *line;

  LIMIT(n, 0, terminal.col - terminal.cursor.x);

  dst = terminal.cursor.x;
  src = terminal.cursor.x + n;
  size = terminal.col - src;
  line = terminal.line[terminal.cursor.y];

  memmove(&line[dst], &line[src], size * sizeof(Character));
  tclearregion(terminal.col - n, terminal.cursor.y, terminal.col - 1,
               terminal.cursor.y);
}
```


Overlapping Code:
```
ize;
Character *line;
LIMIT(n, 0, terminal.col - terminal.cursor.x);
dst = terminal.cursor.x;
src = terminal.cursor.x + n;
size = terminal.col - src;
line = terminal.line[terminal.cursor.y];
memmove(&line[dst], &line[src], size * sizeof(Character));
tclearregion(terminal.col - n, terminal.cursor.y, 
```
<Overlap Ratio: 0.7894736842105263>

---

--- 382 --
Question ID: 9a4a5bb386bdf3d9377a72f7c3a1ebdc21df3387_0
Original Code:
```
native_handle_t* native_handle_create(int numFds, int numInts)
{
    native_handle_t* h = malloc(
            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));

    if (h) {
        h->version = sizeof(native_handle_t);
        h->numFds = numFds;
        h->numInts = numInts;
    }
    return h;
}
```


Overlapping Code:
```
le_t* native_handle_create(int numFds, int numInts)
{
native_handle_t* h = malloc(
sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));
if (h) {
h->version = sizeof(native_handle_t);
h->numFds = numFds;
h->numInts = numI
```
<Overlap Ratio: 0.8853754940711462>

---

--- 383 --
Question ID: 23256ddc014602ea2e0ee0fa1cecfde1bbe33704_19
Original Code:
```
void cdbdisp_clearCdbPgResults(CdbPgResults* cdb_pgresults)
{
	int i = 0;

	if (!cdb_pgresults)
		return;

	for (i = 0; i < cdb_pgresults->numResults; i++)
		PQclear(cdb_pgresults->pg_results[i]);

	cdb_pgresults->numResults = 0;
}
```


Overlapping Code:
```
CdbPgResults(CdbPgResults* cdb_pgresults)
{
int i = 0;
if (!cdb_pgresults)
return;
for (i = 0; i < cdb_pgresults->numResults; i++)
PQclear(cdb_pgresults->pg_results[i]);
cdb_pgresults->numResults = 0;
```
<Overlap Ratio: 0.9090909090909091>

---

