--- 0 --
Question ID: 82a600a9acb2bacf38a48673e2be55462680427e_0
Original Code:
```
@Generated(value = "io.vrap.rmf.codegen.rendring.CoreCodeGenerator", comments = "https://github.com/vrapio/rmf-codegen")
public class TransactionDraftBuilder implements Builder<TransactionDraft> {

    @Nullable
    private java.time.ZonedDateTime timestamp;

    private com.commercetools.api.models.payment.TransactionType type;

    private com.commercetools.api.models.common.Money amount;

    @Nullable
    private String interactionId;

    @Nullable
    private com.commercetools.api.models.payment.TransactionState state;

    public TransactionDraftBuilder timestamp(@Nullable final java.time.ZonedDateTime timestamp) {
        this.timestamp = timestamp;
        return this;
    }

    public TransactionDraftBuilder type(final com.commercetools.api.models.payment.TransactionType type) {
        this.type = type;
        return this;
    }

    public TransactionDraftBuilder amount(
            Function<com.commercetools.api.models.common.MoneyBuilder, com.commercetools.api.models.common.MoneyBuilder> builder) {
        this.amount = builder.apply(com.commercetools.api.models.common.MoneyBuilder.of()).build();
        return this;
    }

    public TransactionDraftBuilder amount(final com.commercetools.api.models.common.Money amount) {
        this.amount = amount;
        return this;
    }

    public TransactionDraftBuilder interactionId(@Nullable final String interactionId) {
        this.interactionId = interactionId;
        return this;
    }

    public TransactionDraftBuilder state(@Nullable final com.commercetools.api.models.payment.TransactionState state) {
        this.state = state;
        return this;
    }

    @Nullable
    public java.time.ZonedDateTime getTimestamp() {
        return this.timestamp;
    }

    public com.commercetools.api.models.payment.TransactionType getType() {
        return this.type;
    }

    public com.commercetools.api.models.common.Money getAmount() {
        return this.amount;
    }

    @Nullable
    public String getInteractionId() {
        return this.interactionId;
    }

    @Nullable
    public com.commercetools.api.models.payment.TransactionState getState() {
        return this.state;
    }

    public TransactionDraft build() {
        Objects.requireNonNull(type, TransactionDraft.class + ": type is missing");
        Objects.requireNonNull(amount, TransactionDraft.class + ": amount is missing");
        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);
    }

    /**
     * builds TransactionDraft without checking for non null required values
     */
    public TransactionDraft buildUnchecked() {
        return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);
    }

    public static TransactionDraftBuilder of() {
        return new TransactionDraftBuilder();
    }

    public static TransactionDraftBuilder of(final TransactionDraft template) {
        TransactionDraftBuilder builder = new TransactionDraftBuilder();
        builder.timestamp = template.getTimestamp();
        builder.type = template.getType();
        builder.amount = template.getAmount();
        builder.interactionId = template.getInteractionId();
        builder.state = template.getState();
        return builder;
    }

}
```


Overlapping Code:
```
@Generated(value = "io.vrap.rmf.codegen.rendring.CoreCodeGenerator", comments = "https://github.com/vrapio/rmf-codegen")
public class TransactionDraftBuilder implements Builder<TransactionDraft> {
@Nullable
private java.time.ZonedDateTime timestamp;
private com.commercetools.api.models.payment.TransactionType type;
private com.commercetools.api.models.common.Money amount;
@Nullable
private String interactionId;
@Nullable
private com.commercetools.api.models.payment.TransactionState state;
public TransactionDraftBuilder timestamp(@Nullable final java.time.ZonedDateTime timestamp) {
this.timestamp = timestamp;
return this;
}
public TransactionDraftBuilder type(final com.commercetools.api.models.payment.TransactionType type) {
this.type = type;
return this;
}
public TransactionDraftBuilder amount(
Function<com.commercetools.api.models.common.MoneyBuilder, com.commercetools.api.models.common.MoneyBuilder> builder) {
this.amount = builder.apply(com.commercetools.api.models.common.MoneyBuilder.of()).build();
return this;
}
public TransactionDraftBuilder amount(final com.commercetools.api.models.common.Money amount) {
this.amount = amount;
return this;
}
public TransactionDraftBuilder interactionId(@Nullable final String interactionId) {
this.interactionId = interactionId;
return this;
}
public TransactionDraftBuilder state(@Nullable final com.commercetools.api.models.payment.TransactionState state) {
this.state = state;
return this;
}
@Nullable
public java.time.ZonedDateTime getTimestamp() {
return this.timestamp;
}
public com.commercetools.api.models.payment.TransactionType getType() {
return this.type;
}
public com.commercetools.api.models.common.Money getAmount() {
return this.amount;
}
@Nullable
public String getInteractionId() {
return this.interactionId;
}
@Nullable
public com.commercetools.api.models.payment.TransactionState getState() {
return this.state;
}
public TransactionDraft build() {
Objects.requireNonNull(type, TransactionDraft.class + ": type is missing");
Objects.requireNonNull(amount, TransactionDraft.class + ": amount is missing");
return new TransactionDraftImpl(timestamp, type, amount, interactionId, state);
}
/
```
<Overlap Ratio: 1.0>

---

--- 1 --
Question ID: 061eb84ea711d2b46d85f4f5b292ea03238d4daa_0
Original Code:
```
class QuestionTest {

    @Test
    @DisplayName("[Question, 생성] 문제")
    void createQuestion() {
        //given
        Workbook workbook = Workbook.builder()
                .memberId(1L)
                .title("운영체제 5주차")
                .description("운영체제 중간고사 대비")
                .build();

        Commentary commentary = Commentary.builder()
                .comment("문제에 대한 해설 저장")
                .build();

        //when
        Question question = Question.builder()
                .title("다음 보기 중 알맞은 것을 고르세요.")
                .content("보기로 주어질 상황이나 대화가 들어갈 자리")
                .category(Category.SHORT)
                .commentary(commentary)
                .workbook(workbook)
                .build();

        //then
        assertThat(question).isInstanceOf(Question.class);
        assertThat(question.getTitle()).isEqualTo("다음 보기 중 알맞은 것을 고르세요.");
        assertThat(question.getContent()).isEqualTo("보기로 주어질 상황이나 대화가 들어갈 자리");
        assertThat(question.getCategory()).isEqualTo(Category.SHORT);

        assertThat(question.getCommentary().getComment()).isEqualTo(commentary.getComment());
        assertThat(question.getWorkbook().getTitle()).isEqualTo(workbook.getTitle());
    }

}
```


Overlapping Code:
```
"[Question, 생성] 문제")
void createQuestion() {
//given
Workbook workbook = Workbook.builder()
.memberId(1L)
.title("운영체제 5주차")
.description("운영체제 중간고사 대비")
.build();
Commentary commentary = Commentary.builder()
.comment("문제에 대한 해설 저장")
.build();
//when
Question question = Question.builder()
.title("다음 보기 중 알맞은 것을 고르세요.")
.content("보기로 주어질 상황이나 대화가 들어갈 자리")
.category(Category.SHORT)
.commentary(commentary)
.workbook(workbook)
.build();
//then
assertThat(question).isInstanceOf(Question.class);
assertThat(question.getTitle()).isEqualTo("다음 보기 중 알맞은 것을 고르세요.");
assertThat(question.getContent()).isEqualTo("보기로 주어질 상황이나 대화가 들어갈 자리");
assertThat(question.getCategory()).isEqualTo(Category.SHORT);
assertThat(question.getCommentary().getComment()).isEqualTo(commentary.getComment());
assertThat(question.getWorkbook().getTitle()).isEqualTo(workbook.get
```
<Overlap Ratio: 0.9413067552602437>

---

--- 2 --
Question ID: 15c78d13dc4b8fc23a4f4731380ad0f83af9d811_0
Original Code:
```
public class Card7_022 extends AbstractRebel {
    public Card7_022() {
        super(Side.LIGHT, 3, 2, 1, 2, 3, "Incom Engineer");
        setLore("After narrowly escaping the nationalization of Incom by the Empire, many former employees joined the Rebellion. They spent long hours maintaining X-wings and T-47s.");
        setGameText("At same and related locations, adds 2 to your total battle destiny where your X-wing, T-47, T-16 and Z-95 is present and makes those vehicles and starships immune to attrition < 3 (< 5 if he is present with your maintenance droid).");
        addIcons(Icon.SPECIAL_EDITION);
    }

    @Override
    protected List<Modifier> getGameTextWhileActiveInPlayModifiers(SwccgGame game, final PhysicalCard self) {
        List<Modifier> modifiers = new LinkedList<Modifier>();
        modifiers.add(new TotalBattleDestinyModifier(self, new DuringBattleAtCondition(Filters.and(Filters.sameOrRelatedLocation(self),
                Filters.wherePresent(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing, Filters.T_47, Filters.T_16, Filters.Z_95))))),
                2, self.getOwner(), true));
        modifiers.add(new ImmuneToAttritionLessThanModifier(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing,
                Filters.T_47, Filters.T_16, Filters.Z_95), Filters.presentAt(Filters.sameOrRelatedLocation(self))),
                new ConditionEvaluator(3, 5, new PresentWithCondition(self, Filters.and(Filters.your(self), Filters.maintenance_droid)))));
        return modifiers;
    }
}
```


Overlapping Code:
```
tractRebel {
public Card7_022() {
super(Side.LIGHT, 3, 2, 1, 2, 3, "Incom Engineer");
setLore("After narrowly escaping the nationalization of Incom by the Empire, many former employees joined the Rebellion. They spent long hours maintaining X-wings and T-47s.");
setGameText("At same and related locations, adds 2 to your total battle destiny where your X-wing, T-47, T-16 and Z-95 is present and makes those vehicles and starships immune to attrition < 3 (< 5 if he is present with your maintenance droid).");
addIcons(Icon.SPECIAL_EDITION);
}
@Override
protected List<Modifier> getGameTextWhileActiveInPlayModifiers(SwccgGame game, final PhysicalCard self) {
List<Modifier> modifiers = new LinkedList<Modifier>();
modifiers.add(new TotalBattleDestinyModifier(self, new DuringBattleAtCondition(Filters.and(Filters.sameOrRelatedLocation(self),
Filters.wherePresent(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing, Filters.T_47, Filters.T_16, Filters.Z_95))))),
2, self.getOwner(), true));
modifiers.add(new ImmuneToAttritionLessThanModifier(self, Filters.and(Filters.your(self), Filters.or(Filters.X_wing,
Filters.T_47, Filters.T_16, Filters.Z_95), Filters.presentAt(Filters.sameOrRelatedLocation(self))),
new ConditionEvaluator(3, 5, new PresentWithCondition(self, Filters.and(Filters.your(self), Filters.maintenance_droid)))));
retu
```
<Overlap Ratio: 0.9635974304068522>

---

--- 3 --
Question ID: 575cee43e70841a2a31858b937857ef756f6a1ad_0
Original Code:
```
public final class  HexBin {
    static private final int  BASELENGTH   = 255;
    static private final int  LOOKUPLENGTH = 16;
    static final private byte [] hexNumberTable    = new byte[BASELENGTH];
    static final private char [] lookUpHexAlphabet = new char[LOOKUPLENGTH];


    static {
        for (int i = 0; i<BASELENGTH; i++ ) {
            hexNumberTable[i] = -1;
        }
        for ( int i = '9'; i >= '0'; i--) {
            hexNumberTable[i] = (byte) (i-'0');
        }
        for ( int i = 'F'; i>= 'A'; i--) {
            hexNumberTable[i] = (byte) ( i-'A' + 10 );
        }
        for ( int i = 'f'; i>= 'a'; i--) {
           hexNumberTable[i] = (byte) ( i-'a' + 10 );
        }

        for(int i = 0; i<10; i++ )
            lookUpHexAlphabet[i] = (char)('0'+i);
        for(int i = 10; i<=15; i++ )
            lookUpHexAlphabet[i] = (char)('A'+i -10);
    }

    /**
     * Encode a byte array to hex string
     *
     * @param binaryData  array of byte to encode
     * @return return     encoded string
     */
    static public String encode(byte[] binaryData) {
        if (binaryData == null)
            return null;
        int lengthData   = binaryData.length;
        int lengthEncode = lengthData * 2;
        char[] encodedData = new char[lengthEncode];
        int temp;
        for (int i = 0; i < lengthData; i++) {
            temp = binaryData[i];
            if (temp < 0)
                temp += 256;
            encodedData[i*2] = lookUpHexAlphabet[temp >> 4];
            encodedData[i*2+1] = lookUpHexAlphabet[temp & 0xf];
        }
        return new String(encodedData);
    }

    /**
     * Decode hex string to a byte array
     *
     * @param binaryData  encoded string
     * @return return     array of byte to encode
     */
    static public byte[] decode(String encoded) {
        if (encoded == null)
            return null;
        int lengthData = encoded.length();
        if (lengthData % 2 != 0)
            return null;

        char[] binaryData = encoded.toCharArray();
        int lengthDecode = lengthData / 2;
        byte[] decodedData = new byte[lengthDecode];
        byte temp1, temp2;
        for( int i = 0; i<lengthDecode; i++ ){
            temp1 = hexNumberTable[binaryData[i*2]];
            if (temp1 == -1)
                return null;
            temp2 = hexNumberTable[binaryData[i*2+1]];
            if (temp2 == -1)
                return null;
            decodedData[i] = (byte)((temp1 << 4) | temp2);
        }
        return decodedData;
    }
}
```


Overlapping Code:
```
public final class HexBin {
static private final int BASELENGTH = 255;
static private final int LOOKUPLENGTH = 16;
static final private byte [] hexNumberTable = new byte[BASELENGTH];
static final private char [] lookUpHexAlphabet = new char[LOOKUPLENGTH];
static {
for (int i = 0; i<BASELENGTH; i++ ) {
hexNumberTable[i] = -1;
}
for ( int i = '9'; i >= '0'; i--) {
hexNumberTable[i] = (byte) (i-'0');
}
for ( int i = 'F'; i>= 'A'; i--) {
hexNumberTable[i] = (byte) ( i-'A' + 10 );
}
for ( int i = 'f'; i>= 'a'; i--) {
hexNumberTable[i] = (byte) ( i-'a' + 10 );
}
for(int i = 0; i<10; i++ )
lookUpHexAlphabet[i] = (char)('0'+i);
for(int i = 10; i<=15; i++ )
lookUpHexAlphabet[i] = (char)('A'+i -10);
}
/**
* Encode a byte array to hex string
*
* @param binaryData array of byte to encode
* @return return encoded string
*/
static public String encode(byte[] binaryData) {
if (binaryData == null)
return null;
int lengthData = binaryData.length;
int lengthEncode = lengthData * 2;
char[] encodedData = new char[lengthEncode];
int temp;
for (int i = 0; i < lengthData; i++) {
temp = binaryData[i];
if (temp < 0)
temp += 256;
encodedData[i*2] = lookUpHexAlphabet[temp >> 4];
encodedData[i*2+1] = lookUpHexAlphabet[temp & 0xf];
}
return new String(encodedData);
}
/**
* Decode hex string to a byte array
*
* @param binaryData encoded string
* @return return array of byte to encode
*/
static public byte[] decode(String encoded) {
if (encoded == null)
return null;
int lengthData = encoded.length();
if (lengthData % 2 != 0)
return null;
char[] binaryData = encoded.toCharArray();
int lengthDecode = lengthData / 2;
byte[] decodedData = new byte[lengthDecode];
byte temp1, temp2;
for( int i = 0; i<lengthDecode; i++ ){
temp1 = hexNumberTable[binaryData[i*2]];
if (temp1 == -1)
return null;
temp2 = hexNumberTable[binaryData[i*2+1]];
if (temp2 == -1)
return null;
decodedData[i] = (byte)((temp1 << 4) | 
```
<Overlap Ratio: 0.9963235294117647>

---

--- 4 --
Question ID: 88992b81223bff8aff8aefc4402b628c603b4e04_0
Original Code:
```
public class devOnePopup extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.dev_one_popup);
        ArrayList<String> urls= new ArrayList<>();

        ImageView devOneGh = findViewById(R.id.devOneGh);
        devOneGh.setOnClickListener(view -> {
            vibrateDevice();
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            intent.setData(Uri.parse("https://github.com/the-rebooted-coder"));
            startActivity(intent);
        });
        ImageView devOneIn = findViewById(R.id.devOneLinkedin);
        devOneIn.setOnClickListener(view -> {
            vibrateDevice();
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            intent.setData(Uri.parse("https://www.linkedin.com/in/spandn/"));
            startActivity(intent);
        });
        ImageView devOneWeb = findViewById(R.id.devOneWeb);
        new Thread(() -> {
            try {
                // Create a URL for the desired page
                URL url = new URL("https://raw.githubusercontent.com/the-rebooted-coder/Spandan-Saxena-Portfolio/master/porfolioLink.txt");
                //First open the connection
                HttpURLConnection conn=(HttpURLConnection) url.openConnection();
                conn.setConnectTimeout(60000); // timing out in a minute
                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String str;
                while ((str = in.readLine()) != null) {
                    urls.add(str);
                }
                in.close();
            } catch (Exception e) {
                Log.d("MyTag",e.toString());
            }
            try {
                this.runOnUiThread(() -> {
                    if (!urls.isEmpty()) {
                    }
                });
            }
            catch (NullPointerException e){
                //Very Important
                //DO NOTE REMOVE THIS
            }
        }).start();
        devOneWeb.setOnClickListener(view -> {
            vibrateDevice();
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            intent.setData(Uri.parse(urls.toString().replaceAll("\\[", "").replaceAll("]","")));
            startActivity(intent);
        });
        ImageView devOneMail = findViewById(R.id.devOneMail);
        devOneMail.setOnClickListener(view -> {
            vibrateDevice();
            Intent email = new Intent(Intent.ACTION_SEND);
            email.putExtra(android.content.Intent.EXTRA_EMAIL, new String[]{"connectwithspandan@gmail.com"});
            email.putExtra(Intent.EXTRA_SUBJECT, "TakeNotes Connection");
            email.putExtra(Intent.EXTRA_TEXT, "Type your mail here");
            email.setType("message/rfc822");
            startActivity(Intent.createChooser(email, "Choose an Email client :"));
        });
    }
    private void vibrateDevice() {
        Vibrator v3 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            v3.vibrate(VibrationEffect.createOneShot(28, VibrationEffect.DEFAULT_AMPLITUDE));
        } else {
            //deprecated in API 26
            v3.vibrate(25);
        }
    }
}
```


Overlapping Code:
```
lass devOnePopup extends AppCompatActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.dev_one_popup);
ArrayList<String> urls= new ArrayList<>();
ImageView devOneGh = findViewById(R.id.devOneGh);
devOneGh.setOnClickListener(view -> {
vibrateDevice();
Intent intent = new Intent();
intent.setAction(Intent.ACTION_VIEW);
intent.addCategory(Intent.CATEGORY_BROWSABLE);
intent.setData(Uri.parse("https://github.com/the-rebooted-coder"));
startActivity(intent);
});
ImageView devOneIn = findViewById(R.id.devOneLinkedin);
devOneIn.setOnClickListener(view -> {
vibrateDevice();
Intent intent = new Intent();
intent.setAction(Intent.ACTION_VIEW);
intent.addCategory(Intent.CATEGORY_BROWSABLE);
intent.setData(Uri.parse("https://www.linkedin.com/in/spandn/"));
startActivity(intent);
});
ImageView devOneWeb = findViewById(R.id.devOneWeb);
new Thread(() -> {
try {
// Create a URL for the desired page
URL url = new URL("https://raw.githubusercontent.com/the-rebooted-coder/Spandan-Saxena-Portfolio/master/porfolioLink.txt");
//First open the connection
HttpURLConnection conn=(HttpURLConnection) url.openConnection();
conn.setConnectTimeout(60000); // timing out in a minute
BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
String str;
while ((str = in.readLine()) != null) {
urls.add(str);
}
in.close();
} catch (Exception e) {
Log.d("MyTag",e.toString());
}
try {
this.runOnUiThread(() -> {
if (!urls.isEmpty()) {
}
});
}
catch (NullPointerException e){
//Very Important
//DO NOTE REMOVE THIS
}
}).start();
devOneWeb.setOnClickListener(view -> {
vibrateDevice();
Intent intent = new Intent();
intent.setAction(Intent.ACTION_VIEW);
intent.addCategory(Intent.CATEGORY_BROWSABLE);
```
<Overlap Ratio: 0.9955506117908788>

---

--- 5 --
Question ID: c898f2f8fa136058c0edc90363a3298bad61e7b9_0
Original Code:
```
public class FireRisk {

    /**
     * Enum to choose input variable
     */
    public enum From {
        tpac_T_uw_d, L_d_theta, a_b_theta
    };

    /**
     * Enum to choose objective function.
     */
    public enum To {
        F, Fv, Fh, Fsqr
    }

    /**
     * Create optimization problem minimizing Fv on (l,d,theta) inputs.
     *
     * @return OptimizationProblem
     */
    public static OptimizationProblem createOptimizationProblemLdMinFv() {
        return createOptimizationProblem(From.L_d_theta, To.Fv, false);
    }

    /**
     * Create optimization problem maximizing Fv on (tpac,T,uw,d) inputs.
     *
     * @return OptimizationProblem
     */
    public static OptimizationProblem createOptimizationProblemTempMaxFv() {
        return createOptimizationProblem(From.tpac_T_uw_d, To.Fv, true);
    }

    /**
     * Create optimization problem
     *
     * @param from choose input variables
     * @param to choose objective function
     * @param neg true to negate objective function
     * @return OptimizationProblem
     */
    public static OptimizationProblem createOptimizationProblem(From from, To to, boolean neg) {
        String[] box;
        switch (from) {
            case tpac_T_uw_d:
                box = new String[]{
                    "[50.0,170.0]", // tpac
                    "[254.0,299.0]", // T
                    "[2.3,9.0]", // uw
                    "[15.2,34.8]" // d
                };
                break;
            case L_d_theta:
                box = new String[]{
                    "[19.1,55.2]", // L
                    "[15.2,34.8]", // d
                    "[0,1.18]" // theta
                };
                break;
            case a_b_theta:
                box = new String[]{
                    "[382/348,1104/152]", // a = 2*L/d
                    "[2000/348,2000/152]", // b = 2*X/d
                    "[0,1.18]" // theta
                };
                break;
            default:
                throw new AssertionError();
        }
        return new OptimizationProblem(createObjective(from, to, neg), box);
    }

    /**
     * Create objective function
     *
     * @param from choose input variables
     * @param to choose objective function
     * @param neg true to negate objective function
     * @return objective function
     */
    public static Expression createObjective(From from, To to, boolean neg) {
        Subclass fr = new Subclass(from);
        Expression objective;
        switch (to) {
            case F:
                objective = fr.F;
                break;
            case Fv:
                objective = fr.Fv();
                break;
            case Fh:
                objective = fr.Fh();
                break;
            case Fsqr:
                objective = fr.Fsqr();
                break;
            default:
                throw new AssertionError();
        }
        return neg ? objective.neg().name("neg_" + objective.name()) : objective;
    }

    final CodeList cl;
    final From from;

    FireRisk(From from) {
        this.from = from;
        switch (from) {
            case tpac_T_uw_d:
                cl = CodeList.create("tpac", "T", "uw", "d");
                break;
            case L_d_theta:
                cl = CodeList.create("L", "d", "theta");
                break;
            case a_b_theta:
                cl = CodeList.create("a", "b", "theta");
                break;
            default:
                throw new AssertionError();
        }
    }

    boolean from(From from) {
        return this.from.ordinal() <= from.ordinal();
    }

    Expression n(String literal) {
        return cl.lit(literal);
    }

    public static class Subclass extends FireRisk {

        Subclass(From from) {
            super(from);
        }

        // Constants
        public Expression m_prime = n("0.06").name("m_prime");
        public Expression g = n("9.81").name("g");
        public Expression Tnom = n("288.15").name("Tnom");
        public Expression ro_v_nom = n("1.225").name("ro_v_nom");
        public Expression X = n("100").name("X");
        public Expression V_mu = n("22.413").name("V_mu");
        public Expression k_factor = n("1.216").div(n("0.67668")).name("k_factor");
        public Expression c1Pi = cl.pi().recip().name("c1Pi");

        public Expression tpac = from(From.tpac_T_uw_d) ? cl.getInp(0) : null;
        public Expression T = from(From.tpac_T_uw_d) ? cl.getInp(1) : null;
        public Expression uw = from(From.tpac_T_uw_d) ? cl.getInp(2) : null;
        public Expression d = from(From.tpac_T_uw_d)
                ? cl.getInp(3)
                : from(From.L_d_theta)
                ? cl.getInp(1)
                : null;

        /*0*/
        public Expression k = from(From.tpac_T_uw_d)
                ? k_factor.mul(tpac.rootn(3)).name("k")
                : null;

        public Expression mu0 = from(From.tpac_T_uw_d)
                ? n("7").mul(k).sub(n("21.5")).name("mu0")
                : null;
        public Expression mu1 = from(From.tpac_T_uw_d)
                ? n("0.76").sub(n("0.04").mul(k)).name("mu1")
                : null;
        public Expression mu2 = from(From.tpac_T_uw_d)
                ? n("0.0003").mul(k).sub(n("0.00245")).name("mu2")
                : null;
        /*1*/
        public Expression mu = from(From.tpac_T_uw_d)
                ? mu0.add(mu1.mul(tpac)).add(mu2.mul(tpac.sqr())).name("mu")
                : null;

        /*2*/
        public Expression ro_p = from(From.tpac_T_uw_d)
                ? mu.div(V_mu.mul(n("1").add(n("0.00367").mul(tpac)))).name("ro_p")
                : null;

        public Expression u_star_arg = from(From.tpac_T_uw_d)
                ? ro_p.div(m_prime.mul(g).mul(d))
                : null;
        /*3*/
        public Expression u_star = from(From.tpac_T_uw_d)
                ? uw.mul(u_star_arg.rootn(3)).max(n("1")).name("u_star")
                : null;

        /*4*/
        public Expression ro_v = from(From.tpac_T_uw_d)
                ? Tnom.mul(ro_v_nom).div(T).name("ro_v")
                : null;

        /*5*/
        public Expression L = from(From.tpac_T_uw_d)
                ? n("55")
                .mul(m_prime.pow(n("0.67")))
                .div(g.pow(n("0.335")))
                .mul(d.pow(n("0.665")))
                .mul(u_star.pow(n("0.21")))
                .div(ro_v.pow(n("0.67")))
                .name("L")
                : from(From.L_d_theta)
                ? cl.getInp(0)
                : null;

        /*6*/
        public Expression theta = from(From.tpac_T_uw_d)
                ? u_star.sqrt().recip().acos().name("theta")
                : from(From.L_d_theta)
                ? cl.getInp(2)
                : from(From.a_b_theta)
                ? cl.getInp(2)
                : null;

        /*7*/
        public Expression a = from(From.L_d_theta)
                ? L.mul(n("2")).div(d).name("a")
                : from(From.a_b_theta)
                ? cl.getInp(0)
                : null;

        /*8*/
        public Expression b = from(From.L_d_theta)
                ? n("2").mul(X).div(d).name("b")
                : from(From.a_b_theta)
                ? cl.getInp(1)
                : null;

        public Expression bp1 = b.add(n("1")).name("bp1");
        public Expression bm1 = b.sub(n("1")).name("bm1");

        public Expression sinth = theta.sin().name("sinth");
        public Expression costh = theta.cos().name("costh");

        public Expression A_arg = a.sqr()
                .add(bp1.sqr())
                .sub(n("2").mul(a.mul(bp1).mul(sinth)))
                .name("A_arg");
        /*9*/
        public Expression A = A_arg.sqrt().name("A");

        public Expression B_arg = a.sqr()
                .add(bm1.sqr())
                .sub(n("2").mul(a.mul(bm1).mul(sinth)))
                .name("B_arg");
        /*10*/
        public Expression B = B_arg.sqrt().name("B");

        public Expression C_arg = n("1").add((b.sqr().sub(n("1"))).mul(costh.sqr())).name("C_arg");
        /*11*/
        public Expression C = C_arg.sqrt().name("C");

        public Expression D_arg = from(From.L_d_theta)
                ? n("2").mul(X).sub(d)
                .div(n("2").mul(X).add(d))
                .name("D_arg")
                : from(From.a_b_theta)
                ? bm1.div(bp1).sqrt()
                : null;
        /*12*/
        public Expression D = D_arg.sqrt().name("D");

        /*13*/
        public Expression E = from(From.L_d_theta)
                ? L.mul(costh)
                .div(X.sub(L.mul(sinth)))
                .name("E")
                : from(From.a_b_theta)
                ? a.mul(costh).div(b.sub(a.mul(sinth)))
                : null;

        /*14*/
        public Expression F_arg = b.sqr().sub(n("1")).name("F_arg");
        public Expression F = F_arg.sqrt().name("F");

        public Expression ab = a.mul(b).name("ab");
        public Expression AB = A.mul(B).name("AB");

        public Expression S1arg = ab.sub(F.sqr().mul(sinth))
                .div(F.mul(C)).name("S1arg");
        public Expression S1 = S1arg.atan().name("S1");
        public Expression S2arg = F.mul(sinth).div(C).name("S2arg");
        public Expression S2 = S2arg.atan().name("S2");
        public Expression S = S1.add(S2).name("S");

        public Expression ADB = A.mul(D).div(B).name("ADB");
        public Expression atanADB = ADB.atan().name("atanADB");

        public Expression Fv() {
            Expression abFv = a.sqr()
                    .add(b.add(n("1")).sqr())
                    .sub(n("2").mul(b).mul(n("1").add(a.mul(sinth))))
                    .name("abFv");
            Expression Fv1 = E.neg().mul(D.atan()).name("Fv1");
            Expression Fv2 = E.mul(abFv).div(AB).mul(atanADB).name("Fv2");
            Expression Fv3 = costh.div(C).mul(S).name("Fv3");
            Expression Fv = cl.pi().recip().mul(Fv1.add(Fv2.add(Fv3))).name("Fv");
            return Fv;
        }

        public Expression Fh() {
            Expression abFh = a.sqr()
                    .add(b.add(n("1")).sqr())
                    .sub(n("2").mul(b.add(n("1")).add(ab.mul(sinth))))
                    .name("abFh");
            Expression Fh1 = D.recip().atan().name("Fh1");
            Expression Fh2 = sinth.div(C).mul(S).name("Fh2");
            Expression Fh3 = abFh.div(AB).mul(atanADB).name("Fh3");
            Expression Fh = c1Pi.mul(Fh1.add(Fh2).sub(Fh3)).name("Fh");
            return Fh;
        }

        public Expression Fsqr() {
            return Fv().sqr()
                    .add(Fh().sqr())
                    .name("Fsqr");
        }

    }
}
```


Overlapping Code:
```
o choose input variable
*/
public enum From {
tpac_T_uw_d, L_d_theta, a_b_theta
};
/**
* Enum to choose objective function.
*/
public enum To {
F, Fv, Fh, Fsqr
}
/**
* Create optimization problem minimizing Fv on (l,d,theta) inputs.
*
* @return OptimizationProblem
*/
public static OptimizationProblem createOptimizationProblemLdMinFv() {
return createOptimizationProblem(From.L_d_theta, To.Fv, false);
}
/**
* Create optimization problem maximizing Fv on (tpac,T,uw,d) inputs.
*
* @return OptimizationProblem
*/
public static OptimizationProblem createOptimizationProblemTempMaxFv() {
return createOptimizationProblem(From.tpac_T_uw_d, To.Fv, true);
}
/**
* Create optimization problem
*
* @param from choose input variables
* @param to choose objective function
* @param neg true to negate objective function
* @return OptimizationProblem
*/
public static OptimizationProblem createOptimizationProblem(From from, To to, boolean neg) {
String[] box;
switch (from) {
case tpac_T_uw_d:
box = new String[]{
"[50.0,170.0]", // tpac
"[254.0,299.0]", // T
"[2.3,9.0]", // uw
"[15.2,34.8]" // d
};
break;
case L_d_theta:
box = new String[]{
"[19.1,55.2]", // L
"[15.2,34.8]", // d
"[0,1.18]" // theta
};
break;
case a_b_theta:
box = new String[]{
"[382/348,1104/152]", // a = 2*L/d
"[2000/348,2000/152]", // b = 2*X/d
"[0,1.18]" // theta
};
break;
default:
throw new AssertionError();
}
return new OptimizationProblem(createObjective(from, to, neg), box);
}
/**
* Create objective function
*
* @param from choose input variables
* @param to choose objective function
* @param neg true to negate objective function
* @return objective function
*/
public static Expression createObjective(From from, To to, boolean neg) {
Subclass fr = new Subclass(from);
Ex
```
<Overlap Ratio: 0.9695290858725761>

---

--- 6 --
Question ID: 96bc17cd388491f2fadc1aef43f3e9b97f58150e_0
Original Code:
```
class RequestInfoTest {
    private static final String TENANT_NAME = "vmware_gms";
    private static final String TENANT_URL = "https://impl.workday.com";
    private static final String ROUTING_PREFIX = "https://dev.hero.example.com/connectors/id/";
    private static final Locale LOCALE = Locale.ENGLISH;
    private static final String BASE_URL = "http://workday.com";
    private static final String CONNECTOR_AUTH = "connectorAuth";

    @Test
    void testCardsConfigGetters() {
        RequestInfo requestInfo = RequestInfo.builder().tenantName(TENANT_NAME)
                .tenantUrl(TENANT_URL)
                .baseUrl(BASE_URL)
                .routingPrefix(ROUTING_PREFIX)
                .connectorAuth(CONNECTOR_AUTH)
                .isPreHire(true)
                .locale(LOCALE)
                .build();
        assertForGetters(requestInfo);
    }

    @Test
    void testCardsConfigSetters() {
        RequestInfo requestInfo = RequestInfo.builder().build();
        requestInfo.setBaseUrl(BASE_URL);
        requestInfo.setConnectorAuth(CONNECTOR_AUTH);
        requestInfo.setRoutingPrefix(ROUTING_PREFIX);
        requestInfo.setTenantName(TENANT_NAME);
        requestInfo.setTenantUrl(TENANT_URL);
        requestInfo.setPreHire(true);
        requestInfo.setLocale(LOCALE);
        assertForGetters(requestInfo);
    }

    private void assertForGetters(RequestInfo requestInfo) {
        assertThat(requestInfo.getBaseUrl()).isEqualTo(BASE_URL);
        assertThat(requestInfo.getRoutingPrefix()).isEqualTo(ROUTING_PREFIX);
        assertThat(requestInfo.getConnectorAuth()).isEqualTo(CONNECTOR_AUTH);
        assertThat(requestInfo.getTenantName()).isEqualTo(TENANT_NAME);
        assertThat(requestInfo.getTenantUrl()).isEqualTo(TENANT_URL);
        assertThat(requestInfo.isPreHire()).isTrue();
        assertThat(requestInfo.getLocale()).isEqualTo(LOCALE);
    }
}
```


Overlapping Code:
```
stInfoTest {
private static final String TENANT_NAME = "vmware_gms";
private static final String TENANT_URL = "https://impl.workday.com";
private static final String ROUTING_PREFIX = "https://dev.hero.example.com/connectors/id/";
private static final Locale LOCALE = Locale.ENGLISH;
private static final String BASE_URL = "http://workday.com";
private static final String CONNECTOR_AUTH = "connectorAuth";
@Test
void testCardsConfigGetters() {
RequestInfo requestInfo = RequestInfo.builder().tenantName(TENANT_NAME)
.tenantUrl(TENANT_URL)
.baseUrl(BASE_URL)
.routingPrefix(ROUTING_PREFIX)
.connectorAuth(CONNECTOR_AUTH)
.isPreHire(true)
.locale(LOCALE)
.build();
assertForGetters(requestInfo);
}
@Test
void testCardsConfigSetters() {
RequestInfo requestInfo = RequestInfo.builder().build();
requestInfo.setBaseUrl(BASE_URL);
requestInfo.setConnectorAuth(CONNECTOR_AUTH);
requestInfo.setRoutingPrefix(ROUTING_PREFIX);
requestInfo.setTenantName(TENANT_NAME);
requestInfo.setTenantUrl(TENANT_URL);
requestInfo.setPreHire(true);
requestInfo.setLocale(LOCALE);
assertForGetters(requestInfo);
}
private void assertForGetters(RequestInfo requestInfo) {
assertThat(requestInfo.getBaseUrl()).isEqualTo(BASE_URL);
assertThat(requestInfo.getRoutingPrefix()).isEqualTo(ROUTING_PREFIX);
assertThat(requestInfo.getConnectorAuth()).isEqualTo(CONNECTOR_AUTH);
assertThat(requestInfo.getTenantName()).isEqualTo(TENANT_NAME);
assertThat(requestInfo.getTenantUrl()).isEqualTo(TENANT_URL);
assertThat(requestInfo.isPreHire()).isTrue();
assertThat(requestInfo.getLocale()
```
<Overlap Ratio: 0.9779179810725552>

---

--- 7 --
Question ID: e3e08ba1ad0dcac6e8b4dfc54c3b11593840f559_0
Original Code:
```
public class SceneDetectionActivity extends AppCompatActivity {

    //region variablesAndObjects
    private static final String TAG = SceneDetectionActivity.class.getSimpleName();

    private Unbinder unbinder;

    private SceneDetectionTransactor sceneDetectionTransactor;

    private Uri takedImageUri;

    private static final int PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE = 1;
    String[] permissionRequestStorageForSelectImage = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};
    private static final int ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE = 11;

    private static final int PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 2;
    String[] permissionRequestCameraAndStorageForTakePhoto = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};
    private static final int ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 22;

    private static final int PERMISSION_CODE_CAMERA_FOR_STREAM = 3;
    String[] permissionRequestCameraForStream = {Manifest.permission.CAMERA};

    private static final int LIVE_OVERLAY = R.id.live_overlay;
    private static final int IMAGE_VIEW_SCENE_DETECTION = R.id.imageView_sceneDetection;
    private static final int RESULT_LOGS = R.id.resultLogs;
    private static final int PROGRESS_BAR = R.id.progressBar;

    private static final int BTN_SCENE_DETECTION_WITH_IMAGE = R.id.btn_sceneDetectionWithImage;
    private static final int BTN_SCENE_DETECTION_WITH_STORAGE = R.id.btn_sceneDetectionWithStorage;
    private static final int BTN_SCENE_DETECTION_WITH_TAKE_PICTURE = R.id.btn_sceneDetectionWithTakeAPicture;
    private static final int BTN_SCENE_DETECTION_WITH_CAMERA_STREAM = R.id.btn_sceneDetectionWithCameraStream;
    private static final int IV_INFO = R.id.ivInfo;

    private static final String REQUEST_PERMISSION_MESSAGE = "Would You Like To Go To Permission Settings To Allow?";
    private static final String DIALOG_YES_MESSAGE = "YES GO";
    private static final String DIALOG_CANCEL_MESSAGE = "CANCEL";

    @Nullable
    @BindView(LIVE_OVERLAY)
    GraphicOverlay graphicOverlay;

    @Nullable
    @BindView(IMAGE_VIEW_SCENE_DETECTION)
    ImageView imageViewSceneDetection;

    @Nullable
    @BindView(RESULT_LOGS)
    TextView resultLogs;

    @Nullable
    @BindView(PROGRESS_BAR)
    ProgressBar progressBar;

    //endregion variablesAndObjects

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_scene_detection);

        unbinder = ButterKnife.bind(this);
        setupToolbar();

        createSceneDetectionTransactor();

        // this is important for get image of imageView by Bitmap and use with AnalyzeWithImage
        imageViewSceneDetection.setDrawingCacheEnabled(true);

    }

    @OnClick({R.id.btn_sceneDetectionWithImage, R.id.btn_sceneDetectionWithStorage,
            R.id.btn_sceneDetectionWithTakeAPicture, R.id.btn_sceneDetectionWithCameraStream})
    public void onItemClick(View v) {
        switch (v.getId()) {
            case BTN_SCENE_DETECTION_WITH_IMAGE:
                clearLogs();
                showProgress();
                Bitmap bitmap = imageViewSceneDetection.getDrawingCache();
                analyseSceneDetectionWithImage(bitmap, false);
                break;
            case BTN_SCENE_DETECTION_WITH_STORAGE:
                clearLogs();
                showProgress();
                ActivityCompat.requestPermissions(this, permissionRequestStorageForSelectImage, PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE);
                break;
            case BTN_SCENE_DETECTION_WITH_TAKE_PICTURE:
                clearLogs();
                showProgress();
                ActivityCompat.requestPermissions(this, permissionRequestCameraAndStorageForTakePhoto, PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);
                break;
            case BTN_SCENE_DETECTION_WITH_CAMERA_STREAM:
                clearLogs();
                ActivityCompat.requestPermissions(this, permissionRequestCameraForStream, PERMISSION_CODE_CAMERA_FOR_STREAM);
                break;
            default:
                break;
        }
    }


    private void setupToolbar() {
        Toolbar toolbar = findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setDisplayShowHomeEnabled(true);
        Util.setToolbar(this, toolbar, getResources().getString(R.string.link_irs_sd));
    }

    @Override
    public boolean onSupportNavigateUp() {
        onBackPressed();
        return true;
    }

    private void createSceneDetectionTransactor() {
        float confidenceMaxResult = 50.0f;
        Log.d(TAG, "createSceneDetectionTransactor : confidenceMaxResult : " + confidenceMaxResult);
        // You can change confidence parameter
        sceneDetectionTransactor = new SceneDetectionTransactor(getApplicationContext(), "");
    }


    /**
     * Detection with Asynchronous method
     * <p>
     * The scene detection service can classify the scenario content of images and add labels,
     * such as outdoor scenery, indoor places, and buildings, to help understand the image content.
     * Based on the detected information, you can create more personalized app experience for users.
     * Currently, on-device detection on 102 scenarios is supported.
     * <p>
     * For details about the scenarios, please refer to this url
     * https://developer.huawei.com/consumer/en/doc/development/HMSCore-Guides-V5/ml-resource-0000001050038188-V5
     *
     * @param bitmap
     * @param isFromGallery : true = image getting from Gallery. set imageView with this bitmap. false = image using from imageView
     */
    private void analyseSceneDetectionWithImage(Bitmap bitmap, boolean isFromGallery) {

        graphicOverlay.clear();

        if (isFromGallery) {
            imageViewSceneDetection.setImageBitmap(bitmap);
        } else {
            imageViewSceneDetection.setImageResource(R.drawable.test_image_scene_detection);
        }

        // ! important !
        // for change scale takedImageBitmap by imageViewObject size
        Bitmap takedImageBitmap = imageViewSceneDetection.getDrawingCache();

        takedImageUri = BitmapUtils.getImageUriFromBitmap(SceneDetectionActivity.this, bitmap);

        MLFrame frame = new MLFrame.Creator().setBitmap(takedImageBitmap).create();

        Log.d(TAG, "analyseSceneDetectionWithImage : TODO edit here : " + bitmap.getWidth() + "-" + bitmap.getHeight());

        sceneDetectionTransactor.detectInImage(frame)
                .addOnSuccessListener(sceneDetectionsResults -> {
                    if (sceneDetectionsResults == null) {
                        Log.e(TAG, "analyseSceneDetectionWithImage : remote : detectInImage results is NULL !");
                        return;
                    }
                    int sceneDetectionsSize = sceneDetectionsResults.size();
                    Log.e(TAG, "analyseSceneDetectionWithImage : remote : addOnSuccessListener sceneDetectionsSize : " + sceneDetectionsSize);

                    if (sceneDetectionsSize > 0) {
                        graphicOverlay.clear();
                        CameraImageGraphic imageGraphic = new CameraImageGraphic(graphicOverlay, takedImageBitmap);
                        graphicOverlay.addGraphic(imageGraphic);

                        StringBuilder sceneDetectionResultMessage = new StringBuilder();

                        for (int i = 0; i < sceneDetectionsSize; ++i) {
                            MLSceneDetection scene = sceneDetectionsResults.get(i);

                            sceneDetectionResultMessage.append(i).append(". Scene : ").append(scene.getResult()).append(" - Confidence : ").append(scene.getConfidence()).append("\n");
                        }

                        SceneDetectionGraphic sceneGraphic = new SceneDetectionGraphic(graphicOverlay, getApplicationContext(), sceneDetectionsResults);
                        graphicOverlay.addGraphic(sceneGraphic);
                        graphicOverlay.postInvalidate();

                        imageViewSceneDetection.setImageBitmap(BitmapUtils.loadBitmapFromView(graphicOverlay, 1080, 1200));

                        String msg = "Scene Detection Success Results : " + sceneDetectionsSize + " scenes. :\n" + sceneDetectionResultMessage.toString();
                        displaySuccessAnalyseResults(msg);

                    } else {
                        Utils.showToastMessage(getApplicationContext(), "No Scene data, Detected Local sceneDetectionsResults size is zero!");
                        displayFailureAnalyseResults("No Scene data, Detected Local sceneDetectionsResults size is zero!");
                    }

                    hideProgress();

                })
                .addOnFailureListener(e -> {
                    String errorMessage = e.getMessage();
                    try {
                        int errorCode = ((MLException) e).getErrCode();
                        String errorMsg = e.getMessage();
                        errorMessage = "ERROR: " + errorCode + " : " + errorMsg;
                    } catch (Exception ex) {
                        Log.e(TAG, "analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure (MLException) errCode : " + ex.getMessage(), ex);
                    }
                    Log.e(TAG, "analyseSceneDetectionWithImage.sceneDetectionTransactor.detectInImage.onFailure exc : " + errorMessage, e);

                    displayFailureAnalyseResults(errorMessage);
                    hideProgress();
                });

        stopSceneDetectionTransactor();
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        Log.i(TAG, "onRequestPermissionsResult : requestCode : " + requestCode);

        if (requestCode == PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE) {
            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Log.d(TAG, "onRequestPermissionsResult : granted storage permission ForDevice -> Start Intent ACTION_PICK");
                // Call the system album. maybe type change will necessary
                this.startActivityForResult(Utils.createIntentForPickImageFromStorage(), ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE);
            } else {
                hideProgress();
                Log.w(TAG, "onRequestPermissionsResult : StoragePermission was NOT GRANTED");
                DialogUtils.showDialogPermissionWarning(this,
                        "NEED STORAGE PERMISSION",
                        REQUEST_PERMISSION_MESSAGE,
                        R.drawable.icon_folder,
                        "You can not use Scene Detection without Storage Permission!",
                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);
            }
        }

        if (requestCode == PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {
            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED &&
                    grantResults[1] == PackageManager.PERMISSION_GRANTED) {
                Log.d(TAG, "onRequestPermissionsResult : granted camera and storage permission -> Start Intent TakePicture");

                // set taken photo name with timestamp and location
                @SuppressLint("SimpleDateFormat")
                String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                String photoFileName = timeStamp + "_newScenePicture";

                String storageDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + "/ML Scene";
                File imageFile = new File(storageDirectory, photoFileName + ".jpg");
                Uri photoUri = Uri.fromFile(imageFile);
                Log.i(TAG, "onRequestPermissionsResult storageDirectory : " + storageDirectory);
                Log.i(TAG, "onRequestPermissionsResult photoUri.getPath : " + photoUri.getPath());


                Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                if (takePictureIntent.resolveActivity(this.getPackageManager()) != null) {
                    ContentValues values = new ContentValues();
                    values.put(MediaStore.Images.Media.TITLE, photoFileName);
                    values.put(MediaStore.Images.Media.DESCRIPTION, "ML Scene Detection Photo From Camera");

                    takedImageUri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
                    Log.i(TAG, "onRequestPermissionsResult takedImageUri --------> : " + takedImageUri);
                    takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, takedImageUri);
                    this.startActivityForResult(takePictureIntent, ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO);
                } else {
                    Log.i(TAG, "takePictureIntent.resolveActivity( this.getPackageManager()) is NULL");
                }
            } else {
                hideProgress();
                Log.w(TAG, "onRequestPermissionsResult : CameraPermission was NOT GRANTED");
                DialogUtils.showDialogPermissionWarning(this,
                        "NEED CAMERA AND STORAGE PERMISSION",
                        REQUEST_PERMISSION_MESSAGE,
                        R.drawable.icon_folder,
                        "You can not use Scene Detection with Take a Picture without Camera And Storage Permission!",
                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);
            }
        }

        if (requestCode == PERMISSION_CODE_CAMERA_FOR_STREAM) {
            if (grantResults.length != 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Log.d(TAG, "onRequestPermissionsResult : granted camera and storage permission ForDevice -> Start Custom Camera Capture Activity");
                Utils.startActivity(SceneDetectionActivity.this, SceneDetectionCameraActivity.class);
            } else {
                Log.w(TAG, "onRequestPermissionsResult : Camera Permission was NOT GRANTED");
                DialogUtils.showDialogPermissionWarning(this,
                        "NEED CAMERA PERMISSION",
                        REQUEST_PERMISSION_MESSAGE,
                        R.drawable.icons_switch_camera_black,
                        "You can not use Scene Detection with Camera Stream without Camera Permission!",
                        DIALOG_YES_MESSAGE, DIALOG_CANCEL_MESSAGE);
            }
        }

    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        Log.i(TAG, "onActivityResult : requestCode : " + requestCode + " resultCode : " + resultCode);
        if (resultCode == 0) {
            Log.w(TAG, "onActivityResult : onActivityResult No any data detected");
            Utils.showToastMessage(getApplicationContext(), "onActivityResult No any data detected");
            hideProgress();
        } else {

            if (requestCode == ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE) {
                Bitmap bitmap;
                try {
                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), data.getData());
                    analyseSceneDetectionWithImage(bitmap, true);
                } catch (IOException e) {
                    Log.i(TAG, "onActivityResult activityIntentCodeStorageForSelectImage IOException for getBitmap with data.getData : " + e.getMessage());
                    Utils.showToastMessage(getApplicationContext(), "IOException for getBitmap with data.getData : " + e.getMessage());
                    hideProgress();
                }
            }
            if (requestCode == ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO) {
                Bitmap bitmap;
                try {
                    Log.i(TAG, "onActivityResult takedImageUri --------> " + takedImageUri);
                    bitmap = MediaStore.Images.Media.getBitmap(this.getContentResolver(), takedImageUri);
                    analyseSceneDetectionWithImage(bitmap, true);
                } catch (Exception e) {
                    Log.e(TAG, "onActivityResult activityIntentCodeCameraAndStorageForTakePhoto IOException for getBitmap with data.getData : " + e.getMessage());
                    Utils.showToastMessage(getApplicationContext(), "IOException for getBitmap with data.getData : " + e.getMessage());
                    hideProgress();
                }

            }
        }
    }


    private void displaySuccessAnalyseResults(String result) {
        hideProgress();
        Utils.createVibration(getApplicationContext(), 200);
        Log.i(TAG, result);
        resultLogs.setText(result);
    }

    private void displayFailureAnalyseResults(String msg) {
        hideProgress();
        String displayMessage = "Scene Detection was Failed Results : \n" + msg;
        Utils.createVibration(getApplicationContext(), 400);
        Log.e(TAG, displayMessage);
        resultLogs.setText(displayMessage);
        Utils.showToastMessage(getApplicationContext(), displayMessage);
    }


    private void clearLogs() {
        resultLogs.setText(R.string.detection_result_descriptions_will_be_here);
    }


    private void showProgress() {
        progressBar.setVisibility(View.VISIBLE);
    }

    private void hideProgress() {
        progressBar.setVisibility(View.GONE);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        unbinder.unbind();

        stopSceneDetectionTransactor();

    }

    private void stopSceneDetectionTransactor() {
        if (sceneDetectionTransactor != null) {
            sceneDetectionTransactor.stop();
        }
    }

}
```


Overlapping Code:
```
DetectionActivity extends AppCompatActivity {
//region variablesAndObjects
private static final String TAG = SceneDetectionActivity.class.getSimpleName();
private Unbinder unbinder;
private SceneDetectionTransactor sceneDetectionTransactor;
private Uri takedImageUri;
private static final int PERMISSION_CODE_STORAGE_FOR_SELECT_IMAGE = 1;
String[] permissionRequestStorageForSelectImage = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};
private static final int ACTIVITY_INTENT_CODE_STORAGE_FOR_SELECT_IMAGE = 11;
private static final int PERMISSION_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 2;
String[] permissionRequestCameraAndStorageForTakePhoto = {Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE};
private static final int ACTIVITY_INTENT_CODE_CAMERA_AND_STORAGE_FOR_TAKE_PHOTO = 22;
private static final int PERMISSION_CODE_CAMERA_FOR_STREAM = 3;
String[] permissionRequestCameraForStream = {Manifest.permission.CAMERA};
private static final int LIVE_OVERLAY = R.id.live_overlay;
private static final int IMAGE_VIEW_SCENE_DETECTION = R.id.imageView_sceneDetection;
private static final int RESULT_LOGS = R.id.resultLogs;
private static final int PROGRESS_BAR = R.id.progressBar;
private static final int BTN_SCENE_DETECTION_WITH_IMAGE = R.id.btn_sceneDetectionWithImage;
private static final int BTN_SCENE_DETECTION_WITH_STORAGE = R.id.btn_sceneDetectionWithStorage;
private static final int BTN_SCENE_DETECTION_WITH_TAKE_PICTURE = R.id.btn_sceneDetectionWithTakeAPicture;
private static final int BTN_SCENE_DETECTION_WITH_CAMERA_STREAM = R.id.btn_sceneDetectionWithCameraStream;
private static final int IV_INFO = R.id.ivInfo;
private static final String REQUEST_PERMISSION_MESSAGE = "Would You Like To Go To Permission Settings To Allow?";
private static final String DIALOG_YES_MESSAGE = "YES GO";
private static final String DIALOG_CANCEL_MESSAGE = "CANCEL";
@Nullable
@BindView(LIVE_OVERLAY)
GraphicOverlay graphicOverlay;
@Nullable
@BindView(IMAGE_VIEW_SCENE_DETECTION)
ImageView imageViewSceneDetection;
@Nullable
@BindView(RESULT_LOGS)
TextView resultLogs;
@Nullable
@BindView(PROGRESS_BAR)
ProgressBar progressBar;
//endregion variablesAndObjects
@Override
protected void onCreate(Bu
```
<Overlap Ratio: 0.991820921222557>

---

--- 8 --
Question ID: 266a4ba1687a28a03b291a47133a4040e02190d1_0
Original Code:
```
public class Stack {
  private static class StackNode {
    private int data;
    private StackNode next;

    public StackNode(int data) {
      this.data = data;
    }
  }

  private StackNode top;

  public int pop() {
    if (top == null) throw new EmptyStackException();
    int data = top.data;
    top = top.next;
    return data;
  }

  public void push(int data) {
    StackNode newTop = new StackNode(data);
    newTop.next = top;
    top = newTop;
  }

  public int peek() {
    if (top == null) throw new EmptyStackException();
    return top.data;
  }

  public boolean isEmpty() {
    return top == null;
  }
}
```


Overlapping Code:
```
public class Stack {
private static class StackNode {
private int data;
private StackNode next;
public StackNode(int data) {
this.data = data;
}
}
private StackNode top;
public int pop() {
if (top == null) throw new EmptyStackException();
int data = top.data;
top = top.next;
return data;
}
public void push(int data) {
StackNode newTop = new StackNode(data);
newTop.next = top;
top = newTop;
}
public int peek() {
if (top == null) throw new EmptyStackException();
return top.data;
}
public boolean isEmpty() {
return top == null;
}

```
<Overlap Ratio: 0.99812734082397>

---

--- 9 --
Question ID: 85ab45013cab63ee5fd9760e7afb076956e6ee28_0
Original Code:
```
public class BasicTileType extends BasicType
		implements TileType, Json.Serializable {
	private boolean solid = true;
	private SpriteSheet sheet;
	private String drop;

	public BasicTileType() {
	}

	@Override
	public void read(Json json, JsonValue jsonData) {
		super.read(json, jsonData);

		solid = jsonData.getBoolean("solid", true);
		sheet = new SpriteSheet(Assets.getTexture(jsonData.getString("sheet", "null.png")), getGrid());
		drop = jsonData.getString("drop", null);
	}

	/**
	 * Gets the sprite grid used by the textures for this tile type;
	 * can be overriden by subclasses.
	 */
	protected SpriteGrid getGrid() {
		return Assets.tileGrid;
	}

	@Override
	public boolean isSolid() {
		return solid;
	}

	public void setSolid(boolean solid) {
		this.solid = solid;
	}

	public SpriteSheet getSheet() {
		return sheet;
	}

	public void setSheet(SpriteSheet sheet) {
		this.sheet = sheet;
	}

	public String getDrop() {
		return drop;
	}

	public void setDrop(String drop) {
		this.drop = drop;
	}

	@Override
	public Sprite getTexture(WorldView worldView, int x, int y) {
		World world = worldView.getWorld();
		BlockFrame frame = BlockFrame.findFrame(
				y == 0 || world.getTileType(x, y + 1).isSolid(),
				x + 1 == world.getWidth() || world.getTileType(x + 1, y).isSolid(),
				y + 1 == world.getHeight() || world.getTileType(x, y - 1).isSolid(),
				x == 0 || world.getTileType(x - 1, y).isSolid());
		return sheet.getSprite(frame.getX(), frame.getY());
	}

	@Override
	public void placed(World world, int x, int y) {
	}

	@Override
	public void destroyed(World world, int x, int y) {
		if (getDrop() != null)
			world.dropItem(new Item(GameRegistry.getItem(getDrop()), 1), x, y);
	}
}
```


Overlapping Code:
```
pe
implements TileType, Json.Serializable {
private boolean solid = true;
private SpriteSheet sheet;
private String drop;
public BasicTileType() {
}
@Override
public void read(Json json, JsonValue jsonData) {
super.read(json, jsonData);
solid = jsonData.getBoolean("solid", true);
sheet = new SpriteSheet(Assets.getTexture(jsonData.getString("sheet", "null.png")), getGrid());
drop = jsonData.getString("drop", null);
}
/**
* Gets the sprite grid used by the textures for this tile type;
* can be overriden by subclasses.
*/
protected SpriteGrid getGrid() {
return Assets.tileGrid;
}
@Override
public boolean isSolid() {
return solid;
}
public void setSolid(boolean solid) {
this.solid = solid;
}
public SpriteSheet getSheet() {
return sheet;
}
public void setSheet(SpriteSheet sheet) {
this.sheet = sheet;
}
public String getDrop() {
return drop;
}
public void setDrop(String drop) {
this.drop = drop;
}
@Override
public Sprite getTexture(WorldView worldView, int x, int y) {
World world = worldView.getWorld();
BlockFrame frame = BlockFrame.findFrame(
y == 0 || world.getTileType(x, y + 1).isSolid(),
x + 1 == world.getWidth() || world.getTileType(x + 1, y).isSolid(),
y + 1 == world.getHeight() || world.getTileType(x, y - 1).isSolid(),
x == 0 || world.getTileType(x - 1, y).isSolid());
return sheet.getSprite(frame.getX(), frame.getY());
}
@Override
public void placed(World world, int x, int y) {
}
@Override
public void destroyed(World world, int x, int y) {
if (getDrop() != null)
world.dropItem(new Item(GameRegistry.getItem(getDrop()), 1), x
```
<Overlap Ratio: 0.9681449094316052>

---

--- 10 --
Question ID: b7d595b6444fec4db981cd5cca2360fc40b3f76d_0
Original Code:
```
public class Euler extends Base {

    public Euler() {
        this.espaciado = 0;
        this.decimales = 5;
    }

    public double evaluar(Funcion funcion, double x0, double x1, double y, int n) {

        System.out.println("x0: " + x0);
        System.out.println("x1: " + x1);
        System.out.println(" y: " + y);
        System.out.println(" n: " + n);
        System.out.println();

        double resultado = 0;
        double f, h;
        double X[] = new double[n + 1];
        double Y[] = new double[n + 1];
        h = (x1 - x0) / n;

        System.out.println("h: " + h);
        X[0] = x0;
        System.out.println("Y" + 0 + ": " + Y[0]);
        Y[0] = y;
        System.out.println("X" + 0 + ": " + Y[0]);
        System.out.println("---------------------------------");
        for (int i = 0; i < n; i++) {
            f = funcion.evaluar(X[i], Y[i]);
            System.out.println("f x" + (i) + "y" + (i) + " : " + f);
            Y[i + 1] = Y[i] + (h * f);
            System.out.println("Y" + (i + 1) + ": " + Y[i + 1]);
            X[i + 1] = X[i] + h;
            System.out.println("X" + (i + 1) + ": " + X[i + 1]);
            System.out.println("---------------------------------");
        }
        resultado = Y[n];

        this.reportarcoordenadas(X, Y);


        System.out.println("");
        System.out.println("Resultado:");
        System.out.println(this.redondear(resultado));

        return resultado;
    }

    public void consola() {

        Consola consola = new Consola();
        String funcion_cadena = consola.getCadena("Ingresa la Funcion");
        double a = consola.getNumero("Ingresa el Valor para a");
        double b = consola.getNumero("Ingresa el Valor para b");
        double y = consola.getNumero("Ingresa el Valor para y");
        int n = consola.getEntero("Ingresa el Numero de Iteraciones", 4);


        boolean fraccion = consola.getBoolean("Quieres usar Fraccciones?");
        int decimales = consola.getEntero("cuantos decimales queres usar para el reporte?", 6);

        this.fraccion = fraccion;
        this.decimales = decimales;

        consola.limpiarPantalla();
        Funcion funcion = new Funcion(funcion_cadena);
        this.evaluar(funcion, a, b, y, n);

    }
}
```


Overlapping Code:
```
ds Base {
public Euler() {
this.espaciado = 0;
this.decimales = 5;
}
public double evaluar(Funcion funcion, double x0, double x1, double y, int n) {
System.out.println("x0: " + x0);
System.out.println("x1: " + x1);
System.out.println(" y: " + y);
System.out.println(" n: " + n);
System.out.println();
double resultado = 0;
double f, h;
double X[] = new double[n + 1];
double Y[] = new double[n + 1];
h = (x1 - x0) / n;
System.out.println("h: " + h);
X[0] = x0;
System.out.println("Y" + 0 + ": " + Y[0]);
Y[0] = y;
System.out.println("X" + 0 + ": " + Y[0]);
System.out.println("---------------------------------");
for (int i = 0; i < n; i++) {
f = funcion.evaluar(X[i], Y[i]);
System.out.println("f x" + (i) + "y" + (i) + " : " + f);
Y[i + 1] = Y[i] + (h * f);
System.out.println("Y" + (i + 1) + ": " + Y[i + 1]);
X[i + 1] = X[i] + h;
System.out.println("X" + (i + 1) + ": " + X[i + 1]);
System.out.println("---------------------------------");
}
resultado = Y[n];
this.reportarcoordenadas(X, Y);
System.out.println("");
System.out.println("Resultado:");
System.out.println(this.redondear(resultado));
return resultado;
}
public void consola() {
Consola consola = new Consola();
String funcion_cadena = consola.getCadena("Ingresa la Funcion");
double a = consola.getNumero("Ingresa el Valor para a");
double b = consola.getNumero("Ingresa el Valor para b");
double y = consola.getNumero("Ingresa el Valor para y");
int n = consola.getEntero("Ingresa el Numero de Iteraciones", 4);
boolean fraccion = consola.getBoolean("Quieres usar Fraccciones?");
int decimales = consola.getEntero("cuantos decimales queres usar para el reporte?", 6);
this.fraccion = fraccion;
this.decimales = decimales;
consola.limpiarPantalla();
Funcion funcion = new Funcion(funcion_cadena);
this.evaluar(funcion, a, b, y, n);

```
<Overlap Ratio: 0.9852216748768473>

---

--- 11 --
Question ID: 60b1865ce445a0de08c8744d25e13aa6488addb3_0
Original Code:
```
@Service
public class ProgettoFormativoFormatter {
	private static Log logger = LogFactory.getLog(ProgettoFormativoFormatter.class);
			
	@Autowired
	private AttivitaAlternanzaRepository attivitaAlternanzaRepository;
	
	@Autowired
	private EsperienzaSvoltaRepository esperienzaSvoltaRepository;
	
	@Autowired
	private StudenteRepository studenteRepository;
	
	@Autowired
	private AziendaRepository aziendaRepository;
	
	@Autowired
	private IstituzioneRepository istituzioneRepository;
	
	@Autowired
	private ResourceLoader resourceLoader;
	
	@Autowired
	private CompetenzaManager competenzaManager;
	
	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
	
	public OdtFile getOtdFile(String istitutoId, Long esperienzaSvoltaId) throws Exception {
		EsperienzaSvolta es = esperienzaSvoltaRepository.findById(esperienzaSvoltaId).orElse(null);
		if(es == null) {
			throw new BadRequestException("esperienza non trovato");
		}
		if(!es.getIstitutoId().equals(istitutoId)) {
			throw new BadRequestException("istituto non corrispondente");
		}
		Istituzione istituzione = istituzioneRepository.findById(istitutoId).orElse(null);
		if(istituzione == null) {
			throw new BadRequestException("istituto non trovato");
		}
		Studente studente = studenteRepository.findById(es.getStudenteId()).orElse(null);
		if(studente == null) {
			throw new BadRequestException("studente non trovato");
		}
		AttivitaAlternanza aa = attivitaAlternanzaRepository.findById(es.getAttivitaAlternanzaId()).orElse(null);
		if(aa == null) {
			throw new BadRequestException("attività non trovata");
		}
		if(aa.getTipologia() != 7) {
			throw new BadRequestException("tipologia non conforme");
		}
		Azienda azienda = aziendaRepository.findById(aa.getEnteId()).orElse(null);
		if(azienda == null) {
			throw new BadRequestException("anzienda/ente non trovata");
		}
		List<Competenza> competenze = competenzaManager.getRisorsaCompetenze(aa.getUuid());
		
		ProgettoFormativoOdt pf = new ProgettoFormativoOdt();
		pf.setCognome(studente.getSurname());
		pf.setNome(studente.getName());
		pf.setDataNascita(studente.getBirthdate());
		pf.setEmail(getNotEmpty(studente.getEmail()));
		pf.setClasse(es.getClasseStudente());
		pf.setEnte(azienda.getNome());
		pf.setPartitaIva(azienda.getPartita_iva());
		pf.setIndirizzo(getIndirizzo(aa, azienda));
		pf.setTipologia(getTipologiaAzienda(azienda));
		pf.setContattoTel(getNotEmpty(azienda.getPhone()));
		pf.setDateFrom(aa.getDataInizio().format(formatter));
		pf.setDateTo(aa.getDataFine().format(formatter));
		pf.setOre(String.valueOf(aa.getOre()));
		pf.setIntNominativo(getNotEmpty(aa.getReferenteScuola()));
		pf.setIntEmail(getNotEmpty(aa.getReferenteScuolaEmail()));
		pf.setEstNominativo(getNotEmpty(aa.getReferenteEsterno()));
		pf.setEstEmail(getNotEmpty(aa.getReferenteEsternoEmail()));
		pf.setDescrizione(getNotEmpty(aa.getDescrizione()));
		pf.setPolizzaInail(getNotEmpty(istituzione.getPolizzaInail()));
		pf.setRctPat(getNotEmpty(istituzione.getRctPat()));
		pf.setInfortuniPat(getNotEmpty(istituzione.getInfortuniPat()));
		
		// Load ODT file and set Velocity template engine and cache it to the registry
		Resource resource = resourceLoader.getResource("classpath:templates/progetto_formativo_it.odt");
		InputStream isTemplate = resource.getInputStream();
		IXDocReport report = XDocReportRegistry.getRegistry().loadReport(isTemplate, TemplateEngineKind.Velocity);
		
		// Create Java model context
		IContext context = report.createContext();
		context.put("pf", pf);
		context.put("competenze", competenze);
		
		// Generate report by merging Java model with the ODT
		Path tempFile = Files.createTempFile("edit-pf-", ".odt");
		tempFile.toFile().deleteOnExit();
		File outputFileODT = tempFile.toFile();
		OutputStream osODT = new FileOutputStream(outputFileODT);
		report.process(context, osODT);
		osODT.flush();
		osODT.close();
		
		if(logger.isInfoEnabled()) {
			logger.info("getOtdFile:" + outputFileODT.getAbsolutePath());
		}
		String filename = "Progetto formativo " + es.getNominativoStudente() + " " + es.getClasseStudente() + " " + aa.getTitolo() + ".odt";
		filename = filename.replace(" ", "_");
    OdtFile odtFile = new OdtFile();
    odtFile.setFile(outputFileODT);
    odtFile.setFilename(filename);
		return odtFile;
	}
	
	private String getNotEmpty(String value) {
		if(value == null) {
			return "";
		}
		return value;
	}
	
	private String getIndirizzo(AttivitaAlternanza aa, Azienda azienda) {
		if(Utils.isNotEmpty(aa.getLuogoSvolgimento())) {
			return aa.getLuogoSvolgimento();
		}
		if(Utils.isNotEmpty(azienda.getAddress())) {
			return azienda.getAddress();
		}
		return "";
	}
	
	private String getTipologiaAzienda(Azienda azienda) {
		switch(azienda.getIdTipoAzienda()) {
			case 1: return "Associazione";
			case 5: return "Cooperativa";
			case 10: return "Impresa";
			case 15: return "Libero professionista";
			case 20: return "Pubblica amministrazione";
			case 25: return "Ente privato/Fondazione";
		}
		return "";
	}


}
```


Overlapping Code:
```
ss ProgettoFormativoFormatter {
private static Log logger = LogFactory.getLog(ProgettoFormativoFormatter.class);

@Autowired
private AttivitaAlternanzaRepository attivitaAlternanzaRepository;

@Autowired
private EsperienzaSvoltaRepository esperienzaSvoltaRepository;

@Autowired
private StudenteRepository studenteRepository;

@Autowired
private AziendaRepository aziendaRepository;

@Autowired
private IstituzioneRepository istituzioneRepository;

@Autowired
private ResourceLoader resourceLoader;

@Autowired
private CompetenzaManager competenzaManager;

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

public OdtFile getOtdFile(String istitutoId, Long esperienzaSvoltaId) throws Exception {
EsperienzaSvolta es = esperienzaSvoltaRepository.findById(esperienzaSvoltaId).orElse(null);
if(es == null) {
throw new BadRequestException("esperienza non trovato");
}
if(!es.getIstitutoId().equals(istitutoId)) {
throw new BadRequestException("istituto non corrispondente");
}
Istituzione istituzione = istituzioneRepository.findById(istitutoId).orElse(null);
if(istituzione == null) {
throw new BadRequestException("istituto non trovato");
}
Studente studente = studenteRepository.findById(es.getStudenteId()).orElse(null);
if(studente == null) {
throw new BadRequestException("studente non trovato");
}
AttivitaAlternanza aa = attivitaAlternanzaRepository.findById(es.getAttivitaAlternanzaId()).orElse(null);
if(aa == null) {
throw new BadRequestException("attività non trovata");
}
if(aa.getTipologia() != 7) {
throw new BadRequestException("tipologia non conforme");
}
Azienda azienda = aziendaRepository.findById(aa.getEnteId()).orElse(null);
if(azienda == null) {
throw new BadRequestException("anzienda/ente non trovata");
}
List<Competenza> competenze = competenzaManager.getRisorsaCompetenze(aa.getUuid());

ProgettoFormativoOdt pf = new ProgettoFormativoOdt();
pf.setCognome(studente.getSurname());
pf.setNome(studente.getName());
pf.setDataNascita(studente.getBirthdate());
pf.setEmail(getNotEmpty(studente.getEmail()));
pf.setClasse(es.getClasseStudente());
pf.setEnte(azienda.getNome());
pf.setPartitaIva(azienda.getPartita_iva());
pf.setIndirizzo(getIndirizzo(aa, azienda));
pf.setTipologia(getTipologiaAzienda(azienda));
pf.setContattoTel(getNotEmpty(azienda.getPhone()));
pf.setDateFrom(aa.getDataInizio().format(f
```
<Overlap Ratio: 0.9865659109991604>

---

--- 12 --
Question ID: 88189a64409a4a3ed2c071fdfdc63cb42f0e429f_0
Original Code:
```
@ExtendWith(WorkDirExtension.class)
public class MessageInputStreamTest
{
    public WorkDir testdir;

    public ByteBufferPool bufferPool = new MappedByteBufferPool();

    @Test
    public void testBasicAppendRead() throws IOException
    {
        StreamTestSession session = new StreamTestSession();
        MessageInputStream stream = new MessageInputStream(session);
        session.setMessageInputStream(stream);

        // Append a single message (simple, short)
        ByteBuffer payload = BufferUtil.toBuffer("Hello World!", StandardCharsets.UTF_8);
        session.addContent(payload, true);
        session.provideContent();

        // Read entire message it from the stream.
        byte[] buf = new byte[32];
        int len = stream.read(buf);
        String message = new String(buf, 0, len, StandardCharsets.UTF_8);

        // Test it
        assertThat("Message", message, is("Hello World!"));
    }

    @Test
    public void testBlockOnRead() throws Exception
    {
        StreamTestSession session = new StreamTestSession();
        MessageInputStream stream = new MessageInputStream(session);
        session.setMessageInputStream(stream);
        new Thread(session::provideContent).start();

        final AtomicBoolean hadError = new AtomicBoolean(false);
        final CountDownLatch startLatch = new CountDownLatch(1);

        // This thread fills the stream (from the "worker" thread)
        // But slowly (intentionally).
        new Thread(() ->
        {
            try
            {
                startLatch.countDown();
                TimeUnit.MILLISECONDS.sleep(200);
                session.addContent("Saved", false);
                TimeUnit.MILLISECONDS.sleep(200);
                session.addContent(" by ", false);
                TimeUnit.MILLISECONDS.sleep(200);
                session.addContent("Zero", false);
                TimeUnit.MILLISECONDS.sleep(200);
                session.addContent("", true);
            }
            catch (Throwable t)
            {
                hadError.set(true);
                t.printStackTrace(System.err);
            }
        }).start();

        Assertions.assertTimeoutPreemptively(ofSeconds(5), () ->
        {
            // wait for thread to start
            startLatch.await();

            // Read it from the stream.
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            IO.copy(stream, out);
            byte[] bytes = out.toByteArray();
            String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);

            // Test it
            assertThat("Error when appending", hadError.get(), is(false));
            assertThat("Message", message, is("Saved by Zero"));
        });
    }

    @Test
    public void testBlockOnReadInitial() throws IOException
    {
        StreamTestSession session = new StreamTestSession();
        MessageInputStream stream = new MessageInputStream(session);
        session.setMessageInputStream(stream);
        session.addContent("I will conquer", true);

        AtomicReference<Throwable> error = new AtomicReference<>();
        new Thread(() ->
        {
            try
            {
                // wait for a little bit before initiating write to stream
                TimeUnit.MILLISECONDS.sleep(1000);
                session.provideContent();
            }
            catch (Throwable t)
            {
                error.set(t);
                t.printStackTrace(System.err);
            }
        }).start();

        Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->
        {
            // Read byte from stream, block until byte received.
            int b = stream.read();
            assertThat("Initial byte", b, is((int)'I'));

            // No error occurred.
            assertNull(error.get());
        });
    }

    @Test
    public void testReadByteNoBuffersClosed() throws IOException
    {
        try (MessageInputStream stream = new MessageInputStream(new EmptySession()))
        {
            final AtomicBoolean hadError = new AtomicBoolean(false);

            new Thread(() ->
            {
                try
                {
                    // wait for a little bit before sending input closed
                    TimeUnit.MILLISECONDS.sleep(1000);
                    stream.appendFrame(null, true);
                    stream.messageComplete();
                }
                catch (InterruptedException | IOException e)
                {
                    hadError.set(true);
                    e.printStackTrace(System.err);
                }
            }).start();

            Assertions.assertTimeoutPreemptively(ofSeconds(10), () ->
            {
                // Read byte from stream. Should be a -1, indicating the end of the stream.
                int b = stream.read();
                assertThat("Initial byte", b, is(-1));

                // No error occurred.
                assertThat("Error when appending", hadError.get(), is(false));
            });
        }
    }

    @Test
    public void testSplitMessageWithEmptyPayloads() throws IOException
    {
        StreamTestSession session = new StreamTestSession();
        MessageInputStream stream = new MessageInputStream(session);
        session.setMessageInputStream(stream);

        session.addContent("", false);
        session.addContent("Hello", false);
        session.addContent("", false);
        session.addContent(" World", false);
        session.addContent("!", false);
        session.addContent("", true);
        session.provideContent();

        // Read entire message it from the stream.
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        IO.copy(stream, out);
        byte[] bytes = out.toByteArray();
        String message = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);

        // Test it
        assertThat("Message", message, is("Hello World!"));
    }

    @Test
    public void testReadBeforeFirstAppend() throws IOException
    {
        StreamTestSession session = new StreamTestSession();
        MessageInputStream stream = new MessageInputStream(session);
        session.setMessageInputStream(stream);

        // Append a single message (simple, short)
        session.addContent(BufferUtil.EMPTY_BUFFER, false);
        session.addContent("Hello World", true);

        new Thread(() ->
        {
            try
            {
                Thread.sleep(2000);
                session.provideContent();
            }
            catch (Exception e)
            {
                throw new RuntimeException(e);
            }
        }).start();

        // Read entire message it from the stream.
        byte[] buf = new byte[32];
        int len = stream.read(buf);
        String message = new String(buf, 0, len, StandardCharsets.UTF_8);

        // Test it
        assertThat("Message", message, is("Hello World"));
    }

    public static class StreamTestSession extends EmptySession
    {
        private static final ByteBuffer EOF = BufferUtil.allocate(0);
        private final AtomicBoolean suspended = new AtomicBoolean(false);
        private BlockingArrayQueue<ByteBuffer> contentQueue = new BlockingArrayQueue<>();
        private MessageInputStream stream;

        public void setMessageInputStream(MessageInputStream stream)
        {
            this.stream = stream;
        }

        public void addContent(String content, boolean last)
        {
            addContent(BufferUtil.toBuffer(content, StandardCharsets.UTF_8), last);
        }

        public void addContent(ByteBuffer content, boolean last)
        {
            contentQueue.add(content);
            if (last)
                contentQueue.add(EOF);
        }

        public void provideContent()
        {
            pollAndAppendFrame();
        }

        @Override
        public void resume()
        {
            if (!suspended.compareAndSet(true, false))
                throw new IllegalStateException();
            pollAndAppendFrame();
        }

        @Override
        public SuspendToken suspend()
        {
            if (!suspended.compareAndSet(false, true))
                throw new IllegalStateException();
            return super.suspend();
        }

        private void pollAndAppendFrame()
        {
            try
            {
                while (true)
                {
                    ByteBuffer content = contentQueue.poll(10, TimeUnit.SECONDS);
                    assertNotNull(content);

                    boolean eof = (content == EOF);
                    stream.appendFrame(content, eof);
                    if (eof)
                    {
                        stream.messageComplete();
                        break;
                    }

                    if (suspended.get())
                        break;
                }
            }
            catch (Exception e)
            {
                throw new RuntimeException(e);
            }
        }
    }
}
```


Overlapping Code:
```
ic class MessageInputStreamTest
{
public WorkDir testdir;
public ByteBufferPool bufferPool = new MappedByteBufferPool();
@Test
public void testBasicAppendRead() throws IOException
{
StreamTestSession session = new StreamTestSession();
MessageInputStream stream = new MessageInputStream(session);
session.setMessageInputStream(stream);
// Append a single message (simple, short)
ByteBuffer payload = BufferUtil.toBuffer("Hello World!", StandardCharsets.UTF_8);
session.addContent(payload, true);
session.provideContent();
// Read entire message it from the stream.
byte[] buf = new byte[32];
int len = stream.read(buf);
String message = new String(buf, 0, len, StandardCharsets.UTF_8);
// Test it
assertThat("Message", message, is("Hello World!"));
}
@Test
public void testBlockOnRead() throws Exception
{
StreamTestSession session = new StreamTestSession();
MessageInputStream stream = new MessageInputStream(session);
session.setMessageInputStream(stream);
new Thread(session::provideContent).start();
final AtomicBoolean hadError = new AtomicBoolean(false);
final CountDownLatch startLatch = new CountDownLatch(1);
// This thread fills the stream (from the "worker" thread)
// But slowly (intentionally).
new Thread(() ->
{
try
{
startLatch.countDown();
TimeUnit.MILLISECONDS.sleep(200);
session.addContent("Saved", false);
TimeUnit.MILLISECONDS.sleep(200);
session.addContent(" by ", false);
TimeUnit.MILLISECONDS.sleep(200);
session.addContent("Zero", false);
TimeUnit.MILLISECONDS.sleep(200);
session.addContent("", true);
}
catch (Throwable t)
{
hadError.set(true);
t.printStackTrace(System.err);
}
}).start();
Assertions.assertTimeoutPreemptively(ofSeconds(5), () ->
{
// wait for thread to start
startLatch.await();
// Read it from the stream.
ByteArrayOutputStream out = new ByteArrayOutputStream();
IO.copy(stream, out);
byte[] bytes = out.toByteArray();
Stri
```
<Overlap Ratio: 0.9769994772608468>

---

--- 13 --
Question ID: 8019c8eb68ca0d419de99e52cf2cb25dcaeaa318_0
Original Code:
```
public class ArrayHelper {

    /**
     * Merges two arrays
     * @param <TItemType> Type of the items
     * @param first First array
     * @param second Second array
     * @return
     */
    @CheckForNull
    public static <TItemType> TItemType[] merge(@CheckForNull TItemType[] first, @CheckForNull TItemType[] second) {
        // Handle nulls
        if (first == null) {
            return second;
        }
        if (second == null) {
            return first;
        }

        // Handle two arrays
        TItemType[] result = Arrays.copyOf(first, first.length + second.length);
        System.arraycopy(second, 0, result, first.length, second.length);
        return result;
    }
}
```


Overlapping Code:
```
lper {
/**
* Merges two arrays
* @param <TItemType> Type of the items
* @param first First array
* @param second Second array
* @return
*/
@CheckForNull
public static <TItemType> TItemType[] merge(@CheckForNull TItemType[] first, @CheckForNull TItemType[] second) {
// Handle nulls
if (first == null) {
return second;
}
if (second == null) {
return first;
}
// Handle two arrays
TItemType[] result = Arrays.copyOf(first, first.length + second.length);
System.arraycopy(second, 0, result, first.length, second.length);
return result;
}
}
```
<Overlap Ratio: 0.9640287769784173>

---

--- 14 --
Question ID: ee69ab543989a8c1f99628a2517298366e45baf7_0
Original Code:
```
@Service
public class PassiveReplyServiceImpl implements PassiveReplyService {

    @Autowired
    private KeyWordMapper keyWordMapper;
    @Autowired
    private TextMessageMapper textMessageMapper;
    @Autowired
    private ImageMessageMapper imageMessageMapper;
    @Autowired
    private MusicMessageMapper musicMessageMapper;
    @Autowired
    private VideoMessageMapper videoMessageMapper;
    @Autowired
    private NewsMessageMapper newsMessageMapper;
    @Autowired
    private VoiceMessageMapper voiceMessageMapper;

    @Override
    public String selectByKeyWord(String fromUserName, String toUserName, String content) {

        String message = null;

        // 需要回复什么类型的消息
        QueryWrapper<KeyWord> query = Wrappers.query();
        query.select("type").in("keyword", content);

        KeyWord keyWord = keyWordMapper.selectOne(query);
        if (keyWord == null){
            message = ErrorMessage.errorMessage(toUserName, fromUserName);
            return message;
        }

        // 获取关键字对应的类型
        String type = keyWord.getType();
        if (type.equals(Const.MESSAGE_TEXT)){
            // TODO 要回复文本类型的
            QueryWrapper<TextMessage> queryText = Wrappers.query();
            queryText.select("content").in("keyword", content);
            String textContent = textMessageMapper.selectOne(queryText).getContent();

            message = InitTextMessage.initTextMessage(toUserName, fromUserName, textContent);

        }else if (type.equals(Const.MESSAGE_IMAGE)){
            // 要回复图片类型的
            QueryWrapper<Image> queryImage = Wrappers.query();
            queryImage.select("media_id").in("keyword", content);
            String mediaId = imageMessageMapper.selectOne(queryImage).getMediaId();

            message = InitImageMessage.initImageMessage(toUserName, fromUserName, mediaId);

        }else if (type.equals(Const.MESSAGE_VOICE)){
            // 语音
            QueryWrapper queryVoice = Wrappers.query();
            queryVoice.select("media_id").in("keyword", content);
            String mediaId = voiceMessageMapper.selectOne(queryVoice).getMediaId();

            message = InitVoiceMessage.initVoiceMessage(toUserName, fromUserName, mediaId);

        }else if (type.equals(Const.MESSAGE_VIDEO)){
            // 视频
            QueryWrapper<Video> queryVideo = Wrappers.query();
            queryVideo.select("title", "media_id", "description").in("keyword", content);
            Video video = videoMessageMapper.selectOne(queryVideo);

            String title= video.getTitle() ;
            String mediaId= video.getMediaId() ;
            String description = video.getDescription() ;

            message = InitVideoMessage.initVideo(toUserName, fromUserName, title, mediaId, description);

        }else if (type.equals(Const.MESSAGE_MUSIC)){
            // 音乐
            QueryWrapper<Music> queryMusic = Wrappers.query();
            queryMusic.select("title", "description", "music_url", "hq_music_url", "thumb_media_id").in("keyword", content);
            Music music = musicMessageMapper.selectOne(queryMusic);

            String title = music.getTitle();
            String desc =music.getDescription();
            String url =music.getMusicUrl();
            String hqUrl =music.getHQMusicUrl();
            String thumb =music.getThumbMediaId();

            message = InitMusicMessage.initMusic(toUserName, fromUserName, title, desc, url, hqUrl, thumb);

        }else if (type.equals(Const.MESSAGE_NEWS)){
            // 图文
            QueryWrapper<News> queryNews = Wrappers.query();
            queryNews.select("title", "description", "pic_url", "url").in("keyword", content);
            News news = newsMessageMapper.selectOne(queryNews);

            String title = news.getTitle() ;
            String desc = news.getDescription() ;
            String picUrl = news.getPicUrl() ;
            String url = news.getUrl() ;

            message = InitNewsMessage.initNewsMessage(toUserName, fromUserName, title, desc, picUrl, url);

        }
        return message;
    }

}
```


Overlapping Code:
```
ice
public class PassiveReplyServiceImpl implements PassiveReplyService {
@Autowired
private KeyWordMapper keyWordMapper;
@Autowired
private TextMessageMapper textMessageMapper;
@Autowired
private ImageMessageMapper imageMessageMapper;
@Autowired
private MusicMessageMapper musicMessageMapper;
@Autowired
private VideoMessageMapper videoMessageMapper;
@Autowired
private NewsMessageMapper newsMessageMapper;
@Autowired
private VoiceMessageMapper voiceMessageMapper;
@Override
public String selectByKeyWord(String fromUserName, String toUserName, String content) {
String message = null;
// 需要回复什么类型的消息
QueryWrapper<KeyWord> query = Wrappers.query();
query.select("type").in("keyword", content);
KeyWord keyWord = keyWordMapper.selectOne(query);
if (keyWord == null){
message = ErrorMessage.errorMessage(toUserName, fromUserName);
return message;
}
// 获取关键字对应的类型
String type = keyWord.getType();
if (type.equals(Const.MESSAGE_TEXT)){
// TODO 要回复文本类型的
QueryWrapper<TextMessage> queryText = Wrappers.query();
queryText.select("content").in("keyword", content);
String textContent = textMessageMapper.selectOne(queryText).getContent();
message = InitTextMessage.initTextMessage(toUserName, fromUserName, textContent);
}else if (type.equals(Const.MESSAGE_IMAGE)){
// 要回复图片类型的
QueryWrapper<Image> queryImage = Wrappers.query();
queryImage.select("media_id").in("keyword", content);
String mediaId = imageMessageMapper.selectOne(queryImage).getMediaId();
message = InitImageMessage.initImageMessage(toUserName, fromUserName, mediaId);
}else if (type.equals(Const.MESSAGE_VOICE)){
// 语音
QueryWrapper queryVoice = Wrappers.query();
queryVoice.select("media_id").in("keyword", content);
String mediaId = voiceMessageMapper.selectOne(queryVoice).getMediaId();
message = InitVoiceMessage.initVoiceMessage(toUserName, fromUserName, mediaId);
}else if (type.equals(Const.MESSAGE_VIDEO)){
// 视频
QueryWrapper<Video> queryVideo = Wrappers.query();
queryVideo.select("title", "media_id", "description").in("keyword", content);
Video video = videoMessageMapper.selectOn
```
<Overlap Ratio: 0.9917755200774069>

---

--- 15 --
Question ID: 88bd29995ec17f435dcc1e8ee672c8a09d9dbfc0_0
Original Code:
```
public class DummySSLServerSocketFactoryTest {
    @Test
    public void testKeyStore() throws KeyStoreException {
        DummySSLServerSocketFactory factory = new DummySSLServerSocketFactory();
        KeyStore ks = factory.getKeyStore();
        assertThat(ks.containsAlias("greenmail")).isTrue();
    }
}
```


Overlapping Code:
```
c class DummySSLServerSocketFactoryTest {
@Test
public void testKeyStore() throws KeyStoreException {
DummySSLServerSocketFactory factory = new DummySSLServerSocketFactory();
KeyStore ks = factory.getKeyStore();
assertThat(ks.containsAlias("greenmail")
```
<Overlap Ratio: 0.9264705882352942>

---

--- 16 --
Question ID: d435873e6a99c0887e0e3314e1e98a372d5792a7_0
Original Code:
```
public class AtomicsPatchToolsTest extends BaseTest {

    @Test
    public void testAtomicPatchTools(Method method) {
        String methodName = method.getName();
        String atomicName1 = methodName + 1;
        String atomicName2 = methodName + 2;
        String atomicName3 = methodName + 3;

        clientAPI.getIgnite().atomicLong(atomicName1, 1, true);
        clientAPI.getIgnite().atomicLong(atomicName2, 1, true);
        clientAPI.getIgnite().atomicLong(atomicName3, 1, true);

        controller = new Controller(clientAPI.getIgnite(),
                () -> Stream.of(atomicName1, atomicName2, atomicName3).collect(Collectors.toList()));

        controller.serializeDataToAvro(source.getPath());

        PatchContext context = new PatchContext(source, destination);
        context.prepare();

        Map<String, Long> map = new HashMap<>();
        map.put(atomicName1, (long) 1);
        map.put(atomicName2, (long) 1);
        map.put(atomicName3, (long) 1);
        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);

        TransformAction<TransformAtomicsOutput> action = new SelectAtomicsAction.Builder()
                .context(context)
                .from(source.getPath().toString())
                .build();
        TransformAction<TransformAtomicsOutput> duplicatedAtomicAction = new MapAtomicsAction.Builder()
                .action(action)
                .map(row -> {
                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);
                    return Row.fromRow(row)
                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME, atomicName + 1)
                            .build();
                }).build();

        action = new MapAtomicsAction.Builder()
                .action(action)
                .map(row -> {
                    String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);
                    long val = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME);
                    if (atomicName1.equals(atomicName)) {
                        val = 2;
                        map.put(atomicName, val);
                    }
                    return Row.fromRow(row)
                            .withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME, val)
                            .build();
                }).build();

        action = new MergeRowsAtomicsAction(action, duplicatedAtomicAction);
        new AtomicsWriter(action).writeTo(destination.getPath().toString());

        context.getPipeline().run().waitUntilFinish();

        controller.deserializeDataFromAvro(destination.getPath());

        long atomicName1Val = clientAPI.getIgnite().atomicLong(atomicName1, 1, false).get();
        Assert.assertEquals(atomicName1Val, 2);

        map.put(atomicName1 + 1, (long) 1);
        map.put(atomicName2 + 1, (long) 1);
        map.put(atomicName3 + 1, (long) 1);

        clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);
    }
}
```


Overlapping Code:
```
sPatchToolsTest extends BaseTest {
@Test
public void testAtomicPatchTools(Method method) {
String methodName = method.getName();
String atomicName1 = methodName + 1;
String atomicName2 = methodName + 2;
String atomicName3 = methodName + 3;
clientAPI.getIgnite().atomicLong(atomicName1, 1, true);
clientAPI.getIgnite().atomicLong(atomicName2, 1, true);
clientAPI.getIgnite().atomicLong(atomicName3, 1, true);
controller = new Controller(clientAPI.getIgnite(),
() -> Stream.of(atomicName1, atomicName2, atomicName3).collect(Collectors.toList()));
controller.serializeDataToAvro(source.getPath());
PatchContext context = new PatchContext(source, destination);
context.prepare();
Map<String, Long> map = new HashMap<>();
map.put(atomicName1, (long) 1);
map.put(atomicName2, (long) 1);
map.put(atomicName3, (long) 1);
clientAPI.clearIgniteAndCheckIgniteIsEmpty(map);
TransformAction<TransformAtomicsOutput> action = new SelectAtomicsAction.Builder()
.context(context)
.from(source.getPath().toString())
.build();
TransformAction<TransformAtomicsOutput> duplicatedAtomicAction = new MapAtomicsAction.Builder()
.action(action)
.map(row -> {
String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);
return Row.fromRow(row)
.withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME, atomicName + 1)
.build();
}).build();
action = new MapAtomicsAction.Builder()
.action(action)
.map(row -> {
String atomicName = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_NAME_FIELD_NAME);
long val = row.getValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME);
if (atomicName1.equals(atomicName)) {
val = 2;
map.put(atomicName, val);
}
return Row.fromRow(row)
.withFieldValue(FieldNames.IGNITE_ATOMIC_LONG_VALUE_FIELD_NAME, val)
.build();
}).build();
action = new MergeRowsAtomicsAction(action, du
```
<Overlap Ratio: 0.970873786407767>

---

--- 17 --
Question ID: c71602557e32261ee53751d465f43707fce0f63e_0
Original Code:
```
public class ListModifiedIndexEntriesCommand extends GitCommand {

    private final File[] roots;
    private final ProgressMonitor monitor;
    private final FileListener listener;
    private final Set<File> files;

    public ListModifiedIndexEntriesCommand (Repository repository, GitClassFactory gitFactory, File[] roots, ProgressMonitor monitor, FileListener listener) {
        super(repository, gitFactory, monitor);
        this.roots = roots;
        this.monitor = monitor;
        this.listener = listener;
        this.files = new HashSet<File>();
    }

    @Override
    protected void run () throws GitException {
        Repository repository = getRepository();
        try {
            DirCache cache = repository.readDirCache();
            try {
                String workTreePath = repository.getWorkTree().getAbsolutePath();
                Collection<PathFilter> pathFilters = Utils.getPathFilters(repository.getWorkTree(), roots);
                TreeWalk treeWalk = new TreeWalk(repository);
                if (!pathFilters.isEmpty()) {
                    treeWalk.setFilter(PathFilterGroup.create(pathFilters));
                }
                treeWalk.setRecursive(true);
                treeWalk.reset();
                ObjectId headId = repository.resolve(Constants.HEAD);
                if (headId != null) {
                    treeWalk.addTree(new RevWalk(repository).parseTree(headId));
                } else {
                    treeWalk.addTree(new EmptyTreeIterator());
                }
                // Index
                treeWalk.addTree(new DirCacheIterator(cache));
                final int T_HEAD = 0;
                final int T_INDEX = 1;
                while (treeWalk.next() && !monitor.isCanceled()) {
                    String path = treeWalk.getPathString();
                    File file = new File(workTreePath + File.separator + path);
                    int mHead = treeWalk.getRawMode(T_HEAD);
                    int mIndex = treeWalk.getRawMode(T_INDEX);
                    if (mHead != mIndex || !treeWalk.idEqual(T_HEAD, T_INDEX)) {
                        files.add(file);
                        listener.notifyFile(file, path);
                    }
                }
            } finally {
                cache.unlock();
            }
        } catch (CorruptObjectException ex) {
            throw new GitException(ex);
        } catch (IOException ex) {
            throw new GitException(ex);
        }
    }

    @Override
    protected String getCommandDescription () {
        StringBuilder sb = new StringBuilder("git status"); //NOI18N
        for (File root : roots) {
            sb.append(" ").append(root.getAbsolutePath());
        }
        return sb.toString();
    }

    public File[] getFiles () {
        return files.toArray(new File[files.size()]);
    }
}
```


Overlapping Code:
```
exEntriesCommand extends GitCommand {
private final File[] roots;
private final ProgressMonitor monitor;
private final FileListener listener;
private final Set<File> files;
public ListModifiedIndexEntriesCommand (Repository repository, GitClassFactory gitFactory, File[] roots, ProgressMonitor monitor, FileListener listener) {
super(repository, gitFactory, monitor);
this.roots = roots;
this.monitor = monitor;
this.listener = listener;
this.files = new HashSet<File>();
}
@Override
protected void run () throws GitException {
Repository repository = getRepository();
try {
DirCache cache = repository.readDirCache();
try {
String workTreePath = repository.getWorkTree().getAbsolutePath();
Collection<PathFilter> pathFilters = Utils.getPathFilters(repository.getWorkTree(), roots);
TreeWalk treeWalk = new TreeWalk(repository);
if (!pathFilters.isEmpty()) {
treeWalk.setFilter(PathFilterGroup.create(pathFilters));
}
treeWalk.setRecursive(true);
treeWalk.reset();
ObjectId headId = repository.resolve(Constants.HEAD);
if (headId != null) {
treeWalk.addTree(new RevWalk(repository).parseTree(headId));
} else {
treeWalk.addTree(new EmptyTreeIterator());
}
// Index
treeWalk.addTree(new DirCacheIterator(cache));
final int T_HEAD = 0;
final int T_INDEX = 1;
while (treeWalk.next() && !monitor.isCanceled()) {
String path = treeWalk.getPathString();
File file = new File(workTreePath + File.separator + path);
int mHead = treeWalk.getRawMode(T_HEAD);
int mIndex = treeWalk.getRawMode(T_INDEX);
if (mHead != mIndex || !treeWalk.idEqual(T_HEAD, T_INDEX)) {
files.add(file);
listener.notifyFile(file, path);
}
}
} finally {
cache.unlock();
}
} catch (CorruptObjectException ex) {
throw new GitException(ex);
} catch (IOException ex) {
throw new GitException(ex);
}

```
<Overlap Ratio: 0.9837898267188373>

---

--- 18 --
Question ID: 425452f7137aa855e46a387db6bb1411fe4a3107_0
Original Code:
```
public final class JsonWriter {
  public static final Charset UTF_8 = Charset.forName("UTF-8");

  static <T> int sizeInBytes(Writer<T> writer, List<T> value) {
    int length = value.size();
    int sizeInBytes = 2; // []
    if (length > 1) sizeInBytes += length - 1; // comma to join elements
    for (int i = 0; i < length; i++) {
      sizeInBytes += writer.sizeInBytes(value.get(i));
    }
    return sizeInBytes;
  }

  /** Inability to encode is a programming bug. */
  public static <T> byte[] write(Writer<T> writer, T value) {
    byte[] result = new byte[writer.sizeInBytes(value)];
    WriteBuffer b = WriteBuffer.wrap(result);
    try {
      writer.write(value, b);
    } catch (RuntimeException e) {
      int lengthWritten = result.length;
      for (int i = 0; i < result.length; i++) {
        if (result[i] == 0) {
          lengthWritten = i;
          break;
        }
      }

      // Don't use value directly in the message, as its toString might be implemented using this
      // method. If that's the case, we'd stack overflow. Instead, emit what we've written so far.
      String message =
          format(
              "Bug found using %s to write %s as json. Wrote %s/%s bytes: %s",
              writer.getClass().getSimpleName(),
              value.getClass().getSimpleName(),
              lengthWritten,
              result.length,
              new String(result, 0, lengthWritten, UTF_8));
      throw Platform.get().assertionError(message, e);
    }
    return result;
  }

  public static <T> byte[] writeList(Writer<T> writer, List<T> value) {
    if (value.isEmpty()) return new byte[] {'[', ']'};
    byte[] result = new byte[sizeInBytes(writer, value)];
    writeList(writer, value, WriteBuffer.wrap(result));
    return result;
  }

  public static <T> int writeList(Writer<T> writer, List<T> value, byte[] out,
      int pos) {
    if (value.isEmpty()) {
      out[pos++] = '[';
      out[pos++] = ']';
      return 2;
    }
    int initialPos = pos;
    WriteBuffer result = WriteBuffer.wrap(out, pos);
    writeList(writer, value, result);
    return result.pos() - initialPos;
  }

  public static <T> void writeList(Writer<T> writer, List<T> value, WriteBuffer b) {
    b.writeByte('[');
    for (int i = 0, length = value.size(); i < length; ) {
      writer.write(value.get(i++), b);
      if (i < length) b.writeByte(',');
    }
    b.writeByte(']');
  }
}
```


Overlapping Code:
```
 {
public static final Charset UTF_8 = Charset.forName("UTF-8");
static <T> int sizeInBytes(Writer<T> writer, List<T> value) {
int length = value.size();
int sizeInBytes = 2; // []
if (length > 1) sizeInBytes += length - 1; // comma to join elements
for (int i = 0; i < length; i++) {
sizeInBytes += writer.sizeInBytes(value.get(i));
}
return sizeInBytes;
}
/** Inability to encode is a programming bug. */
public static <T> byte[] write(Writer<T> writer, T value) {
byte[] result = new byte[writer.sizeInBytes(value)];
WriteBuffer b = WriteBuffer.wrap(result);
try {
writer.write(value, b);
} catch (RuntimeException e) {
int lengthWritten = result.length;
for (int i = 0; i < result.length; i++) {
if (result[i] == 0) {
lengthWritten = i;
break;
}
}
// Don't use value directly in the message, as its toString might be implemented using this
// method. If that's the case, we'd stack overflow. Instead, emit what we've written so far.
String message =
format(
"Bug found using %s to write %s as json. Wrote %s/%s bytes: %s",
writer.getClass().getSimpleName(),
value.getClass().getSimpleName(),
lengthWritten,
result.length,
new String(result, 0, lengthWritten, UTF_8));
throw Platform.get().assertionError(message, e);
}
return result;
}
public static <T> byte[] writeList(Writer<T> writer, List<T> value) {
if (value.isEmpty()) return new byte[] {'[', ']'};
byte[] result = new byte[sizeInBytes(writer, value)];
writeList(writer, value, WriteBuffer.wrap(result));
return result;
}
public static <T> int writeList(Writer<T> writer, List<T> value, byte[] out,
int pos) {
if (value.isEmpty()) {
out[pos++] = '[';
out[pos++] = ']';
return 2;
}
int initialPos = pos;
WriteBuffer result = WriteBuffer.wrap(out, pos);
writeList(writer, value, result);
return result.pos() - initialPos;
}
public static <T> void writeList(Writer<T> writer, List<T> value, WriteBuffer b) {
b.writeByte('[');
for (int i = 0, length = value.size(); i < length; ) {
writer.write(value.get(i++), b);
if (i < length) b.writeByte(',');
}
b.writeByte(']');
}

```
<Overlap Ratio: 0.985429820301117>

---

--- 19 --
Question ID: d7f21d38f3dbc9b1d4715a257c440a38a14eb58f_0
Original Code:
```
@CheckReturnValue
public class ToInteger extends Function {

  public ToInteger() {
    super(eCategory.STRING_OPERATORS, "TO_INTEGER", "TO_INTEGER(x) converts x to an integer.");
  }

  @Override
  public BoxedType<?> evaluate(List<BoxedType<?>> parameters) {

    Preconditions.checkArgument(parameters.size() == 1, "TO_INTEGER takes exactly one parameter.");
    Preconditions.checkArgument(parameters.get(0).isNumber(), "%s should be a number",
        parameters.get(0));

    return box(parameters.get(0).asBigInteger());
  }
}
```


Overlapping Code:
```
nteger extends Function {
public ToInteger() {
super(eCategory.STRING_OPERATORS, "TO_INTEGER", "TO_INTEGER(x) converts x to an integer.");
}
@Override
public BoxedType<?> evaluate(List<BoxedType<?>> parameters) {
Preconditions.checkArgument(parameters.size() == 1, "TO_INTEGER takes exactly one parameter.");
Preconditions.checkArgument(parameters.get(0).isNumber(), "%s should be a number",
parameters.get(0));
return box(parameters.get(0).asBigInte
```
<Overlap Ratio: 0.9090909090909091>

---

--- 20 --
Question ID: 70c6601e007d9db9c21e9df59dd84045c38a8d37_0
Original Code:
```
public class DBConnection {
	
	public static Connection CreateConnection() {
		Connection con = null;
		try {
			Class.forName("org.mariadb.jdbc.Driver");
			
			con = DriverManager.getConnection("jdbc:mariadb://localhost:3306/java?user=root&password=password");
			Statement st=con.createStatement();
			System.out.println("connection succeded");
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("connection failed");

		}
		return con;
	}
	

}
```


Overlapping Code:
```
blic class DBConnection {

public static Connection CreateConnection() {
Connection con = null;
try {
Class.forName("org.mariadb.jdbc.Driver");

con = DriverManager.getConnection("jdbc:mariadb://localhost:3306/java?user=root&password=password");
Statement st=con.createStatement();
System.out.println("connection succeded");
} catch (ClassNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
catch (SQLException e) {
// TODO Auto-generated catch block
e.printStackTrace();
System.out.println("connection failed");
}
return con;
```
<Overlap Ratio: 0.9875444839857651>

---

--- 21 --
Question ID: 09d5b3e0819fc3fb245e2e3ec06662e5e99fb02a_0
Original Code:
```
public class AudioPlayer02 extends JFrame {
   private static final long serialVersionUID = 1L;
   
   AudioFormat audioFormat;
   AudioInputStream audioInputStream;
   SourceDataLine sourceDataLine;
   boolean stopPlayback = false;
   boolean terminatePlayback = false;
   final JButton stopBtn = new JButton ("Stop");
   final JButton resumeBtn = new JButton ("Resume");
   final JButton playBtn = new JButton ("Play");
   final JTextField textField = new JTextField ("A.wav");

   public static void main (String args[]) {
      new AudioPlayer02();
   }// end main

   // -------------------------------------------//

   public AudioPlayer02() {// constructor

      stopBtn.setEnabled (false);
      resumeBtn.setEnabled (false);
      playBtn.setEnabled (true);

      // Instantiate and register action listeners
      // on the Play and Stop buttons.
      playBtn.addActionListener (new ActionListener() {
         public void actionPerformed (ActionEvent e) {
            stopBtn.setEnabled (true);
            resumeBtn.setEnabled (false);
            playBtn.setEnabled (false);
            playAudio();// Play the file
         }// end actionPerformed
      }// end ActionListener
         );// end addActionListener()

      stopBtn.addActionListener (new ActionListener() {
         public void actionPerformed (ActionEvent e) {
            // Terminate playback before EOF
            stopPlayback = true;
            resumeBtn.setEnabled (true);
         }// end actionPerformed
      }// end ActionListener
         );// end addActionListener()

      resumeBtn.addActionListener (new ActionListener() {
         public void actionPerformed (ActionEvent e) {
            stopPlayback = false;
            resumeBtn.setEnabled (false);
         }// end actionPerformed
      }// end ActionListener
         );// end addActionListener()

      getContentPane().add (playBtn, "West");
      getContentPane().add (stopBtn, "East");
      getContentPane().add (resumeBtn);
      getContentPane().add (textField, "North");

      setDefaultCloseOperation (EXIT_ON_CLOSE);
      setSize (250, 70);
      setVisible (true);
   }// end constructor

   // -------------------------------------------//

   // This method plays back audio data from an
   // audio file whose name is specified in the
   // text field.
   private void playAudio() {
      try {
         File soundFile = new File (textField.getText());
         audioInputStream = AudioSystem.getAudioInputStream (soundFile);
         audioFormat = audioInputStream.getFormat();
         System.out.println (audioFormat);

         DataLine.Info dataLineInfo =
            new DataLine.Info (SourceDataLine.class, audioFormat);

         sourceDataLine = (SourceDataLine)AudioSystem.getLine (dataLineInfo);

         // Create a thread to play back the data and
         // start it running. It will run until the
         // end of file, or the Stop button is
         // clicked, whichever occurs first.
         // Because of the data buffers involved,
         // there will normally be a delay between
         // the click on the Stop button and the
         // actual termination of playback.
         new PlayThread().start();
      }
      catch (Exception e) {
         e.printStackTrace();
         System.exit (0);
      }// end catch
   }// end playAudio

   // =============================================//
   // Inner class to play back the data from the
   // audio file.
   class PlayThread extends Thread {
      int bufferSize = 1024;
      byte tempBuffer[] = new byte[bufferSize];

      public void run() {
         // int ii = 0;
         setPriority (MAX_PRIORITY);
         try {
            sourceDataLine.open (audioFormat, bufferSize);
            sourceDataLine.start();

            int cnt;
            // Keep looping until the input read method
            // returns -1 for empty stream or the
            // user clicks the Stop button causing
            // stopPlayback to switch from false to
            // true.
            while ((cnt =
               audioInputStream.read (tempBuffer, 0, tempBuffer.length)) != -1
            && terminatePlayback == false) {
               if (cnt > 0) {
                  // Write data to the internal buffer of
                  // the data line where it will be
                  // delivered to the speaker.
                  while (stopPlayback) {
                     try {
                        sleep (10);
                        // System.out.println(ii++);
                     }
                     catch (Exception eee) {
                     }
                  }
                  sourceDataLine.write (tempBuffer, 0, cnt);
               }// end if
            }// end while
            // Block and wait for internal buffer of the
            // data line to empty.
            sourceDataLine.drain();
            sourceDataLine.close();

            // Prepare to playback another file
            stopBtn.setEnabled (false);
            playBtn.setEnabled (true);
            stopPlayback = false;
         }
         catch (Exception e) {
            e.printStackTrace();
            System.exit (0);
         }// end catch
      }// end run
   }// end inner class PlayThread
   // ===================================//

}
```


Overlapping Code:
```
oPlayer02 extends JFrame {
private static final long serialVersionUID = 1L;

AudioFormat audioFormat;
AudioInputStream audioInputStream;
SourceDataLine sourceDataLine;
boolean stopPlayback = false;
boolean terminatePlayback = false;
final JButton stopBtn = new JButton ("Stop");
final JButton resumeBtn = new JButton ("Resume");
final JButton playBtn = new JButton ("Play");
final JTextField textField = new JTextField ("A.wav");
public static void main (String args[]) {
new AudioPlayer02();
}// end main
// -------------------------------------------//
public AudioPlayer02() {// constructor
stopBtn.setEnabled (false);
resumeBtn.setEnabled (false);
playBtn.setEnabled (true);
// Instantiate and register action listeners
// on the Play and Stop buttons.
playBtn.addActionListener (new ActionListener() {
public void actionPerformed (ActionEvent e) {
stopBtn.setEnabled (true);
resumeBtn.setEnabled (false);
playBtn.setEnabled (false);
playAudio();// Play the file
}// end actionPerformed
}// end ActionListener
);// end addActionListener()
stopBtn.addActionListener (new ActionListener() {
public void actionPerformed (ActionEvent e) {
// Terminate playback before EOF
stopPlayback = true;
resumeBtn.setEnabled (true);
}// end actionPerformed
}// end ActionListener
);// end addActionListener()
resumeBtn.addActionListener (new ActionListener() {
public void actionPerformed (ActionEvent e) {
stopPlayback = false;
resumeBtn.setEnabled (false);
}// end actionPerformed
}// end ActionListener
);// end addActionListener()
getContentPane().add (playBtn, "West");
getContentPane().add (stopBtn, "East");
getContentPane().add (resumeBtn);
getContentPane().add (textField, "North");
setDefaultCloseOperation (EXIT_ON_CLOSE);
setSize (250, 70);
setVisible (true);
}// end constructor
// -------------------------------------------//
// This method plays back audio data from an
// audio file whose name is specified in the
// text field.
private void playAudio() {
try {
File soundFile = new File (textField.getText());
audioInputStream = AudioSystem.getAudioInputStream
```
<Overlap Ratio: 0.9856938483547926>

---

--- 22 --
Question ID: 1f58d128d2c01cbdd0a61b6d9c611c7ceb60633e_0
Original Code:
```
@Configuration
@Import(SolaceBinderHealthIndicatorConfiguration.class)
@EnableConfigurationProperties({ SolaceExtendedBindingProperties.class })
public class SolaceMessageChannelBinderConfiguration {
	private final JCSMPProperties jcsmpProperties;
	private final SolaceExtendedBindingProperties solaceExtendedBindingProperties;
	private final SolaceSessionEventHandler solaceSessionEventHandler;

	private JCSMPSession jcsmpSession;
	private Context context;

	private static final Log logger = LogFactory.getLog(SolaceMessageChannelBinderConfiguration.class);

	public SolaceMessageChannelBinderConfiguration(JCSMPProperties jcsmpProperties,
												   SolaceExtendedBindingProperties solaceExtendedBindingProperties,
												   @Nullable SolaceSessionEventHandler solaceSessionEventHandler) {
		this.jcsmpProperties = jcsmpProperties;
		this.solaceExtendedBindingProperties = solaceExtendedBindingProperties;
		this.solaceSessionEventHandler = solaceSessionEventHandler;
	}

	@PostConstruct
	private void initSession() throws JCSMPException {
		JCSMPProperties jcsmpProperties = (JCSMPProperties) this.jcsmpProperties.clone();
		jcsmpProperties.setProperty(JCSMPProperties.CLIENT_INFO_PROVIDER, new SolaceBinderClientInfoProvider());
		try {
			if (solaceSessionEventHandler != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("Registering Solace Session Event handler on session");
				}
				context = JCSMPFactory.onlyInstance().createContext(new ContextProperties());
				jcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties, context, solaceSessionEventHandler);
			} else {
				jcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties);
			}
			logger.info(String.format("Connecting JCSMP session %s", jcsmpSession.getSessionName()));
			jcsmpSession.connect();
			if (solaceSessionEventHandler != null) {
				solaceSessionEventHandler.connected();
			}
		} catch (Exception e) {
			if (context != null) {
				context.destroy();
			}
			throw e;
		}
	}

	@Bean
	SolaceMessageChannelBinder solaceMessageChannelBinder() {
		SolaceMessageChannelBinder binder = new SolaceMessageChannelBinder(jcsmpSession, context, provisioningProvider());
		binder.setExtendedBindingProperties(solaceExtendedBindingProperties);
		return binder;
	}

	@Bean
	SolaceQueueProvisioner provisioningProvider() {
		return new SolaceQueueProvisioner(jcsmpSession);
	}

}
```


Overlapping Code:
```
torConfiguration.class)
@EnableConfigurationProperties({ SolaceExtendedBindingProperties.class })
public class SolaceMessageChannelBinderConfiguration {
private final JCSMPProperties jcsmpProperties;
private final SolaceExtendedBindingProperties solaceExtendedBindingProperties;
private final SolaceSessionEventHandler solaceSessionEventHandler;
private JCSMPSession jcsmpSession;
private Context context;
private static final Log logger = LogFactory.getLog(SolaceMessageChannelBinderConfiguration.class);
public SolaceMessageChannelBinderConfiguration(JCSMPProperties jcsmpProperties,
SolaceExtendedBindingProperties solaceExtendedBindingProperties,
@Nullable SolaceSessionEventHandler solaceSessionEventHandler) {
this.jcsmpProperties = jcsmpProperties;
this.solaceExtendedBindingProperties = solaceExtendedBindingProperties;
this.solaceSessionEventHandler = solaceSessionEventHandler;
}
@PostConstruct
private void initSession() throws JCSMPException {
JCSMPProperties jcsmpProperties = (JCSMPProperties) this.jcsmpProperties.clone();
jcsmpProperties.setProperty(JCSMPProperties.CLIENT_INFO_PROVIDER, new SolaceBinderClientInfoProvider());
try {
if (solaceSessionEventHandler != null) {
if (logger.isDebugEnabled()) {
logger.debug("Registering Solace Session Event handler on session");
}
context = JCSMPFactory.onlyInstance().createContext(new ContextProperties());
jcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties, context, solaceSessionEventHandler);
} else {
jcsmpSession = JCSMPFactory.onlyInstance().createSession(jcsmpProperties);
}
logger.info(String.format("Connecting JCSMP session %s", jcsmpSession.getSessionName()));
jcsmpSession.connect();
if (solaceSessionEventHandler != null) {
solaceSessionEventHandler.connected();
}
} catch (Exception e) {
if (context != null) {
context.destroy();
}
throw e;
}
}
@Bean
SolaceMessageChannelBinder solaceMessageChannelBinder() {
SolaceMessageChannelBinder binder = new SolaceMessageChannelBinder(jcsmpSession, context, provisioningProvider());
binder.setExtendedBindingProperties(solaceExtendedBindingProperties);
return binder;
}
@Bean
SolaceQueueProvisioner provisioningProvider() {
return new SolaceQueueProvisioner(jcsmpSessio
```
<Overlap Ratio: 0.9761378700839594>

---

--- 23 --
Question ID: 6c6c9df46325cc266a0f0f402a2e97f98e4bc02e_0
Original Code:
```
public abstract class RefPtgBase extends OperandPtg {

	/**
	 * YK: subclasses of RefPtgBase are used by the FormulaParser and FormulaEvaluator accross HSSF and XSSF.
	 * The bit mask should accommodate the maximum number of avaiable columns, i.e. 0x3FFF.
	 *
	 * @see org.apache.poi.ss.SpreadsheetVersion
	 */
	private static final BitField column = BitFieldFactory.getInstance(0x3FFF);

	private static final BitField rowRelative = BitFieldFactory.getInstance(0x8000);
	private static final BitField colRelative = BitFieldFactory.getInstance(0x4000);


	/** The row index - zero based unsigned 16 bit value */
	private int field_1_row;
	/**
	 * Field 2 - lower 8 bits is the zero based unsigned byte column index - bit
	 * 16 - isRowRelative - bit 15 - isColumnRelative
	 */
	private int field_2_col;

	protected RefPtgBase() {}

	protected RefPtgBase(RefPtgBase other) {
		super(other);
		field_1_row = other.field_1_row;
		field_2_col = other.field_2_col;
	}

	protected RefPtgBase(CellReference c) {
		setRow(c.getRow());
		setColumn(c.getCol());
		setColRelative(!c.isColAbsolute());
		setRowRelative(!c.isRowAbsolute());
	}

	protected final void readCoordinates(LittleEndianInput in) {
		field_1_row = in.readUShort();
		field_2_col = in.readUShort();
	}

	protected final void writeCoordinates(LittleEndianOutput out) {
		out.writeShort(field_1_row);
		out.writeShort(field_2_col);
	}

	public final void setRow(int rowIndex) {
		field_1_row = rowIndex;
	}

	/**
	 * @return the row number as an int
	 */
	public final int getRow() {
		return field_1_row;
	}

	public final boolean isRowRelative() {
		return rowRelative.isSet(field_2_col);
	}

	public final void setRowRelative(boolean rel) {
		field_2_col = rowRelative.setBoolean(field_2_col, rel);
	}

	public final boolean isColRelative() {
		return colRelative.isSet(field_2_col);
	}

	public final void setColRelative(boolean rel) {
		field_2_col = colRelative.setBoolean(field_2_col, rel);
	}

	public final void setColumn(int col) {
		field_2_col = column.setValue(field_2_col, col);
	}

	public final int getColumn() {
		return column.getValue(field_2_col);
	}

	protected String formatReferenceAsString() {
		// Only make cell references as needed. Memory is an issue
		CellReference cr = new CellReference(getRow(), getColumn(), !isRowRelative(), !isColRelative());
		return cr.formatAsString();
	}

	@Override
    public final byte getDefaultOperandClass() {
		return Ptg.CLASS_REF;
	}

	@Override
	public Map<String, Supplier<?>> getGenericProperties() {
		return GenericRecordUtil.getGenericProperties(
			"row", this::getRow,
			"rowRelative", this::isRowRelative,
			"column", this::getColumn,
			"colRelative", this::isColRelative,
			"formatReference", this::formatReferenceAsString
		);
	}
}
```


Overlapping Code:
```
Base extends OperandPtg {
/**
* YK: subclasses of RefPtgBase are used by the FormulaParser and FormulaEvaluator accross HSSF and XSSF.
* The bit mask should accommodate the maximum number of avaiable columns, i.e. 0x3FFF.
*
* @see org.apache.poi.ss.SpreadsheetVersion
*/
private static final BitField column = BitFieldFactory.getInstance(0x3FFF);
private static final BitField rowRelative = BitFieldFactory.getInstance(0x8000);
private static final BitField colRelative = BitFieldFactory.getInstance(0x4000);
/** The row index - zero based unsigned 16 bit value */
private int field_1_row;
/**
* Field 2 - lower 8 bits is the zero based unsigned byte column index - bit
* 16 - isRowRelative - bit 15 - isColumnRelative
*/
private int field_2_col;
protected RefPtgBase() {}
protected RefPtgBase(RefPtgBase other) {
super(other);
field_1_row = other.field_1_row;
field_2_col = other.field_2_col;
}
protected RefPtgBase(CellReference c) {
setRow(c.getRow());
setColumn(c.getCol());
setColRelative(!c.isColAbsolute());
setRowRelative(!c.isRowAbsolute());
}
protected final void readCoordinates(LittleEndianInput in) {
field_1_row = in.readUShort();
field_2_col = in.readUShort();
}
protected final void writeCoordinates(LittleEndianOutput out) {
out.writeShort(field_1_row);
out.writeShort(field_2_col);
}
public final void setRow(int rowIndex) {
field_1_row = rowIndex;
}
/**
* @return the row number as an int
*/
public final int getRow() {
return field_1_row;
}
public final boolean isRowRelative() {
return rowRelative.isSet(field_2_col);
}
public final void setRowRelative(boolean rel) {
field_2_col = rowRelative.setBoolean(field_2_col, rel);
}
public final boolean isColRelative() {
return colRelative.isSet(field_2_col);
}
public final void setColRelative(boolean rel) {
field_2_col = colRelative.setBoolean(field_2_col, rel);
}
public final void setColumn(int col) {
field_2_col = column.setValue(field_2_col, col);
}
public final int getColumn() {
return column.getValue(field_2_col);
}
protected String formatReferenceAsString() {
// Only make cell references as needed. Memory is an issue
CellReference cr = new CellReference(getRow(), getColumn(), !isRowRelative(), !isColRelative());
return cr.formatAsString();
}
@Override
public final byte getDefaultOperandClass() {
return Ptg.CLASS_REF;
}
@Overr
```
<Overlap Ratio: 0.9746728577458843>

---

--- 24 --
Question ID: 8583e4992664b245cbdaf2549ac75cb70f5efc47_0
Original Code:
```
public class CubeSegmentTupleIterator implements ITupleIterator {

    public static final Logger logger = LoggerFactory.getLogger(CubeSegmentTupleIterator.class);

    public static final int SCAN_CACHE = 1024;

    private final CubeInstance cube;
    private final CubeSegment cubeSeg;
    private final Collection<TblColRef> dimensions;
    private final TupleFilter filter;
    private final Collection<TblColRef> groupBy;
    private final Collection<RowValueDecoder> rowValueDecoders;
    private final StorageContext context;
    private final String tableName;
    private final HTableInterface table;
    private final RowKeyDecoder rowKeyDecoder;
    private final Iterator<HBaseKeyRange> rangeIterator;

    private Scan scan;
    private ResultScanner scanner;
    private Iterator<Result> resultIterator;
    private TupleInfo tupleInfo;
    private Tuple tuple;
    private int scanCount;

    public CubeSegmentTupleIterator(CubeSegment cubeSeg, Collection<HBaseKeyRange> keyRanges, HConnection conn, Collection<TblColRef> dimensions, TupleFilter filter, Collection<TblColRef> groupBy, Collection<RowValueDecoder> rowValueDecoders, StorageContext context) {
        this.cube = cubeSeg.getCubeInstance();
        this.cubeSeg = cubeSeg;
        this.dimensions = dimensions;
        this.filter = filter;
        this.groupBy = groupBy;
        this.rowValueDecoders = rowValueDecoders;
        this.context = context;
        this.tableName = cubeSeg.getStorageLocationIdentifier();
        this.rowKeyDecoder = new RowKeyDecoder(this.cubeSeg);
        this.scanCount = 0;

        try {
            this.table = conn.getTable(tableName);
        } catch (Throwable t) {
            throw new StorageException("Error when open connection to table " + tableName, t);
        }
        this.rangeIterator = keyRanges.iterator();
        scanNextRange();
    }

    @Override
    public void close() {
        closeScanner();
        closeTable();
    }

    private void closeScanner() {
        if (logger.isDebugEnabled() && scan != null) {
            logger.debug("Scan " + scan.toString());
            byte[] metricsBytes = scan.getAttribute(Scan.SCAN_ATTRIBUTES_METRICS_DATA);
            if (metricsBytes != null) {
                ScanMetrics scanMetrics = ProtobufUtil.toScanMetrics(metricsBytes);
                logger.debug("HBase Metrics: " + "count={}, ms={}, bytes={}, remote_bytes={}, regions={}, not_serving_region={}, rpc={}, rpc_retries={}, remote_rpc={}, remote_rpc_retries={}", new Object[] { scanCount, scanMetrics.sumOfMillisSecBetweenNexts, scanMetrics.countOfBytesInResults, scanMetrics.countOfBytesInRemoteResults, scanMetrics.countOfRegions, scanMetrics.countOfNSRE, scanMetrics.countOfRPCcalls, scanMetrics.countOfRPCRetries, scanMetrics.countOfRemoteRPCcalls, scanMetrics.countOfRemoteRPCRetries });
            }
        }
        try {
            if (scanner != null) {
                scanner.close();
                scanner = null;
            }
        } catch (Throwable t) {
            throw new StorageException("Error when close scanner for table " + tableName, t);
        }
    }

    private void closeTable() {
        try {
            if (table != null) {
                table.close();
            }
        } catch (Throwable t) {
            throw new StorageException("Error when close table " + tableName, t);
        }
    }

    @Override
    public boolean hasNext() {
        return rangeIterator.hasNext() || resultIterator.hasNext();
    }

    @Override
    public Tuple next() {
        // get next result from hbase
        Result result = null;
        while (hasNext()) {
            if (resultIterator.hasNext()) {
                result = this.resultIterator.next();
                scanCount++;
                break;
            } else {
                scanNextRange();
            }
        }
        if (result == null) {
            return null;
        }
        // translate result to tuple
        try {
            translateResult(result, this.tuple);
        } catch (IOException e) {
            throw new IllegalStateException("Can't translate result " + result, e);
        }
        return this.tuple;
    }

    private void scanNextRange() {
        if (this.rangeIterator.hasNext()) {
            closeScanner();
            HBaseKeyRange keyRange = this.rangeIterator.next();
            this.tupleInfo = buildTupleInfo(keyRange.getCuboid());
            this.tuple = new Tuple(this.tupleInfo);

            this.resultIterator = doScan(keyRange);
        } else {
            this.resultIterator = Collections.<Result> emptyList().iterator();
        }
    }

    private final Iterator<Result> doScan(HBaseKeyRange keyRange) {

        Iterator<Result> iter = null;
        try {
            scan = buildScan(keyRange);
            applyFuzzyFilter(scan, keyRange);
            logScan(keyRange);

            scanner = ObserverEnabler.scanWithCoprocessorIfBeneficial(cubeSeg, keyRange.getCuboid(), filter, groupBy, rowValueDecoders, context, table, scan);

            iter = scanner.iterator();
        } catch (Throwable t) {
            String msg = MessageFormat.format("Error when scan from lower key {1} to upper key {2} on table {0}.", tableName, Bytes.toString(keyRange.getStartKey()), Bytes.toString(keyRange.getStopKey()));
            throw new StorageException(msg, t);
        }
        return iter;
    }

    private void logScan(HBaseKeyRange keyRange) {
        StringBuilder info = new StringBuilder();
        info.append("\nScan hbase table ").append(tableName).append(": ");
        if (keyRange.getCuboid().requirePostAggregation()) {
            info.append("cuboid require post aggregation, from ");
        } else {
            info.append("cuboid exact match, from ");
        }
        info.append(keyRange.getCuboid().getInputID());
        info.append(" to ");
        info.append(keyRange.getCuboid().getId());
        info.append("\nStart: ");
        info.append(keyRange.getStartKeyAsString());
        info.append("     - ");
        info.append(Bytes.toStringBinary(keyRange.getStartKey()));
        info.append("\nStop:  ");
        info.append(keyRange.getStopKeyAsString());
        info.append(" - ");
        info.append(Bytes.toStringBinary(keyRange.getStopKey()));
        if (this.scan.getFilter() != null) {
            info.append("\nFuzzy: ");
            info.append(keyRange.getFuzzyKeyAsString());
        }
        logger.info(info.toString());
    }

    private Scan buildScan(HBaseKeyRange keyRange) {
        Scan scan = new Scan();
        scan.setCaching(SCAN_CACHE);
        scan.setCacheBlocks(true);
        scan.setAttribute(Scan.SCAN_ATTRIBUTES_METRICS_ENABLE, Bytes.toBytes(Boolean.TRUE));
        for (RowValueDecoder valueDecoder : this.rowValueDecoders) {
            HBaseColumnDesc hbaseColumn = valueDecoder.getHBaseColumn();
            byte[] byteFamily = Bytes.toBytes(hbaseColumn.getColumnFamilyName());
            byte[] byteQualifier = Bytes.toBytes(hbaseColumn.getQualifier());
            scan.addColumn(byteFamily, byteQualifier);
        }
        scan.setStartRow(keyRange.getStartKey());
        scan.setStopRow(keyRange.getStopKey());
        return scan;
    }

    private void applyFuzzyFilter(Scan scan, HBaseKeyRange keyRange) {
        List<Pair<byte[], byte[]>> fuzzyKeys = keyRange.getFuzzyKeys();
        if (fuzzyKeys != null && fuzzyKeys.size() > 0) {
            FuzzyRowFilter rowFilter = new FuzzyRowFilter(fuzzyKeys);

            Filter filter = scan.getFilter();
            if (filter != null) {
                // may have existed InclusiveStopFilter, see buildScan
                FilterList filterList = new FilterList();
                filterList.addFilter(filter);
                filterList.addFilter(rowFilter);
                scan.setFilter(filterList);
            } else {
                scan.setFilter(rowFilter);
            }
        }
    }

    private TupleInfo buildTupleInfo(Cuboid cuboid) {
        TupleInfo info = new TupleInfo();
        int index = 0;
        rowKeyDecoder.setCuboid(cuboid);
        List<TblColRef> rowColumns = rowKeyDecoder.getColumns();
        List<String> colNames = rowKeyDecoder.getNames(context.getAliasMap());
        for (int i = 0; i < rowColumns.size(); i++) {
            TblColRef column = rowColumns.get(i);
            if (!dimensions.contains(column)) {
                continue;
            }
            // add normal column
            info.setField(colNames.get(i), rowColumns.get(i), rowColumns.get(i).getType().getName(), index++);
        }

        // derived columns and filler
        Map<Array<TblColRef>, List<DeriveInfo>> hostToDerivedInfo = cubeSeg.getCubeDesc().getHostToDerivedInfo(rowColumns, null);
        for (Entry<Array<TblColRef>, List<DeriveInfo>> entry : hostToDerivedInfo.entrySet()) {
            TblColRef[] hostCols = entry.getKey().data;
            for (DeriveInfo deriveInfo : entry.getValue()) {
                // mark name for each derived field
                for (TblColRef derivedCol : deriveInfo.columns) {
                    String derivedField = getFieldName(derivedCol, context.getAliasMap());
                    info.setField(derivedField, derivedCol, derivedCol.getType().getName(), index++);
                }
                // add filler
                info.addDerivedColumnFiller(Tuple.newDerivedColumnFiller(rowColumns, hostCols, deriveInfo, info, CubeManager.getInstance(this.cube.getConfig()), cubeSeg));
            }
        }

        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {
            List<String> names = rowValueDecoder.getNames();
            MeasureDesc[] measures = rowValueDecoder.getMeasures();
            for (int i = 0; i < measures.length; i++) {
                String dataType = measures[i].getFunction().getSQLType();
                info.setField(names.get(i), null, dataType, index++);
            }
        }
        return info;
    }

    private String getFieldName(TblColRef column, Map<TblColRef, String> aliasMap) {
        String name = null;
        if (aliasMap != null) {
            name = aliasMap.get(column);
        }
        if (name == null) {
            name = column.getName();
        }
        return name;
    }

    private void translateResult(Result res, Tuple tuple) throws IOException {
        // groups
        byte[] rowkey = res.getRow();
        rowKeyDecoder.decode(rowkey);
        List<TblColRef> columns = rowKeyDecoder.getColumns();
        List<String> dimensionNames = rowKeyDecoder.getNames(context.getAliasMap());
        List<String> dimensionValues = rowKeyDecoder.getValues();
        for (int i = 0; i < dimensionNames.size(); i++) {
            TblColRef column = columns.get(i);
            if (!tuple.hasColumn(column)) {
                continue;
            }
            tuple.setDimensionValue(dimensionNames.get(i), dimensionValues.get(i));
        }

        // derived
        for (IDerivedColumnFiller filler : tupleInfo.getDerivedColumnFillers()) {
            filler.fillDerivedColumns(dimensionValues, tuple);
        }

        // aggregations
        for (RowValueDecoder rowValueDecoder : this.rowValueDecoders) {
            HBaseColumnDesc hbaseColumn = rowValueDecoder.getHBaseColumn();
            String columnFamily = hbaseColumn.getColumnFamilyName();
            String qualifier = hbaseColumn.getQualifier();
            // FIXME: avoidable bytes array creation, why not use res.getValueAsByteBuffer directly?
            byte[] valueBytes = res.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));
            rowValueDecoder.decode(valueBytes);
            List<String> measureNames = rowValueDecoder.getNames();
            Object[] measureValues = rowValueDecoder.getValues();
            BitSet projectionIndex = rowValueDecoder.getProjectionIndex();
            for (int i = projectionIndex.nextSetBit(0); i >= 0; i = projectionIndex.nextSetBit(i + 1)) {
                tuple.setMeasureValue(measureNames.get(i), measureValues[i]);
            }
        }
    }
}
```


Overlapping Code:
```
blic class CubeSegmentTupleIterator implements ITupleIterator {
public static final Logger logger = LoggerFactory.getLogger(CubeSegmentTupleIterator.class);
public static final int SCAN_CACHE = 1024;
private final CubeInstance cube;
private final CubeSegment cubeSeg;
private final Collection<TblColRef> dimensions;
private final TupleFilter filter;
private final Collection<TblColRef> groupBy;
private final Collection<RowValueDecoder> rowValueDecoders;
private final StorageContext context;
private final String tableName;
private final HTableInterface table;
private final RowKeyDecoder rowKeyDecoder;
private final Iterator<HBaseKeyRange> rangeIterator;
private Scan scan;
private ResultScanner scanner;
private Iterator<Result> resultIterator;
private TupleInfo tupleInfo;
private Tuple tuple;
private int scanCount;
public CubeSegmentTupleIterator(CubeSegment cubeSeg, Collection<HBaseKeyRange> keyRanges, HConnection conn, Collection<TblColRef> dimensions, TupleFilter filter, Collection<TblColRef> groupBy, Collection<RowValueDecoder> rowValueDecoders, StorageContext context) {
this.cube = cubeSeg.getCubeInstance();
this.cubeSeg = cubeSeg;
this.dimensions = dimensions;
this.filter = filter;
this.groupBy = groupBy;
this.rowValueDecoders = rowValueDecoders;
this.context = context;
this.tableName = cubeSeg.getStorageLocationIdentifier();
this.rowKeyDecoder = new RowKeyDecoder(this.cubeSeg);
this.scanCount = 0;
try {
this.table = conn.getTable(tableName);
} catch (Throwable t) {
throw new StorageException("Error when open connection to table " + tableName, t);
}
this.rangeIterator = keyRanges.iterator();
scanNextRange();
}
@Override
public void close() {
closeScanner();
closeTable();
}
private void closeScanner() {
if (logger.isDebugEnabled() && scan != null) {
logger.debug("Scan " + scan.toString());
byte[] metricsBytes = scan.getAttribute(Scan.SCAN_ATTRIBUTES_METRICS_DATA);
if (metricsBytes != null) {
ScanMetrics scanMetrics = ProtobufUtil.toScanMetrics(metricsBytes);
logger.debug("HBase Metrics: " + "count={}, ms={}, bytes={}, remote_bytes={}, regions={}, not_serving_region={}, rpc={}, rpc_retries
```
<Overlap Ratio: 0.9860788863109049>

---

--- 25 --
Question ID: 6a1ebeef7e33b35166dde776a778aec860d3c4ab_0
Original Code:
```
@Component("BeaconOwnerMapperV2")
public class BeaconOwnerMapper {

  private final AddressMapper addressMapper;

  @Autowired
  public BeaconOwnerMapper(AddressMapper addressMapper) {
    this.addressMapper = addressMapper;
  }

  public BeaconOwner fromDTO(CreateBeaconOwnerDTO dto) {
    BeaconOwner beaconOwner = new BeaconOwner();

    beaconOwner.setFullName(dto.getFullName());
    beaconOwner.setEmail(dto.getEmail());
    beaconOwner.setTelephoneNumber(dto.getTelephoneNumber());
    beaconOwner.setAlternativeTelephoneNumber(
      dto.getAlternativeTelephoneNumber()
    );
    beaconOwner.setAddress(addressMapper.fromDTO(dto.getAddressDTO()));

    return beaconOwner;
  }

  public BeaconOwnerDTO toDTO(BeaconOwner beaconOwner) {
    return BeaconOwnerDTO
      .builder()
      .id(Objects.requireNonNull(beaconOwner.getId()).unwrap())
      .fullName(beaconOwner.getFullName())
      .email(beaconOwner.getEmail())
      .telephoneNumber(beaconOwner.getTelephoneNumber())
      .alternativeTelephoneNumber(beaconOwner.getAlternativeTelephoneNumber())
      .addressDTO(addressMapper.toDTO(beaconOwner.getAddress()))
      .createdDate(beaconOwner.getCreatedDate())
      .lastModifiedDate(beaconOwner.getLastModifiedDate())
      .beaconId(beaconOwner.getBeaconId().unwrap())
      .build();
  }
}
```


Overlapping Code:
```
aconOwnerMapper {
private final AddressMapper addressMapper;
@Autowired
public BeaconOwnerMapper(AddressMapper addressMapper) {
this.addressMapper = addressMapper;
}
public BeaconOwner fromDTO(CreateBeaconOwnerDTO dto) {
BeaconOwner beaconOwner = new BeaconOwner();
beaconOwner.setFullName(dto.getFullName());
beaconOwner.setEmail(dto.getEmail());
beaconOwner.setTelephoneNumber(dto.getTelephoneNumber());
beaconOwner.setAlternativeTelephoneNumber(
dto.getAlternativeTelephoneNumber()
);
beaconOwner.setAddress(addressMapper.fromDTO(dto.getAddressDTO()));
return beaconOwner;
}
public BeaconOwnerDTO toDTO(BeaconOwner beaconOwner) {
return BeaconOwnerDTO
.builder()
.id(Objects.requireNonNull(beaconOwner.getId()).unwrap())
.fullName(beaconOwner.getFullName())
.email(beaconOwner.getEmail())
.telephoneNumber(beaconOwner.getTelephoneNumber())
.alternativeTelephoneNumber(beaconOwner.getAlternativeTelephoneNumber())
.addressDTO(addressMapper.toDTO(beaconOwner.getAddress()))
.createdDate(beaconOwner.getCreatedDate())
.lastModifiedDate(beaconOwner.getLastModifiedDate())
.beaconId(beaconOwner.getBeac
```
<Overlap Ratio: 0.9329940627650551>

---

--- 26 --
Question ID: f47a90b6e364133e5f5879fad5b6b48cab9927c0_0
Original Code:
```
public class StormEnvironment {

	public static final String BEGIN_DATABASE = ":DB_START";
	public static final String END_DATABASE = ":DB_END";
	public static final String BEGIN_CONVERTERS = ":CONV_START";
	public static final String END_CONVERTERS = ":CONV_END";
	private static final String ENV_FILE = "stormEnv";
	private ProcessorLogger logger;
	private Map<String,DatabaseModel> dbModels = new TreeMap<String,DatabaseModel>();
	private List<ConverterModel> converters = new ArrayList<ConverterModel>();
	private Map<String, ConverterModel> typeMap = new HashMap<String, ConverterModel>();

	StormEnvironment(ProcessorLogger logger) {
		this.logger = logger;
		addBuiltInConverters();
	}

	private void addBuiltInConverters() {
		this.addConverter(new ConverterModel(new BlobConverter()));
		this.addConverter(new ConverterModel(new BooleanConverter()));
		this.addConverter(new ConverterModel(new ByteConverter()));
		this.addConverter(new ConverterModel(new CharConverter()));
		this.addConverter(new ConverterModel(new DateConverter()));
		this.addConverter(new ConverterModel(new DoubleConverter()));
		this.addConverter(new ConverterModel(new EnumConverter()));
		this.addConverter(new ConverterModel(new FloatConverter()));
		this.addConverter(new ConverterModel(new IntegerConverter()));
		this.addConverter(new ConverterModel(new LongConverter()));
		this.addConverter(new ConverterModel(new ShortConverter()));
		this.addConverter(new ConverterModel(new StringConverter()));
	}

	public ProcessorLogger getLogger() {
		return this.logger;
	}

	void addDatabase(DatabaseModel dbModel) {
		dbModels.put(dbModel.getQualifiedClassName(), dbModel);
	}

	Collection<DatabaseModel> getDbModels() {
		return dbModels.values();
	}

	public DatabaseModel getDbByName(String helperClass) {
		return dbModels.get(helperClass);
	}

	public DatabaseModel getDefaultDb() {
		if (dbModels.size() > 0) {
			return dbModels.values().iterator().next();
		}
		return null;
	}

	/**
	 * Read the current model state from a file in support of incremental
	 * compilation. This is necessary because the annotation processor has
	 * access to only classes which have been annotated (and any resulting
	 * generated classes on subsequent rounds), but DatabaseHelper classes
	 * aren't available when doing incremental compilation on a new @Entity.
	 *
	 * @see http
	 *      ://stackoverflow.com/questions/10585665/how-can-i-examine-the-whole
	 *      -source-tree-with-an-annotation-processor
	 *      https://github.com/sentinelt/evo-classindex
	 *
	 * @param Filer
	 *            used by the annotation processor
	 */
	void readIndex(Filer filer) {
		StandardLocation location = StandardLocation.SOURCE_OUTPUT;
		FileObject indexFile;
		try {
			indexFile = filer.getResource(location, "com.turbomanage.storm",
					ENV_FILE);
			logger.info("Reading index " + indexFile.toUri());
			// indexFile.openReader() not implemented on all platforms
			Reader fileReader = new InputStreamReader(indexFile.openInputStream());
			BufferedReader reader = new BufferedReader(fileReader);
			String line = reader.readLine(); // BEGIN_CONVERTERS
			line = reader.readLine();
			while (line != null && !line.startsWith(END_CONVERTERS)) {
				ConverterModel converter = ConverterModel.readFromIndex(line, logger);
				this.addConverter(converter);
				line = reader.readLine();
			}
			line = reader.readLine();
			while (line != null && line.startsWith(BEGIN_DATABASE)) {
				DatabaseModel dbModel = DatabaseModel.readFromIndex(reader, logger);
				this.addDatabase(dbModel);
				line = reader.readLine();
			}
			reader.close();
		} catch (IOException e) {
			// gulp--only way to catch not yet existing file on first run
		}
	}

	/**
	 * Write the current model state to a file in support of incremental
	 * compilation.
	 *
	 * @see StormEnvironment#readIndex(Filer)
	 *
	 * @param Filer
	 *            used by the annotation processor
	 */
	void writeIndex(Filer filer) {
		StandardLocation location = StandardLocation.SOURCE_OUTPUT;
		FileObject indexFile;
		try {
			indexFile = filer.createResource(location, "com.turbomanage.storm",
					ENV_FILE);
			OutputStream fos = indexFile.openOutputStream();
			PrintWriter out = new PrintWriter(fos);
			// Dump converters
			out.println(BEGIN_CONVERTERS);
			for (ConverterModel converter : converters) {
				converter.writeToIndex(out);
			}
			out.println(END_CONVERTERS);
			// Dump databases
			for (DatabaseModel dbModel : dbModels.values()) {
				dbModel.writeToIndex(out);
			}
			out.close();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Register a custom {@link TypeConverter} for a given data (field) type.
	 * This method is called at compile time by the annotation processor. In
	 * order for the TypeConverter to be visible, it must be in a jar on the
	 * client project's annotation factory classpath.
	 *
	 * @param converter
	 * @return true if successful, false if converter was already registered for
	 *         type
	 */
	public boolean addConverter(ConverterModel converter) {
		if (converters.contains(converter))
			return true;
		for (String type : converter.getConvertibleTypes()) {
			// TODO what if already put the 1st type?
			if (typeMap.containsKey(type)
					&& !typeMap.get(type).equals(converter))
				return false;
			typeMap.put(type, converter);
		}
		converters.add(converter);
		logger.info("Added " + converter.getQualifiedClassName());
		return true;
	}

	public ConverterModel getConverterForType(String javaType) {
		ConverterModel converter = typeMap.get(javaType);
		if (converter != null)
			return converter;
		throw new TypeNotSupportedException(
				"Could not find converter for type " + javaType);
	}

	public List<ConverterModel> getConverters() {
		return converters;
	}

}
```


Overlapping Code:
```
 static final String BEGIN_DATABASE = ":DB_START";
public static final String END_DATABASE = ":DB_END";
public static final String BEGIN_CONVERTERS = ":CONV_START";
public static final String END_CONVERTERS = ":CONV_END";
private static final String ENV_FILE = "stormEnv";
private ProcessorLogger logger;
private Map<String,DatabaseModel> dbModels = new TreeMap<String,DatabaseModel>();
private List<ConverterModel> converters = new ArrayList<ConverterModel>();
private Map<String, ConverterModel> typeMap = new HashMap<String, ConverterModel>();
StormEnvironment(ProcessorLogger logger) {
this.logger = logger;
addBuiltInConverters();
}
private void addBuiltInConverters() {
this.addConverter(new ConverterModel(new BlobConverter()));
this.addConverter(new ConverterModel(new BooleanConverter()));
this.addConverter(new ConverterModel(new ByteConverter()));
this.addConverter(new ConverterModel(new CharConverter()));
this.addConverter(new ConverterModel(new DateConverter()));
this.addConverter(new ConverterModel(new DoubleConverter()));
this.addConverter(new ConverterModel(new EnumConverter()));
this.addConverter(new ConverterModel(new FloatConverter()));
this.addConverter(new ConverterModel(new IntegerConverter()));
this.addConverter(new ConverterModel(new LongConverter()));
this.addConverter(new ConverterModel(new ShortConverter()));
this.addConverter(new ConverterModel(new StringConverter()));
}
public ProcessorLogger getLogger() {
return this.logger;
}
void addDatabase(DatabaseModel dbModel) {
dbModels.put(dbModel.getQualifiedClassName(), dbModel);
}
Collection<DatabaseModel> getDbModels() {
return dbModels.values();
}
public DatabaseModel getDbByName(String helperClass) {
return dbModels.get(helperClass);
}
public DatabaseModel getDefaultDb() {
if (dbModels.size() > 0) {
return dbModels.values().iterator().next();
}
return null;
}
/**
* Read the current model state from a file in support of incremental
* compilation. This is necessary because the annotation processor has
* access to only classes which have been annotated (and any resulting
* generated classes on subsequent rounds), but DatabaseHelper classes
* aren't available when doing incremental compilation on a new @Entity.
*
* @see http
* ://stackoverflow.com/questions/10585665/how-can-i-examine-the-whole
* -so
```
<Overlap Ratio: 0.9639564124057>

---

--- 27 --
Question ID: 69b06d04cc9b13c4a7071acecbe0b42bd767287b_0
Original Code:
```
public final class GitNewBranchNameValidator implements InputValidatorEx {

  private final Collection<GitRepository> myRepositories;
  private String myErrorText;

  private GitNewBranchNameValidator(@NotNull Collection<GitRepository> repositories) {
    myRepositories = repositories;
  }

  public static GitNewBranchNameValidator newInstance(@NotNull Collection<GitRepository> repositories) {
    return new GitNewBranchNameValidator(repositories);
  }

  @Override
  public boolean checkInput(String inputString) {
    if (!GitRefNameValidator.getInstance().checkInput(inputString)){
      myErrorText = "Invalid name for branch";
      return false;
    }
    return checkBranchConflict(inputString);
  }

  private boolean checkBranchConflict(String inputString) {
    if (isNotPermitted(inputString) || conflictsWithLocalBranch(inputString) || conflictsWithRemoteBranch(inputString)) {
      return false;
    }
    myErrorText = null;
    return true;
  }

  private boolean isNotPermitted(@NotNull String inputString) {
    if (inputString.equalsIgnoreCase("head")) {
      myErrorText = "Branch name " + inputString + " is not valid";
      return true;
    }
    return false;
  }

  private boolean conflictsWithLocalBranch(String inputString) {
    return conflictsWithLocalOrRemote(inputString, true, " already exists");
  }

  private boolean conflictsWithRemoteBranch(String inputString) {
    return conflictsWithLocalOrRemote(inputString, false, " clashes with remote branch with the same name");
  }

  private boolean conflictsWithLocalOrRemote(String inputString, boolean local, String message) {
    for (GitRepository repository : myRepositories) {
      GitBranchesCollection branchesCollection = repository.getBranches();
      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();
      for (GitBranch branch : branches) {
        if (branch.getName().equals(inputString)) {
          myErrorText = "Branch name " + inputString + message;
          if (myRepositories.size() > 1 && !allReposHaveBranch(inputString, local)) {
            myErrorText += " in repository " + repository.getPresentableUrl();
          }
          return true;
        }
      }
    }
    return false;
  }

  private boolean allReposHaveBranch(String inputString, boolean local) {
    for (GitRepository repository : myRepositories) {
      GitBranchesCollection branchesCollection = repository.getBranches();
      Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();
      if (!GitBranchUtil.convertBranchesToNames(branches).contains(inputString)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public boolean canClose(String inputString) {
    return checkInput(inputString);
  }

  @Override
  public String getErrorText(String inputString) {
    return myErrorText;
  }
}
```


Overlapping Code:
```
GitNewBranchNameValidator implements InputValidatorEx {
private final Collection<GitRepository> myRepositories;
private String myErrorText;
private GitNewBranchNameValidator(@NotNull Collection<GitRepository> repositories) {
myRepositories = repositories;
}
public static GitNewBranchNameValidator newInstance(@NotNull Collection<GitRepository> repositories) {
return new GitNewBranchNameValidator(repositories);
}
@Override
public boolean checkInput(String inputString) {
if (!GitRefNameValidator.getInstance().checkInput(inputString)){
myErrorText = "Invalid name for branch";
return false;
}
return checkBranchConflict(inputString);
}
private boolean checkBranchConflict(String inputString) {
if (isNotPermitted(inputString) || conflictsWithLocalBranch(inputString) || conflictsWithRemoteBranch(inputString)) {
return false;
}
myErrorText = null;
return true;
}
private boolean isNotPermitted(@NotNull String inputString) {
if (inputString.equalsIgnoreCase("head")) {
myErrorText = "Branch name " + inputString + " is not valid";
return true;
}
return false;
}
private boolean conflictsWithLocalBranch(String inputString) {
return conflictsWithLocalOrRemote(inputString, true, " already exists");
}
private boolean conflictsWithRemoteBranch(String inputString) {
return conflictsWithLocalOrRemote(inputString, false, " clashes with remote branch with the same name");
}
private boolean conflictsWithLocalOrRemote(String inputString, boolean local, String message) {
for (GitRepository repository : myRepositories) {
GitBranchesCollection branchesCollection = repository.getBranches();
Collection<? extends GitBranch> branches = local ? branchesCollection.getLocalBranches() : branchesCollection.getRemoteBranches();
for (GitBranch branch : branches) {
if (branch.getName().equals(inputString)) {
myErrorText = "Branch name " + inputString + message;
if (myRepositories.size() > 1 && !allReposHaveBranch(inputString, local)) {
myErrorText += " in repository " + repository.getPresentableUrl();
}
return true;
}
}
}
return false;
}
private boolean allReposHaveBranch(String inputString, boolean local) {
for (GitRepository repository : myRepositories) {
GitBranchesCollection branchesCollection = repository.getB
```
<Overlap Ratio: 0.9870651204281892>

---

--- 28 --
Question ID: 65e2e4cfba931a6b71441a1bd15fd5501ac7562f_0
Original Code:
```
public abstract class AbstractEmbeddedQuestDbStatusHistoryRepositoryTest extends AbstractStatusHistoryRepositoryTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractEmbeddedQuestDbStatusHistoryRepositoryTest.class);

    protected static final String PATH = "target/questdb";
    protected static final long NOW = System.currentTimeMillis();
    protected static final Date START = new Date(0);
    protected static final Date INSERTED_AT = new Date(NOW - TimeUnit.MINUTES.toMillis(1));
    protected static final Date END = new Date(NOW);
    protected static final Date END_EARLY = new Date(NOW - TimeUnit.MINUTES.toMillis(10));

    protected static final int PREFERRED_DATA_POINTS = 1000;
    protected static final int DAYS_TO_KEEP_DATA = 7;
    protected static final long PERSIST_FREQUENCY = 50; //200 milliseconds

    protected EmbeddedQuestDbStatusHistoryRepository testSubject;
    protected String path;

    @Before
    public void setUp() throws Exception {
        path = PATH + System.currentTimeMillis();
        testSubject = givenTestSubject();
    }

    @After
    public void tearDown() throws Exception {
        testSubject.shutdown();

        try {
            FileUtils.deleteFile(new File(path), true);
        } catch (final Exception e) {
            LOGGER.error("Could not delete database directory", e);
        }
    }

    private EmbeddedQuestDbStatusHistoryRepository givenTestSubject() {
        final NiFiProperties niFiProperties = Mockito.mock(NiFiProperties.class);

        Mockito.when(niFiProperties.getIntegerProperty(
                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_NODE_DAYS,
                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_NODE_DAYS)
        ).thenReturn(DAYS_TO_KEEP_DATA);

        Mockito.when(niFiProperties.getIntegerProperty(
                NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_COMPONENT_DAYS,
                NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_COMPONENT_DAYS)
        ).thenReturn(DAYS_TO_KEEP_DATA);

        Mockito.when(niFiProperties.getQuestDbStatusRepositoryPath()).thenReturn(Paths.get(path));

        final EmbeddedQuestDbStatusHistoryRepository testSubject = new EmbeddedQuestDbStatusHistoryRepository(niFiProperties, PERSIST_FREQUENCY);
        testSubject.start();
        return testSubject;
    }

    protected void givenWaitUntilPersisted() throws InterruptedException {
        Thread.sleep(3000); // The actual writing happens asynchronously on a different thread
    }
}
```


Overlapping Code:
```
lass AbstractEmbeddedQuestDbStatusHistoryRepositoryTest extends AbstractStatusHistoryRepositoryTest {
private static final Logger LOGGER = LoggerFactory.getLogger(AbstractEmbeddedQuestDbStatusHistoryRepositoryTest.class);
protected static final String PATH = "target/questdb";
protected static final long NOW = System.currentTimeMillis();
protected static final Date START = new Date(0);
protected static final Date INSERTED_AT = new Date(NOW - TimeUnit.MINUTES.toMillis(1));
protected static final Date END = new Date(NOW);
protected static final Date END_EARLY = new Date(NOW - TimeUnit.MINUTES.toMillis(10));
protected static final int PREFERRED_DATA_POINTS = 1000;
protected static final int DAYS_TO_KEEP_DATA = 7;
protected static final long PERSIST_FREQUENCY = 50; //200 milliseconds
protected EmbeddedQuestDbStatusHistoryRepository testSubject;
protected String path;
@Before
public void setUp() throws Exception {
path = PATH + System.currentTimeMillis();
testSubject = givenTestSubject();
}
@After
public void tearDown() throws Exception {
testSubject.shutdown();
try {
FileUtils.deleteFile(new File(path), true);
} catch (final Exception e) {
LOGGER.error("Could not delete database directory", e);
}
}
private EmbeddedQuestDbStatusHistoryRepository givenTestSubject() {
final NiFiProperties niFiProperties = Mockito.mock(NiFiProperties.class);
Mockito.when(niFiProperties.getIntegerProperty(
NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_NODE_DAYS,
NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_NODE_DAYS)
).thenReturn(DAYS_TO_KEEP_DATA);
Mockito.when(niFiProperties.getIntegerProperty(
NiFiProperties.STATUS_REPOSITORY_QUESTDB_PERSIST_COMPONENT_DAYS,
NiFiProperties.DEFAULT_COMPONENT_STATUS_REPOSITORY_PERSIST_COMPONENT_DAYS)
).thenReturn(DAYS_TO_KEEP_DATA);
Mockito.when(niFiProperties.getQuestDbStatusRepositoryPath()).thenReturn(Paths.get(path));
final EmbeddedQuestDbStatusHistoryRepository testSubject = new EmbeddedQuestDbStatusHistoryRepository(niFiProperties, PERSIST_FREQUENCY);
testSubject.start();
return testSubject;
}
protected void givenWaitUntilPersisted() throws InterruptedException {
Thread.sleep(3000); // Th
```
<Overlap Ratio: 0.9853680841335163>

---

--- 29 --
Question ID: a9fe0b44577e5e671587b5147fdd73f0ab27ba15_0
Original Code:
```
@Slf4j
public class Producer1 {

    public static void main(String[] args){
        Properties properties = new Properties();
        properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        properties.setProperty(ProducerConfig.CLIENT_ID_CONFIG, "producer-01");
        properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());

        try (KafkaProducer<String, String> producer = new KafkaProducer<>(properties)) {
            ProducerRecord<String, String> record = new ProducerRecord<>("my-topic-01", "hello kafka");
            producer.send(record, (recordMetadata, e) -> {
                if (e != null) {
                    log.error("发送消息失败: ", e);
                } else {
                    log.info(recordMetadata.topic() + "-p:"+recordMetadata.partition() +"-o:" + recordMetadata.offset());
                }
            });
        } catch (Exception e) {
            log.error("发送消息失败: ", e);
        }

        new Stack().clear();
    }
}
```


Overlapping Code:
```
c class Producer1 {
public static void main(String[] args){
Properties properties = new Properties();
properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
properties.setProperty(ProducerConfig.CLIENT_ID_CONFIG, "producer-01");
properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
try (KafkaProducer<String, String> producer = new KafkaProducer<>(properties)) {
ProducerRecord<String, String> record = new ProducerRecord<>("my-topic-01", "hello kafka");
producer.send(record, (recordMetadata, e) -> {
if (e != null) {
log.error("发送消息失败: ", e);
} else {
log.info(recordMetadata.topic() + "-p:"+recordMetadata.partition() +"-o:" + recordMetadata.offset());
}
});
} catch (Exception e) {
log.error("发送消息失败: ", e);
}
new S
```
<Overlap Ratio: 0.966702470461869>

---

--- 30 --
Question ID: 5270960ef06915ee2e89e878943c28b57eaafe22_0
Original Code:
```
@Configuration
@EnableWebSecurity
public class SecurityConfiguration
    extends WebSecurityConfigurerAdapter {

    @Value("${spring.security.oauth2.client.provider.oidc.issuer-uri}")
    private String issuerUri;

    @Value("${oidc.issuer}")
    private String issuerOverride;

    private final ServiceAuthFilter serviceAuthFilter;
    private final JwtAuthenticationConverter jwtAuthenticationConverter;

    @Inject
    public SecurityConfiguration(final ServiceAuthFilter serviceAuthFilter,
                                 final JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter) {
        this.serviceAuthFilter = serviceAuthFilter;
        jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/swagger-resources/**",
            "/swagger-ui/**",
            "/webjars/**",
            "/v2/**",
            "/health",
            "/health/liveness",
            "/health/readiness",
            "/",
            "/loggers/**");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .addFilterBefore(serviceAuthFilter, BearerTokenAuthenticationFilter.class)
            .sessionManagement().sessionCreationPolicy(STATELESS).and()
            .csrf().disable()
            .formLogin().disable()
            .logout().disable()
            .authorizeRequests()
            .antMatchers(ImportController.URI_IMPORT, ElasticsearchIndexController.ELASTIC_INDEX_URI)
            .hasAuthority("ccd-import")
            .anyRequest()
            .authenticated()
            .and()
            .oauth2ResourceServer()
            .jwt()
            .jwtAuthenticationConverter(jwtAuthenticationConverter)
            .and()
            .and()
            .oauth2Client();
    }

    @Bean
    JwtDecoder jwtDecoder() {
        NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);

        // We are using issuerOverride instead of issuerUri as SIDAM has the wrong issuer at the moment
        OAuth2TokenValidator<Jwt> withTimestamp = new JwtTimestampValidator();
        OAuth2TokenValidator<Jwt> withIssuer = new JwtIssuerValidator(issuerOverride);
        // FIXME : enable `withIssuer` once idam migration is done RDM-8094
        // OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp, withIssuer);
        OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>(withTimestamp);

        jwtDecoder.setJwtValidator(validator);
        return jwtDecoder;
    }
}
```


Overlapping Code:
```
@Configuration
@EnableWebSecurity
public class SecurityConfiguration
extends WebSecurityConfigurerAdapter {
@Value("${spring.security.oauth2.client.provider.oidc.issuer-uri}")
private String issuerUri;
@Value("${oidc.issuer}")
private String issuerOverride;
private final ServiceAuthFilter serviceAuthFilter;
private final JwtAuthenticationConverter jwtAuthenticationConverter;
@Inject
public SecurityConfiguration(final ServiceAuthFilter serviceAuthFilter,
final JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter) {
this.serviceAuthFilter = serviceAuthFilter;
jwtAuthenticationConverter = new JwtAuthenticationConverter();
jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);
}
@Override
public void configure(WebSecurity web) throws Exception {
web.ignoring().antMatchers("/swagger-resources/**",
"/swagger-ui/**",
"/webjars/**",
"/v2/**",
"/health",
"/health/liveness",
"/health/readiness",
"/",
"/loggers/**");
}
@Override
protected void configure(HttpSecurity http) throws Exception {
http
.addFilterBefore(serviceAuthFilter, BearerTokenAuthenticationFilter.class)
.sessionManagement().sessionCreationPolicy(STATELESS).and()
.csrf().disable()
.formLogin().disable()
.logout().disable()
.authorizeRequests()
.antMatchers(ImportController.URI_IMPORT, ElasticsearchIndexController.ELASTIC_INDEX_URI)
.hasAuthority("ccd-import")
.anyRequest()
.authenticated()
.and()
.oauth2ResourceServer()
.jwt()
.jwtAuthenticationConverter(jwtAuthenticationConverter)
.and()
.and()
.oauth2Client();
}
@Bean
JwtDecoder jwtDecoder() {
NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);
// We are using issuerOverride instead of issuerUri as SIDAM has the wrong issuer at the moment
OAuth2TokenValidator<Jwt> withTimestamp = new JwtTimestampValidator();
OAuth2TokenValidator<Jwt> withIssuer = new JwtIssuerValidator(issuerOverride);
// FIXME : enable `withIssuer` once idam migration is done RDM-8094
// O
```
<Overlap Ratio: 0.9944944944944945>

---

--- 31 --
Question ID: 0c12cad6dfbdeee51b9de92181dcea806f9b5436_0
Original Code:
```
public class AFontInfo {

	public String m_name;
	public float m_size;
	public boolean m_isBold;
	public boolean m_isItalic;
	public boolean m_isUnicode;
	public String m_charset;
    public float m_stretchHeight;
    public final float[] m_padding = new float[4];
    public final float[] m_spacing = new float[2];
    public int m_charCount;
    
    public void set(AFontInfo o){
    	m_name = o.m_name;
    	m_size = o.m_size;
    	m_isBold = o.m_isBold;
    	m_isItalic = o.m_isItalic;
    	m_isUnicode = o.m_isUnicode;
    	m_charset = o.m_charset;
    	m_stretchHeight = o.m_stretchHeight;
    	m_charCount = o.m_charCount;
    	
    	System.arraycopy(o.m_padding, 0, m_padding, 0, 4);
    	System.arraycopy(o.m_spacing, 0, m_spacing, 0, 2);
    }

	@Override
	public String toString() {
		return "AFontInfo [m_name=" + m_name + ", m_size=" + m_size
				+ ", m_isBold=" + m_isBold + ", m_isItalic=" + m_isItalic
				+ ", m_isUnicode=" + m_isUnicode + ", m_charset=" + m_charset
				+ ", m_stretchHeight=" + m_stretchHeight + ", m_padding="
				+ Arrays.toString(m_padding) + ", m_spacing="
				+ Arrays.toString(m_spacing) + ", m_charCount=" + m_charCount
				+ "]";
	}
}
```


Overlapping Code:
```
String m_name;
public float m_size;
public boolean m_isBold;
public boolean m_isItalic;
public boolean m_isUnicode;
public String m_charset;
public float m_stretchHeight;
public final float[] m_padding = new float[4];
public final float[] m_spacing = new float[2];
public int m_charCount;

public void set(AFontInfo o){
m_name = o.m_name;
m_size = o.m_size;
m_isBold = o.m_isBold;
m_isItalic = o.m_isItalic;
m_isUnicode = o.m_isUnicode;
m_charset = o.m_charset;
m_stretchHeight = o.m_stretchHeight;
m_charCount = o.m_charCount;

System.arraycopy(o.m_padding, 0, m_padding, 0, 4);
System.arraycopy(o.m_spacing, 0, m_spacing, 0, 2);
}
@Override
public String toString() {
return "AFontInfo [m_name=" + m_name + ", m_size=" + m_size
+ ", m_isBold=" + m_isBold + ", m_isItalic=" + m_isItalic
+ ", m_isUnicode=" + m_isUnicode + ", m_charset=" + m_charset
+ ", m_stretchHeight=" + m_stretchHeight + ", m_padding="
+ Arrays.toString(m_padding) + ", m_spacing="
+ Arrays.toString(m_spacing) + ", m_charCount=" +
```
<Overlap Ratio: 0.9480151228733459>

---

--- 32 --
Question ID: 879dc8dd9e67585a4d687d3eb68b0979e66c2335_0
Original Code:
```
@Component
public class MutationCreationMapper implements Mapper<Mutation, MutationCreationDTO>
{
    private final MutationCommonMapper mutationCommonMapper;
    private final GeneCreationMapper geneCreationMapper;

    public MutationCreationMapper(
        MutationCommonMapper mutationCommonMapper, GeneCreationMapper geneCreationMapper)
    {
        this.mutationCommonMapper = mutationCommonMapper;
        this.geneCreationMapper = geneCreationMapper;
    }

    @Override
    public MutationCreationDTO toDto(Mutation mutation)
    {
        return null;
    }

    @Override
    public Mutation toEntity(MutationCreationDTO mutationCreationDTO)
    {
        Mutation mutation = new Mutation();
        if (mutationCreationDTO.getMutationCommonDTO() != null)
        {
            mutation = mutationCommonMapper.toEntity(mutationCreationDTO.getMutationCommonDTO());
        }
        addGenes(mutation, mutationCreationDTO);
        return mutation;
    }

    private void addGenes(Mutation mutation, MutationCreationDTO mutationCreationDTO)
    {
        List<GeneCreationDTO> geneCreationDTOS = mutationCreationDTO.getGeneCreationDTOS();
        Set<Gene> genes = new HashSet<>( geneCreationMapper.toEntities(geneCreationDTOS));
        mutation.setGenes(genes);
    }
}
```


Overlapping Code:
```
c class MutationCreationMapper implements Mapper<Mutation, MutationCreationDTO>
{
private final MutationCommonMapper mutationCommonMapper;
private final GeneCreationMapper geneCreationMapper;
public MutationCreationMapper(
MutationCommonMapper mutationCommonMapper, GeneCreationMapper geneCreationMapper)
{
this.mutationCommonMapper = mutationCommonMapper;
this.geneCreationMapper = geneCreationMapper;
}
@Override
public MutationCreationDTO toDto(Mutation mutation)
{
return null;
}
@Override
public Mutation toEntity(MutationCreationDTO mutationCreationDTO)
{
Mutation mutation = new Mutation();
if (mutationCreationDTO.getMutationCommonDTO() != null)
{
mutation = mutationCommonMapper.toEntity(mutationCreationDTO.getMutationCommonDTO());
}
addGenes(mutation, mutationCreationDTO);
return mutation;
}
private void addGenes(Mutation mutation, MutationCreationDTO mutationCreationDTO)
{
List<GeneCreationDTO> geneCreationDTOS = mutationCreationDTO.getGeneCreationDTOS();
Set<Gene> genes = new HashSet<>( geneCreationMapper.toEntities(geneCreationDTO
```
<Overlap Ratio: 0.9545454545454546>

---

--- 33 --
Question ID: ab3a47d4f901cc5b98e69815713f8762f24f7642_0
Original Code:
```
public class GLTFImporter {

  private static final Logger logger = LoggerFactory.getLogger(GLTFImporter.class);
  /**
   * Default GLTFImporter instance
   */
  public static final GLTFImporter instance = new GLTFImporter();

  private BufferIO bufferIO = new DefaultBufferIO();

  private final ObjectMapper mapper = new ObjectMapper();

  public GLTFImporter() {
    mapper.registerModule(JomlModule.getModule());
  }

  public GLTF load(URI uri) {
    try {
      InputStream jsonStream;

      if (uri.toString().endsWith(".glb")) {
        logger.info("Loading .glb file: " + uri.toString());
        GLBLoader glbLoader = new GLBLoader(this);
        glbLoader.procesGLB(uri);
        jsonStream = new ByteBufferBackedInputStream(
            glbLoader.jsonData().order(ByteOrder.LITTLE_ENDIAN));
      } else {
        jsonStream = new ByteBufferBackedInputStream(
            bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN));
      }

      GLTF gltf = new GLTF(this, uri);
      ObjectReader reader = mapper.setInjectableValues(injectGLTF(gltf)).readerForUpdating(gltf);
      reader.readValue(jsonStream);
      gltf.applyLookupMap();

      boolean valid = validateGLTF(gltf);

      return gltf;
    } catch (Exception e) {
      logger.error("Error loading gltf file: " + uri.toString());
      logger.error(e.getLocalizedMessage());
      e.printStackTrace();
      return null;
    }
  }

  private boolean validateGLTF(GLTF gltf) {
    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
    Validator validator = factory.getValidator();

    Set<ConstraintViolation<GLTF>> violations = validator.validate(gltf);

    boolean ret = true;
    for (ConstraintViolation<GLTF> violation : violations) {
      ret = false;
      logger.error(violation.getMessage());
    }
    assert ret : violations;
    return ret;
  }

  /**
   * Inject reference to base GLTF into each node, used for index resolution Also a
   * RelativePathResolver, called to get a stream from a path
   *
   * @param gltf
   * @return
   */
  private InjectableValues injectGLTF(GLTF gltf) {
    InjectableValues.Std iv = new InjectableValues.Std();
    iv.addValue(GLTF.class, gltf);
    return iv;
  }

  public void setBufferIO(BufferIO bufferIO) {
    this.bufferIO = bufferIO;
  }

  BufferIO getBufferIO() {
    return this.bufferIO;
  }

  /**
   * Route bufferIO function through this to ensure little endian.
   *
   * @param uri
   * @return
   */
  public ByteBuffer getDirectByteBuffer(URI uri) {
    return bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN).rewind();
  }
}
```


Overlapping Code:
```
 GLTFImporter {
private static final Logger logger = LoggerFactory.getLogger(GLTFImporter.class);
/**
* Default GLTFImporter instance
*/
public static final GLTFImporter instance = new GLTFImporter();
private BufferIO bufferIO = new DefaultBufferIO();
private final ObjectMapper mapper = new ObjectMapper();
public GLTFImporter() {
mapper.registerModule(JomlModule.getModule());
}
public GLTF load(URI uri) {
try {
InputStream jsonStream;
if (uri.toString().endsWith(".glb")) {
logger.info("Loading .glb file: " + uri.toString());
GLBLoader glbLoader = new GLBLoader(this);
glbLoader.procesGLB(uri);
jsonStream = new ByteBufferBackedInputStream(
glbLoader.jsonData().order(ByteOrder.LITTLE_ENDIAN));
} else {
jsonStream = new ByteBufferBackedInputStream(
bufferIO.getDirectByteBuffer(uri).order(ByteOrder.LITTLE_ENDIAN));
}
GLTF gltf = new GLTF(this, uri);
ObjectReader reader = mapper.setInjectableValues(injectGLTF(gltf)).readerForUpdating(gltf);
reader.readValue(jsonStream);
gltf.applyLookupMap();
boolean valid = validateGLTF(gltf);
return gltf;
} catch (Exception e) {
logger.error("Error loading gltf file: " + uri.toString());
logger.error(e.getLocalizedMessage());
e.printStackTrace();
return null;
}
}
private boolean validateGLTF(GLTF gltf) {
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
Set<ConstraintViolation<GLTF>> violations = validator.validate(gltf);
boolean ret = true;
for (ConstraintViolation<GLTF> violation : violations) {
ret = false;
logger.error(violation.getMessage());
}
assert ret : violations;
return ret;
}
/**
* Inject reference to base GLTF into each node, used for index resolution Also a
* RelativePathResolver, called to get a stream from a path
*
* @param gltf
* @return
*/
private InjectableValues injectGLTF(GLTF gltf) {
InjectableValues.Std iv = new InjectableValues.Std();
iv.addValue(GLTF.class, gltf);
return iv;
}
public void setBufferIO(BufferIO bufferIO) {
this.bufferIO = bufferIO;
}
BufferIO getBufferIO() {
return this.bufferIO;
}
/**
* Route bufferIO function through this to ensure little endian.
*
* @param uri
* @return
*/
pub
```
<Overlap Ratio: 0.9880514705882353>

---

--- 34 --
Question ID: 880abdb15b4618d03cbf39ecef14942bc5afac20_0
Original Code:
```
@Tag("ExpirationPolicy")
public class AlwaysExpiresExpirationPolicyTests {

    private static final File JSON_FILE = new File(FileUtils.getTempDirectoryPath(), "alwaysExpiresExpirationPolicy.json");
    private static final ObjectMapper MAPPER = JacksonObjectMapperFactory.builder()
        .defaultTypingEnabled(true).build().toObjectMapper();

    @Test
    public void verifySerializeAnAlwaysExpiresExpirationPolicyToJson() throws IOException {
        val policyWritten = new AlwaysExpiresExpirationPolicy();
        MAPPER.writeValue(JSON_FILE, policyWritten);
        val policyRead = MAPPER.readValue(JSON_FILE, AlwaysExpiresExpirationPolicy.class);
        assertEquals(policyWritten, policyRead);
    }

    @Test
    public void verifySerialization() {
        val policyWritten = new AlwaysExpiresExpirationPolicy();
        val result = SerializationUtils.serialize(policyWritten);
        val policyRead = SerializationUtils.deserialize(result, AlwaysExpiresExpirationPolicy.class);
        assertEquals(policyWritten, policyRead);
    }
}
```


Overlapping Code:
```
ass AlwaysExpiresExpirationPolicyTests {
private static final File JSON_FILE = new File(FileUtils.getTempDirectoryPath(), "alwaysExpiresExpirationPolicy.json");
private static final ObjectMapper MAPPER = JacksonObjectMapperFactory.builder()
.defaultTypingEnabled(true).build().toObjectMapper();
@Test
public void verifySerializeAnAlwaysExpiresExpirationPolicyToJson() throws IOException {
val policyWritten = new AlwaysExpiresExpirationPolicy();
MAPPER.writeValue(JSON_FILE, policyWritten);
val policyRead = MAPPER.readValue(JSON_FILE, AlwaysExpiresExpirationPolicy.class);
assertEquals(policyWritten, policyRead);
}
@Test
public void verifySerialization() {
val policyWritten = new AlwaysExpiresExpirationPolicy();
val result = SerializationUtils.serialize(policyWritten);
val policyRead = SerializationUtils.deserialize(result, AlwaysExpiresExpirationPolicy.class);
assertEquals(policyWritten, policyRead)
```
<Overlap Ratio: 0.9587737843551797>

---

--- 35 --
Question ID: 585aac20027ec786ff5d7aaa11c6a7026b2e5a64_0
Original Code:
```
public class JSONLDExtractor extends BaseRDFExtractor {

    private static final ObjectMapper OBJECT_MAPPER = JsonMapper.builder()
            .enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER).disable(JsonReadFeature.ALLOW_JAVA_COMMENTS)
            .disable(JsonReadFeature.ALLOW_MISSING_VALUES).enable(JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS)
            .enable(JsonReadFeature.ALLOW_LEADING_ZEROS_FOR_NUMBERS).disable(JsonReadFeature.ALLOW_SINGLE_QUOTES)
            .disable(JsonReadFeature.ALLOW_TRAILING_COMMA).enable(JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS)
            .enable(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES).disable(JsonReadFeature.ALLOW_YAML_COMMENTS)
            .enable(StreamReadFeature.IGNORE_UNDEFINED).enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)
            .disable(StreamReadFeature.STRICT_DUPLICATE_DETECTION).build();

    /**
     * @deprecated since 2.4. This extractor has never supported these settings. Use {@link #JSONLDExtractor()} instead.
     * 
     * @param verifyDataType
     *            has no effect
     * @param stopAtFirstError
     *            has no effect
     */
    @Deprecated
    public JSONLDExtractor(boolean verifyDataType, boolean stopAtFirstError) {
        super(verifyDataType, stopAtFirstError);
    }

    public JSONLDExtractor() {
        super(false, false);
    }

    @Override
    public ExtractorDescription getDescription() {
        return JSONLDExtractorFactory.getDescriptionInstance();
    }

    @Override
    public void run(ExtractionParameters extractionParameters, ExtractionContext extractionContext, InputStream in,
            ExtractionResult extractionResult) throws IOException, ExtractionException {
        JSONLDJavaSink handler = new JSONLDJavaSink(extractionResult, new Any23ValueFactoryWrapper(
                SimpleValueFactory.getInstance(), extractionResult, extractionContext.getDefaultLanguage()));

        JsonLdOptions options = new JsonLdOptions(extractionContext.getDocumentIRI().stringValue());
        options.useNamespaces = true;

        try {
            Object json = JsonUtils
                    .fromJsonParser(OBJECT_MAPPER.getFactory().createParser(new JsonCleaningInputStream(in)));
            JsonLdProcessor.toRDF(json, handler, options);
        } catch (JsonProcessingException e) {
            JsonLocation loc = e.getLocation();
            if (loc == null) {
                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), -1L, -1L);
            } else {
                extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, e.getOriginalMessage(), loc.getLineNr(),
                        loc.getColumnNr());
            }
        } catch (Exception e) {
            // ANY23-420: jsonld-java can sometimes throw IllegalArgumentException
            extractionResult.notifyIssue(IssueReport.IssueLevel.FATAL, toString(e), -1, -1);
        }
    }

    /* DEPRECATED METHODS */

    /**
     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.
     * 
     * @param stopAtFirstError
     *            has no effect
     */
    @Deprecated
    @Override
    public void setStopAtFirstError(boolean stopAtFirstError) {
        super.setStopAtFirstError(stopAtFirstError);
    }

    /**
     * @deprecated since 2.4. This extractor has never supported this setting. Do not use.
     * 
     * @param verifyDataType
     *            has no effect
     */
    @Deprecated
    @Override
    public void setVerifyDataType(boolean verifyDataType) {
        super.setVerifyDataType(verifyDataType);
    }

    /**
     * @deprecated since 2.4. This extractor no longer wraps an RDF4J {@link RDFParser}. Do not use this method.
     * 
     * @param extractionContext
     *            the extraction context
     * @param extractionResult
     *            the extraction result
     * 
     * @return a {@link RDFParser}
     */
    @Deprecated
    @Override
    protected RDFParser getParser(ExtractionContext extractionContext, ExtractionResult extractionResult) {
        return RDFParserFactory.getInstance().getJSONLDParser(isVerifyDataType(), isStopAtFirstError(),
                extractionContext, extractionResult);
    }

}
```


Overlapping Code:
```
SONLDExtractor extends BaseRDFExtractor {
private static final ObjectMapper OBJECT_MAPPER = JsonMapper.builder()
.enable(JsonReadFeature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER).disable(JsonReadFeature.ALLOW_JAVA_COMMENTS)
.disable(JsonReadFeature.ALLOW_MISSING_VALUES).enable(JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS)
.enable(JsonReadFeature.ALLOW_LEADING_ZEROS_FOR_NUMBERS).disable(JsonReadFeature.ALLOW_SINGLE_QUOTES)
.disable(JsonReadFeature.ALLOW_TRAILING_COMMA).enable(JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS)
.enable(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES).disable(JsonReadFeature.ALLOW_YAML_COMMENTS)
.enable(StreamReadFeature.IGNORE_UNDEFINED).enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)
.disable(StreamReadFeature.STRICT_DUPLICATE_DETECTION).build();
/**
* @deprecated since 2.4. This extractor has never supported these settings. Use {@link #JSONLDExtractor()} instead.
* 
* @param verifyDataType
* has no effect
* @param stopAtFirstError
* has no effect
*/
@Deprecated
public JSONLDExtractor(boolean verifyDataType, boolean stopAtFirstError) {
super(verifyDataType, stopAtFirstError);
}
public JSONLDExtractor() {
super(false, false);
}
@Override
public ExtractorDescription getDescription() {
return JSONLDExtractorFactory.getDescriptionInstance();
}
@Override
public void run(ExtractionParameters extractionParameters, ExtractionContext extractionContext, InputStream in,
ExtractionResult extractionResult) throws IOException, ExtractionException {
JSONLDJavaSink handler = new JSONLDJavaSink(extractionResult, new Any23ValueFactoryWrapper(
SimpleValueFactory.getInstance(), extractionResult, extractionContext.getDefaultLanguage()));
JsonLdOptions options = new JsonLdOptions(extractionContext.getDocumentIRI().stringValue());
options.useNamespaces = true;
try {
Object json = JsonUtils
.fromJsonParser(OBJECT_MAPPER.getFactory().createParser(new JsonCleaningInputStream(in)));
JsonLdProcessor.toRDF(json, handler, options);
} catch (JsonProcessingException e) {
JsonLocation loc = e.getLocation();
if (loc == null) {
extractionResult.notifyIssue(IssueReport.IssueLevel.FATA
```
<Overlap Ratio: 0.9910672308415609>

---

--- 36 --
Question ID: 034c9a3c0d0dff371fc4d01077ef946a827e0e0c_0
Original Code:
```
public class UriParserTest {

    @Test
    public void parserReturnsHostGivenHttpUrl() {

        // given
        String url = "tcp://localhost:8080";
        UriParser uriParser = new UriParser();

        // when
        String parsedHost = uriParser.getHost(url);

        // then
        assertEquals("localhost", parsedHost);

    }

    @Test
    public void parserReturnsIpGivenHttpUrl() {

        // given
        String url = "tcp://10.120.10.10:8080";
        UriParser uriParser = new UriParser();

        // when
        String parsedHost = uriParser.getHost(url);

        // then
        assertEquals("10.120.10.10", parsedHost);

    }

    @Test
    public void parserReturnsPortGivenHttpUrl() {

        // given
        String url = "tcp://localhost:8080";
        UriParser uriParser = new UriParser();

        // when
        int parsedPort = uriParser.getPort(url);

        // then
        assertEquals(8080, parsedPort);

    }

    @Test
    public void parserReturnsPortGivenIpUrl() {

        // given
        String url = "tcp://10.120.10.10:8080";
        UriParser uriParser = new UriParser();

        // when
        int parsedPort = uriParser.getPort(url);

        // then
        assertEquals(8080, parsedPort);

    }

    @Test
    public void getHostThrowsOnInvalidUri() {

        // given
        String url = "${";
        UriParser uriParser = new UriParser();

        // when
        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getHost(url));

        // then
        assertThat(exception.getMessage(), containsString("Illegal character in path at index 1: ${"));

    }

    @Test
    public void getPortThrowsOnInvalidUri() {

        // given
        String url = "%s";
        UriParser uriParser = new UriParser();

        // when
        final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getPort(url));

        // then
        assertThat(exception.getMessage(), equalTo("java.net.URISyntaxException: Malformed escape pair at index 0: %s"));

    }

}
```


Overlapping Code:
```
ass UriParserTest {
@Test
public void parserReturnsHostGivenHttpUrl() {
// given
String url = "tcp://localhost:8080";
UriParser uriParser = new UriParser();
// when
String parsedHost = uriParser.getHost(url);
// then
assertEquals("localhost", parsedHost);
}
@Test
public void parserReturnsIpGivenHttpUrl() {
// given
String url = "tcp://10.120.10.10:8080";
UriParser uriParser = new UriParser();
// when
String parsedHost = uriParser.getHost(url);
// then
assertEquals("10.120.10.10", parsedHost);
}
@Test
public void parserReturnsPortGivenHttpUrl() {
// given
String url = "tcp://localhost:8080";
UriParser uriParser = new UriParser();
// when
int parsedPort = uriParser.getPort(url);
// then
assertEquals(8080, parsedPort);
}
@Test
public void parserReturnsPortGivenIpUrl() {
// given
String url = "tcp://10.120.10.10:8080";
UriParser uriParser = new UriParser();
// when
int parsedPort = uriParser.getPort(url);
// then
assertEquals(8080, parsedPort);
}
@Test
public void getHostThrowsOnInvalidUri() {
// given
String url = "${";
UriParser uriParser = new UriParser();
// when
final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getHost(url));
// then
assertThat(exception.getMessage(), containsString("Illegal character in path at index 1: ${"));
}
@Test
public void getPortThrowsOnInvalidUri() {
// given
String url = "%s";
UriParser uriParser = new UriParser();
// when
final ConfigurationException exception = assertThrows(ConfigurationException.class, () -> uriParser.getPort(url));
// then
assertThat(exception.getMessage(), equalTo("java.net.URISyntaxException: Malformed escape pair at index
```
<Overlap Ratio: 0.986252241482367>

---

--- 37 --
Question ID: b0f0dcb234f6fe524140afbf4a0dddc50e1ccaba_0
Original Code:
```
public class ValidityDialogDefaultValue {

	@Rule
	public Logger log = Logger.getLogger(this);
	
	@Before
	public void setUp() throws Exception {
		app.start(true);
		AppTool.newSpreadsheet();
		app.dispatch(".uno:Validation");
	}

	@After
	public void tearDown() throws Exception {
		app.stop();
	}

	/**
	 * test Data -> Validity - UI(Criteria: Cell range).
	 */
	@Test
	public void testValidityUICellRange() {

		scValidityCriteriaTabpage.select();
		scValidityCriteriaAllowList.select(5); 

		assertEquals("Wrong default value of AllowBlankCells in Validity",true, scValidityAllowBlankCells.isChecked());
		assertEquals("Wrong default value of ShowSelectionList in Validity",true, scValidityShowSelectionList.isChecked());
		assertEquals("Wrong default value of Sort Entries Ascending in Validity",false, scValiditySortEntriesAscending.isChecked());
		assertEquals("Wrong default value of AllowBlankCells in Validity",true, scValidityAllowBlankCells.isEnabled());
		assertEquals("Wrong default value of Sort Entries Ascending in Validity",true, scValiditySortEntriesAscending.isEnabled());
		assertEquals("Wrong default value of SourcePicker in Validity",true, scValiditySourcePicker.isEnabled());
	}

	/**
	 * test Data -> Validity - UI(Error Alert: Default status)
	 */
	@Test
	public void testValidityUIErrorAlert() {

		scValidityErrorAlertTabPage.select();
		assertEquals("Error Alert Action list is disable",true, scValidityErrorAlertActionList.isEnabled());
		// assertEquals("Stop",SC_ValidityErrorAlertActionList.getSelText()); 
		// Do not test this. Do it in GVT.
		assertEquals("Error Message Title is disable",true, scValidityErrorMessageTitle.isEnabled());
		assertEquals("Have default error message title","", scValidityErrorMessageTitle.getText());
		assertEquals("Error message is disable",true, scValidityErrorMessage.isEnabled());
		assertEquals("Have default error message","", scValidityErrorMessage.getText());
		scValidityErrorAlertActionList.select(3); // "Macro"
		assertEquals("error browse button is disable",true, scValidityErrorBrowseButton.isEnabled());
	}

}
```


Overlapping Code:
```
alogDefaultValue {
@Rule
public Logger log = Logger.getLogger(this);

@Before
public void setUp() throws Exception {
app.start(true);
AppTool.newSpreadsheet();
app.dispatch(".uno:Validation");
}
@After
public void tearDown() throws Exception {
app.stop();
}
/**
* test Data -> Validity - UI(Criteria: Cell range).
*/
@Test
public void testValidityUICellRange() {
scValidityCriteriaTabpage.select();
scValidityCriteriaAllowList.select(5); 
assertEquals("Wrong default value of AllowBlankCells in Validity",true, scValidityAllowBlankCells.isChecked());
assertEquals("Wrong default value of ShowSelectionList in Validity",true, scValidityShowSelectionList.isChecked());
assertEquals("Wrong default value of Sort Entries Ascending in Validity",false, scValiditySortEntriesAscending.isChecked());
assertEquals("Wrong default value of AllowBlankCells in Validity",true, scValidityAllowBlankCells.isEnabled());
assertEquals("Wrong default value of Sort Entries Ascending in Validity",true, scValiditySortEntriesAscending.isEnabled());
assertEquals("Wrong default value of SourcePicker in Validity",true, scValiditySourcePicker.isEnabled());
}
/**
* test Data -> Validity - UI(Error Alert: Default status)
*/
@Test
public void testValidityUIErrorAlert() {
scValidityErrorAlertTabPage.select();
assertEquals("Error Alert Action list is disable",true, scValidityErrorAlertActionList.isEnabled());
// assertEquals("Stop",SC_ValidityErrorAlertActionList.getSelText()); 
// Do not test this. Do it in GVT.
assertEquals("Error Message Title is disable",true, scValidityErrorMessageTitle.isEnabled());
assertEquals("Have default error message title","", scValidityErrorMessageTitle.getText());
assertEquals("Error message is disable",true, scValidityErrorMessage.isEnabled());
assertEquals("Have default error message","", scValidityErrorMessage.getText());
scValidityErrorAlertActionList.select(3); // "Macro"
assertEquals("error browse button is disable",true, sc
```
<Overlap Ratio: 0.9672619047619048>

---

--- 38 --
Question ID: 00c5f865523219b167bfac68902ecabd5bc7eed0_0
Original Code:
```
public abstract class Numbers {


  /**
   * Checks whether tow numbers have equal values (even they are instances of different classes).
   *
   * @param x  the first number.
   * @param y  the second number.
   * @return   whether they're equal.
   */
  public static boolean valuesAreEqual(@Nullable final Number x, @Nullable final Number y) {
    //noinspection NumberEquality
    if (x == y) return true;
    //noinspection SimplifiableIfStatement
    if (x == null || y == null) return false;
    return x.getClass() == y.getClass() ? x.equals(y) : x.toString().equals(y.toString());
  }


  /**
   * Converts an arbitrary number to the specified class of Number.
   * @param <N>            desired type of number.
   * @param numberClass    desired class of number.
   * @param number         the number to convert (nulls are possible).
   * @return               the converted number.
   */
  @SuppressWarnings("unchecked")
  @Contract(value = "_,!null -> !null; _,null -> null", pure = true)
  public static <N extends Number> N convertNumber(final Class<N> numberClass, final Number number) {
    if (number == null) return null;
    if (numberClass.isAssignableFrom(number.getClass())) return (N) number;

    if (numberClass == Byte.class || numberClass == byte.class) return (N) Byte.valueOf(number.byteValue());
    if (numberClass == Short.class || numberClass == short.class) return (N) Short.valueOf(number.shortValue());
    if (numberClass == Integer.class || numberClass == int.class) return (N) Integer.valueOf(number.intValue());
    if (numberClass == Long.class || numberClass == long.class) return (N) Long.valueOf(number.longValue());
    if (numberClass == Float.class || numberClass == float.class) return (N) Float.valueOf(number.floatValue());
    if (numberClass == Double.class || numberClass == double.class) return (N) Double.valueOf(number.doubleValue());
    if (numberClass == BigInteger.class) return (N) new BigInteger(number.toString());
    if (numberClass == BigDecimal.class) return (N) new BigDecimal(number.toString());

    String message =
        String.format("Unknown how to convert value (%s) of type %s to %s.",
                      number.toString(),
                      number.getClass().getCanonicalName(),
                      numberClass.getCanonicalName());
    throw new IllegalArgumentException(message);
  }

  @Contract(value = "!null -> !null; null -> null", pure = true)
  public static Number convertNumberSmartly(final BigDecimal decimal) {
    if (decimal == null) return null;
    if (decimal.equals(Numbers.DECIMAL_ZERO)) return BYTE_ZERO;

    final int precision = decimal.precision();
    final int scale = decimal.scale();

    Number num;
    if (scale == 0) {
      try {
        if (precision <= 19 && decimal.compareTo(Numbers.DECIMAL_MIN_LONG) >= 0
                            && decimal.compareTo(Numbers.DECIMAL_MAX_LONG) <= 0) {
          long v = decimal.longValueExact();
          if (-128 <= v && v <= 127) num = (byte) v;
          else if (-32768 <= v && v <= 32767) num = (short) v;
          else if (Integer.MIN_VALUE <= v && v <= Integer.MAX_VALUE) num = (int) v;
          else num = v;
        }
        else {
          num = decimal.toBigIntegerExact();
        }
      }
      catch (ArithmeticException ae) {
        num = decimal;
      }
    }
    else {
      if (precision <= 6) {
        num = decimal.floatValue();
      }
      else if (precision <= 15) {
        num = decimal.doubleValue();
      }
      else {
        num = decimal;
      }
    }

    return num;
  }

  public static int parseIntSafe(@Nullable final String str) {
    if (str == null) {
      return 0;
    }
    try {
      final String s = str.trim();
      if (s.isEmpty()) return 0;
      if (s.charAt(0) == '+') return Integer.parseInt(s.substring(1));
      return Integer.parseInt(s);
    }
    catch (NumberFormatException e) {
      return 0;
    }
  }


  public static long parseLongSafe(@Nullable final String str) {
    if (str == null) {
      return 0;
    }
    try {
      final String s = str.trim();
      if (s.isEmpty()) return 0L;
      if (s.charAt(0) == '+') return Long.parseLong(s.substring(1));
      return Long.parseLong(s);
    }
    catch (NumberFormatException e) {
      return 0;
    }
  }


  public static final Byte       BYTE_ZERO        = (byte) 0;
  public static final BigDecimal DECIMAL_ZERO     = new BigDecimal(0);
  public static final BigDecimal DECIMAL_MIN_LONG = new BigDecimal(Long.MIN_VALUE);
  public static final BigDecimal DECIMAL_MAX_LONG = new BigDecimal(Long.MAX_VALUE);

}
```


Overlapping Code:
```
her tow numbers have equal values (even they are instances of different classes).
*
* @param x the first number.
* @param y the second number.
* @return whether they're equal.
*/
public static boolean valuesAreEqual(@Nullable final Number x, @Nullable final Number y) {
//noinspection NumberEquality
if (x == y) return true;
//noinspection SimplifiableIfStatement
if (x == null || y == null) return false;
return x.getClass() == y.getClass() ? x.equals(y) : x.toString().equals(y.toString());
}
/**
* Converts an arbitrary number to the specified class of Number.
* @param <N> desired type of number.
* @param numberClass desired class of number.
* @param number the number to convert (nulls are possible).
* @return the converted number.
*/
@SuppressWarnings("unchecked")
@Contract(value = "_,!null -> !null; _,null -> null", pure = true)
public static <N extends Number> N convertNumber(final Class<N> numberClass, final Number number) {
if (number == null) return null;
if (numberClass.isAssignableFrom(number.getClass())) return (N) number;
if (numberClass == Byte.class || numberClass == byte.class) return (N) Byte.valueOf(number.byteValue());
if (numberClass == Short.class || numberClass == short.class) return (N) Short.valueOf(number.shortValue());
if (numberClass == Integer.class || numberClass == int.class) return (N) Integer.valueOf(number.intValue());
if (numberClass == Long.class || numberClass == long.class) return (N) Long.valueOf(number.longValue());
if (numberClass == Float.class || numberClass == float.class) return (N) Float.valueOf(number.floatValue());
if (numberClass == Double.class || numberClass == double.class) return (N) Double.valueOf(number.doubleValue());
if (numberClass == BigInteger.class) return (N) new BigInteger(number.toString());
if (numberClass == BigDecimal.class) return (N) new BigDecimal(number.toString());
String message =
String.format("Unknown how to convert value (%s) of type %s to %s.",
number.toString(),
number.getClass().getCanonicalName(),
numberClass.getCanonicalName());
throw new IllegalArgumentException(message);
}
@Contract(value = "!null -> !null; null -> null", pure = true)
public static Number convertNumberSmartly(final BigDe
```
<Overlap Ratio: 0.9760425909494232>

---

--- 39 --
Question ID: c279024e4dc6e942f3a284a3279b9989d23b7c49_0
Original Code:
```
public class WorldmapConnectionsTest extends Application {
    private static final  Random RND = new Random();
    private World         worldMap;
    private MapConnection animatedConnection;

    @Override public void init() {
        worldMap = WorldBuilder.create()
                               .resolution(Resolution.HI_RES)
                               .zoomEnabled(true)
                               .hoverEnabled(false)
                               .selectionEnabled(false)
                               .backgroundColor(Color.WHITE)
                               .fillColor(Color.LIGHTGRAY)
                               .connectionWidth(1)
                               .weightedMapPoints(WeightedMapPoints.NONE)
                               .weightedMapConnections(false)
                               .arrowsVisible(false)
                               .drawImagePath(true)
                               .mapPointTextVisible(true)
                               .textColor(Color.BLACK)
                               .build();

        MapPoint calgary           = new MapPoint("Calgary", Color.RED,51.08299176,-114.0799982);
        MapPoint san_francisco     = new MapPoint("San Francisco", Color.BLUE, 37.74000775,-122.4599777);
        MapPoint new_york          = new MapPoint("New York", Color.BLUE,40.74997906,-73.98001693);
        MapPoint chicago           = new MapPoint("Chicago", Color.BLUE,41.82999066,-87.75005497);
        MapPoint denver            = new MapPoint("Denver",Color.BLUE, 39.73918805,-104.984016);

        MapPoint mexico_city       = new MapPoint("Mexico City",Color.GREEN, 19.44244244,-99.1309882);
        MapPoint buenos_aires      = new MapPoint("Buenos Aires", Color.LIGHTBLUE, -34.60250161,-58.39753137);
        MapPoint santiago_de_chile = new MapPoint("Santiago de Chile", Color.BLUE,-33.45001382,-70.66704085);
        MapPoint sao_paulo         = new MapPoint("Sao Paulo", Color.GREEN, -23.55867959,-46.62501998);

        MapPoint berlin            = new MapPoint("Berlin", Color.DARKORANGE, 52.52181866, 13.40154862);
        MapPoint paris             = new MapPoint("Paris", Color.DARKBLUE, 48.86669293,2.333335326);
        MapPoint madrid            = new MapPoint("Madrid", Color.YELLOW,40.40002626,-3.683351686);

        MapPoint johannesburg      = new MapPoint("Johannesburg", Color.BROWN,-26.17004474,28.03000972);
        MapPoint casablanca        = new MapPoint("Casablanca", Color.SADDLEBROWN,33.59997622,-7.616367433);
        MapPoint tunis             = new MapPoint("Tunis", Color.DARKGREEN,36.80277814,10.1796781);
        MapPoint alexandria        = new MapPoint("Alexandria", Color.BLACK,31.20001935,29.94999589);
        MapPoint nairobi           = new MapPoint("Nairobi", Color.LIGHTBLUE,-1.283346742,36.81665686);
        MapPoint abidjan           = new MapPoint("Abidjan", Color.IVORY,5.319996967,-4.04004826);

        MapPoint moscow            = new MapPoint("Moscow", Color.RED,55.75216412,37.61552283);
        MapPoint novosibirsk       = new MapPoint("Novosibirsk", Color.RED,55.02996014,82.96004187);
        MapPoint magadan           = new MapPoint("Magadan", Color.RED,59.57497988,150.8100089);

        MapPoint abu_dabi          = new MapPoint("Abu Dhabi", Color.GOLD, 24.46668357,54.36659338);
        MapPoint mumbai            = new MapPoint("Mumbai", Color.GOLD, 19.01699038,72.8569893);
        MapPoint hyderabad         = new MapPoint("Hyderabad", Color.GOLD,17.39998313,78.47995357);

        MapPoint beijing           = new MapPoint("Beijing", Color.DARKRED,39.92889223,116.3882857);
        MapPoint chongqing          = new MapPoint("Chongqing", Color.DARKRED,29.56497703,106.5949816);
        MapPoint hong_kong         = new MapPoint("Hong Kong", Color.DARKRED,22.3049809,114.1850093);
        MapPoint singapore         = new MapPoint("Singapore", Color.CRIMSON, 1.293033466,103.8558207);
        MapPoint tokio             = new MapPoint("Tokio",Color.RED, 35.652832,139.839478);

        MapPoint sydney            = new MapPoint("Sydney", Color.BLUE, -33.865143, 151.209900);
        MapPoint perth             = new MapPoint("Perth", Color.BLUE, -31.95501463,115.8399987);
        MapPoint christchurch      = new MapPoint("Christchurch", Color.BLUE, -43.53503131,172.6300207);


        List<MapPoint> northAmerica = List.of(calgary, san_francisco, chicago, new_york, denver);
        List<MapPoint> southAmerica = List.of(mexico_city, buenos_aires, santiago_de_chile, sao_paulo);
        List<MapPoint> europe       = List.of(madrid, paris, berlin);
        List<MapPoint> afrika       = List.of(johannesburg, casablanca, tunis, alexandria, nairobi, abidjan);
        List<MapPoint> russia       = List.of(moscow, novosibirsk, magadan);
        List<MapPoint> india        = List.of(abu_dabi, mumbai, hyderabad);
        List<MapPoint> asia         = List.of(beijing, hong_kong, singapore, tokio, chongqing);
        List<MapPoint> australia    = List.of(sydney, perth, christchurch);

        worldMap.addMapPoints(berlin, paris, san_francisco, abu_dabi, new_york, chicago, denver, sao_paulo, madrid, calgary,
                              mexico_city, buenos_aires, santiago_de_chile, johannesburg, moscow, novosibirsk, magadan,
                              mumbai, beijing, hong_kong, sydney, christchurch, tokio, singapore, casablanca, tunis, alexandria, nairobi,
                              abidjan, hyderabad, chongqing, perth);

        /*
        northAmerica.forEach(mapPoint -> {
            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));
        });
        asia.forEach(mapPoint -> {
            worldMap.addMapConnections(new MapConnection(berlin, mapPoint, RND.nextInt(130) + 10, berlin.getFill(), Color.ORANGERED, true));
        });
        australia.forEach(mapPoint -> {
            worldMap.addMapConnections(new MapConnection(beijing, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));
            worldMap.addMapConnections(new MapConnection(hong_kong, mapPoint, RND.nextInt(130) + 10, beijing.getFill(), Color.PURPLE, true));
        });
        europe.forEach(mapPoint -> {
            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));
        });
        southAmerica.forEach(mapPoint -> {
            worldMap.addMapConnections(new MapConnection(johannesburg, mapPoint, RND.nextInt(130) + 10, johannesburg.getFill(), Color.ORANGE, true));
        });
        */

        MapConnection sanfrancisco_mumbai     = new MapConnection(san_francisco, mumbai, 90, Color.ORANGERED, Color.BLUE, true);
        MapConnection sanfrancisco_newyork    = new MapConnection(san_francisco, new_york, 100, Color.ORANGERED, Color.BLUE, true);
        MapConnection sanfrancisco_abudabi    = new MapConnection(san_francisco, abu_dabi, 60, Color.ORANGERED, Color.BLUE, true);
        MapConnection sanfrancisco_mexicocity = new MapConnection(san_francisco, mexico_city, 30, Color.ORANGERED, Color.BLUE, true);
        MapConnection sanfrancisco_santiago   = new MapConnection(san_francisco, santiago_de_chile, 70, Color.ORANGERED, Color.BLUE, true);


        animatedConnection = new MapConnection(berlin, christchurch, 1, Color.CRIMSON);
        animatedConnection.setLineWidth(5);

        //worldMap.addMapConnections(sanfrancisco_mumbai, sanfrancisco_abudabi, sanfrancisco_newyork, sanfrancisco_mexicocity, sanfrancisco_santiago);
    }

    @Override public void start(Stage stage) {
        StackPane pane = new StackPane(worldMap);

        Scene scene = new Scene(pane);

        stage.setTitle("Worldmap Connections");
        stage.setScene(scene);
        stage.show();

        Image plane = new Image(WorldmapConnectionsTest.class.getResourceAsStream("plane.png"));
        pane.setOnMousePressed(e -> worldMap.animateImageAlongConnection(plane, animatedConnection));
    }

    @Override public void stop() {
        System.exit(0);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```


Overlapping Code:
```
public class WorldmapConnectionsTest extends Application {
private static final Random RND = new Random();
private World worldMap;
private MapConnection animatedConnection;
@Override public void init() {
worldMap = WorldBuilder.create()
.resolution(Resolution.HI_RES)
.zoomEnabled(true)
.hoverEnabled(false)
.selectionEnabled(false)
.backgroundColor(Color.WHITE)
.fillColor(Color.LIGHTGRAY)
.connectionWidth(1)
.weightedMapPoints(WeightedMapPoints.NONE)
.weightedMapConnections(false)
.arrowsVisible(false)
.drawImagePath(true)
.mapPointTextVisible(true)
.textColor(Color.BLACK)
.build();
MapPoint calgary = new MapPoint("Calgary", Color.RED,51.08299176,-114.0799982);
MapPoint san_francisco = new MapPoint("San Francisco", Color.BLUE, 37.74000775,-122.4599777);
MapPoint new_york = new MapPoint("New York", Color.BLUE,40.74997906,-73.98001693);
MapPoint chicago = new MapPoint("Chicago", Color.BLUE,41.82999066,-87.75005497);
MapPoint denver = new MapPoint("Denver",Color.BLUE, 39.73918805,-104.984016);
MapPoint mexico_city = new MapPoint("Mexico City",Color.GREEN, 19.44244244,-99.1309882);
MapPoint buenos_aires = new MapPoint("Buenos Aires", Color.LIGHTBLUE, -34.60250161,-58.39753137);
MapPointle", Color.BLUE,-33.45001382,-70.66704085);
MapPoint sao_paulo = new MapPoint("Sao Paulo", Color.GREEN, -23.55867959,-46.62501998);
MapPoint berlin = new MapPoint("Berlin", Color.DARKORANGE, 52.52181866, 13.40154862);
MapPoint paris = new MapPoint("Paris", Color.DARKBLUE, 48.86669293,2.333335326);
MapPoint madrid = new MapPoint("Madrid", Color.YELLOW,40.40002626,-3.683351686);
MapPoint johannesburg = new MapPoint("Johannesburg", Color.BROWN,-26.17004474,28.03000972);
MapPoint casablanca = new MapPoint("Casablanca", Color.SADDLEBROWN,33.59997622
```
<Overlap Ratio: 0.9689922480620154>

---

--- 40 --
Question ID: 293427dcf404bcb02f8d8b80d8f20b38609a6093_0
Original Code:
```
final class V0ModMetadataParser {
	private static final Pattern WEBSITE_PATTERN = Pattern.compile("\\((.+)\\)");
	private static final Pattern EMAIL_PATTERN = Pattern.compile("<(.+)>");

	public static LoaderModMetadata parse(Logger logger, JsonReader reader) throws IOException, ParseMetadataException {
		List<ParseWarning> warnings = new ArrayList<>();

		// All the values the `fabric.mod.json` may contain:
		// Required
		String id = null;
		Version version = null;

		// Optional (mod loading)
		Map<String, ModDependency> requires = new HashMap<>();
		Map<String, ModDependency> conflicts = new HashMap<>();
		V0ModMetadata.Mixins mixins = null;
		ModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal
		String initializer = null;
		List<String> initializers = new ArrayList<>();

		String name = null;
		String description = null;
		Map<String, ModDependency> recommends = new HashMap<>();
		List<Person> authors = new ArrayList<>();
		List<Person> contributors = new ArrayList<>();
		ContactInformation links = null;
		String license = null;

		while (reader.hasNext()) {
			final String key = reader.nextName();

			switch (key) {
			case "schemaVersion":
				// Duplicate field, make sure it matches our current schema version
				if (reader.peek() != JsonToken.NUMBER) {
					throw new ParseMetadataException("Duplicate \"schemaVersion\" field is not a number", reader);
				}

				final int read = reader.nextInt();

				if (read != 0) {
					throw new ParseMetadataException(String.format("Duplicate \"schemaVersion\" field does not match the predicted schema version of 0. Duplicate field value is %s", read), reader);
				}

				break;
			case "id":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Mod id must be a non-empty string with a length of 3-64 characters.", reader);
				}

				id = reader.nextString();
				break;
			case "version":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Version must be a non-empty string", reader);
				}

				final String rawVersion = reader.nextString();

				try {
					version = VersionDeserializer.deserialize(rawVersion);
				} catch (VersionParsingException e) {
					throw new ParseMetadataException(String.format("Failed to parse version: %s", rawVersion), e);
				}

				break;
			case "requires":
				readDependenciesContainer(reader, requires, "requires");
				break;
			case "conflicts":
				readDependenciesContainer(reader, conflicts, "conflicts");
				break;
			case "mixins":
				mixins = readMixins(warnings, reader);
				break;
			case "side":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Side must be a string", reader);
				}

				final String rawEnvironment = reader.nextString();

				switch (rawEnvironment) {
				case "universal":
					environment = ModEnvironment.UNIVERSAL;
					break;
				case "client":
					environment = ModEnvironment.CLIENT;
					break;
				case "server":
					environment = ModEnvironment.SERVER;
					break;
				default:
					warnings.add(new ParseWarning(reader.locationString(), rawEnvironment, "Invalid side type"));
				}

				break;
			case "initializer":
				// `initializer` and `initializers` cannot be used at the same time
				if (!initializers.isEmpty()) {
					throw new ParseMetadataException("initializer and initializers should not be set at the same time! (mod ID '" + id + "')");
				}

				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Initializer must be a non-empty string", reader);
				}

				initializer = reader.nextString();
				break;
			case "initializers":
				// `initializer` and `initializers` cannot be used at the same time
				if (initializer != null) {
					throw new ParseMetadataException("initializer and initializers should not be set at the same time! (mod ID '" + id + "')");
				}

				if (reader.peek() != JsonToken.BEGIN_ARRAY) {
					throw new ParseMetadataException("Initializers must be in a list", reader);
				}

				reader.beginArray();

				while (reader.hasNext()) {
					if (reader.peek() != JsonToken.STRING) {
						throw new ParseMetadataException("Initializer in initializers list must be a string", reader);
					}

					initializers.add(reader.nextString());
				}

				reader.endArray();

				break;
			case "name":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Name must be a string", reader);
				}

				name = reader.nextString();
				break;
			case "description":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("Mod description must be a string", reader);
				}

				description = reader.nextString();
				break;
			case "recommends":
				readDependenciesContainer(reader, recommends, "recommends");
				break;
			case "authors":
				readPeople(warnings, reader, authors);
				break;
			case "contributors":
				readPeople(warnings, reader, contributors);
				break;
			case "links":
				links = readLinks(warnings, reader);
				break;
			case "license":
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException("License name must be a string", reader);
				}

				license = reader.nextString();
				break;
			default:
				warnings.add(new ParseWarning(reader.locationString(), key, "Unsupported root entry"));
				reader.skipValue();
				break;
			}
		}

		// Validate all required fields are resolved
		if (id == null) {
			throw new ParseMetadataException.MissingRequired("id");
		}

		if (version == null) {
			throw new ParseMetadataException.MissingRequired("version");
		}

		FabricModMetadataReader.logWarningMessages(logger, id, warnings);

		// Optional stuff
		if (links == null) {
			links = ContactInformation.EMPTY;
		}

		return new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);
	}

	private static ContactInformation readLinks(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
		final Map<String, String> contactInfo = new HashMap<>();

		switch (reader.peek()) {
		case STRING:
			contactInfo.put("homepage", reader.nextString());
			break;
		case BEGIN_OBJECT:
			reader.beginObject();

			while (reader.hasNext()) {
				final String key = reader.nextName();

				switch (key) {
				case "homepage":
					if (reader.peek() != JsonToken.STRING) {
						throw new ParseMetadataException("homepage link must be a string", reader);
					}

					contactInfo.put("homepage", reader.nextString());
					break;
				case "issues":
					if (reader.peek() != JsonToken.STRING) {
						throw new ParseMetadataException("issues link must be a string", reader);
					}

					contactInfo.put("issues", reader.nextString());
					break;
				case "sources":
					if (reader.peek() != JsonToken.STRING) {
						throw new ParseMetadataException("sources link must be a string", reader);
					}

					contactInfo.put("sources", reader.nextString());
					break;
				default:
					warnings.add(new ParseWarning(reader.locationString(), key, "Unsupported links entry"));
					reader.skipValue();
				}
			}

			reader.endObject();
			break;
		default:
			throw new ParseMetadataException("Expected links to be an object or string", reader);
		}

		return new MapBackedContactInformation(contactInfo);
	}

	private static V0ModMetadata.Mixins readMixins(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
		final List<String> client = new ArrayList<>();
		final List<String> common = new ArrayList<>();
		final List<String> server = new ArrayList<>();

		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
			throw new ParseMetadataException("Expected mixins to be an object.", reader);
		}

		reader.beginObject();

		while (reader.hasNext()) {
			final String environment = reader.nextName();

			switch (environment) {
			case "client":
				client.addAll(readStringArray(reader, "client"));
				break;
			case "common":
				common.addAll(readStringArray(reader, "common"));
				break;
			case "server":
				server.addAll(readStringArray(reader, "server"));
				break;
			default:
				warnings.add(new ParseWarning(reader.locationString(), environment, "Invalid environment type"));
				reader.skipValue();
			}
		}

		reader.endObject();
		return new V0ModMetadata.Mixins(client, common, server);
	}

	private static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {
		switch (reader.peek()) {
		case NULL:
			reader.nextNull();
			return Collections.emptyList();
		case STRING:
			return Collections.singletonList(reader.nextString());
		case BEGIN_ARRAY:
			reader.beginArray();
			final List<String> list = new ArrayList<>();

			while (reader.hasNext()) {
				if (reader.peek() != JsonToken.STRING) {
					throw new ParseMetadataException(String.format("Expected entries in %s to be an array of strings", key), reader);
				}

				list.add(reader.nextString());
			}

			reader.endArray();
			return list;
		default:
			throw new ParseMetadataException(String.format("Expected %s to be a string or an array of strings", key), reader);
		}
	}

	private static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> dependencies, String name) throws IOException, ParseMetadataException {
		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
			throw new ParseMetadataException(String.format("%s must be an object containing dependencies.", name), reader);
		}

		reader.beginObject();

		while (reader.hasNext()) {
			final String modId = reader.nextName();
			final List<String> versionMatchers = new ArrayList<>();

			switch (reader.peek()) {
			case STRING:
				versionMatchers.add(reader.nextString());
				break;
			case BEGIN_ARRAY:
				reader.beginArray();

				while (reader.hasNext()) {
					if (reader.peek() != JsonToken.STRING) {
						throw new ParseMetadataException("List of version requirements must be strings", reader);
					}

					versionMatchers.add(reader.nextString());
				}

				reader.endArray();
				break;
			default:
				throw new ParseMetadataException("Expected version to be a string or array", reader);
			}

			dependencies.put(modId, new ModDependencyImpl(modId, versionMatchers));
		}

		reader.endObject();
	}

	private static void readPeople(List<ParseWarning> warnings, JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {
		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
			throw new ParseMetadataException("List of people must be an array", reader);
		}

		reader.beginArray();

		while (reader.hasNext()) {
			people.add(readPerson(warnings, reader));
		}

		reader.endArray();
	}

	private static Person readPerson(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
		final HashMap<String, String> contactMap = new HashMap<>();
		String name = "";

		switch (reader.peek()) {
		case STRING:
			final String person = reader.nextString();
			String[] parts = person.split(" ");

			Matcher websiteMatcher = V0ModMetadataParser.WEBSITE_PATTERN.matcher(parts[parts.length - 1]);

			if (websiteMatcher.matches()) {
				contactMap.put("website", websiteMatcher.group(1));
				parts = Arrays.copyOf(parts, parts.length - 1);
			}

			Matcher emailMatcher = V0ModMetadataParser.EMAIL_PATTERN.matcher(parts[parts.length - 1]);

			if (emailMatcher.matches()) {
				contactMap.put("email", emailMatcher.group(1));
				parts = Arrays.copyOf(parts, parts.length - 1);
			}

			name = String.join(" ", parts);

			return new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));
		case BEGIN_OBJECT:
			reader.beginObject();

			while (reader.hasNext()) {
				final String key = reader.nextName();

				switch (key) {
				case "name":
					if (reader.peek() != JsonToken.STRING) {
						break;
					}

					name = reader.nextString();
					break;
				case "email":
					if (reader.peek() != JsonToken.STRING) {
						break;
					}

					contactMap.put("email", reader.nextString());
					break;
				case "website":
					if (reader.peek() != JsonToken.STRING) {
						break;
					}

					contactMap.put("website", reader.nextString());
					break;
				default:
					warnings.add(new ParseWarning(reader.locationString(), key, "Unsupported contact information entry"));
					reader.skipValue();
				}
			}

			reader.endObject();
			return new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));
		default:
			throw new ParseMetadataException("Expected person to be a string or object", reader);
		}
	}
}
```


Overlapping Code:
```
tic final Pattern WEBSITE_PATTERN = Pattern.compile("\\((.+)\\)");
private static final Pattern EMAIL_PATTERN = Pattern.compile("<(.+)>");
public static LoaderModMetadata parse(Logger logger, JsonReader reader) throws IOException, ParseMetadataException {
List<ParseWarning> warnings = new ArrayList<>();
// All the values the `fabric.mod.json` may contain:
// Required
String id = null;
Version version = null;
// Optional (mod loading)
Map<String, ModDependency> requires = new HashMap<>();
Map<String, ModDependency> conflicts = new HashMap<>();
V0ModMetadata.Mixins mixins = null;
ModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal
String initializer = null;
List<String> initializers = new ArrayList<>();
String name = null;
String description = null;
Map<String, ModDependency> recommends = new HashMap<>();
List<Person> authors = new ArrayList<>();
List<Person> contributors = new ArrayList<>();
ContactInformation links = null;
String license = null;
while (reader.hasNext()) {
final String key = reader.nextName();
switch (key) {
case "schemaVersion":
// Duplicate field, make sure it matches our current schema version
if (reader.peek() != JsonToken.NUMBER) {
throw new ParseMetadataException("Duplicate \"schemaVersion\" field is not a number", reader);
}
final int read = reader.nextInt();
if (read != 0) {
throw new ParseMetadataException(String.format("Duplicate \"schemaVersion\" field does not match the predicted schema version of 0. Duplicate field value is %s", read), reader);
}
break;
case "id":
if (reader.peek() != JsonToken.STRING) {
throw new ParseMetadataException("Mod id must be a non-empty string with a length of 3-64 characters.", reader);
}
id = reader.nextString();
break;
case "version":
if (reader.peek() != JsonToken.STRING) {
throw new ParseMetadataException("Version must be a non-empty string", reader);
}
final String rawVersion = reader.nextString();
try {
version = VersionDeserializer.deserialize(rawVersion);
} catch (VersionParsingException e) {
throw new ParseMetadataException(String.format("Failed to parse version: %s", rawVersion), e);
}
break;
case "requires":
readDependenciesContainer(reader, requires, "requires");
break;
case "conflicts":
readDependenciesConta
```
<Overlap Ratio: 0.9752925877763329>

---

--- 41 --
Question ID: 6eb84c666362d423699cccf93c2cf2217f39e5a7_0
Original Code:
```
public class ComputeGrayCodeTest {

  private List<Integer> expected;
  private int numBits;

  @Test
  public void grayCode1() throws Exception {
    expected = Arrays.asList(0, 1, 2, 3);
    numBits = 2;

    test(expected, numBits);
  }

  @Test
  public void grayCode2() throws Exception {
    expected = Arrays.asList(0, 1, 3, 2, 6, 7, 5, 4);
    numBits = 3;

    test(expected, numBits);
  }

  private void test(List<Integer> expected, int numBits) {
    AssertUtils.assertSameContentsInt(expected, ComputeGrayCode.grayCode(numBits));
  }

}
```


Overlapping Code:
```
est {
private List<Integer> expected;
private int numBits;
@Test
public void grayCode1() throws Exception {
expected = Arrays.asList(0, 1, 2, 3);
numBits = 2;
test(expected, numBits);
}
@Test
public void grayCode2() throws Exception {
expected = Arrays.asList(0, 1, 3, 2, 6, 7, 5, 4);
numBits = 3;
test(expected, numBits);
}
private void test(List<Integer> expected, int numBits) {
AssertUtils.assertSameContentsInt(expected, ComputeGrayCode.grayCode
```
<Overlap Ratio: 0.9109311740890689>

---

--- 42 --
Question ID: ee65f005a54d16027d653a2c19c40ef485a42b36_0
Original Code:
```
public class PhoenixClusterMetricsCopier extends AbstractPhoenixMetricsCopier {
  private static final Log LOG = LogFactory.getLog(PhoenixClusterMetricsCopier.class);
  private Map<TimelineClusterMetric, MetricHostAggregate> aggregateMap = new HashMap<>();

  PhoenixClusterMetricsCopier(String inputTableName, String outputTableName, PhoenixHBaseAccessor hBaseAccessor, Set<String> metricNames, Long startTime, FileWriter processedMetricsFileWriter) {
    super(inputTableName, outputTableName, hBaseAccessor, metricNames, startTime, processedMetricsFileWriter);
  }

  @Override
  protected String getColumnsClause() {
    return "METRIC_NAME, " +
      "APP_ID, " +
      "INSTANCE_ID, " +
      "SERVER_TIME, " +
      "METRIC_SUM, " +
      "METRIC_COUNT, " +
      "METRIC_MAX, " +
      "METRIC_MIN";
  }

  @Override
  protected void saveMetrics() throws SQLException {
    LOG.debug(String.format("Saving %s results read from %s into %s", aggregateMap.size(), inputTable, outputTable));
    hBaseAccessor.saveClusterAggregateRecordsSecond(aggregateMap, outputTable);
  }

  @Override
  protected void addToResults(ResultSet rs) throws SQLException {
    TimelineClusterMetric timelineMetric = new TimelineClusterMetric(
            rs.getString("METRIC_NAME"), rs.getString("APP_ID"),
            rs.getString("INSTANCE_ID"), rs.getLong("SERVER_TIME"));

    MetricHostAggregate metricHostAggregate = new MetricHostAggregate();
    metricHostAggregate.setSum(rs.getDouble("METRIC_SUM"));
    metricHostAggregate.setNumberOfSamples(rs.getLong("METRIC_COUNT"));
    metricHostAggregate.setMax(rs.getDouble("METRIC_MAX"));
    metricHostAggregate.setMin(rs.getDouble("METRIC_MIN"));

    aggregateMap.put(timelineMetric, metricHostAggregate);

  }
}
```


Overlapping Code:
```
nds AbstractPhoenixMetricsCopier {
private static final Log LOG = LogFactory.getLog(PhoenixClusterMetricsCopier.class);
private Map<TimelineClusterMetric, MetricHostAggregate> aggregateMap = new HashMap<>();
PhoenixClusterMetricsCopier(String inputTableName, String outputTableName, PhoenixHBaseAccessor hBaseAccessor, Set<String> metricNames, Long startTime, FileWriter processedMetricsFileWriter) {
super(inputTableName, outputTableName, hBaseAccessor, metricNames, startTime, processedMetricsFileWriter);
}
@Override
protected String getColumnsClause() {
return "METRIC_NAME, " +
"APP_ID, " +
"INSTANCE_ID, " +
"SERVER_TIME, " +
"METRIC_SUM, " +
"METRIC_COUNT, " +
"METRIC_MAX, " +
"METRIC_MIN";
}
@Override
protected void saveMetrics() throws SQLException {
LOG.debug(String.format("Saving %s results read from %s into %s", aggregateMap.size(), inputTable, outputTable));
hBaseAccessor.saveClusterAggregateRecordsSecond(aggregateMap, outputTable);
}
@Override
protected void addToResults(ResultSet rs) throws SQLException {
TimelineClusterMetric timelineMetric = new TimelineClusterMetric(
rs.getString("METRIC_NAME"), rs.getString("APP_ID"),
rs.getString("INSTANCE_ID"), rs.getLong("SERVER_TIME"));
MetricHostAggregate metricHostAggregate = new MetricHostAggregate();
metricHostAggregate.setSum(rs.getDouble("METRIC_SUM"));
metricHostAggregate.setNumberOfSamples(rs.getLong("METRIC_COUNT"));
metricHostAggregate.setMax(rs.getDouble("METRIC_MAX"));
metricHostAggregate.setMin(rs.getDouble("METRIC_MIN"));
aggregateMap.put(timelineMetric, metricHo
```
<Overlap Ratio: 0.9615384615384616>

---

--- 43 --
Question ID: 175c69ffe0252f291b4f82da237fc1965ab13420_0
Original Code:
```
public class UserFactory {

    private UserRepository userRepository;

    public UserFactory(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public com.taotao.cloud.stock.biz.domain.model.user.User createUser(Mobile mobile, Email email, Password password, UserName userName, List<RoleId> roleIdList, TenantId currentTenantId) {
        List<com.taotao.cloud.stock.biz.domain.model.user.User> users = userRepository.find(mobile);
        com.taotao.cloud.stock.biz.domain.model.user.Account account;
        if (users != null && !users.isEmpty()) {
            for (com.taotao.cloud.stock.biz.domain.model.user.User user : users) {
                if (user.getTenantId().sameValueAs(currentTenantId)) {
                    throw new RuntimeException("租户内账号已存在");
                }
            }
            account = users.get(0).getAccount();
        } else {
            account = new Account(mobile, email, password);
        }
        if (roleIdList == null || roleIdList.isEmpty()) {
            throw new RuntimeException("角色未分配");
        }
        return new User(userName, account, roleIdList);
    }

}
```


Overlapping Code:
```
Factory {
private UserRepository userRepository;
public UserFactory(UserRepository userRepository) {
this.userRepository = userRepository;
}
public com.taotao.cloud.stock.biz.domain.model.user.User createUser(Mobile mobile, Email email, Password password, UserName userName, List<RoleId> roleIdList, TenantId currentTenantId) {
List<com.taotao.cloud.stock.biz.domain.model.user.User> users = userRepository.find(mobile);
com.taotao.cloud.stock.biz.domain.model.user.Account account;
if (users != null && !users.isEmpty()) {
for (com.taotao.cloud.stock.biz.domain.model.user.User user : users) {
if (user.getTenantId().sameValueAs(currentTenantId)) {
throw new RuntimeException("租户内账号已存在");
}
}
account = users.get(0).getAccount();
} else {
account = new Account(mobile, email, password);
}
if (roleIdList == null || roleIdList.isEmpty()) {
throw new RuntimeException("角色未分配");
}
return new User(userName, account, roleIdList);
}
}
```
<Overlap Ratio: 0.9820485744456178>

---

--- 44 --
Question ID: c7d84f5823ba3388e4323fdca618fb765ba83be2_0
Original Code:
```
@SpringBootApplication
@RestController
public class Application implements CommandLineRunner {

    @Autowired
    private ConfigurableEnvironment environment;


    @Value("${spring.cosmos.db.key:local}")
    private String cosmosDBkey;

    private static ObjectMapper mapper = new ObjectMapper();

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @GetMapping("hello")
    public String hello() {
        try {
            return mapper.writeValueAsString(System.getenv());
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return "Some error happens";
        }
    }

    @GetMapping("get")
    public String get() {
        return cosmosDBkey;
    }

    @GetMapping("env/{key}")
    public String env(@PathVariable String key) {
        final String property = environment.getProperty(key);
        return property;
    }

    @GetMapping("list")
    public String list() {
        final List list = new ArrayList();
        final MutablePropertySources propertySources = this.environment.getPropertySources();
        final Iterator<PropertySource<?>> iterator = propertySources.iterator();
        while (iterator.hasNext()) {
            final PropertySource<?> next = iterator.next();
            list.add(next.getName());
        }
        return JSON.toJSONString(list);
    }

    @GetMapping("getSpecificProperty/{ps}/{key}")
    public String getSpecificProperty(@PathVariable String ps, @PathVariable String key) {
        final MutablePropertySources propertySources = this.environment.getPropertySources();
        final PropertySource<?> propertySource = propertySources.get(ps);
        if (propertySource != null) {
            final Object property = propertySource.getProperty(key);
            return property == null ? null : property.toString();
        } else {
            return null;
        }
    }

    public void run(String... varl) throws Exception {
        System.out.println("property your-property-name value is: " + cosmosDBkey);
    }

}
```


Overlapping Code:
```
@SpringBootApplication
@RestController
public class Application implements CommandLineRunner {
@Autowired
private ConfigurableEnvironment environment;
@Value("${spring.cosmos.db.key:local}")
private String cosmosDBkey;
private static ObjectMapper mapper = new ObjectMapper();
public static void main(String[] args) {
SpringApplication.run(Application.class, args);
}
@GetMapping("hello")
public String hello() {
try {
return mapper.writeValueAsString(System.getenv());
} catch (JsonProcessingException e) {
e.printStackTrace();
return "Some error happens";
}
}
@GetMapping("get")
public String get() {
return cosmosDBkey;
}
@GetMapping("env/{key}")
public String env(@PathVariable String key) {
final String property = environment.getProperty(key);
return property;
}
@GetMapping("list")
public String list() {
final List list = new ArrayList();
final MutablePropertySources propertySources = this.environment.getPropertySources();
final Iterator<PropertySource<?>> iterator = propertySources.iterator();
while (iterator.hasNext()) {
final PropertySource<?> next = iterator.next();
list.add(next.getName());
}
return JSON.toJSONString(list);
}
@GetMapping("getSpecificProperty/{ps}/{key}")
public String getSpecificProperty(@PathVariable String ps, @PathVariable String key) {
final MutablePropertySources propertySources = this.environment.getPropertySources();
final PropertySource<?> propertySource = propertySources.get(ps);
if (propertySource != null) {
final Object property = propertySource.getProperty(key);
return property == null ? null : property.toString();
} else {
return null;
}
}
public void run(String... varl) throws Exception {
System.out.println("property your-property-name value is: " + cosmosDBk
```
<Overlap Ratio: 0.9953650057937428>

---

--- 45 --
Question ID: 31acfac9146e92236bf377117dcbd65c1fff71af_0
Original Code:
```
public class FoldedFigureRotate extends JPanel {
    private JButton foldedFigureRotateAntiClockwiseButton;
    private JPanel panel1;
    private JTextField foldedFigureRotateTextField;
    private JButton foldedFigureRotateClockwiseButton;
    private JButton foldedFigureRotateSetButton;

    public FoldedFigureRotate(ButtonService buttonService, FoldedFigureModel foldedFigureModel, MeasuresModel measuresModel) {
        add($$$getRootComponent$$$());

        buttonService.registerButton(foldedFigureRotateAntiClockwiseButton, "foldedFigureRotateAntiClockwiseAction");
        buttonService.registerButton(foldedFigureRotateSetButton, "foldedFigureRotateSetAction");
        buttonService.registerButton(foldedFigureRotateClockwiseButton, "foldedFigureRotateClockwiseAction");

        foldedFigureRotateAntiClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() + 11.25)));
        foldedFigureRotateSetButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(measuresModel.string2double(foldedFigureRotateTextField.getText(), foldedFigureModel.getRotation()))));
        foldedFigureRotateClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() - 11.25)));
        foldedFigureRotateTextField.addActionListener(e -> foldedFigureRotateSetButton.doClick());
    }

    public void setText(String text) {
        foldedFigureRotateTextField.setText(text);
        foldedFigureRotateTextField.setCaretPosition(0);
    }

    public String getText() {
        return foldedFigureRotateTextField.getText();
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 4, new Insets(0, 0, 0, 0), -1, -1));
        foldedFigureRotateAntiClockwiseButton = new JButton();
        foldedFigureRotateAntiClockwiseButton.setIcon(new ImageIcon(getClass().getResource("/ppp/oriagari_p_kaiten.png")));
        panel1.add(foldedFigureRotateAntiClockwiseButton, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        foldedFigureRotateTextField = new JTextField();
        foldedFigureRotateTextField.setColumns(2);
        panel1.add(foldedFigureRotateTextField, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, new Dimension(30, -1), null, null, 0, false));
        foldedFigureRotateSetButton = new JButton();
        foldedFigureRotateSetButton.setText("S");
        panel1.add(foldedFigureRotateSetButton, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        foldedFigureRotateClockwiseButton = new JButton();
        foldedFigureRotateClockwiseButton.setIcon(new ImageIcon(getClass().getResource("/ppp/oriagari_m_kaiten.png")));
        panel1.add(foldedFigureRotateClockwiseButton, new GridConstraints(0, 3, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return panel1;
    }

}
```


Overlapping Code:
```
 JPanel {
private JButton foldedFigureRotateAntiClockwiseButton;
private JPanel panel1;
private JTextField foldedFigureRotateTextField;
private JButton foldedFigureRotateClockwiseButton;
private JButton foldedFigureRotateSetButton;
public FoldedFigureRotate(ButtonService buttonService, FoldedFigureModel foldedFigureModel, MeasuresModel measuresModel) {
add($$$getRootComponent$$$());
buttonService.registerButton(foldedFigureRotateAntiClockwiseButton, "foldedFigureRotateAntiClockwiseAction");
buttonService.registerButton(foldedFigureRotateSetButton, "foldedFigureRotateSetAction");
buttonService.registerButton(foldedFigureRotateClockwiseButton, "foldedFigureRotateClockwiseAction");
foldedFigureRotateAntiClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() + 11.25)));
foldedFigureRotateSetButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(measuresModel.string2double(foldedFigureRotateTextField.getText(), foldedFigureModel.getRotation()))));
foldedFigureRotateClockwiseButton.addActionListener(e -> foldedFigureModel.setRotation(OritaCalc.angle_between_m180_180(foldedFigureModel.getRotation() - 11.25)));
foldedFigureRotateTextField.addActionListener(e -> foldedFigureRotateSetButton.doClick());
}
public void setText(String text) {
foldedFigureRotateTextField.setText(text);
foldedFigureRotateTextField.setCaretPosition(0);
}
public String getText() {
return foldedFigureRotateTextField.getText();
}
{
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
$$$setupUI$$$();
}
/**
* Method generated by IntelliJ IDEA GUI Designer
* >>> IMPORTANT!! <<<
* DO NOT edit this method OR call it in your code!
*
* @noinspection ALL
*/
private void $$$setupUI$$$() {
panel1 = new JPanel();
panel1.setLayout(new GridLayoutManager(1, 4, new Insets(0, 0, 0, 0), -1, -1));
foldedFigureRotateAntiClockwiseButton = new JButton();
foldedFigureRotateAntiClockwiseButton.setIcon(new ImageIcon(getClass().getResource("/ppp/oriagari_p_kaiten.png")));
panel1.add(foldedFigureRotateAntiClockwiseButton, new GridConstraints(0, 0, 1, 1, GridConstraints.
```
<Overlap Ratio: 0.9827890556045896>

---

--- 46 --
Question ID: cee3f2d9ac0ef0557dadf9ab913037859b04fd66_0
Original Code:
```
public class TestElasticsearchProcessManager {
    private ElasticsearchProcessManager elasticSearchProcessManager;

    @Before
    public void setup() {
        IConfiguration config = new FakeConfiguration("us-east-1", "test_cluster", "us-east-1a", "i-1234afd3");
        elasticSearchProcessManager = new ElasticsearchProcessManager(config);
    }

    @Test
    public void logProcessOutput_BadApp() throws IOException, InterruptedException {
        Process p = null;
        try {
            p = new ProcessBuilder("ls", "/tmppppp").start();
            int exitValue = p.waitFor();
            assertTrue(0 != exitValue);
            elasticSearchProcessManager.logProcessOutput(p);
        } catch (IOException ioe) {
            if (p != null) {
                elasticSearchProcessManager.logProcessOutput(p);
            }
        }
    }

    /**
     * Note: this will succeed on a *nix machine, unclear about anything else...
     */
    @Test
    public void logProcessOutput_GoodApp() throws IOException, InterruptedException {
        Process p = new ProcessBuilder("true").start();
        int exitValue = p.waitFor();
        assertEquals(0, exitValue);
        elasticSearchProcessManager.logProcessOutput(p);
    }
}
```


Overlapping Code:
```
csearchProcessManager {
private ElasticsearchProcessManager elasticSearchProcessManager;
@Before
public void setup() {
IConfiguration config = new FakeConfiguration("us-east-1", "test_cluster", "us-east-1a", "i-1234afd3");
elasticSearchProcessManager = new ElasticsearchProcessManager(config);
}
@Test
public void logProcessOutput_BadApp() throws IOException, InterruptedException {
Process p = null;
try {
p = new ProcessBuilder("ls", "/tmppppp").start();
int exitValue = p.waitFor();
assertTrue(0 != exitValue);
elasticSearchProcessManager.logProcessOutput(p);
} catch (IOException ioe) {
if (p != null) {
elasticSearchProcessManager.logProcessOutput(p);
}
}
}
/**
* Note: this will succeed on a *nix machine, unclear about anything else...
*/
@Test
public void logProcessOutput_GoodApp() throws IOException, InterruptedException {
Process p = new ProcessBuilder("true").start();
int exitValue = p.waitFor();
assertEquals(0, exitValue);
elasticSear
```
<Overlap Ratio: 0.9368836291913215>

---

--- 47 --
Question ID: 7ed1f75cb68c24db36b4704e2940d8df35499052_0
Original Code:
```
public class DiscoverResponse {
    private List<GGGroup> GGGroups;

    public List<GGGroup> getGGGroups() {
        return GGGroups;
    }

    public void setGGGroups(List<GGGroup> GGGroups) {
        this.GGGroups = GGGroups;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscoverResponse that = (DiscoverResponse) o;
        return Objects.equals(GGGroups, that.GGGroups);
    }

    @Override
    public int hashCode() {
        return Objects.hash(GGGroups);
    }
}
```


Overlapping Code:
```
oup> GGGroups;
public List<GGGroup> getGGGroups() {
return GGGroups;
}
public void setGGGroups(List<GGGroup> GGGroups) {
this.GGGroups = GGGroups;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
DiscoverResponse that = (DiscoverResponse) o;
return Objects.equals(GGGroups, that.GGGroups);
}
@Override
public int hashCode() {
return Objects.hash(GGGr
```
<Overlap Ratio: 0.8803245436105477>

---

--- 48 --
Question ID: 1fc904f0cd7d567a68ecb1abd53f180658d21438_0
Original Code:
```
public class LokiFilter implements Filter{

    static Log log = LogFactory.get(Thread.currentThread().getStackTrace()[1].getClassName());

    @Autowired
    HttpLogMapper httpLogMapper;

    @Value("${loki.adminPort}")
    private Integer adminPort;

    public static String getTime() {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String  nowtime = df.format(new Date());
        return nowtime;
    }



    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info("Loki Filter is init.... ");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;

        String ip = request.getRemoteAddr();
        String method = request.getMethod();
        String path = request.getServletPath();
        Map<String, String[]> param = request.getParameterMap();
        String parameter = Utils.params2string(param);

        StringBuilder headerStr = new StringBuilder();
        Enumeration headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()){
            String headerKey = (String) headerNames.nextElement();
            String headerValue = request.getHeader(headerKey);
            headerStr.append(String.format("%s: %s\r\n", headerKey, headerValue));
        }

        StringBuilder body = new StringBuilder();
        String str = null;
        try {
            BufferedReader br = request.getReader();
            while ((str = br.readLine())!=null){
                body.append(str);
            }
        }catch (Exception e){
            body.append(e.getMessage());
        }

        String time = getTime();

        String bheaderStr = Base64.getEncoder().encodeToString(headerStr.toString().getBytes());
        String bbody = Base64.getEncoder().encodeToString(body.toString().getBytes());

        if (!new AuthService().check(request)){
            httpLogMapper.addHttpLog(ip,method,path,parameter, bheaderStr, bbody,time);
        }

        filterChain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        log.info("Loki Filter was destroyed....");
    }
}
```


Overlapping Code:
```
ublic class LokiFilter implements Filter{
static Log log = LogFactory.get(Thread.currentThread().getStackTrace()[1].getClassName());
@Autowired
HttpLogMapper httpLogMapper;
@Value("${loki.adminPort}")
private Integer adminPort;
public static String getTime() {
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String nowtime = df.format(new Date());
return nowtime;
}
@Override
public void init(FilterConfig filterConfig) throws ServletException {
log.info("Loki Filter is init.... ");
}
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
HttpServletRequest request = (HttpServletRequest) servletRequest;
String ip = request.getRemoteAddr();
String method = request.getMethod();
String path = request.getServletPath();
Map<String, String[]> param = request.getParameterMap();
String parameter = Utils.params2string(param);
StringBuilder headerStr = new StringBuilder();
Enumeration headerNames = request.getHeaderNames();
while (headerNames.hasMoreElements()){
String headerKey = (String) headerNames.nextElement();
String headerValue = request.getHeader(headerKey);
headerStr.append(String.format("%s: %s\r\n", headerKey, headerValue));
}
StringBuilder body = new StringBuilder();
String str = null;
try {
BufferedReader br = request.getReader();
while ((str = br.readLine())!=null){
body.append(str);
}
}catch (Exception e){
body.append(e.getMessage());
}
String time = getTime();
String bheaderStr = Base64.getEncoder().encodeToString(headerStr.toString().getBytes());
String bbody = Base64.getEncoder().encodeToString(body.toString().getBytes());
if (!new AuthService().check(request)){
httpLogMapper.addHttpLog(ip,method,path,parameter, bheaderStr, bbody,time);
}
filterChain.doFilter(request, response);
}
@Override
public void destroy() {
log.info("Loki Filter was destroyed....
```
<Overlap Ratio: 0.99581589958159>

---

--- 49 --
Question ID: 4e5f33b9e9cb24ff6bd84bceab4e3030a436a5a6_0
Original Code:
```
final class BackupRequestExecutor<R> extends PolicyExecutor<BackupRequest<R>> {

    BackupRequestExecutor(final BackupRequest<R> policy, final AbstractExecution execution) {
        super(policy, execution);
    }

    @Override
    protected Supplier<CompletableFuture<ExecutionResult>> supplyAsync(
            final Supplier<CompletableFuture<ExecutionResult>> supplier,
            final Scheduler scheduler,
            final FailsafeFuture<Object> future) {

        return () -> {
            final CompletableFuture<ExecutionResult> original = supplier.get();
            final CompletableFuture<ExecutionResult> backup = new CompletableFuture<>();

            final Future<?> scheduledBackup = delay(scheduler, backup(supplier, backup));

            original.whenComplete(cancel(scheduledBackup));
            backup.whenComplete(cancel(original));

            return anyOf(original, backup);
        };
    }

    private Callable<CompletableFuture<ExecutionResult>> backup(
            final Supplier<CompletableFuture<ExecutionResult>> supplier,
            final CompletableFuture<ExecutionResult> target) {

        return () -> supplier.get().whenComplete(forwardTo(target));
    }

    @SuppressWarnings("unchecked")
    private <T> ScheduledFuture<T> delay(
            final Scheduler scheduler,
            final Callable<T> callable) {

        final long delay = policy.getDelay();
        final TimeUnit unit = policy.getUnit();
        return (ScheduledFuture<T>) scheduler.schedule(callable, delay, unit);
    }

    private <T> BiConsumer<T, Throwable> cancel(final Future<?> future) {
        return (result, throwable) -> future.cancel(true);
    }

    @SafeVarargs
    private final <T> CompletableFuture<T> anyOf(final CompletableFuture<? extends T>... futures) {
        final CompletableFuture<T> any = new CompletableFuture<>();

        for (final CompletableFuture<? extends T> future : futures) {
            future.whenComplete(forwardTo(any));
        }

        return any;
    }

}
```


Overlapping Code:
```
PolicyExecutor<BackupRequest<R>> {
BackupRequestExecutor(final BackupRequest<R> policy, final AbstractExecution execution) {
super(policy, execution);
}
@Override
protected Supplier<CompletableFuture<ExecutionResult>> supplyAsync(
final Supplier<CompletableFuture<ExecutionResult>> supplier,
final Scheduler scheduler,
final FailsafeFuture<Object> future) {
return () -> {
final CompletableFuture<ExecutionResult> original = supplier.get();
final CompletableFuture<ExecutionResult> backup = new CompletableFuture<>();
final Future<?> scheduledBackup = delay(scheduler, backup(supplier, backup));
original.whenComplete(cancel(scheduledBackup));
backup.whenComplete(cancel(original));
return anyOf(original, backup);
};
}
private Callable<CompletableFuture<ExecutionResult>> backup(
final Supplier<CompletableFuture<ExecutionResult>> supplier,
final CompletableFuture<ExecutionResult> target) {
return () -> supplier.get().whenComplete(forwardTo(target));
}
@SuppressWarnings("unchecked")
private <T> ScheduledFuture<T> delay(
final Scheduler scheduler,
final Callable<T> callable) {
final long delay = policy.getDelay();
final TimeUnit unit = policy.getUnit();
return (ScheduledFuture<T>) scheduler.schedule(callable, delay, unit);
}
private <T> BiConsumer<T, Throwable> cancel(final Future<?> future) {
return (result, throwable) -> future.cancel(true);
}
@SafeVarargs
private final <T> CompletableFuture<T> anyOf(final CompletableFuture<? extends T>... futures) {
final CompletableFuture<T> any = new CompletableFuture<>();
for (final CompletableFuture<? extends T> future : futures) {
future.whenComplete(forwa
```
<Overlap Ratio: 0.9561091340450771>

---

--- 50 --
Question ID: 2371fd7a216767cecabc030d1c52e9bf8c0ee50a_0
Original Code:
```
public class ModStatistics
{
	public static final Identifier INTERACT_WITH_ALLOY_KILN = Alloygery.identifier("interact_with_alloy_kiln");
	public static final Identifier INTERACT_WITH_BLAST_ALLOY_KILN = Alloygery.identifier("interact_with_blast_alloy_kiln");

	public static void register()
	{
		Registry.register(Registry.CUSTOM_STAT, "interact_with_alloy_kiln", INTERACT_WITH_ALLOY_KILN);
		Registry.register(Registry.CUSTOM_STAT, "interact_with_blast_alloy_kiln", INTERACT_WITH_BLAST_ALLOY_KILN);

		Stats.CUSTOM.getOrCreateStat(INTERACT_WITH_ALLOY_KILN, StatFormatter.DEFAULT);
		Stats.CUSTOM.getOrCreateStat(INTERACT_WITH_BLAST_ALLOY_KILN, StatFormatter.DEFAULT);
	}
}
```


Overlapping Code:
```
ic class ModStatistics
{
public static final Identifier INTERACT_WITH_ALLOY_KILN = Alloygery.identifier("interact_with_alloy_kiln");
public static final Identifier INTERACT_WITH_BLAST_ALLOY_KILN = Alloygery.identifier("interact_with_blast_alloy_kiln");
public static void register()
{
Registry.register(Registry.CUSTOM_STAT, "interact_with_alloy_kiln", INTERACT_WITH_ALLOY_KILN);
Registry.register(Registry.CUSTOM_STAT, "interact_with_blast_alloy_kiln", INTERACT_WITH_BLAST_ALLOY_KILN);
Stats.CUSTOM.getOrCreateStat(INTERACT_WITH_ALLOY_KILN, StatFormatter.DEFAULT);
Stats.CUSTOM.getOrCreateStat(INTERACT_WITH_BLAST_ALLOY_KILN, StatFormatter.DEFAULT);
```
<Overlap Ratio: 0.9878419452887538>

---

--- 51 --
Question ID: 5ef3646e714e5b80e01d25da946c545352922f83_0
Original Code:
```
public class Engine implements EventProcessor, GameManager {

    // Game States
    public final static int TITLE = 0;
    public final static int PLAY = 1;
    public final static int OVER = 2;
    //public final static int DEMO = 3;
    //public final static int PAUSE = 4;
    public final static int WIN = 5;
    //public final static int MENU = 6;
    public final static int HOF = 7;
    public final static int MENU = 8;

    int state;
    Player player;
    GameMIDlet midlet;

    /** If != "" draw text in the middle of screen */
    String centerText = "";

    private int level;
    private int calibration;
    private boolean level_started;
    private boolean done;
    private boolean autofire = false;

    //private int numLevels;

    Screen screen;
    EventHandler eh;
    private Sound sound;

    Hashtable enemies;
    Hashtable playerBullets;
    Hashtable background;
    private Hashtable foreground;
    private static final String levelFile = "/level.evt";

    public Engine(GameMIDlet midlet) throws Exception {
        int n;
        long then;

        this.midlet = midlet;
        screen = new Screen(this);

        reset();

        state = TITLE;

        then = System.currentTimeMillis();
        n = 0;

        for (int i = 0; i < 30000; i++) {
            n++;
        }

        if (n > 0) {
            calibration = (int) (System.currentTimeMillis() - then);
        }

        Thread runner = new Thread(this);

        runner.start();
    }

    void makeCollisions() throws Exception {
        String key1, key2;
        GameObject enemy, bullet;

        // collisions between enemies and player bullets
        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {
            key1 = (String) e.nextElement();
            enemy = (GameObject) enemies.get(key1);

            if (!enemy.bulletCollision)
                continue;

            for (Enumeration e2 = playerBullets.keys();
                e2.hasMoreElements();
                ) {
                key2 = (String) e2.nextElement();
                bullet = (GameObject) playerBullets.get(key2);

                if (enemy.collidesWith((Sprite) bullet, true)) {
                    enemy.energy -= bullet.damage;
                    bullet.energy -= enemy.damage;

                    if (bullet.energy <= 0) {
                        bullet.end();
                        playerBullets.remove(key2);
                    }

                    if (enemy.energy <= 0) {
                        player.points += enemy.points;
                        enemy.end();
                        enemies.remove(key1);
                        break;
                    }
                }
            }
        }

        // collisions between enemies and player
        if (player.isExploded) return;
        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {
            key1 = (String) e.nextElement();
            enemy = (GameObject) enemies.get(key1);

            if (player.collidesWith((Sprite) enemy, true)) {
                enemy.energy -= player.damage;
                player.energy -= enemy.damage;

                if(Settings.getUseVibration());
                    gcc.DeviceControl.startVibra(100, 300L);

                if (enemy.energy <= 0) {
                    player.points += enemy.points;
                    enemy.end();
                    enemies.remove(key1);
                }

                if (player.energy <= 0) {
                    player.lifes--;
                    player.end();

                    if (player.lifes < 0) {
                        state = Engine.OVER;
                        //player = null;
                    } else {
                        player.setVisible(false);
                        player.energy = 100; //TODO FIX:player.params.energy
                    }

                    return;
                }
            }
        }

    }

    void destroyOutOfScreen(Hashtable h, int x, int y, int x2, int y2) {
        GameObject o;
        String key;
        
        for (Enumeration e = h.keys(); e.hasMoreElements();) {
            key = (String) e.nextElement();
            o = (GameObject) h.get(key);

            if (o.getY() < y
                || o.getY() > y2
                || o.getX() < x
                || o.getX() > x2) {
                h.remove(key);
            }
        }
    }

    void destroyEndedBackground() {
        GameObject o;
        String key;

        for (Enumeration e = background.keys(); e.hasMoreElements();) {
            key = (String) e.nextElement();
            o = (GameObject) background.get(key);

            if (o.getFrame() == o.getFrameSequenceLength() - 1
                && o.loop == 0) {
                background.remove(key);
            }
        }
    }

    private void reset() throws Exception {
        level = 0;

        startLevel();
    }

    private DataInputStream getLevel(String level) throws Exception {
        DataInputStream dis = null;

        InputStream is = getClass().getResourceAsStream(level);

        if (is == null) {
            throw new Exception("ERROR: loading level file " + level);
        }

        dis = new DataInputStream(is);

        return dis;
    }

    private void restartLevel() throws Exception {
        synchronized (this) {
            level_started = true;
        }

        //screen.clearKeys();

        try {
            eh = new EventHandler(getLevel(levelFile), this);
        } catch (IOException e) {
            throw new Exception("ERROR: loading level file " + levelFile);
        }

        setScrollSpeed(20);
        Timing.reset();

        enemies = new Hashtable();
        playerBullets = new Hashtable();
        background = new Hashtable();
        foreground = new Hashtable();
        sound = new Sound();
        player = null;

        done = false;
        //autofire = false;
    }

    private void startLevel() throws Exception {
        restartLevel();
    }

/*
    private void nextLevel() throws Exception {
        level++;

        startLevel();
    }
*/
    public void setHof() {
        state = HOF;
    }
    
    void setMenu(boolean isGameOver) {        
        if (isGameOver) {
              screen.menu.deleteContinue();
          } else {
              //gameManager.pause();
              screen.menu.selectContinue();
          }
          
        state = MENU;
    }
    
    GraphicsMenu getMenu() {
        return screen.menu;
    }
    
    public void toggleAutofire() {       
        if (autofire) autofire = false;
        else autofire = true;     
    }

    public synchronized boolean levelStarted() {
        boolean x = level_started;

        level_started = false;

        return x;
    }

    public synchronized void start() {
        try {
            reset();
        } catch (Exception e) {
            midlet.showErrorMsg(e.getMessage());
        }

        state = PLAY;
    }

    public synchronized void stop() {
        done = true;
    }

    public void pause() {
        Timing.setPause(true);
    }

    public void resume() {
        state = PLAY;
        Timing.setPause(false);

        // ugly fix, breaks midp2.0 compatibility
        //screen.clearKeys();
    }

    public Canvas getCanvas() {
        return screen;
    }

    public void run() {
        long then;
        int keyStates, delta;

        then = System.currentTimeMillis();

        while (!done) {
            try {
                if (state == PLAY) {
                    // 1.- process new events
                    eh.processEvents();

                    // 2.- destroy all objects that are out of the limits
                    destroyOutOfScreen(
                        playerBullets,
                        -50,
                        -50,
                        Screen.width + 50,
                        Screen.height + 50);

                    destroyOutOfScreen(
                        enemies,
                        -200,
                        -200,
                        Screen.width + 200,
                        Screen.height + 200);

                    // 4.- collision detection
                    makeCollisions();

                    // 6.- movement and fire keys
                    keyStates = screen.getKeyStates();
                    KeyboardPath.setKeys(keyStates);
                    if ((autofire || (keyStates & GameCanvas.FIRE_PRESSED) != 0)
                        && player != null
                        && player.isVisible())
                        player.fire();

                }

                screen.drawFrame();

                if (state == PLAY)
                    destroyEndedBackground();

                delta = (int) (System.currentTimeMillis() - then);

                if (delta < 30 && calibration < 100) {
                    try {
                        Thread.sleep(30 - delta);
                    } catch (InterruptedException e) {
                    }
                }

                then = System.currentTimeMillis();
            } catch (Exception e) {
                String msg = e.getMessage();
                if(msg == null) msg = e.toString();
                e.printStackTrace();
                state = TITLE;
                midlet.showErrorMsg(msg);
            }
        }
    }

    public GameObject searchGameObject(String name) {
        GameObject o;

        o = (GameObject) enemies.get(name);
        if (o != null)
            return o;

        o = (GameObject) playerBullets.get(name);
        if (o != null)
            return o;

        if (name.equals("player"))
            return (GameObject) player;

        // TODO  searching in background and foreground

        return null;
    }
    
    public String searchGameObjectKey(GameObject o) {
        String key;
        
        for (Enumeration e = enemies.keys(); e.hasMoreElements();) {
                    key = (String) e.nextElement();
                    if((GameObject) enemies.get(key) == o) return key;
        }
        
        return null;
    }

    public void destroyGameObject(String name, Object creator) throws Exception {
        GameObject o;
        
        if(name.equals("*")) name = searchGameObjectKey((GameObject)creator);

        o = (GameObject) enemies.get(name);

        if (o != null) {
            o.end();
            enemies.remove(name);
        }

        // TODO searching in playerBullets, background and foreground
    }

    void setScrollSpeed(int s) {
        screen.starfield.setSpeed(s);
        Path.setScrollSpeed(s);
    }

    public void processEvent(Event e, Object creator) throws Exception {
        switch (e.type) {
            case Event.ENEMY :
                //System.out.println("ENEMY: " + e.name);
                enemies.put(
                    e.name,
                    GameObject.gameObjectFactory(
                        e,
                        this,
                        (GameObject) creator));
                break;
            case Event.PLAYER :
                //System.out.println("PLAYER: " + e.name);
                player = Player.playerFactory(e, this, (GameObject) creator);
                player.points = 0;
                TargetPlayerPath.setPlayer((GameObject) player);
                break;
            case Event.PLAYERBULLET :
                //System.out.println("PLAYERBULLET: " + e.name);
                playerBullets.put(
                    e.name,
                    GameObject.gameObjectFactory(
                        e,
                        this,
                        (GameObject) creator));
                break;
            case Event.BACKGROUND :
                //System.out.println("BACKGROUND: " + e.name);
                background.put(
                    e.name,
                    GameObject.gameObjectFactory(
                        e,
                        this,
                        (GameObject) creator));
                break;

            case Event.END :
                System.out.println("END: " + e.name);
                state = WIN;
                break;

            case Event.LOAD :
                System.out.println("Loading: " + e.name);
                eh.load(getLevel(e.name));
                break;

            case Event.SPEED :
                GameObject o =
                    searchGameObject(((ObjectPropParams) e.params).object);
                if (o != null)
                    o.path.params.speed += ((ObjectPropParams) e.params).value;
                break;
                
            case Event.LIFE :
                player.lifes += ((ObjectPropParams) e.params).value;
                break;
               
            case Event.ENERGY :
                GameObject o2 =
                    searchGameObject(((ObjectPropParams) e.params).object);
                if (o2 != null) {
                    o2.energy += ((ObjectPropParams) e.params).value;
                    if (o2.energy <= 0) {
                        o2.end();
                        enemies.remove(((ObjectPropParams) e.params).object);
                    }

                    // More energy that 100 not allow
                    if(o2.energy > 100) o2.energy = 100;
                }
                break;

            case Event.SOUND :
                //System.out.println("Playing: " + e.name);
                sound.playSound(e.name);
                break;

            case Event.DESTROY :
                System.out.println(
                    "Destroying: " + ((ObjectPropParams) e.params).object);
                destroyGameObject(((ObjectPropParams) e.params).object, creator);
                break;

            case Event.TEXT:
                centerText = ResourceBundle.getString("i18n.GameTexts", e.name);
                break;

            case Event.FIRE:
                GameObject obj =
                    searchGameObject(((ChangeEventParams) e.params).object);
                if (obj != null)
                    obj.fireEvent = ((ChangeEventParams) e.params).event;
                break;
        }
    }
}
```


Overlapping Code:
```
public class Engine implements EventProcessor, GameManager {
// Game States
public final static int TITLE = 0;
public final static int PLAY = 1;
public final static int OVER = 2;
//public final static int DEMO = 3;
//public final static int PAUSE = 4;
public final static int WIN = 5;
//public final static int MENU = 6;
public final static int HOF = 7;
public final static int MENU = 8;
int state;
Player player;
GameMIDlet midlet;
/** If != "" draw text in the middle of screen */
String centerText = "";
private int level;
private int calibration;
private boolean level_started;
private boolean done;
private boolean autofire = false;
//private int numLevels;
Screen screen;
EventHandler eh;
private Sound sound;
Hashtable enemies;
Hashtable playerBullets;
Hashtable background;
private Hashtable foreground;
private static final String levelFile = "/level.evt";
public Engine(GameMIDlet midlet) throws Exception {
int n;
long then;
this.midlet = midlet;
screen = new Screen(this);
reset();
state = TITLE;
then = System.currentTimeMillis();
n = 0;
for (int i = 0; i < 30000; i++) {
n++;
}
if (n > 0) {
calibration = (int) (System.currentTimeMillis() - then);
}
Thread runner = new Thread(this);
runner.start();
}
void makeCollisions() throws Exception {
String key1, key2;
GameObject enemy, bullet;
// collisions between enemies and player bullets
for (Enumeration e = enemies.keys(); e.hasMoreElements();) {
key1 = (String) e.nextElement();
enemy = (GameObject) enemies.get(key1);
if (!enemy.bulletCollision)
continue;
for (Enumeration e2 = playerBullets.keys();
e2.hasMoreElements();
) {
key2 = (String) e2.nextElement();
bullet = (GameObject) playerBullets.get(key2);
if (enemy.collidesWith((Sprite) bullet, true)) {
enemy.energy -= bullet.damage;
bullet.energy -= enemy.damage;
if (bullet.energy <= 0) {
bullet.end();
playerBullets.remove(key2
```
<Overlap Ratio: 0.9845662586482171>

---

--- 52 --
Question ID: a9cd3209edfafa6f8a0562f2f093883ddee7ae96_0
Original Code:
```
class LinkedList{
    Node head;
    public void swapNodes(int x,int y){
        if(x == y) return;
        //look for x
        Node prevX = null,currentX = head;
        while(currentX != null && currentX.data != x){
            prevX = currentX;
            currentX = currentX.next;
        }
        //look for y
        Node prevY = null,currentY = head;
        while(currentY != null && currentY.data != y){
            prevY = currentY;
            currentY = currentY.next;
        }
        if(currentX == null || currentY == null) return;
        // if x is not head,then make y the new head.
        if(prevX != null)
            prevX.next = currentY;
        else
            head = currentY;
        // if y is not head,then make x the new head.
        if(prevY != null)
            prevY.next = currentX;
        else
            head = currentX;
        // swap next pointers.
        Node temp = currentX.next;
        currentX.next = currentY.next;
        currentY.next = temp;
    }

    public void insertNode(int item){
        Node node = new Node(item);
        node.next = head;
        head = node; // move the head to point the next node
    }

    public void print(){
        Node node = head;
        while(node != null){
            System.out.print(node.data + " ");
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String args[]){
        LinkedList llist = new LinkedList();
        llist.insertNode(14);
        llist.insertNode(20);
        llist.insertNode(13);
        llist.insertNode(12);
        llist.insertNode(15);
        llist.insertNode(10);
        System.out.println("Before swap - ");
        llist.print();
        llist.swapNodes(12,20);
        System.out.println("After swap - ");
        llist.print();
    }
}
```


Overlapping Code:
```
Node head;
public void swapNodes(int x,int y){
if(x == y) return;
//look for x
Node prevX = null,currentX = head;
while(currentX != null && currentX.data != x){
prevX = currentX;
currentX = currentX.next;
}
//look for y
Node prevY = null,currentY = head;
while(currentY != null && currentY.data != y){
prevY = currentY;
currentY = currentY.next;
}
if(currentX == null || currentY == null) return;
// if x is not head,then make y the new head.
if(prevX != null)
prevX.next = currentY;
else
head = currentY;
// if y is not head,then make x the new head.
if(prevY != null)
prevY.next = currentX;
else
head = currentX;
// swap next pointers.
Node temp = currentX.next;
currentX.next = currentY.next;
currentY.next = temp;
}
public void insertNode(int item){
Node node = new Node(item);
node.next = head;
head = node; // move the head to point the next node
}
public void print(){
Node node = head;
while(node != null){
System.out.print(node.data + " ");
node = node.next;
}
System.out.println();
}
public static void main(String args[]){
LinkedList llist = new LinkedList();
llist.insertNode(14);
llist.insertNode(20);
llist.insertNode(13);
llist.insertNode(12);
llist.insertNode(15);
llist.insertNode(10);
System.out.println("Before swap - ");
llist.print();
llist.swapNodes(12,20);
System.out.println("
```
<Overlap Ratio: 0.9608277900960828>

---

--- 53 --
Question ID: 1e07b4cb88290aa5e3722fcbba740f81298d82b4_0
Original Code:
```
public class Sql2oIntegrationTest {


    @Test
    public void testSql2O() throws SQLException, ParseException {
        Connection connection = DbHelper.objectDb();
        try {
            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);
            Sql2o sql2o = new Sql2o(scds);

            Query query = sql2o.open().createQuery(DbHelper.TEST_DB_OBJECT_QUERY);
            query.setAutoDeriveColumnNames(true);
            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder());

            List<DbObject> dbObjects = query.executeAndFetch(DbObject.class);

            assertEquals(1, dbObjects.size());
            DbHelper.assertDbObjectMapping(dbObjects.get(0));

        } finally {
            connection.close();
        }
    }


    //IFJAVA8_START
    @Test
    public void testDiscriminator608() throws SQLException {
        Connection connection = DbHelper.getDbConnection(DbHelper.TargetDB.POSTGRESQL);
        if ( connection == null) return;
        try {
            SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);
            Sql2o sql2o = new Sql2o(scds);

            Query query = sql2o.open().createQuery("with t(id, type, name) as (values(1, 's', 'solar'), (2, 'e', 'electric')) select * from t" +
                    "");
            query.setAutoDeriveColumnNames(true);

            JdbcMapperFactory jdbcMapperFactory = JdbcMapperFactory
                    .newInstance()
                    .discriminator(Device.class,
                            "type",
                            ResultSet::getString,
                            b ->
                                    b.when("e", ElectricDevice.class)
                                            .when("s", SolarDevice.class));

            query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder(jdbcMapperFactory));


            List<Device> devices = query.executeAndFetch(Device.class);


            assertEquals(2, devices.size());

            assertEquals(new SolarDevice(1, "s", "solar"), devices.get(0));
            assertEquals(new ElectricDevice(2, "e", "electric"), devices.get(1));



        } finally {
            connection.close();
        }
    }
    //IFJAVA8_END


    public static abstract class Device {
        public final int id;
        public final String type;
        public final String name;

        protected Device(int id, String type, String name) {
            this.id = id;
            this.type = type;
            this.name = name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Device device = (Device) o;

            if (id != device.id) return false;
            if (type != null ? !type.equals(device.type) : device.type != null) return false;
            return name != null ? name.equals(device.name) : device.name == null;
        }

        @Override
        public int hashCode() {
            int result = id;
            result = 31 * result + (type != null ? type.hashCode() : 0);
            result = 31 * result + (name != null ? name.hashCode() : 0);
            return result;
        }
    }

    public static class ElectricDevice extends Device {
        public ElectricDevice(int id, String type, String name) {
            super(id, type, name);
        }



    }

    public static class SolarDevice extends Device {
        public SolarDevice(int id, String type, String name) {
            super(id, type, name);
        }
    }

}
```


Overlapping Code:
```
st
public void testSql2O() throws SQLException, ParseException {
Connection connection = DbHelper.objectDb();
try {
SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);
Sql2o sql2o = new Sql2o(scds);
Query query = sql2o.open().createQuery(DbHelper.TEST_DB_OBJECT_QUERY);
query.setAutoDeriveColumnNames(true);
query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder());
List<DbObject> dbObjects = query.executeAndFetch(DbObject.class);
assertEquals(1, dbObjects.size());
DbHelper.assertDbObjectMapping(dbObjects.get(0));
} finally {
connection.close();
}
}
//IFJAVA8_START
@Test
public void testDiscriminator608() throws SQLException {
Connection connection = DbHelper.getDbConnection(DbHelper.TargetDB.POSTGRESQL);
if ( connection == null) return;
try {
SingleConnectionDataSource scds = new SingleConnectionDataSource(connection, true);
Sql2o sql2o = new Sql2o(scds);
Query query = sql2o.open().createQuery("with t(id, type, name) as (values(1, 's', 'solar'), (2, 'e', 'electric')) select * from t" +
"");
query.setAutoDeriveColumnNames(true);
JdbcMapperFactory jdbcMapperFactory = JdbcMapperFactory
.newInstance()
.discriminator(Device.class,
"type",
ResultSet::getString,
b ->
b.when("e", ElectricDevice.class)
.when("s", SolarDevice.class));
query.setResultSetHandlerFactoryBuilder(new SfmResultSetHandlerFactoryBuilder(jdbcMapperFactory));
List<Device> devices = query.executeAndFetch(Device.class);
assertEquals(2, devices.size());
assertEquals(new SolarDevice(1, "s", "solar"), devices.get(0));
assertEquals(new ElectricDevice(2, "e", "electric"), devices.get(1));
} finally {
connection.close();
}
}
//IFJAVA8_END
public static abstract class Device {
public final int id;
public final String type;
public final String name;
protected Devi
```
<Overlap Ratio: 0.9610250934329952>

---

--- 54 --
Question ID: 712e63e3cbb226a50631cdb060500a83fbc9674d_0
Original Code:
```
public class MinaComponentWithConfigurationTest extends CamelTestSupport {

    @Test
    public void testMinaComponentWithConfiguration() throws Exception {
        MinaComponent comp = context.getComponent("mina", MinaComponent.class);

        MinaConfiguration cfg = new MinaConfiguration();
        cfg.setTextline(true);

        comp.setConfiguration(cfg);
        assertSame(cfg, comp.getConfiguration());

        MinaEndpoint e1 = (MinaEndpoint) comp.createEndpoint("mina://tcp://localhost:4455");
        MinaEndpoint e2 = (MinaEndpoint) comp.createEndpoint("mina://tcp://localhost:5566?sync=false");

        // should not be same
        assertNotSame(e1, e2);
        assertNotSame(e1.getConfiguration(), e2.getConfiguration());

        e2.getConfiguration().setPort(5566);

        assertEquals(true, e1.getConfiguration().isSync());
        assertEquals(false, e2.getConfiguration().isSync());
        assertEquals(true, e1.getConfiguration().isTextline());
        assertEquals(true, e2.getConfiguration().isTextline());
        assertEquals(4455, e1.getConfiguration().getPort());
        assertEquals(5566, e2.getConfiguration().getPort());
    }
}
```


Overlapping Code:
```
 class MinaComponentWithConfigurationTest extends CamelTestSupport {
@Test
public void testMinaComponentWithConfiguration() throws Exception {
MinaComponent comp = context.getComponent("mina", MinaComponent.class);
MinaConfiguration cfg = new MinaConfiguration();
cfg.setTextline(true);
comp.setConfiguration(cfg);
assertSame(cfg, comp.getConfiguration());
MinaEndpoint e1 = (MinaEndpoint) comp.createEndpoint("mina://tcp://localhost:4455");
MinaEndpoint e2 = (MinaEndpoint) comp.createEndpoint("mina://tcp://localhost:5566?sync=false");
// should not be same
assertNotSame(e1, e2);
assertNotSame(e1.getConfiguration(), e2.getConfiguration());
e2.getConfiguration().setPort(5566);
assertEquals(true, e1.getConfiguration().isSync());
assertEquals(false, e2.getConfiguration().isSync());
assertEquals(true, e1.getConfiguration().isTextline());
assertEquals(true, e2.getConfiguration().isTextline());
assertEquals(4455, e1.getConfiguration().getPort());
assertEquals(5566, e2.getConfiguration(
```
<Overlap Ratio: 0.9772951628825272>

---

--- 55 --
Question ID: b53ab9010c6b27272b456d66e13ba741d5650cac_0
Original Code:
```
public final class GateExpansionPulsar extends GateExpansionBuildcraft implements IGateExpansion {

	public static GateExpansionPulsar INSTANCE = new GateExpansionPulsar();

	private GateExpansionPulsar() {
		super("pulsar");
	}

	@Override
	public GateExpansionController makeController(TileEntity pipeTile) {
		return new GateExpansionControllerPulsar(pipeTile);
	}

	private class GateExpansionControllerPulsar extends GateExpansionController {

		private static final int PULSE_PERIOD = 10;
		private boolean isActive;
		private boolean singlePulse;
		private boolean hasPulsed;
		private int tick;
		private int count;

		public GateExpansionControllerPulsar(TileEntity pipeTile) {
			super(GateExpansionPulsar.this, pipeTile);

			// by default, initialize tick so that not all gates created at
			// one single moment would do the work at the same time. This
			// spreads a bit work load. Note, this is not a problem for
			// existing gates since tick is stored in NBT
			tick = (int) (Math.random() * PULSE_PERIOD);
		}

		@Override
		public void startResolution() {
			if (isActive()) {
				disablePulse();
			}
		}

		@Override
		public boolean resolveAction(IStatement action, int count) {
			if (action instanceof ActionEnergyPulsar) {
				enablePulse(count);
				return true;
			} else if (action instanceof ActionSingleEnergyPulse) {
				enableSinglePulse(count);
				return true;
			}
			return false;
		}

		@Override
		public void addActions(List<IActionInternal> list) {
			super.addActions(list);
			list.add(BuildCraftTransport.actionEnergyPulser);
			list.add(BuildCraftTransport.actionSingleEnergyPulse);
		}

		@Override
		public void tick(IGate gate) {
			if (!isActive && hasPulsed) {
				hasPulsed = false;
			}

			if (tick++ % PULSE_PERIOD != 0) {
				// only do the treatement once every period
				return;
			}

			if (!isActive) {
				gate.setPulsing(false);
				return;
			}

			if (pipeTile instanceof IEnergyHandler && (!singlePulse || !hasPulsed)) {
				gate.setPulsing(true);
				((IEnergyHandler) pipeTile).receiveEnergy(ForgeDirection.UNKNOWN, Math.min(1 << (count - 1), 64) * 10,
						false);
				hasPulsed = true;
			} else {
				gate.setPulsing(true);
			}
		}

		private void enableSinglePulse(int count) {
			singlePulse = true;
			isActive = true;
			this.count = count;
		}

		private void enablePulse(int count) {
			isActive = true;
			singlePulse = false;
			this.count = count;
		}

		private void disablePulse() {
			if (!isActive) {
				hasPulsed = false;
			}
			isActive = false;
			this.count = 0;
		}

		@Override
		public boolean isActive() {
			return isActive;
		}

		@Override
		public void writeToNBT(NBTTagCompound nbt) {
			nbt.setBoolean("singlePulse", singlePulse);
			nbt.setBoolean("isActive", isActive);
			nbt.setBoolean("hasPulsed", hasPulsed);
			nbt.setByte("pulseCount", (byte) count);
			nbt.setInteger("tick", tick);
		}

		@Override
		public void readFromNBT(NBTTagCompound nbt) {
			isActive = nbt.getBoolean("isActive");
			singlePulse = nbt.getBoolean("singlePulse");
			hasPulsed = nbt.getBoolean("hasPulsed");
			count = nbt.getByte("pulseCount");
			tick = nbt.getInteger("tick");
		}
	}
}
```


Overlapping Code:
```
s GateExpansionBuildcraft implements IGateExpansion {
public static GateExpansionPulsar INSTANCE = new GateExpansionPulsar();
private GateExpansionPulsar() {
super("pulsar");
}
@Override
public GateExpansionController makeController(TileEntity pipeTile) {
return new GateExpansionControllerPulsar(pipeTile);
}
private class GateExpansionControllerPulsar extends GateExpansionController {
private static final int PULSE_PERIOD = 10;
private boolean isActive;
private boolean singlePulse;
private boolean hasPulsed;
private int tick;
private int count;
public GateExpansionControllerPulsar(TileEntity pipeTile) {
super(GateExpansionPulsar.this, pipeTile);
// by default, initialize tick so that not all gates created at
// one single moment would do the work at the same time. This
// spreads a bit work load. Note, this is not a problem for
// existing gates since tick is stored in NBT
tick = (int) (Math.random() * PULSE_PERIOD);
}
@Override
public void startResolution() {
if (isActive()) {
disablePulse();
}
}
@Override
public boolean resolveAction(IStatement action, int count) {
if (action instanceof ActionEnergyPulsar) {
enablePulse(count);
return true;
} else if (action instanceof ActionSingleEnergyPulse) {
enableSinglePulse(count);
return true;
}
return false;
}
@Override
public void addActions(List<IActionInternal> list) {
super.addActions(list);
list.add(BuildCraftTransport.actionEnergyPulser);
list.add(BuildCraftTransport.actionSingleEnergyPulse);
}
@Override
public void tick(IGate gate) {
if (!isActive && hasPulsed) {
hasPulsed = false;
}
if (tick++ % PULSE_PERIOD != 0) {
// only do the treatement once every period
return;
}
if (!isActive) {
gate.setPulsing(false);
return;
}
if (pipeTile instanceof IEnergyHandler && (!singlePulse || !hasPulsed)) {
gate.setPulsing(true);
((IEnergyHandler) pipeTile).receiveEnergy(ForgeDirection.UNKNOWN, Math.min(1 << (count - 1), 64) * 10,
false);
hasPulsed = true;
} else {
gate.setPulsing(true);
}
}
private void enableSinglePulse(int count) {
singlePulse = true;
isActive = true;
this.count = count;
}
private void enablePulse(int count) {
isActive = true;
singlePulse = false;
this.count = count;
}
private void disablePulse() {
if (!isActi
```
<Overlap Ratio: 0.9739168877099912>

---

--- 56 --
Question ID: cd67a3041803f2680c205b9e6146dace4c41f38a_0
Original Code:
```
class DefaultMdxValidatorImpl
    implements ParseTreeVisitor<ParseTreeNode>, MdxValidator
{
    private Stack<Boolean> scalarStack = new Stack<Boolean>();
    private final SelectNode selectNode;

    /**
     * Creates a DefaultMdxValidatorImpl.
     *
     * @param selectNode Root of parse tree
     */
    protected DefaultMdxValidatorImpl(SelectNode selectNode) {
        this.selectNode = selectNode;
    }

    public SelectNode validateSelect(SelectNode selectNode)
        throws OlapException
    {
        return null;
    }

    public ParseTreeNode visit(SelectNode selectNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(AxisNode axis) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(WithMemberNode withMemberNode) {
        ParseTreeNode expression = acceptScalar(withMemberNode.getExpression());
        withMemberNode.setExpression(expression);
        final Type type = expression.getType();
        if (!TypeUtil.canEvaluate(type)) {
            throw new RuntimeException(
                "'Member expression '" + MdxUtil.toString(expression)
                + "' must not be a set'");
        }
        for (PropertyValueNode prop : withMemberNode.getMemberPropertyList()) {
            prop.accept(this);
        }
        return withMemberNode;
    }

    public ParseTreeNode visit(WithSetNode withSetNode) {
        ParseTreeNode expression = acceptScalar(withSetNode.getExpression());
        withSetNode.setExpression(expression);
        final Type type = expression.getType();
        if (!TypeUtil.isSet(type)) {
            final IdentifierNode id = withSetNode.getIdentifier();
            final String idString = MdxUtil.toString(id);
            throw new RuntimeException(
                "Set expression '" + idString + "' must be a set");
        }
        return withSetNode;
    }

    public ParseTreeNode visit(CallNode call) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(IdentifierNode id) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(ParameterNode parameterNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(CubeNode cubeNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(DimensionNode dimensionNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(HierarchyNode hierarchyNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(LevelNode levelExpr) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(MemberNode memberNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(LiteralNode literalNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(PropertyValueNode propertyValueNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public ParseTreeNode visit(DrillThroughNode drillThroughNode) {
        if (false) {
            return null;
        }
        throw new UnsupportedOperationException();
    }

    public void accept(AxisNode axis) {
        ParseTreeNode exp = axis.getExpression().accept(this);
        final Type type = exp.getType();
        if (!TypeUtil.isSet(type)) {
            throw new RuntimeException(
                "Axis '" + axis.getAxis().name() + "' expression is not a set");
        }
    }

    public ParseTreeNode acceptScalar(ParseTreeNode node) {
        scalarStack.push(Boolean.TRUE);
        try {
            return node.accept(this);
        } finally {
            scalarStack.pop();
        }
    }

    // from IdentifierNode
    public ParseTreeNode accept(IdentifierNode identifier) {
        if (identifier.getSegmentList().size() == 1) {
            final IdentifierSegment s = identifier.getSegmentList().get(0);
            if (s.getQuoting() == Quoting.UNQUOTED
                && isReserved(s.getName()))
            {
                return LiteralNode.createSymbol(
                    s.getRegion(),
                    s.getName().toUpperCase());
            }
        }
        final ParseTreeNode element =
            lookup(selectNode, identifier.getSegmentList(), true);
        if (element == null) {
            return null;
        }
        return element.accept(this);
    }

    public ParseTreeNode accept(LiteralNode literalNode) {
        return literalNode;
    }

    public boolean isReserved(String name) {
        // todo: implement
        throw new UnsupportedOperationException();
    }

    private ParseTreeNode lookup(
        SelectNode select,
        List<IdentifierSegment> segments,
        boolean allowProp)
    {
        // todo: something like this:
        //  final Exp element = Util.lookup(select, names, true);
        throw new UnsupportedOperationException();
    }
}
```


Overlapping Code:
```
seTreeVisitor<ParseTreeNode>, MdxValidator
{
private Stack<Boolean> scalarStack = new Stack<Boolean>();
private final SelectNode selectNode;
/**
* Creates a DefaultMdxValidatorImpl.
*
* @param selectNode Root of parse tree
*/
protected DefaultMdxValidatorImpl(SelectNode selectNode) {
this.selectNode = selectNode;
}
public SelectNode validateSelect(SelectNode selectNode)
throws OlapException
{
return null;
}
public ParseTreeNode visit(SelectNode selectNode) {
if (false) {
return null;
}
throw new UnsupportedOperationException();
}
public ParseTreeNode visit(AxisNode axis) {
if (false) {
return null;
}
throw new UnsupportedOperationException();
}
public ParseTreeNode visit(WithMemberNode withMemberNode) {
ParseTreeNode expression = acceptScalar(withMemberNode.getExpression());
withMemberNode.setExpression(expression);
final Type type = expression.getType();
if (!TypeUtil.canEvaluate(type)) {
throw new RuntimeException(
"'Member expression '" + MdxUtil.toString(expression)
+ "' must not be a set'");
}
for (PropertyValueNode prop : withMemberNode.getMemberPropertyList()) {
prop.accept(this);
}
return withMemberNode;
}
public ParseTreeNode visit(WithSetNode withSetNode) {
ParseTreeNode expression = acceptScalar(withSetNode.getExpression());
withSetNode.setExpression(expression);
final Type type = expression.getType();
if (!TypeUtil.isSet(type)) {
final IdentifierNode id = withSetNode.getIdentifier();
final String idString = MdxUtil.toString(id);
throw new RuntimeException(
"Set expression '" + idString + "' must be a set");
}
return withSetNode;
}
public ParseTreeNode visit(CallNode call) {
if (false) {
return null;
}
throw new UnsupportedOperationException();
}
public ParseTreeNode visit(IdentifierNode id) {
if (false) {
return null;
}
throw new UnsupportedOperationException();
}
public ParseTreeNode visit(ParameterNode parameterNode) {
if (false) {
return null;
}
throw n
```
<Overlap Ratio: 0.9703779366700716>

---

--- 57 --
Question ID: d838cc8d671db03f477f194c75d8ecc5d220e129_0
Original Code:
```
public final class Suppliers {
	private Suppliers() {}

	/**
	 * Returns a new supplier which is the composition of the provided function
	 * and supplier. In other words, the new supplier's value will be computed by
	 * retrieving the value from {@code supplier}, and then applying
	 * {@code function} to that value. Note that the resulting supplier will not
	 * call {@code supplier} or invoke {@code function} until it is called.
	 */
	public static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier) {
		return () -> function.apply(supplier.get());
	}

	/**
	 * Returns a supplier which caches the instance retrieved during the first
	 * call to {@code get()} and returns that value on subsequent calls to
	 * {@code get()}. See:
	 * <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
	 *
	 * <p>The returned supplier is thread-safe.
	 *
	 * <p>If {@code delegate} is an instance created by an earlier call to {@code
	 * memoize}, it is returned directly.
	 */
	public static <T> Supplier<T> memoize(Supplier<T> delegate) {
		return (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<>(Objects.requireNonNull(delegate));
	}

	@SuppressFBWarnings(value = "IS2_INCONSISTENT_SYNC", justification = "It's a lightweight mechanism which ensures that delegate only gets called once.")
	static class MemoizingSupplier<T> implements Supplier<T> {
		final Supplier<T> delegate;
		volatile boolean initialized;
		// "value" does not need to be volatile; visibility piggy-backs
		// on volatile read of "initialized".
		T value;

		MemoizingSupplier(Supplier<T> delegate) {
			this.delegate = delegate;
		}

		@Override
		public T get() {
			// A 2-field variant of Double Checked Locking.
			if (!initialized) {
				synchronized (this) {
					if (!initialized) {
						T t = delegate.get();
						value = t;
						initialized = true;
						return t;
					}
				}
			}
			return value;
		}

		@Override
		public String toString() {
			return "Suppliers.memoize(" + delegate + ")";
		}
	}

	/**
	 * Returns a supplier that caches the instance supplied by the delegate and
	 * removes the cached value after the specified time has passed. Subsequent
	 * calls to {@code get()} return the cached value if the expiration time has
	 * not passed. After the expiration time, a new value is retrieved, cached,
	 * and returned. See:
	 * <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
	 *
	 * <p>The returned supplier is thread-safe.
	 *
	 * @param duration the length of time after a value is created that it
	 *     should stop being returned by subsequent {@code get()} calls
	 * @param unit the unit that {@code duration} is expressed in
	 * @throws IllegalArgumentException if {@code duration} is not positive
	 * @since 2.0
	 */
	public static <T> Supplier<T> memoizeWithExpiration(Supplier<T> delegate, long duration, TimeUnit unit) {
		return new ExpiringMemoizingSupplier<>(delegate, duration, unit);
	}

	static class ExpiringMemoizingSupplier<T> implements Supplier<T> {
		final Supplier<T> delegate;
		final long durationNanos;
		volatile T value;
		// The special value 0 means "not yet initialized".
		volatile long expirationNanos;

		ExpiringMemoizingSupplier(Supplier<T> delegate, long duration, TimeUnit unit) {
			this.delegate = Objects.requireNonNull(delegate);
			this.durationNanos = unit.toNanos(duration);
			if (!(duration > 0)) {
				throw new IllegalArgumentException();
			}
		}

		@Override
		public T get() {
			// Another variant of Double Checked Locking.
			//
			// We use two volatile reads.  We could reduce this to one by
			// putting our fields into a holder class, but (at least on x86)
			// the extra memory consumption and indirection are more
			// expensive than the extra volatile reads.
			long nanos = expirationNanos;
			long now = System.nanoTime();
			if (nanos == 0 || now - nanos >= 0) {
				synchronized (this) {
					if (nanos == expirationNanos) { // recheck for lost race
						T t = delegate.get();
						value = t;
						nanos = now + durationNanos;
						// In the very unlikely event that nanos is 0, set it to 1;
						// no one will notice 1 ns of tardiness.
						expirationNanos = (nanos == 0) ? 1 : nanos;
						return t;
					}
				}
			}
			return value;
		}

		@Override
		public String toString() {
			// This is a little strange if the unit the user provided was not NANOS,
			// but we don't want to store the unit just for toString
			return "Suppliers.memoizeWithExpiration(" + delegate + ", " + durationNanos + ", NANOS)";
		}
	}

	/**
	 * Returns a supplier that always supplies {@code instance}.
	 */
	public static <T> Supplier<T> ofInstance(@Nullable T instance) {
		return () -> instance;
	}

	/**
	 * Returns a supplier whose {@code get()} method synchronizes on
	 * {@code delegate} before calling it, making it thread-safe.
	 */
	public static <T> Supplier<T> synchronizedSupplier(Supplier<T> delegate) {
		return new ThreadSafeSupplier<>(Objects.requireNonNull(delegate));
	}

	private static class ThreadSafeSupplier<T> implements Supplier<T> {
		final Supplier<T> delegate;

		ThreadSafeSupplier(Supplier<T> delegate) {
			this.delegate = delegate;
		}

		@Override
		public T get() {
			synchronized (delegate) {
				return delegate.get();
			}
		}

		@Override
		public String toString() {
			return "Suppliers.synchronizedSupplier(" + delegate + ")";
		}
	}

	/**
	 * Returns a function that accepts a supplier and returns the result of
	 * invoking {@link Supplier#get} on that supplier.
	 *
	 * @since 8.0
	 */
	public static <T> Function<Supplier<T>, T> supplierFunction() {
		return Supplier::get;
	}
}
```


Overlapping Code:
```
ublic final class Suppliers {
private Suppliers() {}
/**
* Returns a new supplier which is the composition of the provided function
* and supplier. In other words, the new supplier's value will be computed by
* retrieving the value from {@code supplier}, and then applying
* {@code function} to that value. Note that the resulting supplier will not
* call {@code supplier} or invoke {@code function} until it is called.
*/
public static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier) {
return () -> function.apply(supplier.get());
}
/**
* Returns a supplier which caches the instance retrieved during the first
* call to {@code get()} and returns that value on subsequent calls to
* {@code get()}. See:
* <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
*
* <p>The returned supplier is thread-safe.
*
* <p>If {@code delegate} is an instance created by an earlier call to {@code
* memoize}, it is returned directly.
*/
public static <T> Supplier<T> memoize(Supplier<T> delegate) {
return (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<>(Objects.requireNonNull(delegate));
}
@SuppressFBWarnings(value = "IS2_INCONSISTENT_SYNC", justification = "It's a lightweight mechanism which ensures that delegate only gets called once.")
static class MemoizingSupplier<T> implements Supplier<T> {
final Supplier<T> delegate;
volatile boolean initialized;
// "value" does not need to be volatile; visibility piggy-backs
// on volatile read of "initialized".
T value;
MemoizingSupplier(Supplier<T> delegate) {
this.delegate = delegate;
}
@Override
public T get() {
// A 2-field variant of Double Checked Locking.
if (!initialized) {
synchronized (this) {
if (!initialized) {
T t = delegate.get();
value = t;
initialized = true;
return t;
}
}
}
return value;
}
@Override
public String toString() {
return "Suppliers.memoize(" + delegate + ")";
}
}
/**
* Returns a supplier that caches the instance supplied by the delegate and
* removes the cached value after the specified time has passed. Subsequent
* calls to {@code get()} return the cached value if the expiration time has
* not passed. After the expiration time, a new value is retrieved, cached,
* and returned. See:
* <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
*
* <p>The returned supplier is th
```
<Overlap Ratio: 0.9995731967562953>

---

--- 58 --
Question ID: 76e47fbafb289f9dda735661d55a50bea337f183_0
Original Code:
```
public class StudyHavingStudySiteQuery extends AbstractQuery {

    private static String queryString = "select distinct s from Study s";

    private static String ORGANIZATION_NAME = "organizationName";
    
    private static String NCI_INSTITUTE_CODE = "nciInstituteCode";
    
    private static String RETIRED_INDICATOR = "retiredIndicator";

    private static String STIUDY_SHORT_TITLE = "shortTitle";

    private static String STUDY_IDENTIFIER_VALUE = "identifier";
    
    private static final String DATA_ENTRY_STATUS = "qcStatus";

    public StudyHavingStudySiteQuery() {

        super(queryString);
        //join("s.studyOrganizations ss");
        //andWhere("ss.class = 'SST'");
    }
    public void joinIdentifier() {
        join("s.identifiers as identifier");
    }

    public void joinStudyOrganization() {
        join("s.studyOrganizations as ss");
    }

    
    public void filterByStudySiteName(final String organizationName) {
        String searchString = "%" + organizationName.toLowerCase() + "%";
        andWhere("lower(ss.organization.name) LIKE :" + ORGANIZATION_NAME);
        setParameter(ORGANIZATION_NAME, searchString);
    }

    public void filterByStudySiteNciInstituteCode(final String nciInstituteCode) {
        String searchString = "%" + nciInstituteCode.toLowerCase() + "%";
        andWhere("lower(ss.organization.nciInstituteCode) LIKE :" + NCI_INSTITUTE_CODE);
        andWhere("ss.retiredIndicator = :" + RETIRED_INDICATOR);
        setParameter(NCI_INSTITUTE_CODE, searchString);
        setParameter(RETIRED_INDICATOR, new Boolean(false));
    }

    public void filterByStudyShortTile(final String shortTitle) {
        String searchString = "%" + shortTitle.toLowerCase() + "%";
        andWhere("lower(s.shortTitle) LIKE :" + STIUDY_SHORT_TITLE);
        setParameter(STIUDY_SHORT_TITLE, searchString);
    }

    public void filterByShortTitleOrIdentifiers(String text) {
        leftOuterJoin(STUDY_ALIAS + ".identifiers as identifier");
        andWhere("(lower(s.shortTitle) LIKE :TITLE or lower(identifier.value) LIKE :IDENTIFIER)");
        setParameter("TITLE", "%" + text.toLowerCase() + "%");
        setParameter("IDENTIFIER", "%" + text.toLowerCase() + "%");
    }

//  identifier
    public void filterByIdentifierValue(final String Identifiervalue) {
    	joinIdentifier();
        String searchString = "%" + Identifiervalue.toLowerCase() + "%";
        andWhere("lower(identifier.value) LIKE :" + STUDY_IDENTIFIER_VALUE);
        setParameter(STUDY_IDENTIFIER_VALUE, searchString);
    }
    
    
    public void filterBySST() {
        andWhere("ss.class = 'SST'");
    }

    public void filterByIdentifierValueExactMatch(final String Identifiervalue) {
        String searchString = Identifiervalue.toLowerCase();
        andWhere("lower(s.identifiers.value) LIKE :" + STUDY_IDENTIFIER_VALUE);
        setParameter(STUDY_IDENTIFIER_VALUE, searchString);
    }
    
    /**
     * If true, will return only DATA ENTRY completed studies.
     * @param ignoreNonQCedStudy
     */
    public void filterByDataEntryStatus(boolean ignoreNonQCedStudy) {
        if (ignoreNonQCedStudy) {
            andWhere("s.dataEntryStatus = :" + DATA_ENTRY_STATUS);
            setParameter(DATA_ENTRY_STATUS, true);
        }
    }

}
```


Overlapping Code:
```
c class StudyHavingStudySiteQuery extends AbstractQuery {
private static String queryString = "select distinct s from Study s";
private static String ORGANIZATION_NAME = "organizationName";

private static String NCI_INSTITUTE_CODE = "nciInstituteCode";

private static String RETIRED_INDICATOR = "retiredIndicator";
private static String STIUDY_SHORT_TITLE = "shortTitle";
private static String STUDY_IDENTIFIER_VALUE = "identifier";

private static final String DATA_ENTRY_STATUS = "qcStatus";
public StudyHavingStudySiteQuery() {
super(queryString);
//join("s.studyOrganizations ss");
//andWhere("ss.class = 'SST'");
}
public void joinIdentifier() {
join("s.identifiers as identifier");
}
public void joinStudyOrganization() {
join("s.studyOrganizations as ss");
}

public void filterByStudySiteName(final String organizationName) {
String searchString = "%" + organizationName.toLowerCase() + "%";
andWhere("lower(ss.organization.name) LIKE :" + ORGANIZATION_NAME);
setParameter(ORGANIZATION_NAME, searchString);
}
public void filterByStudySiteNciInstituteCode(final String nciInstituteCode) {
String searchString = "%" + nciInstituteCode.toLowerCase() + "%";
andWhere("lower(ss.organization.nciInstituteCode) LIKE :" + NCI_INSTITUTE_CODE);
andWhere("ss.retiredIndicator = :" + RETIRED_INDICATOR);
setParameter(NCI_INSTITUTE_CODE, searchString);
setParameter(RETIRED_INDICATOR, new Boolean(false));
}
public void filterByStudyShortTile(final String shortTitle) {
String searchString = "%" + shortTitle.toLowerCase() + "%";
andWhere("lower(s.shortTitle) LIKE :" + STIUDY_SHORT_TITLE);
setParameter(STIUDY_SHORT_TITLE, searchString);
}
public void filterByShortTitleOrIdentifiers(String text) {
leftOuterJoin(STUDY_ALIAS + ".identifiers as identifier");
andWhere("(lower(s.shortTitle) LIKE :TITLE or lower(identifier.value) LIKE :IDENTIFIER)");
setParameter("TITLE", "%" + text.toLowerCase() + "%");
setParameter("IDENTIFIER", "%" + text.toLowerCase() + "%");
}
// identifier
public void filterByIdentifierValue(final String Identifiervalue) {
joinIdentifier();
String searchString = "%" + Identifiervalue.toLowerCas
```
<Overlap Ratio: 0.9901823281907434>

---

--- 59 --
Question ID: fdd9b844d4e81c7ddd19d89c8c85a1d6854ec32b_0
Original Code:
```
public class Finder implements Iterable<Diagnostic<? extends JavaFileObject>> {

    private final List<Diagnostic<? extends JavaFileObject>> diagnostics;
    private final Results results;
    
    /**
     * Creates a {@code Finder} for the given results.
     * 
     * @param results the results of a compilation
     */
    public Finder(Results results) {
        diagnostics = new ArrayList<>(results.diagnostics);
        this.results = results;
    }
    
    /**
     * Returns an iterator over {@code Diagnostic<? extends JavaFileObject>}s.
     * 
     * @return an iterator
     */
    @Override
    public Iterator<Diagnostic<? extends JavaFileObject>> iterator() {
        return diagnostics.iterator();
    }
    
    
    /**
     * Removes all diagnostic messages which kind does not match the given kinds.
     * 
     * @param kinds the kinds which all diagnostic messages should match
     * @return {@code this}
     */
    public Finder kind(Kind... kinds) {
        return kind(Set.of(kinds));
    }
    
    /**
     * Removes all diagnostic messages which kind does not match the given kinds.
     * 
     * @param kinds the kinds which all diagnostic messages should match
     * @return {@code this}
     */
    public Finder kind(Collection<Kind> kinds) {
        diagnostics.removeIf(diagnostic -> !kinds.contains(diagnostic.getKind()));
        return this;
    }
    
    /**
     * Retains only errors.
     * 
     * @return {@code this}
     */
    public Finder errors() {
        diagnostics.retainAll(results.errors);
        return this;
    }
    
    /**
     * Retains only warnings.
     * 
     * @return {@code this}
     */
    public Finder warnings() {
        diagnostics.retainAll(results.warnings);
        return this;
    }
    
    /**
     * Retains only notes.
     * 
     * @return {@code this}
     */
    public Finder notes() {
        diagnostics.retainAll(results.notes);
        return this;
    }
    
    
    /**
     * Retains only diagnostic messages in the given Java source file.
     * 
     * @param file the Java source file
     * @return {@code this}
     */
    public Finder in(JavaFileObject file) {
        var path = file.toUri().getPath();
        diagnostics.removeIf(diagnostic -> !diagnostic.getSource().toUri().getPath().equals(path));
        return this;
    }
    
    /**
     * Retains only diagnostic messages that appear on the given line.
     * 
     * @param line the line
     * @return {@code this}
     */
    public Finder on(long line) {
        diagnostics.removeIf(diagnostic -> diagnostic.getLineNumber() != line);
        return this;
    }
    
    /**
     * Retains only diagnostic messages that appear at the given column.
     * 
     * @param column the column
     * @return {@code this}
     */
    public Finder at(long column) {
        diagnostics.removeIf(diagnostic -> diagnostic.getColumnNumber() != column);
        return this;
    }
    
    /**
     * Retains only diagnostic messages that satisfy the given predicate.
     * 
     * @param condition the condition
     * @return {@code this}
     */
    public Finder where(Predicate<Diagnostic<? extends JavaFileObject>> condition) {
        diagnostics.removeIf(Predicate.not(condition));
        return this;
    }
    
    
    /**
     * Retains only diagnostic messages that exactly match the given message.
     * 
     * @param message the message
     * @return {@code this}
     */
    public Finder matches(String message) {
        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).equals(message));
        return this;
    }
    
    /**
     * Retain only diagnostic messages that match the given pattern.
     * 
     * @param pattern the pattern
     * @return {@code this}
     */
    public Finder matches(Pattern pattern) {
        diagnostics.removeIf(diagnostic -> !pattern.matcher(diagnostic.getMessage(Locale.getDefault())).matches());
        return this;
    }
    
    /**
     * Retain only diagnostic messages that contain the given substring.
     * 
     * @param substring the substring
     * @return {@code this}
     */
    public Finder contains(String substring) {
        diagnostics.removeIf(diagnostic -> !diagnostic.getMessage(Locale.getDefault()).contains(substring));
        return this;
    }

    /**
     * Returns the full descriptions of the diagnostic messages.
     * 
     * @return the full descriptions
     */
    public List<String> diagnostics() {
        return diagnostics.stream().map(Diagnostic::toString).collect(toList());
    }
    
    /**
     * Returns only the message portions of the diagnostic messages.
     * 
     * @return the message portions
     */
    public List<String> messages() {
        return diagnostics.stream().map(diagnostic -> diagnostic.getMessage(Locale.getDefault())).collect(toList());
    }
    
    /**
     * Returns the line numbers of the diagnostic messages.
     * 
     * @return the line numbers
     */
    public List<Long> lines() {
        return diagnostics.stream().map(Diagnostic::getLineNumber).collect(toList());
    }
    
    /**
     * Returns the column numbers of the diagnostic messages.
     * 
     * @return the column numbers
     */
    public List<Long> columns() {
        return diagnostics.stream().map(Diagnostic::getColumnNumber).collect(toList());
    }
    
    /**
     * Return the positions of the diagnostic messages from the start of a source file.
     * 
     * @return the positions
     */
    public List<Long> positions() {
        return diagnostics.stream().map(Diagnostic::getPosition).collect(toList());
    }
    
    /**
     * Return the codes of the diagnostic messages.
     * 
     * @return the codes
     */
    public List<String> codes() {
        return diagnostics.stream().map(Diagnostic::getCode).collect(toList());
    }
    
    
    /**
     * Returns the diagnostic message if this {@code Finder} contains exactly one
     * diagnostic message. Otherwise returns {@code null}.
     * 
     * @return the diagnostic message if this {@code Finder} matches exactly one diagnostic message
     */
    public @Nullable Diagnostic<? extends JavaFileObject> one() {
        return diagnostics.size() == 1 ? diagnostics.get(0) : null;
    }
    
    /**
     * Returns the diagnostic messages.
     * 
     * @return the diagnostic messages
     */
    public List<Diagnostic<? extends JavaFileObject>> list() {
        return diagnostics;
    }
    
    /**
     * Returns a map of diagnostic messages and associated {@code Kind}s.
     * 
     * @return the map
     */
    public Map<Kind, List<Diagnostic<? extends JavaFileObject>>> map() {
        var map = new HashMap<Kind, List<Diagnostic<? extends JavaFileObject>>>();
        for (var diagnostic : diagnostics) {
            var list = map.get(diagnostic.getKind());
            if (list == null) {
                map.put(diagnostic.getKind(), list = new ArrayList<>());
            }
            
            list.add(diagnostic);
        }
        
        return map;
    }
    
    
    /**
     * Returns the current count of diagnostic messages.
     * 
     * @return the current count of diagnostic messages
     */
    public int count() {
        return diagnostics.size();
    }
    
}
```


Overlapping Code:
```
plements Iterable<Diagnostic<? extends JavaFileObject>> {
private final List<Diagnostic<? extends JavaFileObject>> diagnostics;
private final Results results;

/**
* Creates a {@code Finder} for the given results.
* 
* @param results the results of a compilation
*/
public Finder(Results results) {
diagnostics = new ArrayList<>(results.diagnostics);
this.results = results;
}

/**
* Returns an iterator over {@code Diagnostic<? extends JavaFileObject>}s.
* 
* @return an iterator
*/
@Override
public Iterator<Diagnostic<? extends JavaFileObject>> iterator() {
return diagnostics.iterator();
}


/**
* Removes all diagnostic messages which kind does not match the given kinds.
* 
* @param kinds the kinds which all diagnostic messages should match
* @return {@code this}
*/
public Finder kind(Kind... kinds) {
return kind(Set.of(kinds));
}

/**
* Removes all diagnostic messages which kind does not match the given kinds.
* 
* @param kinds the kinds which all diagnostic messages should match
* @return {@code this}
*/
public Finder kind(Collection<Kind> kinds) {
diagnostics.removeIf(diagnostic -> !kinds.contains(diagnostic.getKind()));
return this;
}

/**
* Retains only errors.
* 
* @return {@code this}
*/
public Finder errors() {
diagnostics.retainAll(results.errors);
return this;
}

/**
* Retains only warnings.
* 
* @return {@code this}
*/
public Finder warnings() {
diagnostics.retainAll(results.warnings);
return this;
}

/**
* Retains only notes.
* 
* @return {@code this}
*/
public Finder notes() {
diagnostics.retainAll(results.notes);
return this;
}


/**
* Retains only diagnostic messages in the given Java source file.
* 
* @param file the Java source file
* @return {@code this}
*/
public Finder in(JavaFileObject file) {
var path = file.toUri().getPath();
diagnostics.removeIf(diagnostic -> !diagnostic.getSource().toUri().getPath().equals(path));
return this;
}

/**
* Retains only diagnostic messages that appear on the given line.
* 
* @param line the line
* @return {@code this}
```
<Overlap Ratio: 0.9891304347826086>

---

--- 60 --
Question ID: a3589cc7dee4241865c07f0cbed7b077fb849d91_0
Original Code:
```
public class XMLWriter {
  /**
   * The number of characters to indent by for each nesting level of a tag to be
   * written. Some <code>writeRaw</code> methods accept a nesting level used
   * as a multiplier for this factor.
   */
  public static final int INDENT_WIDTH = 2;
  /**
   * The default encoding to be used when writing byte streams - currently the
   * UTF-8 encoding
   */
  public static final String DEFAULT_ENCODING = "UTF-8";
  private static String DEFAULT_DECLARATION = "<?xml version=\"1.0\" ?>\n";
  private PrintOutputStream internalwriter;

  public PrintOutputStream getInternalWriter() {
    return internalwriter;
  }

  /**
   * Creates an XMLWriter wrapping the supplied OutputStream. Character data is
   * converted using the default encoding scheme above
   * 
   * @param os
   *          The output stream to be wrapped.
   */

  public XMLWriter(OutputStream os) {
    internalwriter = new OutputStreamPOS(os, DEFAULT_ENCODING);
  }

  /**
   * Creates an XMLWriter wrapping the supplied Writer.
   * 
   * @param internalwriter
   *          The writer to be wrapped.
   */

  public XMLWriter(Writer internalwriter) {
    this.internalwriter = new WriterPOS(internalwriter);
  }

  public XMLWriter(PrintOutputStream pos) {
    this.internalwriter = pos;
  }

  /**
   * Writes the supplied data to the wrapped stream without conversion.
   * 
   * @param towrite
   *          A character array holding the data to be written.
   * @param start
   *          The offset of the data to be written within the array.
   * @param length
   *          The length of the data to be written.
   */

  public void writeRaw(char[] towrite, int start, int length) {
    internalwriter.write(towrite, start, length);
  }

  /**
   * Writes the supplied string to the wrapped stream without conversion.
   * 
   * @param tag The string to be written.
   * @return the writer
   */

  public XMLWriter writeRaw(String tag) {
    internalwriter.print(tag);
    return this;
  }

  public static void indent(int nestinglevel, PrintOutputStream writer) {
    for (int i = 0; i < nestinglevel * INDENT_WIDTH; ++i) {
      writer.print(" ");
    }
  }

  // write with specified indenting and without deentitising
  /**
   * Writes the supplied string to the wrapped stream with the specified indent
   * level.
   * 
   * @param tag
   *          The string to be written.
   * @param nestinglevel
   *          The multiplier for the <code>INDENT_WIDTH</code>, giving the
   *          number of spaces to be written before the supplied string.
   */
  public void writeRaw(String tag, int nestinglevel) {
    indent(nestinglevel, internalwriter);
    internalwriter.print(tag);
    // Logger.println(tag, Logger.DEBUG_SUBATOMIC);
  }

  public void closeTag(String tag, int nestinglevel, boolean writtenchildren) {
    if (writtenchildren) {
      indent(nestinglevel, internalwriter);
      internalwriter.print("</");
      internalwriter.print(tag);
      internalwriter.print(">");
    }
    else {
      internalwriter.print("/>");
    }
    if (nestinglevel >= 0) {
      internalwriter.print("\n");
    }
  }

  /**
   * Returns the default declaration that will be written by the
   * <code>writeDeclaration</code> method.
   * 
   * @return The required default declaration.
   */
  public static String getDefaultDeclaration() {
    return DEFAULT_DECLARATION;
  }

  /**
   * Writes a default declaration to the wrapped stream.
   */

  public void writeDeclaration() {
    internalwriter.print(DEFAULT_DECLARATION);
  }

  public static String[] entitytable;

  static {
    entitytable = new String['>' + 1];
    entitytable['&'] = "&amp;";
    entitytable['<'] = "&lt;";
    entitytable['>'] = "&gt;";
    entitytable['"'] = "&quot;";
    // HTML 4.0 does not define &apos; and does not plan to
    entitytable['\''] = "&#39;";
  }

  /**
   * Writes the supplied data to the wrapped stream, escaping all mandatory
   * XML entities, being &amp;, &lt;, &gt;, &quot;.
   * NB apostrophe is no longer encoded, since this seems to give a measurable
   * Increase in speed. (&#39; is
   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity
   * and does not plan to)
   * 
   * @param towrite
   *          A character array holding the data to be written.
   * @param start
   *          The offset of the data to be written within the array.
   * @param length
   *          The length of the data to be written.
   */

  // This odd strategy is based on the observation that MOST attributes/XML
  // data do NOT contain any of the entity characters, but those that do
  // are likely to contain more than one. This could no doubt be tuned
  // even further but there is only a maximum of 5% slack left in typical
  // page rendering -
  // original timing:             690µs
  // timing with strategy:        680µs
  // timing with strategy - apos: 658µs
  // timing with unencoded write: 650µs
  // timing with write as no-op:  630µs
  public final void write(char[] towrite, int start, int length) {
    int limit = start + length;
    // String ent = null;
     //while (length > 0) {
    for (; length > 0; --length) {
      char c = towrite[limit - length];
      if (c == '&' || c == '<' || c == '>' || c == '"') break;
      //on JDK 1.5, amazingly this line puts it back up to 670 with the 4 cases.
      //if ((c & 35) != 32) continue;
//      switch (c) {
//      
//      case '&':
//      // ent = "&amp;";
//      // break outer;
//      case '<':
//      // ent = "&lt;";
//      // break outer;
//      case '>':
//      // ent = "&gt;";
//      // break outer;
//      case '"':
//      // ent = "&quot;";
//      // break outer;
//      case '\'':
//        // ent = "&#39;";
//        break outer;
//      }
    }
    internalwriter.write(towrite, start, limit - start - length);
    // if (ent != null) {
    // internalwriter.print(ent);
    // --length;
    // }
    // }
    if (length > 0) {
//      writeEntity(towrite[limit - length], internalwriter);
//      --length;
      writeSlow(towrite, start + limit - length, length);
    }
     //}
  }

  public static final void writeEntity(char c, PrintOutputStream pos) {
    switch (c) {
    case '&':
      pos.print("&amp;");
      return;
    case '<':
      pos.print("&lt;");
      return;
    case '>':
      pos.print("&gt;");
      return;
    case '"':
      pos.print("&quot;");
      return;
    case '\'':
      pos.print("&#39;");
      return;
    }
    return;
  }

  public final void writeSlow(char[] towrite, int start, int length) {
    // AMAZINGLY, in 1.5 it is quicker to create this here than economise it.
    CharWrap svb = new CharWrap(length + 10);
    int limit = start + length;
    for (int i = length; i > 0; --i) {
      char c = towrite[limit - i];
      switch (c) {
      case '&':
        svb.append("&amp;");
        svb.ensureCapacity(svb.size + i);
        break;
      case '<':
        svb.append("&lt;");
        svb.ensureCapacity(svb.size + i);
        break;
      case '>':
        svb.append("&gt;");
        svb.ensureCapacity(svb.size + i);
        break;
      case '"':
        svb.append("&quot;");
        svb.ensureCapacity(svb.size + i);
        break;

      // HTML 4.0 does not define &apos; and does not plan to
      case '\'':
        svb.append("&#39;");
        svb.ensureCapacity(svb.size + i);
        break;
      default:
        svb.appendFast(c);
      }
      // String lookup = c > entitytable.length? null : entitytable[c];
      // // optimised on the basis that entitising is RARE - we only check
      // // available capacity at that point.
      // if (lookup == null) {
      // svb.appendFast(c);
      // }
      // else {
      // svb.append(lookup);
      // svb.ensureCapacity(svb.size + (limit - i));
      // }
    }
    internalwriter.write(svb.storage, svb.offset, svb.size);
  }

  /**
   * Writes the supplied data to the wrapped stream, escaping all mandatory
   * XML/HTML entities, being &amp;, &lt;, &gt;, &quot; and &#39;. &#39; is
   * escaped to &amp;#39; since HTML 4.0 does not define the &amp;apos; entity
   * and does not plan to.
   * 
   * @param towrite
   *          The string to be written.
   */

  public void write(String towrite) {
    char[] array = (towrite == null ? "null" : towrite).toCharArray();
    write(array, 0, array.length);
  }

  /**
   * Flushes the wrapped stream.
   */

  public void flush() {
    internalwriter.flush();
  }

  /**
   * Closes this XMLWriter object, in effect flushing it and making it unusable
   * for any further write operations.
   * <p>
   * Closing this does not close the underlying input stream!
   */
  public void close() {
    if (internalwriter != null) {
      try {
        flush();
      }
      catch (Throwable t) {
        Logger.println("Unhandled exception closing XML Writer: " + t,
            Logger.DEBUG_SEVERE);
        // internalwriter.close();
        internalwriter = null;
      }
    }
  }
}
```


Overlapping Code:
```
of characters to indent by for each nesting level of a tag to be
* written. Some <code>writeRaw</code> methods accept a nesting level used
* as a multiplier for this factor.
*/
public static final int INDENT_WIDTH = 2;
/**
* The default encoding to be used when writing byte streams - currently the
* UTF-8 encoding
*/
public static final String DEFAULT_ENCODING = "UTF-8";
private static String DEFAULT_DECLARATION = "<?xml version=\"1.0\" ?>\n";
private PrintOutputStream internalwriter;
public PrintOutputStream getInternalWriter() {
return internalwriter;
}
/**
* Creates an XMLWriter wrapping the supplied OutputStream. Character data is
* converted using the default encoding scheme above
* 
* @param os
* The output stream to be wrapped.
*/
public XMLWriter(OutputStream os) {
internalwriter = new OutputStreamPOS(os, DEFAULT_ENCODING);
}
/**
* Creates an XMLWriter wrapping the supplied Writer.
* 
* @param internalwriter
* The writer to be wrapped.
*/
public XMLWriter(Writer internalwriter) {
this.internalwriter = new WriterPOS(internalwriter);
}
public XMLWriter(PrintOutputStream pos) {
this.internalwriter = pos;
}
/**
* Writes the supplied data to the wrapped stream without conversion.
* 
* @param towrite
* A character array holding the data to be written.
* @param start
* The offset of the data to be written within the array.
* @param length
* The length of the data to be written.
*/
public void writeRaw(char[] towrite, int start, int length) {
internalwriter.write(towrite, start, length);
}
/**
* Writes the supplied string to the wrapped stream without conversion.
* 
* @param tag The string to be written.
* @return the writer
*/
public XMLWriter writeRaw(String tag) {
internalwriter.print(tag);
return this;
}
public static void indent(int nestinglevel, PrintOutputStream writer) {
for (int i = 0; i < nestinglevel * INDENT_WIDTH; ++i) {
writer.print(" ");
}
}
// write with specified indenting and without deentitising
/**
* Writes the supplied string to the wrapped stream with the specified indent
* level.
* 
* @param tag
* The string to be written.
* @param nestinglevel
* The multiplier for the <code>INDENT_WIDTH</code>,
```
<Overlap Ratio: 0.9751131221719457>

---

--- 61 --
Question ID: 7a68b1fd390160594b29921e2b89c02b7536286f_0
Original Code:
```
public final class FHIRValidationUtil {
    public static final Comparator<Issue> ISSUE_COMPARATOR = new Comparator<Issue>() {
        @Override
        public int compare(Issue first, Issue second) {
            return first.getSeverity().getValueAsEnum().compareTo(second.getSeverity().getValueAsEnum());
        }
    };

    private FHIRValidationUtil() { }

    public static List<Issue> getErrors(List<Issue> issues) {
        Objects.requireNonNull(issues);
        List<Issue> errors = new ArrayList<>();
        for (Issue issue : issues) {
            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {
                errors.add(issue);
            }
        }
        return errors;
    }

    public static List<Issue> getWarnings(List<Issue> issues) {
        Objects.requireNonNull(issues);
        List<Issue> warnings = new ArrayList<>();
        for (Issue issue : issues) {
            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {
                warnings.add(issue);
            }
        }
        return warnings;
    }

    public static List<Issue> getInformation(List<Issue> issues) {
        Objects.requireNonNull(issues);
        List<Issue> information = new ArrayList<>();
        for (Issue issue : issues) {
            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {
                information.add(issue);
            }
        }
        return information;
    }

    public static boolean hasErrors(List<Issue> issues) {
        for (Issue issue : issues) {
            if (IssueSeverity.ERROR.equals(issue.getSeverity())) {
                return true;
            }
        }
        return false;
    }

    public static boolean hasWarnings(List<Issue> issues) {
        for (Issue issue : issues) {
            if (IssueSeverity.WARNING.equals(issue.getSeverity())) {
                return true;
            }
        }
        return false;
    }

    public static boolean hasInformation(List<Issue> issues) {
        for (Issue issue : issues) {
            if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {
                return true;
            }
        }
        return false;
    }

    public static int countErrors(List<Issue> issues) {
        return getErrors(issues).size();
    }

    public static int countWarnings(List<Issue> issues) {
        return getWarnings(issues).size();
    }

    public static int countInformation(List<Issue> issues) {
        return getInformation(issues).size();
    }
}
```


Overlapping Code:
```
 class FHIRValidationUtil {
public static final Comparator<Issue> ISSUE_COMPARATOR = new Comparator<Issue>() {
@Override
public int compare(Issue first, Issue second) {
return first.getSeverity().getValueAsEnum().compareTo(second.getSeverity().getValueAsEnum());
}
};
private FHIRValidationUtil() { }
public static List<Issue> getErrors(List<Issue> issues) {
Objects.requireNonNull(issues);
List<Issue> errors = new ArrayList<>();
for (Issue issue : issues) {
if (IssueSeverity.ERROR.equals(issue.getSeverity())) {
errors.add(issue);
}
}
return errors;
}
public static List<Issue> getWarnings(List<Issue> issues) {
Objects.requireNonNull(issues);
List<Issue> warnings = new ArrayList<>();
for (Issue issue : issues) {
if (IssueSeverity.WARNING.equals(issue.getSeverity())) {
warnings.add(issue);
}
}
return warnings;
}
public static List<Issue> getInformation(List<Issue> issues) {
Objects.requireNonNull(issues);
List<Issue> information = new ArrayList<>();
for (Issue issue : issues) {
if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {
information.add(issue);
}
}
return information;
}
public static boolean hasErrors(List<Issue> issues) {
for (Issue issue : issues) {
if (IssueSeverity.ERROR.equals(issue.getSeverity())) {
return true;
}
}
return false;
}
public static boolean hasWarnings(List<Issue> issues) {
for (Issue issue : issues) {
if (IssueSeverity.WARNING.equals(issue.getSeverity())) {
return true;
}
}
return false;
}
public static boolean hasInformation(List<Issue> issues) {
for (Issue issue : issues) {
if (IssueSeverity.INFORMATION.equals(issue.getSeverity())) {
return true;
}
}
return false;
}
public static int countErrors(List<Issue> issues) {
return getErrors(issues).size();
}
public static int countWarnings(List<Issue> issues) {
return getWarnings(issues).size();
}
public static int countInformation(List<Issue> issues) {
return getInformatio
```
<Overlap Ratio: 0.9837950862519603>

---

--- 62 --
Question ID: 9d1095695216a557f92d497f712fcd2f87af14d0_2
Original Code:
```
class TextUtils {
	/**
	 * Combines an array of string with the separator
	 * @param a array of Strings to combine
	 * @param sep separator to place in between each String
	 * @return combined string
	 */
	public static String join(String[] a, String sep) {
		StringBuilder s = new StringBuilder();
		for (String str : a) {
			s.append(str + sep);
		}
		return s.substring(0, s.length() - sep.length());
	}
}
```


Overlapping Code:
```
 TextUtils {
/**
* Combines an array of string with the separator
* @param a array of Strings to combine
* @param sep separator to place in between each String
* @return combined string
*/
public static String join(String[] a, String sep) {
StringBuilder s = new StringBuilder();
for (String str : a) {
s.append(str + sep);
}
return s.substring(0, s.
```
<Overlap Ratio: 0.9114583333333334>

---

--- 63 --
Question ID: ebb77db81a764e6c17ae08f275ea0becccb2aaf9_0
Original Code:
```
public class ZeroCommandSimple extends CommandBase {
    private Timer endTimer;

    private boolean hoodDone;
    private boolean turretDone;
    private boolean turretBackedOff;
    private boolean ready;

    private Shooter shooter;
    public ZeroCommandSimple(Shooter shooter)
    {
        this.shooter = shooter;

        this.endTimer = new Timer();

        hoodDone = false;
        turretDone = false;
        turretBackedOff = false;

        this.addRequirements(shooter);
    }

    public void initialize() {
        shooter.setZeroPoint(EDeviceType.Hood);
        shooter.setZeroPoint(EDeviceType.Turret);
        endTimer.reset();
        hoodDone = false;
        turretDone = false;
        turretBackedOff = false;
        ready = false;
    }

    public void execute() {
        if(ready) {
            if(!hoodDone) {
                this.shooter.move(EDeviceType.Hood, -0.3);
            } else {
                shooter.move(EDeviceType.Hood, 0);
            }

            if(!turretBackedOff) {
                shooter.move(EDeviceType.Turret, -0.1);
            } else if(!turretDone) {
                shooter.move(EDeviceType.Turret, 0.1); //0.25
            } else {
                shooter.move(EDeviceType.Turret, 0);
            }

            if(!turretBackedOff && shooter.getTurretPosition() < -20.0) {
                turretBackedOff = true;
            }
        } else if(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) < 1) {
            ready = true;
        }
    }

    public void end(boolean isInterrupted){
        while(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) > 1) {
            States.zeroed = true;
            shooter.setZeroPoint(EDeviceType.Hood);
            shooter.setZeroPoint(EDeviceType.Turret);
            shooter.setHoodAngle(Constants.BASE_HOOD_ANGLE);
            shooter.move(EDeviceType.Hood, 0);
            shooter.move(EDeviceType.Turret, 0);
        }
    }

    // Checking when things are finished by checking the velocity because
    //  the stop switch never reports true :(
    public boolean isFinished(){
        endTimer.start();
        if(!this.shooter.atZeroPoint(EDeviceType.Hood)) {
            endTimer.reset();
        }
        hoodDone = endTimer.hasElapsed(1);
        turretDone = this.shooter.atZeroPoint(EDeviceType.Turret);
        return hoodDone && turretDone;
    }
}
```


Overlapping Code:
```
Base {
private Timer endTimer;
private boolean hoodDone;
private boolean turretDone;
private boolean turretBackedOff;
private boolean ready;
private Shooter shooter;
public ZeroCommandSimple(Shooter shooter)
{
this.shooter = shooter;
this.endTimer = new Timer();
hoodDone = false;
turretDone = false;
turretBackedOff = false;
this.addRequirements(shooter);
}
public void initialize() {
shooter.setZeroPoint(EDeviceType.Hood);
shooter.setZeroPoint(EDeviceType.Turret);
endTimer.reset();
hoodDone = false;
turretDone = false;
turretBackedOff = false;
ready = false;
}
public void execute() {
if(ready) {
if(!hoodDone) {
this.shooter.move(EDeviceType.Hood, -0.3);
} else {
shooter.move(EDeviceType.Hood, 0);
}
if(!turretBackedOff) {
shooter.move(EDeviceType.Turret, -0.1);
} else if(!turretDone) {
shooter.move(EDeviceType.Turret, 0.1); //0.25
} else {
shooter.move(EDeviceType.Turret, 0);
}
if(!turretBackedOff && shooter.getTurretPosition() < -20.0) {
turretBackedOff = true;
}
} else if(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) < 1) {
ready = true;
}
}
public void end(boolean isInterrupted){
while(Math.abs(shooter.getAngle(EDeviceType.Turret) + 90) > 1) {
States.zeroed = true;
shooter.setZeroPoint(EDeviceType.Hood);
shooter.setZeroPoint(EDeviceType.Turret);
shooter.setHoodAngle(Constants.BASE_HOOD_ANGLE);
shooter.move(EDeviceType.Hood, 0);
shooter.move(EDeviceType.Turret, 0);
}
}
// Checking when things are finished by checking the velocity because
// the stop switch never reports true :(
public boolean isFinished(){
endTimer.start();
if(!this.shooter.atZeroPoint(EDeviceType.Hood)) {
endTimer.reset();
}
hoodDone = endTimer.hasElapsed(1);
turretDone = this.shooter.atZeroPoint(EDeviceType.Turret);
return hoodDone && turretDone;
```
<Overlap Ratio: 0.9722222222222222>

---

--- 64 --
Question ID: 5fd4753c7195420601334cfc21de48ee9fe0b50f_0
Original Code:
```
@Validated
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2021-06-09T08:20:20.072Z[GMT]")

@Getter
@Setter
public class ParallelDatasetParamsSchema extends DatasetCommonParamsSchema implements OneOfDatasetParamsSchemaParams {
  @JsonProperty("collectionMethod")
  private ParallelDatasetCollectionMethod collectionMethod = null;
  
  



  /**
   * Get collectionMethod
   * @return collectionMethod
   **/
  @Schema(description = "")
  
    @Valid
    public ParallelDatasetCollectionMethod getCollectionMethod() {
    return collectionMethod;
  }

  public void setCollectionMethod(ParallelDatasetCollectionMethod collectionMethod) {
    this.collectionMethod = collectionMethod;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ParallelDatasetParamsSchema parallelDatasetParamsSchema = (ParallelDatasetParamsSchema) o;
    return Objects.equals(this.collectionMethod, parallelDatasetParamsSchema.collectionMethod) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(collectionMethod, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ParallelDatasetParamsSchema {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    collectionMethod: ").append(toIndentedString(collectionMethod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
```


Overlapping Code:
```
@Validated
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2021-06-09T08:20:20.072Z[GMT]")
@Getter
@Setter
public class ParallelDatasetParamsSchema extends DatasetCommonParamsSchema implements OneOfDatasetParamsSchemaParams {
@JsonProperty("collectionMethod")
private ParallelDatasetCollectionMethod collectionMethod = null;


/**
* Get collectionMethod
* @return collectionMethod
**/
@Schema(description = "")

@Valid
public ParallelDatasetCollectionMethod getCollectionMethod() {
return collectionMethod;
}
public void setCollectionMethod(ParallelDatasetCollectionMethod collectionMethod) {
this.collectionMethod = collectionMethod;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
ParallelDatasetParamsSchema parallelDatasetParamsSchema = (ParallelDatasetParamsSchema) o;
return Objects.equals(this.collectionMethod, parallelDatasetParamsSchema.collectionMethod) &&
super.equals(o);
}
@Override
public int hashCode() {
return Objects.hash(collectionMethod, super.hashCode());
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class ParallelDatasetParamsSchema {\n");
sb.append(" ").append(toIndentedString(super.toString())).append("\n");
sb.append(" collectionMethod: ").append(toIndentedString(collectionMethod)).append("\n");
sb.append("}");
return sb.toString();
}
/**
* Convert the given object to string with each line indented by 4 spaces
* (except the first line).
*/
private String toIndentedString(java.lang.Object o) {
if (o == null) {
return "null";
}
return o.toString().replace("\n", "\n ");
}
}
```
<Overlap Ratio: 1.0>

---

--- 65 --
Question ID: 1824bf17d53722495c9a51156d627a24a8f9432f_0
Original Code:
```
public class MailDateFormatTest extends TestCase {
    public void testMailDateFormat() throws ParseException {
        MailDateFormat mdf = new MailDateFormat();
        Date date = mdf.parse("Wed, 27 Aug 2003 13:43:38 +0100 (BST)");
        // don't we just love the Date class?
        Calendar cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, "BST"), Locale.getDefault());
        cal.setTime(date);
        assertEquals(2003, cal.get(Calendar.YEAR));
        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(43, cal.get(Calendar.MINUTE));
        assertEquals(38, cal.get(Calendar.SECOND));
        
        date = mdf.parse("Wed, 27-Aug-2003 13:43:38 +0100");
        // don't we just love the Date class?
        cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, "BST"), Locale.getDefault());
        cal.setTime(date);
        assertEquals(2003, cal.get(Calendar.YEAR));
        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(43, cal.get(Calendar.MINUTE));
        assertEquals(38, cal.get(Calendar.SECOND));
        
        date = mdf.parse("27-Aug-2003 13:43:38 EST");
        // don't we just love the Date class?
        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, "EST"), Locale.getDefault());
        cal.setTime(date);
        assertEquals(2003, cal.get(Calendar.YEAR));
        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(43, cal.get(Calendar.MINUTE));
        assertEquals(38, cal.get(Calendar.SECOND));
        
        date = mdf.parse("27 Aug 2003 13:43 EST");
        // don't we just love the Date class?
        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, "EST"), Locale.getDefault());
        cal.setTime(date);
        assertEquals(2003, cal.get(Calendar.YEAR));
        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(43, cal.get(Calendar.MINUTE));
        assertEquals(00, cal.get(Calendar.SECOND));
        
        date = mdf.parse("27 Aug 03 13:43 EST");
        // don't we just love the Date class?
        cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, "EST"), Locale.getDefault());
        cal.setTime(date);
        assertEquals(2003, cal.get(Calendar.YEAR));
        assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
        assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
        assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
        assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
        assertEquals(43, cal.get(Calendar.MINUTE));
        assertEquals(00, cal.get(Calendar.SECOND));
    }
}
```


Overlapping Code:
```
s MailDateFormatTest extends TestCase {
public void testMailDateFormat() throws ParseException {
MailDateFormat mdf = new MailDateFormat();
Date date = mdf.parse("Wed, 27 Aug 2003 13:43:38 +0100 (BST)");
// don't we just love the Date class?
Calendar cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, "BST"), Locale.getDefault());
cal.setTime(date);
assertEquals(2003, cal.get(Calendar.YEAR));
assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
assertEquals(43, cal.get(Calendar.MINUTE));
assertEquals(38, cal.get(Calendar.SECOND));

date = mdf.parse("Wed, 27-Aug-2003 13:43:38 +0100");
// don't we just love the Date class?
cal = Calendar.getInstance(new SimpleTimeZone(+1 * 60 * 60 * 1000, "BST"), Locale.getDefault());
cal.setTime(date);
assertEquals(2003, cal.get(Calendar.YEAR));
assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
assertEquals(43, cal.get(Calendar.MINUTE));
assertEquals(38, cal.get(Calendar.SECOND));

date = mdf.parse("27-Aug-2003 13:43:38 EST");
// don't we just love the Date class?
cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, "EST"), Locale.getDefault());
cal.setTime(date);
assertEquals(2003, cal.get(Calendar.YEAR));
assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
assertEquals(27, cal.get(Calendar.DAY_OF_MONTH));
assertEquals(Calendar.WEDNESDAY, cal.get(Calendar.DAY_OF_WEEK));
assertEquals(13, cal.get(Calendar.HOUR_OF_DAY));
assertEquals(43, cal.get(Calendar.MINUTE));
assertEquals(38, cal.get(Calendar.SECOND));

date = mdf.parse("27 Aug 2003 13:43 EST");
// don't we just love the Date class?
cal = Calendar.getInstance(new SimpleTimeZone(-5 * 60 * 60 * 1000, "EST"), Locale.getDefault());
cal.setTime(date);
assertEquals(2003, cal.get(Calendar.YEAR));
assertEquals(Calendar.AUGUST, cal.get(Calendar.MONTH));
as
```
<Overlap Ratio: 0.9948670088660756>

---

--- 66 --
Question ID: c37a60f06f927d0a1679c78786265b35b5add6b3_0
Original Code:
```
@RunWith(Arquillian.class)
public class ConfigurationOptionsEndpointTest extends AbstractTest
{
    @ArquillianResource
    private URL contextPath;

    @Test
    @RunAsClient
    public void testConfigurationOptionsList() throws Exception
    {
        ResteasyClient client = ServiceTestUtil.getResteasyClient();
        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH;
        ResteasyWebTarget target = client.target(uri);
        Response response = target.request().get();
        Assert.assertEquals(200, response.getStatus());

        // Just read it as a List of Maps, as ConfigurationOption can't easily be deserialized by jackson (abstract class).
        List<?> optionList = response.readEntity(List.class);
        Assert.assertNotNull(optionList);
        Assert.assertTrue(optionList.size() > 1);

        int previousPriority = Integer.MIN_VALUE;
        for (Map<String, Object> option : (List<Map<String, Object>>)optionList)
        {
            int priority = (int)option.get("priority");
            if (priority < previousPriority)
                Assert.fail("Options are not listed in priority order");
        }
        response.close();
    }

    @Test
    @RunAsClient
    public void testValidationOkBoolean() throws Exception
    {
        Assert.assertTrue(validateOption(SourceModeOption.NAME, "true"));
    }

    @Test
    @RunAsClient
    public void testValidationBadPath() throws Exception
    {
        Assert.assertFalse(validateOption(UserIgnorePathOption.NAME, "/not/really/here"));
    }

    @Test
    @RunAsClient
    public void testValidationOkPath() throws Exception
    {
        Assert.assertTrue(validateOption(UserIgnorePathOption.NAME, "src/main/java"));
    }

    private boolean validateOption(String name, String value) {
        ResteasyClient client = ServiceTestUtil.getResteasyClient();
        String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH + "/" + ConfigurationOptionsEndpoint.VALIDATE_OPTION;
        ResteasyWebTarget target = client.target(uri);

        AdvancedOption option = new AdvancedOption();
        option.setName(name);
        option.setValue(value);

        Response response = target.request().post(Entity.entity(option, MediaType.APPLICATION_JSON_TYPE));
        Assert.assertEquals(200, response.getStatus());

        Map<String, Object> optionMap = response.readEntity(Map.class);
        switch ((String)optionMap.get("level"))
        {
            case "SUCCESS":
            case "WARNING":
                return true;
            default:
                return false;
        }
    }
}
```


Overlapping Code:
```
@RunWith(Arquillian.class)
public class ConfigurationOptionsEndpointTest extends AbstractTest
{
@ArquillianResource
private URL contextPath;
@Test
@RunAsClient
public void testConfigurationOptionsList() throws Exception
{
ResteasyClient client = ServiceTestUtil.getResteasyClient();
String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH;
ResteasyWebTarget target = client.target(uri);
Response response = target.request().get();
Assert.assertEquals(200, response.getStatus());
// Just read it as a List of Maps, as ConfigurationOption can't easily be deserialized by jackson (abstract class).
List<?> optionList = response.readEntity(List.class);
Assert.assertNotNull(optionList);
Assert.assertTrue(optionList.size() > 1);
int previousPriority = Integer.MIN_VALUE;
for (Map<String, Object> option : (List<Map<String, Object>>)optionList)
{
int priority = (int)option.get("priority");
if (priority < previousPriority)
Assert.fail("Options are not listed in priority order");
}
response.close();
}
@Test
@RunAsClient
public void testValidationOkBoolean() throws Exception
{
Assert.assertTrue(validateOption(SourceModeOption.NAME, "true"));
}
@Test
@RunAsClient
public void testValidationBadPath() throws Exception
{
Assert.assertFalse(validateOption(UserIgnorePathOption.NAME, "/not/really/here"));
}
@Test
@RunAsClient
public void testValidationOkPath() throws Exception
{
Assert.assertTrue(validateOption(UserIgnorePathOption.NAME, "src/main/java"));
}
private boolean validateOption(String name, String value) {
ResteasyClient client = ServiceTestUtil.getResteasyClient();
String uri = contextPath + ConfigurationOptionsEndpoint.CONFIGURATION_OPTIONS_PATH + "/" + ConfigurationOptionsEndpoint.VALIDATE_OPTION;
ResteasyWebTarget target = client.target(uri);
AdvancedOption option = new AdvancedOption();
option.setName(name);
option.setValue(value);
Response response = target.request().post(Entity.entity(option, MediaType.APPLICATION_JSON_TYPE));
Assert.assertEquals(200, response.getStatus());
Map<String, Object> optionMap = response.readEntity(Map.class);
switch ((String)optionMap.get("leve
```
<Overlap Ratio: 0.997184420459878>

---

--- 67 --
Question ID: 3ac31d012ac7695f73d7453958de0b80c1268f02_0
Original Code:
```
public class SplitStringEveryNthChar {

    public static List<String> usingSplitMethod(String text, int n) {
        String[] results = text.split("(?<=\\G.{" + n + "})");

        return Arrays.asList(results);
    }

    public static List<String> usingSubstringMethod(String text, int n) {
        List<String> results = new ArrayList<>();
        int length = text.length();

        for (int i = 0; i < length; i += n) {
            results.add(text.substring(i, Math.min(length, i + n)));
        }

        return results;
    }

    public static List<String> usingPattern(String text, int n) {
        List<String> results = new ArrayList<>();

        Pattern pattern = Pattern.compile(".{1," + n + "}");
        Matcher matcher = pattern.matcher(text);
        while (matcher.find()) {
            String match = text.substring(matcher.start(), matcher.end());
            results.add(match);
        }

        return results;
    }

    public static List<String> usingGuava(String text, int n) {
        Iterable<String> parts = Splitter.fixedLength(n)
            .split(text);

        return ImmutableList.copyOf(parts);
    }

}
```


Overlapping Code:
```
ic class SplitStringEveryNthChar {
public static List<String> usingSplitMethod(String text, int n) {
String[] results = text.split("(?<=\\G.{" + n + "})");
return Arrays.asList(results);
}
public static List<String> usingSubstringMethod(String text, int n) {
List<String> results = new ArrayList<>();
int length = text.length();
for (int i = 0; i < length; i += n) {
results.add(text.substring(i, Math.min(length, i + n)));
}
return results;
}
public static List<String> usingPattern(String text, int n) {
List<String> results = new ArrayList<>();
Pattern pattern = Pattern.compile(".{1," + n + "}");
Matcher matcher = pattern.matcher(text);
while (matcher.find()) {
String match = text.substring(matcher.start(), matcher.end());
results.add(match);
}
return results;
}
public static List<String> usingGuava(String text, int n) {
Iterable<String> parts = Splitter.fixedLength(n)
.split(text
```
<Overlap Ratio: 0.9508547008547008>

---

--- 68 --
Question ID: 597cb386f0507eb9d85e2dab18be5e4417796955_0
Original Code:
```
public class MyHello {
    public void hello() {
        System.out.println("my hello");
    }

    public static void main(String[] args) {
        int num1 = 1;
        int num2 = 130;
        int num3 = num1 + num2;
        int num4 = num2 - num1;
        int num5 = num1 * num2;
        int num6 = num2 / num1;

        final int num7 = 5;
        Integer num88 = 6;

        if (num88 == 0) {
            System.out.println(num1);
        }

        List<Integer> nums = new ArrayList<>();
        nums.add(1);
        nums.add(2);

        for (int num : nums) {
            System.out.println(num);
        }

        if (nums.size() == num2) {
            System.out.println(num2);
        }
    }
}
```


Overlapping Code:
```
c void hello() {
System.out.println("my hello");
}
public static void main(String[] args) {
int num1 = 1;
int num2 = 130;
int num3 = num1 + num2;
int num4 = num2 - num1;
int num5 = num1 * num2;
int num6 = num2 / num1;
final int num7 = 5;
Integer num88 = 6;
if (num88 == 0) {
System.out.println(num1);
}
List<Integer> nums = new ArrayList<>();
nums.add(1);
nums.add(2);
for (int num : nums) {
System.out.println(num);
}
if (nums.size() == num2) {
Syst
```
<Overlap Ratio: 0.8910891089108911>

---

--- 69 --
Question ID: 037b850646ff7ace3595871c7f5744336230612d_0
Original Code:
```
public class CredentialArray {
    private StoredCredential[] creds;
    private boolean[] slotStatus;
    private short size;
    private short counter;

    /**
     * Constructor for a CredentialArray.
     * @param initialSize Initial sizing for the CredentialArray.
     */
    public CredentialArray(short initialSize) {
        creds = new StoredCredential[initialSize];
        slotStatus = new boolean[initialSize];
        size = initialSize;
    }
    /**
     * Adds a new credential to the first free slot, or overwrites if a matching rp and user id matches.
     * @param in the StoredCredential object to be stored.
     */
    public void addCredential(StoredCredential in) throws UserException{
        try {
            short slot = alreadyExists(in);
            creds[slot] = in;
            slotStatus[slot] = true;
        } catch (Exception e) {
            UserException.throwIt(CTAP2.CTAP2_ERR_KEY_STORE_FULL);
        }
    }
    /**
     * Finds and returns a StoredCredential given the rpId and userId, returns null if not present.
     * @param rpId
     * @param off
     * @param len
     * @return
     */
    public StoredCredential getCredential(byte[] rpId, short rpOff, short rpLen, byte[] userId, short userOff, short userLen) {
        for(counter = 0; counter < size; counter++) {
            // Check the slot status, if the RP matches, and then if the user matches. If so, return the credential.
            if(slotStatus[counter] && creds[counter].rp.checkId(rpId, rpOff, rpLen) && creds[counter].user.checkId(userId, userOff, userLen)) {
                return creds[counter];
            }
        }
        return null;
    }
    
    
    
    /**
     * Confirms there is no already existing discoverable credential - if it finds one, it returns its location for overwriting.
     * @return the location of a discoverable credential already matching the RP and User IDs, or the first free slot otherwise.
     */
    public short alreadyExists(StoredCredential cred) {
        for(counter = 0; counter < size; counter++) {
            // Check the slot status, if the RP matches, and then if the user matches. If so, return the slot to use.
            if(slotStatus[counter] && creds[counter].rp.checkId(cred.rp) && creds[counter].user.checkId(cred.user)) {
                return counter;
            }
        }
        // Find the first free slot
        for(counter = 0; counter < size; counter++) {
            if(!slotStatus[counter]) {
                return counter;
            } 
        }
        // No free slots

        // Add more

        StoredCredential[] tmp = new StoredCredential[size];
        boolean[] tmpStatus = new boolean[size];
        for(counter = 0; counter < size; counter++) {
            // SonarLint throws an error here, but JavaCard can only copy byte arrays
            tmp[counter] = creds[counter];
            tmpStatus[counter] = slotStatus[counter];
        }
        creds = new StoredCredential[(short) (size*2)];
        slotStatus = new boolean[(short) (size*2)];
        for(counter = 0; counter < size; counter++) {
            creds[counter] = tmp[counter];
            slotStatus[counter] = tmpStatus[counter];
        }
        // Actually double the size....
        size *= (short) 2;
        // Delete objects we used to copy
        JCSystem.requestObjectDeletion();
        // Return the first free slot in the new array, which is going to be the counter plus 1
        return (short) (counter + (short) 1);
    }
    /**
     * Get the size of the array.
     * @return the array size
     */
    public short getLength() {
        return size;
    }
    /**
     * Returns the credential at position, or null if none.
     * @param position the position to get.
     * @return the credential, or null.
     */
    public StoredCredential getCred(short position) {
        return creds[position];
    }
    
}
```


Overlapping Code:
```

private StoredCredential[] creds;
private boolean[] slotStatus;
private short size;
private short counter;
/**
* Constructor for a CredentialArray.
* @param initialSize Initial sizing for the CredentialArray.
*/
public CredentialArray(short initialSize) {
creds = new StoredCredential[initialSize];
slotStatus = new boolean[initialSize];
size = initialSize;
}
/**
* Adds a new credential to the first free slot, or overwrites if a matching rp and user id matches.
* @param in the StoredCredential object to be stored.
*/
public void addCredential(StoredCredential in) throws UserException{
try {
short slot = alreadyExists(in);
creds[slot] = in;
slotStatus[slot] = true;
} catch (Exception e) {
UserException.throwIt(CTAP2.CTAP2_ERR_KEY_STORE_FULL);
}
}
/**
* Finds and returns a StoredCredential given the rpId and userId, returns null if not present.
* @param rpId
* @param off
* @param len
* @return
*/
public StoredCredential getCredential(byte[] rpId, short rpOff, short rpLen, byte[] userId, short userOff, short userLen) {
for(counter = 0; counter < size; counter++) {
// Check the slot status, if the RP matches, and then if the user matches. If so, return the credential.
if(slotStatus[counter] && creds[counter].rp.checkId(rpId, rpOff, rpLen) && creds[counter].user.checkId(userId, userOff, userLen)) {
return creds[counter];
}
}
return null;
}



/**
* Confirms there is no already existing discoverable credential - if it finds one, it returns its location for overwriting.
* @return the location of a discoverable credential already matching the RP and User IDs, or the first free slot otherwise.
*/
public short alreadyExists(StoredCredential cred) {
for(counter = 0; counter < size; counter++) {
// Check the slot status, if the RP matches, and then if the user matches. If so, return the slot to use.
if(slotStatus[counter] && creds[counter].rp.checkId(cred.rp) && creds[counter].user.checkId(cred.user)) {
return counter;
}
}
// Find the first free slot
for(counter = 0; counter < s
```
<Overlap Ratio: 0.9643201542912246>

---

--- 70 --
Question ID: af4d1d96f88db892ebd8778831685e9df6719013_0
Original Code:
```
public final class ElasticsearchRestInstrumenterFactory {

  public static Instrumenter<String, Response> create(String instrumentationName) {
    ElasticsearchRestAttributesExtractor attributesExtractor =
        new ElasticsearchRestAttributesExtractor();
    SpanNameExtractor<String> spanNameExtractor = DbSpanNameExtractor.create(attributesExtractor);
    ElasticsearchRestNetAttributesExtractor netAttributesExtractor =
        new ElasticsearchRestNetAttributesExtractor();

    return Instrumenter.<String, Response>newBuilder(
            GlobalOpenTelemetry.get(), instrumentationName, spanNameExtractor)
        .addAttributesExtractor(attributesExtractor)
        .addAttributesExtractor(netAttributesExtractor)
        .addAttributesExtractor(PeerServiceAttributesExtractor.create(netAttributesExtractor))
        .newInstrumenter(SpanKindExtractor.alwaysClient());
  }

  private ElasticsearchRestInstrumenterFactory() {}
}
```


Overlapping Code:
```
public final class ElasticsearchRestInstrumenterFactory {
public static Instrumenter<String, Response> create(String instrumentationName) {
ElasticsearchRestAttributesExtractor attributesExtractor =
new ElasticsearchRestAttributesExtractor();
SpanNameExtractor<String> spanNameExtractor = DbSpanNameExtractor.create(attributesExtractor);
ElasticsearchRestNetAttributesExtractor netAttributesExtractor =
new ElasticsearchRestNetAttributesExtractor();
return Instrumenter.<String, Response>newBuilder(
GlobalOpenTelemetry.get(), instrumentationName, spanNameExtractor)
.addAttributesExtractor(attributesExtractor)
.addAttributesExtractor(netAttributesExtractor)
.addAttributesExtractor(PeerServiceAttributesExtractor.create(netAttributesExtractor))
.newInstrumenter(SpanKindExtractor.alwaysClient());
}
private ElasticsearchRestInstrumenterFact
```
<Overlap Ratio: 0.9882629107981221>

---

--- 71 --
Question ID: 7c39078e69295fbfefa032d8672d85f58334ba4b_0
Original Code:
```
public class OpenfireX509TrustManager implements X509TrustManager
{
    private static final Logger Log = LoggerFactory.getLogger( OpenfireX509TrustManager.class );
    
    private SSLEngine engine;
    
    static
    {
    	CryptoUtils.registerJCEProviders();
    }

    /**
     * A boolean that indicates if this trust manager will allow self-signed certificates to be trusted.
     */
    protected final boolean acceptSelfSigned;

    /**
     * A boolean that indicates if this trust manager will check if all certificates in the chain (including the root
     * certificates) are currently valid (notBefore/notAfter check).
     */
    private final boolean checkValidity;

    protected TrustCircleManager circleManager;
    
    public OpenfireX509TrustManager( TrustCircleManager circleManager, boolean acceptSelfSigned, boolean checkValidity ) throws NoSuchAlgorithmException, KeyStoreException
    {
    	this.circleManager = circleManager;
        this.acceptSelfSigned = acceptSelfSigned;
        this.checkValidity = checkValidity;

        Log.debug( "Constructed trust manager. Accepts self-signed: {}, checks validity: {}", acceptSelfSigned, checkValidity );
    }

    public void setSSLEngine(SSLEngine engine)
    {
    	this.engine = engine;
    }
    
    @Override
    public void checkClientTrusted( X509Certificate[] chain, String authType ) throws CertificateException
    {
        // Find and use the end entity as the selector for verification.
        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );
        final X509CertSelector selector = new X509CertSelector();
        selector.setCertificate( endEntityCert );

        try
        {
            checkChainTrusted( selector, chain );
        }
        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )
        {
            throw new CertificateException( ex );
        }
    }

    @Override
    public void checkServerTrusted( X509Certificate[] chain, String authType ) throws CertificateException
    {
        // Find and use the end entity as the selector for verification.
        final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );
        final X509CertSelector selector = new X509CertSelector();
        selector.setCertificate( endEntityCert );

        try
        {
            checkChainTrusted( selector, chain );
        }
        catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )
        {
            throw new CertificateException( ex );
        }
    }

    @Override
    public X509Certificate[] getAcceptedIssuers()
    {
    	final Set<X509Certificate> result = new HashSet<>();
    	
    	Collection<TrustCircle> circles = null;
    	
		// make sure we have a reference id so we no what domain connection is being requested
		final String referenceId = getTopDomain(ReferenceIDUtil.getSessionReferenceId(engine.getSession()));
		
		Log.debug("Looking up trust anchors associated to domain " + referenceId);
		
    	try
    	{
			if (!StringUtils.isEmpty(referenceId))
	    	{
	    		
	    		circles = circleManager.getCirclesByDomain(referenceId, true, true);
	    	}
	    	else
	    	{
	    		// fall back 
	    		circles = circleManager.getTrustCircles(true, true);
	
	    	}
    	}
    	catch (Exception e)
    	{
    		Log.warn("Could not get trust anchors for trust validation.");
    	}
    	
    	if (circles == null || circles.isEmpty())
    		return new X509Certificate[] {};
    	
    	for (TrustCircle circle : circles)
    	{
    		for (TrustBundle bundle : circle.getTrustBundles())
    			for (TrustBundleAnchor anchor : bundle.getTrustBundleAnchors())
    				if (checkValidity)
    					result.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));
    						
			for (org.jivesoftware.openfire.trustanchor.TrustAnchor anchor : circle.getAnchors())
				if (checkValidity)
					result.addAll(CertificateUtils.filterValid( anchor.asX509Certificate()));	
    		
    	}
    	
        return result.toArray( new X509Certificate[ result.size() ] );
    }

    /**
     * Determine if the given partial or complete certificate chain can be trusted to represent the entity that is
     * defined by the criteria specified by the 'selector' argument.
     *
     * A (valid) partial chain is a chain that, combined with certificates from the trust store in this manager, can be
     * completed to a full chain.
     *
     * Chains provided to this method do not need to be in any particular order.
     *
     * This implementation uses the trust anchors as represented by {@link #getAcceptedIssuers()} to verify that the
     * chain that is provided either includes a certificate from an accepted issuer, or is directly issued by one.
     *
     * Depending on the configuration of this class, other verification is done:
     * <ul>
     *     <li>{@link #acceptSelfSigned}: when {@code true}, any chain that has a length of one and is self-signed is
     *                                    considered as a 'trust anchor' (but is still subject to other checks, such as
     *                                    expiration checks).</li>
     * </ul>
     *
     * This method will either return a value, which indicates that the chain is trusted, or will throw an exception.
     *
     * @param selector Characteristics of the entity to be represented by the chain (cannot be null).
     * @param chain The certificate chain that is to be verified (cannot be null or empty).
     * @return A trusted certificate path (never null).
     *
     * @throws InvalidAlgorithmParameterException if the algorithm is invalid
     * @throws NoSuchAlgorithmException if the algorithm could not be found
     * @throws CertPathBuilderException if there was a problem with the certificate path
     */
    protected CertPath checkChainTrusted( CertSelector selector, X509Certificate... chain ) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, CertPathBuilderException
    {
        if ( selector == null )
        {
            throw new IllegalArgumentException( "Argument 'selector' cannot be null");
        }

        if ( chain == null || chain.length == 0 )
        {
            throw new IllegalArgumentException( "Argument 'chain' cannot be null or an empty array.");
        }

        Log.debug( "Attempting to verify a chain of {} certificates.", chain.length );

        /*
         * The certificate path validation process checks for valid dates in certificates,
         * but we will choose to fail fast in anything in the chain is expired.  This will save
         * time from having to lookup intermediate certificates (if necessary) if the given certificates
         * are already not valid.
         */
        X509Certificate endEntityCert = null;
		try
		{
			endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );
		} 
		catch (Exception e1)
		{
			throw new IllegalArgumentException( "Could not get end entity certificate from chain.");
		}
		
		final Set<X509Certificate> acceptedServerCerts = CertificateUtils.filterValid( endEntityCert );
        if (acceptedServerCerts.size() <= 0)
        {
        	// the end entity certificate is invalid
        	Log.warn( "TLS certificate chain has an expired certificate.  This is an invalid chain and the connection is rejected." );
        	throw new CertPathBuilderException("The certificate chain contains an expired certificate");
        }
        
        /*
         * Make sure the certificate isn't revoke.  The default cert path checker can do this work, but the revocation
         * manager uses some optimizations in terms of caching so the CRL doesn't have to be downloaded every time.
         */
        try
        {
        	
        	final CRLRevocationManager revManager = CRLRevocationManager.getInstance();
        	
        	if (revManager.isRevoked(endEntityCert))
        	{
        		Log.warn( "TLS end enity certificate has been marked as revoked.  The connection is rejected." );
        		throw new CertPathBuilderException("TLS end enity certificate has been marked as revoked.");
        	}
        }
        catch (CertPathBuilderException e)
        {
        	throw e;
        }
        catch (Exception e)
        {
        	throw new IllegalArgumentException("Could not check revocation status of end entity certificate.");
        }
        
        
        
        // The set of trusted issuers (for this invocation), based on the issuers from the truststore.
        final Set<X509Certificate> trustedIssuers = new HashSet<>();
        trustedIssuers.addAll( Arrays.asList(getAcceptedIssuers() ));
        
        // When accepting self-signed certificates, and the chain is a self-signed certificate, add it to the collection
        // of trusted issuers. Blindly accepting this issuer is undesirable, as that would circumvent other checks, such
        // as expiration checking.
        if ( acceptSelfSigned && chain.length == 1 )
        {
            Log.debug( "Attempting to accept the self-signed certificate of this chain of length one, as instructed by configuration." );

            final X509Certificate cert = chain[0];
            if ( cert.getSubjectDN().equals( cert.getIssuerDN() ) )
            {
                Log.debug( "Chain of one appears to be self-signed. Adding it to the set of trusted issuers." );
                trustedIssuers.add( cert );
            }
            else
            {
                Log.debug( "Chain of one is not self-signed. Not adding it to the set of trusted issuers." );
            }
        }

        // Turn trusted into accepted issuers.
        final Set<X509Certificate> acceptedIssuers;
        if ( checkValidity )
        {
            // See what certificates are currently valid.
            acceptedIssuers = CertificateUtils.filterValid( trustedIssuers );
        }
        else
        {
            acceptedIssuers = trustedIssuers;
        }

        Log.debug("Using the following trust anchors for checking trust of the TLS connection for certificate " + endEntityCert.getSubjectDN());
        for (X509Certificate anchor : acceptedIssuers)
        	Log.debug("\tDN=" + anchor.getIssuerDN());
        
        if (acceptedIssuers.isEmpty())
        {
        	Log.warn("No accepted issuers were found for certificate DN: {}", endEntityCert.getSubjectDN().toString());
        }
        
        // Transform all accepted issuers into a set of unique trustAnchors.
        final Set<TrustAnchor> trustAnchors = CertificateUtils.toTrustAnchors( acceptedIssuers );

        // All certificates that are part of the (possibly incomplete) chain.
        final CertStore certificates = CertStore.getInstance( "Collection", new CollectionCertStoreParameters( Arrays.asList( chain ) ) );

        // Build the configuration for the path builder. It is based on the collection of accepted issuers / trust anchors
        final PKIXBuilderParameters parameters = new PKIXBuilderParameters( trustAnchors, selector );

        // Validity checks are enabled by default in the CertPathBuilder implementation.
        if ( !checkValidity )
        {
            Log.debug( "Attempting to ignore any validity (expiry) issues, as instructed by configuration." );

            // There is no way to configure the pathBuilder to ignore date validity. When validity checks are to be
            // ignored, try to find a point in time where all certificates in the chain are valid.
            final Date validPointInTime = CertificateUtils.findValidPointInTime( chain );

            // This strategy to 'disable' validity checks won't work if there's no overlap of validity periods of all
            // certificates. TODO improve the implementation.
            if ( validPointInTime == null )
            {
                Log.warn( "The existing implementation is unable to fully ignore certificate validity periods for this chain, even though it is configured to do so. Certificate checks might fail because of expiration for end entity: " + chain[0] );
            }
            else
            {
                parameters.setDate( validPointInTime );
            }
        }

        // Add all certificates that are part of the chain to the configuration. Together with the trust anchors, the
        // entire chain should now be in the store.
        parameters.addCertStore( certificates );

        // When true, validation will fail if no CRLs are provided!
        parameters.setRevocationEnabled( false );

        Log.debug( "Validating chain with {} certificates, using {} trust anchors.", chain.length, trustAnchors.size() );

        // Try to use BouncyCastle - if that doesn't work, pick one.
        CertPathBuilder pathBuilder;
        try
        {
            pathBuilder = CertPathBuilder.getInstance( "PKIX", "BC" );
        }
        catch ( NoSuchProviderException e )
        {
            Log.warn( "Unable to use the BC provider! Trying to use a fallback provider.", e );
            pathBuilder = CertPathBuilder.getInstance( "PKIX" );
        }

        try
        {
            // Finally, construct (and implicitly validate) the certificate path.
            final CertPathBuilderResult result = pathBuilder.build( parameters );
            return result.getCertPath();
        }
        catch ( CertPathBuilderException ex )
        {
            // This exception generally isn't very helpful. This block attempts to print more debug information.
            try
            {
                Log.debug( "** Accepted Issuers (trust anchors, \"root CA's\"):" );
                for ( X509Certificate acceptedIssuer : acceptedIssuers) {
                    Log.debug( "   - " + acceptedIssuer.getSubjectDN() + "/" + acceptedIssuer.getIssuerDN() );
                }
                Log.debug( "** Chain to be validated:" );
                Log.debug( "   length: " + chain.length );
                for (int i=0; i<chain.length; i++) {
                    Log.debug( " Certificate[{}] (valid from {} to {}):", i, chain[ i ].getNotBefore(), chain[ i ].getNotAfter() );
                    Log.debug( "   subjectDN: " + chain[ i ].getSubjectDN() );
                    Log.debug( "   issuerDN: " + chain[ i ].getIssuerDN() );

                    for ( X509Certificate acceptedIssuer : acceptedIssuers) {
                        if ( acceptedIssuer.getIssuerDN().equals( chain[i].getIssuerDN() ) ) {
                            Log.debug( "Found accepted issuer with same DN: " + acceptedIssuer.getIssuerDN() );
                        }
                    }
                }
            }
            finally
            {
                // rethrow the original exception.
                throw ex;
            }
        }

    }
    
    protected String getTopDomain(String domain)
    {
    	if (StringUtils.isEmpty(domain))
    		return "";
    	
    	String workDomain = domain.toLowerCase();
    	if (workDomain.startsWith("groupchat."))
    		return workDomain.substring("groupchat.".length());
    	else if (workDomain.startsWith("ftproxystream."))
    		return workDomain.substring("ftproxystream.".length());
    	
    	return workDomain;
    }
}
```


Overlapping Code:
```
reX509TrustManager implements X509TrustManager
{
private static final Logger Log = LoggerFactory.getLogger( OpenfireX509TrustManager.class );

private SSLEngine engine;

static
{
CryptoUtils.registerJCEProviders();
}
/**
* A boolean that indicates if this trust manager will allow self-signed certificates to be trusted.
*/
protected final boolean acceptSelfSigned;
/**
* A boolean that indicates if this trust manager will check if all certificates in the chain (including the root
* certificates) are currently valid (notBefore/notAfter check).
*/
private final boolean checkValidity;
protected TrustCircleManager circleManager;

public OpenfireX509TrustManager( TrustCircleManager circleManager, boolean acceptSelfSigned, boolean checkValidity ) throws NoSuchAlgorithmException, KeyStoreException
{
this.circleManager = circleManager;
this.acceptSelfSigned = acceptSelfSigned;
this.checkValidity = checkValidity;
Log.debug( "Constructed trust manager. Accepts self-signed: {}, checks validity: {}", acceptSelfSigned, checkValidity );
}
public void setSSLEngine(SSLEngine engine)
{
this.engine = engine;
}

@Override
public void checkClientTrusted( X509Certificate[] chain, String authType ) throws CertificateException
{
// Find and use the end entity as the selector for verification.
final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );
final X509CertSelector selector = new X509CertSelector();
selector.setCertificate( endEntityCert );
try
{
checkChainTrusted( selector, chain );
}
catch ( InvalidAlgorithmParameterException | NoSuchAlgorithmException | CertPathBuilderException ex )
{
throw new CertificateException( ex );
}
}
@Override
public void checkServerTrusted( X509Certificate[] chain, String authType ) throws CertificateException
{
// Find and use the end entity as the selector for verification.
final X509Certificate endEntityCert = CertificateUtils.identifyEndEntityCertificate( Arrays.asList( chain ) );
final X509CertSelector selector = new X509CertSelector();
selector.setCertificate( endEntityCert );
try
{
checkChainTrusted( selector, chai
```
<Overlap Ratio: 0.9883558453656265>

---

--- 72 --
Question ID: c7dd78e22c07b8e0fc390ffbd3b466b0c8e42f39_0
Original Code:
```
public class CustomViewRowImpl extends ViewRowImpl {
    @Override
    protected ViewRowAttrHintsImpl createViewRowAttrHints(AttributeDefImpl attrDef) {
        return new CustomViewRowAttrHints(attrDef,this);
    }
    class CustomViewRowAttrHints extends ViewRowAttrHintsImpl {
        protected CustomViewRowAttrHints(AttributeDefImpl attr, ViewRowImpl viewRow) {
           super(attr,viewRow);
        }
        @Override
        public String getHint(LocaleContext locale, String sHintName) {
            if ("rowState".equals(sHintName)) {
              ViewRowImpl vri = getViewRow();
              if (vri != null) {
                  Entity e = vri.getEntity(0);
                  if (e != null) {
                      return translateStatusToString(e.getEntityState());
                  }
                  return null;
              }
            }
            else if ("valueChanged".equals(sHintName)) {
                ViewRowImpl vri = getViewRow();
                if (vri != null) {
                    boolean changed = vri.isAttributeChanged(getViewAttributeDef().getName());
                    return changed ? "true":"false";
                }
            }
            return super.getHint(locale, sHintName);
        }
        private String translateStatusToString(byte b) {
          String ret = null;
          switch (b) {
            case Entity.STATUS_DELETED: {
              ret = "Deleted";
              break;
            }
            case Entity.STATUS_INITIALIZED: {
              ret = "Initialized";
              break;
            }
            case Entity.STATUS_MODIFIED: {
              ret = "Modified";
              break;
            }
            case Entity.STATUS_UNMODIFIED: {
              ret = "Unmodified";
              break;
            }
            case Entity.STATUS_NEW: {
              ret = "New";
              break;
            }
          }
          return ret;
        }        
    }
}
```


Overlapping Code:
```
lic class CustomViewRowImpl extends ViewRowImpl {
@Override
protected ViewRowAttrHintsImpl createViewRowAttrHints(AttributeDefImpl attrDef) {
return new CustomViewRowAttrHints(attrDef,this);
}
class CustomViewRowAttrHints extends ViewRowAttrHintsImpl {
protected CustomViewRowAttrHints(AttributeDefImpl attr, ViewRowImpl viewRow) {
super(attr,viewRow);
}
@Override
public String getHint(LocaleContext locale, String sHintName) {
if ("rowState".equals(sHintName)) {
ViewRowImpl vri = getViewRow();
if (vri != null) {
Entity e = vri.getEntity(0);
if (e != null) {
return translateStatusToString(e.getEntityState());
}
return null;
}
}
else if ("valueChanged".equals(sHintName)) {
ViewRowImpl vri = getViewRow();
if (vri != null) {
boolean changed = vri.isAttributeChanged(getViewAttributeDef().getName());
return changed ? "true":"false";
}
}
return super.getHint(locale, sHintName);
}
private String translateStatusToString(byte b) {
String ret = null;
switch (b) {
case Entity.STATUS_DELETED: {
ret = "Deleted";
break;
}
case Entity.STATUS_INITIALIZED: {
ret = "Initialized";
break;
}
case Entity.STATUS_MODIFIED: {
ret = "Modified";
break;
}
case Entity.STATUS_UNMODIFIED: {
ret = "Unmodified";
break;
}
case Entity.STATUS_NEW: {
ret = "New";
break;
}
}
r
```
<Overlap Ratio: 0.9843260188087775>

---

--- 73 --
Question ID: c2506325303b329653e79d68dec8842d4e6e02a9_0
Original Code:
```
public class ValidatorFactoryImpl implements ValidatorFactory {

    private static final boolean jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", ValidatorFactoryImpl.class.getClassLoader()) &&
            ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", ValidatorFactoryImpl.class.getClassLoader());

    private static final boolean jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", ValidatorFactoryImpl.class.getClassLoader());

    private static final boolean fastjsonPresent = ClassUtils.isPresent("com.alibaba.fastjson.JSON", ValidatorFactoryImpl.class.getClassLoader());
    
    private static final boolean commonsFileUploadPresent = ClassUtils.isPresent("org.apache.commons.fileupload.servlet.ServletFileUpload", ValidatorFactoryImpl.class.getClassLoader());
    
    private MessageInterpolator messageInterpolator;
    private List<HttpMessageReader<?>> messageReaders;
    private ValidationFactory validationFactory;
    private ValidatorConfig validatorConfig;
    private boolean initialized;
    
    public ValidatorFactoryImpl() {
    }

    public ValidatorFactoryImpl(ValidatorConfig validatorConfig) {
        setValidatorConfig(validatorConfig);
    }

    @Override
    public MessageInterpolator getMessageInterpolator() {
        return this.messageInterpolator;
    }
    
    @Override
    public List<HttpMessageReader<?>> getMessageReaders() {
        return this.messageReaders;
    }
    
    @Override
    public ValidationFactory getValidationFactory() {
        return this.validationFactory;
    }
    
    @Override
    public ValidatorConfig getValidatorConfig() {
        return this.validatorConfig;
    }
    
    public void setMessageInterpolator(MessageInterpolator messageInterpolator) {
        this.messageInterpolator = messageInterpolator;
    }
    
    public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {
        this.messageReaders = messageReaders;
    }
    
    public void setValidationFactory(ValidationFactory validationFactory) {
        this.validationFactory = validationFactory;
    }
    
    public void setValidatorConfig(ValidatorConfig validatorConfig) {
        Assert.notNull(validatorConfig, "validator config must not be null.");
        this.validatorConfig = validatorConfig;
    }
    
    public void init() {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        if (this.validatorConfig == null) {
            throw new IllegalArgumentException("validator config must not be null.");
        }
        if (this.messageInterpolator == null) {
            this.messageInterpolator = new ResourceBundleMessageInterpolator();
        }
        if (this.messageReaders == null) {
            this.messageReaders = new ArrayList<>();
            this.messageReaders.add(new FormHttpMessageReader());
            if (commonsFileUploadPresent) {
                this.messageReaders.add(new MultipartFormHttpMessageReader());
            }
            if (jackson2Present) {
                this.messageReaders.add(new MappingJackson2HttpMessageReader());
            } else if (fastjsonPresent) {
                this.messageReaders.add(new FastJsonHttpMessageReader());
            }
            if (jackson2XmlPresent) {
                this.messageReaders.add(new MappingJackson2XmlHttpMessageReader());
            }
        }
        if (this.validationFactory == null) {
            this.validationFactory = new DefaultValidationFactory();
        }
        if (this.validatorConfig.getInvalidHandler() == null) {
            this.validatorConfig.setInvalidHandler(new DefaultInvalidHandler());
        }
        if (this.validatorConfig.getValidatorDelegate() == null) {
            this.validatorConfig.setValidatorDelegate(new DefaultValidatorDelegate());
        }
    }

    @Override
    public Validator buildValidator() {
        init();
        return new ValidatorImpl(this);
    }
}
```


Overlapping Code:
```
lass ValidatorFactoryImpl implements ValidatorFactory {
private static final boolean jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", ValidatorFactoryImpl.class.getClassLoader()) &&
ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", ValidatorFactoryImpl.class.getClassLoader());
private static final boolean jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", ValidatorFactoryImpl.class.getClassLoader());
private static final boolean fastjsonPresent = ClassUtils.isPresent("com.alibaba.fastjson.JSON", ValidatorFactoryImpl.class.getClassLoader());

private static final boolean commonsFileUploadPresent = ClassUtils.isPresent("org.apache.commons.fileupload.servlet.ServletFileUpload", ValidatorFactoryImpl.class.getClassLoader());

private MessageInterpolator messageInterpolator;
private List<HttpMessageReader<?>> messageReaders;
private ValidationFactory validationFactory;
private ValidatorConfig validatorConfig;
private boolean initialized;

public ValidatorFactoryImpl() {
}
public ValidatorFactoryImpl(ValidatorConfig validatorConfig) {
setValidatorConfig(validatorConfig);
}
@Override
public MessageInterpolator getMessageInterpolator() {
return this.messageInterpolator;
}

@Override
public List<HttpMessageReader<?>> getMessageReaders() {
return this.messageReaders;
}

@Override
public ValidationFactory getValidationFactory() {
return this.validationFactory;
}

@Override
public ValidatorConfig getValidatorConfig() {
return this.validatorConfig;
}

public void setMessageInterpolator(MessageInterpolator messageInterpolator) {
this.messageInterpolator = messageInterpolator;
}

public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {
this.messageReaders = messageReaders;
}

public void setValidationFactory(ValidationFactory validationFactory) {
this.validationFactory = validationFactory;
}

public void setValidatorConfig(ValidatorConfig validatorConfig) {
Assert.notNull(validatorConfig, "validator config must not be null.");
this.validatorConfig = validatorConfig;
}

public void init() {
if (this.initialized) {
return;
}
this.initialized = true;
```
<Overlap Ratio: 0.9963403476669717>

---

--- 74 --
Question ID: d11d295afdb7aa2ecfcb7a3f568ee00239877175_0
Original Code:
```
public class IgniteSqlDistributedJoin2SelfTest extends AbstractIndexingCommonTest {
    /** */
    private static final int NODES_COUNT = 3;

    /** */
    private static final String PERSON_CACHE = "person";

    /** */
    private static final String MED_INFO_CACHE = "medical_info";

    /** */
    private static final String BLOOD_INFO_PJ_CACHE = "blood_group_info_PJ";

    /** */
    private static final String BLOOD_INFO_P_CACHE = "blood_group_info_P";

    /** {@inheritDoc} */
    @Override protected void afterTest() throws Exception {
        stopAllGrids();

        super.afterTest();
    }

    /**
     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result
     * for non-collocated data.
     *
     * <ul>
     *     <li>Create single cache with multiple query entities.</li>
     *     <li>Put data into cache.</li>
     *     <li>Check query with distributedJoin=true returns correct results.</li>
     * </ul>
     *
     * @throws Exception If failed.
     */
    @Ignore("https://ggsystems.atlassian.net/browse/GG-29449")
    @Test
    public void testNonCollocatedDistributedJoinSingleCache() throws Exception {
        startGridsMultiThreaded(NODES_COUNT, false);

        QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class)
            .setTableName(BLOOD_INFO_P_CACHE)
            .setKeyFieldName("blood_group");

        bgQueryEntity.getFields().put("blood_group", String.class.toString());

        IgniteCache<Object, Object> cache = ignite(0).createCache(
            new CacheConfiguration<>(DEFAULT_CACHE_NAME)
                .setQueryEntities(Arrays.asList(
                    new QueryEntity(String.class, Person.class).setTableName(PERSON_CACHE),
                    new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE),
                    new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE),
                    bgQueryEntity
                ))
        );

        awaitPartitionMapExchange();

        populatePersonData(cache);
        populateMedInfoData(cache);
        populateBloodGrpPJData(cache);
        populateBloodGrpPData(cache);

        checkQueries(cache);
    }

    /**
     * Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result
     * for non-collocated data.
     *
     * <ul>
     *     <li>Create caches for query entities (single query entity per cache).</li>
     *     <li>Put data into cache.</li>
     *     <li>Check query with distributedJoin=true returns correct results.</li>
     * </ul>
     *
     * @throws Exception If failed.
     */
    @Test
    public void testNonCollocatedDistributedJoin() throws Exception {
        startGridsMultiThreaded(NODES_COUNT, false);

        IgniteCache<Object, Object> personCache = ignite(0).createCache(
            new CacheConfiguration<>(PERSON_CACHE).setQueryEntities(Collections.singleton(
                new QueryEntity(String.class, Person.class)))
                .setSqlSchema("PUBLIC")
        );

        IgniteCache<Object, Object> medInfoCache = ignite(0).createCache(
            new CacheConfiguration<>(MED_INFO_CACHE).setQueryEntities(Collections.singleton(
                new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE)))
                .setSqlSchema("PUBLIC")
        );

        IgniteCache<Object, Object> bloodGrpCache1 = ignite(0).createCache(
            new CacheConfiguration<>(BLOOD_INFO_PJ_CACHE).setQueryEntities(Collections.singleton(
                new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE)))
                .setSqlSchema("PUBLIC")
        );

        final QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class).setTableName(BLOOD_INFO_P_CACHE)
            .setKeyFieldName("blood_group");
        bgQueryEntity.getFields().put("blood_group", String.class.toString());

        IgniteCache<Object, Object> bloodGrpCache2 = ignite(0).createCache(
            new CacheConfiguration<>(BLOOD_INFO_P_CACHE).setQueryEntities(Collections.singleton(
                bgQueryEntity))
                .setSqlSchema("PUBLIC")
        );

        awaitPartitionMapExchange();

        populatePersonData(personCache);
        populateMedInfoData(medInfoCache);
        populateBloodGrpPJData(bloodGrpCache1);
        populateBloodGrpPData(bloodGrpCache2);

        checkQueries(personCache);
    }

    /**
     * Start queries and check query results.
     *
     * @param cache Cache.
     */
    private void checkQueries(IgniteCache<Object, Object> cache) {
        // Join on secondary index.
        SqlFieldsQuery qry1 = new SqlFieldsQuery("SELECT person.id, person.name, medical_info.blood_group, blood_group_info_PJ.universal_donor FROM person\n" +
            "  LEFT JOIN medical_info ON medical_info.name = person.name \n" +
            "  LEFT JOIN blood_group_info_PJ ON blood_group_info_PJ.blood_group = medical_info.blood_group;");

        // Join on primary index.
        SqlFieldsQuery qry2 = new SqlFieldsQuery("SELECT person.id, person.name, medical_info.blood_group, blood_group_info_P.universal_donor FROM person\n" +
            "  LEFT JOIN medical_info ON medical_info.name = person.name \n" +
            "  LEFT JOIN blood_group_info_P ON blood_group_info_P.blood_group = medical_info.blood_group;");

        qry1.setDistributedJoins(true);
        qry2.setDistributedJoins(true);

        final String res1 = queryResultAsString(cache.query(qry1).getAll());
        final String res2 = queryResultAsString(cache.query(qry2).getAll());

        log.info("Query1 result: \n" + res1);
        log.info("Query2 result: \n" + res2);

        String expOut = "2001,Shravya,null,null\n" +
            "2002,Kiran,O+,O+A+B+AB+\n" +
            "2003,Harika,AB+,AB+\n" +
            "2004,Srinivas,null,null\n" +
            "2005,Madhavi,A+,A+AB+\n" +
            "2006,Deeps,null,null\n" +
            "2007,Hope,null,null\n";

        assertEquals("Wrong result", expOut, res1);
        assertEquals("Wrong result", expOut, res2);
    }

    /**
     * Convert query result to string.
     *
     * @param res Query result set.
     * @return String representation.
     */
    private String queryResultAsString(List<List<?>> res) {
        List<String> results = new ArrayList<>();

        for (List<?> row : res) {
            StringBuilder sb = new StringBuilder();
            for (Iterator<?> iterator = row.iterator(); iterator.hasNext(); ) {
                sb.append(iterator.next());

                if (iterator.hasNext())
                    sb.append(',');
            }
            results.add(sb.toString());
        }

        results.sort(String::compareTo);

        StringBuilder sb = new StringBuilder();

        for (String result : results)
            sb.append(result).append('\n');

        return sb.toString();
    }

    /**
     * @param cache Ignite cache.
     */
    private void populatePersonData(IgniteCache<Object, Object> cache) {
        cache.put("Shravya", new Person(2001, "Shravya"));
        cache.put("Kiran", new Person(2002, "Kiran"));
        cache.put("Harika", new Person(2003, "Harika"));
        cache.put("Srinivas", new Person(2004, "Srinivas"));
        cache.put("Madhavi", new Person(2005, "Madhavi"));
        cache.put("Deeps", new Person(2006, "Deeps"));
        cache.put("Hope", new Person(2007, "Hope"));
    }

    /**
     * @param cache Ignite cache.
     */
    private void populateMedInfoData(IgniteCache<Object, Object> cache) {
        cache.put(2001L, new MedicalInfo(2001, "Madhavi", "A+"));
        cache.put(2002L, new MedicalInfo(2002, "Diggi", "B+"));
        cache.put(2003L, new MedicalInfo(2003, "Kiran", "O+"));
        cache.put(2004L, new MedicalInfo(2004, "Harika", "AB+"));
    }

    /**
     * @param cache Ignite cache.
     */
    private void populateBloodGrpPJData(IgniteCache<Object, Object> cache) {
        cache.put(2001L, new BloodGroupInfoPJ(2001, "A+", "A+AB+"));
        cache.put(2002L, new BloodGroupInfoPJ(2002, "O+", "O+A+B+AB+"));
        cache.put(2003L, new BloodGroupInfoPJ(2003, "B+", "B+AB+"));
        cache.put(2004L, new BloodGroupInfoPJ(2004, "AB+", "AB+"));
        cache.put(2005L, new BloodGroupInfoPJ(2005, "O-", "EveryOne"));
    }

    /**
     * @param cache Ignite cache.
     */
    private void populateBloodGrpPData(IgniteCache<Object, Object> cache) {
        cache.put("A+", new BloodGroupInfoP(2001, "A+", "A+AB+"));
        cache.put("O+", new BloodGroupInfoP(2002, "O+", "O+A+B+AB+"));
        cache.put("B+", new BloodGroupInfoP(2003, "B+", "B+AB+"));
        cache.put("AB+", new BloodGroupInfoP(2004, "AB+", "AB+"));
        cache.put("O-", new BloodGroupInfoP(2005, "O-", "EveryOne"));
    }

    /**
     *
     */
    private static class Person {
        /** */
        @QuerySqlField
        private long id;

        /** */
        @QuerySqlField
        private String name;

        Person(long id, String name) {
            this.id = id;
            this.name = name;
        }

        public long getId() { return id; }

        public void setId(long id) { this.id = id; }

        public String getName() { return name; }

        public void setName(String name) { this.name = name; }
    }

    /**
     *
     */
    private static class MedicalInfo {
        /** */
        @QuerySqlField
        private long id;

        /** */
        @QuerySqlField(index = true)
        private String name;

        /** */
        @QuerySqlField(name = "blood_group")
        private String bloodGroup;

        MedicalInfo(long id, String name, String bloodGroup) {
            this.id = id;
            this.name = name;
            this.bloodGroup = bloodGroup;
        }

        public void setId(long id) { this.id = id; }

        public long getId() { return id; }

        public String getName() { return name; }

        public void setName(String name) { this.name = name; }

        public String getBloodGroup() { return bloodGroup; }

        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }
    }

    /**
     *
     */
    private static class BloodGroupInfoPJ {
        /** */
        @QuerySqlField
        private long id;

        /** */
        @QuerySqlField(index = true, name = "blood_group")
        private String bloodGroup;

        /** */
        @QuerySqlField(name = "universal_donor")
        private String universalDonor;

        BloodGroupInfoPJ(long id, String bloodGroup, String universalDonor) {
            this.id = id;
            this.bloodGroup = bloodGroup;
            this.universalDonor = universalDonor;
        }

        public void setId(long id) { this.id = id; }

        public long getId() { return id; }

        public String getBloodGroup() { return bloodGroup; }

        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }

        public String getUniversalDonor() { return universalDonor; }

        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }
    }

    /**
     *
     */
    private static class BloodGroupInfoP {
        /** */
        private long id;

        /** */
        @QuerySqlField
        private String bloodGroup;  // PK

        /** */
        @QuerySqlField(name = "universal_donor")
        private String universalDonor;

        BloodGroupInfoP(long id, String bloodGroup, String universalDonor) {
            this.id = id;
            this.bloodGroup = bloodGroup;
            this.universalDonor = universalDonor;
        }

        public void setId(long id) { this.id = id; }

        public long getId() { return id; }

        public String getBloodGroup() { return bloodGroup; }

        public void setBloodGroup(String bloodGroup) { this.bloodGroup = bloodGroup; }

        public String getUniversalDonor() { return universalDonor; }

        public void setUniversalDonor(String universalDonor) { this.universalDonor = universalDonor; }
    }
}
```


Overlapping Code:
```
tedJoin2SelfTest extends AbstractIndexingCommonTest {
/** */
private static final int NODES_COUNT = 3;
/** */
private static final String PERSON_CACHE = "person";
/** */
private static final String MED_INFO_CACHE = "medical_info";
/** */
private static final String BLOOD_INFO_PJ_CACHE = "blood_group_info_PJ";
/** */
private static final String BLOOD_INFO_P_CACHE = "blood_group_info_P";
/** {@inheritDoc} */
@Override protected void afterTest() throws Exception {
stopAllGrids();
super.afterTest();
}
/**
* Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result
* for non-collocated data.
*
* <ul>
* <li>Create single cache with multiple query entities.</li>
* <li>Put data into cache.</li>
* <li>Check query with distributedJoin=true returns correct results.</li>
* </ul>
*
* @throws Exception If failed.
*/
@Ignore("https://ggsystems.atlassian.net/browse/GG-29449")
@Test
public void testNonCollocatedDistributedJoinSingleCache() throws Exception {
startGridsMultiThreaded(NODES_COUNT, false);
QueryEntity bgQueryEntity = new QueryEntity(String.class, BloodGroupInfoP.class)
.setTableName(BLOOD_INFO_P_CACHE)
.setKeyFieldName("blood_group");
bgQueryEntity.getFields().put("blood_group", String.class.toString());
IgniteCache<Object, Object> cache = ignite(0).createCache(
new CacheConfiguration<>(DEFAULT_CACHE_NAME)
.setQueryEntities(Arrays.asList(
new QueryEntity(String.class, Person.class).setTableName(PERSON_CACHE),
new QueryEntity(Long.class, MedicalInfo.class).setTableName(MED_INFO_CACHE),
new QueryEntity(Long.class, BloodGroupInfoPJ.class).setTableName(BLOOD_INFO_PJ_CACHE),
bgQueryEntity
))
);
awaitPartitionMapExchange();
populatePersonData(cache);
populateMedInfoData(cache);
populateBloodGrpPJData(cache);
populateBloodGrpPData(cache);
checkQueries(cache);
}
/**
* Check distributed OUTER join of 3 tables (T1 -> T2 -> T3) returns correct result
* for non-collocated data.
*
* <ul>
* <li>Create caches for query entities (single query entity per cache).</
```
<Overlap Ratio: 0.9746588693957114>

---

--- 75 --
Question ID: 25a167e4e5d0f3d0036d35d07ab5219669453238_0
Original Code:
```
@Dependent
@Default
public class DefaultSSHKeyStore implements SSHKeyStore {

    public static final String USER_DIR = "user.dir";

    public static final String SSH_KEYS_PATH_PARAM = "appformer.ssh.keys.storage.folder";

    public static final String SSH_KEYS_FOLDER = ".security/pkeys";

    private final Map<String, UserSSHKeyStore> userKeyStores = new HashMap<>();

    private final Path sshStoragePath;

    public DefaultSSHKeyStore() {

        String customStorage = System.getProperty(SSH_KEYS_PATH_PARAM, null);

        if (customStorage != null) {
            sshStoragePath = Paths.get(customStorage);
        } else {
            sshStoragePath = Paths.get(System.getProperty(USER_DIR)).resolve(SSH_KEYS_FOLDER);
        }
    }

    @PostConstruct
    public void init() {
        File keysFolder = sshStoragePath.toFile();

        if (keysFolder.exists()) {
            Stream.of(keysFolder.list())
                    .map(this::getUserKeyStore)
                    .forEach(userSSHKeyStore -> userKeyStores.put(userSSHKeyStore.getUser(), userSSHKeyStore));
        } else {
            keysFolder.mkdirs();
        }
    }

    public UserSSHKeyStore getUserKeyStore(String userName) {
        UserSSHKeyStore userStore = userKeyStores.get(userName);

        if (userStore == null) {
            userStore = new UserSSHKeyStore(userName, sshStoragePath);
            userKeyStores.put(userName, userStore);
        }

        return userStore;
    }

    @Override
    public void addUserKey(final String userName, final SSHPublicKey key) {
        getUserKeyStore(userName).addUserKey(key);
    }

    @Override
    public void removeUserKey(String userName, SSHPublicKey key) {
        getUserKeyStore(userName).removeUserKey(key);
    }

    @Override
    public void updateUserKey(String userName, SSHPublicKey key) {
        addUserKey(userName, key);
    }

    @Override
    public Collection<SSHPublicKey> getUserKeys(String userName) {
        return getUserKeyStore(userName).getUserKeys();
    }
}
```


Overlapping Code:
```
Store implements SSHKeyStore {
public static final String USER_DIR = "user.dir";
public static final String SSH_KEYS_PATH_PARAM = "appformer.ssh.keys.storage.folder";
public static final String SSH_KEYS_FOLDER = ".security/pkeys";
private final Map<String, UserSSHKeyStore> userKeyStores = new HashMap<>();
private final Path sshStoragePath;
public DefaultSSHKeyStore() {
String customStorage = System.getProperty(SSH_KEYS_PATH_PARAM, null);
if (customStorage != null) {
sshStoragePath = Paths.get(customStorage);
} else {
sshStoragePath = Paths.get(System.getProperty(USER_DIR)).resolve(SSH_KEYS_FOLDER);
}
}
@PostConstruct
public void init() {
File keysFolder = sshStoragePath.toFile();
if (keysFolder.exists()) {
Stream.of(keysFolder.list())
.map(this::getUserKeyStore)
.forEach(userSSHKeyStore -> userKeyStores.put(userSSHKeyStore.getUser(), userSSHKeyStore));
} else {
keysFolder.mkdirs();
}
}
public UserSSHKeyStore getUserKeyStore(String userName) {
UserSSHKeyStore userStore = userKeyStores.get(userName);
if (userStore == null) {
userStore = new UserSSHKeyStore(userName, sshStoragePath);
userKeyStores.put(userName, userStore);
}
return userStore;
}
@Override
public void addUserKey(final String userName, final SSHPublicKey key) {
getUserKeyStore(userName).addUserKey(key);
}
@Override
public void removeUserKey(String userName, SSHPublicKey key) {
getUserKeyStore(userName).removeUserKey(key);
}
@Override
public void updateUserKey(String userName, SSHPublicKey key) {
addUserKey(userName, key);
}
@Override
public Collection<SSHPublicKey> getUserKeys(String userName) {
return getUserKey
```
<Overlap Ratio: 0.9523809523809523>

---

--- 76 --
Question ID: 01e167677eb8cc00d3380457990ffa9f367952f0_0
Original Code:
```
class AnnotatedMixinElementHandlerInjector extends AnnotatedMixinElementHandler {
  static class AnnotatedElementInjector extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {
    private final InjectorRemap state;
    
    public AnnotatedElementInjector(ExecutableElement element, AnnotationHandle annotation, InjectorRemap shouldRemap) {
      super(element, annotation);
      this.state = shouldRemap;
    }
    
    public boolean shouldRemap() {
      return this.state.shouldRemap();
    }
    
    public boolean hasCoerceArgument() {
      if (!this.annotation.toString().equals("@Inject"))
        return false; 
      Iterator<? extends VariableElement> iterator = this.element.getParameters().iterator();
      if (iterator.hasNext()) {
        VariableElement param = iterator.next();
        return AnnotationHandle.of(param, Coerce.class).exists();
      } 
      return false;
    }
    
    public void addMessage(Diagnostic.Kind kind, CharSequence msg, Element element, AnnotationHandle annotation) {
      this.state.addMessage(kind, msg, element, annotation);
    }
    
    public String toString() {
      return getAnnotation().toString();
    }
  }
  
  static class AnnotatedElementInjectionPoint extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {
    private final AnnotationHandle at;
    
    private Map<String, String> args;
    
    private final InjectorRemap state;
    
    public AnnotatedElementInjectionPoint(ExecutableElement element, AnnotationHandle inject, AnnotationHandle at, InjectorRemap state) {
      super(element, inject);
      this.at = at;
      this.state = state;
    }
    
    public boolean shouldRemap() {
      return this.at.getBoolean("remap", this.state.shouldRemap());
    }
    
    public AnnotationHandle getAt() {
      return this.at;
    }
    
    public String getAtArg(String key) {
      if (this.args == null) {
        this.args = new HashMap<String, String>();
        for (String arg : this.at.getList("args")) {
          if (arg == null)
            continue; 
          int eqPos = arg.indexOf('=');
          if (eqPos > -1) {
            this.args.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
          } 
          this.args.put(arg, "");
        } 
      } 
      return this.args.get(key);
    }
    
    public void notifyRemapped() {
      this.state.notifyRemapped();
    }
  }
  
  AnnotatedMixinElementHandlerInjector(IMixinAnnotationProcessor ap, AnnotatedMixin mixin) {
    super(ap, mixin);
  }
  
  public void registerInjector(AnnotatedElementInjector elem) {
    if (this.mixin.isInterface())
      this.ap.printMessage(Diagnostic.Kind.ERROR, "Injector in interface is unsupported", elem.getElement()); 
    for (String reference : elem.getAnnotation().getList("method")) {
      MemberInfo targetMember = MemberInfo.parse(reference);
      if (targetMember.name == null)
        continue; 
      try {
        targetMember.validate();
      } catch (InvalidMemberDescriptorException ex) {
        elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, ex.getMessage());
      } 
      if (targetMember.desc != null)
        validateReferencedTarget(elem.getElement(), elem.getAnnotation(), targetMember, elem.toString()); 
      if (!elem.shouldRemap())
        continue; 
      for (TypeHandle target : this.mixin.getTargets()) {
        if (!registerInjector(elem, reference, targetMember, target))
          break; 
      } 
    } 
  }
  
  private boolean registerInjector(AnnotatedElementInjector elem, String reference, MemberInfo targetMember, TypeHandle target) {
    String desc = target.findDescriptor(targetMember);
    if (desc == null) {
      Diagnostic.Kind error = this.mixin.isMultiTarget() ? Diagnostic.Kind.ERROR : Diagnostic.Kind.WARNING;
      if (target.isSimulated()) {
        elem.printMessage((Messager)this.ap, Diagnostic.Kind.NOTE, elem + " target '" + reference + "' in @Pseudo mixin will not be obfuscated");
      } else if (target.isImaginary()) {
        elem.printMessage((Messager)this.ap, error, elem + " target requires method signature because enclosing type information for " + target + " is unavailable");
      } else if (!targetMember.isInitialiser()) {
        elem.printMessage((Messager)this.ap, error, "Unable to determine signature for " + elem + " target method");
      } 
      return true;
    } 
    String targetName = elem + " target " + targetMember.name;
    MappingMethod targetMethod = target.getMappingMethod(targetMember.name, desc);
    ObfuscationData<MappingMethod> obfData = this.obf.getDataProvider().getObfMethod(targetMethod);
    if (obfData.isEmpty())
      if (target.isSimulated()) {
        obfData = this.obf.getDataProvider().getRemappedMethod(targetMethod);
      } else {
        if (targetMember.isClassInitialiser())
          return true; 
        Diagnostic.Kind error = targetMember.isConstructor() ? Diagnostic.Kind.WARNING : Diagnostic.Kind.ERROR;
        elem.addMessage(error, "No obfuscation mapping for " + targetName, elem.getElement(), elem.getAnnotation());
        return false;
      }  
    IReferenceManager refMap = this.obf.getReferenceManager();
    try {
      if ((targetMember.owner == null && this.mixin.isMultiTarget()) || target.isSimulated())
        obfData = AnnotatedMixinElementHandler.stripOwnerData(obfData); 
      refMap.addMethodMapping(this.classRef, reference, obfData);
    } catch (ReferenceConflictException ex) {
      String conflictType = this.mixin.isMultiTarget() ? "Multi-target" : "Target";
      if (elem.hasCoerceArgument() && targetMember.owner == null && targetMember.desc == null) {
        MemberInfo oldMember = MemberInfo.parse(ex.getOld());
        MemberInfo newMember = MemberInfo.parse(ex.getNew());
        if (oldMember.name.equals(newMember.name)) {
          obfData = AnnotatedMixinElementHandler.stripDescriptors(obfData);
          refMap.setAllowConflicts(true);
          refMap.addMethodMapping(this.classRef, reference, obfData);
          refMap.setAllowConflicts(false);
          elem.printMessage((Messager)this.ap, Diagnostic.Kind.WARNING, "Coerced " + conflictType + " reference has conflicting descriptors for " + targetName + ": Storing bare references " + obfData
              .values() + " in refMap");
          return true;
        } 
      } 
      elem.printMessage((Messager)this.ap, Diagnostic.Kind.ERROR, conflictType + " reference conflict for " + targetName + ": " + reference + " -> " + ex
          .getNew() + " previously defined as " + ex.getOld());
    } 
    return true;
  }
  
  public void registerInjectionPoint(AnnotatedElementInjectionPoint elem, String format) {
    if (this.mixin.isInterface())
      this.ap.printMessage(Diagnostic.Kind.ERROR, "Injector in interface is unsupported", elem.getElement()); 
    if (!elem.shouldRemap())
      return; 
    String type = InjectionPointData.parseType((String)elem.getAt().getValue("value"));
    String target = (String)elem.getAt().getValue("target");
    if ("NEW".equals(type)) {
      remapNewTarget(String.format(format, new Object[] { type + ".<target>" }), target, elem);
      remapNewTarget(String.format(format, new Object[] { type + ".args[class]" }), elem.getAtArg("class"), elem);
    } else {
      remapReference(String.format(format, new Object[] { type + ".<target>" }), target, elem);
    } 
  }
  
  protected final void remapNewTarget(String subject, String reference, AnnotatedElementInjectionPoint elem) {
    if (reference == null)
      return; 
    MemberInfo member = MemberInfo.parse(reference);
    String target = member.toCtorType();
    if (target != null) {
      String desc = member.toCtorDesc();
      MappingMethod m = new MappingMethod(target, ".", (desc != null) ? desc : "()V");
      ObfuscationData<MappingMethod> remapped = this.obf.getDataProvider().getRemappedMethod(m);
      if (remapped.isEmpty()) {
        this.ap.printMessage(Diagnostic.Kind.WARNING, "Cannot find class mapping for " + subject + " '" + target + "'", elem.getElement(), elem
            .getAnnotation().asMirror());
        return;
      } 
      ObfuscationData<String> mappings = new ObfuscationData<String>();
      for (ObfuscationType type : remapped) {
        MappingMethod mapping = remapped.get(type);
        if (desc == null) {
          mappings.put(type, mapping.getOwner());
          continue;
        } 
        mappings.put(type, mapping.getDesc().replace(")V", ")L" + mapping.getOwner() + ";"));
      } 
      this.obf.getReferenceManager().addClassMapping(this.classRef, reference, mappings);
    } 
    elem.notifyRemapped();
  }
  
  protected final void remapReference(String subject, String reference, AnnotatedElementInjectionPoint elem) {
    if (reference == null)
      return; 
    AnnotationMirror errorsOn = ((this.ap.getCompilerEnvironment() == IMixinAnnotationProcessor.CompilerEnvironment.JDT) ? elem.getAt() : elem.getAnnotation()).asMirror();
    MemberInfo targetMember = MemberInfo.parse(reference);
    if (!targetMember.isFullyQualified()) {
      String missing = (targetMember.owner == null) ? ((targetMember.desc == null) ? "owner and signature" : "owner") : "signature";
      this.ap.printMessage(Diagnostic.Kind.ERROR, subject + " is not fully qualified, missing " + missing, elem.getElement(), errorsOn);
      return;
    } 
    try {
      targetMember.validate();
    } catch (InvalidMemberDescriptorException ex) {
      this.ap.printMessage(Diagnostic.Kind.ERROR, ex.getMessage(), elem.getElement(), errorsOn);
    } 
    try {
      if (targetMember.isField()) {
        ObfuscationData<MappingField> obfFieldData = this.obf.getDataProvider().getObfFieldRecursive(targetMember);
        if (obfFieldData.isEmpty()) {
          this.ap.printMessage(Diagnostic.Kind.WARNING, "Cannot find field mapping for " + subject + " '" + reference + "'", elem.getElement(), errorsOn);
          return;
        } 
        this.obf.getReferenceManager().addFieldMapping(this.classRef, reference, targetMember, obfFieldData);
      } else {
        ObfuscationData<MappingMethod> obfMethodData = this.obf.getDataProvider().getObfMethodRecursive(targetMember);
        if (obfMethodData.isEmpty() && (
          targetMember.owner == null || !targetMember.owner.startsWith("java/lang/"))) {
          this.ap.printMessage(Diagnostic.Kind.WARNING, "Cannot find method mapping for " + subject + " '" + reference + "'", elem.getElement(), errorsOn);
          return;
        } 
        this.obf.getReferenceManager().addMethodMapping(this.classRef, reference, targetMember, obfMethodData);
      } 
    } catch (ReferenceConflictException ex) {
      this.ap.printMessage(Diagnostic.Kind.ERROR, "Unexpected reference conflict for " + subject + ": " + reference + " -> " + ex
          .getNew() + " previously defined as " + ex.getOld(), elem.getElement(), errorsOn);
      return;
    } 
    elem.notifyRemapped();
  }
}
```


Overlapping Code:
```
notatedMixinElementHandlerInjector extends AnnotatedMixinElementHandler {
static class AnnotatedElementInjector extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {
private final InjectorRemap state;

public AnnotatedElementInjector(ExecutableElement element, AnnotationHandle annotation, InjectorRemap shouldRemap) {
super(element, annotation);
this.state = shouldRemap;
}

public boolean shouldRemap() {
return this.state.shouldRemap();
}

public boolean hasCoerceArgument() {
if (!this.annotation.toString().equals("@Inject"))
return false; 
Iterator<? extends VariableElement> iterator = this.element.getParameters().iterator();
if (iterator.hasNext()) {
VariableElement param = iterator.next();
return AnnotationHandle.of(param, Coerce.class).exists();
} 
return false;
}

public void addMessage(Diagnostic.Kind kind, CharSequence msg, Element element, AnnotationHandle annotation) {
this.state.addMessage(kind, msg, element, annotation);
}

public String toString() {
return getAnnotation().toString();
}
}

static class AnnotatedElementInjectionPoint extends AnnotatedMixinElementHandler.AnnotatedElement<ExecutableElement> {
private final AnnotationHandle at;

private Map<String, String> args;

private final InjectorRemap state;

public AnnotatedElementInjectionPoint(ExecutableElement element, AnnotationHandle inject, AnnotationHandle at, InjectorRemap state) {
super(element, inject);
this.at = at;
this.state = state;
}

public boolean shouldRemap() {
return this.at.getBoolean("remap", this.state.shouldRemap());
}

public AnnotationHandle getAt() {
return this.at;
}

public String getAtArg(String key) {
if (this.args == null) {
this.args = new HashMap<String, String>();
for (String arg : this.at.getList("args")) {
if (arg == null)
continue; 
int eqPos = arg.indexOf('=');
if (eqPos > -1) {
this.args.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
continue;
} 
this.args.put(arg, "");
} 
} 
return this.args.get(key);
}

public void notifyRemapped() {
this.state.notifyRemapped();
}
}

AnnotatedMixinElementHandlerInjector(IMixinAnnota
```
<Overlap Ratio: 0.9961777353081701>

---

--- 77 --
Question ID: 678045a3f505e6fae08a6134241817945240b01d_0
Original Code:
```
@Component
@EnableBinding(Sink.class)
public class MessageListener {

  @Autowired
  private SimpMessagingTemplate simpMessageTemplate;
  
  @Autowired
  private ObjectMapper objectMapper;

  @StreamListener(target = Sink.INPUT)
  @Transactional
  public void messageReceived(byte[] messageJsonBytes) throws Exception {
	String messageJson = new String(messageJsonBytes, "UTF-8");  
    Message<JsonNode> message = objectMapper.readValue( //
        messageJson, //
        new TypeReference<Message<JsonNode>>() {});
    
    String type = "Event";
    if (message.getType().endsWith("Command")) {
      type = "Command";
    }
    
    PastEvent event = new PastEvent( //
        type, //
        message.getType(), //
        message.getTraceid(), //
        message.getSource(), //
        message.getData().toString());
    event.setSourceJson(messageJson);
    
    // save
    LogRepository.instance.addEvent(event);
    
    // and probably send to connected websocket (TODO: Not a good place for the code here!)
    simpMessageTemplate.convertAndSend("/topic/events", event);
  }

}
```


Overlapping Code:
```
Component
@EnableBinding(Sink.class)
public class MessageListener {
@Autowired
private SimpMessagingTemplate simpMessageTemplate;

@Autowired
private ObjectMapper objectMapper;
@StreamListener(target = Sink.INPUT)
@Transactional
public void messageReceived(byte[] messageJsonBytes) throws Exception {
String messageJson = new String(messageJsonBytes, "UTF-8"); 
Message<JsonNode> message = objectMapper.readValue( //
messageJson, //
new TypeReference<Message<JsonNode>>() {});

String type = "Event";
if (message.getType().endsWith("Command")) {
type = "Command";
}

PastEvent event = new PastEvent( //
type, //
message.getType(), //
message.getTraceid(), //
message.getSource(), //
message.getData().toString());
event.setSourceJson(messageJson);

// save
LogRepository.instance.addEvent(event);

// and probably send to connected websocket (TODO: Not a good place for the code here!)
simpMessageTemplate.convertAndSend("/topic/events", ev
```
<Overlap Ratio: 0.9894736842105263>

---

--- 78 --
Question ID: 3ffb5cabc55fea8cb734e91d425ffb34b89aa274_0
Original Code:
```
public class PowerOffAction extends OmniAction {
    public static final String APP_NAME = "Signals";
    public static final String ACTION_NAME = "Power Off Device";

    public PowerOffAction(HashMap<String, String> parameters) throws libretasks.app.controller.util.OmnidroidException {
        super(libretasks.app.controller.external.actions.SignalsActionService.class.getName(),
                libretasks.app.controller.Action.BY_SERVICE);
    }

    @Override
    public Intent getIntent() {
        Intent intent = new Intent();
        intent.setClassName(LIBRETASKS_PACKAGE_NAME, libretasks.app.controller.external.actions.SignalsActionService.class.getName());
        intent.putExtra(libretasks.app.controller.external.actions.SignalsActionService.OPERATION_TYPE,
                libretasks.app.controller.external.actions.SignalsActionService.POWER_OFF_DEVICE);
        intent.putExtra(DATABASE_ID, databaseId);
        intent.putExtra(ACTION_TYPE, actionType);
        intent.putExtra(NOTIFICATION, showNotification);
        return intent;
    }

    @Override
    public String getDescription() {
        return APP_NAME + "-" + ACTION_NAME;
    }


}
```


Overlapping Code:
```
n extends OmniAction {
public static final String APP_NAME = "Signals";
public static final String ACTION_NAME = "Power Off Device";
public PowerOffAction(HashMap<String, String> parameters) throws libretasks.app.controller.util.OmnidroidException {
super(libretasks.app.controller.external.actions.SignalsActionService.class.getName(),
libretasks.app.controller.Action.BY_SERVICE);
}
@Override
public Intent getIntent() {
Intent intent = new Intent();
intent.setClassName(LIBRETASKS_PACKAGE_NAME, libretasks.app.controller.external.actions.SignalsActionService.class.getName());
intent.putExtra(libretasks.app.controller.external.actions.SignalsActionService.OPERATION_TYPE,
libretasks.app.controller.external.actions.SignalsActionService.POWER_OFF_DEVICE);
intent.putExtra(DATABASE_ID, databaseId);
intent.putExtra(ACTION_TYPE, actionType);
intent.putExtra(NOTIFICATION, showNotification);
return intent;
}
@Override
public String getDescription() {
return APP_NAME + "-" + ACTION_NAME;
}
}
```
<Overlap Ratio: 0.9744597249508841>

---

--- 79 --
Question ID: 80e314fc843a0e143ee24bde6d195b484f3b6a2d_0
Original Code:
```
public class DMLCallStatement implements DMLStatement {

    private static final long serialVersionUID = -3180767340174107586L;
    private long parseInfo;
    private Identifier name;
    private final List<Expression> params;

    public DMLCallStatement(Identifier name, List<Expression> params) {
        this.name = name;
        this.params = params;
    }

    public Identifier getName() {
        return name;
    }

    public List<Expression> getParams() {
        return params;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public int getSQLType() {
        return SQLType.CALL;
    }

    @Override
    public void setParseInfo(long parseInfo) {
        this.parseInfo = parseInfo;
    }

    @Override
    public long getParseInfo() {
        return parseInfo;
    }

    @Override
    public boolean replace(AST from, AST to) {
        boolean result = false;
        if (name != null) {
            if (name.equals(from)) {
                name = (Identifier) to;
                result = true;
            } else {
                result |= name.replace(from, to);
            }
        }
        if (params != null) {
            Iterator<Expression> iter = params.iterator();
            int i = 0;
            while (iter.hasNext()) {
                Expression exp = iter.next();
                if (exp != null) {
                    if (exp.equals(to)) {
                        params.set(i, (Expression) to);
                        result = true;
                    } else {
                        result |= exp.replace(from, to);
                    }
                }
                i++;
            }
        }
        return result;
    }

    @Override
    public boolean removeSchema(byte[] schema) {
        boolean removed = false;
        if (name != null) {
            removed |= name.removeSchema(schema);
        }
        if (params != null) {
            Iterator<Expression> iter = params.iterator();
            while (iter.hasNext()) {
                Expression exp = iter.next();
                if (exp != null) {
                    removed |= exp.removeSchema(schema);
                }
            }
        }
        return removed;
    }

    @Override
    public void setCachedTableName(byte[] affectedTable) {}

    @Override
    public byte[] getCachedTableName() {
        return null;
    }

    @Override
    public boolean maybeMoreThanTwoTable() {
        return false;
    }
}
```


Overlapping Code:
```
tement implements DMLStatement {
private static final long serialVersionUID = -3180767340174107586L;
private long parseInfo;
private Identifier name;
private final List<Expression> params;
public DMLCallStatement(Identifier name, List<Expression> params) {
this.name = name;
this.params = params;
}
public Identifier getName() {
return name;
}
public List<Expression> getParams() {
return params;
}
@Override
public void accept(Visitor visitor) {
visitor.visit(this);
}
@Override
public int getSQLType() {
return SQLType.CALL;
}
@Override
public void setParseInfo(long parseInfo) {
this.parseInfo = parseInfo;
}
@Override
public long getParseInfo() {
return parseInfo;
}
@Override
public boolean replace(AST from, AST to) {
boolean result = false;
if (name != null) {
if (name.equals(from)) {
name = (Identifier) to;
result = true;
} else {
result |= name.replace(from, to);
}
}
if (params != null) {
Iterator<Expression> iter = params.iterator();
int i = 0;
while (iter.hasNext()) {
Expression exp = iter.next();
if (exp != null) {
if (exp.equals(to)) {
params.set(i, (Expression) to);
result = true;
} else {
result |= exp.replace(from, to);
}
}
i++;
}
}
return result;
}
@Override
public boolean removeSchema(byte[] schema) {
boolean removed = false;
if (name != null) {
removed |= name.removeSchema(schema);
}
if (params != null) {
Iterator<Expression> iter = params.iterator();
while (iter.hasNext()) {
Expression exp = iter.next();
if (exp != null) {
removed |= exp.removeSchema(schema);
}
}
}
return removed;
}
@Override
public void setCachedTableName(byte[] affectedTable) {}
@Override
public byte[] getCachedTableName() {
return null;
}
@Override
public boolean maybeMoreThanTwoTable() {
ret
```
<Overlap Ratio: 0.984936268829664>

---

--- 80 --
Question ID: 8d736cfbdb7f0b903c51d0664b74557bb2115a86_0
Original Code:
```
class FXOMRefresher {

    public void refresh(FXOMDocument document) {
        String fxmlText = null;
        try {
            fxmlText = document.getFxmlText(false);
            final FXOMDocument newDocument
                    = new FXOMDocument(fxmlText,
                    document.getLocation(),
                    document.getClassLoader(),
                    document.getResources(),
                    false /* normalized */);
            final TransientStateBackup backup = new TransientStateBackup(document);
            // if the refresh should not take place (e.g. due to an error), remove a property from intrinsic
            if (newDocument.getSceneGraphRoot() == null && newDocument.getFxomRoot() == null) {
                removeIntrinsicProperty(document);
            } else {
                refreshDocument(document, newDocument);
            }
            backup.restore();
            synchronizeDividerPositions(document);
        } catch (RuntimeException | IOException x) {
            final StringBuilder sb = new StringBuilder();
            sb.append("Bug in ");
            sb.append(getClass().getSimpleName());
            if (fxmlText != null) {
                try {
                    final File fxmlFile = File.createTempFile("DTL-5996-", ".fxml");
                    try (PrintWriter pw = new PrintWriter(fxmlFile, "UTF-8")) {
                        pw.write(fxmlText);
                        sb.append(": FXML dumped in ");
                        sb.append(fxmlFile.getPath());
                    }
                } catch (IOException xx) {
                    sb.append(": no FXML dumped");
                }
            } else {
                sb.append(": no FXML dumped");
            }
            throw new IllegalStateException(sb.toString(), x);
        }
    }

    private void removeIntrinsicProperty(FXOMDocument document) {
        FXOMInstance fxomRoot = (FXOMInstance) document.getFxomRoot();
        if (fxomRoot != null) {
            FXOMPropertyC propertyC = (FXOMPropertyC) fxomRoot.getProperties().get(new PropertyName("children"));
            if (propertyC.getValues().get(0) instanceof FXOMIntrinsic) {
                FXOMIntrinsic fxomIntrinsic = (FXOMIntrinsic) propertyC.getValues().get(0);
                fxomIntrinsic.removeCharsetProperty();
            }
        }
    }

    /*
     * Private (stylesheet)
     */

    private void refreshDocument(FXOMDocument currentDocument, FXOMDocument newDocument) {
        // Transfers scene graph object from newDocument to currentDocument
        currentDocument.setSceneGraphRoot(newDocument.getSceneGraphRoot());
        // Transfers display node from newDocument to currentDocument
        currentDocument.setDisplayNode(newDocument.getDisplayNode());
        // Transfers display stylesheets from newDocument to currentDocument
        currentDocument.setDisplayStylesheets(newDocument.getDisplayStylesheets());
        // Simulates Scene's behavior : automatically adds "root" styleclass if
        // if the scene graph root is a Parent instance or wraps a Parent instance
        if (currentDocument.getSceneGraphRoot() instanceof Parent) {
            final Parent rootParent = (Parent) currentDocument.getSceneGraphRoot();
            rootParent.getStyleClass().add(0, "root");
        } else if (currentDocument.getSceneGraphRoot() instanceof Scene
                || currentDocument.getSceneGraphRoot() instanceof Window) {
            Node displayNode = currentDocument.getDisplayNode();
            if (displayNode != null && displayNode instanceof Parent) {
                displayNode.getStyleClass().add(0, "root");
            }
        }
        // Recurses
        if (currentDocument.getFxomRoot() != null) {
            refreshFxomObject(currentDocument.getFxomRoot(), newDocument.getFxomRoot());
        }
    }


    private void refreshFxomObject(FXOMObject currentObject, FXOMObject newObject) {
        assert currentObject != null;
        assert newObject != null;
        assert currentObject.getClass() == newObject.getClass();
        currentObject.setSceneGraphObject(newObject.getSceneGraphObject());
        if (currentObject instanceof FXOMInstance) {
            refreshFxomInstance((FXOMInstance) currentObject, (FXOMInstance) newObject);
        } else if (currentObject instanceof FXOMCollection) {
            refreshFxomCollection((FXOMCollection) currentObject, (FXOMCollection) newObject);
        } else if (currentObject instanceof FXOMIntrinsic) {
            refreshFxomIntrinsic((FXOMIntrinsic) currentObject, (FXOMIntrinsic) newObject);
        } else {
            assert false : "Unexpected fxom object " + currentObject;
        }

//        assert currentObject.equals(newObject) : "currentValue=" + currentObject +
//                                               "  newValue=" + newObject;
    }


    private void refreshFxomInstance(FXOMInstance currentInstance, FXOMInstance newInstance) {
        assert currentInstance != null;
        assert newInstance != null;
        assert currentInstance.getClass() == newInstance.getClass();
        currentInstance.setDeclaredClass(newInstance.getDeclaredClass());
        final Set<PropertyName> currentNames = currentInstance.getProperties().keySet();
        final Set<PropertyName> newNames = newInstance.getProperties().keySet();
        assert currentNames.equals(newNames);
        for (PropertyName name : currentNames) {
            final FXOMProperty currentProperty = currentInstance.getProperties().get(name);
            final FXOMProperty newProperty = newInstance.getProperties().get(name);
            refreshFxomProperty(currentProperty, newProperty);
        }
    }

    private void refreshFxomCollection(FXOMCollection currentCollection, FXOMCollection newCollection) {
        assert currentCollection != null;
        assert newCollection != null;
        currentCollection.setDeclaredClass(newCollection.getDeclaredClass());
        refreshFxomObjects(currentCollection.getItems(), newCollection.getItems());
    }

    private void refreshFxomIntrinsic(FXOMIntrinsic currentIntrinsic, FXOMIntrinsic newIntrinsic) {
        assert currentIntrinsic != null;
        assert newIntrinsic != null;
        currentIntrinsic.setSourceSceneGraphObject(newIntrinsic.getSourceSceneGraphObject());
        currentIntrinsic.getProperties().clear();
        currentIntrinsic.fillProperties(newIntrinsic.getProperties());
    }

    private void refreshFxomProperty(FXOMProperty currentProperty, FXOMProperty newProperty) {
        assert currentProperty != null;
        assert newProperty != null;
        assert currentProperty.getName().equals(newProperty.getName());
        if (currentProperty instanceof FXOMPropertyT) {
            assert newProperty instanceof FXOMPropertyT;
            assert ((FXOMPropertyT) currentProperty).getValue().equals(((FXOMPropertyT) newProperty).getValue());
        } else {
            assert currentProperty instanceof FXOMPropertyC;
            assert newProperty instanceof FXOMPropertyC;
            final FXOMPropertyC currentPC = (FXOMPropertyC) currentProperty;
            final FXOMPropertyC newPC = (FXOMPropertyC) newProperty;
            refreshFxomObjects(currentPC.getValues(), newPC.getValues());
        }
    }


    private void refreshFxomObjects(List<FXOMObject> currentObjects, List<FXOMObject> newObjects) {
        assert currentObjects != null;
        assert newObjects != null;
        assert currentObjects.size() == newObjects.size();
        for (int i = 0, count = currentObjects.size(); i < count; i++) {
            final FXOMObject currentObject = currentObjects.get(i);
            final FXOMObject newObject = newObjects.get(i);
            if (currentObject instanceof FXOMIntrinsic || newObject instanceof FXOMIntrinsic) {
                handleRefreshIntrinsic(currentObject, newObject);
            } else {
                refreshFxomObject(currentObject, newObject);
            }
        }
    }

    private void handleRefreshIntrinsic(FXOMObject currentObject, FXOMObject newObject) {
        if (currentObject instanceof FXOMIntrinsic && newObject instanceof FXOMIntrinsic) {
            refreshFxomObject(currentObject, newObject);
        } else if (newObject instanceof FXOMIntrinsic) {
            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) newObject);
            refreshFxomObject(currentObject, fxomInstance);
        } else if (currentObject instanceof FXOMIntrinsic) {
            FXOMInstance fxomInstance = getFxomInstance((FXOMIntrinsic) currentObject);
            refreshFxomObject(fxomInstance, newObject);
        }
    }

    private FXOMInstance getFxomInstance(FXOMIntrinsic intrinsic) {
        FXOMInstance fxomInstance = new FXOMInstance(intrinsic.getFxomDocument(), intrinsic.getGlueElement());
        fxomInstance.setSceneGraphObject(intrinsic.getSourceSceneGraphObject());
        fxomInstance.setDeclaredClass(intrinsic.getClass());
        if (!intrinsic.getProperties().isEmpty()) {
            fxomInstance.fillProperties(intrinsic.getProperties());
        }
        return fxomInstance;
    }
    
    /*
     * The case of SplitPane.dividerPositions property
     * -----------------------------------------------
     * 
     * When user adds a child to a SplitPane, this adds a new entry in
     * SplitPane.children property but also adds a new value to 
     * SplitPane.dividerPositions by side-effect.
     * 
     * The change in SplitPane.dividerPositions is performed at scene graph
     * level by FX. Thus it is unseen by FXOM. 
     * 
     * So in that case we perform a special operation which copies value of 
     * SplitPane.dividerPositions into FXOMProperty representing 
     * dividerPositions in FXOM.
     */

    private void synchronizeDividerPositions(FXOMDocument document) {
        final FXOMObject fxomRoot = document.getFxomRoot();
        if (fxomRoot != null) {
            final Metadata metadata
                    = Metadata.getMetadata();
            final PropertyName dividerPositionsName
                    = new PropertyName("dividerPositions");
            final List<FXOMObject> candidates
                    = fxomRoot.collectObjectWithSceneGraphObjectClass(SplitPane.class);

            for (FXOMObject fxomObject : candidates) {
                if (fxomObject instanceof FXOMInstance) {
                    final FXOMInstance fxomInstance = (FXOMInstance) fxomObject;
                    assert fxomInstance.getSceneGraphObject() instanceof SplitPane;
                    final SplitPane splitPane
                            = (SplitPane) fxomInstance.getSceneGraphObject();
                    splitPane.layout();
                    final ValuePropertyMetadata vpm
                            = metadata.queryValueProperty(fxomInstance, dividerPositionsName);
                    assert vpm instanceof ListValuePropertyMetadata
                            : "vpm.getClass()=" + vpm.getClass().getSimpleName();
                    final DoubleArrayPropertyMetadata davpm
                            = (DoubleArrayPropertyMetadata) vpm;
                    davpm.synchronizeWithSceneGraphObject(fxomInstance);
                }
            }
        }
    }


//    
//    
//    private void reloadStylesheets(final Parent p) {
//        assert p != null;
//        assert p.getScene() != null;
//        
//        if (p.getStylesheets().isEmpty() == false) {
//            final List<String> stylesheets = new ArrayList<>();
//            stylesheets.addAll(p.getStylesheets());
////            p.getStylesheets().clear();
////            p.impl_processCSS(true);
//            p.getStylesheets().setAll(stylesheets);
////            p.impl_processCSS(true);
//        }
//        for (Node child : p.getChildrenUnmodifiable()) {
//            if (child instanceof Parent) {
//                reloadStylesheets((Parent)child);
//            }
//        }
//        
//    }
}
```


Overlapping Code:
```
ss FXOMRefresher {
public void refresh(FXOMDocument document) {
String fxmlText = null;
try {
fxmlText = document.getFxmlText(false);
final FXOMDocument newDocument
= new FXOMDocument(fxmlText,
document.getLocation(),
document.getClassLoader(),
document.getResources(),
false /* normalized */);
final TransientStateBackup backup = new TransientStateBackup(document);
// if the refresh should not take place (e.g. due to an error), remove a property from intrinsic
if (newDocument.getSceneGraphRoot() == null && newDocument.getFxomRoot() == null) {
removeIntrinsicProperty(document);
} else {
refreshDocument(document, newDocument);
}
backup.restore();
synchronizeDividerPositions(document);
} catch (RuntimeException | IOException x) {
final StringBuilder sb = new StringBuilder();
sb.append("Bug in ");
sb.append(getClass().getSimpleName());
if (fxmlText != null) {
try {
final File fxmlFile = File.createTempFile("DTL-5996-", ".fxml");
try (PrintWriter pw = new PrintWriter(fxmlFile, "UTF-8")) {
pw.write(fxmlText);
sb.append(": FXML dumped in ");
sb.append(fxmlFile.getPath());
}
} catch (IOException xx) {
sb.append(": no FXML dumped");
}
} else {
sb.append(": no FXML dumped");
}
throw new IllegalStateException(sb.toString(), x);
}
}
private void removeIntrinsicProperty(FXOMDocument document) {
FXOMInstance fxomRoot = (FXOMInstance) document.getFxomRoot();
if (fxomRoot != null) {
FXOMPropertyC propertyC = (FXOMPropertyC) fxomRoot.getProperties().get(new PropertyName("children"));
if (propertyC.getValues().get(0) instanceof FXOMIntrinsic) {
FXOMIntrinsic fxomIntrinsic = (FXOMIntrinsic) propertyC.getValues().get(0);
fxomIntrinsic.removeCharsetProperty();
}
}
}
/*
* Private (stylesheet)
*/
private void refreshDocument(FXOMDocument currentDocument, FXOMDocument newDocument
```
<Overlap Ratio: 0.9966499162479062>

---

--- 81 --
Question ID: 584adf95b12d49372efde44a112841a25b0668ab_0
Original Code:
```
public class JsonTreeSerializer {
    private boolean serializeNulls = false;
    private boolean prettyFormat = false;

    public boolean isSerializeNulls() {
        return serializeNulls;
    }

    public void setSerializeNulls(boolean serializeNulls) {
        this.serializeNulls = serializeNulls;
    }

    public boolean isPrettyFormat() {
        return prettyFormat;
    }

    public void setPrettyFormat(boolean prettyFormat) {
        this.prettyFormat = prettyFormat;
    }

    /**
     * Converts a tree of {@link JsonTreeNode}s into its equivalent JSON representation.
     *
     * @param jsonElement root of a tree of {@link JsonTreeNode}s
     * @return JSON String representation of the tree
     * @since 1.4
     */
    public String toJson(JsonTreeNode jsonElement) {
        StringWriter writer = new StringWriter();
        toJson(jsonElement, writer);
        return writer.toString();
    }

    /**
     * Writes out the equivalent JSON for a tree of {@link JsonTreeNode}s.
     *
     * @param jsonElement root of a tree of {@link JsonTreeNode}s
     * @param writer      Writer to which the Json representation needs to be written
     * @throws JsonException if there was a problem writing to the writer
     * @since 1.4
     */
    public void toJson(JsonTreeNode jsonElement, Appendable writer) throws JsonException {
        try {
            JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
            toJson(jsonElement, jsonWriter);
        } catch (IOException e) {
            throw new JsonException(e);
        }
    }


    /**
     * Returns a new JSON writer configured for the settings on this JSON instance.
     */
    private JsonWriter newJsonWriter(Writer writer) throws IOException {
        JsonWriter jsonWriter = new JsonWriter(writer);
        if (prettyFormat) {
            jsonWriter.setIndent("  ");
        }
        jsonWriter.setSerializeNulls(serializeNulls);
        return jsonWriter;
    }

    /**
     * Writes the JSON for {@code jsonElement} to {@code writer}.
     *
     * @throws JsonException if there was a problem writing to the writer
     */
    public void toJson(JsonTreeNode jsonElement, JsonWriter writer) throws JsonException {
        boolean oldLenient = writer.isLenient();
        writer.setLenient(true);
        boolean oldHtmlSafe = writer.isHtmlSafe();
        writer.setHtmlSafe(true);
        boolean oldSerializeNulls = writer.getSerializeNulls();
        writer.setSerializeNulls(serializeNulls);
        try {
            Streams.write(jsonElement, writer);
        } catch (IOException e) {
            throw new JsonException(e);
        } catch (AssertionError e) {
            throw new JsonException("AssertionError " + e.getMessage(), e);
        } finally {
            writer.setLenient(oldLenient);
            writer.setHtmlSafe(oldHtmlSafe);
            writer.setSerializeNulls(oldSerializeNulls);
        }
    }

}
```


Overlapping Code:
```
lizer {
private boolean serializeNulls = false;
private boolean prettyFormat = false;
public boolean isSerializeNulls() {
return serializeNulls;
}
public void setSerializeNulls(boolean serializeNulls) {
this.serializeNulls = serializeNulls;
}
public boolean isPrettyFormat() {
return prettyFormat;
}
public void setPrettyFormat(boolean prettyFormat) {
this.prettyFormat = prettyFormat;
}
/**
* Converts a tree of {@link JsonTreeNode}s into its equivalent JSON representation.
*
* @param jsonElement root of a tree of {@link JsonTreeNode}s
* @return JSON String representation of the tree
* @since 1.4
*/
public String toJson(JsonTreeNode jsonElement) {
StringWriter writer = new StringWriter();
toJson(jsonElement, writer);
return writer.toString();
}
/**
* Writes out the equivalent JSON for a tree of {@link JsonTreeNode}s.
*
* @param jsonElement root of a tree of {@link JsonTreeNode}s
* @param writer Writer to which the Json representation needs to be written
* @throws JsonException if there was a problem writing to the writer
* @since 1.4
*/
public void toJson(JsonTreeNode jsonElement, Appendable writer) throws JsonException {
try {
JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
toJson(jsonElement, jsonWriter);
} catch (IOException e) {
throw new JsonException(e);
}
}
/**
* Returns a new JSON writer configured for the settings on this JSON instance.
*/
private JsonWriter newJsonWriter(Writer writer) throws IOException {
JsonWriter jsonWriter = new JsonWriter(writer);
if (prettyFormat) {
jsonWriter.setIndent(" ");
}
jsonWriter.setSerializeNulls(serializeNulls);
return jsonWriter;
}
/**
* Writes the JSON for {@code jsonElement} to {@code writer}.
*
* @throws JsonException if there was a problem writing to the writer
*/
public void toJson(JsonTreeNode jsonElement, JsonWriter writer) throws JsonException {
boolean oldLenient = writer.isLenient();
writer.setLenient(true);
boolean oldHtmlSafe = writer.isHtmlSafe();
writer.setHtmlSafe(true);
boolean oldSerializeNulls = writer.getSerializeNulls();
writer.setSer
```
<Overlap Ratio: 0.9856390617520344>

---

--- 82 --
Question ID: e31c9e0a20536d43963d88976a8713cf3571b64c_0
Original Code:
```
public class EventDefintionParser {
	
	@SuppressWarnings("rawtypes")
	public static EventDefinition parserEventDefinition(Element element) {
		String nodeName = element.getName();
		if (BpmnXMLConstants.ELEMENT_TERMINATEEVENTDEFINITION.equalsIgnoreCase(nodeName)) {
			TerminateEventDefinition terminateEventDefinition = new TerminateEventDefinition();
			terminateEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));
			return terminateEventDefinition;
		} else if (BpmnXMLConstants.ELEMENT_TIMEREVENTDEFINITION.equalsIgnoreCase(nodeName)) {
			TimerEventDefinition timerEventDefinition = new TimerEventDefinition();
			timerEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));
			Element elem = null;
			for (Iterator iterator = element.elements().iterator(); iterator.hasNext();) {
				elem = (Element) iterator.next();
				nodeName = elem.getName();
				if (BpmnXMLConstants.ELEMENT_TIMEDATE.equalsIgnoreCase(nodeName)) {
					timerEventDefinition.setTimeDate(BpmnXMLUtil.parseExpression(elem));
				} else if (BpmnXMLConstants.ELEMENT_TIMEDURATION.equalsIgnoreCase(nodeName)) {
					timerEventDefinition.setTimeDuration(BpmnXMLUtil.parseExpression(elem));
				} else if (BpmnXMLConstants.ELEMENT_TIMECYCLE.equalsIgnoreCase(nodeName)) {
					timerEventDefinition.setTimeCycle(BpmnXMLUtil.parseExpression(elem));
				}
			}
			return timerEventDefinition;
		}
		return null;
	}
}
```


Overlapping Code:
```

@SuppressWarnings("rawtypes")
public static EventDefinition parserEventDefinition(Element element) {
String nodeName = element.getName();
if (BpmnXMLConstants.ELEMENT_TERMINATEEVENTDEFINITION.equalsIgnoreCase(nodeName)) {
TerminateEventDefinition terminateEventDefinition = new TerminateEventDefinition();
terminateEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));
return terminateEventDefinition;
} else if (BpmnXMLConstants.ELEMENT_TIMEREVENTDEFINITION.equalsIgnoreCase(nodeName)) {
TimerEventDefinition timerEventDefinition = new TimerEventDefinition();
timerEventDefinition.setId(element.attributeValue(BpmnXMLConstants.ATTRIBUTE_ID));
Element elem = null;
for (Iterator iterator = element.elements().iterator(); iterator.hasNext();) {
elem = (Element) iterator.next();
nodeName = elem.getName();
if (BpmnXMLConstants.ELEMENT_TIMEDATE.equalsIgnoreCase(nodeName)) {
timerEventDefinition.setTimeDate(BpmnXMLUtil.parseExpression(elem));
} else if (BpmnXMLConstants.ELEMENT_TIMEDURATION.equalsIgnoreCase(nodeName)) {
timerEventDefinition.setTimeDuration(BpmnXMLUtil.parseExpression(elem));
} else if (BpmnXMLConstants.ELEMENT_TIMECYCLE.equalsIgnoreCase(nodeName)) {
timerEventDefinition.setTimeCycle(BpmnXMLUtil.parseExpression(elem));
}
}
return timerEventDefinition;
}
return n
```
<Overlap Ratio: 0.9674556213017751>

---

--- 83 --
Question ID: 78f5a083638aa3008d8699e518e6dfa6bb395155_0
Original Code:
```
public class DecimalTransform {

  /**
   Add a value to a column
   */
  public static BigDecimal add(BigDecimal bd1, Object o) {
    BigDecimal bd2 = objectToBigDecimal(o);
    if (bd1 == null) {
      return bd2;
    }
    return bd1.add(bd2);
  }

  /**
   Subtract a value from a column
   */
  public static BigDecimal subtract(BigDecimal bd1, Object o) {
    BigDecimal bd2 = objectToBigDecimal(o);
    if (bd1 == null) {
      return bd2.negate();
    }
    return bd1.subtract(bd2);
  }

  /**
   Multiply the column by a given value
   */
  public static BigDecimal multiply(BigDecimal bd1, Object o) {
    BigDecimal bd2 = objectToBigDecimal(o);
    if (bd1 == null) {
      return BigDecimal.ZERO;
    }
    return bd1.multiply(bd2);
  }

  /**
   Divide the column by a given value and return the quotient
   */
  public static BigDecimal divideq(BigDecimal bd1, Object o) {
    BigDecimal bd2 = objectToBigDecimal(o);
    if (bd2.equals(BigDecimal.ZERO)) {
      return null;
    }
    if (bd1 == null) {
      return BigDecimal.ZERO;
    }
    return bd1.divide(bd2, BigDecimal.ROUND_HALF_EVEN);
  }

  /**
   Divide the column by a given value and return the remainder
   */
  public static BigDecimal divider(BigDecimal bd1, Object o) {
    BigDecimal bd2 = objectToBigDecimal(o);
    if (bd2.equals(BigDecimal.ZERO)) {
      return null;
    }
    if (bd1 == null) {
      return BigDecimal.ZERO;
    }
    return bd1.remainder(bd2);
  }

  /**
  Get the absolute value
   */
  public static BigDecimal abs(BigDecimal bd) {
    return bd.abs();
  }

  /**
   Get the precision of a decimal value
   */
  public static int precision(BigDecimal bd) {
    return bd.precision();
  }

  /**
   Get the scale of a decimal value
   */
  public static int scale(BigDecimal bd) {
    return bd.scale();
  }

  /**
   Get the unscaled value of a decimal value
   */
  public static BigInteger unscaled(BigDecimal bd) {
    return bd.unscaledValue();
  }

  /**
   Move the decimal point n places to the left
   */
  public static BigDecimal decimal_left(BigDecimal bd, int n) {
    int newScale = bd.scale() + n;
    bd = bd.setScale(newScale, BigDecimal.ROUND_UP);
    bd = bd.divide(BigDecimal.valueOf(Math.pow(10, n)), BigDecimal.ROUND_HALF_EVEN);
    return bd.stripTrailingZeros();
  }

  /**
   Move the decimal point n places to the right
   */
  public static BigDecimal decimal_right(BigDecimal bd, int n) {
    int newScale = Math.max(bd.scale() - n, 0);
    bd = bd.multiply(BigDecimal.valueOf(Math.pow(10, n)));
    bd = bd.setScale(newScale, BigDecimal.ROUND_DOWN);
    return bd;
  }

  /**
   Get the nth power of a decimal
   */
  public static BigDecimal pow(BigDecimal bd, int pow) {
    return bd.pow(pow);
  }

  /**
   Negate a decimal
   */
  public static BigDecimal negate(BigDecimal bd) {
    bd = bd.negate();
    if (bd.compareTo(BigDecimal.ZERO) == 0) {
      return BigDecimal.ZERO;
    }
    return bd;
  }

  /**
   Strip trailing zeros in a decimal
   */
  public static BigDecimal strip_zero(BigDecimal bd) {
    return bd.stripTrailingZeros();
  }

  /**
   Sign of a value
   */
  public static int sign(BigDecimal bd) {
    return Integer.compare(bd.compareTo(BigDecimal.ZERO), 0);
  }

  private static BigDecimal objectToBigDecimal(Object o) {
    if (o instanceof BigDecimal) {
      return (BigDecimal) o;
    } else if (o instanceof Integer) {
      return BigDecimal.valueOf((Integer) o);
    } else if (o instanceof Double) {
      return BigDecimal.valueOf((Double) o);
    } else {
      return null;
    }
  }
}
```


Overlapping Code:
```
value to a column
*/
public static BigDecimal add(BigDecimal bd1, Object o) {
BigDecimal bd2 = objectToBigDecimal(o);
if (bd1 == null) {
return bd2;
}
return bd1.add(bd2);
}
/**
Subtract a value from a column
*/
public static BigDecimal subtract(BigDecimal bd1, Object o) {
BigDecimal bd2 = objectToBigDecimal(o);
if (bd1 == null) {
return bd2.negate();
}
return bd1.subtract(bd2);
}
/**
Multiply the column by a given value
*/
public static BigDecimal multiply(BigDecimal bd1, Object o) {
BigDecimal bd2 = objectToBigDecimal(o);
if (bd1 == null) {
return BigDecimal.ZERO;
}
return bd1.multiply(bd2);
}
/**
Divide the column by a given value and return the quotient
*/
public static BigDecimal divideq(BigDecimal bd1, Object o) {
BigDecimal bd2 = objectToBigDecimal(o);
if (bd2.equals(BigDecimal.ZERO)) {
return null;
}
if (bd1 == null) {
return BigDecimal.ZERO;
}
return bd1.divide(bd2, BigDecimal.ROUND_HALF_EVEN);
}
/**
Divide the column by a given value and return the remainder
*/
public static BigDecimal divider(BigDecimal bd1, Object o) {
BigDecimal bd2 = objectToBigDecimal(o);
if (bd2.equals(BigDecimal.ZERO)) {
return null;
}
if (bd1 == null) {
return BigDecimal.ZERO;
}
return bd1.remainder(bd2);
}
/**
Get the absolute value
*/
public static BigDecimal abs(BigDecimal bd) {
return bd.abs();
}
/**
Get the precision of a decimal value
*/
public static int precision(BigDecimal bd) {
return bd.precision();
}
/**
Get the scale of a decimal value
*/
public static int scale(BigDecimal bd) {
return bd.scale();
}
/**
Get the unscaled value of a decimal value
*/
public static BigInteger unscaled(BigDecimal bd) {
return bd.unscaledValue();
}
/**
Move the decimal point n places to the left
*/
public static BigDecimal decimal_left(BigDecimal bd, int n) {
int newScale = bd.scale() + n;
bd = bd.setScale(newScale, BigDecimal.ROUND_UP);
bd = bd.divide(BigDecimal.valueOf(Math.pow(10, n)), BigDecimal.ROUND_HALF_EVEN);
return bd.stripTrailingZeros();
}
/**
Move the decimal point n places to the right
*/
public static BigDecimal decimal_right(BigDecimal bd, int n) {
int newScale = Math.max(bd
```
<Overlap Ratio: 0.9628610729023384>

---

--- 84 --
Question ID: f91046b4c380f8846b75378c46037baabe9fc5c2_0
Original Code:
```
@Configuration
public class KaptchaConfig {

    @Bean
    public Producer kaptchaProducer(){
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width","100");
        properties.setProperty("kaptcha.image.height","40");
        properties.setProperty("kaptcha.textproducer.font.size","32");
        properties.setProperty("kaptcha.textproducer.font.color","0,0,0");
        properties.setProperty("kaptcha.textproducer.char.string","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
        properties.setProperty("kaptcha.textproducer.char.length","4");
        properties.setProperty("kaptcha.noise.impl","com.google.code.kaptcha.impl.NoNoise");


        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        Config config = new Config(properties);
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }

}
```


Overlapping Code:
```
onfiguration
public class KaptchaConfig {
@Bean
public Producer kaptchaProducer(){
Properties properties = new Properties();
properties.setProperty("kaptcha.image.width","100");
properties.setProperty("kaptcha.image.height","40");
properties.setProperty("kaptcha.textproducer.font.size","32");
properties.setProperty("kaptcha.textproducer.font.color","0,0,0");
properties.setProperty("kaptcha.textproducer.char.string","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
properties.setProperty("kaptcha.textproducer.char.length","4");
properties.setProperty("kaptcha.noise.impl","com.google.code.kaptcha.impl.NoNoise");
DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
Config config = new Config(properties);
defaultKaptcha.setConfig(config);
return defaultKaptcha;
}
}
```
<Overlap Ratio: 0.9974715549936789>

---

--- 85 --
Question ID: c797673248382e6feec94ccd27c96be56563c613_0
Original Code:
```
public class CreateNetworkCmdExec extends AbstrSyncDockerCmdExec<CreateNetworkCmd, CreateNetworkResponse> implements
        CreateNetworkCmd.Exec {

    private static final Logger LOGGER = LoggerFactory.getLogger(CreateNetworkCmdExec.class);

    public CreateNetworkCmdExec(WebTarget baseResource, DockerClientConfig dockerClientConfig) {
        super(baseResource, dockerClientConfig);
    }

    @Override
    protected CreateNetworkResponse execute(CreateNetworkCmd command) {
        WebTarget webResource = getBaseResource().path("/networks/create");

        LOGGER.trace("POST: {}", webResource);
        return webResource.request().accept(MediaType.APPLICATION_JSON)
                .post(command, new TypeReference<CreateNetworkResponse>() {
                });
    }
}
```


Overlapping Code:
```
SyncDockerCmdExec<CreateNetworkCmd, CreateNetworkResponse> implements
CreateNetworkCmd.Exec {
private static final Logger LOGGER = LoggerFactory.getLogger(CreateNetworkCmdExec.class);
public CreateNetworkCmdExec(WebTarget baseResource, DockerClientConfig dockerClientConfig) {
super(baseResource, dockerClientConfig);
}
@Override
protected CreateNetworkResponse execute(CreateNetworkCmd command) {
WebTarget webResource = getBaseResource().path("/networks/create");
LOGGER.trace("POST: {}", webResource);
return webResource.request().accept(MediaType.APPLICATION_JSON)
.post(command, new TypeReferenc
```
<Overlap Ratio: 0.8784773060029283>

---

--- 86 --
Question ID: 0d1833cd258b31ca5b4938380875a6dcde8abcc4_0
Original Code:
```
public class DataValidatorJSON {

    public DataValidatorJSON() { }

    static final String jInput           = "input";

    static final String paramFormat           = "outputFormat";
    static final String paramIndirection      = "url";
    static final String paramData             = "data";
    static final String paramSyntax           = "languageSyntax";

    public static JsonObject execute(ValidationAction action) {
        JsonBuilder obj = new JsonBuilder();
        obj.startObject();

        String syntax = getArgOrNull(action, paramSyntax);
        if ( syntax == null || syntax.equals("") )
            syntax = RDFLanguages.NQUADS.getName();

        Lang language = RDFLanguages.shortnameToLang(syntax);
        if ( language == null ) {
            ServletOps.errorBadRequest("Unknown syntax: " + syntax);
            return null;
        }

        String string = getArg(action, paramData);
        StringReader sr = new StringReader(string);
        obj.key(jInput).value(string);
        StreamRDF dest = StreamRDFLib.sinkNull();

        try {
            RDFParser.create().source(sr).lang(language).parse(dest);
        } catch (RiotParseException ex) {
            obj.key(jErrors);

            obj.startArray();      // Errors array
            obj.startObject();
            obj.key(jParseError).value(ex.getMessage());
            obj.key(jParseErrorLine).value(ex.getLine());
            obj.key(jParseErrorCol).value(ex.getCol());
            obj.finishObject();
            obj.finishArray();

            obj.finishObject(); // Outer object
            return obj.build().getAsObject();
        } catch (RiotException ex) {
            obj.key(jErrors);

            obj.startArray();      // Errors array
            obj.startObject();
            obj.key(jParseError).value(ex.getMessage());
            obj.finishObject();
            obj.finishArray();

            obj.finishObject(); // Outer object
            return obj.build().getAsObject();
        }


        obj.finishObject();
        return obj.build().getAsObject();
    }
}
```


Overlapping Code:
```
public DataValidatorJSON() { }
static final String jInput = "input";
static final String paramFormat = "outputFormat";
static final String paramIndirection = "url";
static final String paramData = "data";
static final String paramSyntax = "languageSyntax";
public static JsonObject execute(ValidationAction action) {
JsonBuilder obj = new JsonBuilder();
obj.startObject();
String syntax = getArgOrNull(action, paramSyntax);
if ( syntax == null || syntax.equals("") )
syntax = RDFLanguages.NQUADS.getName();
Lang language = RDFLanguages.shortnameToLang(syntax);
if ( language == null ) {
ServletOps.errorBadRequest("Unknown syntax: " + syntax);
return null;
}
String string = getArg(action, paramData);
StringReader sr = new StringReader(string);
obj.key(jInput).value(string);
StreamRDF dest = StreamRDFLib.sinkNull();
try {
RDFParser.create().source(sr).lang(language).parse(dest);
} catch (RiotParseException ex) {
obj.key(jErrors);
obj.startArray(); // Errors array
obj.startObject();
obj.key(jParseError).value(ex.getMessage());
obj.key(jParseErrorLine).value(ex.getLine());
obj.key(jParseErrorCol).value(ex.getCol());
obj.finishObject();
obj.finishArray();
obj.finishObject(); // Outer object
return obj.build().getAsObject();
} catch (RiotException ex) {
obj.key(jErrors);
obj.startArray(); // Errors array
obj.startObject();
obj.key(jParseError).value(ex.getMessage());
obj.finishObject();
obj.finishArray();
obj.finishObject(); // Outer object
return obj.build().getAsObject();
}
obj.finishOb
```
<Overlap Ratio: 0.9505703422053232>

---

--- 87 --
Question ID: 851b85e6a3f156eb8ab512df1acc07ee0706e6b3_0
Original Code:
```
public class Gossiper {
    private static final Logger log = LoggerFactory.getLogger(Gossiper.class);

    private final Orderer                   orderer;
    private final List<BloomFilter<Digest>> biffs;
    private final Lock                      mx = new ReentrantLock();

    public Gossiper(Controller controller) {
        this(controller.orderer());
    }

    public Gossiper(Orderer orderer) {
        this.orderer = orderer;
        biffs = new ArrayList<>();
        Config config = orderer.getConfig();
        int count = Math.max(4, config.nProc()); 
        for (int i = 0; i < count; i++) {
            biffs.add(new DigestBloomFilter(Utils.bitStreamEntropy().nextLong(),
                                            config.epochLength() * config.numberOfEpochs() * config.nProc() * 2,
                                            config.fpr()));
        }
    }

    public Gossip gossip() {
        return gossip(DigestAlgorithm.DEFAULT.getOrigin());
    }

    public Gossip gossip(Digest context) {
        log.trace("Gossiping for: {} on: {}", context, orderer.getConfig().pid());
        mx.lock();
        try {
            return Gossip.newBuilder().setContext(context.toDigeste())
                         .setHave(biffs.get(Utils.bitStreamEntropy().nextInt(biffs.size())).toBff()).build();
        } finally {
            mx.unlock();
        }
    }

    public Update gossip(Gossip gossip) {
        Update update = orderer.missing(BloomFilter.from(gossip.getHave()));
        log.trace("Gossip received for: {} missing: {} on: {}", Digest.from(gossip.getContext()),
                  update.getMissingCount(), orderer.getConfig().pid());
        return update;
    }

    public void update(Update update) {
        List<PreUnit> missing = update.getMissingList().stream()
                                      .map(pus -> PreUnit.from(pus, orderer.getConfig().digestAlgorithm()))
//                                      .filter(pu -> pu.verify(config.verifiers()))
                                      .toList();
        if (missing.isEmpty()) {
            return;
        }
        log.trace("Gossip update: {} on: {}", missing.size(), orderer.getConfig().pid());
        mx.lock();
        try {
            missing.forEach(pu -> {
                biffs.forEach(biff -> biff.add(pu.hash()));
            });
        } finally {
            mx.unlock();
        }
        orderer.addPreunits(PreUnit.topologicalSort(new ArrayList<>(missing)));
    }
}
```


Overlapping Code:
```
ssiper {
private static final Logger log = LoggerFactory.getLogger(Gossiper.class);
private final Orderer orderer;
private final List<BloomFilter<Digest>> biffs;
private final Lock mx = new ReentrantLock();
public Gossiper(Controller controller) {
this(controller.orderer());
}
public Gossiper(Orderer orderer) {
this.orderer = orderer;
biffs = new ArrayList<>();
Config config = orderer.getConfig();
int count = Math.max(4, config.nProc()); 
for (int i = 0; i < count; i++) {
biffs.add(new DigestBloomFilter(Utils.bitStreamEntropy().nextLong(),
config.epochLength() * config.numberOfEpochs() * config.nProc() * 2,
config.fpr()));
}
}
public Gossip gossip() {
return gossip(DigestAlgorithm.DEFAULT.getOrigin());
}
public Gossip gossip(Digest context) {
log.trace("Gossiping for: {} on: {}", context, orderer.getConfig().pid());
mx.lock();
try {
return Gossip.newBuilder().setContext(context.toDigeste())
.setHave(biffs.get(Utils.bitStreamEntropy().nextInt(biffs.size())).toBff()).build();
} finally {
mx.unlock();
}
}
public Update gossip(Gossip gossip) {
Update update = orderer.missing(BloomFilter.from(gossip.getHave()));
log.trace("Gossip received for: {} missing: {} on: {}", Digest.from(gossip.getContext()),
update.getMissingCount(), orderer.getConfig().pid());
return update;
}
public void update(Update update) {
List<PreUnit> missing = update.getMissingList().stream()
.map(pus -> PreUnit.from(pus, orderer.getConfig().digestAlgorithm()))
// .filter(pu -> pu.verify(config.verifiers()))
.toList();
if (missing.isEmpty()) {
return;
}
log.trace("Gossip update: {} on: {}", missing.size(), orderer.getConfig().pid());
mx.lock();
try {
missing.forEach(pu -> {
biffs.forEach(biff -> biff.add(pu.hash()));
});
} finally {
mx.unlock();
}
orderer.addPreunits(PreUnit.topologicalSort(new ArrayList<>
```
<Overlap Ratio: 0.9830693610049154>

---

--- 88 --
Question ID: d1556e3cc448e5e27b330b7cced5cebb52f46ffb_0
Original Code:
```
public class RestMultiActionController extends AbstractMultiActionController {
    
    /**
     * custom MethodNameResolver is configured that checks the value of an expected
     * paramter called "method" in the request and formats the value that may be
     * in the form of  "namespace.subnamespace.action" into "namespaceSubnamespaceAction"
     * or more like a java method name
     */
    public RestMultiActionController() {
        setMethodNameResolver(new MethodNameResolver() {
            public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException {
                String temp = request.getParameter("method");
                if (temp == null) {
                    return null;
                }
                StringBuffer sb = new StringBuffer();
                for(int i = 0; i < temp.length(); i++) {
                    char c = temp.charAt(i);
                    if (c == '.') {
                        i++;
                        c = temp.charAt(i);
                        sb.append(Character.toUpperCase(c));
                    } else {
                        sb.append(c);
                    }
                }
                return sb.toString();
            }
        });
    }
    
    /**
     * override Spring template method as a crude interceptor
     * here we are doing HTTP basic authentication TODO better security
     */
    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if(!authenticate(request)) {
            String title = "Basic realm=\"JTrac Remote API\"";
            response.setHeader("WWW-Authenticate", title);
            response.setStatus(401);
            return null;
        } else {
            return super.handleRequestInternal(request, response);
        }
    }
    
    private boolean authenticate(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        logger.debug("auth header: " + authHeader);
        if (authHeader == null) {
            return false;
        }
        StringTokenizer st = new StringTokenizer(authHeader);
        if (st.hasMoreTokens()) {
            String basic = st.nextToken();
            if (basic.equalsIgnoreCase("Basic")) {
                String credentials = st.nextToken();
                Base64 decoder = new Base64();
                String userPass = new String(decoder.decode(credentials.getBytes()));                
                int p = userPass.indexOf(":");
                if (p == -1) {
                    return false;
                }
                String loginName = userPass.substring(0, p);
                String password = userPass.substring(p + 1);
                User user = jtrac.loadUser(loginName);
                if(user == null) {
                    return false;
                }
                String encoded = jtrac.encodeClearText(password);
                if(user.getPassword().equals(encoded)) {
                    request.setAttribute("user", user);
                    return true;
                }                
            }
        }
        return false;
    }
    
    private void writeXml(Document document, HttpServletResponse response) throws Exception {
        writeXml(document.getRootElement(), response);
    }    
    
    private void writeXml(Element element, HttpServletResponse response) throws Exception {
        initXmlResponse(response);
        element.write(response.getWriter());
    }
    
    private void initXmlResponse(HttpServletResponse response) {
        applyCacheSeconds(response, 0, true);
        response.setContentType("text/xml");         
    }
    
    private String getContent(HttpServletRequest request) throws Exception {
        InputStream is = request.getInputStream();        
        int ch;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        while ((ch = is.read()) != -1) {
            baos.write((byte) ch);
        }
        return new String(baos.toByteArray());
    }
    
    //============================ REQUEST HANDLERS ============================
        
    public void versionGet(HttpServletRequest request, HttpServletResponse response) throws Exception {
        Document d = XmlUtils.getNewDocument("version");
        Element root = d.getRootElement();
        root.addAttribute("number", jtrac.getReleaseVersion());
        root.addAttribute("timestamp", jtrac.getReleaseTimestamp());
        writeXml(d, response);
    }
    
    public void itemGet(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String refId = request.getParameter("refId");
        Item item = null;
        try {
            item = jtrac.loadItemByRefId(refId);
        } catch (InvalidRefIdException e) {
            // TODO
        }
        // TODO if item == null
        if (item == null) {
            return;
        }
        Element e = ItemUtils.getAsXml(item);
        writeXml(e, response);
    }
    
    public void itemPut(HttpServletRequest request, HttpServletResponse response) throws Exception {
        logger.debug(getContent(request));
        Document d = XmlUtils.getNewDocument("success");
        Element root = d.getRootElement();
        root.addElement("refId").addText("FOOBAR-123");
        writeXml(d, response);      
    }
    
    public void spaceUsersGet(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String prefixCode = request.getParameter("prefixCode");
        Space space = jtrac.loadSpace(prefixCode);
        Document d = XmlUtils.getNewDocument("users");
        Element root = d.getRootElement();
        root.addAttribute("prefixCode", prefixCode);
        List<User> users = jtrac.findUsersForSpace(space.getId());
        for(User user : users) {
            root.addElement("user").addAttribute("loginName", user.getLoginName()).addText(user.getName());
        }
        writeXml(d, response);
    }
    
    public void itemSearchGet(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String queryString = request.getQueryString();
        logger.debug("parsing queryString: " + queryString);
        ValueMap map = new ValueMap();
        RequestUtils.decodeParameters(queryString, map);
        logger.debug("decoded: " + map);
        User user = (User) request.getAttribute("user");
        PageParameters params = new PageParameters(map);
        ItemSearch itemSearch = ItemUtils.getItemSearch(user, params, jtrac);        
        initXmlResponse(response);
        ItemUtils.writeAsXml(itemSearch, jtrac, response.getWriter());
    }
    
    public void itemAllGet(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // GOD mode!
        User user = (User) request.getAttribute("user");
        if(!user.isSuperUser()) {
            // TODO error code
            return;
        }
        initXmlResponse(response);
        ItemUtils.writeAsXml(jtrac, response.getWriter());
    }
    
}
```


Overlapping Code:
```
xtends AbstractMultiActionController {

/**
* custom MethodNameResolver is configured that checks the value of an expected
* paramter called "method" in the request and formats the value that may be
* in the form of "namespace.subnamespace.action" into "namespaceSubnamespaceAction"
* or more like a java method name
*/
public RestMultiActionController() {
setMethodNameResolver(new MethodNameResolver() {
public String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException {
String temp = request.getParameter("method");
if (temp == null) {
return null;
}
StringBuffer sb = new StringBuffer();
for(int i = 0; i < temp.length(); i++) {
char c = temp.charAt(i);
if (c == '.') {
i++;
c = temp.charAt(i);
sb.append(Character.toUpperCase(c));
} else {
sb.append(c);
}
}
return sb.toString();
}
});
}

/**
* override Spring template method as a crude interceptor
* here we are doing HTTP basic authentication TODO better security
*/
@Override
protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
if(!authenticate(request)) {
String title = "Basic realm=\"JTrac Remote API\"";
response.setHeader("WWW-Authenticate", title);
response.setStatus(401);
return null;
} else {
return super.handleRequestInternal(request, response);
}
}

private boolean authenticate(HttpServletRequest request) {
String authHeader = request.getHeader("Authorization");
logger.debug("auth header: " + authHeader);
if (authHeader == null) {
return false;
}
StringTokenizer st = new StringTokenizer(authHeader);
if (st.hasMoreTokens()) {
String basic = st.nextToken();
if (basic.equalsIgnoreCase("Basic")) {
String credentials = st.nextToken();
Base64 decoder = new Base64();
String userPass = new String(decoder.decode(cred
```
<Overlap Ratio: 0.972972972972973>

---

--- 89 --
Question ID: 489066975d59139b57dfd440f27f5e5586b2fca7_0
Original Code:
```
@Test(groups = { "UnitTests" })
public class CellDeepJobConfigMongoDBTest {

    @Test
    public void createTest() {

        MongoDeepJobConfig<Cells> cellDeepJobConfigMongoDB = new MongoDeepJobConfig(Cells.class);

        assertNotNull(cellDeepJobConfigMongoDB);

        assertEquals(cellDeepJobConfigMongoDB.getEntityClass(), Cells.class);

    }

}
```


Overlapping Code:
```
sts" })
public class CellDeepJobConfigMongoDBTest {
@Test
public void createTest() {
MongoDeepJobConfig<Cells> cellDeepJobConfigMongoDB = new MongoDeepJobConfig(Cells.class);
assertNotNull(cellDeepJobConfigMongoDB);
assertEquals(cellDeepJobConfigMong
```
<Overlap Ratio: 0.7987220447284346>

---

--- 90 --
Question ID: 1fc326900689a727dcb62b44559558f7f5a85d44_0
Original Code:
```
public class BytePropertySet extends PropertySet {
    private final static long serialVersionUID = 1;
	/**
	 * Constructor for BytePropertySet.
	 * @param name the name associated with this property set.
	 */
	public BytePropertySet(String name) {
		super(name, null);
	}

	/**
	 * @see PropertySet#getDataSize()
	 */
	@Override
    public int getDataSize() {
		return 1;
	}

	/**
	 * Stores a byte value at the given index.  Any value currently at that
	 * index will be replaced by the new value.
	 * @param index the index at which to store the byte value.
	 * @param value the byte value to store.
	 */
	public void putByte(long index, byte value) {
		PropertyPage page = getOrCreatePage(getPageID(index));
		int n = page.getSize();
		page.addByte(getPageOffset(index), value);
		numProperties += page.getSize() - n;
	}

	/**
	 * Retrieves the byte value stored at the given index.
	 * @param index the index at which to retrieve the byte value.
	 * @return byte the value stored at the given index.
	 * @throws NoValueException if there is no byte value stored at the index.
	 */
	public byte getByte(long index) throws NoValueException {
		PropertyPage page = getPage(getPageID(index));
		if (page != null) {
			return page.getByte(getPageOffset(index));
		}
		throw noValueException;
	}

	/* (non-Javadoc)
	 * @see ghidra.util.prop.PropertySet#moveIndex(long, long)
	 */
	@Override
    protected void moveIndex(long from, long to) {
		try {
			byte value = getByte(from);
			remove(from);
			putByte(to, value);
		}catch(NoValueException e) {}
	}

	/**
	 * saves the property at the given index to the given output stream.
	 */
	@Override
    protected void saveProperty(ObjectOutputStream oos, long index) throws IOException {
		try {
			oos.writeByte(getByte(index));
		}
        catch(NoValueException e) {
            throw new AssertException(e.getMessage());
        }
	}
	/**
	 * restores the property from the input stream to the given index.
	 */
	@Override
    protected void restoreProperty(ObjectInputStream ois, long index) throws IOException{
		putByte(index, ois.readByte());
	}

	/**
	 * 
	 * @see ghidra.util.prop.PropertySet#applyValue(PropertyVisitor, long)
	 */
	@Override
    public void applyValue(PropertyVisitor visitor, long addr) {
		throw new NotYetImplementedException();
//		try {
//			visitor.visit(getLong(addr));
//		}
//		catch(NoValueException e) {
//		}
	}

}
```


Overlapping Code:
```
c class BytePropertySet extends PropertySet {
private final static long serialVersionUID = 1;
/**
* Constructor for BytePropertySet.
* @param name the name associated with this property set.
*/
public BytePropertySet(String name) {
super(name, null);
}
/**
* @see PropertySet#getDataSize()
*/
@Override
public int getDataSize() {
return 1;
}
/**
* Stores a byte value at the given index. Any value currently at that
* index will be replaced by the new value.
* @param index the index at which to store the byte value.
* @param value the byte value to store.
*/
public void putByte(long index, byte value) {
PropertyPage page = getOrCreatePage(getPageID(index));
int n = page.getSize();
page.addByte(getPageOffset(index), value);
numProperties += page.getSize() - n;
}
/**
* Retrieves the byte value stored at the given index.
* @param index the index at which to retrieve the byte value.
* @return byte the value stored at the given index.
* @throws NoValueException if there is no byte value stored at the index.
*/
public byte getByte(long index) throws NoValueException {
PropertyPage page = getPage(getPageID(index));
if (page != null) {
return page.getByte(getPageOffset(index));
}
throw noValueException;
}
/* (non-Javadoc)
* @see ghidra.util.prop.PropertySet#moveIndex(long, long)
*/
@Override
protected void moveIndex(long from, long to) {
try {
byte value = getByte(from);
remove(from);
putByte(to, value);
}catch(NoValueException e) {}
}
/**
* saves the property at the given index to the given output stream.
*/
@Override
protected void saveProperty(ObjectOutputStream oos, long index) throws IOException {
try {
oos.writeByte(getByte(index));
}
catch(NoValueException e) {
throw new AssertException(e.getMessage());
}
}
/**
* restores the property from the input stream to the given index.
*/
@Override
protected void restoreProperty(ObjectInputStream ois, long index) throws IOException{
putByte(index, ois.readByte());
}
/**
* 
* @see ghidra.util.prop.PropertySet#applyValue(PropertyVisitor, long)
*/
@Override
public void applyValue(PropertyVisitor visitor, long addr) {
throw new NotYetImplementedException();
// try {
// visitor.visit(getLong(addr));
// }
// catch(NoValueException e
```
<Overlap Ratio: 0.9923319801533604>

---

--- 91 --
Question ID: c84ca92eed0925a17cc582d53b4cea88c352b903_0
Original Code:
```
public class StatusFilterViewHolder extends CheckboxFilterViewHolder<Integer, StatusGeocacheFilter> {

    private static final int OWN_FOUND = 1;
    private static final int DISABLED = 2;
    private static final int ARCHIVED = 3;

    public StatusFilterViewHolder() {
        super(new ValueGroupFilterAccessor<Integer, StatusGeocacheFilter>()
            .setSelectableValues(new Integer[]{OWN_FOUND, DISABLED, ARCHIVED})
            .setValueGetter(StatusFilterViewHolder::getFilterValues)
            .setValueSetter(StatusFilterViewHolder::setFilterValues)
            .setValueDisplayTextGetter(s -> LocalizationUtils.getString(s == ARCHIVED ? R.string.map_showc_archived : (s == OWN_FOUND ? R.string.map_showc_ownfound : R.string.map_showc_disabled)))
            .setValueDrawableGetter(s -> s == ARCHIVED ? R.drawable.ic_menu_archived : (s == OWN_FOUND ? R.drawable.ic_menu_myplaces : R.drawable.ic_menu_disabled))
            .setGeocacheValueGetter((f, c) -> getGeocacheValues(c)));
    }

    @NotNull
    private static Set<Integer> getGeocacheValues(final Geocache c) {
        final Set<Integer> set = new HashSet<>();
        if (c.isArchived()) {
            set.add(ARCHIVED);
        }
        if (c.isDisabled()) {
            set.add(DISABLED);
        }
        if (c.isFound() || c.getOwnerUserId().equals(Settings.getUserName())) {
            set.add(OWN_FOUND);
        }
        return set;
    }

    private static void setFilterValues(final StatusGeocacheFilter f, final Collection<Integer> s) {
        f.setShowOwnFound(s.contains(OWN_FOUND));
        f.setShowDisabled(s.contains(DISABLED));
        f.setShowArchived(s.contains(ARCHIVED));
    }

    @NotNull
    private static Collection<Integer> getFilterValues(final StatusGeocacheFilter f) {

            final Set<Integer> set = new HashSet<>();
            if (f.isShowArchived()) {
                set.add(ARCHIVED);
            }
            if (f.isShowOwnFound()) {
                set.add(OWN_FOUND);
            }
            if (f.isShowDisabled()) {
                set.add(DISABLED);
            }
            return set;
    }

}
```


Overlapping Code:
```
sFilterViewHolder extends CheckboxFilterViewHolder<Integer, StatusGeocacheFilter> {
private static final int OWN_FOUND = 1;
private static final int DISABLED = 2;
private static final int ARCHIVED = 3;
public StatusFilterViewHolder() {
super(new ValueGroupFilterAccessor<Integer, StatusGeocacheFilter>()
.setSelectableValues(new Integer[]{OWN_FOUND, DISABLED, ARCHIVED})
.setValueGetter(StatusFilterViewHolder::getFilterValues)
.setValueSetter(StatusFilterViewHolder::setFilterValues)
.setValueDisplayTextGetter(s -> LocalizationUtils.getString(s == ARCHIVED ? R.string.map_showc_archived : (s == OWN_FOUND ? R.string.map_showc_ownfound : R.string.map_showc_disabled)))
.setValueDrawableGetter(s -> s == ARCHIVED ? R.drawable.ic_menu_archived : (s == OWN_FOUND ? R.drawable.ic_menu_myplaces : R.drawable.ic_menu_disabled))
.setGeocacheValueGetter((f, c) -> getGeocacheValues(c)));
}
@NotNull
private static Set<Integer> getGeocacheValues(final Geocache c) {
final Set<Integer> set = new HashSet<>();
if (c.isArchived()) {
set.add(ARCHIVED);
}
if (c.isDisabled()) {
set.add(DISABLED);
}
if (c.isFound() || c.getOwnerUserId().equals(Settings.getUserName())) {
set.add(OWN_FOUND);
}
return set;
}
private static void setFilterValues(final StatusGeocacheFilter f, final Collection<Integer> s) {
f.setShowOwnFound(s.contains(OWN_FOUND));
f.setShowDisabled(s.contains(DISABLED));
f.setShowArchived(s.contains(ARCHIVED));
}
@NotNull
private static Collection<Integer> getFilterValues(final StatusGeocacheFilter f) {
final Set<Integer> set = new HashSet<>();
if (f.isShowArchived()) {
set.add(ARCHIVED);
}
if (f.isShowOwnFound()) {
set.add(OWN_FOUND);
}
if (f.isShowDisabled()) {
set.add(DISABLED);
}
return 
```
<Overlap Ratio: 0.984936268829664>

---

--- 92 --
Question ID: cdc194423e239fc7f925c4e4d08b2c2096099253_0
Original Code:
```
class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) { 
        List<String> res = new LinkedList<>();
        Set<String> set = new HashSet<>();
        int minlen = Integer.MAX_VALUE;
        
        //build dict
        for(String word : words){
            if(word.length()>0){
                set.add(word);
                minlen = Math.min(minlen, word.length());
            }
        }
        
        //check each word and add good ones to dict
        for(String word : words){
            if(canForm(word, 0, minlen, set)){
                res.add(word);
            }
        }
        return res;
    
    }
    
    //no need to remove and add current word in this setup
    private static boolean canForm(String word, int start, int offset, Set<String> set){
        for(int mid=start+offset; mid<=word.length()-offset;mid++){
            if(set.contains(word.substring(start,mid)) &&
              (set.contains(word.substring(mid)) || canForm(word, mid, offset, set))) {//backtrack
                return true;
                }
        }
        return false;
    }
}
```


Overlapping Code:
```
class Solution {
public List<String> findAllConcatenatedWordsInADict(String[] words) { 
List<String> res = new LinkedList<>();
Set<String> set = new HashSet<>();
int minlen = Integer.MAX_VALUE;

//build dict
for(String word : words){
if(word.length()>0){
set.add(word);
minlen = Math.min(minlen, word.length());
}
}

//check each word and add good ones to dict
for(String word : words){
if(canForm(word, 0, minlen, set)){
res.add(word);
}
}
return res;

}

//no need to remove and add current word in this setup
private static boolean canForm(String word, int start, int offset, Set<String> set){
for(int mid=start+offset; mid<=word.length()-offset;mid++){
if(set.contains(word.substring(start,mid)) &&
(set.contains(word.substring(mid)) || canForm(word, mid, offset, set))) {/
```
<Overlap Ratio: 0.9452554744525548>

---

--- 93 --
Question ID: 61c3c2959b3cdcafa1e3f989c8f8e35219894c70_0
Original Code:
```
@SuppressWarnings("serial")
public class AckRemoteApplicationEvent extends RemoteApplicationEvent {

	private final String ackId;

	private final String ackDestinationService;

	private Class<? extends RemoteApplicationEvent> event;

	@SuppressWarnings("unused")
	private AckRemoteApplicationEvent() {
		super();
		this.ackDestinationService = null;
		this.ackId = null;
		this.event = null;
	}

	public AckRemoteApplicationEvent(Object source, String originService, Destination destination,
			String ackDestinationService, String ackId, Class<? extends RemoteApplicationEvent> type) {
		super(source, originService, destination);
		this.ackDestinationService = ackDestinationService;
		this.ackId = ackId;
		this.event = type;
	}

	public String getAckId() {
		return this.ackId;
	}

	public String getAckDestinationService() {
		return this.ackDestinationService;
	}

	public Class<? extends RemoteApplicationEvent> getEvent() {
		return this.event;
	}

	/**
	 * Used by Jackson to set the remote class name of the event implementation. If the
	 * implementing class is unknown to this app, set the event to
	 * {@link UnknownRemoteApplicationEvent}.
	 * @param eventName the fq class name of the event implementation, not null
	 */
	@JsonProperty("event")
	@SuppressWarnings("unchecked")
	public void setEventName(String eventName) {
		try {
			this.event = (Class<? extends RemoteApplicationEvent>) Class.forName(eventName);
		}
		catch (ClassNotFoundException e) {
			this.event = UnknownRemoteApplicationEvent.class;
		}
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result + ((this.ackDestinationService == null) ? 0 : this.ackDestinationService.hashCode());
		result = prime * result + ((this.ackId == null) ? 0 : this.ackId.hashCode());
		result = prime * result + ((this.event == null) ? 0 : this.event.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!super.equals(obj)) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		AckRemoteApplicationEvent other = (AckRemoteApplicationEvent) obj;
		if (this.ackDestinationService == null) {
			if (other.ackDestinationService != null) {
				return false;
			}
		}
		else if (!this.ackDestinationService.equals(other.ackDestinationService)) {
			return false;
		}
		if (this.ackId == null) {
			if (other.ackId != null) {
				return false;
			}
		}
		else if (!this.ackId.equals(other.ackId)) {
			return false;
		}
		if (this.event == null) {
			if (other.event != null) {
				return false;
			}
		}
		else if (!this.event.equals(other.event)) {
			return false;
		}
		return true;
	}

}
```


Overlapping Code:
```
s("serial")
public class AckRemoteApplicationEvent extends RemoteApplicationEvent {
private final String ackId;
private final String ackDestinationService;
private Class<? extends RemoteApplicationEvent> event;
@SuppressWarnings("unused")
private AckRemoteApplicationEvent() {
super();
this.ackDestinationService = null;
this.ackId = null;
this.event = null;
}
public AckRemoteApplicationEvent(Object source, String originService, Destination destination,
String ackDestinationService, String ackId, Class<? extends RemoteApplicationEvent> type) {
super(source, originService, destination);
this.ackDestinationService = ackDestinationService;
this.ackId = ackId;
this.event = type;
}
public String getAckId() {
return this.ackId;
}
public String getAckDestinationService() {
return this.ackDestinationService;
}
public Class<? extends RemoteApplicationEvent> getEvent() {
return this.event;
}
/**
* Used by Jackson to set the remote class name of the event implementation. If the
* implementing class is unknown to this app, set the event to
* {@link UnknownRemoteApplicationEvent}.
* @param eventName the fq class name of the event implementation, not null
*/
@JsonProperty("event")
@SuppressWarnings("unchecked")
public void setEventName(String eventName) {
try {
this.event = (Class<? extends RemoteApplicationEvent>) Class.forName(eventName);
}
catch (ClassNotFoundException e) {
this.event = UnknownRemoteApplicationEvent.class;
}
}
@Override
public int hashCode() {
final int prime = 31;
int result = super.hashCode();
result = prime * result + ((this.ackDestinationService == null) ? 0 : this.ackDestinationService.hashCode());
result = prime * result + ((this.ackId == null) ? 0 : this.ackId.hashCode());
result = prime * result + ((this.event == null) ? 0 : this.event.hashCode());
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (!super.equals(obj)) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
AckRemoteApplicationEvent other = (AckRemoteApplicationEvent) obj;
if (this.ackDestinationService == null) {
if (other.ackDestinationService != null) {
return false;
}
}
else if (!this.ackDestinationService.equals(other.ackDestinationService)) {
return false;
}
if (this.ackId == null) {
if (other.ackId != null) {
ret
```
<Overlap Ratio: 0.9816474605207>

---

--- 94 --
Question ID: 832205708c121ac9bd47d0e83924afa467bc1da3_0
Original Code:
```
public class AssignmentBaseTest {

    protected StringUtils utils = spy(StringUtils.class);

    public void setUp() throws Exception {
        // Prevent runtime GWT.create() error at DesignerEditorConstants.INSTANCE
        GWTMockUtilities.disarm();
        // MockDesignerEditorConstants replaces DesignerEditorConstants.INSTANCE
        final Answer answer = invocation -> invocation.getMethod().getName();
        final DesignerEditorConstants designerEditorConstants = mock(DesignerEditorConstants.class,
                                                                     answer);
        setFinalStaticField(DesignerEditorConstants.class.getDeclaredField("INSTANCE"),
                            designerEditorConstants);

        // Mock StringUtils URL Encoding methods
         Mockito.when(utils.urlDecode(Mockito.any())).thenAnswer(invocation -> {
            Object[] args = invocation.getArguments();
            return urlDecode((String) args[0]);
        });
        Mockito.when(utils.urlEncode(Mockito.any())).thenAnswer(invocation -> {
            Object[] args = invocation.getArguments();
            return urlEncode((String) args[0]);
        });
        Assignment.setStringUtils(utils);
    }

    public void tearDown() {
        GWTMockUtilities.restore();
    }

    /**
     * Implementation of urlEncode for PowerMocked StringUtils
     * @param s
     * @return
     */
    public String urlEncode(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }

        try {
            return URLEncoder.encode(s,
                                     "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return s;
        }
    }

    /**
     * Implementation of urlDecode for PowerMocked StringUtils
     * @param s
     * @return
     */
    public String urlDecode(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }
        try {
            return URLDecoder.decode(s,
                                     "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return s;
        }
    }

    private void setFinalStaticField(Field field,
                                     Object newValue) throws Exception {
        field.setAccessible(true);
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field,
                              field.getModifiers() & ~Modifier.FINAL);
        field.set(null,
                  newValue);
    }
}
```


Overlapping Code:
```
ntBaseTest {
protected StringUtils utils = spy(StringUtils.class);
public void setUp() throws Exception {
// Prevent runtime GWT.create() error at DesignerEditorConstants.INSTANCE
GWTMockUtilities.disarm();
// MockDesignerEditorConstants replaces DesignerEditorConstants.INSTANCE
final Answer answer = invocation -> invocation.getMethod().getName();
final DesignerEditorConstants designerEditorConstants = mock(DesignerEditorConstants.class,
answer);
setFinalStaticField(DesignerEditorConstants.class.getDeclaredField("INSTANCE"),
designerEditorConstants);
// Mock StringUtils URL Encoding methods
Mockito.when(utils.urlDecode(Mockito.any())).thenAnswer(invocation -> {
Object[] args = invocation.getArguments();
return urlDecode((String) args[0]);
});
Mockito.when(utils.urlEncode(Mockito.any())).thenAnswer(invocation -> {
Object[] args = invocation.getArguments();
return urlEncode((String) args[0]);
});
Assignment.setStringUtils(utils);
}
public void tearDown() {
GWTMockUtilities.restore();
}
/**
* Implementation of urlEncode for PowerMocked StringUtils
* @param s
* @return
*/
public String urlEncode(String s) {
if (s == null || s.isEmpty()) {
return s;
}
try {
return URLEncoder.encode(s,
"UTF-8");
} catch (UnsupportedEncodingException e) {
return s;
}
}
/**
* Implementation of urlDecode for PowerMocked StringUtils
* @param s
* @return
*/
public String urlDecode(String s) {
if (s == null || s.isEmpty()) {
return s;
}
try {
return URLDecoder.decode(s,
"UTF-8");
} catch (UnsupportedEncodingException e) {
return s;
}
}
private void setFinalStaticField(Field field,
Object newValue) throws Exception {
field.setAccessible(true);
Field modifiersField = Field.class.getDeclaredField("modifiers");
modifiersField.setAccessible(true);
modifiersField.setInt(field,
field.getModifiers() & ~Modifier.
```
<Overlap Ratio: 0.9879649890590809>

---

--- 95 --
Question ID: 239868afa7e8dfbabe9951c709d2f08c97880278_0
Original Code:
```
public class GFGAnagramSubstringSearch {
    
    public List<Integer> getAllPosition(String mainString, String pat){
        Map<Character,Integer> patternCharCountMap =  new TreeMap<>();
        Map<Character,Integer> mainCharCountMap =  new TreeMap<>();
        
        List<Integer> output = Lists.newArrayList();
        
        int patLength = pat.length();
        int mainStringLength = mainString.length();
        
        for(int count = 0; count < patLength; count++){
            patternCharCountMap.put(pat.charAt(count),patternCharCountMap.getOrDefault(pat.charAt(count),0)+1);
            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);
        }
        
        for(int count = patLength; count<mainStringLength; count++){
            if(compare(patternCharCountMap,mainCharCountMap)){
                output.add(count-patLength);
            }
            
            mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);
            mainCharCountMap.put(mainString.charAt(count-patLength),mainCharCountMap.get(mainString.charAt(count-patLength))-1);
        }
        
        if(compare(patternCharCountMap,mainCharCountMap)){
            output.add(mainStringLength-patLength);
        }
        
        return output;
    }
    
    
    public boolean compare(Map<Character,Integer> pattern, Map<Character,Integer> actual){
        
        for(Character key : pattern.keySet()){
            if(!actual.containsKey(key) || pattern.get(key) != actual.get(key)){
                return false;  
            }
        }
        
        return true;
    }
    
    
}
```


Overlapping Code:
```
ass GFGAnagramSubstringSearch {

public List<Integer> getAllPosition(String mainString, String pat){
Map<Character,Integer> patternCharCountMap = new TreeMap<>();
Map<Character,Integer> mainCharCountMap = new TreeMap<>();

List<Integer> output = Lists.newArrayList();

int patLength = pat.length();
int mainStringLength = mainString.length();

for(int count = 0; count < patLength; count++){
patternCharCountMap.put(pat.charAt(count),patternCharCountMap.getOrDefault(pat.charAt(count),0)+1);
mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);
}

for(int count = patLength; count<mainStringLength; count++){
if(compare(patternCharCountMap,mainCharCountMap)){
output.add(count-patLength);
}

mainCharCountMap.put(mainString.charAt(count),mainCharCountMap.getOrDefault(mainString.charAt(count),0)+1);
mainCharCountMap.put(mainString.charAt(count-patLength),mainCharCountMap.get(mainString.charAt(count-patLength))-1);
}

if(compare(patternCharCountMap,mainCharCountMap)){
output.add(mainStringLength-patLength);
}

return output;
}


public boolean compare(Map<Character,Integer> pattern, Map<Character,Integer> actual){

for(Character key : pattern.keySet()){
if(!actual.containsKey(key) || pattern.get(key) != actual.get(key)){
return false; 
}
```
<Overlap Ratio: 0.976709241172051>

---

--- 96 --
Question ID: d8642d783d805ae418aec30e5673ceea837328e1_0
Original Code:
```
public class ArrayOfDoubledPairs {
    public static void main(String[] args) {

        ArrayOfDoubledPairs arrayOfDoubledPairs = new ArrayOfDoubledPairs();
       // arrayOfDoubledPairs.canReorderDoubled(new int[]{4, -2, 2, -4});
        arrayOfDoubledPairs.canReorderDoubled(new int[]{-33,0});
    }

    public boolean canReorderDoubled(int[] arr) {

        TreeMap<Integer, Integer> map = new TreeMap<>();
        for (int num : arr) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        Arrays.sort(arr);
        for (int num : arr) {
            if(!map.containsKey(num)) continue;
            int doubleNum = num * 2;
            int halfNum=Integer.MAX_VALUE;
            if(num%2==0)
                halfNum=num/2;

            if (map.containsKey(doubleNum)) {
                map.put(num, map.get(num) - 1);
                if (map.get(num) == 0)
                    map.remove(num);

                if(!map.containsKey(doubleNum)) return false;
                map.put(doubleNum, map.get(doubleNum) - 1);
                if (map.get(doubleNum) == 0)
                    map.remove(doubleNum);

            } else if(map.containsKey(halfNum)){
                if(halfNum!= Integer.MAX_VALUE){
                    map.put(num, map.get(num) - 1);
                    if (map.get(num) == 0)
                        map.remove(num);
                    if(!map.containsKey(halfNum)) return false;

                    map.put(halfNum, map.get(halfNum) - 1);
                    if (map.get(halfNum) == 0)
                        map.remove(halfNum);
                }
            }
        }
        if (map.isEmpty()) return true;
        return false;
    }
}
```


Overlapping Code:
```
s ArrayOfDoubledPairs {
public static void main(String[] args) {
ArrayOfDoubledPairs arrayOfDoubledPairs = new ArrayOfDoubledPairs();
// arrayOfDoubledPairs.canReorderDoubled(new int[]{4, -2, 2, -4});
arrayOfDoubledPairs.canReorderDoubled(new int[]{-33,0});
}
public boolean canReorderDoubled(int[] arr) {
TreeMap<Integer, Integer> map = new TreeMap<>();
for (int num : arr) {
map.put(num, map.getOrDefault(num, 0) + 1);
}
Arrays.sort(arr);
for (int num : arr) {
if(!map.containsKey(num)) continue;
int doubleNum = num * 2;
int halfNum=Integer.MAX_VALUE;
if(num%2==0)
halfNum=num/2;
if (map.containsKey(doubleNum)) {
map.put(num, map.get(num) - 1);
if (map.get(num) == 0)
map.remove(num);
if(!map.containsKey(doubleNum)) return false;
map.put(doubleNum, map.get(doubleNum) - 1);
if (map.get(doubleNum) == 0)
map.remove(doubleNum);
} else if(map.containsKey(halfNum)){
if(halfNum!= Integer.MAX_VALUE){
map.put(num, map.get(num) - 1);
if (map.get(num) == 0)
map.remove(num);
if(!map.containsKey(halfNum)) return false;
map.put(halfNum, map.get(halfNum) - 1);
if (map.get(halfNum) == 0)
map.remove(halfNum);
}
}
}
if (map.isEmpty()) ret
```
<Overlap Ratio: 0.9675491033304867>

---

--- 97 --
Question ID: 5c50e368b7b1ec2a3efb1ffbd26ee59359f6033f_0
Original Code:
```
public class W3CMappingGenerator extends MappingGenerator {
	
	public W3CMappingGenerator(ConnectedDB database) {
		super(database);
		setGenerateLabelBridges(false);
		setHandleLinkTables(false);
		setGenerateDefinitionLabels(false);
		setServeVocabulary(false);
		setSkipForeignKeyTargetColumns(false);
	}

	@Override
	protected void writeEntityIdentifier(RelationName tableName, List<Attribute> identifierColumns) {
		String uriPattern = this.instanceNamespaceURI + encodeTableName(tableName);
		Iterator<Attribute> it = identifierColumns.iterator();
		int i = 0;
		while (it.hasNext()) {
			uriPattern += i == 0 ? "/" : ";";
			i++;
			
			Attribute column = it.next();
			uriPattern += encodeColumnName(column) + "=@@" + column.qualifiedName();
			if (!database.columnType(column).isIRISafe()) {
				uriPattern += "|encode";
			}
			uriPattern += "@@";
		}
		this.out.println("\td2rq:uriPattern \"" + uriPattern + "\";");
	}
	
	@Override
	protected void writePseudoEntityIdentifier(RelationName tableName) {
		List<Attribute> usedColumns = filter(schema.listColumns(tableName), true, "pseudo identifier column");
		out.print("\td2rq:bNodeIdColumns \"");
		Iterator<Attribute> it = usedColumns.iterator();
		while (it.hasNext()) {
			Attribute column = it.next();
			out.print(column.qualifiedName());
			if (it.hasNext()) {
				out.print(",");
			}
		}
		out.println("\";");
	}
	
	@Override
	protected String vocabularyIRITurtle(RelationName table) {
		return "<" + encodeTableName(table) + ">";
	}
	
	@Override
	protected String vocabularyIRITurtle(Attribute attribute) {
		return "<" + encodeTableName(attribute.relationName()) + "#"
		+ encodeColumnName(attribute) + ">";
	}
	
	@Override
	protected String vocabularyIRITurtle(List<Attribute> attributes) {
		StringBuffer result = new StringBuffer();
		result.append("<");
		result.append(encodeTableName(attributes.get(0).relationName()));
		int i = 1;
		for (Attribute column: attributes) {
			String attributeName = encodeColumnName(column);
			if (i == 1) {
				result.append("#ref-");
				result.append(attributeName);
			} else {
				result.append(";" + attributeName);
			}
			i++;
		}
		result.append(">");
		return result.toString();
	}

	private String encodeTableName(RelationName tableName) {
		return (tableName.schemaName() == null ? "" : IRIEncoder.encode(tableName.schemaName()) + '/')
			+ IRIEncoder.encode(tableName.tableName());
	}

	private String encodeColumnName(Attribute column) {
		return IRIEncoder.encode(column.attributeName());
	}
}
```


Overlapping Code:
```
ublic class W3CMappingGenerator extends MappingGenerator {

public W3CMappingGenerator(ConnectedDB database) {
super(database);
setGenerateLabelBridges(false);
setHandleLinkTables(false);
setGenerateDefinitionLabels(false);
setServeVocabulary(false);
setSkipForeignKeyTargetColumns(false);
}
@Override
protected void writeEntityIdentifier(RelationName tableName, List<Attribute> identifierColumns) {
String uriPattern = this.instanceNamespaceURI + encodeTableName(tableName);
Iterator<Attribute> it = identifierColumns.iterator();
int i = 0;
while (it.hasNext()) {
uriPattern += i == 0 ? "/" : ";";
i++;

Attribute column = it.next();
uriPattern += encodeColumnName(column) + "=@@" + column.qualifiedName();
if (!database.columnType(column).isIRISafe()) {
uriPattern += "|encode";
}
uriPattern += "@@";
}
this.out.println("\td2rq:uriPattern \"" + uriPattern + "\";");
}

@Override
protected void writePseudoEntityIdentifier(RelationName tableName) {
List<Attribute> usedColumns = filter(schema.listColumns(tableName), true, "pseudo identifier column");
out.print("\td2rq:bNodeIdColumns \"");
Iterator<Attribute> it = usedColumns.iterator();
while (it.hasNext()) {
Attribute column = it.next();
out.print(column.qualifiedName());
if (it.hasNext()) {
out.print(",");
}
}
out.println("\";");
}

@Override
protected String vocabularyIRITurtle(RelationName table) {
return "<" + encodeTableName(table) + ">";
}

@Override
protected String vocabularyIRITurtle(Attribute attribute) {
return "<" + encodeTableName(attribute.relationName()) + "#"
+ encodeColumnName(attribute) + ">";
}

@Override
protected String vocabularyIRITurtle(List<Attribute> attributes) {
StringBuffer result = new StringBuffer();
result.append("<");
result.append(encodeTableName(attributes.get(0).relationName()));
int i = 1;
for (Attribute column: attributes) {
String attributeName = encodeColumnName(column);
if (i == 1) {
result.append("#ref-");
result.append(attributeName);
} else {
result.append(";" + attributeName);
}
i++;
}
result.append(">");
return result.toString();
}
private String encodeTableName(RelationName tableName) {
return (tableName.schemaName() == null ? "" : IRIEncoder.encode(tableName.schemaName()) + '/')
+ IRIEncoder.encode(tableName.tableName());
}
private String encodeColumnName(Attribute column) {
re
```
<Overlap Ratio: 0.9858672376873662>

---

--- 98 --
Question ID: 5d42bfbd525a96e3872e60902d366d8b52535d51_0
Original Code:
```
class RegistryDataControllerTest extends BaseControllerTest {

    private static final String REGISTRY_TYPE_NAME = RegistryTestEntity.class.getName();

    @PersistenceContext
    private EntityManager entityManager;

    @Autowired
    private PlatformTransactionManager platformTransactionManager;

    @Test
    void shouldBulkListRegistry() throws Exception {
        // given
        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));

        String requestUrl = fullUrl("list-bulk");
        ListBulkRegistryRequest request = createBulkListRegistryRequest(REGISTRY_TYPE_NAME, "name%");

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.['" + REGISTRY_TYPE_NAME + "'].content").isNotEmpty());
    }

    @Test
    void shouldListRegistry() throws Exception {
        // given
        executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));

        String requestUrl = fullUrl("list");
        ListRegistryRequest request = createListRegistryRequest(REGISTRY_TYPE_NAME, "name%");

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.numberOfElements").value(5));
    }

    @Test
    void shouldCreateRegistryEntity() throws Exception {
        // given
        String requestUrl = fullUrl("create");
        String entityName = "name for creating";
        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, entityName);

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value(entityName));
    }

    @Test
    void shouldReturnErrorWhenCreateInputDataIsNotValid() throws Exception {
        // given
        String requestUrl = fullUrl("create");
        CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, null);

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isBadRequest());
    }

    @Test
    void shouldUpdateRegistryEntity() throws Exception {
        // given
        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));

        String requestUrl = fullUrl("update");
        String entityName = "name for creating update";
        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value(entityName));
    }

    @Test
    void shouldReturnErrorWhenUpdatingWithInvalidData() throws Exception {
        // given
        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));

        String requestUrl = fullUrl("update");
        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), null);

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isBadRequest());
    }

    @Test
    void shouldNotFailUpdatingRegistryEntityWithAssociation() throws Exception {
        // given
        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityWithParent(entityManager));

        String requestUrl = fullUrl("update");
        String entityName = "name for update";
        UpdateRegistryRequest request = updateRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, registryTestEntity.getId(), entityName);

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value(entityName));
    }

    @Test
    void shouldDeleteRegistryEntity() throws Exception {
        // given
        RegistryTestEntity registryTestEntity = executeInTransaction(platformTransactionManager, () -> createRegistryTestEntity(entityManager));

        String requestUrl = fullUrl("delete");
        DeleteRegistryRequest request = createDeleteRegistryRequest(RegistryTestEntity.class.getName(), registryTestEntity.getId());

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(registryTestEntity.getId()));
    }

    @Test
    void shouldDeleteRegistryEntityWithEmbeddedId() throws Exception {
        // given
        RegistryTestEmbeddedUserGroup registryTestEmbeddedUserGroup = executeInTransaction(platformTransactionManager, () -> createRegistryTestEmbeddedUserGroup(entityManager));

        String requestUrl = fullUrl("delete");
        DeleteRegistryRequest request = createDeleteEmbeddedUserGroupRequest(registryTestEmbeddedUserGroup.getUserGroupId());

        // when
        ResultActions result = performPostRequest(requestUrl, request);

        // then
        result.andExpect(status().isOk());
    }

    @AfterEach
    void cleanup() {
        executeInTransaction(platformTransactionManager, () -> entityManager.createQuery("delete from " + RegistryTestEntity.class.getName()).executeUpdate());
    }

    private String fullUrl(String path) {
        return String.format("/nrich/registry/data/%s", path);
    }
}
```


Overlapping Code:
```
ataControllerTest extends BaseControllerTest {
private static final String REGISTRY_TYPE_NAME = RegistryTestEntity.class.getName();
@PersistenceContext
private EntityManager entityManager;
@Autowired
private PlatformTransactionManager platformTransactionManager;
@Test
void shouldBulkListRegistry() throws Exception {
// given
executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));
String requestUrl = fullUrl("list-bulk");
ListBulkRegistryRequest request = createBulkListRegistryRequest(REGISTRY_TYPE_NAME, "name%");
// when
ResultActions result = performPostRequest(requestUrl, request);
// then
result.andExpect(status().isOk())
.andExpect(jsonPath("$.['" + REGISTRY_TYPE_NAME + "'].content").isNotEmpty());
}
@Test
void shouldListRegistry() throws Exception {
// given
executeInTransaction(platformTransactionManager, () -> createRegistryTestEntityList(entityManager));
String requestUrl = fullUrl("list");
ListRegistryRequest request = createListRegistryRequest(REGISTRY_TYPE_NAME, "name%");
// when
ResultActions result = performPostRequest(requestUrl, request);
// then
result.andExpect(status().isOk())
.andExpect(jsonPath("$.numberOfElements").value(5));
}
@Test
void shouldCreateRegistryEntity() throws Exception {
// given
String requestUrl = fullUrl("create");
String entityName = "name for creating";
CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, entityName);
// when
ResultActions result = performPostRequest(requestUrl, request);
// then
result.andExpect(status().isOk())
.andExpect(jsonPath("$.name").value(entityName));
}
@Test
void shouldReturnErrorWhenCreateInputDataIsNotValid() throws Exception {
// given
String requestUrl = fullUrl("create");
CreateRegistryRequest request = createRegistryRequest(objectMapper, REGISTRY_TYPE_NAME, null);
// when
ResultActions result = performPostRequest(requestUrl, request);
// then
result.andExpect(status().isBadRequest());
}
@Test
void shouldUpdateRegistryEntity() throws Exception {
// given
RegistryTestEntity registryTestE
```
<Overlap Ratio: 0.9852731591448931>

---

--- 99 --
Question ID: 437d1e78154dc2f307c2f7732b10fabb7fd2e481_0
Original Code:
```
public class WizardDialog extends JDialog {

  private static final long serialVersionUID = 1L;

  private WizardController wizardController;

  private final JPanel contentPanel = new JPanel();
  private JButton nextButton;
  private JButton backButton;

  /**
   * Create the dialog.
   * 
   * @param controller
   */
  public WizardDialog(WizardController controller) {
    this.wizardController = controller;
    controller.addPropertyChangeListener(new WizardControllerPropertyChangeHandler());
    controller.addCompletionListener(new WizardCompletionHandler());

    setBounds(100, 100, 450, 300);
    getContentPane().setLayout(new BorderLayout());
    contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
    getContentPane().add(contentPanel, BorderLayout.CENTER);
    contentPanel.setLayout(new BorderLayout(0, 0));
    {
      JPanel buttonPane = new JPanel();
      buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
      getContentPane().add(buttonPane, BorderLayout.SOUTH);
      {
        JButton cancelButton = new JButton("Cancel");
        cancelButton.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            wizardController.handleCancelButton();
          }
        });
        cancelButton.setActionCommand("Cancel");
        buttonPane.add(cancelButton);
      }
      {
        backButton = new JButton("Back");
        backButton.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            wizardController.handleBackButton();
          }
        });
        buttonPane.add(backButton);
      }
      {
        nextButton = new JButton("Next");
        nextButton.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            wizardController.handleNextButton();
          }
        });
        nextButton.setActionCommand("OK");
        buttonPane.add(nextButton);
        getRootPane().setDefaultButton(nextButton);
      }
    }
    initDataBindings();
    updateControlPanel();
  }

  protected void initDataBindings() {
    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty = BeanProperty.create("nextButtonEnabled");
    BeanProperty<JButton, Boolean> jButtonBeanProperty = BeanProperty.create("enabled");
    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding = Bindings.createAutoBinding(
        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty,
        nextButton, jButtonBeanProperty);
    autoBinding.bind();
    //
    BeanProperty<WizardController, Boolean> wizardControllerBeanProperty_1 = BeanProperty.create("backButtonEnabled");
    AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding_1 = Bindings.createAutoBinding(
        UpdateStrategy.READ, wizardController, wizardControllerBeanProperty_1,
        backButton, jButtonBeanProperty);
    autoBinding_1.bind();
  }

  private void updateControlPanel() {
    contentPanel.removeAll();
    WizardPanelController controller = wizardController.getCurrentController();
    if (controller != null) {
      JPanel panel = controller.getPanel();
      if (panel != null) {
        contentPanel.add(panel, BorderLayout.CENTER);
        contentPanel.revalidate();
      }
    }
  }

  private class WizardControllerPropertyChangeHandler implements
      PropertyChangeListener {

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      String name = evt.getPropertyName();
      if (name.equals(WizardController.PROPERTY_CURRENT_PANEL)) {
        updateControlPanel();
      }
    }
  }

  private class WizardCompletionHandler implements WizardCompletionListener {

    @Override
    public void handleCanceled() {
      handleFinished();
    }

    @Override
    public void handleFinished() {
      WizardDialog.this.setVisible(false);
    }
  }
}
```


Overlapping Code:
```
Dialog extends JDialog {
private static final long serialVersionUID = 1L;
private WizardController wizardController;
private final JPanel contentPanel = new JPanel();
private JButton nextButton;
private JButton backButton;
/**
* Create the dialog.
* 
* @param controller
*/
public WizardDialog(WizardController controller) {
this.wizardController = controller;
controller.addPropertyChangeListener(new WizardControllerPropertyChangeHandler());
controller.addCompletionListener(new WizardCompletionHandler());
setBounds(100, 100, 450, 300);
getContentPane().setLayout(new BorderLayout());
contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
getContentPane().add(contentPanel, BorderLayout.CENTER);
contentPanel.setLayout(new BorderLayout(0, 0));
{
JPanel buttonPane = new JPanel();
buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
getContentPane().add(buttonPane, BorderLayout.SOUTH);
{
JButton cancelButton = new JButton("Cancel");
cancelButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
wizardController.handleCancelButton();
}
});
cancelButton.setActionCommand("Cancel");
buttonPane.add(cancelButton);
}
{
backButton = new JButton("Back");
backButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
wizardController.handleBackButton();
}
});
buttonPane.add(backButton);
}
{
nextButton = new JButton("Next");
nextButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent e) {
wizardController.handleNextButton();
}
});
nextButton.setActionCommand("OK");
buttonPane.add(nextButton);
getRootPane().setDefaultButton(nextButton);
}
}
initDataBindings();
updateControlPanel();
}
protected void initDataBindings() {
BeanProperty<WizardController, Boolean> wizardControllerBeanProperty = BeanProperty.create("nextButtonEnabled");
BeanProperty<JButton, Boolean> jButtonBeanProperty = BeanProperty.create("enabled");
AutoBinding<WizardController, Boolean, JButton, Boolean> autoBinding = Bindings.createAutoBinding(
UpdateStrategy.READ, wizardController, wiz
```
<Overlap Ratio: 0.9773264052905054>

---

--- 100 --
Question ID: 289166cba6ee2d5a5cc69e03e720f78c269f9212_0
Original Code:
```
public class GraphQlFieldsHelper {
    public static String INPUT = "input";
    public static String FILTER = "filter";

    public static TypedValueMap getInputMap(DataFetchingEnvironment environment) {
        return new TypedValueMap(environment.getArgument(INPUT));
    }

    public static TypedValueMap getFilterMap(DataFetchingEnvironment environment) {
        Map<String, Object> filterMap = environment.getArgument(FILTER);

        if (filterMap == null) {
            return new TypedValueMap();
        }

        return new TypedValueMap(filterMap);
    }
}
```


Overlapping Code:
```
hQlFieldsHelper {
public static String INPUT = "input";
public static String FILTER = "filter";
public static TypedValueMap getInputMap(DataFetchingEnvironment environment) {
return new TypedValueMap(environment.getArgument(INPUT));
}
public static TypedValueMap getFilterMap(DataFetchingEnvironment environment) {
Map<String, Object> filterMap = environment.getArgument(FILTER);
if (filterMap == null) {
return new TypedValueMap();
}
return new Type
```
<Overlap Ratio: 0.9146341463414634>

---

--- 101 --
Question ID: 17b5b32b9ae059fcf6615900d7af00c708add168_0
Original Code:
```
public class ImportExportUtils {
  private static final String ONTOPIA_RDBMS_URI_PREFIX = "x-ontopia:tm-rdbms:";
  private static final String XTM_EXTENSION = ".xtm";
  private static final String TMX_EXTENSION = ".tmx";
  private static final String LTM_EXTENSION = ".ltm";
  private static final String CTM_EXTENSION = ".ctm";

  private static Set<ImportExportServiceIF> services;
  
  static {
    loadServices();
  }

  private static void loadServices() {
    try {
      services = ServiceUtils.loadServices(ImportExportServiceIF.class);
    } catch (IOException ex) {
      LoggerFactory.getLogger(ImportExportUtils.class).error("Could not load import-export services", ex);
    }
  }
  
  /**
   * Returns the loaded ImportExportServiceIF services.
   * @return the loaded ImportExportServiceIF services.
   */
  @SuppressWarnings("unchecked")
  public static Set<ImportExportServiceIF> getServices() {
    return UnmodifiableSet.unmodifiableSet(services);
  }

  /**
   * PUBLIC: Given a file reference to a topic map, returns a topic
   * map reader of the right class. Uses the file extension to
   * determine what reader to create. Supports '.xtm', and '.ltm'.
   * 
   * @since 2.0
   */
  public static TopicMapReaderIF getReader (File file) throws IOException {
    return getReader(URIUtils.toURL(file));
  }

  /**
   * PUBLIC: Given the file name or URL of a topic map, returns a
   * topic map reader of the right class. Uses the file extension to
   * determine what reader to create. Supports '.xtm', and '.ltm'.
   */
  public static TopicMapReaderIF getReader (String filename_or_url) {
    try {
      return getReader(StreamUtils.getResource(filename_or_url));
    } catch (IOException ioe) {
      throw new OntopiaRuntimeException(ioe);
    }
  }

  /**
   * PUBLIC: Given a locator referring to a topic map, returns a topic
   * map reader of the right class. Uses the file extension to
   * determine what reader to create. Supports '.xtm', '.tmx', and
   * '.ltm'.
   * 
   * @since 2.0
   */
  public static TopicMapReaderIF getReader (URL url) {
    String address = url.toString();
    try {
      if (address.startsWith (ONTOPIA_RDBMS_URI_PREFIX))
        return new RDBMSTopicMapReader (getTopicMapId (address));
      else if (address.endsWith (XTM_EXTENSION))
        return new XTMTopicMapReader (url);
      else if (address.endsWith (LTM_EXTENSION))
        return new LTMTopicMapReader (url);
      else if (address.endsWith (TMX_EXTENSION))
        return new TMXMLReader (url);
      else if (address.endsWith (".xml"))
        return new TMXMLReader(url); 
      else if (address.endsWith (CTM_EXTENSION))
        return new CTMTopicMapReader(url);
      else {
        for (ImportExportServiceIF service : services) {
          if (service.canRead(url)) {
            return service.getReader(url);
          }
        }
        // fallback
        return new XTMTopicMapReader (url);
      }
    } catch (MalformedURLException mufe) {
      throw new OntopiaRuntimeException(mufe);
    }
  }

  /**
   * PUBLIC: Given the file for a topicmap, returns a topicmap
   * writer of the right class. Uses the file extension to determine
   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix
   * is unknown, the default writer is a XTM writer.
   */
  public static TopicMapWriterIF getWriter (File tmfile) throws IOException {
    return getWriter(tmfile, null);
  }

  /**
   * PUBLIC: Given the file for a topicmap, returns a topicmap
   * writer of the right class. Uses the file extension to determine
   * what writer to create.  Supports '.xtm' and '.tmx'. If the suffix
   * is unknown, the default writer is a XTM writer.
   */
  public static TopicMapWriterIF getWriter (File tmfile, String encoding) throws IOException {
    String name = tmfile.getName();
    if (name.endsWith(LTM_EXTENSION)) {
      return new LTMTopicMapWriter(tmfile, encoding);
    } else if (name.endsWith(TMX_EXTENSION)) {
      return new TMXMLWriter(tmfile, encoding);
    } else if (name.endsWith(".xtm1")) {
      return new XTMTopicMapWriter(tmfile, encoding);
    } else {
      for (ImportExportServiceIF service : services) {
        if (service.canWrite(tmfile.toURI().toURL())) {
          return service.getWriter(new FileOutputStream(tmfile));
        }
      }
      // fallback
      return new XTM2TopicMapWriter(tmfile);
    }
  }

  /**
   * INTERNAL: Gets the numeric topic map id from an RDBMS URI or a
   * simple topic map id reference. Examples: x-ontopia:tm-rdbms:123,
   * x-ontopia:tm-rdbms:M123, 123 and M123.
   */
  public static long getTopicMapId (String address) {
    int offset = 0;
    if (address.startsWith("M"))
      offset = 1;
    else if (address.startsWith(ONTOPIA_RDBMS_URI_PREFIX)) {
      // Syntax: x-ontopia:tm-rdbms:12345
      offset = ONTOPIA_RDBMS_URI_PREFIX.length ();
      
      // Ignore M suffix on topic map id
      if (address.charAt (offset) == 'M')
        offset = offset + 1;
    }
    
    try {
      return Long.parseLong (address.substring (offset));
    } catch (NumberFormatException e) {
      throw new OntopiaRuntimeException ("'" + address
          + " is not a valid rdbms topic map URI.");
    }
  }
}
```


Overlapping Code:
```
portUtils {
private static final String ONTOPIA_RDBMS_URI_PREFIX = "x-ontopia:tm-rdbms:";
private static final String XTM_EXTENSION = ".xtm";
private static final String TMX_EXTENSION = ".tmx";
private static final String LTM_EXTENSION = ".ltm";
private static final String CTM_EXTENSION = ".ctm";
private static Set<ImportExportServiceIF> services;

static {
loadServices();
}
private static void loadServices() {
try {
services = ServiceUtils.loadServices(ImportExportServiceIF.class);
} catch (IOException ex) {
LoggerFactory.getLogger(ImportExportUtils.class).error("Could not load import-export services", ex);
}
}

/**
* Returns the loaded ImportExportServiceIF services.
* @return the loaded ImportExportServiceIF services.
*/
@SuppressWarnings("unchecked")
public static Set<ImportExportServiceIF> getServices() {
return UnmodifiableSet.unmodifiableSet(services);
}
/**
* PUBLIC: Given a file reference to a topic map, returns a topic
* map reader of the right class. Uses the file extension to
* determine what reader to create. Supports '.xtm', and '.ltm'.
* 
* @since 2.0
*/
public static TopicMapReaderIF getReader (File file) throws IOException {
return getReader(URIUtils.toURL(file));
}
/**
* PUBLIC: Given the file name or URL of a topic map, returns a
* topic map reader of the right class. Uses the file extension to
* determine what reader to create. Supports '.xtm', and '.ltm'.
*/
public static TopicMapReaderIF getReader (String filename_or_url) {
try {
return getReader(StreamUtils.getResource(filename_or_url));
} catch (IOException ioe) {
throw new OntopiaRuntimeException(ioe);
}
}
/**
* PUBLIC: Given a locator referring to a topic map, returns a topic
* map reader of the right class. Uses the file extension to
* determine what reader to create. Supports '.xtm', '.tmx', and
* '.ltm'.
* 
* @since 2.0
*/
public static TopicMapReaderIF getReader (URL url) {
String address = url.toString();
try {
if (address.startsWith (ONTOPIA_RDBMS_URI_PREFIX))
return new RDBMSTopicMapReader (getTopicMapId (address));
else if (address.endsWith (XTM_EXTENSION))
return new XTMTopicMapReader (url);
else if (address.endsWith (LTM_EXTENSION))
return new LTMTopicMapReader (url);
else if (address.endsWith (T
```
<Overlap Ratio: 0.9814323607427056>

---

--- 102 --
Question ID: 2e5e147d5189cf6082af9d03cbbe31c46a1d667a_0
Original Code:
```
class MojaApl1 extends Frame {

    MojaApl1(String naslov) {
        super(naslov);
        setLayout(new FlowLayout());
        add(new Button("OK"));
        add(new Button("Ponovo"));
        add(new Button("Prekini"));
    }

    public static void main(String args[]) {
        MojaApl1 apl = new MojaApl1("Kako izgledam?");
        apl.resize(300,300);
        apl.setLocation(400,400);
        apl.show();
          for (int i=1;i<100000000; i++)Math.random();
        apl.hide();      
        System.exit(0);
        
    }
   
}
```


Overlapping Code:
```
1 extends Frame {
MojaApl1(String naslov) {
super(naslov);
setLayout(new FlowLayout());
add(new Button("OK"));
add(new Button("Ponovo"));
add(new Button("Prekini"));
}
public static void main(String args[]) {
MojaApl1 apl = new MojaApl1("Kako izgledam?");
apl.resize(300,300);
apl.setLocation(400,400);
apl.show();
for (int i=1;i<100000000; i++)Math.
```
<Overlap Ratio: 0.85995085995086>

---

--- 103 --
Question ID: a5f95092cb09f26d3e2eb488bd93eba068b2f130_0
Original Code:
```
public class KEPRuleItem implements TextRulerRuleItem {

  private boolean isStarWildCard = false;

  private boolean isReluctant = false;

  private Type type;

  private TextRulerAnnotation annotation;

  private int min = 1;

  private int max = 1;

  private List<List<KEPRuleItemCondition>> conditions = new ArrayList<List<KEPRuleItemCondition>>();

  public KEPRuleItem(KEPRuleItem copyFrom) {
    super();
    this.annotation = copyFrom.annotation;
    this.isStarWildCard = copyFrom.isStarWildCard;
    this.type = copyFrom.type;
    this.conditions = new ArrayList<List<KEPRuleItemCondition>>();
    for (List<KEPRuleItemCondition> cList : copyFrom.conditions) {
      this.conditions.add(new ArrayList<KEPRuleItemCondition>(cList));
    }
    this.isReluctant = copyFrom.isReluctant;
    this.min = copyFrom.min;
    this.max = copyFrom.max;
  }

  public KEPRuleItem(Type type) {
    super();
    this.type = type;
  }

  public KEPRuleItem(TextRulerAnnotation a) {
    super();
    this.type = a.getType();
    this.annotation = a;
  }

  public KEPRuleItem(AnnotationFS afs) {
    super();
    this.annotation = new TextRulerAnnotation(afs);
    this.type = this.annotation.getType();
  }

  public KEPRuleItem(Type type, String regExpString) {
    super();
    this.type = type;
    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();
    list.add(new KEPRuleItemCondition(regExpString));
    this.conditions.add(list);
  }

  public KEPRuleItem() {
    this.type = null;
  }

  public KEPRuleItem copy() {
    return new KEPRuleItem(this);
  }

  public String getStringForRuleString(TextRulerRule rule, MLRuleItemType type,
          int numberInPattern, int patternSize, int numberInRule, int ruleSize, int slotIndex) {

    String mark = "";
    KEPRule kepRule = (KEPRule) rule;
    boolean isMarkingItem = type == MLRuleItemType.FILLER && numberInPattern == 0;
    String cStr = "";

    String anchor = (this.type == null ? "ANY" : this.type.getShortName())
            + (isStarWildCard ? "*" : "")
            + ((min == 1 && max == 1) ? "" : ("[" + min + "," + max + "]"))
            + (isReluctant ? "?" : "") + ((isMarkingItem || !this.conditions.isEmpty()) ? "{" : "");

    if (!this.conditions.isEmpty() && !this.conditions.get(0).isEmpty()) {
      for (List<KEPRuleItemCondition> cList : this.conditions) {
        if (cList.size() == 1) {
          cStr += cList.get(0) + ", ";
        } else {
          cStr += "OR(";
          for (KEPRuleItemCondition condition : cList) {
            cStr += condition + ", ";
          }
          cStr = cStr.substring(0, cStr.lastIndexOf(","));
          cStr += "), ";
        }
      }
      cStr = cStr.substring(0, cStr.lastIndexOf(","));
    }

    if (isMarkingItem) {
      if (kepRule.isCorrectionRule())
        mark += "->UNMARK(" + kepRule.getMarkName(slotIndex);
      else
        mark += "->MARKONCE(" + kepRule.getMarkName(slotIndex);
      if (patternSize > 1)
        mark += ", " + (numberInRule + 1) + ", " + (numberInRule + patternSize);
      mark += ")";
    }
    return anchor + cStr + mark + ((isMarkingItem || !this.conditions.isEmpty()) ? "}" : "");
  }

  @Override
  public String toString() {
    return getStringForRuleString(null, null, 0, 0, 0, 0, 0);
  }

  public boolean isStarWildCard() {
    return isStarWildCard;
  }

  public KEPRuleItem setStarWildCard(boolean isStarWildCard) {
    this.isStarWildCard = isStarWildCard;
    if (isStarWildCard) {
      this.min = 1;
      this.max = 1;
    }
    return this;
  }

  public Type getType() {
    return type;
  }

  public void setType(Type type) {
    this.type = type;
  }

  public boolean equals(TextRulerRuleItem o) {
    return o.toString().equals(this.toString());
  }

  public int getBegin() {
    return this.annotation.getBegin();
  }

  public int getEnd() {
    return this.annotation.getEnd();
  }

  public int getMin() {
    return min;
  }

  public KEPRuleItem setMin(int min) {
    this.min = min;
    if (min > this.max)
      this.max = min;
    isStarWildCard = false;
    return this;
  }

  public int getMax() {
    return max;
  }

  public KEPRuleItem setMax(int max) {
    this.max = max;
    if (max < this.min)
      this.min = max;
    isStarWildCard = false;
    return this;
  }

  public boolean isReluctant() {
    return isReluctant;
  }

  public KEPRuleItem setReluctant(boolean isReluctant) {
    this.isReluctant = isReluctant;
    return this;
  }

  public KEPRuleItem addAndCondition(KEPRuleItemCondition condition) {
    List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();
    list.add(condition);
    this.conditions.add(list);
    return this;
  }

  public List<List<KEPRuleItemCondition>> getConditions() {
    return this.conditions;
  }

  public void setAnnotation(AnnotationFS afs) {
    this.annotation = new TextRulerAnnotation(afs);
    this.type = this.annotation.getType();
  }

  public KEPRuleItem setConditions(List<List<KEPRuleItemCondition>> conditions) {
    this.conditions = conditions;
    return this;
  }

  public KEPRuleItem addConditions(List<KEPRuleItemCondition> toMerge) {
    this.conditions.add(toMerge);
    return this;
  }

  public boolean containsAndCondition(Type type2) {
    for (List<KEPRuleItemCondition> list : this.conditions) {
      if (list.size() == 1)
        for (KEPRuleItemCondition c : list) {
          if (c.equals(type2))
            return true;
        }
    }
    return false;
  }
}
```


Overlapping Code:
```
leItem {
private boolean isStarWildCard = false;
private boolean isReluctant = false;
private Type type;
private TextRulerAnnotation annotation;
private int min = 1;
private int max = 1;
private List<List<KEPRuleItemCondition>> conditions = new ArrayList<List<KEPRuleItemCondition>>();
public KEPRuleItem(KEPRuleItem copyFrom) {
super();
this.annotation = copyFrom.annotation;
this.isStarWildCard = copyFrom.isStarWildCard;
this.type = copyFrom.type;
this.conditions = new ArrayList<List<KEPRuleItemCondition>>();
for (List<KEPRuleItemCondition> cList : copyFrom.conditions) {
this.conditions.add(new ArrayList<KEPRuleItemCondition>(cList));
}
this.isReluctant = copyFrom.isReluctant;
this.min = copyFrom.min;
this.max = copyFrom.max;
}
public KEPRuleItem(Type type) {
super();
this.type = type;
}
public KEPRuleItem(TextRulerAnnotation a) {
super();
this.type = a.getType();
this.annotation = a;
}
public KEPRuleItem(AnnotationFS afs) {
super();
this.annotation = new TextRulerAnnotation(afs);
this.type = this.annotation.getType();
}
public KEPRuleItem(Type type, String regExpString) {
super();
this.type = type;
List<KEPRuleItemCondition> list = new ArrayList<KEPRuleItemCondition>();
list.add(new KEPRuleItemCondition(regExpString));
this.conditions.add(list);
}
public KEPRuleItem() {
this.type = null;
}
public KEPRuleItem copy() {
return new KEPRuleItem(this);
}
public String getStringForRuleString(TextRulerRule rule, MLRuleItemType type,
int numberInPattern, int patternSize, int numberInRule, int ruleSize, int slotIndex) {
String mark = "";
KEPRule kepRule = (KEPRule) rule;
boolean isMarkingItem = type == MLRuleItemType.FILLER && numberInPattern == 0;
String cStr = "";
String anchor = (this.type == null ? "ANY" : this.type.getShortName())
+ (isStarWildCard ? "*" : "")
+ ((min == 1 && max == 1) ? "" : ("[" + min + "," + max + "]"))
+ (isReluctant ? "?" : "") + ((isMarkingItem || !this.conditions.isEmpty()) ? "{" : "");
if (!this.conditions.isEmpty() && !this.conditions.get(0).isEmpty()) {
for (List<KEPRuleItemCondition> cList : this.conditions) {
if (cList.size() == 1) {
cStr += cList.get(0) + ", ";
} else {
cStr += "OR(";
for
```
<Overlap Ratio: 0.9732910819375283>

---

--- 104 --
Question ID: b6dfb9f5d1cd6359d28f7f100320c5ff9bf04764_0
Original Code:
```
public class Alerts extends BaseBlock
{
	private int m_nFileFrequency;
	/**
	 * List of rules
	 */
	private ArrayList<AlertRule> m_oRules = new ArrayList();

	/**
	 * Bounding box of the study area
	 */
	private int[] m_nStudyArea;

	private FilenameFormatter m_oFormatter;

	/**
	 * Array of obs types needed to evaluate the rules for this block
	 */
	private int[] m_nObsTypes;

	/**
	 * Length the area arrays need to be based off of the rules for this block
	 */
	private int m_nArrayLength;

	/**
	 * Reusable array to initial values for a new area
	 */
	private long[] m_lInitialValues;

	/**
	 * Header for the csv file
	 */
	public static final String g_sHEADER = "ObsType,Source,ObjId,ObsTime1,ObsTime2,TimeRecv,Lat1,Lon1,Lat2,Lon2,Elev,Value,Conf\n";


	/**
	 * Comparator used to compare long arrays that represent areas in this
	 * block. Compares first by lon1, then lon2, then lat1, then lat2.
	 */
	public static final Comparator<long[]> COMPBYAREA = (long[] o1, long[] o2) -> 
	{
		int nReturn = Long.compare(o1[2], o2[2]); // compare by lon1
		if (nReturn == 0)
		{
			nReturn = Long.compare(o1[3], o2[3]); // then lon2
			if (nReturn == 0)
			{
				nReturn = Long.compare(o1[0], o2[0]); // then lat1
				if (nReturn == 0)
					nReturn = Long.compare(o1[1], o2[1]); // then lat2
			}
		}

		return nReturn;
	};


	/**
	 * Reads in the rules and creates the necessary objects from the config
	 * file.
	 *
	 * @return true if no errors occur, false otherwise
	 * @throws Exception
	 */
	@Override
	public boolean start() throws Exception
	{
		String[] sRules = m_oConfig.getStringArray("rules", null);
		int nArrayPosition = 5;
		for (String sRule : sRules) // for each configured rule create the object
		{
			String[] sConditions = m_oConfig.getStringArray(sRule, null);
			if (sConditions.length % 4 != 1 || sConditions.length == 0) // rules have this struct {alert type, list of conditions} (conditions have 4 elements each)
			{
				m_oLogger.error("Incorrect length for rule: " + sRule);
				continue;
			}
			AlertRule oAdd = new AlertRule(sConditions, nArrayPosition);
			m_oRules.add(oAdd);
			nArrayPosition += (oAdd.m_oAlgorithm.size() * 2);
		}
		m_nArrayLength = nArrayPosition;
		m_lInitialValues = new long[m_nArrayLength - 5];
		for (int i = 0; i < m_lInitialValues.length;)
		{
			m_lInitialValues[i++] = Long.MAX_VALUE;
			m_lInitialValues[i++] = Long.MIN_VALUE;
		}
		return true;
	}


	/**
	 * Resets are configurable variables
	 */
	@Override
	public void reset()
	{
		m_nFileFrequency = m_oConfig.getInt("freq", 86400000);
		m_oFormatter = new FilenameFormatter(m_oConfig.getString("format", ""));
		String[] sObsTypes = m_oConfig.getStringArray("obs", null);
		m_nObsTypes = new int[sObsTypes.length];
		for (int i = 0; i < sObsTypes.length; i++)
			m_nObsTypes[i] = Integer.valueOf(sObsTypes[i], 36);
		String[] sBox = m_oConfig.getStringArray("box", "");
		m_nStudyArea = new int[4];

		m_nStudyArea[0] = Integer.MAX_VALUE;
		m_nStudyArea[1] = Integer.MIN_VALUE;
		m_nStudyArea[2] = Integer.MAX_VALUE;
		m_nStudyArea[3] = Integer.MIN_VALUE;
		for (int i = 0; i < sBox.length;)
		{
			int nLon = Integer.parseInt(sBox[i++]);
			int nLat = Integer.parseInt(sBox[i++]);

			if (nLon < m_nStudyArea[2])
				m_nStudyArea[2] = nLon;

			if (nLon > m_nStudyArea[3])
				m_nStudyArea[3] = nLon;

			if (nLat < m_nStudyArea[0])
				m_nStudyArea[0] = nLat;

			if (nLat > m_nStudyArea[1])
				m_nStudyArea[1] = nLat;
		}
	}


	/**
	 * Processes Notifications received from other blocks.
	 *
	 * @param oNotification the received Notification
	 */
	@Override
	public void process(String[] sMessage)
	{
		if (sMessage[MESSAGE].compareTo("new data") == 0)
		{
			String sStore = sMessage[FROM];
			long lStartTime = Long.parseLong(sMessage[2]);
			long lEndTime = Long.parseLong(sMessage[3]);
			int[] nObsTypes = new int[sMessage.length - 4];
			int nIndex = 0;
			for (int i = 4; i < sMessage.length; i++)
				nObsTypes[nIndex++] = Integer.parseInt(sMessage[i]);
			createAlerts(sStore, nObsTypes, lStartTime, lEndTime);
		}
	}


	/**
	 * Ran when a notification of new data is sent from a data Store. This
	 * function checks alert rules for the current forecasts in the study area.
	 * We use a long array for each area that could have an alert. The format of
	 * the arrays is: [lat1, lat2, lon1, lon2, objId, (pairs of start and end
	 * times for each condition for each rule)]
	 */
	public void createAlerts(String sStore, int[] nObsTypes, long lStartTime, long lEndTime)
	{
		try
		{
			SegmentShps oShps = (SegmentShps)Directory.getInstance().lookup("SegmentShps");
			BaseBlock oStore = (BaseBlock)Directory.getInstance().lookup(sStore);
			ArrayList<Obs> oAlerts = new ArrayList();
			ArrayList<long[]> oAreas = new ArrayList();
			long[] lSearch = new long[6];

			for (int j = 0; j < nObsTypes.length; j++) // for each obs type
			{
				boolean bCreateAlerts = false;
				for (int nCreateObsType : m_nObsTypes)
				{
					if (nCreateObsType == nObsTypes[j])
					{
						bCreateAlerts = true;
						break;
					}
				}
				if (!bCreateAlerts)
					continue;
				
				ImrcpObsResultSet oData = (ImrcpObsResultSet)oStore.getData(nObsTypes[j], lStartTime, lEndTime, m_nStudyArea[0], m_nStudyArea[1], m_nStudyArea[2], m_nStudyArea[3], System.currentTimeMillis()); // get Obs
				for (Obs oObs : oData)
				{
					if (Util.isSegment(oObs.m_nObjId))
					{
						Segment oSegment = oShps.getLinkById(oObs.m_nObjId);
						if (oSegment == null || !oSegment.m_sType.equals("H")) // skip segments that are not highways
							continue;
					}

					for (AlertRule oRule : m_oRules) // go through all the rules once, setting when each condition was met
					{
						for (int nCondIndex = 0; nCondIndex < oRule.m_oAlgorithm.size(); nCondIndex++)
						{
							AlertCondition oCond = oRule.m_oAlgorithm.get(nCondIndex);
							if (oObs.m_nObsTypeId != oCond.m_nObsType) // not the correct obs type
								continue;
							if (!oCond.evaluate(oObs.m_dValue)) // does not fall within the range of the condition
								continue;

							lSearch[0] = oObs.m_nLat1; // lat1
							lSearch[1] = oObs.m_nLat2; // lat2
							lSearch[2] = oObs.m_nLon1; // lon1
							lSearch[3] = oObs.m_nLon2; // lon2
							if (lSearch[1] == Integer.MIN_VALUE) // point observations
								lSearch[1] = lSearch[0];
							if (lSearch[3] == Integer.MIN_VALUE)
								lSearch[3] = lSearch[2];
							lSearch[4] = oObs.m_lObsTime1; // obstime1
							lSearch[5] = oObs.m_lObsTime2; // obstime2

							int nIndex = Collections.binarySearch(oAreas, lSearch, COMPBYAREA); // search if the an array for the area has been made yet
							if (nIndex < 0)
							{
								nIndex = ~nIndex;
								long[] lTemp = new long[m_nArrayLength];
								System.arraycopy(lSearch, 0, lTemp, 0, 4);
								System.arraycopy(m_lInitialValues, 0, lTemp, 5, m_lInitialValues.length); // initialize all the condition timestamps
								lTemp[4] = oObs.m_nObjId; // objid
								oAreas.add(nIndex, lTemp);
							}

							for (int i = 0; i < oAreas.size(); i++)
							{
								long[] lArea = oAreas.get(i);
								if (lArea[1] >= lSearch[0] && lArea[0] <= lSearch[1] && lArea[3] >= lSearch[2] && lArea[2] <= lSearch[3]) // check if the current area intersects the areas in the list
								{
									int nAreaCond = oRule.m_nArrayPosition + (nCondIndex * 2);
									if (lArea[nAreaCond] > lSearch[4]) // check if the endtime is later than the current endtime
										lArea[nAreaCond] = lSearch[4]; // if so use the earlier endtime
									++nAreaCond;
									if (lArea[nAreaCond] < lSearch[5]) // check if the start time is earlier than the current start time
										lArea[nAreaCond] = lSearch[5]; // if so use the later start time
								}
							}
						}
					}
				}
			}

			for (AlertRule oRule : m_oRules) // evaluate all the rules for each area
			{
				for (long[] lArea : oAreas)
				{
					Obs oObs = oRule.evaluateRuleForArea(lArea, lStartTime);
					if (oObs != null)
						oAlerts.add(oObs);
				}
			}
			long lFileStartTime = (lStartTime / m_nFileFrequency) * m_nFileFrequency;
			long lFileEndTime = lFileStartTime + m_nFileFrequency * 2;
			String sFilename = m_oFormatter.format(lFileStartTime, lFileStartTime, lFileEndTime);
			new File(sFilename.substring(0, sFilename.lastIndexOf("/"))).mkdirs();
			try (BufferedWriter oOut = new BufferedWriter(new FileWriter(sFilename, true))) // write the alert file
			{
				if (new File(sFilename).length() == 0)
					oOut.write(g_sHEADER);
				for (Obs oAlert : oAlerts)
					oAlert.writeCsv(oOut);
			}

			notify("file download", sFilename);
		}
		catch (Exception oException)
		{
			m_oLogger.error(oException, oException);
		}
	}
}
```


Overlapping Code:
```
ock
{
private int m_nFileFrequency;
/**
* List of rules
*/
private ArrayList<AlertRule> m_oRules = new ArrayList();
/**
* Bounding box of the study area
*/
private int[] m_nStudyArea;
private FilenameFormatter m_oFormatter;
/**
* Array of obs types needed to evaluate the rules for this block
*/
private int[] m_nObsTypes;
/**
* Length the area arrays need to be based off of the rules for this block
*/
private int m_nArrayLength;
/**
* Reusable array to initial values for a new area
*/
private long[] m_lInitialValues;
/**
* Header for the csv file
*/
public static final String g_sHEADER = "ObsType,Source,ObjId,ObsTime1,ObsTime2,TimeRecv,Lat1,Lon1,Lat2,Lon2,Elev,Value,Conf\n";
/**
* Comparator used to compare long arrays that represent areas in this
* block. Compares first by lon1, then lon2, then lat1, then lat2.
*/
public static final Comparator<long[]> COMPBYAREA = (long[] o1, long[] o2) -> 
{
int nReturn = Long.compare(o1[2], o2[2]); // compare by lon1
if (nReturn == 0)
{
nReturn = Long.compare(o1[3], o2[3]); // then lon2
if (nReturn == 0)
{
nReturn = Long.compare(o1[0], o2[0]); // then lat1
if (nReturn == 0)
nReturn = Long.compare(o1[1], o2[1]); // then lat2
}
}
return nReturn;
};
/**
* Reads in the rules and creates the necessary objects from the config
* file.
*
* @return true if no errors occur, false otherwise
* @throws Exception
*/
@Override
public boolean start() throws Exception
{
String[] sRules = m_oConfig.getStringArray("rules", null);
int nArrayPosition = 5;
for (String sRule : sRules) // for each configured rule create the object
{
String[] sConditions = m_oConfig.getStringArray(sRule, null);
if (sConditions.length % 4 != 1 || sConditions.length == 0) // rules have this struct {alert type, list of conditions} (conditions have 4 elements each)
{
m_oLogger.error("Incorrect length for rule: " + sRule);
continue;
}
AlertRule oAdd = new AlertRule(sConditions, nArrayPosition);
m_oRules.add(oAdd);
nArrayPosition += (oAdd.m_oAlgorithm.size() * 2);
}
m_nArrayLength = nArrayPosition;
m_lInitialValues = new long[m_nArrayLength - 5];
for (int i = 0; i < m_lInitialValues.length;)
{
m_lInitialValues[i++] = Long.MAX_VALUE;
m_lInitialValues[i++] = Long.MIN_VALUE;
}
return true;
}
/**
* Resets are configurable var
```
<Overlap Ratio: 0.9689922480620154>

---

--- 105 --
Question ID: 6de71c59202d774e3e87ef910384b8fb289cb435_0
Original Code:
```
public class PermissionsDetailDialogFragment extends BasePermissionsDialogFragment
{
  @Nullable
  public static DialogFragment show(@NonNull FragmentActivity activity, int requestCode)
  {
    DialogFragment dialog = BasePermissionsDialogFragment.show(activity, requestCode,
                                       PermissionsDetailDialogFragment.class);
    if (dialog != null)
      dialog.setCancelable(true);
    return dialog;
  }

  @Nullable
  public static DialogFragment find(@NonNull FragmentActivity activity)
  {
    final FragmentManager fm = activity.getSupportFragmentManager();
    if (fm.isDestroyed())
      return null;

    Fragment f = fm.findFragmentByTag(PermissionsDetailDialogFragment.class.getName());
    return (DialogFragment) f;
  }

  @NonNull
  @Override
  public Dialog onCreateDialog(Bundle savedInstanceState)
  {
    Dialog res = super.onCreateDialog(savedInstanceState);
    RecyclerView permissions = (RecyclerView) res.findViewById(R.id.rv__permissions);
    permissions.setLayoutManager(new LinearLayoutManager(getContext(),
                                                         LinearLayoutManager.VERTICAL, false));
    permissions.setAdapter(new PermissionsAdapter());
    TextView acceptBtn = res.findViewById(R.id.accept_btn);
    acceptBtn.setText(R.string.continue_download);
    TextView declineBtn = res.findViewById(R.id.decline_btn);
    declineBtn.setText(R.string.back);
    return res;
  }

  @LayoutRes
  @Override
  protected int getLayoutRes()
  {
    return R.layout.fragment_detail_permissions;
  }

  @IdRes
  @Override
  protected int getFirstActionButton()
  {
    return R.id.decline_btn;
  }

  @Override
  protected void onFirstActionClick()
  {
    dismiss();
  }

  @IdRes
  @Override
  protected int getContinueActionButton()
  {
    return R.id.accept_btn;
  }
}
```


Overlapping Code:
```
ass PermissionsDetailDialogFragment extends BasePermissionsDialogFragment
{
@Nullable
public static DialogFragment show(@NonNull FragmentActivity activity, int requestCode)
{
DialogFragment dialog = BasePermissionsDialogFragment.show(activity, requestCode,
PermissionsDetailDialogFragment.class);
if (dialog != null)
dialog.setCancelable(true);
return dialog;
}
@Nullable
public static DialogFragment find(@NonNull FragmentActivity activity)
{
final FragmentManager fm = activity.getSupportFragmentManager();
if (fm.isDestroyed())
return null;
Fragment f = fm.findFragmentByTag(PermissionsDetailDialogFragment.class.getName());
return (DialogFragment) f;
}
@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState)
{
Dialog res = super.onCreateDialog(savedInstanceState);
RecyclerView permissions = (RecyclerView) res.findViewById(R.id.rv__permissions);
permissions.setLayoutManager(new LinearLayoutManager(getContext(),
LinearLayoutManager.VERTICAL, false));
permissions.setAdapter(new PermissionsAdapter());
TextView acceptBtn = res.findViewById(R.id.accept_btn);
acceptBtn.setText(R.string.continue_download);
TextView declineBtn = res.findViewById(R.id.decline_btn);
declineBtn.setText(R.string.back);
return res;
}
@LayoutRes
@Override
protected int getLayoutRes()
{
return R.layout.fragment_detail_permissions;
}
@IdRes
@Override
protected int getFirstActionButton()
{
return R.id.decline_btn;
}
@Override
protected void onFirstActionClick()
{
dismiss();
}
@IdRes
@Override
protected int getContinueActionButton()
{
return R.id
```
<Overlap Ratio: 0.9841269841269841>

---

--- 106 --
Question ID: ab320bfa25b7bdbb6227e772c5c776d1b1d1bc82_0
Original Code:
```
public class DumpDatabaseAction extends Action implements Parcelable {
    private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;
    public static final String DUMP_NAME = "db_copy.db";
    private static final int BUFFER_SIZE = 16384;

    /**
     * Copy the database to external storage
     */
    public static void dumpDatabase() {
        final DumpDatabaseAction action = new DumpDatabaseAction();
        action.start();
    }

    private DumpDatabaseAction() {
    }

    @Override
    protected Object executeAction() {
        final Context context = Factory.get().getApplicationContext();
        final String dbName = DatabaseHelper.DATABASE_NAME;
        BufferedOutputStream bos = null;
        BufferedInputStream bis = null;

        long originalSize = 0;
        final File inFile = context.getDatabasePath(dbName);
        if (inFile.exists() && inFile.isFile()) {
            originalSize = inFile.length();
        }
        final File outFile = DebugUtils.getDebugFile(DUMP_NAME, true);
        if (outFile != null) {
            int totalBytes = 0;
            try {
                bos = new BufferedOutputStream(new FileOutputStream(outFile));
                bis = new BufferedInputStream(new FileInputStream(inFile));

                final byte[] buffer = new byte[BUFFER_SIZE];
                int bytesRead;
                while ((bytesRead = bis.read(buffer)) > 0) {
                    bos.write(buffer, 0, bytesRead);
                    totalBytes += bytesRead;
                }
            } catch (final IOException e) {
                LogUtil.w(TAG, "Exception copying the database;"
                        + " destination may not be complete.", e);
            } finally {
                if (bos != null) {
                    try {
                        bos.close();
                    } catch (final IOException e) {
                        // Nothing to do
                    }
                }

                if (bis != null) {
                    try {
                        bis.close();
                    } catch (final IOException e) {
                        // Nothing to do
                    }
                }
                DebugUtils.ensureReadable(outFile);
                LogUtil.i(TAG, "Dump complete; orig size: " + originalSize +
                        ", copy size: " + totalBytes);
            }
        }
        return null;
    }

    private DumpDatabaseAction(final Parcel in) {
        super(in);
    }

    public static final Parcelable.Creator<DumpDatabaseAction> CREATOR
            = new Parcelable.Creator<DumpDatabaseAction>() {
        @Override
        public DumpDatabaseAction createFromParcel(final Parcel in) {
            return new DumpDatabaseAction(in);
        }

        @Override
        public DumpDatabaseAction[] newArray(final int size) {
            return new DumpDatabaseAction[size];
        }
    };

    @Override
    public void writeToParcel(final Parcel parcel, final int flags) {
        writeActionToParcel(parcel, flags);
    }
}
```


Overlapping Code:
```
lic class DumpDatabaseAction extends Action implements Parcelable {
private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;
public static final String DUMP_NAME = "db_copy.db";
private static final int BUFFER_SIZE = 16384;
/**
* Copy the database to external storage
*/
public static void dumpDatabase() {
final DumpDatabaseAction action = new DumpDatabaseAction();
action.start();
}
private DumpDatabaseAction() {
}
@Override
protected Object executeAction() {
final Context context = Factory.get().getApplicationContext();
final String dbName = DatabaseHelper.DATABASE_NAME;
BufferedOutputStream bos = null;
BufferedInputStream bis = null;
long originalSize = 0;
final File inFile = context.getDatabasePath(dbName);
if (inFile.exists() && inFile.isFile()) {
originalSize = inFile.length();
}
final File outFile = DebugUtils.getDebugFile(DUMP_NAME, true);
if (outFile != null) {
int totalBytes = 0;
try {
bos = new BufferedOutputStream(new FileOutputStream(outFile));
bis = new BufferedInputStream(new FileInputStream(inFile));
final byte[] buffer = new byte[BUFFER_SIZE];
int bytesRead;
while ((bytesRead = bis.read(buffer)) > 0) {
bos.write(buffer, 0, bytesRead);
totalBytes += bytesRead;
}
} catch (final IOException e) {
LogUtil.w(TAG, "Exception copying the database;"
+ " destination may not be complete.", e);
} finally {
if (bos != null) {
try {
bos.close();
} catch (final IOException e) {
// Nothing to do
}
}
if (bis != null) {
try {
bis.close();
} catch (final IOException e) {
// Nothing to do
}
}
DebugUtils.ensureReadable(outFile);
LogUtil.i(TAG, "Dump complete; orig size: " + originalSize +
", copy size: " + totalBytes);
}
}
return null;
}
private DumpDatabaseAction(final P
```
<Overlap Ratio: 0.9855072463768116>

---

--- 107 --
Question ID: ca79ef9e7f06b653ccde96919f39f8fdc51afbd9_0
Original Code:
```
@Configuration
@ConditionalOnWebApplication(type = Type.ANY)
@AutoConfigureBefore(InMemoryUserDetailsAutoConfiguration.class)
@AutoConfigureAfter(LdaptiveAutoConfiguration.class)
@ConditionalOnClass({
    ConnectionFactory.class,
    LdaptiveOperations.class
})
@ConditionalOnProperty(
    prefix = "bremersee.ldaptive",
    name = {"enabled", "authentication-enabled"},
    havingValue = "true")
@EnableConfigurationProperties(LdaptiveProperties.class)
@Slf4j
public class LdaptiveUserDetailsAutoConfiguration {

  private final UserDetailsProperties properties;

  private final LdaptiveOperations ldaptiveOperations;

  /**
   * Instantiates a new ldaptive user details auto configuration.
   *
   * @param properties the properties
   * @param ldaptiveOperationsProvider the ldaptive operations provider
   */
  public LdaptiveUserDetailsAutoConfiguration(
      LdaptiveProperties properties,
      ObjectProvider<LdaptiveOperations> ldaptiveOperationsProvider) {
    this.properties = properties.getUserDetails();
    this.ldaptiveOperations = ldaptiveOperationsProvider.getIfAvailable();
    Assert.notNull(this.ldaptiveOperations, "Ldap operations must not be present.");
  }

  /**
   * Init.
   */
  @EventListener(ApplicationReadyEvent.class)
  public void init() {
    log.info("\n"
            + "*********************************************************************************\n"
            + "* {}\n"
            + "*********************************************************************************\n"
            + "* properties = {}\n"
            + "*********************************************************************************",
        ClassUtils.getUserClass(getClass()).getSimpleName(),
        properties);
    Assert.hasText(properties.getUserBaseDn(), "User base dn must be present.");
    Assert.hasText(properties.getUserFindOneFilter(), "User find one filter must be present.");
  }

  /**
   * Ldaptive user details service.
   *
   * @return the ldaptive user details service
   */
  @ConditionalOnWebApplication(type = Type.SERVLET)
  @ConditionalOnMissingBean(value = {UserDetailsService.class})
  @Bean
  public LdaptiveUserDetailsService ldaptiveUserDetailsService() {
    return new LdaptiveUserDetailsService(
        ldaptiveOperations,
        properties.getUserBaseDn(),
        properties.getUserFindOneFilter(),
        properties.getUserFindOneSearchScope(),
        properties.getUserAccountControlAttributeName(),
        properties.getAuthorities(),
        properties.getAuthorityAttributeName(),
        properties.isAuthorityDn(),
        properties.getAuthorityMap(),
        properties.getAuthorityPrefix());
  }

  /**
   * Reactive ldaptive user details service.
   *
   * @param reactiveLdaptiveOperationsProvider the reactive ldaptive operations provider
   * @return the reactive ldaptive user details service
   */
  @ConditionalOnWebApplication(type = Type.REACTIVE)
  @ConditionalOnMissingBean(value = {ReactiveUserDetailsService.class})
  @Bean
  public ReactiveLdaptiveUserDetailsService reactiveLdaptiveUserDetailsService(
      ObjectProvider<ReactiveLdaptiveOperations> reactiveLdaptiveOperationsProvider) {
    ReactiveLdaptiveOperations reactiveLdaptiveOperations = reactiveLdaptiveOperationsProvider.getIfAvailable();
    Assert.notNull(reactiveLdaptiveOperations, "Reactive ldap operations must not be present.");
    return new ReactiveLdaptiveUserDetailsService(
        reactiveLdaptiveOperations,
        properties.getUserBaseDn(),
        properties.getUserFindOneFilter(),
        properties.getUserFindOneSearchScope(),
        properties.getUserAccountControlAttributeName(),
        properties.getAuthorities(),
        properties.getAuthorityAttributeName(),
        properties.isAuthorityDn(),
        properties.getAuthorityMap(),
        properties.getAuthorityPrefix());
  }

  /**
   * Ldaptive password matcher.
   *
   * @return the ldaptive password matcher
   */
  @ConditionalOnMissingBean(value = {PasswordEncoder.class})
  @Bean
  public LdaptivePasswordMatcher passwordEncoder() {
    LdaptivePasswordMatcher matcher = new LdaptivePasswordMatcher(
        ldaptiveOperations,
        properties.getUserBaseDn(),
        properties.getUserFindOneFilter());
    matcher.setUserPasswordAttributeName(properties.getUserAccountControlAttributeName());
    matcher.setUserFindOneSearchScope(properties.getUserFindOneSearchScope());
    matcher.setUserPasswordAttributeName(properties.getUserPasswordAttributeName());
    matcher.setDelegate(new LdaptivePasswordEncoder(
        properties.getUserPasswordLabel(),
        properties.getUserPasswordAlgorithm()));
    return matcher;
  }

}
```


Overlapping Code:
```
@Configuration
@ConditionalOnWebApplication(type = Type.ANY)
@AutoConfigureBefore(InMemoryUserDetailsAutoConfiguration.class)
@AutoConfigureAfter(LdaptiveAutoConfiguration.class)
@ConditionalOnClass({
ConnectionFactory.class,
LdaptiveOperations.class
})
@ConditionalOnProperty(
prefix = "bremersee.ldaptive",
name = {"enabled", "authentication-enabled"},
havingValue = "true")
@EnableConfigurationProperties(LdaptiveProperties.class)
@Slf4j
public class LdaptiveUserDetailsAutoConfiguration {
private final UserDetailsProperties properties;
private final LdaptiveOperations ldaptiveOperations;
/**
* Instantiates a new ldaptive user details auto configuration.
*
* @param properties the properties
* @param ldaptiveOperationsProvider the ldaptive operations provider
*/
public LdaptiveUserDetailsAutoConfiguration(
LdaptiveProperties properties,
ObjectProvider<LdaptiveOperations> ldaptiveOperationsProvider) {
this.properties = properties.getUserDetails();
this.ldaptiveOperations = ldaptiveOperationsProvider.getIfAvailable();
Assert.notNull(this.ldaptiveOperations, "Ldap operations must not be present.");
}
/**
* Init.
*/
@EventListener(ApplicationReadyEvent.class)
public void init() {
log.info("\n"
+ "*********************************************************************************\n"
+ "* {}\n"
+ "*********************************************************************************\n"
+ "* properties = {}\n"
+ "*********************************************************************************",
ClassUtils.getUserClass(getClass()).getSimpleName(),
properties);
Assert.hasText(properties.getUserBaseDn(), "User base dn must be present.");
Assert.hasText(properties.getUserFindOneFilter(), "User find one filter must be present.");
}
/**
* Ldaptive user details service.
*
* @return the ldaptive user details service
*/
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnMissingBean(value = {UserDetailsService.class})
@Bean
public LdaptiveUserDetailsService ldaptiveUserDetailsService() {
return new LdaptiveUserDetailsService(
ldaptiveOperations,
properties.getUserBaseDn(),
properties.getUserFindOneFilter(),
properties.getUserFindOneSearchScope(),
properties.getUserAccountControlAttributeName(),
properties.getAuth
```
<Overlap Ratio: 0.9955535793686082>

---

--- 108 --
Question ID: 721a6c092b33922d5f067d8f07d4bb106361fb10_0
Original Code:
```
public class ComponentDiagramParser {

    /**
     * Create a UML component diagram from the model and relationship elements given as JSON arrays. It parses the JSON objects to corresponding Java objects and creates a
     * component diagram containing these UML model elements.
     *
     * @param modelElements the model elements as JSON array
     * @param relationships the relationship elements as JSON array
     * @param modelSubmissionId the ID of the corresponding modeling submission
     * @return a UML component diagram containing the parsed model elements and relationships
     * @throws IOException when no corresponding model elements could be found for the source and target IDs in the relationship JSON objects
     */
    protected static UMLComponentDiagram buildComponentDiagramFromJSON(JsonArray modelElements, JsonArray relationships, long modelSubmissionId) throws IOException {
        Map<String, UMLComponent> umlComponentMap = new HashMap<>();
        Map<String, UMLComponentInterface> umlComponentInterfaceMap = new HashMap<>();
        Map<String, UMLElement> allUmlElementsMap = new HashMap<>();
        List<UMLComponentRelationship> umlComponentRelationshipList = new ArrayList<>();

        // owners might not yet be available, therefore we need to store them in a map first before we can resolve them
        Map<UMLElement, String> ownerRelationships = new HashMap<>();

        // loop over all JSON elements and create the UML objects
        for (JsonElement jsonElement : modelElements) {
            JsonObject jsonObject = jsonElement.getAsJsonObject();
            UMLElement umlElement = null;
            String elementType = jsonObject.get(ELEMENT_TYPE).getAsString();
            if (UMLComponent.UML_COMPONENT_TYPE.equals(elementType)) {
                UMLComponent umlComponent = parseComponent(jsonObject);
                umlComponentMap.put(umlComponent.getJSONElementID(), umlComponent);
                umlElement = umlComponent;
            }
            else if (UMLComponentInterface.UML_COMPONENT_INTERFACE_TYPE.equals(elementType)) {
                UMLComponentInterface umlComponentInterface = parseComponentInterface(jsonObject);
                umlComponentInterfaceMap.put(umlComponentInterface.getJSONElementID(), umlComponentInterface);
                umlElement = umlComponentInterface;
            }
            if (umlElement != null) {
                allUmlElementsMap.put(umlElement.getJSONElementID(), umlElement);
                findOwner(ownerRelationships, jsonObject, umlElement);
            }
        }

        // now we can resolve the owners: for this diagram type, only uml components can be the actual owner
        resolveParentComponent(allUmlElementsMap, ownerRelationships);

        // loop over all JSON control flow elements and create UML communication links
        for (JsonElement rel : relationships) {
            Optional<UMLComponentRelationship> componentRelationship = parseComponentRelationship(rel.getAsJsonObject(), allUmlElementsMap);
            componentRelationship.ifPresent(umlComponentRelationshipList::add);
        }

        return new UMLComponentDiagram(modelSubmissionId, new ArrayList<>(umlComponentMap.values()), new ArrayList<>(umlComponentInterfaceMap.values()),
                umlComponentRelationshipList);
    }

    /**
     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.
     *
     * @param relationshipJson the JSON object containing the component interface
     * @param allUmlElementsMap the JSON object containing the component interface
     * @return the UMLComponentInterface object parsed from the JSON object
     */
    protected static Optional<UMLComponentRelationship> parseComponentRelationship(JsonObject relationshipJson, Map<String, UMLElement> allUmlElementsMap) throws IOException {

        String relationshipType = relationshipJson.get(RELATIONSHIP_TYPE).getAsString();
        relationshipType = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, relationshipType);

        if (!EnumUtils.isValidEnum(UMLComponentRelationship.UMLComponentRelationshipType.class, relationshipType)) {
            return Optional.empty();
        }

        UMLElement source = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_SOURCE);
        UMLElement target = UMLModelParser.findElement(relationshipJson, allUmlElementsMap, RELATIONSHIP_TARGET);

        if (source != null && target != null) {
            UMLComponentRelationship newComponentRelationship = new UMLComponentRelationship(source, target,
                    UMLComponentRelationship.UMLComponentRelationshipType.valueOf(relationshipType), relationshipJson.get(ELEMENT_ID).getAsString());
            return Optional.of(newComponentRelationship);
        }
        else {
            throw new IOException("Relationship source or target not part of model!");
        }
    }

    /**
     * Parses the given JSON representation of a UML component interface to a UMLComponentInterface Java object.
     *
     * @param componentInterfaceJson the JSON object containing the component interface
     * @return the UMLComponentInterface object parsed from the JSON object
     */
    protected static UMLComponentInterface parseComponentInterface(JsonObject componentInterfaceJson) {
        String componentInterfaceName = componentInterfaceJson.get(ELEMENT_NAME).getAsString();
        return new UMLComponentInterface(componentInterfaceName, componentInterfaceJson.get(ELEMENT_ID).getAsString());
    }

    /**
     * Parses the given JSON representation of a UML component to a UMLComponent Java object.
     *
     * @param componentJson the JSON object containing the component
     * @return the UMLComponent object parsed from the JSON object
     */
    protected static UMLComponent parseComponent(JsonObject componentJson) {
        String componentName = componentJson.get(ELEMENT_NAME).getAsString();
        return new UMLComponent(componentName, componentJson.get(ELEMENT_ID).getAsString());
    }

    /**
     * Finds the owner element of relationship and sets parent of relationship to that element
     *
     * @param allUmlElementsMap map of uml elements and ids to find owner element
     * @param ownerRelationships map of uml elements and ids of their owners
     * @return the UMLComponent object parsed from the JSON object
     */
    protected static void resolveParentComponent(Map<String, UMLElement> allUmlElementsMap, Map<UMLElement, String> ownerRelationships) {
        for (var ownerEntry : ownerRelationships.entrySet()) {
            String ownerId = ownerEntry.getValue();
            UMLElement umlElement = ownerEntry.getKey();
            UMLElement parentComponent = allUmlElementsMap.get(ownerId);
            umlElement.setParentElement(parentComponent);
        }
    }

    /**
     * Gets the owner id from element's json object and puts it into a relationship map
     *
     * @param ownerRelationships map of uml relationship elements and their ids
     * @param jsonObject json representation of element
     * @param umlElement uml element
     * @return the UMLComponent object parsed from the JSON object
     */
    protected static void findOwner(Map<UMLElement, String> ownerRelationships, JsonObject jsonObject, UMLElement umlElement) {
        if (jsonObject.has(ELEMENT_OWNER) && !jsonObject.get(ELEMENT_OWNER).isJsonNull()) {
            String ownerId = jsonObject.get(ELEMENT_OWNER).getAsString();
            ownerRelationships.put(umlElement, ownerId);
        }
    }

}
```


Overlapping Code:
```
 ComponentDiagramParser {
/**
* Create a UML component diagram from the model and relationship elements given as JSON arrays. It parses the JSON objects to corresponding Java objects and creates a
* component diagram containing these UML model elements.
*
* @param modelElements the model elements as JSON array
* @param relationships the relationship elements as JSON array
* @param modelSubmissionId the ID of the corresponding modeling submission
* @return a UML component diagram containing the parsed model elements and relationships
* @throws IOException when no corresponding model elements could be found for the source and target IDs in the relationship JSON objects
*/
protected static UMLComponentDiagram buildComponentDiagramFromJSON(JsonArray modelElements, JsonArray relationships, long modelSubmissionId) throws IOException {
Map<String, UMLComponent> umlComponentMap = new HashMap<>();
Map<String, UMLComponentInterface> umlComponentInterfaceMap = new HashMap<>();
Map<String, UMLElement> allUmlElementsMap = new HashMap<>();
List<UMLComponentRelationship> umlComponentRelationshipList = new ArrayList<>();
// owners might not yet be available, therefore we need to store them in a map first before we can resolve them
Map<UMLElement, String> ownerRelationships = new HashMap<>();
// loop over all JSON elements and create the UML objects
for (JsonElement jsonElement : modelElements) {
JsonObject jsonObject = jsonElement.getAsJsonObject();
UMLElement umlElement = null;
String elementType = jsonObject.get(ELEMENT_TYPE).getAsString();
if (UMLComponent.UML_COMPONENT_TYPE.equals(elementType)) {
UMLComponent umlComponent = parseComponent(jsonObject);
umlComponentMap.put(umlComponent.getJSONElementID(), umlComponent);
umlElement = umlComponent;
}
else if (UMLComponentInterface.UML_COMPONENT_INTERFACE_TYPE.equals(elementType)) {
UMLComponentInterface umlComponentInterface = parseComponentInterface(jsonObject);
umlComponentInterfaceMap.put(umlComponentInterface.getJSONElementID(), umlComponentInterface);
umlElement = umlComponentInterface;
}
if (umlElement != null) {
allUmlElementsMap.put(umlElement.getJSONElementID(), umlElem
```
<Overlap Ratio: 0.9921550530687586>

---

--- 109 --
Question ID: e3ae0f2a22f26e9a4ff23fac0c789cb3335ba243_0
Original Code:
```
public class C_RfQ_PublishResults extends JavaProcess implements IProcessPrecondition
{
	// services
	private final transient IRfQConfiguration rfqConfiguration = Services.get(IRfQConfiguration.class);
	private final transient IRfqBL rfqBL = Services.get(IRfqBL.class);
	private final transient IRfqDAO rfqDAO = Services.get(IRfqDAO.class);
	private final transient IPMM_RfQ_BL pmmRfqBL = Services.get(IPMM_RfQ_BL.class);


	@Override
	public ProcessPreconditionsResolution checkPreconditionsApplicable(final IProcessPreconditionsContext context)
	{
		final I_C_RfQ rfq = context.getSelectedModel(I_C_RfQ.class);
		return ProcessPreconditionsResolution.acceptIf(rfqBL.isClosed(rfq));
	}

	@Override
	protected String doIt()
	{
		final I_C_RfQ rfq = getRecord(I_C_RfQ.class);
		final IRfQResponsePublisher rfQResponsePublisher = rfqConfiguration.getRfQResponsePublisher();

		for (final I_C_RfQResponse rfqResponse : rfqDAO.retrieveAllResponses(rfq))
		{
			if (!rfqBL.isClosed(rfqResponse))
			{
				addLog("@Error@ @NotClosed@: {}", rfqBL.getSummary(rfqResponse));
				continue;
			}
			
			pmmRfqBL.checkCompleteContractsForWinners(rfqResponse);

			rfQResponsePublisher.publish(RfQResponsePublisherRequest.of(rfqResponse, PublishingType.Close));
		}

		return MSG_OK;
	}
}
```


Overlapping Code:
```
Results extends JavaProcess implements IProcessPrecondition
{
// services
private final transient IRfQConfiguration rfqConfiguration = Services.get(IRfQConfiguration.class);
private final transient IRfqBL rfqBL = Services.get(IRfqBL.class);
private final transient IRfqDAO rfqDAO = Services.get(IRfqDAO.class);
private final transient IPMM_RfQ_BL pmmRfqBL = Services.get(IPMM_RfQ_BL.class);
@Override
public ProcessPreconditionsResolution checkPreconditionsApplicable(final IProcessPreconditionsContext context)
{
final I_C_RfQ rfq = context.getSelectedModel(I_C_RfQ.class);
return ProcessPreconditionsResolution.acceptIf(rfqBL.isClosed(rfq));
}
@Override
protected String doIt()
{
final I_C_RfQ rfq = getRecord(I_C_RfQ.class);
final IRfQResponsePublisher rfQResponsePublisher = rfqConfiguration.getRfQResponsePublisher();
for (final I_C_RfQResponse rfqResponse : rfqDAO.retrieveAllResponses(rfq))
{
if (!rfqBL.isClosed(rfqResponse))
{
addLog("@Error@ @NotClosed@: {}", rfqBL.getSummary(rfqResponse));
continue;
}

pmmRfqBL.checkCompleteContractsForWinners(rfqResponse);
rfQResponsePublisher.publish(RfQResponsePublisherRequest.of(rfqResponse, Publish
```
<Overlap Ratio: 0.9481054365733114>

---

--- 110 --
Question ID: 9bfe59bbf92baf826e82f2d63c52bb51cc6a3390_0
Original Code:
```
public class MissionsViewModel extends AndroidViewModel
        implements MissionsAdapter.OnAcceptClickListener {
    private static final long TIME_BASE = 1800000; // 30 minutes
    public final ObservableField<Mission.Type> typeSelected = new ObservableField<>();
    public final ObservableField<Mission.Rank> rankSelected = new ObservableField<>();
    private MutableLiveData<List<Mission>> mMissions = new MutableLiveData<>();

    private SingleLiveEvent<Void> mShowWarningDialogEvent = new SingleLiveEvent<>();
    private SingleLiveEvent<Boolean> mShowProgressBarEvent = new SingleLiveEvent<>();

    public MissionsViewModel(@NonNull Application application) {
        super(application);
        typeSelected.set(Mission.Type.TIME);
        rankSelected.set(Mission.Rank.RANK_D);
        filterMissions();
    }

    public void onTypeSelected(Mission.Type type) {
        if (type == typeSelected.get()) {
            return;
        }
        typeSelected.set(type);
        filterMissions();
    }

    public void onRankSelected(Mission.Rank rank) {
        if (rank == rankSelected.get()) {
            return;
        }
        rankSelected.set(rank);
        filterMissions();
    }

    @Override
    public synchronized void onAcceptClick(Mission mission) {
        mShowProgressBarEvent.setValue(true);

        if (mission instanceof SpecialMission) {
            MissionRepository.getInstance().acceptMission(mission, Mission.Type.SPECIAL);
            CharOn.character.setSpecialMission(true);
            mShowProgressBarEvent.setValue(false);
        } else if (mission instanceof TimeMission && CharOn.character.getTotalDailyMissions() <= 3) {
            FirebaseFunctionsUtils.getServerTime(currentTimestamp -> {
                TimeMission timeMission = (TimeMission) mission;
                timeMission.setInitialTimestamp(currentTimestamp);
                MissionRepository.getInstance().acceptMission(timeMission, Mission.Type.TIME);
                NotificationsUtils.setAlarm(getApplication(),
                        currentTimestamp + timeMission.getDurationMillis());
                CharOn.character.setTimeMission(true);
                mShowProgressBarEvent.setValue(false);
            });
        } else {
            mShowProgressBarEvent.setValue(false);
            mShowWarningDialogEvent.call();
        }
    }

    private void filterMissions() {
        List<Mission> missions = new ArrayList<>();

        if (typeSelected.get() == Mission.Type.TIME) {
            if (rankSelected.get() == Mission.Rank.RANK_D) {
                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION1, MissionInfo.MISSION91)) {
                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));
                }
            } else if (rankSelected.get() == Mission.Rank.RANK_C) {
                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION92, MissionInfo.MISSION167)) {
                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));
                }
            } else if (rankSelected.get() == Mission.Rank.RANK_B) {
                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION168, MissionInfo.MISSION238)) {
                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));
                }
            } else if (rankSelected.get() == Mission.Rank.RANK_A) {
                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION239, MissionInfo.MISSION297)) {
                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));
                }
            } else { // Rank S
                for (MissionInfo missionInfo : EnumSet.range(MissionInfo.MISSION298, MissionInfo.MISSION371)) {
                    missions.add(new TimeMission(missionInfo.name(), TIME_BASE));
                }
            }
        } else { // Type == SPECIAL
            if (rankSelected.get() == Mission.Rank.RANK_D) {
                missions.add(new SpecialMission(MissionInfo.MISSION372.name(), 5));
                missions.add(new SpecialMission(MissionInfo.MISSION373.name(), 10));
                missions.add(new SpecialMission(MissionInfo.MISSION374.name(), 10));
                missions.add(new SpecialMission(MissionInfo.MISSION375.name(), 10));
                missions.add(new SpecialMission(MissionInfo.MISSION376.name(), 10));
                missions.add(new SpecialMission(MissionInfo.MISSION377.name(), 10));
                missions.add(new SpecialMission(MissionInfo.MISSION378.name(), 20));
                missions.add(new SpecialMission(MissionInfo.MISSION379.name(), 20));
                missions.add(new SpecialMission(MissionInfo.MISSION380.name(), 20));
                missions.add(new SpecialMission(MissionInfo.MISSION381.name(), 20));
            } else if (rankSelected.get() == Mission.Rank.RANK_C) {
                missions.add(new SpecialMission(MissionInfo.MISSION382.name(), 15));
                missions.add(new SpecialMission(MissionInfo.MISSION383.name(), 20));
                missions.add(new SpecialMission(MissionInfo.MISSION384.name(), 30));
                missions.add(new SpecialMission(MissionInfo.MISSION385.name(), 30));
                missions.add(new SpecialMission(MissionInfo.MISSION386.name(), 30));
                missions.add(new SpecialMission(MissionInfo.MISSION387.name(), 30));
                missions.add(new SpecialMission(MissionInfo.MISSION388.name(), 40));
                missions.add(new SpecialMission(MissionInfo.MISSION389.name(), 40));
                missions.add(new SpecialMission(MissionInfo.MISSION390.name(), 40));
                missions.add(new SpecialMission(MissionInfo.MISSION391.name(), 40));
            } else if (rankSelected.get() == Mission.Rank.RANK_B) {
                missions.add(new SpecialMission(MissionInfo.MISSION392.name(), 25));
            }
        }

        if (missions.size() > 0) {
            Collections.sort(CharOn.character.getMissionsFinishedId());
            removeRepeatedMissions(CharOn.character.getMissionsFinishedId(), missions);
        }

        mMissions.postValue(missions);
    }

    private void removeRepeatedMissions(Collection<Integer> missionIds, Collection<Mission> missions) {
        for (int missionId : missionIds) {
            Iterator<Mission> missionIterator = missions.iterator();

            while (missionIterator.hasNext()) {
                Mission mission = missionIterator.next();
                MissionInfo missionInfo = mission.missionInfo();

                if (missionId == missionInfo.ordinal()) {
                    missionIterator.remove();
                    break;
                }
            }
        }
    }


    LiveData<List<Mission>> getMissions() {
        return mMissions;
    }

    LiveData<Void> getShowWarningDialogEvent() {
        return mShowWarningDialogEvent;
    }

    LiveData<Boolean> getShowProgressBarEvent() {
        return mShowProgressBarEvent;
    }
}
```


Overlapping Code:
```
onsViewModel extends AndroidViewModel
implements MissionsAdapter.OnAcceptClickListener {
private static final long TIME_BASE = 1800000; // 30 minutes
public final ObservableField<Mission.Type> typeSelected = new ObservableField<>();
public final ObservableField<Mission.Rank> rankSelected = new ObservableField<>();
private MutableLiveData<List<Mission>> mMissions = new MutableLiveData<>();
private SingleLiveEvent<Void> mShowWarningDialogEvent = new SingleLiveEvent<>();
private SingleLiveEvent<Boolean> mShowProgressBarEvent = new SingleLiveEvent<>();
public MissionsViewModel(@NonNull Application application) {
super(application);
typeSelected.set(Mission.Type.TIME);
rankSelected.set(Mission.Rank.RANK_D);
filterMissions();
}
public void onTypeSelected(Mission.Type type) {
if (type == typeSelected.get()) {
return;
}
typeSelected.set(type);
filterMissions();
}
public void onRankSelected(Mission.Rank rank) {
if (rank == rankSelected.get()) {
return;
}
rankSelected.set(rank);
filterMissions();
}
@Override
public synchronized void onAcceptClick(Mission mission) {
mShowProgressBarEvent.setValue(true);
if (mission instanceof SpecialMission) {
MissionRepository.getInstance().acceptMission(mission, Mission.Type.SPECIAL);
CharOn.character.setSpecialMission(true);
mShowProgressBarEvent.setValue(false);
} else if (mission instanceof TimeMission && CharOn.character.getTotalDailyMissions() <= 3) {
FirebaseFunctionsUtils.getServerTime(currentTimestamp -> {
TimeMission timeMission = (TimeMission) mission;
timeMission.setInitialTimestamp(currentTimestamp);
MissionRepository.getInstance().acceptMission(timeMission, Mission.Type.TIME);
NotificationsUtils.setAlarm(getApplication(),
currentTimestamp + timeMission.getDurationMillis());
CharOn.character.setTimeMission(true);
mShowProgressBarEvent.setValue(false);
});
} else {
mShowProgressBarEvent.setValue(false);
mShowWarningDialogEvent.call();
}
}
private void filterMissions() {
List<Mission> missions = new ArrayList<>();
if (typeSelected.
```
<Overlap Ratio: 0.980872976949485>

---

--- 111 --
Question ID: c9e5258a78fe8b1cf3cefd85165a8d79d7b38649_0
Original Code:
```
public class RMManagerConfigurationTest {

    private Bus bus;

    @After
    public void tearDown() {
        bus.shutdown(true);
        BusFactory.setDefaultBus(null);
    }

    @Test
    public void testManagerBean() {
        SpringBusFactory factory = new SpringBusFactory();
        bus = factory.createBus("org/apache/cxf/ws/rm/manager-bean.xml", false);
        RMManager manager = bus.getExtension(RMManager.class);
        verifyManager(manager);
    }

    @Test
    public void testExactlyOnce() {
        SpringBusFactory factory = new SpringBusFactory();
        bus = factory.createBus("org/apache/cxf/ws/rm/exactly-once.xml", false);
        RMManager manager = bus.getExtension(RMManager.class);
        RMConfiguration cfg = manager.getConfiguration();
        DeliveryAssurance da = cfg.getDeliveryAssurance();
        assertEquals(da, DeliveryAssurance.EXACTLY_ONCE);
        assertFalse(cfg.isInOrder());
    }

    @Test
    public void testFeature() {
        SpringBusFactory factory = new SpringBusFactory();
        bus = factory.createBus("org/apache/cxf/ws/rm/feature.xml");
        RMManager manager = bus.getExtension(RMManager.class);
        verifyManager(manager);
    }

    private void verifyManager(RMManager manager) {
        assertNotNull(manager);
        assertTrue(manager.getSourcePolicy().getSequenceTerminationPolicy().isTerminateOnShutdown());
        assertEquals(0L, manager.getDestinationPolicy().getAcksPolicy().getIntraMessageThreshold());
        assertEquals(2000L, manager.getDestinationPolicy().getAcksPolicy().getImmediaAcksTimeout());
        assertEquals(10000L, manager.getConfiguration().getBaseRetransmissionInterval().longValue());
        assertEquals(10000L, manager.getConfiguration().getAcknowledgementInterval().longValue());
        assertEquals("http://www.w3.org/2005/08/addressing", manager.getConfiguration().getRM10AddressingNamespace());
        TestStore store = (TestStore)manager.getStore();
        assertEquals("here", store.getLocation());
        assertTrue(manager.getConfiguration().isInOrder());
    }

    static class TestStore implements RMStore {

        private String location;

        TestStore() {
            // this(null);
        }

        public String getLocation() {
            return location;
        }

        public void setLocation(String location) {
            this.location = location;
        }



        public void createDestinationSequence(DestinationSequence seq) {
    
        }

        public void createSourceSequence(SourceSequence seq) {
    
        }

        public Collection<DestinationSequence> getDestinationSequences(String endpointIdentifier) {
            return null;
        }

        public Collection<RMMessage> getMessages(Identifier sid, boolean outbound) {
            return null;
        }

        public Collection<SourceSequence> getSourceSequences(String endpointIdentifier) {
            return null;
        }

        public void persistIncoming(DestinationSequence seq, RMMessage msg) {
    
        }

        public void persistOutgoing(SourceSequence seq, RMMessage msg) {
    
        }

        public void removeDestinationSequence(Identifier seq) {
    
        }

        public void removeMessages(Identifier sid, Collection<Long> messageNrs, boolean outbound) {
    
        }

        public void removeSourceSequence(Identifier seq) {
    
        }

        public SourceSequence getSourceSequence(Identifier seq) {
            return null;
        }

        public DestinationSequence getDestinationSequence(Identifier seq) {
            return null;
        }

    }
}
```


Overlapping Code:
```
lic class RMManagerConfigurationTest {
private Bus bus;
@After
public void tearDown() {
bus.shutdown(true);
BusFactory.setDefaultBus(null);
}
@Test
public void testManagerBean() {
SpringBusFactory factory = new SpringBusFactory();
bus = factory.createBus("org/apache/cxf/ws/rm/manager-bean.xml", false);
RMManager manager = bus.getExtension(RMManager.class);
verifyManager(manager);
}
@Test
public void testExactlyOnce() {
SpringBusFactory factory = new SpringBusFactory();
bus = factory.createBus("org/apache/cxf/ws/rm/exactly-once.xml", false);
RMManager manager = bus.getExtension(RMManager.class);
RMConfiguration cfg = manager.getConfiguration();
DeliveryAssurance da = cfg.getDeliveryAssurance();
assertEquals(da, DeliveryAssurance.EXACTLY_ONCE);
assertFalse(cfg.isInOrder());
}
@Test
public void testFeature() {
SpringBusFactory factory = new SpringBusFactory();
bus = factory.createBus("org/apache/cxf/ws/rm/feature.xml");
RMManager manager = bus.getExtension(RMManager.class);
verifyManager(manager);
}
private void verifyManager(RMManager manager) {
assertNotNull(manager);
assertTrue(manager.getSourcePolicy().getSequenceTerminationPolicy().isTerminateOnShutdown());
assertEquals(0L, manager.getDestinationPolicy().getAcksPolicy().getIntraMessageThreshold());
assertEquals(2000L, manager.getDestinationPolicy().getAcksPolicy().getImmediaAcksTimeout());
assertEquals(10000L, manager.getConfiguration().getBaseRetransmissionInterval().longValue());
assertEquals(10000L, manager.getConfiguration().getAcknowledgementInterval().longValue());
assertEquals("http://www.w3.org/2005/08/addressing", manager.getConfiguration().getRM10AddressingNamespace());
TestStore store = (TestStore)manager.getStore();
assertEquals("here", store.getLocation());
assertTrue(manager.getConfiguration().isInOrder());
}
static class TestStore implements RMStore {
private String location;
TestStore() {
// this(null);
}
public String getLocation() {
return location;
}
public void setLocation(String location) {
this.location = location;
}
public void createDestinationSequence(DestinationSequence 
```
<Overlap Ratio: 0.9956999522216914>

---

--- 112 --
Question ID: ddeb8129068939c966b46e68d4be152042d45fc4_0
Original Code:
```
public class CustomXsltComponent extends XsltComponent {

    protected static final Log log = LogFactory.getLog(CustomXsltComponent.class);


    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
        Resource resource = resolveMandatoryResource(remaining);
        if (log.isDebugEnabled()) {
            log.debug(this + " using schema resource: " + resource);
        }
        XsltBuilder xslt = getCamelContext().getInjector().newInstance(XsltBuilder.class);

        // lets allow the converter to be configured
        XmlConverter converter = resolveAndRemoveReferenceParameter(parameters, "converter", XmlConverter.class);
        if (converter == null) {
            converter = getXmlConverter();
        }
        if (converter != null) {
            xslt.setConverter(converter);
        }

        String transformerFactoryClassName = getAndRemoveParameter(parameters, "transformerFactoryClass", String.class);
        TransformerFactory factory = null;
        if (transformerFactoryClassName != null) {
            // provide the class loader of this component to work in OSGi environments
            Class<?> factoryClass = getCamelContext().getClassResolver().resolveClass(transformerFactoryClassName, XsltComponent.class.getClassLoader());
            if (factoryClass != null) {
                factory = (TransformerFactory) getCamelContext().getInjector().newInstance(factoryClass);
            } else {
                log.warn("Cannot find the TransformerFactoryClass with the class name: " + transformerFactoryClassName);
            }
        }

        if (parameters.get("transformerFactory") != null) {
            factory = resolveAndRemoveReferenceParameter(parameters, "transformerFactory", TransformerFactory.class);
        }

        if (factory != null) {
            xslt.getConverter().setTransformerFactory(factory);
        }

        log.info("Transformer factory  : " + xslt.getConverter().getTransformerFactory().getClass().getName());
        xslt.getConverter()
                .getTransformerFactory()
                .setURIResolver(new ClasspathURIResolver(getResourceLoader(),
                remaining.substring(0, remaining.lastIndexOf('/') + 1) ));
        xslt.setTransformerInputStream(resource.getInputStream());

        configureXslt(xslt, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, xslt);
    }


}
```


Overlapping Code:
```
omXsltComponent extends XsltComponent {
protected static final Log log = LogFactory.getLog(CustomXsltComponent.class);
protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
Resource resource = resolveMandatoryResource(remaining);
if (log.isDebugEnabled()) {
log.debug(this + " using schema resource: " + resource);
}
XsltBuilder xslt = getCamelContext().getInjector().newInstance(XsltBuilder.class);
// lets allow the converter to be configured
XmlConverter converter = resolveAndRemoveReferenceParameter(parameters, "converter", XmlConverter.class);
if (converter == null) {
converter = getXmlConverter();
}
if (converter != null) {
xslt.setConverter(converter);
}
String transformerFactoryClassName = getAndRemoveParameter(parameters, "transformerFactoryClass", String.class);
TransformerFactory factory = null;
if (transformerFactoryClassName != null) {
// provide the class loader of this component to work in OSGi environments
Class<?> factoryClass = getCamelContext().getClassResolver().resolveClass(transformerFactoryClassName, XsltComponent.class.getClassLoader());
if (factoryClass != null) {
factory = (TransformerFactory) getCamelContext().getInjector().newInstance(factoryClass);
} else {
log.warn("Cannot find the TransformerFactoryClass with the class name: " + transformerFactoryClassName);
}
}
if (parameters.get("transformerFactory") != null) {
factory = resolveAndRemoveReferenceParameter(parameters, "transformerFactory", TransformerFactory.class);
}
if (factory != null) {
xslt.getConverter().setTransformerFactory(factory);
}
log.info("Transformer factory : " + xslt.getConverter().getTransformerFactory().getClass().getName());
xslt.getConverter()
.getTransformerFactory()
.setURIResolver(new ClasspathURIResolver(getResourceLoader(),
remaining.substring(0, remaining.lastIndexOf('/') + 1) ));
xslt.setTransformerInputStream(resource.getInputStream());
configureXslt(xslt, uri, remaining, parameters);
return new Proc
```
<Overlap Ratio: 0.9765625>

---

--- 113 --
Question ID: 2f2a41b33dd9ba8e7c9ecdbb5190b5fc9a0c5d5f_0
Original Code:
```
public class SecretKeyFactoryTest extends TestCase {

    public static final String srvSecretKeyFactory = "SecretKeyFactory";

    private static String defaultAlgorithm1 = "DESede";
    private static String defaultAlgorithm2 = "DES";

    public static String defaultAlgorithm = null;

    private static String defaultProviderName = null;

    private static Provider defaultProvider = null;

    private static final String[] invalidValues = SpiEngUtils.invalidValues;

    public static final String[] validValues = new String[2];
    private static boolean DEFSupported = false;

    private static final String NotSupportMsg = "Default algorithm is not supported";

    static {
        defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm1,
                srvSecretKeyFactory);
        DEFSupported = (defaultProvider != null);
        if (DEFSupported) {
            defaultAlgorithm = defaultAlgorithm1;
            validValues[0] = defaultAlgorithm.toUpperCase();
            validValues[1] = defaultAlgorithm.toLowerCase();
            defaultProviderName = defaultProvider.getName();
        } else {
            defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm2,
                    srvSecretKeyFactory);
            DEFSupported = (defaultProvider != null);
            if (DEFSupported) {
                defaultAlgorithm = defaultAlgorithm2;
                validValues[0] = defaultAlgorithm.toUpperCase();
                validValues[2] = defaultAlgorithm.toLowerCase();
                defaultProviderName = defaultProvider.getName();
            } else {
                defaultAlgorithm = null;
                defaultProviderName = null;
                defaultProvider = null;
            }
        }
    }

    protected SecretKeyFactory[] createSKFac() {
        if (!DEFSupported) {
            fail(defaultAlgorithm + " algorithm is not supported");
            return null;
        }
        SecretKeyFactory[] skF = new SecretKeyFactory[3];
        try {
            skF[0] = SecretKeyFactory.getInstance(defaultAlgorithm);
            skF[1] = SecretKeyFactory.getInstance(defaultAlgorithm,
                    defaultProvider);
            skF[2] = SecretKeyFactory.getInstance(defaultAlgorithm,
                    defaultProviderName);
            return skF;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Test for <code>SecretKeyFactory</code> constructor
     * Assertion: returns SecretKeyFactory object
     */
    public void testSecretKeyFactory01() throws NoSuchAlgorithmException,
            InvalidKeySpecException, InvalidKeyException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        SecretKeyFactorySpi spi = new MySecretKeyFactorySpi();
        SecretKeyFactory secKF = new mySecretKeyFactory(spi, defaultProvider,
                defaultAlgorithm);
        assertEquals("Incorrect algorithm", secKF.getAlgorithm(),
                defaultAlgorithm);
        assertEquals("Incorrect provider", secKF.getProvider(), defaultProvider);
        assertNull("Incorrect result", secKF.generateSecret(null));
        assertNull("Incorrect result", secKF.getKeySpec(null, null));
        assertNull("Incorrect result", secKF.translateKey(null));
        secKF = new mySecretKeyFactory(null, null, null);
        assertNull("Algorithm must be null", secKF.getAlgorithm());
        assertNull("Provider must be null", secKF.getProvider());
        try {
            secKF.translateKey(null);
            fail("NullPointerException must be thrown");
        } catch (NullPointerException e) {
        }
    }

    /**
     * Test for <code>getInstance(String algorithm)</code> method
     * Assertions:
     * throws NullPointerException when algorithm is null;
     * throws NoSuchAlgorithmException when algorithm has invalid value
     */
    public void testSecretKeyFactory02() throws NoSuchAlgorithmException {
        try {
            SecretKeyFactory.getInstance(null);
            fail("NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null");
        } catch (NullPointerException e) {
        } catch (NoSuchAlgorithmException e) {
        }
        for (int i = 0; i < invalidValues.length; i++) {
            try {
                SecretKeyFactory.getInstance(invalidValues[i]);
                fail("NoSuchAlgorithmException was not thrown as expected");
            } catch (NoSuchAlgorithmException e) {
            }
        }
    }

    /**
     * Test for <code>getInstance(String algorithm)</code> method
     * Assertion: returns SecretKeyObject
     */
    public void testSecretKeyFactory03() throws NoSuchAlgorithmException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        for (int i = 0; i < validValues.length; i++) {
            SecretKeyFactory secKF = SecretKeyFactory
                    .getInstance(validValues[i]);
            assertEquals("Incorrect algorithm", secKF.getAlgorithm(),
                    validValues[i]);
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, String provider)</code>
     * method
     * Assertion:
     * throws NullPointerException when algorithm is null;
     * throws NoSuchAlgorithmException when algorithm is invalid
     */
    public void testSecretKeyFactory04() throws NoSuchAlgorithmException,
            NoSuchProviderException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        try {
            SecretKeyFactory.getInstance(null, defaultProviderName);
            fail("NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null");
        } catch (NullPointerException e) {
        } catch (NoSuchAlgorithmException e) {
        }
        for (int i = 0; i < invalidValues.length; i++) {
            try {
                SecretKeyFactory.getInstance(invalidValues[i],
                        defaultProviderName);
                fail("NoSuchAlgorithmException was not thrown as expected (algorithm: "
                        .concat(invalidValues[i]).concat(")"));
            } catch (NoSuchAlgorithmException e) {
            }
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, String provider)</code>
     * method
     * Assertion:
     * throws IllegalArgumentException when provider is null or empty;
     * throws NoSuchProviderException when provider has invalid value
     */
    public void testSecretKeyFactory05() throws NoSuchAlgorithmException,
            NoSuchProviderException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        String prov = null;
        for (int i = 0; i < validValues.length; i++) {
            try {
                SecretKeyFactory.getInstance(validValues[i], prov);
                fail("IllegalArgumentException was not thrown as expected (algorithm: "
                        .concat(validValues[i]).concat(" provider: null"));
            } catch (IllegalArgumentException e) {
            }
            try {
                SecretKeyFactory.getInstance(validValues[i], "");
                fail("IllegalArgumentException was not thrown as expected (algorithm: "
                        .concat(validValues[i]).concat(" provider: empty"));
            } catch (IllegalArgumentException e) {
            }
            for (int j = 1; j < invalidValues.length; j++) {
                try {
                    SecretKeyFactory.getInstance(validValues[i],
                            invalidValues[j]);
                    fail("NoSuchProviderException was not thrown as expected (algorithm: "
                            .concat(validValues[i]).concat(" provider: ")
                            .concat(invalidValues[j]).concat(")"));
                } catch (NoSuchProviderException e) {
                }
            }
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, String provider)</code>
     * method
     * Assertion: returns SecretKeyFactory object
     */
    public void testSecretKeyFactory06() throws NoSuchProviderException,
            NoSuchAlgorithmException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        for (int i = 0; i < validValues.length; i++) {
            SecretKeyFactory secKF = SecretKeyFactory.getInstance(
                    validValues[i], defaultProviderName);
            assertEquals("Incorrect algorithm", secKF.getAlgorithm(),
                    validValues[i]);
            assertEquals("Incorrect provider", secKF.getProvider().getName(),
                    defaultProviderName);
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, Provider provider)</code>
     * method
     * Assertion: throws NullPointerException when algorithm is null;
     * throws NoSuchAlgorithmException when algorithm is invalid
     */
    public void testSecretKeyFactory07() throws NoSuchAlgorithmException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        try {
            SecretKeyFactory.getInstance(null, defaultProvider);
            fail("NullPointerException or NoSuchAlgorithmException should be thrown if algorithm is null");
        } catch (NullPointerException e) {
        } catch (NoSuchAlgorithmException e) {
        }
        for (int i = 0; i < invalidValues.length; i++) {
            try {
                SecretKeyFactory.getInstance(invalidValues[i], defaultProvider);
                fail("NoSuchAlgorithmException was not thrown as expected (algorithm: "
                        .concat(invalidValues[i]).concat(")"));
            } catch (NoSuchAlgorithmException e) {
            }
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, Provider provider)</code>
     * method
     * Assertion: throws IllegalArgumentException when provider is null
     */
    public void testSecretKeyFactory08() throws NoSuchAlgorithmException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        Provider prov = null;
        for (int i = 0; i < validValues.length; i++) {
            try {
                SecretKeyFactory.getInstance(validValues[i], prov);
                fail("IllegalArgumentException was not thrown as expected (provider is null, algorithm: "
                        .concat(validValues[i]).concat(")"));
            } catch (IllegalArgumentException e) {
            }
        }
    }

    /**
     * Test for <code>getInstance(String algorithm, Provider provider)</code>
     * method
     * Assertion: returns SecretKeyFactory object
     */
    public void testSecretKeyFactory09() throws NoSuchAlgorithmException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        for (int i = 0; i < validValues.length; i++) {
            SecretKeyFactory secKF = SecretKeyFactory.getInstance(
                    validValues[i], defaultProvider);
            assertEquals("Incorrect algorithm", secKF.getAlgorithm(),
                    validValues[i]);
            assertEquals("Incorrect provider", secKF.getProvider(),
                    defaultProvider);
        }
    }

    /**
     * Test for <code>generateSecret(KeySpec keySpec)</code> and
     * <code>getKeySpec(SecretKey key, Class keySpec)
     * methods
     * Assertion:
     * throw InvalidKeySpecException if parameter is inappropriate
     */
    public void testSecretKeyFactory10() throws InvalidKeyException,
            InvalidKeySpecException {
        if (!DEFSupported) {
            fail(NotSupportMsg);
            return;
        }
        byte[] bb = new byte[24];
        KeySpec ks = (defaultAlgorithm.equals(defaultAlgorithm2) ? (KeySpec)new DESKeySpec(bb) :
            (KeySpec)new DESedeKeySpec(bb));
        KeySpec rks = null;
        SecretKeySpec secKeySpec = new SecretKeySpec(bb, defaultAlgorithm);
        SecretKey secKey = null;
        SecretKeyFactory[] skF = createSKFac();
        assertNotNull("SecretKeyFactory object were not created", skF);
        for (int i = 0; i < skF.length; i++) {
            // This both serves to ensure that we're testing the default provider and forces
            // the implementation to lock in the provider, even if later calls fail
            assertEquals(defaultProvider, skF[i].getProvider());
            try {
                skF[i].generateSecret(null);
                fail("generateSecret(null): InvalidKeySpecException must be thrown");
            } catch (InvalidKeySpecException e) {
            }

            secKey = skF[i].generateSecret(ks);
            try {
                skF[i].getKeySpec(null, null);
                fail("getKeySpec(null,null): InvalidKeySpecException must be thrown");
            } catch (InvalidKeySpecException e) {
            }
            try {
                skF[i].getKeySpec(null, ks.getClass());
                fail("getKeySpec(null, Class): InvalidKeySpecException must be thrown");
            } catch (InvalidKeySpecException e) {
            }
            try {
                skF[i].getKeySpec(secKey, null);
                fail("getKeySpec(secKey, null): NullPointerException or InvalidKeySpecException must be thrown");
            } catch (InvalidKeySpecException e) {
                // Expected
            } catch (NullPointerException e) {
                // Expected
            }

            try {
                Class c;
                if (defaultAlgorithm.equals(defaultAlgorithm2)) {
                    c = DESedeKeySpec.class;
                } else {
                    c = DESKeySpec.class;
                }
                skF[i].getKeySpec(secKeySpec, c);
                fail("getKeySpec(secKey, Class): InvalidKeySpecException must be thrown");
            } catch (InvalidKeySpecException e) {
            }
            rks = skF[i].getKeySpec(secKeySpec, ks.getClass());
            if (defaultAlgorithm.equals(defaultAlgorithm1)) {
                assertTrue("Incorrect getKeySpec() result 1",
                        rks instanceof DESedeKeySpec);
            } else {
                assertTrue("Incorrect getKeySpec() result 1",
                        rks instanceof DESKeySpec);
            }

            rks = skF[i].getKeySpec(secKey, ks.getClass());
            if (defaultAlgorithm.equals(defaultAlgorithm1)) {
                assertTrue("Incorrect getKeySpec() result 2",
                        rks instanceof DESedeKeySpec);
            } else {
                assertTrue("Incorrect getKeySpec() result 2",
                        rks instanceof DESKeySpec);
            }
        }
    }

    public void test_getAlgorithm() throws NoSuchAlgorithmException {
        for (int i = 0; i < validValues.length; i++) {
            SecretKeyFactory secKF = SecretKeyFactory
                    .getInstance(validValues[i]);
            assertEquals("Incorrect algorithm", secKF.getAlgorithm(),
                    validValues[i]);
        }

        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);
        assertNull(msf.getAlgorithm());
    }

    class Mock_SecretKeyFactory extends SecretKeyFactory{
        protected Mock_SecretKeyFactory(SecretKeyFactorySpi arg0, Provider arg1, String arg2) {
            super(arg0, arg1, arg2);
        }
    }

    public void test_getProvider() throws NoSuchAlgorithmException {
        for (int i = 0; i < validValues.length; i++) {
            SecretKeyFactory secKF = SecretKeyFactory
                    .getInstance(validValues[i]);
            assertNotNull(secKF.getProvider());
        }

        Mock_SecretKeyFactory msf = new Mock_SecretKeyFactory(null, null, null);
        assertNull(msf.getProvider());
    }

    public void test_translateKeyLjavax_crypto_SecretKey()
            throws NoSuchAlgorithmException, InvalidKeyException {
        KeyGenerator kg = null;
        Key key = null;
        SecretKeyFactory secKF = null;

        for (int i = 0; i < validValues.length; i++) {
            secKF = SecretKeyFactory
                    .getInstance(validValues[i]);
            assertNotNull(secKF.getProvider());
            kg = KeyGenerator.getInstance(secKF.getAlgorithm());
            kg.init(new SecureRandom());
            key = kg.generateKey();

            secKF.translateKey((SecretKey) key);
        }
        try {
            secKF.translateKey(null);
            fail("InvalidKeyException expected");
        } catch (InvalidKeyException e) {
            //expected
        }
    }
}
```


Overlapping Code:
```
Test extends TestCase {
public static final String srvSecretKeyFactory = "SecretKeyFactory";
private static String defaultAlgorithm1 = "DESede";
private static String defaultAlgorithm2 = "DES";
public static String defaultAlgorithm = null;
private static String defaultProviderName = null;
private static Provider defaultProvider = null;
private static final String[] invalidValues = SpiEngUtils.invalidValues;
public static final String[] validValues = new String[2];
private static boolean DEFSupported = false;
private static final String NotSupportMsg = "Default algorithm is not supported";
static {
defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm1,
srvSecretKeyFactory);
DEFSupported = (defaultProvider != null);
if (DEFSupported) {
defaultAlgorithm = defaultAlgorithm1;
validValues[0] = defaultAlgorithm.toUpperCase();
validValues[1] = defaultAlgorithm.toLowerCase();
defaultProviderName = defaultProvider.getName();
} else {
defaultProvider = SpiEngUtils.isSupport(defaultAlgorithm2,
srvSecretKeyFactory);
DEFSupported = (defaultProvider != null);
if (DEFSupported) {
defaultAlgorithm = defaultAlgorithm2;
validValues[0] = defaultAlgorithm.toUpperCase();
validValues[2] = defaultAlgorithm.toLowerCase();
defaultProviderName = defaultProvider.getName();
} else {
defaultAlgorithm = null;
defaultProviderName = null;
defaultProvider = null;
}
}
}
protected SecretKeyFactory[] createSKFac() {
if (!DEFSupported) {
fail(defaultAlgorithm + " algorithm is not supported");
return null;
}
SecretKeyFactory[] skF = new SecretKeyFactory[3];
try {
skF[0] = SecretKeyFactory.getInstance(defaultAlgorithm);
skF[1] = SecretKeyFactory.getInstance(defaultAlgorithm,
defaultProvider);
skF[2] = SecretKeyFactory.getInstance(defaultAlgorithm,
defaultProviderName);
return skF;
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
/**
* Test for <code>SecretKeyFactory</code> constructor
* Asse
```
<Overlap Ratio: 0.9809081527347782>

---

--- 114 --
Question ID: 52d3af15d7157eba95b9c9fecb2018428ae5839c_0
Original Code:
```
public class InstanceNotificationPublisher {
    private static final Log log = LogFactory.getLog(InstanceNotificationPublisher.class);

    public static InstanceNotificationPublisher getInstance() {
        return InstanceHolder.INSTANCE;
    }

    private static void publish(Event event) {
        String topic = MessagingUtil.getMessageTopicName(event);

        EventPublisher instanceNotifyingEvent = EventPublisherPool.
                getPublisher(topic);
        instanceNotifyingEvent.publish(event);
    }

    public synchronized void sendInstanceCleanupEventForCluster(String clusterId, String instanceId) {
        log.info(String.format("Publishing Instance Cleanup Event: [cluster] %s " +
                "[cluster-instance] %s", clusterId, instanceId));
        publish(new InstanceCleanupClusterEvent(clusterId, instanceId));
    }

    /**
     * Publishing the instance termination notification to the instances
     *
     * @param memberId
     */
    public synchronized void sendInstanceCleanupEventForMember(String memberId) {
        log.info(String.format("Publishing Instance Cleanup Event: [member] %s", memberId));
        publish(new InstanceCleanupMemberEvent(memberId));
    }

    /* An instance of InstanceNotificationPublisher is created when the class is loaded.
     * Since the class is loaded only once, it is guaranteed that an object of
     * InstanceNotificationPublisher is created only once. Hence it is singleton.
     */
    private static class InstanceHolder {
        private static final InstanceNotificationPublisher INSTANCE = new InstanceNotificationPublisher();
    }
}
```


Overlapping Code:
```
c class InstanceNotificationPublisher {
private static final Log log = LogFactory.getLog(InstanceNotificationPublisher.class);
public static InstanceNotificationPublisher getInstance() {
return InstanceHolder.INSTANCE;
}
private static void publish(Event event) {
String topic = MessagingUtil.getMessageTopicName(event);
EventPublisher instanceNotifyingEvent = EventPublisherPool.
getPublisher(topic);
instanceNotifyingEvent.publish(event);
}
public synchronized void sendInstanceCleanupEventForCluster(String clusterId, String instanceId) {
log.info(String.format("Publishing Instance Cleanup Event: [cluster] %s " +
"[cluster-instance] %s", clusterId, instanceId));
publish(new InstanceCleanupClusterEvent(clusterId, instanceId));
}
/**
* Publishing the instance termination notification to the instances
*
* @param memberId
*/
public synchronized void sendInstanceCleanupEventForMember(String memberId) {
log.info(String.format("Publishing Instance Cleanup Event: [member] %s", memberId));
publish(new InstanceCleanupMemberEvent(memberId));
}
/* An instance of InstanceNotificationPublisher is created when the class is loaded.
* Since the class is loaded only once, it is guaranteed that an object of
* InstanceNotificationPublisher is created only once. Hence it is singleton.
*/
private static class InstanceHolder {
private static final InstanceNotificationPublisher INSTANCE = new InstanceNot
```
<Overlap Ratio: 0.9790209790209791>

---

--- 115 --
Question ID: 0a4e7f177cec35878781aac9ee4be2a683a746ef_0
Original Code:
```
class DefineNamedBindingsStatementCustomizer implements StatementCustomizer {
    @Override
    public void beforeTemplating(PreparedStatement stmt, StatementContext ctx) {
        final Set<String> alreadyDefined = ctx.getAttributes().keySet();
        final Binding binding = ctx.getBinding();
        final SetNullHandler handler = new SetNullHandler(ctx);
        binding.getNames().stream()
            .filter(name -> !alreadyDefined.contains(name))
            .forEach(name -> binding.findForName(name, ctx).ifPresent(
                    a -> handler.define(name, a)));
    }

    private static class SetNullHandler implements InvocationHandler {
        private static final Map<Class<?>, Object> DEFAULT_VALUES = Stream.of(
            boolean.class,
            char.class,
            byte.class,
            short.class,
            int.class,
            long.class,
            float.class,
            double.class
        ).collect(Collectors.toMap(identity(), SetNullHandler::defaultValue));

        private final StatementContext ctx;
        private final PreparedStatement fakeStmt = (PreparedStatement)
                Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] {PreparedStatement.class}, this);
        private boolean setNull;
        private boolean setCalled;

        SetNullHandler(StatementContext ctx) {
            this.ctx = ctx;
        }

        private static Object defaultValue(Class<?> clazz) {
            return Array.get(Array.newInstance(clazz, 1), 0);
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws SQLException {
            if ("unwrap".equals(method.getName())
                && args.length == 1
                && method.getParameterTypes()[0].equals(Class.class)) {
                throw new SQLException("The current implementation of DefineNamedBindings is incompatible with "
                    + "arguments that rely on java.sql.Wrapper.unwrap(Class<?>)");
            }

            if ("getConnection".equals(method.getName())) {
                return ctx.getConnection();
            }

            if (method.getName().startsWith("set")) {
                setCalled = true;
                boolean argNull = args.length > 1 && args[1] == null;
                setNull = argNull || "setNull".equals(method.getName());
            }

            return DEFAULT_VALUES.get(method.getReturnType());
        }

        void define(String name, Argument arg) {
            setNull = false;
            setCalled = false;
            Unchecked.runnable(() -> arg.apply(1, fakeStmt, ctx)).run();
            if (setCalled) {
                ctx.define(name, !setNull);
            }
        }
    }
}
```


Overlapping Code:
```
ineNamedBindingsStatementCustomizer implements StatementCustomizer {
@Override
public void beforeTemplating(PreparedStatement stmt, StatementContext ctx) {
final Set<String> alreadyDefined = ctx.getAttributes().keySet();
final Binding binding = ctx.getBinding();
final SetNullHandler handler = new SetNullHandler(ctx);
binding.getNames().stream()
.filter(name -> !alreadyDefined.contains(name))
.forEach(name -> binding.findForName(name, ctx).ifPresent(
a -> handler.define(name, a)));
}
private static class SetNullHandler implements InvocationHandler {
private static final Map<Class<?>, Object> DEFAULT_VALUES = Stream.of(
boolean.class,
char.class,
byte.class,
short.class,
int.class,
long.class,
float.class,
double.class
).collect(Collectors.toMap(identity(), SetNullHandler::defaultValue));
private final StatementContext ctx;
private final PreparedStatement fakeStmt = (PreparedStatement)
Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] {PreparedStatement.class}, this);
private boolean setNull;
private boolean setCalled;
SetNullHandler(StatementContext ctx) {
this.ctx = ctx;
}
private static Object defaultValue(Class<?> clazz) {
return Array.get(Array.newInstance(clazz, 1), 0);
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws SQLException {
if ("unwrap".equals(method.getName())
&& args.length == 1
&& method.getParameterTypes()[0].equals(Class.class)) {
throw new SQLException("The current implementation of DefineNamedBindings is incompatible with "
+ "arguments that rely on java.sql.Wrapper.unwrap(Class<?>)");
}
if ("getConnection".equals(method.getName())) {
return ctx.getConnection();
}
if (method.getName().startsWith("set")) {
setCalled = true;
boolean argNull = args.length > 1 && args[1] == null;
setNull = argNull || "setNull".equals(method.getName());
}
return DEFAULT_VALUES.get(method.getReturnType());
}
void define
```
<Overlap Ratio: 0.9922440537745605>

---

--- 116 --
Question ID: 7db28ce1d6d4756e539c17aa84d4ca1667e68f76_0
Original Code:
```
class CSharpNamespaceDetectorTest extends ResourceTest {
    @ParameterizedTest(name = "{index} => file={0}, expected package={1}")
    @CsvSource({
            "ActionBinding.cs, Avaloq.SmartClient.Utilities",
            "ActionBinding-Original-Formatting.cs, Avaloq.SmartClient.Utilities",
            "Program.cs, ConsoleApplication1", // see Jenkins-48869
            "Class1.cs, ConsoleApplication1",  // see Jenkins-48869
            "pom.xml, -",
            "MavenJavaTest.txt, -"})
    void shouldExtractPackageNameFromJavaSource(final String fileName, final String expectedPackage) throws IOException {
        try (InputStream stream = asInputStream(fileName)) {
            assertThat(new CSharpNamespaceDetector().detectPackageName(stream, StandardCharsets.UTF_8))
                    .isEqualTo(expectedPackage);
        }
    }

    @Test
    void shouldAcceptCorrectFileSuffix() {
        CSharpNamespaceDetector namespaceDetector = new CSharpNamespaceDetector();
        assertThat(namespaceDetector.accepts("ActionBinding.cs"))
                .as("Does not accept a C# file.").isTrue();
        assertThat(namespaceDetector.accepts("ActionBinding.cs.c"))
                .as("Accepts a non-C# file.").isFalse();
        assertThat(namespaceDetector.accepts("Action.java"))
                .as("Accepts a non-C# file.").isFalse();
        assertThat(namespaceDetector.accepts("pom.xml"))
                .as("Accepts a non-C# file.").isFalse();
    }
}
```


Overlapping Code:
```
spaceDetectorTest extends ResourceTest {
@ParameterizedTest(name = "{index} => file={0}, expected package={1}")
@CsvSource({
"ActionBinding.cs, Avaloq.SmartClient.Utilities",
"ActionBinding-Original-Formatting.cs, Avaloq.SmartClient.Utilities",
"Program.cs, ConsoleApplication1", // see Jenkins-48869
"Class1.cs, ConsoleApplication1", // see Jenkins-48869
"pom.xml, -",
"MavenJavaTest.txt, -"})
void shouldExtractPackageNameFromJavaSource(final String fileName, final String expectedPackage) throws IOException {
try (InputStream stream = asInputStream(fileName)) {
assertThat(new CSharpNamespaceDetector().detectPackageName(stream, StandardCharsets.UTF_8))
.isEqualTo(expectedPackage);
}
}
@Test
void shouldAcceptCorrectFileSuffix() {
CSharpNamespaceDetector namespaceDetector = new CSharpNamespaceDetector();
assertThat(namespaceDetector.accepts("ActionBinding.cs"))
.as("Does not accept a C# file.").isTrue();
assertThat(namespaceDetector.accepts("ActionBinding.cs.c"))
.as("Accepts a non-C# file.").isFalse();
assertThat(namespaceDetector.accepts("Action.java"))
.as("Accepts a non-C# file.").isFalse();
assertThat(namespaceDetector.accepts("pom.xml"))
.as("Accepts a non-C# file.").isFalse();
}

```
<Overlap Ratio: 0.9860312243221035>

---

--- 117 --
Question ID: e1c55e7a2cd83c8a168e344efd31b3994f31fe8e_0
Original Code:
```
public class SignatureKeyPair {
    SignaturePrivateKey priv;
    SignaturePublicKey pub;
    
    /**
     * Constructs a new key pair.
     * @param priv a private key
     * @param pub a public key
     */
    public SignatureKeyPair(SignaturePrivateKey priv, SignaturePublicKey pub) {
        this.priv = priv;
        this.pub = pub;
    }
    
    /**
     * Constructs a new key pair from a byte array
     * @param b an encoded key pair
     */
    public SignatureKeyPair(byte[] b) {
        this(new ByteArrayInputStream(b));
    }
    
    /**
     * Constructs a new key pair from an input stream
     * @param is an input stream
     * @throws NtruException if an {@link IOException} occurs
     */
    public SignatureKeyPair(InputStream is) {
        pub = new SignaturePublicKey(is);
        priv = new SignaturePrivateKey(is);
    }
    
    /**
     * Returns the private key
     * @return the private key
     */
    public SignaturePrivateKey getPrivate() {
        return priv;
    }
    
    /**
     * Returns the public key (verification key)
     * @return the public key
     */
    public SignaturePublicKey getPublic() {
        return pub;
    }

    /**
     * Tests if the key pair is valid.
     * @return <code>true</code> if the key pair is valid, <code>false</code> otherwise
     */
    public boolean isValid() {
        if (priv.N != pub.h.coeffs.length)
            return false;
        if (priv.q != pub.q)
            return false;
        
        int B = priv.getNumBases() - 1;
        for (int i=0; i<=B; i++) {
            Basis basis = priv.getBasis(i);
            if (!basis.isValid(i==0 ? pub.h : basis.h))
                return false;
        }
        
        return true;
    }
    
    /**
     * Converts the key pair to a byte array
     * @return the encoded key pair
     */
    public byte[] getEncoded() {
        byte[] pubArr = pub.getEncoded();
        byte[] privArr = priv.getEncoded();
        byte[] kpArr = Arrays.copyOf(pubArr, pubArr.length+privArr.length);
        System.arraycopy(privArr, 0, kpArr, pubArr.length, privArr.length);
        return kpArr;
    }
    
    /**
     * Writes the key pair to an output stream
     * @param os an output stream
     * @throws IOException
     */
    public void writeTo(OutputStream os) throws IOException {
        os.write(getEncoded());
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((priv == null) ? 0 : priv.hashCode());
        result = prime * result + ((pub == null) ? 0 : pub.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        SignatureKeyPair other = (SignatureKeyPair) obj;
        if (priv == null) {
            if (other.priv != null)
                return false;
        } else if (!priv.equals(other.priv))
            return false;
        if (pub == null) {
            if (other.pub != null)
                return false;
        } else if (!pub.equals(other.pub))
            return false;
        return true;
    }
}
```


Overlapping Code:
```
teKey priv;
SignaturePublicKey pub;

/**
* Constructs a new key pair.
* @param priv a private key
* @param pub a public key
*/
public SignatureKeyPair(SignaturePrivateKey priv, SignaturePublicKey pub) {
this.priv = priv;
this.pub = pub;
}

/**
* Constructs a new key pair from a byte array
* @param b an encoded key pair
*/
public SignatureKeyPair(byte[] b) {
this(new ByteArrayInputStream(b));
}

/**
* Constructs a new key pair from an input stream
* @param is an input stream
* @throws NtruException if an {@link IOException} occurs
*/
public SignatureKeyPair(InputStream is) {
pub = new SignaturePublicKey(is);
priv = new SignaturePrivateKey(is);
}

/**
* Returns the private key
* @return the private key
*/
public SignaturePrivateKey getPrivate() {
return priv;
}

/**
* Returns the public key (verification key)
* @return the public key
*/
public SignaturePublicKey getPublic() {
return pub;
}
/**
* Tests if the key pair is valid.
* @return <code>true</code> if the key pair is valid, <code>false</code> otherwise
*/
public boolean isValid() {
if (priv.N != pub.h.coeffs.length)
return false;
if (priv.q != pub.q)
return false;

int B = priv.getNumBases() - 1;
for (int i=0; i<=B; i++) {
Basis basis = priv.getBasis(i);
if (!basis.isValid(i==0 ? pub.h : basis.h))
return false;
}

return true;
}

/**
* Converts the key pair to a byte array
* @return the encoded key pair
*/
public byte[] getEncoded() {
byte[] pubArr = pub.getEncoded();
byte[] privArr = priv.getEncoded();
byte[] kpArr = Arrays.copyOf(pubArr, pubArr.length+privArr.length);
System.arraycopy(privArr, 0, kpArr, pubArr.length, privArr.length);
return kpArr;
}

/**
* Writes the key pair to an output stream
* @param os an output stream
* @throws IOException
*/
public void writeTo(OutputStream os) throws IOException {
os.write(getEncoded());
}

@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result +
```
<Overlap Ratio: 0.9765664798777381>

---

--- 118 --
Question ID: e146128b3182403def38213884871f2e8aab7bd5_0
Original Code:
```
public class ImageCompressorOptions {
    public static ImageCompressorOptions fromMap(ReadableMap map) {
        final ImageCompressorOptions options = new ImageCompressorOptions();
        final ReadableMapKeySetIterator iterator = map.keySetIterator();

        while (iterator.hasNextKey()) {
            final String key = iterator.nextKey();

            switch (key) {
                case "compressionMethod":
                     options.compressionMethod = CompressionMethod.valueOf(map.getString(key));
                      break;
                case "maxWidth":
                    options.maxWidth = map.getInt(key);
                    break;
                case "maxHeight":
                    options.maxHeight = map.getInt(key);
                    break;
                case "quality":
                    options.quality = (float) map.getDouble(key);
                    break;
                case "input":
                    options.input = InputType.valueOf(map.getString(key));
                    break;
                case "output":
                    options.output = OutputType.valueOf(map.getString(key));
                    break;
              case "returnableOutputType":
                options.returnableOutputType = ReturnableOutputType.valueOf(map.getString(key));
                break;
            }
        }

        return options;
    }

    public enum InputType {
        base64, uri
    }

    public enum OutputType {
        png, jpg
    }

  public enum ReturnableOutputType {
    base64, uri
  }

  public enum CompressionMethod {
    auto, manual
  }

    public CompressionMethod compressionMethod = CompressionMethod.manual;
    public int maxWidth = 1280;
    public int maxHeight = 1280;
    public float quality = 0.8f;
    public InputType input = InputType.uri;
    public OutputType output = OutputType.jpg;
    public ReturnableOutputType returnableOutputType = ReturnableOutputType.uri;
}
```


Overlapping Code:
```
atic ImageCompressorOptions fromMap(ReadableMap map) {
final ImageCompressorOptions options = new ImageCompressorOptions();
final ReadableMapKeySetIterator iterator = map.keySetIterator();
while (iterator.hasNextKey()) {
final String key = iterator.nextKey();
switch (key) {
case "compressionMethod":
options.compressionMethod = CompressionMethod.valueOf(map.getString(key));
break;
case "maxWidth":
options.maxWidth = map.getInt(key);
break;
case "maxHeight":
options.maxHeight = map.getInt(key);
break;
case "quality":
options.quality = (float) map.getDouble(key);
break;
case "input":
options.input = InputType.valueOf(map.getString(key));
break;
case "output":
options.output = OutputType.valueOf(map.getString(key));
break;
case "returnableOutputType":
options.returnableOutputType = ReturnableOutputType.valueOf(map.getString(key));
break;
}
}
return options;
}
public enum InputType {
base64, uri
}
public enum OutputType {
png, jpg
}
public enum ReturnableOutputType {
base64, uri
}
public enum CompressionMethod {
auto, manual
}
public CompressionMethod compressionMethod = CompressionMethod.manual;
public int maxWidth = 1280;
public int maxHeight = 1280;
public float quality = 0.8f;
public InputType input = InputType.uri;
public OutputType output = OutputType.jpg;
public ReturnableOutputType returnableOutputType = ReturnableOutputType.
```
<Overlap Ratio: 0.962223806129722>

---

--- 119 --
Question ID: 26aa466a9160fbc357adb29275d8a5b7e3d57c6b_0
Original Code:
```
class Problem01_GrayCodeTest {

    private final Problem01_GrayCode testObject = new Problem01_GrayCode();

    @Test
    void testGrayCode() {
        int n = 2;
        List<Integer> expected = Arrays.asList(0, 1, 3, 2);
        assertEquals(expected, testObject.grayCode(n));

        n = 1;
        expected = Arrays.asList(0, 1);
        assertEquals(expected, testObject.grayCode(n));
    }
}
```


Overlapping Code:
```
ss Problem01_GrayCodeTest {
private final Problem01_GrayCode testObject = new Problem01_GrayCode();
@Test
void testGrayCode() {
int n = 2;
List<Integer> expected = Arrays.asList(0, 1, 3, 2);
assertEquals(expected, testObject.grayCode(n));
n = 1;
expected = Arrays.asList(0, 1);
assertEquals(expected, testObject.
```
<Overlap Ratio: 0.9397590361445783>

---

--- 120 --
Question ID: 4bad9ae31b0d00617b43b8e06cb60143072e1a03_0
Original Code:
```
public class DragomeEntityManager
{
	protected static Map<String, Object> entities= new Hashtable<String, Object>();

	public static String add(Object entity)
	{
		String identityHashCode= getEntityId(entity);
		entities.put(identityHashCode, entity);
		return identityHashCode;
	}
	
	public static Object remove(Object entity)
	{
		String identityHashCode= getEntityId(entity);
		return entities.remove(identityHashCode);
	}


	public static Object get(String id)
	{
		return entities.get(id);
	}

	public static String getEntityId(Object object)
	{
		return System.identityHashCode(object) + "";
	}

	public static void clear()
	{
		entities.clear();
	}
}
```


Overlapping Code:
```
class DragomeEntityManager
{
protected static Map<String, Object> entities= new Hashtable<String, Object>();
public static String add(Object entity)
{
String identityHashCode= getEntityId(entity);
entities.put(identityHashCode, entity);
return identityHashCode;
}

public static Object remove(Object entity)
{
String identityHashCode= getEntityId(entity);
return entities.remove(identityHashCode);
}
public static Object get(String id)
{
return entities.get(id);
}
public static String getEntityId(Object object)
{
return System.identityHashCode(object) + "";
}
public static void clear()
{
entities.
```
<Overlap Ratio: 0.9693053311793215>

---

--- 121 --
Question ID: bce37b2816d68aa631aa52752c26dea498b575a6_0
Original Code:
```
public abstract class JOGLGLWindow extends J2SEWindow
        implements GLEventListener, MouseListener, MouseMotionListener, java.awt.event.MouseListener,
        com.jogamp.newt.event.WindowListener,
        KeyListener, WindowListener {

    private boolean alwaysOnTop = false;
    private boolean mouseVisible = true;
    private boolean mouseConfined = false;
    private boolean autoSwapBuffer = false;
    protected volatile boolean contextCreated = false;
    protected GLCanvas canvas;
    protected Frame frame;
    protected GLWindow glWindow;
    Animator animator;
    private Hashtable<Integer, Integer> AWTKeycodes;

    /**
     * Creates a new JOGL window with the specified {@link CoreAppStarter} and swapinterval
     * 
     * @throws IllegalArgumentException If coreAppStarter is null
     */
    public JOGLGLWindow(BackendFactory factory, CoreAppStarter coreAppStarter, PropertySettings appSettings) {
        super(factory, coreAppStarter, appSettings);
    }

    @Override
    public VideoMode init(PropertySettings appSettings) {
        version = appSettings.version;
        if (coreAppStarter == null) {
            throw new IllegalArgumentException("CoreAppStarter is null");
        }
        switch (appSettings.windowType) {
            case NEWT:
                createNEWTWindow(appSettings);
                break;
            case JAWT:
                createAWTWindow(appSettings);
                break;
            default:
                throw new IllegalArgumentException("Invalid windowtype for JOGL: " + appSettings.windowType);
        }

        /**
         * Fetch jogamp.newt fields that start with VK_ and store keycodes in array to convert to AWT values.
         */
        AWTKeycodes = getAWTFields();
        return new VideoMode(appSettings.width, appSettings.height, appSettings.fullscreen, appSettings.swapInterval);
    }

    private Hashtable<Integer, Integer> getAWTFields() {
        Hashtable<Integer, Integer> awtFields = new Hashtable<>();
        for (Field newtField : com.jogamp.newt.event.KeyEvent.class.getDeclaredFields()) {
            if (java.lang.reflect.Modifier.isStatic(newtField.getModifiers())) {
                String fieldName = newtField.getName();
                if (fieldName.startsWith("VK_")) {
                    try {
                        Field awtField = java.awt.event.KeyEvent.class.getField(fieldName);
                        int newtKeyCode = newtField.getShort(null) & 0xffff;
                        int awtKeyCode = awtField.getInt(null);
                        awtFields.put(newtKeyCode, awtKeyCode);
                    } catch (NoSuchFieldException | IllegalAccessException e) {
                        SimpleLogger.d(getClass(), e.toString());
                    }
                }
            }
        }
        return awtFields;
    }

    protected GLProfile getProfile(Renderers version) {
        SimpleLogger.d(getClass(), "os.and.arch: " + Platform.os_and_arch);
        GLProfile defaultProfile = null;
        try {
            defaultProfile = GLProfile.getDefault();
            if (defaultProfile != null) {
                SimpleLogger.d(getClass(), "Default profile implName: " + defaultProfile.getImplName() + ", name: "
                        + defaultProfile.getName());
            } else {
                SimpleLogger.d(getClass(), "Default profile is NULL");
            }
        } catch (Throwable t) {
            // Not much to do
            SimpleLogger.d(getClass(), "Internal error when fetching default profile");
        }
        GLProfile profile = null;
        switch (version) {
            case GLES20:
                if (defaultProfile != null && (defaultProfile.isGLES2() || defaultProfile.isGL2ES2())) {
                    profile = defaultProfile;
                } else {
                    profile = GLProfile.get(GLProfile.GL2ES2);
                }
                break;
            case GLES30:
            case GLES31:
            case GLES32:
                if (defaultProfile != null && (defaultProfile.isGLES3() || defaultProfile.isGL4ES3())) {
                    profile = defaultProfile;
                } else {
                    profile = GLProfile.get(GLProfile.GL4ES3);
                }
                break;
            default:
                throw new IllegalArgumentException("Invalid version " + version);
        }
        return profile;
    }

    /**
     * Creates the JOGL display and OpenGLES
     * 
     * @param width
     * @param height
     * @param profile
     * @version
     */
    private void createNEWTWindow(PropertySettings appSettings) {
        GLProfile profile = getProfile(appSettings.version);
        SurfaceConfiguration config = appSettings.getConfiguration();
        GLProfile.initSingleton();
        GLCapabilities glCapabilities = new GLCapabilities(profile);
        glCapabilities.setSampleBuffers(config.getSamples() > 0);
        glCapabilities.setNumSamples(config.getSamples());
        glCapabilities.setBackgroundOpaque(true);
        glCapabilities.setAlphaBits(0);
        glWindow = GLWindow.create(glCapabilities);
        glWindow.setUndecorated(appSettings.windowUndecorated);
        InsetsImmutable insets = glWindow.getInsets();
        glWindow.setSize(
                appSettings.windowUndecorated ? appSettings.width
                        : appSettings.width + insets.getTotalWidth(),
                appSettings.windowUndecorated ? appSettings.height
                        : appSettings.height + insets.getTotalHeight());
        glWindow.setAlwaysOnTop(alwaysOnTop);
        glWindow.setPointerVisible(mouseVisible);
        glWindow.confinePointer(mouseConfined);
        glWindow.addMouseListener(this);
        glWindow.addWindowListener(this);
        glWindow.addKeyListener(this);
        glWindow.addWindowListener(this);
        glWindow.addGLEventListener(this);
        glWindow.setFullscreen(appSettings.fullscreen);
        animator = new Animator();
        animator.add(glWindow);
        animator.start();
        glWindow.setAutoSwapBufferMode(autoSwapBuffer);

    }

    private void createAWTWindow(PropertySettings appSettings) {
        GLProfile profile = getProfile(appSettings.version);
        GLProfile.initSingleton();
        GLCapabilities caps = new GLCapabilities(profile);
        caps.setBackgroundOpaque(true);
        caps.setAlphaBits(0);
        // glWindow = GLWindow.create(caps);
        frame = new java.awt.Frame("Nucleus");
        frame.setSize(appSettings.width, appSettings.height);
        frame.setLayout(new java.awt.BorderLayout());
        canvas = new GLCanvas(caps);
        canvas.addGLEventListener(this);
        frame.add(canvas, java.awt.BorderLayout.CENTER);
        frame.validate();
        frame.addWindowListener(this);
        animator = new Animator();
        animator.add(canvas);
        animator.start();
        canvas.setAutoSwapBufferMode(autoSwapBuffer);
        canvas.addMouseListener(this);
        canvas.addMouseMotionListener(this);
    }

    @Override
    public void setWindowTitle(String title) {
        if (frame != null) {
            frame.setTitle(title);
        }
        if (glWindow != null) {
            glWindow.setTitle(title);
        }
    }

    public void setGLEVentListener() {
        if (glWindow != null) {
            glWindow.addGLEventListener(this);
        }
        if (canvas != null) {
            canvas.addGLEventListener(this);
        }
    }

    @Override
    public void setVisible(boolean visible) {
        if (glWindow != null) {
            glWindow.setVisible(visible);
        }
        if (frame != null) {
            frame.setVisible(visible);
        }

    }

    @Override
    public void init(GLAutoDrawable drawable) {
        internalCreateCoreApp(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());
        drawable.swapBuffers();
        drawable.getGL().setSwapInterval(videoMode.getSwapInterval());
        internalContextCreated(drawable.getSurfaceWidth(), drawable.getSurfaceHeight());
    }

    @Override
    public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
        SimpleLogger.d(getClass(), "reshape: x,y= " + x + ", " + y + " width,height= " + width + ", " + height);
    }

    @Override
    public void display(GLAutoDrawable drawable) {
        if (!autoSwapBuffer) {
            coreApp.renderFrame();
            if (glWindow != null) {
                glWindow.swapBuffers();
            } else if (canvas != null) {
                canvas.swapBuffers();
            }
        }
    }

    protected void handleMouseEvent(MouseEvent e, PointerAction action) {
        int[] xpos = e.getAllX();
        int[] ypos = e.getAllY();
        int count = e.getPointerCount();
        Type type = Type.STYLUS;
        for (int i = 0; i < count; i++) {
            switch (e.getButton()) {
                case MouseEvent.BUTTON1:
                    type = Type.MOUSE;
                    break;
                case MouseEvent.BUTTON2:
                    type = Type.MOUSE;
                    break;
                case MouseEvent.BUTTON3:
                    type = Type.MOUSE;
                    break;
                case MouseEvent.BUTTON4:
                    type = Type.MOUSE;
                    break;
                case MouseEvent.BUTTON5:
                    type = Type.MOUSE;
                    break;
                case MouseEvent.BUTTON6:
                    type = Type.MOUSE;
                    break;
            }
            handleMouseEvent(action, type, xpos[i], ypos[i], e.getPointerId(i), e.getWhen());
        }
    }

    protected void handleKeyEvent(KeyEvent event) {
        /**
         * com.jogamp.newt.event.KeyEvent keycodes are the same as the AWT KeyEvent keycodes.
         */
        SimpleLogger.d(getClass(), "KeyEvent " + event.getEventType() + " : " + event.getKeyCode());
        switch (event.getEventType()) {
            case KeyEvent.EVENT_KEY_PRESSED:
                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.PRESSED,
                        AWTKeycodes.get((int) event.getKeyCode())));
                switch (event.getKeyCode()) {
                    case KeyEvent.VK_ESCAPE:
                        onBackPressed();
                }
                break;
            case KeyEvent.EVENT_KEY_RELEASED:
                super.handleKeyEvent(new com.nucleus.mmi.Key(Action.RELEASED,
                        AWTKeycodes.get((int) event.getKeyCode())));
                break;
            default:
                // Do nothing
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void mouseEntered(MouseEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void mouseExited(MouseEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void mousePressed(MouseEvent e) {
        handleMouseEvent(e, PointerAction.DOWN);
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        handleMouseEvent(e, PointerAction.UP);
    }

    @Override
    public void mouseMoved(MouseEvent e) {
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        handleMouseEvent(e, PointerAction.MOVE);
    }

    @Override
    public void mouseWheelMoved(MouseEvent e) {
        mouseWheelMoved(e.getRotation()[1], e.getWhen());
    }

    @Override
    public void mouseDragged(java.awt.event.MouseEvent e) {
        handleMouseEvent(PointerAction.MOVE, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());
    }

    @Override
    public void mouseMoved(java.awt.event.MouseEvent e) {
        // TODO Auto-generated method stub
    }

    @Override
    public void mouseClicked(java.awt.event.MouseEvent e) {

    }

    @Override
    public void mousePressed(java.awt.event.MouseEvent e) {
        handleMouseEvent(PointerAction.DOWN, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());
    }

    @Override
    public void mouseReleased(java.awt.event.MouseEvent e) {
        handleMouseEvent(PointerAction.UP, Type.MOUSE, e.getX(), e.getX(), Pointer.POINTER_1, e.getWhen());
    }

    @Override
    public void mouseEntered(java.awt.event.MouseEvent e) {

    }

    @Override
    public void mouseExited(java.awt.event.MouseEvent e) {
    }

    @Override
    public void windowResized(WindowEvent e) {
    }

    @Override
    public void windowMoved(WindowEvent e) {
    }

    @Override
    public void windowDestroyNotify(WindowEvent e) {
        windowClosed();
    }

    @Override
    public void windowDestroyed(WindowEvent e) {
        windowClosed();
    }

    @Override
    public void windowGainedFocus(WindowEvent e) {
    }

    @Override
    public void windowLostFocus(WindowEvent e) {
    }

    @Override
    public void windowRepaint(WindowUpdateEvent e) {
    }

    @Override
    public void windowOpened(java.awt.event.WindowEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void windowClosing(java.awt.event.WindowEvent e) {
        SimpleLogger.d(getClass(), "Window closing");
        windowClosed();
    }

    @Override
    public void windowClosed(java.awt.event.WindowEvent e) {
        SimpleLogger.d(getClass(), "Window closed");
    }

    @Override
    public void windowIconified(java.awt.event.WindowEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void windowDeiconified(java.awt.event.WindowEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void windowActivated(java.awt.event.WindowEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void windowDeactivated(java.awt.event.WindowEvent e) {
        // TODO Auto-generated method stub

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {
            handleKeyEvent(e);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        if ((e.getModifiers() & InputEvent.AUTOREPEAT_MASK) == 0) {
            handleKeyEvent(e);
        }
    }

    @Override
    public VideoMode setVideoMode(VideoMode videoMode, int monitorIndex) {
        switch (windowType) {
            case JAWT:
                break;
            case NEWT:
                glWindow.setFullscreen(videoMode.isFullScreen());
                break;
            default:
                throw new IllegalArgumentException("Invalid windowtype: " + windowType);
        }
        return videoMode;
    }

    @Override
    public void destroy() {
        if (animator != null) {
            animator.stop();
        }
    }

}
```


Overlapping Code:
```
s JOGLGLWindow extends J2SEWindow
implements GLEventListener, MouseListener, MouseMotionListener, java.awt.event.MouseListener,
com.jogamp.newt.event.WindowListener,
KeyListener, WindowListener {
private boolean alwaysOnTop = false;
private boolean mouseVisible = true;
private boolean mouseConfined = false;
private boolean autoSwapBuffer = false;
protected volatile boolean contextCreated = false;
protected GLCanvas canvas;
protected Frame frame;
protected GLWindow glWindow;
Animator animator;
private Hashtable<Integer, Integer> AWTKeycodes;
/**
* Creates a new JOGL window with the specified {@link CoreAppStarter} and swapinterval
* 
* @throws IllegalArgumentException If coreAppStarter is null
*/
public JOGLGLWindow(BackendFactory factory, CoreAppStarter coreAppStarter, PropertySettings appSettings) {
super(factory, coreAppStarter, appSettings);
}
@Override
public VideoMode init(PropertySettings appSettings) {
version = appSettings.version;
if (coreAppStarter == null) {
throw new IllegalArgumentException("CoreAppStarter is null");
}
switch (appSettings.windowType) {
case NEWT:
createNEWTWindow(appSettings);
break;
case JAWT:
createAWTWindow(appSettings);
break;
default:
throw new IllegalArgumentException("Invalid windowtype for JOGL: " + appSettings.windowType);
}
/**
* Fetch jogamp.newt fields that start with VK_ and store keycodes in array to convert to AWT values.
*/
AWTKeycodes = getAWTFields();
return new VideoMode(appSettings.width, appSettings.height, appSettings.fullscreen, appSettings.swapInterval);
}
private Hashtable<Integer, Integer> getAWTFields() {
Hashtable<Integer, Integer> awtFields = new Hashtable<>();
for (Field newtField : com.jogamp.newt.event.KeyEvent.class.getDeclaredFields()) {
if (java.lang.reflect.Modifier.isStatic(newtField.getModifiers())) {
String fieldName = newtField.getName();
if (fieldName.startsWith("VK_")) {
try {
Field awtField = java.awt.event.KeyEvent.class.getField(fieldName);
int newtKeyCode = newtField.getShort(null) & 0xffff;
```
<Overlap Ratio: 0.9900990099009901>

---

--- 122 --
Question ID: ee1daddd0b9026a345a6b60439b4b644bd27a360_0
Original Code:
```
public class NamedQueriesBeanDefinitionBuilder {

	private final String defaultLocation;
	private String locations;

	/**
	 * Creates a new {@link NamedQueriesBeanDefinitionBuilder} using the given default location.
	 *
	 * @param defaultLocation must not be {@literal null} or empty.
	 */
	@SuppressWarnings("null")
	public NamedQueriesBeanDefinitionBuilder(String defaultLocation) {

		Assert.hasText(defaultLocation, "DefaultLocation must not be null nor empty!");
		this.defaultLocation = defaultLocation;
	}

	/**
	 * Sets the (comma-separated) locations to load the properties files from to back the {@link NamedQueries} instance.
	 *
	 * @param locations must not be {@literal null} or empty.
	 */
	public void setLocations(String locations) {

		Assert.hasText(locations, "Locations must not be null nor empty!");

		this.locations = locations;
	}

	/**
	 * Builds a new {@link BeanDefinition} from the given source.
	 *
	 * @param source
	 * @return
	 */
	public BeanDefinition build(@Nullable Object source) {

		BeanDefinitionBuilder properties = BeanDefinitionBuilder.rootBeanDefinition(PropertiesFactoryBean.class);

		String locationsToUse = StringUtils.hasText(locations) ? locations : defaultLocation;
		properties.addPropertyValue("locations", locationsToUse);

		if (!StringUtils.hasText(locations)) {
			properties.addPropertyValue("ignoreResourceNotFound", true);
		}

		AbstractBeanDefinition propertiesDefinition = properties.getBeanDefinition();
		propertiesDefinition.setSource(source);

		BeanDefinitionBuilder namedQueries = BeanDefinitionBuilder.rootBeanDefinition(PropertiesBasedNamedQueries.class);
		namedQueries.addConstructorArgValue(propertiesDefinition);

		AbstractBeanDefinition namedQueriesDefinition = namedQueries.getBeanDefinition();
		namedQueriesDefinition.setSource(source);

		return namedQueriesDefinition;
	}
}
```


Overlapping Code:
```
BeanDefinitionBuilder {
private final String defaultLocation;
private String locations;
/**
* Creates a new {@link NamedQueriesBeanDefinitionBuilder} using the given default location.
*
* @param defaultLocation must not be {@literal null} or empty.
*/
@SuppressWarnings("null")
public NamedQueriesBeanDefinitionBuilder(String defaultLocation) {
Assert.hasText(defaultLocation, "DefaultLocation must not be null nor empty!");
this.defaultLocation = defaultLocation;
}
/**
* Sets the (comma-separated) locations to load the properties files from to back the {@link NamedQueries} instance.
*
* @param locations must not be {@literal null} or empty.
*/
public void setLocations(String locations) {
Assert.hasText(locations, "Locations must not be null nor empty!");
this.locations = locations;
}
/**
* Builds a new {@link BeanDefinition} from the given source.
*
* @param source
* @return
*/
public BeanDefinition build(@Nullable Object source) {
BeanDefinitionBuilder properties = BeanDefinitionBuilder.rootBeanDefinition(PropertiesFactoryBean.class);
String locationsToUse = StringUtils.hasText(locations) ? locations : defaultLocation;
properties.addPropertyValue("locations", locationsToUse);
if (!StringUtils.hasText(locations)) {
properties.addPropertyValue("ignoreResourceNotFound", true);
}
AbstractBeanDefinition propertiesDefinition = properties.getBeanDefinition();
propertiesDefinition.setSource(source);
BeanDefinitionBuilder namedQueries = BeanDefinitionBuilder.rootBeanDefinition(PropertiesBasedNamedQueries.class);
namedQueries.addConstructorArgValue(propertiesDefinition);
AbstractBeanDefinition namedQueriesDefinition = namedQueries.getBeanDefinition();
namedQueriesDefinition.setSource(source)
```
<Overlap Ratio: 0.9655172413793104>

---

--- 123 --
Question ID: a6d523b703659dc6debf0ce356a2e5cdb450a35a_0
Original Code:
```
public class MOCL {
    @Deprecated // use clij2 instead
    CLIJ clij;

    CLIJ2 clij2;
    MOCL(CLIJ2 clij2, CLIJ clij) {
        this.clij2 = clij2;
        this.clij = clij;
    }


    public MOCLBuffer imhist(MOCLBuffer input, int numberOfBins) {
        float minimumGreyValue = (new Double(clij2.minimumOfAllPixels(input.buffer))).floatValue();
        float maximumGreyValue = (new Double(clij2.maximumOfAllPixels(input.buffer))).floatValue();

        ClearCLBuffer histogram = clij2.create(new long[]{(long)numberOfBins, 1L, 1L}, NativeTypeEnum.Float);
        clij2.fillHistogram(input.buffer, histogram, minimumGreyValue, maximumGreyValue);

        return new MOCLBuffer(this, histogram);
    }

    public MOCLBuffer fliplr(MOCLBuffer input) {
        ClearCLBuffer output = clij2.create(input.buffer);
        if (input.buffer.getDimension() == 2) {
            clij2.flip(input.buffer, output, true, false);
        } else {
            clij2.flip(input.buffer, output, true, false, false);
        }
        return new MOCLBuffer(this, output);
    }

    public MOCLBuffer imRead(String imageFile) {
        ImagePlus imp = IJ.openImage(imageFile);
        return new MOCLBuffer(this, clij2.convert(imp, ClearCLBuffer.class));
    }

    public double min(MOCLBuffer input) {
        return clij2.minimumOfAllPixels(input.buffer);
    }

    public double max(MOCLBuffer input) {
        return clij2.maximumOfAllPixels(input.buffer);
    }

    public double mean(MOCLBuffer input) {
        return clij2.sumPixels(input.buffer) / input.buffer.getWidth() / input.buffer.getHeight() / input.buffer.getDepth();
    }

    public MOCLBuffer ones(int numberOfElementsX) {
        ClearCLBuffer buffer = anys(numberOfElementsX).buffer;
        clij2.set(buffer, 1f);
        return new MOCLBuffer(this, buffer);
    }

    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY) {
        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;
        clij2.set(buffer, 1f);
        return new MOCLBuffer(this, buffer);
    }

    public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {
        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;
        clij2.set(buffer, 1f);
        return new MOCLBuffer(this, buffer);
    }

    public MOCLBuffer zeros(int numberOfElements) {
        ClearCLBuffer buffer = anys(numberOfElements).buffer;
        clij2.set(buffer, 0f);
        return new MOCLBuffer(this, buffer);
    }

    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY) {
        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;
        clij2.set(buffer, 0f);
        return new MOCLBuffer(this, buffer);
    }

    public MOCLBuffer zeros(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {
        ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;
        clij2.set(buffer, 0f);
        return new MOCLBuffer(this, buffer);
    }


    public MOCLBuffer anys(int... numberOfElements) {
        long[] dimensions = new long[Math.max(Math.min(numberOfElements.length, 3), 2)];
        for (int i = 0; i < dimensions.length; i++) {
            if (i < numberOfElements.length) {
                dimensions[i] = numberOfElements[i];
            } else {
                dimensions[i] = dimensions[0];
            }
        }
        return new MOCLBuffer(this, clij2.create(dimensions, NativeTypeEnum.Float));
    }

    public long[] size(MOCLBuffer input) {
        return clij2.getSize(input.buffer);
    }

    public MOCLBuffer colon(int min, int max) {
        System.out.println("MOCL colon2");
        ClearCLBuffer intensities = clij2.create(new long[]{max-min + 1, 1}, NativeTypeEnum.Float);
        ClearCLBuffer temp = clij2.create(intensities);
        clij2.set(intensities, 1f);
        clij2.multiplyImageAndCoordinate(intensities, temp, 0);
        clij2.addImageAndScalar(temp, intensities, new Float(min));
        temp.close();
        return new MOCLBuffer(this, intensities);
    }

    public MOCLBuffer colon(int min, int step, int max) {
        System.out.println("MOCL colon3");
        ClearCLBuffer intensities = clij2.create(new long[]{(max-min)/step + 1, 1}, NativeTypeEnum.Float);
        ClearCLBuffer temp = clij2.create(intensities);
        clij2.set(intensities, 1f);
        clij2.multiplyImageAndCoordinate(intensities, temp, 0);
        clij2.multiplyImageAndScalar(temp, intensities, new Float(step));
        clij2.addImageAndScalar(intensities, temp, new Float(min));
        intensities.close();
        return new MOCLBuffer(this, temp);
    }

    public MOCLBuffer push(Object object) {
        if (object instanceof MOCLBuffer) {
            return (MOCLBuffer)object;
        }
        if (object instanceof double[][][]) {
            Double3 double3 = new Double3((double[][][])object);
            System.out.println("d3 size: " + double3.data.length + "/" + double3.data[0].length + "/" + double3.data[0][0].length );
            Double3ToClearCLBufferConverter converter = new Double3ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(double3));
        }
        if (object instanceof double[][]) {
            Double2 double2 = new Double2((double[][])object);
            System.out.println("d2 size: " + double2.data.length + "/" + double2.data[0].length );
            Double2ToClearCLBufferConverter converter = new Double2ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(double2));
        }
        if (object instanceof double[]) {
            Double1 double1 = new Double1((double[])object);
            System.out.println("d1 size: " + double1.data.length );
            Double1ToClearCLBufferConverter converter = new Double1ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(double1));
        }
        if (object instanceof byte[][][]) {
            Byte3 byte3 = new Byte3((byte[][][])object);
            System.out.println("b3 size: " + byte3.data.length + "/" + byte3.data[0].length + "/" + byte3.data[0][0].length );
            Byte3ToClearCLBufferConverter converter = new Byte3ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(byte3));
        }
        if (object instanceof byte[][]) {
            Byte2 byte2 = new Byte2((byte[][])object);
            System.out.println("b2 size: " + byte2.data.length + "/" + byte2.data[0].length );
            Byte2ToClearCLBufferConverter converter = new Byte2ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(byte2));
        }
        if (object instanceof byte[]) {
            Byte1 byte1 = new Byte1((byte[])object);
            System.out.println("b1 size: " + byte1.data.length);
            Byte1ToClearCLBufferConverter converter = new Byte1ToClearCLBufferConverter();
            converter.setCLIJ(clij);
            return new MOCLBuffer(this, converter.convert(byte1));
        }
        throw new IllegalArgumentException("Conversion of " + object +
                " / " + object.getClass().getName() + " not supported");
    }

    public Object pull(MOCLBuffer input) {
        return pull(input.buffer);
    }
    public Object pull(ClearCLBuffer buffer) {
        if (buffer.getNativeType() == NativeTypeEnum.Float) {
            if (buffer.getDimension() == 2) {
                return new ClearCLBufferToDouble2Converter().convert(buffer).data;
            }
            if (buffer.getDimension() == 3) {
                return new ClearCLBufferToDouble3Converter().convert(buffer).data;
            }
        }

        throw new IllegalArgumentException("Conversion of " + buffer +
                " / " + buffer.getClass().getName() + " not supported");
    }
}
```


Overlapping Code:
```
ted // use clij2 instead
CLIJ clij;
CLIJ2 clij2;
MOCL(CLIJ2 clij2, CLIJ clij) {
this.clij2 = clij2;
this.clij = clij;
}
public MOCLBuffer imhist(MOCLBuffer input, int numberOfBins) {
float minimumGreyValue = (new Double(clij2.minimumOfAllPixels(input.buffer))).floatValue();
float maximumGreyValue = (new Double(clij2.maximumOfAllPixels(input.buffer))).floatValue();
ClearCLBuffer histogram = clij2.create(new long[]{(long)numberOfBins, 1L, 1L}, NativeTypeEnum.Float);
clij2.fillHistogram(input.buffer, histogram, minimumGreyValue, maximumGreyValue);
return new MOCLBuffer(this, histogram);
}
public MOCLBuffer fliplr(MOCLBuffer input) {
ClearCLBuffer output = clij2.create(input.buffer);
if (input.buffer.getDimension() == 2) {
clij2.flip(input.buffer, output, true, false);
} else {
clij2.flip(input.buffer, output, true, false, false);
}
return new MOCLBuffer(this, output);
}
public MOCLBuffer imRead(String imageFile) {
ImagePlus imp = IJ.openImage(imageFile);
return new MOCLBuffer(this, clij2.convert(imp, ClearCLBuffer.class));
}
public double min(MOCLBuffer input) {
return clij2.minimumOfAllPixels(input.buffer);
}
public double max(MOCLBuffer input) {
return clij2.maximumOfAllPixels(input.buffer);
}
public double mean(MOCLBuffer input) {
return clij2.sumPixels(input.buffer) / input.buffer.getWidth() / input.buffer.getHeight() / input.buffer.getDepth();
}
public MOCLBuffer ones(int numberOfElementsX) {
ClearCLBuffer buffer = anys(numberOfElementsX).buffer;
clij2.set(buffer, 1f);
return new MOCLBuffer(this, buffer);
}
public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY) {
ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY).buffer;
clij2.set(buffer, 1f);
return new MOCLBuffer(this, buffer);
}
public MOCLBuffer ones(int numberOfElementsX, int numberOfElementsY, int numberOfElementsZ) {
ClearCLBuffer buffer = anys(numberOfElementsX, numberOfElementsY, numberOfElementsZ).buffer;
clij2.set(buffer, 1f);
return new MOCLBuffer(this, buffer);
}
public MOCLBuffer zeros(int numberOfElements) {
ClearCLBuffer buffer = anys(numberOfElements).buffer;
clij2.s
```
<Overlap Ratio: 0.9808500700607193>

---

--- 124 --
Question ID: 4483e31236019de9aecf45fd88f1dfa7b37b5d8d_0
Original Code:
```
public class Factory {

    public static ChatImpl createChat(SkypeImpl client, String identity) throws ConnectionException, ChatNotFoundException {
        Validate.notNull(client, "Client must not be null");
        Validate.notEmpty(identity, "Identity must not be null/empty");

        ChatImpl result = null;

        if (identity.startsWith("19:")) {
            if (identity.endsWith("@thread.skype")) {
                result = new ChatGroup(client, identity);
            } else if (identity.endsWith("@p2p.thread.skype")) {
                result = new ChatP2P(client, identity);
            }
        } else if (identity.startsWith("8:")) {
            result = new ChatIndividual(client, identity);
        } else if (identity.startsWith("28:")) {
            result = new ChatBot(client, identity);
        }

        if (result != null) {
            result.load();
            return result;
        }

        throw new IllegalArgumentException(String.format("Unknown chat type with identity %s", identity));
    }

    public static ParticipantImpl createParticipant(SkypeImpl client, ChatImpl chat, String id) throws ConnectionException {
        Validate.notNull(client, "Client must not be null");
        Validate.notNull(chat, "Chat must not be null");
        Validate.notEmpty(id, "Identity must not be null/empty");

        ParticipantImpl result = null;

        if (id.startsWith("8:")) {
            result = new UserImpl(client, chat, id);
        } else if (id.startsWith("28:")) {
            result = new BotImpl(client, chat, id);
        }

        if (result != null) {
            return result;
        }

        throw new IllegalArgumentException(String.format("Unknown participant type with id %s", id));
    }

    public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) throws ConnectionException {
        Validate.notNull(chat, "Chat must not be null");
        Validate.isTrue(chat instanceof ChatImpl, "Chat must be instanceof ChatImpl");
        Validate.notNull(user, "User must not be null");

        if (("8:" + chat.getClient().getUsername()).equals(user.getId())) {
            return new SentMessageImpl(chat, user, id, clientId, time, message, skype);
        } else {
            return new ReceivedMessageImpl(chat, user, id, clientId, time, message, skype);
        }
    }
}
```


Overlapping Code:
```
public static ChatImpl createChat(SkypeImpl client, String identity) throws ConnectionException, ChatNotFoundException {
Validate.notNull(client, "Client must not be null");
Validate.notEmpty(identity, "Identity must not be null/empty");
ChatImpl result = null;
if (identity.startsWith("19:")) {
if (identity.endsWith("@thread.skype")) {
result = new ChatGroup(client, identity);
} else if (identity.endsWith("@p2p.thread.skype")) {
result = new ChatP2P(client, identity);
}
} else if (identity.startsWith("8:")) {
result = new ChatIndividual(client, identity);
} else if (identity.startsWith("28:")) {
result = new ChatBot(client, identity);
}
if (result != null) {
result.load();
return result;
}
throw new IllegalArgumentException(String.format("Unknown chat type with identity %s", identity));
}
public static ParticipantImpl createParticipant(SkypeImpl client, ChatImpl chat, String id) throws ConnectionException {
Validate.notNull(client, "Client must not be null");
Validate.notNull(chat, "Chat must not be null");
Validate.notEmpty(id, "Identity must not be null/empty");
ParticipantImpl result = null;
if (id.startsWith("8:")) {
result = new UserImpl(client, chat, id);
} else if (id.startsWith("28:")) {
result = new BotImpl(client, chat, id);
}
if (result != null) {
return result;
}
throw new IllegalArgumentException(String.format("Unknown participant type with id %s", id));
}
public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) throws ConnectionException {
Validate.notNull(chat, "Chat must not be null");
Validate.isTrue(chat instanceof ChatImpl, "Chat must be instanceof ChatImpl");
Validate.notNull(user, "User must not be null");
if (("8:" + chat.getClient().getUsername()).equals(user.getId())) {
return new SentMessageImpl(chat, user, id, clientId, time, message, skype);
} else {
return new ReceivedMessageImpl(chat, user, id, cl
```
<Overlap Ratio: 0.9706321553011449>

---

--- 125 --
Question ID: 7a080dc263b61a87e167758217177a0cd3c56480_0
Original Code:
```
@WebServlet(description = "Login servlet", urlPatterns = { "/login" })
public class Login extends HttpServlet {
	private static final long serialVersionUID = 4815162342L;
	private static Logger logger = Logger.getLogger(Login.class.getName());

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/WEB-INF/jsps/login.jsp");
        dispatcher.forward(request, response);
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		boolean success = false;
		String id = request.getParameter("id");
		String password = request.getParameter("password");

		try {
			if (request.getUserPrincipal() != null) request.logout(); //in case there's a left over auth cookie but we ended up here

			request.login(id, password);

			Cookie cookie = new Cookie("user", id); //clear text user id that can be used in Istio routing rules
			response.addCookie(cookie);

			success = true;
			logger.info("Successfully logged in user: "+id);
		} catch (Throwable t) {
			logException(t);
		}

		String url = "error";
		if (success) url = "summary";

		response.sendRedirect(url);
	}

	private void logException(Throwable t) {
		logger.warning(t.getClass().getName()+": "+t.getMessage());

		//only log the stack trace if the level has been set to at least FINE
		if (logger.isLoggable(Level.FINE)) {
			StringWriter writer = new StringWriter();
			t.printStackTrace(new PrintWriter(writer));
			logger.fine(writer.toString());
		}
	}
}
```


Overlapping Code:
```
let(description = "Login servlet", urlPatterns = { "/login" })
public class Login extends HttpServlet {
private static final long serialVersionUID = 4815162342L;
private static Logger logger = Logger.getLogger(Login.class.getName());
/**
* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
*/
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/WEB-INF/jsps/login.jsp");
dispatcher.forward(request, response);
}
/**
* @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
*/
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
boolean success = false;
String id = request.getParameter("id");
String password = request.getParameter("password");
try {
if (request.getUserPrincipal() != null) request.logout(); //in case there's a left over auth cookie but we ended up here
request.login(id, password);
Cookie cookie = new Cookie("user", id); //clear text user id that can be used in Istio routing rules
response.addCookie(cookie);
success = true;
logger.info("Successfully logged in user: "+id);
} catch (Throwable t) {
logException(t);
}
String url = "error";
if (success) url = "summary";
response.sendRedirect(url);
}
private void logException(Throwable t) {
logger.warning(t.getClass().getName()+": "+t.getMessage());
//only log the stack trace if the level has been set to at least FINE
if (logger.isLoggable(Level.FINE)) {
StringWriter writer = new StringWriter();
t.printStackTrace(new PrintWriter(writer));
logger.fine(writer.toString());
}
}
```
<Overlap Ratio: 0.994199535962877>

---

--- 126 --
Question ID: 13a95c5a4baf8cfcab37776de31ce155fd66c37a_0
Original Code:
```
public class HTree<T> {
    private final HNode<T> root;

    public HTree() {
        root = new HNode<>(HPath.empty());
    }

    /**
     * Add {@code value} by {@code path} to the tree.
     *
     * @param path  the path
     * @param value the value
     * @return previously added {@code value} or {@code null} otherwise
     */
    @Nullable
    public T put(HPath path, T value) {
        HNode<T> current = root;
        HPath.TagIterator iterator = path.it();
        while (iterator.hasNext()) {
            TinyString next = iterator.next();
            HNode<T> parent = current;
            HPath base = parent.path;
            HNode<T> child = parent.children.computeIfAbsent(next, (tag) -> new HNode<T>(parent, HPath.combine(base, tag)));
            current = child;
        }
        T previousValue = current.value;
        current.value = value;
        return previousValue;
    }

    /**
     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.
     *
     * @return navigator
     */
    public Navigator navigator() {
        return new Navigator();
    }

    /**
     * {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.
     */
    public class Navigator {
        private HNode<T> current = HTree.this.root;

        /**
         * Returns the value is stored in the current node.
         *
         * @return the value is stored in the current node, or {@code null} otherwise
         */
        @Nullable
        public T getValue() {
            return current.value;
        }

        /**
         * Navigates to the child node.
         *
         * @param tag the child node tag
         * @return {@code true} if the child node exists, otherwise {@code false}
         */
        public boolean navigateToChild(TinyString tag) {
            HNode<T> child = current.children.get(tag);
            if (child == null) {
                return false;
            }
            current = child;
            return true;
        }

        /**
         * Navigates to the parent node.
         * <p>
         * Do nothing if the current is the root itself.
         */
        public void navigateToParent() {
            current = current.parent;
        }

        /**
         * Returns {@code true} if the current node has child nodes.
         *
         * @return {@code true} if the current node has child nodes, otherwise {@code false}
         */
        public boolean hasChildren() {
            return !current.children.isEmpty();
        }

        public boolean hasValue() {
            return current.value != null;
        }

        /**
         * Returns {@code true} if the current node is the root.
         *
         * @return {@code true} if the current node is the root, otherwise {@code false}
         */
        public boolean isRoot() {
            return current == HTree.this.root;
        }

        /**
         * Returns path to the current node.
         *
         * @return path of the current node
         */
        public HPath path() {
            return current.path;
        }

        /**
         * Return the set of child nodes tags.
         * <p>
         * This set is a view. It means that changes in the {@link HTree} are also applied to the set.
         *
         * @return the set of child nodes tags
         */
        public Set<TinyString> children() {
            return current.children.keySet();
        }
    }

    private static class HNode<T> {
        final Map<TinyString, HNode<T>> children = new LinkedHashMap<>();
        final HNode<T> parent;
        final HPath path;
        T value;

        private HNode(@NotNull HPath path) {
            this.parent = this;
            this.path = path;
        }

        private HNode(@NotNull HNode<T> parent, @NotNull HPath path) {
            this.path = path;
            this.parent = parent;
        }
    }
}
```


Overlapping Code:
```
lass HTree<T> {
private final HNode<T> root;
public HTree() {
root = new HNode<>(HPath.empty());
}
/**
* Add {@code value} by {@code path} to the tree.
*
* @param path the path
* @param value the value
* @return previously added {@code value} or {@code null} otherwise
*/
@Nullable
public T put(HPath path, T value) {
HNode<T> current = root;
HPath.TagIterator iterator = path.it();
while (iterator.hasNext()) {
TinyString next = iterator.next();
HNode<T> parent = current;
HPath base = parent.path;
HNode<T> child = parent.children.computeIfAbsent(next, (tag) -> new HNode<T>(parent, HPath.combine(base, tag)));
current = child;
}
T previousValue = current.value;
current.value = value;
return previousValue;
}
/**
* {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.
*
* @return navigator
*/
public Navigator navigator() {
return new Navigator();
}
/**
* {@link Navigator} navigates to parent or child nodes. Starts from the root of tree.
*/
public class Navigator {
private HNode<T> current = HTree.this.root;
/**
* Returns the value is stored in the current node.
*
* @return the value is stored in the current node, or {@code null} otherwise
*/
@Nullable
public T getValue() {
return current.value;
}
/**
* Navigates to the child node.
*
* @param tag the child node tag
* @return {@code true} if the child node exists, otherwise {@code false}
*/
public boolean navigateToChild(TinyString tag) {
HNode<T> child = current.children.get(tag);
if (child == null) {
return false;
}
current = child;
return true;
}
/**
* Navigates to the parent node.
* <p>
* Do nothing if the current is the root itself.
*/
public void navigateToParent() {
current = current.parent;
}
/**
* Returns {@code true} if the current node has child nodes.
*
* @return {@code true} if the current node has child nodes, otherwise {@code false}
*/
public boolean hasChil
```
<Overlap Ratio: 0.9915388683236382>

---

--- 127 --
Question ID: 6ebe14be1f20975df8ddde807635d4212e191180_0
Original Code:
```
public class LogBuiltin extends Builtin {
  @Override public String repr() {
    return "⍟";
  }
  
  
  static final double LN2 = Math.log(2);
  
  public static final NumMV NF = new NumMV() {
    public Value call(Num w) {
      return w.log(Num.E);
    }
    public void call(double[] res, double[] a) {
      for (int i = 0; i < a.length; i++) res[i] = Math.log(a[i]);
    }
    public Num call(BigValue w) {
      if (w.i.signum() <= 0) {
        if (w.i.signum() == -1) throw new DomainError("logarithm of negative number", w);
        return Num.NEGINF;
      }
      if (w.i.bitLength()<1023) return new Num(Math.log(w.i.doubleValue())); // safe quick path
      int len = w.i.bitLength();
      int shift = len > 64? len - 64 : 0; // 64 msb should be enough to get most out of log
      double d = w.i.shiftRight(shift).doubleValue();
      return new Num(Math.log(d) + LN2*shift);
    }
  };
  public Value call(Value w) {
    return numM(NF, w);
  }
  public Value callInv(Value w) {
    return numM(StarBuiltin.NF, w);
  }
  
  public static final D_NNeN DNF = new D_NNeN() {
    public double on(double a, double w) {
      return Math.log(w) / Math.log(a);
    }
    public void on(double[] res, double a, double[] w) {
      double la = Math.log(a);
      for (int i = 0; i < w.length; i++) res[i] = Math.log(w[i]) / la;
    }
    public void on(double[] res, double[] a, double w) {
      double lw = Math.log(w);
      for (int i = 0; i < a.length; i++) res[i] = lw / Math.log(a[i]);
    }
    public void on(double[] res, double[] a, double[] w) {
      for (int i = 0; i < a.length; i++) res[i] = Math.log(w[i]) / Math.log(a[i]);
    }
    public Value call(double a, BigValue w) {
      double res = ((Num) NF.call(w)).num/Math.log(a);
      if (a==2) { // quick path to make sure 2⍟ makes sense
        int expected = w.i.bitLength()-1;
        // System.out.println(res+" > "+expected);
        if (res < expected) return Num.of(expected);
        if (res >= expected+1) { // have to get the double juuuust below expected
          long repr = Double.doubleToRawLongBits(expected+1);
          repr--; // should be safe as positive int values are always well into the proper double domain
          return new Num(Double.longBitsToDouble(repr));
        }
      }
      return new Num(res);
    }
  };
  public Value call(Value a0, Value w0) {
    return numD(DNF, a0, w0);
  }
  
  @Override public Value callInvW(Value a, Value w) {
    return numD(StarBuiltin.DNF, a, w);
  }
  @Override public Value callInvA(Value a, Value w) {
    return numD(RootBuiltin.DNF, a, w);
  }
}
```


Overlapping Code:
```
uiltin extends Builtin {
@Override public String repr() {
return "⍟";
}


static final double LN2 = Math.log(2);

public static final NumMV NF = new NumMV() {
public Value call(Num w) {
return w.log(Num.E);
}
public void call(double[] res, double[] a) {
for (int i = 0; i < a.length; i++) res[i] = Math.log(a[i]);
}
public Num call(BigValue w) {
if (w.i.signum() <= 0) {
if (w.i.signum() == -1) throw new DomainError("logarithm of negative number", w);
return Num.NEGINF;
}
if (w.i.bitLength()<1023) return new Num(Math.log(w.i.doubleValue())); // safe quick path
int len = w.i.bitLength();
int shift = len > 64? len - 64 : 0; // 64 msb should be enough to get most out of log
double d = w.i.shiftRight(shift).doubleValue();
return new Num(Math.log(d) + LN2*shift);
}
};
public Value call(Value w) {
return numM(NF, w);
}
public Value callInv(Value w) {
return numM(StarBuiltin.NF, w);
}

public static final D_NNeN DNF = new D_NNeN() {
public double on(double a, double w) {
return Math.log(w) / Math.log(a);
}
public void on(double[] res, double a, double[] w) {
double la = Math.log(a);
for (int i = 0; i < w.length; i++) res[i] = Math.log(w[i]) / la;
}
public void on(double[] res, double[] a, double w) {
double lw = Math.log(w);
for (int i = 0; i < a.length; i++) res[i] = lw / Math.log(a[i]);
}
public void on(double[] res, double[] a, double[] w) {
for (int i = 0; i < a.length; i++) res[i] = Math.log(w[i]) / Math.log(a[i]);
}
public Value call(double a, BigValue w) {
double res = ((Num) NF.call(w)).num/Math.log(a);
if (a==2) { // quick path to make sure 2⍟ makes sense
int expected = w.i.bitLength()-1;
// System.out.println(res+" > "+expected);
if (res < expected) return Num.of(expected);
if (res >= expected+1) { // have to get the double juuuust below expected
long repr = Double.doubleToRawLongBits(expected+1);
repr--; // should be safe as positive int values are always well into the proper double domain
return new Num(Double.longBitsToDouble(repr));
}
}
return new Num(res);
}
};
public Value call(Value a0, Value w0) {
return numD(DNF, a0, w0);
}

@Override public Value callInvW(Value a, Value w) {
return numD(StarBuiltin.DNF, a, 
```
<Overlap Ratio: 0.9908003679852806>

---

--- 128 --
Question ID: 3029540e11c24534ecc057af01ba0fd4a2da95fd_0
Original Code:
```
@SpringBootApplication
@CommonsLog
public class EventServer {

	public static void main(String[] args) {
		new SpringApplicationBuilder(EventServer.class).web(WebApplicationType.NONE).build().run(args);
	}

	@Bean
	public ApplicationRunner runner(CustomerRepository customerRepository, OrderRepository orderRepository,
			ProductRepository productRepository, OrderProductSummaryRepository orderProductSummaryRepository,
			@Qualifier("Products") Region<Long, Product> products) {
		return args -> {
			createCustomerData(customerRepository);

			createProducts(productRepository);

			createOrders(productRepository, orderRepository);

			log.info("Completed creating orders ");

			var allForProductID = orderProductSummaryRepository.findAllForProductID(3L);
			allForProductID.forEach(orderProductSummary -> log.info("orderProductSummary = " + orderProductSummary));
		};
	}

	private void createOrders(ProductRepository productRepository, OrderRepository orderRepository) {
		var random = new Random(System.nanoTime());
		var address = new Address("it", "doesn't", "matter");
		LongStream.rangeClosed(1, 10).forEach((orderId) -> LongStream.rangeClosed(1, 300).forEach((customerId) -> {
			var order = new Order(orderId, customerId, address);
			IntStream.rangeClosed(0, random.nextInt(3) + 1).forEach((lineItemCount) -> {
				var quantity = random.nextInt(3) + 1;
				long productId = random.nextInt(3) + 1;
				order.add(new LineItem(productRepository.findById(productId).get(), quantity));
			});
			orderRepository.save(order);
		}));
	}

	private void createProducts(ProductRepository productRepository) {
		productRepository.save(new Product(1L, "Apple iPod", new BigDecimal("99.99"), "An Apple portable music player"));
		productRepository.save(new Product(2L, "Apple iPad", new BigDecimal("499.99"), "An Apple tablet device"));
		var macbook = new Product(3L, "Apple macBook", new BigDecimal("899.99"), "An Apple notebook computer");
		macbook.addAttribute("warranty", "included");
		productRepository.save(macbook);
	}

	private void createCustomerData(CustomerRepository customerRepository) {
		LongStream.rangeClosed(0, 300).parallel().forEach(customerId -> customerRepository.save(
				new Customer(customerId, new EmailAddress(customerId + "@2.com"), "John" + customerId, "Smith" + customerId)));
	}
}
```


Overlapping Code:
```

public class EventServer {
public static void main(String[] args) {
new SpringApplicationBuilder(EventServer.class).web(WebApplicationType.NONE).build().run(args);
}
@Bean
public ApplicationRunner runner(CustomerRepository customerRepository, OrderRepository orderRepository,
ProductRepository productRepository, OrderProductSummaryRepository orderProductSummaryRepository,
@Qualifier("Products") Region<Long, Product> products) {
return args -> {
createCustomerData(customerRepository);
createProducts(productRepository);
createOrders(productRepository, orderRepository);
log.info("Completed creating orders ");
var allForProductID = orderProductSummaryRepository.findAllForProductID(3L);
allForProductID.forEach(orderProductSummary -> log.info("orderProductSummary = " + orderProductSummary));
};
}
private void createOrders(ProductRepository productRepository, OrderRepository orderRepository) {
var random = new Random(System.nanoTime());
var address = new Address("it", "doesn't", "matter");
LongStream.rangeClosed(1, 10).forEach((orderId) -> LongStream.rangeClosed(1, 300).forEach((customerId) -> {
var order = new Order(orderId, customerId, address);
IntStream.rangeClosed(0, random.nextInt(3) + 1).forEach((lineItemCount) -> {
var quantity = random.nextInt(3) + 1;
long productId = random.nextInt(3) + 1;
order.add(new LineItem(productRepository.findById(productId).get(), quantity));
});
orderRepository.save(order);
}));
}
private void createProducts(ProductRepository productRepository) {
productRepository.save(new Product(1L, "Apple iPod", new BigDecimal("99.99"), "An Apple portable music player"));
productRepository.save(new Product(2L, "Apple iPad", new BigDecimal("499.99"), "An Apple tablet device"));
var macbook = new Product(3L, "Apple macBook", new BigDecimal("899.99"), "An Apple notebook computer");
macbook.addAttribute("warranty", "included");
productRepository.save(macbook);
}
private void createCustomerData(CustomerRepository customerRepository) {
LongStream.rangeClosed(0, 300).parallel().forEach(customerId -> customerRepository.save(
new Customer(customerId, new EmailAddress(customerId + "@2.com"), "John" + customerId,
```
<Overlap Ratio: 0.9715960324616771>

---

--- 129 --
Question ID: 520e43372799a057230e34c5d2fd2fdc1a3b8793_0
Original Code:
```
public class ChronicleSource<C extends Chronicle> implements Closeable {

    private final C chronicle;
    private final ServerSocketChannel server;
    private final int delayNS;

    private final String name;
    private final ExecutorService service;
    private final Logger logger;

    private volatile boolean closed = false;

    public ChronicleSource(C chronicle, int port, int delayNS) throws IOException {
        this.chronicle = chronicle;
        this.delayNS = delayNS;
        server = ServerSocketChannel.open();
        server.socket().bind(new InetSocketAddress(port));
        name = chronicle.name() + "@" + port;
        logger = Logger.getLogger(getClass().getName() + "." + name);
        service = Executors.newCachedThreadPool(new NamedThreadFactory(name));
        service.execute(new Acceptor());
    }

    public static void main(String... args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: java " + ChronicleSource.class.getName() + " {chronicle-base-path} {port} [delayNS]");
            System.exit(-1);
        }
        int dataBitsHintSize = Integer.getInteger("dataBitsHintSize", 24);
        String def = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? "Big" : "Little";
        ByteOrder byteOrder = System.getProperty("byteOrder", def).equalsIgnoreCase("Big") ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
        String basePath = args[0];
        int port = Integer.parseInt(args[1]);
        int delayNS = 5 * 1000 * 1000;
        if (args.length > 2)
            delayNS = Integer.parseInt(args[2]);
        IndexedChronicle ic = new IndexedChronicle(basePath, dataBitsHintSize, byteOrder);
        ChronicleSource cs = new ChronicleSource(ic, port, delayNS);
    }

    class Acceptor implements Runnable {
        @Override
        public void run() {
            Thread.currentThread().setName(name + "-acceptor");
            try {
                while (!closed) {
                    SocketChannel socket = server.accept();
                    service.execute(new Handler(socket));
                }
            } catch (IOException e) {
                if (!closed)
                    logger.log(Level.SEVERE, "Acceptor dying", e);
            }
        }
    }

    class Handler implements Runnable {
        private final SocketChannel socket;

        public Handler(SocketChannel socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            try {
                long index = readIndex(socket);
                Excerpt excerpt = chronicle.createExcerpt();
                ByteBuffer bb = TcpUtil.createBuffer(1, chronicle);
                while (!closed) {
                    while (!excerpt.index(index))
                        pause(delayNS);
                    int size = excerpt.capacity();
                    int capacity = size + TcpUtil.HEADER_SIZE;
                    if (capacity > bb.capacity())
                        bb = TcpUtil.createBuffer(capacity, chronicle);

                    bb.clear();
                    bb.putLong(index);
                    bb.putLong(size);
                    excerpt.read(bb);
                    bb.flip();
                    while (bb.remaining() > 0 && socket.write(bb) > 0) ;
                    if (bb.remaining() > 0) throw new EOFException("Failed to send index=" + index);
                }
            } catch (IOException e) {
                if (!closed)
                    logger.log(Level.INFO, "Connect " + socket + " died", e);
            }
        }

        private long readIndex(SocketChannel socket) throws IOException {
            ByteBuffer bb = ByteBuffer.allocate(8);
            while (bb.remaining() > 0 && socket.read(bb) > 0) ;
            if (bb.remaining() > 0) throw new EOFException();
            return bb.getLong(0);
        }
    }

    protected void pause(int delayNS) {
        if (delayNS < 1) return;
        if (delayNS < 20000)
            Thread.yield();
        else
            LockSupport.parkNanos(delayNS);
    }

    @Override
    public void close() throws IOException {
        closed = true;
        service.shutdown();
        try {
            service.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        chronicle.close();
    }

}
```


Overlapping Code:
```
ronicleSource<C extends Chronicle> implements Closeable {
private final C chronicle;
private final ServerSocketChannel server;
private final int delayNS;
private final String name;
private final ExecutorService service;
private final Logger logger;
private volatile boolean closed = false;
public ChronicleSource(C chronicle, int port, int delayNS) throws IOException {
this.chronicle = chronicle;
this.delayNS = delayNS;
server = ServerSocketChannel.open();
server.socket().bind(new InetSocketAddress(port));
name = chronicle.name() + "@" + port;
logger = Logger.getLogger(getClass().getName() + "." + name);
service = Executors.newCachedThreadPool(new NamedThreadFactory(name));
service.execute(new Acceptor());
}
public static void main(String... args) throws IOException {
if (args.length < 2) {
System.err.println("Usage: java " + ChronicleSource.class.getName() + " {chronicle-base-path} {port} [delayNS]");
System.exit(-1);
}
int dataBitsHintSize = Integer.getInteger("dataBitsHintSize", 24);
String def = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ? "Big" : "Little";
ByteOrder byteOrder = System.getProperty("byteOrder", def).equalsIgnoreCase("Big") ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
String basePath = args[0];
int port = Integer.parseInt(args[1]);
int delayNS = 5 * 1000 * 1000;
if (args.length > 2)
delayNS = Integer.parseInt(args[2]);
IndexedChronicle ic = new IndexedChronicle(basePath, dataBitsHintSize, byteOrder);
ChronicleSource cs = new ChronicleSource(ic, port, delayNS);
}
class Acceptor implements Runnable {
@Override
public void run() {
Thread.currentThread().setName(name + "-acceptor");
try {
while (!closed) {
SocketChannel socket = server.accept();
service.execute(new Handler(socket));
}
} catch (IOException e) {
if (!closed)
logger.log(Level.SEVERE, "Acceptor dying", e);
}
}
}
class Handler implements Runnable {
private final SocketChannel socket;
public Handler(SocketChannel socket) {
this.socket = socket;
}
@Override
public void run() {
```
<Overlap Ratio: 0.9925298804780877>

---

--- 130 --
Question ID: a3ea1f2b20b3e5f730f5c572016ffc7f969abaac_0
Original Code:
```
public class PinboardUser implements Serializable {
    public Long id;

    public List<Pin> getPins() {
        return pins;
    }

    public List<Pin> pins;

    public String getState() {
        return state;
    }

    public PinboardUser setState(String state) {
        this.state = state;
        return this;
    }

    public String state;

    public PinboardUser(Long id) {
        this.id = id;
        this.pins = new ArrayList<>();
        this.state = "none";
    }

    public void removePin(Pin p) {
        pins.remove(p);
    }

    public Long getId() {
        return id;
    }

    public PinboardUser setId(Long id) {
        this.id = id;
        return this;
    }

    public List<Pin> getReadyPins() {
        List<Pin> readyPins = new ArrayList<>();
        for(Pin pin:pins) {
            if(pin.checkMe()) {
                readyPins.add(pin);
            }
        }
        return readyPins;
    }

    public void removeExpiredPins() {
        pins.removeIf(Pin::checkMe);
    }

    public Pin getPin(Integer id) {
        return pins.get(id);
    }

    public void addPin(Pin pin) {
        pins.add(pin);
    }

}
```


Overlapping Code:
```
izable {
public Long id;
public List<Pin> getPins() {
return pins;
}
public List<Pin> pins;
public String getState() {
return state;
}
public PinboardUser setState(String state) {
this.state = state;
return this;
}
public String state;
public PinboardUser(Long id) {
this.id = id;
this.pins = new ArrayList<>();
this.state = "none";
}
public void removePin(Pin p) {
pins.remove(p);
}
public Long getId() {
return id;
}
public PinboardUser setId(Long id) {
this.id = id;
return this;
}
public List<Pin> getReadyPins() {
List<Pin> readyPins = new ArrayList<>();
for(Pin pin:pins) {
if(pin.checkMe()) {
readyPins.add(pin);
}
}
return readyPins;
}
public void removeExpiredPins() {
pins.removeIf(Pin::checkMe);
}
public Pin getPin(Integer id) {
return pins.get(id);
}
public void addPin(Pin pin) {
pins.a
```
<Overlap Ratio: 0.935672514619883>

---

--- 131 --
Question ID: abe0f26e99350ce8103fe5f9bc16929960bed0a3_0
Original Code:
```
public class Math {

	public static Integer pow(Integer a, Integer b) {
		return (int) java.lang.Math.pow(a, b);
	}
	
	public static Integer sbin(Integer in, Integer size) {
		switch(size) {
		case 1: return (int) Short.valueOf(in.toString());
		case 2: return (int) Integer.valueOf(in.toString()).shortValue();
		case 4: return (int) Long.valueOf(in.toString()).intValue();
		}
		return in;
	}
	
	public static Integer defaultIndicator(Integer size, Boolean signed) {
		if(signed) return -1;
		
		switch(size) {
		case 1: return 0xff;
		case 2: return 0xffff;
		case 3: return 0xffffff;
		case 4: return 0xffffffff;
		}
		throw new IllegalArgumentException("Unsupported size "+size);
	}

	   public static Integer calculateFlagValue(Integer size, Integer bit) {
	        BitSet set = new BitSet(size);
	        set.set(size - bit - 1);
	        return (int) set.toLongArray()[0];
	    }

}
```


Overlapping Code:
```
ath {
public static Integer pow(Integer a, Integer b) {
return (int) java.lang.Math.pow(a, b);
}

public static Integer sbin(Integer in, Integer size) {
switch(size) {
case 1: return (int) Short.valueOf(in.toString());
case 2: return (int) Integer.valueOf(in.toString()).shortValue();
case 4: return (int) Long.valueOf(in.toString()).intValue();
}
return in;
}

public static Integer defaultIndicator(Integer size, Boolean signed) {
if(signed) return -1;

switch(size) {
case 1: return 0xff;
case 2: return 0xffff;
case 3: return 0xffffff;
case 4: return 0xffffffff;
}
throw new IllegalArgumentException("Unsupported size "+size);
}
public static Integer calculateFlagValue(Integer size, Integer bit) {
BitSet set = new BitSet(size);
set.set(size - b
```
<Overlap Ratio: 0.9247842170160296>

---

--- 132 --
Question ID: 3b02ebef53958906e7e0cdfc4e765a08c6978cdd_0
Original Code:
```
public class MatchLineQuery implements SearchFiltersQuery {
  private final int _lineNum;

  MatchLineQuery(int lineNum) {
    _lineNum = lineNum;
  }

  public int getLineNum() {
    return _lineNum;
  }

  @Override
  public boolean canQuery(IpAccessList acl) {
    return acl.getLines().size() > _lineNum;
  }

  @Override
  @Nonnull
  public BDD getMatchingBdd(IpAccessList acl, IpAccessListToBdd ipAccessListToBdd, BDDPacket pkt) {
    checkArgument(canQuery(acl), "ACL %s is too short to apply match line query", acl.getName());

    // Generate BDD matching all flows that would match the target line, then subtract out the BDD
    // of all flows matched by any previous line
    BDD matchingTargetLine =
        ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(_lineNum)).getMatchBdd();
    List<BDD> prevLineBdds =
        IntStream.range(0, _lineNum)
            .mapToObj(
                i -> ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(i)).getMatchBdd())
            .collect(ImmutableList.toImmutableList());
    return matchingTargetLine.diff(pkt.getFactory().orAll(prevLineBdds));
  }
}
```


Overlapping Code:
```
tersQuery {
private final int _lineNum;
MatchLineQuery(int lineNum) {
_lineNum = lineNum;
}
public int getLineNum() {
return _lineNum;
}
@Override
public boolean canQuery(IpAccessList acl) {
return acl.getLines().size() > _lineNum;
}
@Override
@Nonnull
public BDD getMatchingBdd(IpAccessList acl, IpAccessListToBdd ipAccessListToBdd, BDDPacket pkt) {
checkArgument(canQuery(acl), "ACL %s is too short to apply match line query", acl.getName());
// Generate BDD matching all flows that would match the target line, then subtract out the BDD
// of all flows matched by any previous line
BDD matchingTargetLine =
ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(_lineNum)).getMatchBdd();
List<BDD> prevLineBdds =
IntStream.range(0, _lineNum)
.mapToObj(
i -> ipAccessListToBdd.toPermitAndDenyBdds(acl.getLines().get(i)).getMatchBdd())
.collect(ImmutableList.toImmutableList());
return matchingTargetLine.diff(pkt.getFactory().orAll(prevLineBdds))
```
<Overlap Ratio: 0.9471585244267199>

---

--- 133 --
Question ID: b6de42e2d1ba659a4b0d3b1d73f3bde9f1bdf5f6_0
Original Code:
```
public class InstitutionService {
    private static Logger _logger = LoggerFactory.getLogger(InstitutionService.class);
    
    private static final String SELECT_STATEMENT = "select * from  mxk_institutions where domain = ? and status = " + ConstantsStatus.ACTIVE;

    protected static final Cache<String, Institutions> institutionsStore = 
            Caffeine.newBuilder()
                .expireAfterWrite(ConstantsTimeInterval.ONE_HOUR, TimeUnit.MINUTES)
                .build();
    
    protected JdbcTemplate jdbcTemplate;
    
    public InstitutionService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
        
    public Institutions findByDomain(String domain) {
        _logger.trace(" domain {}" , domain);
        Institutions inst = institutionsStore.getIfPresent(domain);
        if(inst == null) {
	        List<Institutions> institutions = 
	        		jdbcTemplate.query(SELECT_STATEMENT,new InstitutionsRowMapper(),domain);
	        
	        if (institutions != null && institutions.size() > 0) {
	        	inst = institutions.get(0);
	        }
	        
	        institutionsStore.put(domain, inst);
        }
        
        return inst;
    }
    
    public class InstitutionsRowMapper implements RowMapper<Institutions> {
        @Override
        public Institutions mapRow(ResultSet rs, int rowNum) throws SQLException {
        	Institutions institution = new Institutions();
        	institution.setId(rs.getString("id"));
        	institution.setName(rs.getString("name"));
        	institution.setFullName(rs.getString("fullname"));
        	institution.setLogo(rs.getString("logo"));
        	institution.setDomain(rs.getString("domain"));
            return institution;
        }
    }
}
```


Overlapping Code:
```
rvice {
private static Logger _logger = LoggerFactory.getLogger(InstitutionService.class);

private static final String SELECT_STATEMENT = "select * from mxk_institutions where domain = ? and status = " + ConstantsStatus.ACTIVE;
protected static final Cache<String, Institutions> institutionsStore = 
Caffeine.newBuilder()
.expireAfterWrite(ConstantsTimeInterval.ONE_HOUR, TimeUnit.MINUTES)
.build();

protected JdbcTemplate jdbcTemplate;

public InstitutionService(JdbcTemplate jdbcTemplate) {
this.jdbcTemplate = jdbcTemplate;
}

public Institutions findByDomain(String domain) {
_logger.trace(" domain {}" , domain);
Institutions inst = institutionsStore.getIfPresent(domain);
if(inst == null) {
List<Institutions> institutions = 
jdbcTemplate.query(SELECT_STATEMENT,new InstitutionsRowMapper(),domain);

if (institutions != null && institutions.size() > 0) {
inst = institutions.get(0);
}

institutionsStore.put(domain, inst);
}

return inst;
}

public class InstitutionsRowMapper implements RowMapper<Institutions> {
@Override
public Institutions mapRow(ResultSet rs, int rowNum) throws SQLException {
Institutions institution = new Institutions();
institution.setId(rs.getString("id"));
institution.setName(rs.getString("name"));
institution.setFullName(rs.getString("fullname"));
institution.setLogo(rs.getString("logo"));
institution.setDomain(rs.getString
```
<Overlap Ratio: 0.9551820728291317>

---

--- 134 --
Question ID: f9b181b9be7f023d288befd01d54469a8174de8f_0
Original Code:
```
public class ZadBuilder extends UGraphicNo {

	@Override
	public UGraphic apply(UChange change) {
		return new ZadBuilder(this, change);
	}

	private final Context context;

	static class Context {
		private final Zad zad = new Zad();
	}

	public ZadBuilder(StringBounder stringBounder) {
		super(stringBounder);
		this.context = new Context();
	}

	private ZadBuilder(ZadBuilder other, UChange change) {
		super(other, change);
		if (!instanceOfAny(change,
				UBackground.class,
				HColor.class,
				UStroke.class,
				UTranslate.class
		)) {
			throw new UnsupportedOperationException(change.getClass().toString());
		}
		this.context = other.context;
	}

	public void draw(UShape shape) {
		if (shape instanceof URectangle) {
			drawRectangle((URectangle) shape);
		}
	}

	private void drawRectangle(URectangle shape) {
		final MinMax area = shape.getMinMax().translate(getTranslate());
		// System.err.println("ZadBuilder " + shape + " " + area);
		context.zad.add(area);
	}

	public Zad getZad() {
		return context.zad;
	}

}
```


Overlapping Code:
```
ic class ZadBuilder extends UGraphicNo {
@Override
public UGraphic apply(UChange change) {
return new ZadBuilder(this, change);
}
private final Context context;
static class Context {
private final Zad zad = new Zad();
}
public ZadBuilder(StringBounder stringBounder) {
super(stringBounder);
this.context = new Context();
}
private ZadBuilder(ZadBuilder other, UChange change) {
super(other, change);
if (!instanceOfAny(change,
UBackground.class,
HColor.class,
UStroke.class,
UTranslate.class
)) {
throw new UnsupportedOperationException(change.getClass().toString());
}
this.context = other.context;
}
public void draw(UShape shape) {
if (shape instanceof URectangle) {
drawRectangle((URectangle) shape);
}
}
private void drawRectangle(URectangle shape) {
final MinMax area = shape.getMinMax().translate(getTranslate());
// System.err.println("ZadBuilder " + shape + " " + area);
context.zad.add(area);
}
public Zad getZad() {
return context.zad;
}

```
<Overlap Ratio: 0.9947643979057592>

---

--- 135 --
Question ID: ede52d42fa146366dea9ca2a2ef82e8c516028e3_0
Original Code:
```
public class PlayerCounter {
    private Label botText, peopleText;
    private int bots, people;
    private boolean square;

    public PlayerCounter(Label botText, Label peopleText, boolean square) {
        this.botText = botText;
        this.peopleText = peopleText;

        this.people = 1;
        this.bots = 1;
        this.square = square;
    }

    public void update(int bots, int people, boolean square){
        if(people <= 0) return;
        if(bots <= 0) return;
        if(square){
            if(people + bots > 4)
                if(!this.square){bots = 1; people = 1;} //too much players!
                else return;
        }
        else{
            if(people + bots > 6) return; //too much players!
        }

        botText.setText(bots);
        peopleText.setText(people);

        this.bots = bots;
        this.people = people;
        this.square = square;
    }

    public Label getBotText() {
        return botText;
    }

    public Label getPeopleText() {
        return peopleText;
    }

    public int getBots() {
        return bots;
    }

    public int getPeople() {
        return people;
    }

    public boolean isSquare() {
        return square;
    }
}
```


Overlapping Code:
```
ass PlayerCounter {
private Label botText, peopleText;
private int bots, people;
private boolean square;
public PlayerCounter(Label botText, Label peopleText, boolean square) {
this.botText = botText;
this.peopleText = peopleText;
this.people = 1;
this.bots = 1;
this.square = square;
}
public void update(int bots, int people, boolean square){
if(people <= 0) return;
if(bots <= 0) return;
if(square){
if(people + bots > 4)
if(!this.square){bots = 1; people = 1;} //too much players!
else return;
}
else{
if(people + bots > 6) return; //too much players!
}
botText.setText(bots);
peopleText.setText(people);
this.bots = bots;
this.people = people;
this.square = square;
}
public Label getBotText() {
return botText;
}
public Label getPeopleText() {
return peopleText;
}
public int getBots() {
return bots;
}
public int getPeople() {
return people;
}
```
<Overlap Ratio: 0.9381898454746137>

---

--- 136 --
Question ID: 94fd864833873e122a5f05aae0924bc43c743bce_0
Original Code:
```
public class FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES{
static int f_gold ( int arr [ ] , int arr_size ) {
  int i ;
  for ( i = 0 ;
  i < arr_size ;
  i ++ ) {
    int count = 0 ;
    for ( int j = 0 ;
    j < arr_size ;
    j ++ ) {
      if ( arr [ i ] == arr [ j ] ) count ++ ;
    }
    if ( count % 2 != 0 ) return arr [ i ] ;
  }
  return - 1 ;
}


//TOFILL

public static void main(String args[]) {
    int n_success = 0;
    List<int [ ]> param0 = new ArrayList<>();
    param0.add(new int[]{1,5,5,8,14,15,17,17,18,23,23,25,26,35,36,39,51,53,56,56,60,62,64,64,65,66,67,68,71,75,80,82,83,88,89,91,91,92,93,95,99});
    param0.add(new int[]{-56,98,44,30,-88,18,60,86,4,16,10,64,-22,-86,-66,-16,70,-44,98,78,-96,-66,92,10,40,-16});
    param0.add(new int[]{0,0,0,0,0,1,1,1});
    param0.add(new int[]{36,11,83,41,42,14,46,89,91,96,57,42,74,73,9,26,79,40,31,69,44,39,14,92,34,20,52,47,14});
    param0.add(new int[]{-84,-84,-84,-78,-66,-62,-62,-36,-24,-10,-10,-8,-4,-2,12,14,20,22,36,42,46,66,84,96,96,98});
    param0.add(new int[]{1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1});
    param0.add(new int[]{11,12,14,28,42,48,50,58,67,74,86,89,95});
    param0.add(new int[]{52,-56,-6,74,10,68,74,10,16,-80,82,-32,6,-6,82,20});
    param0.add(new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1});
    param0.add(new int[]{4,80,92});
    List<Integer> param1 = new ArrayList<>();
    param1.add(31);
    param1.add(19);
    param1.add(6);
    param1.add(25);
    param1.add(23);
    param1.add(19);
    param1.add(7);
    param1.add(11);
    param1.add(31);
    param1.add(1);
    for(int i = 0; i < param0.size(); ++i)
    {
        if(f_filled(param0.get(i),param1.get(i)) == f_gold(param0.get(i),param1.get(i)))
        {
            n_success+=1;
        }
    }
    System.out.println("#Results:" + n_success + ", " + param0.size());
}
}
```


Overlapping Code:
```
ass FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES{
static int f_gold ( int arr [ ] , int arr_size ) {
int i ;
for ( i = 0 ;
i < arr_size ;
i ++ ) {
int count = 0 ;
for ( int j = 0 ;
j < arr_size ;
j ++ ) {
if ( arr [ i ] == arr [ j ] ) count ++ ;
}
if ( count % 2 != 0 ) return arr [ i ] ;
}
return - 1 ;
}
//TOFILL
public static void main(String args[]) {
int n_success = 0;
List<int [ ]> param0 = new ArrayList<>();
param0.add(new int[]{1,5,5,8,14,15,17,17,18,23,23,25,26,35,36,39,51,53,56,56,60,62,64,64,65,66,67,68,71,75,80,82,83,88,89,91,91,92,93,95,99});
param0.add(new int[]{-56,98,44,30,-88,18,60,86,4,16,10,64,-22,-86,-66,-16,70,-44,98,78,-96,-66,92,10,40,-16});
param0.add(new int[]{0,0,0,0,0,1,1,1});
param0.add(new int[]{36,11,83,41,42,14,46,89,91,96,57,42,74,73,9,26,79,40,31,69,44,39,14,92,34,20,52,47,14});
param0.add(new int[]{-84,-84,-84,-78,-66,-62,-62,-36,-24,-10,-10,-8,-4,-2,12,14,20,22,36,42,46,66,84,96,96,98});
param0.add(new int[]{1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1});
param0.add(new int[]{11,12,14,28,42,48,50,58,67,74,86,89,95});
param0.add(new int[]{52,-56,-6,74,10,68,74,10,16,-80,82,-32,6,-6,82,20});
param0.add(new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1});
param0.add(new int[]{4,80,92});
List<Integer> param1 = new ArrayList<>();
param1.add(31);
param1.add(19);
param1.add(6);
param1.add(25);
param1.add(23);
param1.add(19);
param1.add(7);
param1.add(11);
param1.add(31);
param1.add(1);
for(int i = 0; i < param0.size(); ++i)
{
if(f_filled(param0.get(i),param1.get(i)) == f_gold(param0.get(i),param1.get(i)))
{
n_success+=1;
}
}
System.out.println("#Results:" + n_success + ", " + param0.size());
}
}
```
<Overlap Ratio: 0.9947643979057592>

---

--- 137 --
Question ID: b5c9978897ac0d9a7a2a1ca8fb5ada9197f2a1c0_0
Original Code:
```
public class Axis2ConfigurationContextObserverImpl extends
        AbstractAxis2ConfigurationContextObserver {
    private static Log log = LogFactory.getLog(Axis2ConfigurationContextObserverImpl.class);

    private HumanTaskServer humanTaskServer;

    public Axis2ConfigurationContextObserverImpl() {
        humanTaskServer = HumanTaskServerHolder.getInstance().getHtServer();
    }

    public void createdConfigurationContext(ConfigurationContext configurationContext) {
//        log.info("HUMANTASK createdConfigurationContext");
//        Integer tenantId = MultitenantUtils.getTenantId(configurationContext);
//        AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();
//        DeploymentEngine deploymentEngine = (DeploymentEngine) axisConfig.getConfigurator();
//
//        HumanTaskStore taskStoreForTenant =
//                htServer.getTaskStoreManager().createHumanTaskStoreForTenant(tenantId, axisConfig);
//
//        AxisHumanTaskDeployer humantaskDeployer = new AxisHumanTaskDeployer();
//        humantaskDeployer.setHumanTaskStore(taskStoreForTenant);
//        deploymentEngine.addDeployer(humantaskDeployer,
//                HumanTaskConstants.HUMANTASK_REPO_DIRECTORY,
//                HumanTaskConstants.HUMANTASK_PACKAGE_EXTENSION);

    }

    public void terminatingConfigurationContext(ConfigurationContext configurationContext) {
        Integer tenantId = CarbonContext.getThreadLocalCarbonContext().getTenantId();
        log.info("Unloading TenantTaskStore for tenant " + tenantId + ".");
        humanTaskServer.getTaskStoreManager().unloadTenantTaskStore(tenantId);
    }
}
```


Overlapping Code:
```
blic class Axis2ConfigurationContextObserverImpl extends
AbstractAxis2ConfigurationContextObserver {
private static Log log = LogFactory.getLog(Axis2ConfigurationContextObserverImpl.class);
private HumanTaskServer humanTaskServer;
public Axis2ConfigurationContextObserverImpl() {
humanTaskServer = HumanTaskServerHolder.getInstance().getHtServer();
}
public void createdConfigurationContext(ConfigurationContext configurationContext) {
// log.info("HUMANTASK createdConfigurationContext");
// Integer tenantId = MultitenantUtils.getTenantId(configurationContext);
// AxisConfiguration axisConfig = configurationContext.getAxisConfiguration();
// DeploymentEngine deploymentEngine = (DeploymentEngine) axisConfig.getConfigurator();
//
// HumanTaskStore taskStoreForTenant =
// htServer.getTaskStoreManager().createHumanTaskStoreForTenant(tenantId, axisConfig);
//
// AxisHumanTaskDeployer humantaskDeployer = new AxisHumanTaskDeployer();
// humantaskDeployer.setHumanTaskStore(taskStoreForTenant);
// deploymentEngine.addDeployer(humantaskDeployer,
// HumanTaskConstants.HUMANTASK_REPO_DIRECTORY,
// HumanTaskConstants.HUMANTASK_PACKAGE_EXTENSION);
}
public void terminatingConfigurationContext(ConfigurationContext configurationContext) {
Integer tenantId = CarbonContext.getThreadLocalCarbonContext().getTenantId();
log.info("Unloading TenantTaskStore for tenant " + tenantId + ".");
humanTaskServer.getTaskStoreManager().unloadTenantTaskSto
```
<Overlap Ratio: 0.9869952087611226>

---

--- 138 --
Question ID: 71d9f830499cea150fad9ac7fee313a95fbc5d27_0
Original Code:
```
@Command(name = "uploadTelemetry", description = "Upload Telemetry from an air-gapped deployment.")
public class UploadTelemetry implements Runnable {

  @Option(
      name = {"-f", "--file"},
      description = "Path to stats.json to be uploaded.",
      required = true
  )
  public String filePath;

  @Override
  public void run() {
    File file = new File(filePath);

    System.out.println(String.format("Uploading telemetry from %s", file.getAbsolutePath()));
    if (!file.exists() || !file.isFile()) {
      throw new RuntimeException(String.format("ERROR: file %s must be a valid stats.json", file.getAbsolutePath()));
    }

    ObjectGraph dagger = ObjectGraph.create(RuntimeModule.class);
    DCStatsCollectorTask statsTask = new DCStatsCollectorTask(
        dagger.get(BuildInfo.class),
        dagger.get(RuntimeInfo.class),
        dagger.get(Configuration.class),
        null,
        null,
        null
    );

    try {
      statsTask.reportStats(FileUtils.readFileToString(file, StandardCharsets.UTF_8));
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

  }
}
```


Overlapping Code:
```
ommand(name = "uploadTelemetry", description = "Upload Telemetry from an air-gapped deployment.")
public class UploadTelemetry implements Runnable {
@Option(
name = {"-f", "--file"},
description = "Path to stats.json to be uploaded.",
required = true
)
public String filePath;
@Override
public void run() {
File file = new File(filePath);
System.out.println(String.format("Uploading telemetry from %s", file.getAbsolutePath()));
if (!file.exists() || !file.isFile()) {
throw new RuntimeException(String.format("ERROR: file %s must be a valid stats.json", file.getAbsolutePath()));
}
ObjectGraph dagger = ObjectGraph.create(RuntimeModule.class);
DCStatsCollectorTask statsTask = new DCStatsCollectorTask(
dagger.get(BuildInfo.class),
dagger.get(RuntimeInfo.class),
dagger.get(Configuration.class),
null,
null,
null
);
try {
statsTask.reportStats(FileUtils.readFileToString(file, StandardCharsets.UTF_8));
} catch (IOException e) {
throw new RuntimeException(e);
}
}
}
```
<Overlap Ratio: 0.9979338842975206>

---

--- 139 --
Question ID: c8560978a51a44a8cc7697f0678b099716f16761_0
Original Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class RegisterGameServerRequest extends com.amazonaws.AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * <p>
     * A unique identifier for the game server group where the game server is running. Use either the
     * <a>GameServerGroup</a> name or ARN value.
     * </p>
     */
    private String gameServerGroupName;
    /**
     * <p>
     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and
     * must be unique across all game server groups in your AWS account.
     * </p>
     */
    private String gameServerId;
    /**
     * <p>
     * The unique identifier for the instance where the game server is running. This ID is available in the instance
     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.
     * </p>
     */
    private String instanceId;
    /**
     * <p>
     * Information that is needed to make inbound client connections to the game server. This might include the IP
     * address and port, DNS name, and other information.
     * </p>
     */
    private String connectionInfo;
    /**
     * <p>
     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client
     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.
     * </p>
     */
    private String gameServerData;

    /**
     * <p>
     * A unique identifier for the game server group where the game server is running. Use either the
     * <a>GameServerGroup</a> name or ARN value.
     * </p>
     * 
     * @param gameServerGroupName
     *        A unique identifier for the game server group where the game server is running. Use either the
     *        <a>GameServerGroup</a> name or ARN value.
     */

    public void setGameServerGroupName(String gameServerGroupName) {
        this.gameServerGroupName = gameServerGroupName;
    }

    /**
     * <p>
     * A unique identifier for the game server group where the game server is running. Use either the
     * <a>GameServerGroup</a> name or ARN value.
     * </p>
     * 
     * @return A unique identifier for the game server group where the game server is running. Use either the
     *         <a>GameServerGroup</a> name or ARN value.
     */

    public String getGameServerGroupName() {
        return this.gameServerGroupName;
    }

    /**
     * <p>
     * A unique identifier for the game server group where the game server is running. Use either the
     * <a>GameServerGroup</a> name or ARN value.
     * </p>
     * 
     * @param gameServerGroupName
     *        A unique identifier for the game server group where the game server is running. Use either the
     *        <a>GameServerGroup</a> name or ARN value.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public RegisterGameServerRequest withGameServerGroupName(String gameServerGroupName) {
        setGameServerGroupName(gameServerGroupName);
        return this;
    }

    /**
     * <p>
     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and
     * must be unique across all game server groups in your AWS account.
     * </p>
     * 
     * @param gameServerId
     *        A custom string that uniquely identifies the game server to register. Game server IDs are
     *        developer-defined and must be unique across all game server groups in your AWS account.
     */

    public void setGameServerId(String gameServerId) {
        this.gameServerId = gameServerId;
    }

    /**
     * <p>
     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and
     * must be unique across all game server groups in your AWS account.
     * </p>
     * 
     * @return A custom string that uniquely identifies the game server to register. Game server IDs are
     *         developer-defined and must be unique across all game server groups in your AWS account.
     */

    public String getGameServerId() {
        return this.gameServerId;
    }

    /**
     * <p>
     * A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and
     * must be unique across all game server groups in your AWS account.
     * </p>
     * 
     * @param gameServerId
     *        A custom string that uniquely identifies the game server to register. Game server IDs are
     *        developer-defined and must be unique across all game server groups in your AWS account.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public RegisterGameServerRequest withGameServerId(String gameServerId) {
        setGameServerId(gameServerId);
        return this;
    }

    /**
     * <p>
     * The unique identifier for the instance where the game server is running. This ID is available in the instance
     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.
     * </p>
     * 
     * @param instanceId
     *        The unique identifier for the instance where the game server is running. This ID is available in the
     *        instance metadata. EC2 instance IDs use a 17-character format, for example:
     *        <code>i-1234567890abcdef0</code>.
     */

    public void setInstanceId(String instanceId) {
        this.instanceId = instanceId;
    }

    /**
     * <p>
     * The unique identifier for the instance where the game server is running. This ID is available in the instance
     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.
     * </p>
     * 
     * @return The unique identifier for the instance where the game server is running. This ID is available in the
     *         instance metadata. EC2 instance IDs use a 17-character format, for example:
     *         <code>i-1234567890abcdef0</code>.
     */

    public String getInstanceId() {
        return this.instanceId;
    }

    /**
     * <p>
     * The unique identifier for the instance where the game server is running. This ID is available in the instance
     * metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.
     * </p>
     * 
     * @param instanceId
     *        The unique identifier for the instance where the game server is running. This ID is available in the
     *        instance metadata. EC2 instance IDs use a 17-character format, for example:
     *        <code>i-1234567890abcdef0</code>.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public RegisterGameServerRequest withInstanceId(String instanceId) {
        setInstanceId(instanceId);
        return this;
    }

    /**
     * <p>
     * Information that is needed to make inbound client connections to the game server. This might include the IP
     * address and port, DNS name, and other information.
     * </p>
     * 
     * @param connectionInfo
     *        Information that is needed to make inbound client connections to the game server. This might include the
     *        IP address and port, DNS name, and other information.
     */

    public void setConnectionInfo(String connectionInfo) {
        this.connectionInfo = connectionInfo;
    }

    /**
     * <p>
     * Information that is needed to make inbound client connections to the game server. This might include the IP
     * address and port, DNS name, and other information.
     * </p>
     * 
     * @return Information that is needed to make inbound client connections to the game server. This might include the
     *         IP address and port, DNS name, and other information.
     */

    public String getConnectionInfo() {
        return this.connectionInfo;
    }

    /**
     * <p>
     * Information that is needed to make inbound client connections to the game server. This might include the IP
     * address and port, DNS name, and other information.
     * </p>
     * 
     * @param connectionInfo
     *        Information that is needed to make inbound client connections to the game server. This might include the
     *        IP address and port, DNS name, and other information.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public RegisterGameServerRequest withConnectionInfo(String connectionInfo) {
        setConnectionInfo(connectionInfo);
        return this;
    }

    /**
     * <p>
     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client
     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.
     * </p>
     * 
     * @param gameServerData
     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game
     *        client or service when it requests information on game servers using <a>ListGameServers</a> or
     *        <a>ClaimGameServer</a>.
     */

    public void setGameServerData(String gameServerData) {
        this.gameServerData = gameServerData;
    }

    /**
     * <p>
     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client
     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.
     * </p>
     * 
     * @return A set of custom game server properties, formatted as a single string value. This data is passed to a game
     *         client or service when it requests information on game servers using <a>ListGameServers</a> or
     *         <a>ClaimGameServer</a>.
     */

    public String getGameServerData() {
        return this.gameServerData;
    }

    /**
     * <p>
     * A set of custom game server properties, formatted as a single string value. This data is passed to a game client
     * or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.
     * </p>
     * 
     * @param gameServerData
     *        A set of custom game server properties, formatted as a single string value. This data is passed to a game
     *        client or service when it requests information on game servers using <a>ListGameServers</a> or
     *        <a>ClaimGameServer</a>.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public RegisterGameServerRequest withGameServerData(String gameServerData) {
        setGameServerData(gameServerData);
        return this;
    }

    /**
     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be
     * redacted from this string using a placeholder value.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getGameServerGroupName() != null)
            sb.append("GameServerGroupName: ").append(getGameServerGroupName()).append(",");
        if (getGameServerId() != null)
            sb.append("GameServerId: ").append(getGameServerId()).append(",");
        if (getInstanceId() != null)
            sb.append("InstanceId: ").append(getInstanceId()).append(",");
        if (getConnectionInfo() != null)
            sb.append("ConnectionInfo: ").append(getConnectionInfo()).append(",");
        if (getGameServerData() != null)
            sb.append("GameServerData: ").append(getGameServerData());
        sb.append("}");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;

        if (obj instanceof RegisterGameServerRequest == false)
            return false;
        RegisterGameServerRequest other = (RegisterGameServerRequest) obj;
        if (other.getGameServerGroupName() == null ^ this.getGameServerGroupName() == null)
            return false;
        if (other.getGameServerGroupName() != null && other.getGameServerGroupName().equals(this.getGameServerGroupName()) == false)
            return false;
        if (other.getGameServerId() == null ^ this.getGameServerId() == null)
            return false;
        if (other.getGameServerId() != null && other.getGameServerId().equals(this.getGameServerId()) == false)
            return false;
        if (other.getInstanceId() == null ^ this.getInstanceId() == null)
            return false;
        if (other.getInstanceId() != null && other.getInstanceId().equals(this.getInstanceId()) == false)
            return false;
        if (other.getConnectionInfo() == null ^ this.getConnectionInfo() == null)
            return false;
        if (other.getConnectionInfo() != null && other.getConnectionInfo().equals(this.getConnectionInfo()) == false)
            return false;
        if (other.getGameServerData() == null ^ this.getGameServerData() == null)
            return false;
        if (other.getGameServerData() != null && other.getGameServerData().equals(this.getGameServerData()) == false)
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;

        hashCode = prime * hashCode + ((getGameServerGroupName() == null) ? 0 : getGameServerGroupName().hashCode());
        hashCode = prime * hashCode + ((getGameServerId() == null) ? 0 : getGameServerId().hashCode());
        hashCode = prime * hashCode + ((getInstanceId() == null) ? 0 : getInstanceId().hashCode());
        hashCode = prime * hashCode + ((getConnectionInfo() == null) ? 0 : getConnectionInfo().hashCode());
        hashCode = prime * hashCode + ((getGameServerData() == null) ? 0 : getGameServerData().hashCode());
        return hashCode;
    }

    @Override
    public RegisterGameServerRequest clone() {
        return (RegisterGameServerRequest) super.clone();
    }

}
```


Overlapping Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class RegisterGameServerRequest extends com.amazonaws.AmazonWebServiceRequest implements Serializable, Cloneable {
/**
* <p>
* A unique identifier for the game server group where the game server is running. Use either the
* <a>GameServerGroup</a> name or ARN value.
* </p>
*/
private String gameServerGroupName;
/**
* <p>
* A custom string that uniquely identifies the game server to register. Game server IDs are developer-defined and
* must be unique across all game server groups in your AWS account.
* </p>
*/
private String gameServerId;
/**
* <p>
* The unique identifier for the instance where the game server is running. This ID is available in the instance
* metadata. EC2 instance IDs use a 17-character format, for example: <code>i-1234567890abcdef0</code>.
* </p>
*/
private String instanceId;
/**
* <p>
* Information that is needed to make inbound client connections to the game server. This might include the IP
* address and port, DNS name, and other information.
* </p>
*/
private String connectionInfo;
/**
* <p>
* A set of custom game server properties, formatted as a single string value. This data is passed to a game client
* or service when it requests information on game servers using <a>ListGameServers</a> or <a>ClaimGameServer</a>.
* </p>
*/
private String gameServerData;
/**
* <p>
* A unique identifier for the game server group where the game server is running. Use either the
* <a>GameServerGroup</a> name or ARN value.
* </p>
* 
* @param gameServerGroupName
* A unique identifier for the game server group where the game server is running. Use either the
* <a>GameServerGroup</a> name or ARN value.
*/
public void setGameServerGroupName(String gameServerGroupName) {
this.gameServerGroupName = gameServerGroupName;
}
/**
* <p>
* A unique identifier for the game server group where the game server is running. Use either the
* <a>GameServerGroup</a> name or ARN value.
* </p>
* 
* @return A unique identifier for the game server group where the game server is running. Use either the
* <a>GameServerGroup</a> name or ARN value.
*/
public String getGameServerGroupName() {
return this.gameServ
```
<Overlap Ratio: 0.9995425434583715>

---

--- 140 --
Question ID: cc796e610bc57d084c97b5d05ead33dd1711c3c7_0
Original Code:
```
public class NewZenUmlBufferAction extends DumbAwareAction {

    private static int nextBufferIndex() {
        try {
            Method method = ScratchFileActions.class.getDeclaredMethod("nextBufferIndex");
            method.setAccessible(true);
            return (int) method.invoke(null);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("No such method: ScratchFileActions.nextBufferIndex", e);
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    static ScratchFileCreationHelper.Context createContext(@NotNull AnActionEvent event, @NotNull Project project) {
        try {
            Method method = ScratchFileActions.class.getDeclaredMethod("createContext", AnActionEvent.class);
            method.setAccessible(true);
            return (ScratchFileCreationHelper.Context) method.invoke(null, event);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("No such method: ScratchFileActions.createContext", e);
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    static void doCreateNewScratch(@NotNull Project project, @NotNull ScratchFileCreationHelper.Context context) {
        try {
            Method method = ScratchFileActions.class.getDeclaredMethod("doCreateNewScratch", Project.class, ScratchFileCreationHelper.Context.class);
            method.setAccessible(true);
            method.invoke(null, project, context);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("No such method: ScratchFileActions.doCreateNewScratch", e);
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

        @Override
    public void update(@NotNull AnActionEvent e) {
        boolean enabled = e.getProject() != null && Registry.intValue("ide.scratch.buffers") > 0;
        e.getPresentation().setEnabledAndVisible(enabled);
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent e) {
        Project project = e.getProject();
        if (project == null) return;
        ScratchFileCreationHelper.Context context = createContext(e, project);
        context.text = e.getDataContext().getData("predefined.text.value").toString();
        context.filePrefix = "zenuml";
        context.createOption = ScratchFileService.Option.create_if_missing;
        context.fileCounter = NewZenUmlBufferAction::nextBufferIndex;
        context.language = getLanguage();
        doCreateNewScratch(project, context);
    }

    private Language getLanguage() {
        Language zenUML = Language.findLanguageByID("ZenUML");
        return zenUML != null ? zenUML : StdLanguages.TEXT;
    }
}
```


Overlapping Code:
```
ass NewZenUmlBufferAction extends DumbAwareAction {
private static int nextBufferIndex() {
try {
Method method = ScratchFileActions.class.getDeclaredMethod("nextBufferIndex");
method.setAccessible(true);
return (int) method.invoke(null);
} catch (NoSuchMethodException e) {
throw new RuntimeException("No such method: ScratchFileActions.nextBufferIndex", e);
} catch (IllegalAccessException | InvocationTargetException e) {
throw new RuntimeException(e);
}
}
static ScratchFileCreationHelper.Context createContext(@NotNull AnActionEvent event, @NotNull Project project) {
try {
Method method = ScratchFileActions.class.getDeclaredMethod("createContext", AnActionEvent.class);
method.setAccessible(true);
return (ScratchFileCreationHelper.Context) method.invoke(null, event);
} catch (NoSuchMethodException e) {
throw new RuntimeException("No such method: ScratchFileActions.createContext", e);
} catch (IllegalAccessException | InvocationTargetException e) {
throw new RuntimeException(e);
}
}
static void doCreateNewScratch(@NotNull Project project, @NotNull ScratchFileCreationHelper.Context context) {
try {
Method method = ScratchFileActions.class.getDeclaredMethod("doCreateNewScratch", Project.class, ScratchFileCreationHelper.Context.class);
method.setAccessible(true);
method.invoke(null, project, context);
} catch (NoSuchMethodException e) {
throw new RuntimeException("No such method: ScratchFileActions.doCreateNewScratch", e);
} catch (IllegalAccessException | InvocationTargetException e) {
throw new RuntimeException(e);
}
}
@Override
public void update(@NotNull AnActionEvent e) {
boolean enabled = e.getProject() != null && Registry.intValue("ide.scratch.buffers") > 0;
e.getPresentation().setEnabledAndVisible(enabled);
}
@Override
public void actionPerformed(@NotNull AnActionEvent e) {
Project project = e.getProject();
if (project == null) return;
ScratchFileCreationHelper.Context context = createContext(e, project);
context.text = e.getDataContext().getData("predefined.text.value").toString();
context.filePrefix = "zenuml";
context.createOption = ScratchFileService.Optio
```
<Overlap Ratio: 0.9957264957264957>

---

--- 141 --
Question ID: 86a3a1bfa8fb25de9c5d752e4bd6da9fa5b872fe_1
Original Code:
```
class WordPublisher extends Handler<WordEnvelope> {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private final String topic;
    private final SendProducer<String, String> sendProducer;

    public WordPublisher(String topic, SendProducer<String, String> sendProducer) {
      this.topic = topic;
      this.sendProducer = sendProducer;
    }

    @Override
    public CompletionStage<Done> process(WordEnvelope envelope) {
      String word = envelope.word;
      // using the word as the key and `DefaultPartitioner` will select partition based on the key
      // so that same word always ends up in same partition
      String key = word;
      ProducerRecord<String, String> producerRecord = new ProducerRecord<>(topic, key, word);
      CompletionStage<RecordMetadata> result = sendProducer.send(producerRecord);
      CompletionStage<Done> done =
          result.thenApply(
              recordMetadata -> {
                logger.info(
                    "Published word [{}] to topic/partition {}/{}",
                    word,
                    topic,
                    recordMetadata.partition());
                return Done.getInstance();
              });
      return done;
    }
  }
```


Overlapping Code:
```
Publisher extends Handler<WordEnvelope> {
private final Logger logger = LoggerFactory.getLogger(getClass());
private final String topic;
private final SendProducer<String, String> sendProducer;
public WordPublisher(String topic, SendProducer<String, String> sendProducer) {
this.topic = topic;
this.sendProducer = sendProducer;
}
@Override
public CompletionStage<Done> process(WordEnvelope envelope) {
String word = envelope.word;
// using the word as the key and `DefaultPartitioner` will select partition based on the key
// so that same word always ends up in same partition
String key = word;
ProducerRecord<String, String> producerRecord = new ProducerRecord<>(topic, key, word);
CompletionStage<RecordMetadata> result = sendProducer.send(producerRecord);
CompletionStage<Done> done =
result.thenApply(
recordMetadata -> {
logger.info(
"Published word [{}] to topic/partition {}/{}",
word,
topic,
recordMetadata.partition());
return Done.getInst
```
<Overlap Ratio: 0.9615384615384616>

---

--- 142 --
Question ID: 30b43951ad5eee1293c46ed19eef06130536df62_0
Original Code:
```
public class KHashingPanel extends JPanel {
  private static final JLabel LABEL = new JLabel("Choose one of 3 options below.");

  private static final JLabel LABEL_EMPTY_1 = new JLabel(" ");
  private static final JLabel LABEL_OPTION_1 = new JLabel("1. Get SHA3 of a chosen file.");
  private static final JButton BUTTON_OPTION_1 = new JButton("SHA3 - file");

  private static final JLabel LABEL_EMPTY_2 = new JLabel(" ");
  private static final JLabel LABEL_OPTION_2 = new JLabel(
      "2. Get SHA3 of an input text. Enter your text in blank field below.");
  private static final JTextArea TEXT_OPTION_2 = new JTextArea();
  private static final JScrollPane SCROLL_OPTION_2 = new JScrollPane(TEXT_OPTION_2);
  private static final JButton BUTTON_OPTION_2 = new JButton("SHA3 - text input");

  private static final JLabel LABEL_EMPTY_3 = new JLabel(" ");
  private static final JLabel LABEL_OPTION_3 = new JLabel(
      "3. Get MAC of a chosen file. Enter MAC passphrase below (empty field is an empty passphrase)");
  private static final JTextArea TEXT_OPTION_3 = new JTextArea();
  private static final JScrollPane SCROLL_OPTION_3 = new JScrollPane(TEXT_OPTION_3);
  private static final JButton BUTTON_OPTION_3 = new JButton("MAC - file");

  private static final JLabel LABEL_EMPTY_4 = new JLabel(" ");

  public KHashingPanel(JTextArea console) {
    this.setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));
    TEXT_OPTION_2.setLineWrap(true);
    TEXT_OPTION_3.setLineWrap(true);

    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Exception e) {
      System.out.println(e);
    }

    addButtonBehavior(console);

    this.add(LABEL);

    this.add(LABEL_EMPTY_1);
    this.add(LABEL_OPTION_1);
    this.add(BUTTON_OPTION_1);

    this.add(LABEL_EMPTY_2);
    this.add(LABEL_OPTION_2);
    this.add(SCROLL_OPTION_2);
    this.add(BUTTON_OPTION_2);

    this.add(LABEL_EMPTY_3);
    this.add(LABEL_OPTION_3);
    this.add(SCROLL_OPTION_3);
    this.add(BUTTON_OPTION_3);

    this.add(LABEL_EMPTY_4);

    this.setVisible(true);

  }

  /**
   * A helper method to add listener to components
   */
  private void addButtonBehavior(JTextArea console) {
    BUTTON_OPTION_1.addActionListener(event -> {
      final File directory = UtilGui.fileBrowse();
      String outval = directory == null ? "Error: You must chose a file!"
          : "SHA3 of your file is: " + KCrypt.get_sha3_file(directory);
      console.setText(outval);
    });
    BUTTON_OPTION_2.addActionListener(event -> {
      final String m = TEXT_OPTION_2.getText();
      console.setText("SHA3 of your text input is: " + KCrypt.get_sha3_text(m));
    });
    BUTTON_OPTION_3.addActionListener(event -> {
      final File directory = UtilGui.fileBrowse();
      String passphrase = TEXT_OPTION_3.getText();
      String outval = directory == null ? "Error: You must chose a file!"
          : "MAC of your file is: " + KCrypt.get_mac_file(directory, passphrase);
      console.setText(outval);

    });
  }
}
```


Overlapping Code:
```
gPanel extends JPanel {
private static final JLabel LABEL = new JLabel("Choose one of 3 options below.");
private static final JLabel LABEL_EMPTY_1 = new JLabel(" ");
private static final JLabel LABEL_OPTION_1 = new JLabel("1. Get SHA3 of a chosen file.");
private static final JButton BUTTON_OPTION_1 = new JButton("SHA3 - file");
private static final JLabel LABEL_EMPTY_2 = new JLabel(" ");
private static final JLabel LABEL_OPTION_2 = new JLabel(
"2. Get SHA3 of an input text. Enter your text in blank field below.");
private static final JTextArea TEXT_OPTION_2 = new JTextArea();
private static final JScrollPane SCROLL_OPTION_2 = new JScrollPane(TEXT_OPTION_2);
private static final JButton BUTTON_OPTION_2 = new JButton("SHA3 - text input");
private static final JLabel LABEL_EMPTY_3 = new JLabel(" ");
private static final JLabel LABEL_OPTION_3 = new JLabel(
"3. Get MAC of a chosen file. Enter MAC passphrase below (empty field is an empty passphrase)");
private static final JTextArea TEXT_OPTION_3 = new JTextArea();
private static final JScrollPane SCROLL_OPTION_3 = new JScrollPane(TEXT_OPTION_3);
private static final JButton BUTTON_OPTION_3 = new JButton("MAC - file");
private static final JLabel LABEL_EMPTY_4 = new JLabel(" ");
public KHashingPanel(JTextArea console) {
this.setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));
TEXT_OPTION_2.setLineWrap(true);
TEXT_OPTION_3.setLineWrap(true);
try {
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
} catch (Exception e) {
System.out.println(e);
}
addButtonBehavior(console);
this.add(LABEL);
this.add(LABEL_EMPTY_1);
this.add(LABEL_OPTION_1);
this.add(BUTTON_OPTION_1);
this.add(LABEL_EMPTY_2);
this.add(LABEL_OPTION_2);
this.add(SCROLL_OPTION_2);
this.add(BUTTON_OPTION_2);
this.add(LABEL_EMPTY_3);
this.add(LABEL_OPTION_3);
this.add(SCROLL_OPTION_3);
this.add(BUTTON_OPTION_3);
this.add(LABEL_EMPTY_4);
this.setVisible(true);
}
/**
* A helper method to add listener to components
*/
private void addButtonBehavior(JTextArea console) {
BUTTON_OPTION_1.addActionListener(event -> {
final File directory = UtilGui.fileBrowse();
String outval = directory == null ? "Error: You must chose a file!"
: "SHA3 of your file is: " + KCrypt.get_sha3_file(directory);
con
```
<Overlap Ratio: 0.9803921568627451>

---

--- 143 --
Question ID: 8bea51c7a9477acd7f8c3cb187c06671128097f1_0
Original Code:
```
public class NormGrammar implements INormGrammar, Serializable {

    private static final long serialVersionUID = -13739894962185282L;

    // all files used in this grammar
    private final Set<File> filesRead;

    // factory to create all symbols in the grammar
    private final GrammarFactory gf;

    private IProduction initialProduction;

    // all symbols in this grammar
    private final Set<ISymbol> symbols;

    // to handle Sort.Cons in priorities
    private final Map<ProductionReference, Production> sortConsProductionMapping;

    // merging same productions with different attributes
    private final SetMultimap<IProduction, IAttribute> productionAttributesMapping;

    // constructor attributes
    private final Map<IProduction, ConstructorAttribute> constructors;

    // necessary for calculating deep priority conflicts
    private final Map<UniqueProduction, Production> uniqueProductionMapping;
    private final BiMap<Production, ContextualProduction> prodContextualProdMapping;
    private final Set<ContextualProduction> derivedContextualProds;
    private final Set<ContextualSymbol> contextualSymbols;
    private final SetMultimap<ISymbol, ISymbol> leftRecursiveSymbolsMapping;
    private final SetMultimap<ISymbol, ISymbol> rightRecursiveSymbolsMapping;
    private final SetMultimap<Symbol, Production> longestMatchProdsFront;
    private final SetMultimap<Symbol, Production> shortestMatchProdsFront;
    private final SetMultimap<Symbol, Production> longestMatchProdsBack;
    private final SetMultimap<Symbol, Production> shortestMatchProdsBack;

    // priorities
    private final Set<Priority> transitivePriorities;
    private final Set<Priority> nonTransitivePriorities;
    private final SetMultimap<Priority, Integer> priorities;
    private final SetMultimap<Priority, Integer> indexedPriorities;

    // extra collections to calculate the transitive closure
    private final Set<Production> productionsOnPriorities;
    private final SetMultimap<Priority, Integer> transitivePriorityArgs;
    private final SetMultimap<Priority, Integer> nonTransitivePriorityArgs;
    private final SetMultimap<Production, Priority> higherPriorityProductions;

    private final HashMap<String, Symbol> cacheSymbolsRead; // caching symbols read
    private final HashMap<String, Production> cacheProductionsRead; // caching productions read

    // get all productions for a certain symbol
    private final SetMultimap<ISymbol, IProduction> symbolProductionsMapping;

    // get all productions that contain a particular literal
    private final SetMultimap<ISymbol, IProduction> literalProductionsMapping;

    // expression grammars per non-terminal
    private final SetMultimap<ISymbol, IProduction> expressionGrammars;

    // expression grammars collapsed
    private final Set<Set<IProduction>> combinedExpressionGrammars;

    // left and right derivable symbols from a symbol
    private final SetMultimap<ISymbol, ISymbol> leftDerivable;
    private final SetMultimap<ISymbol, ISymbol> rightDerivable;

    public NormGrammar() {
        this.filesRead = Sets.newHashSet();
        this.gf = new GrammarFactory();
        this.uniqueProductionMapping = Maps.newLinkedHashMap();
        this.sortConsProductionMapping = Maps.newHashMap();
        this.prodContextualProdMapping = HashBiMap.create();
        this.leftRecursiveSymbolsMapping = HashMultimap.create();
        this.rightRecursiveSymbolsMapping = HashMultimap.create();
        this.derivedContextualProds = Sets.newHashSet();
        this.contextualSymbols = Sets.newHashSet();
        this.longestMatchProdsFront = LinkedHashMultimap.create();
        this.longestMatchProdsBack = LinkedHashMultimap.create();
        this.shortestMatchProdsFront = LinkedHashMultimap.create();
        this.shortestMatchProdsBack = LinkedHashMultimap.create();
        this.productionAttributesMapping = HashMultimap.create();
        this.priorities = HashMultimap.create();
        this.indexedPriorities = HashMultimap.create();
        this.constructors = Maps.newHashMap();
        this.transitivePriorities = Sets.newHashSet();
        this.nonTransitivePriorities = Sets.newHashSet();
        this.productionsOnPriorities = Sets.newHashSet();
        this.transitivePriorityArgs = HashMultimap.create();
        this.nonTransitivePriorityArgs = HashMultimap.create();
        this.higherPriorityProductions = HashMultimap.create();
        this.symbolProductionsMapping = HashMultimap.create();
        this.cacheSymbolsRead = Maps.newHashMap();
        this.cacheProductionsRead = Maps.newHashMap();
        this.symbols = Sets.newHashSet();
        this.literalProductionsMapping = HashMultimap.create();
        this.expressionGrammars = HashMultimap.create();
        this.combinedExpressionGrammars = Sets.newHashSet();
        this.leftDerivable = HashMultimap.create();
        this.rightDerivable = HashMultimap.create();
    }

    public Map<UniqueProduction, Production> syntax() {
        return getUniqueProductionMapping();
    }

    public void priorityTransitiveClosure() {

        // Floyd Warshall Algorithm to calculate the transitive closure
        for(Production intermediate_prod : getProductionsOnPriorities()) {
            for(Production first_prod : getProductionsOnPriorities()) {
                for(Production second_prod : getProductionsOnPriorities()) {
                    Priority first_sec = gf.createPriority(first_prod, second_prod, true);
                    Priority first_k = gf.createPriority(first_prod, intermediate_prod, true);
                    Priority k_second = gf.createPriority(intermediate_prod, second_prod, true);
                    // if there is no priority first_prod > second_prod
                    if(!getTransitivePriorities().contains(first_sec)) {
                        // if there are priorities first_prod > intermediate_prod and
                        // intermediate_prod > second_prod
                        // add priority first_prod > second_prod
                        if(getTransitivePriorities().contains(first_k)
                            && getTransitivePriorities().contains(k_second)) {
                            getTransitivePriorities().add(first_sec);
                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));
                        }
                    } else {
                        if(getTransitivePriorities().contains(first_k)
                            && getTransitivePriorities().contains(k_second)) {
                            getTransitivePriorityArgs().putAll(first_sec, getTransitivePriorityArgs().get(first_k));
                        }
                    }
                }
            }
        }

        priorities.putAll(getNonTransitivePriorityArgs());
        priorities.putAll(getTransitivePriorityArgs());
    }


    public IProduction getInitialProduction() {
        return initialProduction;
    }

    public SetMultimap<Priority, Integer> priorities() {
        return priorities;
    }

    public Set<File> getFilesRead() {
        return filesRead;
    }

    public Set<ISymbol> getSymbols() {
        return symbols;
    }

    public Map<ProductionReference, Production> getSortConsProductionMapping() {
        return sortConsProductionMapping;
    }

    public SetMultimap<IProduction, IAttribute> getProductionAttributesMapping() {
        return productionAttributesMapping;
    }

    public Map<UniqueProduction, Production> getUniqueProductionMapping() {
        return uniqueProductionMapping;
    }

    public BiMap<Production, ContextualProduction> getProdContextualProdMapping() {
        return prodContextualProdMapping;
    }

    public Set<ContextualProduction> getDerivedContextualProds() {
        return derivedContextualProds;
    }

    public Set<ContextualSymbol> getContextualSymbols() {
        return contextualSymbols;
    }

    public SetMultimap<ISymbol, ISymbol> getLeftRecursiveSymbolsMapping() {
        return leftRecursiveSymbolsMapping;
    }

    public SetMultimap<ISymbol, ISymbol> getRightRecursiveSymbolsMapping() {
        return rightRecursiveSymbolsMapping;
    }

    public SetMultimap<Symbol, Production> getLongestMatchProdsFront() {
        return longestMatchProdsFront;
    }

    public SetMultimap<Symbol, Production> getLongestMatchProdsBack() {
        return longestMatchProdsBack;
    }

    public SetMultimap<Symbol, Production> getShortestMatchProdsFront() {
        return shortestMatchProdsFront;
    }

    public SetMultimap<Symbol, Production> getShortestMatchProdsBack() {
        return shortestMatchProdsBack;
    }

    public Set<Priority> getTransitivePriorities() {
        return transitivePriorities;
    }

    public Set<Priority> getNonTransitivePriorities() {
        return nonTransitivePriorities;
    }

    public Set<Production> getProductionsOnPriorities() {
        return productionsOnPriorities;
    }

    public SetMultimap<Priority, Integer> getTransitivePriorityArgs() {
        return transitivePriorityArgs;
    }

    public SetMultimap<Priority, Integer> getNonTransitivePriorityArgs() {
        return nonTransitivePriorityArgs;
    }

    public HashMap<String, Symbol> getCacheSymbolsRead() {
        return cacheSymbolsRead;
    }

    public HashMap<String, Production> getCacheProductionsRead() {
        return cacheProductionsRead;
    }

    public SetMultimap<ISymbol, IProduction> getSymbolProductionsMapping() {
        return symbolProductionsMapping;
    }

    public SetMultimap<Production, Priority> getHigherPriorityProductions() {
        return higherPriorityProductions;
    }

    public void normalizeFollowRestrictionLookahead() {
        for(ISymbol s : symbols) {
            s.normalizeFollowRestrictionLookahead();
        }
    }

    public Map<IProduction, ConstructorAttribute> getConstructors() {
        return constructors;
    }

    public SetMultimap<ISymbol, IProduction> getLiteralProductionsMapping() {
        return literalProductionsMapping;
    }

    public SetMultimap<ISymbol, IProduction> getExpressionGrammars() {
        return expressionGrammars;
    }

    public Set<Set<IProduction>> getCombinedExpressionGrammars() {
        return combinedExpressionGrammars;
    }

    public void setInitialProduction(Production prod) {
        this.initialProduction = prod;
    }

    public SetMultimap<Priority, Integer> getIndexedPriorities() {
        return indexedPriorities;
    }

    public GrammarFactory getGrammarFactory() {
        return gf;
    }

    public void cleanupGrammar() {
        this.cacheProductionsRead.clear();
        this.cacheSymbolsRead.clear();
        this.combinedExpressionGrammars.clear();
        this.contextualSymbols.clear();
        this.derivedContextualProds.clear();
        this.expressionGrammars.clear();
        this.leftRecursiveSymbolsMapping.clear();
        this.rightRecursiveSymbolsMapping.clear();
        this.literalProductionsMapping.clear();
        this.longestMatchProdsBack.clear();
        this.longestMatchProdsFront.clear();
        this.nonTransitivePriorities.clear();
        this.nonTransitivePriorityArgs.clear();
        this.productionsOnPriorities.clear();
        this.symbolProductionsMapping.clear();
        this.transitivePriorities.clear();
        this.transitivePriorityArgs.clear();
        this.filesRead.clear();
    }

    public SetMultimap<ISymbol, ISymbol> getLeftDerivable() {
        return leftDerivable;
    }

    public SetMultimap<ISymbol, ISymbol> getRightDerivable() {
        return rightDerivable;
    }

}
```


Overlapping Code:
```
c class NormGrammar implements INormGrammar, Serializable {
private static final long serialVersionUID = -13739894962185282L;
// all files used in this grammar
private final Set<File> filesRead;
// factory to create all symbols in the grammar
private final GrammarFactory gf;
private IProduction initialProduction;
// all symbols in this grammar
private final Set<ISymbol> symbols;
// to handle Sort.Cons in priorities
private final Map<ProductionReference, Production> sortConsProductionMapping;
// merging same productions with different attributes
private final SetMultimap<IProduction, IAttribute> productionAttributesMapping;
// constructor attributes
private final Map<IProduction, ConstructorAttribute> constructors;
// necessary for calculating deep priority conflicts
private final Map<UniqueProduction, Production> uniqueProductionMapping;
private final BiMap<Production, ContextualProduction> prodContextualProdMapping;
private final Set<ContextualProduction> derivedContextualProds;
private final Set<ContextualSymbol> contextualSymbols;
private final SetMultimap<ISymbol, ISymbol> leftRecursiveSymbolsMapping;
private final SetMultimap<ISymbol, ISymbol> rightRecursiveSymbolsMapping;
private final SetMultimap<Symbol, Production> longestMatchProdsFront;
private final SetMultimap<Symbol, Production> shortestMatchProdsFront;
private final SetMultimap<Symbol, Production> longestMatchProdsBack;
private final SetMultimap<Symbol, Production> shortestMatchProdsBack;
// priorities
private final Set<Priority> transitivePriorities;
private final Set<Priority> nonTransitivePriorities;
private final SetMultimap<Priority, Integer> priorities;
private final SetMultimap<Priority, Integer> indexedPriorities;
// extra collections to calculate the transitive closure
private final Set<Production> productionsOnPriorities;
private final SetMultimap<Priority, Integer> transitivePriorityArgs;
private final SetMultimap<Priority, Integer> nonTransitivePriorityArgs;
private final SetMultimap<Production, Priority> higherPriorityProductions;
private final HashMap<String, Symbol> cacheSymbolsRead; // caching symbols read
private final HashMap<String, Production> cacheProductionsRead; // caching productions read
// get all productions for a certain symbol
private final SetMultimap<ISymbol, IProdu
```
<Overlap Ratio: 0.9871244635193133>

---

--- 144 --
Question ID: 0129bba8e6670e159e58ac1642fa9d85cc3c37d7_0
Original Code:
```
public class CompositeCredentialsRepository<T extends Credentials> {
  private Map<String, CredentialsRepository<? extends T>> allRepositories;

  public CompositeCredentialsRepository(List<CredentialsRepository<? extends T>> repositories) {
    allRepositories = new HashMap<>();
    repositories.forEach(this::registerRepository);
  }

  public void registerRepository(CredentialsRepository<? extends T> repository) {
    allRepositories.put(repository.getType(), repository);
  }

  public T getCredentials(String credentialsName, String type) {
    CredentialsRepository<? extends T> repository = allRepositories.get(type);
    if (repository == null) {
      throw new UnknownCredentialsTypeException("No credentials of type '" + type + "' found");
    }

    T creds = repository.getOne(credentialsName);
    if (creds == null) {
      throw new MissingCredentialsException(
          "Credentials '" + credentialsName + "' of type '" + type + "' cannot be found");
    }
    return creds;
  }

  /**
   * Helper method during migration from single to multiple credential repositories
   *
   * @param name
   * @return Account with the given name across all repositories
   */
  @Nullable
  public T getFirstCredentialsWithName(String name) {
    return allRepositories.values().stream()
        .map(r -> r.getOne(name))
        .filter(Objects::nonNull)
        .findFirst()
        .orElse(null);
  }

  /** @return All credentials across all repositories */
  public List<T> getAllCredentials() {
    return Collections.unmodifiableList(
        allRepositories.values().stream()
            .map(CredentialsRepository::getAll)
            .flatMap(Collection::stream)
            .collect(Collectors.toList()));
  }
}
```


Overlapping Code:
```
sRepository<T extends Credentials> {
private Map<String, CredentialsRepository<? extends T>> allRepositories;
public CompositeCredentialsRepository(List<CredentialsRepository<? extends T>> repositories) {
allRepositories = new HashMap<>();
repositories.forEach(this::registerRepository);
}
public void registerRepository(CredentialsRepository<? extends T> repository) {
allRepositories.put(repository.getType(), repository);
}
public T getCredentials(String credentialsName, String type) {
CredentialsRepository<? extends T> repository = allRepositories.get(type);
if (repository == null) {
throw new UnknownCredentialsTypeException("No credentials of type '" + type + "' found");
}
T creds = repository.getOne(credentialsName);
if (creds == null) {
throw new MissingCredentialsException(
"Credentials '" + credentialsName + "' of type '" + type + "' cannot be found");
}
return creds;
}
/**
* Helper method during migration from single to multiple credential repositories
*
* @param name
* @return Account with the given name across all repositories
*/
@Nullable
public T getFirstCredentialsWithName(String name) {
return allRepositories.values().stream()
.map(r -> r.getOne(name))
.filter(Objects::nonNull)
.findFirst()
.orElse(null);
}
/** @return All credentials across all repositories */
public List<T> getAllCredentials() {
return Collections.unmodifiableList(
allRepositories.values().stream()
.map(CredentialsRepository::getAll)
.flatMap(Collection::stream)
.collect(Collectors.toList()));
}
}
```
<Overlap Ratio: 0.9791395045632334>

---

--- 145 --
Question ID: 5d20351af1ca40e6f69d30e686093f8186a2d643_0
Original Code:
```
@RunWith(Theories.class)
public class OtherwiseDeceasedFeatureTest extends EmbeddedDatabaseTest {

    @Resource
    private OtherwiseDeceasedFeature feature;

    @Resource
    private OtherwiseDeceasedRepository otherwiseDeceasedRepository;

    @Resource
    private OtherwiseDeceasedChangeRepository changeRepository;

    private SystemUser privilegedModerator;

    private SystemUser notAuthorised;

    private EntitySupplier es;

    private GameSpecies gameSpecies1;
    private GameSpecies gameSpecies2;

    private GeoLocation location1;
    private GeoLocation location2;

    private Municipality municipality1;
    private Municipality municipality2;

    private Riistanhoitoyhdistys rhy1;
    private Riistanhoitoyhdistys rhy2;

    @Before
    public void setUp() {
        es = getEntitySupplier();
        privilegedModerator = createNewModerator(SystemUserPrivilege.MUUTOIN_KUOLLEET);
        notAuthorised = createNewModerator();
        gameSpecies1 = es.newGameSpecies();
        gameSpecies2 = es.newGameSpecies();
        location1 = geoLocation();
        location2 = geoLocation();
        municipality1 = es.newMunicipality();
        municipality2 = es.newMunicipality();
        rhy1 = es.newRiistanhoitoyhdistys();
        rhy2 = es.newRiistanhoitoyhdistys();
        persistInNewTransaction();
    }

    @Test(expected = AccessDeniedException.class)
    public void listByYear_moderatorMustHavePrivilege() {
        onSavedAndAuthenticated(notAuthorised, () -> feature.listByYear(2021));
    }

    @Test
    public void listByYear_returnsEmptyListIfNoneFound() {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);
            assertThat(results, hasSize(0));
        });
    }

    @Test
    public void listByYear_andOnlyByThatYear() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased(new DateTime(2021, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));
        es.newOtherwiseDeceased(new DateTime(2020, 12, 31, 23, 59, 59, 999, Constants.DEFAULT_TIMEZONE));
        es.newOtherwiseDeceased(new DateTime(2022, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));

        onSavedAndAuthenticated(privilegedModerator, () -> {
            runInTransaction(() -> {
                final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);
                assertThat(results, hasSize(1));

                final OtherwiseDeceasedBriefDTO result = results.get(0);
                assertThat(result.getPointOfTime(), equalTo(item.getPointOfTime().toLocalDateTime()));
                assertThat(result.getCause(), equalTo(item.getCause()));
                assertThat(result.getGameSpeciesCode(), equalTo(item.getSpecies().getOfficialCode()));
                assertThat(result.getMunicipality().getNameFI(),
                           equalTo(item.getMunicipality().getNameLocalisation().getFinnish()));
                assertThat(result.getRhy().getNameFI(), equalTo(item.getRhy().getNameFinnish()));
                assertThat(result.getRka().getNameFI(), equalTo(item.getRka().getNameFinnish()));
            });
        });
    }

    @Test(expected = AccessDeniedException.class)
    public void getDetails_moderatorMustHavePrivilege() {
        onSavedAndAuthenticated(notAuthorised, () -> feature.getDetails(1));
    }

    @Test(expected = NotFoundException.class)
    public void getDetails_throwsExceptionIfNotFound() {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            feature.getDetails(1);
        });
    }

    @Theory
    public void getDetails_causeAndSourceValues(final OtherwiseDeceasedCause cause,
                                                final OtherwiseDeceasedSource source) {
        final OtherwiseDeceased item = es.newOtherwiseDeceased(cause, source);
        onSavedAndAuthenticated(privilegedModerator, () -> {
            runInTransaction(() -> {
                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());
                assertThatEquals(result, item);
                checkOutgoingDtoFields(result);
            });
        });
    }

    @Theory
    public void getDetails_ageAndGenderValues(final GameAge age, final GameGender gender) {
        final OtherwiseDeceased item = es.newOtherwiseDeceased(age, gender);
        onSavedAndAuthenticated(privilegedModerator, () -> {
            runInTransaction(() -> {
                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());
                assertThatEquals(result, item);
                checkOutgoingDtoFields(result);
            });
        });
    }

    @Test
    public void getDetails_optionalFieldsCanBeNull() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased();
        item.setWeight(null);
        item.setDescription(null);
        item.setAdditionalInfo(null);
        item.setCauseOther(null);
        item.setSourceOther(null);
        onSavedAndAuthenticated(privilegedModerator, () -> {
            runInTransaction(() -> {
                OtherwiseDeceasedDTO result = feature.getDetails(item.getId());
                assertThat(result.getWeight(), is(nullValue()));
                assertThat(result.getDescription(), is(nullValue()));
                assertThat(result.getAdditionalInfo(), is(nullValue()));
                assertThat(result.getCauseOther(), is(nullValue()));
                assertThat(result.getSourceOther(), is(nullValue()));
                assertThatEquals(result, item);
                checkOutgoingDtoFields(result);
            });
        });
    }

    @Test(expected = AccessDeniedException.class)
    public void save_moderatorMustHavePrivilege() {
        onSavedAndAuthenticated(notAuthorised, () -> {
            feature.save(newOtherwiseDeceasedDTO());
        });
    }

    @Theory
    public void save_andCreate_withAgeAndGender(final GameAge age, final GameGender gender) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();
            input.setAge(age);
            input.setGender(gender);
            saveAndCheckDTO(input);
        });
    }

    @Theory
    public void save_andCreate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();
            input.setCause(cause);
            input.setSource(source);
            saveAndCheckDTO(input);
        });
    }

    @Theory
    public void save_andCreate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO input = newOtherwiseDeceasedDTO();
            input.setRejected(isRejected);
            input.setNoExactLocation(noExactLocation);
            saveAndCheckDTO(input);
        });
    }

    @Theory
    public void save_andUpdate_withAgeAndGender(final GameAge age, final GameGender gender) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setAge(age);
            created.setGender(gender);
            created.setReasonForChange("Reason for change");
            updateAndCheckDTO(created);
        });
    }

    @Theory
    public void save_andUpdate_withCauseAndSource(final OtherwiseDeceasedCause cause, final OtherwiseDeceasedSource source) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setCause(cause);
            created.setSource(source);
            created.setReasonForChange("Reason for change");
            updateAndCheckDTO(created);
        });
    }

    @Theory
    public void save_andUpdate_withRejectedAndNoExactLocation(final boolean isRejected, final boolean noExactLocation) {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setRejected(isRejected);
            created.setNoExactLocation(noExactLocation);
            created.setReasonForChange("Reason for change");
            updateAndCheckDTO(created);
        });
    }

    @Test
    public void save_andUpdate_location() {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setGeoLocation(location2);
            final OtherwiseDeceasedDTO updated = feature.save(created);
            assertThat(updated.getGeoLocation(), equalTo(location2));
            assertThat(updated.getMunicipality(), is(notNullValue()));
            assertThat(updated.getRhy(), is(notNullValue()));
            assertThat(updated.getRka(), is(notNullValue()));
            assertThat(updated.getMunicipality(), not(equalTo(created.getMunicipality())));
            assertThat(updated.getRhy(), not(equalTo(created.getRhy())));
            assertThat(updated.getRka(), not(equalTo(created.getRka())));
        });
    }

    @Test
    public void save_andUpdate_species() {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setGameSpeciesCode(gameSpecies2.getOfficialCode());
            final OtherwiseDeceasedDTO updated = feature.save(created);
            assertThat(updated.getGameSpeciesCode(), equalTo(created.getGameSpeciesCode()));
        });
    }

    @Test(expected = NotFoundException.class)
    public void save_andUpdate_itemNotFound() {
        onSavedAndAuthenticated(privilegedModerator, () -> {
            final OtherwiseDeceasedDTO created = feature.save(newOtherwiseDeceasedDTO());
            created.setId(created.getId() + 1);
            feature.save(created);
        });
    }

    @Test(expected = AccessDeniedException.class)
    public void save_withAttachments_moderatorMustHavePrivilege() throws IOException {
        authenticate(notAuthorised);
        feature.save(newOtherwiseDeceasedDTO(), emptyList());
    }

    @Test
    public void save_withAttachments_butThereIsNone() throws IOException {
        authenticate(privilegedModerator);
        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();
        final OtherwiseDeceasedDTO saved = feature.save(dto, emptyList());
        assertThat(saved.getAttachments(), hasSize(0));
    }

    @Test
    public void save_withAttachments_andTheyExists() throws IOException {
        authenticate(privilegedModerator);
        final OtherwiseDeceasedDTO dto = newOtherwiseDeceasedDTO();
        final MultipartFile file = newAttachment();
        final OtherwiseDeceasedDTO saved = feature.save(dto, Arrays.asList(file));
        runInTransaction(() -> {
            assertThat(saved.getAttachments(), hasSize(1));
            assertThat(saved.getAttachments().get(0).getFilename(), equalTo(file.getOriginalFilename()));
        });
    }

    @Test(expected = AccessDeniedException.class)
    public void reject_moderatorMustHavePrivilege() {
        onSavedAndAuthenticated(notAuthorised, () -> feature.reject(1));
    }

    @Test(expected = NotFoundException.class)
    public void reject_itemNotFound() {
        onSavedAndAuthenticated(privilegedModerator, () -> feature.reject(1));
    }

    @Test
    public void reject_restoredItem() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased();
        onSavedAndAuthenticated(privilegedModerator, () -> {
            feature.reject(item.getId());
            runInTransaction(() -> {
                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);
                assertThat(saved.isRejected(), is(true));
                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);
                assertThat(changes, hasSize(1));
                final OtherwiseDeceasedChange change = changes.get(0);
                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.DELETE));
                assertThat(change.getReasonForChange(), is(nullValue()));
                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));
            });
        });
    }

    @Test
    public void reject_rejectedItem() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased();
        item.setRejected(true);
        onSavedAndAuthenticated(privilegedModerator, () -> {
            feature.reject(item.getId());
            runInTransaction(() -> {
                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);
                assertThat(saved.isRejected(), is(true));
                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);
                assertThat(changes, hasSize(0));
            });
        });
    }

    @Test(expected = AccessDeniedException.class)
    public void restore_moderatorMustHavePrivilege() {
        onSavedAndAuthenticated(notAuthorised, () -> feature.restore(1));
    }

    @Test(expected = NotFoundException.class)
    public void restore_itemNotFound() {
        onSavedAndAuthenticated(privilegedModerator, () -> feature.restore(1));
    }

    @Test
    public void restore_rejectedItem() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased();
        item.setRejected(true);
        onSavedAndAuthenticated(privilegedModerator, () -> {
            feature.restore(item.getId());
            runInTransaction(() -> {
                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);
                assertThat(saved.isRejected(), is(false));
                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);
                assertThat(changes, hasSize(1));
                final OtherwiseDeceasedChange change = changes.get(0);
                assertThat(change.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.RESTORE));
                assertThat(change.getReasonForChange(), is(nullValue()));
                assertThat(change.getUserId(), equalTo(privilegedModerator.getId()));
            });
        });
    }

    @Test
    public void restore_restoredItem() {
        final OtherwiseDeceased item = es.newOtherwiseDeceased();
        onSavedAndAuthenticated(privilegedModerator, () -> {
            feature.restore(item.getId());
            runInTransaction(() -> {
                final OtherwiseDeceased saved = otherwiseDeceasedRepository.findById(item.getId()).orElseThrow(NotFoundException::new);
                assertThat(saved.isRejected(), is(false));
                final List<OtherwiseDeceasedChange> changes = changeRepository.findAllByOtherwiseDeceasedOrderByPointOfTime(saved);
                assertThat(changes, hasSize(0));
            });
        });
    }

    private MultipartFile newAttachment() {
        final byte[] attachmentData = new byte[4096];
        new Random().nextBytes(attachmentData);
        final String filename = "test" + nextLong() + ".png";
        return new MockMultipartFile(filename, "//test/" + filename, "image/png", attachmentData);
    }

    private void saveAndCheckDTO(final OtherwiseDeceasedDTO input) {
        final OtherwiseDeceasedDTO output = feature.save(input);
        assertThatEquals(output, input);
        checkOutgoingDtoFields(output);
        checkSavedDtoFields(output);
        assertThat(output.isRejected(), is(false), "rejected should be false after creation");
        assertThat(output.getChangeHistory(), hasSize(1), "no change info");
        final OtherwiseDeceasedChangeDTO changeDTO = output.getChangeHistory().get(0);
        assertThat(changeDTO.getReasonForChange(), is(nullValue()), "change reason not null");
        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.CREATE), "change type not CREATE");
        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), "author id mismatch");
    }

    private void updateAndCheckDTO(final OtherwiseDeceasedDTO created) {
        final OtherwiseDeceasedDTO updated = feature.save(created);
        assertThatEquals(created, updated);
        checkOutgoingDtoFields(updated);
        checkSavedDtoFields(updated);
        assertThat(updated.isRejected(), is(false), "rejected should be false after creation");

        assertThat(updated.getChangeHistory(), hasSize(2), "no change info");
        final OtherwiseDeceasedChangeDTO changeDTO = updated.getChangeHistory().get(1);
        assertThat(changeDTO.getReasonForChange(), equalTo(created.getReasonForChange()), "change reason mismatch");
        assertThat(changeDTO.getChangeType(), equalTo(OtherwiseDeceasedChange.ChangeType.MODIFY), "change type not MODIFY");
        assertThat(changeDTO.getAuthor().getId(), equalTo(privilegedModerator.getId()), "author id mismatch");
    }

    private void assertThatEquals(final OtherwiseDeceasedDTO actual, final OtherwiseDeceasedDTO expected) {
        assertThat(actual.getGameSpeciesCode(), equalTo(expected.getGameSpeciesCode()), "species mismatch");
        assertThat(actual.getAge(), equalTo(expected.getAge()), "age mismatch");
        assertThat(actual.getGender(), equalTo(expected.getGender()), "gender mismatch");
        assertThat(actual.getWeight(), equalTo(expected.getWeight()), "weight mismatch");
        assertThat(actual.getPointOfTime(), equalTo(expected.getPointOfTime()), "pointOfTime mismatch");
        assertThat(actual.isNoExactLocation(), equalTo(expected.isNoExactLocation()), "isNoExactLocation mismatch");
        assertThat(actual.getGeoLocation(), equalTo(expected.getGeoLocation()), "geoLocation mismatch");
        assertThat(actual.getCause(), equalTo(expected.getCause()), "cause mismatch");
        assertThat(actual.getSource(), equalTo(expected.getSource()), "source mismatch");
        assertThat(actual.getDescription(), equalTo(expected.getDescription()), "description mismatch");
        assertThat(actual.getAdditionalInfo(), equalTo(expected.getAdditionalInfo()), "additionalInfo mismatch");
    }

    private void checkSavedDtoFields(final OtherwiseDeceasedDTO dto) {
        if (dto.getCauseOther() != null) {
            assertThat(dto.getCause(), equalTo(OtherwiseDeceasedCause.OTHER), "causeOther has value but cause is not OTHER");
        }

        if (dto.getSourceOther() != null) {
            assertThat(dto.getSource(), equalTo(OtherwiseDeceasedSource.OTHER), "sourceOther has value but source is not OTHER");
        }
    }

    private void assertThatEquals(final OtherwiseDeceasedDTO dto, final OtherwiseDeceased entity) {
        assertThat(dto.getId(), equalTo(entity.getId()), "id mismatch");
        assertThat(dto.getPointOfTime(), equalTo(entity.getPointOfTime().toLocalDateTime()));
        assertThat(dto.getGameSpeciesCode(), equalTo(entity.getSpecies().getOfficialCode()), "species mismatch");
        assertThat(dto.getAge(), equalTo(entity.getAge()), "age mismatch");
        assertThat(dto.getGender(), equalTo(entity.getGender()), "gender mismatch");
        assertThat(dto.getWeight(), equalTo(entity.getWeight()), "weight mismatch");
        assertThat(dto.getGeoLocation(), equalTo(entity.getGeoLocation()), "geoLocation mismatch");
        assertThat(dto.getMunicipality().getNameLocalisation(), equalTo(entity.getMunicipality().getNameLocalisation()), "municipality name");
        assertThat(dto.getRhy().getNameLocalisation(), equalTo(entity.getRhy().getNameLocalisation()), "rhy name mismatch");
        assertThat(dto.getRka().getNameLocalisation(), equalTo(entity.getRka().getNameLocalisation()), "rka name mismatch");
        assertThat(dto.getCause(), equalTo(entity.getCause()), "cause mismatch");
        assertThat(dto.getCauseOther(), equalTo(entity.getCauseOther()), "cause mismatch");
        assertThat(dto.getSource(), equalTo(entity.getSource()), "source mismatch");
        assertThat(dto.getSourceOther(), equalTo(entity.getSourceOther()), "sourceOther mismatch");
        assertThat(dto.getDescription(), equalTo(entity.getDescription()), "description mismatch");
        assertThat(dto.getAdditionalInfo(), equalTo(entity.getAdditionalInfo()), "additional info mismatch");
        assertThat(dto.isRejected(), equalTo(entity.isRejected()), "rejected mismatch");
        assertThat(dto.getAttachments(), hasSize(entity.getAttachments().size()), "attachment mismatch");
        assertThat(dto.getChangeHistory(), hasSize(entity.getChangeHistory().size()), "changes mismatch");
        assertThatAttachmentsEquals(dto.getAttachments(), entity.getAttachments());
        assertThatChangesEquals(dto.getChangeHistory(), entity.getChangeHistory());
    }

    private void assertThatAttachmentsEquals(final List<OtherwiseDeceasedAttachmentDTO> dtos,
                                             final List<OtherwiseDeceasedAttachment> entities) {
        assertThat(dtos, hasSize(entities.size()), "number of attachment mismatch");
        final Map<Long, OtherwiseDeceasedAttachment> entityMap = F.indexById(entities);
        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));
    }

    private void assertThatEquals(final OtherwiseDeceasedAttachmentDTO dto,
                                  final OtherwiseDeceasedAttachment entity) {
        assertThat(dto.getId(), equalTo(entity.getId()), "attachment id mismatch");
        assertThat(dto.getFilename(),
                   equalTo(entity.getAttachmentMetadata().getOriginalFilename()),
                   "attachment filename mismatch");
    }

    private void assertThatChangesEquals(final List<OtherwiseDeceasedChangeDTO> dtos,
                                         final List<OtherwiseDeceasedChange> entities) {
        assertThat(dtos, hasSize(entities.size()));
        final Map<Long, OtherwiseDeceasedChange> entityMap = F.indexById(entities);
        dtos.forEach(dto -> assertThatEquals(dto, entityMap.get(dto.getId())));
    }

    private void assertThatEquals(final OtherwiseDeceasedChangeDTO dto,
                                  final OtherwiseDeceasedChange entity) {
        assertThat(dto.getId(), equalTo(entity.getId()));
        assertThat(dto.getAuthor().getId(), equalTo(entity.getUserId()), "change author mismatch");
        assertThat(dto.getModificationTime(), equalTo(entity.getPointOfTime()), "change pointOfTime mismatch");
        assertThat(dto.getChangeType(), equalTo(entity.getChangeType()), "change type mismatch");
        assertThat(dto.getReasonForChange(), equalTo(entity.getReasonForChange()), "change reason mismatch");
    }

    private void checkOutgoingDtoFields(final OtherwiseDeceasedDTO dto) {
        assertThat(dto.getId(), is(notNullValue()), "outgoing dto id is null");
        assertThat(dto.getRhy().getOfficialCode(), is(notNullValue()), "rhy officialCode is null");
        assertThat(dto.getRka().getOfficialCode(), is(notNullValue()), "rka officialCode is null");
        assertThat(dto.getReasonForChange(), is(nullValue()), "reasonForChange is not null");
    }

    private OtherwiseDeceasedDTO newOtherwiseDeceasedDTO() {
        final OtherwiseDeceasedDTO dto = new OtherwiseDeceasedDTO();
        dto.setGameSpeciesCode(gameSpecies1.getOfficialCode());
        dto.setAge(some(GameAge.class));
        dto.setGender(some(GameGender.class));
        dto.setWeight(weight());
        dto.setPointOfTime(LocalDateTime.now());
        dto.setNoExactLocation(someBoolean());
        dto.setGeoLocation(location1);
        //dto.setMunicipality()
        //dto.setRhy()
        //dto.setRka()
        dto.setCause(some(OtherwiseDeceasedCause.class));
        dto.setCauseOther("Cause other " + nextLong());
        dto.setSource(some(OtherwiseDeceasedSource.class));
        dto.setSourceOther("Source other " + nextLong());
        dto.setDescription("Description " + nextLong());
        dto.setAdditionalInfo("Additional ingo " + nextLong());
        return dto;
    }
}
```


Overlapping Code:
```
@RunWith(Theories.class)
public class OtherwiseDeceasedFeatureTest extends EmbeddedDatabaseTest {
@Resource
private OtherwiseDeceasedFeature feature;
@Resource
private OtherwiseDeceasedRepository otherwiseDeceasedRepository;
@Resource
private OtherwiseDeceasedChangeRepository changeRepository;
private SystemUser privilegedModerator;
private SystemUser notAuthorised;
private EntitySupplier es;
private GameSpecies gameSpecies1;
private GameSpecies gameSpecies2;
private GeoLocation location1;
private GeoLocation location2;
private Municipality municipality1;
private Municipality municipality2;
private Riistanhoitoyhdistys rhy1;
private Riistanhoitoyhdistys rhy2;
@Before
public void setUp() {
es = getEntitySupplier();
privilegedModerator = createNewModerator(SystemUserPrivilege.MUUTOIN_KUOLLEET);
notAuthorised = createNewModerator();
gameSpecies1 = es.newGameSpecies();
gameSpecies2 = es.newGameSpecies();
location1 = geoLocation();
location2 = geoLocation();
municipality1 = es.newMunicipality();
municipality2 = es.newMunicipality();
rhy1 = es.newRiistanhoitoyhdistys();
rhy2 = es.newRiistanhoitoyhdistys();
persistInNewTransaction();
}
@Test(expected = AccessDeniedException.class)
public void listByYear_moderatorMustHavePrivilege() {
onSavedAndAuthenticated(notAuthorised, () -> feature.listByYear(2021));
}
@Test
public void listByYear_returnsEmptyListIfNoneFound() {
onSavedAndAuthenticated(privilegedModerator, () -> {
final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);
assertThat(results, hasSize(0));
});
}
@Test
public void listByYear_andOnlyByThatYear() {
final OtherwiseDeceased item = es.newOtherwiseDeceased(new DateTime(2021, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));
es.newOtherwiseDeceased(new DateTime(2020, 12, 31, 23, 59, 59, 999, Constants.DEFAULT_TIMEZONE));
es.newOtherwiseDeceased(new DateTime(2022, 1, 1, 0, 0, Constants.DEFAULT_TIMEZONE));
onSavedAndAuthenticated(privilegedModerator, () -> {
runInTransaction(() -> {
final List<OtherwiseDeceasedBriefDTO> results = feature.listByYear(2021);
assertThat(results, hasSize(1));
fin
```
<Overlap Ratio: 0.9770491803278688>

---

--- 146 --
Question ID: d9e53affc9f2a0161650f064ee8e04c7926595c6_0
Original Code:
```
@WebServlet("/nest-backend/CsDetail.do")
public class CsDetailServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

//	private SimpleDateFormat sFormat = new SimpleDateFormat("yyyy-MM-dd");
//	private CsDetailService csDetailService;
//	@Override
//	public void init() throws ServletException {
//		csDetailService = new CsDetailService();
//	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {

		doPost(req, res);

	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {

		req.setCharacterEncoding("UTF-8");
//		res.setContentType("text/html; charset=UTF-8");
		String action = req.getParameter("action");

		
		// fendshop_mainpage選取目前busid，轉跳到fendcs_reply頁
		if ("from_shopmain_to_CsReply_with_Busid".equals(action)) {

			List<String> errorMsgs = new LinkedList<String>();
			// Store this set in the request scope, in case we need to
			// send the ErrorPage view.
			req.setAttribute("errorMsgs", errorMsgs);

			try {
				/*************************** 1.接收請求參數 ****************************************/
				Integer busid = Integer.parseInt(req.getParameter("busid"));
				//= new Integer(req.getParameter("caseid"));

				/*************************** 2.開始查詢資料 ****************************************/
				BusService busSvc = new BusService();
				BusVO busVO = busSvc.select(busid);

				/*************************** 3.查詢完成,準備轉交(Send the Success view) ************/
				req.setAttribute("busVO_from_ShopMainpage", busVO); // 資料庫取出的busVO物件,存入req
				String url = "/nest-frontend/fendcs_reply.jsp";
				RequestDispatcher successView = req.getRequestDispatcher(url);// 成功轉交 update_emp_input.jsp
				successView.forward(req, res);

				/*************************** 其他可能的錯誤處理 **********************************/
			} catch (Exception e) {
				errorMsgs.add("無法取得要修改的資料:" + e.getMessage());
				RequestDispatcher failureView = req.getRequestDispatcher("/nest-frontend/fendshop_mainpage.jsp");
				failureView.forward(req, res);
			}
		}
		
		// fendshop_mainpage選取目前busid，轉跳到fendcs_reply頁
		if ("from_Order_to_CsReply".equals(action)) {

			List<String> errorMsgs = new LinkedList<String>();
			// Store this set in the request scope, in case we need to
			// send the ErrorPage view.
			req.setAttribute("errorMsgs", errorMsgs);

			try {
				/*************************** 1.接收請求參數 ****************************************/
				Integer busid = Integer.parseInt(req.getParameter("busid"));
				//= new Integer(req.getParameter("caseid"));

				/*************************** 2.開始查詢資料 ****************************************/
				BusService busSvc = new BusService();
				BusVO busVO = busSvc.select(busid);

				/*************************** 3.查詢完成,準備轉交(Send the Success view) ************/
				req.setAttribute("busVO_from_ShopMainpage", busVO); // 資料庫取出的busVO物件,存入req
				String url = "/nest-frontend/fendcs_reply.jsp";
				RequestDispatcher successView = req.getRequestDispatcher(url);// 成功轉交 update_emp_input.jsp
				successView.forward(req, res);

				/*************************** 其他可能的錯誤處理 **********************************/
			} catch (Exception e) {
				errorMsgs.add("無法取得要修改的資料:" + e.getMessage());
				RequestDispatcher failureView = req.getRequestDispatcher("/nest-frontend/fendshop_mainpage.jsp");
				failureView.forward(req, res);
			}
		}
		
//		// 聯繫客服 (待測試)
//		if ("contact_Ord_Detail".equals(action)) { // 來自orderDetail的請求
//
//			List<String> errorMsgs = new LinkedList<String>();
//			// Store this set in the request scope, in case we need to send the ErrorPage
//			// view.
//			req.setAttribute("errorMsgs", errorMsgs);
//
//			try {
//				// 接收請求參數
//				// 取得訂單id
//				Integer orderId = new Integer(req.getParameter("orderId"));
//				// 開始查詢資料
//				OrderService orderSvc = new OrderService();
//				OrderVO orderVO = orderSvc.getOneByOrderId(orderId);
//				// 查詢完成，準備轉交
//				req.setAttribute("orderVO", orderVO); // 資料庫取出orderVO物件,存入req
//				String url = "fendcs_reply.jsp";
//				RequestDispatcher successView = req.getRequestDispatcher(url);// 成功轉交頁面
//				successView.forward(req, res);
//
//				// 其他錯誤處理
//			} catch (Exception e) {
//				errorMsgs.add("無法取得要修改的資料:" + e.getMessage());
//				RequestDispatcher failureView = req.getRequestDispatcher("accountCenter.jsp");
//				failureView.forward(req, res);
//			}
//		}


	}

}
```


Overlapping Code:
```
ckend/CsDetail.do")
public class CsDetailServlet extends HttpServlet {
private static final long serialVersionUID = 1L;
// private SimpleDateFormat sFormat = new SimpleDateFormat("yyyy-MM-dd");
// private CsDetailService csDetailService;
// @Override
// public void init() throws ServletException {
// csDetailService = new CsDetailService();
// }
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
doPost(req, res);
}
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
req.setCharacterEncoding("UTF-8");
// res.setContentType("text/html; charset=UTF-8");
String action = req.getParameter("action");

// fendshop_mainpage選取目前busid，轉跳到fendcs_reply頁
if ("from_shopmain_to_CsReply_with_Busid".equals(action)) {
List<String> errorMsgs = new LinkedList<String>();
// Store this set in the request scope, in case we need to
// send the ErrorPage view.
req.setAttribute("errorMsgs", errorMsgs);
try {
/*************************** 1.接收請求參數 ****************************************/
Integer busid = Integer.parseInt(req.getParameter("busid"));
//= new Integer(req.getParameter("caseid"));
/*************************** 2.開始查詢資料 ****************************************/
BusService busSvc = new BusService();
BusVO busVO = busSvc.select(busid);
/*************************** 3.查詢完成,準備轉交(Send the Success view) ************/
req.setAttribute("busVO_from_ShopMainpage", busVO); // 資料庫取出的busVO物件,存入req
String url = "/nest-frontend/fendcs_reply.jsp";
RequestDispatcher successView = req.getRequestDispatcher(url);// 成功轉交 update_emp_input.jsp
successView.forward(req, res);
/*************************** 其他可能的錯誤處理 **********************************/
} catch (Exception e) {
errorMsgs.add("無法取得要修改的資料:" + e.getMessage());
RequestDispatcher failureView = req.getRequestDispatcher("/nest-frontend/fendshop_mainpage.jsp");
failureView.forward(req, res);
}
}

// fendshop_mainpage選取目前busid，轉跳到fendcs_reply頁
if ("from_Order_to_CsReply".equals(action)) {
List<String> errorMsgs = new LinkedList<String>();
// Store this set in the request scope, in case we need to
// send the ErrorPage view.
req.setAttribute("errorMsgs", errorMsgs);
try {
/*************************** 1.接收請求參數 ***************************************
```
<Overlap Ratio: 0.9902252443688908>

---

--- 147 --
Question ID: cb164d377ea45c88976dfb5ca642cb5257e618f5_0
Original Code:
```
public class HarvestedItem 
{
	private Context context;
	private TableRow harvestRow;

	
	HarvestedItem(Context c, TableRow row)
    {
        context = c;
        harvestRow = row;
    }
    
    
    public static void exists(Context c) throws SQLException {
    	DatabaseManager.queryTable(c, "harvested_item", "SELECT COUNT(*) FROM harvested_item");    	
    }
	
	
    /**
     * Find the harvest parameters corresponding to the specified DSpace item 
     * @return a HarvestedItem object corresponding to this item, null if not found.
     */
    public static HarvestedItem find(Context c, int item_id) throws SQLException 
    {
    	TableRow row = DatabaseManager.findByUnique(c, "harvested_item", "item_id", item_id);
    	
    	if (row == null) {
    		return null;
    	}
    	
    	return new HarvestedItem(c, row);
    }
    
    
    /*
     * select foo.item_id from (select item.item_id, item.owning_collection from item join item2bundle on item.item_id=item2bundle.item_id where item2bundle.bundle_id=22) as foo join collection on foo.owning_collection=collection.collection_id where collection.collection_id=5;
     */
    
    /**
     * Retrieve a DSpace Item that corresponds to this particular combination of owning collection and OAI ID. 
     * @param context 
     * @param itemOaiID the string used by the OAI-PMH provider to identify the item
     * @param collectionID id of the local collection that the item should be found in
     * @return DSpace Item or null if no item was found
     */
    public static Item getItemByOAIId(Context context, String itemOaiID, int collectionID) throws SQLException
    {
    	/*
         * FYI: This method has to be scoped to a collection. Otherwise, we could have collisions as more 
         * than one collection might be importing the same item. That is OAI_ID's might be unique to the 
         * provider but not to the harvester.
         */
   	 	Item resolvedItem = null;
        TableRowIterator tri = null;
        final String selectItemFromOaiId = "SELECT dsi.item_id FROM " + 
        	"(SELECT item.item_id, item.owning_collection FROM item JOIN harvested_item ON item.item_id=harvested_item.item_id WHERE harvested_item.oai_id=?) " + 
        	"dsi JOIN collection ON dsi.owning_collection=collection.collection_id WHERE collection.collection_id=?";
        
        try
        {
            tri = DatabaseManager.query(context, selectItemFromOaiId, itemOaiID, collectionID);

            if (tri.hasNext())
            {
                TableRow row = tri.next();
                int itemID = row.getIntColumn("item_id");
                resolvedItem = Item.find(context, itemID);
            }
            else {
           	 return null;
            }
        }
        finally {
            if (tri != null)
            {
                tri.close();
            }
        }

        return resolvedItem;
    }
        
    /**
     * Create a new harvested item row for a specified item id.  
     * @return a new HarvestedItem object
     */
    public static HarvestedItem create(Context c, int itemId, String itemOAIid) throws SQLException {
    	TableRow row = DatabaseManager.row("harvested_item");
    	row.setColumn("item_id", itemId);
    	row.setColumn("oai_id", itemOAIid);
    	DatabaseManager.insert(c, row);
    	
    	return new HarvestedItem(c, row);    	
    }
    
    
    public String getItemID()
    {
        String oai_id = harvestRow.getStringColumn("item_id");

        return oai_id;
    }

    /**
     * Get the oai_id associated with this item 
     */
    public String getOaiID()
    {
        String oai_id = harvestRow.getStringColumn("oai_id");

        return oai_id;
    }
    
    /**
     * Set the oai_id associated with this item 
     */
    public void setOaiID(String itemOaiID)
    {
    	harvestRow.setColumn("oai_id",itemOaiID);
        return;
    }
    
    
    public void setHarvestDate(Date date) {
    	if (date == null) {    	
    		date = new Date();
    	}
    	harvestRow.setColumn("last_harvested", date);
    }
    
    public Date getHarvestDate() {
    	return harvestRow.getDateColumn("last_harvested");
    }
    
    
    
    public void delete() throws SQLException {
    	DatabaseManager.delete(context, harvestRow);
    }
    
    
    
    public void update() throws SQLException, IOException, AuthorizeException {
        DatabaseManager.update(context, harvestRow);
    }

}
```


Overlapping Code:
```
Item 
{
private Context context;
private TableRow harvestRow;

HarvestedItem(Context c, TableRow row)
{
context = c;
harvestRow = row;
}


public static void exists(Context c) throws SQLException {
DatabaseManager.queryTable(c, "harvested_item", "SELECT COUNT(*) FROM harvested_item"); 
}


/**
* Find the harvest parameters corresponding to the specified DSpace item 
* @return a HarvestedItem object corresponding to this item, null if not found.
*/
public static HarvestedItem find(Context c, int item_id) throws SQLException 
{
TableRow row = DatabaseManager.findByUnique(c, "harvested_item", "item_id", item_id);

if (row == null) {
return null;
}

return new HarvestedItem(c, row);
}


/*
* select foo.item_id from (select item.item_id, item.owning_collection from item join item2bundle on item.item_id=item2bundle.item_id where item2bundle.bundle_id=22) as foo join collection on foo.owning_collection=collection.collection_id where collection.collection_id=5;
*/

/**
* Retrieve a DSpace Item that corresponds to this particular combination of owning collection and OAI ID. 
* @param context 
* @param itemOaiID the string used by the OAI-PMH provider to identify the item
* @param collectionID id of the local collection that the item should be found in
* @return DSpace Item or null if no item was found
*/
public static Item getItemByOAIId(Context context, String itemOaiID, int collectionID) throws SQLException
{
/*
* FYI: This method has to be scoped to a collection. Otherwise, we could have collisions as more 
* than one collection might be importing the same item. That is OAI_ID's might be unique to the 
* provider but not to the harvester.
*/
Item resolvedItem = null;
TableRowIterator tri = null;
final String selectItemFromOaiId = "SELECT dsi.item_id FROM " + 
"(SELECT item.item_id, item.owning_collection FROM item JOIN harvested_item ON item.item_id=harvested_item.item_id WHERE harvested_item.oai_id=?) " + 
"dsi JOIN collection ON dsi.owning_collection=collection.collection_id WHERE collection.collection_id=?";

try
{
tri = DatabaseManager.query(context, selectItemFromOaiId, itemOaiID, collectionID);
if (tri.hasNext())
```
<Overlap Ratio: 0.9898710865561694>

---

--- 148 --
Question ID: f28a0bdf00a2235f6383e6c55f882b5312213edd_0
Original Code:
```
public abstract class AbstractApiClient implements ApiClient {

    private final String url;

    protected AbstractApiClient() {
        url = Environment.TEST.getUrl();
    }

    protected AbstractApiClient(String url) {
        this.url = url;
    }

    protected AbstractApiClient(Environment environment) {
        url = environment.getUrl();
    }

    protected byte[] marshalXML(@NotNull Object o) throws JAXBException {

        val jc = JAXBContext.newInstance(o.getClass());
        val jaxbMarshaller = jc.createMarshaller();

        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        val stream = new ByteArrayOutputStream();
        jaxbMarshaller.marshal(o, stream);

        return stream.toByteArray();
    }

    @NotNull
    protected String createUrl(@NotNull String endpoint) {

        val sb = new StringBuilder();
        sb.append(url);
        if (!endpoint.startsWith("/")) sb.append("/");
        sb.append(endpoint);

        return sb.toString();
    }

    @Getter
    @RequiredArgsConstructor
    public enum Environment {

        DEMO("https://ksef-demo.mf.gov.pl/api"),
        PROD("https://ksef.mf.gov.pl/api"),
        TEST("https://ksef-test.mf.gov.pl/api");

        private final String url;
    }
}
```


Overlapping Code:
```
abstract class AbstractApiClient implements ApiClient {
private final String url;
protected AbstractApiClient() {
url = Environment.TEST.getUrl();
}
protected AbstractApiClient(String url) {
this.url = url;
}
protected AbstractApiClient(Environment environment) {
url = environment.getUrl();
}
protected byte[] marshalXML(@NotNull Object o) throws JAXBException {
val jc = JAXBContext.newInstance(o.getClass());
val jaxbMarshaller = jc.createMarshaller();
jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
val stream = new ByteArrayOutputStream();
jaxbMarshaller.marshal(o, stream);
return stream.toByteArray();
}
@NotNull
protected String createUrl(@NotNull String endpoint) {
val sb = new StringBuilder();
sb.append(url);
if (!endpoint.startsWith("/")) sb.append("/");
sb.append(endpoint);
return sb.toString();
}
@Getter
@RequiredArgsConstructor
public enum Environment {
DEMO("https://ksef-demo.mf.gov.pl/api"),
PROD("https://ksef.mf.gov.pl/api"),
TEST("https://ksef-test.mf.go
```
<Overlap Ratio: 0.9545023696682464>

---

--- 149 --
Question ID: 8a0f34e82e7baee7789025dc81122cef0b294a40_0
Original Code:
```
public class ProjectContextMenuTest extends BaseProjectTest {
  @Rule public TestProjectCreator projectCreator = new TestProjectCreator();
  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();
  @Rule public ThreadDumpingWatchdog timer = new ThreadDumpingWatchdog(2, TimeUnit.MINUTES);

  @Test
  public void testPlainJavaProject() {
    IProject project = projectCreator.withFacets(JavaFacet.VERSION_1_8).getProject();
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(
        selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu(), not(MenuMatcher.hasMenuItem("Deploy to App Engine Standard...")));
    assertThat(
        selected.contextMenu("Configure"),
        MenuMatcher.hasMenuItem("Convert to App Engine Standard Project"));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
  }

  @Test
  public void testDynamicWebProjectJava7() {
    IProject project =
        projectCreator.withFacets(JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25).getProject();
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(
        selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu(), not(MenuMatcher.hasMenuItem("Deploy to App Engine Standard...")));
    assertThat(
        selected.contextMenu("Configure"),
        MenuMatcher.hasMenuItem("Convert to App Engine Standard Project"));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
  }

  @Test
  public void testDynamicWebProjectJava8() {
    IProject project =
        projectCreator.withFacets(JavaFacet.VERSION_1_8, WebFacetUtils.WEB_31).getProject();
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(
        selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
    assertThat(
        selected.contextMenu(), not(MenuMatcher.hasMenuItem("Deploy to App Engine Standard...")));
    assertThat(
        selected.contextMenu("Configure"),
        MenuMatcher.hasMenuItem("Convert to App Engine Standard Project"));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
  }

  @Test
  public void testAppEngineStandardJava7() {
    IProject project =
        projectCreator
            .withFacets(AppEngineStandardFacet.JRE7, JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25)
            .getProject();
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(selected.contextMenu("Debug As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu("Run As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem("Deploy to App Engine Standard..."));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Convert to App Engine Standard Project")));
    assertThat(
        selected.contextMenu("Configure"),
        MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime"));
  }

  @Test
  public void testAppEngineStandardJava8() {
    IProject project =
        projectCreator
            .withFacets(
                AppEngineStandardFacet.FACET.getVersion("JRE8"),
                JavaFacet.VERSION_1_8,
                WebFacetUtils.WEB_31)
            .getProject();
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(selected.contextMenu("Debug As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu("Run As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem("Deploy to App Engine Standard..."));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Convert to App Engine Standard Project")));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
  }

  @Test
  public void testMavenAppEngineStandardJava8() {
    project =
        SwtBotAppEngineActions.createMavenWebAppProject(
            bot,
            "projectContextMenuJava8",
            tempFolder.getRoot().getPath(),
            "com.example.maven7",
            AppEngineRuntime.STANDARD_JAVA_8,
            "com.google.cloud.tools.eclipse.tests",
            "projectContextMenuJava8");
    SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
    assertThat(selected.contextMenu("Debug As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu("Run As"), MenuMatcher.hasMenuItem(endsWith("App Engine")));
    assertThat(selected.contextMenu(), MenuMatcher.hasMenuItem("Deploy to App Engine Standard..."));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Convert to App Engine Standard Project")));
    assertThat(
        selected.contextMenu("Configure"),
        not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
  }
}
```


Overlapping Code:
```
 extends BaseProjectTest {
@Rule public TestProjectCreator projectCreator = new TestProjectCreator();
@Rule public TemporaryFolder tempFolder = new TemporaryFolder();
@Rule public ThreadDumpingWatchdog timer = new ThreadDumpingWatchdog(2, TimeUnit.MINUTES);
@Test
public void testPlainJavaProject() {
IProject project = projectCreator.withFacets(JavaFacet.VERSION_1_8).getProject();
SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
assertThat(
selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
assertThat(
selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
assertThat(
selected.contextMenu(), not(MenuMatcher.hasMenuItem("Deploy to App Engine Standard...")));
assertThat(
selected.contextMenu("Configure"),
MenuMatcher.hasMenuItem("Convert to App Engine Standard Project"));
assertThat(
selected.contextMenu("Configure"),
not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
}
@Test
public void testDynamicWebProjectJava7() {
IProject project =
projectCreator.withFacets(JavaFacet.VERSION_1_7, WebFacetUtils.WEB_25).getProject();
SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
assertThat(
selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
assertThat(
selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
assertThat(
selected.contextMenu(), not(MenuMatcher.hasMenuItem("Deploy to App Engine Standard...")));
assertThat(
selected.contextMenu("Configure"),
MenuMatcher.hasMenuItem("Convert to App Engine Standard Project"));
assertThat(
selected.contextMenu("Configure"),
not(MenuMatcher.hasMenuItem("Reconfigure for App Engine Java 8 runtime")));
}
@Test
public void testDynamicWebProjectJava8() {
IProject project =
projectCreator.withFacets(JavaFacet.VERSION_1_8, WebFacetUtils.WEB_31).getProject();
SWTBotTreeItem selected = SwtBotProjectActions.selectProject(bot, project.getName());
assertThat(
selected.contextMenu("Debug As"), not(MenuMatcher.hasMenuItem(endsWith("App Engine"))));
assertThat(
selected.contextMenu("Run As"), not(MenuMatcher.hasMenuItem(endsWith
```
<Overlap Ratio: 0.9805137289636847>

---

--- 150 --
Question ID: 7bb64d98e72cc58319bf73e2b485510062895646_0
Original Code:
```
public class ResourceRequestKey implements RequestKey {

    private Resources mResources;
    private int mResId;

    /**
     * Create a new request key with the given resource id. A resId of 0 will
     * return a null request key.
     */
    public static ResourceRequestKey from(Resources res, int resId) {
        if (resId != 0) {
            return new ResourceRequestKey(res, resId);
        }
        return null;
    }

    private ResourceRequestKey(Resources res, int resId) {
        mResources = res;
        mResId = resId;
    }

    @Override
    public Cancelable createFileDescriptorFactoryAsync(RequestKey requestKey, Callback callback) {
        return null;
    }

    @Override
    public InputStream createInputStream() throws IOException {
        return mResources.openRawResource(mResId);
    }

    @Override
    public boolean hasOrientationExif() throws IOException {
        return false;
    }

    // START AUTO-GENERATED CODE

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        ResourceRequestKey that = (ResourceRequestKey) o;

        if (mResId != that.mResId) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        return mResId;
    }

    // END AUTO-GENERATED CODE

    @Override
    public String toString() {
        return String.format("ResourceRequestKey: %d", mResId);
    }
}
```


Overlapping Code:
```
urceRequestKey implements RequestKey {
private Resources mResources;
private int mResId;
/**
* Create a new request key with the given resource id. A resId of 0 will
* return a null request key.
*/
public static ResourceRequestKey from(Resources res, int resId) {
if (resId != 0) {
return new ResourceRequestKey(res, resId);
}
return null;
}
private ResourceRequestKey(Resources res, int resId) {
mResources = res;
mResId = resId;
}
@Override
public Cancelable createFileDescriptorFactoryAsync(RequestKey requestKey, Callback callback) {
return null;
}
@Override
public InputStream createInputStream() throws IOException {
return mResources.openRawResource(mResId);
}
@Override
public boolean hasOrientationExif() throws IOException {
return false;
}
// START AUTO-GENERATED CODE
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
ResourceRequestKey that = (ResourceRequestKey) o;
if (mResId != that.mResId) {
return false;
}
return true;
}
@Override
public int hashCode() {
return mResId;
}
// END AUTO-GENERATED CODE
@Override
public String toString() {
return String.format("ResourceRequestKey: %d", mResId);

```
<Overlap Ratio: 0.9836065573770492>

---

--- 151 --
Question ID: ce150fb300b4026c8524ced5dcd54a568fa5cb4a_0
Original Code:
```
@RunWith(PowerMockRunner.class)
    @PrepareForTest({LDAPUtils.class, UserLoginProfileImpl.class})
    @MockPolicy(Slf4jMockPolicy.class) @PowerMockIgnore(
        {"javax.management.*"}) public class UserLoginProfileImplTest {

 private
  final UserLoginProfileImpl userLoginProfileImpl;
 private
  final LDAPSearchResults ldapResults;
 private
  final LDAPEntry entry;

 private
  final LDAPAttribute userIdAttr;
 private
  final LDAPAttribute objectClassAttr;
 private
  final LDAPAttribute pathAttr;
 private
  final LDAPAttribute commonNameAttr;
 private
  final LDAPAttribute roleAttr;

  @Rule public final ExpectedException exception = ExpectedException.none();

 public
  UserLoginProfileImplTest() {
    userLoginProfileImpl = new UserLoginProfileImpl();
    ldapResults = Mockito.mock(LDAPSearchResults.class);
    entry = Mockito.mock(LDAPEntry.class);
    userIdAttr = Mockito.mock(LDAPAttribute.class);
    objectClassAttr = Mockito.mock(LDAPAttribute.class);
    pathAttr = Mockito.mock(LDAPAttribute.class);
    commonNameAttr = Mockito.mock(LDAPAttribute.class);
    roleAttr = Mockito.mock(LDAPAttribute.class);
  }

  @Before public void setUp() throws Exception {
    PowerMockito.mockStatic(LDAPUtils.class);
    Mockito.when(ldapResults.next()).thenReturn(entry);
  }

  @Test public void Create_UserLoginProfileFailed_ThrowException()
      throws Exception {

    PowerMockito.mockStatic(UserLoginProfileImpl.class);
    User user = new User();
    user.setAccountName("s3test");
    user.setName("s3testuser");
    user.setId("123");
    user.setPassword("abcdef");
    user.setProfileCreateDate("2019-06-16 15:38:53+00:00");
    user.setPwdResetRequired("true");

    String dn = "s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3," +
                "dc=seagate,dc=com";

    ArrayList mockList = Mockito.mock(ArrayList.class);
    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(
        mockList);

    PowerMockito.doThrow(new LDAPException())
        .when(LDAPUtils.class, "modify", dn, mockList);

    exception.expect(DataAccessException.class);

    userLoginProfileImpl.save(user);
  }

  @Test public void Update_UserModifySuccess() throws Exception {

    User user = new User();
    user.setAccountName("s3test");
    user.setName("s3testuser");
    user.setId("123");
    user.setPassword("abcd");
    user.setProfileCreateDate("2019-06-16 15:38:53+00:00");
    user.setPwdResetRequired("true");

    ArrayList modifyList = Mockito.mock(ArrayList.class);
    LDAPAttribute ldapAttribute = Mockito.mock(LDAPAttribute.class);
    LDAPModification modification = Mockito.mock(LDAPModification.class);

    PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(
        modifyList);

    PowerMockito.whenNew(LDAPAttribute.class).withAnyArguments().thenReturn(
        ldapAttribute);

    PowerMockito.whenNew(LDAPModification.class)
        .withParameterTypes(int.class, LDAPAttribute.class)
        .withArguments(LDAPModification.REPLACE, ldapAttribute)
        .thenReturn(modification);

    String dn = "s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3," +
                "dc=seagate,dc=com";

    userLoginProfileImpl.save(user);

    PowerMockito.verifyNew(LDAPAttribute.class)
        .withArguments("userPassword", "abcd");
    PowerMockito.verifyNew(LDAPModification.class, times(3))
        .withArguments(LDAPModification.REPLACE, ldapAttribute);
    Mockito.verify(modifyList, Mockito.times(3)).add(modification);

    PowerMockito.verifyStatic(Mockito.times(1));
    LDAPUtils.modify(dn, modifyList);
  }
}
```


Overlapping Code:
```
@RunWith(PowerMockRunner.class)
@PrepareForTest({LDAPUtils.class, UserLoginProfileImpl.class})
@MockPolicy(Slf4jMockPolicy.class) @PowerMockIgnore(
{"javax.management.*"}) public class UserLoginProfileImplTest {
private
final UserLoginProfileImpl userLoginProfileImpl;
private
final LDAPSearchResults ldapResults;
private
final LDAPEntry entry;
private
final LDAPAttribute userIdAttr;
private
final LDAPAttribute objectClassAttr;
private
final LDAPAttribute pathAttr;
private
final LDAPAttribute commonNameAttr;
private
final LDAPAttribute roleAttr;
@Rule public final ExpectedException exception = ExpectedException.none();
public
UserLoginProfileImplTest() {
userLoginProfileImpl = new UserLoginProfileImpl();
ldapResults = Mockito.mock(LDAPSearchResults.class);
entry = Mockito.mock(LDAPEntry.class);
userIdAttr = Mockito.mock(LDAPAttribute.class);
objectClassAttr = Mockito.mock(LDAPAttribute.class);
pathAttr = Mockito.mock(LDAPAttribute.class);
commonNameAttr = Mockito.mock(LDAPAttribute.class);
roleAttr = Mockito.mock(LDAPAttribute.class);
}
@Before public void setUp() throws Exception {
PowerMockito.mockStatic(LDAPUtils.class);
Mockito.when(ldapResults.next()).thenReturn(entry);
}
@Test public void Create_UserLoginProfileFailed_ThrowException()
throws Exception {
PowerMockito.mockStatic(UserLoginProfileImpl.class);
User user = new User();
user.setAccountName("s3test");
user.setName("s3testuser");
user.setId("123");
user.setPasswor");
user.setProfileCreateDate("2019-06-16 15:38:53+00:00");
user.setPwdResetRequired("true");
String dn = "s3userid=123,ou=users,o=s3test,ou=accounts,dc=s3," +
"dc=seagate,dc=com";
ArrayList mockList = Mockito.mock(ArrayList.class);
PowerMockito.whenNew(ArrayList.class).withNoArguments().thenReturn(
mockList);
PowerMockito.doThrow(new LDAPException())
.when(LDAPUtils.class, "modify", dn, mockList);
exception.expect(DataAccessException.class);
userLoginProfileImpl.save(user);
}
@Test public void Update_UserModifySuccess() throws Exception {
User user = new User();
user.setAccountName("s3test");
user.setName("s3testuser");
user.setId("123");
user.setPasswor");
user.setProfileCreateDate("2019-06-16 15:38:53+00:00");
user.setPwdResetRequired("true");
ArrayList modifyList = Mockito.mock(Ar
```
<Overlap Ratio: 0.9920389208314905>

---

--- 152 --
Question ID: 2e09fec0ce4c0e909a45949f158d511c15647c0c_0
Original Code:
```
@SpringBootTest(
        classes = {
            HSQLDBTestProfileJPAConfiguration.class,
            TailormapHealthIndicator.class,
            VersionController.class
        })
@AutoConfigureMockMvc
@EnableAutoConfiguration
@TestPropertySource(properties = {"management.health.tailormap.enabled=true"})
@ActiveProfiles("test")
@AutoConfigureMetrics
class TailormapHealthIndicatorEnabledIntegrationTest {
    @Autowired private MockMvc mockMvc;

    @SuppressWarnings("PMD.JUnitTestsShouldIncludeAssert")
    @Test
    void when_enabled_health_should_have_status_and_response_data() throws Exception {
        String projectVersion = System.getProperty("project.version");
        assumeFalse(
                null == projectVersion,
                "Project version unknown, should be set as system property");
        String databaseVersion = System.getenv("DATABASE_VERSION");
        assumeFalse(
                null == databaseVersion,
                "Database version unknown, should be set in system environment");
        String apiVersion = System.getenv("API_VERSION");
        assumeFalse(null == apiVersion, "API version unknown, should be set in system environment");

        mockMvc.perform(get("/actuator/health/tailormap"))
                .andExpect(status().isOk())
                .andExpect(
                        content()
                                .contentType(
                                        MediaType.parseMediaType(
                                                "application/vnd.spring-boot.actuator.v3+json")))
                .andExpect(jsonPath("$.details.version").value(projectVersion))
                .andExpect(jsonPath("$.details.apiVersion").value(apiVersion))
                .andExpect(jsonPath("$.details.databaseversion").value(databaseVersion));
    }
}
```


Overlapping Code:
```
pringBootTest(
classes = {
HSQLDBTestProfileJPAConfiguration.class,
TailormapHealthIndicator.class,
VersionController.class
})
@AutoConfigureMockMvc
@EnableAutoConfiguration
@TestPropertySource(properties = {"management.health.tailormap.enabled=true"})
@ActiveProfiles("test")
@AutoConfigureMetrics
class TailormapHealthIndicatorEnabledIntegrationTest {
@Autowired private MockMvc mockMvc;
@SuppressWarnings("PMD.JUnitTestsShouldIncludeAssert")
@Test
void when_enabled_health_should_have_status_and_response_data() throws Exception {
String projectVersion = System.getProperty("project.version");
assumeFalse(
null == projectVersion,
"Project version unknown, should be set as system property");
String databaseVersion = System.getenv("DATABASE_VERSION");
assumeFalse(
null == databaseVersion,
"Database version unknown, should be set in system environment");
String apiVersion = System.getenv("API_VERSION");
assumeFalse(null == apiVersion, "API version unknown, should be set in system environment");
mockMvc.perform(get("/actuator/health/tailormap"))
.andExpect(status().isOk())
.andExpect(
content()
.contentType(
MediaType.parseMediaType(
"application/vnd.spring-boot.actuator.v3+json")))
.andExpect(jsonPath("$.details.version").value(projectVersion))
.andExpect(jsonPath("$.details.apiVersion").value(apiVersion))
.andExpect(jsonPath("$.details.databaseversion").value(databas
```
<Overlap Ratio: 0.9878571428571429>

---

--- 153 --
Question ID: cb08cf762e00fa4456bca75444154d2d5fb05213_0
Original Code:
```
@Execution(ExecutionMode.SAME_THREAD)
class JsonTemplateLayoutAdditionalFieldTest {

    @Test
    @LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.json")
    void test_JSON_config_additional_fields(
            final LoggerContext loggerContext,
            final @Named(value = "List") ListAppender appender) {
        assertAdditionalFields(loggerContext, appender);
    }

    @Test
    @LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.properties")
    void test_Properties_config_additional_fields(
            final LoggerContext loggerContext,
            final @Named(value = "List") ListAppender appender) {
        assertAdditionalFields(loggerContext, appender);
    }

    @Test
    @LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.xml")
    void test_XML_config_additional_fields(
            final LoggerContext loggerContext,
            final @Named(value = "List") ListAppender appender) {
        assertAdditionalFields(loggerContext, appender);
    }

    @Test
    @LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.yaml")
    void test_YAML_config_additional_fields(
            final LoggerContext loggerContext,
            final @Named(value = "List") ListAppender appender) {
        assertAdditionalFields(loggerContext, appender);
    }

    private static void assertAdditionalFields(
            final LoggerContext loggerContext,
            final ListAppender appender) {

        // Log an event.
        final Logger logger =
                loggerContext.getLogger(JsonTemplateLayoutAdditionalFieldTest.class);
        logger.info("trigger");

        // Verify that the appender has logged the event.
        final List<byte[]> serializedEvents = appender.getData();
        Assertions.assertThat(serializedEvents).hasSize(1);

        // Deserialize the serialized event.
        final byte[] serializedEvent = serializedEvents.get(0);
        final String serializedEventJson =
                new String(
                        serializedEvent,
                        JsonTemplateLayoutDefaults.getCharset());
        final Object serializedEventObject = JsonReader.read(serializedEventJson);
        Assertions.assertThat(serializedEventObject).isInstanceOf(Map.class);
        @SuppressWarnings("unchecked") final Map<String, Object> serializedEventMap =
                (Map<String, Object>) serializedEventObject;

        // Verify the serialized additional fields.
        Assertions
                .assertThat(serializedEventMap)
                .containsEntry("stringField", "string")
                .containsEntry("numberField", 1)
                .containsEntry("objectField", Collections.singletonMap("numberField", 1))
                .containsEntry("listField", Arrays.asList(1, "two"));

    }

}
```


Overlapping Code:
```
ExecutionMode.SAME_THREAD)
class JsonTemplateLayoutAdditionalFieldTest {
@Test
@LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.json")
void test_JSON_config_additional_fields(
final LoggerContext loggerContext,
final @Named(value = "List") ListAppender appender) {
assertAdditionalFields(loggerContext, appender);
}
@Test
@LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.properties")
void test_Properties_config_additional_fields(
final LoggerContext loggerContext,
final @Named(value = "List") ListAppender appender) {
assertAdditionalFields(loggerContext, appender);
}
@Test
@LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.xml")
void test_XML_config_additional_fields(
final LoggerContext loggerContext,
final @Named(value = "List") ListAppender appender) {
assertAdditionalFields(loggerContext, appender);
}
@Test
@LoggerContextSource("additionalFieldEnrichedJsonTemplateLayoutLogging.yaml")
void test_YAML_config_additional_fields(
final LoggerContext loggerContext,
final @Named(value = "List") ListAppender appender) {
assertAdditionalFields(loggerContext, appender);
}
private static void assertAdditionalFields(
final LoggerContext loggerContext,
final ListAppender appender) {
// Log an event.
final Logger logger =
loggerContext.getLogger(JsonTemplateLayoutAdditionalFieldTest.class);
logger.info("trigger");
// Verify that the appender has logged the event.
final List<byte[]> serializedEvents = appender.getData();
Assertions.assertThat(serializedEvents).hasSize(1);
// Deserialize the serialized event.
final byte[] serializedEvent = serializedEvents.get(0);
final String serializedEventJson =
new String(
serializedEvent,
JsonTemplateLayoutDefaults.getCharset());
final Object serializedEventObject = JsonReader.read(serializedEventJson);
Assertions.assertThat(serializedEventObject).isInstanceOf(Map.class);
@SuppressWarnings("unchecked") final Map<String, Object> serializedEventMap =
(Map<String, Object>) serializedEventObject;
// Verify the serialized additional f
```
<Overlap Ratio: 0.9917755200774069>

---

--- 154 --
Question ID: 8d30ebd09be518da76c8ceb500e1e51506245dfd_0
Original Code:
```
public class ActPerformanceTest extends ActivityInstrumentationTestCase2<Main> {
    private static final String TAG = "M3dMark";

    public ActPerformanceTest() {
        super("com.mediatek.media3d", Main.class);
    }

    private static final long APP_LAUNCH_TIME_WO_CACHE_CRITERIA = 3000;

    public void test01_AppLaunchTimeWOCache() {
        long t1 = SystemClock.uptimeMillis();
        Log.v(TAG, "starting activity without shader cache");
        final Main activity = getActivity();
        assertNotNull(activity);
        getInstrumentation().waitForIdleSync();
        long t2 = SystemClock.uptimeMillis() - t1;
        Log.v(TAG, "getActivity costs: " + t2);

        writePerformanceData(activity, "app.launch-time-wo-cache.txt", t2);
        assertThat(t2, is(lessThanOrEqualTo(APP_LAUNCH_TIME_WO_CACHE_CRITERIA)));
    }

    private void writePerformanceData(Activity activity, String name, Object data) {
        File dataFile = new File(activity.getDir("perf", Context.MODE_PRIVATE), name);
        dataFile.delete();
        try {
            FileWriter writer = new FileWriter(dataFile);
            writer.write("YVALUE=" + data);
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```


Overlapping Code:
```
eTest extends ActivityInstrumentationTestCase2<Main> {
private static final String TAG = "M3dMark";
public ActPerformanceTest() {
super("com.mediatek.media3d", Main.class);
}
private static final long APP_LAUNCH_TIME_WO_CACHE_CRITERIA = 3000;
public void test01_AppLaunchTimeWOCache() {
long t1 = SystemClock.uptimeMillis();
Log.v(TAG, "starting activity without shader cache");
final Main activity = getActivity();
assertNotNull(activity);
getInstrumentation().waitForIdleSync();
long t2 = SystemClock.uptimeMillis() - t1;
Log.v(TAG, "getActivity costs: " + t2);
writePerformanceData(activity, "app.launch-time-wo-cache.txt", t2);
assertThat(t2, is(lessThanOrEqualTo(APP_LAUNCH_TIME_WO_CACHE_CRITERIA)));
}
private void writePerformanceData(Activity activity, String name, Object data) {
File dataFile = new File(activity.getDir("perf", Context.MODE_PRIVATE), name);
dataFile.delete();
try {
FileWriter writer = new FileWriter(dataFile);
writer.write("YVALUE=" + data);
writer.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
<Overlap Ratio: 0.9755868544600939>

---

--- 155 --
Question ID: d8377ec8ea407a5942f9f6a2b9ea8f9371b1e0aa_0
Original Code:
```
public class UntaggedWithSchemaDeserializationTests {
    private static final int SIMPLE_VERSION = 2;
    private RecordV1 recordIn;
    private SchemaDef recordV1Schema;
    private SimpleBinaryReader reader;

    /*
     * These tests all begin with serialized data containing the schema for
     * RecordV1 and a real RecordV1. The actual tests vary the type they
     * attempt to deserialize into.
     */
    @Before
    public void setup() throws IOException {
        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
        final SimpleBinaryWriter writer = new SimpleBinaryWriter(baos, SIMPLE_VERSION);
        final Serializer<SchemaDef> schemaSerializer = new Serializer<SchemaDef>();
        final Serializer<RecordV1> recordSerializer = new Serializer<RecordV1>();
        recordIn = new RecordV1();
        recordIn.name = "event";
        recordIn.tstamp = 800;

        schemaSerializer.serialize(RecordV1.BOND_TYPE.buildSchemaDef(), writer);
        recordSerializer.serialize(recordIn, writer);

        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        reader = new SimpleBinaryReader(bais, SIMPLE_VERSION);
        final Deserializer<SchemaDef> schemaDeserializer = new Deserializer<SchemaDef>(SchemaDef.BOND_TYPE);
        recordV1Schema = schemaDeserializer.deserialize(reader);
    }

    @Test
    public void sameTypeAsSchema() throws IOException {
        final Deserializer<RecordV1> recordV1Deserializer = new Deserializer<RecordV1>(RecordV1.BOND_TYPE);
        final RecordV1 recordOut = recordV1Deserializer.deserialize(reader, recordV1Schema);

        Assert.assertEquals(recordIn, recordOut);
    }

    @Test
    public void fieldAdded() throws IOException {
        final Deserializer<RecordV2> recordV2Deserializer = new Deserializer<RecordV2>(RecordV2.BOND_TYPE);
        final RecordV2 recordOut = recordV2Deserializer.deserialize(reader, recordV1Schema);

        Assert.assertEquals(recordIn.name, recordOut.name);
        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);
        Assert.assertEquals("", recordOut.location);
    }

    @Test
    public void fieldRemoved() throws IOException {
        final Deserializer<FieldRemovedRecord> fieldRemovedRecordDeserializer =
            new Deserializer<FieldRemovedRecord>(FieldRemovedRecord.BOND_TYPE);
        final FieldRemovedRecord recordOut = fieldRemovedRecordDeserializer.deserialize(reader, recordV1Schema);

        Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);
    }
}
```


Overlapping Code:
```
ationTests {
private static final int SIMPLE_VERSION = 2;
private RecordV1 recordIn;
private SchemaDef recordV1Schema;
private SimpleBinaryReader reader;
/*
* These tests all begin with serialized data containing the schema for
* RecordV1 and a real RecordV1. The actual tests vary the type they
* attempt to deserialize into.
*/
@Before
public void setup() throws IOException {
final ByteArrayOutputStream baos = new ByteArrayOutputStream();
final SimpleBinaryWriter writer = new SimpleBinaryWriter(baos, SIMPLE_VERSION);
final Serializer<SchemaDef> schemaSerializer = new Serializer<SchemaDef>();
final Serializer<RecordV1> recordSerializer = new Serializer<RecordV1>();
recordIn = new RecordV1();
recordIn.name = "event";
recordIn.tstamp = 800;
schemaSerializer.serialize(RecordV1.BOND_TYPE.buildSchemaDef(), writer);
recordSerializer.serialize(recordIn, writer);
final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
reader = new SimpleBinaryReader(bais, SIMPLE_VERSION);
final Deserializer<SchemaDef> schemaDeserializer = new Deserializer<SchemaDef>(SchemaDef.BOND_TYPE);
recordV1Schema = schemaDeserializer.deserialize(reader);
}
@Test
public void sameTypeAsSchema() throws IOException {
final Deserializer<RecordV1> recordV1Deserializer = new Deserializer<RecordV1>(RecordV1.BOND_TYPE);
final RecordV1 recordOut = recordV1Deserializer.deserialize(reader, recordV1Schema);
Assert.assertEquals(recordIn, recordOut);
}
@Test
public void fieldAdded() throws IOException {
final Deserializer<RecordV2> recordV2Deserializer = new Deserializer<RecordV2>(RecordV2.BOND_TYPE);
final RecordV2 recordOut = recordV2Deserializer.deserialize(reader, recordV1Schema);
Assert.assertEquals(recordIn.name, recordOut.name);
Assert.assertEquals(recordIn.tstamp, recordOut.tstamp);
Assert.assertEquals("", recordOut.location);
}
@Test
public void fieldRemoved() throws IOException {
final Deserializer<FieldRemovedRecord> fieldRemovedRecordDeserializer =
new Deserializer<FieldRemovedRecord>(FieldRemovedRecord.BOND_TYPE);
final FieldRemovedRecord recordOut = fieldRemovedRecordDeserializer.deserialize(reader, recordV1Schema);
Assert.assertE
```
<Overlap Ratio: 0.9782016348773842>

---

--- 156 --
Question ID: 5a5703e6f6582e2edfa87e767c9a4b78f0a507b9_0
Original Code:
```
public class TestFederationStateStoreInputValidator {

  private static final Logger LOG =
      LoggerFactory.getLogger(TestFederationStateStoreInputValidator.class);

  private static SubClusterId subClusterId;
  private static String amRMServiceAddress;
  private static String clientRMServiceAddress;
  private static String rmAdminServiceAddress;
  private static String rmWebServiceAddress;
  private static int lastHeartBeat;
  private static SubClusterState stateNew;
  private static SubClusterState stateLost;
  private static ApplicationId appId;
  private static int lastStartTime;
  private static String capability;
  private static String queue;
  private static String type;
  private static ByteBuffer params;

  private static SubClusterId subClusterIdInvalid;
  private static SubClusterId subClusterIdNull;

  private static int lastHeartBeatNegative;
  private static int lastStartTimeNegative;

  private static SubClusterState stateNull;
  private static ApplicationId appIdNull;

  private static String capabilityNull;
  private static String capabilityEmpty;

  private static String addressNull;
  private static String addressEmpty;
  private static String addressWrong;
  private static String addressWrongPort;

  private static String queueEmpty;
  private static String queueNull;

  private static String typeEmpty;
  private static String typeNull;

  @BeforeClass
  public static void setUp() {
    subClusterId = SubClusterId.newInstance("abc");
    amRMServiceAddress = "localhost:8032";
    clientRMServiceAddress = "localhost:8034";
    rmAdminServiceAddress = "localhost:8031";
    rmWebServiceAddress = "localhost:8088";
    lastHeartBeat = 1000;
    stateNew = SubClusterState.SC_NEW;
    stateLost = SubClusterState.SC_LOST;
    lastStartTime = 1000;
    capability = "Memory VCores";
    appId = ApplicationId.newInstance(lastStartTime, 1);
    queue = "default";
    type = "random";
    params = ByteBuffer.allocate(10);
    params.put((byte) 0xFF);

    subClusterIdInvalid = SubClusterId.newInstance("");
    subClusterIdNull = null;

    lastHeartBeatNegative = -10;
    lastStartTimeNegative = -10;

    stateNull = null;
    appIdNull = null;

    capabilityNull = null;
    capabilityEmpty = "";

    addressNull = null;
    addressEmpty = "";
    addressWrong = "AddressWrong";
    addressWrongPort = "Address:WrongPort";

    queueEmpty = "";
    queueNull = null;

    typeEmpty = "";
    typeNull = null;
  }

  @Test
  public void testValidateSubClusterRegisterRequest() {

    // Execution with valid inputs

    SubClusterInfo subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      SubClusterRegisterRequest request = null;
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubClusterRegister Request."));
    }

    // Execution with null SubClusterInfo

    subClusterInfo = null;
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Information."));
    }

    // Execution with Null SubClusterId

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterIdNull, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with Invalid SubClusterId

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterIdInvalid, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }

    // Execution with Null State

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster State information."));
    }

    // Execution with Null Capability

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capabilityNull);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with Empty Capability

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capabilityEmpty);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }
  }

  @Test
  public void testValidateSubClusterRegisterRequestTimestamp() {

    // Execution with Negative Last Heartbeat

    SubClusterInfo subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeatNegative, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid timestamp information."));
    }

    // Execution with Negative Last StartTime

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTimeNegative, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid timestamp information."));
    }
  }

  @Test
  public void testValidateSubClusterRegisterRequestAddress() {
    // Execution with Null Address for amRMServiceAddress

    SubClusterInfo subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, addressNull,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Empty Address for amRMServiceAddress

    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressEmpty,
        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
        lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Null Address for clientRMServiceAddress

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            addressNull, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Empty Address for clientRMServiceAddress

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            addressEmpty, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Null Address for rmAdminServiceAddress

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, addressNull, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Empty Address for rmAdminServiceAddress

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, addressEmpty, rmWebServiceAddress,
            lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Null Address for rmWebServiceAddress

    subClusterInfo = SubClusterInfo.newInstance(subClusterId,
        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,
        addressNull, lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }

    // Execution with Empty Address for rmWebServiceAddress

    subClusterInfo = SubClusterInfo.newInstance(subClusterId,
        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,
        addressEmpty, lastHeartBeat, stateNew, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SubCluster Endpoint information."));
    }
  }

  @Test
  public void testValidateSubClusterRegisterRequestAddressInvalid() {

    // Address is not in host:port format for amRMService

    SubClusterInfo subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, addressWrong,
            clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Address is not in host:port format for clientRMService

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            addressWrong, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Address is not in host:port format for rmAdminService

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, addressWrong, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Address is not in host:port format for rmWebService

    subClusterInfo = SubClusterInfo.newInstance(subClusterId,
        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,
        addressWrong, lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Port is not an integer for amRMService

    subClusterInfo = SubClusterInfo.newInstance(subClusterId, addressWrongPort,
        clientRMServiceAddress, rmAdminServiceAddress, rmWebServiceAddress,
        lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Port is not an integer for clientRMService

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            addressWrongPort, rmAdminServiceAddress, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Port is not an integer for rmAdminService

    subClusterInfo =
        SubClusterInfo.newInstance(subClusterId, amRMServiceAddress,
            clientRMServiceAddress, addressWrongPort, rmWebServiceAddress,
            lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

    // Port is not an integer for rmWebService

    subClusterInfo = SubClusterInfo.newInstance(subClusterId,
        amRMServiceAddress, clientRMServiceAddress, rmAdminServiceAddress,
        addressWrongPort, lastHeartBeat, stateNull, lastStartTime, capability);
    try {
      SubClusterRegisterRequest request =
          SubClusterRegisterRequest.newInstance(subClusterInfo);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().contains("valid host:port authority:"));
    }

  }

  @Test
  public void testValidateSubClusterDeregisterRequest() {

    // Execution with valid inputs

    try {
      SubClusterDeregisterRequest request =
          SubClusterDeregisterRequest.newInstance(subClusterId, stateLost);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      SubClusterDeregisterRequest request = null;
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubClusterDeregister Request."));
    }

    // Execution with null SubClusterId

    try {
      SubClusterDeregisterRequest request =
          SubClusterDeregisterRequest.newInstance(subClusterIdNull, stateLost);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with invalid SubClusterId

    try {
      SubClusterDeregisterRequest request = SubClusterDeregisterRequest
          .newInstance(subClusterIdInvalid, stateLost);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }

    // Execution with null SubClusterState

    try {
      SubClusterDeregisterRequest request =
          SubClusterDeregisterRequest.newInstance(subClusterId, stateNull);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster State information."));
    }

    // Execution with invalid SubClusterState

    try {
      SubClusterDeregisterRequest request =
          SubClusterDeregisterRequest.newInstance(subClusterId, stateNew);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(e.getMessage().startsWith("Invalid non-final state: "));
    }
  }

  @Test
  public void testSubClusterHeartbeatRequest() {

    // Execution with valid inputs

    try {
      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest
          .newInstance(subClusterId, lastHeartBeat, stateLost, capability);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      SubClusterHeartbeatRequest request = null;
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubClusterHeartbeat Request."));
    }

    // Execution with null SubClusterId

    try {
      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest
          .newInstance(subClusterIdNull, lastHeartBeat, stateLost, capability);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with invalid SubClusterId

    try {
      SubClusterHeartbeatRequest request =
          SubClusterHeartbeatRequest.newInstance(subClusterIdInvalid,
              lastHeartBeat, stateLost, capability);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }

    // Execution with null SubClusterState

    try {
      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest
          .newInstance(subClusterId, lastHeartBeat, stateNull, capability);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster State information."));
    }

    // Execution with negative Last Heartbeat

    try {
      SubClusterHeartbeatRequest request =
          SubClusterHeartbeatRequest.newInstance(subClusterId,
              lastHeartBeatNegative, stateLost, capability);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid timestamp information."));
    }

    // Execution with null Capability

    try {
      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest
          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityNull);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid capability information."));
    }

    // Execution with empty Capability

    try {
      SubClusterHeartbeatRequest request = SubClusterHeartbeatRequest
          .newInstance(subClusterId, lastHeartBeat, stateLost, capabilityEmpty);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid capability information."));
    }
  }

  @Test
  public void testGetSubClusterInfoRequest() {

    // Execution with valid inputs

    try {
      GetSubClusterInfoRequest request =
          GetSubClusterInfoRequest.newInstance(subClusterId);
      FederationMembershipStateStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      GetSubClusterInfoRequest request = null;
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing GetSubClusterInfo Request."));
    }

    // Execution with null SubClusterId

    try {
      GetSubClusterInfoRequest request =
          GetSubClusterInfoRequest.newInstance(subClusterIdNull);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with invalid SubClusterId

    try {
      GetSubClusterInfoRequest request =
          GetSubClusterInfoRequest.newInstance(subClusterIdInvalid);
      FederationMembershipStateStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }
  }

  @Test
  public void testAddApplicationHomeSubClusterRequest() {

    // Execution with valid inputs

    ApplicationHomeSubCluster applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterId);
    try {
      AddApplicationHomeSubClusterRequest request =
          AddApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      AddApplicationHomeSubClusterRequest request = null;
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing AddApplicationHomeSubCluster Request."));
    }

    // Execution with null ApplicationHomeSubCluster

    applicationHomeSubCluster = null;
    try {
      AddApplicationHomeSubClusterRequest request =
          AddApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(
          e.getMessage().startsWith("Missing ApplicationHomeSubCluster Info."));
    }

    // Execution with null SubClusterId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);
    try {
      AddApplicationHomeSubClusterRequest request =
          AddApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with invalid SubClusterId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);
    try {
      AddApplicationHomeSubClusterRequest request =
          AddApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }

    // Execution with Null ApplicationId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);
    try {
      AddApplicationHomeSubClusterRequest request =
          AddApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Application Id."));
    }
  }

  @Test
  public void testUpdateApplicationHomeSubClusterRequest() {

    // Execution with valid inputs

    ApplicationHomeSubCluster applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterId);
    try {
      UpdateApplicationHomeSubClusterRequest request =
          UpdateApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      UpdateApplicationHomeSubClusterRequest request = null;
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing UpdateApplicationHomeSubCluster Request."));
    }

    // Execution with null ApplicationHomeSubCluster

    applicationHomeSubCluster = null;
    try {
      UpdateApplicationHomeSubClusterRequest request =
          UpdateApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(
          e.getMessage().startsWith("Missing ApplicationHomeSubCluster Info."));
    }

    // Execution with null SubClusteId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterIdNull);
    try {
      UpdateApplicationHomeSubClusterRequest request =
          UpdateApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubCluster Id information."));
    }

    // Execution with invalid SubClusterId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appId, subClusterIdInvalid);
    try {
      UpdateApplicationHomeSubClusterRequest request =
          UpdateApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      LOG.info(e.getMessage());
      Assert.assertTrue(
          e.getMessage().startsWith("Invalid SubCluster Id information."));
    }

    // Execution with null ApplicationId

    applicationHomeSubCluster =
        ApplicationHomeSubCluster.newInstance(appIdNull, subClusterId);
    try {
      UpdateApplicationHomeSubClusterRequest request =
          UpdateApplicationHomeSubClusterRequest
              .newInstance(applicationHomeSubCluster);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Application Id."));
    }
  }

  @Test
  public void testGetApplicationHomeSubClusterRequest() {

    // Execution with valid inputs

    try {
      GetApplicationHomeSubClusterRequest request =
          GetApplicationHomeSubClusterRequest.newInstance(appId);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      GetApplicationHomeSubClusterRequest request = null;
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing GetApplicationHomeSubCluster Request."));
    }

    // Execution with null ApplicationId

    try {
      GetApplicationHomeSubClusterRequest request =
          GetApplicationHomeSubClusterRequest.newInstance(appIdNull);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Application Id."));
    }

  }

  @Test
  public void testDeleteApplicationHomeSubClusterRequestNull() {

    // Execution with valid inputs

    try {
      DeleteApplicationHomeSubClusterRequest request =
          DeleteApplicationHomeSubClusterRequest.newInstance(appId);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      DeleteApplicationHomeSubClusterRequest request = null;
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing DeleteApplicationHomeSubCluster Request."));
    }

    // Execution with null ApplicationId

    try {
      DeleteApplicationHomeSubClusterRequest request =
          DeleteApplicationHomeSubClusterRequest.newInstance(appIdNull);
      FederationApplicationHomeSubClusterStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Application Id."));
    }

  }

  @Test
  public void testGetSubClusterPolicyConfigurationRequest() {

    // Execution with valid inputs

    try {
      GetSubClusterPolicyConfigurationRequest request =
          GetSubClusterPolicyConfigurationRequest.newInstance(queue);
      FederationPolicyStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      GetSubClusterPolicyConfigurationRequest request = null;
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing GetSubClusterPolicyConfiguration Request."));
    }

    // Execution with null queue id

    try {
      GetSubClusterPolicyConfigurationRequest request =
          GetSubClusterPolicyConfigurationRequest.newInstance(queueNull);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Queue."));
    }

    // Execution with empty queue id

    try {
      GetSubClusterPolicyConfigurationRequest request =
          GetSubClusterPolicyConfigurationRequest.newInstance(queueEmpty);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Queue."));
    }

  }

  @Test
  public void testSetSubClusterPolicyConfigurationRequest() {

    // Execution with valid inputs

    try {
      SubClusterPolicyConfiguration policy =
          SubClusterPolicyConfiguration.newInstance(queue, type, params);
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.fail(e.getMessage());
    }

    // Execution with null request

    try {
      SetSubClusterPolicyConfigurationRequest request = null;
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage()
          .startsWith("Missing SetSubClusterPolicyConfiguration Request."));
    }

    // Execution with null SubClusterPolicyConfiguration

    try {
      SubClusterPolicyConfiguration policy = null;
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(
          e.getMessage().startsWith("Missing SubClusterPolicyConfiguration."));
    }

    // Execution with null queue id

    try {
      SubClusterPolicyConfiguration policy =
          SubClusterPolicyConfiguration.newInstance(queueNull, type, params);
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Queue."));
    }

    // Execution with empty queue id

    try {
      SubClusterPolicyConfiguration policy =
          SubClusterPolicyConfiguration.newInstance(queueEmpty, type, params);
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Queue."));
    }

    // Execution with null policy type

    try {
      SubClusterPolicyConfiguration policy =
          SubClusterPolicyConfiguration.newInstance(queue, typeNull, params);
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Policy Type."));
    }

    // Execution with empty policy type

    try {
      SubClusterPolicyConfiguration policy =
          SubClusterPolicyConfiguration.newInstance(queue, typeEmpty, params);
      SetSubClusterPolicyConfigurationRequest request =
          SetSubClusterPolicyConfigurationRequest.newInstance(policy);
      FederationPolicyStoreInputValidator
          .validate(request);
      Assert.fail();
    } catch (FederationStateStoreInvalidInputException e) {
      Assert.assertTrue(e.getMessage().startsWith("Missing Policy Type."));
    }
  }

}
```


Overlapping Code:
```
s TestFederationStateStoreInputValidator {
private static final Logger LOG =
LoggerFactory.getLogger(TestFederationStateStoreInputValidator.class);
private static SubClusterId subClusterId;
private static String amRMServiceAddress;
private static String clientRMServiceAddress;
private static String rmAdminServiceAddress;
private static String rmWebServiceAddress;
private static int lastHeartBeat;
private static SubClusterState stateNew;
private static SubClusterState stateLost;
private static ApplicationId appId;
private static int lastStartTime;
private static String capability;
private static String queue;
private static String type;
private static ByteBuffer params;
private static SubClusterId subClusterIdInvalid;
private static SubClusterId subClusterIdNull;
private static int lastHeartBeatNegative;
private static int lastStartTimeNegative;
private static SubClusterState stateNull;
private static ApplicationId appIdNull;
private static String capabilityNull;
private static String capabilityEmpty;
private static String addressNull;
private static String addressEmpty;
private static String addressWrong;
private static String addressWrongPort;
private static String queueEmpty;
private static String queueNull;
private static String typeEmpty;
private static String typeNull;
@BeforeClass
public static void setUp() {
subClusterId = SubClusterId.newInstance("abc");
amRMServiceAddress = "localhost:8032";
clientRMServiceAddress = "localhost:8034";
rmAdminServiceAddress = "localhost:8031";
rmWebServiceAddress = "localhost:8088";
lastHeartBeat = 1000;
stateNew = SubClusterState.SC_NEW;
stateLost = SubClusterState.SC_LOST;
lastStartTime = 1000;
capability = "Memory VCores";
appId = ApplicationId.newInstance(lastStartTime, 1);
queue = "default";
type = "random";
params = ByteBuffer.allocate(10);
params.put((byte) 0xFF);
subClusterIdInvalid = SubClusterId.newInstance("");
subClusterIdNull = null;
lastHeartBeatNegative = -10;
lastStartTimeNegative = -10;
stateNull = null;
appIdNull = null;
capabilityNull = null;
capabilityEmpty = "";
addressNull = null;
addressEmpty = "";
addressWrong = "AddressWrong";
addressWrongPort = "Address:WrongPort";
queueEmpty = "";
queueNull = null;
typeEmpty = "";
typeNull = null;
}
@Test
publi
```
<Overlap Ratio: 0.9872751206669592>

---

--- 157 --
Question ID: 78e8d20e9ccc772ee9791869c2caceeffb8f94fe_0
Original Code:
```
@ThreadSafe
class BroadcastOutputBufferManager
    implements OutputBufferManager {
    private final Consumer<OutputBuffers> outputBufferTarget;
    private final Map<Integer, Boolean> outputNoMoreBuffers;

    @GuardedBy("this")
    private OutputBuffers outputBuffers =
        OutputBuffers.createInitialEmptyOutputBuffers(OutputBuffers.BufferType.BROADCAST);

    public BroadcastOutputBufferManager(Map<Integer, Boolean> outputNoMoreBuffers,
                                        Consumer<OutputBuffers> outputBufferTarget) {
        this.outputBufferTarget = requireNonNull(outputBufferTarget, "outputBufferTarget is null");
        this.outputNoMoreBuffers = requireNonNull(outputNoMoreBuffers, "outputNoMoreBuffers is null");
        outputBufferTarget.accept(outputBuffers);
    }

    @Override
    public void addOutputBuffers(StageId stageId, List<OutputBuffers.OutputBufferId> newBuffers,
                                 boolean noMoreBuffers) {
        OutputBuffers newOutputBuffers;
        synchronized (this) {
            if (outputBuffers.isNoMoreBufferIds()) {
                // a stage can move to a final state (e.g., failed) while scheduling, so ignore
                // the new buffers
                return;
            }

            OutputBuffers originalOutputBuffers = outputBuffers;

            // Note: it does not matter which partition id the task is using, in broadcast all tasks read from the same partition
            for (OutputBuffers.OutputBufferId newBuffer : newBuffers) {
                outputBuffers = outputBuffers.withBuffer(newBuffer, OutputBuffers.BROADCAST_PARTITION_ID);
            }

            Boolean stageNoMoreBuffersFlag = outputNoMoreBuffers.get(stageId.getId());
            checkArgument(stageNoMoreBuffersFlag != null, "noMoreBuffersFlag for stage:%s is null", stageId.getId());
            if (noMoreBuffers && stageNoMoreBuffersFlag.equals(false)) {
                outputNoMoreBuffers.put(stageId.getId(), true);
            }

            // only set no more buffers flag
            boolean notFinish = false;
            for (Boolean isNoMoreBuffers : outputNoMoreBuffers.values()) {
                if (!isNoMoreBuffers) {
                    notFinish = true;
                    break;
                }
            }
            if (!notFinish) {
                outputBuffers = outputBuffers.withNoMoreBufferIds();
            }

            // don't update if nothing changed
            if (outputBuffers == originalOutputBuffers) {
                return;
            }
            newOutputBuffers = this.outputBuffers;
        }
        outputBufferTarget.accept(newOutputBuffers);
    }
}
```


Overlapping Code:
```
e
class BroadcastOutputBufferManager
implements OutputBufferManager {
private final Consumer<OutputBuffers> outputBufferTarget;
private final Map<Integer, Boolean> outputNoMoreBuffers;
@GuardedBy("this")
private OutputBuffers outputBuffers =
OutputBuffers.createInitialEmptyOutputBuffers(OutputBuffers.BufferType.BROADCAST);
public BroadcastOutputBufferManager(Map<Integer, Boolean> outputNoMoreBuffers,
Consumer<OutputBuffers> outputBufferTarget) {
this.outputBufferTarget = requireNonNull(outputBufferTarget, "outputBufferTarget is null");
this.outputNoMoreBuffers = requireNonNull(outputNoMoreBuffers, "outputNoMoreBuffers is null");
outputBufferTarget.accept(outputBuffers);
}
@Override
public void addOutputBuffers(StageId stageId, List<OutputBuffers.OutputBufferId> newBuffers,
boolean noMoreBuffers) {
OutputBuffers newOutputBuffers;
synchronized (this) {
if (outputBuffers.isNoMoreBufferIds()) {
// a stage can move to a final state (e.g., failed) while scheduling, so ignore
// the new buffers
return;
}
OutputBuffers originalOutputBuffers = outputBuffers;
// Note: it does not matter which partition id the task is using, in broadcast all tasks read from the same partition
for (OutputBuffers.OutputBufferId newBuffer : newBuffers) {
outputBuffers = outputBuffers.withBuffer(newBuffer, OutputBuffers.BROADCAST_PARTITION_ID);
}
Boolean stageNoMoreBuffersFlag = outputNoMoreBuffers.get(stageId.getId());
checkArgument(stageNoMoreBuffersFlag != null, "noMoreBuffersFlag for stage:%s is null", stageId.getId());
if (noMoreBuffers && stageNoMoreBuffersFlag.equals(false)) {
outputNoMoreBuffers.put(stageId.getId(), true);
}
// only set no more buffers flag
boolean notFinish = false;
for (Boolean isNoMoreBuffers : outputNoMoreBuffers.values()) {
if (!isNoMoreBuffers) {
notFinish = true;
break;
}
}
if (!notFinish) {
outputBuffers = outputBuffers.withNoMoreBufferIds();
}
// don't update if nothing changed
if (outputB
```
<Overlap Ratio: 0.9866666666666667>

---

--- 158 --
Question ID: 3ea81b72b10a1a71d38f4038b6a333e9e787f304_0
Original Code:
```
public class ManagementUtil {

    /**
     * Get the MBeanServerId of Agent ID for the provided MBeanServer.
     *
     * @param aMBeanServer MBeanServer whose Server ID/Agent ID is desired.
     * @return MBeanServerId/Agent ID of provided MBeanServer.
     */
    public static String getMBeanServerId(final MBeanServer aMBeanServer) {
        String serverId = null;
        final String SERVER_DELEGATE = "JMImplementation:type=MBeanServerDelegate";
        final String MBEAN_SERVER_ID_KEY = "MBeanServerId";
        try {
            ObjectName delegateObjName = new ObjectName(SERVER_DELEGATE);
            serverId = (String) aMBeanServer.getAttribute(delegateObjName,
                    MBEAN_SERVER_ID_KEY);
        } catch (MalformedObjectNameException malformedObjectNameException) {
            //System.err.println("Problems constructing MBean ObjectName: " + malformedObjectNameException.getMessage());
        } catch (AttributeNotFoundException noMatchingAttrException) {
            //System.err.println("Unable to find attribute " + MBEAN_SERVER_ID_KEY + " in MBean " + SERVER_DELEGATE + ": " + noMatchingAttrException);
        } catch (MBeanException mBeanException) {
            //System.err.println("Exception thrown by MBean's (" + SERVER_DELEGATE + "'s " + MBEAN_SERVER_ID_KEY + ") getter: " + mBeanException.getMessage());
        } catch (ReflectionException reflectionException) {
            //System.err.println("Exception thrown by MBean's (" + SERVER_DELEGATE + "'s " + MBEAN_SERVER_ID_KEY + ") setter: " + reflectionException.getMessage());
        } catch (InstanceNotFoundException noMBeanInstance) {
            //System.err.println("No instance of MBean " + SERVER_DELEGATE + " found in MBeanServer: " + noMBeanInstance.getMessage());
        }
        return serverId;
    }

}
```


Overlapping Code:
```
ic class ManagementUtil {
/**
* Get the MBeanServerId of Agent ID for the provided MBeanServer.
*
* @param aMBeanServer MBeanServer whose Server ID/Agent ID is desired.
* @return MBeanServerId/Agent ID of provided MBeanServer.
*/
public static String getMBeanServerId(final MBeanServer aMBeanServer) {
String serverId = null;
final String SERVER_DELEGATE = "JMImplementation:type=MBeanServerDelegate";
final String MBEAN_SERVER_ID_KEY = "MBeanServerId";
try {
ObjectName delegateObjName = new ObjectName(SERVER_DELEGATE);
serverId = (String) aMBeanServer.getAttribute(delegateObjName,
MBEAN_SERVER_ID_KEY);
} catch (MalformedObjectNameException malformedObjectNameException) {
//System.err.println("Problems constructing MBean ObjectName: " + malformedObjectNameException.getMessage());
} catch (AttributeNotFoundException noMatchingAttrException) {
//System.err.println("Unable to find attribute " + MBEAN_SERVER_ID_KEY + " in MBean " + SERVER_DELEGATE + ": " + noMatchingAttrException);
} catch (MBeanException mBeanException) {
//System.err.println("Exception thrown by MBean's (" + SERVER_DELEGATE + "'s " + MBEAN_SERVER_ID_KEY + ") getter: " + mBeanException.getMessage());
} catch (ReflectionException reflectionException) {
//System.err.println("Exception thrown by MBean's (" + SERVER_DELEGATE + "'s " + MBEAN_SERVER_ID_KEY + ") setter: " + reflectionException.getMessage());
} catch (InstanceNotFoundException noMBeanInstance) {
//System.err.println("No instance of MBean " + SERVER_DELEGATE + " found in MBeanServer: " + noMBeanInstance.getMessage());
}
re
```
<Overlap Ratio: 0.9861460957178841>

---

--- 159 --
Question ID: 1104846c58988fcda1603b26d6518a77a20f63c9_0
Original Code:
```
public class DoUnlessAttachedControllerPaysEffect extends OneShotEffect {

    protected Effects executingEffects = new Effects();
    private final Cost cost;
    private String chooseUseText;

    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost) {
        this(effect, cost, null);
    }

    public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost, String chooseUseText) {
        super(Outcome.Neutral);
        this.executingEffects.add(effect);
        this.cost = cost;
        this.chooseUseText = chooseUseText;
    }

    public DoUnlessAttachedControllerPaysEffect(final DoUnlessAttachedControllerPaysEffect effect) {
        super(effect);
        this.executingEffects = effect.executingEffects.copy();
        this.cost = effect.cost.copy();
        this.chooseUseText = effect.chooseUseText;
    }

    public void addEffect(Effect effect) {
        executingEffects.add(effect);
    }

    @Override
    public boolean apply(Game game, Ability source) {
        Permanent aura = game.getPermanentOrLKIBattlefield(source.getSourceId());
        if (aura == null) {
            return false;
        }
        Permanent attachedTo = game.getPermanentOrLKIBattlefield(aura.getAttachedTo());
        if (attachedTo == null) {
            return false;
        }
        Player controllerOfAttachedTo = game.getPlayer(attachedTo.getControllerId());
        if (controllerOfAttachedTo != null) {
            String message;
            if (chooseUseText == null) {
                String effectText = executingEffects.getText(source.getModes().getMode());
                message = "Pay " + cost.getText() + " to prevent (" + effectText.substring(0, effectText.length() - 1) + ")?";
            } else {
                message = chooseUseText;
            }
            message = CardUtil.replaceSourceName(message, aura.getName());
            boolean result = true;
            boolean doEffect = true;

            // check if controller is willing to pay
            if (cost.canPay(source, source, controllerOfAttachedTo.getId(), game)
                    && controllerOfAttachedTo.chooseUse(Outcome.Neutral, message, source, game)) {
                cost.clearPaid();
                if (cost.pay(source, game, source, controllerOfAttachedTo.getId(), false, null)) {
                    if (!game.isSimulation()) {
                        game.informPlayers(controllerOfAttachedTo.getLogName() + " pays the cost to prevent the effect");
                    }
                    doEffect = false;
                }
            }

            // do the effects if not paid
            if (doEffect) {
                for (Effect effect : executingEffects) {
                    effect.setTargetPointer(this.targetPointer);
                    if (effect instanceof OneShotEffect) {
                        result &= effect.apply(game, source);
                    } else {
                        game.addEffect((ContinuousEffect) effect, source);
                    }
                }
            }
            return result;
        }
        return false;
    }

    @Override
    public String getText(Mode mode) {
        if (!staticText.isEmpty()) {
            return staticText;
        }
        String effectsText = executingEffects.getText(mode);
        return effectsText.substring(0, effectsText.length() - 1) + " unless controller pays " + cost.getText();
    }

    @Override
    public DoUnlessAttachedControllerPaysEffect copy() {
        return new DoUnlessAttachedControllerPaysEffect(this);
    }
}
```


Overlapping Code:
```
essAttachedControllerPaysEffect extends OneShotEffect {
protected Effects executingEffects = new Effects();
private final Cost cost;
private String chooseUseText;
public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost) {
this(effect, cost, null);
}
public DoUnlessAttachedControllerPaysEffect(Effect effect, Cost cost, String chooseUseText) {
super(Outcome.Neutral);
this.executingEffects.add(effect);
this.cost = cost;
this.chooseUseText = chooseUseText;
}
public DoUnlessAttachedControllerPaysEffect(final DoUnlessAttachedControllerPaysEffect effect) {
super(effect);
this.executingEffects = effect.executingEffects.copy();
this.cost = effect.cost.copy();
this.chooseUseText = effect.chooseUseText;
}
public void addEffect(Effect effect) {
executingEffects.add(effect);
}
@Override
public boolean apply(Game game, Ability source) {
Permanent aura = game.getPermanentOrLKIBattlefield(source.getSourceId());
if (aura == null) {
return false;
}
Permanent attachedTo = game.getPermanentOrLKIBattlefield(aura.getAttachedTo());
if (attachedTo == null) {
return false;
}
Player controllerOfAttachedTo = game.getPlayer(attachedTo.getControllerId());
if (controllerOfAttachedTo != null) {
String message;
if (chooseUseText == null) {
String effectText = executingEffects.getText(source.getModes().getMode());
message = "Pay " + cost.getText() + " to prevent (" + effectText.substring(0, effectText.length() - 1) + ")?";
} else {
message = chooseUseText;
}
message = CardUtil.replaceSourceName(message, aura.getName());
boolean result = true;
boolean doEffect = true;
// check if controller is willing to pay
if (cost.canPay(source, source, controllerOfAttachedTo.getId(), game)
&& controllerOfAttachedTo.chooseUse(Outcome.Neutral, message, source, game)) {
cost.clearPaid();
if (cost.pay(source, game, source, controllerOfAttachedTo.getId(), false, null)) {
if (!game.isSimulation()) {
game.informPlayers(controllerOfAttachedTo.getLogName() + 
```
<Overlap Ratio: 0.9711155378486056>

---

--- 160 --
Question ID: 59a8161407a6a4712485cbca245c5400ab930c1b_0
Original Code:
```
public class BuddyList {
	public ArrayList<BuddyTeamInfo> m_arrBuddyTeamInfo = new ArrayList<BuddyTeamInfo>();
	
	public void reset() {
		m_arrBuddyTeamInfo.clear();
	}
	
	public int getBuddyTeamCount() {
		return m_arrBuddyTeamInfo.size();
	}
	
	public BuddyTeamInfo getBuddyTeam(int nTeamIndex) {
		if (nTeamIndex >= 0 && nTeamIndex < m_arrBuddyTeamInfo.size())
			return m_arrBuddyTeamInfo.get(nTeamIndex);
		else
			return null;
	}
	
	public BuddyTeamInfo getBuddyTeamByIndex(int nIndex) {
		for (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)
		{
			BuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);
			if (buddyTeamInfo != null && nIndex == buddyTeamInfo.m_nIndex)
				return buddyTeamInfo;
		}
		return null;
	}
	
	public int getBuddyCount(int nTeamIndex) {
		BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
		if (buddyTeamInfo != null)
			return buddyTeamInfo.getBuddyCount();
		else
			return 0;
	}
	
	public int getOnlineBuddyCount(int nTeamIndex) {
		BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
		if (buddyTeamInfo != null)
			return buddyTeamInfo.getOnlineBuddyCount();
		else
			return 0;
	}
	
	public BuddyInfo getBuddy(int nTeamIndex, int nIndex) {
		BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
		if (buddyTeamInfo != null)
			return buddyTeamInfo.getBuddy(nIndex);
		else
			return null;
	}
	
	public BuddyInfo getBuddy(int nQQUin) {
		for (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)
		{
			BuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);
			if (buddyTeamInfo != null)
			{
				for (int j = 0; j < buddyTeamInfo.m_arrBuddyInfo.size(); j++)
				{
					BuddyInfo buddyInfo = buddyTeamInfo.m_arrBuddyInfo.get(j);
					if (buddyInfo != null && buddyInfo.m_nQQUin == nQQUin)
						return buddyInfo;
				}
			}
		}
		return null;
	}
	
	public boolean setOnlineBuddyList(OnlineBuddyListResult result) {
		if (null == result)
			return false;

		for (int i = 0; i < result.m_arrOnlineBuddyInfo.size(); i++)
		{
			OnlineBuddyInfo onlineBuddyInfo = result.m_arrOnlineBuddyInfo.get(i);
			if (onlineBuddyInfo != null)
			{
				BuddyInfo buddyInfo = getBuddy(onlineBuddyInfo.m_nUin);
				if (buddyInfo != null)
				{
					buddyInfo.m_nClientType = onlineBuddyInfo.m_nClientType;
					buddyInfo.m_nStatus = onlineBuddyInfo.m_nStatus;
				}
			}
		}
		return true;
	}
	
	public void sortBuddyTeam() {
		BuddyTeamInfo buddyTeamInfo1, buddyTeamInfo2;
		boolean bExchange;
		int nCount;

		nCount = m_arrBuddyTeamInfo.size();
		for (int i = 0; i < nCount-1; i++)
		{
			bExchange = false;
			for (int j = nCount-1; j > i; j--)
			{
				buddyTeamInfo1 = m_arrBuddyTeamInfo.get(j-1);
				buddyTeamInfo2 = m_arrBuddyTeamInfo.get(j);
				if (buddyTeamInfo1 != null && buddyTeamInfo2 != null)
				{
					if (buddyTeamInfo2.m_nSort < buddyTeamInfo1.m_nSort)
					{
						m_arrBuddyTeamInfo.set(j-1, buddyTeamInfo2);
						m_arrBuddyTeamInfo.set(j, buddyTeamInfo1);
						bExchange = true;
					}
				}
			}
			if (!bExchange)
				break;
		}
	}
	
	public void sortBuddy() {
		for (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)
		{
			BuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);
			if (buddyTeamInfo != null)
				buddyTeamInfo.sort();
		}
	}
	
	public boolean addBuddyTeam(BuddyTeamInfo buddyTeamInfo) {
		if (null == buddyTeamInfo)
			return false;
		m_arrBuddyTeamInfo.add(buddyTeamInfo);
		return true;
	}
}
```


Overlapping Code:
```

public ArrayList<BuddyTeamInfo> m_arrBuddyTeamInfo = new ArrayList<BuddyTeamInfo>();

public void reset() {
m_arrBuddyTeamInfo.clear();
}

public int getBuddyTeamCount() {
return m_arrBuddyTeamInfo.size();
}

public BuddyTeamInfo getBuddyTeam(int nTeamIndex) {
if (nTeamIndex >= 0 && nTeamIndex < m_arrBuddyTeamInfo.size())
return m_arrBuddyTeamInfo.get(nTeamIndex);
else
return null;
}

public BuddyTeamInfo getBuddyTeamByIndex(int nIndex) {
for (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)
{
BuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);
if (buddyTeamInfo != null && nIndex == buddyTeamInfo.m_nIndex)
return buddyTeamInfo;
}
return null;
}

public int getBuddyCount(int nTeamIndex) {
BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
if (buddyTeamInfo != null)
return buddyTeamInfo.getBuddyCount();
else
return 0;
}

public int getOnlineBuddyCount(int nTeamIndex) {
BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
if (buddyTeamInfo != null)
return buddyTeamInfo.getOnlineBuddyCount();
else
return 0;
}

public BuddyInfo getBuddy(int nTeamIndex, int nIndex) {
BuddyTeamInfo buddyTeamInfo = getBuddyTeam(nTeamIndex);
if (buddyTeamInfo != null)
return buddyTeamInfo.getBuddy(nIndex);
else
return null;
}

public BuddyInfo getBuddy(int nQQUin) {
for (int i = 0; i < m_arrBuddyTeamInfo.size(); i++)
{
BuddyTeamInfo buddyTeamInfo = m_arrBuddyTeamInfo.get(i);
if (buddyTeamInfo != null)
{
for (int j = 0; j < buddyTeamInfo.m_arrBuddyInfo.size(); j++)
{
BuddyInfo buddyInfo = buddyTeamInfo.m_arrBuddyInfo.get(j);
if (buddyInfo != null && buddyInfo.m_nQQUin == nQQUin)
return buddyInfo;
}
}
}
return null;
}

public boolean setOnlineBuddyList(OnlineBuddyListResult result) {
if (null == result)
return false;
for (int i = 0; i < result.m_arrOnlineBuddyInfo.size(); i++)
{
OnlineBuddyInfo onlineBuddyInfo = result.m_arrOnlineBuddyInfo.get(i);
if (onlineBuddyInfo != null)
{
BuddyInfo buddyInfo = getBuddy(onlineBuddyInfo.m_nUin);
if (buddyInfo != null)
{
buddyInfo.m_nClientType = onlineBuddyInfo.m_nClientType;
buddyInfo.m_nStatus = onlineBuddyInfo.m_nStatus;
}
}
}
return true;
}

public void sortBuddyTeam() {
BuddyTeamInfo buddyTeamInfo1, buddyTeamInfo2;
boolean bExchange;
int nCount;
nCount = m_arrBuddyTeamInfo.size();
for
```
<Overlap Ratio: 0.982532751091703>

---

--- 161 --
Question ID: 38da4edfe24143fd0f72613e4d60bd71ef6d4b1a_0
Original Code:
```
public class PersistedOptions {

	/** Prefix used for keys to store normalization. */
	private static final String NORMALIZATION_KEY_PREFIX = "NORMALIZATION:";

	/** Key used to store the chunk length. */
	private static final String CHUNK_LENGTH_KEY = "CHUNK_LENGTH";

	/** The store used. */
	private final ICloneIndexStore store;

	/** Cache for normalizations. */
	private final Map<ELanguage, IUnitProvider<ITextResource, Unit>> normalizationCache = new EnumMap<ELanguage, IUnitProvider<ITextResource, Unit>>(
			ELanguage.class);

	/** Value used for unset/uncached chunk length. */
	public static final int UNSET = -1;

	/** Caches the chunk length. */
	private int cachedChunkLength = UNSET;

	/** Constructor. */
	public PersistedOptions(ICloneIndexStore store) {
		this.store = store;
	}

	/** Returns the normalization to be used for a given language. */
	public IUnitProvider<ITextResource, Unit> getNormalization(
			ELanguage language) throws StorageException {
		IUnitProvider<ITextResource, Unit> normalization = normalizationCache
				.get(language);
		if (normalization == null) {
			normalization = readNormalization(store, language);
			normalizationCache.put(language, normalization);
		}
		return normalization;
	}

	/**
	 * Returns the stored chunk length. If no length is set, an exception is
	 * thrown as this is a required field.
	 */
	public int getChunkLength() throws StorageException {
		if (cachedChunkLength <= 0) {
			cachedChunkLength = readChunkLength(store);
			if (cachedChunkLength <= 0) {
				throw new StorageException(
						"No chunk length found in store! Clone index not initialized?");
			}
		}
		return cachedChunkLength;
	}

	/**
	 * Sets the chunk length used. If the chunk length was already set and
	 * differs from the new provided value, a {@link StorageException} is
	 * thrown, as this would cause an inconsistent index.
	 * 
	 * @param chunkLength
	 *            the chunk length (must be positive).
	 */
	public static void setChunkLength(ICloneIndexStore store, int chunkLength)
			throws StorageException {
		CCSMAssert.isTrue(chunkLength > 0, "Only positive values allowed.");
		int oldLength = readChunkLength(store);
		if (oldLength < 0) {
			store.setOption(CHUNK_LENGTH_KEY, chunkLength);
		} else if (oldLength != chunkLength) {
			throw new StorageException(
					"Attempt to replace chunk length with different value!");
		}
	}

	/**
	 * Returns the stored chunk length. If no length is set, {@link #UNSET} is
	 * returned.
	 */
	public static int readChunkLength(ICloneIndexStore store)
			throws StorageException {
		Integer chunkLength = (Integer) store.getOption(CHUNK_LENGTH_KEY);
		if (chunkLength == null) {
			return UNSET;
		}
		return chunkLength;
	}

	/**
	 * Sets the normalization for the given language. If the normalization was
	 * already set and differs from the new provided normalization, a
	 * {@link StorageException} is thrown, as this would cause an inconsistent
	 * index. Equality of normalizations is checked by their serializations.
	 */
	public static void setNormalization(ICloneIndexStore store,
			ELanguage language,
			IUnitProvider<? extends ITextResource, Unit> normalization)
			throws StorageException {
		CCSMAssert.isNotNull(normalization);

		IUnitProvider<ITextResource, Unit> oldNormalization = readNormalization(
				store, language);
		if (oldNormalization == null) {
			store.setOption(normalizationKey(language), normalization);
		} else {
			ensureNormalizationsEqual(language, normalization, oldNormalization);
		}
	}

	/**
	 * Ensures that both normalizations are equals by serializing them and
	 * comparing bytes.
	 */
	private static void ensureNormalizationsEqual(ELanguage language,
			IUnitProvider<? extends ITextResource, Unit> normalization,
			IUnitProvider<? extends ITextResource, Unit> oldNormalization)
			throws StorageException {
		try {
			byte[] normalizationData = SerializationUtils
					.serializeToByteArray(normalization);
			byte[] oldNormalizationData = SerializationUtils
					.serializeToByteArray(oldNormalization);
			if (!Arrays.equals(normalizationData, oldNormalizationData)) {
				throw new StorageException(
						"Attempt to replace normalization for language "
								+ language + " with different normalization!");
			}
		} catch (IOException e) {
			throw new StorageException("Error during serialization!", e);
		}
	}

	/** Reads a normalization from a store. */
	@SuppressWarnings("unchecked")
	private static IUnitProvider<ITextResource, Unit> readNormalization(
			ICloneIndexStore store, ELanguage language) throws StorageException {
		return (IUnitProvider<ITextResource, Unit>) store
				.getOption(normalizationKey(language));
	}

	/** Returns the name used to store normalization for the given language. */
	private static String normalizationKey(ELanguage language) {
		return NORMALIZATION_KEY_PREFIX + language.name();
	}
}
```


Overlapping Code:
```
s {
/** Prefix used for keys to store normalization. */
private static final String NORMALIZATION_KEY_PREFIX = "NORMALIZATION:";
/** Key used to store the chunk length. */
private static final String CHUNK_LENGTH_KEY = "CHUNK_LENGTH";
/** The store used. */
private final ICloneIndexStore store;
/** Cache for normalizations. */
private final Map<ELanguage, IUnitProvider<ITextResource, Unit>> normalizationCache = new EnumMap<ELanguage, IUnitProvider<ITextResource, Unit>>(
ELanguage.class);
/** Value used for unset/uncached chunk length. */
public static final int UNSET = -1;
/** Caches the chunk length. */
private int cachedChunkLength = UNSET;
/** Constructor. */
public PersistedOptions(ICloneIndexStore store) {
this.store = store;
}
/** Returns the normalization to be used for a given language. */
public IUnitProvider<ITextResource, Unit> getNormalization(
ELanguage language) throws StorageException {
IUnitProvider<ITextResource, Unit> normalization = normalizationCache
.get(language);
if (normalization == null) {
normalization = readNormalization(store, language);
normalizationCache.put(language, normalization);
}
return normalization;
}
/**
* Returns the stored chunk length. If no length is set, an exception is
* thrown as this is a required field.
*/
public int getChunkLength() throws StorageException {
if (cachedChunkLength <= 0) {
cachedChunkLength = readChunkLength(store);
if (cachedChunkLength <= 0) {
throw new StorageException(
"No chunk length found in store! Clone index not initialized?");
}
}
return cachedChunkLength;
}
/**
* Sets the chunk length used. If the chunk length was already set and
* differs from the new provided value, a {@link StorageException} is
* thrown, as this would cause an inconsistent index.
* 
* @param chunkLength
* the chunk length (must be positive).
*/
public static void setChunkLength(ICloneIndexStore store, int chunkLength)
throws StorageException {
CCSMAssert.isTrue(chunkLength > 0, "Only positive values allowed.");
int oldLength = readChunkLength(store);
if (oldLength < 0) {
store.setOption(CHUNK_LENGTH_KEY, chunkLength);
} else if (oldLength != chunkLength) {
throw new StorageException(
"Attempt to replace chunk length with different value!");
}
}
/**
* Returns the stored chunk length. If no length is set, {@link #UNSET
```
<Overlap Ratio: 0.9787234042553191>

---

--- 162 --
Question ID: 6af3f32ebf817c19ce1c1ebf7583a79712c31618_0
Original Code:
```
public class SumToLeafNodes {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		TreeNode root = new TreeNode(1);

		TreeNode child1 = new TreeNode(1);
		TreeNode child2 = new TreeNode(1);
		child1.left = child2;
		root.right = child1;

		System.out.println(sumNumbers(root));
	}

	public static int sumNumbers(TreeNode root) {
		return sumNumbersHelper(root, 0);
	}

	private static int sumNumbersHelper(TreeNode root, int parentSum) {
		if (root == null)
			return 0;
		if (root.left == null && root.right == null)
			return parentSum * 10 + root.val;
		return sumNumbersHelper(root.left, parentSum * 10 + root.val)
				+ sumNumbersHelper(root.right, parentSum * 10 + root.val);
	}
}
```


Overlapping Code:
```
ToLeafNodes {
public static void main(String[] args) {
// TODO Auto-generated method stub
TreeNode root = new TreeNode(1);
TreeNode child1 = new TreeNode(1);
TreeNode child2 = new TreeNode(1);
child1.left = child2;
root.right = child1;
System.out.println(sumNumbers(root));
}
public static int sumNumbers(TreeNode root) {
return sumNumbersHelper(root, 0);
}
private static int sumNumbersHelper(TreeNode root, int parentSum) {
if (root == null)
return 0;
if (root.left == null && root.right == null)
return parentSum * 10 + root.val;
return sumNumbersHelper(root.left, parentSum * 10 + root.val)
+ sumNumbersHelpe
```
<Overlap Ratio: 0.9093610698365527>

---

--- 163 --
Question ID: 6943932b8652d103488dc8b0172c60413f4e1ea4_0
Original Code:
```
public class AbstractPersisterTest {
	
	@SuppressWarnings("unchecked")
	@Test
	public void testAlternateStateFields() {
		
		List<State<MockEntity>> states = new ArrayList<State<MockEntity>>();
		State<MockEntity> startState = mock(State.class);
		states.add(startState);
		
		MockPersister<MockEntity> mockPersister = new MockPersister<MockEntity>(
				states, 
				"stateField1", 
				startState, 
				MockEntity.class);
		Field field = mockPersister.getStateField();
		
		assertNotNull(field);
		assertEquals("stateField1", field.getName());

		mockPersister = new MockPersister<MockEntity>(
				states, 
				"", 
				startState, 
				MockEntity.class);
		field = mockPersister.getStateField();
		
		assertNotNull(field);
		assertEquals("stateField2", field.getName());
	}

}
```


Overlapping Code:
```
erTest {

@SuppressWarnings("unchecked")
@Test
public void testAlternateStateFields() {

List<State<MockEntity>> states = new ArrayList<State<MockEntity>>();
State<MockEntity> startState = mock(State.class);
states.add(startState);

MockPersister<MockEntity> mockPersister = new MockPersister<MockEntity>(
states, 
"stateField1", 
startState, 
MockEntity.class);
Field field = mockPersister.getStateField();

assertNotNull(field);
assertEquals("stateField1", field.getName());
mockPersister = new MockPersister<MockEntity>(
states, 
"", 
startState, 
MockEntity.class);
field = mockPersister.getStateField();

assertNotNull(field);
assertEquals("stateField2", fiel
```
<Overlap Ratio: 0.9365303244005642>

---

--- 164 --
Question ID: 26826cb79211c3de49ccd044750b79bf2b9162aa_0
Original Code:
```
public class msg_hil_controls extends MAVLinkMessage {

    public static final int MAVLINK_MSG_ID_HIL_CONTROLS = 91;
    public static final int MAVLINK_MSG_LENGTH = 42;
    private static final long serialVersionUID = MAVLINK_MSG_ID_HIL_CONTROLS;


    /**
     * Timestamp (microseconds since UNIX epoch or microseconds since system boot)
     */
    public long time_usec;

    /**
     * Control output -1 .. 1
     */
    public float roll_ailerons;

    /**
     * Control output -1 .. 1
     */
    public float pitch_elevator;

    /**
     * Control output -1 .. 1
     */
    public float yaw_rudder;

    /**
     * Throttle 0 .. 1
     */
    public float throttle;

    /**
     * Aux 1, -1 .. 1
     */
    public float aux1;

    /**
     * Aux 2, -1 .. 1
     */
    public float aux2;

    /**
     * Aux 3, -1 .. 1
     */
    public float aux3;

    /**
     * Aux 4, -1 .. 1
     */
    public float aux4;

    /**
     * System mode (MAV_MODE)
     */
    public short mode;

    /**
     * Navigation mode (MAV_NAV_MODE)
     */
    public short nav_mode;


    /**
     * Constructor for a new message, just initializes the msgid
     */
    public msg_hil_controls() {
        msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
    }

    /**
     * Constructor for a new message, initializes the message with the payload
     * from a mavlink packet
     */
    public msg_hil_controls(MAVLinkPacket mavLinkPacket) {
        this.sysid = mavLinkPacket.sysid;
        this.compid = mavLinkPacket.compid;
        this.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
        unpack(mavLinkPacket.payload);
    }

    /**
     * Generates the payload for a mavlink message for a message of this type
     *
     * @return
     */
    public MAVLinkPacket pack() {
        MAVLinkPacket packet = new MAVLinkPacket(MAVLINK_MSG_LENGTH);
        packet.sysid = 255;
        packet.compid = 190;
        packet.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;

        packet.payload.putUnsignedLong(time_usec);

        packet.payload.putFloat(roll_ailerons);

        packet.payload.putFloat(pitch_elevator);

        packet.payload.putFloat(yaw_rudder);

        packet.payload.putFloat(throttle);

        packet.payload.putFloat(aux1);

        packet.payload.putFloat(aux2);

        packet.payload.putFloat(aux3);

        packet.payload.putFloat(aux4);

        packet.payload.putUnsignedByte(mode);

        packet.payload.putUnsignedByte(nav_mode);

        return packet;
    }

    /**
     * Decode a hil_controls message into this class fields
     *
     * @param payload The message to decode
     */
    public void unpack(MAVLinkPayload payload) {
        payload.resetIndex();

        this.time_usec = payload.getUnsignedLong();

        this.roll_ailerons = payload.getFloat();

        this.pitch_elevator = payload.getFloat();

        this.yaw_rudder = payload.getFloat();

        this.throttle = payload.getFloat();

        this.aux1 = payload.getFloat();

        this.aux2 = payload.getFloat();

        this.aux3 = payload.getFloat();

        this.aux4 = payload.getFloat();

        this.mode = payload.getUnsignedByte();

        this.nav_mode = payload.getUnsignedByte();

    }

    /**
     * Returns a string with the MSG name and data
     */
    public String toString() {
        return "MAVLINK_MSG_ID_HIL_CONTROLS - sysid:" + sysid + " compid:" + compid + " time_usec:" + time_usec + " roll_ailerons:" + roll_ailerons + " pitch_elevator:" + pitch_elevator + " yaw_rudder:" + yaw_rudder + " throttle:" + throttle + " aux1:" + aux1 + " aux2:" + aux2 + " aux3:" + aux3 + " aux4:" + aux4 + " mode:" + mode + " nav_mode:" + nav_mode + "";
    }
}
```


Overlapping Code:
```
lass msg_hil_controls extends MAVLinkMessage {
public static final int MAVLINK_MSG_ID_HIL_CONTROLS = 91;
public static final int MAVLINK_MSG_LENGTH = 42;
private static final long serialVersionUID = MAVLINK_MSG_ID_HIL_CONTROLS;
/**
* Timestamp (microseconds since UNIX epoch or microseconds since system boot)
*/
public long time_usec;
/**
* Control output -1 .. 1
*/
public float roll_ailerons;
/**
* Control output -1 .. 1
*/
public float pitch_elevator;
/**
* Control output -1 .. 1
*/
public float yaw_rudder;
/**
* Throttle 0 .. 1
*/
public float throttle;
/**
* Aux 1, -1 .. 1
*/
public float aux1;
/**
* Aux 2, -1 .. 1
*/
public float aux2;
/**
* Aux 3, -1 .. 1
*/
public float aux3;
/**
* Aux 4, -1 .. 1
*/
public float aux4;
/**
* System mode (MAV_MODE)
*/
public short mode;
/**
* Navigation mode (MAV_NAV_MODE)
*/
public short nav_mode;
/**
* Constructor for a new message, just initializes the msgid
*/
public msg_hil_controls() {
msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
}
/**
* Constructor for a new message, initializes the message with the payload
* from a mavlink packet
*/
public msg_hil_controls(MAVLinkPacket mavLinkPacket) {
this.sysid = mavLinkPacket.sysid;
this.compid = mavLinkPacket.compid;
this.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
unpack(mavLinkPacket.payload);
}
/**
* Generates the payload for a mavlink message for a message of this type
*
* @return
*/
public MAVLinkPacket pack() {
MAVLinkPacket packet = new MAVLinkPacket(MAVLINK_MSG_LENGTH);
packet.sysid = 255;
packet.compid = 190;
packet.msgid = MAVLINK_MSG_ID_HIL_CONTROLS;
packet.payload.putUnsignedLong(time_usec);
packet.payload.putFloat(roll_ailerons);
packet.payload.putFloat(pitch_elevator);
packet.payload.putFloat(yaw_rudder);
packet.payload.putFloat(throttle);
packet.payload.putFloat(aux1);
packet.payload.putFloat(aux2);
packet.payload.putFloat(aux3);
packet.payload.putFloat(aux4);
packet.payload.putUnsignedByte(mode);
packet.payload.putUnsignedByte(nav_mode);
return packet;

```
<Overlap Ratio: 0.9850074962518741>

---

--- 165 --
Question ID: dd98d76b058c48a50eca80f901c078b4127bc5cf_0
Original Code:
```
public class EnterBetweenBracesHandler extends EnterHandlerDelegateAdapter {
  private static final Logger LOG = Logger.getInstance("#com.intellij.codeInsight.editorActions.enter.EnterBetweenBracesHandler");

  @Override
  public Result preprocessEnter(@NotNull final PsiFile file, @NotNull final Editor editor, @NotNull final Ref<Integer> caretOffsetRef, @NotNull final Ref<Integer> caretAdvance,
                                @NotNull final DataContext dataContext, final EditorActionHandler originalHandler) {
    Document document = editor.getDocument();
    CharSequence text = document.getCharsSequence();
    int caretOffset = caretOffsetRef.get().intValue();
    if (!CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {
      return Result.Continue;
    }
    
    if (caretOffset <= 0 || caretOffset >= text.length() || !isBracePair(text.charAt(caretOffset - 1), text.charAt(caretOffset))) {
      return Result.Continue;
    }

    final int line = document.getLineNumber(caretOffset);
    final int start = document.getLineStartOffset(line);
    final CodeDocumentationUtil.CommentContext commentContext =
      CodeDocumentationUtil.tryParseCommentContext(file, text, caretOffset, start);

    // special case: enter inside "()" or "{}"
    String indentInsideJavadoc = commentContext.docAsterisk
                                 ? CodeDocumentationUtil.getIndentInsideJavadoc(document, caretOffset)
                                 : null;

    originalHandler.execute(editor, dataContext);

    Project project = editor.getProject();
    if (indentInsideJavadoc != null && project != null && CodeStyleSettingsManager.getSettings(project).JD_LEADING_ASTERISKS_ARE_ENABLED) {
      document.insertString(editor.getCaretModel().getOffset(), "*" + indentInsideJavadoc);
    }

    PsiDocumentManager.getInstance(file.getProject()).commitDocument(document);
    try {
      CodeStyleManager.getInstance(file.getProject()).adjustLineIndent(file, editor.getCaretModel().getOffset());
    }
    catch (IncorrectOperationException e) {
      LOG.error(e);
    }
    return indentInsideJavadoc == null ? Result.Continue : Result.DefaultForceIndent;
  }

  protected boolean isBracePair(char c1, char c2) {
    return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}');
  }
}
```


Overlapping Code:
```
s EnterBetweenBracesHandler extends EnterHandlerDelegateAdapter {
private static final Logger LOG = Logger.getInstance("#com.intellij.codeInsight.editorActions.enter.EnterBetweenBracesHandler");
@Override
public Result preprocessEnter(@NotNull final PsiFile file, @NotNull final Editor editor, @NotNull final Ref<Integer> caretOffsetRef, @NotNull final Ref<Integer> caretAdvance,
@NotNull final DataContext dataContext, final EditorActionHandler originalHandler) {
Document document = editor.getDocument();
CharSequence text = document.getCharsSequence();
int caretOffset = caretOffsetRef.get().intValue();
if (!CodeInsightSettings.getInstance().SMART_INDENT_ON_ENTER) {
return Result.Continue;
}

if (caretOffset <= 0 || caretOffset >= text.length() || !isBracePair(text.charAt(caretOffset - 1), text.charAt(caretOffset))) {
return Result.Continue;
}
final int line = document.getLineNumber(caretOffset);
final int start = document.getLineStartOffset(line);
final CodeDocumentationUtil.CommentContext commentContext =
CodeDocumentationUtil.tryParseCommentContext(file, text, caretOffset, start);
// special case: enter inside "()" or "{}"
String indentInsideJavadoc = commentContext.docAsterisk
? CodeDocumentationUtil.getIndentInsideJavadoc(document, caretOffset)
: null;
originalHandler.execute(editor, dataContext);
Project project = editor.getProject();
if (indentInsideJavadoc != null && project != null && CodeStyleSettingsManager.getSettings(project).JD_LEADING_ASTERISKS_ARE_ENABLED) {
document.insertString(editor.getCaretModel().getOffset(), "*" + indentInsideJavadoc);
}
PsiDocumentManager.getInstance(file.getProject()).commitDocument(document);
try {
CodeStyleManager.getInstance(file.getProject()).adjustLineIndent(file, editor.getCaretModel().getOffset());
}
catch (IncorrectOperationException e) {
LOG.error(e);
}
return indentInsideJavadoc == null ? Result.Continue : Result.DefaultForceIndent;
}
protected boolean isBracePair(char c1, char c2) {
return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}
```
<Overlap Ratio: 0.9911764705882353>

---

--- 166 --
Question ID: 444ca9cb78c29026a7ce2db01d9000d5b632deb6_0
Original Code:
```
@Component(immediate = true, service = MepStore.class)
public class DistributedMepStore extends AbstractStore<CfmMepEvent, MepStoreDelegate>
    implements MepStore {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @Reference(cardinality = ReferenceCardinality.MANDATORY)
    protected StorageService storageService;

    private ConsistentMap<MepKeyId, Mep> mepConsistentMap;
    private Map<MepKeyId, Mep> mepMap;

    private MapEventListener<MepKeyId, Mep> mapListener = null;

    @Activate
    public void activate() {
        mepConsistentMap = storageService
                .<MepKeyId, Mep>consistentMapBuilder()
                .withName("onos-cfm-mep-map")
                .withSerializer(Serializer.using(new KryoNamespace.Builder()
                        .register(KryoNamespaces.API)
                        .register(DefaultMep.class)
                        .register(MepId.class)
                        .register(MepKeyId.class)
                        .register(NetworkResource.class)
                        .register(DeviceId.class)
                        .register(PortNumber.class)
                        .register(Mep.MepDirection.class)
                        .register(VlanId.class)
                        .register(Mep.Priority.class)
                        .register(Mep.FngAddress.class)
                        .register(Mep.FngAddressType.class)
                        .register(IpAddress.class)
                        .register(Mep.LowestFaultDefect.class)
                        .register(Duration.class)
                        .register(MdIdCharStr.class)
                        .register(MdIdDomainName.class)
                        .register(MdIdMacUint.class)
                        .register(MdIdNone.class)
                        .register(MaIdCharStr.class)
                        .register(MaIdShort.class)
                        .register(MaId2Octet.class)
                        .register(MaIdIccY1731.class)
                        .register(MaIdPrimaryVid.class)
                        .register(MaIdRfc2685VpnId.class)
                        .build("mep")))
                .build();
        mapListener = new InternalMepListener();
        mepConsistentMap.addListener(mapListener);

        mepMap = mepConsistentMap.asJavaMap();
        log.info("MepStore started");
    }

    @Deactivate
    public void deactivate() {
        mepConsistentMap.removeListener(mapListener);
        log.info("MepStore stopped");
    }

    @Override
    public Collection<Mep> getAllMeps() {
        return mepMap.values();
    }

    @Override
    public Collection<Mep> getMepsByMd(MdId mdName) {
        return mepMap.values().stream()
                .filter(mep -> mep.mdId().equals(mdName))
                .collect(Collectors.toList());
    }

    @Override
    public Collection<Mep> getMepsByMdMa(MdId mdName, MaIdShort maName) {
        return mepMap.values().stream()
                .filter(mep -> mep.mdId().equals(mdName) && mep.maId().equals(maName))
                .collect(Collectors.toList());
    }

    @Override
    public Collection<Mep> getMepsByDeviceId(DeviceId deviceId) {
        return mepMap.values().stream()
                .filter(mep -> mep.deviceId().equals(deviceId))
                .collect(Collectors.toList());
    }

    @Override
    public Optional<Mep> getMep(MepKeyId mepKeyId) {
        return mepMap.values().stream()
                .filter(mep -> mep.mdId().equals(mepKeyId.mdId()) &&
                        mep.maId().equals(mepKeyId.maId()) &&
                        mep.mepId().equals(mepKeyId.mepId()))
                .findFirst();
    }

    @Override
    public boolean deleteMep(MepKeyId mepKeyId) {
        return mepMap.remove(mepKeyId) == null ? false : true;
    }

    @Override
    public boolean createUpdateMep(MepKeyId mepKeyId, Mep mep) {
        return mepMap.put(mepKeyId, mep) == null ? false : true;
    }

    private class InternalMepListener implements MapEventListener<MepKeyId, Mep> {

        @Override
        public void event(MapEvent<MepKeyId, Mep> mapEvent) {
            final CfmMepEvent.Type type;

            switch (mapEvent.type()) {
                case INSERT:
                    type = CfmMepEvent.Type.MEP_ADDED;
                    break;
                case UPDATE:
                    type = CfmMepEvent.Type.MEP_UPDATED;
                    break;
                default:
                case REMOVE:
                    type = CfmMepEvent.Type.MEP_REMOVED;
            }
            notifyDelegate(new CfmMepEvent(type, mapEvent.key()));
        }
    }
}
```


Overlapping Code:
```
class)
public class DistributedMepStore extends AbstractStore<CfmMepEvent, MepStoreDelegate>
implements MepStore {
private final Logger log = LoggerFactory.getLogger(getClass());
@Reference(cardinality = ReferenceCardinality.MANDATORY)
protected StorageService storageService;
private ConsistentMap<MepKeyId, Mep> mepConsistentMap;
private Map<MepKeyId, Mep> mepMap;
private MapEventListener<MepKeyId, Mep> mapListener = null;
@Activate
public void activate() {
mepConsistentMap = storageService
.<MepKeyId, Mep>consistentMapBuilder()
.withName("onos-cfm-mep-map")
.withSerializer(Serializer.using(new KryoNamespace.Builder()
.register(KryoNamespaces.API)
.register(DefaultMep.class)
.register(MepId.class)
.register(MepKeyId.class)
.register(NetworkResource.class)
.register(DeviceId.class)
.register(PortNumber.class)
.register(Mep.MepDirection.class)
.register(VlanId.class)
.register(Mep.Priority.class)
.register(Mep.FngAddress.class)
.register(Mep.FngAddressType.class)
.register(IpAddress.class)
.register(Mep.LowestFaultDefect.class)
.register(Duration.class)
.register(MdIdCharStr.class)
.register(MdIdDomainName.class)
.register(MdIdMacUint.class)
.register(MdIdNone.class)
.register(MaIdCharStr.class)
.register(MaIdShort.class)
.register(MaId2Octet.class)
.register(MaIdIccY1731.class)
.register(MaIdPrimaryVid.class)
.register(MaIdRfc2685VpnId.class)
.build("mep")))
.build();
mapListener = new InternalMepListener();
mepConsistentMap.addListener(mapListener);
mepMap = mepConsistentMap.asJavaMap();
log.info("MepStore started");
}
@Deactivate
public void deactivate() {
mepConsistentMap.removeListener(mapListener);
log.info("MepStore s
```
<Overlap Ratio: 0.9705882352941176>

---

--- 167 --
Question ID: 4f9bb5e5d74727a6b76a10657eaea95f97d27788_0
Original Code:
```
public class GenericHandlerTest {

  private GenericHandler gh;
  private final ContextStore store = new ContextStore();

  @Test(expected = NullPointerException.class)
  public void testNullContext() {
    gh = new MockGenericHandler(null);
  }

  @Test
  @SuppressWarnings("PMD.JUnitTestsShouldIncludeAssert")
  public void testNoClaim() {
    gh = new MockGenericHandler();
    gh = new MockGenericHandler("testNoClaim");
    gh = new MockGenericHandler("testNoClaim", false);
    // An exception will be thrown if something went wrong
  }

  @Test(expected = IllegalArgumentException.class)
  public void testClaim() {
    String context = "testClaim";
    gh = new MockGenericHandler(context, true);
    assertTrue("Context should have been claimed", store.contains(context));
    gh = new MockGenericHandler(context, true); // Should throw IllegalArgumentException
  }

  @Test
  public void testGetContext() {
    String context = "testGetContext";
    gh = new MockGenericHandler(context);
    assertEquals("Context was wrong", context, gh.getContext());
  }

  @After
  public void tearDown() {
    if (gh != null) {
      gh.releaseContext();
    }
  }

  private class MockGenericHandler extends GenericHandler {

    MockGenericHandler() {
      super();
    }

    MockGenericHandler(String context) {
      super(store, context);
    }

    MockGenericHandler(String context, boolean doClaim) {
      super(store, context, doClaim);
    }

    @Override
    public void handle(String target,
                       Request baseRequest,
                       HttpServletRequest request,
                       HttpServletResponse response) throws IOException, ServletException {
      // Do nothing, this class is only used for testing automatic claims
    }
  }

}
```


Overlapping Code:
```
{
private GenericHandler gh;
private final ContextStore store = new ContextStore();
@Test(expected = NullPointerException.class)
public void testNullContext() {
gh = new MockGenericHandler(null);
}
@Test
@SuppressWarnings("PMD.JUnitTestsShouldIncludeAssert")
public void testNoClaim() {
gh = new MockGenericHandler();
gh = new MockGenericHandler("testNoClaim");
gh = new MockGenericHandler("testNoClaim", false);
// An exception will be thrown if something went wrong
}
@Test(expected = IllegalArgumentException.class)
public void testClaim() {
String context = "testClaim";
gh = new MockGenericHandler(context, true);
assertTrue("Context should have been claimed", store.contains(context));
gh = new MockGenericHandler(context, true); // Should throw IllegalArgumentException
}
@Test
public void testGetContext() {
String context = "testGetContext";
gh = new MockGenericHandler(context);
assertEquals("Context was wrong", context, gh.getContext());
}
@After
public void tearDown() {
if (gh != null) {
gh.releaseContext();
}
}
private class MockGenericHandler extends GenericHandler {
MockGenericHandler() {
super();
}
MockGenericHandler(String context) {
super(store, context);
}
MockGenericHandler(String context, boolean doClaim) {
super(store, context, doClaim);
}
@Override
public void handle(String target,
Request baseRequest,
HttpServletRequest request,
HttpServletResponse response) throws IOException, ServletException {
// Do nothing, this class is only used for testing automatic claims
}
```
<Overlap Ratio: 0.9765625>

---

--- 168 --
Question ID: d54f79f395ac7a5835a9bd5c91ec71f13d0fa86d_0
Original Code:
```
public class TransactionTest {
    private Amount amount;
    private TransactionDate transactionDate;
    private DueDate dueDate;
    private Transaction transaction;
    private long validId;

    @BeforeEach
    public void setUp() {
        amount = new Amount(VALID_AMOUNT_ONE);
        transactionDate = new TransactionDate(VALID_TRANSACTION_DATE_ONE);
        dueDate = new DueDate(VALID_DUE_DATE_ONE);
        validId = VALID_ID;

        Collection<TransactionField> fields = List.of(
                amount,
                transactionDate,
                dueDate
        );
        transaction = new Transaction(
                fields,
                validId
        );
    }

    @Test
    public void constructor_null_throwsNullArgumentException() {
        assertThrows(NullPointerException.class, () -> new Transaction((Collection<TransactionField>) null, VALID_ID));
    }

    @Test
    public void constructor_missingRequiredField_throwsIllegalArgumentException() {
        // Missing Transaction Date Field
        List<TransactionField> incompleteArgumentsOne = List.of(
                new Amount(VALID_AMOUNT_ONE)
        );
        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsOne, VALID_ID));

        // Missing Amount Field
        List<TransactionField> incompleteArgumentsTwo = List.of(
                    new TransactionDate(VALID_TRANSACTION_DATE_ONE)
        );
        assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsTwo, VALID_ID));
    }

    @Test
    public void isValidTest() {
        Transaction validTransaction = TRANSACTION_ONE;
        Transaction invalidTransaction = INVALID_TRANSACTION;

        // valid transaction -> returns True
        assertTrue(validTransaction.isValid());

        // invalid transaction (due date < transaction date) -> returns false
        assertFalse(invalidTransaction.isValid());
    }

    @Test
    public void removeFieldTest() {
        DueDate toRemove = dueDate;
        Collection<TransactionField> fieldsOne = List.of(
                amount,
                transactionDate,
                dueDate
        );

        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);

        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);
        fieldCopy.remove(toRemove);
        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);

        assertEquals(expectedTransaction, transactionOne.removeField(DueDate.PREFIX));
    }

    @Test
    public void addFieldTest() {
        DueDate toAdd = dueDate;

        Collection<TransactionField> fieldsOne = List.of(
                amount,
                transactionDate,
                dueDate
        );

        Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);

        Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);
        fieldCopy.add(toAdd);
        Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID_ID);

        assertEquals(expectedTransaction, transactionOne.addField(toAdd));
    }

    @Test
    public void setStatusToTest() {
        Status statusPaid = new Status("true");

        Collection<TransactionField> fields = new ArrayList<>(transaction.getFields());
        fields.add(statusPaid);

        Transaction expectedTransaction = new Transaction(transaction.getTransactionId(),
                fields,
                validId
        );

        assertEquals(expectedTransaction, transaction.setStatusTo(Command.class, new StatusFactoryAlwaysReturnsTrue()));
    }

    @Test
    public void equals() {
        // same values -> returns true
        Transaction transactionCopy = new Transaction(TRANSACTION_ONE);
        assertEquals(TRANSACTION_ONE, transactionCopy);

        // same object -> returns true
        assertEquals(TRANSACTION_ONE, TRANSACTION_ONE);

        // null -> returns false
        assertNotEquals(null, TRANSACTION_ONE);

        // different type -> returns false
        assertNotEquals("TRANSACTION_ONE", TRANSACTION_ONE);

        // different Transaction -> returns false
        assertNotEquals(TRANSACTION_ONE, TRANSACTION_TWO);

        // some fields are missing -> return false
        assertNotEquals(TRANSACTION_ONE, TRANSACTION_ONE_INCOMPLETE);
    }

    private class StatusFactoryAlwaysReturnsTrue implements StatusFactoryInterface {

        @Override
        public Status getStatus(Class<? extends Command> command) {
            return new Status("True");
        }
    }
}
```


Overlapping Code:
```

private Amount amount;
private TransactionDate transactionDate;
private DueDate dueDate;
private Transaction transaction;
private long validId;
@BeforeEach
public void setUp() {
amount = new Amount(VALID_AMOUNT_ONE);
transactionDate = new TransactionDate(VALID_TRANSACTION_DATE_ONE);
dueDate = new DueDate(VALID_DUE_DATE_ONE);
validId = VALID_ID;
Collection<TransactionField> fields = List.of(
amount,
transactionDate,
dueDate
);
transaction = new Transaction(
fields,
validId
);
}
@Test
public void constructor_null_throwsNullArgumentException() {
assertThrows(NullPointerException.class, () -> new Transaction((Collection<TransactionField>) null, VALID_ID));
}
@Test
public void constructor_missingRequiredField_throwsIllegalArgumentException() {
// Missing Transaction Date Field
List<TransactionField> incompleteArgumentsOne = List.of(
new Amount(VALID_AMOUNT_ONE)
);
assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsOne, VALID_ID));
// Missing Amount Field
List<TransactionField> incompleteArgumentsTwo = List.of(
new TransactionDate(VALID_TRANSACTION_DATE_ONE)
);
assertThrows(IllegalArgumentException.class, () -> new Transaction(incompleteArgumentsTwo, VALID_ID));
}
@Test
public void isValidTest() {
Transaction validTransaction = TRANSACTION_ONE;
Transaction invalidTransaction = INVALID_TRANSACTION;
// valid transaction -> returns True
assertTrue(validTransaction.isValid());
// invalid transaction (due date < transaction date) -> returns false
assertFalse(invalidTransaction.isValid());
}
@Test
public void removeFieldTest() {
DueDate toRemove = dueDate;
Collection<TransactionField> fieldsOne = List.of(
amount,
transactionDate,
dueDate
);
Collection<TransactionField> fieldCopy = new ArrayList<>(fieldsOne);
Transaction transactionOne = new Transaction(fieldsOne, VALID_ID);
fieldCopy.remove(toRemove);
Transaction expectedTransaction = new Transaction(transactionOne.getTransactionId(), fieldCopy, VALID
```
<Overlap Ratio: 0.9794897448724362>

---

--- 169 --
Question ID: 4fa044fef0f762a3d373af5618f17682dcae776a_0
Original Code:
```
@MeshTestSetting(testSize = TestSize.EMPTY, startServer = false)
public class AdminGUIEndpointTest extends AbstractMeshTest {

	@Before
	public void setupVerticle() throws Exception {
		EndpointRegistry registry = mesh().endpointRegistry();
		registry.register(AdminGUIEndpoint.class);
		registry.register(AdminGUI2Endpoint.class);
	}

	@BeforeClass
	public static void cleanupConfig() {
		new File(AdminGUIEndpoint.CONF_FILE).delete();
		new File(AdminGUI2Endpoint.CONF_FILE).delete();
	}

	@Test
	public void testAdminConfigRendering() throws InterruptedException, ExecutionException, TimeoutException {

		HttpClient client = createHttpClient();
		CompletableFuture<String> future = new CompletableFuture<>();
		HttpClientRequest request = client.request(GET, "/mesh-ui-v1/mesh-ui-config.js", rh -> {
			rh.bodyHandler(bh -> {
				if (rh.statusCode() == 200) {
					future.complete(bh.toString());
				} else {
					future.completeExceptionally(new Exception("Status code wrong {" + rh.statusCode() + "}"));
				}
			});
		});
		request.end();

		String response = future.get(10, TimeUnit.SECONDS);
		// String expectedUrl = "localhost:" + port;
		// assertTrue("The meshConfig.js file did not contain the expected url {" + expectedUrl + "} Response {" + response + "}",
		// response.contains(expectedUrl));
		// System.out.println(response);
		assertTrue("The response string should not contain any html specific characters but it was {" + response + "} ", response.indexOf("<") != 0);

	}

	@Test
	public void testRedirect() throws InterruptedException, ExecutionException {
		HttpClient client = createHttpClient();
		CompletableFuture<String> future = new CompletableFuture<>();
		HttpClientRequest request = client.request(GET, "/", rh -> {
			future.complete(rh.getHeader("Location"));
		});
		request.end();
		assertEquals("/mesh-ui/", future.get());
	}
}
```


Overlapping Code:
```
eshTestSetting(testSize = TestSize.EMPTY, startServer = false)
public class AdminGUIEndpointTest extends AbstractMeshTest {
@Before
public void setupVerticle() throws Exception {
EndpointRegistry registry = mesh().endpointRegistry();
registry.register(AdminGUIEndpoint.class);
registry.register(AdminGUI2Endpoint.class);
}
@BeforeClass
public static void cleanupConfig() {
new File(AdminGUIEndpoint.CONF_FILE).delete();
new File(AdminGUI2Endpoint.CONF_FILE).delete();
}
@Test
public void testAdminConfigRendering() throws InterruptedException, ExecutionException, TimeoutException {
HttpClient client = createHttpClient();
CompletableFuture<String> future = new CompletableFuture<>();
HttpClientRequest request = client.request(GET, "/mesh-ui-v1/mesh-ui-config.js", rh -> {
rh.bodyHandler(bh -> {
if (rh.statusCode() == 200) {
future.complete(bh.toString());
} else {
future.completeExceptionally(new Exception("Status code wrong {" + rh.statusCode() + "}"));
}
});
});
request.end();
String response = future.get(10, TimeUnit.SECONDS);
// String expectedUrl = "localhost:" + port;
// assertTrue("The meshConfig.js file did not contain the expected url {" + expectedUrl + "} Response {" + response + "}",
// response.contains(expectedUrl));
// System.out.println(response);
assertTrue("The response string should not contain any html specific characters but it was {" + response + "} ", response.indexOf("<") != 0);
}
@Test
public void testRedirect() throws InterruptedException, ExecutionException {
HttpClient client = createHttpClient();
CompletableFuture<String> future = new CompletableFuture<>();
HttpClientRequest request = client.request(GET, "/", rh -> {
future.complete(rh.getHeader("Location"));
});
request.end();
assertEquals("/me
```
<Overlap Ratio: 0.9836343115124153>

---

--- 170 --
Question ID: 7c02e8b9a874b62a78d99846c5ab5f8d36c4ad3a_0
Original Code:
```
public class AuthenticationRequestProcessing {

	public AuthenticationResponse processRequest(AuthenticationRequest request) {
		AuthenticationResponse response = new AuthenticationResponse();
		Gson gson = new Gson();
		setAppId(request, response);
		response.header = new OperationHeader();
		response.header.serverData = request.header.serverData;
		response.header.op = request.header.op;
		response.header.upv = request.header.upv;

		FinalChallengeParams fcParams = new FinalChallengeParams();
		fcParams.appID = Constants.APP_ID;
		fcParams.facetID = Constants.FACET_ID;
		fcParams.challenge = request.challenge;
		response.fcParams = Base64.encodeBase64URLSafeString(gson.toJson(
				fcParams).getBytes());
		setAssertions(response);
		return response;
	}

	private void setAssertions(AuthenticationResponse response) {
		AuthenticatorSignAssertion assertion = new AuthenticatorSignAssertion();
		assertion.assertionScheme = "UAFV1TLV";
		// Example from specs doc
		assertion.assertion = "Aj7WAAQ-jgALLgkAQUJDRCNBQkNEDi4FAAABAQEADy4gAHwyJAEX8t1b2wOxbaKOC5ZL7ACqbLo_TtiQfK3DzDsHCi4gAFwCUz-dOuafXKXJLbkUrIzjAU6oDbP8B9iLQRmCf58fEC4AAAkuIABkwI-f3bIe_Uin6IKIFvqLgAOrpk6_nr0oVAK9hIl82A0uBAACAAAABi5AADwDOcBvPslX2bRNy4SvFhAwhEAoBSGUitgMUNChgUSMxss3K3ukekq1paG7Fv1v5mBmDCZVPt2NCTnjUxrjTp4";
		AuthenticatorSignAssertion[] assertions = new AuthenticatorSignAssertion[1];
		assertions[0] = assertion;
		response.assertions = assertions;
	}

	private void setAppId(AuthenticationRequest request,
			AuthenticationResponse response) {
		if (request.header.appID == null && request.header.appID.isEmpty()) {
			response.header.appID = Constants.APP_ID;
		} else {
			setAppID(request, response);
		}
	}

	private void setAppID(AuthenticationRequest request,
			AuthenticationResponse response) {
		// TODO Auto-generated method stub

	}
}
```


Overlapping Code:
```
equestProcessing {
public AuthenticationResponse processRequest(AuthenticationRequest request) {
AuthenticationResponse response = new AuthenticationResponse();
Gson gson = new Gson();
setAppId(request, response);
response.header = new OperationHeader();
response.header.serverData = request.header.serverData;
response.header.op = request.header.op;
response.header.upv = request.header.upv;
FinalChallengeParams fcParams = new FinalChallengeParams();
fcParams.appID = Constants.APP_ID;
fcParams.facetID = Constants.FACET_ID;
fcParams.challenge = request.challenge;
response.fcParams = Base64.encodeBase64URLSafeString(gson.toJson(
fcParams).getBytes());
setAssertions(response);
return response;
}
private void setAssertions(AuthenticationResponse response) {
AuthenticatorSignAssertion assertion = new AuthenticatorSignAssertion();
assertion.assertionScheme = "UAFV1TLV";
// Example from specs docAHwyJAEX8t1b2wOxbaKOC5ZL7ACqbLo_TtiQfK3DzDsHCi4gAFssertion[] assertions = new AuthenticatorSignAssertion[1];
assertions[0] = assertion;
response.assertions = assertions;
}
private void setAppId(AuthenticationRequest request,
AuthenticationResponse response) {
if (request.header.appID == null && request.header.appID.isEmpty()) {
response.header.appID = Constants.APP_ID;
} else {
setAppID(request, response);
}
}
private void setAppID(AuthenticationRequest request,
AuthenticationResponse response) {
// TODO Auto-generated method stub
}
}
```
<Overlap Ratio: 0.8209806157354618>

---

--- 171 --
Question ID: 25ee476c4ae2e1a62d1abeb6d999e51d820bf6c2_0
Original Code:
```
public class MainActivity extends BaseActivity {

    final String TAG = getClass().getSimpleName();
    ProductFileLoader _productFileLoader;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ProductDataService.getInstance(this);
        _productFileLoader = ProductFileLoader.getInstance(this);
        _productFileLoader.loadDataFromExternalFile();

    }

    public void onStartScanner(View v) {
        startActivity(new Intent(this, ScannerActivity.class));
    }
}
```


Overlapping Code:
```
nActivity extends BaseActivity {
final String TAG = getClass().getSimpleName();
ProductFileLoader _productFileLoader;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
ProductDataService.getInstance(this);
_productFileLoader = ProductFileLoader.getInstance(this);
_productFileLoader.loadDataFromExternalFile();
}
public void onStartScanner(View v) {
startActivity(new Intent(this, ScannerActivity.class))
```
<Overlap Ratio: 0.9591439688715954>

---

--- 172 --
Question ID: d18ab24e1f43d1617b7d520a872d3d5a55e1cbfc_0
Original Code:
```
public class AlgoTestRunner {

	protected static final Logger s_log = MR4CLogging.getLogger(AlgoTestRunner.class);

	private AlgoTestSource m_testSrc;
	private MR4CConfig m_bbConf;
	private Map<String,DatasetDiff> m_diffs = new HashMap<String,DatasetDiff>();
	private boolean m_passed=true;

	public static void main(String argv[]) throws Exception {
		AlgoTestRunnerConfig config = new AlgoTestRunnerConfig(true);
		config.setCommandLineArguments(argv);
		config.configure();
		AlgoTestRunner runner = new AlgoTestRunner(config);
		runner.executeStandalone();
	}

	public AlgoTestRunner(AlgoTestRunnerConfig runnerConfig) throws IOException {
		this(
			runnerConfig.getSource(),
			runnerConfig.getMR4CConfig()
		);
	}

	public AlgoTestRunner(AlgoTestSource testSrc) throws IOException {
		this(
			testSrc,
			MR4CConfig.getDefaultInstance()
		);
	}

	public AlgoTestRunner(AlgoTestSource testSrc, MR4CConfig bbConf) throws IOException {
		m_testSrc = testSrc;
		m_bbConf = bbConf;
	}

	public void executeStandalone() throws IOException {
		execute();
		checkResults();
	}

	public void execute() throws IOException {
		ExecutionSource exeSrc = m_testSrc.getExecutionSource();
		AlgoRunner algoRunner = new AlgoRunner(exeSrc, m_bbConf);
		algoRunner.executeStandalone();
	}

	public void checkResults() throws IOException {
		for ( String name : m_testSrc.getOutputDiffNames() ) {
			DiffSource diffSrc = m_testSrc.getOutputDiffSource(name);
			DiffRunner diffRunner = new DiffRunner(diffSrc);
			diffRunner.setMinimalOutput(true);
			diffRunner.execute();
			DatasetDiff diff = diffRunner.getDiff();
			m_diffs.put(name, diff);
			if ( diff.different() ) {
				m_passed = false;
			}
		}
	}

	public boolean isPassed() {
		return m_passed;
	}

	public Map<String,DatasetDiff> getDiffs() {
		return m_diffs;
	}

	public static class AlgoTestRunnerConfig extends MR4CRunnerConfig<AlgoTestSource> {

		public AlgoTestRunnerConfig(boolean dumpToFiles) {
			super(s_log, dumpToFiles);
		}

		protected AlgoTestSource loadSource(URI confFile) throws IOException {
			ConfiguredAlgoTestSource src = new ConfiguredAlgoTestSource(confFile);
			src.loadConfig();
			return src;
		}

	}

}
```


Overlapping Code:
```
er {
protected static final Logger s_log = MR4CLogging.getLogger(AlgoTestRunner.class);
private AlgoTestSource m_testSrc;
private MR4CConfig m_bbConf;
private Map<String,DatasetDiff> m_diffs = new HashMap<String,DatasetDiff>();
private boolean m_passed=true;
public static void main(String argv[]) throws Exception {
AlgoTestRunnerConfig config = new AlgoTestRunnerConfig(true);
config.setCommandLineArguments(argv);
config.configure();
AlgoTestRunner runner = new AlgoTestRunner(config);
runner.executeStandalone();
}
public AlgoTestRunner(AlgoTestRunnerConfig runnerConfig) throws IOException {
this(
runnerConfig.getSource(),
runnerConfig.getMR4CConfig()
);
}
public AlgoTestRunner(AlgoTestSource testSrc) throws IOException {
this(
testSrc,
MR4CConfig.getDefaultInstance()
);
}
public AlgoTestRunner(AlgoTestSource testSrc, MR4CConfig bbConf) throws IOException {
m_testSrc = testSrc;
m_bbConf = bbConf;
}
public void executeStandalone() throws IOException {
execute();
checkResults();
}
public void execute() throws IOException {
ExecutionSource exeSrc = m_testSrc.getExecutionSource();
AlgoRunner algoRunner = new AlgoRunner(exeSrc, m_bbConf);
algoRunner.executeStandalone();
}
public void checkResults() throws IOException {
for ( String name : m_testSrc.getOutputDiffNames() ) {
DiffSource diffSrc = m_testSrc.getOutputDiffSource(name);
DiffRunner diffRunner = new DiffRunner(diffSrc);
diffRunner.setMinimalOutput(true);
diffRunner.execute();
DatasetDiff diff = diffRunner.getDiff();
m_diffs.put(name, diff);
if ( diff.different() ) {
m_passed = false;
}
}
}
public boolean isPassed() {
return m_passed;
}
public Map<String,DatasetDiff> getDiffs() {
return m_diffs;
}
public static class AlgoTestRunnerConfig extends MR4CRunnerConfig<AlgoTestSource> {
public AlgoTestRunnerConfig(boolean dumpToFiles) {
super(s_log, dumpToFiles);
}
protected AlgoTestSource loadSource(URI confFile) throws IOException {
ConfiguredAlgoTestSource src = new ConfiguredAlgoTestSource(confFile);
src.loadConfig();
r
```
<Overlap Ratio: 0.9799216454456415>

---

--- 173 --
Question ID: 63b28142dc308b467da56ec4046d9159414ac09e_0
Original Code:
```
public class AmazonTest {

    @BeforeSuite
    public void setup() {
        WebDriverManager.chromedriver().setup();
    }

    public WebDriver getDriver() {
        SeleniumWaitOptions options = SeleniumWaitOptions.builder()
                .parseAnnotations(true)
                .defaultWaitTime(Duration.ofSeconds(30))
                .packageToBeParsed("io.github.sudharsan_selvaraj")
                .build();
        SeleniumWaitPlugin<ChromeDriver> seleniumWaitPlugin = new SeleniumWaitPlugin<ChromeDriver>(new ChromeDriver(), options);
        return seleniumWaitPlugin.getDriver();
    }

    @Test
    public void runTestWthAutoWait() {
        WebDriver driver = getDriver();
        driver.get("https://www.amazon.in");
        driver.findElement(By.id("twotabsearchtextbox")).sendKeys("oneplus 7");
        driver.findElement(By.id("twotabsearchtextbox")).sendKeys(Keys.ENTER);
        driver.findElement(By.partialLinkText("OnePlus 7 Pro")).click();
        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);
        driver.findElement(By.cssSelector("#add-to-cart-button")).click();
        driver.findElement(By.cssSelector("#attach-view-cart-button-form")).click();
    }

    @Test
    @IgnoreWait
    public void runTestIgnoreWait() {
        WebDriver driver = getDriver();
        driver.get("https://www.amazon.in");

        new WebDriverWait(driver, 10).until(ExpectedConditions.presenceOfElementLocated(By.id("twotabsearchtextbox")));

        driver.findElement(By.id("twotabsearchtextbox")).sendKeys("oneplus 7", Keys.ENTER);

        new WebDriverWait(driver, 10)
                .until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText("OnePlus 7 Pro")));

        driver.findElement(By.partialLinkText("OnePlus 7 Pro")).click();
        driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);

        new WebDriverWait(driver, 10)
                .until(ExpectedConditions.presenceOfElementLocated(By.cssSelector("#add-to-cart-button")));

        driver.findElement(By.cssSelector("#add-to-cart-button")).click();

        new WebDriverWait(driver, 10)
                .until(ExpectedConditions.elementToBeClickable(By.cssSelector("#attach-view-cart-button-form")));

        driver.findElement(By.cssSelector("#attach-view-cart-button-form")).click();
    }
}
```


Overlapping Code:
```

public void setup() {
WebDriverManager.chromedriver().setup();
}
public WebDriver getDriver() {
SeleniumWaitOptions options = SeleniumWaitOptions.builder()
.parseAnnotations(true)
.defaultWaitTime(Duration.ofSeconds(30))
.packageToBeParsed("io.github.sudharsan_selvaraj")
.build();
SeleniumWaitPlugin<ChromeDriver> seleniumWaitPlugin = new SeleniumWaitPlugin<ChromeDriver>(new ChromeDriver(), options);
return seleniumWaitPlugin.getDriver();
}
@Test
public void runTestWthAutoWait() {
WebDriver driver = getDriver();
driver.get("https://www.amazon.in");
driver.findElement(By.id("twotabsearchtextbox")).sendKeys("oneplus 7");
driver.findElement(By.id("twotabsearchtextbox")).sendKeys(Keys.ENTER);
driver.findElement(By.partialLinkText("OnePlus 7 Pro")).click();
driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);
driver.findElement(By.cssSelector("#add-to-cart-button")).click();
driver.findElement(By.cssSelector("#attach-view-cart-button-form")).click();
}
@Test
@IgnoreWait
public void runTestIgnoreWait() {
WebDriver driver = getDriver();
driver.get("https://www.amazon.in");
new WebDriverWait(driver, 10).until(ExpectedConditions.presenceOfElementLocated(By.id("twotabsearchtextbox")));
driver.findElement(By.id("twotabsearchtextbox")).sendKeys("oneplus 7", Keys.ENTER);
new WebDriverWait(driver, 10)
.until(ExpectedConditions.presenceOfElementLocated(By.partialLinkText("OnePlus 7 Pro")));
driver.findElement(By.partialLinkText("OnePlus 7 Pro")).click();
driver.switchTo().window(driver.getWindowHandles().toArray(new String[]{})[1]);
new WebDriverWait(driver, 10)
.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector("#add-to-cart-button")));
driver.findElement(By.cssSelector("#add-to-cart-button")).click();
new WebDriverWait(driver, 10)
.until(ExpectedConditions.elementToBeClickable(By.cssSelector("#attach-view-cart-button-form")));
driver.findElement(By.cssSelector("#attach-view-cart-button-fo
```
<Overlap Ratio: 0.9720837487537388>

---

--- 174 --
Question ID: 300f73cad482defce27b88d7ca89f6802695f210_0
Original Code:
```
@JSON(strict = true)
public class SubscriptionModelImpl
	extends BaseModelImpl<Subscription> implements SubscriptionModel {

	/*
	 * NOTE FOR DEVELOPERS:
	 *
	 * Never modify or reference this class directly. All methods that expect a subscription model instance should use the <code>Subscription</code> interface instead.
	 */
	public static final String TABLE_NAME = "IoTCatalogue_Subscription";

	public static final Object[][] TABLE_COLUMNS = {
		{"uuid_", Types.VARCHAR}, {"subscriptionId", Types.BIGINT},
		{"groupId", Types.BIGINT}, {"companyId", Types.BIGINT},
		{"userId", Types.BIGINT}, {"userName", Types.VARCHAR},
		{"createDate", Types.TIMESTAMP}, {"modifiedDate", Types.TIMESTAMP},
		{"status", Types.INTEGER}, {"statusByUserId", Types.BIGINT},
		{"statusByUserName", Types.VARCHAR}, {"statusDate", Types.TIMESTAMP},
		{"connectionId", Types.VARCHAR}, {"connectionState", Types.VARCHAR},
		{"token", Types.VARCHAR}, {"host", Types.VARCHAR},
		{"componentPagePath", Types.VARCHAR},
		{"validationPagePath", Types.VARCHAR}, {"port", Types.INTEGER},
		{"useSSL", Types.BOOLEAN}
	};

	public static final Map<String, Integer> TABLE_COLUMNS_MAP =
		new HashMap<String, Integer>();

	static {
		TABLE_COLUMNS_MAP.put("uuid_", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("subscriptionId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("groupId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("companyId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("userId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("userName", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("createDate", Types.TIMESTAMP);
		TABLE_COLUMNS_MAP.put("modifiedDate", Types.TIMESTAMP);
		TABLE_COLUMNS_MAP.put("status", Types.INTEGER);
		TABLE_COLUMNS_MAP.put("statusByUserId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("statusByUserName", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("statusDate", Types.TIMESTAMP);
		TABLE_COLUMNS_MAP.put("connectionId", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("connectionState", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("token", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("host", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("componentPagePath", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("validationPagePath", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("port", Types.INTEGER);
		TABLE_COLUMNS_MAP.put("useSSL", Types.BOOLEAN);
	}

	public static final String TABLE_SQL_CREATE =
		"create table IoTCatalogue_Subscription (uuid_ VARCHAR(75) null,subscriptionId LONG not null primary key,groupId LONG,companyId LONG,userId LONG,userName VARCHAR(75) null,createDate DATE null,modifiedDate DATE null,status INTEGER,statusByUserId LONG,statusByUserName VARCHAR(75) null,statusDate DATE null,connectionId VARCHAR(75) null,connectionState VARCHAR(75) null,token VARCHAR(75) null,host VARCHAR(75) null,componentPagePath VARCHAR(75) null,validationPagePath VARCHAR(75) null,port INTEGER,useSSL BOOLEAN)";

	public static final String TABLE_SQL_DROP =
		"drop table IoTCatalogue_Subscription";

	public static final String ORDER_BY_JPQL =
		" ORDER BY subscription.subscriptionId ASC";

	public static final String ORDER_BY_SQL =
		" ORDER BY IoTCatalogue_Subscription.subscriptionId ASC";

	public static final String DATA_SOURCE = "liferayDataSource";

	public static final String SESSION_FACTORY = "liferaySessionFactory";

	public static final String TX_MANAGER = "liferayTransactionManager";

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}
	 */
	@Deprecated
	public static final long COMPANYID_COLUMN_BITMASK = 1L;

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}
	 */
	@Deprecated
	public static final long GROUPID_COLUMN_BITMASK = 2L;

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}
	 */
	@Deprecated
	public static final long SUBSCRIPTIONID_COLUMN_BITMASK = 4L;

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link #getColumnBitmask(String)}
	 */
	@Deprecated
	public static final long UUID_COLUMN_BITMASK = 8L;

	/**
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	public static void setEntityCacheEnabled(boolean entityCacheEnabled) {
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	public static void setFinderCacheEnabled(boolean finderCacheEnabled) {
	}

	/**
	 * Converts the soap model instance into a normal model instance.
	 *
	 * @param soapModel the soap model instance to convert
	 * @return the normal model instance
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	public static Subscription toModel(SubscriptionSoap soapModel) {
		if (soapModel == null) {
			return null;
		}

		Subscription model = new SubscriptionImpl();

		model.setUuid(soapModel.getUuid());
		model.setSubscriptionId(soapModel.getSubscriptionId());
		model.setGroupId(soapModel.getGroupId());
		model.setCompanyId(soapModel.getCompanyId());
		model.setUserId(soapModel.getUserId());
		model.setUserName(soapModel.getUserName());
		model.setCreateDate(soapModel.getCreateDate());
		model.setModifiedDate(soapModel.getModifiedDate());
		model.setStatus(soapModel.getStatus());
		model.setStatusByUserId(soapModel.getStatusByUserId());
		model.setStatusByUserName(soapModel.getStatusByUserName());
		model.setStatusDate(soapModel.getStatusDate());
		model.setConnectionId(soapModel.getConnectionId());
		model.setConnectionState(soapModel.getConnectionState());
		model.setToken(soapModel.getToken());
		model.setHost(soapModel.getHost());
		model.setComponentPagePath(soapModel.getComponentPagePath());
		model.setValidationPagePath(soapModel.getValidationPagePath());
		model.setPort(soapModel.getPort());
		model.setUseSSL(soapModel.isUseSSL());

		return model;
	}

	/**
	 * Converts the soap model instances into normal model instances.
	 *
	 * @param soapModels the soap model instances to convert
	 * @return the normal model instances
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	public static List<Subscription> toModels(SubscriptionSoap[] soapModels) {
		if (soapModels == null) {
			return null;
		}

		List<Subscription> models = new ArrayList<Subscription>(
			soapModels.length);

		for (SubscriptionSoap soapModel : soapModels) {
			models.add(toModel(soapModel));
		}

		return models;
	}

	public SubscriptionModelImpl() {
	}

	@Override
	public long getPrimaryKey() {
		return _subscriptionId;
	}

	@Override
	public void setPrimaryKey(long primaryKey) {
		setSubscriptionId(primaryKey);
	}

	@Override
	public Serializable getPrimaryKeyObj() {
		return _subscriptionId;
	}

	@Override
	public void setPrimaryKeyObj(Serializable primaryKeyObj) {
		setPrimaryKey(((Long)primaryKeyObj).longValue());
	}

	@Override
	public Class<?> getModelClass() {
		return Subscription.class;
	}

	@Override
	public String getModelClassName() {
		return Subscription.class.getName();
	}

	@Override
	public Map<String, Object> getModelAttributes() {
		Map<String, Object> attributes = new HashMap<String, Object>();

		Map<String, Function<Subscription, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		for (Map.Entry<String, Function<Subscription, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<Subscription, Object> attributeGetterFunction =
				entry.getValue();

			attributes.put(
				attributeName,
				attributeGetterFunction.apply((Subscription)this));
		}

		return attributes;
	}

	@Override
	public void setModelAttributes(Map<String, Object> attributes) {
		Map<String, BiConsumer<Subscription, Object>>
			attributeSetterBiConsumers = getAttributeSetterBiConsumers();

		for (Map.Entry<String, Object> entry : attributes.entrySet()) {
			String attributeName = entry.getKey();

			BiConsumer<Subscription, Object> attributeSetterBiConsumer =
				attributeSetterBiConsumers.get(attributeName);

			if (attributeSetterBiConsumer != null) {
				attributeSetterBiConsumer.accept(
					(Subscription)this, entry.getValue());
			}
		}
	}

	public Map<String, Function<Subscription, Object>>
		getAttributeGetterFunctions() {

		return _attributeGetterFunctions;
	}

	public Map<String, BiConsumer<Subscription, Object>>
		getAttributeSetterBiConsumers() {

		return _attributeSetterBiConsumers;
	}

	private static Function<InvocationHandler, Subscription>
		_getProxyProviderFunction() {

		Class<?> proxyClass = ProxyUtil.getProxyClass(
			Subscription.class.getClassLoader(), Subscription.class,
			ModelWrapper.class);

		try {
			Constructor<Subscription> constructor =
				(Constructor<Subscription>)proxyClass.getConstructor(
					InvocationHandler.class);

			return invocationHandler -> {
				try {
					return constructor.newInstance(invocationHandler);
				}
				catch (ReflectiveOperationException
							reflectiveOperationException) {

					throw new InternalError(reflectiveOperationException);
				}
			};
		}
		catch (NoSuchMethodException noSuchMethodException) {
			throw new InternalError(noSuchMethodException);
		}
	}

	private static final Map<String, Function<Subscription, Object>>
		_attributeGetterFunctions;
	private static final Map<String, BiConsumer<Subscription, Object>>
		_attributeSetterBiConsumers;

	static {
		Map<String, Function<Subscription, Object>> attributeGetterFunctions =
			new LinkedHashMap<String, Function<Subscription, Object>>();
		Map<String, BiConsumer<Subscription, ?>> attributeSetterBiConsumers =
			new LinkedHashMap<String, BiConsumer<Subscription, ?>>();

		attributeGetterFunctions.put("uuid", Subscription::getUuid);
		attributeSetterBiConsumers.put(
			"uuid", (BiConsumer<Subscription, String>)Subscription::setUuid);
		attributeGetterFunctions.put(
			"subscriptionId", Subscription::getSubscriptionId);
		attributeSetterBiConsumers.put(
			"subscriptionId",
			(BiConsumer<Subscription, Long>)Subscription::setSubscriptionId);
		attributeGetterFunctions.put("groupId", Subscription::getGroupId);
		attributeSetterBiConsumers.put(
			"groupId",
			(BiConsumer<Subscription, Long>)Subscription::setGroupId);
		attributeGetterFunctions.put("companyId", Subscription::getCompanyId);
		attributeSetterBiConsumers.put(
			"companyId",
			(BiConsumer<Subscription, Long>)Subscription::setCompanyId);
		attributeGetterFunctions.put("userId", Subscription::getUserId);
		attributeSetterBiConsumers.put(
			"userId", (BiConsumer<Subscription, Long>)Subscription::setUserId);
		attributeGetterFunctions.put("userName", Subscription::getUserName);
		attributeSetterBiConsumers.put(
			"userName",
			(BiConsumer<Subscription, String>)Subscription::setUserName);
		attributeGetterFunctions.put("createDate", Subscription::getCreateDate);
		attributeSetterBiConsumers.put(
			"createDate",
			(BiConsumer<Subscription, Date>)Subscription::setCreateDate);
		attributeGetterFunctions.put(
			"modifiedDate", Subscription::getModifiedDate);
		attributeSetterBiConsumers.put(
			"modifiedDate",
			(BiConsumer<Subscription, Date>)Subscription::setModifiedDate);
		attributeGetterFunctions.put("status", Subscription::getStatus);
		attributeSetterBiConsumers.put(
			"status",
			(BiConsumer<Subscription, Integer>)Subscription::setStatus);
		attributeGetterFunctions.put(
			"statusByUserId", Subscription::getStatusByUserId);
		attributeSetterBiConsumers.put(
			"statusByUserId",
			(BiConsumer<Subscription, Long>)Subscription::setStatusByUserId);
		attributeGetterFunctions.put(
			"statusByUserName", Subscription::getStatusByUserName);
		attributeSetterBiConsumers.put(
			"statusByUserName",
			(BiConsumer<Subscription, String>)
				Subscription::setStatusByUserName);
		attributeGetterFunctions.put("statusDate", Subscription::getStatusDate);
		attributeSetterBiConsumers.put(
			"statusDate",
			(BiConsumer<Subscription, Date>)Subscription::setStatusDate);
		attributeGetterFunctions.put(
			"connectionId", Subscription::getConnectionId);
		attributeSetterBiConsumers.put(
			"connectionId",
			(BiConsumer<Subscription, String>)Subscription::setConnectionId);
		attributeGetterFunctions.put(
			"connectionState", Subscription::getConnectionState);
		attributeSetterBiConsumers.put(
			"connectionState",
			(BiConsumer<Subscription, String>)Subscription::setConnectionState);
		attributeGetterFunctions.put("token", Subscription::getToken);
		attributeSetterBiConsumers.put(
			"token", (BiConsumer<Subscription, String>)Subscription::setToken);
		attributeGetterFunctions.put("host", Subscription::getHost);
		attributeSetterBiConsumers.put(
			"host", (BiConsumer<Subscription, String>)Subscription::setHost);
		attributeGetterFunctions.put(
			"componentPagePath", Subscription::getComponentPagePath);
		attributeSetterBiConsumers.put(
			"componentPagePath",
			(BiConsumer<Subscription, String>)
				Subscription::setComponentPagePath);
		attributeGetterFunctions.put(
			"validationPagePath", Subscription::getValidationPagePath);
		attributeSetterBiConsumers.put(
			"validationPagePath",
			(BiConsumer<Subscription, String>)
				Subscription::setValidationPagePath);
		attributeGetterFunctions.put("port", Subscription::getPort);
		attributeSetterBiConsumers.put(
			"port", (BiConsumer<Subscription, Integer>)Subscription::setPort);
		attributeGetterFunctions.put("useSSL", Subscription::getUseSSL);
		attributeSetterBiConsumers.put(
			"useSSL",
			(BiConsumer<Subscription, Boolean>)Subscription::setUseSSL);

		_attributeGetterFunctions = Collections.unmodifiableMap(
			attributeGetterFunctions);
		_attributeSetterBiConsumers = Collections.unmodifiableMap(
			(Map)attributeSetterBiConsumers);
	}

	@JSON
	@Override
	public String getUuid() {
		if (_uuid == null) {
			return "";
		}
		else {
			return _uuid;
		}
	}

	@Override
	public void setUuid(String uuid) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_uuid = uuid;
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link
	 *             #getColumnOriginalValue(String)}
	 */
	@Deprecated
	public String getOriginalUuid() {
		return getColumnOriginalValue("uuid_");
	}

	@JSON
	@Override
	public long getSubscriptionId() {
		return _subscriptionId;
	}

	@Override
	public void setSubscriptionId(long subscriptionId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_subscriptionId = subscriptionId;
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link
	 *             #getColumnOriginalValue(String)}
	 */
	@Deprecated
	public long getOriginalSubscriptionId() {
		return GetterUtil.getLong(
			this.<Long>getColumnOriginalValue("subscriptionId"));
	}

	@JSON
	@Override
	public long getGroupId() {
		return _groupId;
	}

	@Override
	public void setGroupId(long groupId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_groupId = groupId;
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link
	 *             #getColumnOriginalValue(String)}
	 */
	@Deprecated
	public long getOriginalGroupId() {
		return GetterUtil.getLong(this.<Long>getColumnOriginalValue("groupId"));
	}

	@JSON
	@Override
	public long getCompanyId() {
		return _companyId;
	}

	@Override
	public void setCompanyId(long companyId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_companyId = companyId;
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), replaced by {@link
	 *             #getColumnOriginalValue(String)}
	 */
	@Deprecated
	public long getOriginalCompanyId() {
		return GetterUtil.getLong(
			this.<Long>getColumnOriginalValue("companyId"));
	}

	@JSON
	@Override
	public long getUserId() {
		return _userId;
	}

	@Override
	public void setUserId(long userId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_userId = userId;
	}

	@Override
	public String getUserUuid() {
		try {
			User user = UserLocalServiceUtil.getUserById(getUserId());

			return user.getUuid();
		}
		catch (PortalException portalException) {
			return "";
		}
	}

	@Override
	public void setUserUuid(String userUuid) {
	}

	@JSON
	@Override
	public String getUserName() {
		if (_userName == null) {
			return "";
		}
		else {
			return _userName;
		}
	}

	@Override
	public void setUserName(String userName) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_userName = userName;
	}

	@JSON
	@Override
	public Date getCreateDate() {
		return _createDate;
	}

	@Override
	public void setCreateDate(Date createDate) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_createDate = createDate;
	}

	@JSON
	@Override
	public Date getModifiedDate() {
		return _modifiedDate;
	}

	public boolean hasSetModifiedDate() {
		return _setModifiedDate;
	}

	@Override
	public void setModifiedDate(Date modifiedDate) {
		_setModifiedDate = true;

		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_modifiedDate = modifiedDate;
	}

	@JSON
	@Override
	public int getStatus() {
		return _status;
	}

	@Override
	public void setStatus(int status) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_status = status;
	}

	@JSON
	@Override
	public long getStatusByUserId() {
		return _statusByUserId;
	}

	@Override
	public void setStatusByUserId(long statusByUserId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_statusByUserId = statusByUserId;
	}

	@Override
	public String getStatusByUserUuid() {
		try {
			User user = UserLocalServiceUtil.getUserById(getStatusByUserId());

			return user.getUuid();
		}
		catch (PortalException portalException) {
			return "";
		}
	}

	@Override
	public void setStatusByUserUuid(String statusByUserUuid) {
	}

	@JSON
	@Override
	public String getStatusByUserName() {
		if (_statusByUserName == null) {
			return "";
		}
		else {
			return _statusByUserName;
		}
	}

	@Override
	public void setStatusByUserName(String statusByUserName) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_statusByUserName = statusByUserName;
	}

	@JSON
	@Override
	public Date getStatusDate() {
		return _statusDate;
	}

	@Override
	public void setStatusDate(Date statusDate) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_statusDate = statusDate;
	}

	@JSON
	@Override
	public String getConnectionId() {
		if (_connectionId == null) {
			return "";
		}
		else {
			return _connectionId;
		}
	}

	@Override
	public void setConnectionId(String connectionId) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_connectionId = connectionId;
	}

	@JSON
	@Override
	public String getConnectionState() {
		if (_connectionState == null) {
			return "";
		}
		else {
			return _connectionState;
		}
	}

	@Override
	public void setConnectionState(String connectionState) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_connectionState = connectionState;
	}

	@JSON
	@Override
	public String getToken() {
		if (_token == null) {
			return "";
		}
		else {
			return _token;
		}
	}

	@Override
	public void setToken(String token) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_token = token;
	}

	@JSON
	@Override
	public String getHost() {
		if (_host == null) {
			return "";
		}
		else {
			return _host;
		}
	}

	@Override
	public void setHost(String host) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_host = host;
	}

	@JSON
	@Override
	public String getComponentPagePath() {
		if (_componentPagePath == null) {
			return "";
		}
		else {
			return _componentPagePath;
		}
	}

	@Override
	public void setComponentPagePath(String componentPagePath) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_componentPagePath = componentPagePath;
	}

	@JSON
	@Override
	public String getValidationPagePath() {
		if (_validationPagePath == null) {
			return "";
		}
		else {
			return _validationPagePath;
		}
	}

	@Override
	public void setValidationPagePath(String validationPagePath) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_validationPagePath = validationPagePath;
	}

	@JSON
	@Override
	public Integer getPort() {
		return _port;
	}

	@Override
	public void setPort(Integer port) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_port = port;
	}

	@JSON
	@Override
	public boolean getUseSSL() {
		return _useSSL;
	}

	@JSON
	@Override
	public boolean isUseSSL() {
		return _useSSL;
	}

	@Override
	public void setUseSSL(boolean useSSL) {
		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		_useSSL = useSSL;
	}

	@Override
	public StagedModelType getStagedModelType() {
		return new StagedModelType(
			PortalUtil.getClassNameId(Subscription.class.getName()));
	}

	@Override
	public boolean isApproved() {
		if (getStatus() == WorkflowConstants.STATUS_APPROVED) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isDenied() {
		if (getStatus() == WorkflowConstants.STATUS_DENIED) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isDraft() {
		if (getStatus() == WorkflowConstants.STATUS_DRAFT) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isExpired() {
		if (getStatus() == WorkflowConstants.STATUS_EXPIRED) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isInactive() {
		if (getStatus() == WorkflowConstants.STATUS_INACTIVE) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isIncomplete() {
		if (getStatus() == WorkflowConstants.STATUS_INCOMPLETE) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isPending() {
		if (getStatus() == WorkflowConstants.STATUS_PENDING) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public boolean isScheduled() {
		if (getStatus() == WorkflowConstants.STATUS_SCHEDULED) {
			return true;
		}
		else {
			return false;
		}
	}

	public long getColumnBitmask() {
		if (_columnBitmask > 0) {
			return _columnBitmask;
		}

		if ((_columnOriginalValues == null) ||
			(_columnOriginalValues == Collections.EMPTY_MAP)) {

			return 0;
		}

		for (Map.Entry<String, Object> entry :
				_columnOriginalValues.entrySet()) {

			if (entry.getValue() != getColumnValue(entry.getKey())) {
				_columnBitmask |= _columnBitmasks.get(entry.getKey());
			}
		}

		return _columnBitmask;
	}

	@Override
	public ExpandoBridge getExpandoBridge() {
		return ExpandoBridgeFactoryUtil.getExpandoBridge(
			getCompanyId(), Subscription.class.getName(), getPrimaryKey());
	}

	@Override
	public void setExpandoBridgeAttributes(ServiceContext serviceContext) {
		ExpandoBridge expandoBridge = getExpandoBridge();

		expandoBridge.setAttributes(serviceContext);
	}

	@Override
	public Subscription toEscapedModel() {
		if (_escapedModel == null) {
			Function<InvocationHandler, Subscription>
				escapedModelProxyProviderFunction =
					EscapedModelProxyProviderFunctionHolder.
						_escapedModelProxyProviderFunction;

			_escapedModel = escapedModelProxyProviderFunction.apply(
				new AutoEscapeBeanHandler(this));
		}

		return _escapedModel;
	}

	@Override
	public Object clone() {
		SubscriptionImpl subscriptionImpl = new SubscriptionImpl();

		subscriptionImpl.setUuid(getUuid());
		subscriptionImpl.setSubscriptionId(getSubscriptionId());
		subscriptionImpl.setGroupId(getGroupId());
		subscriptionImpl.setCompanyId(getCompanyId());
		subscriptionImpl.setUserId(getUserId());
		subscriptionImpl.setUserName(getUserName());
		subscriptionImpl.setCreateDate(getCreateDate());
		subscriptionImpl.setModifiedDate(getModifiedDate());
		subscriptionImpl.setStatus(getStatus());
		subscriptionImpl.setStatusByUserId(getStatusByUserId());
		subscriptionImpl.setStatusByUserName(getStatusByUserName());
		subscriptionImpl.setStatusDate(getStatusDate());
		subscriptionImpl.setConnectionId(getConnectionId());
		subscriptionImpl.setConnectionState(getConnectionState());
		subscriptionImpl.setToken(getToken());
		subscriptionImpl.setHost(getHost());
		subscriptionImpl.setComponentPagePath(getComponentPagePath());
		subscriptionImpl.setValidationPagePath(getValidationPagePath());
		subscriptionImpl.setPort(getPort());
		subscriptionImpl.setUseSSL(isUseSSL());

		subscriptionImpl.resetOriginalValues();

		return subscriptionImpl;
	}

	@Override
	public int compareTo(Subscription subscription) {
		long primaryKey = subscription.getPrimaryKey();

		if (getPrimaryKey() < primaryKey) {
			return -1;
		}
		else if (getPrimaryKey() > primaryKey) {
			return 1;
		}
		else {
			return 0;
		}
	}

	@Override
	public boolean equals(Object object) {
		if (this == object) {
			return true;
		}

		if (!(object instanceof Subscription)) {
			return false;
		}

		Subscription subscription = (Subscription)object;

		long primaryKey = subscription.getPrimaryKey();

		if (getPrimaryKey() == primaryKey) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return (int)getPrimaryKey();
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	@Override
	public boolean isEntityCacheEnabled() {
		return true;
	}

	/**
	 * @deprecated As of Athanasius (7.3.x), with no direct replacement
	 */
	@Deprecated
	@Override
	public boolean isFinderCacheEnabled() {
		return true;
	}

	@Override
	public void resetOriginalValues() {
		_columnOriginalValues = Collections.emptyMap();

		_setModifiedDate = false;

		_columnBitmask = 0;
	}

	@Override
	public CacheModel<Subscription> toCacheModel() {
		SubscriptionCacheModel subscriptionCacheModel =
			new SubscriptionCacheModel();

		subscriptionCacheModel.uuid = getUuid();

		String uuid = subscriptionCacheModel.uuid;

		if ((uuid != null) && (uuid.length() == 0)) {
			subscriptionCacheModel.uuid = null;
		}

		subscriptionCacheModel.subscriptionId = getSubscriptionId();

		subscriptionCacheModel.groupId = getGroupId();

		subscriptionCacheModel.companyId = getCompanyId();

		subscriptionCacheModel.userId = getUserId();

		subscriptionCacheModel.userName = getUserName();

		String userName = subscriptionCacheModel.userName;

		if ((userName != null) && (userName.length() == 0)) {
			subscriptionCacheModel.userName = null;
		}

		Date createDate = getCreateDate();

		if (createDate != null) {
			subscriptionCacheModel.createDate = createDate.getTime();
		}
		else {
			subscriptionCacheModel.createDate = Long.MIN_VALUE;
		}

		Date modifiedDate = getModifiedDate();

		if (modifiedDate != null) {
			subscriptionCacheModel.modifiedDate = modifiedDate.getTime();
		}
		else {
			subscriptionCacheModel.modifiedDate = Long.MIN_VALUE;
		}

		subscriptionCacheModel.status = getStatus();

		subscriptionCacheModel.statusByUserId = getStatusByUserId();

		subscriptionCacheModel.statusByUserName = getStatusByUserName();

		String statusByUserName = subscriptionCacheModel.statusByUserName;

		if ((statusByUserName != null) && (statusByUserName.length() == 0)) {
			subscriptionCacheModel.statusByUserName = null;
		}

		Date statusDate = getStatusDate();

		if (statusDate != null) {
			subscriptionCacheModel.statusDate = statusDate.getTime();
		}
		else {
			subscriptionCacheModel.statusDate = Long.MIN_VALUE;
		}

		subscriptionCacheModel.connectionId = getConnectionId();

		String connectionId = subscriptionCacheModel.connectionId;

		if ((connectionId != null) && (connectionId.length() == 0)) {
			subscriptionCacheModel.connectionId = null;
		}

		subscriptionCacheModel.connectionState = getConnectionState();

		String connectionState = subscriptionCacheModel.connectionState;

		if ((connectionState != null) && (connectionState.length() == 0)) {
			subscriptionCacheModel.connectionState = null;
		}

		subscriptionCacheModel.token = getToken();

		String token = subscriptionCacheModel.token;

		if ((token != null) && (token.length() == 0)) {
			subscriptionCacheModel.token = null;
		}

		subscriptionCacheModel.host = getHost();

		String host = subscriptionCacheModel.host;

		if ((host != null) && (host.length() == 0)) {
			subscriptionCacheModel.host = null;
		}

		subscriptionCacheModel.componentPagePath = getComponentPagePath();

		String componentPagePath = subscriptionCacheModel.componentPagePath;

		if ((componentPagePath != null) && (componentPagePath.length() == 0)) {
			subscriptionCacheModel.componentPagePath = null;
		}

		subscriptionCacheModel.validationPagePath = getValidationPagePath();

		String validationPagePath = subscriptionCacheModel.validationPagePath;

		if ((validationPagePath != null) &&
			(validationPagePath.length() == 0)) {

			subscriptionCacheModel.validationPagePath = null;
		}

		Integer port = getPort();

		if (port != null) {
			subscriptionCacheModel.port = port;
		}

		subscriptionCacheModel.useSSL = isUseSSL();

		return subscriptionCacheModel;
	}

	@Override
	public String toString() {
		Map<String, Function<Subscription, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		StringBundler sb = new StringBundler(
			(4 * attributeGetterFunctions.size()) + 2);

		sb.append("{");

		for (Map.Entry<String, Function<Subscription, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<Subscription, Object> attributeGetterFunction =
				entry.getValue();

			sb.append(attributeName);
			sb.append("=");
			sb.append(attributeGetterFunction.apply((Subscription)this));
			sb.append(", ");
		}

		if (sb.index() > 1) {
			sb.setIndex(sb.index() - 1);
		}

		sb.append("}");

		return sb.toString();
	}

	@Override
	public String toXmlString() {
		Map<String, Function<Subscription, Object>> attributeGetterFunctions =
			getAttributeGetterFunctions();

		StringBundler sb = new StringBundler(
			(5 * attributeGetterFunctions.size()) + 4);

		sb.append("<model><model-name>");
		sb.append(getModelClassName());
		sb.append("</model-name>");

		for (Map.Entry<String, Function<Subscription, Object>> entry :
				attributeGetterFunctions.entrySet()) {

			String attributeName = entry.getKey();
			Function<Subscription, Object> attributeGetterFunction =
				entry.getValue();

			sb.append("<column><column-name>");
			sb.append(attributeName);
			sb.append("</column-name><column-value><![CDATA[");
			sb.append(attributeGetterFunction.apply((Subscription)this));
			sb.append("]]></column-value></column>");
		}

		sb.append("</model>");

		return sb.toString();
	}

	private static class EscapedModelProxyProviderFunctionHolder {

		private static final Function<InvocationHandler, Subscription>
			_escapedModelProxyProviderFunction = _getProxyProviderFunction();

	}

	private String _uuid;
	private long _subscriptionId;
	private long _groupId;
	private long _companyId;
	private long _userId;
	private String _userName;
	private Date _createDate;
	private Date _modifiedDate;
	private boolean _setModifiedDate;
	private int _status;
	private long _statusByUserId;
	private String _statusByUserName;
	private Date _statusDate;
	private String _connectionId;
	private String _connectionState;
	private String _token;
	private String _host;
	private String _componentPagePath;
	private String _validationPagePath;
	private Integer _port;
	private boolean _useSSL;

	public <T> T getColumnValue(String columnName) {
		columnName = _attributeNames.getOrDefault(columnName, columnName);

		Function<Subscription, Object> function = _attributeGetterFunctions.get(
			columnName);

		if (function == null) {
			throw new IllegalArgumentException(
				"No attribute getter function found for " + columnName);
		}

		return (T)function.apply((Subscription)this);
	}

	public <T> T getColumnOriginalValue(String columnName) {
		if (_columnOriginalValues == null) {
			return null;
		}

		if (_columnOriginalValues == Collections.EMPTY_MAP) {
			_setColumnOriginalValues();
		}

		return (T)_columnOriginalValues.get(columnName);
	}

	private void _setColumnOriginalValues() {
		_columnOriginalValues = new HashMap<String, Object>();

		_columnOriginalValues.put("uuid_", _uuid);
		_columnOriginalValues.put("subscriptionId", _subscriptionId);
		_columnOriginalValues.put("groupId", _groupId);
		_columnOriginalValues.put("companyId", _companyId);
		_columnOriginalValues.put("userId", _userId);
		_columnOriginalValues.put("userName", _userName);
		_columnOriginalValues.put("createDate", _createDate);
		_columnOriginalValues.put("modifiedDate", _modifiedDate);
		_columnOriginalValues.put("status", _status);
		_columnOriginalValues.put("statusByUserId", _statusByUserId);
		_columnOriginalValues.put("statusByUserName", _statusByUserName);
		_columnOriginalValues.put("statusDate", _statusDate);
		_columnOriginalValues.put("connectionId", _connectionId);
		_columnOriginalValues.put("connectionState", _connectionState);
		_columnOriginalValues.put("token", _token);
		_columnOriginalValues.put("host", _host);
		_columnOriginalValues.put("componentPagePath", _componentPagePath);
		_columnOriginalValues.put("validationPagePath", _validationPagePath);
		_columnOriginalValues.put("port", _port);
		_columnOriginalValues.put("useSSL", _useSSL);
	}

	private static final Map<String, String> _attributeNames;

	static {
		Map<String, String> attributeNames = new HashMap<>();

		attributeNames.put("uuid_", "uuid");

		_attributeNames = Collections.unmodifiableMap(attributeNames);
	}

	private transient Map<String, Object> _columnOriginalValues;

	public static long getColumnBitmask(String columnName) {
		return _columnBitmasks.get(columnName);
	}

	private static final Map<String, Long> _columnBitmasks;

	static {
		Map<String, Long> columnBitmasks = new HashMap<>();

		columnBitmasks.put("uuid_", 1L);

		columnBitmasks.put("subscriptionId", 2L);

		columnBitmasks.put("groupId", 4L);

		columnBitmasks.put("companyId", 8L);

		columnBitmasks.put("userId", 16L);

		columnBitmasks.put("userName", 32L);

		columnBitmasks.put("createDate", 64L);

		columnBitmasks.put("modifiedDate", 128L);

		columnBitmasks.put("status", 256L);

		columnBitmasks.put("statusByUserId", 512L);

		columnBitmasks.put("statusByUserName", 1024L);

		columnBitmasks.put("statusDate", 2048L);

		columnBitmasks.put("connectionId", 4096L);

		columnBitmasks.put("connectionState", 8192L);

		columnBitmasks.put("token", 16384L);

		columnBitmasks.put("host", 32768L);

		columnBitmasks.put("componentPagePath", 65536L);

		columnBitmasks.put("validationPagePath", 131072L);

		columnBitmasks.put("port", 262144L);

		columnBitmasks.put("useSSL", 524288L);

		_columnBitmasks = Collections.unmodifiableMap(columnBitmasks);
	}

	private long _columnBitmask;
	private Subscription _escapedModel;

}
```


Overlapping Code:
```
ic class SubscriptionModelImpl
extends BaseModelImpl<Subscription> implements SubscriptionModel {
/*
* NOTE FOR DEVELOPERS:
*
* Never modify or reference this class directly. All methods that expect a subscription model instance should use the <code>Subscription</code> interface instead.
*/
public static final String TABLE_NAME = "IoTCatalogue_Subscription";
public static final Object[][] TABLE_COLUMNS = {
{"uuid_", Types.VARCHAR}, {"subscriptionId", Types.BIGINT},
{"groupId", Types.BIGINT}, {"companyId", Types.BIGINT},
{"userId", Types.BIGINT}, {"userName", Types.VARCHAR},
{"createDate", Types.TIMESTAMP}, {"modifiedDate", Types.TIMESTAMP},
{"status", Types.INTEGER}, {"statusByUserId", Types.BIGINT},
{"statusByUserName", Types.VARCHAR}, {"statusDate", Types.TIMESTAMP},
{"connectionId", Types.VARCHAR}, {"connectionState", Types.VARCHAR},
{"token", Types.VARCHAR}, {"host", Types.VARCHAR},
{"componentPagePath", Types.VARCHAR},
{"validationPagePath", Types.VARCHAR}, {"port", Types.INTEGER},
{"useSSL", Types.BOOLEAN}
};
public static final Map<String, Integer> TABLE_COLUMNS_MAP =
new HashMap<String, Integer>();
static {
TABLE_COLUMNS_MAP.put("uuid_", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("subscriptionId", Types.BIGINT);
TABLE_COLUMNS_MAP.put("groupId", Types.BIGINT);
TABLE_COLUMNS_MAP.put("companyId", Types.BIGINT);
TABLE_COLUMNS_MAP.put("userId", Types.BIGINT);
TABLE_COLUMNS_MAP.put("userName", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("createDate", Types.TIMESTAMP);
TABLE_COLUMNS_MAP.put("modifiedDate", Types.TIMESTAMP);
TABLE_COLUMNS_MAP.put("status", Types.INTEGER);
TABLE_COLUMNS_MAP.put("statusByUserId", Types.BIGINT);
TABLE_COLUMNS_MAP.put("statusByUserName", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("statusDate", Types.TIMESTAMP);
TABLE_COLUMNS_MAP.put("connectionId", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("connectionState", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("token", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("host", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("componentPagePath", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("validationPagePath", Types.VARCHAR);
TABLE_COLUMNS_MAP.put("port", Types.INTEGER);
TABLE_COLUMNS_MAP.put("useSSL", Types.BOOLEAN);
}
public static final String TABLE_SQL_CREATE =
"create table IoTCatalogue_Subscription (uuid_ VARCHAR(75) null,subscriptionId LONG not null primary key,groupId LONG,companyId LONG,userId LONG,userName VARCHAR(75
```
<Overlap Ratio: 0.9892116182572614>

---

--- 175 --
Question ID: 4cfefbd5de1e08a28d1a68f0a47c019b22ef9ab3_0
Original Code:
```
public class Physics {

    public static double momentOfInertia(Rigidbody rigidbody){
        Vector2 c = rigidbody.collider.getCentroid();
        double totArea = rigidbody.collider.getArea();
        Vector2 vertices[] = rigidbody.gameObject.collider.getPolygon().getVertices();
        Matrix_2x2 m = rigidbody.collider.getTransform().getMatrix();

        double iSum = 0;
        double massDiameterSum = 0;

        for(int i = 0; i < vertices.length; i++){
            Vector2 v1 = vertices[i].multiply(m);
            Vector2 v2 = vertices[(i+1)%vertices.length].multiply(m);

            Vector2 bEdge = v2.difference(c);
            double b = bEdge.magnitude();
            Vector2 nh = bEdge.leftNormal();
            double hMin = c.dotProduct(nh);
            double hMax = v1.dotProduct(nh);
            double h = Math.abs(hMax - hMin);

            Vector2 na = bEdge.normalize();
            double aMin = c.dotProduct(na);
            double aMax = v1.dotProduct(na);
            double a = Math.abs(aMax-aMin);

            double I = (b*b*b*h-b*b*h*a+b*h*a*a+b*h*h*h)/36;

            iSum += I;

            Polygon p = new Polygon(new Vector2[]{v1,v2,c});
            PolygonGeometry pg = PolygonGeometry.getPolygonGeometry(p);
            double triArea = pg.getArea();
            Vector2 cT = pg.getCentroid();

            double d2 = cT.difference(c).nonSqrtMagnitude();

            massDiameterSum += (triArea/totArea)*d2;
        }
        return iSum+massDiameterSum*rigidbody.getMass();
    }

    /**
     * Resolves overlap based on velocity. Such that each collider is moved as much as they contributed to the overlap.
     * For example if v1=5 and v2=15 then p1 is responsible for 25% of the overlap and p2 75%
     *
     * This overlap resolver is very simple. It only resolves overlap on a one collision at a time basis.
     *
     * @param collisionClips    Collision clips
     *
     * @return  Resolved collision. With adjusted contact information.
     */
    public static ArrayList<Collision> resolveOverlap(Collection<CollisionClip> collisionClips){
        ArrayList<Collision> resolvedCollision = new ArrayList<>();

        for(CollisionClip collisionClip : collisionClips){
            if(!collisionClip.isCollision()){
                resolvedCollision.add(new Collision(collisionClip,new ArrayList<>()));
                continue;
            }
            Rigidbody rig1 = collisionClip.getC1().gameObject.rigidbody;
            Rigidbody rig2 = collisionClip.getC2().gameObject.rigidbody;
            Vector2 mtv = collisionClip.getMTV();
            if ((!rig1.isKinematic && !rig2.isKinematic))
                continue;
            if(mtv.magnitude() == 0){
                continue;
            }

            double m;

            double d1 = rig1.getVelocity().dotProduct(mtv);
            double d2 = rig2.getVelocity().dotProduct(mtv);

            //Calculate percentage of overlap contribution.
            if(!rig1.isKinematic || !rig2.isKinematic){
                m = 0.5;
                if(rig1.isKinematic) {
                    m += 0.5;
                } else if(rig2.isKinematic) {
                    m -= 0.5;
                }
            }
            else if(d1*d2 < 0){
                m = Math.abs(d1) / (Math.abs(d1) + Math.abs(d2));
            } else {
                if(Math.abs(d1) > Math.abs(d2)){
                    m = 1.0;
                } else if(Math.abs(d2) > Math.abs(d1)){
                    m = 0.0;
                } else{
                    m = 0.5;
                }
            }

            rig1.gameObject.transform.translate(mtv.multiply(m));
            rig2.gameObject.transform.translate(mtv.inverse().multiply(1 - m));

            resolvedCollision.add(new Collision(collisionClip,collisionClip.getCollisionManifold(m)));
        }

        return resolvedCollision;
    }

    public static void resolveCollisions(Collection<Collision> collisions){
        for (Collision collision : collisions) {
            resolveCollision(collision);
        }
    }

    /**
     * Resolve collision between two rigidbodies.
     * Utilizes an Impulse-based reaction model.
     * Computes reactionary forces for the two bodies involved in the collision.
     * Computes angular and linear forces.
     *
     * @param collision Collision information.
     */
    public static void resolveCollision(Collision collision){
        if(!collision.isCollision())
            return;
        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;
        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;

        Vector2 n = collision.getContactNormal();


        ArrayList<Vector2> collisionManifold = collision.getContactManifold();

        int size = collisionManifold.size();
        Edge e1 = collision.getE1();
        Edge e2 = collision.getE2();
        boolean closeParalell = false;

        if(size == 2){
            Vector2 v1 = collisionManifold.get(0);
            Vector2 v2 = collisionManifold.get(1);
            Vector2 p = n.leftNormal();
            double d1 = v1.dotProduct(p);
            double d2 = v2.dotProduct(p);
            double c1 = rig1.collider.getWorldCentroid().dotProduct(p);
            double c2 = rig2.collider.getWorldCentroid().dotProduct(p);
            double c1d1 = d1-c1;
            double c1d2 = d2-c1;
            double c2d1 = d1-c2;
            double c2d2 = d2-c2;

            boolean diffSides1 = c1d1*c1d2 <= 0;
            boolean diffSides2 = c2d1*c2d2 <= 0;


            if(e1 != null && e2 != null) {
                Vector2 en1 = e1.getR().leftNormal();
                Vector2 en2 = e2.getR().leftNormal();

                //This also uses the fact that in collision clip when two clip points are 0.01 units apart they count as
                // being the same depth
                closeParalell = en1.dotProduct(en2) < -0.9995 && size == 2;


                //This is to fix rocking which arises when using constant forces such as gravity
                if (closeParalell && Math.abs(rig1.getAngularVelocity()) < 0.2 && Math.abs(rig2.getAngularVelocity()) < 0.2
                        && (!rig1.isKinematic || !rig2.isKinematic)) {
                    if (collision.isFlip() && rig1.isKinematic && rig1.isRotatable && diffSides1) {
                        rig1.gameObject.transform.align(en1, en2.inverse());
                        rig1.setAngMomentum(0);
                    } else if (rig2.isKinematic && rig2.isRotatable && diffSides2) {
                        rig2.gameObject.transform.align(en2, en1.inverse());
                        rig2.setAngMomentum(0);
                    } else{
                        closeParalell = false;
                    }


                } else {
                    closeParalell = false;
                }
            }


            double jr1 = getJr(rig1,rig2,v1,n);
            double jr2 = getJr(rig1,rig2,v2,n);
            Vector2 middle = v1.add(v2.difference(v1).multiply(0.5));
            double jrMiddle = getJr(rig1,rig2,middle,n);

            if(rig1.isKinematic) {
                if (diffSides1) {
                    if(!closeParalell) {
                        rig1.addReactionForceAngular(jr1, n.inverse(), v1);
                        rig1.addReactionForceAngular(jr2, n.inverse(), v2);;
                    }
                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);
                } else {
                    if(!closeParalell) {
                        rig1.addReactionForceAngular(jrMiddle, n.inverse(), middle);
                    }
                    rig1.addReactionForceLinear(jrMiddle, n.inverse(), middle);
                }
            }

            if(rig2.isKinematic) {
                if (diffSides2) {
                    if(!closeParalell) {
                        rig2.addReactionForceAngular(jr1, n, v1);
                        rig2.addReactionForceAngular(jr2, n, v2);
                    }
                    rig2.addReactionForceLinear(jrMiddle, n, middle);
                } else {
                    if(!closeParalell) {
                        rig2.addReactionForceAngular(jrMiddle, n, middle);
                    }
                    rig2.addReactionForceLinear(jrMiddle, n, middle);
                }
            }
            collision.setReactionImpulse(jrMiddle);
        }
        else if(size == 1){
            Vector2 cPoint = collisionManifold.get(0);
            double jr = getJr(rig1,rig2, cPoint,n);
            if (rig1.isKinematic) {
                if(!closeParalell) {
                    rig1.addReactionForceAngular(jr, n.inverse(), cPoint);
                }
                rig1.addReactionForceLinear(jr, n.inverse(), cPoint);
            }
            if (rig2.isKinematic) {
                if(!closeParalell) {
                    rig2.addReactionForceAngular(jr, n, cPoint);
                }
                rig2.addReactionForceLinear(jr, n, cPoint);
            }
            collision.setReactionImpulse(jr);
        }

    }

    /**
     * Calculate reaction impulse magnitude.
     *
     * @param rig1      rig1
     * @param rig2      rig2
     * @param cPoint    contact point
     * @param n         contact normal
     * @return          reaction impuluse magnitude.
     */
    private static double getJr(Rigidbody rig1, Rigidbody rig2, Vector2 cPoint, Vector2 n){
        Vector2 r1 = cPoint.difference(rig1.collider.getWorldCentroid()).multiply(1.0);
        Vector2 r2 = cPoint.difference(rig2.collider.getWorldCentroid()).multiply(1.0);
        Vector2 r1n = r1.rightNormal();
        Vector2 r2n = r2.rightNormal();
        double r1Mag = r1.magnitude();
        double r2Mag = r2.magnitude();
        double oneDivI1;
        if(rig1.isKinematic)
            oneDivI1 = 1/rig1.getMomentOfInertia();
        else
            oneDivI1 = 0;
        double oneDivI2;
        if(rig2.isKinematic)
            oneDivI2 = 1/rig2.getMomentOfInertia();
        else
            oneDivI2 = 0;
        double oneDivm1;
        if(rig1.isKinematic)
            oneDivm1 =  1/rig1.getMass();
        else
            oneDivm1 = 0;
        double oneDivm2;
        if(rig2.isKinematic)
            oneDivm2 =  1/rig2.getMass();
        else
            oneDivm2 = 0;

        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));
        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));
        Vector2 vr = vp2.difference(vp1);

        double K = oneDivm2 + oneDivm1 + (r2n.multiply((oneDivI2)*(r2n.dotProduct(n))*r2Mag).add(r1n.multiply(
                (oneDivI1)*(r1n.dotProduct(n))*r1Mag))).dotProduct(n);


        double e = (rig1.elasticity+rig2.elasticity)/2;

        double jr = (-1-e)*(vr.dotProduct(n))/K;
        return jr;
    }

    public static void resolveFrictions(ArrayList<Collision> collisions){
        for (Collision collision:collisions) {
            resolveFriction(collision);
        }
    }

    /**
     * Computes and applies frictional forces induced from collision between two rigid bodies.
     * Impulse-based friction model.
     *
     * @param collision
     */
    public static void resolveFriction(Collision collision){
        if(!collision.isCollision())
            return;
        Rigidbody rig1 = collision.getC1().gameObject.rigidbody;
        Rigidbody rig2 = collision.getC2().gameObject.rigidbody;

        Vector2 n = collision.getContactNormal();
        Vector2 cPoint;
        ArrayList<Vector2> contactManifold = collision.getContactManifold();
        if(contactManifold.size() == 2){
            cPoint = contactManifold.get(0).add(contactManifold.get(1).difference(contactManifold.get(0)).multiply(0.5));
        } else if (contactManifold.size() == 1){
            cPoint = contactManifold.get(0);
        }
        else{
            return;
        }
        Vector2 vp1 = rig1.getVelocity().add(rig1.getCrossRadialVelocity(cPoint));
        Vector2 vp2 = rig2.getVelocity().add(rig2.getCrossRadialVelocity(cPoint));
        Vector2 vr1 = vp2.difference(vp1);
        Vector2 vr2 = vp1.difference(vp2);
        Vector2 fe1 = rig1.getMomentumForce();
        Vector2 fe2 = rig2.getMomentumForce();

        Vector2 t1, t2;
        double vr1nDot = vr1.dotProduct(n);
        double vr2nDot = vr2.dotProduct(n);
        double fe1Dot = fe1.dotProduct(n);
        double fe2Dot = fe2.dotProduct(n);

        if(vr1nDot != 0){
            t1 = vr1.difference(n.multiply(vr1nDot)).normalize();
        }
        else if(fe1Dot != 0){
            t1 = fe1.difference(n.multiply(fe1Dot)).normalize();
        }
        else{
            t1 = new Vector2();
        }

        if(vr2nDot != 0){
            t2 = vr2.difference(n.multiply(vr2nDot));
            t2 = t2.normalize();
        }
        else if(fe2Dot != 0){
            t2 = fe2.difference(n.multiply(fe2Dot)).normalize();
        }
        else{
            t2 = new Vector2();
        }

        double us = (rig1.staticFriction+rig2.staticFriction)/2;
        double ud = (rig1.dynamicFriction+rig2.dynamicFriction)/2;
        //ud = 0;
        //us = 0;
        double jr = collision.getReactionImpulse();
        double js = jr*us;
        double jd = jr*ud;
        double vrt1Dot = vr1.dotProduct(t1);
        double vrt2Dot = vr2.dotProduct(t2);
        double m1 = rig1.getMass();
        double m2 = rig2.getMass();

        double jf1;
        if(vrt1Dot == 0 && vrt1Dot*m1 <= js){
            jf1 = -(m1*vrt1Dot);
        }
        else{
            jf1 = -jd;
        }

        double jf2;
        if(vrt2Dot == 0 && vrt2Dot*m2 <= js){
            jf2 = -(m2*vrt2Dot);
        }
        else{
            jf2 = -jd;
        }

        if(jf2 == 0.0 && jf1 == 0)
            return;


        boolean z1 = false, z2 = false;
        if(contactManifold.size() == 2 ){
            Vector2 rn = n.rightNormal();
            double dot1 = rn.dotProduct(rig1.getVelocity());
            double dot2 = rn.dotProduct(rig2.getVelocity());

            //This is to fix micro sliding when parallel to a surface
            if(rig1.isKinematic && Math.abs(dot1) < 0.2){
                rig1.addReactionForceLinear(dot1*rig1.getMass(), rn.inverse(), rig1.collider
                        .getWorldCentroid());
                z1 = true;
            }
            if(rig2.isKinematic && Math.abs(dot2) < 0.2){
                rig2.addReactionForceLinear(dot2*rig2.getMass(), rn.inverse(), rig2.collider
                        .getWorldCentroid());
                z2 = true;
            }
        }
        if(rig1.isKinematic && !z1) {
            rig1.addReactionForce(jf1, t1.inverse(), rig1.collider.getWorldCentroid());
            rig1.addReactionForce(jf2, t2, rig1.collider.getWorldCentroid());
        }
        if(rig2.isKinematic && !z2) {
            rig2.addReactionForce(jf2, t2.inverse(), rig2.collider.getWorldCentroid());
            rig2.addReactionForce(jf1, t1, rig2.collider.getWorldCentroid());
        }
    }
}
```


Overlapping Code:
```
sics {
public static double momentOfInertia(Rigidbody rigidbody){
Vector2 c = rigidbody.collider.getCentroid();
double totArea = rigidbody.collider.getArea();
Vector2 vertices[] = rigidbody.gameObject.collider.getPolygon().getVertices();
Matrix_2x2 m = rigidbody.collider.getTransform().getMatrix();
double iSum = 0;
double massDiameterSum = 0;
for(int i = 0; i < vertices.length; i++){
Vector2 v1 = vertices[i].multiply(m);
Vector2 v2 = vertices[(i+1)%vertices.length].multiply(m);
Vector2 bEdge = v2.difference(c);
double b = bEdge.magnitude();
Vector2 nh = bEdge.leftNormal();
double hMin = c.dotProduct(nh);
double hMax = v1.dotProduct(nh);
double h = Math.abs(hMax - hMin);
Vector2 na = bEdge.normalize();
double aMin = c.dotProduct(na);
double aMax = v1.dotProduct(na);
double a = Math.abs(aMax-aMin);
double I = (b*b*b*h-b*b*h*a+b*h*a*a+b*h*h*h)/36;
iSum += I;
Polygon p = new Polygon(new Vector2[]{v1,v2,c});
PolygonGeometry pg = PolygonGeometry.getPolygonGeometry(p);
double triArea = pg.getArea();
Vector2 cT = pg.getCentroid();
double d2 = cT.difference(c).nonSqrtMagnitude();
massDiameterSum += (triArea/totArea)*d2;
}
return iSum+massDiameterSum*rigidbody.getMass();
}
/**
* Resolves overlap based on velocity. Such that each collider is moved as much as they contributed to the overlap.
* For example if v1=5 and v2=15 then p1 is responsible for 25% of the overlap and p2 75%
*
* This overlap resolver is very simple. It only resolves overlap on a one collision at a time basis.
*
* @param collisionClips Collision clips
*
* @return Resolved collision. With adjusted contact information.
*/
public static ArrayList<Collision> resolveOverlap(Collection<CollisionClip> collisionClips){
ArrayList<Collision> resolvedCollision = new ArrayList<>();
for(CollisionClip collisionClip : collisionClips){
if(!collisionClip.isCollision()){
resolvedCollision.add(new Collision(collisionClip,new ArrayList<>()));
continue;
}
Rigidbody rig1 = collisi
```
<Overlap Ratio: 0.968222442899702>

---

--- 176 --
Question ID: 0284c04136aa1d742418b895fd9ff3c44cf11fb7_0
Original Code:
```
public class DedicatedStatelessManualByonDeployTest extends AbstractFromXenToByonGSMTest {
	
	@BeforeMethod
    public void beforeTest() {
		super.beforeTestInit();
	}
	
	@BeforeClass
	protected void bootstrap() throws Exception {
		super.bootstrapBeforeClass();
	}
	
	@AfterMethod
    public void afterTest() {
		super.afterTest();
	}
	
	@AfterClass(alwaysRun = true)
	protected void teardownAfterClass() throws Exception {
		super.teardownAfterClass();
	}
	
	@Test(timeOut = DEFAULT_TEST_TIMEOUT)
	public void test() {
	    File archive = DeploymentUtils.getArchive("simpleStatelessPu.jar");
	 // make sure no gscs yet created
	    repetitiveAssertNumberOfGSCsAdded(0, OPERATION_TIMEOUT);
	    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);	    
		final ProcessingUnit pu = super.deploy(
				new ElasticStatelessProcessingUnitDeployment(archive)
	            .memoryCapacityPerContainer(1, MemoryUnit.GIGABYTES)
	            .dedicatedMachineProvisioning(getMachineProvisioningConfig())
	            .scale(new ManualCapacityScaleConfigurer()
	            	  .memoryCapacity(2, MemoryUnit.GIGABYTES)
                      .create())
	    );
	    
	    pu.waitFor(2);
	    
	    //TODO check why expected number of GSA's added was 2 before
	    repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);
	    repetitiveAssertNumberOfGSAsRemoved(0, OPERATION_TIMEOUT);
	    repetitiveAssertNumberOfGSCsAdded(2, OPERATION_TIMEOUT);
	    
	    
	    assertUndeployAndWait(pu);
	}
}
```


Overlapping Code:
```
class DedicatedStatelessManualByonDeployTest extends AbstractFromXenToByonGSMTest {

@BeforeMethod
public void beforeTest() {
super.beforeTestInit();
}

@BeforeClass
protected void bootstrap() throws Exception {
super.bootstrapBeforeClass();
}

@AfterMethod
public void afterTest() {
super.afterTest();
}

@AfterClass(alwaysRun = true)
protected void teardownAfterClass() throws Exception {
super.teardownAfterClass();
}

@Test(timeOut = DEFAULT_TEST_TIMEOUT)
public void test() {
File archive = DeploymentUtils.getArchive("simpleStatelessPu.jar");
// make sure no gscs yet created
repetitiveAssertNumberOfGSCsAdded(0, OPERATION_TIMEOUT);
repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT); 
final ProcessingUnit pu = super.deploy(
new ElasticStatelessProcessingUnitDeployment(archive)
.memoryCapacityPerContainer(1, MemoryUnit.GIGABYTES)
.dedicatedMachineProvisioning(getMachineProvisioningConfig())
.scale(new ManualCapacityScaleConfigurer()
.memoryCapacity(2, MemoryUnit.GIGABYTES)
.create())
);

pu.waitFor(2);

//TODO check why expected number of GSA's added was 2 before
repetitiveAssertNumberOfGSAsAdded(1, OPERATION_TIMEOUT);
repetitiveAssertNumberOfGSAsRemoved(0, OPERATION_TIMEOUT);
repetitiveAssertNumberOfGSCsAdded(2, OPERATION_TIMEO
```
<Overlap Ratio: 0.9659969088098919>

---

--- 177 --
Question ID: 47652e4681f1e3790901ae86009d47ccdf505ce3_0
Original Code:
```
public class OverflowTest {
    @Test
    public void ok() {
        // normal content size
        Json.createReaderFactory(new HashMap<String, Object>() {{
            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
            put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
        }}).createReader(new StringReader("{\"a\":\"b\",\n\"another\":\"value\"}")).readObject();

        // oversized
        final JsonObject object = Json.createReaderFactory(new HashMap<String, Object>() {{
            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
            put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
        }}).createReader(new StringReader("{\"a\":\"b\",\n\"another\":\"value very long\"}")).readObject();
        assertEquals("value very long", object.getString("another"));
    }

    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void ko() {
        Json.createReaderFactory(new HashMap<String, Object>() {{
            put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
            put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
            put(JsonParserFactoryImpl.AUTO_ADJUST_STRING_BUFFER, "false");
        }}).createReader(new StringReader("{\"another\":\"value too long\"}")).readObject();
    }

    @Test
    public void testVeryLargeJson() {
        JsonWriterFactory writerFactory = Json.createWriterFactory(new HashMap<String, Object>() {{
            put(JsonParserFactoryImpl.BUFFER_LENGTH, "256");
        }});

        int itemSize = 50_000;

        StringWriter sw = new StringWriter();
        JsonWriter writer = writerFactory.createWriter(sw);

        JsonArrayBuilder arrayBuilder = Json.createArrayBuilder();
        for (int i = 0; i < itemSize; i++) {
            arrayBuilder.add("0123456789012345-" + i);
        }
        writer.writeArray(arrayBuilder.build());
        writer.close();

        String json = sw.toString();
        System.out.println("Created a JSON of size " + json.length() + " bytes");

        // read it back in
        JsonArray jsonArray = Json.createReader(new StringReader(json)).readArray();
        Assert.assertEquals(itemSize, jsonArray.size());

    }
}
```


Overlapping Code:
```
c class OverflowTest {
@Test
public void ok() {
// normal content size
Json.createReaderFactory(new HashMap<String, Object>() {{
put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
}}).createReader(new StringReader("{\"a\":\"b\",\n\"another\":\"value\"}")).readObject();
// oversized
final JsonObject object = Json.createReaderFactory(new HashMap<String, Object>() {{
put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
}}).createReader(new StringReader("{\"a\":\"b\",\n\"another\":\"value very long\"}")).readObject();
assertEquals("value very long", object.getString("another"));
}
@Test(expected = ArrayIndexOutOfBoundsException.class)
public void ko() {
Json.createReaderFactory(new HashMap<String, Object>() {{
put(JsonParserFactoryImpl.MAX_STRING_LENGTH, "10");
put(JsonParserFactoryImpl.BUFFER_LENGTH, "2");
put(JsonParserFactoryImpl.AUTO_ADJUST_STRING_BUFFER, "false");
}}).createReader(new StringReader("{\"another\":\"value too long\"}")).readObject();
}
@Test
public void testVeryLargeJson() {
JsonWriterFactory writerFactory = Json.createWriterFactory(new HashMap<String, Object>() {{
put(JsonParserFactoryImpl.BUFFER_LENGTH, "256");
}});
int itemSize = 50_000;
StringWriter sw = new StringWriter();
JsonWriter writer = writerFactory.createWriter(sw);
JsonArrayBuilder arrayBuilder = Json.createArrayBuilder();
for (int i = 0; i < itemSize; i++) {
arrayBuilder.add("0123456789012345-" + i);
}
writer.writeArray(arrayBuilder.build());
writer.close();
String json = sw.toString();
System.out.println("Created a JSON of size " + json.length() + " bytes");
// read it back in
JsonArray jsonArray = Json.createReader(new StringReader(json)).readArray();
Assert.assertEquals(itemSize, 
```
<Overlap Ratio: 0.9850993377483444>

---

--- 178 --
Question ID: 314162009daa2234d115fa8a7912cba3d4305e99_0
Original Code:
```
public final class ObjectToFieldsSerializer implements ObjectSerializer {

    /** The Constant visited. */
    private static final ArrayList<Object> visited = new ArrayList<Object>();

    /**
     * Converts an object to a string representation that lists all fields.
     *
     * @param auditFields the audit fields
     * @param object an object
     * @param objectName the object name
     * @param deidentify the de-identify
     */
    public final void toFields(List<Field> auditFields, Object object, String objectName, DeIdentify deidentify) {
        String localOjectName = objectName;
        if (object == null) {
            auditFields.add(new Field(localOjectName, CoreConstants.NULL));
            return;
        }
        
        Class<?> clazz = object.getClass();
        if (!visited.contains(object)) {
            visited.add(object);
            if (isPrimitive(object)) {
                String primitiveValue = String.valueOf(object);
                if (deidentify != null) {
                    primitiveValue = DeIdentifyUtil.deidentify(primitiveValue, deidentify.left(), deidentify.right(),
                            deidentify.fromLeft(), deidentify.fromRight());
                }
                auditFields.add(new Field(localOjectName, primitiveValue, object.getClass()
                        .getName()));
            } else if (clazz.isArray()) {
                if (Array.getLength(object) == 0) {
                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),
                            CoreConstants.EMPTY));
                } else {
                    // String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR +
                    // clazz.getName();
                    for (int i = 0; i < Array.getLength(object); i++) {
                        Object objVal = Array.get(object, i);
                        String internalLocalOjectName = localOjectName + CoreConstants.OPEN_BRACES_CHAR + "arg"
                                + i + CoreConstants.CLOSE_BRACES_CHAR;
                        if (clazz.getComponentType().isPrimitive())
                            auditFields.add(new Field(internalLocalOjectName, String
                                    .valueOf(objVal), objVal.getClass().getName()));
                        else if (objVal != null) {
                            toFields(auditFields, objVal, internalLocalOjectName, null);
                        }
                    }
                }
            } else if (object instanceof Collection<?>) {
                Collection<?> collection = (Collection<?>) object;
                if (collection.isEmpty()) {
                    auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),
                            CoreConstants.EMPTY));
                } else {
                    String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + object.getClass().getName();
                int i = 0;
                for (Object collectionObject : collection) {
                    String internalLocalOjectName2 = internalLocalOjectName +  CoreConstants.OPEN_BRACES_CHAR + "arg" + i
                            + CoreConstants.CLOSE_BRACES_CHAR;
                    if (isPrimitive(collectionObject)) {
                        auditFields.add(new Field(internalLocalOjectName2, String
                                .valueOf(collectionObject), collectionObject.getClass().getName()));
                    } else if (collectionObject != null) {
                        toFields(auditFields, collectionObject, internalLocalOjectName2, null);
                    }
                    i++;
                }
                }
            } else {
                String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName();
                do {
                    java.lang.reflect.Field[] fields = clazz.getDeclaredFields();
                    AccessibleObject.setAccessible(fields, true);
                    for (java.lang.reflect.Field field : fields) {
                        if (!Modifier.isStatic(field.getModifiers()) && !field.isAnnotationPresent(IgnoreAudit.class)) {
                            String internalLocalOjectName2 = internalLocalOjectName + CoreConstants.DOLLAR_CHAR + field.getName();
                            boolean deidentifyFlag = false;
                            DeIdentify deidentifyAnn = null;
                            if (field.isAnnotationPresent(DeIdentify.class)) {
                                deidentifyAnn = field.getAnnotation(DeIdentify.class);
                                deidentifyFlag = true;
                            }
                            try {
                                Object objValue = field.get(object);
                                if (isPrimitive(object)) {
                                    String paramValue = String.valueOf(object);
                                    if (deidentifyFlag) {
                                        paramValue = DeIdentifyUtil.deidentify(paramValue, deidentifyAnn.left(),
                                                deidentifyAnn.right(), deidentifyAnn.fromLeft(),
                                                deidentifyAnn.fromRight());
                                    }
                                    auditFields.add(new Field(internalLocalOjectName2, paramValue,
                                            object.getClass().getName()));
                                } else {
                                    if (objValue != null) {
                                        toFields(auditFields, objValue, internalLocalOjectName2, deidentifyAnn);
                                    }
                                }
                            } catch (IllegalArgumentException e) {
                                throw new Audit4jRuntimeException(
                                        "Error due to converting object to string representation. ", e);
                            } catch (IllegalAccessException e) {
                                throw new Audit4jRuntimeException(
                                        "Error due to converting object to string representation. ", e);
                            } catch (Exception e) {
                                throw new Audit4jRuntimeException(
                                        "Error due to converting object to string representation. ", e);
                            }
                        }
                    }
                    clazz = clazz.getSuperclass();
                } while (clazz != null);
            }
        }
    }

    /* (non-Javadoc)
     * @see org.audit4j.core.ObjectSerializer#serialize(java.util.List, java.lang.Object, java.lang.String, org.audit4j.core.annotation.DeIdentify)
     */
    @Override
    public void serialize(List<Field> auditFields, Object object,
            String objectName,  DeIdentify deidentify) {
        visited.clear();
       toFields(auditFields, object, objectName, deidentify);
    }

    /**
     * Checks if is primitive.
     * 
     * @param object
     *            the object
     * @return true, if is primitive
     */
    public final static boolean isPrimitive(Object object) {
        if (object instanceof String || object instanceof Number || object instanceof Boolean
                || object instanceof Character) {
            return true;
        }
        return false;
    }
    
}
```


Overlapping Code:
```
c final class ObjectToFieldsSerializer implements ObjectSerializer {
/** The Constant visited. */
private static final ArrayList<Object> visited = new ArrayList<Object>();
/**
* Converts an object to a string representation that lists all fields.
*
* @param auditFields the audit fields
* @param object an object
* @param objectName the object name
* @param deidentify the de-identify
*/
public final void toFields(List<Field> auditFields, Object object, String objectName, DeIdentify deidentify) {
String localOjectName = objectName;
if (object == null) {
auditFields.add(new Field(localOjectName, CoreConstants.NULL));
return;
}

Class<?> clazz = object.getClass();
if (!visited.contains(object)) {
visited.add(object);
if (isPrimitive(object)) {
String primitiveValue = String.valueOf(object);
if (deidentify != null) {
primitiveValue = DeIdentifyUtil.deidentify(primitiveValue, deidentify.left(), deidentify.right(),
deidentify.fromLeft(), deidentify.fromRight());
}
auditFields.add(new Field(localOjectName, primitiveValue, object.getClass()
.getName()));
} else if (clazz.isArray()) {
if (Array.getLength(object) == 0) {
auditFields.add(new Field(localOjectName + CoreConstants.DOLLAR_CHAR + clazz.getName(),
CoreConstants.EMPTY));
} else {
// String internalLocalOjectName = localOjectName + CoreConstants.DOLLAR_CHAR +
// clazz.getName();
for (int i = 0; i < Array.getLength(object); i++) {
Object objVal = Array.get(object, i);
String internalLocalOjectName = localOjectName + CoreConstants.OPEN_BRACES_CHAR + "arg"
+ i + CoreConstants.CLOSE_BRACES_CHAR;
if (clazz.getComponentType().isPrimitive())
auditFields.add(new Field(internalLocalOjectName, String
.valueOf(objVal), objVal.getClass().getName()));
else if (objVal != null) {
toFields(auditFields, objVal, internalLocal
```
<Overlap Ratio: 0.9867256637168141>

---

--- 179 --
Question ID: 5eb74c5442d6f7c2288f7b9fd8dbc5af726a9536_0
Original Code:
```
public class KubernetesConfigMapProviderIT {
    private static final String RESOURCE_NAME = "my-test-config-map";

    private static String namespace;
    private static KubernetesClient client;
    private static KubernetesConfigMapConfigProvider provider;

    @BeforeAll
    public static void beforeAll()   {
        provider = new KubernetesConfigMapConfigProvider();
        provider.configure(emptyMap());

        client = new DefaultKubernetesClient();
        namespace = client.getNamespace();

        ConfigMap cm = new ConfigMapBuilder()
                .withNewMetadata()
                    .withName(RESOURCE_NAME)
                    .withNamespace(namespace)
                .endMetadata()
                .addToData("test-key-1", "test-value-1")
                .addToData("test-key-2", "test-value-2")
                .addToData("test-key-3", "test-value-3")
                .build();

        client.configMaps().create(cm);
    }

    @AfterAll
    public static void afterAll() throws IOException {
        client.configMaps().inNamespace(namespace).withName(RESOURCE_NAME).delete();
        provider.close();
    }

    @Test
    public void testAllValues() {
        ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME);
        Map<String, String> data = config.data();

        assertThat(data.size(), is(3));
        assertThat(data.get("test-key-1"), is("test-value-1"));
        assertThat(data.get("test-key-2"), is("test-value-2"));
        assertThat(data.get("test-key-3"), is("test-value-3"));
    }

    @Test
    public void testSomeValues() {
        ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME, new HashSet<>(Arrays.asList("test-key-1", "test-key-3")));
        Map<String, String> data = config.data();

        assertThat(data.size(), is(2));
        assertThat(data.get("test-key-1"), is("test-value-1"));
        assertThat(data.get("test-key-3"), is("test-value-3"));
    }

    @Test
    public void testOneValue() {
        ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME, Collections.singleton("test-key-2"));
        Map<String, String> data = config.data();

        assertThat(data.size(), is(1));
        assertThat(data.get("test-key-2"), is("test-value-2"));
    }

    @Test
    public void testNonExistentConfigMap() {
        assertThrows(ConfigException.class, () -> provider.get(namespace + "/i-do-not-exist"));
        assertThrows(ConfigException.class, () -> provider.get("i-do-not-exist/i-do-not-exist-either"));
        assertThrows(ConfigException.class, () -> provider.get("i-do-not-exist"));
    }
}
```


Overlapping Code:
```
 KubernetesConfigMapProviderIT {
private static final String RESOURCE_NAME = "my-test-config-map";
private static String namespace;
private static KubernetesClient client;
private static KubernetesConfigMapConfigProvider provider;
@BeforeAll
public static void beforeAll() {
provider = new KubernetesConfigMapConfigProvider();
provider.configure(emptyMap());
client = new DefaultKubernetesClient();
namespace = client.getNamespace();
ConfigMap cm = new ConfigMapBuilder()
.withNewMetadata()
.withName(RESOURCE_NAME)
.withNamespace(namespace)
.endMetadata()
.addToData("test-key-1", "test-value-1")
.addToData("test-key-2", "test-value-2")
.addToData("test-key-3", "test-value-3")
.build();
client.configMaps().create(cm);
}
@AfterAll
public static void afterAll() throws IOException {
client.configMaps().inNamespace(namespace).withName(RESOURCE_NAME).delete();
provider.close();
}
@Test
public void testAllValues() {
ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME);
Map<String, String> data = config.data();
assertThat(data.size(), is(3));
assertThat(data.get("test-key-1"), is("test-value-1"));
assertThat(data.get("test-key-2"), is("test-value-2"));
assertThat(data.get("test-key-3"), is("test-value-3"));
}
@Test
public void testSomeValues() {
ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME, new HashSet<>(Arrays.asList("test-key-1", "test-key-3")));
Map<String, String> data = config.data();
assertThat(data.size(), is(2));
assertThat(data.get("test-key-1"), is("test-value-1"));
assertThat(data.get("test-key-3"), is("test-value-3"));
}
@Test
public void testOneValue() {
ConfigData config = provider.get(namespace + "/" + RESOURCE_NAME, Collections.singleton("test-key-2"));
Map<String, String> data = config.data();
assertThat(data.size(), is(1));
assertThat(data.get("test-key-2"), is("test-value-2"));
}
@Test
public void testNonExistentConfigMap() {
assertThrows(ConfigException.class, () -> provider.get(namespace + "/i-do-not-exist"));
assertThrows(ConfigException.class, () -> provider.get("i-do-not-
```
<Overlap Ratio: 0.9932170542635659>

---

--- 180 --
Question ID: fc88a55f46be4de2d3cafec09b9a4f5844614d6a_0
Original Code:
```
public class DemoTest {
    public static void main(String[] args) {
        IgoChessman black1,black2,black3,white1,white2,white3;
//        IgoChessmanFactory factory;
    
        IgoChessmanFactory factory=IgoChessmanFactory.getInstance();
    
        black1=factory.getIgoChessman("b");
        black2=factory.getIgoChessman("b");
        black3=factory.getIgoChessman("b");
    
        System.out.println("判断黑色棋子是否相等" + (black1 == black2));
    
        white1 = factory.getIgoChessman("w");
        white2 = factory.getIgoChessman("w");
        System.out.println("判断白色棋子是否相等" + (white1 == white2));
    
        
    }
}
```


Overlapping Code:
```
ublic class DemoTest {
public static void main(String[] args) {
IgoChessman black1,black2,black3,white1,white2,white3;
// IgoChessmanFactory factory;

IgoChessmanFactory factory=IgoChessmanFactory.getInstance();

black1=factory.getIgoChessman("b");
black2=factory.getIgoChessman("b");
black3=factory.getIgoChessman("b");

System.out.println("判断黑色棋子是否相等" + (black1 == black2));

white1 = factory.getIgoChessman("w");
white2 = factory.getIgoChessman("w");
System.out.println("判断白色棋子是否相等" + (white1 == white2
```
<Overlap Ratio: 0.9805825242718447>

---

--- 181 --
Question ID: a8c2ca609a64cd64453fc698fbaf869f4eb244c0_0
Original Code:
```
public class HarryPotterMagicMarshaller implements MessageMarshaller<HPMagic> {

   @Override
   public HPMagic readFrom(ProtoStreamReader reader) throws IOException {
      String id = reader.readString("id");
      String caster = reader.readString("caster");
      String spell = reader.readString("spell");
      boolean h = reader.readBoolean("hogwarts");
      return new HPMagic(id, caster, spell, h);
   }

   @Override
   public void writeTo(ProtoStreamWriter writer, HPMagic magic) throws IOException {
      writer.writeString("id", magic.getId());
      writer.writeString("caster", magic.getCaster());
      writer.writeString("spell", magic.getSpell());
      writer.writeBoolean("hogwarts", magic.isHogwarts());
   }

   @Override
   public Class<? extends HPMagic> getJavaClass() {
      return HPMagic.class;
   }

   @Override
   public String getTypeName() {
      return "quickstart.HPMagic";
   }
}
```


Overlapping Code:
```
ler implements MessageMarshaller<HPMagic> {
@Override
public HPMagic readFrom(ProtoStreamReader reader) throws IOException {
String id = reader.readString("id");
String caster = reader.readString("caster");
String spell = reader.readString("spell");
boolean h = reader.readBoolean("hogwarts");
return new HPMagic(id, caster, spell, h);
}
@Override
public void writeTo(ProtoStreamWriter writer, HPMagic magic) throws IOException {
writer.writeString("id", magic.getId());
writer.writeString("caster", magic.getCaster());
writer.writeString("spell", magic.getSpell());
writer.writeBoolean("hogwarts", magic.isHogwarts());
}
@Override
public Class<? extends HPMagic> getJavaClass() {
return HPMagic.class;
}
@Override
public String getTypeName() {
return "
```
<Overlap Ratio: 0.9261992619926199>

---

--- 182 --
Question ID: 7e71c047d72e04130a8cd57e4327853615945323_0
Original Code:
```
public class AbstractWindowedCursorTest extends InstrumentationTestCase {
    private static final String TEST_STRING = "TESTSTRING";
    private static final int COLUMN_INDEX0 = 0;
    private static final int COLUMN_INDEX1 = 1;
    private static final int ROW_INDEX0 = 0;
    private static final int TEST_COLUMN_COUNT = 7;
    private MockAbstractWindowedCursor mCursor;
    private CursorWindow mWindow;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mCursor = new MockAbstractWindowedCursor();
        mWindow = new CursorWindow(false);
    }

    @Override
    protected void tearDown() throws Exception {
        mCursor.close();
        mWindow.close();
        super.tearDown();
    }
    
    public void testIsNull() {
        mCursor.setWindow(mWindow);

        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        mCursor.moveToFirst();
        assertTrue(mCursor.isNull(COLUMN_INDEX0));
        assertTrue(mWindow.allocRow());

        String str = "abcdefg";
        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
        assertFalse(mCursor.isNull(COLUMN_INDEX0));
    }

    public void testIsBlob() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        assertFalse(mCursor.isBlob(COLUMN_INDEX0));

        String str = "abcdefg";
        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
        assertTrue(mWindow.putBlob(new byte[10], ROW_INDEX0, COLUMN_INDEX1));
        assertTrue(mCursor.isBlob(COLUMN_INDEX1));
    }

    public void testHasWindow() {
        assertFalse(mCursor.hasWindow());
        assertNull(mCursor.getWindow());

        mCursor.setWindow(mWindow);
        assertTrue(mCursor.hasWindow());
        assertSame(mWindow, mCursor.getWindow());

        mCursor.setWindow(null);
        assertFalse(mCursor.hasWindow());
        assertNull(mCursor.getWindow());
    }

    public void testGetString() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        String str = "abcdefg";
        assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
        assertEquals(str, mCursor.getString(COLUMN_INDEX0));
    }

    public void testGetShort() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        short shortNumber = 10;
        assertTrue(mWindow.putLong((long) shortNumber, ROW_INDEX0, COLUMN_INDEX0));
        assertEquals(shortNumber, mCursor.getShort(COLUMN_INDEX0));
    }

    public void testGetLong() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        long longNumber = 10;
        assertTrue(mWindow.putLong(longNumber, ROW_INDEX0, COLUMN_INDEX0));
        assertEquals(longNumber, mCursor.getLong(COLUMN_INDEX0));
    }

    public void testGetInt() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        int intNumber = 10;
        assertTrue(mWindow.putLong((long) intNumber, ROW_INDEX0, COLUMN_INDEX0));
        assertEquals(intNumber, mCursor.getInt(COLUMN_INDEX0));
    }

    public void testGetFloat() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        mCursor.moveToFirst();
        float f1oatNumber = 1.26f;
        assertTrue(mWindow.putDouble((double) f1oatNumber, ROW_INDEX0, COLUMN_INDEX0));
        assertEquals(f1oatNumber, mCursor.getFloat(COLUMN_INDEX0));
    }

    public void testGetDouble() {
        mCursor.setWindow(mWindow);
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());

        double db1 = 1.26;
        assertTrue(mWindow.putDouble(db1, ROW_INDEX0, COLUMN_INDEX0));

        double db2 = mWindow.getDouble(ROW_INDEX0, COLUMN_INDEX0);
        assertEquals(db1, db2);

        mCursor.moveToFirst();
        double cd = mCursor.getDouble(COLUMN_INDEX0);
        assertEquals(db1, cd);
    }

    public void testGetBlob() {
        byte TEST_VALUE = 3;
        byte BLOB_SIZE = 100;
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());
        assertTrue(mWindow.putString("", ROW_INDEX0, COLUMN_INDEX0));

        byte[] blob = new byte[BLOB_SIZE];
        Arrays.fill(blob, TEST_VALUE);
        assertTrue(mWindow.putBlob(blob, ROW_INDEX0, COLUMN_INDEX1));

        mCursor.setWindow(mWindow);
        mCursor.moveToFirst();

        byte[] targetBuffer = mCursor.getBlob(COLUMN_INDEX1);
        assertEquals(BLOB_SIZE, targetBuffer.length);
        assertTrue(Arrays.equals(blob, targetBuffer));
    }

    public void testCopyStringToBuffer() {
        assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
        assertTrue(mWindow.allocRow());
        assertTrue(mWindow.putString(TEST_STRING, ROW_INDEX0, COLUMN_INDEX0));
        assertTrue(mWindow.putString("", ROW_INDEX0, COLUMN_INDEX1));

        mCursor.setWindow(mWindow);
        mCursor.moveToFirst();

        CharArrayBuffer charArrayBuffer = new CharArrayBuffer(TEST_STRING.length());

        mCursor.copyStringToBuffer(COLUMN_INDEX0, charArrayBuffer);
        assertEquals(TEST_STRING.length(), charArrayBuffer.sizeCopied);
        assertTrue(Arrays.equals(TEST_STRING.toCharArray(), charArrayBuffer.data));

        Arrays.fill(charArrayBuffer.data, '\0');
        mCursor.copyStringToBuffer(COLUMN_INDEX1, charArrayBuffer);
        assertEquals(0, charArrayBuffer.sizeCopied);
    }

    public void testCheckPosition() {
        try {
            mCursor.checkPosition();
            fail("testCheckPosition failed");
        } catch (CursorIndexOutOfBoundsException e) {
            // expected
        }

        try {
            assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));
            mCursor.checkPosition();
            fail("testCheckPosition failed");
        } catch (StaleDataException e) {
            // expected
        }

        assertTrue(mCursor.moveToPosition(mCursor.getCount() - 1));
        mCursor.setWindow(mWindow);
        mCursor.checkPosition();
    }

    private class MockAbstractWindowedCursor extends AbstractWindowedCursor {

        public MockAbstractWindowedCursor() {
        }

        @Override
        public String[] getColumnNames() {
            return new String[] {
                    "col1", "col2", "col3"
            };
        }

        @Override
        public int getCount() {
            return 1;
        }

        @Override
        protected void checkPosition() {
            super.checkPosition();
        }
    }
}
```


Overlapping Code:
```
 class AbstractWindowedCursorTest extends InstrumentationTestCase {
private static final String TEST_STRING = "TESTSTRING";
private static final int COLUMN_INDEX0 = 0;
private static final int COLUMN_INDEX1 = 1;
private static final int ROW_INDEX0 = 0;
private static final int TEST_COLUMN_COUNT = 7;
private MockAbstractWindowedCursor mCursor;
private CursorWindow mWindow;
@Override
protected void setUp() throws Exception {
super.setUp();
mCursor = new MockAbstractWindowedCursor();
mWindow = new CursorWindow(false);
}
@Override
protected void tearDown() throws Exception {
mCursor.close();
mWindow.close();
super.tearDown();
}

public void testIsNull() {
mCursor.setWindow(mWindow);
assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
mCursor.moveToFirst();
assertTrue(mCursor.isNull(COLUMN_INDEX0));
assertTrue(mWindow.allocRow());
String str = "abcdefg";
assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
assertFalse(mCursor.isNull(COLUMN_INDEX0));
}
public void testIsBlob() {
mCursor.setWindow(mWindow);
assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
assertTrue(mWindow.allocRow());
mCursor.moveToFirst();
assertFalse(mCursor.isBlob(COLUMN_INDEX0));
String str = "abcdefg";
assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
assertTrue(mWindow.putBlob(new byte[10], ROW_INDEX0, COLUMN_INDEX1));
assertTrue(mCursor.isBlob(COLUMN_INDEX1));
}
public void testHasWindow() {
assertFalse(mCursor.hasWindow());
assertNull(mCursor.getWindow());
mCursor.setWindow(mWindow);
assertTrue(mCursor.hasWindow());
assertSame(mWindow, mCursor.getWindow());
mCursor.setWindow(null);
assertFalse(mCursor.hasWindow());
assertNull(mCursor.getWindow());
}
public void testGetString() {
mCursor.setWindow(mWindow);
assertTrue(mWindow.setNumColumns(TEST_COLUMN_COUNT));
assertTrue(mWindow.allocRow());
mCursor.moveToFirst();
String str = "abcdefg";
assertTrue(mWindow.putString(str, ROW_INDEX0, COLUMN_INDEX0));
assertEquals(str, mCursor.getString(COLUMN_INDEX0));
}
public void testGetShort() {
mCursor.setWindow(mWindow);
assertTrue(mWindow.set
```
<Overlap Ratio: 0.9961408586589484>

---

--- 183 --
Question ID: c0ea2bd1af0d1c3b7917b1d3117b05ee528d67e9_0
Original Code:
```
public abstract class PrefixTreeBase<T> implements PrefixTree<T> {
    public static final String DEFAULT_PATH_SEPARATOR = "/";

    public static final String PROTOCOL_PREFIX = "://";

    private final PrefixTreeNode<T> _RootNode;

    private final String _PathSeparator;

    public PrefixTreeBase() {

        this(DEFAULT_PATH_SEPARATOR);
    }

    public PrefixTreeBase(final String pathSeparator) {

        _PathSeparator = pathSeparator;
        _RootNode = new PrefixTreeNode<>();
    }


    public String getPathSeparator() {

        return _PathSeparator;
    }

    public PrefixTreeNode<T> getRoot() {

        return _RootNode;
    }

    @Override
    public void setPathValue(final String path, final T value) {

        PrefixTreeNode node = getRoot();
        final List<String> segments = segmentPath(path);

        for (final String segment : segments) {
            if (node.hasChild(segment)) {
                node = node.getChild(segment);
            }
            else {
                node = node.addChild(segment, null);
            }
        }

        node.setValue(value);
    }

    public String toString() {

        final String pathSeparator = getPathSeparator();
        final Set<String> paths = getRoot().deepPrint(pathSeparator);
        final StringBuilder sb = new StringBuilder();
        for (final String p : paths) {
            sb.append(p).append('\n');
        }
        return sb.toString();
    }

    protected List<String> segmentPath(final String path) {

        final String pathSeparator = getPathSeparator();

        String trimmedPath = path.trim();

        final int protocolPrefixIndex = trimmedPath.indexOf(PROTOCOL_PREFIX);
        if (protocolPrefixIndex >= 0) {
            trimmedPath = trimmedPath.substring(protocolPrefixIndex + PROTOCOL_PREFIX.length());
        }

        if (trimmedPath.endsWith(pathSeparator)) {
            trimmedPath = trimmedPath.substring(0, trimmedPath.length() - 1);
        }

        if (trimmedPath.startsWith(pathSeparator)) {
            trimmedPath = trimmedPath.substring(1);
        }

        String[] segmentArray = trimmedPath.split(pathSeparator);
        if (segmentArray.length == 0) {
            return Collections.EMPTY_LIST;
        }

        final List<String> segments = new LinkedList<>(Arrays.asList(segmentArray));
        return segments;
    }
}
```


Overlapping Code:
```
c abstract class PrefixTreeBase<T> implements PrefixTree<T> {
public static final String DEFAULT_PATH_SEPARATOR = "/";
public static final String PROTOCOL_PREFIX = "://";
private final PrefixTreeNode<T> _RootNode;
private final String _PathSeparator;
public PrefixTreeBase() {
this(DEFAULT_PATH_SEPARATOR);
}
public PrefixTreeBase(final String pathSeparator) {
_PathSeparator = pathSeparator;
_RootNode = new PrefixTreeNode<>();
}
public String getPathSeparator() {
return _PathSeparator;
}
public PrefixTreeNode<T> getRoot() {
return _RootNode;
}
@Override
public void setPathValue(final String path, final T value) {
PrefixTreeNode node = getRoot();
final List<String> segments = segmentPath(path);
for (final String segment : segments) {
if (node.hasChild(segment)) {
node = node.getChild(segment);
}
else {
node = node.addChild(segment, null);
}
}
node.setValue(value);
}
public String toString() {
final String pathSeparator = getPathSeparator();
final Set<String> paths = getRoot().deepPrint(pathSeparator);
final StringBuilder sb = new StringBuilder();
for (final String p : paths) {
sb.append(p).append('\n');
}
return sb.toString();
}
protected List<String> segmentPath(final String path) {
final String pathSeparator = getPathSeparator();
String trimmedPath = path.trim();
final int protocolPrefixIndex = trimmedPath.indexOf(PROTOCOL_PREFIX);
if (protocolPrefixIndex >= 0) {
trimmedPath = trimmedPath.substring(protocolPrefixIndex + PROTOCOL_PREFIX.length());
}
if (trimmedPath.endsWith(pathSeparator)) {
trimmedPath = trimmedPath.substring(0, trimmedPath.length() - 1);
}
if (trimmedPath.startsWith(pathSeparator)) {
trimmedPath = trimmedPath.substring(1);
}
String[] segmentArray = trimmedPath.split(pathSeparator);
if (segmentArray.length == 0) {
return Collections.EMPTY_LIST;
}
final List<String> segments = new LinkedList<>(Arrays.asL
```
<Overlap Ratio: 0.9762532981530343>

---

--- 184 --
Question ID: 2f5561f6ce3943600beaddf87b4fd1d3011cf09c_0
Original Code:
```
public class RemindersAppTestsInit {

    @BeforeClass(alwaysRun = true)
    public void setUp() {
        initMobile(RemindersApp.class);
        AppiumDriver driver = (AppiumDriver) getDriver();
        driver.launchApp();
        logger.toLog("Run Reminders App Tests");
    }

    @BeforeMethod(alwaysRun = true)
    public void continueThroughWelcomePage() {
        if (RemindersApp.continueButton.isDisplayed())
            RemindersApp.continueButton.click();
    }

    @AfterMethod(alwaysRun = true)
    public void resetApp() {
        AppManager.resetApp();
    }

    @AfterClass(alwaysRun = true)
    public void tearDown() {
        WebDriverFactory.quit();
    }
}
```


Overlapping Code:
```
TestsInit {
@BeforeClass(alwaysRun = true)
public void setUp() {
initMobile(RemindersApp.class);
AppiumDriver driver = (AppiumDriver) getDriver();
driver.launchApp();
logger.toLog("Run Reminders App Tests");
}
@BeforeMethod(alwaysRun = true)
public void continueThroughWelcomePage() {
if (RemindersApp.continueButton.isDisplayed())
RemindersApp.continueButton.click();
}
@AfterMethod(alwaysRun = true)
public void resetApp() {
AppManager.resetApp();
}
@AfterClass(alwaysRun = true)
public void tearDown() {
WebDriverFactory.quit();
}
```
<Overlap Ratio: 0.9517857142857142>

---

--- 185 --
Question ID: c96b7bbfeb5d17e3b13aedab9e977d813c3fc9c3_0
Original Code:
```
public class GlueCommandFactory extends JSONInputCommandFactory{

	private enum Arguments {
		worksheetId, hTableId, hNodeId, 
		newColumnName, defaultValue, selectionName, 
		values, ImplMethod
	}
	
	@Override
	public Command createCommand(JSONArray inputJson, String model, Workspace workspace)
			throws JSONException, KarmaException {
		String hNodeId = CommandInputJSONUtil.getStringValue(Arguments.hNodeId.name(), inputJson);
		String worksheetId = CommandInputJSONUtil.getStringValue(Arguments.worksheetId.name(), inputJson);
		String hNodeIdList = CommandInputJSONUtil.getStringValue(Arguments.values.name(), inputJson);
		String implMethod = CommandInputJSONUtil.getStringValue(Arguments.ImplMethod.name(), inputJson);
		this.normalizeSelectionId(worksheetId, inputJson, workspace);
		String selectionName = CommandInputJSONUtil.getStringValue(Arguments.selectionName.name(), inputJson);
		GlueCommand glueCmd = new GlueCommand(getNewId(workspace), model, worksheetId,
				hNodeId, selectionName, hNodeIdList, implMethod);
		glueCmd.setInputParameterJson(inputJson.toString());
		return glueCmd;
	}

	@Override
	public Command createCommand(HttpServletRequest request, Workspace workspace) {
		return null;
	}

	@Override
	public Class<? extends Command> getCorrespondingCommand() {
		return GlueCommand.class;
	}

}
```


Overlapping Code:
```
ndFactory extends JSONInputCommandFactory{
private enum Arguments {
worksheetId, hTableId, hNodeId, 
newColumnName, defaultValue, selectionName, 
values, ImplMethod
}

@Override
public Command createCommand(JSONArray inputJson, String model, Workspace workspace)
throws JSONException, KarmaException {
String hNodeId = CommandInputJSONUtil.getStringValue(Arguments.hNodeId.name(), inputJson);
String worksheetId = CommandInputJSONUtil.getStringValue(Arguments.worksheetId.name(), inputJson);
String hNodeIdList = CommandInputJSONUtil.getStringValue(Arguments.values.name(), inputJson);
String implMethod = CommandInputJSONUtil.getStringValue(Arguments.ImplMethod.name(), inputJson);
this.normalizeSelectionId(worksheetId, inputJson, workspace);
String selectionName = CommandInputJSONUtil.getStringValue(Arguments.selectionName.name(), inputJson);
GlueCommand glueCmd = new GlueCommand(getNewId(workspace), model, worksheetId,
hNodeId, selectionName, hNodeIdList, implMethod);
glueCmd.setInputParameterJson(inputJson.toString());
return glueCmd;
}
@Override
public Command createCommand(HttpServletRequest request, Workspace workspace) {
return null;
}
@Override
public Class<? extends Command> getCorrespondingCommand() {
return GlueCommand.class;
}
}
```
<Overlap Ratio: 0.9827315541601256>

---

--- 186 --
Question ID: 682b1b2e97e87628ab52e2898214c99e8e8409c2_0
Original Code:
```
public class InMemoryStorageTest {
  private InMemoryStorage<Integer> storage;

  @BeforeEach
  public void setup() {
    storage = InMemoryStorage.<Integer>builder().maxItems(2).build();
  }

  @Test
  public void itCanSave() {
    storage.save(123);

    assertThat(storage.peek().getValue()).isEqualTo(123);
  }

  @Test
  public void itCanSaveAndRemoveIfExceedTheMaxItemsSize() {
    storage.save(123);
    storage.save(456);
    storage.save(789);

    assertThat(storage.peek().getValue()).isEqualTo(456);
  }

  @Test
  public void itCanGetItemsForALimitLessThanCurrentItems() {
    storage.save(123);
    storage.save(456);

    List<StorageItem<Integer>> items = storage.get(1);
    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
        .isEqualTo(List.of(123));
  }

  @Test
  public void itCanGetItemsForALimitEqualToCurrentItems() {
    storage.save(123);
    storage.save(456);

    List<StorageItem<Integer>> items = storage.get(2);
    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
        .isEqualTo(List.of(123, 456));
  }

  @Test
  public void itCanGetItemsForALimitMoreThanCurrentItems() {
    storage.save(123);
    storage.save(456);

    List<StorageItem<Integer>> items = storage.get(3);
    assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
        .isEqualTo(List.of(123, 456));
  }

  @Test
  public void itCanRemoveByTimestamp() {
    storage.save(123);
    StorageItem<Integer> item = storage.peek();
    storage.remove(item.getTimestamp());

    assertThat(storage.peek()).isNull();
  }
}
```


Overlapping Code:
```
est {
private InMemoryStorage<Integer> storage;
@BeforeEach
public void setup() {
storage = InMemoryStorage.<Integer>builder().maxItems(2).build();
}
@Test
public void itCanSave() {
storage.save(123);
assertThat(storage.peek().getValue()).isEqualTo(123);
}
@Test
public void itCanSaveAndRemoveIfExceedTheMaxItemsSize() {
storage.save(123);
storage.save(456);
storage.save(789);
assertThat(storage.peek().getValue()).isEqualTo(456);
}
@Test
public void itCanGetItemsForALimitLessThanCurrentItems() {
storage.save(123);
storage.save(456);
List<StorageItem<Integer>> items = storage.get(1);
assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
.isEqualTo(List.of(123));
}
@Test
public void itCanGetItemsForALimitEqualToCurrentItems() {
storage.save(123);
storage.save(456);
List<StorageItem<Integer>> items = storage.get(2);
assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
.isEqualTo(List.of(123, 456));
}
@Test
public void itCanGetItemsForALimitMoreThanCurrentItems() {
storage.save(123);
storage.save(456);
List<StorageItem<Integer>> items = storage.get(3);
assertThat(items.stream().map(StorageItem::getValue).collect(Collectors.toList()))
.isEqualTo(List.of(123, 456));
}
@Test
public void itCanRemoveByTimestamp() {
storage.save(123);
StorageItem<Integer> item = storage.peek();
storage.remove(item.getTimestamp());
assertThat(storag
```
<Overlap Ratio: 0.9641873278236914>

---

--- 187 --
Question ID: ce6dc5a582b585ce72817a1ced6012c5be5bca7c_0
Original Code:
```
public final class TbiIndex extends Index{
	
	private TIndex[] mIndex;
	
	public void readMagic() throws IOException {
		byte[] buf = new byte[4];
        is.read(buf, 0, 4); // read "TBI\1"
    }
	
	public void readFormat() throws IOException {
		mSeq = new String[GlobalParameter.readInt(is)]; // # sequences
		mChr2tid = new HashMap<String, Integer>();
		mTid2chr = new HashMap<Integer, String>();
		mPreset = GlobalParameter.readInt(is);
		mSc = GlobalParameter.readInt(is);
		mBc = GlobalParameter.readInt(is);
		mEc = GlobalParameter.readInt(is);

		mMeta = GlobalParameter.readInt(is);
		mSkip = GlobalParameter.readInt(is); // read skip
	}
	
	public TbiIndex(String indexPath) {
		super(indexPath, true);
		try {
			read();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void read() throws IOException {
		super.read();

		if((mPreset & 0xffff) == 2) {
			this.format = Format.newVCF();
			this.format.numHeaderLinesToSkip = mSkip;
		} else {
			this.format = new Format(mPreset, mSc, mBc, mEc, mSkip, Character.toString((char) mMeta), -1, -1, false);
		}
	}
	
	public void readIndex() throws IOException {
		mIndex = new TIndex[mSeq.length];
		int i, j, k;
		for (i = 0; i < mSeq.length; ++i) {

			int n_bin = GlobalParameter.readInt(is);
			mIndex[i] = new TIndex();
			mIndex[i].b = new HashMap<Integer, TPair64[]>(n_bin);
			for (j = 0; j < n_bin; ++j) {
				int bin = GlobalParameter.readInt(is);
				TPair64[] chunks = new TPair64[GlobalParameter.readInt(is)];
				for (k = 0; k < chunks.length; ++k) {
					long u = GlobalParameter.readLong(is, buf);
					long v = GlobalParameter.readLong(is, buf);
					chunks[k] = new TPair64(u, v); // in C, this is inefficient
				}
				mIndex[i].b.put(bin, chunks);
			}
			
			// the linear index
			mIndex[i].l = new long[GlobalParameter.readInt(is)];

			for (k = 0; k < mIndex[i].l.length; ++k) {
				mIndex[i].l[k] = GlobalParameter.readLong(is, buf);
				if (i == 0) {
					minOffForChr.put(i, 0l);
				} else {
					if (mIndex[i].l[k] > 0) {
						if (minOffForChr.get(i) == null) {
							minOffForChr.put(i, mIndex[i].l[k]);
						} else {
							if (mIndex[i].l[k] < minOffForChr.get(i)) {
								minOffForChr.put(i, mIndex[i].l[k]);
								throw new InvalidArgumentException("That is  impossible! in SweepReader read index.");
							}
						}
					}
				}
			}
		}
	}

	public TIndex[] getmIndex() {
		return mIndex;
	}

	public static void main(String[] args) {
		TbiIndex index  = new TbiIndex("ALL.chr1.phase3_shapeit2_mvncall_integrated_v3plus_nounphased.rsID.genotypes.GRCh38_dbSNP.vcf.gz.tbi");
		
		System.out.println(index.mSc);
		System.out.println(index.mBc);
		System.out.println(index.mEc);
		System.out.println(index.mPreset);
	}

	@Override
	public String[] getColumnNames() {
		return null;
	}
}
```


Overlapping Code:
```
dex{

private TIndex[] mIndex;

public void readMagic() throws IOException {
byte[] buf = new byte[4];
is.read(buf, 0, 4); // read "TBI\1"
}

public void readFormat() throws IOException {
mSeq = new String[GlobalParameter.readInt(is)]; // # sequences
mChr2tid = new HashMap<String, Integer>();
mTid2chr = new HashMap<Integer, String>();
mPreset = GlobalParameter.readInt(is);
mSc = GlobalParameter.readInt(is);
mBc = GlobalParameter.readInt(is);
mEc = GlobalParameter.readInt(is);
mMeta = GlobalParameter.readInt(is);
mSkip = GlobalParameter.readInt(is); // read skip
}

public TbiIndex(String indexPath) {
super(indexPath, true);
try {
read();
} catch (IOException e) {
e.printStackTrace();
}
}

public void read() throws IOException {
super.read();
if((mPreset & 0xffff) == 2) {
this.format = Format.newVCF();
this.format.numHeaderLinesToSkip = mSkip;
} else {
this.format = new Format(mPreset, mSc, mBc, mEc, mSkip, Character.toString((char) mMeta), -1, -1, false);
}
}

public void readIndex() throws IOException {
mIndex = new TIndex[mSeq.length];
int i, j, k;
for (i = 0; i < mSeq.length; ++i) {
int n_bin = GlobalParameter.readInt(is);
mIndex[i] = new TIndex();
mIndex[i].b = new HashMap<Integer, TPair64[]>(n_bin);
for (j = 0; j < n_bin; ++j) {
int bin = GlobalParameter.readInt(is);
TPair64[] chunks = new TPair64[GlobalParameter.readInt(is)];
for (k = 0; k < chunks.length; ++k) {
long u = GlobalParameter.readLong(is, buf);
long v = GlobalParameter.readLong(is, buf);
chunks[k] = new TPair64(u, v); // in C, this is inefficient
}
mIndex[i].b.put(bin, chunks);
}

// the linear index
mIndex[i].l = new long[GlobalParameter.readInt(is)];
for (k = 0; k < mIndex[i].l.length; ++k) {
mIndex[i].l[k] = GlobalParameter.readLong(is, buf);
if (i == 0) {
minOffForChr.put(i, 0l);
} else {
if (mIndex[i].l[k] > 0) {
if (minOffForChr.get(i) == null) {
minOffForChr.put(i, mIndex[i].l[k]);
} else {
if (mIndex[i].l[k] < minOffForChr.get(i)) {
minOffForChr.put(i, mIndex[i].l[k]);
throw new InvalidArgumentException("That is impossible! in SweepReader read index.");
}
}
}
}
}
}
}
public TIndex[] getmIndex() {
return mIndex;
}
public static void main(String[] args) {
TbiIndex index = new TbiIndex("ALL
```
<Overlap Ratio: 0.9795191451469278>

---

--- 188 --
Question ID: 882a1296db27426c0da0b3e0cd41386ad5204be5_0
Original Code:
```
public class JlineReplTest {
  private static ReplParser parser;
  private static JlineRepl repl;

  @BeforeAll public static void setup() throws IOException {
    repl = new JlineRepl(ImmutableSeq.empty(), PlainReplTest.config);
    parser = new ReplParser(repl.commandManager, repl);
  }

  @Test public void sanity() {
    assertEquals("", repl.renderDoc(Doc.empty()));
  }

  @Test public void command() {
    assertEquals(List.of(":type", "Type"), parser.parse(":type Type", 2).words());
  }

  @Test public void shellLike() {
    // Different lexing strategy depending on the prefix
    assertEquals(List.of(":cd", "../oh/my/./kiva"), parser.parse(":cd ../oh/my/./kiva", 2).words());
    assertEquals(List.of(":type", ".", "/"), parser.parse(":type ./", 2).words());
  }

  @Test public void shellLike2() {
    // Different lexing strategy depending on the prefix
    assertEquals(List.of(":cd", "(Ty"), parser.parse(":cd (Ty", 2).words());
    assertEquals(List.of(":type", "(", "Ty"), parser.parse(":type (Ty", 2).words());
  }

  @Test public void sucZero() {
    assertEquals(List.of("suc", "zero"), parser.parse("suc zero", 2).words());
  }

  @Test public void ws() {
    assertEquals("zero", parser.parse("suc     zero", 5).word());
    assertEquals("", parser.parse("suc  zero      ", 12).word());
  }

  @Test public void parenTyCode() {
    var line = parser.parse("(Ty", 2);
    var candidates = new ArrayList<Candidate>();
    new AyaCompleters.Code(repl).complete(repl.lineReader, line, candidates);
    assertFalse(candidates.isEmpty());
    assertTrue(candidates.stream().anyMatch(c -> "Type".equals(c.value())));
  }

  @Test public void sucZeroIx() {
    assertEquals(0, parser.parse("suc zero", 0).wordIndex());
    assertEquals(0, parser.parse("suc zero", 1).wordIndex());
    assertEquals(0, parser.parse("suc zero", 2).wordIndex());
    assertEquals(0, parser.parse("suc zero", 3).wordIndex());
    assertEquals(1, parser.parse("suc zero", 4).wordIndex());
    assertEquals(1, parser.parse("suc zero", 5).wordIndex());
    assertEquals(1, parser.parse("suc zero", 6).wordIndex());
    assertEquals(1, parser.parse("suc zero", 7).wordIndex());
    var lastToken = parser.parse("suc zero", 8);
    assertEquals(1, lastToken.wordIndex());
    assertEquals("zero", lastToken.word());
  }
}
```


Overlapping Code:
```
ReplTest {
private static ReplParser parser;
private static JlineRepl repl;
@BeforeAll public static void setup() throws IOException {
repl = new JlineRepl(ImmutableSeq.empty(), PlainReplTest.config);
parser = new ReplParser(repl.commandManager, repl);
}
@Test public void sanity() {
assertEquals("", repl.renderDoc(Doc.empty()));
}
@Test public void command() {
assertEquals(List.of(":type", "Type"), parser.parse(":type Type", 2).words());
}
@Test public void shellLike() {
// Different lexing strategy depending on the prefix
assertEquals(List.of(":cd", "../oh/my/./kiva"), parser.parse(":cd ../oh/my/./kiva", 2).words());
assertEquals(List.of(":type", ".", "/"), parser.parse(":type ./", 2).words());
}
@Test public void shellLike2() {
// Different lexing strategy depending on the prefix
assertEquals(List.of(":cd", "(Ty"), parser.parse(":cd (Ty", 2).words());
assertEquals(List.of(":type", "(", "Ty"), parser.parse(":type (Ty", 2).words());
}
@Test public void sucZero() {
assertEquals(List.of("suc", "zero"), parser.parse("suc zero", 2).words());
}
@Test public void ws() {
assertEquals("zero", parser.parse("suc zero", 5).word());
assertEquals("", parser.parse("suc zero ", 12).word());
}
@Test public void parenTyCode() {
var line = parser.parse("(Ty", 2);
var candidates = new ArrayList<Candidate>();
new AyaCompleters.Code(repl).complete(repl.lineReader, line, candidates);
assertFalse(candidates.isEmpty());
assertTrue(candidates.stream().anyMatch(c -> "Type".equals(c.value())));
}
@Test public void sucZeroIx() {
assertEquals(0, parser.parse("suc zero", 0).wordIndex());
assertEquals(0, parser.parse("suc zero", 1).wordIndex());
assertEquals(0, parser.parse("suc zero", 2).wordIndex());
assertEquals(0, parser.parse("suc zero", 3).wordIndex());
assertEquals(1, parser.parse("suc zero", 4).wordIndex());
assertEquals(1, parser.parse("suc zero", 5).wordIndex());
assertEquals(1, parser.parse("suc zero", 6).wordIndex());
assertEquals(1, parser.parse("suc zero", 7).wordIndex());
var lastToken = parser.parse("suc zero", 8);
assertEquals(1, lastToken.wordIndex());
assertEquals("zero", las
```
<Overlap Ratio: 0.9826860084230229>

---

--- 189 --
Question ID: 769b59f14a20333ab57acbfea3828c25b222d52d_0
Original Code:
```
public final class InsertColumnsTokenGenerator implements OptionalSQLTokenGenerator<BaseRule> {
    
    @Override
    public Optional<InsertColumnsToken> generateSQLToken(final SQLStatement sqlStatement, final List<Object> parameters, final BaseRule rule) {
        Optional<InsertColumnsSegment> insertColumnsSegment = sqlStatement.findSQLSegment(InsertColumnsSegment.class);
        if (!(sqlStatement instanceof InsertStatement && insertColumnsSegment.isPresent())) {
            return Optional.absent();
        }
        return createInsertColumnsToken((InsertStatement) sqlStatement, rule, insertColumnsSegment.get());
    }
    
    private Optional<InsertColumnsToken> createInsertColumnsToken(final InsertStatement insertStatement, final BaseRule rule, final InsertColumnsSegment segment) {
        if (!segment.getColumns().isEmpty()) {
            return Optional.absent();
        }
        InsertColumnsToken result = new InsertColumnsToken(segment.getStopIndex(), new LinkedList<>(insertStatement.getColumnNames()), !isNeededToAppendColumns(insertStatement, rule));
        return Optional.of(result);
    }
    
    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final BaseRule rule) {
        if (rule instanceof ShardingRule) {
            return isNeededToAppendColumns(insertStatement, (ShardingRule) rule);
        }
        if (rule instanceof EncryptRule) {
            return isNeededToAppendColumns(insertStatement.getTables().getSingleTableName(), (EncryptRule) rule);
        }
        return false;
    }
    
    private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final ShardingRule shardingRule) {
        String tableName = insertStatement.getTables().getSingleTableName();
        return isNeededToAppendGeneratedKey(tableName, insertStatement.getColumnNames(), shardingRule) || isNeededToAppendColumns(tableName, shardingRule.getEncryptRule());
    }
    
    private boolean isNeededToAppendGeneratedKey(final String tableName, final Collection<String> columnNames, final ShardingRule shardingRule) {
        Optional<String> generateKeyColumnName = shardingRule.findGenerateKeyColumnName(tableName);
        return generateKeyColumnName.isPresent() && !columnNames.contains(generateKeyColumnName.get());
    }
    
    private boolean isNeededToAppendColumns(final String tableName, final EncryptRule encryptRule) {
        return !encryptRule.getEncryptorEngine().getAssistedQueryColumns(tableName).isEmpty();
    }
}
```


Overlapping Code:
```
ublic final class InsertColumnsTokenGenerator implements OptionalSQLTokenGenerator<BaseRule> {

@Override
public Optional<InsertColumnsToken> generateSQLToken(final SQLStatement sqlStatement, final List<Object> parameters, final BaseRule rule) {
Optional<InsertColumnsSegment> insertColumnsSegment = sqlStatement.findSQLSegment(InsertColumnsSegment.class);
if (!(sqlStatement instanceof InsertStatement && insertColumnsSegment.isPresent())) {
return Optional.absent();
}
return createInsertColumnsToken((InsertStatement) sqlStatement, rule, insertColumnsSegment.get());
}

private Optional<InsertColumnsToken> createInsertColumnsToken(final InsertStatement insertStatement, final BaseRule rule, final InsertColumnsSegment segment) {
if (!segment.getColumns().isEmpty()) {
return Optional.absent();
}
InsertColumnsToken result = new InsertColumnsToken(segment.getStopIndex(), new LinkedList<>(insertStatement.getColumnNames()), !isNeededToAppendColumns(insertStatement, rule));
return Optional.of(result);
}

private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final BaseRule rule) {
if (rule instanceof ShardingRule) {
return isNeededToAppendColumns(insertStatement, (ShardingRule) rule);
}
if (rule instanceof EncryptRule) {
return isNeededToAppendColumns(insertStatement.getTables().getSingleTableName(), (EncryptRule) rule);
}
return false;
}

private boolean isNeededToAppendColumns(final InsertStatement insertStatement, final ShardingRule shardingRule) {
String tableName = insertStatement.getTables().getSingleTableName();
return isNeededToAppendGeneratedKey(tableName, insertStatement.getColumnNames(), shardingRule) || isNeededToAppendColumns(tableName, shardingRule.getEncryptRule());
}

private boolean isNeededToAppendGeneratedKey(final String tableName, final Collection<String> columnNames, final ShardingRule shardingRule) {
Optional<String> generateKeyColumnName = shardingRule.findGenerateKeyColumnName(tableName);
return generateKeyColumnName.isPresent() && !columnNames.contains(generateKeyColumnName.get());
}

private boolean isNeededToAppendColumns(final String tableName, final EncryptRule encryptRule) {
return !encryptRule.getEncryptorEngine().getAssistedQueryColumns(tableName
```
<Overlap Ratio: 0.9973154362416108>

---

--- 190 --
Question ID: 1d615816737b5bd4944e0bd0fd4529565a4e81d5_0
Original Code:
```
public class OperationalLimitType extends IdentifiedObject {
	/**
	 * The default value of the '{@link #getDirection() <em>Direction</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getDirection()
	 * @generated
	 * @ordered
	 */
	protected static final OperationalLimitDirectionKind DIRECTION_EDEFAULT = OperationalLimitDirectionKind.LOW;

	/**
	 * The cached value of the '{@link #getDirection() <em>Direction</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getDirection()
	 * @generated
	 * @ordered
	 */
	protected OperationalLimitDirectionKind direction = DIRECTION_EDEFAULT;

	/**
	 * This is true if the Direction attribute has been set.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	protected boolean directionESet;

	/**
	 * The cached value of the '{@link #getOperationalLimit() <em>Operational Limit</em>}' reference list.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getOperationalLimit()
	 * @generated
	 * @ordered
	 */
	protected EList<OperationalLimit> operationalLimit;

	/**
	 * The default value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getAcceptableDuration()
	 * @generated
	 * @ordered
	 */
	protected static final float ACCEPTABLE_DURATION_EDEFAULT = 0.0F;

	/**
	 * The cached value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #getAcceptableDuration()
	 * @generated
	 * @ordered
	 */
	protected float acceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;

	/**
	 * This is true if the Acceptable Duration attribute has been set.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 * @ordered
	 */
	protected boolean acceptableDurationESet;

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected OperationalLimitType() {
		super();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EClass eStaticClass() {
		return OperationalLimitsPackage.Literals.OPERATIONAL_LIMIT_TYPE;
	}

	/**
	 * Returns the value of the '<em><b>Direction</b></em>' attribute.
	 * The literals are from the enumeration {@link CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind}.
	 * <!-- begin-user-doc -->
	 * <p>
	 * If the meaning of the '<em>Direction</em>' attribute isn't clear,
	 * there really should be more of a description here...
	 * </p>
	 * <!-- end-user-doc -->
	 * @return the value of the '<em>Direction</em>' attribute.
	 * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind
	 * @see #isSetDirection()
	 * @see #unsetDirection()
	 * @see #setDirection(OperationalLimitDirectionKind)
	 * @generated
	 */
	public OperationalLimitDirectionKind getDirection() {
		return direction;
	}

	/**
	 * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @param value the new value of the '<em>Direction</em>' attribute.
	 * @see CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind
	 * @see #isSetDirection()
	 * @see #unsetDirection()
	 * @see #getDirection()
	 * @generated
	 */
	public void setDirection(OperationalLimitDirectionKind newDirection) {
		direction = newDirection == null ? DIRECTION_EDEFAULT : newDirection;
		directionESet = true;
	}

	/**
	 * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #isSetDirection()
	 * @see #getDirection()
	 * @see #setDirection(OperationalLimitDirectionKind)
	 * @generated
	 */
	public void unsetDirection() {
		direction = DIRECTION_EDEFAULT;
		directionESet = false;
	}

	/**
	 * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getDirection <em>Direction</em>}' attribute is set.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return whether the value of the '<em>Direction</em>' attribute is set.
	 * @see #unsetDirection()
	 * @see #getDirection()
	 * @see #setDirection(OperationalLimitDirectionKind)
	 * @generated
	 */
	public boolean isSetDirection() {
		return directionESet;
	}

	/**
	 * Returns the value of the '<em><b>Operational Limit</b></em>' reference list.
	 * The list contents are of type {@link CIM15.IEC61970.OperationalLimits.OperationalLimit}.
	 * It is bidirectional and its opposite is '{@link CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType <em>Operational Limit Type</em>}'.
	 * <!-- begin-user-doc -->
	 * <p>
	 * If the meaning of the '<em>Operational Limit</em>' reference list isn't clear,
	 * there really should be more of a description here...
	 * </p>
	 * <!-- end-user-doc -->
	 * @return the value of the '<em>Operational Limit</em>' reference list.
	 * @see CIM15.IEC61970.OperationalLimits.OperationalLimit#getOperationalLimitType
	 * @generated
	 */
	public EList<OperationalLimit> getOperationalLimit() {
		if (operationalLimit == null) {
			operationalLimit = new BasicInternalEList<OperationalLimit>(OperationalLimit.class);
		}
		return operationalLimit;
	}

	/**
	 * Returns the value of the '<em><b>Acceptable Duration</b></em>' attribute.
	 * <!-- begin-user-doc -->
	 * <p>
	 * If the meaning of the '<em>Acceptable Duration</em>' attribute isn't clear,
	 * there really should be more of a description here...
	 * </p>
	 * <!-- end-user-doc -->
	 * @return the value of the '<em>Acceptable Duration</em>' attribute.
	 * @see #isSetAcceptableDuration()
	 * @see #unsetAcceptableDuration()
	 * @see #setAcceptableDuration(float)
	 * @generated
	 */
	public float getAcceptableDuration() {
		return acceptableDuration;
	}

	/**
	 * Sets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @param value the new value of the '<em>Acceptable Duration</em>' attribute.
	 * @see #isSetAcceptableDuration()
	 * @see #unsetAcceptableDuration()
	 * @see #getAcceptableDuration()
	 * @generated
	 */
	public void setAcceptableDuration(float newAcceptableDuration) {
		acceptableDuration = newAcceptableDuration;
		acceptableDurationESet = true;
	}

	/**
	 * Unsets the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see #isSetAcceptableDuration()
	 * @see #getAcceptableDuration()
	 * @see #setAcceptableDuration(float)
	 * @generated
	 */
	public void unsetAcceptableDuration() {
		acceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;
		acceptableDurationESet = false;
	}

	/**
	 * Returns whether the value of the '{@link CIM15.IEC61970.OperationalLimits.OperationalLimitType#getAcceptableDuration <em>Acceptable Duration</em>}' attribute is set.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @return whether the value of the '<em>Acceptable Duration</em>' attribute is set.
	 * @see #unsetAcceptableDuration()
	 * @see #getAcceptableDuration()
	 * @see #setAcceptableDuration(float)
	 * @generated
	 */
	public boolean isSetAcceptableDuration() {
		return acceptableDurationESet;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@SuppressWarnings("unchecked")
	@Override
	public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				return ((InternalEList<InternalEObject>)(InternalEList<?>)getOperationalLimit()).basicAdd(otherEnd, msgs);
		}
		return super.eInverseAdd(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				return ((InternalEList<?>)getOperationalLimit()).basicRemove(otherEnd, msgs);
		}
		return super.eInverseRemove(otherEnd, featureID, msgs);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public Object eGet(int featureID, boolean resolve, boolean coreType) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:
				return getDirection();
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				return getOperationalLimit();
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:
				return getAcceptableDuration();
		}
		return super.eGet(featureID, resolve, coreType);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:
				setDirection((OperationalLimitDirectionKind)newValue);
				return;
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				getOperationalLimit().clear();
				getOperationalLimit().addAll((Collection<? extends OperationalLimit>)newValue);
				return;
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:
				setAcceptableDuration((Float)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:
				unsetDirection();
				return;
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				getOperationalLimit().clear();
				return;
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:
				unsetAcceptableDuration();
				return;
		}
		super.eUnset(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__DIRECTION:
				return isSetDirection();
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__OPERATIONAL_LIMIT:
				return operationalLimit != null && !operationalLimit.isEmpty();
			case OperationalLimitsPackage.OPERATIONAL_LIMIT_TYPE__ACCEPTABLE_DURATION:
				return isSetAcceptableDuration();
		}
		return super.eIsSet(featureID);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	public String toString() {
		if (eIsProxy()) return super.toString();

		StringBuffer result = new StringBuffer(super.toString());
		result.append(" (direction: ");
		if (directionESet) result.append(direction); else result.append("<unset>");
		result.append(", acceptableDuration: ");
		if (acceptableDurationESet) result.append(acceptableDuration); else result.append("<unset>");
		result.append(')');
		return result.toString();
	}

}
```


Overlapping Code:
```
nalLimitType extends IdentifiedObject {
/**
* The default value of the '{@link #getDirection() <em>Direction</em>}' attribute.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @see #getDirection()
* @generated
* @ordered
*/
protected static final OperationalLimitDirectionKind DIRECTION_EDEFAULT = OperationalLimitDirectionKind.LOW;
/**
* The cached value of the '{@link #getDirection() <em>Direction</em>}' attribute.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @see #getDirection()
* @generated
* @ordered
*/
protected OperationalLimitDirectionKind direction = DIRECTION_EDEFAULT;
/**
* This is true if the Direction attribute has been set.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @generated
* @ordered
*/
protected boolean directionESet;
/**
* The cached value of the '{@link #getOperationalLimit() <em>Operational Limit</em>}' reference list.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @see #getOperationalLimit()
* @generated
* @ordered
*/
protected EList<OperationalLimit> operationalLimit;
/**
* The default value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @see #getAcceptableDuration()
* @generated
* @ordered
*/
protected static final float ACCEPTABLE_DURATION_EDEFAULT = 0.0F;
/**
* The cached value of the '{@link #getAcceptableDuration() <em>Acceptable Duration</em>}' attribute.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @see #getAcceptableDuration()
* @generated
* @ordered
*/
protected float acceptableDuration = ACCEPTABLE_DURATION_EDEFAULT;
/**
* This is true if the Acceptable Duration attribute has been set.
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @generated
* @ordered
*/
protected boolean acceptableDurationESet;
/**
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @generated
*/
protected OperationalLimitType() {
super();
}
/**
* <!-- begin-user-doc -->
* <!-- end-user-doc -->
* @generated
*/
@Override
protected EClass eStaticClass() {
return OperationalLimitsPackage.Literals.OPERATIONAL_LIMIT_TYPE;
}
/**
* Returns the value of the '<em><b>Direction</b></em>' attribute.
* The literals are from the enumeration {@link CIM15.IEC61970.OperationalLimits.OperationalLimitDirectionKind}.
* <!-- begin-user-doc -->
* <p>
* If the meaning of the '<em>Dir
```
<Overlap Ratio: 0.9910409556313993>

---

--- 191 --
Question ID: dc861f96f26b009c1a139b0cb1b2c0f2ffc06848_0
Original Code:
```
public class RoboportRendering extends EntityRendererFactory {
	@Override
	public void createRenderers(Consumer<Renderer> register, WorldMap map, DataTable dataTable, BlueprintEntity entity,
			EntityPrototype prototype) {
		register.accept(RenderUtils.spriteRenderer(RenderUtils.getSpritesFromAnimation(prototype.lua().get("base")),
				entity, prototype));
		register.accept(RenderUtils.spriteRenderer(
				RenderUtils.getSpriteFromAnimation(prototype.lua().get("door_animation_down")), entity, prototype));
		register.accept(RenderUtils.spriteRenderer(
				RenderUtils.getSpriteFromAnimation(prototype.lua().get("door_animation_up")), entity, prototype));
	}
}
```


Overlapping Code:
```
ss RoboportRendering extends EntityRendererFactory {
@Override
public void createRenderers(Consumer<Renderer> register, WorldMap map, DataTable dataTable, BlueprintEntity entity,
EntityPrototype prototype) {
register.accept(RenderUtils.spriteRenderer(RenderUtils.getSpritesFromAnimation(prototype.lua().get("base")),
entity, prototype));
register.accept(RenderUtils.spriteRenderer(
RenderUtils.getSpriteFromAnimation(prototype.lua().get("door_animation_down")), entity, prototype));
register.accept(RenderUtils.spriteRenderer(
RenderUtils.getSpriteFromAnimation(prototype.lua().get("door_animation_up
```
<Overlap Ratio: 0.9389671361502347>

---

--- 192 --
Question ID: b8e83a39b33a7d415d7cd84878ffca2dcb3ebb56_0
Original Code:
```
final class CreateTableQueryImpl
    extends AbstractQuery<CreateTableQuery>
    implements CreateTableQuery {

  private boolean table = false;
  private boolean columns = false;

  CreateTableQueryImpl(
      @NotNull DialectProvider dialectProvider,
      @NotNull ConnectionSource connectionSource) {
    super(dialectProvider, connectionSource);

    this.builder.append("CREATE TABLE ");
  }

  @Override
  protected CreateTableQuery self() {
    return this;
  }

  @Override
  public CreateTableQuery table(@NotNull String table) {
    if (check()) {
      return this;
    }

    if (!this.table) {
      this.builder.append(" ").append(dialectProvider.protectValue(table));

      this.table = true;
    }
    return this;
  }

  @Override
  public CreateTableQuery ifNotExists() {
    if (check()) {
      return this;
    }

    if (!table) {
      this.builder.append("IF NOT EXISTS");
    }
    return this;
  }

  @Override
  public CreateTableQuery rawColumns(@NotNull String... columns) {
    if (check()) {
      return this;
    }

    if (!table) {
      return this;
    }

    final StringJoiner joiner = new StringJoiner(", ", " (", ")");

    for (final String column : columns) {
      joiner.add(column);
    }

    this.builder.append(joiner);

    this.columns = true;

    return this;
  }

  @Override
  public CreateTableQuery columns(@NotNull Iterable<? extends ColumnMeta> columnMeta) {
    if (check()) {
      return this;
    }

    if (!table) {
      return this;
    }

    final StringJoiner joiner = new StringJoiner(", ", " (", ")");

    for (final ColumnMeta meta : columnMeta) {
      joiner.add(dialectProvider.columnMetaToString(meta));
    }

    this.builder.append(joiner);

    columns = true;

    return this;
  }

  @Override
  protected boolean subQuerySupported(@NotNull Query<?> sub) {
    return false;
  }

  @Override
  protected boolean check() {
    return table && columns;
  }
}
```


Overlapping Code:
```
teTableQueryImpl
extends AbstractQuery<CreateTableQuery>
implements CreateTableQuery {
private boolean table = false;
private boolean columns = false;
CreateTableQueryImpl(
@NotNull DialectProvider dialectProvider,
@NotNull ConnectionSource connectionSource) {
super(dialectProvider, connectionSource);
this.builder.append("CREATE TABLE ");
}
@Override
protected CreateTableQuery self() {
return this;
}
@Override
public CreateTableQuery table(@NotNull String table) {
if (check()) {
return this;
}
if (!this.table) {
this.builder.append(" ").append(dialectProvider.protectValue(table));
this.table = true;
}
return this;
}
@Override
public CreateTableQuery ifNotExists() {
if (check()) {
return this;
}
if (!table) {
this.builder.append("IF NOT EXISTS");
}
return this;
}
@Override
public CreateTableQuery rawColumns(@NotNull String... columns) {
if (check()) {
return this;
}
if (!table) {
return this;
}
final StringJoiner joiner = new StringJoiner(", ", " (", ")");
for (final String column : columns) {
joiner.add(column);
}
this.builder.append(joiner);
this.columns = true;
return this;
}
@Override
public CreateTableQuery columns(@NotNull Iterable<? extends ColumnMeta> columnMeta) {
if (check()) {
return this;
}
if (!table) {
return this;
}
final StringJoiner joiner = new StringJoiner(", ", " (", ")");
for (final ColumnMeta meta : columnMeta) {
joiner.add(dialectProvider.columnMetaToString(meta));
}
this.builder.append(joiner);
columns = true;
return this;
}
@Override
protected boolean subQuerySupported(@NotNull Query<?> sub) {
return false;
}
@Override
protected boolean check() {
ret
```
<Overlap Ratio: 0.9750152346130408>

---

--- 193 --
Question ID: a2a24e9efd0b795da6aa78ab5f20c79a669ff65a_0
Original Code:
```
@State(Scope.Benchmark)
public class ParameterFormatterBenchmark {
    private static final Object[] ARGS = { "arg1", "arg2", "arg3", "arg4", "arg5", "arg6", "arg7", "arg8",
            "arg9", "arg10",};

    @State(Scope.Thread)
    public static class ThreadState {
        StringBuilder buffer = new StringBuilder(2048);
        int[] indices = new int[255];
        char[] copy = new char[4096];
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency3ParamsV3(final ThreadState state) {
        state.buffer.setLength(0);
        final String STR = "p1={}, p2={}, p3={}";
        final int length = STR.length();
        STR.getChars(0, length, state.copy, 0);
        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency5ParamsV3(final ThreadState state) {
        state.buffer.setLength(0);
        final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}";
        final int length = STR.length();
        STR.getChars(0, length, state.copy, 0);
        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency7ParamsV3(final ThreadState state) {
        state.buffer.setLength(0);
        final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}";
        final int length = STR.length();
        STR.getChars(0, length, state.copy, 0);
        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency9ParamsV3(final ThreadState state) {
        state.buffer.setLength(0);
        final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}";
        final int length = STR.length();
        STR.getChars(0, length, state.copy, 0);
        final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
        ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency3ParamsV2(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders2("p1={}, p2={}, p3={}", state.indices);
        ParameterFormatter.formatMessage2(state.buffer, "p1={}, p2={}, p3={}", ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency5ParamsV2(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders2("p1={}, p2={}, p3={}, p4={}, p5={}", state.indices);
        ParameterFormatter.formatMessage2(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}", ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency7ParamsV2(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders2("p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}", state.indices);
        ParameterFormatter.formatMessage2(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}", ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency9ParamsV2(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders2("p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}", state.indices);
        ParameterFormatter.formatMessage2(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}", ARGS, count, state.indices);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency3Params(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders("p1={}, p2={}, p3={}");
        ParameterFormatter.formatMessage(state.buffer, "p1={}, p2={}, p3={}", ARGS, count);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency5Params(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders("p1={}, p2={}, p3={}, p4={}, p5={}");
        ParameterFormatter.formatMessage(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}", ARGS, count);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency7Params(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders("p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}");
        ParameterFormatter.formatMessage(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}", ARGS, count);
        return state.buffer.length();
    }

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.NANOSECONDS)
    public int latency9Params(final ThreadState state) {
        state.buffer.setLength(0);
        final int count = ParameterFormatter.countArgumentPlaceholders("p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}");
        ParameterFormatter.formatMessage(state.buffer, "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={}, p9={}", ARGS, count);
        return state.buffer.length();
    }
}
```


Overlapping Code:
```
rFormatterBenchmark {
private static final Object[] ARGS = { "arg1", "arg2", "arg3", "arg4", "arg5", "arg6", "arg7", "arg8",
"arg9", "arg10",};
@State(Scope.Thread)
public static class ThreadState {
StringBuilder buffer = new StringBuilder(2048);
int[] indices = new int[255];
char[] copy = new char[4096];
}
@Benchmark
@BenchmarkMode(Mode.SampleTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public int latency3ParamsV3(final ThreadState state) {
state.buffer.setLength(0);
final String STR = "p1={}, p2={}, p3={}";
final int length = STR.length();
STR.getChars(0, length, state.copy, 0);
final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
return state.buffer.length();
}
@Benchmark
@BenchmarkMode(Mode.SampleTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public int latency5ParamsV3(final ThreadState state) {
state.buffer.setLength(0);
final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}";
final int length = STR.length();
STR.getChars(0, length, state.copy, 0);
final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
return state.buffer.length();
}
@Benchmark
@BenchmarkMode(Mode.SampleTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public int latency7ParamsV3(final ThreadState state) {
state.buffer.setLength(0);
final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}";
final int length = STR.length();
STR.getChars(0, length, state.copy, 0);
final int count = ParameterFormatter.countArgumentPlaceholders3(state.copy, length, state.indices);
ParameterFormatter.formatMessage3(state.buffer, state.copy, length, ARGS, count, state.indices);
return state.buffer.length();
}
@Benchmark
@BenchmarkMode(Mode.SampleTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public int latency9ParamsV3(final ThreadState state) {
state.buffer.setLength(0);
final String STR = "p1={}, p2={}, p3={}, p4={}, p5={}, p6={}, p7={}, p8={},
```
<Overlap Ratio: 0.9710078232857801>

---

--- 194 --
Question ID: e3312ea73716161dc23a3e1955fa1343fb8bc85b_0
Original Code:
```
@Getter
public class QueryRunner {

    static {
        try {
            Class.forName("com.aliyun.fastmodel.driver.client.FastModelEngineDriver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    private final Properties properties;

    public QueryRunner(Properties properties) {
        this.properties = properties;
    }

    public Connection getConnection() throws Exception {
        String url = properties.getProperty("url");
        boolean prefix = url.startsWith("jdbc:fastmodel");
        if (prefix) {
            return DriverManager.getConnection(url, properties);
        }
        return DriverManager.getConnection("jdbc:fastmodel://" + url, properties);
    }

    public QueryResult execute(String statement) throws SQLException {
        try (Connection connection = getConnection(); Statement statementObject = connection.createStatement()) {
            if (!DriverUtil.isSelect(statement)) {
                statementObject.executeUpdate(statement);
                return QueryResult.EMPTY;
            }
            ResultSet resultSet = statementObject.executeQuery(statement);
            if (resultSet == null) {
                return QueryResult.EMPTY;
            }
            ResultSetMetaData metaData = resultSet.getMetaData();
            List<DriverColumnInfo> columnInfo = toDriverColumn(metaData);
            List<DriverRow> rows = toRows(resultSet);
            return new QueryResult(
                columnInfo,
                rows
            );
        } catch (Exception e) {
            throw new SQLException("execute statement exception", e);
        }
    }

    private List<DriverRow> toRows(ResultSet resultSet) throws SQLException {
        List<DriverRow> driverRows = new ArrayList<>();
        while (resultSet.next()) {
            int columnCount = resultSet.getMetaData().getColumnCount();
            List<Object> list = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                list.add(resultSet.getObject(i));
            }
            DriverRow driverRow = new DriverRow(list);
            driverRows.add(driverRow);
        }
        return driverRows;
    }

    private List<DriverColumnInfo> toDriverColumn(ResultSetMetaData metaData) throws SQLException {
        int columnCount = metaData.getColumnCount();
        List<DriverColumnInfo> driverColumnInfo = new ArrayList<>();
        for (int i = 1; i <= columnCount; i++) {
            driverColumnInfo.add(
                new DriverColumnInfo(metaData.getColumnName(i), new DriverDataType(metaData.getColumnType(i))));
        }
        return driverColumnInfo;
    }
}
```


Overlapping Code:
```
yRunner {
static {
try {
Class.forName("com.aliyun.fastmodel.driver.client.FastModelEngineDriver");
} catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
private final Properties properties;
public QueryRunner(Properties properties) {
this.properties = properties;
}
public Connection getConnection() throws Exception {
String url = properties.getProperty("url");
boolean prefix = url.startsWith("jdbc:fastmodel");
if (prefix) {
return DriverManager.getConnection(url, properties);
}
return DriverManager.getConnection("jdbc:fastmodel://" + url, properties);
}
public QueryResult execute(String statement) throws SQLException {
try (Connection connection = getConnection(); Statement statementObject = connection.createStatement()) {
if (!DriverUtil.isSelect(statement)) {
statementObject.executeUpdate(statement);
return QueryResult.EMPTY;
}
ResultSet resultSet = statementObject.executeQuery(statement);
if (resultSet == null) {
return QueryResult.EMPTY;
}
ResultSetMetaData metaData = resultSet.getMetaData();
List<DriverColumnInfo> columnInfo = toDriverColumn(metaData);
List<DriverRow> rows = toRows(resultSet);
return new QueryResult(
columnInfo,
rows
);
} catch (Exception e) {
throw new SQLException("execute statement exception", e);
}
}
private List<DriverRow> toRows(ResultSet resultSet) throws SQLException {
List<DriverRow> driverRows = new ArrayList<>();
while (resultSet.next()) {
int columnCount = resultSet.getMetaData().getColumnCount();
List<Object> list = new ArrayList<>();
for (int i = 1; i <= columnCount; i++) {
list.add(resultSet.getObject(i));
}
DriverRow driverRow = new DriverRow(list);
driverRows.add(driverRow);
}
return driverRows;
}
private List<DriverColumnInfo> toDriverColumn(ResultSetMetaData metaData) throws SQLException {
int columnCount = metaData.getColumnCount();
List<DriverColumnInfo> driverColumnInfo = new ArrayList<>();
for (int i = 1; i <= columnCount; i++) 
```
<Overlap Ratio: 0.9866666666666667>

---

--- 195 --
Question ID: d16d165371c9cbdcbc0059c1d0464e5182d90ead_0
Original Code:
```
class UDTParserTest {

    @Test
    void test_null_or_empty() {
        Assertions.assertNull(UDTParser.parse(""));
        Assertions.assertNull(UDTParser.parse(null));
    }

    @Test
    void test_invalid_with_strict() {
        Assertions.assertThrows(IllegalArgumentException.class, () -> UDTParser.parse("abc"));
    }

    @Test
    void test_invalid_with_non_strict() {
        final String[] udt = UDTParser.parse("abc", false);
        Assertions.assertNotNull(udt);
        Assertions.assertEquals(1, udt.length);
        Assertions.assertEquals("abc", udt[0]);
    }

    @Test
    void test_without_quote() {
        final String[] udt = UDTParser.parse("(abc,123,xyz)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("abc", udt[0]);
        Assertions.assertEquals("123", udt[1]);
        Assertions.assertEquals("xyz", udt[2]);
    }

    @Test
    void test_null_item_in_first() {
        final String[] udt = UDTParser.parse("(,123,xyz)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("", udt[0]);
        Assertions.assertEquals("123", udt[1]);
        Assertions.assertEquals("xyz", udt[2]);
    }

    @Test
    void test_null_item_in_last() {
        final String[] udt = UDTParser.parse("(abc,123,)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("abc", udt[0]);
        Assertions.assertEquals("123", udt[1]);
        Assertions.assertEquals("", udt[2]);
    }

    @Test
    void test_null_item_between() {
        final String[] udt = UDTParser.parse("(abc,,xyz)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("abc", udt[0]);
        Assertions.assertEquals("", udt[1]);
        Assertions.assertEquals("xyz", udt[2]);
    }

    @Test
    void test_quote_first() {
        final String[] udt = UDTParser.parse("(\"s t h\",abc,t)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("s t h", udt[0]);
        Assertions.assertEquals("abc", udt[1]);
        Assertions.assertEquals("t", udt[2]);
    }

    @Test
    void test_quote_between() {
        final String[] udt = UDTParser.parse("(Anytown,\"Main St\",t)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("Anytown", udt[0]);
        Assertions.assertEquals("Main St", udt[1]);
        Assertions.assertEquals("t", udt[2]);
    }

    @Test
    void test_quote_last() {
        final String[] udt = UDTParser.parse("(abc,123,\"x y z\")");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("abc", udt[0]);
        Assertions.assertEquals("123", udt[1]);
        Assertions.assertEquals("x y z", udt[2]);
    }

    @Test
    void test_comma_in_quote() {
        final String[] udt = UDTParser.parse("(\"Any,town\",xyz,f)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("Any,town", udt[0]);
        Assertions.assertEquals("xyz", udt[1]);
        Assertions.assertEquals("f", udt[2]);
    }

    @Test
    void test_has_escaped_quote() {
        final String[] udt = UDTParser.parse("(Anytown,\"Main \"\" St\",t)");
        System.out.println(Arrays.toString(udt));
        Assertions.assertEquals(3, udt.length);
        Assertions.assertEquals("Anytown", udt[0]);
        Assertions.assertEquals("Main \" St", udt[1]);
        Assertions.assertEquals("t", udt[2]);
    }

}
```


Overlapping Code:
```
_or_empty() {
Assertions.assertNull(UDTParser.parse(""));
Assertions.assertNull(UDTParser.parse(null));
}
@Test
void test_invalid_with_strict() {
Assertions.assertThrows(IllegalArgumentException.class, () -> UDTParser.parse("abc"));
}
@Test
void test_invalid_with_non_strict() {
final String[] udt = UDTParser.parse("abc", false);
Assertions.assertNotNull(udt);
Assertions.assertEquals(1, udt.length);
Assertions.assertEquals("abc", udt[0]);
}
@Test
void test_without_quote() {
final String[] udt = UDTParser.parse("(abc,123,xyz)");
System.out.println(Arrays.toString(udt));
Assertions.assertEquals(3, udt.length);
Assertions.assertEquals("abc", udt[0]);
Assertions.assertEquals("123", udt[1]);
Assertions.assertEquals("xyz", udt[2]);
}
@Test
void test_null_item_in_first() {
final String[] udt = UDTParser.parse("(,123,xyz)");
System.out.println(Arrays.toString(udt));
Assertions.assertEquals(3, udt.length);
Assertions.assertEquals("", udt[0]);
Assertions.assertEquals("123", udt[1]);
Assertions.assertEquals("xyz", udt[2]);
}
@Test
void test_null_item_in_last() {
final String[] udt = UDTParser.parse("(abc,123,)");
System.out.println(Arrays.toString(udt));
Assertions.assertEquals(3, udt.length);
Assertions.assertEquals("abc", udt[0]);
Assertions.assertEquals("123", udt[1]);
Assertions.assertEquals("", udt[2]);
}
@Test
void test_null_item_between() {
final String[] udt = UDTParser.parse("(abc,,xyz)");
System.out.println(Arrays.toString(udt));
Assertions.assertEquals(3, udt.length);
Assertions.assertEquals("abc", udt[0]);
Assertions.assertEquals("", udt[1]);
Assertions.assertEquals("xyz", udt[2]);
}
@Test
void test_quote_first() {
final String[] udt = UDTParser.parse("(\"s t h\",abc,t)");
System.out.println(Arrays.toString(udt));
Assertions.assertEquals(3, udt.length);
Assertions.assertEquals("s t h", udt[0]);
Assertions.assertEquals("abc", udt[1]);
Assertions.assertEquals("t", udt[2]);
}
@Test
void test_quote_between() {
final String[] udt = UDTParser.parse("(Anytown,\"Main St\",t
```
<Overlap Ratio: 0.9643201542912246>

---

--- 196 --
Question ID: 2214f58d235e1e07260fcf8b252e03451c36e4c3_0
Original Code:
```
public class ObjectDetailsDatabaseBuilder {

    private static final String DEFAULT_TABLE_NAME = "ocfl_object_details";

    private boolean storeInventory;
    private long waitTime;
    private TimeUnit timeUnit;
    private DataSource dataSource;
    private String tableName;

    public ObjectDetailsDatabaseBuilder() {
        storeInventory = true;
        waitTime = 10;
        timeUnit = TimeUnit.SECONDS;
    }

    /**
     * If serialized inventories should be stored in the database. Default: true.
     *
     * @param storeInventory true if serialized inventories should be stored in the database.
     * @return builder
     */
    public ObjectDetailsDatabaseBuilder storeInventory(boolean storeInventory) {
        this.storeInventory = storeInventory;
        return this;
    }

    /**
     * Used to override the amount of time the client will wait to obtain a lock. Default: 10 seconds.
     *
     * @param waitTime wait time (MariaDB uses seconds, while PostgreSQL and H2 use milliseconds)
     * @param timeUnit unit of time
     * @return builder
     */
    public ObjectDetailsDatabaseBuilder waitTime(long waitTime, TimeUnit timeUnit) {
        this.waitTime = Enforce.expressionTrue(waitTime > 0, waitTime, "waitTime must be greater than 0");
        this.timeUnit = Enforce.notNull(timeUnit, "timeUnit cannot be null");
        return this;
    }

    /**
     * Sets the DataSource to use for the object details table. This is a required field.
     *
     * @param dataSource the DataSource
     * @return builder
     */
    public ObjectDetailsDatabaseBuilder dataSource(DataSource dataSource) {
        this.dataSource = Enforce.notNull(dataSource, "dataSource cannot be null");
        return this;
    }

    /**
     * Sets the name of the table to use to store object details. Default: ocfl_object_details
     *
     * @param tableName the table name to use
     * @return builder
     */
    public ObjectDetailsDatabaseBuilder tableName(String tableName) {
        this.tableName = tableName;
        return this;
    }

    /**
     * Constructs a new {@link ObjectDetailsDatabase} instance using the given dataSource. If the database does not
     * already contain an object details table, it attempts to create one.
     *
     * @return ObjectDetailsDatabase
     */
    public ObjectDetailsDatabase build() {
        Enforce.notNull(dataSource, "dataSource cannot be null");

        var resolvedTableName = tableName == null ? DEFAULT_TABLE_NAME : tableName;

        var dbType = DbType.fromDataSource(dataSource);
        ObjectDetailsDatabase database;

        switch (dbType) {
            case POSTGRES:
                database = new PostgresObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);
                break;
            case MARIADB:
                database = new MariaDbObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);
                break;
            case H2:
                database = new H2ObjectDetailsDatabase(resolvedTableName, dataSource, storeInventory, waitTime, timeUnit);
                break;
            default:
                throw new OcflJavaException(String.format("Database type %s is not mapped to an ObjectDetailsDatabase implementation.", dbType));
        }

        new TableCreator(dbType, dataSource).createObjectDetailsTable(resolvedTableName);

        return database;
    }

}
```


Overlapping Code:
```
lsDatabaseBuilder {
private static final String DEFAULT_TABLE_NAME = "ocfl_object_details";
private boolean storeInventory;
private long waitTime;
private TimeUnit timeUnit;
private DataSource dataSource;
private String tableName;
public ObjectDetailsDatabaseBuilder() {
storeInventory = true;
waitTime = 10;
timeUnit = TimeUnit.SECONDS;
}
/**
* If serialized inventories should be stored in the database. Default: true.
*
* @param storeInventory true if serialized inventories should be stored in the database.
* @return builder
*/
public ObjectDetailsDatabaseBuilder storeInventory(boolean storeInventory) {
this.storeInventory = storeInventory;
return this;
}
/**
* Used to override the amount of time the client will wait to obtain a lock. Default: 10 seconds.
*
* @param waitTime wait time (MariaDB uses seconds, while PostgreSQL and H2 use milliseconds)
* @param timeUnit unit of time
* @return builder
*/
public ObjectDetailsDatabaseBuilder waitTime(long waitTime, TimeUnit timeUnit) {
this.waitTime = Enforce.expressionTrue(waitTime > 0, waitTime, "waitTime must be greater than 0");
this.timeUnit = Enforce.notNull(timeUnit, "timeUnit cannot be null");
return this;
}
/**
* Sets the DataSource to use for the object details table. This is a required field.
*
* @param dataSource the DataSource
* @return builder
*/
public ObjectDetailsDatabaseBuilder dataSource(DataSource dataSource) {
this.dataSource = Enforce.notNull(dataSource, "dataSource cannot be null");
return this;
}
/**
* Sets the name of the table to use to store object details. Default: ocfl_object_details
*
* @param tableName the table name to use
* @return builder
*/
public ObjectDetailsDatabaseBuilder tableName(String tableName) {
this.tableName = tableName;
return this;
}
/**
* Constructs a new {@link ObjectDetailsDatabase} instance using the given dataSource. If the database does not
* already contain an object details table, it attempts to create one.
*
* @return ObjectDetailsDatabase
*/
public ObjectDetailsDatabase build() {
Enforce.notNull(dataSource, "dataSource cannot be null");
var resolvedTableName = tableName == null 
```
<Overlap Ratio: 0.9796201945345067>

---

--- 197 --
Question ID: 558dd50cbac15bc958917bfc817abee9cfe9c414_0
Original Code:
```
@RunWith(AndroidJUnit4.class)
public class CardedAwardListElementTest {

    private static final int WIDTH_DP = 400;
    private static final List<IAwardRecipient> SINGLE_TEAM = new ArrayList<>();
    private static final List<IAwardRecipient> MULTI_TEAM = new ArrayList<>();
    private static final List<IAwardRecipient> INDIVIDUAL = new ArrayList<>();
    private static final List<IAwardRecipient> INDIVIDUAL_NO_TEAM = new ArrayList<>();
    private static final List<IAwardRecipient> MULTI_INDIVIDUAL = new ArrayList<>();
    private static final Map<String, Team> TEAM_MAP = new HashMap<>();

    static {
        SINGLE_TEAM.add(buildWinnerDict(null, "frc1124"));
        MULTI_TEAM.add(buildWinnerDict(null, "frc1124"));
        MULTI_TEAM.add(buildWinnerDict(null, "frc254"));
        INDIVIDUAL.add(buildWinnerDict("Foo Bar", "frc1124"));
        INDIVIDUAL_NO_TEAM.add(buildWinnerDict("Foo Bar",  null));
        MULTI_INDIVIDUAL.add(buildWinnerDict("Foo Bar", "frc1124"));
        MULTI_INDIVIDUAL.add(buildWinnerDict("Foo Baz", "frc254"));

        Team team = ModelMaker.getModel(Team.class, "frc1124");
        TEAM_MAP.put("frc1124", team);
        TEAM_MAP.put("frc254", team);
    }

    @Test
    public void testRenderSingleTeam() {
        View view = getView(null, "Test Award", "2016test", SINGLE_TEAM, TEAM_MAP, null);
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    @Test
    public void testRenderSelectedTeam() {
        View view = getView(null, "Test Award", "2016test", SINGLE_TEAM, TEAM_MAP, "1124");
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    @Test
    public void testRenderMultiWinner() {
        View view = getView(null, "Test Award", "2016test", MULTI_TEAM, TEAM_MAP, null);
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    @Test
    public void testRenderIndividual() {
        View view = getView(null, "Test Award", "2016test", INDIVIDUAL, TEAM_MAP, null);
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    @Test
    public void testRenderIndividualNoTeam() {
        View view = getView(null, "Test Award", "2016test", INDIVIDUAL_NO_TEAM, TEAM_MAP, null);
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    @Test
    public void testRenderMultiIndividual() {
        View view = getView(null, "Test Award", "2016test", MULTI_INDIVIDUAL, TEAM_MAP, null);
        ViewHelpers.setupView(view)
                   .setExactWidthDp(WIDTH_DP)
                   .layout();

        Screenshot.snap(view)
                  .record();
    }

    private View getView(
            APICache datafeed,
            String name,
            String eventKey,
            List<IAwardRecipient> winners,
            Map<String, Team> teams,
            String selectedTeamKey) {
        CardedAwardListElement element = new CardedAwardListElement(datafeed, name, eventKey,
                                                                    winners, teams,
                                                                    selectedTeamKey);
        Context targetContext = InstrumentationRegistry.getTargetContext();
        LayoutInflater inflater = LayoutInflater.from(targetContext);
        return element.getView(targetContext, inflater, null);
    }

    private static IAwardRecipient buildWinnerDict(String awardee, String teamKey) {
        Award.AwardRecipient winner = new Award.AwardRecipient();
        if (awardee != null) winner.setAwardee(awardee);
        if (teamKey != null) winner.setTeamKey(teamKey);
        return winner;
    }
}
```


Overlapping Code:
```
.class)
public class CardedAwardListElementTest {
private static final int WIDTH_DP = 400;
private static final List<IAwardRecipient> SINGLE_TEAM = new ArrayList<>();
private static final List<IAwardRecipient> MULTI_TEAM = new ArrayList<>();
private static final List<IAwardRecipient> INDIVIDUAL = new ArrayList<>();
private static final List<IAwardRecipient> INDIVIDUAL_NO_TEAM = new ArrayList<>();
private static final List<IAwardRecipient> MULTI_INDIVIDUAL = new ArrayList<>();
private static final Map<String, Team> TEAM_MAP = new HashMap<>();
static {
SINGLE_TEAM.add(buildWinnerDict(null, "frc1124"));
MULTI_TEAM.add(buildWinnerDict(null, "frc1124"));
MULTI_TEAM.add(buildWinnerDict(null, "frc254"));
INDIVIDUAL.add(buildWinnerDict("Foo Bar", "frc1124"));
INDIVIDUAL_NO_TEAM.add(buildWinnerDict("Foo Bar", null));
MULTI_INDIVIDUAL.add(buildWinnerDict("Foo Bar", "frc1124"));
MULTI_INDIVIDUAL.add(buildWinnerDict("Foo Baz", "frc254"));
Team team = ModelMaker.getModel(Team.class, "frc1124");
TEAM_MAP.put("frc1124", team);
TEAM_MAP.put("frc254", team);
}
@Test
public void testRenderSingleTeam() {
View view = getView(null, "Test Award", "2016test", SINGLE_TEAM, TEAM_MAP, null);
ViewHelpers.setupView(view)
.setExactWidthDp(WIDTH_DP)
.layout();
Screenshot.snap(view)
.record();
}
@Test
public void testRenderSelectedTeam() {
View view = getView(null, "Test Award", "2016test", SINGLE_TEAM, TEAM_MAP, "1124");
ViewHelpers.setupView(view)
.setExactWidthDp(WIDTH_DP)
.layout();
Screenshot.snap(view)
.record();
}
@Test
public void testRenderMultiWinner() {
View view = getView(null, "Test Award", "2016test", MULTI_TEAM, TEAM_MAP, null);
ViewHelpers.setupView(view)
.setExactWidthDp(WIDTH_DP)
.layout();
Screenshot.snap(view)
.record();
}
@Test
public void testRenderIndividual() {
View view = getView(null, "Test Award", "2016test", INDIVIDUAL, TEAM_MAP, null);
ViewHelpers.setupView(view)
.setExactWidthDp(WIDTH_DP)
.layout();
Screenshot.snap(view)
.record();
}
@Test
```
<Overlap Ratio: 0.9889669007021064>

---

--- 198 --
Question ID: 7124b9148d4f342734f761ba76dcf05a467ac969_0
Original Code:
```
@APICommand(name = "stopVirtualMachine", group = APICommandGroup.VirtualMachineService, responseObject = UserVmResponse.class, description = "Stops a virtual machine.", responseView = ResponseView
        .Full, entityType =
        {VirtualMachine.class},
        requestHasSensitiveInfo = false, responseHasSensitiveInfo = true)
public class StopVMCmdByAdmin extends StopVMCmd {
    public static final Logger s_logger = LoggerFactory.getLogger(StopVMCmdByAdmin.class.getName());

    @Override
    public void execute() throws ServerApiException, ConcurrentOperationException {
        CallContext.current().setEventDetails("Vm Id: " + getId());
        final UserVm result;

        result = _userVmService.stopVirtualMachine(getId(), isForced());

        if (result != null) {
            final UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", result).get(0);
            response.setResponseName(getCommandName());
            setResponseObject(response);
        } else {
            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to stop vm");
        }
    }
}
```


Overlapping Code:
```
VirtualMachine", group = APICommandGroup.VirtualMachineService, responseObject = UserVmResponse.class, description = "Stops a virtual machine.", responseView = ResponseView
.Full, entityType =
{VirtualMachine.class},
requestHasSensitiveInfo = false, responseHasSensitiveInfo = true)
public class StopVMCmdByAdmin extends StopVMCmd {
public static final Logger s_logger = LoggerFactory.getLogger(StopVMCmdByAdmin.class.getName());
@Override
public void execute() throws ServerApiException, ConcurrentOperationException {
CallContext.current().setEventDetails("Vm Id: " + getId());
final UserVm result;
result = _userVmService.stopVirtualMachine(getId(), isForced());
if (result != null) {
final UserVmResponse response = _responseGenerator.createUserVmResponse(ResponseView.Full, "virtualmachine", result).get(0);
response.setResponseName(getCommandName());
setResponseObject(response);
} else {
throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, "Failed to s
```
<Overlap Ratio: 0.9611553784860558>

---

--- 199 --
Question ID: f4943d7420777c94e74d1fa22194380d253cac60_0
Original Code:
```
public class AbsenceNoticeFilter implements Predicate<AbsenceNoticeRow> {
	
	private final Locale locale;
	private final String searchString;
	private final List<UserPropertyHandler> userPropertyHandlers;
	
	public AbsenceNoticeFilter(String searchString, List<UserPropertyHandler> userPropertyHandlers, Locale locale) {
		this.searchString = searchString.toLowerCase();
		this.userPropertyHandlers = userPropertyHandlers;
		this.locale = locale;
	}
	
	@Override
	public boolean test(AbsenceNoticeRow row) {
		List<RepositoryEntry> entries = row.getEntriesList();
		if(entries != null && !entries.isEmpty()) {
			for(RepositoryEntry entry:entries) {
				if(FilterHelper.test(entry, searchString)) {
					return true;
				}
			}
		}
		
		List<LectureBlock> lectureBlocks = row.getLectureBlocks();
		if(lectureBlocks != null && !lectureBlocks.isEmpty()) {
			for(LectureBlock lectureBlock:lectureBlocks) {
				if(FilterHelper.test(lectureBlock, searchString)) {
					return true;
				}
			}
		}
		
		List<Identity> teachers = row.getTeachers();
		if(teachers != null && !teachers.isEmpty()) {
			for(Identity teacher:teachers) {
				if(FilterHelper.test(teacher, searchString)) {
					return true;
				}
			}
		}
		
		return FilterHelper.test(row.getAbsentIdentity().getUser(), searchString, userPropertyHandlers, locale);
	}
}
```


Overlapping Code:
```
ter implements Predicate<AbsenceNoticeRow> {

private final Locale locale;
private final String searchString;
private final List<UserPropertyHandler> userPropertyHandlers;

public AbsenceNoticeFilter(String searchString, List<UserPropertyHandler> userPropertyHandlers, Locale locale) {
this.searchString = searchString.toLowerCase();
this.userPropertyHandlers = userPropertyHandlers;
this.locale = locale;
}

@Override
public boolean test(AbsenceNoticeRow row) {
List<RepositoryEntry> entries = row.getEntriesList();
if(entries != null && !entries.isEmpty()) {
for(RepositoryEntry entry:entries) {
if(FilterHelper.test(entry, searchString)) {
return true;
}
}
}

List<LectureBlock> lectureBlocks = row.getLectureBlocks();
if(lectureBlocks != null && !lectureBlocks.isEmpty()) {
for(LectureBlock lectureBlock:lectureBlocks) {
if(FilterHelper.test(lectureBlock, searchString)) {
return true;
}
}
}

List<Identity> teachers = row.getTeachers();
if(teachers != null && !teachers.isEmpty()) {
for(Identity teacher:teachers) {
if(FilterHelper.test(teacher, searchString)) {
return true;
}
}
}

return FilterHelper.test(row.getAbsentIdentity().getUser(), se
```
<Overlap Ratio: 0.9387755102040817>

---

--- 200 --
Question ID: dea97423645a8ac4ca94f6bc34c067a7e48224d6_0
Original Code:
```
public class CompressingFileAppender<E> extends UnsynchronizedAppenderBase<E> {

  protected Encoder<E> encoder;

  private FileAppender<E> fileAppender;

  protected boolean append = true;

  protected String fileName = null;

  private boolean prudent = false;

  private int bufferSize = 1024000;

  private String compressAlgo = CompressorStreamFactory.getGzip();

  public Encoder<E> getEncoder() {
    return encoder;
  }

  public void setEncoder(Encoder<E> encoder) {
    this.encoder = encoder;
  }

  public boolean isPrudent() {
    return prudent;
  }

  public void setPrudent(boolean prudent) {
    this.prudent = prudent;
  }

  public void setAppend(boolean append) {
    this.append = append;
  }

  public void setFile(String file) {
    fileName = file;
  }

  public boolean isAppend() {
    return append;
  }

  public String getFile() {
    return fileName;
  }

  public int getBufferSize() {
    return bufferSize;
  }

  public void setBufferSize(int bufferSize) {
    this.bufferSize = bufferSize;
  }

  public String getCompressAlgo() {
    return compressAlgo;
  }

  public void setCompressAlgo(String compressAlgo) {
    this.compressAlgo = compressAlgo;
  }

  @Override
  public void start() {
    fileAppender = new FileAppender<>();
    fileAppender.setContext(getContext());
    fileAppender.setFile(getFile());
    fileAppender.setImmediateFlush(false);
    fileAppender.setPrudent(isPrudent());
    fileAppender.setAppend(isAppend());
    fileAppender.setName(name + "-embedded-file");

    CompressingEncoder<E> compressedEncoder = createCompressingEncoder(getEncoder());
    fileAppender.setEncoder(compressedEncoder);
    fileAppender.start();

    super.start();
  }

  public void stop() {
    fileAppender.stop();
    super.stop();
  }

  @Override
  protected void append(E eventObject) {
    fileAppender.doAppend(eventObject);
  }

  protected CompressingEncoder<E> createCompressingEncoder(Encoder<E> e) {
    int bufferSize = getBufferSize();
    String compressAlgo = getCompressAlgo();

    CompressorStreamFactory factory = CompressorStreamFactory.getSingleton();
    Set<String> names = factory.getOutputStreamCompressorNames();
    if (names.contains(getCompressAlgo())) {
      try {
        return new CompressingEncoder<>(e, compressAlgo, factory, bufferSize);
      } catch (CompressorException ex) {
        throw new RuntimeException("Cannot create CompressingEncoder", ex);
      }
    } else {
      throw new RuntimeException("No such compression algorithm: " + compressAlgo);
    }
  }
}
```


Overlapping Code:
```
Appender<E> extends UnsynchronizedAppenderBase<E> {
protected Encoder<E> encoder;
private FileAppender<E> fileAppender;
protected boolean append = true;
protected String fileName = null;
private boolean prudent = false;
private int bufferSize = 1024000;
private String compressAlgo = CompressorStreamFactory.getGzip();
public Encoder<E> getEncoder() {
return encoder;
}
public void setEncoder(Encoder<E> encoder) {
this.encoder = encoder;
}
public boolean isPrudent() {
return prudent;
}
public void setPrudent(boolean prudent) {
this.prudent = prudent;
}
public void setAppend(boolean append) {
this.append = append;
}
public void setFile(String file) {
fileName = file;
}
public boolean isAppend() {
return append;
}
public String getFile() {
return fileName;
}
public int getBufferSize() {
return bufferSize;
}
public void setBufferSize(int bufferSize) {
this.bufferSize = bufferSize;
}
public String getCompressAlgo() {
return compressAlgo;
}
public void setCompressAlgo(String compressAlgo) {
this.compressAlgo = compressAlgo;
}
@Override
public void start() {
fileAppender = new FileAppender<>();
fileAppender.setContext(getContext());
fileAppender.setFile(getFile());
fileAppender.setImmediateFlush(false);
fileAppender.setPrudent(isPrudent());
fileAppender.setAppend(isAppend());
fileAppender.setName(name + "-embedded-file");
CompressingEncoder<E> compressedEncoder = createCompressingEncoder(getEncoder());
fileAppender.setEncoder(compressedEncoder);
fileAppender.start();
super.start();
}
public void stop() {
fileAppender.stop();
super.stop();
}
@Override
protected void append(E eventObject) {
fileAppender.doAppend(eventObject);
}
protected CompressingEncoder<E> createCompressingEncoder(Encoder<E> e) {
int bufferSize = getBufferSize();
String compressAlgo = getCompressAlgo();
CompressorStreamFactory factory = CompressorStreamFactory.getSingleton();
Set<String> names = factory.getOutputStreamCompressorNames();
if (names.contains(getCompressAlgo())) {
try {
return new CompressingEncoder<>(e, compressAlgo, factory, bufferSize);
} catch (CompressorException ex) {
throw new RuntimeException("Cannot create CompressingEncoder", ex);
}
} else {
throw new RuntimeException
```
<Overlap Ratio: 0.983363309352518>

---

--- 201 --
Question ID: e0edbf6b466ab1df46c252e987057131b79cde73_0
Original Code:
```
public class EncryptedPrivateKeyInfo
    extends ASN1Encodable
{
    private AlgorithmIdentifier algId;
    private ASN1OctetString     data;

    public EncryptedPrivateKeyInfo(
        ASN1Sequence  seq)
    {
        Enumeration e = seq.getObjects();

        algId = AlgorithmIdentifier.getInstance(e.nextElement());
        data = (ASN1OctetString)e.nextElement();
    }

    public EncryptedPrivateKeyInfo(
        AlgorithmIdentifier algId,
        byte[]              encoding)
    {
        this.algId = algId;
        this.data = new DEROctetString(encoding);
    }

    public static EncryptedPrivateKeyInfo getInstance(
        Object  obj)
    {
        if (obj instanceof EncryptedData)
        {
            return (EncryptedPrivateKeyInfo)obj;
        }
        else if (obj instanceof ASN1Sequence)
        { 
            return new EncryptedPrivateKeyInfo((ASN1Sequence)obj);
        }

        throw new IllegalArgumentException("unknown object in factory: " + obj.getClass().getName());
    }
    
    public AlgorithmIdentifier getEncryptionAlgorithm()
    {
        return algId;
    }

    public byte[] getEncryptedData()
    {
        return data.getOctets();
    }

    /**
     * Produce an object suitable for an ASN1OutputStream.
     * <pre>
     * EncryptedPrivateKeyInfo ::= SEQUENCE {
     *      encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
     *      encryptedData EncryptedData
     * }
     *
     * EncryptedData ::= OCTET STRING
     *
     * KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
     *          ... -- For local profiles
     * }
     * </pre>
     */
    public DERObject toASN1Object()
    {
        ASN1EncodableVector v = new ASN1EncodableVector();

        v.add(algId);
        v.add(data);

        return new DERSequence(v);
    }
}
```


Overlapping Code:
```
c class EncryptedPrivateKeyInfo
extends ASN1Encodable
{
private AlgorithmIdentifier algId;
private ASN1OctetString data;
public EncryptedPrivateKeyInfo(
ASN1Sequence seq)
{
Enumeration e = seq.getObjects();
algId = AlgorithmIdentifier.getInstance(e.nextElement());
data = (ASN1OctetString)e.nextElement();
}
public EncryptedPrivateKeyInfo(
AlgorithmIdentifier algId,
byte[] encoding)
{
this.algId = algId;
this.data = new DEROctetString(encoding);
}
public static EncryptedPrivateKeyInfo getInstance(
Object obj)
{
if (obj instanceof EncryptedData)
{
return (EncryptedPrivateKeyInfo)obj;
}
else if (obj instanceof ASN1Sequence)
{ 
return new EncryptedPrivateKeyInfo((ASN1Sequence)obj);
}
throw new IllegalArgumentException("unknown object in factory: " + obj.getClass().getName());
}

public AlgorithmIdentifier getEncryptionAlgorithm()
{
return algId;
}
public byte[] getEncryptedData()
{
return data.getOctets();
}
/**
* Produce an object suitable for an ASN1OutputStream.
* <pre>
* EncryptedPrivateKeyInfo ::= SEQUENCE {
* encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
* encryptedData EncryptedData
* }
*
* EncryptedData ::= OCTET STRING
*
* KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
* ... -- For local profiles
* }
* </pre>
*/
public DERObject toASN1Object()
{
ASN1EncodableVector v = new ASN1EncodableVector();
v.add(algId);
v.add(data);
return new DERSequen
```
<Overlap Ratio: 0.9893617021276596>

---

--- 202 --
Question ID: ffc0f4bff0919baaeb33a8f2ded0d3b6c4233a46_0
Original Code:
```
public abstract class AbstractMySqlHibernateConfiguration extends AbstractHibernateConfiguration {

  public static final String DRIVER_CLASS_MYSQL = "com.mysql.jdbc.Driver";
  public static final String DIALECT_MYSQL = "org.hibernate.dialect.MySQL5InnoDBDialect";

  @Bean
  @Override
  public DataSource dataSource() {
    return buildDataSource(DRIVER_CLASS_MYSQL,
        "jdbc:mysql://localhost/" + getDatabaseName(),
        "root",
        "root");
  }

  @Override
  public Properties hibernateProperties() {
    Properties props = super.hibernateProperties();
    props.put(Environment.DIALECT, DIALECT_MYSQL);
    return props;
  }

}
```


Overlapping Code:
```
tract class AbstractMySqlHibernateConfiguration extends AbstractHibernateConfiguration {
public static final String DRIVER_CLASS_MYSQL = "com.mysql.jdbc.Driver";
public static final String DIALECT_MYSQL = "org.hibernate.dialect.MySQL5InnoDBDialect";
@Bean
@Override
public DataSource dataSource() {
return buildDataSource(DRIVER_CLASS_MYSQL,
"jdbc:mysql://localhost/" + getDatabaseName(),
"root",
"root");
}
@Override
public Properties hibernateProperties() {
Properties props = super.hibernateProperties();
props.put(Environment.DIALECT, DIALECT_MYS
```
<Overlap Ratio: 0.9450171821305842>

---

--- 203 --
Question ID: 15ad78e5472a8c012961055bbc9a24c9d8373779_0
Original Code:
```
class LanguagesHighlightsLayer extends AbstractHighlightsContainer {

    private Document document;
    
    LanguagesHighlightsLayer (Document document) {
        this.document = document;
    }

    public HighlightsSequence getHighlights (int startOffset, int endOffset) {
        TokenSequence seq = TokenHierarchy.get (document).tokenSequence();
        if (seq != null) {
            return new Highlights (seq, startOffset, endOffset); //NOI18N
        } else {
            return HighlightsSequence.EMPTY;
        }
    }

    
    private static class Highlights implements HighlightsSequence {

        private int                 endOffset;
        private int                 startOffset1;
        private int                 endOffset1;
        private SimpleAttributeSet  attributeSet;
        private TokenSequence       tokenSequence;
        private String              mimeType;
        
        
        private Highlights (TokenSequence tokenSequence, int startOffset, int endOffset) {
            this.tokenSequence = tokenSequence;
            this.mimeType = tokenSequence.language().mimeType();
            this.endOffset = endOffset;
            startOffset1 = startOffset;
            endOffset1 = startOffset;
        }
        
        public boolean moveNext () {
            if (tokenSequence == null) return false;
            attributeSet = new SimpleAttributeSet ();
            do {
                startOffset1 = endOffset1;
                mark (tokenSequence);
                if (endOffset1 > startOffset1) return true;
                tokenSequence.move (startOffset1);
                if (!tokenSequence.moveNext ()) return false;
                Token token = tokenSequence.token ();
                endOffset1 = tokenSequence.offset () + token.length ();
            } while (endOffset1 < endOffset);
            return false;
        }

        public int getStartOffset () {
            return startOffset1;
        }

        public int getEndOffset () {
            return endOffset1;
        }

        public AttributeSet getAttributes () {
            return attributeSet;
        }

        private void mark (TokenSequence ts) {
            ts.move (startOffset1);
            if (!ts.moveNext ()) return;
            Token token = ts.token ();
            TokenSequence ts2 = ts.embedded ();
            if (ts2 == null) return;
            String mimeTypeOut = ts.language ().mimeType ();
            String mimeTypeIn = ts2.language ().mimeType ();
            if (token.id ().name ().equals (SLexer.EMBEDDING_TOKEN_TYPE_NAME)) {
                Color c = getPreprocessorImportsColor (mimeTypeIn);
                if (c != null) {
                    attributeSet.addAttribute (StyleConstants.Background, c);
                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);
                    endOffset1 = tokenSequence.offset () + token.length ();
                }
            } else
            if (!mimeTypeOut.equals (mimeTypeIn)) {
                Color c = getTokenImportsColor (mimeTypeOut, mimeTypeIn, token.id ().name ());
                if (c != null) {
                    attributeSet.addAttribute (StyleConstants.Background, c);
                    attributeSet.addAttribute (HighlightsContainer.ATTR_EXTENDS_EOL, Boolean.TRUE);
                    endOffset1 = tokenSequence.offset () + token.length ();
                }
            }
            mark (ts2);
        }

        private Map<String,Map<String,Color>> tokenImportColors = new HashMap<String,Map<String,Color>> ();

        private Color getPreprocessorImportsColor (String mimeTypeIn) {
            if (preprocessorImportColors == null) {
                preprocessorImportColors = new HashMap<String,Color> ();
                try {
                    Language l = LanguagesManager.getDefault ().
                        getLanguage (mimeType);
                    Feature properties = l.getPreprocessorImport ();
                    if (properties != null) {
                        String mimeType = (String) properties.getValue ("mimeType");
                        Color color = ColorsManager.readColor (
                            (String) properties.getValue ("background_color")
                        );
                        if (color != null)
                            preprocessorImportColors.put (mimeType, color);
                    }
                } catch (ParseException ex) {
                }
            }
            return preprocessorImportColors.get (mimeTypeIn);
        }

        private Map<String,Color> preprocessorImportColors;

        private Color getTokenImportsColor (String mimeTypeOut, String mimeTypeIn, String tokenTypeIn) {
            Map<String,Color> m = tokenImportColors.get (mimeTypeOut);
            if (m == null) {
                m = new HashMap<String,Color> ();
                tokenImportColors.put (mimeTypeOut, m);
                try {
                    Language l = LanguagesManager.getDefault ().
                        getLanguage (mimeTypeOut);
                    Map<String,Feature> m2 = l.getTokenImports ();
                    Iterator<String> it = m2.keySet ().iterator ();
                    while (it.hasNext ()) {
                        String tokenType = it.next ();
                        Feature properties = m2.get (tokenType);
                        Color color = ColorsManager.readColor (
                            (String) properties.getValue ("background_color")
                        );
                        if (color != null)
                            m.put (tokenType, color);
                    }
                } catch (LanguageDefinitionNotFoundException ex) {
                }
            }
            if (m.containsKey (tokenTypeIn))
                return m.get (tokenTypeIn);
            return m.get (mimeTypeIn);
        }
    }
}
```


Overlapping Code:
```
actHighlightsContainer {
private Document document;

LanguagesHighlightsLayer (Document document) {
this.document = document;
}
public HighlightsSequence getHighlights (int startOffset, int endOffset) {
TokenSequence seq = TokenHierarchy.get (document).tokenSequence();
if (seq != null) {
return new Highlights (seq, startOffset, endOffset); //NOI18N
} else {
return HighlightsSequence.EMPTY;
}
}

private static class Highlights implements HighlightsSequence {
private int endOffset;
private int startOffset1;
private int endOffset1;
private SimpleAttributeSet attributeSet;
private TokenSequence tokenSequence;
private String mimeType;


private Highlights (TokenSequence tokenSequence, int startOffset, int endOffset) {
this.tokenSequence = tokenSequence;
this.mimeType = tokenSequence.language().mimeType();
this.endOffset = endOffset;
startOffset1 = startOffset;
endOffset1 = startOffset;
}

public boolean moveNext () {
if (tokenSequence == null) return false;
attributeSet = new SimpleAttributeSet ();
do {
startOffset1 = endOffset1;
mark (tokenSequence);
if (endOffset1 > startOffset1) return true;
tokenSequence.move (startOffset1);
if (!tokenSequence.moveNext ()) return false;
Token token = tokenSequence.token ();
endOffset1 = tokenSequence.offset () + token.length ();
} while (endOffset1 < endOffset);
return false;
}
public int getStartOffset () {
return startOffset1;
}
public int getEndOffset () {
return endOffset1;
}
public AttributeSet getAttributes () {
return attributeSet;
}
private void mark (TokenSequence ts) {
ts.move (startOffset1);
if (!ts.moveNext ()) return;
Token token = ts.token ();
TokenSequence ts2 = ts.embedded ();
if (ts2 == null) return;
String mimeTypeOut = ts.language ().mimeType ();
String mimeTypeIn = ts2
```
<Overlap Ratio: 0.9641873278236914>

---

--- 204 --
Question ID: 6ab2417f171d4242db1b03f6d94cfa2645c9dac2_0
Original Code:
```
public class SimilarityDisambiguator extends Disambiguator {

    public static final int DEFAULT_NUM_CANDIDATES = 5;
    protected final PhraseAnalyzer phraseAnalyzer;
    private int numCandidates = DEFAULT_NUM_CANDIDATES;
    private Language language;

    /**
     * Algorithms for disambiguating similar phrases
     */
    public static enum Criteria {
        SUM,         // select senses with highest sum of popularity + similarity
        PRODUCT,     // select senses with highest sum of popularity * similarity
        POPULARITY,  // select most popular senses
        SIMILARITY   // select most similar senses
    }

    // Method for disambiguating similar phrases
    private Criteria criteria = Criteria.SUM;

    private final SRMetric metric;

    public SimilarityDisambiguator(PhraseAnalyzer phraseAnalyzer, SRMetric metric) {
        this.phraseAnalyzer = phraseAnalyzer;
        this.metric = metric;
        this.language = metric.getLanguage();
    }

    @Override
    public List<LinkedHashMap<LocalId, Float>> disambiguate(List<LocalString> phrases, Set<LocalString> context) throws DaoException {
        List<LinkedHashMap<LocalId, Float>> results = new ArrayList<LinkedHashMap<LocalId, Float>>();

        List<LocalString> allPhrases = new ArrayList<LocalString>(
                (context == null) ? phrases : CollectionUtils.union(phrases, context));

        // Step 0: calculate most frequent candidate senses for each phrase
        Map<LocalString, LinkedHashMap<LocalId, Float>> candidates = Maps.newHashMap();
        for (LocalString s : allPhrases) {
            candidates.put(s, phraseAnalyzer.resolve(s.getLanguage(), s.getString(), numCandidates));
        }

        // Skip using the sr metric at all!
        if (criteria == Criteria.POPULARITY) {
            for (LocalString phrase : phrases) {
                LinkedHashMap<LocalId, Float> m = new LinkedHashMap<LocalId, Float>();
                for (LocalId li : candidates.get(phrase).keySet()) {
                    m.put(li, candidates.get(phrase).get(li));
                }
                results.add(m);
            }
            return results;
        }

        // Step 2: calculate the sum of cosimilarities for each page
        Map<LocalId, Float> pageSims = getCosimilaritySums(candidates);

        // Step 3: multiply background probability by sim sums, choose best product
        List<LinkedHashMap<LocalId, Float>> result = new ArrayList<LinkedHashMap<LocalId, Float>>();
        for (LocalString ls : phrases) {
            Map<LocalId, Float> phraseCands = candidates.get(ls);
            LinkedHashMap<LocalId, Float> pageResult = selectFinalPhraseSenses(pageSims, phraseCands);
            result.add(pageResult);
        }
        return result;
    }

    private LinkedHashMap<LocalId, Float> selectFinalPhraseSenses(Map<LocalId, Float> pageSims, Map<LocalId, Float> phrasePops) {
        if (phrasePops == null || phrasePops.isEmpty()) {
            return null;
        }
        double sum = 0.0;
        for (LocalId lp : phrasePops.keySet()) {
            float pop = phrasePops.get(lp);
            float sim =  pageSims.get(lp);

            float score;
            switch (criteria) {
                case POPULARITY:
                    score = pop;
                    break;
                case SIMILARITY:
                    score = sim;
                    break;
                case SUM:
                    score = pop + sim;
                    break;
                case PRODUCT:
                    score = pop * sim;
                    break;
                default:
                    throw new IllegalStateException();
            }

            phrasePops.put(lp, score);
            sum += score;
        }
        LinkedHashMap<LocalId, Float> pageResult = new LinkedHashMap<LocalId, Float>();
        for (LocalId key : WpCollectionUtils.sortMapKeys(phrasePops, true)) {
            pageResult.put(key, (float)(phrasePops.get(key) / sum));
        }
        return pageResult;
    }

    /**
     * Return the sum of cosimilarity scores for all unique pages among the candidates.
     * @param candidates
     * @return
     * @throws DaoException
     */
    private Map<LocalId, Float> getCosimilaritySums(Map<LocalString, LinkedHashMap<LocalId, Float>> candidates) throws DaoException {
    	
        // Step 1: compute the page cosimilarity matrix
        Set<LocalId> uniques = new HashSet<LocalId>();
        for (LinkedHashMap<LocalId, Float> prob : candidates.values()) {
            uniques.addAll(prob.keySet());
        }
        List<LocalId> pages = new ArrayList<LocalId>(uniques);
        double[][] cosim;

        if (pages.isEmpty()){
            cosim = new double[0][0];
        } else {
            if (!pages.get(0).getLanguage().equals(language)) {
                throw new DaoException("Expected language " + language + ", found " +  pages.get(0).getLanguage());
            }
            int[] pageIds = new int[pages.size()];
            for (int i=0; i<pages.size(); i++){
                pageIds[i] = pages.get(i).getId();
            }
            cosim = metric.cosimilarity(pageIds);
        }

        // Step 2: calculate the sum of cosimilarities for each page
        Map<LocalId, Float> pageSims = new HashMap<LocalId, Float>();
        for (int i = 0; i < pages.size(); i++) {
            double sum = 0.0;
            for (int j = 0; j < pages.size(); j++) {
                if (i != j && WbMathUtils.isReal(cosim[i][j])) {
                    sum += Math.max(0, cosim[i][j]);    // Hack: no negative numbers
                }
            }
            // add 0.0001 to give every candidate a tiny chance and avoid divide by zero errors when there are no good options
            pageSims.put(pages.get(i), (float)(sum + 0.0001));
        }
        return pageSims;
    }

    public Criteria getCriteria() {
        return criteria;
    }

    public void setCriteria(Criteria criteria) {
        this.criteria = criteria;
    }

    public int getNumCandidates() {
        return numCandidates;
    }

    public void setNumCandidates(int numCandidates) {
        this.numCandidates = numCandidates;
    }

    public static class Provider extends org.wikibrain.conf.Provider<Disambiguator>{
        public Provider(Configurator configurator, Configuration config) throws ConfigurationException {
            super(configurator,config);
        }

        @Override
        public Class getType(){
            return Disambiguator.class;
        }

        @Override
        public String getPath(){
            return "sr.disambig";
        }

        @Override
        public Disambiguator get(String name, Config config, Map<String, String> runtimeParams) throws ConfigurationException{
            if (!config.getString("type").equals("similarity")){
                return null;
            }

            if (runtimeParams == null || !runtimeParams.containsKey("language")){
                throw new IllegalArgumentException("SimpleMilneWitten requires 'language' runtime parameter.");
            }
            Language lang = Language.getByLangCode(runtimeParams.get("language"));

            PhraseAnalyzer pa = getConfigurator().get(PhraseAnalyzer.class, config.getString("phraseAnalyzer"));

            // Create override config for sr metric and load it.
            String srName = config.getString("metric");
            Config newConfig = getConfig().get().getConfig("sr.metric.local." + srName)
                    .withValue("disambiguator", ConfigValueFactory.fromAnyRef("topResult"));
            Map<String, String> srRuntimeParams = new HashMap<String, String>();
            srRuntimeParams.put("language", lang.getLangCode());
            SRMetric sr = getConfigurator().construct(SRMetric.class, srName, newConfig, srRuntimeParams);

            SimilarityDisambiguator dab = new SimilarityDisambiguator(pa, sr);
            if (config.hasPath("criteria")) {
                dab.setCriteria(Criteria.valueOf(config.getString("criteria").toUpperCase()));
            }
            return dab;
        }
    }
}
```


Overlapping Code:
```
mbiguator extends Disambiguator {
public static final int DEFAULT_NUM_CANDIDATES = 5;
protected final PhraseAnalyzer phraseAnalyzer;
private int numCandidates = DEFAULT_NUM_CANDIDATES;
private Language language;
/**
* Algorithms for disambiguating similar phrases
*/
public static enum Criteria {
SUM, // select senses with highest sum of popularity + similarity
PRODUCT, // select senses with highest sum of popularity * similarity
POPULARITY, // select most popular senses
SIMILARITY // select most similar senses
}
// Method for disambiguating similar phrases
private Criteria criteria = Criteria.SUM;
private final SRMetric metric;
public SimilarityDisambiguator(PhraseAnalyzer phraseAnalyzer, SRMetric metric) {
this.phraseAnalyzer = phraseAnalyzer;
this.metric = metric;
this.language = metric.getLanguage();
}
@Override
public List<LinkedHashMap<LocalId, Float>> disambiguate(List<LocalString> phrases, Set<LocalString> context) throws DaoException {
List<LinkedHashMap<LocalId, Float>> results = new ArrayList<LinkedHashMap<LocalId, Float>>();
List<LocalString> allPhrases = new ArrayList<LocalString>(
(context == null) ? phrases : CollectionUtils.union(phrases, context));
// Step 0: calculate most frequent candidate senses for each phrase
Map<LocalString, LinkedHashMap<LocalId, Float>> candidates = Maps.newHashMap();
for (LocalString s : allPhrases) {
candidates.put(s, phraseAnalyzer.resolve(s.getLanguage(), s.getString(), numCandidates));
}
// Skip using the sr metric at all!
if (criteria == Criteria.POPULARITY) {
for (LocalString phrase : phrases) {
LinkedHashMap<LocalId, Float> m = new LinkedHashMap<LocalId, Float>();
for (LocalId li : candidates.get(phrase).keySet()) {
m.put(li, candidates.get(phrase).get(li));
}
results.add(m);
}
return results;
}
// Step 2: calculate the sum of cosimilarities for each page
Map<LocalId, Float> pageSims = getCosimilaritySums(candidates);
// Step 3: multiply background probability by sim sums, choose best product
List<LinkedHashMap<LocalId, Float>> result = new ArrayList<LinkedHashMap<LocalId,
```
<Overlap Ratio: 0.9818615751789976>

---

--- 205 --
Question ID: 57ab2cf796f1e9e3cceff028ee71776a2ac2d440_0
Original Code:
```
@RestController
@RequestMapping("/clientes")
public class ControleCliente {

    private final DaoCliente dao;

    public ControleCliente(DaoCliente dao) {
        this.dao = dao;
    }

    @GetMapping
    public List<Cliente> getClientes() {
        return dao.findAll();
    }

    @GetMapping("/{id}")
    public Cliente getCliente(@PathVariable Long id) {
        return dao.findById(id).orElseThrow(RuntimeException::new);
    }

    @PostMapping
    public ResponseEntity createCliente(@RequestBody Cliente client) throws URISyntaxException {
        Cliente savedClient = dao.save(client);
        return ResponseEntity.created(new URI("/clients/" + savedClient.getId())).body(savedClient);
    }

    @PutMapping("/{id}")
    public ResponseEntity updateCliente(@PathVariable Long id, @RequestBody Cliente client) {
        Cliente currentClient = dao.findById(id).orElseThrow(RuntimeException::new);
        currentClient.setName(client.getName());
        currentClient.setEmail(client.getEmail());
        currentClient = dao.save(client);

        return ResponseEntity.ok(currentClient);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity deleteCliente(@PathVariable Long id) {
        dao.deleteById(id);
        return ResponseEntity.ok().build();
    }
}
```


Overlapping Code:
```
@RestController
@RequestMapping("/clientes")
public class ControleCliente {
private final DaoCliente dao;
public ControleCliente(DaoCliente dao) {
this.dao = dao;
}
@GetMapping
public List<Cliente> getClientes() {
return dao.findAll();
}
@GetMapping("/{id}")
public Cliente getCliente(@PathVariable Long id) {
return dao.findById(id).orElseThrow(RuntimeException::new);
}
@PostMapping
public ResponseEntity createCliente(@RequestBody Cliente client) throws URISyntaxException {
Cliente savedClient = dao.save(client);
return ResponseEntity.created(new URI("/clients/" + savedClient.getId())).body(savedClient);
}
@PutMapping("/{id}")
public ResponseEntity updateCliente(@PathVariable Long id, @RequestBody Cliente client) {
Cliente currentClient = dao.findById(id).orElseThrow(RuntimeException::new);
currentClient.setName(client.getName());
currentClient.setEmail(client.getEmail());
currentClient = dao.save(client);
return ResponseEntity.ok(currentClient);
}
@DeleteMapping("/{id}")
public ResponseEntity deleteCliente(@PathVariable Long id) {
dao.deleteById(id);
return ResponseEntity.ok().build();
}
}
```
<Overlap Ratio: 1.0>

---

--- 206 --
Question ID: c55147ed1c6bd71ff454f0c5a6482b20027e7707_0
Original Code:
```
public class ElementFieldDecorator extends DefaultFieldDecorator {

	public ElementFieldDecorator(ElementLocatorFactory factory) {
		super(factory);
	}
	
	@Override
	protected boolean isDecoratableList(Field field) {
	    if (!List.class.isAssignableFrom(field.getType())) {
	      return false;
	    }

	    // Type erasure in Java isn't complete. Attempt to discover the generic
	    // type of the list.
	    Type genericType = field.getGenericType();
	    if (!(genericType instanceof ParameterizedType)) {
	      return false;
	    }

	    Type listType = ((ParameterizedType) genericType).getActualTypeArguments()[0];

	    if (!WebElement.class.equals(listType)) {
	      return false;
	    }

	    if (field.getAnnotation(FindElementBy.class) == null &&
	    	field.getAnnotation(FindBy.class) == null &&
	        field.getAnnotation(FindBys.class) == null &&
	        field.getAnnotation(FindAll.class) == null) {
	      return false;
	    }

	    return true;
	  }

}
```


Overlapping Code:
```
ieldDecorator extends DefaultFieldDecorator {
public ElementFieldDecorator(ElementLocatorFactory factory) {
super(factory);
}

@Override
protected boolean isDecoratableList(Field field) {
if (!List.class.isAssignableFrom(field.getType())) {
return false;
}
// Type erasure in Java isn't complete. Attempt to discover the generic
// type of the list.
Type genericType = field.getGenericType();
if (!(genericType instanceof ParameterizedType)) {
return false;
}
Type listType = ((ParameterizedType) genericType).getActualTypeArguments()[0];
if (!WebElement.class.equals(listType)) {
return false;
}
if (field.getAnnotation(FindElementBy.class) == null &&
field.getAnnotation(FindBy.class) == null &&
field.getAnnotation(FindBys.class) == null &&
field.getAnnotation(FindAll.class) == null) {
return false;
}
re
```
<Overlap Ratio: 0.9584816132858838>

---

--- 207 --
Question ID: d553a9664836aa1644d0c7c667efc465ebb88599_0
Original Code:
```
public class ShowCommand extends Command {

    public static final String COMMAND_WORD = "show";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List all potential teammates.";

    public static final String MESSAGE_SUCCESS = "Listed your potential teammate(s)!";

    @Override
    public CommandResult execute(Model model) {
        requireNonNull(model);
        model.updateDisplayPersonList(PREDICATE_SHOW_POTENTIAL_TEAMMATES);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```


Overlapping Code:
```
lic class ShowCommand extends Command {
public static final String COMMAND_WORD = "show";
public static final String MESSAGE_USAGE = COMMAND_WORD + ": List all potential teammates.";
public static final String MESSAGE_SUCCESS = "Listed your potential teammate(s)!";
@Override
public CommandResult execute(Model model) {
requireNonNull(model);
model.updateDisplayPersonList(PREDICATE_SHOW_POTENTIAL_TEAMMATES);
return new CommandResult(MESSAGE_SUCCESS);
}
}
```
<Overlap Ratio: 0.9934640522875817>

---

--- 208 --
Question ID: 330058bcf9f3666d677a4d46192e73844525de95_0
Original Code:
```
@ExtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class GetAuctionsIntegrationTest extends AbstractIntegrationTest {

    private PostgreSQLContainer postgres;
    private AuctionsRepository auctionsRepository;
    private BidsRepository bidsRepository;
    Vertx vertx;

    @BeforeAll
    public void beforeAll(VertxTestContext testContext) throws Throwable {
        this.postgres = new PostgreSQLContainer("postgres:12.6");
        this.vertx = Vertx.vertx();

        deployServerAndClient(postgres, this.vertx, testContext, new ApiVerticle());

        SqlConnectionManager connectionManager = new SqlConnectionManager(this.postgres.getJdbcUrl(), this.postgres.getUsername(), this.postgres.getPassword());
        this.auctionsRepository = new AuctionsRepository(connectionManager);
        this.bidsRepository = new BidsRepository(connectionManager);
    }
    @AfterAll
    public void afterAll(VertxTestContext testContext) {
        this.vertx.close(testContext.completing());
        this.postgres.close();
    }

    @Test
    public void getAuctionsTest(VertxTestContext testContext) throws SQLException {
        @Var Auction auction = testAuctionObject(1);
        Auction newAuction1 = auctionsRepository.createComplete(auction);
        auction = testAuctionObject(2);
        Auction newAuction2 = auctionsRepository.createComplete(auction);

        webClient.get(9005, "localhost", "/v1/auctions/")
                .as(BodyCodec.buffer())
                .send(testContext.succeeding(response -> testContext.verify(() -> {
                    assertNotNull(response);
                    JsonArray body = new JsonArray(response.body());
                    assertNotNull(body);
                    assertEquals(2, body.size());
                    verifyAuction(newAuction1, body.getJsonObject(0));
                    verifyAuction(newAuction2, body.getJsonObject(1));

                    auctionsRepository.deleteAllAuctions();
                    testContext.completeNow();
                })));
    }

    @Test
    public void getPendingAuctionsTest(VertxTestContext testContext) throws SQLException {
        getAuction(testContext,  "/v1/pendingauctions/", Auction.PENDING, 2);
    }

    @Test
    public void getActiveAuctionsTest(VertxTestContext testContext) throws SQLException {
        getAuction(testContext,  "/v1/activeauctions/", Auction.ACTIVE, 1);
    }

    @Test
    public void getClosedAuctionsTest(VertxTestContext testContext) throws SQLException {
        getAuction(testContext,  "/v1/closedauctions/", Auction.CLOSED, 1);
    }

    @Test
    public void getEndedAuctionsTest(VertxTestContext testContext) throws SQLException {
        getAuction(testContext,  "/v1/endedauctions/", Auction.ENDED, 1);
    }

    @Test
    public void getAuctionReserveNotMet(VertxTestContext testContext) throws SQLException {
        // reserve not met auction
        @Var Auction auction = testAuctionObject(1);
        auction.setWinningbid(0L);
        auction.setReserve(5L);
        auction = auctionsRepository.createComplete(auction);

        Bid bid = testBidObject(1, auction.getId());
        bid.setStatus("Bid below reserve");
        bidsRepository.add(bid);

        // reserve met auction
        Auction newAuction = testAuctionObject(2);
        newAuction.setWinningbid(2L);
        newAuction.setReserve(0L);
        auctionsRepository.createComplete(newAuction);

        Auction finalAuction = auction;
        webClient.get(9005, "localhost", "/v1/reservenotmetauctions")
                .as(BodyCodec.buffer())
                .send(testContext.succeeding(response -> testContext.verify(() -> {
                    assertNotNull(response);
                    JsonArray body = new JsonArray(response.body());
                    assertNotNull(body);
                    assertEquals(1, body.size());
                    verifyAuction(finalAuction, body.getJsonObject(0));

                    bidsRepository.deleteAllBids();
                    auctionsRepository.deleteAllAuctions();
                    testContext.completeNow();
                })));
    }

  @Test
  public void getAuctionSold(VertxTestContext testContext) throws SQLException {
    // reserve met auction
    Auction auction = testAuctionObject(1);
    auction.setStatus(Auction.ENDED);
    auction.setWinningbid(6L);
    auction.setReserve(5L);
    auctionsRepository.createComplete(auction);
    // ended not sold
    Auction newAuction = testAuctionObject(2);
    newAuction.setWinningbid(0L);
    newAuction.setReserve(0L);
    newAuction.setStatus(Auction.ENDED);
    auctionsRepository.createComplete(newAuction);
    // ended below reserve
    Auction newAuction2 = testAuctionObject(3);
    newAuction2.setWinningbid(1L);
    newAuction2.setReserve(5L);
    newAuction2.setStatus(Auction.ENDED);
    auctionsRepository.createComplete(newAuction2);

    webClient.get(9005, "localhost", "/v1/soldauctions")
            .as(BodyCodec.buffer())
            .send(testContext.succeeding(response -> testContext.verify(() -> {
              assertNotNull(response);
              JsonArray body = new JsonArray(response.body());
              assertNotNull(body);
              assertEquals(1, body.size());
              verifyAuction(auction, body.getJsonObject(0));

              auctionsRepository.deleteAllAuctions();
              testContext.completeNow();
            })));
  }

  public void getAuction(VertxTestContext testContext, String url, String status, int expectedCount) throws SQLException {
        Auction auction = testAuctionObject(1);
        auctionsRepository.createComplete(auction);
        @Var Auction newAuction = testAuctionObject(2);
        newAuction.setStatus(status);
        newAuction = auctionsRepository.createComplete(newAuction);

        Auction finalNewAuction = newAuction;
        webClient.get(9005, "localhost", url)
                .as(BodyCodec.buffer())
                .send(testContext.succeeding(response -> testContext.verify(() -> {
                    assertNotNull(response);
                    JsonArray body = new JsonArray(response.body());
                    assertNotNull(body);
                    assertEquals(expectedCount, body.size());
                    verifyAuction(finalNewAuction, body.getJsonObject(expectedCount - 1));

                    auctionsRepository.deleteAllAuctions();
                    testContext.completeNow();
                })));
    }
}
```


Overlapping Code:
```
xtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class GetAuctionsIntegrationTest extends AbstractIntegrationTest {
private PostgreSQLContainer postgres;
private AuctionsRepository auctionsRepository;
private BidsRepository bidsRepository;
Vertx vertx;
@BeforeAll
public void beforeAll(VertxTestContext testContext) throws Throwable {
this.postgres = new PostgreSQLContainer("postgres:12.6");
this.vertx = Vertx.vertx();
deployServerAndClient(postgres, this.vertx, testContext, new ApiVerticle());
SqlConnectionManager connectionManager = new SqlConnectionManager(this.postgres.getJdbcUrl(), this.postgres.getUsername(), this.postgres.getPassword());
this.auctionsRepository = new AuctionsRepository(connectionManager);
this.bidsRepository = new BidsRepository(connectionManager);
}
@AfterAll
public void afterAll(VertxTestContext testContext) {
this.vertx.close(testContext.completing());
this.postgres.close();
}
@Test
public void getAuctionsTest(VertxTestContext testContext) throws SQLException {
@Var Auction auction = testAuctionObject(1);
Auction newAuction1 = auctionsRepository.createComplete(auction);
auction = testAuctionObject(2);
Auction newAuction2 = auctionsRepository.createComplete(auction);
webClient.get(9005, "localhost", "/v1/auctions/")
.as(BodyCodec.buffer())
.send(testContext.succeeding(response -> testContext.verify(() -> {
assertNotNull(response);
JsonArray body = new JsonArray(response.body());
assertNotNull(body);
assertEquals(2, body.size());
verifyAuction(newAuction1, body.getJsonObject(0));
verifyAuction(newAuction2, body.getJsonObject(1));
auctionsRepository.deleteAllAuctions();
testContext.completeNow();
})));
}
@Test
public void getPendingAuctionsTest(VertxTestContext testContext) throws SQLException {
getAuction(testContext, "/v1/pendingauctions/", Auction.PENDING, 2);
}
@Test
public void getActiveAuctionsTest(VertxTestContext testContext) throws SQLException {
getAuction(testContext, "/v1/activeauctions/", Auction.ACTIVE, 1);
}
@Test
public void getClosedAuctionsTest(VertxTe
```
<Overlap Ratio: 0.9946987951807229>

---

--- 209 --
Question ID: 36158a59483bf5c1c163ec629f05c240b02810ec_0
Original Code:
```
public class AuthSession {
    public static String USERNAME, PASSWORD, HWID;
    public static String I_USERNAME, I_PASSWORD, I_HWID;

    public static void entry() {
        ConfigUtils configUtils = new ConfigUtils("auth", "");
        USERNAME = (String)configUtils.get("u");
        PASSWORD = (String)configUtils.get("p");
        HWID = "NOHWID";
        try {
            String fullHWID = System.getenv("COMPUTERNAME") + System.getProperty("user.name") + System.getenv("PROCESSOR_IDENTIFIER") + System.getenv("PROCESSOR_LEVEL");
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(fullHWID.getBytes());

            StringBuffer buffer = new StringBuffer();

            byte[] md5Bytes = md5.digest();
            for (byte md5Byte : md5Bytes) {
                String hex = Integer.toHexString(0xff & md5Byte);
                buffer.append(hex.length() == 1 ? '0' : hex);
            }
            HWID = "HWID!!" + buffer.toString();
        } catch (Exception exception) {}

        I_USERNAME = StringEscapeUtils.escapeHtml4(USERNAME);
        I_PASSWORD = StringEscapeUtils.escapeHtml4(PASSWORD);
        I_HWID = StringEscapeUtils.escapeHtml4(HWID);
    }
}
```


Overlapping Code:
```
blic static String USERNAME, PASSWORD, HWID;
public static String I_USERNAME, I_PASSWORD, I_HWID;
public static void entry() {
ConfigUtils configUtils = new ConfigUtils("auth", "");
USERNAME = (String)configUtils.get("u");
PASSWORD = (String)configUtils.get("p");
HWID = "NOHWID";
try {
String fullHWID = System.getenv("COMPUTERNAME") + System.getProperty("user.name") + System.getenv("PROCESSOR_IDENTIFIER") + System.getenv("PROCESSOR_LEVEL");
MessageDigest md5 = MessageDigest.getInstance("MD5");
md5.update(fullHWID.getBytes());
StringBuffer buffer = new StringBuffer();
byte[] md5Bytes = md5.digest();
for (byte md5Byte : md5Bytes) {
String hex = Integer.toHexString(0xff & md5Byte);
buffer.append(hex.length() == 1 ? '0' : hex);
}
HWID = "HWID!!" + buffer.toString();
} catch (Exception exception) {}
I_USERNAME = StringEscapeUtils.escapeHtml4(USERNAME);
I_PASSWORD = StringEscapeUtils.escapeHtml4(PASSWORD);
I_HWID = StringEscapeUtils.escapeHtm
```
<Overlap Ratio: 0.9576612903225806>

---

--- 210 --
Question ID: 7311e333513f8c6ace3fdd627d1fe78c7302ae3c_0
Original Code:
```
@ApiModel(description = "Set of fields along with symbol is mandatory to update the date.")
@JsonPropertyOrder({
  InlineObject3.JSON_PROPERTY_DATA
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class InlineObject3 implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_DATA = "data";
  private java.util.List<Object> data = null;

  public InlineObject3() { 
  }

  public InlineObject3 data(java.util.List<Object> data) {
    this.data = data;
    return this;
  }

  public InlineObject3 addDataItem(Object dataItem) {
    if (this.data == null) {
      this.data = new java.util.ArrayList<>();
    }
    this.data.add(dataItem);
    return this;
  }

   /**
   * date has to be provide in case 3d OFDB with date and atleast one iterative field
   * @return data
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "[{\"symbol\":\"FACTSET\",\"field1\":\"VALUE\"}]", value = "date has to be provide in case 3d OFDB with date and atleast one iterative field")
  @JsonProperty(JSON_PROPERTY_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.List<Object> getData() {
    return data;
  }


  @JsonProperty(JSON_PROPERTY_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setData(java.util.List<Object> data) {
    this.data = data;
  }


  /**
   * Return true if this inline_object_3 object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineObject3 inlineObject3 = (InlineObject3) o;
    return Objects.equals(this.data, inlineObject3.data);
  }

  @Override
  public int hashCode() {
    return Objects.hash(data);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineObject3 {\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
```


Overlapping Code:
```
description = "Set of fields along with symbol is mandatory to update the date.")
@JsonPropertyOrder({
InlineObject3.JSON_PROPERTY_DATA
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class InlineObject3 implements Serializable {
private static final long serialVersionUID = 1L;
public static final String JSON_PROPERTY_DATA = "data";
private java.util.List<Object> data = null;
public InlineObject3() { 
}
public InlineObject3 data(java.util.List<Object> data) {
this.data = data;
return this;
}
public InlineObject3 addDataItem(Object dataItem) {
if (this.data == null) {
this.data = new java.util.ArrayList<>();
}
this.data.add(dataItem);
return this;
}
/**
* date has to be provide in case 3d OFDB with date and atleast one iterative field
* @return data
**/
@javax.annotation.Nullable
@ApiModelProperty(example = "[{\"symbol\":\"FACTSET\",\"field1\":\"VALUE\"}]", value = "date has to be provide in case 3d OFDB with date and atleast one iterative field")
@JsonProperty(JSON_PROPERTY_DATA)
@JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
public java.util.List<Object> getData() {
return data;
}
@JsonProperty(JSON_PROPERTY_DATA)
@JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
public void setData(java.util.List<Object> data) {
this.data = data;
}
/**
* Return true if this inline_object_3 object is equal to o.
*/
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
InlineObject3 inlineObject3 = (InlineObject3) o;
return Objects.equals(this.data, inlineObject3.data);
}
@Override
public int hashCode() {
return Objects.hash(data);
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class InlineObject3 {\n");
sb.append(" data: ").append(toIndentedString(data)).append("\n");
sb.append("}");
return sb.toString();
}
/**
* Convert the given object to string with each line indented by 4 spaces
* (except the first line).
*/
private String toIndentedString(Object o) {
if (o == null) {
return "null";
}
return o.toString().replace("\n", "\n ");
}
}
```
<Overlap Ratio: 0.9953617810760668>

---

--- 211 --
Question ID: 166edaf948f37cbd4f574618f7512af0d99665b1_0
Original Code:
```
@WithTags({@WithTag("testType:Integration")})
@SuppressWarnings("unchecked")
class RetrieveRegionDetailsIntegrationTest extends LrdAuthorizationEnabledIntegrationTest {

    public static final String HTTP_STATUS = "http_status";

    List<LrdRegionResponse> expectedListAll = List.of(
        new LrdRegionResponse(new Region("1", "National", null)),
        new LrdRegionResponse(new Region("2", "London", null)),
        new LrdRegionResponse(new Region("3", "Midlands", null)),
        new LrdRegionResponse(new Region("4", "North East", null)),
        new LrdRegionResponse(new Region("5", "North West", null)),
        new LrdRegionResponse(new Region("6", "South East", null)),
        new LrdRegionResponse(new Region("7", "South West", null)),
        new LrdRegionResponse(new Region("8", "Wales", null)),
        new LrdRegionResponse(new Region("9", "Scotland", null))
    );

    @Test
    void returnsRegionDetailsByDescriptionWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsByDescription("London", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerification(response, 1);
    }

    @Test
    void returnsRegionDetailsByDescriptionsWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsByDescription("London, Midlands", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerification(response, 2);
    }

    @Test
    void returnsRegionDetailsByDescriptionCaseInsensitiveWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsByDescription("LoNdOn", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerification(response, 1);
    }

    @Test
    void returnsRegionDetailsByIdWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsById("2", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerification(response, 1);
    }

    @Test
    void returnsRegionDetailsByIdsWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsById("2, 3", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerification(response, 2);
    }

    @Test
    void returnsRegionDetailsByIdAllWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsById("ALL", LrdRegionResponse[].class);

        assertNotNull(response);
        responseVerificationForAll(response, expectedListAll);
    }

    @Test
    void returnsRegionDetailsById1AndAllWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsById("1, ALL", LrdRegionResponse[].class);

        assertNotNull(response);
        assertEquals(9, response.size());
        assertEquals("1", response.get(0).getRegionId());
        assertEquals("National", response.get(0).getDescription());
        assertNull(response.get(0).getWelshDescription());
    }

    @Test
    void returnsRegionDetailsNoParamWithStatusCode_200() throws JsonProcessingException {

        List<LrdRegionResponse> response = (List<LrdRegionResponse>)
            lrdApiClient.findRegionDetailsById("", LrdRegionResponse[].class);

        assertNotNull(response);
        assertEquals(8, response.size());
    }

    @Test
    void doesNotReturnRegionDetailsByInvalidDescriptionWithStatusCode_404() throws JsonProcessingException {

        Map<String, Object> errorResponseMap = (Map<String, Object>)
            lrdApiClient.findRegionDetailsByDescription("Invalid Description", ErrorResponse.class);


        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.NOT_FOUND);
    }

    @Test
    void doesNotReturnRegionByInvalidDescriptionSpecialCharWithStatusCode_400() throws JsonProcessingException {

        Map<String, Object> errorResponseMap = (Map<String, Object>)
            lrdApiClient.findRegionDetailsByDescription("Lo£nd*on", ErrorResponse.class);


        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);
    }

    @Test
    void doesNotReturnRegionByInvalidIdnSpecialCharWithStatusCode_400() throws JsonProcessingException {

        Map<String, Object> errorResponseMap = (Map<String, Object>)
            lrdApiClient.findRegionDetailsByDescription("1*", ErrorResponse.class);


        assertThat(errorResponseMap).containsEntry(HTTP_STATUS, HttpStatus.BAD_REQUEST);
    }

    private void responseVerification(List<LrdRegionResponse> response, int expectedRegions) {
        assertThat(response.size()).isEqualTo(expectedRegions);
        assertThat(response.get(0).getRegionId()).isEqualTo("2");
        assertThat(response.get(0).getDescription()).isEqualTo("London");
        assertThat(response.get(0).getWelshDescription()).isNull();
        if (expectedRegions == 2) {
            assertThat(response.get(1).getRegionId()).isEqualTo("3");
            assertThat(response.get(1).getDescription()).isEqualTo("Midlands");
            assertThat(response.get(1).getWelshDescription()).isNull();
        }
    }

    private void responseVerificationForAll(List<LrdRegionResponse> actual, List<LrdRegionResponse> expected) {
        assertThat(actual).hasSize(expected.size()).usingRecursiveComparison().isEqualTo(expected);
    }

}
```


Overlapping Code:
```
gs({@WithTag("testType:Integration")})
@SuppressWarnings("unchecked")
class RetrieveRegionDetailsIntegrationTest extends LrdAuthorizationEnabledIntegrationTest {
public static final String HTTP_STATUS = "http_status";
List<LrdRegionResponse> expectedListAll = List.of(
new LrdRegionResponse(new Region("1", "National", null)),
new LrdRegionResponse(new Region("2", "London", null)),
new LrdRegionResponse(new Region("3", "Midlands", null)),
new LrdRegionResponse(new Region("4", "North East", null)),
new LrdRegionResponse(new Region("5", "North West", null)),
new LrdRegionResponse(new Region("6", "South East", null)),
new LrdRegionResponse(new Region("7", "South West", null)),
new LrdRegionResponse(new Region("8", "Wales", null)),
new LrdRegionResponse(new Region("9", "Scotland", null))
);
@Test
void returnsRegionDetailsByDescriptionWithStatusCode_200() throws JsonProcessingException {
List<LrdRegionResponse> response = (List<LrdRegionResponse>)
lrdApiClient.findRegionDetailsByDescription("London", LrdRegionResponse[].class);
assertNotNull(response);
responseVerification(response, 1);
}
@Test
void returnsRegionDetailsByDescriptionsWithStatusCode_200() throws JsonProcessingException {
List<LrdRegionResponse> response = (List<LrdRegionResponse>)
lrdApiClient.findRegionDetailsByDescription("London, Midlands", LrdRegionResponse[].class);
assertNotNull(response);
responseVerification(response, 2);
}
@Test
void returnsRegionDetailsByDescriptionCaseInsensitiveWithStatusCode_200() throws JsonProcessingException {
List<LrdRegionResponse> response = (List<LrdRegionResponse>)
lrdApiClient.findRegionDetailsByDescription("LoNdOn", LrdRegionResponse[].class);
assertNotNull(response);
responseVerification(response, 1);
}
@Test
void returnsRegionDetailsByIdWithStatusCode_200() throws JsonProcessingException {
List<LrdRegionResponse> response = (List<LrdRegionResponse>)
lrdApiClient.findRegionDetailsById("2", LrdRegionResponse[].class);
assertNotNull(response);
responseVerification(response, 1);
}
@Test
void returnsRegionDetailsByIdsWithStatusCode_200() throws JsonProcessingException {
List<LrdRegionResponse> response = (List<LrdRegionResponse>)
lrdApi
```
<Overlap Ratio: 0.9949518127581459>

---

--- 212 --
Question ID: c53ce38df7a8663c294ef37cb2b3a837ded1c9f8_0
Original Code:
```
public class OutputBlacklistDao extends DatabaseObjectDao<OutputBlacklist> {
    
    private static final Logger logger = LoggerFactory.getLogger(OutputBlacklistDao.class.getName());
    
    private final String tableName_ = "OUTPUT_BLACKLIST";
    
    public OutputBlacklistDao(){}
            
    public OutputBlacklistDao(boolean closeConnectionAfterOperation) {
        databaseInterface_.setCloseConnectionAfterOperation(closeConnectionAfterOperation);
    }
    
    public OutputBlacklistDao(DatabaseInterface databaseInterface) {
        super(databaseInterface);
    }
    
    public boolean dropTable() {
        return dropTable(OutputBlacklistSql.DropTable_OutputBlacklist);
    }
    
    public boolean createTable() {
        List<String> databaseCreationSqlStatements = new ArrayList<>();
        
        if (DatabaseConfiguration.getType() == DatabaseConfiguration.MYSQL) {
            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_MySQL);
        }
        else {
            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_Derby);
            databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_PrimaryKey);
        }
        
        databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_ForeignKey_MetricGroupId);

        return createTable(databaseCreationSqlStatements);
    }
    
    @Override
    public OutputBlacklist getDatabaseObject(OutputBlacklist outputBlacklist) {
        if (outputBlacklist == null) {
            databaseInterface_.cleanupAutomatic();
            return null;
        }
        
        return getDatabaseObject(OutputBlacklistSql.Select_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); 
    }
    
    @Override
    public boolean insert(OutputBlacklist outputBlacklist) {
        if (outputBlacklist == null) {
            databaseInterface_.cleanupAutomatic();
            return false;
        }
        
        return insert(OutputBlacklistSql.Insert_OutputBlacklist, outputBlacklist.getMetricGroupId());
    }
    
    @Override
    public boolean update(OutputBlacklist outputBlacklist) {
        if (outputBlacklist == null) {
            databaseInterface_.cleanupAutomatic();
            return false;
        }
        
        return update(OutputBlacklistSql.Update_OutputBlacklist_ByPrimaryKey, outputBlacklist.getMetricGroupId(), outputBlacklist.getId());
    }

    @Override
    public boolean delete(OutputBlacklist outputBlacklist) {
        if (outputBlacklist == null) {
            databaseInterface_.cleanupAutomatic();
            return false;
        }
        
        return delete(OutputBlacklistSql.Delete_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); 
    }
    
    @Override
    public OutputBlacklist processSingleResultAllColumns(ResultSet resultSet) {
        
        try {     
            if ((resultSet == null) || resultSet.isClosed()) {
                return null;
            }

            Integer id = resultSet.getInt("ID");
            if (resultSet.wasNull()) id = null;
            
            Integer mgId = resultSet.getInt("METRIC_GROUP_ID");
            if (resultSet.wasNull()) mgId = null;

            OutputBlacklist outputBlacklist = new OutputBlacklist(id, mgId);
            
            return outputBlacklist;
        }
        catch (Exception e) {
            logger.error(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));
            return null;
        }
    }
    
    @Override
    public String getTableName() {
        return tableName_;
    }
    
    public static OutputBlacklist getSingleOutputBlacklistRow() {
        
        OutputBlacklist outputBlacklist = null;
        
        OutputBlacklistDao outputBlacklistDao = new OutputBlacklistDao();
        List<OutputBlacklist> outputBlacklists = outputBlacklistDao.getAllDatabaseObjectsInTable();
        
        if ((outputBlacklists != null) && outputBlacklists.size() > 1) {
            logger.warn("There should not be more than one output blacklist row in the database.");
        }
        
        if ((outputBlacklists != null) && !outputBlacklists.isEmpty()) {
            for (OutputBlacklist outputBlacklistFromDb : outputBlacklists) {
                outputBlacklist = outputBlacklistFromDb;
                break;
            }
        }
        
        return outputBlacklist;
    }

}
```


Overlapping Code:
```
 OutputBlacklistDao extends DatabaseObjectDao<OutputBlacklist> {

private static final Logger logger = LoggerFactory.getLogger(OutputBlacklistDao.class.getName());

private final String tableName_ = "OUTPUT_BLACKLIST";

public OutputBlacklistDao(){}

public OutputBlacklistDao(boolean closeConnectionAfterOperation) {
databaseInterface_.setCloseConnectionAfterOperation(closeConnectionAfterOperation);
}

public OutputBlacklistDao(DatabaseInterface databaseInterface) {
super(databaseInterface);
}

public boolean dropTable() {
return dropTable(OutputBlacklistSql.DropTable_OutputBlacklist);
}

public boolean createTable() {
List<String> databaseCreationSqlStatements = new ArrayList<>();

if (DatabaseConfiguration.getType() == DatabaseConfiguration.MYSQL) {
databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_MySQL);
}
else {
databaseCreationSqlStatements.add(OutputBlacklistSql.CreateTable_OutputBlacklist_Derby);
databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_PrimaryKey);
}

databaseCreationSqlStatements.add(OutputBlacklistSql.CreateIndex_OutputBlacklist_ForeignKey_MetricGroupId);
return createTable(databaseCreationSqlStatements);
}

@Override
public OutputBlacklist getDatabaseObject(OutputBlacklist outputBlacklist) {
if (outputBlacklist == null) {
databaseInterface_.cleanupAutomatic();
return null;
}

return getDatabaseObject(OutputBlacklistSql.Select_OutputBlacklist_ByPrimaryKey, outputBlacklist.getId()); 
}

@Override
public boolean insert(OutputBlacklist outputBlacklist) {
if (outputBlacklist == null) {
databaseInterface_.cleanupAutomatic();
return false;
}

return insert(OutputBlacklistSql.Insert_OutputBlacklist, outputBlacklist.getMetricGroupId());
}

@Override
public boolean update(OutputBlacklist outputBlacklist) {
if (outputBlacklist == null) {
databaseInterface_.cleanupAutomatic();
return false;
}

return update(OutputBlacklistSql.Update_OutputBlacklist_ByPrimaryKey, outputBlacklist.getMetricGroupId(),
```
<Overlap Ratio: 0.970402717127608>

---

--- 213 --
Question ID: 6c671a06a15db1ca2f40789f19c4f875f173bdec_0
Original Code:
```
@RunWith(value = Parameterized.class)
public class CertificateResourceIT extends IntegrationTestBase {

    public CertificateResourceIT(Type tokenType) throws Exception  {
        super(true, tokenType);
    }

    @Parameters
    public static Object[] data() {
           return new Object[] { AccessToken.Type.JWT, AccessToken.Type.SAML };
    }

    private static String TEST_CERT_DN = "C=US, ST=WA, L=Bellevue, O=VMware, OU=SSO, CN=junkcert";
    private static CertificateDTO testCert;

    @BeforeClass
    public static void init() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {
        IntegrationTestBase.init(true);

        testCert = TestGenerator.generateCertificate(TEST_CERT_DN);
    }

    @AfterClass
    public static void cleanup() throws ClientProtocolException, HttpException, ClientException, IOException {
        IntegrationTestBase.cleanup(true);
    }

    @Test
    public void testSet() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {
        List<CertificateDTO> certificates = new ArrayList<CertificateDTO>();
        certificates.add(testCert);
        certificates.add(TestGenerator.generateCertificate(TEST_CERT_DN + "1"));

        TenantCredentialsDTO credentials = new TenantCredentialsDTO.Builder()
            .withPrivateKey(new PrivateKeyDTO(TestGenerator.getKeyPair().getPrivate()))
            .withCertificates(certificates)
            .build();

        testAdminClient.certificate().setCredentials(testTenant.getName(), credentials);

        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);
        assertFalse(chains.isEmpty());

        List<CertificateDTO> retrievedCerts = chains.get(chains.size() - 1).getCertificates();
        assertContainsCertificates(credentials.getCertificates(), retrievedCerts);

        // TODO If the server used the history of the signing certificates, it could still validate old tokens...
        // Update the client so we have a valid token
        testAdminClient = TestClientFactory.createClient(properties.getHost(),
                testTenant.getName(),
                testTenant.getUsername(),
                testTenant.getPassword());
    }

    @Test
    public void testGet() throws ClientProtocolException, HttpException, ClientException, IOException {
        List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);

        assertFalse(chains.isEmpty());
        List<CertificateDTO> certs = chains.get(0).getCertificates();

        assertContainsCertificates(testTenant.getCredentials().getCertificates(), certs);
    }

}
```


Overlapping Code:
```
@RunWith(value = Parameterized.class)
public class CertificateResourceIT extends IntegrationTestBase {
public CertificateResourceIT(Type tokenType) throws Exception {
super(true, tokenType);
}
@Parameters
public static Object[] data() {
return new Object[] { AccessToken.Type.JWT, AccessToken.Type.SAML };
}
private static String TEST_CERT_DN = "C=US, ST=WA, L=Bellevue, O=VMware, OU=SSO, CN=junkcert";
private static CertificateDTO testCert;
@BeforeClass
public static void init() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {
IntegrationTestBase.init(true);
testCert = TestGenerator.generateCertificate(TEST_CERT_DN);
}
@AfterClass
public static void cleanup() throws ClientProtocolException, HttpException, ClientException, IOException {
IntegrationTestBase.cleanup(true);
}
@Test
public void testSet() throws GeneralSecurityException, IOException, HttpException, ClientException, SOAPException {
List<CertificateDTO> certificates = new ArrayList<CertificateDTO>();
certificates.add(testCert);
certificates.add(TestGenerator.generateCertificate(TEST_CERT_DN + "1"));
TenantCredentialsDTO credentials = new TenantCredentialsDTO.Builder()
.withPrivateKey(new PrivateKeyDTO(TestGenerator.getKeyPair().getPrivate()))
.withCertificates(certificates)
.build();
testAdminClient.certificate().setCredentials(testTenant.getName(), credentials);
List<CertificateChainDTO> chains = testAdminClient.certificate().get(testTenant.getName(), CertificateScope.TENANT, CertificateGranularity.CHAIN);
assertFalse(chains.isEmpty());
List<CertificateDTO> retrievedCerts = chains.get(chains.size() - 1).getCertificates();
assertContainsCertificates(credentials.getCertificates(), retrievedCerts);
// TODO If the server used the history of the signing certificates, it could still validate old tokens...
// Update the client so we have a valid token
testAdminClient = TestClientFactory.createClient(properties.getHost(),
testTenant.getName(),
testTenant.getUsername(),
testTenant.getPassword());
}
@Test
public void testGet() throws ClientProtocolException, HttpException, ClientException, IOException {
List<CertificateChainDTO> chains = testAdminClie
```
<Overlap Ratio: 0.9995417048579285>

---

--- 214 --
Question ID: 2fe24cd32a37fb3e0c0dde69995c5bd1bcd20401_0
Original Code:
```
public class MarkDown14_40 {
  public static org.hl7.fhir.r4.model.MarkdownType convertMarkdown(org.hl7.fhir.dstu2016may.model.MarkdownType src) throws FHIRException {
    org.hl7.fhir.r4.model.MarkdownType tgt = new org.hl7.fhir.r4.model.MarkdownType();
    if (src.hasValue()) tgt.setValue(src.getValue());
    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);
    return tgt;
  }

  public static org.hl7.fhir.dstu2016may.model.MarkdownType convertMarkdown(org.hl7.fhir.r4.model.MarkdownType src) throws FHIRException {
    org.hl7.fhir.dstu2016may.model.MarkdownType tgt = new org.hl7.fhir.dstu2016may.model.MarkdownType();
    if (src.hasValue()) tgt.setValue(src.getValue());
    ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);
    return tgt;
  }
}
```


Overlapping Code:
```
MarkDown14_40 {
public static org.hl7.fhir.r4.model.MarkdownType convertMarkdown(org.hl7.fhir.dstu2016may.model.MarkdownType src) throws FHIRException {
org.hl7.fhir.r4.model.MarkdownType tgt = new org.hl7.fhir.r4.model.MarkdownType();
if (src.hasValue()) tgt.setValue(src.getValue());
ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);
return tgt;
}
public static org.hl7.fhir.dstu2016may.model.MarkdownType convertMarkdown(org.hl7.fhir.r4.model.MarkdownType src) throws FHIRException {
org.hl7.fhir.dstu2016may.model.MarkdownType tgt = new org.hl7.fhir.dstu2016may.model.MarkdownType();
if (src.hasValue()) tgt.setValue(src.getValue());
ConversionContext14_40.INSTANCE.getVersionConvertor_14_40().copyElement(src, tgt);
return tgt;
}

```
<Overlap Ratio: 0.9820971867007673>

---

--- 215 --
Question ID: 874c0230b0504decf6f215d5f14e8258bf671828_0
Original Code:
```
public class Image {

  private String url;
  private Integer w;
  private Integer h;
  private Integer type;
  private String ext;

  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }

  public Integer getW() {
    return w;
  }

  public void setW(Integer w) {
    this.w = w;
  }

  public Integer getH() {
    return h;
  }

  public void setH(Integer h) {
    this.h = h;
  }

  public Integer getType() {
    return type;
  }

  public void setType(Integer type) {
    this.type = type;
  }

  public String getExt() {
    return ext;
  }

  public void setExt(String ext) {
    this.ext = ext;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Image image = (Image) o;
    return Objects.equals(getUrl(), image.getUrl())
        && Objects.equals(getW(), image.getW())
        && Objects.equals(getH(), image.getH())
        && Objects.equals(getType(), image.getType())
        && Objects.equals(getExt(), image.getExt());
  }

  @Override
  public int hashCode() {

    return Objects.hash(getUrl(), getW(), getH(), getType(), getExt());
  }
}
```


Overlapping Code:
```
ss Image {
private String url;
private Integer w;
private Integer h;
private Integer type;
private String ext;
public String getUrl() {
return url;
}
public void setUrl(String url) {
this.url = url;
}
public Integer getW() {
return w;
}
public void setW(Integer w) {
this.w = w;
}
public Integer getH() {
return h;
}
public void setH(Integer h) {
this.h = h;
}
public Integer getType() {
return type;
}
public void setType(Integer type) {
this.type = type;
}
public String getExt() {
return ext;
}
public void setExt(String ext) {
this.ext = ext;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Image image = (Image) o;
return Objects.equals(getUrl(), image.getUrl())
&& Objects.equals(getW(), image.getW())
&& Objects.equals(getH(), image.getH())
&& Objects.equals(getType(), image.getType())
&& Objects.equals(getExt(), image.getExt());
}
@Override
public int hashCode() {
return Objects.hash(getUrl(), getW(), ge
```
<Overlap Ratio: 0.9606147934678194>

---

--- 216 --
Question ID: 5b87507066ab7e7c25aba54b78a5daed9a364cb4_0
Original Code:
```
public final class APIJsonMapper {

    /** Module used to extend the object mappers functionality in terms of mapping the APIs data model interfaces */
    private static final SimpleModule DATA_MODULE = createDataModule();

    /** Module used to extend the object mappers functionality in terms of mapping JDK8 Optionals */
    private static final Module JDK8_MODULE = new Jdk8Module();

    private APIJsonMapper() {}      // Private constructor. Only static methods

    /**
     * Maps some <i>TheTVDB.com</i> API response JSON into it's Java model representation.
     *
     * @param json          The full JSON as returned by the remote service
     * @param typeReference Type reference representing the Java model structure to which the JSON should be mapped to
     * @param <T>           The DTO type to which the JSON's {@code data} node should be mapped to
     *
     * @return Extended API response containing the requested data parsed from the given JSON as well as additional
     *         status information.
     *
     * @throws APIException If an IO error occurred during the deserialization of the given JSON object
     */
    public static <T> APIResponse<T> readValue(@Nonnull JsonNode json,
            @Nonnull TypeReference<APIResponse<T>> typeReference) throws APIException {
        try {
            return new ObjectMapper()
                    .registerModule(createAPIResponseModule(((ParameterizedType)typeReference.getType())
                            .getActualTypeArguments()[0]))
                    .readValue(json.toString(), typeReference);
        } catch (JsonProcessingException | IllegalArgumentException ex) {
            throw new APIException(String.format(API_JSON_PARSE_ERROR, ex.getMessage()), ex);
        }
    }

    /**
     * Creates a JSON module with enhanced functionality regarding the deserialization of <i>TheTVDB.com</i> API JSON
     * responses. This includes the creation of a new API response deserializer for the given DTO type which also
     * supports the usage of Java {@code Optional} data types. Unknown properties within the JSON's {@code data} node
     * will be ignored by default.
     *
     * @param dataType DTO type to which the content of the JSON's {@code data} node should be parsed to
     *
     * @return JSON module with enhanced functionality for parsing JSON responses received from the remote service
     */
    private static Module createAPIResponseModule(@Nonnull Type dataType) {
        ThrowableFunctionalInterfaces.Function<JsonNode, ?, IOException> dataFunction = dataNode ->
                new ObjectMapper().registerModules(JDK8_MODULE, DATA_MODULE)
                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
                        .readValue(dataNode.toString(), new StaticTypeReference<>(dataType));
        return new SimpleModule().addDeserializer(APIResponse.class, new APIResponseDeserializer<>(dataFunction));
    }

    /**
     * Creates a JSON module with enhanced functionality regarding the deserialization of the JSON's {@code data} node.
     * This includes proper handling of nullable collections and well as type resolver mappings for DTO model
     * interfaces. The latter will automatically be resolved via the {@link APIDataModel} annotation.
     *
     * @param <T> the API model interface type, used for adding type resolver mappings
     *
     * @return JSON module with enhanced functionality for parsing the actual response DTO models
     */
    @SuppressWarnings("unchecked")  // dto implements dtoInterface
    private static <T> SimpleModule createDataModule() {
        // Add Interface <-> Implementation mappings to the module. The object mapper will use these mappings to determine the
        // proper builder to be used to create new instances of a specific interface (via @JsonDeserialize annotation).
        SimpleAbstractTypeResolver dtoTypeResolver = new SimpleAbstractTypeResolver()
                .addMapping(Translated.class, EntityTranslation.class); // Use EntityTranslation as default implementation
        ClassFilter.only().classes().annotatedWith(JsonDeserialize.class)
                .from(ClassIndex.getAnnotated(APIDataModel.class)).forEach(dto ->
                        Arrays.stream(dto.getInterfaces()).forEach(dtoInterface ->
                                dtoTypeResolver.addMapping((Class<T>)dtoInterface, (Class<? extends T>)dto)));

        SimpleModule dataModule = new SimpleModule();
        dataModule.setDeserializerModifier(new CollectionDeserializerModifier()).setAbstractTypes(dtoTypeResolver);
        return dataModule;
    }
}
```


Overlapping Code:
```
** Module used to extend the object mappers functionality in terms of mapping the APIs data model interfaces */
private static final SimpleModule DATA_MODULE = createDataModule();
/** Module used to extend the object mappers functionality in terms of mapping JDK8 Optionals */
private static final Module JDK8_MODULE = new Jdk8Module();
private APIJsonMapper() {} // Private constructor. Only static methods
/**
* Maps some <i>TheTVDB.com</i> API response JSON into it's Java model representation.
*
* @param json The full JSON as returned by the remote service
* @param typeReference Type reference representing the Java model structure to which the JSON should be mapped to
* @param <T> The DTO type to which the JSON's {@code data} node should be mapped to
*
* @return Extended API response containing the requested data parsed from the given JSON as well as additional
* status information.
*
* @throws APIException If an IO error occurred during the deserialization of the given JSON object
*/
public static <T> APIResponse<T> readValue(@Nonnull JsonNode json,
@Nonnull TypeReference<APIResponse<T>> typeReference) throws APIException {
try {
return new ObjectMapper()
.registerModule(createAPIResponseModule(((ParameterizedType)typeReference.getType())
.getActualTypeArguments()[0]))
.readValue(json.toString(), typeReference);
} catch (JsonProcessingException | IllegalArgumentException ex) {
throw new APIException(String.format(API_JSON_PARSE_ERROR, ex.getMessage()), ex);
}
}
/**
* Creates a JSON module with enhanced functionality regarding the deserialization of <i>TheTVDB.com</i> API JSON
* responses. This includes the creation of a new API response deserializer for the given DTO type which also
* supports the usage of Java {@code Optional} data types. Unknown properties within the JSON's {@code data} node
* will be ignored by default.
*
* @param dataType DTO type to which the content of the JSON's {@code data} node should be parsed to
*
* @return JSON module with enhanced functionality for parsing JSON responses received from the remote service
*/
private static Module createAPIResponseModule(@Nonnull Type dataType) {
Throwa
```
<Overlap Ratio: 0.9835315645013724>

---

--- 217 --
Question ID: 1b675423836ba754efdd53d99b2dd931e4e0e564_0
Original Code:
```
@Entity
@Table(name = "lib_author")
@SequenceGenerator(name = "seq_lib_author", sequenceName = "seq_lib_author", allocationSize = 1)
public class Author {
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq_lib_author")
	@Column(name = "id_author", unique = false, nullable = false, insertable = true, updatable = true)
	private Integer idAuthor;

	@Column(name = "name", unique = false, nullable = true, insertable = true, updatable = true, length = 30)
	private String name;

	@Column(name = "surname", unique = false, nullable = true, insertable = true, updatable = true, length = 80)
	private String surname;

	@Column(name = "nickname", unique = false, nullable = true, insertable = true, updatable = true, length = 80)
	private String nickname;

	@Temporal(TemporalType.DATE)
	@Column(name = "birth_date", unique = false, nullable = true, insertable = true, updatable = true, length = 13)
	private Date birthDate;

	@ManyToMany(cascade = { CascadeType.ALL }, fetch = FetchType.LAZY, mappedBy = "author")
	private Set<Book> book = new HashSet<Book>(0);

	public Integer getIdAuthor() {
		return idAuthor;
	}

	public void setIdAuthor(Integer idAuthor) {
		this.idAuthor = idAuthor;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSurname() {
		return surname;
	}

	public void setSurname(String surname) {
		this.surname = surname;
	}

	public String getNickname() {
		return nickname;
	}

	public void setNickname(String nickname) {
		this.nickname = nickname;
	}

	public Date getBirthDate() {
		return birthDate;
	}

	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}

	public Set<Book> getBook() {
		return book;
	}

	public void setBook(Set<Book> book) {
		this.book = book;
	}
	
	@Override
	public String toString() {
		String result = "";
		if(surname != null && name == null)
			result = surname;
		else if(surname == null && name != null)
			result = name;
		else if( surname != null && name != null)
			result = surname + " " + name;
		return result;
	}
}
```


Overlapping Code:
```
erator(name = "seq_lib_author", sequenceName = "seq_lib_author", allocationSize = 1)
public class Author {
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq_lib_author")
@Column(name = "id_author", unique = false, nullable = false, insertable = true, updatable = true)
private Integer idAuthor;
@Column(name = "name", unique = false, nullable = true, insertable = true, updatable = true, length = 30)
private String name;
@Column(name = "surname", unique = false, nullable = true, insertable = true, updatable = true, length = 80)
private String surname;
@Column(name = "nickname", unique = false, nullable = true, insertable = true, updatable = true, length = 80)
private String nickname;
@Temporal(TemporalType.DATE)
@Column(name = "birth_date", unique = false, nullable = true, insertable = true, updatable = true, length = 13)
private Date birthDate;
@ManyToMany(cascade = { CascadeType.ALL }, fetch = FetchType.LAZY, mappedBy = "author")
private Set<Book> book = new HashSet<Book>(0);
public Integer getIdAuthor() {
return idAuthor;
}
public void setIdAuthor(Integer idAuthor) {
this.idAuthor = idAuthor;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getSurname() {
return surname;
}
public void setSurname(String surname) {
this.surname = surname;
}
public String getNickname() {
return nickname;
}
public void setNickname(String nickname) {
this.nickname = nickname;
}
public Date getBirthDate() {
return birthDate;
}
public void setBirthDate(Date birthDate) {
this.birthDate = birthDate;
}
public Set<Book> getBook() {
return book;
}
public void setBook(Set<Book> book) {
this.book = book;
}

@Override
public String toString() {
String result = "";
if(surname != null && name == null)
result = surname;
else if(surname == null && name != null)
result = name;
else if( surname != null && name != null)
result = surname + " "
```
<Overlap Ratio: 0.9624248496993988>

---

--- 218 --
Question ID: 180a19ee9b6867319cc9e76670c69f2efbe859e4_0
Original Code:
```
public class GistSyncFavorite extends SyncFavorite {
  private String owner;
  private String id;

  public GistSyncFavorite() {
    super(Type.GIST);
  }

  public GistSyncFavorite(String owner, String id) {
    super(Type.GIST);
    this.owner = owner;
    this.id = id;
  }

  public GistSyncFavorite(Map<String, Object> map) {
    super(map);
    if (map != null) {
      if (map.containsKey("id") && map.get("id") != null) {
        this.id = (String) map.get("id");
      }
      if (map.containsKey("owner") && map.get("owner") != null) {
        this.owner = (String) map.get("owner");
      }
    }
  }

  public String getOwner() {
    return owner;
  }

  public String getId() {
    return id;
  }

  @Override
  public Map<String, Object> toMap() {
    Map<String, Object> map = new HashMap<>();
    map.put("owner", owner);
    map.put("id", id);
    return map;
  }
}
```


Overlapping Code:
```
 SyncFavorite {
private String owner;
private String id;
public GistSyncFavorite() {
super(Type.GIST);
}
public GistSyncFavorite(String owner, String id) {
super(Type.GIST);
this.owner = owner;
this.id = id;
}
public GistSyncFavorite(Map<String, Object> map) {
super(map);
if (map != null) {
if (map.containsKey("id") && map.get("id") != null) {
this.id = (String) map.get("id");
}
if (map.containsKey("owner") && map.get("owner") != null) {
this.owner = (String) map.get("owner");
}
}
}
public String getOwner() {
return owner;
}
public String getId() {
return id;
}
@Override
public Map<String, Object> toMap() {
Map<String, Object> map = new HashMap<>();
map.put("owner", owner);
map.put("id", id)
```
<Overlap Ratio: 0.9283819628647215>

---

--- 219 --
Question ID: 9f18838ea34795383f96a3aed3403aa73d15789e_0
Original Code:
```
public class TabCompleter implements org.bukkit.command.TabCompleter {

	private static final List<String> COMMANDS = Arrays.asList("reload");

public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
        final List<String> completions = new ArrayList<>();
        StringUtil.copyPartialMatches(args[0], COMMANDS, completions);
        Collections.sort(completions);
        return completions;
    }
}
```


Overlapping Code:
```
public class TabCompleter implements org.bukkit.command.TabCompleter {
private static final List<String> COMMANDS = Arrays.asList("reload");
public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
final List<String> completions = new ArrayList<>();
StringUtil.copyPartialMatches(args[0], COMMANDS, completions);
Collections.sort(completions);
return completions;
}
}
```
<Overlap Ratio: 1.0>

---

--- 220 --
Question ID: 6230d08f0425e98cd38cf222b765976d97ca58ae_0
Original Code:
```
public class OptionsUtil {

	private static final Logger logger      = Logger.getLogger(OptionsUtil.class);
	private HashMap<String, String> options       = new HashMap<String, String>();
	private static OptionsUtil INSTANCE     = null;
	
	private OptionsUtil() {
		readParameters();
	}
	
	public static OptionsUtil getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new OptionsUtil();
		}
		
		return INSTANCE;
	}

	public void readParameters() {
		String[] args = Platform.getCommandLineArgs();
		
		int i = 0;
		try {
			while (i < args.length) {
				String key = args[i];
			    String value;
			    if (key.startsWith("-")) {
			    	try {
			    		String test = args[i+1];
			    	    if (test.startsWith("-")) {
			    	    	value = test;
			    	    } else {
			    	    	value = key;
			    	    }
			    	} catch (Throwable t) {
			    		value = key;
			    	}
			    	
				    options.put(key, value);
			    }
			    
			    i++;
			}
		} catch (Exception e) {
			logger.error("An error occured when trying to read input parameters.");
		}
		
		System.out.println("here.");
	}
	
	public static String getOption(String optionName) throws Exception {
		 try {
			 return getInstance().options.get(optionName);
		 } catch (Exception e) {
			 //log and throw it
			 logger.error("An error occured when trying to read input parameters.");
			 throw e;
		 }
	}

}
```


Overlapping Code:
```
c class OptionsUtil {
private static final Logger logger = Logger.getLogger(OptionsUtil.class);
private HashMap<String, String> options = new HashMap<String, String>();
private static OptionsUtil INSTANCE = null;

private OptionsUtil() {
readParameters();
}

public static OptionsUtil getInstance() {
if (INSTANCE == null) {
INSTANCE = new OptionsUtil();
}

return INSTANCE;
}
public void readParameters() {
String[] args = Platform.getCommandLineArgs();

int i = 0;
try {
while (i < args.length) {
String key = args[i];
String value;
if (key.startsWith("-")) {
try {
String test = args[i+1];
if (test.startsWith("-")) {
value = test;
} else {
value = key;
}
} catch (Throwable t) {
value = key;
}

options.put(key, value);
}

i++;
}
} catch (Exception e) {
logger.error("An error occured when trying to read input parameters.");
}

System.out.println("here.");
}

public static String getOption(String optionName) throws Exception {
try {
return getInstance().options.get(optionName);
} catch (Exception e) {
//log and throw it
logger.error("An error occured when trying to read input parameters.");
th
```
<Overlap Ratio: 0.9848214285714286>

---

--- 221 --
Question ID: 73bd4b62de5e6b5357c7d248eb40132d32a4a3a1_0
Original Code:
```
public class MaestroBackendClient extends AbstractBackendListenerClient {
    // Logger instance used for logging
    private static final Logger log = LoggerFactory.getLogger(MaestroBackendClient.class);

    // Maestro Backend Listener Parameters
    private String maestroUrl;
    private String maestroAuthToken;
    private String maestroRunId;

    public MaestroHttpMetricsSender maestroHttpSender = new MaestroHttpMetricsSender();

    public MaestroBackendClient() {
        super();
    }

    public MaestroBackendClient(String url, String runId) {
        super();
        maestroUrl = url;
        maestroRunId = runId;
    }

    private static final Map<String, String> DEFAULT_ARGS = new LinkedHashMap<>();
    static {
        DEFAULT_ARGS.put("maestroUrl", "${__P(maestro.api.host)}");
        DEFAULT_ARGS.put("maestroAuthToken", "${__P(maestro.api.token)}");
        DEFAULT_ARGS.put("maestroRunId", "${__P(maestro.run.id)}");
    }

    @Override
    public Arguments getDefaultParameters() {
        Arguments arguments = new Arguments();
        DEFAULT_ARGS.forEach(arguments::addArgument);
        return arguments;
    }

    public String getTestMaestroUrl(){
        if (maestroUrl.endsWith("/")) {
            return maestroUrl + maestroRunId;
        }
        return maestroUrl + "/" + maestroRunId;
    }

    // Do initialization required by this client.
    @Override
    public void setupTest(BackendListenerContext context) throws Exception {
        maestroUrl = context.getParameter("maestroUrl", "");
        maestroAuthToken = context.getParameter("maestroAuthToken", "");
        maestroRunId = context.getParameter("maestroRunId", "");

        maestroHttpSender.setup(getTestMaestroUrl(), maestroAuthToken);
    }

    // Converts JMeter Sample Result to JSON Object
    private JSONObject sampleToJSON(SampleResult sr) {
        // Doc: https://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/SamplerMetric.html
        JSONObject srObj = new JSONObject();
        srObj.put("timeStamp", Long.toString(sr.getTimeStamp()));
        srObj.put("elapsed", Long.toString(sr.getTime()));
        srObj.put("label", sr.getSampleLabel());
        srObj.put("responseCode", sr.getResponseCode());
        srObj.put("responseMessage", sr.getResponseMessage());
        srObj.put("threadName", sr.getThreadName());
        srObj.put("dataType", sr.getDataType());
        srObj.put("success", Boolean.toString(sr.isSuccessful()));
        srObj.put("failureMessage", Optional.ofNullable(sr.getFirstAssertionFailureMessage()).orElse(""));
        srObj.put("bytes", Long.toString((sr.getBytesAsLong())));
        srObj.put("sentBytes", Long.toString(sr.getSentBytes()));
        srObj.put("grpThreads", Integer.toString(sr.getGroupThreads()));
        srObj.put("allThreads", Integer.toString(sr.getAllThreads()));
        srObj.put("URL", sr.getUrlAsString());
        srObj.put("Latency", Long.toString(sr.getLatency()));
        srObj.put("IdleTime", Long.toString(sr.getIdleTime()));
        srObj.put("Connect", Long.toString(sr.getConnectTime()));
        return srObj;
    }

    public String processSampleResults(List<SampleResult> results){
        JSONArray allSamplesResults = new JSONArray();

        // Adds all JMeter test sample and subsamples results to allow us to
        // recreate the csv file.
        for (SampleResult sr : results) {
            allSamplesResults.add(sampleToJSON(sr));
            SampleResult[] sampleResults = sr.getSubResults();
            for (SampleResult sampleResult : sampleResults) {
                allSamplesResults.add(sampleToJSON(sampleResult));
            }
        }

        // Format request body accordingly to the Maestro API Interface
        JSONObject request_body = new JSONObject();
        request_body.put("metrics", allSamplesResults);
        return request_body.toJSONString();
    }

    // Handle sampleResults, send them to maestro API
    @Override
    public void handleSampleResults(List<SampleResult> results, BackendListenerContext context) {
        maestroHttpSender.writeAndSendMetrics(processSampleResults(results));
    }

    // Do any clean-up required at the end of a test run.
    @Override
    public void teardownTest(BackendListenerContext context) throws Exception {
        log.info("Sending final metrics.");
        maestroHttpSender.destroy();
        super.teardownTest(context);
    }

}
```


Overlapping Code:
```
endClient extends AbstractBackendListenerClient {
// Logger instance used for logging
private static final Logger log = LoggerFactory.getLogger(MaestroBackendClient.class);
// Maestro Backend Listener Parameters
private String maestroUrl;
private String maestroAuthToken;
private String maestroRunId;
public MaestroHttpMetricsSender maestroHttpSender = new MaestroHttpMetricsSender();
public MaestroBackendClient() {
super();
}
public MaestroBackendClient(String url, String runId) {
super();
maestroUrl = url;
maestroRunId = runId;
}
private static final Map<String, String> DEFAULT_ARGS = new LinkedHashMap<>();
static {
DEFAULT_ARGS.put("maestroUrl", "${__P(maestro.api.host)}");
DEFAULT_ARGS.put("maestroAuthToken", "${__P(maestro.api.token)}");
DEFAULT_ARGS.put("maestroRunId", "${__P(maestro.run.id)}");
}
@Override
public Arguments getDefaultParameters() {
Arguments arguments = new Arguments();
DEFAULT_ARGS.forEach(arguments::addArgument);
return arguments;
}
public String getTestMaestroUrl(){
if (maestroUrl.endsWith("/")) {
return maestroUrl + maestroRunId;
}
return maestroUrl + "/" + maestroRunId;
}
// Do initialization required by this client.
@Override
public void setupTest(BackendListenerContext context) throws Exception {
maestroUrl = context.getParameter("maestroUrl", "");
maestroAuthToken = context.getParameter("maestroAuthToken", "");
maestroRunId = context.getParameter("maestroRunId", "");
maestroHttpSender.setup(getTestMaestroUrl(), maestroAuthToken);
}
// Converts JMeter Sample Result to JSON Object
private JSONObject sampleToJSON(SampleResult sr) {
// Doc: https://jmeter.apache.org/api/org/apache/jmeter/visualizers/backend/SamplerMetric.html
JSONObject srObj = new JSONObject();
srObj.put("timeStamp", Long.toString(sr.getTimeStamp()));
srObj.put("elapsed", Long.toString(sr.getTime()));
srObj.put("label", sr.getSampleLabel());
srObj.put("responseCode", sr.getResponseCode());
srObj.put("responseMessage", sr.getResponseMessage());
srObj.put("threadName", sr.getThreadName());
srObj.put("dataType", sr.getDataType());
srObj.put("success", Boolean.toString(sr.isSuccessfu
```
<Overlap Ratio: 0.9786344635392475>

---

--- 222 --
Question ID: d6d82d1885fb859a68a6fadb3df0bf67c0d889c5_0
Original Code:
```
public class TypedNodeTransformationMakerList extends TypedNodeMaker {
		
	public TypedNodeTransformationMakerList(NodeType nodeType, ValueMaker valueMaker) {
		super(nodeType, valueMaker);
	}
	@Override
	public Node makeNode(ResultRow tuple) {
		String value = this.valueMaker.makeValue(tuple);
		if (value == null) {
			return null;
		}
		return this.nodeType.makeNode(value);
	}
	
@Override
	public void accept(NodeMakerVisitor visitor) {
	super.accept(visitor);
		//visitor.visit(this); //DIMIS FIX ME NOW!!!!!!!
		System.out.print("visit?");
	}
}
```


Overlapping Code:
```
ass TypedNodeTransformationMakerList extends TypedNodeMaker {

public TypedNodeTransformationMakerList(NodeType nodeType, ValueMaker valueMaker) {
super(nodeType, valueMaker);
}
@Override
public Node makeNode(ResultRow tuple) {
String value = this.valueMaker.makeValue(tuple);
if (value == null) {
return null;
}
return this.nodeType.makeNode(value);
}

@Override
public void accept(NodeMakerVisitor visitor) {
super.accept(visitor);
//visitor.visit(this); //DIMIS FIX ME NOW!!!!!!!
System.out.print("vi
```
<Overlap Ratio: 0.9617590822179732>

---

--- 223 --
Question ID: c70dbee9c06604d822b612fb40b23f4b8dc69ca2_0
Original Code:
```
public class Ledger extends AbstractAccountingConcept {

  private static final String FACTORY_CLASS_NAME = "com.yanimetaxas.bookkeeping.BankFactoryImpl";

  private String name;
  private ChartOfAccounts chartOfAccounts;

  private Ledger(LedgerBuilder builder) throws InfrastructureException {
    super(FACTORY_CLASS_NAME, builder.options);
    this.chartOfAccounts = builder.chartOfAccounts;
    this.name = builder.name;
  }

  public Ledger init() {
    chartOfAccounts.get().forEach(account -> {
      if (!account.getBalance().isNullMoney()) {
        getAccountService().createAccount(account.getAccountRef(), account.getBalance());
      }
    });
    return this;
  }

  public void commit(TransferRequest transferRequest) {
    validateAccountRefs(
        transferRequest.getLegs()
            .stream()
            .map(TransactionLeg::getAccountRef)
            .toArray(String[]::new)
    );
    getTransferService().transferFunds(transferRequest);
  }

  private void validateAccountRefs(String... accountRefs) {
    List<String> chartOfAccountsRefs = this.chartOfAccounts.get()
        .stream()
        .map(Account::getAccountRef)
        .collect(Collectors.toList());

    for (String ref : accountRefs) {
      if (!chartOfAccountsRefs.contains(ref)) {
        throw new LedgerAccountException(ref);
      }
    }
  }

  public ReferenceStep createTransferRequest() {
    return TransferRequest.builder();
  }

  public List<Transaction> findTransactions(String accountRef) {
    validateAccountRefs(accountRef);
    return getTransferService().findTransactionsByAccountRef(accountRef);
  }

  public Transaction getTransactionByRef(String transactionRef) {
    return getTransferService().getTransactionByRef(transactionRef);
  }

  public Money getAccountBalance(String accountRef) {
    validateAccountRefs(accountRef);
    return getAccountService().getAccountBalance(accountRef);
  }

  public void printHistoryLog() {
    System.out.println(toString());
  }

  private String formatAccounts() {
    StringBuilder sb = new StringBuilder();
    sb.append("Ledger: " + name + "\n\n");
    sb.append(String
        .format("%20s %20s %10s %15s %10s %10s", "Account", "|", "Amount", "|", "Currency", "|"));
    sb.append(String.format("%s",
        "\n------------------------------------------------------------------------------------------"));

    chartOfAccounts.get().forEach(account -> {
      Money money = getAccountService().getAccountBalance(account.getAccountRef());
      sb.append("\n" + String
          .format("%20s %20s %10.2f %15s %10s %10s", account.getAccountRef(), "|",
              money.getAmount(), "|",
              money.getCurrency(), "|"));
    });

    return sb.toString();
  }

  private String formatTransactionLog() {
    StringBuilder sb = new StringBuilder();

    sb.append(String
        .format("%20s %20s %15s %10s %10s %10s %10s", "Account", "|", "Transaction", "|", "Type",
            "|", "Date"));
    sb.append(String.format("%s",
        "\n-------------------------------------------------------------------------------------------------------------------------"));

    chartOfAccounts.get().forEach(account -> {
      List<Transaction> transactions = getTransferService()
          .findTransactionsByAccountRef(account.getAccountRef());
      if (!transactions.isEmpty()) {
        transactions.forEach(transaction -> sb.append("\n" + String
            .format("%20s %20s %10s %15s %10s %10s %10s %1s", account.getAccountRef(), "|",
                transaction.getTransactionRef(), "|", transaction.getTransactionType(), "|",
                transaction.getTransactionDate(), "|")));
      } else {
        sb.append("\n" + String
            .format("%20s %20s %10s %15s %10s %10s %10s %1s", account.getAccountRef(), "|",
                "N/A", "|", "N/A", "|",
                "N/A", "|"));
      }
    });
    chartOfAccounts.get().forEach(account -> {
      List<Transaction> transactions = getTransferService()
          .findTransactionsByAccountRef(account.getAccountRef());
      if (!transactions.isEmpty()) {
        sb.append(
            "\n\n" + String.format("%20s %20s %15s %4s %10s %10s %15s %5s", "Account", "|",
                "Transaction Leg Ref", "|", "Amount", "|", "Currency", "|"));
        sb.append(String.format("%s",
            "\n-------------------------------------------------------------------------------------------------------------------------"));
        transactions.forEach(transaction ->
            transaction.getLegs().forEach(leg -> sb.append("\n" + String
                .format("%20s %20s %10s %10s %10s %10s %10s %10s", account.getAccountRef(), "|",
                    leg.getAccountRef(), "|", leg.getAmount().getAmount(), "|",
                    leg.getAmount().getCurrency(), "|"))));
      }
    });

    return sb.toString();
  }

  @Override
  public String toString() {
    return formatAccounts() + "\n\n" + formatTransactionLog() + "\n\n";
  }

  public static class LedgerBuilder {

    private String name = "General Ledger";
    private ChartOfAccounts chartOfAccounts;
    private ConnectionOptions options = ConnectionOptions.EMBEDDED_H2_CONNECTION;

    public LedgerBuilder(ChartOfAccounts chartOfAccounts) {
      this.chartOfAccounts = chartOfAccounts;
    }

    public LedgerBuilder name(String name) {
      this.name = name;
      return this;
    }

    public LedgerBuilder options(ConnectionOptions options) {
      this.options = options;
      return this;
    }

    public Ledger build() {
      return new Ledger(this);
    }
  }
}
```


Overlapping Code:
```
 extends AbstractAccountingConcept {
private static final String FACTORY_CLASS_NAME = "com.yanimetaxas.bookkeeping.BankFactoryImpl";
private String name;
private ChartOfAccounts chartOfAccounts;
private Ledger(LedgerBuilder builder) throws InfrastructureException {
super(FACTORY_CLASS_NAME, builder.options);
this.chartOfAccounts = builder.chartOfAccounts;
this.name = builder.name;
}
public Ledger init() {
chartOfAccounts.get().forEach(account -> {
if (!account.getBalance().isNullMoney()) {
getAccountService().createAccount(account.getAccountRef(), account.getBalance());
}
});
return this;
}
public void commit(TransferRequest transferRequest) {
validateAccountRefs(
transferRequest.getLegs()
.stream()
.map(TransactionLeg::getAccountRef)
.toArray(String[]::new)
);
getTransferService().transferFunds(transferRequest);
}
private void validateAccountRefs(String... accountRefs) {
List<String> chartOfAccountsRefs = this.chartOfAccounts.get()
.stream()
.map(Account::getAccountRef)
.collect(Collectors.toList());
for (String ref : accountRefs) {
if (!chartOfAccountsRefs.contains(ref)) {
throw new LedgerAccountException(ref);
}
}
}
public ReferenceStep createTransferRequest() {
return TransferRequest.builder();
}
public List<Transaction> findTransactions(String accountRef) {
validateAccountRefs(accountRef);
return getTransferService().findTransactionsByAccountRef(accountRef);
}
public Transaction getTransactionByRef(String transactionRef) {
return getTransferService().getTransactionByRef(transactionRef);
}
public Money getAccountBalance(String accountRef) {
validateAccountRefs(accountRef);
return getAccountService().getAccountBalance(accountRef);
}
public void printHistoryLog() {
System.out.println(toString());
}
private String formatAccounts() {
StringBuilder sb = new StringBuilder();
sb.append("Ledger: " + name + "\n\n");
sb.append(String
.format("%20s %20s %10s %15s %10s %10s", "Account", "|", "Amount", "|", "Currency", "|"));
sb.append(String.format("%s",
"\n------------------------------------------------------------------------------------------"));
chartOfAccounts.get().forEach(account -> {
Money money = getAccountService().getAccountBalance(a
```
<Overlap Ratio: 0.981941309255079>

---

--- 224 --
Question ID: 8307ea1d8657843c9dd331881e650e76d039063e_0
Original Code:
```
public class LoadBalancerModule extends AbstractModule {
    @Override
    protected void configure() {
        bind(LoadBalancerServiceGrpc.LoadBalancerServiceImplBase.class).to(DefaultLoadBalancerServiceGrpc.class);
        bind(LoadBalancerService.class).to(DefaultLoadBalancerService.class);
        bind(LoadBalancerJobValidator.class).to(DefaultLoadBalancerJobValidator.class);
        bind(LoadBalancerConnector.class).to(NoOpLoadBalancerConnector.class);
    }

    @Provides
    @Singleton
    public LoadBalancerConfiguration getLoadBalancerConfiguration(ConfigProxyFactory factory) {
        return factory.newProxy(LoadBalancerConfiguration.class);
    }

    @Provides
    @Singleton
    public LoadBalancerValidationConfiguration getLoadBalancerValidationConfiguration(ConfigProxyFactory factory) {
        return factory.newProxy(LoadBalancerValidationConfiguration.class);
    }
}
```


Overlapping Code:
```
s LoadBalancerModule extends AbstractModule {
@Override
protected void configure() {
bind(LoadBalancerServiceGrpc.LoadBalancerServiceImplBase.class).to(DefaultLoadBalancerServiceGrpc.class);
bind(LoadBalancerService.class).to(DefaultLoadBalancerService.class);
bind(LoadBalancerJobValidator.class).to(DefaultLoadBalancerJobValidator.class);
bind(LoadBalancerConnector.class).to(NoOpLoadBalancerConnector.class);
}
@Provides
@Singleton
public LoadBalancerConfiguration getLoadBalancerConfiguration(ConfigProxyFactory factory) {
return factory.newProxy(LoadBalancerConfiguration.class);
}
@Provides
@Singleton
public LoadBalancerValidationConfiguration getLoadBalancerValidationConfiguration(ConfigProxyFactory factory) {
return factory.newProxy(LoadBa
```
<Overlap Ratio: 0.9351620947630923>

---

--- 225 --
Question ID: 632d53786d2948c3d5c78c1a9615b0daf5edf8df_0
Original Code:
```
public class EventuateSTOMPClientTest {

  private Logger logger = LoggerFactory.getLogger(getClass());

  private EventuateSTOMPClient client;
  private TrackingStompServer server;
  private EventuateCredentials credentials = new EventuateCredentials("x", "y", "default");
  private static Vertx vertx;
  private static int port;
  private BlockingQueue<Int128> ids;
  private String mySubId = "MySubId";
  private String subId;

  @Before
  public void setUp() {
    ids = new LinkedBlockingDeque<>();
  }

  @BeforeClass
  public static void beforeClass() throws IOException {
    port = PortUtil.findPort();
    vertx = Vertx.vertx();
  }

  @AfterClass
  public static void afterClass() {
    if (vertx != null) vertx.close();
  }

  @After
  public void tearDown() throws ExecutionException, InterruptedException {
    if (server != null)
      server.close();
  }

  private void makeClientAndSubscribeSync() throws URISyntaxException, ExecutionException, InterruptedException {
    makeClient();
    subscribeSync();
  }

  private void makeClient() throws URISyntaxException {
    client = new EventuateSTOMPClient(vertx, credentials, new URI("stomp://localhost:" + port));
  }

  private void subscribeSync() throws InterruptedException, ExecutionException {
    subId = subscribeAsync(mySubId).get();
  }

  private CompletableFuture<String> subscribeAsync(String subscribeId) {
    return (CompletableFuture<String>) client.subscribe(subscribeId,
            Collections.singletonMap("MyEntityType",
                    Collections.singleton("MyEvent")),
            null, se -> {
              ids.add(se.getId());
              return CompletableFuture.completedFuture("x");
            });
  }

  private void makeServer() {
    server = new TrackingStompServer(vertx, port);
    try {
      server.getListenFuture().get(5, TimeUnit.SECONDS);
    } catch (InterruptedException | TimeoutException | ExecutionException e) {
      throw new RuntimeException(e);
    }
  }

  private void assertDisconnected() throws InterruptedException, ExecutionException {
    for (int i = 0; i < 2000; i++) {
      if (!client.isConnected()) break;
      TimeUnit.MILLISECONDS.sleep(50);
    }

    assertFalse(client.isConnected());
  }

  private void assertConnected() throws InterruptedException, ExecutionException {
    for (int i = 0; i < 50; i++) {
      if (client.isConnected()) break;
      TimeUnit.MILLISECONDS.sleep(100);
    }

    assertTrue(client.isConnected());
  }


  @Test
  public void shouldConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException {

    makeServer();

    makeClientAndSubscribeSync();

    assertConnected();

    server.assertSubscribed();

    List<Int128> receivedIds = new ArrayList<>();

    logger.debug("Sending message");
    for (int i = 0; i < 500; i++) {
      server.sendMessage(subId, "0-" + i);
    }

    while (receivedIds.size() != 500) {
      Int128 x = ids.poll(20, TimeUnit.SECONDS);
      assertNotNull(x);
      receivedIds.add(x);
    }

    List<Int128> sorted = new ArrayList<>(receivedIds);
    sorted.sort((o1, o2) -> o1.asString().compareTo(o2.asString()));

    assertEquals(sorted, receivedIds);
    server.close();


    assertDisconnected();


    makeServer();
    assertConnected();

    server.assertSubscribed();

    client.close();



  }

  @Test
  public void shouldRepeatedlyAttemptToConnect() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {

    makeClient();
    subscribeAsync(mySubId);

    TimeUnit.SECONDS.sleep(5);

    makeServer();

    assertConnected();

    server.assertSubscribed();

    server.close();
    client.close();

  }

  @Test
  public void trySubscribing() throws InterruptedException, URISyntaxException, IOException, ExecutionException, TimeoutException {

    makeServer();
    makeClientAndSubscribeSync();

    assertConnected();

    // server.assertSubscribed();

    client.subscribe("MySubId2",
            Collections.singletonMap("MyEntityType2",
                    Collections.singleton("MyEvent")),
            null, se -> {
              System.out.print("Y");
              return CompletableFuture.completedFuture("x");
            }).get(5, TimeUnit.SECONDS);

    client.close();

    server.close();

  }


  @Test
  public void shouldClose() throws Exception {

    makeServer();

    makeClientAndSubscribeSync();

    assertConnected();

    server.assertSubscribed();

    client.close();

    server.assertClientIsDisconnected();
  }


  @Test
  public void shouldProcessTwoSubscriptions() throws Exception {

    makeServer();

    makeClient();

    CompletableFuture sub1cf = new CompletableFuture();

    String subId1 = ((CompletableFuture<String>) client.subscribe("mySubscribeId1",
            Collections.singletonMap("MyEntityType",
                    Collections.singleton("MyEvent")),
            null, se -> {
              ids.add(se.getId());
              return sub1cf;
            })).get(4, TimeUnit.SECONDS);

    assertConnected();

    CompletableFuture sub2cf = new CompletableFuture();

    String subId2 = ((CompletableFuture<String>) client.subscribe("mySubscribeId2",
            Collections.singletonMap("MyEntityType",
                    Collections.singleton("MyEvent")),
            null, se -> {
              ids.add(se.getId());
              return sub2cf;
            })).get(4, TimeUnit.SECONDS);


    server.assertSubscribed();

    List<Int128> receivedIds = new ArrayList<>();

    server.sendMessage(subId1, "1-2");

    while (receivedIds.size() != 1) {
      Int128 x = ids.poll(20, TimeUnit.SECONDS);
      assertNotNull(x);
      receivedIds.add(x);
    }

    server.sendMessage(subId2, "3-4");

    while (receivedIds.size() != 2) {
      Int128 x = ids.poll(20, TimeUnit.SECONDS);
      assertNotNull(x);
      receivedIds.add(x);
    }

    sub2cf.complete(null);

    server.assertAcked(1);

    sub1cf.complete(null);

    server.assertAcked(2);

    server.close();


    assertDisconnected();


    makeServer();
    assertConnected();

    server.assertSubscribed();

    client.close();



  }

  }
```


Overlapping Code:
```
 EventuateSTOMPClientTest {
private Logger logger = LoggerFactory.getLogger(getClass());
private EventuateSTOMPClient client;
private TrackingStompServer server;
private EventuateCredentials credentials = new EventuateCredentials("x", "y", "default");
private static Vertx vertx;
private static int port;
private BlockingQueue<Int128> ids;
private String mySubId = "MySubId";
private String subId;
@Before
public void setUp() {
ids = new LinkedBlockingDeque<>();
}
@BeforeClass
public static void beforeClass() throws IOException {
port = PortUtil.findPort();
vertx = Vertx.vertx();
}
@AfterClass
public static void afterClass() {
if (vertx != null) vertx.close();
}
@After
public void tearDown() throws ExecutionException, InterruptedException {
if (server != null)
server.close();
}
private void makeClientAndSubscribeSync() throws URISyntaxException, ExecutionException, InterruptedException {
makeClient();
subscribeSync();
}
private void makeClient() throws URISyntaxException {
client = new EventuateSTOMPClient(vertx, credentials, new URI("stomp://localhost:" + port));
}
private void subscribeSync() throws InterruptedException, ExecutionException {
subId = subscribeAsync(mySubId).get();
}
private CompletableFuture<String> subscribeAsync(String subscribeId) {
return (CompletableFuture<String>) client.subscribe(subscribeId,
Collections.singletonMap("MyEntityType",
Collections.singleton("MyEvent")),
null, se -> {
ids.add(se.getId());
return CompletableFuture.completedFuture("x");
});
}
private void makeServer() {
server = new TrackingStompServer(vertx, port);
try {
server.getListenFuture().get(5, TimeUnit.SECONDS);
} catch (InterruptedException | TimeoutException | ExecutionException e) {
throw new RuntimeException(e);
}
}
private void assertDisconnected() throws InterruptedException, ExecutionException {
for (int i = 0; i < 2000; i++) {
if (!client.isConnected()) break;
TimeUnit.MILLISECONDS.sleep(50);
}
assertFalse(client.isConnected());
}
private void assertConnected() throws InterruptedException, ExecutionException {
for (int i = 0; i < 50; i++) {
if (client.isConnected()) break;
TimeUnit.MILLISECONDS.sleep(100);
}
assert
```
<Overlap Ratio: 0.9768392370572208>

---

--- 226 --
Question ID: 217eb679fc2ba5fd5115e9475ec1bbdb88bb5afc_0
Original Code:
```
@Service
@ConditionalOnProperty(prefix = "zk", value = "enabled", havingValue = "true", matchIfMissing = false)
@Slf4j
public class ZkDiscoveryService
    implements DiscoveryService, PathChildrenCacheListener, ApplicationListener<ApplicationReadyEvent> {

  @Value("${zk.url}")
  private String zkUrl;
  @Value("${zk.retry_interval_ms}")
  private Integer zkRetryInterval;
  @Value("${zk.connection_timeout_ms}")
  private Integer zkConnectionTimeout;
  @Value("${zk.session_timeout_ms}")
  private Integer zkSessionTimeout;
  @Value("${zk.zk_dir}")
  private String zkDir;

  private String zkNodesDir;

  @Autowired
  private ServerInstanceService serverInstance;

  private final List<DiscoveryServiceListener> listeners = new CopyOnWriteArrayList<>();

  private CuratorFramework client;
  private PathChildrenCache cache;
  private String nodePath;

  @PostConstruct
  public void init() {
    log.info("Initializing...");
    Assert.hasLength(zkUrl, MiscUtils.missingProperty("zk.url"));
    Assert.notNull(zkRetryInterval, MiscUtils.missingProperty("zk.retry_interval_ms"));
    Assert.notNull(zkConnectionTimeout, MiscUtils.missingProperty("zk.connection_timeout_ms"));
    Assert.notNull(zkSessionTimeout, MiscUtils.missingProperty("zk.session_timeout_ms"));

    log.info("Initializing discovery service using ZK connect string: {}", zkUrl);

    zkNodesDir = zkDir + "/nodes";
    try {
      client = CuratorFrameworkFactory.newClient(zkUrl, zkSessionTimeout, zkConnectionTimeout,
          new RetryForever(zkRetryInterval));
      client.start();
      client.blockUntilConnected();
      cache = new PathChildrenCache(client, zkNodesDir, true);
      cache.getListenable().addListener(this);
      cache.start();
    } catch (Exception e) {
      log.error("Failed to connect to ZK: {}", e.getMessage(), e);
      CloseableUtils.closeQuietly(client);
      throw new RuntimeException(e);
    }
  }

  @PreDestroy
  public void destroy() {
    unpublishCurrentServer();
    CloseableUtils.closeQuietly(client);
    log.info("Stopped discovery service");
  }

  @Override
  public void publishCurrentServer() {
    try {
      ServerInstance self = this.serverInstance.getSelf();
      log.info("[{}:{}] Creating ZK node for current instance", self.getHost(), self.getPort());
      nodePath = client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
          .forPath(zkNodesDir + "/", self.getServerInfo().toByteArray());
      log.info("[{}:{}] Created ZK node for current instance: {}", self.getHost(), self.getPort(), nodePath);
    } catch (Exception e) {
      log.error("Failed to create ZK node", e);
      throw new RuntimeException(e);
    }
  }

  @Override
  public void unpublishCurrentServer() {
    try {
      if (nodePath != null) {
        client.delete().forPath(nodePath);
      }
    } catch (Exception e) {
      log.error("Failed to delete ZK node {}", nodePath, e);
      throw new RuntimeException(e);
    }
  }

  @Override
  public ServerInstance getCurrentServer() {
    return serverInstance.getSelf();
  }

  @Override
  public List<ServerInstance> getOtherServers() {
    return cache.getCurrentData().stream().filter(cd -> !cd.getPath().equals(nodePath)).map(cd -> {
      try {
        return new ServerInstance(ServerInfo.parseFrom(cd.getData()));
      } catch (InvalidProtocolBufferException e) {
        log.error("Failed to decode ZK node", e);
        throw new RuntimeException(e);
      }
    }).collect(Collectors.toList());
  }

  @Override
  public boolean addListener(DiscoveryServiceListener listener) {
    return listeners.add(listener);
  }

  @Override
  public boolean removeListener(DiscoveryServiceListener listener) {
    return listeners.remove(listener);
  }

  @Override
  public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {
    publishCurrentServer();
    getOtherServers().forEach(server -> log.info("Found active server: [{}:{}]", server.getHost(), server.getPort()));
  }

  @Override
  public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)
      throws Exception {
    ChildData data = pathChildrenCacheEvent.getData();
    if (data == null) {
      log.debug("Ignoring {} due to empty child data", pathChildrenCacheEvent);
      return;
    } else if (data.getData() == null) {
      log.debug("Ignoring {} due to empty child's data", pathChildrenCacheEvent);
      return;
    } else if (nodePath != null && nodePath.equals(data.getPath())) {
      log.debug("Ignoring event about current server {}", pathChildrenCacheEvent);
      return;
    }
    ServerInstance instance;
    try {
      instance = new ServerInstance(ServerInfo.parseFrom(data.getData()));
    } catch (IOException e) {
      log.error("Failed to decode server instance for node {}", data.getPath(), e);
      throw e;
    }
    log.info("Processing [{}] event for [{}:{}]", pathChildrenCacheEvent.getType(), instance.getHost(),
        instance.getPort());
    switch (pathChildrenCacheEvent.getType()) {
    case CHILD_ADDED:
      listeners.forEach(listener -> listener.onServerAdded(instance));
      break;
    case CHILD_UPDATED:
      listeners.forEach(listener -> listener.onServerUpdated(instance));
      break;
    case CHILD_REMOVED:
      listeners.forEach(listener -> listener.onServerRemoved(instance));
      break;
    }
  }
}
```


Overlapping Code:
```
vice
@ConditionalOnProperty(prefix = "zk", value = "enabled", havingValue = "true", matchIfMissing = false)
@Slf4j
public class ZkDiscoveryService
implements DiscoveryService, PathChildrenCacheListener, ApplicationListener<ApplicationReadyEvent> {
@Value("${zk.url}")
private String zkUrl;
@Value("${zk.retry_interval_ms}")
private Integer zkRetryInterval;
@Value("${zk.connection_timeout_ms}")
private Integer zkConnectionTimeout;
@Value("${zk.session_timeout_ms}")
private Integer zkSessionTimeout;
@Value("${zk.zk_dir}")
private String zkDir;
private String zkNodesDir;
@Autowired
private ServerInstanceService serverInstance;
private final List<DiscoveryServiceListener> listeners = new CopyOnWriteArrayList<>();
private CuratorFramework client;
private PathChildrenCache cache;
private String nodePath;
@PostConstruct
public void init() {
log.info("Initializing...");
Assert.hasLength(zkUrl, MiscUtils.missingProperty("zk.url"));
Assert.notNull(zkRetryInterval, MiscUtils.missingProperty("zk.retry_interval_ms"));
Assert.notNull(zkConnectionTimeout, MiscUtils.missingProperty("zk.connection_timeout_ms"));
Assert.notNull(zkSessionTimeout, MiscUtils.missingProperty("zk.session_timeout_ms"));
log.info("Initializing discovery service using ZK connect string: {}", zkUrl);
zkNodesDir = zkDir + "/nodes";
try {
client = CuratorFrameworkFactory.newClient(zkUrl, zkSessionTimeout, zkConnectionTimeout,
new RetryForever(zkRetryInterval));
client.start();
client.blockUntilConnected();
cache = new PathChildrenCache(client, zkNodesDir, true);
cache.getListenable().addListener(this);
cache.start();
} catch (Exception e) {
log.error("Failed to connect to ZK: {}", e.getMessage(), e);
CloseableUtils.closeQuietly(client);
throw new RuntimeException(e);
}
}
@PreDestroy
public void destroy() {
unpublishCurrentServer();
CloseableUtils.closeQuietly(client);
log.info("Stopped discovery service");
}
@Override
public void publishCurrentServer() {
try {
ServerInstance self = this.serverInstance.getSelf();
log.info("[{}:{}] Creating ZK node for current instance", self.getHost(), self.getPort());
nodePath = client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
.forPath(zkNodesDir + "/", self.getServerInfo
```
<Overlap Ratio: 0.9780797895659799>

---

--- 227 --
Question ID: 4365f154534fa25cfd1b30eb34d382ab0be9b254_0
Original Code:
```
public class AssignImportTest extends TestBase {
    public AssignImportTest() {
        super(AssignImportTest.class);
    }

    @Test
    public void testImportAsync() throws Exception {
        ArrayList<ServerName> serverNameList;
        List<HRegionInfo> regionInfoList;
        ServerName rs1, rs2;
        List<String> assignmentList;

        String expFileName = "export_test.exp";

        splitTable("a".getBytes());
        splitTable("b".getBytes());

        serverNameList = getServerNameList();
        rs1 = serverNameList.get(0);
        rs2 = serverNameList.get(1);

        // move all regions to rs1
        regionInfoList = getRegionInfoList(tableName);
        for (HRegionInfo hRegionInfo : regionInfoList)
            move(hRegionInfo, rs1);
        assertEquals(regionInfoList.size(), getRegionInfoList(rs1, tableName).size());

        boolean balancerRunning = false;
        try {
            String[] argsParam;
            Args args;
            Assign command;

            // export
            balancerRunning = admin.setBalancerRunning(false, true);
            argsParam = new String[]{"zookeeper", "export", expFileName};
            args = new ManagerArgs(argsParam);
            command = new Assign(admin, args);
            command.run();

            assignmentList = AssignTest.readExportFile(expFileName);
            assertEquals(AssignAction.getProcessedCount(), assignmentList.size());

            // remember region count of rs1
            int regionCountRS1 = getRegionInfoList(rs1, tableName).size();

            // move all regions to rs2
            regionInfoList = getRegionInfoList(tableName);
            for (HRegionInfo hRegionInfo : regionInfoList)
                move(hRegionInfo, rs2);
            assertEquals(0, getRegionInfoList(rs1, tableName).size());
            assertEquals(regionInfoList.size(), getRegionInfoList(rs2, tableName).size());

            // import
            balancerRunning = admin.setBalancerRunning(false, true);
            argsParam = new String[]{"zookeeper", "import", expFileName, "--force-proceed", "--move-async"};
            args = new ManagerArgs(argsParam);
            command = new Assign(admin, args);
            command.run();

            // verify
            assertEquals(regionCountRS1, getRegionInfoList(rs1, tableName).size());
            assertEquals(regionInfoList.size(), getRegionInfoList(tableName).size());
        } finally {
            if (balancerRunning)
                admin.setBalancerRunning(true, true);
            Files.delete(Paths.get(expFileName));
        }
    }

    @Test
    public void testImportWithRS() throws Exception {
        ArrayList<ServerName> serverNameList;
        List<HRegionInfo> regionInfoList;
        ServerName rs1, rs2;

        String expFileName = "export_test.exp";

        splitTable("a".getBytes());
        splitTable("b".getBytes());

        serverNameList = getServerNameList();
        rs1 = serverNameList.get(0);
        rs2 = serverNameList.get(1);

        // move all regions to rs1 except 1
        regionInfoList = getRegionInfoList(tableName);
        for (HRegionInfo hRegionInfo : regionInfoList)
            move(hRegionInfo, rs1);
        HRegionInfo region1 = regionInfoList.get(0);
        HRegionInfo region2 = regionInfoList.get(1);
        HRegionInfo region3 = regionInfoList.get(2);
        move(region1, rs2);
        assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));
        assertEquals(region2, getRegionInfoList(rs1, tableName).get(0));
        assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));

        boolean balancerRunning = false;
        try {
            String[] argsParam;
            Args args;
            Assign command;

            balancerRunning = admin.setBalancerRunning(false, true);

            // export all RSs
            argsParam = new String[]{"zookeeper", "export", expFileName};
            args = new ManagerArgs(argsParam);
            command = new Assign(admin, args);
            command.run();

            // move regions
            move(region1, rs1);
            move(region2, rs2);
            move(region3, rs1);
            assertEquals(region1, getRegionInfoList(rs1, tableName).get(0));
            assertEquals(region2, getRegionInfoList(rs2, tableName).get(0));
            assertEquals(region3, getRegionInfoList(rs1, tableName).get(1));

            // import rs2
            String serverNameModified = rs2.getServerName().substring(0,
                rs2.getServerName().lastIndexOf(",")) + "," + System.currentTimeMillis();
            argsParam = new String[]{"zookeeper", "import", expFileName,
                "--force-proceed", "--rs=" + serverNameModified};
            args = new ManagerArgs(argsParam);
            command = new Assign(admin, args);
            command.run();

            // check
            assertEquals(region1, getRegionInfoList(rs2, tableName).get(0));
            assertEquals(region2, getRegionInfoList(rs2, tableName).get(1));
            assertEquals(region3, getRegionInfoList(rs1, tableName).get(0));
        } finally {
            if (balancerRunning)
                admin.setBalancerRunning(true, true);
            Files.delete(Paths.get(expFileName));
        }
    }
}
```


Overlapping Code:
```
ass AssignImportTest extends TestBase {
public AssignImportTest() {
super(AssignImportTest.class);
}
@Test
public void testImportAsync() throws Exception {
ArrayList<ServerName> serverNameList;
List<HRegionInfo> regionInfoList;
ServerName rs1, rs2;
List<String> assignmentList;
String expFileName = "export_test.exp";
splitTable("a".getBytes());
splitTable("b".getBytes());
serverNameList = getServerNameList();
rs1 = serverNameList.get(0);
rs2 = serverNameList.get(1);
// move all regions to rs1
regionInfoList = getRegionInfoList(tableName);
for (HRegionInfo hRegionInfo : regionInfoList)
move(hRegionInfo, rs1);
assertEquals(regionInfoList.size(), getRegionInfoList(rs1, tableName).size());
boolean balancerRunning = false;
try {
String[] argsParam;
Args args;
Assign command;
// export
balancerRunning = admin.setBalancerRunning(false, true);
argsParam = new String[]{"zookeeper", "export", expFileName};
args = new ManagerArgs(argsParam);
command = new Assign(admin, args);
command.run();
assignmentList = AssignTest.readExportFile(expFileName);
assertEquals(AssignAction.getProcessedCount(), assignmentList.size());
// remember region count of rs1
int regionCountRS1 = getRegionInfoList(rs1, tableName).size();
// move all regions to rs2
regionInfoList = getRegionInfoList(tableName);
for (HRegionInfo hRegionInfo : regionInfoList)
move(hRegionInfo, rs2);
assertEquals(0, getRegionInfoList(rs1, tableName).size());
assertEquals(regionInfoList.size(), getRegionInfoList(rs2, tableName).size());
// import
balancerRunning = admin.setBalancerRunning(false, true);
argsParam = new String[]{"zookeeper", "import", expFileName, "--force-proceed", "--move-async"};
args = new ManagerArgs(argsParam);
command = new Assign(admin, args);
command.run();
// verify
assertEquals(regionCountRS1, getRegionInfoList(rs1, tableName).size());
assertEquals(regionInfoList.size(), getRegionInfoList(tableName).size
```
<Overlap Ratio: 0.9763617677286742>

---

--- 228 --
Question ID: 8c165c1dbb6ddc63cf19943b671c28ef4aba71d0_0
Original Code:
```
public class CreateMeshOperation {

    private macroutils.checker.MainChecker _chk = null;
    private macroutils.misc.MainDisabler _dis = null;
    private macroutils.getter.MainGetter _get = null;
    private macroutils.io.MainIO _io = null;
    private MacroUtils _mu = null;
    private macroutils.setter.MainSetter _set = null;
    private Simulation _sim = null;
    private macroutils.UserDeclarations _ud = null;

    /**
     * Main constructor for this class.
     *
     * @param m given MacroUtils object.
     */
    public CreateMeshOperation(MacroUtils m) {
        _mu = m;
        _sim = m.getSimulation();
    }

    /**
     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.
     *
     * @param ag given ArrayList of Geometry Parts.
     * @param am given ArrayList of Meshers. <u>Hint</u>: use with
     *           {@link macroutils.getter.GetStrings#meshers}.
     * @return The AutoMeshOperation.
     */
    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag, ArrayList<String> am) {
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        AutoMeshOperation amo = mom.createAutoMeshOperation(am, ag);
        _setAutomatedMesh(amo, ag, "");
        return amo;
    }

    /**
     * Creates an Automated Mesh Mesh Operation for the given Geometry Parts.
     *
     * @param ag      given ArrayList of Geometry Parts.
     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}
     *                for options.
     * @return The AutoMeshOperation.
     */
    public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag,
            StaticDeclarations.Meshers... meshers) {
        return automatedMesh(ag, _get.strings.meshers(meshers));
    }

    /**
     * Creates a Badge for 2D Mesh Operation on a set of Geometry Parts.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @return The PrepareFor2dOperation.
     */
    public PrepareFor2dOperation badgeFor2D(ArrayList<GeometryPart> agp) {
        _io.say.action("Creating a Badge for 2D Mesh Operation", true);
        _io.say.objects(agp, "Geometry Parts", true);
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        PrepareFor2dOperation p2d = (PrepareFor2dOperation) mom.createPrepareFor2dOperation(agp);
        p2d.execute();
        _io.say.created(p2d, true);
        return p2d;
    }

    /**
     * Creates a Bounded Shape Block with individual offsets.
     *
     * @param agp            given ArrayList of Geometry Parts.
     * @param negOffset      given negative 3-components offset array using
     *                       {@link UserDeclarations#defUnitLength} units.
     * @param posOffset      given positive 3-components offset array using
     *                       {@link UserDeclarations#defUnitLength} units.
     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry
     *                       Parts.
     * @return The MeshOperationPart.
     */
    public MeshOperationPart boundedShape_Block(ArrayList<GeometryPart> agp, double[] negOffset,
            double[] posOffset, double[] centroidOffset) {
        Units u = _ud.defUnitLength;
        _io.say.action("Creating a Block Bounded Shape Mesh Operation", true);
        _io.say.objects(agp, "Geometry Parts", true);
        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,
                BoundedShapeCreatingOperation.OutputPartType.BLOCK);
        BoxShapeInflationControl bsic = bsmo.getBoundedShapeValuesManager()
                .get(BoxShapeInflationControl.class);
        bsic.setInflationMode(BoxShapeInflationControl.InflationMode.INDIVIDUAL_OFFSETS);
        BoxShapeIndividualOffsetsInflation bsioi = bsic.getIndividualInflationOffsets();
        _set.object.physicalQuantity(bsioi.getNXOffset(), negOffset[0], u, "-X Offset", true);
        _set.object.physicalQuantity(bsioi.getNYOffset(), negOffset[1], u, "-Y Offset", true);
        _set.object.physicalQuantity(bsioi.getNZOffset(), negOffset[2], u, "-Z Offset", true);
        _set.object.physicalQuantity(bsioi.getPXOffset(), posOffset[0], u, "+X Offset", true);
        _set.object.physicalQuantity(bsioi.getPYOffset(), posOffset[1], u, "+Y Offset", true);
        _set.object.physicalQuantity(bsioi.getPZOffset(), posOffset[2], u, "+Z Offset", true);
        _setCentroidOffset(bsmo, centroidOffset);
        bsmo.execute();
        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());
        _io.say.created(bsmo, true);
        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);
    }

    /**
     * Creates a Bounded Shape Sphere with individual offsets.
     *
     * @param agp            given ArrayList of Geometry Parts.
     * @param factor         given inflation factor w.r.t. centroid supplied as Parts.
     * @param centroidOffset given 3-components offset array for the centroid of supplied Geometry
     *                       Parts.
     * @return The MeshOperationPart.
     */
    public MeshOperationPart boundedShape_Sphere(ArrayList<GeometryPart> agp, double factor,
            double[] centroidOffset) {
        Units u = _ud.defUnitLength;
        _io.say.action("Creating a Block Bounded Shape Mesh Operation", true);
        _io.say.objects(agp, "Geometry Parts", true);
        BoundedShapeCreatingOperation bsmo = _createBoundedShapeMeshOp(agp,
                BoundedShapeCreatingOperation.OutputPartType.SPHERE);
        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();
        bscm.get(BoundedShapeConstantFactorInflation.class).setInflationFactor(factor);
        _io.say.value("Inflation Factor", factor, true);
        _setCentroidOffset(bsmo, centroidOffset);
        bsmo.execute();
        String opName = _get.strings.withinTheBrackets(bsmo.getOutputPartNames());
        _io.say.created(bsmo, true);
        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);
    }

    /**
     * Creates a One Group Contact Prevention with the supplied Geometry Objects.
     *
     * @param mo  given Mesh Operation.
     * @param ago given ArrayList of Geometry Objects.
     * @param val given search floor value.
     * @param u   given units for the search floor.
     * @return The PartsOneGroupContactPreventionSet.
     */
    public PartsOneGroupContactPreventionSet contactPrevention(MeshOperation mo,
            ArrayList<GeometryObject> ago, double val, Units u) {
        _io.say.action("Creating a Contact Prevention between Object Parts", true);
        _io.say.object(mo, true);
        _io.say.objects(ago, "Geometry Objects", true);
        if (!_chk.is.surfaceWrapperOperation(mo)) {
            _io.say.msg(true, "This is not a Surface Wrapper Mesh Operation. Skipping...");
            return null;
        }
        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) mo;
        PartsContactPreventionSetManager pcpsm = swamo.getContactPreventionSet();
        PartsOneGroupContactPreventionSet cp = pcpsm.createPartsOneGroupContactPreventionSet();
        cp.getPartSurfaceGroup().setObjects(ago);
        _set.object.physicalQuantity(cp.getFloor(), val, u, "Search Floor", true);
        _io.say.ok(true);
        return cp;
    }

    /**
     * Creates a Directed Mesh Operation using an Automated 2D Mesh.
     *
     * @param src     given Source Part Surface.
     * @param tgt     given Target Part Surface.
     * @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}
     *                for options.
     * @param nVol    given number of layers in volume distribution.
     * @return The DirectedMeshOperation.
     */
    public DirectedMeshOperation directedMeshing_AutoMesh(PartSurface src, PartSurface tgt,
            int nVol, StaticDeclarations.Meshers... meshers) {
        _io.say.action("Creating a Directed Mesh Operation with an Automated 2D Mesh", true);
        _io.say.object(src, true);
        _io.say.object(tgt, true);
        _io.say.msg(true, "Number of Layers: %d.", nVol);
        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);
        //--
        String pn = src.getPart().getPresentationName();
        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();
        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));
        DirectedSurfaceMeshBaseManager dsmbm = dmo.getGuidedSurfaceMeshBaseManager();
        dsmbm.createAutoSourceMesh(_get.strings.meshers(meshers), _get.objects.arrayList(dmpc));
        DirectedAutoSourceMesh dasm = (DirectedAutoSourceMesh) dsmbm.getObjects().iterator().next();
        _setMeshDefaults(dasm.getDefaultValues());
        _setWorkAroundAutoSourceMesh(dasm, src.getPart());
        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();
        DirectedMeshDistribution dmd = dmdm
                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),
                        "Constant");
        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);
        dmo.execute();
        _io.say.created(dmo, true);
        return dmo;
    }

    /**
     * Creates a Directed Mesh Operation in a squared Channel.
     *
     * @param src given Source Part Surface.
     * @param tgt given Target Part Surface.
     * @param nX  given number of points in X-direction.
     * @param nY  given number of points in Y-direction.
     * @param nZ  given number of points in Z-direction.
     * @return The DirectedMeshOperation.
     */
    public DirectedMeshOperation directedMeshing_Channel(PartSurface src, PartSurface tgt,
            int nX, int nY, int nZ) {
        _io.say.action("Creating a Directed Mesh Operation in a Channel", true);
        _io.say.msg("Number of Elements:");
        _io.say.msg(true, "  - X Direction: %d;", nX);
        _io.say.msg(true, "  - Y Direction: %d;", nY);
        _io.say.msg(true, "  - Z Direction: %d.", nZ);
        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);
        int isX = 0, isY = 0, isZ = 0;
        int nP1 = 2, nP2 = 2, nVol = 2;
        PatchCurve pcX = null, pcY = null, pcZ = null, pc1 = null, pc2 = null;
        //--
        String pn = src.getPart().getPresentationName();
        DirectedMeshPartCollectionManager dmpcm = dmo.getGuidedMeshPartCollectionManager();
        DirectedMeshPartCollection dmpc = ((DirectedMeshPartCollection) dmpcm.getObject(pn));
        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));
        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));
        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,
                vpsSrc, vpsTgt);
        //--
        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()
                .createPatchSourceMesh(vpsSrc, dmpc);
        NeoProperty np = patchMsh.autopopulateFeatureEdges();
        ArrayList<PatchCurve> pcs = _getPatchCurves(patchMsh);
        //--
        double err = 0.05;
        for (PatchCurve p : pcs) {
            DoubleVector pts = p.getPoints();
            if (_get.info.relativeError(pts.get(0), pts.get(3), true) <= err) {
                isX += 1;
                pcX = p;
                _io.say.msg(p.getPresentationName() + " is on X plane.");
            }
            if (_get.info.relativeError(pts.get(1), pts.get(4), true) <= err) {
                isY += 1;
                pcY = p;
                _io.say.msg(p.getPresentationName() + " is on Y plane.");
            }
            if (_get.info.relativeError(pts.get(2), pts.get(5), true) <= err) {
                isZ += 1;
                pcZ = p;
                _io.say.msg(p.getPresentationName() + " is on Z plane.");
            }
        }
        //_io.say.msg("X = %d; Y = %d; Z = %d.", isX, isY, isZ);
        //--
        if (isX == 4) {
            nVol = nX;
            pc1 = pcY;
            nP2 = nY;
            pc2 = pcZ;
            nP1 = nZ;
        } else if (isY == 4) {
            nVol = nY;
            pc1 = pcX;
            nP2 = nX;
            pc2 = pcZ;
            nP1 = nZ;
        } else if (isZ == 4) {
            nVol = nZ;
            pc1 = pcX;
            nP2 = nX;
            pc2 = pcY;
            nP1 = nY;
        }
        //--
        patchMsh.defineMeshPatchCurve(pc1, pc1.getStretchingFunction(), 0., 0., nP1, false, false);
        patchMsh.defineMeshPatchCurve(pc2, pc2.getStretchingFunction(), 0., 0., nP2, false, false);
        //--
        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();
        DirectedMeshDistribution dmd = dmdm
                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),
                        "Constant");
        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);
        dmo.execute();
        _io.say.created(dmo, true);
        return dmo;
    }

    /**
     * Creates a Directed Mesh Operation in a Pipe, using an O-Grid structure.
     *
     * @param src  given Source Part Surface.
     * @param tgt  given Target Part Surface.
     * @param nT   given number of points in the circumference, i.e., Theta direction.
     * @param nR   given number of points radially.
     * @param nVol given number of points for the volume distribution.
     * @param rR   given r/R distance for the O-Grid. E.x.: 0.5;
     * @param c    given Cylindrical Coordinate System.
     * @return The DirectedMeshOperation.
     */
    public DirectedMeshOperation directedMeshing_Pipe(PartSurface src, PartSurface tgt,
            int nT, int nR, int nVol, double rR, CoordinateSystem c) {
        _io.say.action("Creating a Directed Mesh Operation in a Pipe", true);
        if (!_chk.is.cylindricalCSYS(c)) {
            _io.say.value("Warning! Not a Cylindrical Coordinate System", c.getPresentationName(),
                    true, true);
            _io.say.msg("Directed Mesh not created.");
            return null;
        }
        _io.say.msg("Number of Elements:");
        _io.say.msg(true, "  - Tangent Direction (theta): %d;", nT);
        _io.say.msg(true, "  - Radial Direction (r): %d;", nR);
        _io.say.msg(true, "  - Along Pipe (axially): %d.", nVol);
        DirectedMeshOperation dmo = _createDirectedMeshOperation(src, tgt);
        CylindricalCoordinateSystem ccs = (CylindricalCoordinateSystem) c;
        //--
        String s = src.getPart().getPresentationName();
        DirectedMeshPartCollection dmpc = dmo.getGuidedMeshPartCollectionManager().getObject(s);
        Vector<PartSurface> vpsSrc = new Vector<>(_get.objects.arrayList(src));
        Vector<PartSurface> vpsTgt = new Vector<>(_get.objects.arrayList(tgt));
        dmo.getGuidedSurfaceMeshBaseManager().validateConfigurationForPatchMeshCreation(dmpc,
                vpsSrc, vpsTgt);
        //--
        DirectedPatchSourceMesh patchMsh = dmo.getGuidedSurfaceMeshBaseManager()
                .createPatchSourceMesh(vpsSrc, dmpc);
        NeoProperty np = patchMsh.autopopulateFeatureEdges();
        //_io.say.msg("NeoProperty np = patchMsh.autopopulateFeatureEdges();");
        //_io.say.msg(np.getHashtable().toString());
        //--

        //-- Trying the simple approach, i.e., split existing patch curves
        ArrayList<PatchCurve> pcExts = new ArrayList<>();
        ArrayList<PatchCurve> pcInts = new ArrayList<>();
        ArrayList<PatchCurve> stockCurves = _getPatchCurves(patchMsh);
        _sayPatchVerticesNames(_getPatchVertices(patchMsh));

        if (stockCurves.size() == 2) {

            // External curves creation
            stockCurves.forEach(patchCurve -> {
                _io.say.msg("Splitting external Patch Curve: " + patchCurve.getPresentationName());
                patchMsh.splitPatchCurve(patchCurve, 1);
                _sayPatchVerticesNames(_getPatchVertices(patchMsh));
            });
            List<PatchCurve> externalCurves = _getPatchCurves(patchMsh);
            List<PatchVertex> sortedVertices = _getPatchVerticesSortedByAngle(patchMsh, ccs);

            // Internal Patch curves creation
            _io.say.msg("Building internal Patch Curves...");
            _io.say.msg(" ");
            List<PatchCurve> internalCurves = new ArrayList<>();
            List<PatchVertex> internalVertices = new ArrayList<>();

            sortedVertices.forEach(externalVertex -> {

                // In cylindrical coordinates
                Vector3 cartCoordsExt = new Vector3(externalVertex.getCoordinate().toDoubleArray());
                Vector3 cylCoordsExt = _getVector3(externalVertex, ccs);
                double extR = cylCoordsExt.x;
                double theta = cylCoordsExt.y;
                Vector3 cylCoordsInt = new Vector3(extR * rR, theta, 0.0);

                // Back to cartesian
                Vector3 cartCoordsInt = ccs.transformCoordinate(cylCoordsInt);

                _io.say.msg("  - External Coordinate [Cyl]: " + cylCoordsExt.toString());
                _io.say.msg("  - Internal Coordinate [Cyl]: " + cylCoordsInt.toString());
                _io.say.msg("  - External Coordinate [Cart]: " + cartCoordsExt.toString());
                _io.say.msg("  - Internal Coordinate [Cart]: " + cartCoordsInt.toString());

                // Create new internal Patch curve
                patchMsh.createPatchCurve(externalVertex, null,
                        new DoubleVector(cartCoordsInt.toArray()),
                        new StringVector(new String[] {"ON_SURFACE"}));

                // Find out which new vertex was created
                List<PatchVertex> currentVertices = _getPatchVertices(patchMsh);
                currentVertices.removeAll(sortedVertices);
                currentVertices.removeAll(internalVertices);

                PatchVertex createdVertex = currentVertices.get(0);
                internalVertices.add(createdVertex);

                List<PatchCurve> currentCurves = _getPatchCurves(patchMsh);
                currentCurves.removeAll(externalCurves);
                currentCurves.removeAll(internalCurves);

                PatchCurve createdCurve = currentCurves.get(0);
                internalCurves.add(createdCurve);

                _io.say.msg("  - Created Patch Curve: " + createdCurve.getPresentationName());
                _io.say.msg("  - Created Patch Vertex: " + createdVertex.getPresentationName());
                _io.say.msg(" ");

            });

            // Finally connect all the internal created vertices to close the O-Grid loop
            internalVertices.add(internalVertices.get(0));
            _io.say.msg("Connecting internal Patch Vertices...");
            _io.say.msg(" ");
            _sayPatchVerticesNames(internalVertices);

            for (int i = 1; i < internalVertices.size(); i++) {

                PatchVertex fromVertex = internalVertices.get(i-1);
                PatchVertex toVertex = internalVertices.get(i);
                _io.say.msg("  - From Patch Vertex: " + fromVertex.getPresentationName());
                _io.say.msg("  - To Patch Vertex: " + toVertex.getPresentationName());
                _io.say.msg(" ");

                patchMsh.createPatchCurve(fromVertex, toVertex, new DoubleVector(new double[] {}),
                        new StringVector(new String[] {}));

            }

            // Mesh distribution in theta
            pcExts.addAll(externalCurves);

            // Radial mesh distribution -- only one is needed
            pcInts.add(internalCurves.get(0));


        } else {

            // Reevaluate when happening
            return null;

        }

        //--
        //--
        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcExts), nT, false);
        patchMsh.defineMeshMultiplePatchCurves(new Vector<>(pcInts), nR, false);
        if (_ud.dmSmooths > 0) {
            patchMsh.smoothPatchPolygonMesh(_ud.dmSmooths, 0.25, false);
        }
        //--
        DirectedMeshDistributionManager dmdm = dmo.getDirectedMeshDistributionManager();
        DirectedMeshDistribution dmd = dmdm
                .createDirectedMeshDistribution(new Vector<>(_get.objects.arrayList(dmpc)),
                        "Constant");
        dmd.getDefaultValues().get(DirectedMeshNumLayers.class).setNumLayers(nVol);
        dmo.execute();
        _io.say.created(dmo, true);
        return dmo;
    }

    /**
     * Creates a Extract Volume Mesh Operation on the supplied geometries.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @return The ExtractVolumeOperation.
     */
    public ExtractVolumeOperation extractVolume(ArrayList<GeometryPart> agp) {
        _io.say.action("Creating a Extract Volume Operation", true);
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        MeshOperation mo = mom.createExtractVolumeOperation(agp);
        _io.say.objects(agp, "Geometry Parts", true);
        mo.execute();
        _io.say.ok(true);
        return (ExtractVolumeOperation) mo;
    }

    /**
     * Creates a Fill Holes Mesh Operation on the supplied geometry objects.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @param aps given ArrayList of Part Surfaces.
     * @param apc given ArrayList of Part Curves. null is ignored.
     * @return The FillHolesOperation.
     */
    public FillHolesOperation fillHoles(ArrayList<GeometryPart> agp, ArrayList<PartSurface> aps,
            ArrayList<PartCurve> apc) {
        _io.say.action("Creating a Fill Holes Operation", true);
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        FillHolesOperation fho = (FillHolesOperation) mom.createFillHolesOperation(agp);
        _io.say.objects(agp, "Geometry Parts", true);
        _io.say.objects(aps, "Part Surfaces", true);
        fho.getEndSurfaces().setObjects(aps);
        if (apc != null) {
            _io.say.objects(aps, "Part Curves", true);
            fho.getEndCurves().setObjects(apc);
        }
        fho.execute();
        _io.say.ok(true);
        return fho;
    }

    /**
     * Creates an Imprint Mesh Operation with the given Parts.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @param tol given tolerance in {@link UserDeclarations#defUnitLength} unit.
     * @param it  given Imprint Method.
     * @param mt  given Resulting Mesh Type
     * @return The ImprintPartsOperation.
     */
    public ImprintPartsOperation imprint(ArrayList<GeometryPart> agp, double tol,
            ImprintMergeImprintMethodOption.Type it, ImprintResultingMeshTypeOption.Type mt) {
        _io.say.action("Creating an Imprint Mesh Operation", true);
        _io.say.objects(agp, "Geometry Parts", true);
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        MeshOperation mo = mom.createImprintPartsOperation(agp);
        ImprintPartsOperation ipo = (ImprintPartsOperation) mo;
        ipo.getMergeImprintMethod().setSelected(it);
        ipo.getResultingMeshType().setSelected(mt);
        _io.say.value("Imprint Method",
                ipo.getMergeImprintMethod().getSelectedElement().getPresentationName(), true, true);
        _io.say.value("Resulting Mesh",
                ipo.getResultingMeshType().getSelectedElement().getPresentationName(), true, true);
        _set.object.physicalQuantity(ipo.getTolerance(), tol, _ud.defUnitLength, "Tolerance", true);
        if (it == ImprintMergeImprintMethodOption.Type.CAD_IMPRINT) {
            ipo.getImprintValuesManager().get(CadTessellationOption.class)
                    .getTessellationDensityOption().setSelected(_ud.defTessOpt.getType());
        }
        if (mt == ImprintResultingMeshTypeOption.Type.CONFORMAL) {
            ipo.getImprintValuesManager().get(ImprintPartSurfaces.class)
                    .getPartSurfacesOption().setSelected(ImprintPartSurfacesOption.Type.USE_INPUT);
        }
        _io.say.created(ipo, true);
        return ipo;
    }

    /**
     * Creates a Subtraction Mesh Operation between a set of Geometry Parts.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @param tgt given target Geometry Part.
     * @return The MeshOperationPart.
     */
    public MeshOperationPart subtract(ArrayList<GeometryPart> agp, GeometryPart tgt) {
        return _createBoolean(StaticDeclarations.Operation.SUBTRACT, agp, tgt);
    }

    /**
     * Creates an empty Custom Surface Control.
     *
     * @param mo given Mesh Operation.
     * @return The SurfaceCustomMeshControl.
     */
    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo) {
        return _createSurfaceCustomMeshControl(mo, true);
    }

    /**
     * Copies a Custom Surface Control from another another Mesh Operation.
     *
     * @param scmc given Surface Control to copy.
     * @param mo   given Mesh Operation where will be copied too.
     * @return The SurfaceCustomMeshControl.
     */
    public SurfaceCustomMeshControl surfaceControl(SurfaceCustomMeshControl scmc,
            MeshOperation mo) {
        _io.say.action("Creating a Custom Surface Mesh Control", true);
        _io.say.object(scmc, true);
        _io.say.object(mo, true);
        SurfaceCustomMeshControl scmc2 = _createSurfaceCustomMeshControl(mo, false);
        scmc2.setPresentationName(scmc.getPresentationName());
        scmc2.copyProperties(scmc);
        _io.say.msg("Properties copied succesfully.");
        _io.say.created(scmc2, true);
        return scmc2;
    }

    /**
     * Creates a Custom Surface Control to change Surface Sizes in a Mesh Operation.
     *
     * @param mo  given Mesh Operation.
     * @param ago given ArrayList of Geometry Objects.
     * @param min minimum relative size (%). If 0, this parameter will not be customized.
     * @param tgt target relative size (%). If 0, this parameter will not be customized.
     * @return The Custom Surface Control.
     */
    public SurfaceCustomMeshControl surfaceControl(MeshOperation mo, ArrayList<GeometryObject> ago,
            double min, double tgt) {
        _io.say.action("Creating a Custom Surface Mesh Control", true);
        _io.say.object(mo, true);
        _io.say.objects(ago, "Geometry Objects", true);
        SurfaceCustomMeshControl scmc = _createSurfaceCustomMeshControl(mo, false);
        scmc.getGeometryObjects().setObjects(ago);
        _set.mesh.surfaceSizes(scmc, min, tgt, true);
        _io.say.created(scmc, true);
        return scmc;
    }

    /**
     * Creates a Custom Surface Control to change Prism Layers in a Mesh Operation.
     *
     * <b>Important:</b> If all three arguments are 0, Prisms will be disabled.
     *
     * @param amo       given Auto Mesh Operation.
     * @param ago       given ArrayList of Geometry Objects.
     * @param numLayers given number of prisms. If 0, this parameter will not be customized.
     * @param stretch   given prism stretch relation. If 0, this parameter will not be customized.
     * @param relSize   given relative size in (%). If 0, this parameter will not be customized.
     * @return The Custom Surface Control.
     */
    public SurfaceCustomMeshControl surfaceControl(AutoMeshOperation amo,
            ArrayList<GeometryObject> ago, int numLayers, double stretch, double relSize) {
        _io.say.action("Creating a Custom Surface Mesh Control", true);
        _io.say.object(amo, true);
        _io.say.objects(ago, "Geometry Objects", true);
        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();
        scmc.getGeometryObjects().setObjects(ago);
        PartsCustomizePrismMesh pcpm = scmc.getCustomConditions()
                .get(PartsCustomizePrismMesh.class);
        if (numLayers + stretch + relSize == 0.0) {
            _dis.prismsLayers(scmc, false);
            _io.say.msg("Prism Layers DISABLED.");
        } else {
            pcpm.getCustomPrismOptions().setSelected(PartsCustomPrismsOption.Type.CUSTOMIZE);
            CustomPrismValuesManager cpvm = scmc.getCustomValues()
                    .get(CustomPrismValuesManager.class);
            if (numLayers > 0) {
                pcpm.getCustomPrismControls().setCustomizeNumLayers(true);
                cpvm.get(NumPrismLayers.class).setNumLayers(numLayers);
            } else {
                pcpm.getCustomPrismControls().setCustomizeNumLayers(false);
            }
            if (stretch > 0) {
                pcpm.getCustomPrismControls().setCustomizeStretching(true);
                cpvm.get(PrismLayerStretching.class).setStretching(stretch);
            } else {
                pcpm.getCustomPrismControls().setCustomizeStretching(false);
            }
            if (relSize > 0) {
                pcpm.getCustomPrismControls().setCustomizeTotalThickness(true);
                cpvm.get(PrismThickness.class).setRelativeSize(relSize);
            } else {
                pcpm.getCustomPrismControls().setCustomizeTotalThickness(false);
            }
        }
        _io.say.created(scmc, true);
        return scmc;
    }

    /**
     * Creates a Surface Wrap Mesh Operation in a set of Geometry Parts.
     *
     * @param agp  given ArrayList of Geometry Parts.
     * @param name given name for the Operation. The Part generated will share the same name.
     * @return The SurfaceWrapperAutoMeshOperation.
     */
    public SurfaceWrapperAutoMeshOperation surfaceWrapper(ArrayList<GeometryPart> agp,
            String name) {
        _io.say.action("Creating a Surface Wrapper Mesh Operation", true);
        _io.say.objects(agp, "Geometry Parts", true);
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        AutoMeshOperation amo = mom.createSurfaceWrapperAutoMeshOperation(agp, name);
        SurfaceWrapperAutoMeshOperation swamo = (SurfaceWrapperAutoMeshOperation) amo;
        AutoMeshDefaultValuesManager amdvm = swamo.getDefaultValues();
        _set.mesh.baseSize(swamo, _ud.mshBaseSize, _ud.defUnitLength, false);
        _set.mesh.surfaceSizes(swamo, _ud.mshSrfSizeMin, _ud.mshSrfSizeTgt, false);
        _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class), _ud.mshSrfCurvNumPoints,
                false);
        GlobalVolumeOfInterestOption gvio = amdvm.get(GlobalVolumeOfInterest.class)
                .getVolumeOfInterestOption();
        GeometricFeatureAngle gfa = amdvm.get(GeometricFeatureAngle.class);
        gvio.setSelected(GlobalVolumeOfInterestOption.Type.LARGEST_INTERNAL);
        gfa.setGeometricFeatureAngle(_ud.mshWrapperFeatureAngle);
        _io.say.value("Volume of Interest", gvio.getSelectedElement().getPresentationName(), true,
                true);
        _io.say.value("Geometric Feature Angle", gfa.getGeometricFeatureAngle(), true);
        _io.say.created(swamo, true);
        return swamo;
    }

    /**
     * Creates an Unite Mesh Operation between a set of Geometry Parts.
     *
     * @param agp given ArrayList of Geometry Parts.
     * @return The MeshOperationPart.
     */
    public MeshOperationPart unite(ArrayList<GeometryPart> agp) {
        return _createBoolean(StaticDeclarations.Operation.UNITE, agp, null);
    }

    /**
     * This method is called automatically by {@link MacroUtils}.
     */
    public void updateInstances() {
        _chk = _mu.check;
        _dis = _mu.disable;
        _get = _mu.get;
        _io = _mu.io;
        _set = _mu.set;
        _ud = _mu.userDeclarations;
    }

    /**
     * Creates a Custom Volumetric Control with isotropic values in a Mesh Operation.
     *
     * @param mo      given Mesh Operation.
     * @param agp     given ArrayList of Geometry Parts.
     * @param relSize relative size in (<b>%</b>). Zero is ignored.
     * @return The VolumeCustomMeshControl.
     */
    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,
            double relSize) {
        return volumetricControl(mo, agp, relSize, StaticDeclarations.COORD0);
    }

    /**
     * Creates a Custom Volumetric Control in a Mesh Operation where the control can be Isotropic or
     * Anisotropic (Trimmer only).
     *
     * @param mo       given Mesh Operation.
     * @param agp      given ArrayList of Geometry Parts.
     * @param relSize  relative size in (<b>%</b>). Zero is ignored.
     * @param relSizes given 3-component relative sizes in (<b>%</b>). E.g.: {0, 50, 0}. Zeros will
     *                 be ignored.
     * @return The VolumeCustomMeshControl.
     */
    public VolumeCustomMeshControl volumetricControl(MeshOperation mo, ArrayList<GeometryPart> agp,
            double relSize, double[] relSizes) {
        _io.say.action("Creating a Custom Volume Mesh Control", true);
        _io.say.object(mo, true);
        _io.say.objects(agp, "Geometry Parts", true);
        if (!_isCustomControllable(mo)) {
            return null;
        }
        AutoMeshOperation amo = (AutoMeshOperation) mo;
        VolumeCustomMeshControl vcmc = amo.getCustomMeshControls().createVolumeControl();
        vcmc.getGeometryObjects().setObjects(agp);
        if (relSize > 0) {
            _setIsotropicSize(vcmc, relSize);
        }
        if (_chk.has.trimmerMesher(amo) && relSizes.length == 3 && _get.info.sum(relSizes) > 0) {
            _setAnisotropicSizes(vcmc, relSizes);
        }
        _io.say.created(vcmc, true);
        return vcmc;
    }

    private MeshOperationPart _createBoolean(StaticDeclarations.Operation op,
            ArrayList<GeometryPart> ag, GeometryPart tgtGP) {
        _io.say.action(String.format("Creating a %s Mesh Operation", op.toString()), true);
        _io.say.objects(ag, "Parts", true);
        MeshOperation mo = _createBooleanMeshOperation(op, tgtGP);
        mo.getInputGeometryObjects().setObjects(ag);
        mo.execute();
        String opName = _get.strings.withinTheBrackets(mo.getOutputPartNames());
        return (MeshOperationPart) _sim.get(SimulationPartManager.class).getPart(opName);
    }

    private MeshOperation _createBooleanMeshOperation(StaticDeclarations.Operation op,
            GeometryPart tgtGP) {
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        switch (op) {
            case SUBTRACT:
                SubtractPartsOperation spo = (SubtractPartsOperation) mom
                        .createSubtractPartsOperation();
                spo.setTargetPart((MeshPart) tgtGP);
                return spo;
            case UNITE:
                UnitePartsOperation upo = (UnitePartsOperation) mom.createUnitePartsOperation();
                return upo;
        }
        return null;
    }

    private BoundedShapeCreatingOperation _createBoundedShapeMeshOp(ArrayList<GeometryPart> agp,
            BoundedShapeCreatingOperation.OutputPartType type) {
        MeshOperation mo = _sim.get(MeshOperationManager.class).createBoundedShapeOperation(agp);
        BoundedShapeCreatingOperation bsco = (BoundedShapeCreatingOperation) mo;
        bsco.setOutputPartType(type);
        return bsco;
    }

    private DirectedMeshOperation _createDirectedMeshOperation(PartSurface src, PartSurface tgt) {
        _io.say.object(src.getPart(), true);
        if (!_chk.is.directedMeshable(src, tgt)) {
            return null;
        }
        MeshOperationManager mom = _sim.get(MeshOperationManager.class);
        MeshOperation mo = mom.createDirectedMeshOperation(
                new ArrayList<>(_get.objects.arrayList(src.getPart())));
        DirectedMeshOperation dmo = (DirectedMeshOperation) mo;
        dmo.getSourceSurfaceGroup().add(src);
        dmo.getTargetSurfaceGroup().add(tgt);
        return dmo;
    }

    private SurfaceCustomMeshControl _createSurfaceCustomMeshControl(MeshOperation mo, boolean vo) {
        _io.say.action("Creating a Custom Surface Mesh Control", vo);
        _io.say.object(mo, vo);
        if (!_isCustomControllable(mo)) {
            return null;
        }
        AutoMeshOperation amo = (AutoMeshOperation) mo;
        SurfaceCustomMeshControl scmc = amo.getCustomMeshControls().createSurfaceControl();
        _io.say.created(scmc, vo);
        return scmc;
    }

    private ArrayList<PatchCurve> _getPatchCurves(DirectedPatchSourceMesh patchMsh) {
        return new ArrayList<>(patchMsh.getPatchCurveManager().getObjects());
    }

    private ArrayList<PatchVertex> _getPatchVertices(DirectedPatchSourceMesh patchMsh) {
        return new ArrayList<>(patchMsh.getPatchVertexManager().getObjects());
    }

    private List<PatchVertex> _getPatchVerticesSortedByAngle(DirectedPatchSourceMesh patchMsh,
            CylindricalCoordinateSystem ccs) {

        List<PatchVertex> vertices = _getPatchVertices(patchMsh);

        List<Double> angles = vertices.stream()
                .map(pv -> _getVector3(pv, ccs))
                .map(cylindricalVector -> cylindricalVector.y)
                .collect(Collectors.toList());

        List<Double> sortedAngles = angles.stream()
                .sorted(Comparator.naturalOrder())
                .collect(Collectors.toList());

        return sortedAngles.stream()
                .map(angle -> angles.indexOf(angle))
                .map(i -> vertices.get(i))
                .collect(Collectors.toList());

    }

    private Vector3 _getVector3(PatchVertex pv, CylindricalCoordinateSystem c) {
        return c.transformLabCoordinate(new Vector3(pv.getCoordinate().toDoubleArray()));
    }

    private boolean _isCustomControllable(MeshOperation mo) {
        if (_chk.is.autoMeshOperation(mo) || _chk.is.surfaceWrapperOperation(mo)) {
            return true;
        }
        _io.say.msg(true, "This Mesh Operation can not have Custom Controls. Skipping...");
        return false;
    }

    private void _sayPatchVerticesNames(List<PatchVertex> vertices) {


        List<String> names = vertices.stream()
                .map(pv -> pv.getPresentationName())
                .collect(Collectors.toList());

        _io.say.msg("Vertices: " + names.toString());

    }

    private void _setAnisotropicSizes(VolumeCustomMeshControl vcmc, double[] relSizes) {
        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();
        VolumeControlTrimmerSizeOption vctso = vccc.get(VolumeControlTrimmerSizeOption.class);
        vctso.setTrimmerAnisotropicSizeOption(true);
        TrimmerAnisotropicSize tas = vcmc.getCustomValues().get(TrimmerAnisotropicSize.class);
        if (relSizes[0] > 0) {
            tas.setXSize(true);
            _set.object.relativeSize(tas.getRelativeXSize(), "Relative Size X", relSizes[0]);
        }
        if (relSizes[1] > 0) {
            tas.setYSize(true);
            _set.object.relativeSize(tas.getRelativeYSize(), "Relative Size Y", relSizes[1]);
        }
        if (relSizes[2] > 0) {
            tas.setZSize(true);
            _set.object.relativeSize(tas.getRelativeZSize(), "Relative Size Z", relSizes[2]);
        }
    }

    private void _setAutomatedMesh(AutoMeshOperation amo, ArrayList<GeometryPart> ag, String txt) {
        _io.say.action("Creating an Automated Mesh Operation " + txt, true);
        _io.say.objects(ag, "Geometry Parts", true);
        _io.say.msg("Meshers: " + _get.strings
                .withinTheBrackets(amo.getMeshersCollection().toString()));
        _setMeshDefaults(amo.getDefaultValues());
        _set.mesh.prisms(amo, _ud.prismsLayers, _ud.prismsStretching, _ud.prismsRelSizeHeight,
                false);
        _set.mesh.thinMesher(amo, _ud.thinMeshLayers, _ud.thinMeshMaxThickness, false);
        _set.mesh.coreMeshOptimizer(amo, _ud.mshOptCycles, _ud.mshQualityThreshold, false);
        _io.say.created(amo, true);
    }

    private void _setCentroidOffset(BoundedShapeCreatingOperation bsmo, double[] offset) {
        Units u = _ud.defUnitLength;
        BoundedShapeControlsManager bscm = bsmo.getBoundedShapeValuesManager();
        BoundedShapeCentroidOffset bsco = bscm.get(BoundedShapeCentroidOffset.class);
        _set.object.physicalQuantity(bsco.getXOffset(), offset[0], u, "X Centroid Offset", true);
        _set.object.physicalQuantity(bsco.getYOffset(), offset[1], u, "Y Centroid Offset", true);
        _set.object.physicalQuantity(bsco.getZOffset(), offset[2], u, "Z Centroid Offset", true);
    }

    private void _setIsotropicSize(VolumeCustomMeshControl vcmc, double relSize) {
        AutoMeshOperation amo = (AutoMeshOperation) vcmc.getManager().getMeshOperation();
        CustomMeshControlValueManager cmcvm = vcmc.getCustomValues();
        CustomMeshControlConditionManager vccc = vcmc.getCustomConditions();
        if (_chk.has.polyMesher(amo)) {
            vccc.get(VolumeControlDualMesherSizeOption.class).setVolumeControlBaseSizeOption(true);
        } else if (_chk.has.trimmerMesher(amo)) {
            vccc.get(VolumeControlTrimmerSizeOption.class).setVolumeControlBaseSizeOption(true);
        } else {
            _io.say.msg("WARNING! Impossible to set Relative size.");
            return;
        }
        _set.object.relativeSize(cmcvm.get(VolumeControlSize.class), "Relative Size", relSize);
    }

    private void _setMeshDefaults(AutoMeshDefaultValuesManager amdvm) {

        boolean isTrimmer = false;

        if (amdvm.getParent() instanceof AutoMeshOperation) {
            AutoMeshOperation amo = amdvm.getParent();
            isTrimmer = _chk.has.trimmerMesher(amo);
        }

        _set.object.physicalQuantity(amdvm.get(BaseSize.class), _ud.mshBaseSize, _ud.defUnitLength,
                "Base Size", true);
        _set.object.relativeSize(amdvm.get(PartsTargetSurfaceSize.class), "Target Surface Size",
                _ud.mshSrfSizeTgt);
        if (amdvm.has("Minimum Surface Size")) {
            _set.object.relativeSize(amdvm.get(PartsMinimumSurfaceSize.class),
                    "Minimum Surface Size", _ud.mshSrfSizeMin);
        }
        if (amdvm.has("Surface Curvature")) {
            _set.mesh.surfaceCurvature(amdvm.get(SurfaceCurvature.class),
                    _ud.mshSrfCurvNumPoints, false);
        }
        if (amdvm.has("Surface Proximity")) {
            _set.mesh.surfaceProximity(amdvm.get(SurfaceProximity.class),
                    _ud.mshProximityPointsInGap, _ud.mshProximitySearchFloor, false);
        }
        if (amdvm.has("Volume Growth Rate") && isTrimmer) {
            star.trimmer.PartsGrowthRateOption.Type t = _ud.mshTrimmerGrowthRate.getType();
            amdvm.get(PartsSimpleTemplateGrowthRate.class).getGrowthRateOption().setSelected(t);
            _io.say.value("Growth Rate Type", t.getPresentationName(), true, true);
        }
        if (amdvm.has("Maximum Cell Size")) {
            _set.object.relativeSize(amdvm.get(MaximumCellSize.class), "Maximum Cell Size",
                    _ud.mshTrimmerMaxCellSize);
        }
    }

    private void _setWorkAroundAutoSourceMesh(DirectedAutoSourceMesh dasm, GeometryPart gp) {
        //-- Check later.
        // Workaround for legacy limitation of Target size not being respected in 2D meshes.
        SurfaceCustomMeshControl scmc = dasm.getCustomMeshControls().createSurfaceControl();
        scmc.getGeometryObjects().setObjects(gp);
        CustomMeshControlConditionManager cmccm = scmc.getCustomConditions();
        cmccm.get(PartsTargetSurfaceSizeOption.class)
                .setSelected(PartsTargetSurfaceSizeOption.Type.CUSTOM);
        _set.object.relativeSize(scmc.getCustomValues().get(PartsTargetSurfaceSize.class),
                "Relative Size", _ud.mshSrfSizeTgt);
        scmc.setPresentationName("Work-Around AutoSource Mesh");
    }

}
```


Overlapping Code:
```
ass CreateMeshOperation {
private macroutils.checker.MainChecker _chk = null;
private macroutils.misc.MainDisabler _dis = null;
private macroutils.getter.MainGetter _get = null;
private macroutils.io.MainIO _io = null;
private MacroUtils _mu = null;
private macroutils.setter.MainSetter _set = null;
private Simulation _sim = null;
private macroutils.UserDeclarations _ud = null;
/**
* Main constructor for this class.
*
* @param m given MacroUtils object.
*/
public CreateMeshOperation(MacroUtils m) {
_mu = m;
_sim = m.getSimulation();
}
/**
* Creates an Automated Mesh Mesh Operation for the given Geometry Parts.
*
* @param ag given ArrayList of Geometry Parts.
* @param am given ArrayList of Meshers. <u>Hint</u>: use with
* {@link macroutils.getter.GetStrings#meshers}.
* @return The AutoMeshOperation.
*/
public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag, ArrayList<String> am) {
MeshOperationManager mom = _sim.get(MeshOperationManager.class);
AutoMeshOperation amo = mom.createAutoMeshOperation(am, ag);
_setAutomatedMesh(amo, ag, "");
return amo;
}
/**
* Creates an Automated Mesh Mesh Operation for the given Geometry Parts.
*
* @param ag given ArrayList of Geometry Parts.
* @param meshers given meshers, separated by comma. See {@link macroutils.StaticDeclarations}
* for options.
* @return The AutoMeshOperation.
*/
public AutoMeshOperation automatedMesh(ArrayList<GeometryPart> ag,
StaticDeclarations.Meshers... meshers) {
return automatedMesh(ag, _get.strings.meshers(meshers));
}
/**
* Creates a Badge for 2D Mesh Operation on a set of Geometry Parts.
*
* @param agp given ArrayList of Geometry Parts.
* @return The PrepareFor2dOperation.
*/
public PrepareFor2dOperation badgeFor2D(ArrayList<GeometryPart> agp) {
_io.say.action("Creating a Badge for 2D Mesh Operation", true);
_io.say.objects(agp, "Geometry Parts", true);
MeshOperationManager mom = _sim.get(MeshOperationManager.class);
PrepareFor2dOperation p2d = (PrepareFor2dOperation) mom.createPrepareFor2dOperation(agp);
p2d.execute();
_io.say.created(p2d, true);
return p2d;
}
/**
* Creates a Bounded Shape Bl
```
<Overlap Ratio: 0.9836065573770492>

---

--- 229 --
Question ID: 3c6494ce77675634578c1e0e20e539c4048f7e78_0
Original Code:
```
public class Fp6_3Over2 extends AbstractFieldElement<Fp6_3Over2> implements Serializable {
    protected final Fp2 c0;
    protected final Fp2 c1;
    protected final Fp2 c2;
    private final AbstractFp6_3Over2_Parameters Fp6Parameters;

    public Fp6_3Over2(
            final Fp2 c0,
            final Fp2 c1,
            final Fp2 c2,
            final AbstractFp6_3Over2_Parameters Fp6Parameters) {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.Fp6Parameters = Fp6Parameters;
    }

    public Fp6_3Over2 self() {
        return this;
    }

    public Fp6_3Over2 add(final Fp6_3Over2 that) {
        return new Fp6_3Over2(c0.add(that.c0), c1.add(that.c1), c2.add(that.c2), Fp6Parameters);
    }

    public Fp6_3Over2 sub(final Fp6_3Over2 that) {
        return new Fp6_3Over2(c0.sub(that.c0), c1.sub(that.c1), c2.sub(that.c2), Fp6Parameters);
    }

    public Fp6_3Over2 mul(final Fp that) {
        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);
    }

    public Fp6_3Over2 mul(final Fp2 that) {
        return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);
    }

    public Fp2 mulByNonResidue(final Fp2 that) {
        return Fp6Parameters.nonresidue().mul(that);
    }

    public Fp6_3Over2 mul(final Fp6_3Over2 that) {
    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly
     Fields.pdf; Section 4 (Karatsuba) */
        final Fp2 c0C0 = c0.mul(that.c0);
        final Fp2 c1C1 = c1.mul(that.c1);
        final Fp2 c2C2 = c2.mul(that.c2);
        final Fp2 c0Factor = c1.add(c2).mul(that.c1.add(that.c2)).sub(c1C1).sub(c2C2);
        final Fp2 c1Factor = c0.add(c1).mul(that.c0.add(that.c1)).sub(c0C0).sub(c1C1);
        final Fp2 c2Factor = c0.add(c2).mul(that.c0.add(that.c2)).sub(c0C0).add(c1C1).sub(c2C2);

        return new Fp6_3Over2(
                c0C0.add(mulByNonResidue(c0Factor)),
                c1Factor.add(mulByNonResidue(c2C2)),
                c2Factor,
                Fp6Parameters);
    }

    public Fp6_3Over2 zero() {
        return Fp6Parameters.ZERO();
    }

    public boolean isZero() {
        return c0.isZero() && c1.isZero() && c2.isZero();
    }

    public Fp6_3Over2 one() {
        return Fp6Parameters.ONE();
    }

    public boolean isOne() {
        return c0.isOne() && c1.isZero() && c2.isZero();
    }

    public Fp6_3Over2 random(final Long seed, final byte[] secureSeed) {
        return new Fp6_3Over2(
                c0.random(seed, secureSeed),
                c1.random(seed, secureSeed),
                c2.random(seed, secureSeed),
                Fp6Parameters);
    }

    public Fp6_3Over2 negate() {
        return new Fp6_3Over2(c0.negate(), c1.negate(), c2.negate(), Fp6Parameters);
    }

    public Fp6_3Over2 square() {
    /* Devegili OhEig Scott Dahab --- Multiplication and Squaring on AbstractPairing-Friendly
     Fields.pdf; Section 4 (CH-SQR2) */
        final Fp2 s0 = c0.square();
        final Fp2 c0c1 = c0.mul(c1);
        final Fp2 s1 = c0c1.add(c0c1);
        final Fp2 s2 = c0.sub(c1).add(c2).square();
        final Fp2 c1c2 = c1.mul(c2);
        final Fp2 s3 = c1c2.add(c1c2);
        final Fp2 s4 = c2.square();

        return new Fp6_3Over2(
                s0.add(mulByNonResidue(s3)),
                s1.add(mulByNonResidue(s4)),
                s1.add(s2).add(s3).sub(s0).sub(s4),
                Fp6Parameters);
    }

    public Fp6_3Over2 inverse() {
    /* From "High-Speed Software Implementation of the Optimal Ate AbstractPairing over
    Barreto-Naehrig Curves"; Algorithm 17 */
        final Fp2 t0 = c0.square();
        final Fp2 t1 = c1.square();
        final Fp2 t2 = c2.square();
        final Fp2 t3 = c0.mul(c1);
        final Fp2 t4 = c0.mul(c2);
        final Fp2 t5 = c1.mul(c2);
        final Fp2 s0 = t0.sub(mulByNonResidue(t5));
        final Fp2 s1 = mulByNonResidue(t2).sub(t3);
        final Fp2 s2 = t1
                .sub(t4); // typo in paper referenced above. should be "-" as per Scott, but is "*"
        final Fp2 t6 = c0.mul(s0).add(mulByNonResidue(c2.mul(s1).add(c1.mul(s2)))).inverse();

        return new Fp6_3Over2(t6.mul(s0), t6.mul(s1), t6.mul(s2), Fp6Parameters);
    }

    public Fp6_3Over2 FrobeniusMap(long power) {
        return new Fp6_3Over2(c0.FrobeniusMap(power),
                Fp6Parameters.FrobeniusMapCoefficientsC1()[(int) (power % 6)].mul(c1.FrobeniusMap(power)),
                Fp6Parameters.FrobeniusMapCoefficientsC2()[(int) (power % 6)].mul(c2.FrobeniusMap(power)),
                Fp6Parameters);
    }

    public int bitSize() {
        return Math.max(c0.bitSize(), Math.max(c1.bitSize(), c2.bitSize()));
    }

    public Fp6_3Over2 construct(final Fp2 c0, final Fp2 c1, final Fp2 c2) {
        return new Fp6_3Over2(c0, c1, c2, Fp6Parameters);
    }

    public String toString() {
        return c0.toString() + " / " + c1.toString() + " / " + c2.toString();
    }

    public boolean equals(final Fp6_3Over2 that) {
        if (that == null) {
            return false;
        }

        return c0.equals(that.c0) && c1.equals(that.c1) && c2.equals(that.c2);
    }
}
```


Overlapping Code:
```
Fp6_3Over2 extends AbstractFieldElement<Fp6_3Over2> implements Serializable {
protected final Fp2 c0;
protected final Fp2 c1;
protected final Fp2 c2;
private final AbstractFp6_3Over2_Parameters Fp6Parameters;
public Fp6_3Over2(
final Fp2 c0,
final Fp2 c1,
final Fp2 c2,
final AbstractFp6_3Over2_Parameters Fp6Parameters) {
this.c0 = c0;
this.c1 = c1;
this.c2 = c2;
this.Fp6Parameters = Fp6Parameters;
}
public Fp6_3Over2 self() {
return this;
}
public Fp6_3Over2 add(final Fp6_3Over2 that) {
return new Fp6_3Over2(c0.add(that.c0), c1.add(that.c1), c2.add(that.c2), Fp6Parameters);
}
public Fp6_3Over2 sub(final Fp6_3Over2 that) {
return new Fp6_3Over2(c0.sub(that.c0), c1.sub(that.c1), c2.sub(that.c2), Fp6Parameters);
}
public Fp6_3Over2 mul(final Fp that) {
return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);
}
public Fp6_3Over2 mul(final Fp2 that) {
return new Fp6_3Over2(c0.mul(that), c1.mul(that), c2.mul(that), Fp6Parameters);
}
public Fp2 mulByNonResidue(final Fp2 that) {
return Fp6Parameters.nonresidue().mul(that);
}
public Fp6_3Over2 mul(final Fp6_3Over2 that)cation and Squaring on AbstractPairing-Friendly
Fields.pdf; Section 4 (Karatsuba) */
final Fp2 c0C0 = c0.mul(that.c0);
final Fp2 c1C1 = c1.mul(that.c1);
final Fp2 c2C2 = c2.mul(that.c2);
final Fp2 c0Factor = c1.add(c2).mul(that.c1.add(that.c2)).sub(c1C1).sub(c2C2);
final Fp2 c1Factor = c0.add(c1).mul(that.c0.add(that.c1)).sub(c0C0).sub(c1C1);
final Fp2 c2Factor = c0.add(c2).mul(that.c0.add(that.c2)).sub(c0C0).add(c1C1).sub(c2C2);
return new Fp6_3Over2(
c0C0.add(mulByNonResidue(c0Factor)),
c1Factor.add(mulByNonResidue(c2C2)),
c2Factor,
Fp6Parameters);
}
public Fp6_3Over2 zero() {
return Fp6Parameters.ZERO();
}
public boolean isZero() {
return c0.isZero() && c1.isZero() && c2.isZero();
}
public Fp6_3Over2 one() {
return Fp6Parameters.ONE();
}
public boolean isOne() {
return c0.isOne() && c1.isZero() && c2.isZero();
}
public Fp6_3Over2 random(final Long seed, final byte[] secureSeed) {
return n
```
<Overlap Ratio: 0.9671814671814671>

---

--- 230 --
Question ID: 6b8394dbe86cfd0bdc0059240230c1467417c2df_0
Original Code:
```
public class MnemonicSOMLibFormatInputReader extends SOMLibFormatInputReader {
    protected void processUnitElement(String line, int j, int i) {
        processUnitElement(line, 0, j, i);
    }

    @Override
    protected void processUnitElement(String line, int k, int j, int i) {
        if (line.startsWith("null")) {
            unitInfo[i][j][k] = null;
        } else {
            super.processUnitElement(line, k, j, i);
        }
    }

    public MnemonicSOMLibFormatInputReader(String unitDescriptionFileName, String mapDescriptionFileName, int dimension)
            throws FileNotFoundException, SOMLibFileFormatException {
        this(null, unitDescriptionFileName, unitDescriptionFileName, dimension);
    }

    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,
            String mapDescriptionFileName) throws FileNotFoundException, SOMLibFileFormatException {
        super(weightVectorFileName, unitDescriptionFileName, mapDescriptionFileName);
    }

    public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,
            String mapDescriptionFileName, int dimension) throws FileNotFoundException, SOMLibFileFormatException {
        super(null, unitDescriptionFileName, mapDescriptionFileName);
        this.dim = dimension;
        generateWRandomWeightvectors();
    }

    /** Generates random weight vectors, but only for those units that are occupied. */
    private void generateWRandomWeightvectors() {
        Random rand = new Random();
        for (int col = 0; col < getXSize(); col++) {
            for (int row = 0; row < getYSize(); row++) {
                for (int slice = 0; slice < getZSize(); slice++) {
                    if (unitInfo[col][row][slice] != null) {
                        double[] weightVector = new double[dim];
                        for (int i = 0; i < weightVector.length; i++) {
                            weightVector[i] = rand.nextDouble();
                        }
                        unitInfo[col][row][slice].vector = VectorTools.normaliseVectorToUnitLength(weightVector);
                    }
                }
            }
        }
    }

    @Override
    public double[][][][] getVectors() {
        double[][][][] res = new double[xSize][ySize][zSize][];
        for (int k = 0; k < zSize; k++) {
            for (int j = 0; j < ySize; j++) {
                for (int i = 0; i < xSize; i++) {
                    if (unitInfo[i][j][k] != null) {
                        res[i][j][k] = unitInfo[i][j][k].vector;
                    }
                }
            }
        }
        return res;
    }

    @Override
    public int getNrVecMapped(int x, int y, int z) {
        if (unitInfo[x][y][z] != null) {
            return super.getNrVecMapped(x, y, z);
        } else {
            return 0;
        }
    }

    @Override
    public String[] getMappedVecs(int x, int y, int z) {
        if (unitInfo[x][y][z] != null) {
            return super.getMappedVecs(x, y, z);
        } else {
            return null;
        }
    }

    @Override
    public double[] getMappedVecsDist(int x, int y, int z) {
        if (unitInfo[x][y][z] != null) {
            return super.getMappedVecsDist(x, y, z);
        } else {
            return null;
        }
    }

}
```


Overlapping Code:
```
utReader extends SOMLibFormatInputReader {
protected void processUnitElement(String line, int j, int i) {
processUnitElement(line, 0, j, i);
}
@Override
protected void processUnitElement(String line, int k, int j, int i) {
if (line.startsWith("null")) {
unitInfo[i][j][k] = null;
} else {
super.processUnitElement(line, k, j, i);
}
}
public MnemonicSOMLibFormatInputReader(String unitDescriptionFileName, String mapDescriptionFileName, int dimension)
throws FileNotFoundException, SOMLibFileFormatException {
this(null, unitDescriptionFileName, unitDescriptionFileName, dimension);
}
public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,
String mapDescriptionFileName) throws FileNotFoundException, SOMLibFileFormatException {
super(weightVectorFileName, unitDescriptionFileName, mapDescriptionFileName);
}
public MnemonicSOMLibFormatInputReader(String weightVectorFileName, String unitDescriptionFileName,
String mapDescriptionFileName, int dimension) throws FileNotFoundException, SOMLibFileFormatException {
super(null, unitDescriptionFileName, mapDescriptionFileName);
this.dim = dimension;
generateWRandomWeightvectors();
}
/** Generates random weight vectors, but only for those units that are occupied. */
private void generateWRandomWeightvectors() {
Random rand = new Random();
for (int col = 0; col < getXSize(); col++) {
for (int row = 0; row < getYSize(); row++) {
for (int slice = 0; slice < getZSize(); slice++) {
if (unitInfo[col][row][slice] != null) {
double[] weightVector = new double[dim];
for (int i = 0; i < weightVector.length; i++) {
weightVector[i] = rand.nextDouble();
}
unitInfo[col][row][slice].vector = VectorTools.normaliseVectorToUnitLength(weightVector);
}
}
}
}
}
@Override
public double[][][][] getVectors() {
double[][][][] res = new double[xSize][ySize][zSize][];
for (int k = 0; k < zSize; k++) {
for (int j = 0; j < ySize; j++) {
for (int i = 0; i < xSize; i++) {
if
```
<Overlap Ratio: 0.9803921568627451>

---

--- 231 --
Question ID: 3833871066190b0d3f0ec786374528b7ee356e10_0
Original Code:
```
@Data
public class PresentationManager {

    private final Presentations presentations;
    private final String presentationId;
    private final String slideId;

    public void addImages(List<PositionedImage> images, int parentWidth, int parentHeight) {
        HostingClient hosting = new HostingClient();
        List<HostedImage> hostedImages = new ArrayList<>();
        for (PositionedImage image : images) {
            String url = hosting.hostFile("image/png", ImageUtils.toBytes(image.image));
            hostedImages.add(new HostedImage(image, url));
        }
        try {
            Size slideSize = presentations.get(presentationId).execute().getPageSize();
            double slideWidth = toPts(slideSize.getWidth());
            double slideHeight = toPts(slideSize.getHeight());
            double scale = Math.min(slideWidth / parentWidth, slideHeight / parentHeight);
            presentations
                .batchUpdate(presentationId, new BatchUpdatePresentationRequest()
                    .setRequests(hostedImages.stream()
                        .map(image -> new Request()
                            .setCreateImage(new CreateImageRequest()
                                .setElementProperties(new PageElementProperties()
                                    .setPageObjectId(slideId)
                                    .setTransform(new AffineTransform()
                                        .setTranslateX(image.getImage().x * scale)
                                        .setTranslateY(image.getImage().y * scale)
                                        .setScaleX(scale)
                                        .setScaleY(scale)
                                        .setUnit("PT")))
                                .setUrl(image.url)))
                        .collect(Collectors.toList())))
                .execute();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static double toPts(Dimension dimension) {
        switch (dimension.getUnit()) {
            case "EMU":
                return dimension.getMagnitude() / 12700;
            case "PT":
                return dimension.getMagnitude();
            default:
                throw new RuntimeException("Invalid dimension unit: " + dimension.getUnit());
        }
    }

    @Data
    public static class PositionedImage {

        private final BufferedImage image;
        private final int x;
        private final int y;
    }

    @Data
    private static class HostedImage {

        private final PositionedImage image;
        private final String url;
    }
}
```


Overlapping Code:
```
ionManager {
private final Presentations presentations;
private final String presentationId;
private final String slideId;
public void addImages(List<PositionedImage> images, int parentWidth, int parentHeight) {
HostingClient hosting = new HostingClient();
List<HostedImage> hostedImages = new ArrayList<>();
for (PositionedImage image : images) {
String url = hosting.hostFile("image/png", ImageUtils.toBytes(image.image));
hostedImages.add(new HostedImage(image, url));
}
try {
Size slideSize = presentations.get(presentationId).execute().getPageSize();
double slideWidth = toPts(slideSize.getWidth());
double slideHeight = toPts(slideSize.getHeight());
double scale = Math.min(slideWidth / parentWidth, slideHeight / parentHeight);
presentations
.batchUpdate(presentationId, new BatchUpdatePresentationRequest()
.setRequests(hostedImages.stream()
.map(image -> new Request()
.setCreateImage(new CreateImageRequest()
.setElementProperties(new PageElementProperties()
.setPageObjectId(slideId)
.setTransform(new AffineTransform()
.setTranslateX(image.getImage().x * scale)
.setTranslateY(image.getImage().y * scale)
.setScaleX(scale)
.setScaleY(scale)
.setUnit("PT")))
.setUrl(image.url)))
.collect(Collectors.toList())))
.execute();
} catch (IOException e) {
throw new RuntimeException(e);
}
}
private static double toPts(Dimension dimension) {
switch (dimension.getUnit()) {
case "EMU":
return dimension.getMagnitude() / 12700;
case "PT":
return dimension.getMagnitude();
default:
throw new RuntimeException("Invalid dimension unit: " + dimension.getUnit());
}
}
@Data
public static class PositionedImage {
private final BufferedImage image;
private final int x;
private fin
```
<Overlap Ratio: 0.9784130688448075>

---

--- 232 --
Question ID: 738e81bfd607906228abcf1d32e9b47406c97dd1_0
Original Code:
```
@Configuration
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {ExpressionConfig.class, AnalyzerTestBase.class})
class NamedExpressionAnalyzerTest extends AnalyzerTestBase {
  @Test
  void visit_named_select_item() {
    Alias alias = AstDSL.alias("integer_value", AstDSL.qualifiedName("integer_value"));

    NamedExpressionAnalyzer analyzer =
        new NamedExpressionAnalyzer(expressionAnalyzer);

    NamedExpression analyze = analyzer.analyze(alias, analysisContext);
    assertEquals("integer_value", analyze.getNameOrAlias());
  }
}
```


Overlapping Code:
```
@Configuration
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {ExpressionConfig.class, AnalyzerTestBase.class})
class NamedExpressionAnalyzerTest extends AnalyzerTestBase {
@Test
void visit_named_select_item() {
Alias alias = AstDSL.alias("integer_value", AstDSL.qualifiedName("integer_value"));
NamedExpressionAnalyzer analyzer =
new NamedExpressionAnalyzer(expressionAnalyzer);
NamedExpression analyze = analyzer.analyze(alias, analysisContext);
assertEquals("integer_value", analyze.getNameOrAlia
```
<Overlap Ratio: 0.9829545454545454>

---

--- 233 --
Question ID: 34267c4672306c3aff1bdc22f78d0fe4c1cbaf88_0
Original Code:
```
public class ODataMapDomain extends IODataMapName
{
    public ODataMapDomain(String name)
    {
        super(name);
    }

    @Override
    public Object getValue(IOServiceContext context, HashMap<String, Object> currentEntry)
    {
        ClientValue value = (ClientValue)currentEntry.get(name);
        if(value == null)
            return null;
		ClientEnumValue enumValue = value.asEnum();
        return enumValue != null ? new ClientPrimitiveValueImpl.BuilderImpl().buildInt32(((ODataConnection)context.getConnection()).getEnumValue(enumValue)) : null;
    }    
}
```


Overlapping Code:
```
n extends IODataMapName
{
public ODataMapDomain(String name)
{
super(name);
}
@Override
public Object getValue(IOServiceContext context, HashMap<String, Object> currentEntry)
{
ClientValue value = (ClientValue)currentEntry.get(name);
if(value == null)
return null;
ClientEnumValue enumValue = value.asEnum();
return enumValue != null ? new ClientPrimitiveValueImpl.BuilderImpl().buildInt32(((ODataConnection)context.getConnection()).getEnumValue(enum
```
<Overlap Ratio: 0.907258064516129>

---

--- 234 --
Question ID: cc1b9f17dc00f6ae1e71a893edde91d03189a496_0
Original Code:
```
public class ModelMapperUtil {


    /**
     * Get modelMapper instance with MatchingStrategies=STANDARD and
     * FieldMatchingEnabled=true<br>
     * <br>
     * Note: enable "FieldMatchingEnabled=true" can help to successfully match
     * obsolete fields in A against A1 class, which A1 have
     * setter & getter while another don't
     *
     * @return
     */
    // TODO If A has getter but no setter, and setFieldMatchingEnabled = false, can it work?
    public static ModelMapper getModelMapperWithFieldMatching() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STANDARD).setFieldMatchingEnabled(true).setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);
        return modelMapper;
    }


}
```


Overlapping Code:
```
apperUtil {
/**
* Get modelMapper instance with MatchingStrategies=STANDARD and
* FieldMatchingEnabled=true<br>
* <br>
* Note: enable "FieldMatchingEnabled=true" can help to successfully match
* obsolete fields in A against A1 class, which A1 have
* setter & getter while another don't
*
* @return
*/
// TODO If A has getter but no setter, and setFieldMatchingEnabled = false, can it work?
public static ModelMapper getModelMapperWithFieldMatching() {
ModelMapper modelMapper = new ModelMapper();
modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STANDARD).setFieldMatchingEnabled(true).setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);
return modelMapper
```
<Overlap Ratio: 0.9659574468085106>

---

--- 235 --
Question ID: c7c6f62e711082863ff9a09915a14edffd8ae5ef_0
Original Code:
```
public class DataTable {
	private final String datatablePath, datatableName;
	private String dataReferenceIdentifier = "#";

	private String currentTestcase;
	private int currentIteration = 0;

	/**
	 * Constructor to initialize the {@link DataTable} object
	 * 
	 * @param datatablePath The path where the datatable is stored
	 * @param datatableName The name of the datatable file
	 */
	public DataTable(String datatablePath, String datatableName) {
		this.datatablePath = datatablePath;
		this.datatableName = datatableName;
	}

	/**
	 * Function to set the data reference identifier character
	 * 
	 * @param dataReferenceIdentifier The data reference identifier character
	 */
	public void setDataReferenceIdentifier(String dataReferenceIdentifier) {
		if (dataReferenceIdentifier.length() != 1) {
			throw new FrameworkException("The data reference identifier must be a single character!");
		}

		this.dataReferenceIdentifier = dataReferenceIdentifier;
	}

	/**
	 * Function to set the variables required to uniquely identify the exact row of
	 * data under consideration
	 * 
	 * @param currentTestcase  The ID of the current test case
	 * @param currentIteration The Iteration being executed currently
	 */
	public void setCurrentRow(String currentTestcase, int currentIteration) {
		this.currentTestcase = currentTestcase;
		this.currentIteration = currentIteration;
	}

	private void checkPreRequisites() {
		if (currentTestcase == null) {
			throw new FrameworkException("DataTable.currentTestCase is not set!");
		}
		if (currentIteration == 0) {
			throw new FrameworkException("DataTable.currentIteration is not set!");
		}
	}

	/**
	 * Function to return the test data value corresponding to the sheet name and
	 * field name passed
	 * 
	 * @param datasheetName The name of the sheet in which the data is present
	 * @param fieldName     The name of the field whose value is required
	 * @return The test data present in the field name specified
	 * @see #putData(String, String, String)
	 * @see #getExpectedResult(String)
	 */
	public String getData(String datasheetName, String fieldName) {
		checkPreRequisites();

		ExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);
		testDataAccess.setDatasheetName(datasheetName);

		int rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start
																		// at
																		// row
																		// 1,
																		// skipping
																		// the
																		// header
																		// row
		if (rowNum == -1) {
			throw new FrameworkException("The test case \"" + currentTestcase + "\""
					+ "is not found in the test data sheet \"" + datasheetName + "\"!");
		}
		rowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);
		if (rowNum == -1) {
			throw new FrameworkException("The iteration number \"" + currentIteration + "\"" + "of the test case \""
					+ currentTestcase + "\"" + "is not found in the test data sheet \"" + datasheetName + "\"!");
		}

		String dataValue = testDataAccess.getValue(rowNum, fieldName);

		if (dataValue.startsWith(dataReferenceIdentifier)) {
			dataValue = getCommonData(fieldName, dataValue);
		}

		return dataValue;
	}

	private String getCommonData(String fieldName, String dataValue) {
		ExcelDataAccess commonDataAccess = new ExcelDataAccess(datatablePath, "Common Testdata");
		commonDataAccess.setDatasheetName("Common_Testdata");

		String dataReferenceId = dataValue.split(dataReferenceIdentifier)[1];

		int rowNum = commonDataAccess.getRowNum(dataReferenceId, 0, 1); // Start
																		// at
																		// row
																		// 1,
																		// skipping
																		// the
																		// header
																		// row
		if (rowNum == -1) {
			throw new FrameworkException("The common test data row identified by \"" + dataReferenceId + "\""
					+ "is not found in the common test data sheet!");
		}

		return commonDataAccess.getValue(rowNum, fieldName);
	}

	/**
	 * Function to output intermediate data (output values) into the specified sheet
	 * 
	 * @param datasheetName The name of the sheet into which the data is to be
	 *                      written
	 * @param fieldName     The name of the field into which the data is to be
	 *                      written
	 * @param dataValue     The value to be written into the field specified
	 * @see #getData(String, String)
	 */
	public void putData(String datasheetName, String fieldName, String dataValue) {
		checkPreRequisites();

		ExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);
		testDataAccess.setDatasheetName(datasheetName);

		int rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start
																		// at
																		// row
																		// 1,
																		// skipping
																		// the
																		// header
																		// row
		if (rowNum == -1) {
			throw new FrameworkException("The test case \"" + currentTestcase + "\""
					+ "is not found in the test data sheet \"" + datasheetName + "\"!");
		}
		rowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);
		if (rowNum == -1) {
			throw new FrameworkException("The iteration number \"" + currentIteration + "\"" + "of the test case \""
					+ currentTestcase + "\"" + "is not found in the test data sheet \"" + datasheetName + "\"!");
		}

		synchronized (DataTable.class) {
			testDataAccess.setValue(rowNum, fieldName, dataValue);
		}
	}

	/**
	 * Function to get the expected result corresponding to the field name passed
	 * 
	 * @param fieldName The name of the field which contains the expected results
	 * @return The expected result present in the field name specified
	 * @see #getData(String, String)
	 */
	public String getExpectedResult(String fieldName) {
		checkPreRequisites();

		ExcelDataAccess expectedResultsAccess = new ExcelDataAccess(datatablePath, datatableName);
		expectedResultsAccess.setDatasheetName("Parametrized_Checkpoints");

		int rowNum = expectedResultsAccess.getRowNum(currentTestcase, 0, 1); // Start
																				// at
																				// row
																				// 1,
																				// skipping
																				// the
																				// header
																				// row
		if (rowNum == -1) {
			throw new FrameworkException("The test case \"" + currentTestcase + "\""
					+ "is not found in the parametrized checkpoints sheet!");
		}
		rowNum = expectedResultsAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);
		if (rowNum == -1) {
			throw new FrameworkException("The iteration number \"" + currentIteration + "\"" + "of the test case \""
					+ currentTestcase + "\"" + "is not found in the parametrized checkpoints sheet!");
		}

		return expectedResultsAccess.getValue(rowNum, fieldName);
	}

	/**
	 * Function to return the test data value corresponding to the sheet name and
	 * field name passed
	 * 
	 * @param datasheetName The name of the sheet in which the data is present
	 * @param keys          The name of the fields whose values are required
	 * @return The Map of Column Names with values
	 */
	public Map<String, String> getData(String datasheetName, String[] keys) {
		checkPreRequisites();

		ExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);
		testDataAccess.setDatasheetName(datasheetName);

		int rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start
																		// at
																		// row
																		// 1,
																		// skipping
																		// the
																		// header
																		// row
		if (rowNum == -1) {
			throw new FrameworkException("The test case \"" + currentTestcase + "\""
					+ "is not found in the test data sheet \"" + datasheetName + "\"!");
		}
		rowNum = testDataAccess.getRowNum(Integer.toString(currentIteration), 1, rowNum);
		if (rowNum == -1) {
			throw new FrameworkException("The iteration number \"" + currentIteration + "\"" + "of the test case \""
					+ currentTestcase + "\"" + "is not found in the test data sheet \"" + datasheetName + "\"!");
		}

		Map<String, String> values = testDataAccess.getValuesForSpecificRow(keys, rowNum);

		return values;
	}

}
```


Overlapping Code:
```
blic class DataTable {
private final String datatablePath, datatableName;
private String dataReferenceIdentifier = "#";
private String currentTestcase;
private int currentIteration = 0;
/**
* Constructor to initialize the {@link DataTable} object
* 
* @param datatablePath The path where the datatable is stored
* @param datatableName The name of the datatable file
*/
public DataTable(String datatablePath, String datatableName) {
this.datatablePath = datatablePath;
this.datatableName = datatableName;
}
/**
* Function to set the data reference identifier character
* 
* @param dataReferenceIdentifier The data reference identifier character
*/
public void setDataReferenceIdentifier(String dataReferenceIdentifier) {
if (dataReferenceIdentifier.length() != 1) {
throw new FrameworkException("The data reference identifier must be a single character!");
}
this.dataReferenceIdentifier = dataReferenceIdentifier;
}
/**
* Function to set the variables required to uniquely identify the exact row of
* data under consideration
* 
* @param currentTestcase The ID of the current test case
* @param currentIteration The Iteration being executed currently
*/
public void setCurrentRow(String currentTestcase, int currentIteration) {
this.currentTestcase = currentTestcase;
this.currentIteration = currentIteration;
}
private void checkPreRequisites() {
if (currentTestcase == null) {
throw new FrameworkException("DataTable.currentTestCase is not set!");
}
if (currentIteration == 0) {
throw new FrameworkException("DataTable.currentIteration is not set!");
}
}
/**
* Function to return the test data value corresponding to the sheet name and
* field name passed
* 
* @param datasheetName The name of the sheet in which the data is present
* @param fieldName The name of the field whose value is required
* @return The test data present in the field name specified
* @see #putData(String, String, String)
* @see #getExpectedResult(String)
*/
public String getData(String datasheetName, String fieldName) {
checkPreRequisites();
ExcelDataAccess testDataAccess = new ExcelDataAccess(datatablePath, datatableName);
testDataAccess.setDatasheetName(datasheetName);
int rowNum = testDataAccess.getRowNum(currentTestcase, 0, 1); // Start
// at
// row
// 1,
// skipping
// t
```
<Overlap Ratio: 0.9947206335239771>

---

--- 236 --
Question ID: 1071a56069e3f3979e741ff7acf3fd60b8979900_0
Original Code:
```
class HelloWorld {
	public static void main(String[] args) {
		String[] vetor = {"aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc", "ccc", "ccc", "ddd", "ddd", "ddd"};
        String[] novoVetor = new String[vetor.length / 3];
        for (int i = 0; i < vetor.length; i += 3) novoVetor[i / 3] = vetor[i] + vetor[i + 1] + vetor[i + 2];
        for (String item : novoVetor) System.out.println(item);
	}
}
```


Overlapping Code:
```
class HelloWorld {
public static void main(String[] args) {
String[] vetor = {"aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc", "ccc", "ccc", "ddd", "ddd", "ddd"};
String[] novoVetor = new String[vetor.length / 3];
for (int i = 0; i < vetor.length; i += 3) novoVetor[i / 3] = vetor[i] + vetor[i + 1] + vetor[i + 2];
for (String item : novoVetor) System.out.pr
```
<Overlap Ratio: 0.9572192513368984>

---

--- 237 --
Question ID: f05c7799656bcdb964afbd4ccff8c8d66b5b9ec0_0
Original Code:
```
@Day(1) @Problem(1) @Year(2018)
@AutoService(DailyEvent.class)
public class ProblemOne implements DailyInputEvent, AnnotatedDailyEvent {
    private final BiFunction<String, Long, Long> applier;

    public ProblemOne(final BiFunction<String, Long, Long> applier) {
        this.applier = applier;
    }

    public ProblemOne() {
        this(new LineToFrequencyFunction());
    }

    @Override
    public void run() {
        System.out.println("Adding all frequencies together, starting with 0!");
        long frequency = 0;
        for (String line : readLines()) {
            frequency = applier.apply(line, frequency);
        }
        System.out.println(frequency);
    }
}
```


Overlapping Code:
```
Problem(1) @Year(2018)
@AutoService(DailyEvent.class)
public class ProblemOne implements DailyInputEvent, AnnotatedDailyEvent {
private final BiFunction<String, Long, Long> applier;
public ProblemOne(final BiFunction<String, Long, Long> applier) {
this.applier = applier;
}
public ProblemOne() {
this(new LineToFrequencyFunction());
}
@Override
public void run() {
System.out.println("Adding all frequencies together, starting with 0!");
long frequency = 0;
for (String line : readLines()) {
frequency = applier.apply(line, frequency);
}
System.out.println(frequency);
}
```
<Overlap Ratio: 0.9810671256454389>

---

--- 238 --
Question ID: f76378487ccb1b66b32fe495cdb9ba4a9289af0a_0
Original Code:
```
public class TestVectorBetweenIn {

  @Test
  public void testTinyInt() throws Exception {
    Random random = new Random(5371);

    doBetweenIn(random, "tinyint");
  }

  @Test
  public void testSmallInt() throws Exception {
    Random random = new Random(2772);

    doBetweenIn(random, "smallint");
  }

  @Test
  public void testInt() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "int");
  }

  @Test
  public void testBigInt() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "bigint");
  }

  @Test
  public void testString() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "string");
  }

  @Test
  public void testTimestamp() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "timestamp");
  }

  @Test
  public void testDate() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "date");
  }

  @Test
  public void testFloat() throws Exception {
    Random random = new Random(7322);

    doBetweenIn(random, "float");
  }

  @Test
  public void testDouble() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "double");
  }

  @Test
  public void testChar() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "char(10)");
  }

  @Test
  public void testVarchar() throws Exception {
    Random random = new Random(12882);

    doBetweenIn(random, "varchar(15)");
  }

  @Test
  public void testDecimal() throws Exception {
    Random random = new Random(9300);

    doDecimalTests(random, /* tryDecimal64 */ false);
  }

  @Test
  public void testDecimal64() throws Exception {
    Random random = new Random(9300);

    doDecimalTests(random, /* tryDecimal64 */ true);
  }

  @Test
  public void testStruct() throws Exception {
    Random random = new Random(9300);

    doStructTests(random);
  }

  public enum BetweenInTestMode {
    ROW_MODE,
    ADAPTOR,
    VECTOR_EXPRESSION;

    static final int count = values().length;
  }

  public enum BetweenInVariation {
    FILTER_BETWEEN,
    FILTER_NOT_BETWEEN,
    PROJECTION_BETWEEN,
    PROJECTION_NOT_BETWEEN,
    FILTER_IN,
    PROJECTION_IN;

    static final int count = values().length;

    final boolean isFilter;
    BetweenInVariation() {
      isFilter = name().startsWith("FILTER");
    }
  }

  private static TypeInfo[] decimalTypeInfos = new TypeInfo[] {
    new DecimalTypeInfo(38, 18),
    new DecimalTypeInfo(25, 2),
    new DecimalTypeInfo(19, 4),
    new DecimalTypeInfo(18, 10),
    new DecimalTypeInfo(17, 3),
    new DecimalTypeInfo(12, 2),
    new DecimalTypeInfo(7, 1)
  };

  private void doDecimalTests(Random random, boolean tryDecimal64)
      throws Exception {
    for (TypeInfo typeInfo : decimalTypeInfos) {
      doBetweenIn(
          random, typeInfo.getTypeName(), tryDecimal64);
    }
  }

  private void doBetweenIn(Random random, String typeName)
      throws Exception {
    doBetweenIn(random, typeName, /* tryDecimal64 */ false);
  }

  private static final BetweenInVariation[] structInVarations =
      new BetweenInVariation[] { BetweenInVariation.FILTER_IN, BetweenInVariation.PROJECTION_IN };

  private void doStructTests(Random random) throws Exception {

    String typeName = "struct";

    // These are the only type supported for STRUCT IN by the VectorizationContext class.
    Set<String> allowedTypeNameSet = new HashSet<String>();
    allowedTypeNameSet.add("int");
    allowedTypeNameSet.add("bigint");
    allowedTypeNameSet.add("double");
    allowedTypeNameSet.add("string");

    // Only STRUCT type IN currently supported.
    for (BetweenInVariation betweenInVariation : structInVarations) {

      for (int i = 0; i < 4; i++) {
        typeName =
            VectorRandomRowSource.getDecoratedTypeName(
                random, typeName, SupportedTypes.ALL, allowedTypeNameSet,
                /* depth */ 0, /* maxDepth */ 1);

         doBetweenStructInVariation(
              random, typeName, betweenInVariation);
      }
    }
  }

  private void doBetweenIn(Random random, String typeName, boolean tryDecimal64)
          throws Exception {

    int subVariation;
    for (BetweenInVariation betweenInVariation : BetweenInVariation.values()) {
      subVariation = 0;
      while (true) {
        if (!doBetweenInVariation(
            random, typeName, tryDecimal64, betweenInVariation, subVariation)) {
          break;
        }
        subVariation++;
      }
    }
  }

  private boolean checkDecimal64(boolean tryDecimal64, TypeInfo typeInfo) {
    if (!tryDecimal64 || !(typeInfo instanceof DecimalTypeInfo)) {
      return false;
    }
    DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) typeInfo;
    boolean result = HiveDecimalWritable.isPrecisionDecimal64(decimalTypeInfo.getPrecision());
    return result;
  }

  private void removeValue(List<Object> valueList, Object value) {
    valueList.remove(value);
  }

  private boolean needsValidDataTypeData(TypeInfo typeInfo) {
    if (!(typeInfo instanceof PrimitiveTypeInfo)) {
      return false;
    }
    PrimitiveCategory primitiveCategory = ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory();
    if (primitiveCategory == PrimitiveCategory.STRING ||
        primitiveCategory == PrimitiveCategory.CHAR ||
        primitiveCategory == PrimitiveCategory.VARCHAR ||
        primitiveCategory == PrimitiveCategory.BINARY) {
      return false;
    }
    return true;
  }

  private boolean doBetweenInVariation(Random random, String typeName,
      boolean tryDecimal64, BetweenInVariation betweenInVariation, int subVariation)
          throws Exception {

    TypeInfo typeInfo = TypeInfoUtils.getTypeInfoFromTypeString(typeName);

    boolean isDecimal64 = checkDecimal64(tryDecimal64, typeInfo);
    DataTypePhysicalVariation dataTypePhysicalVariation =
        (isDecimal64 ? DataTypePhysicalVariation.DECIMAL_64 : DataTypePhysicalVariation.NONE);
    final int decimal64Scale =
        (isDecimal64 ? ((DecimalTypeInfo) typeInfo).getScale() : 0);

    //----------------------------------------------------------------------------------------------

    ObjectInspector objectInspector =
        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(
            typeInfo);

    final int valueCount = 10 + random.nextInt(10);
    List<Object> valueList = new ArrayList<Object>(valueCount);
    for (int i = 0; i < valueCount; i++) {
      valueList.add(
          VectorRandomRowSource.randomWritable(
              random, typeInfo, objectInspector, dataTypePhysicalVariation, /* allowNull */ false));
    }

    final boolean isBetween =
        (betweenInVariation == BetweenInVariation.FILTER_BETWEEN ||
        betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||
        betweenInVariation == BetweenInVariation.PROJECTION_BETWEEN ||
        betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);

    List<Object> compareList = new ArrayList<Object>();

    List<Object> sortedList = new ArrayList<Object>(valueCount);
    sortedList.addAll(valueList);

    Object exampleObject = valueList.get(0);
    WritableComparator writableComparator =
        WritableComparator.get((Class<? extends WritableComparable>) exampleObject.getClass());
    sortedList.sort(writableComparator);

    final boolean isInvert;
    if (isBetween) {

      // FILTER_BETWEEN
      // FILTER_NOT_BETWEEN
      // PROJECTION_BETWEEN
      // PROJECTION_NOT_BETWEEN
      isInvert =
          (betweenInVariation == BetweenInVariation.FILTER_NOT_BETWEEN ||
           betweenInVariation == BetweenInVariation.PROJECTION_NOT_BETWEEN);
      switch (subVariation) {
      case 0:
        // Range covers all values exactly.
        compareList.add(sortedList.get(0));
        compareList.add(sortedList.get(valueCount - 1));
        break;
      case 1:
        // Exclude the first and last sorted.
        compareList.add(sortedList.get(1));
        compareList.add(sortedList.get(valueCount - 2));
        break;
      case 2:
        // Only last 2 sorted.
        compareList.add(sortedList.get(valueCount - 2));
        compareList.add(sortedList.get(valueCount - 1));
        break;
      case 3:
      case 4:
      case 5:
      case 6:
        {
          // Choose 2 adjacent in the middle.
          Object min = sortedList.get(5);
          Object max = sortedList.get(6);
          compareList.add(min);
          compareList.add(max);
          if (subVariation == 4) {
            removeValue(valueList, min);
          } else if (subVariation == 5) {
            removeValue(valueList, max);
          } else if (subVariation == 6) {
            removeValue(valueList, min);
            removeValue(valueList, max);
          }
        }
        break;
      default:
        return false;
      }
    } else {

      // FILTER_IN.
      // PROJECTION_IN.
      isInvert = false;
      switch (subVariation) {
      case 0:
        // All values.
        compareList.addAll(valueList);
        break;
      case 1:
        // Don't include the first and last sorted.
        for (int i = 1; i < valueCount - 1; i++) {
          compareList.add(valueList.get(i));
        }
        break;
      case 2:
        // The even ones.
        for (int i = 2; i < valueCount; i += 2) {
          compareList.add(valueList.get(i));
        }
        break;
      case 3:
        {
          // Choose 2 adjacent in the middle.
          Object min = sortedList.get(5);
          Object max = sortedList.get(6);
          compareList.add(min);
          compareList.add(max);
          if (subVariation == 4) {
            removeValue(valueList, min);
          } else if (subVariation == 5) {
            removeValue(valueList, max);
          } else if (subVariation == 6) {
            removeValue(valueList, min);
            removeValue(valueList, max);
          }
        }
        break;
      default:
        return false;
      }
    }

    //----------------------------------------------------------------------------------------------

    GenerationSpec generationSpec = GenerationSpec.createValueList(typeInfo, valueList);

    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();
    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =
        new ArrayList<DataTypePhysicalVariation>();
    generationSpecList.add(generationSpec);
    explicitDataTypePhysicalVariationList.add(dataTypePhysicalVariation);

    VectorRandomRowSource rowSource = new VectorRandomRowSource();

    rowSource.initGenerationSpecSchema(
        random, generationSpecList, /* maxComplexDepth */ 0,
        /* allowNull */ true, /* isUnicodeOk */ true,
        explicitDataTypePhysicalVariationList);

    List<String> columns = new ArrayList<String>();
    String col1Name = rowSource.columnNames().get(0);
    columns.add(col1Name);
    final ExprNodeDesc col1Expr = new ExprNodeColumnDesc(typeInfo, col1Name, "table", false);

    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();
    if (isBetween) {
      children.add(new ExprNodeConstantDesc(Boolean.valueOf(isInvert)));
    }
    children.add(col1Expr);
    for (Object compareObject : compareList) {
      ExprNodeConstantDesc constDesc =
          new ExprNodeConstantDesc(
              typeInfo,
              VectorRandomRowSource.getNonWritableObject(
                  compareObject, typeInfo, objectInspector));
      children.add(constDesc);
    }

    String[] columnNames = columns.toArray(new String[0]);

    Object[][] randomRows = rowSource.randomRows(100000);

    VectorRandomBatchSource batchSource =
        VectorRandomBatchSource.createInterestingBatches(
            random,
            rowSource,
            randomRows,
            null);

    final GenericUDF udf;
    final ObjectInspector outputObjectInspector;
    if (isBetween) {

      udf = new GenericUDFBetween();

      // First argument is boolean invert. Arguments 1..3 are inspectors for range limits...
      ObjectInspector[] argumentOIs = new ObjectInspector[4];
      argumentOIs[0] = PrimitiveObjectInspectorFactory.writableBooleanObjectInspector;
      argumentOIs[1] = objectInspector;
      argumentOIs[2] = objectInspector;
      argumentOIs[3] = objectInspector;
      outputObjectInspector = udf.initialize(argumentOIs);
    } else {
      final int compareCount = compareList.size();
      udf = new GenericUDFIn();
      ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];
      ConstantObjectInspector constantObjectInspector =
          (ConstantObjectInspector) children.get(1).getWritableObjectInspector();
      for (int i = 0; i < compareCount; i++) {
        argumentOIs[i] = constantObjectInspector;
      }
      outputObjectInspector = udf.initialize(argumentOIs);
    }

    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);

    ExprNodeGenericFuncDesc exprDesc =
        new ExprNodeGenericFuncDesc(
            TypeInfoFactory.booleanTypeInfo, udf, children);

    return executeTestModesAndVerify(
        typeInfo, betweenInVariation, compareList, columns, columnNames, children,
        udf, exprDesc,
        randomRows, rowSource, batchSource, outputTypeInfo,
        /* skipAdaptor */ false);
  }

  private boolean doBetweenStructInVariation(Random random, String structTypeName,
      BetweenInVariation betweenInVariation)
          throws Exception {

    StructTypeInfo structTypeInfo =
        (StructTypeInfo) TypeInfoUtils.getTypeInfoFromTypeString(structTypeName);

    ObjectInspector structObjectInspector =
        TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(
            structTypeInfo);

    final int valueCount = 10 + random.nextInt(10);
    List<Object> valueList = new ArrayList<Object>(valueCount);
    for (int i = 0; i < valueCount; i++) {
      valueList.add(
          VectorRandomRowSource.randomWritable(
              random, structTypeInfo, structObjectInspector, DataTypePhysicalVariation.NONE,
              /* allowNull */ false));
    }

    final boolean isInvert = false;
 
    // No convenient WritableComparator / WritableComparable available for STRUCT.
    List<Object> compareList = new ArrayList<Object>();

    Set<Integer> includedSet = new HashSet<Integer>();
    final int chooseLimit = 4 + random.nextInt(valueCount/2);
    int chooseCount = 0;
    while (chooseCount < chooseLimit) {
      final int index = random.nextInt(valueCount);
      if (includedSet.contains(index)) {
        continue;
      }
      includedSet.add(index);
      compareList.add(valueList.get(index));
      chooseCount++;
    }

    //----------------------------------------------------------------------------------------------

    GenerationSpec structGenerationSpec = GenerationSpec.createValueList(structTypeInfo, valueList);

    List<GenerationSpec> structGenerationSpecList = new ArrayList<GenerationSpec>();
    List<DataTypePhysicalVariation> structExplicitDataTypePhysicalVariationList =
        new ArrayList<DataTypePhysicalVariation>();
    structGenerationSpecList.add(structGenerationSpec);
    structExplicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);

    VectorRandomRowSource structRowSource = new VectorRandomRowSource();

    structRowSource.initGenerationSpecSchema(
        random, structGenerationSpecList, /* maxComplexDepth */ 0,
        /* allowNull */ true, /* isUnicodeOk */ true,
        structExplicitDataTypePhysicalVariationList);

    Object[][] structRandomRows = structRowSource.randomRows(100000);

    // ---------------------------------------------------------------------------------------------

    List<GenerationSpec> generationSpecList = new ArrayList<GenerationSpec>();
    List<DataTypePhysicalVariation> explicitDataTypePhysicalVariationList =
        new ArrayList<DataTypePhysicalVariation>();

    List<TypeInfo> fieldTypeInfoList = structTypeInfo.getAllStructFieldTypeInfos();
    final int fieldCount = fieldTypeInfoList.size();
    for (int i = 0; i < fieldCount; i++) {
      GenerationSpec generationSpec = GenerationSpec.createOmitGeneration(fieldTypeInfoList.get(i));
      generationSpecList.add(generationSpec);
      explicitDataTypePhysicalVariationList.add(DataTypePhysicalVariation.NONE);
    }

    VectorRandomRowSource rowSource = new VectorRandomRowSource();

    rowSource.initGenerationSpecSchema(
        random, generationSpecList, /* maxComplexDepth */ 0,
        /* allowNull */ true, /* isUnicodeOk */ true,
        explicitDataTypePhysicalVariationList);

    Object[][] randomRows = rowSource.randomRows(100000);

    final int rowCount = randomRows.length;
    for (int r = 0; r < rowCount; r++) {
      List<Object> fieldValueList = (ArrayList) structRandomRows[r][0]; 
      for (int f = 0; f < fieldCount; f++) {
        randomRows[r][f] = fieldValueList.get(f);
      }
    }

    // ---------------------------------------------------------------------------------------------

    // Currently, STRUCT IN vectorization assumes a GenericUDFStruct.

    List<ObjectInspector> structUdfObjectInspectorList = new ArrayList<ObjectInspector>();
    List<ExprNodeDesc> structUdfChildren = new ArrayList<ExprNodeDesc>(fieldCount);
    List<String> rowColumnNameList = rowSource.columnNames();
    for (int i = 0; i < fieldCount; i++) {
      TypeInfo fieldTypeInfo = fieldTypeInfoList.get(i);
      ExprNodeColumnDesc fieldExpr =
          new ExprNodeColumnDesc(
              fieldTypeInfo, rowColumnNameList.get(i), "table", false);
      structUdfChildren.add(fieldExpr);
      ObjectInspector fieldObjectInspector =
          VectorRandomRowSource.getObjectInspector(fieldTypeInfo, DataTypePhysicalVariation.NONE);
      structUdfObjectInspectorList.add(fieldObjectInspector);
    }
    StandardStructObjectInspector structUdfObjectInspector =
        ObjectInspectorFactory.
            getStandardStructObjectInspector(rowColumnNameList, structUdfObjectInspectorList);
    String structUdfTypeName = structUdfObjectInspector.getTypeName();
    TypeInfo structUdfTypeInfo = TypeInfoUtils.getTypeInfoFromTypeString(structUdfTypeName);

    String structFuncText = "struct";
    FunctionInfo fi = FunctionRegistry.getFunctionInfo(structFuncText);
    GenericUDF genericUDF = fi.getGenericUDF();
    ExprNodeDesc col1Expr =
        new ExprNodeGenericFuncDesc(
            structUdfObjectInspector, genericUDF, structFuncText, structUdfChildren);

    // ---------------------------------------------------------------------------------------------

    List<String> columns = new ArrayList<String>();

    List<ExprNodeDesc> children = new ArrayList<ExprNodeDesc>();
    children.add(col1Expr);
    for (int i = 0; i < compareList.size(); i++) {
      Object compareObject = compareList.get(i);
      ExprNodeConstantDesc constDesc =
          new ExprNodeConstantDesc(
              structUdfTypeInfo,
              VectorRandomRowSource.getNonWritableObject(
                  compareObject, structUdfTypeInfo, structUdfObjectInspector));
      children.add(constDesc);
    }

    for (int i = 0; i < fieldCount; i++) {
      columns.add(rowColumnNameList.get(i));
    }

    String[] columnNames = columns.toArray(new String[0]);

    VectorRandomBatchSource batchSource =
        VectorRandomBatchSource.createInterestingBatches(
            random,
            rowSource,
            randomRows,
            null);

    // ---------------------------------------------------------------------------------------------

    final GenericUDF udf = new GenericUDFIn();
    final int compareCount = compareList.size();
    ObjectInspector[] argumentOIs = new ObjectInspector[compareCount];
    for (int i = 0; i < compareCount; i++) {
      argumentOIs[i] = structUdfObjectInspector;
    }
    final ObjectInspector outputObjectInspector = udf.initialize(argumentOIs);

    TypeInfo outputTypeInfo = TypeInfoUtils.getTypeInfoFromObjectInspector(outputObjectInspector);

    ExprNodeGenericFuncDesc exprDesc =
        new ExprNodeGenericFuncDesc(
            TypeInfoFactory.booleanTypeInfo, udf, children);

    return executeTestModesAndVerify(
        structUdfTypeInfo, betweenInVariation, compareList, columns, columnNames, children,
        udf, exprDesc,
        randomRows, rowSource, batchSource, outputTypeInfo,
        /* skipAdaptor */ true);
  }

  private boolean executeTestModesAndVerify(TypeInfo typeInfo,
      BetweenInVariation betweenInVariation, List<Object> compareList,
      List<String> columns, String[] columnNames, List<ExprNodeDesc> children,
      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,
      Object[][] randomRows,
      VectorRandomRowSource rowSource, VectorRandomBatchSource batchSource,
      TypeInfo outputTypeInfo, boolean skipAdaptor)
          throws Exception {

    final int rowCount = randomRows.length;
    Object[][] resultObjectsArray = new Object[BetweenInTestMode.count][];
    for (int i = 0; i < BetweenInTestMode.count; i++) {

      Object[] resultObjects = new Object[rowCount];
      resultObjectsArray[i] = resultObjects;

      BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[i];
      switch (betweenInTestMode) {
      case ROW_MODE:
        if (!doRowCastTest(
              typeInfo,
              betweenInVariation,
              compareList,
              columns,
              children,
              udf, exprDesc,
              randomRows,
              rowSource.rowStructObjectInspector(),
              resultObjects)) {
          return false;
        }
        break;
      case ADAPTOR:
         if (skipAdaptor) {
           continue;
         }
      case VECTOR_EXPRESSION:
        if (!doVectorBetweenInTest(
              typeInfo,
              betweenInVariation,
              compareList,
              columns,
              columnNames,
              rowSource.typeInfos(),
              rowSource.dataTypePhysicalVariations(),
              children,
              udf, exprDesc,
              betweenInTestMode,
              batchSource,
              exprDesc.getWritableObjectInspector(),
              outputTypeInfo,
              resultObjects)) {
          return false;
        }
        break;
      default:
        throw new RuntimeException("Unexpected IF statement test mode " + betweenInTestMode);
      }
    }

    for (int i = 0; i < rowCount; i++) {
      // Row-mode is the expected value.
      Object expectedResult = resultObjectsArray[0][i];

      for (int v = 1; v < BetweenInTestMode.count; v++) {
        BetweenInTestMode betweenInTestMode = BetweenInTestMode.values()[v];
        if (skipAdaptor) {
          continue;
        }
        Object vectorResult = resultObjectsArray[v][i];
        if (betweenInVariation.isFilter &&
            expectedResult == null &&
            vectorResult != null) {
          // This is OK.
          boolean vectorBoolean = ((BooleanWritable) vectorResult).get();
          if (vectorBoolean) {
            Assert.fail(
                "Row " + i +
                " typeName " + typeInfo.getTypeName() +
                " outputTypeName " + outputTypeInfo.getTypeName() +
                " " + betweenInVariation +
                " " + betweenInTestMode +
                " result is NOT NULL and true" +
                " does not match row-mode expected result is NULL which means false here" +
                " row values " + Arrays.toString(randomRows[i]) +
                " exprDesc " + exprDesc.toString());
          }
        } else if (expectedResult == null || vectorResult == null) {
          if (expectedResult != null || vectorResult != null) {
            Assert.fail(
                "Row " + i +
                " sourceTypeName " + typeInfo.getTypeName() +
                " " + betweenInVariation +
                " " + betweenInTestMode +
                " result is NULL " + (vectorResult == null ? "YES" : "NO result " + vectorResult.toString()) +
                " does not match row-mode expected result is NULL " +
                (expectedResult == null ? "YES" : "NO result " + expectedResult.toString()) +
                " row values " + Arrays.toString(randomRows[i]) +
                " exprDesc " + exprDesc.toString());
          }
        } else {

          if (!expectedResult.equals(vectorResult)) {
            Assert.fail(
                "Row " + i +
                " sourceTypeName " + typeInfo.getTypeName() +
                " " + betweenInVariation +
                " " + betweenInTestMode +
                " result " + vectorResult.toString() +
                " (" + vectorResult.getClass().getSimpleName() + ")" +
                " does not match row-mode expected result " + expectedResult.toString() +
                " (" + expectedResult.getClass().getSimpleName() + ")" +
                " row values " + Arrays.toString(randomRows[i]) +
                " exprDesc " + exprDesc.toString());
          }
        }
      }
    }
    return true;
  }

  private boolean doRowCastTest(TypeInfo typeInfo,
      BetweenInVariation betweenInVariation, List<Object> compareList,
      List<String> columns, List<ExprNodeDesc> children,
      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,
      Object[][] randomRows,
      ObjectInspector rowInspector, Object[] resultObjects)
          throws Exception {

    /*
    System.out.println(
        "*DEBUG* typeInfo " + typeInfo.toString() +
        " targetTypeInfo " + targetTypeInfo +
        " betweenInTestMode ROW_MODE" +
        " exprDesc " + exprDesc.toString());
    */

    HiveConf hiveConf = new HiveConf();
    ExprNodeEvaluator evaluator =
        ExprNodeEvaluatorFactory.get(exprDesc, hiveConf);

    evaluator.initialize(rowInspector);

    final int rowCount = randomRows.length;
    for (int i = 0; i < rowCount; i++) {
      Object[] row = randomRows[i];
      Object result = evaluator.evaluate(row);
      Object copyResult =
          ObjectInspectorUtils.copyToStandardObject(
              result, PrimitiveObjectInspectorFactory.writableBooleanObjectInspector,
              ObjectInspectorCopyOption.WRITABLE);
      resultObjects[i] = copyResult;
    }

    return true;
  }

  private void extractResultObjects(VectorizedRowBatch batch, int rowIndex,
      VectorExtractRow resultVectorExtractRow, Object[] scrqtchRow,
      ObjectInspector objectInspector, Object[] resultObjects) {

    boolean selectedInUse = batch.selectedInUse;
    int[] selected = batch.selected;
    for (int logicalIndex = 0; logicalIndex < batch.size; logicalIndex++) {
      final int batchIndex = (selectedInUse ? selected[logicalIndex] : logicalIndex);
      resultVectorExtractRow.extractRow(batch, batchIndex, scrqtchRow);

      Object copyResult =
          ObjectInspectorUtils.copyToStandardObject(
              scrqtchRow[0], objectInspector, ObjectInspectorCopyOption.WRITABLE);
      resultObjects[rowIndex++] = copyResult;
    }
  }

  private boolean doVectorBetweenInTest(TypeInfo typeInfo,
      BetweenInVariation betweenInVariation, List<Object> compareList,
      List<String> columns, String[] columnNames,
      TypeInfo[] typeInfos, DataTypePhysicalVariation[] dataTypePhysicalVariations,
      List<ExprNodeDesc> children,
      GenericUDF udf, ExprNodeGenericFuncDesc exprDesc,
      BetweenInTestMode betweenInTestMode,
      VectorRandomBatchSource batchSource,
      ObjectInspector objectInspector,
      TypeInfo outputTypeInfo, Object[] resultObjects)
          throws Exception {

    HiveConf hiveConf = new HiveConf();
    if (betweenInTestMode == BetweenInTestMode.ADAPTOR) {
      hiveConf.setBoolVar(HiveConf.ConfVars.HIVE_TEST_VECTOR_ADAPTOR_OVERRIDE, true);
    }

    final boolean isFilter = betweenInVariation.isFilter;

    VectorizationContext vectorizationContext =
        new VectorizationContext(
            "name",
            columns,
            Arrays.asList(typeInfos),
            Arrays.asList(dataTypePhysicalVariations),
            hiveConf);
    VectorExpression vectorExpression =
        vectorizationContext.getVectorExpression(exprDesc,
            (isFilter ?
                VectorExpressionDescriptor.Mode.FILTER :
                VectorExpressionDescriptor.Mode.PROJECTION));
    vectorExpression.transientInit(hiveConf);

    if (betweenInTestMode == BetweenInTestMode.VECTOR_EXPRESSION) {
      String vecExprString = vectorExpression.toString();
      if (vectorExpression instanceof VectorUDFAdaptor) {
        System.out.println(
            "*NO NATIVE VECTOR EXPRESSION* typeInfo " + typeInfo.toString() +
            " betweenInTestMode " + betweenInTestMode +
            " betweenInVariation " + betweenInVariation +
            " vectorExpression " + vecExprString);
      } else if (dataTypePhysicalVariations[0] == DataTypePhysicalVariation.DECIMAL_64) {
        final String nameToCheck = vectorExpression.getClass().getSimpleName();
        if (!nameToCheck.contains("Decimal64")) {
          System.out.println(
              "*EXPECTED DECIMAL_64 VECTOR EXPRESSION* typeInfo " + typeInfo.toString() +
              " betweenInTestMode " + betweenInTestMode +
              " betweenInVariation " + betweenInVariation +
              " vectorExpression " + vecExprString);
        }
      }
    }

    // System.out.println("*VECTOR EXPRESSION* " + vectorExpression.getClass().getSimpleName());

    /*
    System.out.println(
        "*DEBUG* typeInfo " + typeInfo.toString() +
        " betweenInTestMode " + betweenInTestMode +
        " betweenInVariation " + betweenInVariation +
        " vectorExpression " + vectorExpression.toString());
    */

    VectorRandomRowSource rowSource = batchSource.getRowSource();
    VectorizedRowBatchCtx batchContext =
        new VectorizedRowBatchCtx(
            columnNames,
            rowSource.typeInfos(),
            rowSource.dataTypePhysicalVariations(),
            /* dataColumnNums */ null,
            /* partitionColumnCount */ 0,
            /* virtualColumnCount */ 0,
            /* neededVirtualColumns */ null,
            vectorizationContext.getScratchColumnTypeNames(),
            vectorizationContext.getScratchDataTypePhysicalVariations());

    VectorizedRowBatch batch = batchContext.createVectorizedRowBatch();

    VectorExtractRow resultVectorExtractRow = null;
    Object[] scrqtchRow = null;
    if (!isFilter) {
      resultVectorExtractRow = new VectorExtractRow();
      final int outputColumnNum = vectorExpression.getOutputColumnNum();
      resultVectorExtractRow.init(
          new TypeInfo[] { outputTypeInfo }, new int[] { outputColumnNum });
      scrqtchRow = new Object[1];
    }

    boolean copySelectedInUse = false;
    int[] copySelected = new int[VectorizedRowBatch.DEFAULT_SIZE];

    batchSource.resetBatchIteration();
    int rowIndex = 0;
    while (true) {
      if (!batchSource.fillNextBatch(batch)) {
        break;
      }
      final int originalBatchSize = batch.size;
      if (isFilter) {
        copySelectedInUse = batch.selectedInUse;
        if (batch.selectedInUse) {
          System.arraycopy(batch.selected, 0, copySelected, 0, originalBatchSize);
        }
      }

      // In filter mode, the batch size can be made smaller.
      vectorExpression.evaluate(batch);

      if (!isFilter) {
        extractResultObjects(batch, rowIndex, resultVectorExtractRow, scrqtchRow,
            objectInspector, resultObjects);
      } else {
        final int currentBatchSize = batch.size;
        if (copySelectedInUse && batch.selectedInUse) {
          int selectIndex = 0;
          for (int i = 0; i < originalBatchSize; i++) {
            final int originalBatchIndex = copySelected[i];
            final boolean booleanResult;
            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == originalBatchIndex) {
              booleanResult = true;
              selectIndex++;
            } else {
              booleanResult = false;
            }
            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);
          }
        } else if (batch.selectedInUse) {
          int selectIndex = 0;
          for (int i = 0; i < originalBatchSize; i++) {
            final boolean booleanResult;
            if (selectIndex < currentBatchSize && batch.selected[selectIndex] == i) {
              booleanResult = true;
              selectIndex++;
            } else {
              booleanResult = false;
            }
            resultObjects[rowIndex + i] = new BooleanWritable(booleanResult);
          }
        } else if (currentBatchSize == 0) {
          // Whole batch got zapped.
          for (int i = 0; i < originalBatchSize; i++) {
            resultObjects[rowIndex + i] = new BooleanWritable(false);
          }
        } else {
          // Every row kept.
          for (int i = 0; i < originalBatchSize; i++) {
            resultObjects[rowIndex + i] = new BooleanWritable(true);
          }
        }
      }

      rowIndex += originalBatchSize;
    }

    return true;
  }
}
```


Overlapping Code:
```
In {
@Test
public void testTinyInt() throws Exception {
Random random = new Random(5371);
doBetweenIn(random, "tinyint");
}
@Test
public void testSmallInt() throws Exception {
Random random = new Random(2772);
doBetweenIn(random, "smallint");
}
@Test
public void testInt() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "int");
}
@Test
public void testBigInt() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "bigint");
}
@Test
public void testString() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "string");
}
@Test
public void testTimestamp() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "timestamp");
}
@Test
public void testDate() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "date");
}
@Test
public void testFloat() throws Exception {
Random random = new Random(7322);
doBetweenIn(random, "float");
}
@Test
public void testDouble() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "double");
}
@Test
public void testChar() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "char(10)");
}
@Test
public void testVarchar() throws Exception {
Random random = new Random(12882);
doBetweenIn(random, "varchar(15)");
}
@Test
public void testDecimal() throws Exception {
Random random = new Random(9300);
doDecimalTests(random, /* tryDecimal64 */ false);
}
@Test
public void testDecimal64() throws Exception {
Random random = new Random(9300);
doDecimalTests(random, /* tryDecimal64 */ true);
}
@Test
public void testStruct() throws Exception {
Random random = new Random(9300);
doStructTests(random);
}
public enum BetweenInTestMode {
ROW_MODE,
ADAPTOR,
VECTOR_EXPRESSION;
static final int count = values().length;
}
public enum BetweenInVariation {
FILTER_BETWEEN,
FILTER_NOT_BETWEEN,
PROJECTION_BETWEEN,
PROJECTION_NOT_BETWEEN,
FILTER_IN,
PROJECTION_IN;
static final int count = values().length;
final boolean isFilter;
BetweenInVariation() {
isFilter = name().startsWith("FILTER");
}
}
private static TypeInfo[] decimalTypeInfos = new TypeInfo[] {
new DecimalT
```
<Overlap Ratio: 0.9803921568627451>

---

--- 239 --
Question ID: 869164de1c197bfc35626ca87d397d1eb869eeb6_0
Original Code:
```
public class UploadUtils
{
	private FileItem item;
	private String extension = "";

	public UploadUtils(FileItem item)
	{
		this.item = item;
	}

	public String getExtension()
	{
		if (this.extension == null || this.extension.equals("")) {
			this.extension = this.item.getName().substring(this.item.getName().lastIndexOf('.') + 1);
		}

		return this.extension;
	}

	public String getOriginalName() {
		return item.getName();
	}

	public byte[] getBytes() {
		return item.get();
	}

	public void saveUploadedFile(String filename) 
	{
		BufferedInputStream inputStream = null;
		FileOutputStream outputStream = null;

		try {
			inputStream = new BufferedInputStream(this.item.getInputStream());
			outputStream = new FileOutputStream(filename);

			int c;
			byte[] b = new byte[4096];
			while ((c = inputStream.read(b)) != -1) {
				outputStream.write(b, 0, c);
			}
		}
		catch (IOException e) {
			throw new ForumException(e);
		}
		finally {
			if (outputStream != null) {
				try {
					outputStream.flush();
					outputStream.close();
				}
				catch (IOException e) { }
			}

			if (inputStream != null) {
				try {
					inputStream.close();
				}
				catch (IOException e) { }
			}
		}
	}
}
```


Overlapping Code:
```
eItem item;
private String extension = "";
public UploadUtils(FileItem item)
{
this.item = item;
}
public String getExtension()
{
if (this.extension == null || this.extension.equals("")) {
this.extension = this.item.getName().substring(this.item.getName().lastIndexOf('.') + 1);
}
return this.extension;
}
public String getOriginalName() {
return item.getName();
}
public byte[] getBytes() {
return item.get();
}
public void saveUploadedFile(String filename) 
{
BufferedInputStream inputStream = null;
FileOutputStream outputStream = null;
try {
inputStream = new BufferedInputStream(this.item.getInputStream());
outputStream = new FileOutputStream(filename);
int c;
byte[] b = new byte[4096];
while ((c = inputStream.read(b)) != -1) {
outputStream.write(b, 0, c);
}
}
catch (IOException e) {
throw new ForumException(e);
}
finally {
if (outputStream != null) {
try {
outputStream.flush();
outputStream.close();
}
catch (IOException e) { }
}
if (inputStream != null) {
try {
inputStream.close();
}
catch (IOException e) 
```
<Overlap Ratio: 0.9541627689429373>

---

--- 240 --
Question ID: d2768d5c81a1e0425c84c472160e7d0f47c07717_0
Original Code:
```
public class OrderDiffTransformer
    implements Transformer<String, Order, KeyValue<String, DLQRecord>> {
  private ProcessorContext context;
  private final String storeName;
  private WindowStore<String, Order> ordersWindowStore;
  private final long leftDurationMs;
  private final long rightDurationMs;

  public OrderDiffTransformer(
      final String storeName, final long leftDurationMs, final long rightDurationMs) {
    this.storeName = storeName;
    this.leftDurationMs = leftDurationMs;
    this.rightDurationMs = rightDurationMs;
  }

  @Override
  public void init(final ProcessorContext context) {
    this.context = context;
    ordersWindowStore = this.context.getStateStore(storeName);
  }

  public OrderWithState newOrder(Order order) {
    return OrderWithState.newBuilder()
        .setState(OrderState.Created)
        .setId(order.getId())
        .setOrderTimestamp(order.getOrderTimestamp())
        .setCustomer(
            CustomerOrderWithState.newBuilder()
                .setState(OrderState.Created)
                .setName(order.getCustomer().getName())
                .setAddress(order.getCustomer().getAddress())
                .build())
        .setOrderedItems(
            order.getOrderedItems().stream()
                .map(
                    orderedItem -> {
                      if (orderedItem.getItemType() == OrderedItemType.book) {
                        BookOrder book = (BookOrder) orderedItem.getDetails();
                        return OrderedItem.newBuilder()
                            .setItemType(
                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)
                            .setPrice(orderedItem.getPrice())
                            .setDetails(
                                BookOrderWithState.newBuilder()
                                    .setState(OrderState.Created)
                                    .setId(book.getId())
                                    .setIsbn(book.getIsbn())
                                    .setName(book.getName())
                                    .build())
                            .build();
                      } else if (orderedItem.getItemType() == OrderedItemType.laptop) {
                        LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();
                        return OrderedItem.newBuilder()
                            .setItemType(
                                ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)
                            .setPrice(orderedItem.getPrice())
                            .setDetails(
                                LaptopOrderWithState.newBuilder()
                                    .setState(OrderState.Created)
                                    .setId(laptop.getId())
                                    .setName(laptop.getName())
                                    .build())
                            .build();
                      }
                      return null;
                    })
                .collect(Collectors.toList()))
        .build();
  }

  private BookOrderWithState bookToBookWithState(BookOrder book, OrderState state) {
    return BookOrderWithState.newBuilder()
        .setState(state)
        .setId(book.getId())
        .setIsbn(book.getIsbn())
        .setName(book.getName())
        .build();
  }

  private LaptopOrderWithState laptopToLaptopWithState(LaptopOrder laptop, OrderState state) {
    return LaptopOrderWithState.newBuilder()
        .setState(state)
        .setId(laptop.getId())
        .setName(laptop.getName())
        .build();
  }

  private OrderedItem orderedItemToOrderedItemWithState(
      ps.hassany.consistent.graph.orders.OrderedItem orderedItem, OrderState state) {
    if (orderedItem.getItemType() == OrderedItemType.book) {
      BookOrder book = (BookOrder) orderedItem.getDetails();
      return OrderedItem.newBuilder()
          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)
          .setPrice(orderedItem.getPrice())
          .setDetails(bookToBookWithState(book, state))
          .build();
    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {
      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();
      return OrderedItem.newBuilder()
          .setItemType(ps.hassany.consistent.graph.orders.internal.OrderedItemType.laptop)
          .setPrice(orderedItem.getPrice())
          .setDetails(laptopToLaptopWithState(laptop, state))
          .build();
    }
    return null;
  }

  private String extractOrderedItemId(ps.hassany.consistent.graph.orders.OrderedItem orderedItem) {
    if (orderedItem.getItemType() == OrderedItemType.book) {
      BookOrder book = (BookOrder) orderedItem.getDetails();
      return book.getId();
    } else if (orderedItem.getItemType() == OrderedItemType.laptop) {
      LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();
      return laptop.getId();
    }
    return null;
  }

  private OrderWithState deleteOrder(Order oldOrder) {
    var orderWithSateBuilder =
        OrderWithState.newBuilder()
            .setState(OrderState.Deleted)
            .setId(oldOrder.getId())
            .setOrderTimestamp(System.currentTimeMillis())
            .setCustomer(
                CustomerOrderWithState.newBuilder()
                    .setState(OrderState.Deleted)
                    .setName(oldOrder.getCustomer().getName())
                    .setAddress(oldOrder.getCustomer().getAddress())
                    .build());
    orderWithSateBuilder.setOrderedItems(
        oldOrder.getOrderedItems().stream()
            .map(orderedItem -> orderedItemToOrderedItemWithState(orderedItem, OrderState.Deleted))
            .collect(Collectors.toList()));
    return orderWithSateBuilder.build();
  }

  private OrderWithState orderDiff(Order oldOrder, Order newOrder) {
    if (newOrder == null) {
      return deleteOrder(oldOrder);
    }
    var orderWithSateBuilder =
        OrderWithState.newBuilder()
            .setState(OrderState.Updated)
            .setId(oldOrder.getId())
            .setOrderTimestamp(newOrder.getOrderTimestamp())
            .setCustomer(
                CustomerOrderWithState.newBuilder()
                    .setState(OrderState.Updated)
                    .setName(newOrder.getCustomer().getName())
                    .setAddress(newOrder.getCustomer().getAddress())
                    .build());

    var orderedItemsWithState =
        Stream.concat(
                // Assume all items in the old order are deleted
                oldOrder.getOrderedItems().stream()
                    .map(
                        orderedItem ->
                            Tuple.of(
                                extractOrderedItemId(orderedItem), OrderState.Deleted, orderedItem))
                    .collect(Collectors.toList())
                    .stream(),
                // Assume all items in the new order are Created
                newOrder.getOrderedItems().stream()
                    .map(
                        orderedItem ->
                            Tuple.of(
                                extractOrderedItemId(orderedItem), OrderState.Created, orderedItem))
                    .collect(Collectors.toList())
                    .stream())
            .collect(
                Collectors.toMap(
                    Tuple3::_1,
                    v -> Tuple.of(v._2(), v._3()),
                    // When there's two versions of the same item, take the new one with state
                    // 'Created' and update state to 'Updated'
                    (oldValue, newValue) ->
                        newValue._1() == OrderState.Created
                            ? Tuple.of(OrderState.Updated, newValue._2())
                            : Tuple.of(OrderState.Updated, oldValue._2())))
            .values()
            .stream()
            .map(value -> orderedItemToOrderedItemWithState(value._2(), value._1()))
            .collect(Collectors.toList());

    orderWithSateBuilder.setOrderedItems(orderedItemsWithState);
    return orderWithSateBuilder.build();
  }

  @Override
  public KeyValue<String, DLQRecord> transform(String key, Order order) {
    final long eventTimestamp = OrderTimestampExtractor.getOrderTimestamp(order);
    final var timeIterator =
        ordersWindowStore.fetch(
            key, eventTimestamp - leftDurationMs, eventTimestamp + rightDurationMs);
    OrderWithState orderWithState;
    boolean isError = false;
    String error = null;
    if (timeIterator.hasNext()) {
      orderWithState = orderDiff(timeIterator.next().value, order);
    } else if (order != null) {
      orderWithState = newOrder(order);
    } else {
      isError = true;
      error = "Deleting an order that didn't exists in the WindowedStore.";
      orderWithState =
          OrderWithState.newBuilder()
              .setState(OrderState.Deleted)
              .setId(key)
              .setOrderTimestamp(Clock.systemUTC().millis())
              .setOrderedItems(List.of())
              .build();
    }
    ordersWindowStore.put(key, order, eventTimestamp);
    return new KeyValue<>(
        key,
        DLQRecord.newBuilder()
            .setIsError(isError)
            .setError(error)
            .setTimestamp(Clock.systemUTC().millis())
            .setOrderWithState(orderWithState)
            .build());
  }

  @Override
  public void close() {}
}
```


Overlapping Code:
```
ents Transformer<String, Order, KeyValue<String, DLQRecord>> {
private ProcessorContext context;
private final String storeName;
private WindowStore<String, Order> ordersWindowStore;
private final long leftDurationMs;
private final long rightDurationMs;
public OrderDiffTransformer(
final String storeName, final long leftDurationMs, final long rightDurationMs) {
this.storeName = storeName;
this.leftDurationMs = leftDurationMs;
this.rightDurationMs = rightDurationMs;
}
@Override
public void init(final ProcessorContext context) {
this.context = context;
ordersWindowStore = this.context.getStateStore(storeName);
}
public OrderWithState newOrder(Order order) {
return OrderWithState.newBuilder()
.setState(OrderState.Created)
.setId(order.getId())
.setOrderTimestamp(order.getOrderTimestamp())
.setCustomer(
CustomerOrderWithState.newBuilder()
.setState(OrderState.Created)
.setName(order.getCustomer().getName())
.setAddress(order.getCustomer().getAddress())
.build())
.setOrderedItems(
order.getOrderedItems().stream()
.map(
orderedItem -> {
if (orderedItem.getItemType() == OrderedItemType.book) {
BookOrder book = (BookOrder) orderedItem.getDetails();
return OrderedItem.newBuilder()
.setItemType(
ps.hassany.consistent.graph.orders.internal.OrderedItemType.book)
.setPrice(orderedItem.getPrice())
.setDetails(
BookOrderWithState.newBuilder()
.setState(OrderState.Created)
.setId(book.getId())
.setIsbn(book.getIsbn())
.setName(book.getName())
.build())
.build();
} else if (orderedItem.getItemType() == OrderedItemType.laptop) {
LaptopOrder laptop = (LaptopOrder) orderedItem.getDetails();
return OrderedItem.newBuilder()
.setItemType(
ps.has
```
<Overlap Ratio: 0.9593023255813954>

---

--- 241 --
Question ID: 7390a4df502c2c4e797ae780d36cb491a985a38f_0
Original Code:
```
class ConstructorAPI implements Comparable {
    /** 
     * The type of the constructor, being all the parameter types
     * separated by commas.
     */
    public String type_ = null;
    
    /** 
     * The exceptions thrown by this constructor, being all the exception types
     * separated by commas. "no exceptions" if no exceptions are thrown.
     */
    public String exceptions_ = "no exceptions";
    
    /** Modifiers for this class. */
    public Modifiers modifiers_;

    /** The doc block, default is null. */
    public String doc_ = null;

    /** Constructor. */
    public ConstructorAPI(String type, Modifiers modifiers) {
        type_ = type;
        modifiers_ = modifiers;
    }

    /** Compare two ConstructorAPI objects by type and modifiers. */
    public int compareTo(Object o) {
        ConstructorAPI constructorAPI = (ConstructorAPI)o;
        int comp = type_.compareTo(constructorAPI.type_);
        if (comp != 0)
            return comp;
        comp = exceptions_.compareTo(constructorAPI.exceptions_);
        if (comp != 0)
            return comp;
        comp = modifiers_.compareTo(constructorAPI.modifiers_);
        if (comp != 0)
            return comp;
        if (APIComparator.docChanged(doc_, constructorAPI.doc_))
            return -1;
        return 0;
    }

    /** 
     * Tests two constructors, using just the type, used by indexOf(). 
     */
    public boolean equals(Object o) {
        if (type_.compareTo(((ConstructorAPI)o).type_) == 0)
            return true;
        return false;
    }
}
```


Overlapping Code:
```
implements Comparable {
/** 
* The type of the constructor, being all the parameter types
* separated by commas.
*/
public String type_ = null;

/** 
* The exceptions thrown by this constructor, being all the exception types
* separated by commas. "no exceptions" if no exceptions are thrown.
*/
public String exceptions_ = "no exceptions";

/** Modifiers for this class. */
public Modifiers modifiers_;
/** The doc block, default is null. */
public String doc_ = null;
/** Constructor. */
public ConstructorAPI(String type, Modifiers modifiers) {
type_ = type;
modifiers_ = modifiers;
}
/** Compare two ConstructorAPI objects by type and modifiers. */
public int compareTo(Object o) {
ConstructorAPI constructorAPI = (ConstructorAPI)o;
int comp = type_.compareTo(constructorAPI.type_);
if (comp != 0)
return comp;
comp = exceptions_.compareTo(constructorAPI.exceptions_);
if (comp != 0)
return comp;
comp = modifiers_.compareTo(constructorAPI.modifiers_);
if (comp != 0)
return comp;
if (APIComparator.docChanged(doc_, constructorAPI.doc_))
return -1;
return 0;
}
/** 
* Tests two constructors, using just the type, used by indexOf(). 
*/
public boolean equals(Object o) {
if (type_.compareTo(((ConstructorAPI)o).type_) == 0)
return true;
return fal
```
<Overlap Ratio: 0.9780907668231612>

---

--- 242 --
Question ID: 7590fff966aa492c3b2ff625b697edc9f74370b3_0
Original Code:
```
public class ScLabelRangesObj extends TestCase {
    static XSpreadsheetDocument xSheetDoc = null;

    /**
    * Creates Spreadsheet document.
    */
    protected void initialize( TestParameters tParam, PrintWriter log ) {
        // get a soffice factory object
        SOfficeFactory SOF = SOfficeFactory.getFactory( (XMultiServiceFactory)tParam.getMSF());

        try {
            log.println( "creating a sheetdocument" );
            xSheetDoc = SOF.createCalcDoc(null);
        } catch (com.sun.star.uno.Exception e) {
            // Some exception occured.FAILED
            e.printStackTrace( log );
            throw new StatusException( "Couldn't create document", e );
        }
    }

    /**
    * Disposes Spreadsheet document.
    */
    protected void cleanup( TestParameters tParam, PrintWriter log ) {
        log.println( "    disposing xSheetDoc " );
        XComponent oComp = (XComponent)
            UnoRuntime.queryInterface (XComponent.class, xSheetDoc) ;
        util.DesktopTools.closeDoc(oComp);
    }

    /**
    * Creating a Testenvironment for the interfaces to be tested.
    * Obtains the value of the property <code>'ColumnLabelRanges'</code>
    * from the document. The property value is the collection of label ranges.
    * Adds new label range to the collection using the interface
    * <code>XLabelRanges</code> that was queried from the property value.
    * This collection is the instance of the service
    * <code>com.sun.star.sheet.LabelRanges</code>.
    * @see com.sun.star.sheet.LabelRanges
    * @see com.sun.star.sheet.XLabelRanges
    */
    public synchronized TestEnvironment createTestEnvironment(
        TestParameters Param, PrintWriter log) throws StatusException {

        XInterface oObj = null;

        // creation of testobject here
        // first we write what we are intend to do to log file
        log.println( "Creating a test environment" );

        try {
            log.println("Getting test object ") ;
            XPropertySet docProps = (XPropertySet)
                UnoRuntime.queryInterface(XPropertySet.class, xSheetDoc);
            Object ranges = docProps.getPropertyValue("ColumnLabelRanges");
            XLabelRanges lRanges = (XLabelRanges)
                UnoRuntime.queryInterface(XLabelRanges.class, ranges);

            log.println("Adding at least one element for ElementAccess interface");
            CellRangeAddress aRange2 = new CellRangeAddress((short)0, 0, 1, 0, 6);
            CellRangeAddress aRange1 = new CellRangeAddress((short)0, 0, 0, 0, 1);
            lRanges.addNew(aRange1, aRange2);

            oObj = lRanges;
        } catch (com.sun.star.lang.WrappedTargetException e) {
            e.printStackTrace(log) ;
            throw new StatusException(
                "Error getting test object from spreadsheet document",e);
        } catch (com.sun.star.beans.UnknownPropertyException e) {
            e.printStackTrace(log) ;
            throw new StatusException(
                "Error getting test object from spreadsheet document",e);
        }

        log.println("creating a new environment for object");
        TestEnvironment tEnv = new TestEnvironment(oObj);

        log.println("testing...");

        return tEnv;
    } // finish method getTestEnvironment

}
```


Overlapping Code:
```
ngesObj extends TestCase {
static XSpreadsheetDocument xSheetDoc = null;
/**
* Creates Spreadsheet document.
*/
protected void initialize( TestParameters tParam, PrintWriter log ) {
// get a soffice factory object
SOfficeFactory SOF = SOfficeFactory.getFactory( (XMultiServiceFactory)tParam.getMSF());
try {
log.println( "creating a sheetdocument" );
xSheetDoc = SOF.createCalcDoc(null);
} catch (com.sun.star.uno.Exception e) {
// Some exception occured.FAILED
e.printStackTrace( log );
throw new StatusException( "Couldn't create document", e );
}
}
/**
* Disposes Spreadsheet document.
*/
protected void cleanup( TestParameters tParam, PrintWriter log ) {
log.println( " disposing xSheetDoc " );
XComponent oComp = (XComponent)
UnoRuntime.queryInterface (XComponent.class, xSheetDoc) ;
util.DesktopTools.closeDoc(oComp);
}
/**
* Creating a Testenvironment for the interfaces to be tested.
* Obtains the value of the property <code>'ColumnLabelRanges'</code>
* from the document. The property value is the collection of label ranges.
* Adds new label range to the collection using the interface
* <code>XLabelRanges</code> that was queried from the property value.
* This collection is the instance of the service
* <code>com.sun.star.sheet.LabelRanges</code>.
* @see com.sun.star.sheet.LabelRanges
* @see com.sun.star.sheet.XLabelRanges
*/
public synchronized TestEnvironment createTestEnvironment(
TestParameters Param, PrintWriter log) throws StatusException {
XInterface oObj = null;
// creation of testobject here
// first we write what we are intend to do to log file
log.println( "Creating a test environment" );
try {
log.println("Getting test object ") ;
XPropertySet docProps = (XPropertySet)
UnoRuntime.queryInterface(XPropertySet.class, xSheetDoc);
Object ranges = docProps.getPropertyValue("ColumnLabelRanges");
XLabelRanges lRanges = (XLabelRanges)
UnoRuntime.queryInterface(XLabelRanges.class, ranges);
log.println("Adding at least one element for ElementAccess interface");
CellRangeAddress aRange2 = new CellRangeAddress((short)0, 0, 1, 0, 6);
Ce
```
<Overlap Ratio: 0.9852099236641222>

---

--- 243 --
Question ID: 01ce4c2352ebab86846c3b1a6363425811555a6b_0
Original Code:
```
@PublishTestModule(
	testName = "fapi1-advanced-final-par-attempt-invalid-redirect_uri",
	displayName = "PAR : try to use an invalid redirect_uri ",
	summary = "This test tries to provide an invalid redirect_uri and expects authorization server to return an error",
	profile = "FAPI1-Advanced-Final",
	configurationFields = {
		"server.discoveryUrl",
		"client.client_id",
		"client.scope",
		"client.jwks",
		"mtls.key",
		"mtls.cert",
		"mtls.ca",
		"client2.client_id",
		"client2.scope",
		"client2.jwks",
		"mtls2.key",
		"mtls2.cert",
		"mtls2.ca",
		"resource.resourceUrl"
	}
)
@VariantNotApplicable(parameter = FAPIAuthRequestMethod.class, values = {
	"by_value"
})
public class FAPI1AdvancedFinalPARRejectInvalidRedirectUri extends AbstractFAPI1AdvancedFinalExpectingAuthorizationEndpointPlaceholderOrCallback {

	@Override
	protected void createPlaceholder() {
		callAndStopOnFailure(ExpectRedirectUriErrorPage.class, "FAPI1-BASE-5.2.2-9", "PAR-2.3");

		env.putString("error_callback_placeholder", env.getString("redirect_uri_missing_error"));
	}

	@Override
	protected ConditionSequence makeCreateAuthorizationRequestObjectSteps() {
		return super.makeCreateAuthorizationRequestObjectSteps().
			butFirst(condition(AddBadRedirectUriToRequestParameters.class));
	}

	@Override
	protected void performParAuthorizationRequestFlow() {
		callAndStopOnFailure(CallPAREndpoint.class);

		callAndContinueOnFailure(EnsurePARInvalidRequestOrInvalidRequestObjectError.class, Condition.ConditionResult.FAILURE, "PAR-2.3");

		fireTestFinished();
	}
}
```


Overlapping Code:
```
ublishTestModule(
testName = "fapi1-advanced-final-par-attempt-invalid-redirect_uri",
displayName = "PAR : try to use an invalid redirect_uri ",
summary = "This test tries to provide an invalid redirect_uri and expects authorization server to return an error",
profile = "FAPI1-Advanced-Final",
configurationFields = {
"server.discoveryUrl",
"client.client_id",
"client.scope",
"client.jwks",
"mtls.key",
"mtls.cert",
"mtls.ca",
"client2.client_id",
"client2.scope",
"client2.jwks",
"mtls2.key",
"mtls2.cert",
"mtls2.ca",
"resource.resourceUrl"
}
)
@VariantNotApplicable(parameter = FAPIAuthRequestMethod.class, values = {
"by_value"
})
public class FAPI1AdvancedFinalPARRejectInvalidRedirectUri extends AbstractFAPI1AdvancedFinalExpectingAuthorizationEndpointPlaceholderOrCallback {
@Override
protected void createPlaceholder() {
callAndStopOnFailure(ExpectRedirectUriErrorPage.class, "FAPI1-BASE-5.2.2-9", "PAR-2.3");
env.putString("error_callback_placeholder", env.getString("redirect_uri_missing_error"));
}
@Override
protected ConditionSequence makeCreateAuthorizationRequestObjectSteps() {
return super.makeCreateAuthorizationRequestObjectSteps().
butFirst(condition(AddBadRedirectUriToRequestParameters.class));
}
@Override
protected void performParAuthorizationRequestFlow() {
callAndStopOnFailure(CallPAREndpoint.class);
callAndContinueOnFailure(EnsurePARInvalidRequestOrInvalidRequestObjectError.class, Condition.ConditionResult.FAILURE, "PAR-2.3");
fireTestFinished();
}

```
<Overlap Ratio: 0.997979797979798>

---

--- 244 --
Question ID: d57c055c82af9c037ae79288a8be0e21d673952d_0
Original Code:
```
@SpringBootTest(classes = EnvKeeperApp.class)
@AutoConfigureMockMvc
@WithMockUser(roles={"USER", "WRITER"})
public class EnvironmentResourceIT {

    private static final String DEFAULT_SHORT_NAME = "AAAAAAAAAA";
    private static final String UPDATED_SHORT_NAME = "BBBBBBBBBB";

    private static final String DEFAULT_FULL_NAME = "AAAAAAAAAA";
    private static final String UPDATED_FULL_NAME = "BBBBBBBBBB";

    private static final String DEFAULT_DESCRIPTION = "AAAAAAAAAA";
    private static final String UPDATED_DESCRIPTION = "BBBBBBBBBB";

    private static final Integer DEFAULT_SORT_ORDER = 1;
    private static final Integer UPDATED_SORT_ORDER = 2;
    private static final Integer SMALLER_SORT_ORDER = 1 - 1;

    @Autowired
    private EnvironmentRepository environmentRepository;

    @Autowired
    private EnvironmentMapper environmentMapper;

    @Autowired
    private EnvironmentService environmentService;

    @Autowired
    private EnvironmentQueryService environmentQueryService;

    @Autowired
    private EntityManager em;

    @Autowired
    private MockMvc restEnvironmentMockMvc;

    private Environment environment;

    /**
     * Create an entity for this test.
     *
     * This is a static method, as tests for other entities might also need it,
     * if they test an entity which requires the current entity.
     */
    public static Environment createEntity(EntityManager em) {
        Environment environment = new Environment()
            .shortName(DEFAULT_SHORT_NAME)
            .fullName(DEFAULT_FULL_NAME)
            .description(DEFAULT_DESCRIPTION)
            .sortOrder(DEFAULT_SORT_ORDER);
        // Add required entity
        EnvironmentGroup environmentGroup;
        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {
            environmentGroup = EnvironmentGroupResourceIT.createEntity(em);
            em.persist(environmentGroup);
            em.flush();
        } else {
            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);
        }
        environment.setEnvironmentGroup(environmentGroup);
        return environment;
    }
    /**
     * Create an updated entity for this test.
     *
     * This is a static method, as tests for other entities might also need it,
     * if they test an entity which requires the current entity.
     */
    public static Environment createUpdatedEntity(EntityManager em) {
        Environment environment = new Environment()
            .shortName(UPDATED_SHORT_NAME)
            .fullName(UPDATED_FULL_NAME)
            .description(UPDATED_DESCRIPTION)
            .sortOrder(UPDATED_SORT_ORDER);
        // Add required entity
        EnvironmentGroup environmentGroup;
        if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {
            environmentGroup = EnvironmentGroupResourceIT.createUpdatedEntity(em);
            em.persist(environmentGroup);
            em.flush();
        } else {
            environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);
        }
        environment.setEnvironmentGroup(environmentGroup);
        return environment;
    }

    @BeforeEach
    public void initTest() {
        environment = createEntity(em);
    }

    @Test
    @Transactional
    public void createEnvironment() throws Exception {
        int databaseSizeBeforeCreate = environmentRepository.findAll().size();
        // Create the Environment
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);
        restEnvironmentMockMvc.perform(post("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isCreated());

        // Validate the Environment in the database
        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeCreate + 1);
        Environment testEnvironment = environmentList.get(environmentList.size() - 1);
        assertThat(testEnvironment.getShortName()).isEqualTo(DEFAULT_SHORT_NAME);
        assertThat(testEnvironment.getFullName()).isEqualTo(DEFAULT_FULL_NAME);
        assertThat(testEnvironment.getDescription()).isEqualTo(DEFAULT_DESCRIPTION);
        assertThat(testEnvironment.getSortOrder()).isEqualTo(DEFAULT_SORT_ORDER);
    }

    @Test
    @Transactional
    public void createEnvironmentWithExistingId() throws Exception {
        int databaseSizeBeforeCreate = environmentRepository.findAll().size();

        // Create the Environment with an existing ID
        environment.setId(1L);
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);

        // An entity with an existing ID cannot be created, so this API call must fail
        restEnvironmentMockMvc.perform(post("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isBadRequest());

        // Validate the Environment in the database
        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeCreate);
    }


    @Test
    @Transactional
    public void checkShortNameIsRequired() throws Exception {
        int databaseSizeBeforeTest = environmentRepository.findAll().size();
        // set the field null
        environment.setShortName(null);

        // Create the Environment, which fails.
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);


        restEnvironmentMockMvc.perform(post("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isBadRequest());

        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeTest);
    }

    @Test
    @Transactional
    public void checkFullNameIsRequired() throws Exception {
        int databaseSizeBeforeTest = environmentRepository.findAll().size();
        // set the field null
        environment.setFullName(null);

        // Create the Environment, which fails.
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);


        restEnvironmentMockMvc.perform(post("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isBadRequest());

        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeTest);
    }

    @Test
    @Transactional
    public void checkDescriptionIsRequired() throws Exception {
        int databaseSizeBeforeTest = environmentRepository.findAll().size();
        // set the field null
        environment.setDescription(null);

        // Create the Environment, which fails.
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);


        restEnvironmentMockMvc.perform(post("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isBadRequest());

        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeTest);
    }

    @Test
    @Transactional
    public void getAllEnvironments() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList
        restEnvironmentMockMvc.perform(get("/api/environments?sort=id,desc"))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(jsonPath("$.[*].id").value(hasItem(environment.getId().intValue())))
            .andExpect(jsonPath("$.[*].shortName").value(hasItem(DEFAULT_SHORT_NAME)))
            .andExpect(jsonPath("$.[*].fullName").value(hasItem(DEFAULT_FULL_NAME)))
            .andExpect(jsonPath("$.[*].description").value(hasItem(DEFAULT_DESCRIPTION)))
            .andExpect(jsonPath("$.[*].sortOrder").value(hasItem(DEFAULT_SORT_ORDER)));
    }

    @Test
    @Transactional
    public void getEnvironment() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get the environment
        restEnvironmentMockMvc.perform(get("/api/environments/{id}", environment.getId()))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(jsonPath("$.id").value(environment.getId().intValue()))
            .andExpect(jsonPath("$.shortName").value(DEFAULT_SHORT_NAME))
            .andExpect(jsonPath("$.fullName").value(DEFAULT_FULL_NAME))
            .andExpect(jsonPath("$.description").value(DEFAULT_DESCRIPTION))
            .andExpect(jsonPath("$.sortOrder").value(DEFAULT_SORT_ORDER));
    }


    @Test
    @Transactional
    public void getEnvironmentsByIdFiltering() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        Long id = environment.getId();

        defaultEnvironmentShouldBeFound("id.equals=" + id);
        defaultEnvironmentShouldNotBeFound("id.notEquals=" + id);

        defaultEnvironmentShouldBeFound("id.greaterThanOrEqual=" + id);
        defaultEnvironmentShouldNotBeFound("id.greaterThan=" + id);

        defaultEnvironmentShouldBeFound("id.lessThanOrEqual=" + id);
        defaultEnvironmentShouldNotBeFound("id.lessThan=" + id);
    }


    @Test
    @Transactional
    public void getAllEnvironmentsByShortNameIsEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName equals to DEFAULT_SHORT_NAME
        defaultEnvironmentShouldBeFound("shortName.equals=" + DEFAULT_SHORT_NAME);

        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME
        defaultEnvironmentShouldNotBeFound("shortName.equals=" + UPDATED_SHORT_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByShortNameIsNotEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName not equals to DEFAULT_SHORT_NAME
        defaultEnvironmentShouldNotBeFound("shortName.notEquals=" + DEFAULT_SHORT_NAME);

        // Get all the environmentList where shortName not equals to UPDATED_SHORT_NAME
        defaultEnvironmentShouldBeFound("shortName.notEquals=" + UPDATED_SHORT_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByShortNameIsInShouldWork() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName in DEFAULT_SHORT_NAME or UPDATED_SHORT_NAME
        defaultEnvironmentShouldBeFound("shortName.in=" + DEFAULT_SHORT_NAME + "," + UPDATED_SHORT_NAME);

        // Get all the environmentList where shortName equals to UPDATED_SHORT_NAME
        defaultEnvironmentShouldNotBeFound("shortName.in=" + UPDATED_SHORT_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByShortNameIsNullOrNotNull() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName is not null
        defaultEnvironmentShouldBeFound("shortName.specified=true");

        // Get all the environmentList where shortName is null
        defaultEnvironmentShouldNotBeFound("shortName.specified=false");
    }
                @Test
    @Transactional
    public void getAllEnvironmentsByShortNameContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName contains DEFAULT_SHORT_NAME
        defaultEnvironmentShouldBeFound("shortName.contains=" + DEFAULT_SHORT_NAME);

        // Get all the environmentList where shortName contains UPDATED_SHORT_NAME
        defaultEnvironmentShouldNotBeFound("shortName.contains=" + UPDATED_SHORT_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByShortNameNotContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where shortName does not contain DEFAULT_SHORT_NAME
        defaultEnvironmentShouldNotBeFound("shortName.doesNotContain=" + DEFAULT_SHORT_NAME);

        // Get all the environmentList where shortName does not contain UPDATED_SHORT_NAME
        defaultEnvironmentShouldBeFound("shortName.doesNotContain=" + UPDATED_SHORT_NAME);
    }


    @Test
    @Transactional
    public void getAllEnvironmentsByFullNameIsEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName equals to DEFAULT_FULL_NAME
        defaultEnvironmentShouldBeFound("fullName.equals=" + DEFAULT_FULL_NAME);

        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME
        defaultEnvironmentShouldNotBeFound("fullName.equals=" + UPDATED_FULL_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByFullNameIsNotEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName not equals to DEFAULT_FULL_NAME
        defaultEnvironmentShouldNotBeFound("fullName.notEquals=" + DEFAULT_FULL_NAME);

        // Get all the environmentList where fullName not equals to UPDATED_FULL_NAME
        defaultEnvironmentShouldBeFound("fullName.notEquals=" + UPDATED_FULL_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByFullNameIsInShouldWork() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName in DEFAULT_FULL_NAME or UPDATED_FULL_NAME
        defaultEnvironmentShouldBeFound("fullName.in=" + DEFAULT_FULL_NAME + "," + UPDATED_FULL_NAME);

        // Get all the environmentList where fullName equals to UPDATED_FULL_NAME
        defaultEnvironmentShouldNotBeFound("fullName.in=" + UPDATED_FULL_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByFullNameIsNullOrNotNull() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName is not null
        defaultEnvironmentShouldBeFound("fullName.specified=true");

        // Get all the environmentList where fullName is null
        defaultEnvironmentShouldNotBeFound("fullName.specified=false");
    }
                @Test
    @Transactional
    public void getAllEnvironmentsByFullNameContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName contains DEFAULT_FULL_NAME
        defaultEnvironmentShouldBeFound("fullName.contains=" + DEFAULT_FULL_NAME);

        // Get all the environmentList where fullName contains UPDATED_FULL_NAME
        defaultEnvironmentShouldNotBeFound("fullName.contains=" + UPDATED_FULL_NAME);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByFullNameNotContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where fullName does not contain DEFAULT_FULL_NAME
        defaultEnvironmentShouldNotBeFound("fullName.doesNotContain=" + DEFAULT_FULL_NAME);

        // Get all the environmentList where fullName does not contain UPDATED_FULL_NAME
        defaultEnvironmentShouldBeFound("fullName.doesNotContain=" + UPDATED_FULL_NAME);
    }


    @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionIsEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description equals to DEFAULT_DESCRIPTION
        defaultEnvironmentShouldBeFound("description.equals=" + DEFAULT_DESCRIPTION);

        // Get all the environmentList where description equals to UPDATED_DESCRIPTION
        defaultEnvironmentShouldNotBeFound("description.equals=" + UPDATED_DESCRIPTION);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionIsNotEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description not equals to DEFAULT_DESCRIPTION
        defaultEnvironmentShouldNotBeFound("description.notEquals=" + DEFAULT_DESCRIPTION);

        // Get all the environmentList where description not equals to UPDATED_DESCRIPTION
        defaultEnvironmentShouldBeFound("description.notEquals=" + UPDATED_DESCRIPTION);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionIsInShouldWork() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description in DEFAULT_DESCRIPTION or UPDATED_DESCRIPTION
        defaultEnvironmentShouldBeFound("description.in=" + DEFAULT_DESCRIPTION + "," + UPDATED_DESCRIPTION);

        // Get all the environmentList where description equals to UPDATED_DESCRIPTION
        defaultEnvironmentShouldNotBeFound("description.in=" + UPDATED_DESCRIPTION);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionIsNullOrNotNull() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description is not null
        defaultEnvironmentShouldBeFound("description.specified=true");

        // Get all the environmentList where description is null
        defaultEnvironmentShouldNotBeFound("description.specified=false");
    }
                @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description contains DEFAULT_DESCRIPTION
        defaultEnvironmentShouldBeFound("description.contains=" + DEFAULT_DESCRIPTION);

        // Get all the environmentList where description contains UPDATED_DESCRIPTION
        defaultEnvironmentShouldNotBeFound("description.contains=" + UPDATED_DESCRIPTION);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsByDescriptionNotContainsSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where description does not contain DEFAULT_DESCRIPTION
        defaultEnvironmentShouldNotBeFound("description.doesNotContain=" + DEFAULT_DESCRIPTION);

        // Get all the environmentList where description does not contain UPDATED_DESCRIPTION
        defaultEnvironmentShouldBeFound("description.doesNotContain=" + UPDATED_DESCRIPTION);
    }


    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder equals to DEFAULT_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.equals=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.equals=" + UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsNotEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder not equals to DEFAULT_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.notEquals=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder not equals to UPDATED_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.notEquals=" + UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsInShouldWork() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder in DEFAULT_SORT_ORDER or UPDATED_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.in=" + DEFAULT_SORT_ORDER + "," + UPDATED_SORT_ORDER);

        // Get all the environmentList where sortOrder equals to UPDATED_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.in=" + UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsNullOrNotNull() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder is not null
        defaultEnvironmentShouldBeFound("sortOrder.specified=true");

        // Get all the environmentList where sortOrder is null
        defaultEnvironmentShouldNotBeFound("sortOrder.specified=false");
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsGreaterThanOrEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder is greater than or equal to DEFAULT_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.greaterThanOrEqual=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder is greater than or equal to UPDATED_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.greaterThanOrEqual=" + UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsLessThanOrEqualToSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder is less than or equal to DEFAULT_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.lessThanOrEqual=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder is less than or equal to SMALLER_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.lessThanOrEqual=" + SMALLER_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsLessThanSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder is less than DEFAULT_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.lessThan=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder is less than UPDATED_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.lessThan=" + UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void getAllEnvironmentsBySortOrderIsGreaterThanSomething() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        // Get all the environmentList where sortOrder is greater than DEFAULT_SORT_ORDER
        defaultEnvironmentShouldNotBeFound("sortOrder.greaterThan=" + DEFAULT_SORT_ORDER);

        // Get all the environmentList where sortOrder is greater than SMALLER_SORT_ORDER
        defaultEnvironmentShouldBeFound("sortOrder.greaterThan=" + SMALLER_SORT_ORDER);
    }


    @Test
    @Transactional
    public void getAllEnvironmentsByEnvironmentGroupIsEqualToSomething() throws Exception {
        // Get already existing entity
        EnvironmentGroup environmentGroup = environment.getEnvironmentGroup();
        environmentRepository.saveAndFlush(environment);
        Long environmentGroupId = environmentGroup.getId();

        // Get all the environmentList where environmentGroup equals to environmentGroupId
        defaultEnvironmentShouldBeFound("environmentGroupId.equals=" + environmentGroupId);

        // Get all the environmentList where environmentGroup equals to environmentGroupId + 1
        defaultEnvironmentShouldNotBeFound("environmentGroupId.equals=" + (environmentGroupId + 1));
    }

    /**
     * Executes the search, and checks that the default entity is returned.
     */
    private void defaultEnvironmentShouldBeFound(String filter) throws Exception {
        restEnvironmentMockMvc.perform(get("/api/environments?sort=id,desc&" + filter))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(jsonPath("$.[*].id").value(hasItem(environment.getId().intValue())))
            .andExpect(jsonPath("$.[*].shortName").value(hasItem(DEFAULT_SHORT_NAME)))
            .andExpect(jsonPath("$.[*].fullName").value(hasItem(DEFAULT_FULL_NAME)))
            .andExpect(jsonPath("$.[*].description").value(hasItem(DEFAULT_DESCRIPTION)))
            .andExpect(jsonPath("$.[*].sortOrder").value(hasItem(DEFAULT_SORT_ORDER)));

        // Check, that the count call also returns 1
        restEnvironmentMockMvc.perform(get("/api/environments/count?sort=id,desc&" + filter))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(content().string("1"));
    }

    /**
     * Executes the search, and checks that the default entity is not returned.
     */
    private void defaultEnvironmentShouldNotBeFound(String filter) throws Exception {
        restEnvironmentMockMvc.perform(get("/api/environments?sort=id,desc&" + filter))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(jsonPath("$").isArray())
            .andExpect(jsonPath("$").isEmpty());

        // Check, that the count call also returns 0
        restEnvironmentMockMvc.perform(get("/api/environments/count?sort=id,desc&" + filter))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON_VALUE))
            .andExpect(content().string("0"));
    }

    @Test
    @Transactional
    public void getNonExistingEnvironment() throws Exception {
        // Get the environment
        restEnvironmentMockMvc.perform(get("/api/environments/{id}", Long.MAX_VALUE))
            .andExpect(status().isNotFound());
    }

    @Test
    @Transactional
    public void updateEnvironment() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();

        // Update the environment
        Environment updatedEnvironment = environmentRepository.findById(environment.getId()).get();
        // Disconnect from session so that the updates on updatedEnvironment are not directly saved in db
        em.detach(updatedEnvironment);
        updatedEnvironment
            .shortName(UPDATED_SHORT_NAME)
            .fullName(UPDATED_FULL_NAME)
            .description(UPDATED_DESCRIPTION)
            .sortOrder(UPDATED_SORT_ORDER);
        EnvironmentDTO environmentDTO = environmentMapper.toDto(updatedEnvironment);

        restEnvironmentMockMvc.perform(put("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isOk());

        // Validate the Environment in the database
        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);
        Environment testEnvironment = environmentList.get(environmentList.size() - 1);
        assertThat(testEnvironment.getShortName()).isEqualTo(UPDATED_SHORT_NAME);
        assertThat(testEnvironment.getFullName()).isEqualTo(UPDATED_FULL_NAME);
        assertThat(testEnvironment.getDescription()).isEqualTo(UPDATED_DESCRIPTION);
        assertThat(testEnvironment.getSortOrder()).isEqualTo(UPDATED_SORT_ORDER);
    }

    @Test
    @Transactional
    public void updateNonExistingEnvironment() throws Exception {
        int databaseSizeBeforeUpdate = environmentRepository.findAll().size();

        // Create the Environment
        EnvironmentDTO environmentDTO = environmentMapper.toDto(environment);

        // If the entity doesn't have an ID, it will throw BadRequestAlertException
        restEnvironmentMockMvc.perform(put("/api/environments")
            .contentType(MediaType.APPLICATION_JSON)
            .content(TestUtil.convertObjectToJsonBytes(environmentDTO)))
            .andExpect(status().isBadRequest());

        // Validate the Environment in the database
        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeUpdate);
    }

    @Test
    @Transactional
    public void deleteEnvironment() throws Exception {
        // Initialize the database
        environmentRepository.saveAndFlush(environment);

        int databaseSizeBeforeDelete = environmentRepository.findAll().size();

        // Delete the environment
        restEnvironmentMockMvc.perform(delete("/api/environments/{id}", environment.getId())
            .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isNoContent());

        // Validate the database contains one less item
        List<Environment> environmentList = environmentRepository.findAll();
        assertThat(environmentList).hasSize(databaseSizeBeforeDelete - 1);
    }
}
```


Overlapping Code:
```
otTest(classes = EnvKeeperApp.class)
@AutoConfigureMockMvc
@WithMockUser(roles={"USER", "WRITER"})
public class EnvironmentResourceIT {
private static final String DEFAULT_SHORT_NAME = "AAAAAAAAAA";
private static final String UPDATED_SHORT_NAME = "BBBBBBBBBB";
private static final String DEFAULT_FULL_NAME = "AAAAAAAAAA";
private static final String UPDATED_FULL_NAME = "BBBBBBBBBB";
private static final String DEFAULT_DESCRIPTION = "AAAAAAAAAA";
private static final String UPDATED_DESCRIPTION = "BBBBBBBBBB";
private static final Integer DEFAULT_SORT_ORDER = 1;
private static final Integer UPDATED_SORT_ORDER = 2;
private static final Integer SMALLER_SORT_ORDER = 1 - 1;
@Autowired
private EnvironmentRepository environmentRepository;
@Autowired
private EnvironmentMapper environmentMapper;
@Autowired
private EnvironmentService environmentService;
@Autowired
private EnvironmentQueryService environmentQueryService;
@Autowired
private EntityManager em;
@Autowired
private MockMvc restEnvironmentMockMvc;
private Environment environment;
/**
* Create an entity for this test.
*
* This is a static method, as tests for other entities might also need it,
* if they test an entity which requires the current entity.
*/
public static Environment createEntity(EntityManager em) {
Environment environment = new Environment()
.shortName(DEFAULT_SHORT_NAME)
.fullName(DEFAULT_FULL_NAME)
.description(DEFAULT_DESCRIPTION)
.sortOrder(DEFAULT_SORT_ORDER);
// Add required entity
EnvironmentGroup environmentGroup;
if (TestUtil.findAll(em, EnvironmentGroup.class).isEmpty()) {
environmentGroup = EnvironmentGroupResourceIT.createEntity(em);
em.persist(environmentGroup);
em.flush();
} else {
environmentGroup = TestUtil.findAll(em, EnvironmentGroup.class).get(0);
}
environment.setEnvironmentGroup(environmentGroup);
return environment;
}
/**
* Create an updated entity for this test.
*
* This is a static method, as tests for other entities might also need it,
* if they test an entity which requires the current entity.
*/
public static Environment createUpdatedEntity(EntityManager em) {
Environment environment = new Environment()

```
<Overlap Ratio: 0.9906933457422057>

---

--- 245 --
Question ID: 38954e4fa4dcbe6542ae92d969290e8dd9efd554_0
Original Code:
```
public class SmsIntentService extends IntentService {
    public static final int NOTIFICATION_ID = 1;
    private NotificationManager mNotificationManager;

    public SmsIntentService() {
        super("GcmIntentService");
    }
    public static final String TAG = "SMS Gateway";

    @Override
    protected void onHandleIntent(Intent intent)
    {
        Bundle extras = intent.getExtras();
        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
        String messageType = gcm.getMessageType(intent);

        if (!extras.isEmpty())
        {
            if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType))
            {
                String number = extras.getString("number");
                String message = extras.getString("message");
                if (!TextUtils.isEmpty(number) && !TextUtils.isEmpty(message))
                {
                    try
                    {
                        if (!number.startsWith("+"))
                        {
                            number = "+" + number;
                        }
                        SmsManager smsManager = SmsManager.getDefault();
                        ArrayList<String> parts = smsManager.divideMessage(message);
                        if (parts.size() > 1)
                        {
                            smsManager.sendMultipartTextMessage(number, null, parts, null, null);
                        }
                        else
                        {
                            smsManager.sendTextMessage(number, null, message, null, null);
                        }

                        String result = number + ": " + message;
                        Log.i(TAG, result);

                        sendNotification(result);

                        ContentValues values = new ContentValues();
                        values.put("address", number);
                        values.put("body", message);
                        getApplicationContext().getContentResolver()
                                               .insert(Uri.parse("content://sms/sent"), values);
                    }
                    catch (Exception ex)
                    {
                        Log.e(TAG, ex.toString());
                    }
                }
            }
        }
        SmsBroadcastReceiver.completeWakefulIntent(intent);
    }

    private void sendNotification(String msg) {
        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);

        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), 0);

        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this)
        .setSmallIcon(R.drawable.ic_stat_gcm)
        .setContentTitle(getText(R.string.app_name))
        .setStyle(new NotificationCompat.BigTextStyle()
        .bigText(msg))
        .setContentText(msg).setAutoCancel(true);

        mBuilder.setContentIntent(contentIntent);
        mNotificationManager.notify(NOTIFICATION_ID, mBuilder.build());
    }
}
```


Overlapping Code:
```
sIntentService extends IntentService {
public static final int NOTIFICATION_ID = 1;
private NotificationManager mNotificationManager;
public SmsIntentService() {
super("GcmIntentService");
}
public static final String TAG = "SMS Gateway";
@Override
protected void onHandleIntent(Intent intent)
{
Bundle extras = intent.getExtras();
GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
String messageType = gcm.getMessageType(intent);
if (!extras.isEmpty())
{
if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType))
{
String number = extras.getString("number");
String message = extras.getString("message");
if (!TextUtils.isEmpty(number) && !TextUtils.isEmpty(message))
{
try
{
if (!number.startsWith("+"))
{
number = "+" + number;
}
SmsManager smsManager = SmsManager.getDefault();
ArrayList<String> parts = smsManager.divideMessage(message);
if (parts.size() > 1)
{
smsManager.sendMultipartTextMessage(number, null, parts, null, null);
}
else
{
smsManager.sendTextMessage(number, null, message, null, null);
}
String result = number + ": " + message;
Log.i(TAG, result);
sendNotification(result);
ContentValues values = new ContentValues();
values.put("address", number);
values.put("body", message);
getApplicationContext().getContentResolver()
.insert(Uri.parse("content://sms/sent"), values);
}
catch (Exception ex)
{
Log.e(TAG, ex.toString());
}
}
}
}
SmsBroadcastReceiver.completeWakefulIntent(intent);
}
private void sendNotification(String msg) {
mNotificationManager = (NotificationManager) this.getSystemSe
```
<Overlap Ratio: 0.9903660886319846>

---

--- 246 --
Question ID: 7b9661fa862d71c1346c5fffebf199796071b814_0
Original Code:
```
public class ReorganizeStringTest {

    private final ReorganizeString testObject = new ReorganizeString();

    @Test
    public void testReorganizeString() {
        String s = "aab";
        assertEquals("aba", testObject.reorganizeString(s));

        s = "aaab";
        assertEquals("", testObject.reorganizeString(s));
    }
}
```


Overlapping Code:
```
c class ReorganizeStringTest {
private final ReorganizeString testObject = new ReorganizeString();
@Test
public void testReorganizeString() {
String s = "aab";
assertEquals("aba", testObject.reorganizeString(s));
s = "aaab";
assertEquals("", testObje
```
<Overlap Ratio: 0.8833922261484098>

---

--- 247 --
Question ID: 65bbe3bf9bb6e4d5b37af73b5ce9aac0cdfbd19b_0
Original Code:
```
public class AbstractVsThreadVisualizerTest {

    public AbstractVsThreadVisualizerTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception
    {
        TestJMeterUtils.createJmeterEnv();
    }

    @AfterClass
    public static void tearDownClass() throws Exception
    {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }

    /**
     * Test of getCurrentThreadCount method, of class AbstractVsThreadVisualizer.
     */
    @Test
    public void testGetCurrentThreadCount()
    {
        System.out.println("getCurrentThreadCount");
        long now = System.currentTimeMillis();
        SampleResult sample = new SampleResult();
        sample.setGroupThreads(3);
        sample.setThreadName("test_tg");
        sample.setStampAndTime(now, 300);
        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
        instance.add(sample);
        int expResult = 3;
        int result = instance.getCurrentThreadCount(sample);
        assertEquals(expResult, result);
    }

    /**
     * Test of add method, of class AbstractVsThreadVisualizer.
     */
    @Test
    public void testAdd()
    {
        System.out.println("add");
        SampleResult sample = new SampleResult();
        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
    }

    /**
     * Test of clearData method, of class AbstractVsThreadVisualizer.
     */
    @Test
    public void testClearData()
    {
        System.out.println("clearData");
        AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
        SampleResult sample = new SampleResult();
        instance.clearData();
    }

    public class AbstractVsThreadVisualizerImpl extends AbstractVsThreadVisualizer
    {
        @Override
        protected JSettingsPanel createSettingsPanel()
        {
            return new JSettingsPanel(this, JSettingsPanel.GRADIENT_OPTION);
        }

        @Override
        public String getLabelResource()
        {
            return "";
        }

        @Override
        public String getStaticLabel()
        {
            return "TEST";
        }

        @Override
        public String getWikiPage() {
           return "";
        }
    }

   /**
    * Test of setExtraChartSettings method, of class AbstractVsThreadVisualizer.
    */
   @Test
   public void testSetExtraChartSettings() {
      System.out.println("setExtraChartSettings");
      AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
      instance.setExtraChartSettings();
      assertTrue(instance.getGraphPanelChart().getChartSettings().isDrawCurrentX());
   }

}
```


Overlapping Code:
```
st {
public AbstractVsThreadVisualizerTest() {
}
@BeforeClass
public static void setUpClass() throws Exception
{
TestJMeterUtils.createJmeterEnv();
}
@AfterClass
public static void tearDownClass() throws Exception
{
}
@Before
public void setUp() {
}
@After
public void tearDown() {
}
/**
* Test of getCurrentThreadCount method, of class AbstractVsThreadVisualizer.
*/
@Test
public void testGetCurrentThreadCount()
{
System.out.println("getCurrentThreadCount");
long now = System.currentTimeMillis();
SampleResult sample = new SampleResult();
sample.setGroupThreads(3);
sample.setThreadName("test_tg");
sample.setStampAndTime(now, 300);
AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
instance.add(sample);
int expResult = 3;
int result = instance.getCurrentThreadCount(sample);
assertEquals(expResult, result);
}
/**
* Test of add method, of class AbstractVsThreadVisualizer.
*/
@Test
public void testAdd()
{
System.out.println("add");
SampleResult sample = new SampleResult();
AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
}
/**
* Test of clearData method, of class AbstractVsThreadVisualizer.
*/
@Test
public void testClearData()
{
System.out.println("clearData");
AbstractVsThreadVisualizer instance = new AbstractVsThreadVisualizerImpl();
SampleResult sample = new SampleResult();
instance.clearData();
}
public class AbstractVsThreadVisualizerImpl extends AbstractVsThreadVisualizer
{
@Override
protected JSettingsPanel createSettingsPanel()
{
return new JSettingsPanel(this, JSettingsPanel.GRADIENT_OPTION);
}
@Override
public String getLabelResource()
{
return "";
}
@Override
public String getStaticLabel()
{
return "TEST";
}
@Override
public String getWikiPage() {
return "";
}
}
/**
* Test of setExtraChartSettings method, of class AbstractVsThreadVisualizer.
*/
@Test
public void testSetExtraChartSettings() {
System.out.println("s
```
<Overlap Ratio: 0.9634888438133874>

---

--- 248 --
Question ID: 5df317cb66498d7d0ea5ad6761227e44c89b0cf5_0
Original Code:
```
@Service
public class ManagementBusInvocationPluginRemote extends IManagementBusInvocationPluginService {

    final private static Logger LOG = LoggerFactory.getLogger(ManagementBusInvocationPluginRemote.class);

    private final RequestSender requestSender;

    @Inject
    public ManagementBusInvocationPluginRemote(RequestSender requestSender) {
        this.requestSender = requestSender;
    }

    @Override
    public Exchange invoke(final Exchange exchange) {

        LOG.debug("Invoking IA on remote OpenTOSCA Container.");
        final Message message = exchange.getIn();
        final Object body = message.getBody();

        // IA invocation request containing the input parameters
        final IAInvocationRequest invocationRequest = parseBodyToInvocationRequest(body);

        // create request message and add the input parameters as body
        final BodyType requestBody = new BodyType(invocationRequest);
        final CollaborationMessage request = new CollaborationMessage(new KeyValueMap(), requestBody);

        // perform remote IA operation
        final Exchange responseExchange = requestSender.sendRequestToRemoteContainer(message, RemoteOperations.INVOKE_IA_OPERATION, request, 0);

        LOG.debug("Received a response for the invocation request!");

        if (!(responseExchange.getIn().getBody() instanceof CollaborationMessage)) {
            LOG.error("Received message has invalid class: {}", responseExchange.getIn().getBody().getClass());
            return exchange;
        }

        // extract the body and process the contained response
        final CollaborationMessage responseMessage = responseExchange.getIn().getBody(CollaborationMessage.class);
        final BodyType responseBody = responseMessage.getBody();

        if (Objects.isNull(responseBody)) {
            LOG.error("Collaboration message contains no body.");
            return exchange;
        }

        final IAInvocationRequest invocationResponse = responseBody.getIAInvocationRequest();

        if (Objects.isNull(invocationResponse)) {
            LOG.error("Body contains no IAInvocationRequest object with the result.");
            return exchange;
        }

        // process output of the response
        if (invocationResponse.getParams() != null) {
            LOG.debug("Response contains output as HashMap:");

            final HashMap<String, String> outputParamMap = new HashMap<>();

            for (final KeyValueType outputParam : invocationResponse.getParams().getKeyValuePair()) {
                LOG.debug("Key: {}, Value: {}", outputParam.getKey(), outputParam.getValue());
                outputParamMap.put(outputParam.getKey(), outputParam.getValue());
            }
            message.setBody(outputParamMap, HashMap.class);
        } else {
            if (invocationResponse.getDoc() != null) {
                LOG.debug("Response contains output as Document");

                try {
                    final DocumentBuilderFactory dFact = DocumentBuilderFactory.newInstance();
                    final DocumentBuilder build = dFact.newDocumentBuilder();
                    final Document document = build.newDocument();

                    final Element element = invocationResponse.getDoc().getAny();

                    document.adoptNode(element);
                    document.appendChild(element);

                    message.setBody(document, Document.class);
                } catch (final Exception e) {
                    LOG.error("Unable to parse Document: {}", e.getMessage());
                }
            } else {
                LOG.warn("Response contains no output.");
                message.setBody(null);
            }
        }

        return exchange;
    }

    @Override
    public List<String> getSupportedTypes() {
        // This plug-in supports only the special type 'remote' which is used to forward invocation
        // requests to other OpenTOSCA Containers.
        return Collections.singletonList(Constants.REMOTE_TYPE);
    }

    /**
     * Reads the input parameters of the invocation from the exchange body and adds them to a IAInvocationRequest
     * object.
     *
     * @param body the body of the exchange containing the invocation request
     * @return IAInvocationRequest object with given parameters in the Doc or Params element, if input parameters are
     * given as Hash Map or as Document.
     */
    private IAInvocationRequest parseBodyToInvocationRequest(final Object body) {

        LOG.debug("Parsing input parameters for the invocation...");

        final IAInvocationRequest invocationRequest = new IAInvocationRequest();

        if (body instanceof HashMap) {
            LOG.debug("Adding input params from incoming HashMap to the request.");

            @SuppressWarnings("unchecked") final HashMap<String, String> paramsMap = (HashMap<String, String>) body;

            final KeyValueMap invocationRequestMap = new KeyValueMap();
            final List<KeyValueType> invocationRequestPairs = invocationRequestMap.getKeyValuePair();

            for (final Entry<String, String> param : paramsMap.entrySet()) {
                invocationRequestPairs.add(new KeyValueType(param.getKey(), param.getValue()));
            }

            invocationRequest.setParams(invocationRequestMap);
        } else {
            if (body instanceof Document) {
                LOG.debug("Adding input params from incoming Document to the request.");

                final Document document = (Document) body;
                invocationRequest.setDoc(new Doc(document.getDocumentElement()));
            } else {
                LOG.warn("No input parameters defined!");
            }
        }

        return invocationRequest;
    }
}
```


Overlapping Code:
```
nagementBusInvocationPluginRemote extends IManagementBusInvocationPluginService {
final private static Logger LOG = LoggerFactory.getLogger(ManagementBusInvocationPluginRemote.class);
private final RequestSender requestSender;
@Inject
public ManagementBusInvocationPluginRemote(RequestSender requestSender) {
this.requestSender = requestSender;
}
@Override
public Exchange invoke(final Exchange exchange) {
LOG.debug("Invoking IA on remote OpenTOSCA Container.");
final Message message = exchange.getIn();
final Object body = message.getBody();
// IA invocation request containing the input parameters
final IAInvocationRequest invocationRequest = parseBodyToInvocationRequest(body);
// create request message and add the input parameters as body
final BodyType requestBody = new BodyType(invocationRequest);
final CollaborationMessage request = new CollaborationMessage(new KeyValueMap(), requestBody);
// perform remote IA operation
final Exchange responseExchange = requestSender.sendRequestToRemoteContainer(message, RemoteOperations.INVOKE_IA_OPERATION, request, 0);
LOG.debug("Received a response for the invocation request!");
if (!(responseExchange.getIn().getBody() instanceof CollaborationMessage)) {
LOG.error("Received message has invalid class: {}", responseExchange.getIn().getBody().getClass());
return exchange;
}
// extract the body and process the contained response
final CollaborationMessage responseMessage = responseExchange.getIn().getBody(CollaborationMessage.class);
final BodyType responseBody = responseMessage.getBody();
if (Objects.isNull(responseBody)) {
LOG.error("Collaboration message contains no body.");
return exchange;
}
final IAInvocationRequest invocationResponse = responseBody.getIAInvocationRequest();
if (Objects.isNull(invocationResponse)) {
LOG.error("Body contains no IAInvocationRequest object with the result.");
return exchange;
}
// process output of the response
if (invocationResponse.getParams() != null) {
LOG.debug("Response contains output as HashMap:");
final HashMap<String, String> outputParamMap = new HashMap<>();
for (final KeyValueType o
```
<Overlap Ratio: 0.9749303621169917>

---

--- 249 --
Question ID: 699d4c1baf64343d127ae1f4f38e4cacda7c5f18_0
Original Code:
```
@Path("/endp")
@RolesAllowed({"Echoer", "Tester"})
@ApplicationScoped
public class ApplicationScopedEndpoint {

    @Inject
    private JsonWebToken jwt;

    @Inject
    @Claim("raw_token")
    private ClaimValue<String> rawToken;

    @Inject
    @Claim("raw_token")
    private Provider<String> providedRawToken;

    @GET
    @Path("/verifyInjectedRawTokenClaimValue")
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject verifyInjectedRawTokenClaimValue(@QueryParam("raw_token") String rt) {
        return verifyRawToken(rawToken.getValue(), rt);
    }

    @GET
    @Path("/verifyInjectedRawTokenJwt")
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject verifyInjectedRawTokenJwt(@QueryParam("raw_token") String rt) {
        return verifyRawToken(jwt.getRawToken(), rt);
    }

    @GET
    @Path("/verifyInjectedRawTokenProvider")
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject verifyInjectedRawTokenProvider(@QueryParam("raw_token") String rt) {
        return verifyRawToken(providedRawToken.get(), rt);
    }

    private static JsonObject verifyRawToken(String injectedRawToken, String rawTokenQueryParam) {
        boolean pass = false;
        String msg;
        if (injectedRawToken == null || injectedRawToken.length() == 0) {
            msg = Claims.raw_token.name() + "value is null or empty, FAIL";
        } else if (injectedRawToken.equals(rawTokenQueryParam)) {
            msg = Claims.raw_token.name() + " PASS";
            pass = true;
        } else {
            msg = String.format("%s: %s != %s", Claims.raw_token.name(), injectedRawToken, rawTokenQueryParam);
        }
        JsonObject result = Json.createObjectBuilder()
                .add("pass", pass)
                .add("msg", msg)
                .add("injectedRawToken", injectedRawToken)
                .build();
        return result;
    }
}
```


Overlapping Code:
```
ath("/endp")
@RolesAllowed({"Echoer", "Tester"})
@ApplicationScoped
public class ApplicationScopedEndpoint {
@Inject
private JsonWebToken jwt;
@Inject
@Claim("raw_token")
private ClaimValue<String> rawToken;
@Inject
@Claim("raw_token")
private Provider<String> providedRawToken;
@GET
@Path("/verifyInjectedRawTokenClaimValue")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject verifyInjectedRawTokenClaimValue(@QueryParam("raw_token") String rt) {
return verifyRawToken(rawToken.getValue(), rt);
}
@GET
@Path("/verifyInjectedRawTokenJwt")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject verifyInjectedRawTokenJwt(@QueryParam("raw_token") String rt) {
return verifyRawToken(jwt.getRawToken(), rt);
}
@GET
@Path("/verifyInjectedRawTokenProvider")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject verifyInjectedRawTokenProvider(@QueryParam("raw_token") String rt) {
return verifyRawToken(providedRawToken.get(), rt);
}
private static JsonObject verifyRawToken(String injectedRawToken, String rawTokenQueryParam) {
boolean pass = false;
String msg;
if (injectedRawToken == null || injectedRawToken.length() == 0) {
msg = Claims.raw_token.name() + "value is null or empty, FAIL";
} else if (injectedRawToken.equals(rawTokenQueryParam)) {
msg = Claims.raw_token.name() + " PASS";
pass = true;
} else {
msg = String.format("%s: %s != %s", Claims.raw_token.name(), injectedRawToken, rawTokenQueryParam);
}
JsonObject result = Json.createObjectBuilder()
.add("pass", pass)
.add("msg", msg)
.add("injectedRawToken", injectedRawToken)
.buil
```
<Overlap Ratio: 0.9841269841269841>

---

--- 250 --
Question ID: d90ec197047b76cfb33f23408fe71de503ea3f2c_0
Original Code:
```
@SuppressWarnings("serial")
public class VariableType implements java.io.Serializable, org.vcell.util.Matchable {

	private int type = -1;
	private VariableDomain variableDomain;
	private final String name;
	private final String units;
	private final String label;
	/**
	 * mark types that were not previously supported by {@link #getVariableTypeFromInteger(int)}, issue warning if triggered
	 */
	private boolean legacyWarn = false;
	private static final List<VariableType> allTypes = new ArrayList<>();
	private static final Logger LG = LogManager.getLogger(VariableType.class);
	
	//match constants in numerics SimTypes.h
	private static final int UNKNOWN_TYPE = 0;
	private static final int VOLUME_TYPE = 1;
	private static final int MEMBRANE_TYPE = 2;
	private static final int CONTOUR_TYPE = 3;
	private static final int VOLUME_REGION_TYPE = 4;
	private static final int MEMBRANE_REGION_TYPE = 5;
	private static final int CONTOUR_REGION_TYPE = 6;
	private static final int NONSPATIAL_TYPE = 7;
	private static final int VOLUME_PARTICLE = 8; 
	private static final int MEMBRANE_PARTICLE = 9; 
	private static final int POINT_VARIABLE_TYPE = 10; 
	/**
	 * not generated by solver 
	 */
	private static final int POSTPROCESSING_TYPE = 999;
	
//	private static final String[] NAMES = {"Unknown","Volume","Membrane","Contour","Volume_Region","Membrane_Region","Contour_Region","Nonspatial","Post_Process"};
//	private static final String[] LABEL = {"Unknown","Conc","Density","Density","Conc","Density","Density","Conc","Unknown"};
//	private static final String[] UNITS = {"Unknown","uM","molecules/um^2","molecules/um","uM","molecules/um^2","molecules/um","uM","Unknown"};
	
	public static final VariableType UNKNOWN = new VariableType(UNKNOWN_TYPE,"Unknown","Unknown","Unknown");
	public static final VariableType VOLUME = new TwoCodeType(VOLUME_TYPE,VOLUME_PARTICLE,"Volume","uM","Conc");
	public static final VariableType MEMBRANE = new TwoCodeType(MEMBRANE_TYPE,MEMBRANE_PARTICLE,"Membrane","molecules/um^2","Density");
	public static final VariableType CONTOUR = new VariableType(CONTOUR_TYPE,"Contour","molecules/um","Density");
	public static final VariableType VOLUME_REGION = new VariableType(VOLUME_REGION_TYPE,"Volume_Region","uM","Conc");
	public static final VariableType MEMBRANE_REGION = new VariableType(MEMBRANE_REGION_TYPE,"Membrane_Region","molecules/um^2","Density");
	public static final VariableType CONTOUR_REGION = new VariableType(CONTOUR_REGION_TYPE,"Contour_Region","molecules/um","Density");
	public static final VariableType NONSPATIAL = new VariableType(NONSPATIAL_TYPE,"Nonspatial","uM","Conc");
	public static final VariableType POSTPROCESSING = new VariableType(POSTPROCESSING_TYPE,"Post_Process","Unknown","Unknown");
	public static final VariableType POINT_VARIABLE = new VariableType(POINT_VARIABLE_TYPE,"Point","uM","Conc");
	static {
		UNKNOWN.legacyWarn = true;
		NONSPATIAL.legacyWarn = true;
	}
	
	public enum VariableDomain {
		VARIABLEDOMAIN_POSTPROCESSING("PostProcessing"),
		VARIABLEDOMAIN_UNKNOWN("Unknown"),
		VARIABLEDOMAIN_VOLUME("Volume"),
		VARIABLEDOMAIN_MEMBRANE("Membrane"),
		VARIABLEDOMAIN_CONTOUR("Contour"),
		VARIABLEDOMAIN_NONSPATIAL("Nonspatial"),
		VARIABLEDOMAIN_POINT("Point");
		
		private String name = null;
		private VariableDomain(String arg_name) {
			name = arg_name;
		}
		public String getName() {
			return name;
		}
	}
	/**
	 * create and store reference in class list
	 * @param varType
	 */
	protected VariableType(int varType, String name, String units, String label) {
		super();
		this.type = varType;
		this.name = name;
		this.units = units;
		this.label = label;
		switch (type) {
		case UNKNOWN_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_UNKNOWN;
			break;
		case POSTPROCESSING_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_POSTPROCESSING;
			break;
		case VOLUME_TYPE:
		case VOLUME_REGION_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_VOLUME;
			break;
		case MEMBRANE_TYPE:
		case MEMBRANE_REGION_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_MEMBRANE;
			break;
		case CONTOUR_TYPE:
		case CONTOUR_REGION_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_CONTOUR;
			break;
		case NONSPATIAL_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_NONSPATIAL;
			break;
		case POINT_VARIABLE_TYPE:
			variableDomain = VariableDomain.VARIABLEDOMAIN_POINT;
			break;
		default:
			throw new RuntimeException("Unknown variable type " + type);
		}
		allTypes.add(this);
	}
/**
 * Insert the method's description here.
 * Creation date: (5/24/2001 9:28:51 PM)
 * @return boolean
 * @param obj cbit.util.Matchable
 */
public boolean compareEqual(Matchable obj) {
	return equals(obj);
}
/**
 * Insert the method's description here.
 * Creation date: (10/3/00 5:42:33 PM)
 */
public boolean equals(Object obj) {
	if (obj == null) {
		return false;
	}
	if (!(obj instanceof VariableType)) {
		return false;
	}
	VariableType pdeVT = (VariableType) obj;
	if (type!=pdeVT.type) {
		return false;
	}
	return true;
}

public String getDefaultLabel() {
	 return  label;
}

public String getDefaultUnits() {
	return units; 
}

public int getType() {
	return type;
}

public String getTypeName() {
	return name;
}
///**
// * Insert the method's description here.
// * Creation date: (10/3/00 2:48:55 PM)
// * @return cbit.vcell.simdata.PDEVariableType
// * @param mesh cbit.vcell.solvers.CartesianMesh
// * @param dataLength int
// */
//public static final VariableType getVariableTypeFromInteger(int varType) {
//	if (varType==VOLUME.type){
//		return VOLUME;
//	}else if (varType==MEMBRANE.type){
//		return MEMBRANE;
//	}else if (varType==CONTOUR.type){
//		return CONTOUR;
//	}else if (varType==VOLUME_REGION.type){
//		return VOLUME_REGION;
//	}else if (varType==MEMBRANE_REGION.type){
//		return MEMBRANE_REGION;
//	}else if (varType==CONTOUR_REGION.type){
//		return CONTOUR_REGION;
//	}else{
//		throw new IllegalArgumentException("varType="+varType+" is undefined");
//	}
//}



/**
 * search types to match criteria
 * @param criteria
 * @param errorMsg to display if miss
 * @return type that matches
 * @throws IllegalArgumentException if no match
 */
private static final VariableType find(Predicate<VariableType> criteria, String errorMsg) {
	Optional<VariableType> vt = allTypes.stream().filter( criteria ).findFirst();
	if (vt.isPresent()) {
		return vt.get();
	}
	
	throw new IllegalArgumentException("varType="+errorMsg+" is undefined");	
	
}
public static final VariableType getVariableTypeFromInteger(int varType) {
	Predicate<VariableType> pred = v -> v.supportsCode(varType);
	return find(pred,Integer.toString(varType));
	
}
public static final VariableType getVariableTypeFromVariableTypeName(String type) {	
	Predicate<VariableType> pred = v -> v.name.equals(type);
	return find(pred,type);
}

public static final VariableType getVariableTypeFromVariableTypeNameIgnoreCase(String type) {	
	Predicate<VariableType> pred = v -> v.name.equalsIgnoreCase(type);
	return find(pred,type);
}

/**
 * Insert the method's description here.
 * Creation date: (10/5/00 11:01:55 AM)
 * @return int
 */
public int hashCode() {
	return type;
}
/**
 * Insert the method's description here.
 * Creation date: (7/6/01 4:05:42 PM)
 * @return boolean
 * @param varType cbit.vcell.simdata.VariableType
 */
public boolean isExpansionOf(VariableType varType) {
	//
	// an enclosing domain (e.g. VOLUME) is an expansion of an enclosed region (e.g. VOLUME_REGION).
	//
	// example: if VOLUME_REGION and VOLUME data are used in same function,
	// then function must be evaluated at each volume index (hence VOLUME wins).
	//
	if (type == VOLUME_TYPE && varType.type == VOLUME_REGION_TYPE) return true;
	if (type == MEMBRANE_TYPE && varType.type == MEMBRANE_REGION_TYPE) return true;
	if (type == CONTOUR_TYPE && varType.type == CONTOUR_REGION_TYPE) return true;
	if (type != POINT_VARIABLE_TYPE && varType.type == POINT_VARIABLE_TYPE) return true;
	return false;
}
/**
 * Insert the method's description here.
 * Creation date: (5/8/01 2:12:01 PM)
 * @return java.lang.String
 */
public String toString() {
	return getTypeName()+"_VariableType";
}
public final VariableDomain getVariableDomain() {
	return variableDomain;
}

public static VariableType getVariableType(Variable var) {
	if (var instanceof VolVariable || var instanceof VolumeParticleVariable) {
		return VariableType.VOLUME;
	} else if (var instanceof VolumeRegionVariable) {
		return VariableType.VOLUME_REGION;
	} else if (var instanceof MemVariable || var instanceof MembraneParticleVariable) {
		return VariableType.MEMBRANE;
	} else if (var instanceof MembraneRegionVariable) {
		return VariableType.MEMBRANE_REGION;
	} else if (var instanceof FilamentVariable) {
		return VariableType.CONTOUR;
	} else if (var instanceof FilamentRegionVariable) {
		return VariableType.CONTOUR_REGION;
	} else if (var instanceof InsideVariable) {
		return VariableType.MEMBRANE;
	} else if (var instanceof OutsideVariable) {
		return VariableType.MEMBRANE;
	} else if (var instanceof DataGenerator){
		return VariableType.POSTPROCESSING;
	} else {
		return VariableType.UNKNOWN;
	}
}
public boolean incompatibleWith(VariableType funcType) {
	if ((this.type == POSTPROCESSING_TYPE || funcType.type == POSTPROCESSING_TYPE) && this.type != funcType.type){
		return false;
	}
	return true;
}

/**
 * does variable support code value? 
 * @param code
 * @return true if does
 */
protected boolean supportsCode(int code) {
	final boolean matches = ( code == type );
	if (matches && legacyWarn  && LG.isWarnEnabled()) {
		LG.warn("code match found on " + code + ", " + getTypeName() + ", not previously supported");
	}
	return matches;
}

private static class TwoCodeType extends VariableType {

	private final int secondaryType;

	protected TwoCodeType(int varType, int secondaryType,String name, String units, String label) {
		super(varType, name, units, label);
		this.secondaryType = secondaryType;
	}

	/**
	 * check against both codes
	 */
	@Override
	protected boolean supportsCode(int code) {
		return super.supportsCode(code) || code == secondaryType;
	}
	
	
	
}

}
```


Overlapping Code:
```
ariableType implements java.io.Serializable, org.vcell.util.Matchable {
private int type = -1;
private VariableDomain variableDomain;
private final String name;
private final String units;
private final String label;
/**
* mark types that were not previously supported by {@link #getVariableTypeFromInteger(int)}, issue warning if triggered
*/
private boolean legacyWarn = false;
private static final List<VariableType> allTypes = new ArrayList<>();
private static final Logger LG = LogManager.getLogger(VariableType.class);

//match constants in numerics SimTypes.h
private static final int UNKNOWN_TYPE = 0;
private static final int VOLUME_TYPE = 1;
private static final int MEMBRANE_TYPE = 2;
private static final int CONTOUR_TYPE = 3;
private static final int VOLUME_REGION_TYPE = 4;
private static final int MEMBRANE_REGION_TYPE = 5;
private static final int CONTOUR_REGION_TYPE = 6;
private static final int NONSPATIAL_TYPE = 7;
private static final int VOLUME_PARTICLE = 8; 
private static final int MEMBRANE_PARTICLE = 9; 
private static final int POINT_VARIABLE_TYPE = 10; 
/**
* not generated by solver 
*/
private static final int POSTPROCESSING_TYPE = 999;

// private static final String[] NAMES = {"Unknown","Volume","Membrane","Contour","Volume_Region","Membrane_Region","Contour_Region","Nonspatial","Post_Process"};
// private static final String[] LABEL = {"Unknown","Conc","Density","Density","Conc","Density","Density","Conc","Unknown"};
// private static final String[] UNITS = {"Unknown","uM","molecules/um^2","molecules/um","uM","molecules/um^2","molecules/um","uM","Unknown"};

public static final VariableType UNKNOWN = new VariableType(UNKNOWN_TYPE,"Unknown","Unknown","Unknown");
public static final VariableType VOLUME = new TwoCodeType(VOLUME_TYPE,VOLUME_PARTICLE,"Volume","uM","Conc");
public static final VariableType MEMBRANE = new TwoCodeType(MEMBRANE_TYPE,MEMBRANE_PARTICLE,"Membrane","molecules/um^2","Density");
public static final VariableType CONTOUR = new VariableType(CONTOUR_TYPE,"Contour","molecules/um","Density");
public static final VariableType VOLUME_REGION = new VariableType(VOLUME_REGION_TYPE,"Volume_Region","uM","Conc");
public static final VariableType MEMBRANE_REGION = new VariableType(MEMBRANE_REGION_TYPE,"Membrane_Region","molecules/um^2","Density");
public static final VariableType CONTOUR_
```
<Overlap Ratio: 0.9730848861283644>

---

--- 251 --
Question ID: ebda8f1ae9f5fc231c8017bce332c38520783f1c_0
Original Code:
```
public static class SingletonFactory {
        private Map<Vertex, String> typeNames = new HashMap<>();
        private Map<String, IRType> typeObjs = new HashMap<>();
        private Map<String, GenType> customTypes = new HashMap<>();
        private GraphTraversalSource g;
        public SingletonFactory(GraphTraversalSource g) {
            this.g = g;
        }

        public GenType create(String name, int size, Expression origin){
            if(customTypes.containsKey(name)){
                GenType type = customTypes.get(name);
                if(type.getSize() != size)
                    throw new IllegalStateException("Type already stored, but it has a different size.");

                return type;
            }
            GenType type = new GenType(name, size, origin);
            customTypes.put(name, type);
            return type;
        }
        
        public IRType create(Vertex v){
            if(typeNames.containsKey(v))
                return  typeObjs.get(typeNames.get(v));

            String typeType = (String) g.V(v).values(Dom.Syn.V.CLASS).next();

            switch(typeType){
                case "StructTypeDeclarationContext": // intentional fallthrough
                case "HeaderTypeDeclarationContext": 
                    return handleStructAndHeader(v, typeType);
                case "TypedefDeclarationContext": 
                    return handleTypedef(v, typeType);
                case "BaseTypeContext": 
                    return handleBaseType(v, typeType);
                case "ExternDeclarationContext": 
                    return handleExternDataType(v, typeType);
                default: 
                    throw new IllegalArgumentException(
                        String.format("Type initialized with vertex %s of unknown class %s.", v, typeType));
            }
        }

        private IRType handleStructAndHeader(Vertex v, String typeType) {
            String typeName = (String)
                g.V(v).outE(Dom.SYMBOL)
                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME).inV()
                    .values("value")
                    .next();

            if(typeObjs.containsKey(typeName)){
                IRType typeObj2 = typeObjs.get(typeName);
                typeNames.put(v, typeName);
                return typeObj2;
            }
            IRType typeObj = new Struct(g,v, typeType, this);
            registerTypeObjToVertex(v, typeObj);
            return typeObj;
        }

        private IRType handleTypedef(Vertex v, String typeType){
            String typeName = (String)
                g.V(v).outE(Dom.SYMBOL)
                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)
                    .inV()
                    .values("value")
                    .next();

            if(typeObjs.containsKey(typeName)){
                IRType typeObj2 = typeObjs.get(typeName);
                typeNames.put(v, typeName);
                return typeObj2;
            }

            IRType typeObj = new TypeSynonym(g, v, typeType, this);
            registerTypeObjToVertex(v, typeObj);
            return typeObj;

        }

        // note: this is the same as handleStructAndHeader except for the initialization
        private IRType handleExternDataType(Vertex v, String typeType) {
            String typeName = (String)
                g.V(v).outE(Dom.SYMBOL)
                    .has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME)
                    .inV()
                    .values("value")
                    .next();

            if(typeObjs.containsKey(typeName)){
                IRType typeObj2 = typeObjs.get(typeName);
                typeNames.put(v, typeName);
                return typeObj2;
            }

            IRType typeObj = new ExternDataType(g, v, typeType);
            registerTypeObjToVertex(v, typeObj);
            return typeObj;

        }

        private IRType handleBaseType(Vertex v, String typeType){
            List<Object> subterms = 
                g.V(v).outE(Dom.SYN)
                      .order().by(Dom.Syn.E.ORD, Order.asc)
                      .inV()
                      .values("value").toList();

            String term = subterms.stream().map(o -> (String) o).collect(Collectors.joining(""));
            if(typeObjs.containsKey(term)){
                IRType typeObj2 = typeObjs.get(term);
                typeNames.put(v, term);
                return typeObj2;
            }

            IRType typeObj = new BaseType(g,v, typeType);
            registerTypeObjToVertex(v, typeObj);
            return typeObj;
        }

        private void registerTypeObjToVertex(Vertex v, IRType typeObj) {
            typeNames.put(v, typeObj.getName());
            
            if(typeObjs.containsKey(typeObj.getName()))
                return;

            typeObjs.put(typeObj.getName(), typeObj);
        }
    }
```


Overlapping Code:
```
Factory {
private Map<Vertex, String> typeNames = new HashMap<>();
private Map<String, IRType> typeObjs = new HashMap<>();
private Map<String, GenType> customTypes = new HashMap<>();
private GraphTraversalSource g;
public SingletonFactory(GraphTraversalSource g) {
this.g = g;
}
public GenType create(String name, int size, Expression origin){
if(customTypes.containsKey(name)){
GenType type = customTypes.get(name);
if(type.getSize() != size)
throw new IllegalStateException("Type already stored, but it has a different size.");
return type;
}
GenType type = new GenType(name, size, origin);
customTypes.put(name, type);
return type;
}

public IRType create(Vertex v){
if(typeNames.containsKey(v))
return typeObjs.get(typeNames.get(v));
String typeType = (String) g.V(v).values(Dom.Syn.V.CLASS).next();
switch(typeType){
case "StructTypeDeclarationContext": // intentional fallthrough
case "HeaderTypeDeclarationContext": 
return handleStructAndHeader(v, typeType);
case "TypedefDeclarationContext": 
return handleTypedef(v, typeType);
case "BaseTypeContext": 
return handleBaseType(v, typeType);
case "ExternDeclarationContext": 
return handleExternDataType(v, typeType);
default: 
throw new IllegalArgumentException(
String.format("Type initialized with vertex %s of unknown class %s.", v, typeType));
}
}
private IRType handleStructAndHeader(Vertex v, String typeType) {
String typeName = (String)
g.V(v).outE(Dom.SYMBOL)
.has(Dom.Symbol.ROLE, Dom.Symbol.Role.DECLARES_NAME).inV()
.values("value")
.next();
if(typeObjs.containsKey(typeName)){
IRType typeObj2 = typeObjs.get(typeName);
typeNames.put(v, typeName);
return typeObj2;
}
IRType typeObj = new Struct(g,v, typeType, this);
registerTypeObjToVertex(v, typeObj
```
<Overlap Ratio: 0.9734012450481041>

---

--- 252 --
Question ID: a51f15390d2709779fb27cb6a557fca2488c6e3d_0
Original Code:
```
@Order(-9)
@Component
public class DoubleInterpolatorSupportingContextMenuItem implements PropertyValueContextMenuItem {
    private CurveEditorTab curveEditorTab;
    private DockableTabRepository dockableTabRepository;

    public DoubleInterpolatorSupportingContextMenuItem(CurveEditorTab curveEditorTab, DockableTabRepository dockableTabRepository) {
        this.curveEditorTab = curveEditorTab;
        this.dockableTabRepository = dockableTabRepository;
    }

    @Override
    public boolean supports(PropertyValueContextMenuRequest request) {
        return request.valueProvider.getInterpolator() instanceof DoubleInterpolator;
    }

    @Override
    public MenuItem createMenuItem(PropertyValueContextMenuRequest request) {
        MenuItem revealInEditorMenuItem = new MenuItem("Reveal curve in editor");
        revealInEditorMenuItem.setOnAction(e -> {
            OpenTabRequest tabOpenRequest = OpenTabRequest.builder()
                    .withTabToOpen(curveEditorTab)
                    .withTarget(MAIN_WINDOW)
                    .withSameTabPaneAs(Optional.of(AddableContentDockableTabFactory.ID))
                    .build();
            dockableTabRepository.openTab(tabOpenRequest);
            curveEditorTab.revealInEditor(request.valueProvider);
        });
        return revealInEditorMenuItem;
    }

}
```


Overlapping Code:
```
@Component
public class DoubleInterpolatorSupportingContextMenuItem implements PropertyValueContextMenuItem {
private CurveEditorTab curveEditorTab;
private DockableTabRepository dockableTabRepository;
public DoubleInterpolatorSupportingContextMenuItem(CurveEditorTab curveEditorTab, DockableTabRepository dockableTabRepository) {
this.curveEditorTab = curveEditorTab;
this.dockableTabRepository = dockableTabRepository;
}
@Override
public boolean supports(PropertyValueContextMenuRequest request) {
return request.valueProvider.getInterpolator() instanceof DoubleInterpolator;
}
@Override
public MenuItem createMenuItem(PropertyValueContextMenuRequest request) {
MenuItem revealInEditorMenuItem = new MenuItem("Reveal curve in editor");
revealInEditorMenuItem.setOnAction(e -> {
OpenTabRequest tabOpenRequest = OpenTabRequest.builder()
.withTabToOpen(curveEditorTab)
.withTarget(MAIN_WINDOW)
.withSameTabPaneAs(Optional.of(AddableContentDockableTabFactory.ID))
.build();
dockableTabRepository.openTab(tabOpenRequest);
curveEditorTab.revealInEditor(request.valueProvider);
});
return revealInEditorMen
```
<Overlap Ratio: 0.9812834224598931>

---

--- 253 --
Question ID: 64541162fbc9654d7ff25e39af33e8fde41fc476_0
Original Code:
```
class CassandraBuilderTests {

	private final CassandraBuilder builder = new CassandraBuilder();

	@Test
	void invalidName() {
		assertThatThrownBy(() -> this.builder.name("")).hasStackTraceContaining("Name must not be empty");
	}

	@Test
	void generatedName() {
		Cassandra c1 = this.builder.build();
		Cassandra c2 = this.builder.build();
		assertThat(c1.getName()).isNotEqualTo(c2.getName());
	}

	@Test
	void name() {
		CassandraBuilder cassandra = this.builder.name("cassandra");
		assertThat(cassandra).hasFieldOrPropertyWithValue("name", "cassandra");
		assertThat(this.builder.getName()).isEqualTo("cassandra");
	}

	@Test
	void version() {
		assertThat(this.builder.getVersion()).isEqualTo(CassandraBuilder.DEFAULT_VERSION);
		Cassandra cassandra = this.builder.version("3.11.11").build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("version", Version.parse("3.11.11"));
		assertThat(this.builder.getVersion()).isEqualTo(Version.parse("3.11.11"));
	}

	@Test
	void registerShutdownHook() {
		Cassandra cassandra = this.builder.registerShutdownHook(false).build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("registerShutdownHook", false);
	}

	@Test
	void startupTimeout() {
		Cassandra cassandra = this.builder.startupTimeout(Duration.ofMinutes(1)).build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("startupTimeout", Duration.ofMinutes(1));
	}

	@Test
	void startupNegative() {
		assertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))
				.hasStackTraceContaining("Startup Timeout must be positive");
	}

	@Test
	void startupZero() {
		assertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))
				.hasStackTraceContaining("Startup Timeout must be positive");
	}

	@Test
	void workingDirectory(@TempDir Path workingDirectory) {
		Cassandra cassandra = this.builder.workingDirectory(() -> workingDirectory).build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("workingDirectory", workingDirectory);
	}

	@Test
	void invalidWorkingDirectory() {
		assertThatThrownBy(() -> this.builder.workingDirectory(() -> {
			throw new IOException("");
		}).build()).hasStackTraceContaining("Unable to get a working directory");
	}

	@Test
	void workingDirectoryInitializer() {
		WorkingDirectoryInitializer workingDirectoryInitializer = (workingDirectory, version) -> {
		};
		Cassandra cassandra = this.builder.workingDirectoryInitializer(workingDirectoryInitializer).build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("workingDirectoryInitializer", workingDirectoryInitializer);
	}

	@Test
	void workingDirectoryDestroyer() {
		WorkingDirectoryDestroyer workingDirectoryDestroyer = (workingDirectory, version) -> {
		};
		Cassandra cassandra = this.builder.workingDirectoryDestroyer(workingDirectoryDestroyer).build();
		assertThat(cassandra).hasFieldOrPropertyWithValue("workingDirectoryDestroyer", workingDirectoryDestroyer);
	}

	@Test
	void workingDirectoryCustomizers() {
		WorkingDirectoryCustomizer w1 = WorkingDirectoryCustomizer
				.addResource(new ClassPathResource("text.txt"), "conf/text.txt");
		WorkingDirectoryCustomizer w2 = WorkingDirectoryCustomizer
				.addResource(new ClassPathResource("empty.txt"), "conf/empty.txt");
		assertThat(this.builder.workingDirectoryCustomizers(w1).build())
				.hasFieldOrPropertyWithValue("workingDirectoryCustomizers", Collections.singleton(w1));
		assertThat(this.builder.workingDirectoryCustomizers(w2).build())
				.hasFieldOrPropertyWithValue("workingDirectoryCustomizers", Collections.singleton(w2));
		assertThat(this.builder.addWorkingDirectoryCustomizers(w1).build())
				.hasFieldOrPropertyWithValue("workingDirectoryCustomizers", new LinkedHashSet<>(Arrays.asList(w2, w1)));

	}

	@Test
	void logger() {
		Logger logger = Logger.get("TEST");
		assertThat(this.builder.logger(logger).build()).hasFieldOrPropertyWithValue("logger", logger);
	}

	@Test
	void environmentVariables() {
		Path javaHome = Paths.get(System.getProperty("java.home"));
		assertThat(this.builder.addEnvironmentVariable("JAVA_HOME", javaHome).build())
				.hasFieldOrPropertyWithValue("databaseFactory.environmentVariables",
						mapOf("JAVA_HOME", javaHome));
		assertThat(this.builder.addEnvironmentVariables(mapOf("EXTRA_CLASSPATH", "lib.jar")).build())
				.hasFieldOrPropertyWithValue("databaseFactory.environmentVariables",
						mapOf("JAVA_HOME", javaHome, "EXTRA_CLASSPATH", "lib.jar"));
		assertThat(this.builder.environmentVariables(mapOf("EXTRA_CLASSPATH", "lib.jar")).build())
				.hasFieldOrPropertyWithValue("databaseFactory.environmentVariables",
						mapOf("EXTRA_CLASSPATH", "lib.jar"));
	}

	@Test
	void systemProperties() {
		ClassPathResource resource = new ClassPathResource("test.txt");
		assertThat(this.builder.addSystemProperty("cassandra.rpc_port", 9160).build())
				.hasFieldOrPropertyWithValue("databaseFactory.systemProperties", mapOf("cassandra.rpc_port", 9160));
		assertThat(this.builder.addSystemProperties(mapOf("cassandra.config", resource)).build())
				.hasFieldOrPropertyWithValue("databaseFactory.systemProperties",
						mapOf("cassandra.rpc_port", 9160, "cassandra.config", resource));
		assertThat(this.builder.systemProperties(mapOf("cassandra.config", resource))
				.build()).hasFieldOrPropertyWithValue("databaseFactory.systemProperties",
				mapOf("cassandra.config", resource));
	}

	@Test
	void configurationFile() {
		ClassPathResource resource = new ClassPathResource("test.txt");
		assertThat(this.builder.configFile(resource).build())
				.hasFieldOrPropertyWithValue("databaseFactory.systemProperties",
						mapOf("cassandra.config", resource));
	}

	@Test
	void jvmOptions() {
		assertThat(this.builder.jvmOptions("-Xmx512m").build())
				.hasFieldOrPropertyWithValue("databaseFactory.jvmOptions",
						Collections.singleton("-Xmx512m"));

		assertThat(this.builder.addJvmOptions("-Xmx1024m").build())
				.hasFieldOrPropertyWithValue("databaseFactory.jvmOptions",
						new LinkedHashSet<>(Arrays.asList("-Xmx512m", "-Xmx1024m")));

		assertThat(this.builder.jvmOptions("-Xmx1024m").build())
				.hasFieldOrPropertyWithValue("databaseFactory.jvmOptions",
						Collections.singleton("-Xmx1024m"));
	}

	@Test
	void configProperties() {
		assertThat(this.builder.addConfigProperty("rpc_port", 9160).build())
				.hasFieldOrPropertyWithValue("databaseFactory.configProperties", mapOf("rpc_port", 9160));
		assertThat(this.builder
				.addConfigProperties(mapOf("start_rpc", true)).build())
				.hasFieldOrPropertyWithValue("databaseFactory.configProperties",
						mapOf("rpc_port", 9160, "start_rpc", true));
		assertThat(this.builder.configProperties(mapOf("start_rpc", true)).build())
				.hasFieldOrPropertyWithValue("databaseFactory.configProperties", mapOf("start_rpc", true));
	}

	@Test
	void configPropertiesArrayType() {
		assertThat(this.builder.addConfigProperty("data_file_directories", new String[]{"./data/data"}).build())
				.hasFieldOrPropertyWithValue("databaseFactory.configProperties", mapOf("data_file_directories",
						Collections.singletonList("./data/data")));
	}

	@Test
	void configure() {
		this.builder.configure(builder -> builder.name("super"));
		assertThat(this.builder.build()).hasFieldOrPropertyWithValue("name", "super");
	}

	private static <K, V> Map<K, V> mapOf(K k1, V v1) {
		Map<K, V> map = new LinkedHashMap<>();
		map.put(k1, v1);
		return map;
	}

	private static <K, V> Map<K, V> mapOf(K k1, V v1, K k2, V v2) {
		Map<K, V> map = new LinkedHashMap<>();
		map.put(k1, v1);
		map.put(k2, v2);
		return map;
	}

}
```


Overlapping Code:
```
class CassandraBuilderTests {
private final CassandraBuilder builder = new CassandraBuilder();
@Test
void invalidName() {
assertThatThrownBy(() -> this.builder.name("")).hasStackTraceContaining("Name must not be empty");
}
@Test
void generatedName() {
Cassandra c1 = this.builder.build();
Cassandra c2 = this.builder.build();
assertThat(c1.getName()).isNotEqualTo(c2.getName());
}
@Test
void name() {
CassandraBuilder cassandra = this.builder.name("cassandra");
assertThat(cassandra).hasFieldOrPropertyWithValue("name", "cassandra");
assertThat(this.builder.getName()).isEqualTo("cassandra");
}
@Test
void version() {
assertThat(this.builder.getVersion()).isEqualTo(CassandraBuilder.DEFAULT_VERSION);
Cassandra cassandra = this.builder.version("3.11.11").build();
assertThat(cassandra).hasFieldOrPropertyWithValue("version", Version.parse("3.11.11"));
assertThat(this.builder.getVersion()).isEqualTo(Version.parse("3.11.11"));
}
@Test
void registerShutdownHook() {
Cassandra cassandra = this.builder.registerShutdownHook(false).build();
assertThat(cassandra).hasFieldOrPropertyWithValue("registerShutdownHook", false);
}
@Test
void startupTimeout() {
Cassandra cassandra = this.builder.startupTimeout(Duration.ofMinutes(1)).build();
assertThat(cassandra).hasFieldOrPropertyWithValue("startupTimeout", Duration.ofMinutes(1));
}
@Test
void startupNegative() {
assertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))
.hasStackTraceContaining("Startup Timeout must be positive");
}
@Test
void startupZero() {
assertThatThrownBy(() -> this.builder.startupTimeout(Duration.ofMinutes(-1)))
.hasStackTraceContaining("Startup Timeout must be positive");
}
@Test
void workingDirectory(@TempDir Path workingDirectory) {
Cassandra cassandra = this.builder.workingDirectory(() -> workingDirectory).build();
assertThat(cassandra).hasFieldOrPropertyWithValue("workingDirectory", workingDirectory);
}
@Test
void invalidWorkingDirectory() {
assertThatThrownBy(() -> this.builder.workingDirectory(() -> {
throw new IOException("");
}).build()).hasStackTraceContaining("Unable to get a working directory");
}
@Test
void workingDirectoryInitializer() {
WorkingDirectoryInitializer workingDirectoryInitializer = (workingDirectory, version) -> {
};
Cassandra cassandra = this.builder.workingDirectoryInitializer(workingDirectoryInitializer).build();

```
<Overlap Ratio: 0.9820309235269536>

---

--- 254 --
Question ID: 5448b36f1896fae88ad9b02d8f921742d72bfc10_0
Original Code:
```
public class S1656DesignOrderedStream {
    class OrderedStream {
        String[] data;
        int current;

        public OrderedStream(int n) {
            data = new String[n+1];
            current = 1;
        }

        public List<String> insert(int idKey, String value) {
            data[idKey] = value;
            List<String> res = new ArrayList<>();
            int i = current;
            while (i < data.length && data[i] != null) {
                res.add(data[i]);
                i++;
            }
            current = i;
            return res;
        }
    }
}
```


Overlapping Code:
```
eredStream {
String[] data;
int current;
public OrderedStream(int n) {
data = new String[n+1];
current = 1;
}
public List<String> insert(int idKey, String value) {
data[idKey] = value;
List<String> res = new ArrayList<>();
int i = current;
while (i < data.length && data[i] != null) {
res.add(data[i]
```
<Overlap Ratio: 0.7712082262210797>

---

--- 255 --
Question ID: 983d088e30084240dbad481c840047566b62037b_0
Original Code:
```
public class ANFTransformTests extends TestCase{

	@Test
	public void testgetPrimOrObj() {
		assertEquals("[I, D, I]", ""+ANFTransform.getPrimOrObj("(IDI)V"));
		assertEquals("[I, D, I, L, D]", ""+ANFTransform.getPrimOrObj("(IDILString;D)V"));
		assertEquals("[I, I, D, L, L, L, D, D]", ""+ANFTransform.getPrimOrObj("(IIDLString;[D[LString;DD)LString;"));
		assertEquals("[L, L, L, D, D]", ""+ANFTransform.getPrimOrObj("(LD;LD;LD;DD)"));//a class called D?
		//ANFTransform.getPrimOrObj("([I[I[Ljava/lang/String;)I");
	}
}
```


Overlapping Code:
```
nds TestCase{
@Test
public void testgetPrimOrObj() {
assertEquals("[I, D, I]", ""+ANFTransform.getPrimOrObj("(IDI)V"));
assertEquals("[I, D, I, L, D]", ""+ANFTransform.getPrimOrObj("(IDILString;D)V"));
assertEquals("[I, I, D, L, L, L, D, D]", ""+ANFTransform.getPrimOrObj("(IIDLString;[D[LString;DD)LString;"));
assertEquals("[L, L, L, D, D]", ""+ANFTransform.getPrimOrObj("(LD;LD;LD;DD)"));//a class called D?
//ANFTransform.getPrimOrObj("([I[I[Ljava/lang/String;)I"
```
<Overlap Ratio: 0.9192913385826772>

---

--- 256 --
Question ID: 810eefc5dfc6c24d0d668b4652bd64d9a534bf0d_0
Original Code:
```
@EnabledIfSystemProperty(named = "accountName", matches = ".*",
                         disabledReason = "Make sure to supply azure accessKey or accountName, e.g:  mvn verify -DaccountName=myacc -DaccessKey=mykey")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class QueueOperationsIT extends CamelTestSupport {

    private QueueConfiguration configuration;
    private QueueServiceClientWrapper serviceClientWrapper;

    @BeforeAll
    public void setup() throws Exception {
        final Properties properties = QueueTestUtils.loadAzureAccessFromJvmEnv();

        configuration = new QueueConfiguration();
        configuration.setAccountName(properties.getProperty("account_name"));
        configuration.setAccessKey(properties.getProperty("access_key"));
        configuration.setMaxMessages(5);

        final QueueServiceClient client = QueueClientFactory.createQueueServiceClient(configuration);

        serviceClientWrapper = new QueueServiceClientWrapper(client);
    }

    @Test
    public void testCreateDeleteQueue() {
        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();
        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);
        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);

        // test create queue
        final QueueOperationResponse response = operations.createQueue(null);

        assertNotNull(response);
        assertNotNull(response.getHeaders());
        assertTrue((boolean) response.getBody());
        assertTrue(serviceClientWrapper.listQueues(null, null)
                .stream()
                .map(QueueItem::getName)
                .collect(Collectors.toList())
                .contains(queueName));

        // delete and test
        final QueueOperationResponse response2 = operations.deleteQueue(null);
        assertNotNull(response2);
        assertNotNull(response2.getHeaders());
        assertTrue((boolean) response2.getBody());
        assertFalse(serviceClientWrapper.listQueues(null, null)
                .stream()
                .map(QueueItem::getName)
                .collect(Collectors.toList())
                .contains(queueName));
    }

    @Test
    public void testSendMessageAndClearQueue() {
        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();
        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);
        final QueueOperations operations = new QueueOperations(configuration, clientWrapper);

        final Exchange exchange = new DefaultExchange(context);
        exchange.getIn().setBody("testing message");

        final QueueOperationResponse response = operations.sendMessage(exchange);

        assertNotNull(response);
        assertNotNull(response.getHeaders());
        assertTrue((boolean) response.getBody());
        assertNotNull(response.getHeaders().get(QueueConstants.MESSAGE_ID));
        assertNotNull(response.getHeaders().get(QueueConstants.EXPIRATION_TIME));
        assertNotNull(response.getHeaders().get(QueueConstants.POP_RECEIPT));

        final QueueMessageItem messageItem
                = clientWrapper.receiveMessages(1, Duration.ofSeconds(30), null).stream().findFirst().get();

        assertEquals("testing message", messageItem.getBody().toString());

        // test clear queue
        operations.clearQueue(exchange);

        assertTrue(clientWrapper.receiveMessages(1, null, null).isEmpty());

        // delete testing queue
        operations.deleteQueue(exchange);
    }

    @Test
    @SuppressWarnings("unchecked")
    public void testReceiveAndPeekMessages() {
        final QueueOperations operations = getQueueOperations();

        final Exchange exchange = new DefaultExchange(context);
        exchange.getIn().setBody("testing message-1");
        operations.sendMessage(exchange);

        exchange.getIn().setBody("testing message-2");
        operations.sendMessage(exchange);

        exchange.getIn().setBody("testing message-3");
        operations.sendMessage(exchange);

        // test peek messages
        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);
        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();

        assertEquals(3, peekedMessageItems.size());
        assertEquals("testing message-1", peekedMessageItems.get(0).getBody().toString());
        assertEquals("testing message-2", peekedMessageItems.get(1).getBody().toString());
        assertEquals("testing message-3", peekedMessageItems.get(2).getBody().toString());

        // test receive message
        exchange.getIn().setHeader(QueueConstants.MAX_MESSAGES, 1);
        final QueueOperationResponse receiveResponse = operations.receiveMessages(exchange);
        final List<QueueMessageItem> receivedMessageItems = (List<QueueMessageItem>) receiveResponse.getBody();

        assertEquals(1, receivedMessageItems.size());
        assertEquals("testing message-1", receivedMessageItems.get(0).getBody().toString());

        // make sure the message has been deQueued
        assertEquals(2, ((List<PeekedMessageItem>) operations.peekMessages(null).getBody()).size());

        // delete testing queue
        operations.deleteQueue(exchange);
    }

    @Test
    public void testDeleteMessages() {
        final QueueOperations operations = getQueueOperations();

        final Exchange exchange = new DefaultExchange(context);
        exchange.getIn().setBody("testing message-1");
        final QueueOperationResponse sentMessage1 = operations.sendMessage(exchange);

        exchange.getIn().setBody("testing message-2");
        final QueueOperationResponse sentMessage2 = operations.sendMessage(exchange);

        // test delete message
        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));
        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage1.getHeaders().get(QueueConstants.MESSAGE_ID));
        // we still need pop receipt
        assertThrows(IllegalArgumentException.class, () -> operations.deleteMessage(exchange));
        // delete message now
        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage1.getHeaders().get(QueueConstants.POP_RECEIPT));
        operations.deleteMessage(exchange);

        // check the what we have in the queue
        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);
        @SuppressWarnings("unchecked")
        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();

        assertEquals(1, peekedMessageItems.size());
        assertEquals(sentMessage2.getHeaders().get(QueueConstants.MESSAGE_ID), peekedMessageItems.get(0).getMessageId());

        // delete testing queue
        operations.deleteQueue(exchange);
    }

    @Test
    public void testUpdateMessage() {
        final QueueOperations operations = getQueueOperations();

        final Exchange exchange = new DefaultExchange(context);
        exchange.getIn().setBody("testing message-1");
        final QueueOperationResponse sentMessage = operations.sendMessage(exchange);

        // let's do our update
        exchange.getIn().setBody("updated message-1");
        exchange.getIn().setHeader(QueueConstants.POP_RECEIPT, sentMessage.getHeaders().get(QueueConstants.POP_RECEIPT));
        exchange.getIn().setHeader(QueueConstants.MESSAGE_ID, sentMessage.getHeaders().get(QueueConstants.MESSAGE_ID));
        exchange.getIn().setHeader(QueueConstants.VISIBILITY_TIMEOUT, Duration.ofMillis(10));

        final QueueOperationResponse updatedMessage = operations.updateMessage(exchange);

        assertNotNull(updatedMessage);
        assertNotNull(updatedMessage.getHeaders());
        assertTrue((boolean) updatedMessage.getBody());
        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.POP_RECEIPT));
        assertNotNull(updatedMessage.getHeaders().get(QueueConstants.TIME_NEXT_VISIBLE));

        // check the what we have in the queue
        final QueueOperationResponse peekResponse = operations.peekMessages(exchange);
        @SuppressWarnings("unchecked")
        final List<PeekedMessageItem> peekedMessageItems = (List<PeekedMessageItem>) peekResponse.getBody();

        assertEquals(1, peekedMessageItems.size());
        assertEquals("updated message-1", peekedMessageItems.get(0).getBody().toString());

        // delete testing queue
        operations.deleteQueue(exchange);
    }

    @AfterAll
    public void tearDown() {
        // make sure to clean everything
        final List<QueueItem> queues = serviceClientWrapper.listQueues(null, null);

        if (queues.size() > 0) {
            queues.forEach(queueItem -> serviceClientWrapper.getQueueClientWrapper(queueItem.getName()).delete(null));
        }
    }

    private QueueOperations getQueueOperations() {
        final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();
        final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);
        return new QueueOperations(configuration, clientWrapper);
    }
}
```


Overlapping Code:
```
mProperty(named = "accountName", matches = ".*",
disabledReason = "Make sure to supply azure accessKey or accountName, e.g: mvn verify -DaccountName=myacc -DaccessKey=mykey")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class QueueOperationsIT extends CamelTestSupport {
private QueueConfiguration configuration;
private QueueServiceClientWrapper serviceClientWrapper;
@BeforeAll
public void setup() throws Exception {
final Properties properties = QueueTestUtils.loadAzureAccessFromJvmEnv();
configuration = new QueueConfiguration();
configuration.setAccountName(properties.getProperty("account_name"));
configuration.setAccessKey(properties.getProperty("access_key"));
configuration.setMaxMessages(5);
final QueueServiceClient client = QueueClientFactory.createQueueServiceClient(configuration);
serviceClientWrapper = new QueueServiceClientWrapper(client);
}
@Test
public void testCreateDeleteQueue() {
final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();
final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(queueName);
final QueueOperations operations = new QueueOperations(configuration, clientWrapper);
// test create queue
final QueueOperationResponse response = operations.createQueue(null);
assertNotNull(response);
assertNotNull(response.getHeaders());
assertTrue((boolean) response.getBody());
assertTrue(serviceClientWrapper.listQueues(null, null)
.stream()
.map(QueueItem::getName)
.collect(Collectors.toList())
.contains(queueName));
// delete and test
final QueueOperationResponse response2 = operations.deleteQueue(null);
assertNotNull(response2);
assertNotNull(response2.getHeaders());
assertTrue((boolean) response2.getBody());
assertFalse(serviceClientWrapper.listQueues(null, null)
.stream()
.map(QueueItem::getName)
.collect(Collectors.toList())
.contains(queueName));
}
@Test
public void testSendMessageAndClearQueue() {
final String queueName = RandomStringUtils.randomAlphabetic(10).toLowerCase();
final QueueClientWrapper clientWrapper = serviceClientWrapper.getQueueClientWrapper(
```
<Overlap Ratio: 0.9866348448687351>

---

--- 257 --
Question ID: de9ea4d9a00e1739e43cde4f77164ce2cd2a48c6_0
Original Code:
```
@Service
@Named("isis.runtimeservices.InteractionServiceDefault")
@Priority(PriorityPrecedence.MIDPOINT)
@Qualifier("Default")
@Log4j2
public class InteractionServiceDefault
implements
    InteractionService,
    InteractionLayerTracker {

    @Inject AuthenticationManager authenticationManager;
    @Inject MetamodelEventService runtimeEventService;
    @Inject SpecificationLoader specificationLoader;
    @Inject ServiceInjector serviceInjector;

    @Inject InteractionAwareTransactionalBoundaryHandler txBoundaryHandler;
    @Inject ClockService clockService;
    @Inject CommandPublisher commandPublisher;
    @Inject List<TransactionBoundaryAware> transactionBoundaryAwareBeans;
    @Inject ConfigurableBeanFactory beanFactory;

    private InteractionScopeLifecycleHandler interactionScopeLifecycleHandler;

    public InteractionServiceDefault() {
    }

    @PostConstruct
    public void initIsisInteractionScopeSupport() {
        this.interactionScopeLifecycleHandler = InteractionScopeBeanFactoryPostProcessor.lookupScope(beanFactory);
    }

    //@PostConstruct .. too early, needs services to be provisioned first
    @EventListener
    public void init(final ContextRefreshedEvent event) {

        requires(authenticationManager, "authenticationManager");

        log.info("Initialising Isis System");
        log.info("working directory: {}", new File(".").getAbsolutePath());

        runtimeEventService.fireBeforeMetamodelLoading();

        val taskList = _ConcurrentTaskList.named("IsisInteractionFactoryDefault Init")
                .addRunnable("SpecificationLoader::createMetaModel", specificationLoader::createMetaModel)
                .addRunnable("ChangesDtoUtils::init", ChangesDtoUtils::init)
                .addRunnable("InteractionDtoUtils::init", InteractionDtoUtils::init)
                .addRunnable("CommandDtoUtils::init", CommandDtoUtils::init)
                ;

        taskList.submit(_ConcurrentContext.forkJoin());
        taskList.await();

        { // log any validation failures, experimental code however, not sure how to best propagate failures
            val validationResult = specificationLoader.getOrAssessValidationResult();
            if(validationResult.getNumberOfFailures()==0) {
                log.info("Validation PASSED");
            } else {
                log.error("### Validation FAILED, failure count: {}", validationResult.getNumberOfFailures());
                validationResult.forEach(failure->{
                    log.error("# " + failure.getMessage());
                });
                //throw _Exceptions.unrecoverable("Validation FAILED");
            }
        }

        runtimeEventService.fireAfterMetamodelLoaded();

    }

    private final ThreadLocal<Stack<InteractionLayer>> interactionLayerStack =
            ThreadLocal.withInitial(Stack::new);

    @Override
    public int getInteractionLayerCount() {
        return interactionLayerStack.get().size();
    }

    @Override
    public InteractionLayer openInteraction() {
        return currentInteractionLayer()
                // or else create an anonymous authentication layer
                .orElseGet(()->openInteraction(InteractionContextFactory.anonymous()));
    }

    @Override
    public InteractionLayer openInteraction(
            final @NonNull InteractionContext interactionContextToUse) {

        val isisInteraction = getOrCreateIsisInteraction();

        // check whether we should reuse any current authenticationLayer,
        // that is, if current authentication and authToUse are equal

        val reuseCurrentLayer = currentInteractionContext()
                .map(currentInteractionContext -> Objects.equals(currentInteractionContext, interactionContextToUse))
                .orElse(false);

        if(reuseCurrentLayer) {
            // we are done, just return the stack's top
            return interactionLayerStack.get().peek();
        }

        val interactionLayer = new InteractionLayer(isisInteraction, interactionContextToUse);

        interactionLayerStack.get().push(interactionLayer);

        if(isAtTopLevel()) {
        	postInteractionOpened(isisInteraction);
        }

        if(log.isDebugEnabled()) {
            log.debug("new interaction layer created (conversation-id={}, total-layers-on-stack={}, {})",
                    interactionId.get(),
                    interactionLayerStack.get().size(),
                    _Probe.currentThreadId());
        }

        if(XrayUi.isXrayEnabled()) {
            _Xray.newInteractionLayer(interactionLayerStack.get());
        }

        return interactionLayer;
    }

    private IsisInteraction getOrCreateIsisInteraction() {

        final Stack<InteractionLayer> interactionLayers = interactionLayerStack.get();
        return interactionLayers.isEmpty()
    			? new IsisInteraction(UUID.randomUUID())
				: _Casts.uncheckedCast(interactionLayers.firstElement().getInteraction());
    }

    @Override
    public void closeInteractionLayers() {
        log.debug("about to close the interaction stack (conversation-id={}, total-layers-on-stack={}, {})",
                interactionId.get(),
                interactionLayerStack.get().size(),
                _Probe.currentThreadId());

        closeInteractionLayerStackDownToStackSize(0);
    }

	@Override
    public Optional<InteractionLayer> currentInteractionLayer() {
    	val stack = interactionLayerStack.get();
    	return stack.isEmpty()
    	        ? Optional.empty()
                : Optional.of(stack.lastElement());
    }

    @Override
    public boolean isInInteraction() {
        return !interactionLayerStack.get().isEmpty();
    }

    // -- AUTHENTICATED EXECUTION

    @Override
    @SneakyThrows
    public <R> R call(
            final @NonNull InteractionContext interactionContext,
            final @NonNull Callable<R> callable) {

        final int stackSizeWhenEntering = interactionLayerStack.get().size();
        openInteraction(interactionContext);

        try {
            serviceInjector.injectServicesInto(callable);
            return callable.call();
        } finally {
            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);
        }
    }

    @Override
    @SneakyThrows
    public void run(
            final @NonNull InteractionContext interactionContext,
            final @NonNull ThrowingRunnable runnable) {

        final int stackSizeWhenEntering = interactionLayerStack.get().size();
        openInteraction(interactionContext);

        try {
            serviceInjector.injectServicesInto(runnable);
            runnable.run();
        } finally {
            closeInteractionLayerStackDownToStackSize(stackSizeWhenEntering);
        }

    }

    // -- ANONYMOUS EXECUTION

    @Override
    @SneakyThrows
    public <R> R callAnonymous(@NonNull final Callable<R> callable) {
        if(isInInteraction()) {
            serviceInjector.injectServicesInto(callable);
            return callable.call(); // reuse existing session
        }
        return call(InteractionContextFactory.anonymous(), callable);
    }

    /**
     * Variant of {@link #callAnonymous(Callable)} that takes a runnable.
     * @param runnable
     */
    @Override
    @SneakyThrows
    public void runAnonymous(@NonNull final ThrowingRunnable runnable) {
        if(isInInteraction()) {
            serviceInjector.injectServicesInto(runnable);
            runnable.run(); // reuse existing session
            return;
        }
        run(InteractionContextFactory.anonymous(), runnable);
    }

    // -- CONVERSATION ID

    private final ThreadLocal<UUID> interactionId = ThreadLocal.withInitial(()->null);

    @Override
    public Optional<UUID> getInteractionId() {
        return Optional.ofNullable(interactionId.get());
    }

    // -- HELPER

    private boolean isAtTopLevel() {
    	return interactionLayerStack.get().size()==1;
    }

    private void postInteractionOpened(final IsisInteraction interaction) {
        interactionId.set(interaction.getInteractionId());
        transactionBoundaryAwareBeans.forEach(bean->bean.beforeEnteringTransactionalBoundary(interaction));
        txBoundaryHandler.onOpen(interaction);
        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();
        transactionBoundaryAwareBeans.forEach(bean->bean.afterEnteringTransactionalBoundary(interaction, isSynchronizationActive));
        interactionScopeLifecycleHandler.onTopLevelInteractionOpened();
    }

    private void preInteractionClosed(final IsisInteraction interaction) {
        completeAndPublishCurrentCommand();
        val isSynchronizationActive = TransactionSynchronizationManager.isSynchronizationActive();
        transactionBoundaryAwareBeans.forEach(bean->bean.beforeLeavingTransactionalBoundary(interaction, isSynchronizationActive));
        txBoundaryHandler.onClose(interaction);
        transactionBoundaryAwareBeans.forEach(bean->bean.afterLeavingTransactionalBoundary(interaction));
        interactionScopeLifecycleHandler.onTopLevelInteractionPreDestroy(); // cleanup the InteractionScope (Spring scope)
        interactionScopeLifecycleHandler.onTopLevelInteractionClosed(); // cleanup the InteractionScope (Spring scope)
        interaction.close(); // do this last
    }

    private void closeInteractionLayerStackDownToStackSize(final int downToStackSize) {

        log.debug("about to close authenication stack down to size {} (conversation-id={}, total-sessions-on-stack={}, {})",
                downToStackSize,
                interactionId.get(),
                interactionLayerStack.get().size(),
                _Probe.currentThreadId());

        val stack = interactionLayerStack.get();
        while(stack.size()>downToStackSize) {
        	if(isAtTopLevel()) {
        		// keep the stack unmodified yet, to allow for callbacks to properly operate
        		preInteractionClosed(_Casts.uncheckedCast(stack.peek().getInteraction()));
        	}
        	_Xray.closeInteractionLayer(stack);
            stack.pop();
        }
        if(downToStackSize == 0) {
            // cleanup thread-local
            interactionLayerStack.remove();
            interactionId.remove();
        }
    }

    private IsisInteraction getInternalInteractionElseFail() {
        val interaction = currentInteractionElseFail();
        if(interaction instanceof IsisInteraction) {
            return (IsisInteraction) interaction;
        }
        throw _Exceptions.unrecoverableFormatted("the framework does not recognice "
                + "this implementation of an Interaction: %s", interaction.getClass().getName());
    }

    // -- HELPER - COMMAND COMPLETION

    private void completeAndPublishCurrentCommand() {

        val interaction = getInternalInteractionElseFail();
        val command = interaction.getCommand();

        if(command.getStartedAt() != null && command.getCompletedAt() == null) {
            // the guard is in case we're here as the result of a redirect following a previous exception;just ignore.

            val priorInteractionExecution = interaction.getPriorExecution();
            final Timestamp completedAt =
                    priorInteractionExecution != null
                    ?
                        // copy over from the most recent (which will be the top-level) interaction
                        priorInteractionExecution.getCompletedAt()
                    :
                        // this could arise as the result of calling SessionManagementService#nextSession within an action
                        // the best we can do is to use the current time

                        // REVIEW: as for the interaction object, it is left somewhat high-n-dry.
                         clockService.getClock().nowAsJavaSqlTimestamp();

            command.updater().setCompletedAt(completedAt);
        }

        commandPublisher.complete(command);

        interaction.clear();
    }

}
```


Overlapping Code:
```
sis.runtimeservices.InteractionServiceDefault")
@Priority(PriorityPrecedence.MIDPOINT)
@Qualifier("Default")
@Log4j2
public class InteractionServiceDefault
implements
InteractionService,
InteractionLayerTracker {
@Inject AuthenticationManager authenticationManager;
@Inject MetamodelEventService runtimeEventService;
@Inject SpecificationLoader specificationLoader;
@Inject ServiceInjector serviceInjector;
@Inject InteractionAwareTransactionalBoundaryHandler txBoundaryHandler;
@Inject ClockService clockService;
@Inject CommandPublisher commandPublisher;
@Inject List<TransactionBoundaryAware> transactionBoundaryAwareBeans;
@Inject ConfigurableBeanFactory beanFactory;
private InteractionScopeLifecycleHandler interactionScopeLifecycleHandler;
public InteractionServiceDefault() {
}
@PostConstruct
public void initIsisInteractionScopeSupport() {
this.interactionScopeLifecycleHandler = InteractionScopeBeanFactoryPostProcessor.lookupScope(beanFactory);
}
//@PostConstruct .. too early, needs services to be provisioned first
@EventListener
public void init(final ContextRefreshedEvent event) {
requires(authenticationManager, "authenticationManager");
log.info("Initialising Isis System");
log.info("working directory: {}", new File(".").getAbsolutePath());
runtimeEventService.fireBeforeMetamodelLoading();
val taskList = _ConcurrentTaskList.named("IsisInteractionFactoryDefault Init")
.addRunnable("SpecificationLoader::createMetaModel", specificationLoader::createMetaModel)
.addRunnable("ChangesDtoUtils::init", ChangesDtoUtils::init)
.addRunnable("InteractionDtoUtils::init", InteractionDtoUtils::init)
.addRunnable("CommandDtoUtils::init", CommandDtoUtils::init)
;
taskList.submit(_ConcurrentContext.forkJoin());
taskList.await();
{ // log any validation failures, experimental code however, not sure how to best propagate failures
val validationResult = specificationLoader.getOrAssessValidationResult();
if(validationResult.getNumberOfFailures()==0) {
log.info("Validation PASSED");
} else {
log.error("### Validation FAILED, failure count: {}", validationResult.getNumberOfFailures());
validationResult.forEach(failure->
```
<Overlap Ratio: 0.9911668991166899>

---

--- 258 --
Question ID: 148ead072a61a8c02f9891a8b10c2aad0f63b751_0
Original Code:
```
@Service
@Transactional
public class GroupEmailTemplateServiceImpl extends
		BaseJpaServiceImpl<GroupEmailTemplate, Long> implements
		GroupEmailTemplateService {

	private @Autowired GroupEmailTemplateRepository groupEmailTemplateRepository;

	@PostConstruct
	public void setupService() {
		this.baseJpaRepository = groupEmailTemplateRepository;
		this.entityClass = GroupEmailTemplate.class;
		this.baseJpaRepository.setupEntityClass(GroupEmailTemplate.class);

	}

	public GroupEmailTemplate findbyTemplateName(String templateName) {
		return groupEmailTemplateRepository.findbyTemplateName(templateName);
	}

	public List<GroupEmailTemplate> findbyGroupCode(String groupCode) {

		return groupEmailTemplateRepository.findbyGroupCode(groupCode);
	}

	public List<GroupEmailTemplate> findbyGroupCodeAndGroupEventCode(
			String groupCode, String groupEventCode) {
		return groupEmailTemplateRepository.findbyGroupCodeAndGroupEventCode(
				groupCode, groupEventCode);
	}

}
```


Overlapping Code:
```
nal
public class GroupEmailTemplateServiceImpl extends
BaseJpaServiceImpl<GroupEmailTemplate, Long> implements
GroupEmailTemplateService {
private @Autowired GroupEmailTemplateRepository groupEmailTemplateRepository;
@PostConstruct
public void setupService() {
this.baseJpaRepository = groupEmailTemplateRepository;
this.entityClass = GroupEmailTemplate.class;
this.baseJpaRepository.setupEntityClass(GroupEmailTemplate.class);
}
public GroupEmailTemplate findbyTemplateName(String templateName) {
return groupEmailTemplateRepository.findbyTemplateName(templateName);
}
public List<GroupEmailTemplate> findbyGroupCode(String groupCode) {
return groupEmailTemplateRepository.findbyGroupCode(groupCode);
}
public List<GroupEmailTemplate> findbyGroupCodeAndGroupEventCode(
String groupCode, String groupEventCode) {
return groupEmailTemplateRepository.findbyGroupCodeAndGroupEventCode(
groupCode, groupEvent
```
<Overlap Ratio: 0.9678800856531049>

---

--- 259 --
Question ID: 8fe234960f05cc9705af00e1e9e5d2b0274e7a2c_0
Original Code:
```
@Service
public class GeocoderService {
    private static final String KEY = "AIzaSyDw_d6dfxDEI7MAvqfGXEIsEMwjC1PWRno";

    private final WebClient client;

    public GeocoderService(WebClient.Builder builder) {
        client = builder.baseUrl("https://maps.googleapis.com")
                .build();
    }

    public Castle fillInLatLng(Castle castle) {
        String encoded = Stream.of(castle.getCity(), castle.getState())
                .map(s -> URLEncoder.encode(s, StandardCharsets.UTF_8))
                .collect(Collectors.joining(","));
        Response response = client.get()
                .uri((uriBuilder -> uriBuilder.path("/maps/api/geocode/json")
                        .queryParam("address", encoded)
                        .queryParam("key", KEY)
                        .build()
                ))
                .retrieve()
                .bodyToMono(Response.class)
                .block(Duration.ofSeconds(2L));
        if (response != null) {
            castle.setLatitude(response.getLocation().getLat());
            castle.setLongitude(response.getLocation().getLng());
        }
        return castle;
    }
}
```


Overlapping Code:
```
rvice
public class GeocoderService {
private statient client;
public GeocoderService(WebClient.Builder builder) {
client = builder.baseUrl("https://maps.googleapis.com")
.build();
}
public Castle fillInLatLng(Castle castle) {
String encoded = Stream.of(castle.getCity(), castle.getState())
.map(s -> URLEncoder.encode(s, StandardCharsets.UTF_8))
.collect(Collectors.joining(","));
Response response = client.get()
.uri((uriBuilder -> uriBuilder.path("/maps/api/geocode/json")
.queryParam("address", encoded)
.queryParam("key", KEY)
.build()
))
.retrieve()
.bodyToMono(Response.class)
.block(Duration.ofSeconds(2L));
if (response != null) {
castle.setLatitude(response.getLocation().getLat());
castle.setLongitude(response.getLocation().getLng());
}
r
```
<Overlap Ratio: 0.8782201405152225>

---

--- 260 --
Question ID: 8253a791e88172fbfca883a7bf801c25f6ddac85_0
Original Code:
```
public class TextComponentCaretModel implements CaretModel {
  private final JTextComponent myTextComponent;
  private final TextComponentEditor myEditor;
  private final Caret myCaret;
  private final EventDispatcher<CaretActionListener> myCaretActionListeners = EventDispatcher.create(CaretActionListener.class);

  public TextComponentCaretModel(@Nonnull JTextComponent textComponent, @Nonnull TextComponentEditor editor) {
    myTextComponent = textComponent;
    myEditor = editor;
    myCaret = new TextComponentCaret(editor);
  }

  @Override
  public void moveCaretRelatively(final int columnShift, final int lineShift, final boolean withSelection, final boolean blockSelection, final boolean scrollToCaret) {
    if (lineShift == 0 && !withSelection && !blockSelection && !scrollToCaret) {
      moveToOffset(getOffset() + columnShift);
      return;
    }
    throw new UnsupportedOperationException("Not implemented");
  }

  @Override
  public void moveToLogicalPosition(@Nonnull final LogicalPosition pos) {
    moveToOffset(myEditor.logicalPositionToOffset(pos), false);
  }

  @Override
  public void moveToVisualPosition(@Nonnull final VisualPosition pos) {
    moveToLogicalPosition(myEditor.visualToLogicalPosition(pos));
  }

  @Override
  public void moveToOffset(int offset) {
    moveToOffset(offset, false);
  }

  @Override
  public void moveToOffset(final int offset, boolean locateBeforeSoftWrap) {
    int targetOffset = Math.min(offset, myTextComponent.getText().length());
    int currentPosition = myTextComponent.getCaretPosition();
    // We try to preserve selection, to match EditorImpl behaviour.
    // It's only possible though, if target offset is located at either end of existing selection.
    if (targetOffset != currentPosition) {
      if (targetOffset == myTextComponent.getCaret().getMark()) {
        myTextComponent.setCaretPosition(currentPosition);
        myTextComponent.moveCaretPosition(targetOffset);
      }
      else {
        myTextComponent.setCaretPosition(targetOffset);
      }
    }
  }

  @Override
  public boolean isUpToDate() {
    return true;
  }

  @Override
  @Nonnull
  public LogicalPosition getLogicalPosition() {
    int caretPos = myTextComponent.getCaretPosition();
    int line;
    int lineStart;
    if (myTextComponent instanceof JTextArea) {
      final JTextArea textArea = (JTextArea)myTextComponent;
      try {
        line = textArea.getLineOfOffset(caretPos);
        lineStart = textArea.getLineStartOffset(line);
      }
      catch (BadLocationException e) {
        throw new RuntimeException(e);
      }
    }
    else {
      line = 0;
      lineStart = 0;
    }
    return new LogicalPosition(line, caretPos - lineStart);
  }

  @Override
  @Nonnull
  public VisualPosition getVisualPosition() {
    LogicalPosition pos = getLogicalPosition();
    return new VisualPosition(pos.line, pos.column);
  }

  @Override
  public int getOffset() {
    return myTextComponent.getCaretPosition();
  }

  @Override
  public void addCaretListener(@Nonnull final CaretListener listener) {
    throw new UnsupportedOperationException("Not implemented");
  }

  @Override
  public void removeCaretListener(@Nonnull final CaretListener listener) {
    throw new UnsupportedOperationException("Not implemented");
  }

  @Override
  public int getVisualLineStart() {
    return 0;
  }

  @Override
  public int getVisualLineEnd() {
    return 0;
  }

  @Override
  public TextAttributes getTextAttributes() {
    return null;
  }

  @Override
  public boolean supportsMultipleCarets() {
    return false;
  }

  @Nonnull
  @Override
  public Caret getCurrentCaret() {
    return myCaret;
  }

  @Nonnull
  @Override
  public Caret getPrimaryCaret() {
    return myCaret;
  }

  @Override
  public int getCaretCount() {
    return 1;
  }

  @Nonnull
  @Override
  public List<Caret> getAllCarets() {
    return Collections.singletonList(myCaret);
  }

  @Nullable
  @Override
  public Caret getCaretAt(@Nonnull VisualPosition pos) {
    return myCaret.getVisualPosition().equals(pos) ? myCaret : null;
  }

  @Nullable
  @Override
  public Caret addCaret(@Nonnull VisualPosition pos) {
    return null;
  }

  @Nullable
  @Override
  public Caret addCaret(@Nonnull VisualPosition pos, boolean makePrimary) {
    return null;
  }

  @Override
  public boolean removeCaret(@Nonnull Caret caret) {
    return false;
  }

  @Override
  public void removeSecondaryCarets() {
  }

  @Override
  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates) {
    if (caretStates.size() != 1) throw new IllegalArgumentException("Exactly one CaretState object must be passed");
    CaretState state = caretStates.get(0);
    if (state != null) {
      if (state.getCaretPosition() != null) moveToLogicalPosition(state.getCaretPosition());
      if (state.getSelectionStart() != null && state.getSelectionEnd() != null) {
        myEditor.getSelectionModel().setSelection(myEditor.logicalPositionToOffset(state.getSelectionStart()), myEditor.logicalPositionToOffset(state.getSelectionEnd()));
      }
    }
  }

  @Override
  public void setCaretsAndSelections(@Nonnull List<? extends CaretState> caretStates, boolean updateSystemSelection) {
    setCaretsAndSelections(caretStates);
  }

  @Nonnull
  @Override
  public List<CaretState> getCaretsAndSelections() {
    return Collections.singletonList(new CaretState(getLogicalPosition(), myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionStart()),
                                                    myEditor.offsetToLogicalPosition(myEditor.getSelectionModel().getSelectionEnd())));
  }

  @Override
  public void runForEachCaret(@Nonnull CaretAction action) {
    myCaretActionListeners.getMulticaster().beforeAllCaretsAction();
    action.perform(myCaret);
    myCaretActionListeners.getMulticaster().afterAllCaretsAction();
  }

  @Override
  public void runForEachCaret(@Nonnull CaretAction action, boolean reverseOrder) {
    runForEachCaret(action);
  }

  @Override
  public void addCaretActionListener(@Nonnull CaretActionListener listener, @Nonnull Disposable disposable) {
    myCaretActionListeners.addListener(listener, disposable);
  }

  @Override
  public void runBatchCaretOperation(@Nonnull Runnable runnable) {
    runnable.run();
  }
}
```


Overlapping Code:
```
public class TextComponentCaretModel implements CaretModel {
private final JTextComponent myTextComponent;
private final TextComponentEditor myEditor;
private final Caret myCaret;
private final EventDispatcher<CaretActionListener> myCaretActionListeners = EventDispatcher.create(CaretActionListener.class);
public TextComponentCaretModel(@Nonnull JTextComponent textComponent, @Nonnull TextComponentEditor editor) {
myTextComponent = textComponent;
myEditor = editor;
myCaret = new TextComponentCaret(editor);
}
@Override
public void moveCaretRelatively(final int columnShift, final int lineShift, final boolean withSelection, final boolean blockSelection, final boolean scrollToCaret) {
if (lineShift == 0 && !withSelection && !blockSelection && !scrollToCaret) {
moveToOffset(getOffset() + columnShift);
return;
}
throw new UnsupportedOperationException("Not implemented");
}
@Override
public void moveToLogicalPosition(@Nonnull final LogicalPosition pos) {
moveToOffset(myEditor.logicalPositionToOffset(pos), false);
}
@Override
public void moveToVisualPosition(@Nonnull final VisualPosition pos) {
moveToLogicalPosition(myEditor.visualToLogicalPosition(pos));
}
@Override
public void moveToOffset(int offset) {
moveToOffset(offset, false);
}
@Override
public void moveToOffset(final int offset, boolean locateBeforeSoftWrap) {
int targetOffset = Math.min(offset, myTextComponent.getText().length());
int currentPosition = myTextComponent.getCaretPosition();
// We try to preserve selection, to match EditorImpl behaviour.
// It's only possible though, if target offset is located at either end of existing selection.
if (targetOffset != currentPosition) {
if (targetOffset == myTextComponent.getCaret().getMark()) {
myTextComponent.setCaretPosition(currentPosition);
myTextComponent.moveCaretPosition(targetOffset);
}
else {
myTextComponent.setCaretPosition(targetOffset);
}
}
}
@Override
public boolean isUpToDate() {
return true;
}
@Override
@Nonnull
public LogicalPosition getLogicalPosition() {
int caretPos = myTextComponent.getCaretPosition();
int line;
int lineStart;
if (myTextComponent instanceof JTextArea) {
final JTextArea textArea = (JTextArea)myTextComponent;
try {
line = textArea.getLineOfOffset(caretPos);
lineSt
```
<Overlap Ratio: 0.9841339797267519>

---

--- 261 --
Question ID: ffcbb4fe4625789106460362fa40f62e87e1f2cd_0
Original Code:
```
public class IssuesController extends ModelController<Issue> {

	public IssuesController(Path path) {
		super(path);
	}
	@Override
	protected HtmlView constructModelListView(List<Issue> records,boolean isCompleteList){
		return new ModelListView<Issue>(getPath(), new String[]{"ID","TITLE","PRIORITY","STATUS","ASSIGNED_TO_ID","RESOLUTION","CREATOR_USER_ID"}, records, isCompleteList);
    }
	
	@Override
	protected HtmlView createBlankView(Path path , Issue record, String formAction){
		HtmlView bv = super.createBlankView(path, record,formAction);
		if (bv instanceof AbstractModelView){
			AbstractModelView mev = ((AbstractModelView)bv);
			mev.getIncludedFields().removeAll(Arrays.asList("STATUS","RESOLUTION"));
			Config.instance().getLogger(IssuesController.class.getName()).info(mev.getIncludedFields().toString());
		}

		return bv;
	}

	@SingleRecordAction(tooltip="Yank")
	public View yank(long id){
		Issue issue = Database.getTable(Issue.class).get(id);
		issue.yank();
		return afterPersistDBView(issue);
	}

	@Override
	protected Map<Class<? extends Model>, List<String>> getIncludedModelFields() {
		Map<Class<? extends Model>, List<String>> map =  super.getIncludedModelFields();
		map.put(Note.class, ModelReflector.instance(Note.class).getVisibleFields(Arrays.asList("ID","LOCK_ID","CREATED_AT" ,"UPDATED_AT","CREATOR_USER_ID")));
		return map;
	}
}
```


Overlapping Code:
```
roller extends ModelController<Issue> {
public IssuesController(Path path) {
super(path);
}
@Override
protected HtmlView constructModelListView(List<Issue> records,boolean isCompleteList){
return new ModelListView<Issue>(getPath(), new String[]{"ID","TITLE","PRIORITY","STATUS","ASSIGNED_TO_ID","RESOLUTION","CREATOR_USER_ID"}, records, isCompleteList);
}

@Override
protected HtmlView createBlankView(Path path , Issue record, String formAction){
HtmlView bv = super.createBlankView(path, record,formAction);
if (bv instanceof AbstractModelView){
AbstractModelView mev = ((AbstractModelView)bv);
mev.getIncludedFields().removeAll(Arrays.asList("STATUS","RESOLUTION"));
Config.instance().getLogger(IssuesController.class.getName()).info(mev.getIncludedFields().toString());
}
return bv;
}
@SingleRecordAction(tooltip="Yank")
public View yank(long id){
Issue issue = Database.getTable(Issue.class).get(id);
issue.yank();
return afterPersistDBView(issue);
}
@Override
protected Map<Class<? extends Model>, List<String>> getIncludedModelFields() {
Map<Class<? extends Model>, List<String>> map = super.getIncludedModelFields();
map.put(Note.class, ModelReflector.instance(Note.class).getVisibleFields(Arrays.asList("ID","LOCK_ID","CREATED_AT" ,"UPDATED_AT",
```
<Overlap Ratio: 0.954337899543379>

---

--- 262 --
Question ID: ea908cdd43afca34a367de1c2cc5222f2011e9b6_0
Original Code:
```
public final class ProcessStartListener implements EventListener<ChannelInitEvent> {

    private final Map<UUID, CompletableFuture<ProxyProcessMeta>> waitingProxies = new ConcurrentHashMap<>();
    private final Map<UUID, CompletableFuture<ServerProcessMeta>> waitingServers = new ConcurrentHashMap<>();

    @Override
    public void onCall(final ChannelInitEvent event) {
        if (event.getINetworkComponent() instanceof ProxyServer) {
            final ProxyServer proxyServer = (ProxyServer) event.getINetworkComponent();
            UUID uuid = proxyServer.getProcessMeta().getProperties().getObject("cloudnet:requestId", UUID.class);
            this.waitingProxies.remove(uuid).complete(proxyServer.getProcessMeta());
        } else if (event.getINetworkComponent() instanceof MinecraftServer) {
            final MinecraftServer proxyServer = (MinecraftServer) event.getINetworkComponent();
            UUID uuid = proxyServer.getProcessMeta().getServerConfig().getProperties().getObject("cloudnet:requestId", UUID.class);
            this.waitingServers.remove(uuid).complete(proxyServer.getProcessMeta());
        }
    }

    public CompletableFuture<ProxyProcessMeta> waitForProxy(UUID uuid) {
        CompletableFuture<ProxyProcessMeta> future = new CompletableFuture<>();
        this.waitingProxies.put(uuid, future);
        return future;
    }

    public CompletableFuture<ServerProcessMeta> waitForServer(UUID uuid) {
        CompletableFuture<ServerProcessMeta> future = new CompletableFuture<>();
        this.waitingServers.put(uuid, future);
        return future;
    }
}
```


Overlapping Code:
```
 ProcessStartListener implements EventListener<ChannelInitEvent> {
private final Map<UUID, CompletableFuture<ProxyProcessMeta>> waitingProxies = new ConcurrentHashMap<>();
private final Map<UUID, CompletableFuture<ServerProcessMeta>> waitingServers = new ConcurrentHashMap<>();
@Override
public void onCall(final ChannelInitEvent event) {
if (event.getINetworkComponent() instanceof ProxyServer) {
final ProxyServer proxyServer = (ProxyServer) event.getINetworkComponent();
UUID uuid = proxyServer.getProcessMeta().getProperties().getObject("cloudnet:requestId", UUID.class);
this.waitingProxies.remove(uuid).complete(proxyServer.getProcessMeta());
} else if (event.getINetworkComponent() instanceof MinecraftServer) {
final MinecraftServer proxyServer = (MinecraftServer) event.getINetworkComponent();
UUID uuid = proxyServer.getProcessMeta().getServerConfig().getProperties().getObject("cloudnet:requestId", UUID.class);
this.waitingServers.remove(uuid).complete(proxyServer.getProcessMeta());
}
}
public CompletableFuture<ProxyProcessMeta> waitForProxy(UUID uuid) {
CompletableFuture<ProxyProcessMeta> future = new CompletableFuture<>();
this.waitingProxies.put(uuid, future);
return future;
}
public CompletableFuture<ServerProcessMeta> waitForServer(UUID uuid) {
CompletableFuture<ServerProcessMeta> future = new CompletableFuture<>();
this.waitingServers.put(uuid, future);
return future;
}
```
<Overlap Ratio: 0.9858757062146892>

---

--- 263 --
Question ID: 74419c496f81a8b580b109b02df339a4a334ed43_0
Original Code:
```
public class Foo {
    public static void main(String[] args) {
        int b1 = Bar.b/*caret*/ar();
        int b2 = Bar$.MODULE$.b/*caret*/ar();
        Bar$.MODULE$.bar_/*caret*/$eq(3);
        Bar2.bar_$/*caret*/eq(2);
        Bar2.ba/*caret*/r();
        Bar2$.MODULE$.b/*caret*/ar();
        Bar2$.MODULE$.bar_/*caret*/$eq(4);
    }
}
```


Overlapping Code:
```
public class Foo {
public static void main(String[] args) {
int b1 = Bar.b/*caret*/ar();
int b2 = Bar$.MODULE$.b/*caret*/ar();
Bar$.MODULE$.bar_/*caret*/$eq(3);
Bar2.bar_$/*caret*/eq(2);
Bar2.ba/*caret*/r();
Bar2$.MODULE$.b/*caret*/ar(
```
<Overlap Ratio: 0.8514492753623188>

---

--- 264 --
Question ID: c5e46d9d212669c7df7565125f2693ef177bcf5a_0
Original Code:
```
public class S2029StoneGameIX {
    public boolean stoneGameIX(int[] stones) {
        int[] cnt = new int[3];
        for (int a: stones)
            cnt[a % 3]++;
        if (Math.min(cnt[1], cnt[2]) == 0)
            return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;
        return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 0;
    }
}
```


Overlapping Code:
```
IX {
public boolean stoneGameIX(int[] stones) {
int[] cnt = new int[3];
for (int a: stones)
cnt[a % 3]++;
if (Math.min(cnt[1], cnt[2]) == 0)
return Math.max(cnt[1], cnt[2]) > 2 && cnt[0] % 2 > 0;
return Math.abs(cnt[1] - cnt[2]) > 2 || cnt[0] % 2 == 
```
<Overlap Ratio: 0.8833922261484098>

---

--- 265 --
Question ID: 42d27d96ec0d02d273dd288592b36e77ef176802_0
Original Code:
```
public class UdpClient {

    public static void main(String[] args) throws Exception {
        DatagramSocket socket = new DatagramSocket();
        InetAddress address = InetAddress.getByName("127.0.0.1");
        int port = 9090;
        String data = "udt data";
        DatagramPacket datagramPacket = new DatagramPacket(data.getBytes(), data.length(), address, port);
        socket.send(datagramPacket);
        socket.close();
    }
}
```


Overlapping Code:
```
public class UdpClient {
public static void main(String[] args) throws Exception {
DatagramSocket socket = new DatagramSocket();
InetAddress address = InetAddress.getByName("127.0.0.1");
int port = 9090;
String data = "udt data";
DatagramPacket datagramPacket = new DatagramPacket(data.getBytes(), data.length(), address, port);
socket.se
```
<Overlap Ratio: 0.896551724137931>

---

--- 266 --
Question ID: 7fe3491d2af98d470efecc752e1649b862a69976_0
Original Code:
```
public class V1LimitRangeItemFluentImpl<A extends io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>> extends io.kubernetes.client.fluent.BaseFluent<A> implements io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>{
  public V1LimitRangeItemFluentImpl() {
  }
  public V1LimitRangeItemFluentImpl(io.kubernetes.client.openapi.models.V1LimitRangeItem instance) {
    this.withDefault(instance.getDefault());

    this.withDefaultRequest(instance.getDefaultRequest());

    this.withMax(instance.getMax());

    this.withMaxLimitRequestRatio(instance.getMaxLimitRequestRatio());

    this.withMin(instance.getMin());

    this.withType(instance.getType());

  }
  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default;
  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest;
  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max;
  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio;
  private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min;
  private io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type;
  public A addToDefault(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
    if(this._default == null && key != null && value != null) { this._default = new java.util.LinkedHashMap(); }
    if(key != null && value != null) {this._default.put(key, value);} return (A)this;
  }
  public A addToDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this._default == null && map != null) { this._default = new java.util.LinkedHashMap(); }
    if(map != null) { this._default.putAll(map);} return (A)this;
  }
  public A removeFromDefault(java.lang.String key) {
    if(this._default == null) { return (A) this; }
    if(key != null && this._default != null) {this._default.remove(key);} return (A)this;
  }
  public A removeFromDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this._default == null) { return (A) this; }
    if(map != null) { for(Object key : map.keySet()) {if (this._default != null){this._default.remove(key);}}} return (A)this;
  }
  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefault() {
    return this._default;
  }
  public <K,V>A withDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default) {
    if (_default == null) { this._default =  null;} else {this._default = new java.util.LinkedHashMap(_default);} return (A) this;
  }
  public java.lang.Boolean hasDefault() {
    return this._default != null;
  }
  public A addToDefaultRequest(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
    if(this.defaultRequest == null && key != null && value != null) { this.defaultRequest = new java.util.LinkedHashMap(); }
    if(key != null && value != null) {this.defaultRequest.put(key, value);} return (A)this;
  }
  public A addToDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.defaultRequest == null && map != null) { this.defaultRequest = new java.util.LinkedHashMap(); }
    if(map != null) { this.defaultRequest.putAll(map);} return (A)this;
  }
  public A removeFromDefaultRequest(java.lang.String key) {
    if(this.defaultRequest == null) { return (A) this; }
    if(key != null && this.defaultRequest != null) {this.defaultRequest.remove(key);} return (A)this;
  }
  public A removeFromDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.defaultRequest == null) { return (A) this; }
    if(map != null) { for(Object key : map.keySet()) {if (this.defaultRequest != null){this.defaultRequest.remove(key);}}} return (A)this;
  }
  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefaultRequest() {
    return this.defaultRequest;
  }
  public <K,V>A withDefaultRequest(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest) {
    if (defaultRequest == null) { this.defaultRequest =  null;} else {this.defaultRequest = new java.util.LinkedHashMap(defaultRequest);} return (A) this;
  }
  public java.lang.Boolean hasDefaultRequest() {
    return this.defaultRequest != null;
  }
  public A addToMax(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
    if(this.max == null && key != null && value != null) { this.max = new java.util.LinkedHashMap(); }
    if(key != null && value != null) {this.max.put(key, value);} return (A)this;
  }
  public A addToMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.max == null && map != null) { this.max = new java.util.LinkedHashMap(); }
    if(map != null) { this.max.putAll(map);} return (A)this;
  }
  public A removeFromMax(java.lang.String key) {
    if(this.max == null) { return (A) this; }
    if(key != null && this.max != null) {this.max.remove(key);} return (A)this;
  }
  public A removeFromMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.max == null) { return (A) this; }
    if(map != null) { for(Object key : map.keySet()) {if (this.max != null){this.max.remove(key);}}} return (A)this;
  }
  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMax() {
    return this.max;
  }
  public <K,V>A withMax(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max) {
    if (max == null) { this.max =  null;} else {this.max = new java.util.LinkedHashMap(max);} return (A) this;
  }
  public java.lang.Boolean hasMax() {
    return this.max != null;
  }
  public A addToMaxLimitRequestRatio(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
    if(this.maxLimitRequestRatio == null && key != null && value != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }
    if(key != null && value != null) {this.maxLimitRequestRatio.put(key, value);} return (A)this;
  }
  public A addToMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.maxLimitRequestRatio == null && map != null) { this.maxLimitRequestRatio = new java.util.LinkedHashMap(); }
    if(map != null) { this.maxLimitRequestRatio.putAll(map);} return (A)this;
  }
  public A removeFromMaxLimitRequestRatio(java.lang.String key) {
    if(this.maxLimitRequestRatio == null) { return (A) this; }
    if(key != null && this.maxLimitRequestRatio != null) {this.maxLimitRequestRatio.remove(key);} return (A)this;
  }
  public A removeFromMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.maxLimitRequestRatio == null) { return (A) this; }
    if(map != null) { for(Object key : map.keySet()) {if (this.maxLimitRequestRatio != null){this.maxLimitRequestRatio.remove(key);}}} return (A)this;
  }
  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMaxLimitRequestRatio() {
    return this.maxLimitRequestRatio;
  }
  public <K,V>A withMaxLimitRequestRatio(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio) {
    if (maxLimitRequestRatio == null) { this.maxLimitRequestRatio =  null;} else {this.maxLimitRequestRatio = new java.util.LinkedHashMap(maxLimitRequestRatio);} return (A) this;
  }
  public java.lang.Boolean hasMaxLimitRequestRatio() {
    return this.maxLimitRequestRatio != null;
  }
  public A addToMin(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
    if(this.min == null && key != null && value != null) { this.min = new java.util.LinkedHashMap(); }
    if(key != null && value != null) {this.min.put(key, value);} return (A)this;
  }
  public A addToMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.min == null && map != null) { this.min = new java.util.LinkedHashMap(); }
    if(map != null) { this.min.putAll(map);} return (A)this;
  }
  public A removeFromMin(java.lang.String key) {
    if(this.min == null) { return (A) this; }
    if(key != null && this.min != null) {this.min.remove(key);} return (A)this;
  }
  public A removeFromMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
    if(this.min == null) { return (A) this; }
    if(map != null) { for(Object key : map.keySet()) {if (this.min != null){this.min.remove(key);}}} return (A)this;
  }
  public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getMin() {
    return this.min;
  }
  public <K,V>A withMin(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min) {
    if (min == null) { this.min =  null;} else {this.min = new java.util.LinkedHashMap(min);} return (A) this;
  }
  public java.lang.Boolean hasMin() {
    return this.min != null;
  }
  public io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum getType() {
    return this.type;
  }
  public A withType(io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type) {
    this.type=type; return (A) this;
  }
  public java.lang.Boolean hasType() {
    return this.type != null;
  }
  public boolean equals(java.lang.Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    V1LimitRangeItemFluentImpl that = (V1LimitRangeItemFluentImpl) o;
    if (_default != null ? !_default.equals(that._default) :that._default != null) return false;
    if (defaultRequest != null ? !defaultRequest.equals(that.defaultRequest) :that.defaultRequest != null) return false;
    if (max != null ? !max.equals(that.max) :that.max != null) return false;
    if (maxLimitRequestRatio != null ? !maxLimitRequestRatio.equals(that.maxLimitRequestRatio) :that.maxLimitRequestRatio != null) return false;
    if (min != null ? !min.equals(that.min) :that.min != null) return false;
    if (type != null ? !type.equals(that.type) :that.type != null) return false;
    return true;
  }
  public int hashCode() {
    return java.util.Objects.hash(_default,  defaultRequest,  max,  maxLimitRequestRatio,  min,  type,  super.hashCode());
  }
  
}
```


Overlapping Code:
```
FluentImpl<A extends io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>> extends io.kubernetes.client.fluent.BaseFluent<A> implements io.kubernetes.client.openapi.models.V1LimitRangeItemFluent<A>{
public V1LimitRangeItemFluentImpl() {
}
public V1LimitRangeItemFluentImpl(io.kubernetes.client.openapi.models.V1LimitRangeItem instance) {
this.withDefault(instance.getDefault());
this.withDefaultRequest(instance.getDefaultRequest());
this.withMax(instance.getMax());
this.withMaxLimitRequestRatio(instance.getMaxLimitRequestRatio());
this.withMin(instance.getMin());
this.withType(instance.getType());
}
private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> _default;
private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> defaultRequest;
private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> max;
private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> maxLimitRequestRatio;
private java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> min;
private io.kubernetes.client.openapi.models.V1LimitRangeItem.TypeEnum type;
public A addToDefault(java.lang.String key,io.kubernetes.client.custom.Quantity value) {
if(this._default == null && key != null && value != null) { this._default = new java.util.LinkedHashMap(); }
if(key != null && value != null) {this._default.put(key, value);} return (A)this;
}
public A addToDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
if(this._default == null && map != null) { this._default = new java.util.LinkedHashMap(); }
if(map != null) { this._default.putAll(map);} return (A)this;
}
public A removeFromDefault(java.lang.String key) {
if(this._default == null) { return (A) this; }
if(key != null && this._default != null) {this._default.remove(key);} return (A)this;
}
public A removeFromDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> map) {
if(this._default == null) { return (A) this; }
if(map != null) { for(Object key : map.keySet()) {if (this._default != null){this._default.remove(key);}}} return (A)this;
}
public java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> getDefault() {
return this._default;
}
public <K,V>A withDefault(java.util.Map<java.lang.String,io.kubernetes.client.custom.Quantity> 
```
<Overlap Ratio: 0.9798910766652702>

---

--- 267 --
Question ID: 880c46024fdd0c17c2a0a2b6f868a0d9d3201711_0
Original Code:
```
public final class HiveTestUtils
{
    private HiveTestUtils()
    {
    }

    public static final ConnectorSession SESSION = new TestingConnectorSession(
            new HiveSessionProperties(new HiveClientConfig(), new OrcFileWriterConfig(), new ParquetFileWriterConfig()).getSessionProperties());

    public static final TypeRegistry TYPE_MANAGER = new TypeRegistry();

    public static final MetadataManager METADATA = MetadataManager.createTestMetadataManager();

    public static final StandardFunctionResolution FUNCTION_RESOLUTION = new FunctionResolution(METADATA.getFunctionManager());

    public static final RowExpressionService ROW_EXPRESSION_SERVICE = new RowExpressionService()
    {
        @Override
        public DomainTranslator getDomainTranslator()
        {
            return new RowExpressionDomainTranslator(METADATA);
        }

        @Override
        public ExpressionOptimizer getExpressionOptimizer()
        {
            return new RowExpressionOptimizer(METADATA);
        }

        @Override
        public PredicateCompiler getPredicateCompiler()
        {
            return new RowExpressionPredicateCompiler(METADATA);
        }

        @Override
        public DeterminismEvaluator getDeterminismEvaluator()
        {
            return new RowExpressionDeterminismEvaluator(METADATA);
        }

        @Override
        public String formatRowExpression(ConnectorSession session, RowExpression expression)
        {
            return new RowExpressionFormatter(METADATA.getFunctionManager()).formatRowExpression(session, expression);
        }
    };

    public static final FilterStatsCalculatorService FILTER_STATS_CALCULATOR_SERVICE = new ConnectorFilterStatsCalculatorService(
            new FilterStatsCalculator(METADATA, new ScalarStatsCalculator(METADATA), new StatsNormalizer()));

    static {
        // associate TYPE_MANAGER with a function manager
        new FunctionManager(TYPE_MANAGER, new BlockEncodingManager(TYPE_MANAGER), new FeaturesConfig());
    }

    public static final HiveClientConfig HIVE_CLIENT_CONFIG = new HiveClientConfig();
    public static final MetastoreClientConfig METASTORE_CLIENT_CONFIG = new MetastoreClientConfig();

    public static final HdfsEnvironment HDFS_ENVIRONMENT = createTestHdfsEnvironment(HIVE_CLIENT_CONFIG, METASTORE_CLIENT_CONFIG);

    public static final PageSorter PAGE_SORTER = new PagesIndexPageSorter(new PagesIndex.TestingFactory(false));

    public static Set<HiveBatchPageSourceFactory> getDefaultHiveBatchPageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)
    {
        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();
        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);
        return ImmutableSet.<HiveBatchPageSourceFactory>builder()
                .add(new RcFilePageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))
                .add(new OrcBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))
                .add(new DwrfBatchPageSourceFactory(TYPE_MANAGER, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource()))
                .add(new ParquetPageSourceFactory(TYPE_MANAGER, testHdfsEnvironment, stats))
                .add(new PageFilePageSourceFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))
                .build();
    }

    public static Set<HiveSelectivePageSourceFactory> getDefaultHiveSelectivePageSourceFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)
    {
        FileFormatDataSourceStats stats = new FileFormatDataSourceStats();
        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);
        return ImmutableSet.<HiveSelectivePageSourceFactory>builder()
                .add(new OrcSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))
                .add(new DwrfSelectivePageSourceFactory(TYPE_MANAGER, FUNCTION_RESOLUTION, ROW_EXPRESSION_SERVICE, hiveClientConfig, testHdfsEnvironment, stats, new StorageOrcFileTailSource(), new StorageStripeMetadataSource(), new TupleDomainFilterCache()))
                .build();
    }

    public static Set<HiveRecordCursorProvider> getDefaultHiveRecordCursorProvider(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)
    {
        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);
        return ImmutableSet.<HiveRecordCursorProvider>builder()
                .add(new GenericHiveRecordCursorProvider(testHdfsEnvironment))
                .build();
    }

    public static Set<HiveFileWriterFactory> getDefaultHiveFileWriterFactories(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)
    {
        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);
        return ImmutableSet.<HiveFileWriterFactory>builder()
                .add(new RcFileFileWriterFactory(testHdfsEnvironment, TYPE_MANAGER, new NodeVersion("test_version"), hiveClientConfig, new FileFormatDataSourceStats()))
                .add(new PageFileWriterFactory(testHdfsEnvironment, new BlockEncodingManager(TYPE_MANAGER)))
                .add(getDefaultOrcFileWriterFactory(hiveClientConfig, metastoreClientConfig))
                .build();
    }

    public static OrcFileWriterFactory getDefaultOrcFileWriterFactory(HiveClientConfig hiveClientConfig, MetastoreClientConfig metastoreClientConfig)
    {
        HdfsEnvironment testHdfsEnvironment = createTestHdfsEnvironment(hiveClientConfig, metastoreClientConfig);
        return new OrcFileWriterFactory(
                testHdfsEnvironment,
                TYPE_MANAGER,
                new NodeVersion("test_version"),
                hiveClientConfig,
                new FileFormatDataSourceStats(),
                new OrcFileWriterConfig());
    }

    public static List<Type> getTypes(List<? extends ColumnHandle> columnHandles)
    {
        ImmutableList.Builder<Type> types = ImmutableList.builder();
        for (ColumnHandle columnHandle : columnHandles) {
            types.add(TYPE_MANAGER.getType(((HiveColumnHandle) columnHandle).getTypeSignature()));
        }
        return types.build();
    }

    public static HdfsEnvironment createTestHdfsEnvironment(HiveClientConfig config, MetastoreClientConfig metastoreClientConfig)
    {
        HdfsConfiguration hdfsConfig = new HiveHdfsConfiguration(
                new HdfsConfigurationInitializer(
                        config,
                        metastoreClientConfig,
                        new PrestoS3ConfigurationUpdater(new HiveS3Config()),
                        new HiveGcsConfigurationInitializer(new HiveGcsConfig())),
                ImmutableSet.of());
        return new HdfsEnvironment(hdfsConfig, metastoreClientConfig, new NoHdfsAuthentication());
    }

    public static MapType mapType(Type keyType, Type valueType)
    {
        return (MapType) TYPE_MANAGER.getParameterizedType(StandardTypes.MAP, ImmutableList.of(
                TypeSignatureParameter.of(keyType.getTypeSignature()),
                TypeSignatureParameter.of(valueType.getTypeSignature())));
    }

    public static ArrayType arrayType(Type elementType)
    {
        return (ArrayType) TYPE_MANAGER.getParameterizedType(
                StandardTypes.ARRAY,
                ImmutableList.of(TypeSignatureParameter.of(elementType.getTypeSignature())));
    }

    public static RowType rowType(List<NamedTypeSignature> elementTypeSignatures)
    {
        return (RowType) TYPE_MANAGER.getParameterizedType(
                StandardTypes.ROW,
                ImmutableList.copyOf(elementTypeSignatures.stream()
                        .map(TypeSignatureParameter::of)
                        .collect(toList())));
    }

    public static Long shortDecimal(String value)
    {
        return new BigDecimal(value).unscaledValue().longValueExact();
    }

    public static Slice longDecimal(String value)
    {
        return encodeScaledValue(new BigDecimal(value));
    }
}
```


Overlapping Code:
```
te HiveTestUtils()
{
}
public static final ConnectorSession SESSION = new TestingConnectorSession(
new HiveSessionProperties(new HiveClientConfig(), new OrcFileWriterConfig(), new ParquetFileWriterConfig()).getSessionProperties());
public static final TypeRegistry TYPE_MANAGER = new TypeRegistry();
public static final MetadataManager METADATA = MetadataManager.createTestMetadataManager();
public static final StandardFunctionResolution FUNCTION_RESOLUTION = new FunctionResolution(METADATA.getFunctionManager());
public static final RowExpressionService ROW_EXPRESSION_SERVICE = new RowExpressionService()
{
@Override
public DomainTranslator getDomainTranslator()
{
return new RowExpressionDomainTranslator(METADATA);
}
@Override
public ExpressionOptimizer getExpressionOptimizer()
{
return new RowExpressionOptimizer(METADATA);
}
@Override
public PredicateCompiler getPredicateCompiler()
{
return new RowExpressionPredicateCompiler(METADATA);
}
@Override
public DeterminismEvaluator getDeterminismEvaluator()
{
return new RowExpressionDeterminismEvaluator(METADATA);
}
@Override
public String formatRowExpression(ConnectorSession session, RowExpression expression)
{
return new RowExpressionFormatter(METADATA.getFunctionManager()).formatRowExpression(session, expression);
}
};
public static final FilterStatsCalculatorService FILTER_STATS_CALCULATOR_SERVICE = new ConnectorFilterStatsCalculatorService(
new FilterStatsCalculator(METADATA, new ScalarStatsCalculator(METADATA), new StatsNormalizer()));
static {
// associate TYPE_MANAGER with a function manager
new FunctionManager(TYPE_MANAGER, new BlockEncodingManager(TYPE_MANAGER), new FeaturesConfig());
}
public static final HiveClientConfig HIVE_CLIENT_CONFIG = new HiveClientConfig();
public static final MetastoreClientConfig METASTORE_CLIENT_CONFIG = new MetastoreClientConfig();
public static final HdfsEnvironment HDFS_ENVIRONMENT = createTestHdfsEnvironment(HIVE_CLIENT_CONFIG, METASTORE_CLIENT_CONFIG);
public static final PageSorter PAGE_SORTER = new PagesIndexPageSorter(new PagesIndex.TestingFactory(false));
public static Set<HiveBat
```
<Overlap Ratio: 0.9781598513011153>

---

--- 268 --
Question ID: 1f719598508a3bd9d105c081fae0ea33cff69a79_0
Original Code:
```
public class WildFlyProperties {

    /**
     * Java platform property which is used as a java platform ID
     */
    public static final String PLAT_PROP_ANT_NAME = "platform.ant.name"; //NOI18N

    // properties
    public static final String PROP_PROXY_ENABLED = "proxy_enabled";   // NOI18N
    private static final String PROP_JAVA_PLATFORM = "java_platform";   // NOI18N
    private static final String PROP_SOURCES = "sources";         // NOI18N
    private static final String PROP_JAVADOCS = "javadocs";        // NOI18N

    private static final FilenameFilter CP_FILENAME_FILTER = new FilenameFilter() {

        @Override
        public boolean accept(File dir, String name) {
            return name.endsWith(".jar") || new File(dir, name).isDirectory(); // NOI18N
        }
    };

    // default values
    private static final String DEF_VALUE_JAVA_OPTS = ""; // NOI18N
    private static final boolean DEF_VALUE_PROXY_ENABLED = true;

    private final InstanceProperties ip;
    private final WildflyDeploymentManager manager;

    // credentials initialized with default values
    private String username = "admin"; // NOI18N
    private String password = "admin"; // NOI18N

    /**
     * timestamp of the jmx-console-users.properties file when it was parsed for
     * the last time
     */
    private long updateCredentialsTimestamp;

    private static final Logger LOGGER = Logger.getLogger(WildFlyProperties.class.getName());

    private final Version version;

    private final boolean wildfly;

    private final boolean servletOnly;

    /**
     * Creates a new instance of JBProperties
     */
    public WildFlyProperties(WildflyDeploymentManager manager) {
        this.manager = manager;
        ip = manager.getInstanceProperties();
        File serverPath = new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));
        version = manager.getServerVersion();
        wildfly = manager.isWildfly();
        servletOnly = WildflyPluginUtils.isWildFlyServlet(serverPath);
    }

    public boolean isWildfly() {
         return wildfly;
    }

    public String getServerProfile() {
        if (this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE) == null) {
            return getDefaultConfigurationFile(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));
        }
        return this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE);
    }

    public InstanceProperties getInstanceProperties() {
        return this.ip;
    }

    public Version getServerVersion() {
        return version;
    }

    public boolean isServletOnly() {
        return servletOnly;
    }

    public boolean isVersion(Version targetVersion) {
        return (version != null && version.compareToIgnoreUpdate(targetVersion) >= 0); // NOI18N
    }

    public File getServerDir() {
        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_SERVER_DIR));
    }

    public File getRootDir() {
        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));
    }

    public File getDeployDir() {
        return new File(ip.getProperty(WildflyPluginProperties.PROPERTY_DEPLOY_DIR));
    }

    public File getLibsDir() {
        return new File(getServerDir(), "lib"); // NOI18N
    }

    public boolean getProxyEnabled() {
        String val = ip.getProperty(PROP_PROXY_ENABLED);
        return val != null ? Boolean.valueOf(val)
                : DEF_VALUE_PROXY_ENABLED;
    }

    public void setProxyEnabled(boolean enabled) {
        ip.setProperty(PROP_PROXY_ENABLED, Boolean.toString(enabled));
    }

    public JavaPlatform getJavaPlatform() {
        String currentJvm = ip.getProperty(PROP_JAVA_PLATFORM);
        JavaPlatformManager jpm = JavaPlatformManager.getDefault();
        JavaPlatform[] installedPlatforms = jpm.getPlatforms(null, new Specification("J2SE", null)); // NOI18N
        for (int i = 0; i < installedPlatforms.length; i++) {
            String platformName = (String) installedPlatforms[i].getProperties().get(PLAT_PROP_ANT_NAME);
            if (platformName != null && platformName.equals(currentJvm)) {
                return installedPlatforms[i];
            }
        }
        // return default platform if none was set
        return jpm.getDefaultPlatform();
    }

    public void setJavaPlatform(JavaPlatform javaPlatform) {
        ip.setProperty(PROP_JAVA_PLATFORM, (String) javaPlatform.getProperties().get(PLAT_PROP_ANT_NAME));
    }

    public String getJavaOpts() {
        String val = ip.getProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS);
        return val != null ? val : DEF_VALUE_JAVA_OPTS;
    }

    public void setJavaOpts(String javaOpts) {
        ip.setProperty(WildflyPluginProperties.PROPERTY_JAVA_OPTS, javaOpts);
    }

    public String getModulePath(String module) {
        return getRootDir().getAbsolutePath() + ("/modules/system/layers/base/" + module).replace('/', File.separatorChar);
    }

    private static void addFileToList(List<URL> list, File f) {
        URL u = FileUtil.urlForArchiveOrDir(f);
        if (u != null) {
            list.add(u);
        }
    }

    private List<URL> selectJars(FileObject file) {
        if (file == null) {
            return Collections.EMPTY_LIST;
        }
        if (file.isData()) {
            if (file.isValid() && FileUtil.isArchiveFile(file)) {
                URL url = URLMapper.findURL(file, URLMapper.EXTERNAL);
                if (url != null) {
                    return Collections.singletonList(FileUtil.getArchiveRoot(url));
                }
            }
            return Collections.EMPTY_LIST;
        }
        List<URL> result = new ArrayList<URL>();
        for (FileObject child : file.getChildren()) {
            result.addAll(selectJars(child));
        }
        return result;
    }

    public List<URL> getClasses() {
        List<URL> list = selectJars(FileUtil.toFileObject(new File(getModulePath("javax"))));
        File glassfish = new File(getModulePath("org/glassfish/javax"));
        if(glassfish.exists()) {
            list.addAll(selectJars(FileUtil.toFileObject(glassfish)));
        }
        return list;
    }

    public List<URL> getSources() {
        String path = ip.getProperty(PROP_SOURCES);
        if (path == null) {
            return new ArrayList<URL>();
        }
        return CustomizerSupport.tokenizePath(path);
    }

    public void setSources(List<URL> path) {
        ip.setProperty(PROP_SOURCES, CustomizerSupport.buildPath(path));
        // XXX WILDFLY IMPLEMENT
        //manager.getJBPlatform().notifyLibrariesChanged();
    }

    public List<URL> getJavadocs() {
        String path = ip.getProperty(PROP_JAVADOCS);
        if (path == null) {
            ArrayList<URL> list = new ArrayList<URL>();
            File j2eeDoc = InstalledFileLocator.getDefault().locate("docs/javaee-doc-api.jar", null, false); // NOI18N
            if (j2eeDoc != null) {
                addFileToList(list, j2eeDoc);
            }
            return list;
        }
        return CustomizerSupport.tokenizePath(path);
    }

    public void setJavadocs(List<URL> path) {
        ip.setProperty(PROP_JAVADOCS, CustomizerSupport.buildPath(path));
        // XXX WILDFLY IMPLEMENT
        //manager.getJBPlatform().notifyLibrariesChanged();
    }

    public synchronized String getUsername() {
        updateCredentials();
        return username;
    }

    public synchronized String getPassword() {
        updateCredentials();
        return password;
    }

    // private helper methods -------------------------------------------------
    private synchronized void updateCredentials() {
        File usersPropFile = new File(getServerDir(), "/conf/props/jmx-console-users.properties");
        long lastModified = usersPropFile.lastModified();
        if (lastModified == updateCredentialsTimestamp) {
            LOGGER.log(Level.FINER, "Credentials are up-to-date.");
            return;
        }
        Properties usersProps = new Properties();
        try {
            InputStream is = new BufferedInputStream(new FileInputStream(usersPropFile));
            try {
                usersProps.load(is);
            } finally {
                is.close();
            }
        } catch (FileNotFoundException e) {
            LOGGER.log(Level.WARNING, usersPropFile + " not found.", e);
            return;
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Error while reading " + usersPropFile, e);
            return;
        }

        Enumeration<String> names = NbCollections.checkedEnumerationByFilter(usersProps.propertyNames(), String.class, false);
        if (names.hasMoreElements()) {
            username = names.nextElement();
            password = usersProps.getProperty(username);
        }

        updateCredentialsTimestamp = lastModified;
    }
}
```


Overlapping Code:
```
 Java platform property which is used as a java platform ID
*/
public static final String PLAT_PROP_ANT_NAME = "platform.ant.name"; //NOI18N
// properties
public static final String PROP_PROXY_ENABLED = "proxy_enabled"; // NOI18N
private static final String PROP_JAVA_PLATFORM = "java_platform"; // NOI18N
private static final String PROP_SOURCES = "sources"; // NOI18N
private static final String PROP_JAVADOCS = "javadocs"; // NOI18N
private static final FilenameFilter CP_FILENAME_FILTER = new FilenameFilter() {
@Override
public boolean accept(File dir, String name) {
return name.endsWith(".jar") || new File(dir, name).isDirectory(); // NOI18N
}
};
// default values
private static final String DEF_VALUE_JAVA_OPTS = ""; // NOI18N
private static final boolean DEF_VALUE_PROXY_ENABLED = true;
private final InstanceProperties ip;
private final WildflyDeploymentManager manager;
// credentials initialized with default values
private String username =onsole-users.properties file when it was parsed for
* the last time
*/
private long updateCredentialsTimestamp;
private static final Logger LOGGER = Logger.getLogger(WildFlyProperties.class.getName());
private final Version version;
private final boolean wildfly;
private final boolean servletOnly;
/**
* Creates a new instance of JBProperties
*/
public WildFlyProperties(WildflyDeploymentManager manager) {
this.manager = manager;
ip = manager.getInstanceProperties();
File serverPath = new File(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));
version = manager.getServerVersion();
wildfly = manager.isWildfly();
servletOnly = WildflyPluginUtils.isWildFlyServlet(serverPath);
}
public boolean isWildfly() {
return wildfly;
}
public String getServerProfile() {
if (this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE) == null) {
return getDefaultConfigurationFile(ip.getProperty(WildflyPluginProperties.PROPERTY_ROOT_DIR));
}
return this.ip.getProperty(WildflyPluginProperties.PROPERTY_CONFIG_FILE);
}
public InstanceProperties getInstanceProperties() {
ret
```
<Overlap Ratio: 0.9395756457564576>

---

--- 269 --
Question ID: c5812b5fc57c9ed14c99590ca5a4ee654a5a4ccc_0
Original Code:
```
class ReplayingDecoderBuffer implements ChannelBuffer {

    private static final Error REPLAY = new ReplayError();

    private final ChannelBuffer buffer;
    private boolean terminated;

    ReplayingDecoderBuffer(ChannelBuffer buffer) {
        this.buffer = buffer;
    }

    void terminate() {
        terminated = true;
    }

    @Override
    public int capacity() {
        if (terminated) {
            return buffer.capacity();
        } else {
            return Integer.MAX_VALUE;
        }
    }

    @Override
    public boolean isDirect() {
        return buffer.isDirect();
    }

    @Override
    public boolean hasArray() {
        return false;
    }

    @Override
    public byte[] array() {
        throw new UnsupportedOperationException();
    }

    @Override
    public int arrayOffset() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
        throw new UnreplayableOperationException();
    }

    @Override
    public boolean equals(Object obj) {
        return this == obj;
    }

    @Override
    public int compareTo(ChannelBuffer buffer) {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBuffer copy() {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBuffer copy(int index, int length) {
        checkIndex(index, length);
        return buffer.copy(index, length);
    }

    @Override
    public void discardReadBytes() {
        throw new UnreplayableOperationException();
    }

    @Override
    public void ensureWritableBytes(int writableBytes) {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBuffer duplicate() {
        throw new UnreplayableOperationException();
    }

    @Override
    public byte getByte(int index) {
        checkIndex(index);
        return buffer.getByte(index);
    }

    @Override
    public short getUnsignedByte(int index) {
        checkIndex(index);
        return buffer.getUnsignedByte(index);
    }

    @Override
    public void getBytes(int index, byte[] dst, int dstIndex, int length) {
        checkIndex(index, length);
        buffer.getBytes(index, dst, dstIndex, length);
    }

    @Override
    public void getBytes(int index, byte[] dst) {
        checkIndex(index, dst.length);
        buffer.getBytes(index, dst);
    }

    @Override
    public void getBytes(int index, ByteBuffer dst) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {
        checkIndex(index, length);
        buffer.getBytes(index, dst, dstIndex, length);
    }

    @Override
    public void getBytes(int index, ChannelBuffer dst, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void getBytes(int index, ChannelBuffer dst) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int getBytes(int index, GatheringByteChannel out, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public void getBytes(int index, OutputStream out, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public int getInt(int index) {
        checkIndex(index, 4);
        return buffer.getInt(index);
    }

    @Override
    public long getUnsignedInt(int index) {
        checkIndex(index, 4);
        return buffer.getUnsignedInt(index);
    }

    @Override
    public long getLong(int index) {
        checkIndex(index, 8);
        return buffer.getLong(index);
    }

    @Override
    public int getMedium(int index) {
        checkIndex(index, 3);
        return buffer.getMedium(index);
    }

    @Override
    public int getUnsignedMedium(int index) {
        checkIndex(index, 3);
        return buffer.getUnsignedMedium(index);
    }

    @Override
    public short getShort(int index) {
        checkIndex(index, 2);
        return buffer.getShort(index);
    }

    @Override
    public int getUnsignedShort(int index) {
        checkIndex(index, 2);
        return buffer.getUnsignedShort(index);
    }

    @Override
    public char getChar(int index) {
        checkIndex(index, 2);
        return buffer.getChar(index);
    }

    @Override
    public float getFloat(int index) {
        checkIndex(index, 4);
        return buffer.getFloat(index);
    }

    @Override
    public double getDouble(int index) {
        checkIndex(index, 8);
        return buffer.getDouble(index);
    }

    @Override
    public int hashCode() {
        throw new UnreplayableOperationException();
    }

    @Override
    public int indexOf(int fromIndex, int toIndex, byte value) {
        int endIndex = buffer.indexOf(fromIndex, toIndex, value);
        if (endIndex < 0) {
            throw REPLAY;
        }
        return endIndex;
    }

    @Override
    public int indexOf(int fromIndex, int toIndex,
            ChannelBufferIndexFinder indexFinder) {
        int endIndex = buffer.indexOf(fromIndex, toIndex, indexFinder);
        if (endIndex < 0) {
            throw REPLAY;
        }
        return endIndex;
    }

    @Override
    public int bytesBefore(byte value) {
        int bytes = buffer.bytesBefore(value);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public int bytesBefore(ChannelBufferIndexFinder indexFinder) {
        int bytes = buffer.bytesBefore(indexFinder);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public int bytesBefore(int length, byte value) {
        checkReadableBytes(length);
        int bytes = buffer.bytesBefore(length, value);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public int bytesBefore(int length, ChannelBufferIndexFinder indexFinder) {
        checkReadableBytes(length);
        int bytes = buffer.bytesBefore(length, indexFinder);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public int bytesBefore(int index, int length, byte value) {
        int bytes = buffer.bytesBefore(index, length, value);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public int bytesBefore(int index, int length,
            ChannelBufferIndexFinder indexFinder) {
        int bytes = buffer.bytesBefore(index, length, indexFinder);
        if (bytes < 0) {
            throw REPLAY;
        }
        return bytes;
    }

    @Override
    public void markReaderIndex() {
        buffer.markReaderIndex();
    }

    @Override
    public void markWriterIndex() {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBufferFactory factory() {
        return buffer.factory();
    }

    @Override
    public ByteOrder order() {
        return buffer.order();
    }

    @Override
    public boolean readable() {
        return terminated? buffer.readable() : true;
    }

    @Override
    public int readableBytes() {
        if (terminated) {
            return buffer.readableBytes();
        } else {
            return Integer.MAX_VALUE - buffer.readerIndex();
        }
    }

    @Override
    public byte readByte() {
        checkReadableBytes(1);
        return buffer.readByte();
    }

    @Override
    public short readUnsignedByte() {
        checkReadableBytes(1);
        return buffer.readUnsignedByte();
    }

    @Override
    public void readBytes(byte[] dst, int dstIndex, int length) {
        checkReadableBytes(length);
        buffer.readBytes(dst, dstIndex, length);
    }

    @Override
    public void readBytes(byte[] dst) {
        checkReadableBytes(dst.length);
        buffer.readBytes(dst);
    }

    @Override
    public void readBytes(ByteBuffer dst) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {
        checkReadableBytes(length);
        buffer.readBytes(dst, dstIndex, length);
    }

    @Override
    public void readBytes(ChannelBuffer dst, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void readBytes(ChannelBuffer dst) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int readBytes(GatheringByteChannel out, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBuffer readBytes(int length) {
        checkReadableBytes(length);
        return buffer.readBytes(length);
    }

    @Override
    public ChannelBuffer readSlice(int length) {
        checkReadableBytes(length);
        return buffer.readSlice(length);
    }

    @Override
    public void readBytes(OutputStream out, int length) throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public int readerIndex() {
        return buffer.readerIndex();
    }

    @Override
    public void readerIndex(int readerIndex) {
        buffer.readerIndex(readerIndex);
    }

    @Override
    public int readInt() {
        checkReadableBytes(4);
        return buffer.readInt();
    }

    @Override
    public long readUnsignedInt() {
        checkReadableBytes(4);
        return buffer.readUnsignedInt();
    }

    @Override
    public long readLong() {
        checkReadableBytes(8);
        return buffer.readLong();
    }

    @Override
    public int readMedium() {
        checkReadableBytes(3);
        return buffer.readMedium();
    }

    @Override
    public int readUnsignedMedium() {
        checkReadableBytes(3);
        return buffer.readUnsignedMedium();
    }

    @Override
    public short readShort() {
        checkReadableBytes(2);
        return buffer.readShort();
    }

    @Override
    public int readUnsignedShort() {
        checkReadableBytes(2);
        return buffer.readUnsignedShort();
    }

    @Override
    public char readChar() {
        checkReadableBytes(2);
        return buffer.readChar();
    }

    @Override
    public float readFloat() {
        checkReadableBytes(4);
        return buffer.readFloat();
    }

    @Override
    public double readDouble() {
        checkReadableBytes(8);
        return buffer.readDouble();
    }

    @Override
    public void resetReaderIndex() {
        buffer.resetReaderIndex();
    }

    @Override
    public void resetWriterIndex() {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setByte(int index, int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, byte[] src, int srcIndex, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, byte[] src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, ByteBuffer src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, ChannelBuffer src, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setBytes(int index, ChannelBuffer src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int setBytes(int index, InputStream in, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setZero(int index, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int setBytes(int index, ScatteringByteChannel in, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setIndex(int readerIndex, int writerIndex) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setInt(int index, int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setLong(int index, long value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setMedium(int index, int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setShort(int index, int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setChar(int index, int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setFloat(int index, float value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void setDouble(int index, double value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void skipBytes(int length) {
        checkReadableBytes(length);
        buffer.skipBytes(length);
    }

    @Override
    public ChannelBuffer slice() {
        throw new UnreplayableOperationException();
    }

    @Override
    public ChannelBuffer slice(int index, int length) {
        checkIndex(index, length);
        return buffer.slice(index, length);
    }

    @Override
    public ByteBuffer toByteBuffer() {
        throw new UnreplayableOperationException();
    }

    @Override
    public ByteBuffer toByteBuffer(int index, int length) {
        checkIndex(index, length);
        return buffer.toByteBuffer(index, length);
    }

    @Override
    public ByteBuffer[] toByteBuffers() {
        throw new UnreplayableOperationException();
    }

    @Override
    public ByteBuffer[] toByteBuffers(int index, int length) {
        checkIndex(index, length);
        return buffer.toByteBuffers(index, length);
    }

    @Override
    public String toString(int index, int length, Charset charset) {
        checkIndex(index, length);
        return buffer.toString(index, length, charset);
    }

    @Override
    public String toString(Charset charsetName) {
        throw new UnreplayableOperationException();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '(' +
               "ridx=" +
               readerIndex() +
               ", " +
               "widx=" +
               writerIndex() +
               ')';
    }

    @Override
    public boolean writable() {
        return false;
    }

    @Override
    public int writableBytes() {
        return 0;
    }

    @Override
    public void writeByte(int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(byte[] src, int srcIndex, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(byte[] src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(ByteBuffer src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(ChannelBuffer src, int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeBytes(ChannelBuffer src) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int writeBytes(InputStream in, int length) throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public int writeBytes(ScatteringByteChannel in, int length)
            throws IOException {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeInt(int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeLong(long value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeMedium(int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeZero(int length) {
        throw new UnreplayableOperationException();
    }

    @Override
    public int writerIndex() {
        return buffer.writerIndex();
    }

    @Override
    public void writerIndex(int writerIndex) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeShort(int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeChar(int value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeFloat(float value) {
        throw new UnreplayableOperationException();
    }

    @Override
    public void writeDouble(double value) {
        throw new UnreplayableOperationException();
    }

    private void checkIndex(int index) {
        if (index > buffer.writerIndex()) {
            throw REPLAY;
        }
    }

    private void checkIndex(int index, int length) {
        if (index + length > buffer.writerIndex()) {
            throw REPLAY;
        }
    }

    private void checkReadableBytes(int readableBytes) {
        if (buffer.readableBytes() < readableBytes) {
            throw REPLAY;
        }
    }
}
```


Overlapping Code:
```
eplayingDecoderBuffer implements ChannelBuffer {
private static final Error REPLAY = new ReplayError();
private final ChannelBuffer buffer;
private boolean terminated;
ReplayingDecoderBuffer(ChannelBuffer buffer) {
this.buffer = buffer;
}
void terminate() {
terminated = true;
}
@Override
public int capacity() {
if (terminated) {
return buffer.capacity();
} else {
return Integer.MAX_VALUE;
}
}
@Override
public boolean isDirect() {
return buffer.isDirect();
}
@Override
public boolean hasArray() {
return false;
}
@Override
public byte[] array() {
throw new UnsupportedOperationException();
}
@Override
public int arrayOffset() {
throw new UnsupportedOperationException();
}
@Override
public void clear() {
throw new UnreplayableOperationException();
}
@Override
public boolean equals(Object obj) {
return this == obj;
}
@Override
public int compareTo(ChannelBuffer buffer) {
throw new UnreplayableOperationException();
}
@Override
public ChannelBuffer copy() {
throw new UnreplayableOperationException();
}
@Override
public ChannelBuffer copy(int index, int length) {
checkIndex(index, length);
return buffer.copy(index, length);
}
@Override
public void discardReadBytes() {
throw new UnreplayableOperationException();
}
@Override
public void ensureWritableBytes(int writableBytes) {
throw new UnreplayableOperationException();
}
@Override
public ChannelBuffer duplicate() {
throw new UnreplayableOperationException();
}
@Override
public byte getByte(int index) {
checkIndex(index);
return buffer.getByte(index);
}
@Override
public short getUnsignedByte(int index) {
checkIndex(index);
return buffer.getUnsignedByte(index);
}
@Override
public void getBytes(int index, byte[] dst, int dstIndex, int length) {
checkIndex(index, length);
buffer.getBytes(index, dst, dstIndex, length);
}
@Override
public void getBytes(int index, byte[] dst) {
checkIndex(index, dst.length);
buffer.getBytes(index, dst);
}
@Override
public void getBytes(int index, ByteBuffer dst) {
throw new UnreplayableOpe
```
<Overlap Ratio: 0.9964947421131698>

---

--- 270 --
Question ID: bb29224afaba7312d962acf2a9b29cd78269411e_0
Original Code:
```
class DiscoveryServerControllerTests {

	private static final KubernetesServiceInstance serviceAInstance1 = new KubernetesServiceInstance("serviceAInstance1",
		"serviceAInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);

	private static final KubernetesServiceInstance serviceAInstance2 = new KubernetesServiceInstance("serviceAInstance2",
		"serviceAInstance2", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);

	private static final KubernetesServiceInstance serviceAInstance3 = new KubernetesServiceInstance("serviceAInstance3",
		"serviceAInstance3", "2.2.2.2", 8080, new HashMap<>(), false, "namespace2", null);

	private static final KubernetesServiceInstance serviceBInstance1 = new KubernetesServiceInstance("serviceBInstance1",
		"serviceBInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);

	private static final KubernetesServiceInstance serviceCInstance1 = new KubernetesServiceInstance("serviceCInstance1",
		"serviceCInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace2", null);

	private static DiscoveryServerController.Service serviceA = new DiscoveryServerController.Service();
	private static DiscoveryServerController.Service serviceB = new DiscoveryServerController.Service();
	private static DiscoveryServerController.Service serviceC = new DiscoveryServerController.Service();

	private static KubernetesInformerReactiveDiscoveryClient discoveryClient;

	@BeforeAll
	static void beforeAll() {
		Flux<String> services = Flux.just("serviceA", "serviceB", "serviceC");

		List<ServiceInstance> serviceAInstanceList = new ArrayList<>();
		serviceAInstanceList.add(serviceAInstance1);
		serviceAInstanceList.add(serviceAInstance2);
		serviceAInstanceList.add(serviceAInstance3);

		Flux<ServiceInstance> serviceAInstances = Flux.fromIterable(serviceAInstanceList);

		List<ServiceInstance> serviceBInstanceList = Collections.singletonList(serviceBInstance1);
		Flux<ServiceInstance> serviceBInstances = Flux.fromIterable(serviceBInstanceList);

		List<ServiceInstance> serviceCInstanceList = Collections.singletonList(serviceCInstance1);
		Flux<ServiceInstance> serviceCInstances = Flux.fromIterable(serviceCInstanceList);

		discoveryClient = mock(KubernetesInformerReactiveDiscoveryClient.class);
		when(discoveryClient.getServices()).thenReturn(services);
		when(discoveryClient.getInstances(eq("serviceA"))).thenReturn(serviceAInstances);
		when(discoveryClient.getInstances(eq("serviceB"))).thenReturn(serviceBInstances);
		when(discoveryClient.getInstances(eq("serviceC"))).thenReturn(serviceCInstances);
		when(discoveryClient.getInstances(eq("serviceD"))).thenReturn(Flux.empty());

		serviceA.setName("serviceA");
		serviceA.setServiceInstances(serviceAInstanceList);

		serviceB.setName("serviceB");
		serviceB.setServiceInstances(serviceBInstanceList);

		serviceC.setName("serviceC");
		serviceC.setServiceInstances(serviceCInstanceList);
	}



	@Test
	void apps() {
		DiscoveryServerController controller = new DiscoveryServerController(discoveryClient);
		StepVerifier.create(controller.apps()).expectNext(serviceA, serviceB, serviceC).verifyComplete();
	}

	@Test
	void appInstances() {
		DiscoveryServerController controller = new DiscoveryServerController(discoveryClient);
		StepVerifier.create(controller.appInstances("serviceA")).expectNext(serviceAInstance1, serviceAInstance2, serviceAInstance3).verifyComplete();
		StepVerifier.create(controller.appInstances("serviceB")).expectNext(serviceBInstance1).verifyComplete();
		StepVerifier.create(controller.appInstances("serviceC")).expectNext(serviceCInstance1).verifyComplete();
		StepVerifier.create(controller.appInstances("serviceD")).expectNextCount(0).verifyComplete();
	}

	@Test
	void appInstance() {
		DiscoveryServerController controller = new DiscoveryServerController(discoveryClient);
		StepVerifier.create(controller.appInstance("serviceA", "serviceAInstance2")).expectNext(serviceAInstance2).verifyComplete();
		StepVerifier.create(controller.appInstance("serviceB", "doesnotexist")).expectNextCount(0).verifyComplete();
	}
}
```


Overlapping Code:
```
Tests {
private static final KubernetesServiceInstance serviceAInstance1 = new KubernetesServiceInstance("serviceAInstance1",
"serviceAInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);
private static final KubernetesServiceInstance serviceAInstance2 = new KubernetesServiceInstance("serviceAInstance2",
"serviceAInstance2", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);
private static final KubernetesServiceInstance serviceAInstance3 = new KubernetesServiceInstance("serviceAInstance3",
"serviceAInstance3", "2.2.2.2", 8080, new HashMap<>(), false, "namespace2", null);
private static final KubernetesServiceInstance serviceBInstance1 = new KubernetesServiceInstance("serviceBInstance1",
"serviceBInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace1", null);
private static final KubernetesServiceInstance serviceCInstance1 = new KubernetesServiceInstance("serviceCInstance1",
"serviceCInstance1", "2.2.2.2", 8080, new HashMap<>(), false, "namespace2", null);
private static DiscoveryServerController.Service serviceA = new DiscoveryServerController.Service();
private static DiscoveryServerController.Service serviceB = new DiscoveryServerController.Service();
private static DiscoveryServerController.Service serviceC = new DiscoveryServerController.Service();
private static KubernetesInformerReactiveDiscoveryClient discoveryClient;
@BeforeAll
static void beforeAll() {
Flux<String> services = Flux.just("serviceA", "serviceB", "serviceC");
List<ServiceInstance> serviceAInstanceList = new ArrayList<>();
serviceAInstanceList.add(serviceAInstance1);
serviceAInstanceList.add(serviceAInstance2);
serviceAInstanceList.add(serviceAInstance3);
Flux<ServiceInstance> serviceAInstances = Flux.fromIterable(serviceAInstanceList);
List<ServiceInstance> serviceBInstanceList = Collections.singletonList(serviceBInstance1);
Flux<ServiceInstance> serviceBInstances = Flux.fromIterable(serviceBInstanceList);
List<ServiceInstance> serviceCInstanceList = Collections.singletonList(serviceCInstance1);
Flux<ServiceInstance> serviceCInstances = Flux.fromIterable(serviceCInstanceList);
discoveryClient = mock(KubernetesInformerReactiveDiscoveryClient.class);
when(discoveryClient.getServices()).thenReturn(services);
when(discoveryClient.getInstances(eq("serviceA"))).thenReturn(serviceAInstances);
when(discoveryClient.getInstances(eq("serviceB"))).thenRetu
```
<Overlap Ratio: 0.9848173984407058>

---

--- 271 --
Question ID: 2a158f42b049471ac1076dc9686672c883c98458_0
Original Code:
```
public abstract class AbstractWorkflowAction<E extends BullhornEntity, T extends Traverser> implements WorkflowAction<E, T> {

    private final Logger log = Logger.getLogger(getClass());

    private final Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields;

    private EmailTemplateService emailTemplateService;
    private ApplicationSettings appSettings;
    private MessageSource messageSource;
    private Emailer emailer;

    public AbstractWorkflowAction(Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields) {
        this.relatedEntityFields = relatedEntityFields;
    }

    protected Map<StandardRelatedEntity, Set<String>> getStandardEntityFields() {
        return Maps.newLinkedHashMap();
    }

    protected String getMessageUsingKey(String key) throws NoSuchMessageException {
        return getMessageUsingKey(key, new Object[] {});
    }

    protected String getMessageUsingKey(String key, Object[] args) throws NoSuchMessageException {
        return getMessageSource().getMessage(key, args, Locale.US);
    }

    protected MessageSource getMessageSource() {
        if(this.messageSource == null) {
            this.messageSource = AppContext.getApplicationContext().getBean("messageSource", MessageSource.class);
        }

        return messageSource;
    }

    protected EmailTemplateService getEmailTemplateService() {
        if(this.emailTemplateService == null) {
            this.emailTemplateService = AppContext.getApplicationContext().getBean(EmailTemplateService.class);
        }

        return this.emailTemplateService;
    }

    protected ApplicationSettings getAppSettings() {
        if(this.appSettings == null) {
            this.appSettings = AppContext.getApplicationContext().getBean(ApplicationSettings.class);
        }

        return this.appSettings;
    }

    protected Emailer getEmailer() {
        if(this.emailer == null) {
            this.emailer = AppContext.getApplicationContext().getBean(Emailer.class);
        }

        return emailer;
    }

    @Override
    public Map<? extends BullhornRelatedEntity, Set<String>> getRelatedEntityFields() {
        Map<BullhornRelatedEntity, Set<String>> allFields = Maps.newLinkedHashMap();

        allFields.putAll(getStandardEntityFields());
        allFields.putAll(this.relatedEntityFields);

        return allFields;
    }

    protected Logger getLog() {
        return log;
    }

}
```


Overlapping Code:
```
c abstract class AbstractWorkflowAction<E extends BullhornEntity, T extends Traverser> implements WorkflowAction<E, T> {
private final Logger log = Logger.getLogger(getClass());
private final Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields;
private EmailTemplateService emailTemplateService;
private ApplicationSettings appSettings;
private MessageSource messageSource;
private Emailer emailer;
public AbstractWorkflowAction(Map<? extends BullhornRelatedEntity, Set<String>> relatedEntityFields) {
this.relatedEntityFields = relatedEntityFields;
}
protected Map<StandardRelatedEntity, Set<String>> getStandardEntityFields() {
return Maps.newLinkedHashMap();
}
protected String getMessageUsingKey(String key) throws NoSuchMessageException {
return getMessageUsingKey(key, new Object[] {});
}
protected String getMessageUsingKey(String key, Object[] args) throws NoSuchMessageException {
return getMessageSource().getMessage(key, args, Locale.US);
}
protected MessageSource getMessageSource() {
if(this.messageSource == null) {
this.messageSource = AppContext.getApplicationContext().getBean("messageSource", MessageSource.class);
}
return messageSource;
}
protected EmailTemplateService getEmailTemplateService() {
if(this.emailTemplateService == null) {
this.emailTemplateService = AppContext.getApplicationContext().getBean(EmailTemplateService.class);
}
return this.emailTemplateService;
}
protected ApplicationSettings getAppSettings() {
if(this.appSettings == null) {
this.appSettings = AppContext.getApplicationContext().getBean(ApplicationSettings.class);
}
return this.appSettings;
}
protected Emailer getEmailer() {
if(this.emailer == null) {
this.emailer = AppContext.getApplicationContext().getBean(Emailer.class);
}
return emailer;
}
@Override
public Map<? extends BullhornRelatedEntity, Set<String>> getRelatedEntityFields() {
Map<BullhornRelatedEntity, Set<String>> allFields = Maps.newLinkedHashMap();
allFields.putAll(getStandardEntityFields());
allFields.putAll(this.relatedEntityFields);
return allFields;
}
protected Logger getLog
```
<Overlap Ratio: 0.9880668257756563>

---

--- 272 --
Question ID: aee9a2c6a47dc82a9164df2b3a6c67a9177cc928_0
Original Code:
```
public class TensorIOTest {

    @Test
    public void testIntoTable() {
        Tensor tensor1 = Tensor.fromLongData(new long[]{1, 2, 3});
        Tensor tensor2 = Tensor.fromStringData(new String[]{"1", "2", "3"});

        Table table = new TensorIO(Map.of("col1", tensor1, "col2", tensor2)).intoTable();
        assertEquals(2, table.columnCount());
        assertEquals(3, table.rowCount());

        assertEquals(1L, table.column("col1").get(0));
        assertEquals(2L, table.column("col1").get(1));
        assertEquals(3L, table.column("col1").get(2));
        assertEquals("1", table.column("col2").get(0));
        assertEquals("2", table.column("col2").get(1));
        assertEquals("3", table.column("col2").get(2));
    }

}
```


Overlapping Code:
```
void testIntoTable() {
Tensor tensor1 = Tensor.fromLongData(new long[]{1, 2, 3});
Tensor tensor2 = Tensor.fromStringData(new String[]{"1", "2", "3"});
Table table = new TensorIO(Map.of("col1", tensor1, "col2", tensor2)).intoTable();
assertEquals(2, table.columnCount());
assertEquals(3, table.rowCount());
assertEquals(1L, table.column("col1").get(0));
assertEquals(2L, table.column("col1").get(1));
assertEquals(3L, table.column("col1").get(2));
assertEquals("1", table.column("col2").get(0));
assertEquals("2", table.column("col2").get(1));
assertE
```
<Overlap Ratio: 0.8661417322834646>

---

--- 273 --
Question ID: 6dec400abe03bae7a96e7c2bbadd5fd60e737d2f_0
Original Code:
```
public class NodeInfoViewController {

    @FXML
    private AnchorPane nodeInfoPane;

    @FXML
    private SplitPane nodeInfoSplitPane;

    @FXML
    private AnchorPane nodeDataPane;

    @FXML
    private TextField cZxidField;

    @FXML
    private TextField pZxidField;

    @FXML
    private TextField mtimeField;

    @FXML
    private TextField ephemeralOwnerField;

    @FXML
    private TextField ctimeField;

    @FXML
    private TextField mZxidField;

    @FXML
    private TextField dataLengthField;

    @FXML
    private TextField numChildrenField;

    @FXML
    private TextField dataVersionField;

    @FXML
    private TextField aclVersionField;

    @FXML
    private TextField cVersionField;

    @FXML
    private TextField pathField;

    @FXML
    private Button nodeUpdateButton;

    @FXML
    private Label mtimeLabel;

    @FXML
    private Label ctimeLabel;

    @FXML
    private Button jsonFormatButton;

    @FXML
    private Button rawFormatButton;

    @FXML
    private Button xmlFormatButton;

    @FXML
    private HBox dataMenuBar;

    @FXML
    private ChoiceBox<String> charsetChoice;

    private NodeDataArea dataCodeArea = new NodeDataArea();

    @FXML
    private PrettyZooFacade prettyZooFacade = new PrettyZooFacade();

    private List<Button> formatButtons = List.of();

    @FXML
    private void initialize() {
        nodeUpdateButton.setOnMouseClicked(e -> onNodeUpdate());
        initCodeArea();
        final Tooltip timeLabelTooltip = new Tooltip("Click to change format");
        mtimeLabel.setTooltip(timeLabelTooltip);
        ctimeLabel.setTooltip(timeLabelTooltip);
        mtimeLabel.setOnMouseClicked(e -> changeTimeFormat());
        ctimeLabel.setOnMouseClicked(e -> changeTimeFormat());
        jsonFormatButton.setOnAction(e -> dataJsonFormat());
        rawFormatButton.setOnAction(e -> dataRawFormat());
        xmlFormatButton.setOnAction(e -> dataXmlFormat());
        formatButtons = List.of(jsonFormatButton, xmlFormatButton, rawFormatButton);
        charsetChoice.getItems().addAll("UTF-8", "GBK", "GB2312", "ISO-8859-1", "UTF-16");
        charsetChoice.getSelectionModel().select("UTF-8");
        charsetChoice.getSelectionModel().selectedItemProperty().addListener((event, ov, nv) -> {
            if (nv == null) {
                return;
            }
            byte[] rawBytes = (byte[]) dataCodeArea.getProperties().get("rawBytes");
            if (rawBytes == null) {
                return;
            }
            try {
                setCodeAreaData(new String(rawBytes, nv));
            } catch (UnsupportedEncodingException unsupportedEncodingException) {
                VToast.error("Not supported Charset:" + nv);
            }
        });

        Tooltip tooltip = new Tooltip("Double click");
        Tooltip.install(dataMenuBar, tooltip);
        dataMenuBar.setOnMouseClicked(e -> {
            if (e.getClickCount() == 2 && e.getButton() == MouseButton.PRIMARY) {
                StackPane parent = (StackPane) nodeInfoPane.getParent();
                if (!parent.getChildren().contains(nodeDataPane)) {
                    nodeInfoSplitPane.getItems().remove(nodeDataPane);
                    parent.getChildren().add(nodeDataPane);
                    Transitions.zoomIn(nodeDataPane).play();
                } else {
                    parent.getChildren().remove(nodeDataPane);
                    nodeInfoSplitPane.getItems().add(nodeDataPane);
                }
            }
        });
    }

    public void show(StackPane parent) {
        show(parent, null);
    }

    public void show(StackPane parent, ZkNode zkNode) {
        if (!parent.getChildren().contains(nodeInfoPane)) {
            parent.getChildren().add(nodeInfoPane);
        }

        if (zkNode == null) {
            resetTextField();
        } else {
            initTextField(zkNode);
        }
        switchFormatButton(rawFormatButton);
    }

    private void initCodeArea() {
        var pane = new VirtualizedScrollPane<>(dataCodeArea);
        AnchorPane.setTopAnchor(pane, 40d);
        AnchorPane.setLeftAnchor(pane, 0d);
        AnchorPane.setRightAnchor(pane, 0d);
        AnchorPane.setBottomAnchor(pane, 5d);
        nodeDataPane.getChildren().add(pane);
    }

    private void setCodeAreaData(String data) {
        dataCodeArea.setText(data);
    }

    private void onNodeUpdate() {
        final String path = pathField.getText();
        if (!ActiveServerContext.exists()) {
            VToast.error("Error: connect zookeeper first");
            return;
        }
        if (!prettyZooFacade.nodeExists(path)) {
            VToast.error("Node not exists");
            return;
        }
        final String data = dataCodeArea.getText();
        TreeItem<ZkNode> currentData = TreeItemCache.getInstance().get(ActiveServerContext.get(), path);

        Runnable action = () -> {
            Transitions.rotate(nodeUpdateButton, () -> {
                Stat stat = prettyZooFacade.updateData(ActiveServerContext.get(), path, data, ex -> VToast.error(ex.getMessage()));
                dataCodeArea.getProperties().put("raw", data);
                dataCodeArea.getProperties().put("rawBytes", data.getBytes());
                updateField(stat);
                VToast.info("update success");
            });
        };

        ResourceBundle bundle = ResourceBundleUtils.get(prettyZooFacade.getLocale());
        String title = bundle.getString("nodeData.refresh.conflict.title");
        String content = bundle.getString("nodeData.refresh.conflict.content");
        if (!Objects.equals(currentData.getValue().getData(), data)) {
            Dialog.confirm(title, String.format(content, currentData.getValue().getData()), action);
        } else {
            action.run();
        }
    }

    /**
     * TODO use data bind to instead of manual bind
     */
    private void updateField(Stat node) {
        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));
        cZxidField.setText(String.valueOf(node.getCzxid()));
        pZxidField.setText(String.valueOf(node.getPzxid()));
        mZxidField.setText(String.valueOf(node.getMzxid()));
        dataLengthField.setText(String.valueOf(node.getDataLength()));
        numChildrenField.setText(String.valueOf(node.getNumChildren()));
        dataVersionField.setText(String.valueOf(node.getVersion()));
        aclVersionField.setText(String.valueOf(node.getAversion()));
        cVersionField.setText(String.valueOf(node.getCversion()));
        mtimeField.getProperties().put("timestamp", node.getMtime());
        mtimeField.getProperties().put("dateTime", format(node.getMtime()));
        ctimeField.getProperties().put("timestamp", node.getCtime());
        ctimeField.getProperties().put("dateTime", format(node.getCtime()));
        showDateTime();
    }

    private void initTextField(ZkNode node) {
        setCodeAreaData(transformData(node));
        dataCodeArea.getProperties().put("raw", transformData(node));
        dataCodeArea.getProperties().put("rawBytes", node.getDataBytes());

        ephemeralOwnerField.setText(String.valueOf(node.getEphemeralOwner()));
        cZxidField.setText(String.valueOf(node.getCzxid()));
        pZxidField.setText(String.valueOf(node.getPzxid()));
        mZxidField.setText(String.valueOf(node.getMzxid()));
        dataLengthField.setText(String.valueOf(node.getDataLength()));
        numChildrenField.setText(String.valueOf(node.getNumChildren()));
        dataVersionField.setText(String.valueOf(node.getVersion()));
        aclVersionField.setText(String.valueOf(node.getAversion()));
        cVersionField.setText(String.valueOf(node.getCversion()));
        pathField.setText(node.getPath());

        mtimeField.getProperties().put("timestamp", node.getMtime());
        mtimeField.getProperties().put("dateTime", format(node.getMtime()));
        ctimeField.getProperties().put("timestamp", node.getCtime());
        ctimeField.getProperties().put("dateTime", format(node.getCtime()));
        showDateTime();
    }

    private String transformData(ZkNode node) {
        final String charset = charsetChoice.getSelectionModel().getSelectedItem();
        try {
            return new String(node.getDataBytes(), charset);
        } catch (UnsupportedEncodingException e) {
            return node.getData();
        }
    }

    private void changeTimeFormat() {
        if ("timestamp".equals(mtimeLabel.getProperties().get("format"))) {
            showDateTime();
        } else {
            showTimestamp();
        }
    }

    private void showDateTime() {
        final Object ctime = ctimeField.getProperties().getOrDefault("dateTime", "");
        ctimeField.setText(ctime.toString());
        final Object mtime = mtimeField.getProperties().getOrDefault("dateTime", "");
        mtimeField.setText(mtime.toString());
        ctimeLabel.getProperties().put("format", "dateTime");
        mtimeLabel.getProperties().put("format", "dateTime");
    }

    private void showTimestamp() {
        final Object ctime = ctimeField.getProperties().getOrDefault("timestamp", "");
        ctimeField.setText(ctime.toString());
        final Object mtime = mtimeField.getProperties().getOrDefault("timestamp", "");
        mtimeField.setText(mtime.toString());
        ctimeLabel.getProperties().put("format", "timestamp");
        mtimeLabel.getProperties().put("format", "timestamp");
    }

    private String format(long timestamp) {
        if (timestamp == 0) {
            return "-";
        } else {
            return OffsetDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault())
                    .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        }
    }

    private void resetTextField() {
        dataCodeArea.clear();
        ephemeralOwnerField.clear();
        cZxidField.clear();
        mtimeField.clear();
        pZxidField.clear();
        ctimeField.clear();
        mZxidField.clear();
        dataLengthField.clear();
        numChildrenField.clear();
        dataVersionField.clear();
        aclVersionField.clear();
        cVersionField.clear();
        pathField.clear();
    }

    private void dataJsonFormat() {
        final Object data = dataCodeArea.getProperties().get("raw");
        if (data == null) {
            return;
        }
        final String prettyJson;
        try {
            prettyJson = Formatters.prettyJson(data.toString());
            setCodeAreaData(prettyJson);
            switchFormatButton(jsonFormatButton);
        } catch (JsonProcessingException e) {
            VToast.error("JSON format failed");
        }
    }

    private void dataXmlFormat() {
        final Object data = dataCodeArea.getProperties().get("raw");
        if (data == null) {
            return;
        }
        final String prettyXML;
        try {
            prettyXML = Formatters.prettyXml(data.toString());
            setCodeAreaData(prettyXML);
            switchFormatButton(xmlFormatButton);
        } catch (Exception e) {
            VToast.error("XML format failed");
        }
    }

    private void dataRawFormat() {
        final Object data = dataCodeArea.getProperties().get("raw");
        if (data == null) {
            return;
        }
        setCodeAreaData(data.toString());
        switchFormatButton(rawFormatButton);
    }

    private void switchFormatButton(Button button) {
        button.setTextFill(Color.valueOf("#3F51B5"));
        formatButtons.stream().filter(b -> b != button).forEach(b -> b.setTextFill(Color.valueOf("#000")));
    }
}
```


Overlapping Code:
```
er {
@FXML
private AnchorPane nodeInfoPane;
@FXML
private SplitPane nodeInfoSplitPane;
@FXML
private AnchorPane nodeDataPane;
@FXML
private TextField cZxidField;
@FXML
private TextField pZxidField;
@FXML
private TextField mtimeField;
@FXML
private TextField ephemeralOwnerField;
@FXML
private TextField ctimeField;
@FXML
private TextField mZxidField;
@FXML
private TextField dataLengthField;
@FXML
private TextField numChildrenField;
@FXML
private TextField dataVersionField;
@FXML
private TextField aclVersionField;
@FXML
private TextField cVersionField;
@FXML
private TextField pathField;
@FXML
private Button nodeUpdateButton;
@FXML
private Label mtimeLabel;
@FXML
private Label ctimeLabel;
@FXML
private Button jsonFormatButton;
@FXML
private Button rawFormatButton;
@FXML
private Button xmlFormatButton;
@FXML
private HBox dataMenuBar;
@FXML
private ChoiceBox<String> charsetChoice;
private NodeDataArea dataCodeArea = new NodeDataArea();
@FXML
private PrettyZooFacade prettyZooFacade = new PrettyZooFacade();
private List<Button> formatButtons = List.of();
@FXML
private void initialize() {
nodeUpdateButton.setOnMouseClicked(e -> onNodeUpdate());
initCodeArea();
final Tooltip timeLabelTooltip = new Tooltip("Click to change format");
mtimeLabel.setTooltip(timeLabelTooltip);
ctimeLabel.setTooltip(timeLabelTooltip);
mtimeLabel.setOnMouseClicked(e -> changeTimeFormat());
ctimeLabel.setOnMouseClicked(e -> changeTimeFormat());
jsonFormatButton.setOnAction(e -> dataJsonFormat());
rawFormatButton.setOnAction(e -> dataRawFormat());
xmlFormatButton.setOnAction(e -> dataXmlFormat());
formatButtons = List.of(jsonFormatButton, xmlFormatButton, rawFormatButton);
charsetChoice.getItems().addAll("UTF-8", "GBK", "GB2312", "ISO-8859-1", "UTF-16");
charsetChoice.getSelectionModel().select("UTF-8");
charsetChoice.getSelectionModel().selectedItemProperty().addListener((event, ov, nv) -> {
if (nv == null) {
return;
}
byte[] rawBytes = (byte[]) dataCodeArea.g
```
<Overlap Ratio: 0.9780329505741387>

---

--- 274 --
Question ID: 071b49531cc25c60f4140d15d2b50ee011ddffc1_0
Original Code:
```
public class GenerateEventsForDemoTest {
    private static int NUMBER_OF_SEND_COMMANDS = 58;
    private static int NUMBER_OF_SEND_AND_WAIT_COMMANDS = 9;

    private static final int NUMBER_OF_ADD_ROOM_COMMANDS = 20;
    private static final int NUMBER_OF_PAY_COMMANDS = 9;
    private static final int NUMBER_OF_REGISTER_ACCOUNT_COMMANDS = 9;
    private static final int NUMBER_OF_BOOK_ROOM_COMMANDS = 5;
    private static final int NUMBER_OF_CHECK_OUT_COMMANDS = 5;
    private static final int NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS = 5;
    private static final int NUMBER_OF_CHECK_IN_COMMANDS = 5;
    private static final int NUMBER_OF_PROCESS_PAYMENT_COMMANDS = 9;

    private CommandGateway commandGateway = mock(CommandGateway.class);
    private RoomAvailabilityEntityRepository roomAvailabilityEntityRepository = mock(RoomAvailabilityEntityRepository.class);
    private UUIDProvider uuidProvider = mock(UUIDProvider.class);
    private UUID accountId = UUID.randomUUID();
    private UUID bookingId = UUID.randomUUID();
    private UUID paymentId = UUID.randomUUID();
    @InjectMocks
    private GenerateEventsForDemo generateEventsForDemo;

    @BeforeEach
    void setUp() {
        generateEventsForDemo = new GenerateEventsForDemo(commandGateway, roomAvailabilityEntityRepository,
                                                          uuidProvider);
        when(uuidProvider.getAccountId()).thenReturn(accountId);
        when(uuidProvider.getBookingId()).thenReturn(bookingId);
        when(uuidProvider.getPaymentId()).thenReturn(paymentId);
    }

    @Test
    void sendCommandsForBookingTest(){
        generateEventsForDemo.sendCommandsForBooking();
        verifySendCommands();
        verifySendAndWaitCommands();
    }

    @Test
    void doNotAddRoomsWhenRoomsAlreadyExist(){
        when(roomAvailabilityEntityRepository.existsById(100)).thenReturn(true);
        generateEventsForDemo.sendCommandsForBooking();
        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);
        verify(commandGateway, times(38)).send(commandSendCaptor.capture());
       assertEquals(0L, commandSendCaptor.getAllValues().stream().filter(o -> o instanceof AddRoomCommand).count());
    }

    private void verifySendCommands() {
        ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);
        verify(commandGateway, times(NUMBER_OF_SEND_COMMANDS)).send(commandSendCaptor.capture());

        List<AddRoomCommand> addRoomCommandList = new ArrayList<>();
        List<RegisterAccountCommand> registerAccountCommandList = new ArrayList<>();
        List<BookRoomCommand> bookRoomCommandList = new ArrayList<>();
        List<CheckOutCommand> checkOutCommandList = new ArrayList<>();
        List<ProcessPaymentCommand> processPaymentCommands = new ArrayList<>();
        List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList = new ArrayList<>();
        List<CheckInCommand> checkInCommandList = new ArrayList<>();

        for (Object command : commandSendCaptor.getAllValues()){
            if (command instanceof AddRoomCommand){
                addRoomCommandList.add((AddRoomCommand) command);
            }
            if (command instanceof RegisterAccountCommand){
                registerAccountCommandList.add((RegisterAccountCommand) command);
            }
            if (command instanceof BookRoomCommand){
                bookRoomCommandList.add((BookRoomCommand) command);
            }
            if (command instanceof CheckOutCommand){
                checkOutCommandList.add((CheckOutCommand) command);
            }
            if (command instanceof ProcessPaymentCommand){
                processPaymentCommands.add((ProcessPaymentCommand) command);
            }
            if (command instanceof MarkRoomAsPreparedCommand){
                markRoomAsPreparedCommandList.add((MarkRoomAsPreparedCommand) command);
            }
            if (command instanceof CheckInCommand){
                checkInCommandList.add((CheckInCommand) command);
            }

        }
        assertEquals(NUMBER_OF_ADD_ROOM_COMMANDS, addRoomCommandList.size());
        assertEquals(NUMBER_OF_REGISTER_ACCOUNT_COMMANDS, registerAccountCommandList.size());
        assertEquals(NUMBER_OF_BOOK_ROOM_COMMANDS, bookRoomCommandList.size());
        assertEquals(NUMBER_OF_CHECK_OUT_COMMANDS, checkOutCommandList.size());
        assertEquals(NUMBER_OF_PROCESS_PAYMENT_COMMANDS, processPaymentCommands.size());
        assertEquals(NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS, markRoomAsPreparedCommandList.size());
        assertEquals(NUMBER_OF_CHECK_IN_COMMANDS, checkInCommandList.size());

        checkAddRoomCommands(addRoomCommandList);
        checkRegisterAccountCommands(registerAccountCommandList);
        IntStream.range(100, 105).forEach(roomNumber -> checkBookRoomCommands(bookRoomCommandList, roomNumber));
        IntStream.range(100, 105).forEach(roomNumber -> checkMarkRoomAsPreparedCommand(markRoomAsPreparedCommandList, roomNumber));
        IntStream.range(100, 105).forEach(roomNumber -> checkCheckInCommand(checkInCommandList, roomNumber));
        IntStream.range(100, 105).forEach(roomNumber -> checkCheckOutCommand(checkOutCommandList, roomNumber));
        checkProcessPaymentCommands(processPaymentCommands);
    }

    private void verifySendAndWaitCommands() {
        ArgumentCaptor<Object> commandSendAndWaitCaptor = ArgumentCaptor.forClass(Object.class);
        verify(commandGateway, times(NUMBER_OF_SEND_AND_WAIT_COMMANDS)).sendAndWait(commandSendAndWaitCaptor.capture());


        List<PayCommand> payCommandList = new ArrayList<>();

        for (Object command: commandSendAndWaitCaptor.getAllValues()){

            if (command instanceof PayCommand){
                payCommandList.add((PayCommand) command);
            }
        }
        assertEquals(NUMBER_OF_PAY_COMMANDS, payCommandList.size());
        checkPayCommands(payCommandList);
    }


    private void checkAddRoomCommands(List<AddRoomCommand> addRoomCommandsList) {
        IntStream.range(100, 105).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_SEA_SIDE_DESCRIPTION));
        IntStream.range(105, 110).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, SINGLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));
        IntStream.range(200, 205).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_SEA_SIDE_DESCRIPTION));
        IntStream.range(205, 210).forEach(roomNumber -> checkAddRoomCommand(addRoomCommandsList, roomNumber, DOUBLE_ROOM_MOUNTAIN_SIDE_DESCRIPTION));
    }

    private void checkAddRoomCommand(List<AddRoomCommand> addRoomCommandsList, int roomNumber, String roomDescription){
        assertTrue(addRoomCommandsList.contains(new AddRoomCommand(roomNumber, roomDescription)));
    }

    private void checkRegisterAccountCommands(List<RegisterAccountCommand> registerAccountCommandList){
        assertTrue(registerAccountCommandList.contains(new RegisterAccountCommand(accountId,String.format(USER_NAME_FORMAT,
                                                                                                      accountId), USER_PASSWORD)));
    }

    private void checkBookRoomCommands(List<BookRoomCommand> bookRoomCommandList, int roomNumber){
        assertTrue(bookRoomCommandList.stream().anyMatch(bookRoomCommand -> checkBookRoomCommand(bookRoomCommand, roomNumber)));
    }

    private boolean checkBookRoomCommand(BookRoomCommand bookRoomCommand, int roomNumber) {
        return bookRoomCommand.getRoomNumber() == roomNumber && bookRoomCommand.getRoomBooking().getAccountID().equals(accountId) && bookRoomCommand.getRoomBooking().getBookingId().equals(bookingId);
    }

    private void  checkMarkRoomAsPreparedCommand(List<MarkRoomAsPreparedCommand> markRoomAsPreparedCommandList, int roomNumber){
        assertTrue(markRoomAsPreparedCommandList.contains(new MarkRoomAsPreparedCommand(roomNumber, bookingId)));
    }
    private void  checkCheckInCommand(List<CheckInCommand> checkInCommandList, int roomNumber){
        assertTrue(checkInCommandList.contains(new CheckInCommand(roomNumber, bookingId)));
    }

    private void  checkCheckOutCommand(List<CheckOutCommand> checkOutCommandList, int roomNumber){
        assertTrue(checkOutCommandList.contains(new CheckOutCommand(roomNumber, bookingId)));
    }

    private void checkPayCommands(List<PayCommand> payCommandList){
        assertTrue(payCommandList.contains(new PayCommand(paymentId, accountId, TOTAL_BOOKING_AMOUNT)));
    }
    private void checkProcessPaymentCommands(List<ProcessPaymentCommand> processPaymentCommandList){
        assertTrue(processPaymentCommandList.contains(new ProcessPaymentCommand(paymentId)));
    }
}
```


Overlapping Code:
```
c class GenerateEventsForDemoTest {
private static int NUMBER_OF_SEND_COMMANDS = 58;
private static int NUMBER_OF_SEND_AND_WAIT_COMMANDS = 9;
private static final int NUMBER_OF_ADD_ROOM_COMMANDS = 20;
private static final int NUMBER_OF_PAY_COMMANDS = 9;
private static final int NUMBER_OF_REGISTER_ACCOUNT_COMMANDS = 9;
private static final int NUMBER_OF_BOOK_ROOM_COMMANDS = 5;
private static final int NUMBER_OF_CHECK_OUT_COMMANDS = 5;
private static final int NUMBER_OF_MARK_ROOM_AS_PREPARED_COMMANDS = 5;
private static final int NUMBER_OF_CHECK_IN_COMMANDS = 5;
private static final int NUMBER_OF_PROCESS_PAYMENT_COMMANDS = 9;
private CommandGateway commandGateway = mock(CommandGateway.class);
private RoomAvailabilityEntityRepository roomAvailabilityEntityRepository = mock(RoomAvailabilityEntityRepository.class);
private UUIDProvider uuidProvider = mock(UUIDProvider.class);
private UUID accountId = UUID.randomUUID();
private UUID bookingId = UUID.randomUUID();
private UUID paymentId = UUID.randomUUID();
@InjectMocks
private GenerateEventsForDemo generateEventsForDemo;
@BeforeEach
void setUp() {
generateEventsForDemo = new GenerateEventsForDemo(commandGateway, roomAvailabilityEntityRepository,
uuidProvider);
when(uuidProvider.getAccountId()).thenReturn(accountId);
when(uuidProvider.getBookingId()).thenReturn(bookingId);
when(uuidProvider.getPaymentId()).thenReturn(paymentId);
}
@Test
void sendCommandsForBookingTest(){
generateEventsForDemo.sendCommandsForBooking();
verifySendCommands();
verifySendAndWaitCommands();
}
@Test
void doNotAddRoomsWhenRoomsAlreadyExist(){
when(roomAvailabilityEntityRepository.existsById(100)).thenReturn(true);
generateEventsForDemo.sendCommandsForBooking();
ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);
verify(commandGateway, times(38)).send(commandSendCaptor.capture());
assertEquals(0L, commandSendCaptor.getAllValues().stream().filter(o -> o instanceof AddRoomCommand).count());
}
private void verifySendCommands() {
ArgumentCaptor<Object> commandSendCaptor = ArgumentCaptor.forClass(Object.class);
verify(commandGateway, times(NUMBER_OF_SEND_COMMANDS)).send(
```
<Overlap Ratio: 0.9759418974126192>

---

--- 275 --
Question ID: dfb32e9c49a19af0e3aea7c6d0ab514b6801562c_0
Original Code:
```
public class PropertiesUtil {
    
    /**
     * 
     * @param file
     * @return the properties if the file exists, or null if the file does not exist
     * @throws IOException if there is an error reading the file
     */
    public static Properties load(File file) throws IOException {
        if( !file.exists() ) { return null; }
        try(FileInputStream in = new FileInputStream(file)) {
            Properties properties = new Properties();
            properties.load(in);
            return properties;
        }
    }
    
    /**
     * 
     * @param file
     * @return the properties loaded from file; never null
     * @throws FileNotFoundException if the file is not found
     * @throws IOException if there is an error reading the file
     */
    public static Properties loadExisting(File file) throws FileNotFoundException, IOException {
        try(FileInputStream in = new FileInputStream(file)) {
            Properties properties = new Properties();
            properties.load(in);
            return properties;
        }
    }
    
    public static Properties replacePrefix(Properties properties, String prefix, String replace) {
        Properties copy = new Properties();
        Enumeration names = properties.propertyNames();
        while(names.hasMoreElements()) {
            String key = (String)names.nextElement();
            copy.setProperty(key.replace(prefix, replace), properties.getProperty(key));
        }
        return copy;
    }

    public static Properties removePrefix(Properties properties, String prefix) {
        return replacePrefix(properties, prefix, "");
    }

    public static Properties addPrefix(Properties properties, String prefix) {
        Properties copy = new Properties();
        Enumeration names = properties.propertyNames();
        while(names.hasMoreElements()) {
            String key = (String)names.nextElement();
            copy.setProperty(prefix+key, properties.getProperty(key));
        }
        return copy;
    }    
    
}
```


Overlapping Code:
```
 {

/**
* 
* @param file
* @return the properties if the file exists, or null if the file does not exist
* @throws IOException if there is an error reading the file
*/
public static Properties load(File file) throws IOException {
if( !file.exists() ) { return null; }
try(FileInputStream in = new FileInputStream(file)) {
Properties properties = new Properties();
properties.load(in);
return properties;
}
}

/**
* 
* @param file
* @return the properties loaded from file; never null
* @throws FileNotFoundException if the file is not found
* @throws IOException if there is an error reading the file
*/
public static Properties loadExisting(File file) throws FileNotFoundException, IOException {
try(FileInputStream in = new FileInputStream(file)) {
Properties properties = new Properties();
properties.load(in);
return properties;
}
}

public static Properties replacePrefix(Properties properties, String prefix, String replace) {
Properties copy = new Properties();
Enumeration names = properties.propertyNames();
while(names.hasMoreElements()) {
String key = (String)names.nextElement();
copy.setProperty(key.replace(prefix, replace), properties.getProperty(key));
}
return copy;
}
public static Properties removePrefix(Properties properties, String prefix) {
return replacePrefix(properties, prefix, "");
}
public static Properties addPrefix(Properties properties, String prefix) {
Properties copy = new Properties();
Enumeration names = properties.propertyNames();
while(names.hasMoreElements()) {
String key = (String)names.nextElement();
copy.setProperty(prefix+key, properties.getProperty(ke
```
<Overlap Ratio: 0.9685230024213075>

---

--- 276 --
Question ID: 992af0e005facaad163ec2e5e5ed238d810ac350_0
Original Code:
```
public class Navigations {

    /**
     * Returns the next step position to navigate to.
     * In case an error key was set in the runtime services, throw an error event and return null.
     *
     * @param runEnv                   the run environment
     * @param systemContext            the system context
     * @param currentStepId            the current step's id
     * @return the step id the score engine needs to navigate to the next step
     */
    public Long navigate(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv,
                         @Param(SYSTEM_CONTEXT) SystemContext systemContext,
                         @Param(CURRENT_STEP_ID_KEY) Long currentStepId) {

        if (shouldPause(systemContext)) {
            return currentStepId;
        }

        // If we have an error key stored, we fire an error event and return null as the next position
        if (systemContext.hasStepErrorKey()) {
            AbstractExecutionData.fireEvent(
                    systemContext,
                runEnv,
                ScoreLangConstants.SLANG_EXECUTION_EXCEPTION,
                "Error detected during step",
                LanguageEventData.StepType.NAVIGATION,
                null,
                extractContext(runEnv),
                Pair.of(LanguageEventData.EXCEPTION, systemContext.getStepErrorKey()));
            throw new RuntimeException(systemContext.getStepErrorKey());
        }

        // return the next step position from the run env
        return runEnv.removeNextStepPosition();

    }

    private boolean shouldPause(SystemContext systemContext) {
        return systemContext.isPaused() && !systemContext.hasStepErrorKey();
    }

    private Map<String, Value> extractContext(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv) {
        Context context = runEnv.getStack().popContext();
        Map<String, Value> contextMap;
        if (context != null) {
            runEnv.getStack().pushContext(context);
            contextMap = context.getImmutableViewOfVariables();
        } else {
            contextMap = new HashMap<>();
        }
        return contextMap;
    }

}
```


Overlapping Code:
```
tions {
/**
* Returns the next step position to navigate to.
* In case an error key was set in the runtime services, throw an error event and return null.
*
* @param runEnv the run environment
* @param systemContext the system context
* @param currentStepId the current step's id
* @return the step id the score engine needs to navigate to the next step
*/
public Long navigate(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv,
@Param(SYSTEM_CONTEXT) SystemContext systemContext,
@Param(CURRENT_STEP_ID_KEY) Long currentStepId) {
if (shouldPause(systemContext)) {
return currentStepId;
}
// If we have an error key stored, we fire an error event and return null as the next position
if (systemContext.hasStepErrorKey()) {
AbstractExecutionData.fireEvent(
systemContext,
runEnv,
ScoreLangConstants.SLANG_EXECUTION_EXCEPTION,
"Error detected during step",
LanguageEventData.StepType.NAVIGATION,
null,
extractContext(runEnv),
Pair.of(LanguageEventData.EXCEPTION, systemContext.getStepErrorKey()));
throw new RuntimeException(systemContext.getStepErrorKey());
}
// return the next step position from the run env
return runEnv.removeNextStepPosition();
}
private boolean shouldPause(SystemContext systemContext) {
return systemContext.isPaused() && !systemContext.hasStepErrorKey();
}
private Map<String, Value> extractContext(@Param(ScoreLangConstants.RUN_ENV) RunEnvironment runEnv) {
Context context = runEnv.getStack().popContext();
Map<String, Value> contextMap;
if (context != null) {
runEnv.getStack().pushContext(context);
contextMap = context.getImmutableViewOfVariables();
} else {
conte
```
<Overlap Ratio: 0.9592326139088729>

---

--- 277 --
Question ID: 8f6ca7f8a4c249019b6cd8fd1c342027c3632b68_0
Original Code:
```
public class HourlyTemperatureDewPointCommandTest {

    @BeforeEach
    public void setup() {
        Messages.getInstance().setLocale(Locale.ENGLISH);
    }

    @Test
    public void testExecute() {
        Command command = new HourlyTemperatureDewPointCommand();
        StringBuilder sb = new StringBuilder();
        assertThat(command.execute("T00261015", sb), Matchers.emptyString());
        assertThat(sb.toString(), Matchers.containsString("hourly temperature of 2.6°C and dew point of -1.5°C"));
    }

    @Test
    public void testExecuteOnlyTemperature() {
        Command command = new HourlyTemperatureDewPointCommand();
        StringBuilder sb = new StringBuilder();
        assertEquals("AO1", command.execute("T0026 AO1", sb));
        assertThat(sb.toString(), Matchers.containsString("hourly temperature of 2.6°C"));
        assertThat(sb.toString(), Matchers.not(Matchers.containsString("dew point of")));
    }

    @Test
    public void testCanParse() {
        Command command = new HourlyTemperatureDewPointCommand();
        assertTrue(command.canParse("T0026"));
    }

}
```


Overlapping Code:
```
blic class HourlyTemperatureDewPointCommandTest {
@BeforeEach
public void setup() {
Messages.getInstance().setLocale(Locale.ENGLISH);
}
@Test
public void testExecute() {
Command command = new HourlyTemperatureDewPointCommand();
StringBuilder sb = new StringBuilder();
assertThat(command.execute("T00261015", sb), Matchers.emptyString());
assertThat(sb.toString(), Matchers.containsString("hourly temperature of 2.6°C and dew point of -1.5°C"));
}
@Test
public void testExecuteOnlyTemperature() {
Command command = new HourlyTemperatureDewPointCommand();
StringBuilder sb = new StringBuilder();
assertEquals("AO1", command.execute("T0026 AO1", sb));
assertThat(sb.toString(), Matchers.containsString("hourly temperature of 2.6°C"));
assertThat(sb.toString(), Matchers.not(Matchers.containsString("dew point of")));
}
@Test
public void testCanParse() {
Command command = new HourlyTemperatureDewPointCommand();
assertTrue(command.canParse("T0026"));
}

```
<Overlap Ratio: 0.9968520461699895>

---

--- 278 --
Question ID: 2a2ed52eef7e140b7ed18778ee17e63c4b72238e_0
Original Code:
```
@Singleton
public class PortalManager implements IPortalManager    {
    private final Logger logger;
    private final IPortalPredicateManager predicateManager;
    private final IPortalActivityManager portalActivityManager;

    // Multiple portals can have the same origin position
    private final Map<Location, Set<IPortal>> portals = new HashMap<>();
    private final Map<UUID, IPortal> portalsById = new HashMap<>();

    @Inject
    public PortalManager(Logger logger, IPortalPredicateManager predicateManager, IPortalActivityManager portalActivityManager) {
        this.logger = logger;
        this.predicateManager = predicateManager;
        this.portalActivityManager = portalActivityManager;
    }

    @Override
    public Collection<IPortal> getAllPortals() {
        return portalsById.values();
    }

    @Override
    public Collection<IPortal> getPortalsAt(Location originLoc) {
        Set<IPortal> portalsAtLoc = portals.get(originLoc);
        return portalsAtLoc == null ? Collections.emptyList() : portalsAtLoc;
    }

    @Override
    public IPortal getPortalById(@Nullable UUID id) {
        return portalsById.get(id);
    }

    @Override
    public IPortal findClosestPortal(@NotNull Location position, double maximumDistance, Predicate<IPortal> predicate) {
        IPortal currentClosest = null;
        double currentClosestDistance = maximumDistance;
        for(Map.Entry<Location, Set<IPortal>> entry : portals.entrySet()) {

            Location portalPos = entry.getKey();
            // Avoid throwing an exception when portals not in this world are checked
            if(portalPos.getWorld() != position.getWorld()) {continue;}
            double distance = portalPos.distance(position);

            if(distance >= currentClosestDistance) {continue;}

            // Check to see if any portals here match the predicate
            for(IPortal portal : entry.getValue()) {
                if(!predicate.test(portal)) {continue;}

                currentClosest = portal;
                currentClosestDistance = distance;
                break;
            }
        }

        return currentClosest;
    }

    @Override
    public @NotNull Collection<IPortal> findActivatablePortals(@NotNull Player player) {
        List<IPortal> result = new ArrayList<>();

        for(Set<IPortal> portalSet : portals.values()) {
            for(IPortal portal : portalSet) {
                // Test that the portal passes all predicates for activation
                if(predicateManager.isActivatable(portal, player)) {
                    result.add(portal);
                }
            }
        }

        return result;
    }

    @Override
    public void registerPortal(@NotNull IPortal portal) {
        logger.fine("Registering portal with origin position %s", portal.getOriginPos());

        // Add a new portal array if one doesn't already exist for this location
        Location originLoc = portal.getOriginPos().getLocation();
        if(!portals.containsKey(originLoc)) {
            portals.put(originLoc, new HashSet<>());
        }
        portalsById.put(portal.getId(), portal);

        portals.get(originLoc).add(portal);
    }

    @Override
    public int removePortalsAt(@NotNull Location originLoc) {
        Set<IPortal> portalsRemoved = portals.remove(originLoc);
        if(portalsRemoved == null) {return 0;}

        // Make sure to also remove them from the ID map
        for(IPortal portal : portalsRemoved) {
            portalsById.remove(portal.getId());
        }

        logger.fine("Unregistering %d portal(s) at position %s", portalsRemoved.size(), originLoc);
        return portalsRemoved.size();
    }

    @Override
    public boolean removePortal(@NotNull IPortal portal) {
        logger.fine("Unregistering portal at position %s", portal.getOriginPos().getLocation());

        Set<IPortal> portalsAtLoc = portals.get(portal.getOriginPos().getLocation());
        if(portalsAtLoc == null) {return false;}

        boolean wasRemoved = portalsAtLoc.remove(portal);
        // Remove the portal array if there are no longer any portals at this location
        if(portalsAtLoc.size() == 0) {
            portals.remove(portal.getOriginPos().getLocation());
        }
        portalsById.remove(portal.getId());
        return wasRemoved;
    }

    @Override
    public boolean removePortalById(@NotNull UUID id) {
        IPortal removed = portalsById.remove(id);
        if(removed == null) {return false;}
        removePortal(removed); // Also remove it in the location map

        return true;
    }

    @Override
    public void onReload() {
        portalActivityManager.resetActivity();
    }
}
```


Overlapping Code:
```
eton
public class PortalManager implements IPortalManager {
private final Logger logger;
private final IPortalPredicateManager predicateManager;
private final IPortalActivityManager portalActivityManager;
// Multiple portals can have the same origin position
private final Map<Location, Set<IPortal>> portals = new HashMap<>();
private final Map<UUID, IPortal> portalsById = new HashMap<>();
@Inject
public PortalManager(Logger logger, IPortalPredicateManager predicateManager, IPortalActivityManager portalActivityManager) {
this.logger = logger;
this.predicateManager = predicateManager;
this.portalActivityManager = portalActivityManager;
}
@Override
public Collection<IPortal> getAllPortals() {
return portalsById.values();
}
@Override
public Collection<IPortal> getPortalsAt(Location originLoc) {
Set<IPortal> portalsAtLoc = portals.get(originLoc);
return portalsAtLoc == null ? Collections.emptyList() : portalsAtLoc;
}
@Override
public IPortal getPortalById(@Nullable UUID id) {
return portalsById.get(id);
}
@Override
public IPortal findClosestPortal(@NotNull Location position, double maximumDistance, Predicate<IPortal> predicate) {
IPortal currentClosest = null;
double currentClosestDistance = maximumDistance;
for(Map.Entry<Location, Set<IPortal>> entry : portals.entrySet()) {
Location portalPos = entry.getKey();
// Avoid throwing an exception when portals not in this world are checked
if(portalPos.getWorld() != position.getWorld()) {continue;}
double distance = portalPos.distance(position);
if(distance >= currentClosestDistance) {continue;}
// Check to see if any portals here match the predicate
for(IPortal portal : entry.getValue()) {
if(!predicate.test(portal)) {continue;}
currentClosest = portal;
currentClosestDistance = distance;
break;
}
}
return currentClosest;
}
@Override
public @NotNull Collection<IPortal> findActivatablePortals(@NotNull Player player) {
List<IPortal> result = new ArrayList<>();
for(Set<IPortal> portalSet : portals.values()) {
for(IPortal portal : portalSet) {
// Test that the portal passes all p
```
<Overlap Ratio: 0.9855769230769231>

---

--- 279 --
Question ID: 887bfe128d61bb37141f71e6cdaeb3044bc6271d_0
Original Code:
```
public class TmmLabelUI extends BaseLabelUI {

  private static TmmLabelUI labelUI = null;

  public static ComponentUI createUI(JComponent c) {
    if (labelUI == null) {
      labelUI = new TmmLabelUI();
    }
    return labelUI;
  }

  /**
   * this class supports clip the string on the left/middle/right
   */
  protected String layoutCL(JLabel label, FontMetrics fontMetrics, String text, Icon icon, Rectangle viewR, Rectangle iconR, Rectangle textR) {
    String stringFromSwingUtilities = SwingUtilities.layoutCompoundLabel(label, fontMetrics, text, icon, label.getVerticalAlignment(),
        label.getHorizontalAlignment(), label.getVerticalTextPosition(), label.getHorizontalTextPosition(), viewR, iconR, textR,
        label.getIconTextGap());

    int clipPosition = getClipPosition(label);

    switch (clipPosition) {
      case SwingConstants.LEFT:
      case SwingConstants.CENTER:
        return reLayoutString(label, clipPosition, text, stringFromSwingUtilities);

      case SwingConstants.RIGHT:
      default:
        return stringFromSwingUtilities;
    }
  }

  private int getClipPosition(JLabel label) {
    Object prop = label.getClientProperty("clipPosition");
    if (prop != null && prop instanceof Integer) {
      if ((Integer) prop == SwingConstants.LEFT) {
        return SwingConstants.LEFT;
      }
      else if ((Integer) prop == SwingConstants.RIGHT) {
        return SwingConstants.RIGHT;
      }
      else if ((Integer) prop == SwingConstants.CENTER) {
        return SwingConstants.CENTER;
      }
    }
    return SwingConstants.RIGHT;
  }

  private String reLayoutString(JLabel label, int clipPosition, String originalText, String stringFromSwingUtilities) {
    // clipping needed?
    if (!stringFromSwingUtilities.endsWith("...")) {
      return stringFromSwingUtilities;
    }

    String dots = "...";
    FontMetrics fm = label.getFontMetrics(label.getFont());
    int targetStringWidth = fm.stringWidth(stringFromSwingUtilities);

    if (clipPosition == SwingConstants.LEFT) {
      int i = originalText.length() - stringFromSwingUtilities.length();
      if (i < 0) {
        return stringFromSwingUtilities;
      }
      for (; i < originalText.length(); i++) {
        String substring = dots + originalText.substring(i);
        if (fm.stringWidth(substring) <= targetStringWidth) {
          return substring;
        }
      }
    }
    else if (clipPosition == SwingConstants.CENTER) {
      int i = stringFromSwingUtilities.length() / 2;
      if (i < 0) {
        return stringFromSwingUtilities;
      }
      for (; i > 0; i--) {
        String substring = originalText.substring(0, i) + dots + originalText.substring(originalText.length() - i);
        if (fm.stringWidth(substring) <= targetStringWidth) {
          return substring;
        }
      }
    }

    return stringFromSwingUtilities;
  }
}
```


Overlapping Code:
```
eLabelUI {
private static TmmLabelUI labelUI = null;
public static ComponentUI createUI(JComponent c) {
if (labelUI == null) {
labelUI = new TmmLabelUI();
}
return labelUI;
}
/**
* this class supports clip the string on the left/middle/right
*/
protected String layoutCL(JLabel label, FontMetrics fontMetrics, String text, Icon icon, Rectangle viewR, Rectangle iconR, Rectangle textR) {
String stringFromSwingUtilities = SwingUtilities.layoutCompoundLabel(label, fontMetrics, text, icon, label.getVerticalAlignment(),
label.getHorizontalAlignment(), label.getVerticalTextPosition(), label.getHorizontalTextPosition(), viewR, iconR, textR,
label.getIconTextGap());
int clipPosition = getClipPosition(label);
switch (clipPosition) {
case SwingConstants.LEFT:
case SwingConstants.CENTER:
return reLayoutString(label, clipPosition, text, stringFromSwingUtilities);
case SwingConstants.RIGHT:
default:
return stringFromSwingUtilities;
}
}
private int getClipPosition(JLabel label) {
Object prop = label.getClientProperty("clipPosition");
if (prop != null && prop instanceof Integer) {
if ((Integer) prop == SwingConstants.LEFT) {
return SwingConstants.LEFT;
}
else if ((Integer) prop == SwingConstants.RIGHT) {
return SwingConstants.RIGHT;
}
else if ((Integer) prop == SwingConstants.CENTER) {
return SwingConstants.CENTER;
}
}
return SwingConstants.RIGHT;
}
private String reLayoutString(JLabel label, int clipPosition, String originalText, String stringFromSwingUtilities) {
// clipping needed?
if (!stringFromSwingUtilities.endsWith("...")) {
return stringFromSwingUtilities;
}
String dots = "...";
FontMetrics fm = label.getFontMetrics(label.getFont());
int targetStringWidth = fm.stringWidth(stringFromSwingUtilities);
if (clipPosition == SwingConstants.LEFT) {
int i = originalText.length() - stringFromSwingUtilities.length();
if (i < 0) {
return stringFromSwingUtilities;
}
for (; i < originalText.length(); i++) {
String substring = dots + originalText.substring(i);
if (fm.stringWidth(substring) <= targetStringWidth) {
return substring;
}
}
}
else if (clipPosition == SwingConstants.CENTER) {
i
```
<Overlap Ratio: 0.9637448370812299>

---

--- 280 --
Question ID: caaaa23e4bcbae8f5db496386b22ad54f3c69403_0
Original Code:
```
@Deprecated
public class SpecDependent<V> {

  private static List<SpecDependent<?>> allDependents = new CopyOnWriteArrayList<>();

  public static <V> SpecDependent<V> of(Supplier<V> supplier) {
    SpecDependent<V> ret = new SpecDependent<>(supplier);
    allDependents.add(ret);
    return ret;
  }

  public static void resetAll() {
    allDependents.forEach(SpecDependent::reset);
  }

  private final Supplier<V> supplier;
  private volatile V cached = null;

  private SpecDependent(Supplier<V> supplier) {
    this.supplier = supplier;
  }

  public V get() {
    V cachedLoc = this.cached;
    if (cachedLoc != null) {
      return cachedLoc;
    } else {
      V newValue = supplier.get();
      this.cached = newValue;
      return newValue;
    }
  }

  public void reset() {
    cached = null;
  }

  public <R> SpecDependent<R> map(Function<V, R> mapper) {
    return of(() -> mapper.apply(get()));
  }
}
```


Overlapping Code:
```
ed
public class SpecDependent<V> {
private static List<SpecDependent<?>> allDependents = new CopyOnWriteArrayList<>();
public static <V> SpecDependent<V> of(Supplier<V> supplier) {
SpecDependent<V> ret = new SpecDependent<>(supplier);
allDependents.add(ret);
return ret;
}
public static void resetAll() {
allDependents.forEach(SpecDependent::reset);
}
private final Supplier<V> supplier;
private volatile V cached = null;
private SpecDependent(Supplier<V> supplier) {
this.supplier = supplier;
}
public V get() {
V cachedLoc = this.cached;
if (cachedLoc != null) {
return cachedLoc;
} else {
V newValue = supplier.get();
this.cached = newValue;
return newValue;
}
}
public void reset() {
cached = null;
}
public <R> SpecDependent<R> map(Function<V, R> mapper) {
return of(() -> mapper.apply(get()));

```
<Overlap Ratio: 0.9852216748768473>

---

--- 281 --
Question ID: d4584644392e9448db7bdd0027ce488f8c1bb4bf_0
Original Code:
```
public class ValueClamperTest
    extends TestCase
{
    /**
     * Creates a new test.
     *
     * @param   testName The test name.
     */
    public ValueClamperTest(
        String testName)
    {
        super(testName);
    }
    
    /**
     * Test of constructors of class ValueClamper.
     */
    public void testConstructors()
    {
        Double minimum = null;
        Double maximum = null;
        ValueClamper<Double> instance = new ValueClamper<Double>();
        assertSame(minimum, instance.getMinimum());
        assertSame(maximum, instance.getMaximum());
        
        minimum = 10.01;
        maximum = 20.02;
        instance = new ValueClamper<Double>(minimum, maximum);
        assertSame(minimum, instance.getMinimum());
        assertSame(maximum, instance.getMaximum());
    }

    public void testClone()
    {
        System.out.println( "Clone" );

        Double minimum = 10.0;
        Double maximum = 20.0;
        ValueClamper<Double> instance = new ValueClamper<Double>(minimum, maximum);
        ValueClamper<Double> clone = instance.clone();
        assertNotNull( clone );
        assertNotSame( instance, clone );


    }

    /**
     * Test of evaluate method, of class ValueClamper.
     */
    public void testEvaluate()
    {
        Double minimum = 10.01;
        Double maximum = 20.02;
        Double input = 0.0;
        ValueClamper<Double> instance = new ValueClamper<Double>(
            minimum, maximum);

        assertNull( instance.evaluate(null) );

        input = 15.51;
        assertSame(input, instance.evaluate(input));
        
        input = 10.00;
        assertSame(minimum, instance.evaluate(input));
        
        input = 20.03;
        assertSame(maximum, instance.evaluate(input));
        
        input = 0.0;
        instance.setMinimum(null);
        assertSame(input, instance.evaluate(input));
        
        input = 40.00;
        instance.setMaximum(null);
        assertSame(input, instance.evaluate(input));
    }

    /**
     * Test of getMinimum method, of class ValueClamper.
     */
    public void testGetMinimum()
    {
        this.testSetMinimum();
    }

    /**
     * Test of setMinimum method, of class ValueClamper.
     */
    public void testSetMinimum()
    {
        Double minimum = null;
        ValueClamper<Double> instance = new ValueClamper<Double>();
        assertSame(minimum, instance.getMinimum());
        
        minimum = 20.08;
        instance.setMinimum(minimum);
        assertSame(minimum, instance.getMinimum());
        
        minimum = 10.03;
        instance.setMinimum(minimum);
        assertSame(minimum, instance.getMinimum());
        
        minimum = null;
        instance.setMinimum(minimum);
        assertSame(minimum, instance.getMinimum());
    }

    /**
     * Test of getMaximum method, of class ValueClamper.
     */
    public void testGetMaximum()
    {
        this.testSetMaximum();
    }

    /**
     * Test of setMaximum method, of class ValueClamper.
     */
    public void testSetMaximum()
    {
        Double maximum = null;
        ValueClamper<Double> instance = new ValueClamper<Double>();
        assertSame(maximum, instance.getMaximum());
        
        maximum = 20.08;
        instance.setMaximum(maximum);
        assertSame(maximum, instance.getMaximum());
        
        maximum = 10.03;
        instance.setMaximum(maximum);
        assertSame(maximum, instance.getMaximum());
        
        maximum = null;
        instance.setMaximum(maximum);
        assertSame(maximum, instance.getMaximum());
    }

}
```


Overlapping Code:
```
est
extends TestCase
{
/**
* Creates a new test.
*
* @param testName The test name.
*/
public ValueClamperTest(
String testName)
{
super(testName);
}

/**
* Test of constructors of class ValueClamper.
*/
public void testConstructors()
{
Double minimum = null;
Double maximum = null;
ValueClamper<Double> instance = new ValueClamper<Double>();
assertSame(minimum, instance.getMinimum());
assertSame(maximum, instance.getMaximum());

minimum = 10.01;
maximum = 20.02;
instance = new ValueClamper<Double>(minimum, maximum);
assertSame(minimum, instance.getMinimum());
assertSame(maximum, instance.getMaximum());
}
public void testClone()
{
System.out.println( "Clone" );
Double minimum = 10.0;
Double maximum = 20.0;
ValueClamper<Double> instance = new ValueClamper<Double>(minimum, maximum);
ValueClamper<Double> clone = instance.clone();
assertNotNull( clone );
assertNotSame( instance, clone );
}
/**
* Test of evaluate method, of class ValueClamper.
*/
public void testEvaluate()
{
Double minimum = 10.01;
Double maximum = 20.02;
Double input = 0.0;
ValueClamper<Double> instance = new ValueClamper<Double>(
minimum, maximum);
assertNull( instance.evaluate(null) );
input = 15.51;
assertSame(input, instance.evaluate(input));

input = 10.00;
assertSame(minimum, instance.evaluate(input));

input = 20.03;
assertSame(maximum, instance.evaluate(input));

input = 0.0;
instance.setMinimum(null);
assertSame(input, instance.evaluate(input));

input = 40.00;
instance.setMaximum(null);
assertSame(input, instance.evaluate(input));
}
/**
* Test of getMinimum method, of class ValueClamper.
*/
public void testGetMinimum()
{
this.testSetMinimum();
}
/**
* Test of setMinimum method, of class ValueClamper.
*/
public void testSetMinimum()
{
Double minimum = null;
ValueClamper<Double> instance = new ValueClamper<Double>();
assertSame(minimum, instance.getMinimum());

minimum = 20.08;
instance.setMinimum(minimum
```
<Overlap Ratio: 0.9855222337125129>

---

--- 282 --
Question ID: 4c26605d62dce4f6ede90780d1eb1c63dff18a88_0
Original Code:
```
public class ActionValueHeuristic extends AbstractPlayer implements ToDoubleBiFunction<AbstractAction, AbstractGameState> {

    Random rnd = new Random(System.currentTimeMillis());

    String filename;

    protected double RND_WEIGHT;
    double defaultValue = 0.0;

    Map<String, Map<Integer, Double>> actionValues = new HashMap<>();
    Map<Integer, String> actionNames = new HashMap<>();
    Function<AbstractGameState, String> bucketFunction = s -> "";

    public ActionValueHeuristic(
            Map<String, Map<Integer, Double>> advantages,
            double rndWeight,
            Function<AbstractGameState, String> bucketFn,
            double defaultValue
    ) {
        actionValues = advantages;
        RND_WEIGHT = rndWeight;
        if (bucketFn == null)
            throw new IllegalArgumentException("Must specify a bucket function");
        bucketFunction = bucketFn;
        this.defaultValue = defaultValue;
    }

    public ActionValueHeuristic(String filename) {
        this.filename = filename;
        initialiseFromFile();
    }

    @Override
    public void initializePlayer(AbstractGameState state) {
        initialiseFromFile();
    }

    @SuppressWarnings("unchecked")
    private void initialiseFromFile() {

        try {
            if (filename != null && (new File(filename)).exists()) {
                BufferedReader reader = new BufferedReader(new FileReader(filename));
                String[] header = reader.readLine().split(",");
                RND_WEIGHT = Double.parseDouble(header[0]);
                if (header.length > 1) {
                    try {
                        Class<?> bucketClass = Class.forName(header[1]);
                        bucketFunction = (Function<AbstractGameState, String>) bucketClass.getConstructor().newInstance();
                    } catch (Exception e) {
                        e.printStackTrace();
                        bucketFunction = s -> "";
                    }
                }
                reader.readLine();
                // we expect columns: bucket, hash, value estimate, name (optional)

                String nextLine = reader.readLine();
                while (nextLine != null) {
                    List<String> data = Arrays.stream(nextLine.split(",")).collect(toList());

                    String bucket = data.get(0).trim();
                    Map<Integer, Double> advantages = getActionValues(bucket);

                    int hash = Integer.parseInt(data.get(1).trim());
                    double advantage = Double.parseDouble(data.get(2).trim());
                    advantages.put(hash, advantage);
                    if (data.size() > 3) {
                        String name = data.get(3).trim();
                        actionNames.put(hash, name);
                    }
                    nextLine = reader.readLine();
                }

                reader.close();
            } else {
                System.out.println("File not found : " + filename);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Map<Integer, Double> getActionValues(String bucket) {
        if (!actionValues.containsKey(bucket))
            actionValues.put(bucket, new HashMap<>());
        return actionValues.get(bucket);
    }


    @Override
    public AbstractAction getAction(AbstractGameState gameState, List<AbstractAction> possibleActions) {

        if (possibleActions.size() == 1)
            return possibleActions.get(0);

        double bestValue = Double.NEGATIVE_INFINITY;
        String bucket = bucketFunction.apply(gameState);
        AbstractAction retValue = possibleActions.get(0);

        for (AbstractAction action : possibleActions) {
            double actionValue = actionValue(action, bucket);
            if (actionValue > bestValue) {
                retValue = action;
                bestValue = actionValue;
            }
        }
        return retValue;
    }

    private double actionValue(AbstractAction action, String bucket) {
        Map<Integer, Double> actionValues = getActionValues(bucket);
        Map<Integer, Double> defaultValues = getActionValues("");
        int hash = action.hashCode();
        double actionValue = defaultValue;
        if (actionValues.containsKey(hash)) {
            actionValue = actionValues.get(hash);
        } else if (defaultValues.containsKey(hash)) {
            actionValue = defaultValues.get(hash);
        }

        actionValue += rnd.nextDouble() * RND_WEIGHT;
        actionNames.putIfAbsent(hash, action.toString());
        return actionValue;
    }

    Set<Integer> unknownHashCodes = new HashSet<>();

    @Override
    public double applyAsDouble(AbstractAction abstractAction, AbstractGameState gameState) {
        String bucket = bucketFunction.apply(gameState);
//        if (!actionValues.isEmpty() && !actionValues.containsKey(hash) && !unknownHashCodes.contains(hash)) {
//            unknownHashCodes.add(hash);
//            System.out.println("Action not found : " + hash + " " + abstractAction.toString() + " : " + bucket);
//        }
        return actionValue(abstractAction, bucket);
    }
}
```


Overlapping Code:
```
ristic extends AbstractPlayer implements ToDoubleBiFunction<AbstractAction, AbstractGameState> {
Random rnd = new Random(System.currentTimeMillis());
String filename;
protected double RND_WEIGHT;
double defaultValue = 0.0;
Map<String, Map<Integer, Double>> actionValues = new HashMap<>();
Map<Integer, String> actionNames = new HashMap<>();
Function<AbstractGameState, String> bucketFunction = s -> "";
public ActionValueHeuristic(
Map<String, Map<Integer, Double>> advantages,
double rndWeight,
Function<AbstractGameState, String> bucketFn,
double defaultValue
) {
actionValues = advantages;
RND_WEIGHT = rndWeight;
if (bucketFn == null)
throw new IllegalArgumentException("Must specify a bucket function");
bucketFunction = bucketFn;
this.defaultValue = defaultValue;
}
public ActionValueHeuristic(String filename) {
this.filename = filename;
initialiseFromFile();
}
@Override
public void initializePlayer(AbstractGameState state) {
initialiseFromFile();
}
@SuppressWarnings("unchecked")
private void initialiseFromFile() {
try {
if (filename != null && (new File(filename)).exists()) {
BufferedReader reader = new BufferedReader(new FileReader(filename));
String[] header = reader.readLine().split(",");
RND_WEIGHT = Double.parseDouble(header[0]);
if (header.length > 1) {
try {
Class<?> bucketClass = Class.forName(header[1]);
bucketFunction = (Function<AbstractGameState, String>) bucketClass.getConstructor().newInstance();
} catch (Exception e) {
e.printStackTrace();
bucketFunction = s -> "";
}
}
reader.readLine();
// we expect columns: bucket, hash, value estimate, name (optional)
String nextLine = reader.readLine();
while (nextLine != null) {
List<String> data = Arrays.stream(nextLine.split(",")).collect(toList());
String bucket = data.get(0).trim();
Map<Integer, Double> advantages = getActionValues(bucket);
int hash = Integer.parseI
```
<Overlap Ratio: 0.9762532981530343>

---

--- 283 --
Question ID: bb46907fbd6e776d5797d55cee7cc9ad303026f8_0
Original Code:
```
public final class SessionParameters {
   private int cipherSuite;
   private short compressionAlgorithm;
   private Certificate localCertificate;
   private TlsSecret masterSecret;
   private ProtocolVersion negotiatedVersion;
   private Certificate peerCertificate;
   private byte[] pskIdentity;
   private byte[] srpIdentity;
   private byte[] encodedServerExtensions;

   private SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9) {
      this.pskIdentity = null;
      this.srpIdentity = null;
      this.cipherSuite = var1;
      this.compressionAlgorithm = var2;
      this.localCertificate = var3;
      this.masterSecret = var4;
      this.negotiatedVersion = var5;
      this.peerCertificate = var6;
      this.pskIdentity = Arrays.clone(var7);
      this.srpIdentity = Arrays.clone(var8);
      this.encodedServerExtensions = var9;
   }

   public void clear() {
      if (this.masterSecret != null) {
         this.masterSecret.destroy();
      }

   }

   public SessionParameters copy() {
      return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);
   }

   public int getCipherSuite() {
      return this.cipherSuite;
   }

   public short getCompressionAlgorithm() {
      return this.compressionAlgorithm;
   }

   public Certificate getLocalCertificate() {
      return this.localCertificate;
   }

   public TlsSecret getMasterSecret() {
      return this.masterSecret;
   }

   public ProtocolVersion getNegotiatedVersion() {
      return this.negotiatedVersion;
   }

   public Certificate getPeerCertificate() {
      return this.peerCertificate;
   }

   /** @deprecated */
   public byte[] getPskIdentity() {
      return this.pskIdentity;
   }

   public byte[] getPSKIdentity() {
      return this.pskIdentity;
   }

   public byte[] getSRPIdentity() {
      return this.srpIdentity;
   }

   public Hashtable readServerExtensions() throws IOException {
      if (this.encodedServerExtensions == null) {
         return null;
      } else {
         ByteArrayInputStream var1 = new ByteArrayInputStream(this.encodedServerExtensions);
         return TlsProtocol.readExtensions(var1);
      }
   }

   // $FF: synthetic method
   SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9, Object var10) {
      this(var1, var2, var3, var4, var5, var6, var7, var8, var9);
   }

   public static final class Builder {
      private int cipherSuite = -1;
      private short compressionAlgorithm = -1;
      private Certificate localCertificate = null;
      private TlsSecret masterSecret = null;
      private ProtocolVersion negotiatedVersion;
      private Certificate peerCertificate = null;
      private byte[] pskIdentity = null;
      private byte[] srpIdentity = null;
      private byte[] encodedServerExtensions = null;

      public SessionParameters build() {
         this.validate(this.cipherSuite >= 0, "cipherSuite");
         this.validate(this.compressionAlgorithm >= 0, "compressionAlgorithm");
         this.validate(this.masterSecret != null, "masterSecret");
         return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);
      }

      public SessionParameters.Builder setCipherSuite(int var1) {
         this.cipherSuite = var1;
         return this;
      }

      public SessionParameters.Builder setCompressionAlgorithm(short var1) {
         this.compressionAlgorithm = var1;
         return this;
      }

      public SessionParameters.Builder setLocalCertificate(Certificate var1) {
         this.localCertificate = var1;
         return this;
      }

      public SessionParameters.Builder setMasterSecret(TlsSecret var1) {
         this.masterSecret = var1;
         return this;
      }

      public SessionParameters.Builder setNegotiatedVersion(ProtocolVersion var1) {
         this.negotiatedVersion = var1;
         return this;
      }

      public SessionParameters.Builder setPeerCertificate(Certificate var1) {
         this.peerCertificate = var1;
         return this;
      }

      /** @deprecated */
      public SessionParameters.Builder setPskIdentity(byte[] var1) {
         this.pskIdentity = var1;
         return this;
      }

      public SessionParameters.Builder setPSKIdentity(byte[] var1) {
         this.pskIdentity = var1;
         return this;
      }

      public SessionParameters.Builder setSRPIdentity(byte[] var1) {
         this.srpIdentity = var1;
         return this;
      }

      public SessionParameters.Builder setServerExtensions(Hashtable var1) throws IOException {
         if (var1 == null) {
            this.encodedServerExtensions = null;
         } else {
            ByteArrayOutputStream var2 = new ByteArrayOutputStream();
            TlsProtocol.writeExtensions(var2, var1);
            this.encodedServerExtensions = var2.toByteArray();
         }

         return this;
      }

      private void validate(boolean var1, String var2) {
         if (!var1) {
            throw new IllegalStateException("Required session parameter '" + var2 + "' not configured");
         }
      }
   }
}
```


Overlapping Code:
```
blic final class SessionParameters {
private int cipherSuite;
private short compressionAlgorithm;
private Certificate localCertificate;
private TlsSecret masterSecret;
private ProtocolVersion negotiatedVersion;
private Certificate peerCertificate;
private byte[] pskIdentity;
private byte[] srpIdentity;
private byte[] encodedServerExtensions;
private SessionParameters(int var1, short var2, Certificate var3, TlsSecret var4, ProtocolVersion var5, Certificate var6, byte[] var7, byte[] var8, byte[] var9) {
this.pskIdentity = null;
this.srpIdentity = null;
this.cipherSuite = var1;
this.compressionAlgorithm = var2;
this.localCertificate = var3;
this.masterSecret = var4;
this.negotiatedVersion = var5;
this.peerCertificate = var6;
this.pskIdentity = Arrays.clone(var7);
this.srpIdentity = Arrays.clone(var8);
this.encodedServerExtensions = var9;
}
public void clear() {
if (this.masterSecret != null) {
this.masterSecret.destroy();
}
}
public SessionParameters copy() {
return new SessionParameters(this.cipherSuite, this.compressionAlgorithm, this.localCertificate, this.masterSecret, this.negotiatedVersion, this.peerCertificate, this.pskIdentity, this.srpIdentity, this.encodedServerExtensions);
}
public int getCipherSuite() {
return this.cipherSuite;
}
public short getCompressionAlgorithm() {
return this.compressionAlgorithm;
}
public Certificate getLocalCertificate() {
return this.localCertificate;
}
public TlsSecret getMasterSecret() {
return this.masterSecret;
}
public ProtocolVersion getNegotiatedVersion() {
return this.negotiatedVersion;
}
public Certificate getPeerCertificate() {
return this.peerCertificate;
}
/** @deprecated */
public byte[] getPskIdentity() {
return this.pskIdentity;
}
public byte[] getPSKIdentity() {
return this.pskIdentity;
}
public byte[] getSRPIdentity() {
return this.srpIdentity;
}
public Hashtable readServerExtensions() throws IOException {
if (this.encodedServerExtensions == null) {
return null;
} else {
ByteArrayInputStream var1 = new ByteArrayInputStream(this.encodedServerExtensions);
return TlsProtocol.readExtensions(var1);
}
}
// $FF: synthetic method
SessionParameters(int var1, short var2, 
```
<Overlap Ratio: 0.9871441689623508>

---

--- 284 --
Question ID: f323f9da6a88cae4706fde69a15a962c56d24aa8_0
Original Code:
```
@Singleton
public class GenericEsRestClient implements EsRestClient {
    private static final BasicHeader APPLICATION_JSON_HEADER = new BasicHeader("Content-Type", "application/json");
    private static final BasicHeader APPLICATION_XNDJSON_HEADER = new BasicHeader("Content-Type", "application/x-ndjson");

    private Random random;

    private CloseableHttpClient httpClient;
    private ArrayList<URI> hosts;

    @Override
    public void init(List<URI> hosts, EsConfig config) {
        this.random = new Random();
        this.hosts = new ArrayList<>(hosts);

        RequestConfig requestConfig =
                RequestConfig.custom()
                        .setConnectTimeout(config.getConnectTimeoutSeconds() * 1000)
                        .setSocketTimeout(config.getSocketTimeoutSeconds() * 1000)
                        .setConnectionRequestTimeout(config.getConnectionRequestTimeoutSeconds() * 1000)
                        .build();

        HttpClientBuilder httpClientBuilder =
                HttpClients.custom()
                        .setDefaultRequestConfig(requestConfig)
                        .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false));

        customizeHttpClientBuilder(httpClientBuilder, config);

        this.httpClient = httpClientBuilder.build();
    }

    @Override
    public StatusLine writeSingleDocument(String index, String docType, String id, String document) throws IOException {
        if (this.httpClient == null) {
            throw new RuntimeException("GenericEsRestClient must be initialized");
        }

        HttpPut put = new HttpPut(String.format("%s/%s/%s/%s", selectHost().toString(), index, docType, id));
        put.setEntity(new StringEntity(document));
        put.addHeader(APPLICATION_JSON_HEADER);

        try (CloseableHttpResponse response = this.httpClient.execute(put)) {
            return response.getStatusLine();
        }
    }

    @Override
    public StatusLine readSingleDocument(String index, String docType, String id) throws IOException {
        if (this.httpClient == null) {
            throw new RuntimeException("GenericEsRestClient must be initialized");
        }

        HttpGet get = new HttpGet(String.format("%s/%s/%s/%s", selectHost().toString(), index, docType, id));
        try (CloseableHttpResponse response = this.httpClient.execute(get)) {
            return response.getStatusLine();
        }
    }

    @Override
    public StatusLine writeDocumentsBulk(String bulkPayload) throws IOException {
        if (this.httpClient == null) {
            throw new RuntimeException("GenericEsRestClient must be initialized");
        }

        HttpPost post = new HttpPost(String.format("%s/%s", selectHost().toString(), "_bulk"));
        post.setEntity(new StringEntity(bulkPayload));
        post.addHeader(APPLICATION_XNDJSON_HEADER);

        try (CloseableHttpResponse response = this.httpClient.execute(post)) {
            return response.getStatusLine();
        }
    }

    /**
     * Override this method to add custom configuration to the Apache HttpClient before it is built, called during init phase.
     * @param clientBuilder - HTTP client builder with preset RequestConfig and 0-retry DefaultHttpRequestRetryHandler
     * @param config - ES REST plugin configuration
     */
    protected void customizeHttpClientBuilder(HttpClientBuilder clientBuilder, EsConfig config) {
    }

    protected URI selectHost() {
        if (this.hosts.size() == 1) {
            return this.hosts.get(0);
        } else {
            return this.hosts.get(this.random.nextInt(this.hosts.size()));
        }
    }

    @Override
    public void close() throws IOException {
        this.httpClient.close();
    }
}
```


Overlapping Code:
```
c class GenericEsRestClient implements EsRestClient {
private static final BasicHeader APPLICATION_JSON_HEADER = new BasicHeader("Content-Type", "application/json");
private static final BasicHeader APPLICATION_XNDJSON_HEADER = new BasicHeader("Content-Type", "application/x-ndjson");
private Random random;
private CloseableHttpClient httpClient;
private ArrayList<URI> hosts;
@Override
public void init(List<URI> hosts, EsConfig config) {
this.random = new Random();
this.hosts = new ArrayList<>(hosts);
RequestConfig requestConfig =
RequestConfig.custom()
.setConnectTimeout(config.getConnectTimeoutSeconds() * 1000)
.setSocketTimeout(config.getSocketTimeoutSeconds() * 1000)
.setConnectionRequestTimeout(config.getConnectionRequestTimeoutSeconds() * 1000)
.build();
HttpClientBuilder httpClientBuilder =
HttpClients.custom()
.setDefaultRequestConfig(requestConfig)
.setRetryHandler(new DefaultHttpRequestRetryHandler(0, false));
customizeHttpClientBuilder(httpClientBuilder, config);
this.httpClient = httpClientBuilder.build();
}
@Override
public StatusLine writeSingleDocument(String index, String docType, String id, String document) throws IOException {
if (this.httpClient == null) {
throw new RuntimeException("GenericEsRestClient must be initialized");
}
HttpPut put = new HttpPut(String.format("%s/%s/%s/%s", selectHost().toString(), index, docType, id));
put.setEntity(new StringEntity(document));
put.addHeader(APPLICATION_JSON_HEADER);
try (CloseableHttpResponse response = this.httpClient.execute(put)) {
return response.getStatusLine();
}
}
@Override
public StatusLine readSingleDocument(String index, String docType, String id) throws IOException {
if (this.httpClient == null) {
throw new RuntimeException("GenericEsRestClient must be initialized");
}
HttpGet get = new HttpGet(String.format("%s/%s/%s/%s", selectHost().toString(), index, docType, id));
try (CloseableHttpResponse response = this.httpClient.execute(get)) {
return response.getStatusLine();
}
}
@Override
public Sta
```
<Overlap Ratio: 0.9737098344693281>

---

--- 285 --
Question ID: 86f2ef044808995e336c2728739bcfbb46364372_0
Original Code:
```
public class IP {
    public static void main(String[] args) throws IOException {

        isInSameSubnet();
    }

    public static void isInSameSubnet() throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String str;
        while ((str = reader.readLine()) != null) {
            String[] mask = str.split("\\.");
            String[] ip1 = reader.readLine().split("\\.");
            String[] ip2 = reader.readLine().split("\\.");
            int result = 0;
            for (int i = 0; i < 4; i++) {
                int maskSec = Integer.valueOf(mask[i]);
                int ip1Sec = Integer.valueOf(ip1[i]);
                int ip2Sec = Integer.valueOf(ip2[i]);
                if (maskSec < 0 || maskSec > 255 || ip1Sec < 0 || ip1Sec > 255 || ip2Sec < 0 || ip2Sec > 255) {
                    result = 1;
                    break;
                }
                if ((maskSec & ip1Sec) != (maskSec & ip2Sec)) {
                    result = 2;
                }
            }
            System.out.println(result);
        }
    }
}
```


Overlapping Code:
```
P {
public static void main(String[] args) throws IOException {
isInSameSubnet();
}
public static void isInSameSubnet() throws IOException {
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String str;
while ((str = reader.readLine()) != null) {
String[] mask = str.split("\\.");
String[] ip1 = reader.readLine().split("\\.");
String[] ip2 = reader.readLine().split("\\.");
int result = 0;
for (int i = 0; i < 4; i++) {
int maskSec = Integer.valueOf(mask[i]);
int ip1Sec = Integer.valueOf(ip1[i]);
int ip2Sec = Integer.valueOf(ip2[i]);
if (maskSec < 0 || maskSec > 255 || ip1Sec < 0 || ip1Sec > 255 || ip2Sec < 0 || ip2Sec > 255) {
result = 1;
break;
}
if ((maskSec & ip1Sec) != (maskSec & ip2Sec)) {
result = 2;
}
}
System.out.pri
```
<Overlap Ratio: 0.9583858764186634>

---

--- 286 --
Question ID: a547c2a8ce0337531a5f785e3dbc687b38f67450_0
Original Code:
```
public class TestUtil {

  private static final Logger logger = LoggerFactory.getLogger(TestUtil.class);

  // private on purpose
  private TestUtil() {}

  public static Properties loadProperties(String filePath)
      throws IOException {
    Properties properties = new Properties();
    InputStream inputStream = TestUtil.class.getClassLoader().getResourceAsStream(filePath);
    if (inputStream == null) {
      logger.info("Configuation file not present in classpath. File:  " + filePath);
      throw new RuntimeException("Unable to read " + filePath);
    }
    properties.load(inputStream);
    logger.info("Configuation file loaded. File: " + filePath);
    return properties;
  }

}
```


Overlapping Code:
```
public class TestUtil {
private static final Logger logger = LoggerFactory.getLogger(TestUtil.class);
// private on purpose
private TestUtil() {}
public static Properties loadProperties(String filePath)
throws IOException {
Properties properties = new Properties();
InputStream inputStream = TestUtil.class.getClassLoader().getResourceAsStream(filePath);
if (inputStream == null) {
logger.info("Configuation file not present in classpath. File: " + filePath);
throw new RuntimeException("Unable to read " + filePath);
}
properties.load(inputStream);
logger.info("Configuation file loaded. File: " + filePath);
re
```
<Overlap Ratio: 0.9683544303797469>

---

--- 287 --
Question ID: fb5fb0cbd38cd76fbbd8c2b73a773da087dc0977_0
Original Code:
```
public class ProjectDescriptor {
	private final String projectName;
	private final File projectSaveFile;
	private final Workspace workspace;

	public ProjectDescriptor(@NotNull String projectName, @NotNull File projectSaveFile, @NotNull Workspace workspace) {
		this.projectName = projectName;
		this.projectSaveFile = projectSaveFile;
		this.workspace = workspace;
	}

	@NotNull
	public Workspace getWorkspace() {
		return workspace;
	}

	@NotNull
	public File getProjectSaveFile() {
		return projectSaveFile;
	}

	@NotNull
	public String getProjectName() {
		return projectName;
	}


	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}

		ProjectDescriptor that = (ProjectDescriptor) o;

		if (!projectName.equals(that.projectName)) {
			return false;
		}
		return projectSaveFile.equals(that.projectSaveFile);
	}

}
```


Overlapping Code:
```
c class ProjectDescriptor {
private final String projectName;
private final File projectSaveFile;
private final Workspace workspace;
public ProjectDescriptor(@NotNull String projectName, @NotNull File projectSaveFile, @NotNull Workspace workspace) {
this.projectName = projectName;
this.projectSaveFile = projectSaveFile;
this.workspace = workspace;
}
@NotNull
public Workspace getWorkspace() {
return workspace;
}
@NotNull
public File getProjectSaveFile() {
return projectSaveFile;
}
@NotNull
public String getProjectName() {
return projectName;
}
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
ProjectDescriptor that = (ProjectDescriptor) o;
if (!projectName.equals(that.projectName)) {
return false;
}
return proje
```
<Overlap Ratio: 0.9428904428904429>

---

--- 288 --
Question ID: c9b9f94179c277fc91aea7f31f8d1d50bc63c396_0
Original Code:
```
public class Role {
    public static final String ADMIN_ROLE = "admin";
    public static final String ADMIN_ROLE_DESC = "System reserved role,Have the highest level of authority!";
    public static final Role ADMIN;

    static {
        ADMIN = new Role();
        ADMIN.setRoleName(ADMIN_ROLE);
        ADMIN.setDesc(ADMIN_ROLE_DESC);
    }

    private String roleName;
    private String desc;
    private Map<String, ResourceAction> resourceActionBind = new HashMap<>();

    public String getRoleName() {
        return roleName;
    }

    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public Map<String, ResourceAction> getResourceActionBind() {
        return resourceActionBind;
    }

    public void setResourceActionBind(Map<String, ResourceAction> resourceActionBind) {
        this.resourceActionBind = resourceActionBind;
    }

    public boolean check(ResourceAction requestAction) {
        ResourceAction resourceAction = resourceActionBind.get(requestAction.getNamespace());
        if (resourceAction == null) {
            return false;
        }
        return resourceAction.check(requestAction);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Role)) return false;
        Role role = (Role) o;
        return Objects.equal(roleName, role.roleName);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(roleName);
    }
}
```


Overlapping Code:
```
ublic class Role {
public static final String ADMIN_ROLE = "admin";
public static final String ADMIN_ROLE_DESC = "System reserved role,Have the highest level of authority!";
public static final Role ADMIN;
static {
ADMIN = new Role();
ADMIN.setRoleName(ADMIN_ROLE);
ADMIN.setDesc(ADMIN_ROLE_DESC);
}
private String roleName;
private String desc;
private Map<String, ResourceAction> resourceActionBind = new HashMap<>();
public String getRoleName() {
return roleName;
}
public void setRoleName(String roleName) {
this.roleName = roleName;
}
public String getDesc() {
return desc;
}
public void setDesc(String desc) {
this.desc = desc;
}
public Map<String, ResourceAction> getResourceActionBind() {
return resourceActionBind;
}
public void setResourceActionBind(Map<String, ResourceAction> resourceActionBind) {
this.resourceActionBind = resourceActionBind;
}
public boolean check(ResourceAction requestAction) {
ResourceAction resourceAction = resourceActionBind.get(requestAction.getNamespace());
if (resourceAction == null) {
return false;
}
return resourceAction.check(requestAction);
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (!(o instanceof Role)) return false;
Role role = (Role) o;
return Objects.equal(roleName, role.roleName);
}
@Override
public int hashCode() {
return Objects.hashCode(roleNam
```
<Overlap Ratio: 0.9940520446096655>

---

--- 289 --
Question ID: c908f41b54a0d1bb85a745ef538101b743c06fa6_0
Original Code:
```
@Named
@RequestScoped
public class MultiSelectView {

    private List<SelectItem> categories;
    private String selection;

    @PostConstruct
    public void init() {
        categories = new ArrayList<>();
        SelectItemGroup group1 = new SelectItemGroup("Group 1");
        SelectItemGroup group2 = new SelectItemGroup("Group 2");
        SelectItemGroup group3 = new SelectItemGroup("Group 3");
        SelectItemGroup group4 = new SelectItemGroup("Group 4");

        SelectItemGroup group11 = new SelectItemGroup("Group 1.1");
        SelectItemGroup group12 = new SelectItemGroup("Group 1.2");

        SelectItemGroup group21 = new SelectItemGroup("Group 2.1");

        SelectItem option31 = new SelectItem("Option 3.1", "Option 3.1");
        SelectItem option32 = new SelectItem("Option 3.2", "Option 3.2");
        SelectItem option33 = new SelectItem("Option 3.3", "Option 3.3");
        SelectItem option34 = new SelectItem("Option 3.4", "Option 3.4");

        SelectItem option41 = new SelectItem("Option 4.1", "Option 4.1");

        SelectItem option111 = new SelectItem("Option 1.1.1");
        SelectItem option112 = new SelectItem("Option 1.1.2");
        group11.setSelectItems(new SelectItem[]{option111, option112});

        SelectItem option121 = new SelectItem("Option 1.2.1", "Option 1.2.1");
        SelectItem option122 = new SelectItem("Option 1.2.2", "Option 1.2.2");
        SelectItem option123 = new SelectItem("Option 1.2.3", "Option 1.2.3");
        group12.setSelectItems(new SelectItem[]{option121, option122, option123});

        SelectItem option211 = new SelectItem("Option 2.1.1", "Option 2.1.1");
        group21.setSelectItems(new SelectItem[]{option211});

        group1.setSelectItems(new SelectItem[]{group11, group12});
        group2.setSelectItems(new SelectItem[]{group21});
        group3.setSelectItems(new SelectItem[]{option31, option32, option33, option34});
        group4.setSelectItems(new SelectItem[]{option41});

        categories.add(group1);
        categories.add(group2);
        categories.add(group3);
        categories.add(group4);
    }

    public List<SelectItem> getCategories() {
        return categories;
    }

    public String getSelection() {
        return selection;
    }

    public void setSelection(String selection) {
        this.selection = selection;
    }
}
```


Overlapping Code:
```
tView {
private List<SelectItem> categories;
private String selection;
@PostConstruct
public void init() {
categories = new ArrayList<>();
SelectItemGroup group1 = new SelectItemGroup("Group 1");
SelectItemGroup group2 = new SelectItemGroup("Group 2");
SelectItemGroup group3 = new SelectItemGroup("Group 3");
SelectItemGroup group4 = new SelectItemGroup("Group 4");
SelectItemGroup group11 = new SelectItemGroup("Group 1.1");
SelectItemGroup group12 = new SelectItemGroup("Group 1.2");
SelectItemGroup group21 = new SelectItemGroup("Group 2.1");
SelectItem option31 = new SelectItem("Option 3.1", "Option 3.1");
SelectItem option32 = new SelectItem("Option 3.2", "Option 3.2");
SelectItem option33 = new SelectItem("Option 3.3", "Option 3.3");
SelectItem option34 = new SelectItem("Option 3.4", "Option 3.4");
SelectItem option41 = new SelectItem("Option 4.1", "Option 4.1");
SelectItem option111 = new SelectItem("Option 1.1.1");
SelectItem option112 = new SelectItem("Option 1.1.2");
group11.setSelectItems(new SelectItem[]{option111, option112});
SelectItem option121 = new SelectItem("Option 1.2.1", "Option 1.2.1");
SelectItem option122 = new SelectItem("Option 1.2.2", "Option 1.2.2");
SelectItem option123 = new SelectItem("Option 1.2.3", "Option 1.2.3");
group12.setSelectItems(new SelectItem[]{option121, option122, option123});
SelectItem option211 = new SelectItem("Option 2.1.1", "Option 2.1.1");
group21.setSelectItems(new SelectItem[]{option211});
group1.setSelectItems(new SelectItem[]{group11, group12});
group2.setSelectItems(new SelectItem[]{group21});
group3.setSelectItems(new SelectItem[]{option31, option32, option33, option34});
group4.setSelectItems(new SelectItem[]{option41});
categories.add(group1);
categories.add(group2);
categories.add(group3);
categories.add(group4);
}
public List<SelectItem> getCategories() {
return categories;
}
public String getSelection() {
return selection;
}
public void setSelection(String selection) {
this.selection = selection;
}
```
<Overlap Ratio: 0.976926853215513>

---

--- 290 --
Question ID: b19d5961510e696107f051ce26a9fcf080a996e9_0
Original Code:
```
public class DbFillCommand extends AbstractCommandLauncher {

    private static final String OPTION_SCHEMA = "schema";

    private static final String OPTION_CATALOG = "catalog";

    private static final String OPTION_COUNT = "count";

    private static final String OPTION_CASCADE = "cascade";
    
    private static final String OPTION_CASCADE_SELECT = "select";

    private static final String OPTION_IGNORE_TABLES = "ignore";
    
    private static final String OPTION_PREFIXED_TABLES = "prefixed";
    
    private static final String OPTION_INTERVAL = "interval";
    
    private static final String OPTION_WEIGHTS = "weights";
    
    private static final String OPTION_CONTINUE = "continue";
    
    private static final String OPTION_PRINT = "print";
    
    private static final String OPTION_RAND = "rand";
    
    private static final String OPTION_REPEAT = "repeat";
    
    private static final String OPTION_COMMIT = "commit";
    
    private static final String OPTION_COMMIT_DELAY = "commit-delay";
    
    private static final String OPTION_ROLLBACK = "rollback";
    
    private static final String OPTION_TRUNCATE = "truncate";

    public DbFillCommand() {
        super("dbfill", "[tablename...]", "DbFill.Option.");
    }

    public static void main(String[] args) {
        new DbFillCommand().execute(args);
    }

    @Override
    protected boolean printHelpIfNoOptionsAreProvided() {
        return false;
    }

    @Override
    protected boolean requiresPropertiesFile(CommandLine line) {
        return true;
    }

    @Override
    protected void printHelp(CommandLine cmd, Options options) {
        System.out.println(app + " version " + Version.version());
        System.out.println("Fill database tables with random generated data.\n");
        super.printHelp(cmd, options);
    }

    @Override
    protected void buildOptions(Options options) {
        super.buildOptions(options);
        addOption(options, null, OPTION_SCHEMA, true);
        addOption(options, null, OPTION_CATALOG, true);
        addOption(options, null, OPTION_COUNT, true);
        addOption(options, null, OPTION_CASCADE, false);
        addOption(options, null, OPTION_CASCADE_SELECT, false);
        addOption(options, null, OPTION_IGNORE_TABLES, true);
        addOption(options, null, OPTION_PREFIXED_TABLES, true);
        addOption(options, null, OPTION_INTERVAL, true);
        addOption(options, null, OPTION_WEIGHTS, true);
        addOption(options, null, OPTION_CONTINUE, false);
        addOption(options, null, OPTION_PRINT, false);
        addOption(options, null, OPTION_RAND, false);
        addOption(options, null, OPTION_REPEAT, true);
        addOption(options, null, OPTION_COMMIT, true);
        addOption(options, null, OPTION_COMMIT_DELAY, true);
        addOption(options, null, OPTION_ROLLBACK, true);
        addOption(options, null, OPTION_TRUNCATE, false);
    }

    @Override
    protected boolean executeWithOptions(CommandLine line) throws Exception {
        DbFill dbFill = new DbFill(getDatabasePlatform(false));

        if (line.hasOption(OPTION_SCHEMA)) {
            dbFill.setSchema(line.getOptionValue(OPTION_SCHEMA));
        }
        if (line.hasOption(OPTION_CATALOG)) {
            dbFill.setCatalog(line.getOptionValue(OPTION_CATALOG));
        }
        if (line.hasOption(OPTION_COUNT)) {
            dbFill.setRecordCount(Integer.parseInt(line.getOptionValue(OPTION_COUNT)));
        }
        if (line.hasOption(OPTION_CASCADE)) {
            dbFill.setCascading(true);
        }
        if (line.hasOption(OPTION_CASCADE_SELECT)) {
            dbFill.setCascadingSelect(true);
        }
        if (line.hasOption(OPTION_INTERVAL)) {
            dbFill.setInterval(Integer.parseInt(line.getOptionValue(OPTION_INTERVAL)));
        }
        if (line.hasOption(OPTION_WEIGHTS)) {
            int[] dmlWeight = {0,0,0};
            String[] strWeight = line.getOptionValue(OPTION_WEIGHTS).split(",");
            if (strWeight != null && strWeight.length == 3) {
                for (int i=0; i<3; i++) {
                    dmlWeight[i] = new Integer(strWeight[i]);
                }
                dbFill.setDmlWeight(dmlWeight);
            }
        }
        if (line.hasOption(OPTION_DEBUG)) {
            dbFill.setDebug(true);
        }
        if (line.hasOption(OPTION_VERBOSE_CONSOLE)) {
            dbFill.setVerbose(true);
        }
        
        String ignore[] = null;
        if (line.hasOption(OPTION_IGNORE_TABLES)) {
            ignore = line.getOptionValue(OPTION_IGNORE_TABLES).split(",");
        }
        String prefixed[] = null;
        if (line.hasOption(OPTION_PREFIXED_TABLES)) {
            prefixed = line.getOptionValue(OPTION_PREFIXED_TABLES).split(",");
        }
        if (line.hasOption(OPTION_CONTINUE)) {
            dbFill.setContinueOnError(true);
        }
        if (line.hasOption(OPTION_PRINT)) {
        	dbFill.setPrint(true);
        }
        if (line.hasOption(OPTION_RAND)) {
            dbFill.setUseRandomCount(true);
        }
        if (line.hasOption(OPTION_REPEAT)) {
            dbFill.setRepeat(Integer.parseInt(line.getOptionValue(OPTION_REPEAT)));
        }
        if (line.hasOption(OPTION_COMMIT)) {
            dbFill.setMaxRowsCommit(Integer.parseInt(line.getOptionValue(OPTION_COMMIT)));
        }
        if (line.hasOption(OPTION_COMMIT_DELAY)) {
            dbFill.setCommitDelay(Integer.parseInt(line.getOptionValue(OPTION_COMMIT_DELAY)));
        }        
        if (line.hasOption(OPTION_ROLLBACK)) {
            dbFill.setPercentRollback(Integer.parseInt(line.getOptionValue(OPTION_ROLLBACK)));
        }
        if (line.hasOption(OPTION_TRUNCATE)) {
            dbFill.setTruncate(true);
        }

        // Ignore the Symmetric config tables.
        getSymmetricEngine();
        IParameterService parameterService = engine.getParameterService();
        String cfgPrefix = parameterService.getString(ParameterConstants.RUNTIME_CONFIG_TABLE_PREFIX);
        dbFill.setIgnore((String[])ArrayUtils.add(ignore, cfgPrefix));
        dbFill.setPrefixed(prefixed);
        
        Map<String,int[]> tableProperties = parseTableProperties();
        
        // If tables are provided in the property file, ignore the tables provided at the command line.
        String[] tableNames = null;
        if (tableProperties.size() != 0) {
            tableNames = tableProperties.keySet().toArray(new String[0]);
        } else {
            tableNames = line.getArgs();
        }
        
        if (!dbFill.getPrint()) {
        	dbFill.fillTables(tableNames, tableProperties);
        } else {
        	for (String tableName : tableNames) {
                Table table = platform.readTableFromDatabase(dbFill.getCatalogToUse(), dbFill.getSchemaToUse(),
                        tableName);
                if (table != null) {
                	for (int i = 0; i < dbFill.getRecordCount(); i++) {
                		for (int j = 0; j < dbFill.getInsertWeight(); j++) {
                            String sql = dbFill.createDynamicRandomInsertSql(table);
                            System.out.println(sql);
                        }
                        for (int j = 0; j < dbFill.getUpdateWeight(); j++) {
                            String sql = dbFill.createDynamicRandomUpdateSql(table);
                            System.out.println(sql);
                        }
                        for (int j = 0; j < dbFill.getDeleteWeight(); j++) {
                            String sql = dbFill.createDynamicRandomDeleteSql(table);
                            System.out.println(sql);
                        }        
                	}
                }
        	}
        }

        return true;
    }
    
    private Map<String,int[]> parseTableProperties() {
        Map<String,int[]> tableProperties = new HashMap<String,int[]>();
        Properties properties = engine.getProperties();
        Enumeration<Object> keys = properties.keys();
        while (keys.hasMoreElements()) {
            String key = (String) keys.nextElement();
            String value = (String) properties.get(key);
            if (key.startsWith("fill.")) {
                String tableName = null;
                tableName = key.substring(key.lastIndexOf(".") + 1);
                int[] iudVal = new int[3];
                int i = 0;
                for (String str : value.split(",")) {
                    iudVal[i++] = Integer.valueOf(str).intValue();
                }
                tableProperties.put(tableName, iudVal);
            }
        }
        return tableProperties;
    }

}
```


Overlapping Code:
```
bFillCommand extends AbstractCommandLauncher {
private static final String OPTION_SCHEMA = "schema";
private static final String OPTION_CATALOG = "catalog";
private static final String OPTION_COUNT = "count";
private static final String OPTION_CASCADE = "cascade";

private static final String OPTION_CASCADE_SELECT = "select";
private static final String OPTION_IGNORE_TABLES = "ignore";

private static final String OPTION_PREFIXED_TABLES = "prefixed";

private static final String OPTION_INTERVAL = "interval";

private static final String OPTION_WEIGHTS = "weights";

private static final String OPTION_CONTINUE = "continue";

private static final String OPTION_PRINT = "print";

private static final String OPTION_RAND = "rand";

private static final String OPTION_REPEAT = "repeat";

private static final String OPTION_COMMIT = "commit";

private static final String OPTION_COMMIT_DELAY = "commit-delay";

private static final String OPTION_ROLLBACK = "rollback";

private static final String OPTION_TRUNCATE = "truncate";
public DbFillCommand() {
super("dbfill", "[tablename...]", "DbFill.Option.");
}
public static void main(String[] args) {
new DbFillCommand().execute(args);
}
@Override
protected boolean printHelpIfNoOptionsAreProvided() {
return false;
}
@Override
protected boolean requiresPropertiesFile(CommandLine line) {
return true;
}
@Override
protected void printHelp(CommandLine cmd, Options options) {
System.out.println(app + " version " + Version.version());
System.out.println("Fill database tables with random generated data.\n");
super.printHelp(cmd, options);
}
@Override
protected void buildOptions(Options options) {
super.buildOptions(options);
addOption(options, null, OPTION_SCHEMA, true);
addOption(options, null, OPTION_CATALOG, true);
addOption(options, null, OPTION_COUNT, true);
addOption(options, null, OPTION_CASCADE, false);
addOption(options, null, OPTION_CASCADE_SELECT, false);
addOption(options, null, OPTION_IGNORE_TABLES, true);
addOption(options, null, OPTION_PREFIXED_TABLES, true);
addOption(options, null, OPTION_INTERVAL, true);
addOption(options, null, OPTION_WEIGHTS, true);
addOption(options, nu
```
<Overlap Ratio: 0.9921550530687586>

---

--- 291 --
Question ID: ac4b82f57514b08de7830bcaad91c5eac0044c1f_0
Original Code:
```
public final class CommentsWidget extends Composite implements ClickHandler {

	private static CommentsWidget inst;

	public static CommentsWidget get() {
		if (inst == null) {
			inst = new CommentsWidget();
		}
		return inst;
	}

	private final class CommentEntry extends Composite implements MouseOutHandler, MouseOverHandler,
	    ClickHandler, LoginListener, CommentEditCallback {

		private VerticalPanel mainPanel;
		private Grid header;
		private HTML content;
		private HTML userName;
		private Label lastModified;
		private Image editButton;
		private Image deleteButton;
		private CommentListEntry cle;
		private boolean isToDelete;
		private String possibleText;

		public CommentEntry(CommentListEntry cle) {
			this.cle = cle;
			isToDelete = false;
			mainPanel = new VerticalPanel();
			mainPanel.setStyleName("relW");
			mainPanel.setWidth("100%");

			header = new Grid(1, 5);
			CellFormatter cf = header.getCellFormatter();
			header.setStyleName("relW-header");


			userName = new HTML("<B>"+cle.getAuthor()+"</B>");
			header.setWidget(0, 0, userName);
			cf.setWidth(0, 0, "20");
			cf.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT,
					HasVerticalAlignment.ALIGN_MIDDLE);

			editButton = new Image("img/edit-name.png", 0, 0, 15, 15);
			editButton.addClickHandler(this);
			editButton.addMouseOutHandler(this);
			editButton.addMouseOverHandler(this);
			editButton.setTitle("Edit the comment.");
			Common.setCursorPointer(editButton);
			header.setWidget(0, 1, editButton);
			cf.setWidth(0, 1, "20px");
			cf.setAlignment(0, 1, HasHorizontalAlignment.ALIGN_LEFT,
					HasVerticalAlignment.ALIGN_MIDDLE);

			deleteButton = new Image("img/bin.png", 0, 0, 15, 15);
			deleteButton.addClickHandler(this);
			deleteButton.addMouseOutHandler(this);
			deleteButton.setTitle("Delete the comment.");
			Common.setCursorPointer(deleteButton);
			header.setWidget(0, 2, deleteButton);
			cf.setWidth(0, 2, "20px");
			cf.setAlignment(0, 2, HasHorizontalAlignment.ALIGN_LEFT,
					HasVerticalAlignment.ALIGN_MIDDLE);

			lastModified = new Label(cle.getLastModified());
			header.setWidget(0, 4, lastModified);
			cf.setAlignment(0, 4, HasHorizontalAlignment.ALIGN_RIGHT,
					HasVerticalAlignment.ALIGN_MIDDLE);

			mainPanel.add(header);

			content = new HTML(cle.getCommentString());
			mainPanel.add(content);

			this.initWidget(mainPanel);
			setWidth("100%");
			Login.get().addListener(this);

			editButton.setVisible(false);
			deleteButton.setVisible(false);

			//display edit and delete buttons only if the user is logged in
			if (UserData.get().isLoggedIn()) {
				String id = UserData.get().getId();
				boolean isAdmin = UserData.get().isAdmin();
				if (isAdmin || id.equals(cle.getAuthorID())) {
					editButton.setVisible(true);
					deleteButton.setVisible(true);
				}
			}

		}

		@Override
		public void onMouseOut(MouseOutEvent event) {
			Object sender = event.getSource();
			if (sender == deleteButton) {
				deleteButton.setVisibleRect(0, 0, 15, 15);
			} else if (sender == editButton) {
				editButton.setVisibleRect(0, 0, 15, 15);
			}

		}

		@Override
		public void onMouseOver(MouseOverEvent event) {
			Object sender = event.getSource();
			if (sender == deleteButton) {
				deleteButton.setVisibleRect(15, 0, 15, 15);
			} else if (sender == editButton) {
				editButton.setVisibleRect(15, 0, 15, 15);
			}

		}

		@Override
		public void onClick(ClickEvent event) {
			Object sender = event.getSource();
			if (sender == deleteButton) {
				if(Window.confirm("Are you sure you wan to delete the comment?")) {
					CommentEdit ce = CommentEdit.get();
					isToDelete = true;
					ce.send(this, cle.getId(), "", true);
				}

			} else if (sender == editButton) {
				CommentEditDialog ced = CommentEditDialog.get(cle, this);
				ced.center();
			}
		}

		public void onLoginSuccess() {
			String id = UserData.get().getId();
			boolean isAdmin = UserData.get().isAdmin();
			if (isAdmin || id.equals(cle.getAuthorID())) {
				editButton.setVisible(true);
				deleteButton.setVisible(true);
			}

		}

		public void onSessionKilled() {
			editButton.setVisible(false);
			deleteButton.setVisible(false);
		}


		public void onReseive(boolean isOK) {
			if(isOK) {
				if (isToDelete) {
					removeFromParent();
					//Login.get().removeListener(this);
				} else if (possibleText != null) {
					content.setHTML(Common.escapeHTMLCharacters(possibleText));
				}
			} else {
				if (isToDelete) {
					Window.alert("The comment could not be deleted.");
				} else {
					Window.alert("The comment could not be edited.");
				}
			}
			possibleText = null;
			isToDelete = false;
		}

		public void setPossibleCommentText(String str) {
			this.possibleText = str;
		}
	}

	private VerticalPanel mainPanel;
	private List<CommentEntry> entries;
	private Button addCommentBut;

	private CommentsWidget() {
		mainPanel = new VerticalPanel();
		HorizontalPanel hp = new HorizontalPanel();
		hp.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);
		addCommentBut = new Button("Add new Comment");
		addCommentBut.setStyleName("min-cov-but");
		addCommentBut.addClickHandler(this);
		hp.add(addCommentBut);
		hp.add(new InfoButton("comment"));
		mainPanel.add(hp);
		entries = new ArrayList<>();
		initWidget(mainPanel);
		mainPanel.setSpacing(6);
		setWidth("100%");
	}

	public void clearData() {
		for (CommentEntry cm : entries) {
			cm.removeFromParent();
		}
		entries.clear();
	}

	public void addComments(List<CommentListEntry> comments) {
		for (CommentListEntry cle : comments) {
			CommentEntry c =  new CommentEntry(cle);
			mainPanel.add(c);
			entries.add(c);
		}
	}

	@Override
	public void onClick(ClickEvent event) {
		Object sender = event.getSource();
		if (sender == addCommentBut) {
			if (!UserData.get().isLoggedIn()) {
				Window.alert("You have to login first.");
				return;
			}
//			if(!SolveAssignmentWidget.get().isAssignmentLoadedFromDB()) {
//				Window.alert("This is a static assignment,\n" +
//						"thus it is not loaded from the database\n" +
//						"and comments cannot be submited.");
//				return;
//			}
			CommentAddDialog.get().center();
		}
	}
}
```


Overlapping Code:
```
lass CommentsWidget extends Composite implements ClickHandler {
private static CommentsWidget inst;
public static CommentsWidget get() {
if (inst == null) {
inst = new CommentsWidget();
}
return inst;
}
private final class CommentEntry extends Composite implements MouseOutHandler, MouseOverHandler,
ClickHandler, LoginListener, CommentEditCallback {
private VerticalPanel mainPanel;
private Grid header;
private HTML content;
private HTML userName;
private Label lastModified;
private Image editButton;
private Image deleteButton;
private CommentListEntry cle;
private boolean isToDelete;
private String possibleText;
public CommentEntry(CommentListEntry cle) {
this.cle = cle;
isToDelete = false;
mainPanel = new VerticalPanel();
mainPanel.setStyleName("relW");
mainPanel.setWidth("100%");
header = new Grid(1, 5);
CellFormatter cf = header.getCellFormatter();
header.setStyleName("relW-header");
userName = new HTML("<B>"+cle.getAuthor()+"</B>");
header.setWidget(0, 0, userName);
cf.setWidth(0, 0, "20");
cf.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT,
HasVerticalAlignment.ALIGN_MIDDLE);
editButton = new Image("img/edit-name.png", 0, 0, 15, 15);
editButton.addClickHandler(this);
editButton.addMouseOutHandler(this);
editButton.addMouseOverHandler(this);
editButton.setTitle("Edit the comment.");
Common.setCursorPointer(editButton);
header.setWidget(0, 1, editButton);
cf.setWidth(0, 1, "20px");
cf.setAlignment(0, 1, HasHorizontalAlignment.ALIGN_LEFT,
HasVerticalAlignment.ALIGN_MIDDLE);
deleteButton = new Image("img/bin.png", 0, 0, 15, 15);
deleteButton.addClickHandler(this);
deleteButton.addMouseOutHandler(this);
deleteButton.setTitle("Delete the comment.");
Common.setCursorPointer(deleteButton);
header.setWidget(0, 2, deleteButton);
cf.setWidth(0, 2, "20px");
cf.setAlignment(0, 2, HasHorizontalAlignment.ALIGN_LEFT,
HasVerticalAlignment.ALIGN_MIDDLE);
lastModified = new Label(cle.getLastModified());
header.setWidget(0, 4, lastModified);
cf.setAlignment(0, 4, HasHorizontalAlignment.ALIGN_RIGHT,
HasVerticalAlignment.ALIGN_MIDDLE);
mainPanel.add(header);
content = new HTML(cle.getCommentString());
mainPanel.add(content);
this.initWidget(mainPanel);
setWidth("100%");
Logi
```
<Overlap Ratio: 0.9843400447427293>

---

--- 292 --
Question ID: 5272a48eb8d04dd3b917451b61e3c73bf3dceaca_0
Original Code:
```
public class StreamGroupedFold<IN, OUT> extends StreamFold<IN, OUT> {

	private static final long serialVersionUID = 1L;

	private KeySelector<IN, ?> keySelector;
	private Map<Object, OUT> values;
	private OUT initialValue;

	public StreamGroupedFold(FoldFunction<IN, OUT> folder, KeySelector<IN, ?> keySelector,
			OUT initialValue, TypeInformation<OUT> outTypeInformation) {
		super(folder, initialValue, outTypeInformation);
		this.keySelector = keySelector;
		this.initialValue = initialValue;
		values = new HashMap<Object, OUT>();
	}

	@Override
	public void processElement(StreamRecord<IN> element) throws Exception {
		Object key = keySelector.getKey(element.getValue());
		OUT accumulator = values.get(key);

		if (accumulator != null) {
			OUT folded = userFunction.fold(outTypeSerializer.copy(accumulator), element.getValue());
			values.put(key, folded);
			output.collect(element.replace(folded));
		} else {
			OUT first = userFunction.fold(outTypeSerializer.copy(initialValue), element.getValue());
			values.put(key, first);
			output.collect(element.replace(first));
		}
	}

}
```


Overlapping Code:
```
Fold<IN, OUT> extends StreamFold<IN, OUT> {
private static final long serialVersionUID = 1L;
private KeySelector<IN, ?> keySelector;
private Map<Object, OUT> values;
private OUT initialValue;
public StreamGroupedFold(FoldFunction<IN, OUT> folder, KeySelector<IN, ?> keySelector,
OUT initialValue, TypeInformation<OUT> outTypeInformation) {
super(folder, initialValue, outTypeInformation);
this.keySelector = keySelector;
this.initialValue = initialValue;
values = new HashMap<Object, OUT>();
}
@Override
public void processElement(StreamRecord<IN> element) throws Exception {
Object key = keySelector.getKey(element.getValue());
OUT accumulator = values.get(key);
if (accumulator != null) {
OUT folded = userFunction.fold(outTypeSerializer.copy(accumulator), element.getValue());
values.put(key, folded);
output.collect(element.replace(folded));
} else {
OUT first = userFunction.fold(outTypeSerializer.copy(initialValue), element.getValue());
values.put(key, first);
output.collect(element.replace(f
```
<Overlap Ratio: 0.9624639076034649>

---

--- 293 --
Question ID: 4bef3ba75e60119493cec367a9336d7ef97f9ec4_0
Original Code:
```
public class DigraphUtilsTest extends TestCase {

    public void testPostOrder() {
        Digraph<Integer> digraph = new DigraphImpl<Integer>();
        // 1 -> 2 -> 3;
        digraph.addEdge(1, 2);
        digraph.addEdge(2, 3);
        List<Integer> post = DigraphUtils.topologicalOrder(digraph);
        assertTrue(post.get(0) == 1);
        assertTrue(post.get(1) == 2);
        assertTrue(post.get(2) == 3);
        digraph.addEdge(2, 4);
        digraph.addEdge(4, 1);
    }
}
```


Overlapping Code:
```
 DigraphUtilsTest extends TestCase {
public void testPostOrder() {
Digraph<Integer> digraph = new DigraphImpl<Integer>();
// 1 -> 2 -> 3;
digraph.addEdge(1, 2);
digraph.addEdge(2, 3);
List<Integer> post = DigraphUtils.topologicalOrder(digraph);
assertTrue(post.get(0) == 1);
assertTrue(post.get(1) == 2);
assertTrue(post.get(2) == 3);
digraph.addEdge
```
<Overlap Ratio: 0.8838383838383839>

---

--- 294 --
Question ID: e62593df411efd0f1684fdccd2d77dbe46a1d13e_0
Original Code:
```
@Controller
@RequestMapping("/datashare")
public class DataShareController {
    private final ShareService shareService;
    @Value("${datashareHost}")
    private String datashareHost;

    public DataShareController(ShareService shareService) {
        this.shareService = shareService;
    }

    @GetMapping("/index")
    public String index(Map<String, Object> map, HttpServletRequest request,String path) throws IOException {

        net.gvsun.session.dto.User user = shareService.getCurrentUserFromUnifySession(request);

        request.getSession().setAttribute("user", user);

        GvsunDataSourceDto currDbSource = shareService.getCurrDbSource();
        map.put("currDbSource", currDbSource);
        map.put("path", path);
        return "/datashare/dataShareCenter";
    }

    @GetMapping("/schoolCampusList")
    public String schoolCampusList() {
        return "/datashare/share/schoolCampusList";
    }

    @GetMapping("/userCardList")
    public String userCardList() {
        return "/datashare/share/userCardList";
    }

    @GetMapping("/schoolAcademyList")
    public String schoolAcademyList() {
        return "/datashare/share/schoolAcademyList";
    }

    @GetMapping("/userList")
    public String userList() {
        return "/datashare/share/userList";
    }

    @GetMapping("/schoolTermList")
    public String schoolTermList() {
        return "/datashare/share/schoolTermList";
    }

    @GetMapping("/schoolTimeList")
    public String schoolTimeList() {
        return "/datashare/share/schoolTimeList";
    }

    @GetMapping("/schoolBuildList")
    public String schoolBuildList() {
        return "/datashare/share/schoolBuildList";
    }

    @GetMapping("/schoolSubjectList")
    public String schoolSubjectList() {
        return "/datashare/share/schoolSubjectList";
    }

    @GetMapping("/schoolMajorList")
    public String schoolMajorList() {
        return "/datashare/share/schoolMajorList";
    }

    @GetMapping("/schoolDepartmentList")
    public String schoolDepartmentList() {
        return "/datashare/share/schoolDepartmentList";
    }

    @GetMapping("/schoolClassList")
    public String schoolClassList() {
        return "/datashare/share/schoolClassList";
    }

    @GetMapping("/schoolRoomList")
    public String schoolRoomList() {
        return "/datashare/share/schoolRoomList";
    }

    @GetMapping("/schoolDeviceList")
    public String schoolDeviceList() {
        return "/datashare/share/schoolDeviceList";
    }

    @GetMapping("/dictionary")
    public String dictionary() {
        return "/datashare/share/dictionary";
    }

    @GetMapping("/dictionaryType")
    public String dictionaryType() {
        return "/datashare/share/dictionaryType";
    }

    @GetMapping("/schoolCourseList")
    public String schoolCourseList() {
        return "/datashare/share/schoolCourseList";
    }

    @GetMapping("/schoolCourseInfoList")
    public String schoolCourseInfoList() {
        return "/datashare/share/schoolCourseInfoList";
    }

    @GetMapping("/schoolCourseDetailList")
    public String schoolCourseDetailList() {
        return "/datashare/share/schoolCourseDetailList";
    }

    @GetMapping("/schoolCourseClassList")
    public String schoolCourseClassList() {
        return "/datashare/share/schoolCourseClassList";
    }

    @GetMapping("/schoolCourseStudentList")
    public String schoolCourseStudentList() {
        return "/datashare/share/schoolCourseStudentList";
    }

    @GetMapping("/viewDetail")
    public String viewDetail(Map<String, Object> map,String courseNo) {
        map.put("courseNo",courseNo);
        return "/datashare/share/viewDetail";
    }

    @GetMapping("/viewCourseStudent")
    public String viewCourseStudent(Map<String, Object> map,String courseNo) {
        map.put("courseNo",courseNo);
        return "/datashare/share/viewCourseStudent";
    }

    @GetMapping("/newSchoolTerm")
    public String newSchoolTerm() {
        return "/datashare/share/newSchoolTerm";
    }

    @GetMapping("/newSchoolCourse")
    public String newSchoolCourse() {
        return "/datashare/share/newSchoolCourse";
    }

    @GetMapping("/newSchoolCourseInfo")
    public String newSchoolCourseInfo() {
        return "/datashare/share/newSchoolCourseInfo";
    }

    @GetMapping("/newDictionaryType")
    public String newDictionaryType() {
        return "/datashare/share/newDictionaryType";
    }

}
```


Overlapping Code:
```
@Controller
@RequestMapping("/datashare")
public class DataShareController {
private final ShareService shareService;
@Value("${datashareHost}")
private String datashareHost;
public DataShareController(ShareService shareService) {
this.shareService = shareService;
}
@GetMapping("/index")
public String index(Map<String, Object> map, HttpServletRequest request,String path) throws IOException {
net.gvsun.session.dto.User user = shareService.getCurrentUserFromUnifySession(request);
request.getSession().setAttribute("user", user);
GvsunDataSourceDto currDbSource = shareService.getCurrDbSource();
map.put("currDbSource", currDbSource);
map.put("path", path);
return "/datashare/dataShareCenter";
}
@GetMapping("/schoolCampusList")
public String schoolCampusList() {
return "/datashare/share/schoolCampusList";
}
@GetMapping("/userCardList")
public String userCardList() {
return "/datashare/share/userCardList";
}
@GetMapping("/schoolAcademyList")
public String schoolAcademyList() {
return "/datashare/share/schoolAcademyList";
}
@GetMapping("/userList")
public String userList() {
return "/datashare/share/userList";
}
@GetMapping("/schoolTermList")
public String schoolTermList() {
return "/datashare/share/schoolTermList";
}
@GetMapping("/schoolTimeList")
public String schoolTimeList() {
return "/datashare/share/schoolTimeList";
}
@GetMapping("/schoolBuildList")
public String schoolBuildList() {
return "/datashare/share/schoolBuildList";
}
@GetMapping("/schoolSubjectList")
public String schoolSubjectList() {
return "/datashare/share/schoolSubjectList";
}
@GetMapping("/schoolMajorList")
public String schoolMajorList() {
return "/datashare/share/schoolMajorList";
}
@GetMapping("/schoolDepartmentList")
public String schoolDepartmentList() {
return "/datashare/share/schoolDepartmentList";
}
@GetMapping("/schoolClassList")
public String schoolClassList() {
return "/datashare/share/schoolClassList";
}
@GetMapping("/schoolRoomList")
public String schoolRoomList() {
return "/datashare/share/schoolRoomList";
}
@GetMapping("/schoolDeviceList")
public String schoolDeviceList() {
return "/d
```
<Overlap Ratio: 0.9845288326300985>

---

--- 295 --
Question ID: 85b632cb8ca1c1254bed4a69c55aa69493c730ac_0
Original Code:
```
public class PassportSecurityConfigurer {

    private ApplicationContext applicationContext;

    PassportSecurityConfigurer(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    public void configure(HttpSecurity http) throws Exception {
        PassportSsoProperties sso = this.applicationContext
                .getBean(PassportSsoProperties.class);
        PassportServerProperties server = this.applicationContext
                .getBean(PassportServerProperties.class);
        http.csrf().disable();
        http.headers().frameOptions().disable();
        //去除security session管理
        http.sessionManagement().disable();
        http.securityContext().disable();
        http.formLogin().loginPage(server.getLoginPage())
                .loginProcessingUrl(server.getLoginProcess())
                .successHandler(addSuccessHandler(http,sso))
                .failureHandler(addFailHandler(http,sso,server))
                .and()
                .logout().logoutUrl(server.getLogout())
                .logoutSuccessHandler(addLogoutSuccessHandler(http,sso))
                .logoutSuccessUrl(server.getLogoutSuccess())
                .invalidateHttpSession(true)
                .clearAuthentication(true);
        http.addFilterBefore(serverFilter(sso),
                AbstractPreAuthenticatedProcessingFilter.class);
    }


    private PassportTokenProcessingHandle addSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {
        PassportTokenStore passportTokenStore = this.applicationContext
                .getBean(PassportTokenStore.class);
        PassportTokenProcessingHandle handler = new PassportTokenProcessingHandle();
        if (!StringUtils.isEmpty(sso.getServiceParamName())) {
            handler.setServiceParamName(sso.getServiceParamName());
        }
        if (!StringUtils.isEmpty(sso.getTargetParamName())) {
            handler.setTargetParamName(sso.getTargetParamName());
        }
        if (!StringUtils.isEmpty(sso.getTokenParamName())) {
            handler.setTokenParamName(sso.getTokenParamName());
        }
        handler.setPassportTokenStore(passportTokenStore);
        return handler;
    }

    private ServerAuthenticationFailureHandler addFailHandler(HttpSecurity http, PassportSsoProperties sso ,PassportServerProperties server) throws Exception {
        ServerAuthenticationFailureHandler handler = new ServerAuthenticationFailureHandler(server.getLoginPage());
        if (!StringUtils.isEmpty(sso.getServiceParamName())) {
            handler.setServiceParamName(sso.getServiceParamName());
        }
        if (!StringUtils.isEmpty(sso.getTargetParamName())) {
            handler.setTargetParamName(sso.getTargetParamName());
        }
        return handler;
    }


    private ServerLogoutSuccessHandler addLogoutSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {
        PassportTokenStore passportTokenStore = this.applicationContext
                .getBean(PassportTokenStore.class);
        ServerLogoutSuccessHandler handler = new ServerLogoutSuccessHandler();
        handler.setPassportTokenStore(passportTokenStore);
        handler.setCookieOperations(createCookieOperations(sso));
        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {
            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());
        }
        if (!StringUtils.isEmpty(sso.getLogoutServiceParamName())) {
            handler.setLogoutServiceParamName(sso.getLogoutServiceParamName());
        }
        return handler;
    }

    private PassportServerContextFilter serverFilter(
            PassportSsoProperties sso) {
        PassportServerContextFilter passportFilter = new PassportServerContextFilter();
        if(!StringUtils.isEmpty(sso.getServiceParamName())){
            passportFilter.setServiceParamName(sso.getServiceParamName());
        }
        if(!StringUtils.isEmpty(sso.getTargetParamName())){
            passportFilter.setTargetParamName(sso.getTargetParamName());
        }
        return passportFilter;
    }

    private CookieOperations createCookieOperations(PassportSsoProperties sso) {

        DefaultCookieOperations cookieOperations = new DefaultCookieOperations();
        if (!StringUtils.isEmpty(sso.getCookieDomain())) {
            cookieOperations.setDomain(sso.getCookieDomain());
        }
        if (!StringUtils.isEmpty(sso.getCookieName())) {
            cookieOperations.setCookieName(sso.getCookieName());
        }
        if (!StringUtils.isEmpty(sso.getCookiePath())) {
            cookieOperations.setCookiePath(sso.getCookiePath());
        }
        if (sso.getCookieMaxage() != 0) {
            cookieOperations.setCookieMaxage(sso.getCookieMaxage());
        }
        return cookieOperations;
    }
}
```


Overlapping Code:
```
nfigurer {
private ApplicationContext applicationContext;
PassportSecurityConfigurer(ApplicationContext applicationContext) {
this.applicationContext = applicationContext;
}
public void configure(HttpSecurity http) throws Exception {
PassportSsoProperties sso = this.applicationContext
.getBean(PassportSsoProperties.class);
PassportServerProperties server = this.applicationContext
.getBean(PassportServerProperties.class);
http.csrf().disable();
http.headers().frameOptions().disable();
//去除security session管理
http.sessionManagement().disable();
http.securityContext().disable();
http.formLogin().loginPage(server.getLoginPage())
.loginProcessingUrl(server.getLoginProcess())
.successHandler(addSuccessHandler(http,sso))
.failureHandler(addFailHandler(http,sso,server))
.and()
.logout().logoutUrl(server.getLogout())
.logoutSuccessHandler(addLogoutSuccessHandler(http,sso))
.logoutSuccessUrl(server.getLogoutSuccess())
.invalidateHttpSession(true)
.clearAuthentication(true);
http.addFilterBefore(serverFilter(sso),
AbstractPreAuthenticatedProcessingFilter.class);
}
private PassportTokenProcessingHandle addSuccessHandler(HttpSecurity http, PassportSsoProperties sso) throws Exception {
PassportTokenStore passportTokenStore = this.applicationContext
.getBean(PassportTokenStore.class);
PassportTokenProcessingHandle handler = new PassportTokenProcessingHandle();
if (!StringUtils.isEmpty(sso.getServiceParamName())) {
handler.setServiceParamName(sso.getServiceParamName());
}
if (!StringUtils.isEmpty(sso.getTargetParamName())) {
handler.setTargetParamName(sso.getTargetParamName());
}
if (!StringUtils.isEmpty(sso.getTokenParamName())) {
handler.setTokenParamName(sso.getTokenParamName());
}
handler.setPassportTokenStore(passportTokenStore);
return handler;
}
private ServerAuthenticationFailureHandler addFailHandler(HttpSecurity http, PassportSsoProperties sso ,PassportServerProperties server) throws Exception {
ServerAuthenticationFailureHandler handler = new ServerAuthenticationFailureHandler(
```
<Overlap Ratio: 0.9790141532454856>

---

--- 296 --
Question ID: ffa10dbb482bd57bf9a36f10349612e56733f413_0
Original Code:
```
public class BriefPreviewConfigTO implements DatasetConfigProvider, DatasetProvider {
    @Override
    public List<String> datasets() {
        return new ArrayList<>();
    }

    @Override
    public DatasetConfig forDataset(String dataset) {
        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);
    }

    @Override
    public List<DocumentImage> imageFields() {
        return new ArrayList<>();
    }

    @Override
    public DatasetConfig get(String dataset) {
        return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);
    }


    @Override
    public List<String> datasetNames() {
        return new ArrayList<>();
    }

    @Override
    public List<DatasetMeta> datasetsMeta() {
        return new ArrayList<>();
    }


    class IdentityHashMap<K, V> extends HashMap<K, V> {

        @Override
        public boolean containsKey(Object o) {
            return true;
        }

        @Override
        public V get(Object o) {
            IdentityHashMap<Object, Object> objectObjectIdentityHashMap = new IdentityHashMap<>();
            objectObjectIdentityHashMap.put("", o);
            return (V) objectObjectIdentityHashMap;
        }
    }
}
```


Overlapping Code:
```
O implements DatasetConfigProvider, DatasetProvider {
@Override
public List<String> datasets() {
return new ArrayList<>();
}
@Override
public DatasetConfig forDataset(String dataset) {
return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);
}
@Override
public List<DocumentImage> imageFields() {
return new ArrayList<>();
}
@Override
public DatasetConfig get(String dataset) {
return new DatasetConfigImpl(new IdentityHashMap<>(), dataset, IdentityHashMap.class, false);
}
@Override
public List<String> datasetNames() {
return new ArrayList<>();
}
@Override
public List<DatasetMeta> datasetsMeta() {
return new ArrayList<>();
}
class IdentityHashMap<K, V> extends HashMap<K, V> {
@Override
public boolean containsKey(Object o) {
return true;
}
@Override
public V get(Object o) {
IdentityHashMap<Object, Object> objectObjectIdentityHashMap = new IdentityHashMap<>();
objectObjectIdentityHashMap.put("", o);
return
```
<Overlap Ratio: 0.930460333006856>

---

--- 297 --
Question ID: 861bc13ed7e35b86c7bb9ec24dd1571d7e275d4c_0
Original Code:
```
public class ListQueue {
	private LinkedList<Integer> list = new LinkedList<Integer>();

	//private ListQueue() {}
	
	public static ListQueue makeFromQueue(Queue q) {	
		if(q.isempty()) {
			return new ListQueue();
		} else if(q.isadd()) {
			ListQueue res = makeFromQueue(q.getq());
			res.add(q.gete().getv());
			return res;
		} else if(q.isremove()) {
			ListQueue res = makeFromQueue(q.getq());
			res.remove();
			return res;
		}
		throw new RuntimeException("should not be there");	
	}
	
	public static int makeFromElem(Elem e) throws Exception {
		if(e.isval()) {
			return e.getv();
		}/* else if(e.istop()) {
			ListQueue sq = makeFromQueue(e.getq());
			if(sq.size() > 0) {
				return sq.top();
			} else {
				throw new Exception();
			}
		}*/
		throw new RuntimeException("should not be there");	
	}
	
	public int top() {
		if(!list.isEmpty()) {
			return list.getLast();
		}
		throw new RuntimeException("should not be there");	
	}
	
	public void remove() {
		list.removeLast();
	}
	
	public void add(int e) {
		list.addFirst(e);
	}
	
	public int size() {
		return list.size();
	}
	

	public static void main(String[] args) {
		int nb = 2000;
		BigInteger TWO = BigInteger.ONE.add(BigInteger.ONE);
		
		Enumeration<Queue> e = Queue.getEnumeration();
		long start = System.currentTimeMillis();
		BigInteger index = BigInteger.ONE;
		for(int i = 0 ; i<nb ; i++) {
			Queue q = e.get(index);
			//System.out.println(q);
			
			//index = index.add(TWO);
			index = index.multiply(TWO);
		}
		long stop = System.currentTimeMillis();

		System.out.println(nb + " elems in " + (stop-start));
	}
}
```


Overlapping Code:
```
 class ListQueue {
private LinkedList<Integer> list = new LinkedList<Integer>();
//private ListQueue() {}

public static ListQueue makeFromQueue(Queue q) { 
if(q.isempty()) {
return new ListQueue();
} else if(q.isadd()) {
ListQueue res = makeFromQueue(q.getq());
res.add(q.gete().getv());
return res;
} else if(q.isremove()) {
ListQueue res = makeFromQueue(q.getq());
res.remove();
return res;
}
throw new RuntimeException("should not be there"); 
}

public static int makeFromElem(Elem e) throws Exception {
if(e.isval()) {
return e.getv();
}/* else if(e.istop()) {
ListQueue sq = makeFromQueue(e.getq());
if(sq.size() > 0) {
return sq.top();
} else {
throw new Exception();
}
}*/
throw new RuntimeException("should not be there"); 
}

public int top() {
if(!list.isEmpty()) {
return list.getLast();
}
throw new RuntimeException("should not be there"); 
}

public void remove() {
list.removeLast();
}

public void add(int e) {
list.addFirst(e);
}

public int size() {
return list.size();
}

public static void main(String[] args) {
int nb = 2000;
BigInteger TWO = BigInteger.ONE.add(BigInteger.ONE);

Enumeration<Queue> e = Queue.getEnumeration();
long start = System.currentTimeMillis();
BigInteger index = BigInteger.ONE;
for(int i = 0 ; i<nb ; i++) {
Queue q = e.get(index);
//System.out.println(q);

//index = index.add(TWO);
index = index.multiply(TWO);
}
long stop = System.currentTimeMillis();
System.out.println(nb + " elems in " + (stop-sta
```
<Overlap Ratio: 0.9897610921501706>

---

--- 298 --
Question ID: 13e37529ab5063608e3978a47857d1e7e547875c_0
Original Code:
```
public class StackTest
{
	@Test
	public void test()
	{
		Stack<String> stack = new Stack<String>(3);
		stack.push("1");
		stack.push("2");
		stack.push("3");
		
		assertEquals("3", stack.peek());
		assertEquals("2", stack.peek(1));
		
		assertEquals("3", stack.pop());
		Stack<String> clone = new Stack<String>(stack);
		
		assertEquals("2", stack.pop());
		assertEquals("1", stack.pop());
		
		assertEquals("2", clone.pop());
		assertEquals("1", clone.pop());
	}
}
```


Overlapping Code:
```
ass StackTest
{
@Test
public void test()
{
Stack<String> stack = new Stack<String>(3);
stack.push("1");
stack.push("2");
stack.push("3");

assertEquals("3", stack.peek());
assertEquals("2", stack.peek(1));

assertEquals("3", stack.pop());
Stack<String> clone = new Stack<String>(stack);

assertEquals("2", stack.pop());
assertEquals("1", stack.pop());

assertEquals("2", clone.pop());
assertEquals("1
```
<Overlap Ratio: 0.9324009324009324>

---

--- 299 --
Question ID: ff2ac6411e4148567dd75d3fc3447a458153e66e_0
Original Code:
```
public class AutomaticSpellsModule extends Framework_Module_Abstract {

    private final String thisIniName = "AutomaticSpells.ini";
    private final Ini thisIni;

    private final String patchSettings = "PatchSettings";
    private final String NPCInclusions = "NPCInclusions";
    private final String NPCExclusions = "NPCExclusions";
    private final String KeywordExclusions = "NPCKeywordExclusions";
    private final String NPCModExclusions = "NPCModExclusions";
    private final String effectKYWDPrefixes = "EffectKeywordPrefixes";

    private final String SPELLEXCLUSIONSCONTAINS = "SPELLEXCLUSIONSCONTAINS";
    private final String SPELLEXCLUSIONSSTARTSWITH = "SPELLEXCLUSIONSSTARTSWITH";

    private final String spellModInclusions = "spellModInclusions";

    private final Set<String> effectPrefixes = new HashSet<>();

    public AutomaticSpellsModule() throws IOException {
        name = "Automatic Spells";
        thisIni = new Ini();
        Config c = thisIni.getConfig();
        c.setEmptyOption(true);
        c.setEmptySection(true);
        thisIni.load(new File(thisIniName));

        effectPrefixes.addAll(thisIni.get(effectKYWDPrefixes).keySet());

        RecordSelector npcsToGetSpells = new RecordSelectorBuilder().type(GRUP_TYPE.NPC_).RecordValidator(ASIS.validNPCs_NoSpellsPerks).build();
        npcsToGetSpells.addInclusion(new SelectionSet(thisIni.get(NPCInclusions), new Matcher.EDIDStartsWith()));
        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCExclusions), new Matcher.EDIDContains()));
        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCModExclusions), new Matcher.ModContains()));
        npcsToGetSpells.addExclusion(new SelectionSet(ASIS.getAsisIni().get("MODEXCLUSIONS"), new Matcher.ModContains()));
        npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(KeywordExclusions), new Matcher.HasKYWD()));
        this.addRecordSelector("npcsToGetSpells", npcsToGetSpells);

        RecordSelector spellsToDistribute = new RecordSelectorBuilder().type(GRUP_TYPE.SPEL).RecordValidator(RecordSelector.USE_NON_DELETED).build();
        spellsToDistribute.addInclusion(new SelectionSet(thisIni.get(spellModInclusions), new Matcher.ModContains()));
        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSCONTAINS), new Matcher.EDIDContains()));
        spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSSTARTSWITH), new Matcher.EDIDStartsWith()));
        spellsToDistribute.addExclusion(new SelectionSet(ASIS.getAsisIni().get("MODEXCLUSIONS"), new Matcher.ModContains()));
        this.addRecordSelector("spellsToDistribute", spellsToDistribute);

    }

    private Mod merger;

    @Override
    public void runModuleChanges() {
        merger = Controller.getAllRecords();
        Map<SPEL, SpellInfo> spellsMap = getSpellInfos();
        Map<NPC_, NPCInfo> npcsMap = buildNPCInfos();
        addSpellsToNPCs(spellsMap, npcsMap);
    }

    private Map<SPEL, SpellInfo> getSpellInfos() {
        SPProgressBarPlug.setStatus("Automatic Spells: Mapping Spells");
        SPProgressBarPlug.incrementBar();

        Map<SPEL, SpellInfo> spellMap = new HashMap<>();

        for (MajorRecord r : getRecordSelector("spellsToDistribute").getValidRecords()) {
            SPEL s = (SPEL) r;
            if (s != null) {

                SpellInfo spellInf = getSpellInfo(s);
                if (spellInf != null) {
                    spellMap.put(s, spellInf);
                }

            }
        }
        return spellMap;
    }

    private void addSpellsToNPCs(Map<SPEL, SpellInfo> spellsMap, Map<NPC_, NPCInfo> npcsMap) {
        try {
            Mod patch = SPGlobal.getGlobalPatch();

            for (MajorRecord r : getRecordSelector("npcsToGetSpells").getValidRecords()) {
                NPC_ n = (NPC_) r;
                if (n == null) {
                    continue;
                }
                NPCInfo theNpcsInfo = npcsMap.get(n);
                if (theNpcsInfo == null) {
                    continue;
                }
                boolean changed = false;

                ArrayList<FormID> npcSpellsForms = n.getSpells();
                ArrayList<SPEL> npcSpells = new ArrayList<>();
                for (FormID f : npcSpellsForms) {
                    SPEL s = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);
                    if (s != null) {
                        npcSpells.add(s);
                    }
                    // disabled warning because of unhandled SHOU
//                        else {
//                            SPGlobal.logError(name, "NPC: " + n + ", has spell FormID entry: " + f
//                                    + ", which cannot be resolved to a Spell\n"
//                                    + "Skipping for patch but this is probably a very bad thing");
//                        }
                }

                for (Entry<SPEL, SpellInfo> e : spellsMap.entrySet()) {
                    if (!npcSpells.contains(e.getKey()) && npcCanGet(theNpcsInfo, e.getValue())) {
                        n.addSpell(e.getKey().getForm());
                        changed = true;
                    }
                }
                if (changed) {
                    ASIS.npcsToWrite.add(n.getForm());
                    patch.addRecord(n);
                }

            }
        } catch (Exception exception) {
            System.err.println(exception.toString());
            SPGlobal.logException(exception);
            SPGlobal.flush();
            JOptionPane.showMessageDialog(null, "Something terrible happened running " + name
                    + ": " + exception + " Check the readme and debug logs.");
            System.exit(0);
        }
    }

    private Map<NPC_, NPCInfo> buildNPCInfos() {
        Map<NPC_, NPCInfo> npcMap = new HashMap<>();

        for (MajorRecord r : getRecordSelector("npcsToGetSpells").getValidRecords()) {
            NPC_ n = (NPC_) r;
            if (n != null) {
                NPCInfo theInfo = getNPCInfo(n);
                if (theInfo != null) {
                    npcMap.put(n, theInfo);
                }
            }

        }

        return npcMap;
    }

    private boolean npcCanGet(NPCInfo nInfo, SpellInfo spInfo) {
        Map<Skill, Integer> skillLevels = nInfo.getSkillLevels();

        for (Entry<Skill, Integer> e : spInfo.getNeededSkills().entrySet()) {
            if (skillLevels.get(e.getKey()) < e.getValue()) {
                return false;
            }
        }

        ArrayList<KYWD> magicKeys = new ArrayList<>();
        for (FormID keyForm : spInfo.getMainEffect().getKeywordSet().getKeywordRefs()) {
            KYWD key = (KYWD) merger.getMajor(keyForm, GRUP_TYPE.KYWD);
            if (key != null) {
                String edid = key.getEDID().toUpperCase();
                for (String prefix : effectPrefixes) {
                    if (edid.startsWith(prefix.toUpperCase())) {
                        magicKeys.add(key);
                    }
                }
            }
        }
        Set<KYWD> effects = nInfo.getHandEffects().get(spInfo.getEquipslot());
        if (effects != null && magicKeys.size() > 0) {
            for (KYWD key : magicKeys) {
                if (effects.contains(key)) {
                    return true;
                }
            }
        }
        return false;
    }

    private NPC_ unTemplate(NPC_ n, NPC_.TemplateFlag templateFlag) {
        while (n.isTemplated() && n.get(templateFlag)) {
            NPC_ nTemp = (NPC_) merger.getMajor(n.getTemplate(), GRUP_TYPE.NPC_);
            if (nTemp == null) {
                LVLN lTemp = (LVLN) merger.getMajor(n.getTemplate(), GRUP_TYPE.LVLN);
                if (lTemp == null) {
                    SPGlobal.logError(name, "NPC: " + n
                            + ", has template FormID entry: " + n.getTemplate()
                            + ", which cannot be resolved to an NPC or Leveled NPC.\n"
                            + "Skipping for patch but this is probably a very bad thing");
                }
                n = null;
                break;
            }
            n = nTemp;
        }
        return n;
    }

    private SpellInfo getSpellInfo(SPEL s) {

        Skill curSkill = null;
        int curCost = -1;
        MGEF curEffect = null;
        Map<Skill, Integer> neededSkills = new HashMap();

        for (MagicEffectRef ref : s.getMagicEffects()) {
            FormID refID = ref.getMagicRef();
            MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);
            if (effect != null) {
                ActorValue av = effect.getSkillType();
                Skill sk = AutomaticPerksModule.getAVasSkill(av);
                if ((sk != null) && (isMagicSkill(sk))) {
                    if (!neededSkills.containsKey(sk)) {
                        neededSkills.put(sk, effect.getSkillLevel());
                    } else if (effect.getSkillLevel() > neededSkills.get(sk)) {
                        neededSkills.put(sk, effect.getSkillLevel());
                    }

                    float mag = ref.getMagnitude();
                    if (mag < 1.0) {
                        mag = (float) 1.0;
                    }
                    int dur = ref.getDuration();
                    if (dur == 0) {
                        dur = 10;
                    }

                    double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);
                    int iCost = (int) Math.floor(cost);
                    if (iCost > curCost) {
                        curSkill = sk;
                        curCost = iCost;
                        curEffect = effect;
                    }
                }
            }
        }
        SpellInfo info = null;
        if (curSkill != null) {
            info = new SpellInfo(s, curSkill, curEffect, neededSkills);
        }
        return info;
    }

    private NPCInfo getNPCInfo(NPC_ n) {

        NPC_ unTemplatedSpells = unTemplate(n, NPC_.TemplateFlag.USE_SPELL_LIST);
        NPC_ unTemplatedStats = unTemplate(n, NPC_.TemplateFlag.USE_STATS);

        if ((unTemplatedSpells == null) || (unTemplatedStats == null)) {
            return null;
        }

        NPCInfo theInfo = new NPCInfo();

        // get effects per equipSlot
        ArrayList<FormID> spells = unTemplatedSpells.getSpells();
        Map<SPEL, MGEF> effectsMap = new HashMap<>();

        for (FormID f : spells) {
            SPEL theSpell = (SPEL) merger.getMajor(f, GRUP_TYPE.SPEL);
            if (theSpell != null) {
                int curCost = -1;
                MGEF mainEffect = null;

                for (MagicEffectRef ref : theSpell.getMagicEffects()) {
                    FormID refID = ref.getMagicRef();
                    MGEF effect = (MGEF) merger.getMajor(refID, GRUP_TYPE.MGEF);
                    if ((effect != null) && (effect.getBaseCost() > 0.0)) {
                        float mag = ref.getMagnitude();
                        if (mag < 1.0) {
                            mag = (float) 1.0;
                        }
                        int dur = ref.getDuration();
                        if (dur == 0) {
                            dur = 10;
                        }

                        double cost = effect.getBaseCost() * Math.pow((mag * dur / 10), 1.1);
                        int iCost = (int) Math.floor(cost);
                        if (iCost > curCost) {
                            curCost = iCost;
                            mainEffect = effect;
                        }

                    }
                }
                if (mainEffect != null) {
                    effectsMap.put(theSpell, mainEffect);
                }
            }
        }
        for (Entry<SPEL, MGEF> entry : effectsMap.entrySet()) {
            FormID equipSlot = entry.getKey().getEquipSlot();
            for (FormID f : entry.getValue().getKeywordSet().getKeywordRefs()) {
                KYWD key = (KYWD) merger.getMajor(f, GRUP_TYPE.KYWD);
                if (key == null) {
                    String error = "Magic Effect " + entry.getValue().getEDID()
                            + " has a keyword reference " + f + " that cannot be resolved to a loaded keyword. Skipping.";
                    SPGlobal.log(name, error);
                } else {
                    String edid = key.getEDID().toUpperCase();
                    for (String prefix : effectPrefixes) {
                        if (edid.startsWith(prefix.toUpperCase())) {
                            theInfo.addEquipslotEffect(equipSlot, key);
                        }
                    }
                }
            }
        }

        // get skills
        ArrayList<Skill> skills = new ArrayList<>();
        skills.add(Skill.ALTERATION);
        skills.add(Skill.CONJURATION);
        skills.add(Skill.DESTRUCTION);
        skills.add(Skill.ILLUSION);
        skills.add(Skill.RESTORATION);
        for (Skill s : skills) {
            theInfo.addSkillLevel(s, unTemplatedStats.get(s));
        }

        return theInfo;
    }

    private boolean isMagicSkill(Skill sk) {
        switch (sk) {
            case ALTERATION:
            case CONJURATION:
            case DESTRUCTION:
            case ILLUSION:
            case RESTORATION:
                return true;
        }
        return false;

    }

    private class NPCInfo {

        private final Map<FormID, Set<KYWD>> handEffects;
        private final Map<Skill, Integer> skillLevels;

        public NPCInfo() {
            handEffects = new HashMap<>();
            skillLevels = new HashMap<>();
        }

        public void addEquipslotEffect(FormID f, KYWD k) {
            Set<KYWD> keySet = handEffects.get(f);
            if (keySet == null) {
                keySet = new HashSet<>();
                keySet.add(k);
                handEffects.put(f, keySet);
            } else {
                keySet.add(k);
            }
        }

        public Map<FormID, Set<KYWD>> getHandEffects() {
            return handEffects;
        }

        public void addSkillLevel(Skill theSkill, int i) {
            skillLevels.put(theSkill, i);
        }

        public Map<Skill, Integer> getSkillLevels() {
            return skillLevels;
        }

    }

    private class SpellInfo {

        private Map<Skill, Integer> neededSkills;
        private Skill mainSkill;
        private MGEF mainEffect;
        private SPEL theSpell;
        private FormID equipslot;

        private SpellInfo() {
        }

        private SpellInfo(SPEL theSpell, Skill mainSkill, MGEF mainEffect, Map<Skill, Integer> neededSkills) {
            this.theSpell = theSpell;
            this.neededSkills = neededSkills;
            this.mainSkill = mainSkill;
            this.mainEffect = mainEffect;
            equipslot = theSpell.getEquipSlot();
        }

        public Map<Skill, Integer> getNeededSkills() {
            return neededSkills;
        }

        public Skill getMainSkill() {
            return mainSkill;
        }

        public MGEF getMainEffect() {
            return mainEffect;
        }

        public FormID getEquipslot() {
            return equipslot;
        }

    }

}
```


Overlapping Code:
```
icSpellsModule extends Framework_Module_Abstract {
private final String thisIniName = "AutomaticSpells.ini";
private final Ini thisIni;
private final String patchSettings = "PatchSettings";
private final String NPCInclusions = "NPCInclusions";
private final String NPCExclusions = "NPCExclusions";
private final String KeywordExclusions = "NPCKeywordExclusions";
private final String NPCModExclusions = "NPCModExclusions";
private final String effectKYWDPrefixes = "EffectKeywordPrefixes";
private final String SPELLEXCLUSIONSCONTAINS = "SPELLEXCLUSIONSCONTAINS";
private final String SPELLEXCLUSIONSSTARTSWITH = "SPELLEXCLUSIONSSTARTSWITH";
private final String spellModInclusions = "spellModInclusions";
private final Set<String> effectPrefixes = new HashSet<>();
public AutomaticSpellsModule() throws IOException {
name = "Automatic Spells";
thisIni = new Ini();
Config c = thisIni.getConfig();
c.setEmptyOption(true);
c.setEmptySection(true);
thisIni.load(new File(thisIniName));
effectPrefixes.addAll(thisIni.get(effectKYWDPrefixes).keySet());
RecordSelector npcsToGetSpells = new RecordSelectorBuilder().type(GRUP_TYPE.NPC_).RecordValidator(ASIS.validNPCs_NoSpellsPerks).build();
npcsToGetSpells.addInclusion(new SelectionSet(thisIni.get(NPCInclusions), new Matcher.EDIDStartsWith()));
npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCExclusions), new Matcher.EDIDContains()));
npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(NPCModExclusions), new Matcher.ModContains()));
npcsToGetSpells.addExclusion(new SelectionSet(ASIS.getAsisIni().get("MODEXCLUSIONS"), new Matcher.ModContains()));
npcsToGetSpells.addExclusion(new SelectionSet(thisIni.get(KeywordExclusions), new Matcher.HasKYWD()));
this.addRecordSelector("npcsToGetSpells", npcsToGetSpells);
RecordSelector spellsToDistribute = new RecordSelectorBuilder().type(GRUP_TYPE.SPEL).RecordValidator(RecordSelector.USE_NON_DELETED).build();
spellsToDistribute.addInclusion(new SelectionSet(thisIni.get(spellModInclusions), new Matcher.ModContains()));
spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSCONTAINS), new Matcher.EDIDContains()));
spellsToDistribute.addExclusion(new SelectionSet(thisIni.get(SPELLEXCLUSIONSSTARTSWITH), new Matcher
```
<Overlap Ratio: 0.982532751091703>

---

--- 300 --
Question ID: 4c09433dc97e494c0262c338c2595e368a50d56d_0
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class PaywallCredentialPopulatorTest {

    @Mock
    private ClouderaManagerLicenseProvider clouderaManagerLicenseProvider;

    @InjectMocks
    private PaywallCredentialPopulator underTest;

    @Test
    public void testPopulateWebTargetShouldAddCredentialsWhenTheUrlIsPointsToArchive() {
        String baseUrl = "http://archive.cloudera.com/parcel1/";
        WebTarget webTarget = createWebTarget(baseUrl);
        JsonCMLicense license = mock(JsonCMLicense.class);

        when(clouderaManagerLicenseProvider.getLicense(any())).thenReturn(license);
        when(license.getPaywallUsername()).thenReturn("user");
        when(license.getPaywallPassword()).thenReturn("pw");

        underTest.populateWebTarget(baseUrl, webTarget);

        assertFalse(webTarget.getConfiguration().getInstances().isEmpty());
        verify(clouderaManagerLicenseProvider).getLicense(any());
        verify(license).getPaywallUsername();
        verify(license).getPaywallPassword();
    }

    @Test
    public void testPopulateWebTargetShouldNotAddCredentialsWhenTheUrlIsNotPointsToArchive() {
        String baseUrl = "http://random.cloudera.com/parcel1/";
        WebTarget webTarget = createWebTarget(baseUrl);

        underTest.populateWebTarget(baseUrl, webTarget);

        assertTrue(webTarget.getConfiguration().getInstances().isEmpty());
        verifyNoInteractions(clouderaManagerLicenseProvider);
    }

    private WebTarget createWebTarget(String baseUrl) {
        return RestClientUtil.get().target(StringUtils.stripEnd(baseUrl, "/") + "/manifest.json");
    }

}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class PaywallCredentialPopulatorTest {
@Mock
private ClouderaManagerLicenseProvider clouderaManagerLicenseProvider;
@InjectMocks
private PaywallCredentialPopulator underTest;
@Test
public void testPopulateWebTargetShouldAddCredentialsWhenTheUrlIsPointsToArchive() {
String baseUrl = "http://archive.cloudera.com/parcel1/";
WebTarget webTarget = createWebTarget(baseUrl);
JsonCMLicense license = mock(JsonCMLicense.class);
when(clouderaManagerLicenseProvider.getLicense(any())).thenReturn(license);
when(license.getPaywallUsername()).thenReturn("user");
when(license.getPaywallPassword()).thenReturn("pw");
underTest.populateWebTarget(baseUrl, webTarget);
assertFalse(webTarget.getConfiguration().getInstances().isEmpty());
verify(clouderaManagerLicenseProvider).getLicense(any());
verify(license).getPaywallUsername();
verify(license).getPaywallPassword();
}
@Test
public void testPopulateWebTargetShouldNotAddCredentialsWhenTheUrlIsNotPointsToArchive() {
String baseUrl = "http://random.cloudera.com/parcel1/";
WebTarget webTarget = createWebTarget(baseUrl);
underTest.populateWebTarget(baseUrl, webTarget);
assertTrue(webTarget.getConfiguration().getInstances().isEmpty());
verifyNoInteractions(clouderaManagerLicenseProvider);
}
private WebTarget createWebTarget(String baseUrl) {
return RestClientUtil.get().target(StringUtils.stripEnd(baseUrl, "/") + "/manifest.json")
```
<Overlap Ratio: 0.9964788732394366>

---

--- 301 --
Question ID: 4bc54bf695113851842bace065137e2a083b3b86_0
Original Code:
```
@Category({ Unit.class })
public class PluginManagerTest {

    private static String previousConfig = null;

    /**
     * Preparation before executing this test class.
     */
    @BeforeClass
    public static void prepare() {
        previousConfig = PersoniumUnitConfig.getPluginDefaultLoadClassname();
        PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME,
                AuthPluginLoaderForTesting.class.getName());
    }

    /**
     * Clean up after executing this test class.
     */
    @AfterClass
    public static void cleanup() {
        if (previousConfig == null) {
            PersoniumUnitConfig.getProperties().remove(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME);
        } else {
            PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME, previousConfig);
        }
    }

    /**
     * Test that PluginManager can find correct plugin by grantType.
     *
     * @throws Exception .
     */
    @Test
    public void PluginManger_can_find_AuthPlugin_by_grantType() throws Exception {
        String testGrantType = AuthPluginLoaderForTesting.DEFAULT_GRANT_TYPES.iterator().next();
        PluginManager pm = new PluginManager();
        assertTrue("PluginManager failed to load plugins", (pm.size() > 0));

        PluginInfo pi = (PluginInfo) pm.getPluginsByGrantType(testGrantType);
        assertNotNull("getPluginsByGrantType [" + testGrantType + "] returns null", pi);
    }

    /**
     * Test that PluginManager returns null if invalid grantType is presented.
     *
     * @throws Exception .
     */
    @Test
    public void PluginManager_returns_null_if_invalid_grantType() throws Exception {
        String invalidGrantType = "urn:x-dc1:oidc:hoge:code";

        PluginManager pm = new PluginManager();
        assertTrue("PluginManager failed to load plugins", (pm.size() > 0));

        PluginInfo pi = pm.getPluginsByGrantType(invalidGrantType);
        assertNull("PluginManager returns not null", pi);
    }

    /**
     * PluginManager_can_returns_list_of_AuthPlugin.
     *
     * @throws Exception .
     */
    @Test
    public void PluginManager_can_returns_list_of_AuthPlugin() throws Exception {
        boolean bFind = true;

        PluginManager pm = new PluginManager();
        List<PluginInfo> pl = pm.getPluginsByType(AuthConst.PLUGIN_TYPE);

        assertTrue("PluginManager returns 0 plugin.", (pl.size() > 0));
        for (int i = 0; i < pl.size(); i++) {
            PluginInfo pi = (PluginInfo) pl.get(i);
            if (!pi.getType().equals(AuthConst.PLUGIN_TYPE)) {
                bFind = false;
            }
        }
        assertTrue(bFind);
    }

}
```


Overlapping Code:
```

public class PluginManagerTest {
private static String previousConfig = null;
/**
* Preparation before executing this test class.
*/
@BeforeClass
public static void prepare() {
previousConfig = PersoniumUnitConfig.getPluginDefaultLoadClassname();
PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME,
AuthPluginLoaderForTesting.class.getName());
}
/**
* Clean up after executing this test class.
*/
@AfterClass
public static void cleanup() {
if (previousConfig == null) {
PersoniumUnitConfig.getProperties().remove(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME);
} else {
PersoniumUnitConfig.set(PersoniumUnitConfig.PLUGIN_DEFAULT_LOAD_CLASSNAME, previousConfig);
}
}
/**
* Test that PluginManager can find correct plugin by grantType.
*
* @throws Exception .
*/
@Test
public void PluginManger_can_find_AuthPlugin_by_grantType() throws Exception {
String testGrantType = AuthPluginLoaderForTesting.DEFAULT_GRANT_TYPES.iterator().next();
PluginManager pm = new PluginManager();
assertTrue("PluginManager failed to load plugins", (pm.size() > 0));
PluginInfo pi = (PluginInfo) pm.getPluginsByGrantType(testGrantType);
assertNotNull("getPluginsByGrantType [" + testGrantType + "] returns null", pi);
}
/**
* Test that PluginManager returns null if invalid grantType is presented.
*
* @throws Exception .
*/
@Test
public void PluginManager_returns_null_if_invalid_grantType() throws Exception {
String invalidGrantType = "urn:x-dc1:oidc:hoge:code";
PluginManager pm = new PluginManager();
assertTrue("PluginManager failed to load plugins", (pm.size() > 0));
PluginInfo pi = pm.getPluginsByGrantType(invalidGrantType);
assertNull("PluginManager returns not null", pi);
}
/**
* PluginManager_can_returns_list_of_AuthPlugin.
*
* @throws Exception .
*/
@Test
public void PluginManager_can_returns_list_of_AuthPlugin() throws Exception {
boolean bFind = true;
PluginManager pm = new PluginManager();
List<PluginInfo> pl = pm.getPluginsByType(AuthConst.PLUGIN_TYPE);
assertTrue("PluginManager returns 0 plugin.", (pl.size() > 0));
for
```
<Overlap Ratio: 0.9688090737240076>

---

--- 302 --
Question ID: 05201697c799520ed8fa317811217360130a5685_0
Original Code:
```
public class DummyEntitySelectionModelListener implements EntitySelectionModelListener {

	public boolean isOwlPropertyChanged() {
		return owlPropertyChanged;
	}


	public boolean isValidationTypeChanged() {
		return validationTypeChanged;
	}


	public boolean isSelectedEntityChanged() {
		return selectedEntityChanged;
	}


	public OWLPropertyItem getSelectedProperty() {
		return selectedProperty;
	}


	public OWLEntity getSelectedEntity() {
		return selectedEntity;
	}


	public ValidationType getSelectedValidationType() {
		return selectedValidationType;
	}


	public DummyEntitySelectionModelListener() {
		reset();
	}

	private boolean owlPropertyChanged;
	private boolean validationTypeChanged;
	private boolean selectedEntityChanged;
	
	private OWLPropertyItem selectedProperty;
	private OWLEntity selectedEntity;
	private ValidationType selectedValidationType;
	
	public void reset() {
		owlPropertyChanged=false;
		validationTypeChanged=false;
		selectedEntityChanged=false;
		selectedProperty=null;
		selectedEntity=null;
		selectedValidationType=null;
	}
	
	
	@Override
	public void owlPropertyChanged(OWLPropertyItem item) {
		selectedProperty=item;
		owlPropertyChanged=true;
	}

	@Override
	public void validationTypeChanged(ValidationType type) {
		selectedValidationType=type;
		validationTypeChanged=true;				
	}

	@Override
	public void selectedEntityChanged(OWLEntity entity) {
		selectedEntity=entity;
		selectedEntityChanged=true;		
	}

}
```


Overlapping Code:
```
ctionModelListener implements EntitySelectionModelListener {
public boolean isOwlPropertyChanged() {
return owlPropertyChanged;
}
public boolean isValidationTypeChanged() {
return validationTypeChanged;
}
public boolean isSelectedEntityChanged() {
return selectedEntityChanged;
}
public OWLPropertyItem getSelectedProperty() {
return selectedProperty;
}
public OWLEntity getSelectedEntity() {
return selectedEntity;
}
public ValidationType getSelectedValidationType() {
return selectedValidationType;
}
public DummyEntitySelectionModelListener() {
reset();
}
private boolean owlPropertyChanged;
private boolean validationTypeChanged;
private boolean selectedEntityChanged;

private OWLPropertyItem selectedProperty;
private OWLEntity selectedEntity;
private ValidationType selectedValidationType;

public void reset() {
owlPropertyChanged=false;
validationTypeChanged=false;
selectedEntityChanged=false;
selectedProperty=null;
selectedEntity=null;
selectedValidationType=null;
}


@Override
public void owlPropertyChanged(OWLPropertyItem item) {
selectedProperty=item;
owlPropertyChanged=true;
}
@Override
public void validationTypeChanged(ValidationType type) {
selectedValidationType=type;
validationTypeChanged=true; 
}
@Override
public void selectedEntityChanged(OWLEntity entity) {
selectedEntit
```
<Overlap Ratio: 0.948905109489051>

---

--- 303 --
Question ID: 4d6f6dcadfe12e2893b02064cebdad5f0a21dfba_0
Original Code:
```
class SampleTest {
  @Test
  void sample() {
    assertEquals(11, Kata.houseNumbersSum(new int[] {5, 1, 2, 3, 0, 1, 5, 0, 2}));
    assertEquals(13, Kata.houseNumbersSum(new int[] {4, 2, 1, 6, 0}));
    assertEquals(10, Kata.houseNumbersSum(new int[] {4, 1, 2, 3, 0, 10, 2}));
    assertEquals(0, Kata.houseNumbersSum(new int[] {0, 1, 2, 3, 4, 5}));
  }
}
```


Overlapping Code:
```
s SampleTest {
@Test
void sample() {
assertEquals(11, Kata.houseNumbersSum(new int[] {5, 1, 2, 3, 0, 1, 5, 0, 2}));
assertEquals(13, Kata.houseNumbersSum(new int[] {4, 2, 1, 6, 0}));
assertEquals(10, Kata.houseNumbersSum(new int[] {4, 1, 2, 3, 0, 10, 2}));
assertEquals(0, Kata.houseNumbersSum(new in
```
<Overlap Ratio: 0.9009009009009009>

---

--- 304 --
Question ID: b9aea6b7b81ad451b5ee08ec7644a93e03ff3ba9_0
Original Code:
```
public class GenericRDFGenerator extends RdfGenerator {

	private static Logger logger = LoggerFactory.getLogger(GenericRDFGenerator.class);

	protected R2RMLMappingManager mappingManager = new R2RMLMappingManager();
	protected JSONLDContextManager contextManager = new JSONLDContextManager();
	
	public enum InputType {
		CSV,
		JSON,
		XML,
		AVRO,
		EXCEL,
		JL,
		OBJECT
	};
	
	public GenericRDFGenerator() {
		this(null);
	}
	
	public GenericRDFGenerator(String selectionName) {
		super(selectionName);
	}

	public void addModel(R2RMLMappingIdentifier id) {
		this.mappingManager.addModel(id);
	}

    public void addContext(ContextIdentifier id) {
    	this.contextManager.addContext(id);
    }
    
    public JSONObject getContext(ContextIdentifier id) throws IOException {
    	return this.contextManager.getContext(null, id);
    }
    
    public WorksheetR2RMLJenaModelParser getModelParser(String modelName) throws JSONException, KarmaException {
    	return this.mappingManager.getModelParser(modelName);
    }
    
	private void generateRDF(String modelName, String sourceName,String contextName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters, 
			boolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, 
			List<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters)
					throws KarmaException, IOException {
		
		R2RMLMappingIdentifier id = mappingManager.getMappingIdentifierByName(modelName);
		ContextIdentifier contextId = contextManager.getContextIdentifier(contextName);
		JSONObject context = contextManager.getContext(contextName, contextId);
		initializeRDFWriters(writers, id, contextId, context);
		//Check if the parser for this model exists, else create one
		WorksheetR2RMLJenaModelParser modelParser = mappingManager.getModelParser(modelName);
		generateRDF(modelParser, sourceName, input, dataType, inputTypeParameters, addProvenance, writers, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, contextParameters);
	}

	private void initializeRDFWriters(List<KR2RMLRDFWriter> writers, R2RMLMappingIdentifier id,
			ContextIdentifier contextId, JSONObject context) {
		for (KR2RMLRDFWriter writer : writers) {
			if (writer instanceof JSONKR2RMLRDFWriter) {
				JSONKR2RMLRDFWriter t = (JSONKR2RMLRDFWriter)writer;
				t.setGlobalContext(context, contextId);
			}
			writer.setR2RMLMappingIdentifier(id);
		}
	}

	
	private void generateRDF(WorksheetR2RMLJenaModelParser modelParser, String sourceName, RDFGeneratorInputWrapper input, InputType dataType,  InputProperties inputTypeParameters,
			boolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, 
			List<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters) throws KarmaException, IOException {
		logger.debug("Generating rdf for " + sourceName);
		
		if(contextParameters == null)
		{
			contextParameters = ContextParametersRegistry.getInstance().getDefault();
			logger.debug("No context specified.  Defaulting to: " + contextParameters.getKarmaHome());
		}
		logger.debug("Initializing workspace for {}", sourceName);
		Workspace workspace = initializeWorkspace(contextParameters);
		logger.debug("Initialized workspace for {}", sourceName);
		try
		{
		
			logger.debug("Generating worksheet for {}", sourceName);
			Worksheet worksheet = null;
			if(input.getHeaders() != null) {
				worksheet = WorksheetGenerator.generateWorksheet(sourceName, input.getHeaders(), input.getValues(), workspace);
			}
			else {
				InputStream data = input.getInputAsStream();
				worksheet = WorksheetGenerator.generateWorksheet(sourceName, new BufferedInputStream(data), dataType, inputTypeParameters,
					workspace);
			}
			logger.debug("Generated worksheet for {}", sourceName);
			logger.debug("Parsing mapping for {}", sourceName);
			//Generate mappping data for the worksheet using the model parser
			KR2RMLMapping mapping = modelParser.parse();
			logger.debug("Parsed mapping for {}", sourceName);
			applyHistoryToWorksheet(workspace, worksheet, mapping);
			SuperSelection selection = SuperSelectionManager.DEFAULT_SELECTION;
			if (selectionName != null && !selectionName.trim().isEmpty())
				selection = worksheet.getSuperSelectionManager().getSuperSelection(selectionName);
			if (selection == null)
				return;
			//Generate RDF using the mapping data
			ErrorReport errorReport = new ErrorReport();
			if(rootStrategy == null)
			{
				rootStrategy = new SteinerTreeRootStrategy(new WorksheetDepthRootStrategy());
			}
			logger.debug("Generating output for {}", sourceName);
			KR2RMLWorksheetRDFGenerator rdfGen = new KR2RMLWorksheetRDFGenerator(worksheet,
			        workspace, writers,
			        addProvenance, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, 
			        mapping, errorReport, selection);
			rdfGen.generateRDF(true);
			logger.debug("Generated output for {}", sourceName);
		}
		catch( Exception e)
		{
			logger.error("Error occurred while generating RDF", e);
			throw new KarmaException(e.getMessage());
		}
		finally
		{
			removeWorkspace(workspace);
		}
		
		logger.debug("Generated rdf for {}", sourceName);
	}
	
	public void generateRDF(RDFGeneratorRequest request) throws KarmaException, IOException
	{
		generateRDF(request.getModelName(), request.getSourceName(), request.getContextName(), 
				request.getInput(), request.getDataType(), request.getInputTypeProperties(), request.isAddProvenance(), 
				request.getWriters(), request.getStrategy(), 
				request.getTripleMapToKill(), request.getTripleMapToStop(), request.getPOMToKill(), request.getContextParameters());
	}

	

}
```


Overlapping Code:
```
c class GenericRDFGenerator extends RdfGenerator {
private static Logger logger = LoggerFactory.getLogger(GenericRDFGenerator.class);
protected R2RMLMappingManager mappingManager = new R2RMLMappingManager();
protected JSONLDContextManager contextManager = new JSONLDContextManager();

public enum InputType {
CSV,
JSON,
XML,
AVRO,
EXCEL,
JL,
OBJECT
};

public GenericRDFGenerator() {
this(null);
}

public GenericRDFGenerator(String selectionName) {
super(selectionName);
}
public void addModel(R2RMLMappingIdentifier id) {
this.mappingManager.addModel(id);
}
public void addContext(ContextIdentifier id) {
this.contextManager.addContext(id);
}

public JSONObject getContext(ContextIdentifier id) throws IOException {
return this.contextManager.getContext(null, id);
}

public WorksheetR2RMLJenaModelParser getModelParser(String modelName) throws JSONException, KarmaException {
return this.mappingManager.getModelParser(modelName);
}

private void generateRDF(String modelName, String sourceName,String contextName, RDFGeneratorInputWrapper input, InputType dataType, InputProperties inputTypeParameters, 
boolean addProvenance, List<KR2RMLRDFWriter> writers, RootStrategy rootStrategy, 
List<String> tripleMapToKill, List<String> tripleMapToStop, List<String> POMToKill, ServletContextParameterMap contextParameters)
throws KarmaException, IOException {

R2RMLMappingIdentifier id = mappingManager.getMappingIdentifierByName(modelName);
ContextIdentifier contextId = contextManager.getContextIdentifier(contextName);
JSONObject context = contextManager.getContext(contextName, contextId);
initializeRDFWriters(writers, id, contextId, context);
//Check if the parser for this model exists, else create one
WorksheetR2RMLJenaModelParser modelParser = mappingManager.getModelParser(modelName);
generateRDF(modelParser, sourceName, input, dataType, inputTypeParameters, addProvenance, writers, rootStrategy, tripleMapToKill, tripleMapToStop, POMToKill, contextParameters);
}
private void initializeRDFWriters(List<KR2RMLRDFWriter> writers, R2RMLMappingIdentifier id,
ContextIdentifier contextId, JSONObject context) {
for (KR2RMLRDFWriter writer : writers) {
if (writer instanceof JSONKR2RMLRDFWriter) {
JSONKR2RMLRDFWriter t = (JSONKR2RMLRDFWriter)writer;
t.setGlobalContext(context, contextId);
}
wri
```
<Overlap Ratio: 0.9787234042553191>

---

--- 305 --
Question ID: ce26cb7a0fbee81d713706f4faea17a7415b46ea_0
Original Code:
```
public final class Markers {

    /** Caches markers loaded from resources file. */
    private static final List<Marker> MARKER_CACHE = Lists.newArrayList();
    /** Singleton for empty path. */
    private static final GeneralPath EMPTY_PATH = new GeneralPath();

    //region STATIC INSTANCES

    public static final BlankMarker BLANK = new BlankMarker();
    public static final CircleMarker CIRCLE = new CircleMarker();
    public static final SquareMarker SQUARE = new SquareMarker();
    public static final DiamondMarker DIAMOND = new DiamondMarker();
    public static final TriangleMarker TRIANGLE = new TriangleMarker();
    public static final StarMarker5 STAR = new StarMarker5();
    public static final StarMarker7 STAR7 = new StarMarker7();
    public static final StarMarker11 STAR11 = new StarMarker11();
    public static final PlusMarker PLUS = new PlusMarker();
    public static final CrossMarker CROSS = new CrossMarker();
    public static final TargetMarker TARGET = new TargetMarker();
    public static final ArrowMarker ARROW = new ArrowMarker();
    public static final GapArrowMarker GAP_ARROW = new GapArrowMarker();
    public static final ThickArrowMarker THICK_ARROW = new ThickArrowMarker();
    public static final ChevronMarker CHEVRON_MARKER = new ChevronMarker();
    public static final TriangleMarkerForward TRIANGLE_ARROW = new TriangleMarkerForward();
    public static final ArrowheadMarker ARROWHEAD = new ArrowheadMarker();
    public static final TeardropMarker TEARDROP = new TeardropMarker();
    public static final HappyFaceMarker HAPPYFACE = new HappyFaceMarker();
    public static final HouseMarker HOUSE = new HouseMarker();

    //endregion

    /**
     * Utility class
     */
    private Markers() {
    }

    /**
     * Retrieve list of available shapes.
     * @return list of marker constants
     */
    public static List<Marker> getAvailableMarkers() {
        if (MARKER_CACHE.isEmpty()) {
            ServiceLoader<Marker> loader = ServiceLoader.load(Marker.class);
            Iterables.addAll(MARKER_CACHE, loader);
        }
        return Collections.unmodifiableList(MARKER_CACHE);
    }

    /**
     * Blank marker.
     */
    public static class BlankMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            return EMPTY_PATH;
        }
    }

    /**
     * Circle marker.
     */
    public static class CircleMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            return new Ellipse2D.Double(p.getX() - radius, p.getY() - radius, 2 * radius, 2 * radius);
        }
    }

    /**
     * Square marker.
     */
    public static class SquareMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            return new Rectangle2D.Double(
                    p.getX() - radius / Math.sqrt(2),
                    p.getY() - radius / Math.sqrt(2),
                    2 * radius / Math.sqrt(2),
                    2 * radius / Math.sqrt(2));
        }
    }

    /**
     * Diamond marker.
     */
    public static class DiamondMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            path.lineTo((float) (x - radius), (float) y);
            path.lineTo((float) x, (float) (y + radius));
            path.lineTo((float) (x + radius), (float) y);
            path.closePath();
            return path;
        }
    }

    /**
     * Triangle marker, pointing up.
     */
    public static class TriangleMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.16667)),
                    (float) (y - radius * Math.sin(Math.PI * 1.16667)));
            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.83333)),
                    (float) (y - radius * Math.sin(Math.PI * 1.83333)));
            path.closePath();
            return path;
        }
    }

    /**
     * Five point star marker.
     */
    public static class StarMarker5 implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            for (int i = 0; i < 5; i++) {
                double theta = Math.PI / 2 + 2 * Math.PI * i / 5;
                path.lineTo((float) (x + radius * Math.cos(theta)),
                        (float) (y - radius * Math.sin(theta)));
                theta += Math.PI / 5;
                path.lineTo((float) (x + radius / Math.sqrt(8) * Math.cos(theta)),
                        (float) (y - radius / Math.sqrt(8) * Math.sin(theta)));
            }
            path.closePath();
            return path;
        }
    }

    /**
     * Seven point star marker.
     */
    public static class StarMarker7 implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            for (int i = 0; i < 7; i++) {
                double theta = Math.PI / 2 + 2 * Math.PI * i / 7;
                path.lineTo((float) (x + radius * Math.cos(theta)),
                        (float) (y - radius * Math.sin(theta)));
                theta += Math.PI / 7;
                path.lineTo((float) (x + radius / 2 * Math.cos(theta)),
                        (float) (y - radius / 2 * Math.sin(theta)));
            }
            path.closePath();
            return path;
        }
    }

    /**
     * Eleven point star marker.
     */
    public static class StarMarker11 implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            for (int i = 0; i < 11; i++) {
                double theta = Math.PI / 2 + 2 * Math.PI * i / 11;
                path.lineTo((float) (x + radius * Math.cos(theta)),
                        (float) (y - radius * Math.sin(theta)));
                theta += Math.PI / 11;
                path.lineTo((float) (x + radius / 1.5 * Math.cos(theta)),
                        (float) (y - radius / 1.5 * Math.sin(theta)));
            }
            path.closePath();
            return path;
        }
    }

    /**
     * Plus marker.
     */
    public static class PlusMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            path.lineTo((float) x, (float) (y + radius));
            path.moveTo((float) (x - radius), (float) y);
            path.lineTo((float) (x + radius), (float) y);
            return new Area(new BasicStroke(radius/3).createStrokedShape(path));
        }
    }

    /**
     * Cross marker.
     */
    public static class CrossMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            double r2 = 0.7 * radius;
            path.moveTo((float) (x - r2), (float) (y - r2));
            path.lineTo((float) (x + r2), (float) (y + r2));
            path.moveTo((float) (x - r2), (float) (y + r2));
            path.lineTo((float) (x + r2), (float) (y - r2));
            return new Area(new BasicStroke(radius/3).createStrokedShape(path));
        }
    }

    /**
     * Target marker (with circle and crosshairs).
     */
    public static class TargetMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) x, (float) (y - radius));
            path.lineTo((float) x, (float) (y + radius));
            path.moveTo((float) (x - radius), (float) y);
            path.lineTo((float) (x + radius), (float) y);
            path.append(new Ellipse2D.Double(x - .6 * radius, y - .6 * radius, 1.2 * radius, 1.2 * radius), false);
            return new Area(new BasicStroke(radius/6).createStrokedShape(path));
        }
    }

    /**
     * Arrow marker, pointing forward.
     */
    public static class GapArrowMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));
            path.lineTo((float) (x + radius), (float) y);
            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));
            path.moveTo((float) (x + .4*radius), (float) y);
            path.lineTo((float) (x - radius), (float) y);
            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);
        }
    }

    /**
     * Arrow marker, pointing forward.
     */
    public static class ArrowMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));
            path.lineTo((float) (x + radius), (float) y);
            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));
            path.moveTo((float) (x + .8*radius), (float) y);
            path.lineTo((float) (x - radius), (float) y);
            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);
        }
    }

    /**
     * Thicker arrow marker, pointing forward.
     */
    public static class ThickArrowMarker implements Marker {
        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX();
            double y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) (x + .5 * radius), (float) (y - .5 * radius));
            path.lineTo((float) (x + radius), (float) y);
            path.lineTo((float) (x + .5*radius), (float) (y + .5*radius));
            path.moveTo((float) (x + .6*radius), (float) y);
            path.lineTo((float) (x - radius), (float) y);
            Shape wideShape = new Area(new BasicStroke(radius/2).createStrokedShape(path));
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);
        }
    }

    /**
     * Chevron marker, pointing forward.
     */
    public static class ChevronMarker implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) (x + .3 * radius), (float) (y - .5 * radius));
            path.lineTo((float) (x + .8 * radius), (float) y);
            path.lineTo((float) (x + .3 * radius), (float) (y + .5 * radius));
            path.moveTo((float) (x - .7 * radius), (float) (y - .5 * radius));
            path.lineTo((float) (x - .2 * radius), (float) y);
            path.lineTo((float) (x - .7 * radius), (float) (y + .5 * radius));
            Shape wideShape = new Area(new BasicStroke(radius/4).createStrokedShape(path));
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(wideShape);
        }
    }

    /**
     * Triangle marker, pointing forward.
     */
    public static class TriangleMarkerForward implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            GeneralPath path = new GeneralPath();
            path.moveTo((float) (x + radius), (float) y);
            path.lineTo((float) (x + radius * Math.cos(Math.PI * 0.6667)),
                    (float) (y - radius * Math.sin(Math.PI * 0.6667)));
            path.lineTo((float) (x + radius * Math.cos(Math.PI * 1.3333)),
                    (float) (y - radius * Math.sin(Math.PI * 1.3333)));
            path.closePath();
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(path);
        }
    }

    /**
     * Arrowhead marker, pointing forward.
     */
    public static class ArrowheadMarker implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            GeneralPath gp10 = new GeneralPath();
            gp10.moveTo((float) (x + radius), (float) y);
            gp10.lineTo((float) (x - radius), (float) (y + radius));
            gp10.lineTo((float) (x - .5 * radius), (float) y);
            gp10.lineTo((float) (x - radius), (float) (y - radius));
            gp10.closePath();
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp10);
        }
    }

    /**
     * Teardrop marker, pointing forward.
     */
    public static class TeardropMarker implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            GeneralPath gp11 = new GeneralPath();
            gp11.moveTo(-.25f, -.5f);
            gp11.curveTo(-1f, -.5f, -1f, .5f, -.25f, .5f);
            gp11.curveTo(.5f, .5f, .5f, 0, 1f, 0);
            gp11.curveTo(.5f, 0, .5f, -.5f, -.2f, -.5f);
            gp11.closePath();
            gp11.transform(new AffineTransform(radius, 0, 0, radius, x, y));
            return AffineTransform.getRotateInstance(angle, x, y).createTransformedShape(gp11);
        }
    }

    /**
     * Happy face marker.
     */
    public static class HappyFaceMarker implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            Area a = new Area(new Ellipse2D.Double(x - radius, y - radius, 2 * radius, 2 * radius));
            a.subtract(new Area(new Ellipse2D.Double(x - radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));
            a.subtract(new Area(new Ellipse2D.Double(x + radius / 3 - radius / 6, y - radius / 2, radius / 3, radius / 3)));
            a.subtract(new Area(new Arc2D.Double(x - radius / 2, y - radius / 2, radius, radius, 200, 140, Arc2D.CHORD)));
            return a;
        }
    }

    /**
     * House-shaped marker.
     */
    public static class HouseMarker implements Marker {

        @Override
        public Shape create(Point2D p, double angle, float radius) {
            double x = p.getX(), y = p.getY();
            GeneralPath gp13 = new GeneralPath();
            gp13.moveTo(-.9f, -.9f);
            gp13.lineTo(.9f, -.9f);
            gp13.lineTo(.9f, .4f);
            gp13.lineTo(1f, .4f);
            gp13.lineTo(.75f, .625f);
            gp13.lineTo(.75f, 1f);
            gp13.lineTo(.5f, 1f);
            gp13.lineTo(.5f, .75f);
            gp13.lineTo(0f, 1f);
            gp13.lineTo(-1f, .4f);
            gp13.lineTo(-.9f, .4f);
            gp13.lineTo(-.9f, -.9f);
            gp13.closePath();
            gp13.transform(new AffineTransform(radius, 0, 0, -radius, x, y));
            return gp13;
        }
    }

}
```


Overlapping Code:
```
** Caches markers loaded from resources file. */
private static final List<Marker> MARKER_CACHE = Lists.newArrayList();
/** Singleton for empty path. */
private static final GeneralPath EMPTY_PATH = new GeneralPath();
//region STATIC INSTANCES
public static final BlankMarker BLANK = new BlankMarker();
public static final CircleMarker CIRCLE = new CircleMarker();
public static final SquareMarker SQUARE = new SquareMarker();
public static final DiamondMarker DIAMOND = new DiamondMarker();
public static final TriangleMarker TRIANGLE = new TriangleMarker();
public static final StarMarker5 STAR = new StarMarker5();
public static final StarMarker7 STAR7 = new StarMarker7();
public static final StarMarker11 STAR11 = new StarMarker11();
public static final PlusMarker PLUS = new PlusMarker();
public static final CrossMarker CROSS = new CrossMarker();
public static final TargetMarker TARGET = new TargetMarker();
public static final ArrowMarker ARROW = new ArrowMarker();
public static final GapArrowMarker GAP_ARROW = new GapArrowMarker();
public static final ThickArrowMarker THICK_ARROW = new ThickArrowMarker();
public static final ChevronMarker CHEVRON_MARKER = new ChevronMarker();
public static final TriangleMarkerForward TRIANGLE_ARROW = new TriangleMarkerForward();
public static final ArrowheadMarker ARROWHEAD = new ArrowheadMarker();
public static final TeardropMarker TEARDROP = new TeardropMarker();
public static final HappyFaceMarker HAPPYFACE = new HappyFaceMarker();
public static final HouseMarker HOUSE = new HouseMarker();
//endregion
/**
* Utility class
*/
private Markers() {
}
/**
* Retrieve list of available shapes.
* @return list of marker constants
*/
public static List<Marker> getAvailableMarkers() {
if (MARKER_CACHE.isEmpty()) {
ServiceLoader<Marker> loader = ServiceLoader.load(Marker.class);
Iterables.addAll(MARKER_CACHE, loader);
}
return Collections.unmodifiableList(MARKER_CACHE);
}
/**
* Blank marker.
*/
public static class BlankMarker implements Marker {
@Override
public Shape create(Point2D p, double angle, float radius) {
return EMPTY_PATH;
}
}
/**
* Circle marker.
*/
public static class CircleMarker
```
<Overlap Ratio: 0.9746146872166818>

---

--- 306 --
Question ID: 13e11f1140617faf33692a297bbf2caf0f5080d1_0
Original Code:
```
public class NamedEntity {

	/**
	 * Type of Named Entity
	 */
	public enum Type {
		Organisation,
		Person,
		Location
	}

	/**
	 * Type of Named Entity
	 */
	public Type type;
	/**
	 * Unique root name of entity
	 */
	public String rootName;
	/**
	 * The string that resulted in a match
	 */
	public String stringMatched;
	/**
	 * Start token of the match
	 */
	public int startToken;
	/**
	 * Stop token of the match
	 */
	public int stopToken;
	/**
	 * Start char of the match
	 */
	public int startChar;
	/**
	 * Stop char of the match
	 */
	public int stopChar;

	@Override
	public String toString() {
		return "NamedEntity [type=" + type + ", rootName=" + rootName
				+ ", startToken=" + startToken + ", stopToken=" + stopToken
				+ "]";
	}

	public NamedEntity() {

	}

	public NamedEntity(String rootName, Type type) {
		this.rootName = rootName;
		this.type = type;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((rootName == null) ? 0 : rootName.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		final NamedEntity other = (NamedEntity) obj;
		if (rootName == null) {
			if (other.rootName != null)
				return false;
		} else if (!rootName.equals(other.rootName))
			return false;
		return true;
	}
}
```


Overlapping Code:
```
ity {
/**
* Type of Named Entity
*/
public enum Type {
Organisation,
Person,
Location
}
/**
* Type of Named Entity
*/
public Type type;
/**
* Unique root name of entity
*/
public String rootName;
/**
* The string that resulted in a match
*/
public String stringMatched;
/**
* Start token of the match
*/
public int startToken;
/**
* Stop token of the match
*/
public int stopToken;
/**
* Start char of the match
*/
public int startChar;
/**
* Stop char of the match
*/
public int stopChar;
@Override
public String toString() {
return "NamedEntity [type=" + type + ", rootName=" + rootName
+ ", startToken=" + startToken + ", stopToken=" + stopToken
+ "]";
}
public NamedEntity() {
}
public NamedEntity(String rootName, Type type) {
this.rootName = rootName;
this.type = type;
}
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result
+ ((rootName == null) ? 0 : rootName.hashCode());
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
if (getClass() != obj.getClass())
return false;
final NamedEntity other = (NamedEntity) obj;
if (rootName == null) {
if (other.rootName != null)
return false;
} else if (!rootName.equals(other.rootName)
```
<Overlap Ratio: 0.9593246354566385>

---

--- 307 --
Question ID: fe2a5eda25f17d67f54f1f53386c5d5251cc2005_0
Original Code:
```
public class TestEnumToKernelConstantMappings {

    @Test
    public void testConnectionRetainModes() {
        assertEquals(ConnectionRetainModes.CONN_RETAIN_ALWAYS,
            ConnectionRetainMode.ALWAYS.toKernelConstant());
        assertEquals(ConnectionRetainMode.ALWAYS,
            ConnectionRetainMode.fromKernelConstant(
                ConnectionRetainModes.CONN_RETAIN_ALWAYS));
        assertEquals(ConnectionRetainMode.ALWAYS.toKernelConstant(),
            ConnectionRetainMode.ALWAYS.ordinal());

        assertEquals(ConnectionRetainModes.CONN_RETAIN_DEMAND,
            ConnectionRetainMode.ON_DEMAND.toKernelConstant());
        assertEquals(ConnectionRetainMode.ON_DEMAND,
            ConnectionRetainMode.fromKernelConstant(
                ConnectionRetainModes.CONN_RETAIN_DEMAND));
        assertEquals(ConnectionRetainMode.ON_DEMAND.toKernelConstant(),
            ConnectionRetainMode.ON_DEMAND.ordinal());

        assertEquals(ConnectionRetainModes.CONN_RETAIN_TRANS,
            ConnectionRetainMode.TRANSACTION.toKernelConstant());
        assertEquals(ConnectionRetainMode.TRANSACTION,
            ConnectionRetainMode.fromKernelConstant(
                ConnectionRetainModes.CONN_RETAIN_TRANS));
        assertEquals(ConnectionRetainMode.TRANSACTION.toKernelConstant(),
            ConnectionRetainMode.TRANSACTION.ordinal());

        assertEquals(getConstantCount(ConnectionRetainModes.class),
            ConnectionRetainMode.values().length);
    }

    @Test
    public void testDetachState() {
        assertEquals(DetachState.DETACH_ALL,
            DetachStateType.ALL.toKernelConstant());
        assertEquals(DetachStateType.ALL,
            DetachStateType.fromKernelConstant(DetachState.DETACH_ALL));
        assertEquals(DetachStateType.ALL.toKernelConstant(),
            DetachStateType.ALL.ordinal());

        assertEquals(DetachState.DETACH_FETCH_GROUPS,
            DetachStateType.FETCH_GROUPS.toKernelConstant());
        assertEquals(DetachStateType.FETCH_GROUPS,
            DetachStateType.fromKernelConstant(
                DetachState.DETACH_FETCH_GROUPS));
        assertEquals(DetachStateType.FETCH_GROUPS.toKernelConstant(),
            DetachStateType.FETCH_GROUPS.ordinal());

        assertEquals(DetachState.DETACH_LOADED,
            DetachStateType.LOADED.toKernelConstant());
        assertEquals(DetachStateType.LOADED,
            DetachStateType.fromKernelConstant(DetachState.DETACH_LOADED));
        assertEquals(DetachStateType.LOADED.toKernelConstant(),
            DetachStateType.LOADED.ordinal());

        // subtract 1 for DetachState.DETACH_FGS, which is deprecated
        assertEquals(getConstantCount(DetachState.class) - 1,
            DetachStateType.values().length);
    }

    @Test
    public void testRestoreState() {
        assertEquals(RestoreState.RESTORE_ALL,
            RestoreStateType.ALL.toKernelConstant());
        assertEquals(RestoreStateType.ALL,
            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_ALL));
        assertEquals(RestoreStateType.ALL.toKernelConstant(),
            RestoreStateType.ALL.ordinal());

        assertEquals(RestoreState.RESTORE_IMMUTABLE,
            RestoreStateType.IMMUTABLE.toKernelConstant());
        assertEquals(RestoreStateType.IMMUTABLE,
            RestoreStateType.fromKernelConstant(
                RestoreState.RESTORE_IMMUTABLE));
        assertEquals(RestoreStateType.IMMUTABLE.toKernelConstant(),
            RestoreStateType.IMMUTABLE.ordinal());

        assertEquals(RestoreState.RESTORE_NONE,
            RestoreStateType.NONE.toKernelConstant());
        assertEquals(RestoreStateType.NONE,
            RestoreStateType.fromKernelConstant(RestoreState.RESTORE_NONE));
        assertEquals(RestoreStateType.NONE.toKernelConstant(),
            RestoreStateType.NONE.ordinal());

        assertEquals(getConstantCount(RestoreState.class),
            RestoreStateType.values().length);
    }

    @Test
    public void testAutoClear() {
        assertEquals(AutoClear.CLEAR_ALL, AutoClearType.ALL.toKernelConstant());
        assertEquals(AutoClearType.ALL,
            AutoClearType.fromKernelConstant(AutoClear.CLEAR_ALL));
        assertEquals(AutoClearType.ALL.toKernelConstant(),
            AutoClearType.ALL.ordinal());

        assertEquals(AutoClear.CLEAR_DATASTORE,
            AutoClearType.DATASTORE.toKernelConstant());
        assertEquals(AutoClearType.DATASTORE,
            AutoClearType.fromKernelConstant(AutoClear.CLEAR_DATASTORE));
        assertEquals(AutoClearType.DATASTORE.toKernelConstant(),
            AutoClearType.DATASTORE.ordinal());

        assertEquals(getConstantCount(AutoClear.class),
            AutoClearType.values().length);
    }

    @Test
    public void testAutoDetach() {
        // Commenting out constant count test for now. Subtracting 2 is brittle.
        // assertEquals(getConstantCount(AutoDetach.class) - 2,
        //    AutoDetachType.values().length);

        assertEquals(EnumSet.of(AutoDetachType.CLOSE),
            AutoDetachType.toEnumSet(AutoDetach.DETACH_CLOSE));
        assertEquals(AutoDetach.DETACH_CLOSE,
            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.CLOSE)));

        assertEquals(EnumSet.of(AutoDetachType.COMMIT),
            AutoDetachType.toEnumSet(AutoDetach.DETACH_COMMIT));
        assertEquals(AutoDetach.DETACH_COMMIT,
            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.COMMIT)));

        assertEquals(EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ),
            AutoDetachType.toEnumSet(AutoDetach.DETACH_NONTXREAD));
        assertEquals(AutoDetach.DETACH_NONTXREAD,
            AutoDetachType.fromEnumSet(
                EnumSet.of(AutoDetachType.NON_TRANSACTIONAL_READ)));

        assertEquals(EnumSet.of(AutoDetachType.ROLLBACK),
            AutoDetachType.toEnumSet(AutoDetach.DETACH_ROLLBACK));
        assertEquals(AutoDetach.DETACH_ROLLBACK,
            AutoDetachType.fromEnumSet(EnumSet.of(AutoDetachType.ROLLBACK)));


        assertEquals(EnumSet.of(AutoDetachType.CLOSE, AutoDetachType.COMMIT),
            AutoDetachType.toEnumSet(
                AutoDetach.DETACH_CLOSE | AutoDetach.DETACH_COMMIT));
        assertEquals(AutoDetach.DETACH_ROLLBACK | AutoDetach.DETACH_CLOSE,
            AutoDetachType.fromEnumSet(
                EnumSet.of(AutoDetachType.ROLLBACK, AutoDetachType.CLOSE)));


        assertEquals(EnumSet.allOf(AutoDetachType.class),
            AutoDetachType.toEnumSet(
                    AutoDetach.DETACH_NONE
                    | AutoDetach.DETACH_CLOSE
                    | AutoDetach.DETACH_COMMIT
                    | AutoDetach.DETACH_NONTXREAD
                    | AutoDetach.DETACH_ROLLBACK));
        assertEquals( AutoDetach.DETACH_NONE
                    | AutoDetach.DETACH_CLOSE
                    | AutoDetach.DETACH_COMMIT
                    | AutoDetach.DETACH_NONTXREAD
                    | AutoDetach.DETACH_ROLLBACK,
            AutoDetachType.fromEnumSet(EnumSet.allOf(AutoDetachType.class)));
    }

    @Test
    public void testCallbackMode() {
        assertEquals(getConstantCount(CallbackModes.class),
            CallbackMode.values().length);

        assertEquals(EnumSet.of(CallbackMode.FAIL_FAST),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_FAIL_FAST));
        assertEquals(CallbackModes.CALLBACK_FAIL_FAST,
            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.FAIL_FAST)));

        assertEquals(EnumSet.of(CallbackMode.IGNORE),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_IGNORE));
        assertEquals(CallbackModes.CALLBACK_IGNORE,
            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.IGNORE)));

        assertEquals(EnumSet.of(CallbackMode.LOG),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_LOG));
        assertEquals(CallbackModes.CALLBACK_LOG,
            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.LOG)));

        assertEquals(EnumSet.of(CallbackMode.RETHROW),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_RETHROW));
        assertEquals(CallbackModes.CALLBACK_RETHROW,
            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.RETHROW)));

        assertEquals(EnumSet.of(CallbackMode.ROLLBACK),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK));
        assertEquals(CallbackModes.CALLBACK_ROLLBACK,
            CallbackMode.fromEnumSet(EnumSet.of(CallbackMode.ROLLBACK)));


        assertEquals(EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE),
            CallbackMode.toEnumSet(CallbackModes.CALLBACK_ROLLBACK
                | CallbackModes.CALLBACK_IGNORE));
        assertEquals(
            CallbackModes.CALLBACK_ROLLBACK | CallbackModes.CALLBACK_IGNORE,
            CallbackMode.fromEnumSet(
                EnumSet.of(CallbackMode.ROLLBACK, CallbackMode.IGNORE)));


        assertEquals(EnumSet.allOf(CallbackMode.class),
            CallbackMode.toEnumSet(
                CallbackModes.CALLBACK_FAIL_FAST
                    | CallbackModes.CALLBACK_IGNORE
                    | CallbackModes.CALLBACK_LOG
                    | CallbackModes.CALLBACK_RETHROW
                    | CallbackModes.CALLBACK_ROLLBACK));
        assertEquals(CallbackModes.CALLBACK_FAIL_FAST
                    | CallbackModes.CALLBACK_IGNORE
                    | CallbackModes.CALLBACK_LOG
                    | CallbackModes.CALLBACK_RETHROW
                    | CallbackModes.CALLBACK_ROLLBACK,
            CallbackMode.fromEnumSet(EnumSet.allOf(CallbackMode.class)));
    }

    @Test
    public void testQueryOperationTypes() {
        assertEquals(QueryOperations.OP_SELECT,
            QueryOperationType.SELECT.toKernelConstant());
        assertEquals(QueryOperationType.SELECT,
            QueryOperationType.fromKernelConstant(
                QueryOperations.OP_SELECT));
        assertEquals(QueryOperationType.SELECT.toKernelConstant(),
            QueryOperationType.SELECT.ordinal() + 1);

        assertEquals(QueryOperations.OP_UPDATE,
            QueryOperationType.UPDATE.toKernelConstant());
        assertEquals(QueryOperationType.UPDATE,
            QueryOperationType.fromKernelConstant(
                QueryOperations.OP_UPDATE));
        assertEquals(QueryOperationType.UPDATE.toKernelConstant(),
            QueryOperationType.UPDATE.ordinal() + 1);

        assertEquals(QueryOperations.OP_DELETE,
            QueryOperationType.DELETE.toKernelConstant());
        assertEquals(QueryOperationType.DELETE,
            QueryOperationType.fromKernelConstant(
                QueryOperations.OP_DELETE));
        assertEquals(QueryOperationType.DELETE.toKernelConstant(),
            QueryOperationType.DELETE.ordinal() + 1);

        assertEquals(getConstantCount(QueryOperations.class),
            QueryOperationType.values().length);
    }

    private int getConstantCount(Class cls) {
        return cls.getDeclaredFields().length;
    }
}
```


Overlapping Code:
```
elConstantMappings {
@Test
public void testConnectionRetainModes() {
assertEquals(ConnectionRetainModes.CONN_RETAIN_ALWAYS,
ConnectionRetainMode.ALWAYS.toKernelConstant());
assertEquals(ConnectionRetainMode.ALWAYS,
ConnectionRetainMode.fromKernelConstant(
ConnectionRetainModes.CONN_RETAIN_ALWAYS));
assertEquals(ConnectionRetainMode.ALWAYS.toKernelConstant(),
ConnectionRetainMode.ALWAYS.ordinal());
assertEquals(ConnectionRetainModes.CONN_RETAIN_DEMAND,
ConnectionRetainMode.ON_DEMAND.toKernelConstant());
assertEquals(ConnectionRetainMode.ON_DEMAND,
ConnectionRetainMode.fromKernelConstant(
ConnectionRetainModes.CONN_RETAIN_DEMAND));
assertEquals(ConnectionRetainMode.ON_DEMAND.toKernelConstant(),
ConnectionRetainMode.ON_DEMAND.ordinal());
assertEquals(ConnectionRetainModes.CONN_RETAIN_TRANS,
ConnectionRetainMode.TRANSACTION.toKernelConstant());
assertEquals(ConnectionRetainMode.TRANSACTION,
ConnectionRetainMode.fromKernelConstant(
ConnectionRetainModes.CONN_RETAIN_TRANS));
assertEquals(ConnectionRetainMode.TRANSACTION.toKernelConstant(),
ConnectionRetainMode.TRANSACTION.ordinal());
assertEquals(getConstantCount(ConnectionRetainModes.class),
ConnectionRetainMode.values().length);
}
@Test
public void testDetachState() {
assertEquals(DetachState.DETACH_ALL,
DetachStateType.ALL.toKernelConstant());
assertEquals(DetachStateType.ALL,
DetachStateType.fromKernelConstant(DetachState.DETACH_ALL));
assertEquals(DetachStateType.ALL.toKernelConstant(),
DetachStateType.ALL.ordinal());
assertEquals(DetachState.DETACH_FETCH_GROUPS,
DetachStateType.FETCH_GROUPS.toKernelConstant());
assertEquals(DetachStateType.FETCH_GROUPS,
DetachStateType.fromKernelConstant(
DetachState.DETACH_FETCH_GROUPS));
assertEquals(DetachStateType.FETCH_GROUPS.toKernelConstant(),
DetachStateType.FETCH_GROUPS.ordinal());
assertEquals(DetachState.DETACH_LOADED,
DetachStateType.LOADED.toKernelConstant());
assertEquals(DetachStateType.LOADED,
DetachStateType.fromKernelConstant(DetachState.DETACH_LOADED));
assertEqua
```
<Overlap Ratio: 0.9803921568627451>

---

--- 308 --
Question ID: c153f8e62848c842c2c292edb1b038207498f4a6_0
Original Code:
```
public class WonAssemblerTest {
    private static final String RESOURCE_FILE = "/won-signed-messages/create-atom-msg.trig";
    private static final String ATOM_CORE_DATA_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data";
    private static final String ATOM_CORE_DATA_SIG_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data-sig";

    @Test
    public void testAssembleOneGraphSignature() throws Exception {
        // The Signingframework reader cannot reproduce the correct graph
        // structure, it has problems with blank nodes [] parts.
        // GraphCollection gc = TriGPlusReader.readFile(inFile);
        // create dataset that contains atom core data graph
        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                        new String[] { ATOM_CORE_DATA_URI });
        // convert to graph collection
        GraphCollection gc = ModelConverter.modelToGraphCollection(ATOM_CORE_DATA_URI, testDataset);
        // create mock signature
        SignatureData mockSigData = createMockSignature();
        gc.setSignature(mockSigData);
        // test assemble()
        WonAssembler.assemble(gc, testDataset, ATOM_CORE_DATA_SIG_URI);
        // use for debugging output
        // TestSigningUtils.writeToTempFile(testDataset);
        // extract names of the named graphs
        List<String> namesList = RdfUtils.getModelNames(testDataset);
        // do some checks to make sure there is 1 signed names graph
        Assert.assertEquals("should be one named graph with data and one named graph with signature", 2,
                        namesList.size());
        Assert.assertTrue("should be some triples in signature graph",
                        testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements().hasNext());
        Assert.assertFalse(testDataset.getDefaultModel().listStatements().hasNext());
        int triplesCounter = TestSigningUtils
                        .countTriples(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements());
        Set<String> subjs = TestSigningUtils.getSubjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));
        Set<String> objs = TestSigningUtils.getUriResourceObjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));
        Assert.assertEquals("signature graph should contain 11 triples", 11, triplesCounter);
        Assert.assertTrue("signed graph name should be an object in signature triples",
                        objs.contains(ATOM_CORE_DATA_URI));
        Assert.assertTrue("signature graph name should be a subject in signature triples",
                        subjs.contains(ATOM_CORE_DATA_SIG_URI));
    }

    private SignatureData createMockSignature() throws NoSuchAlgorithmException {
        SignatureData mockSigData = new SignatureData();
        mockSigData.setHash(new BigInteger(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }));
        mockSigData.setSignature("\"blahblahSignature\"");
        mockSigData.setDigestGen(MessageDigest.getInstance("sha-256"));
        mockSigData.setCanonicalizationMethod("blahblahCanonicalizationMethod");
        mockSigData.setGraphDigestMethod("blahblahGraphDigestMethod");
        mockSigData.setSerializationMethod("blahblahSerializationmethod");
        mockSigData.setSignatureMethod("blahblahSigMathod");
        // mockSigData.setVerificationCertificateUri("\"blahblahVerificationCertificate\"");
        mockSigData.setVerificationCertificate("<http://localhost:8080/blahblah/certificate>");
        return mockSigData;
    }
}
```


Overlapping Code:
```
lass WonAssemblerTest {
private static final String RESOURCE_FILE = "/won-signed-messages/create-atom-msg.trig";
private static final String ATOM_CORE_DATA_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data";
private static final String ATOM_CORE_DATA_SIG_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data-sig";
@Test
public void testAssembleOneGraphSignature() throws Exception {
// The Signingframework reader cannot reproduce the correct graph
// structure, it has problems with blank nodes [] parts.
// GraphCollection gc = TriGPlusReader.readFile(inFile);
// create dataset that contains atom core data graph
Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
new String[] { ATOM_CORE_DATA_URI });
// convert to graph collection
GraphCollection gc = ModelConverter.modelToGraphCollection(ATOM_CORE_DATA_URI, testDataset);
// create mock signature
SignatureData mockSigData = createMockSignature();
gc.setSignature(mockSigData);
// test assemble()
WonAssembler.assemble(gc, testDataset, ATOM_CORE_DATA_SIG_URI);
// use for debugging output
// TestSigningUtils.writeToTempFile(testDataset);
// extract names of the named graphs
List<String> namesList = RdfUtils.getModelNames(testDataset);
// do some checks to make sure there is 1 signed names graph
Assert.assertEquals("should be one named graph with data and one named graph with signature", 2,
namesList.size());
Assert.assertTrue("should be some triples in signature graph",
testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements().hasNext());
Assert.assertFalse(testDataset.getDefaultModel().listStatements().hasNext());
int triplesCounter = TestSigningUtils
.countTriples(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements());
Set<String> subjs = TestSigningUtils.getSubjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));
Set<String> objs = TestSigningUtils.getUriResourceObjects(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI));
Assert.assertEquals("signature graph should contain 11 triples", 11, triplesCounter);
Assert.assertTrue("signed graph name should be an 
```
<Overlap Ratio: 0.9853345554537122>

---

--- 309 --
Question ID: cfc0e7d283fd37db786eeef8b0877feba002ecf5_2
Original Code:
```
public class Contacts {
    private static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {
        int queries = in.nextInt();
        performQueries(queries);
    }

    private static void performQueries(int queries){
        Trie contacts = new Trie();

        while (queries-- > 0){
            String operation = in.next();
            String name = in.next();

            if(operation.charAt(0) == 'a'){
                contacts.addWord(name);
            } else {
                System.out.println(contacts.numberOfClosestEntries(name));
            }
        }

        contacts.print();
    }
}
```


Overlapping Code:
```
 {
private static Scanner in = new Scanner(System.in);
public static void main(String[] args) {
int queries = in.nextInt();
performQueries(queries);
}
private static void performQueries(int queries){
Trie contacts = new Trie();
while (queries-- > 0){
String operation = in.next();
String name = in.next();
if(operation.charAt(0) == 'a'){
contacts.addWord(name);
} else {
System.out.println(contacts.numberOfClosestEntries(name)
```
<Overlap Ratio: 0.8970588235294118>

---

--- 310 --
Question ID: 4b2f466a2efbfb403ac3a41f85d58dc900a7f8d6_0
Original Code:
```
public class ModifierTracker {
	/**
	 * Add KeyListeners to everything in an applet.
	 * <P>
	 * Unsigned applets can't simply add an event listener to the toolkit for
	 * security reasons, so this method provides an alternative approach.
	 * <P>
	 * This alternative should work in controlled environments where components
	 * are not added to an applet after this method is called, but in other
	 * cases it might fail.
	 * 
	 * @param applet
	 *            the applet to track
	 */
	public static void track(JApplet applet) {
		if (isActive() == false) {
			track(applet.getContentPane());
		}
	}

	private static KeyListener keyListener = new KeyListener() {
		public void keyTyped(KeyEvent e) {
		}

		public void keyPressed(KeyEvent e) {
			key(e.getKeyCode(), true);
		}

		public void keyReleased(KeyEvent e) {
			key(e.getKeyCode(), false);
		}

		private void key(int code, boolean pressed) {
			if (code == KeyEvent.VK_ALT) {
				if (alt != pressed) {
					alt = pressed;
					fireAltChangeListeners();
				}
			} else if (code == KeyEvent.VK_ALT_GRAPH) {
				if (altGraph != pressed) {
					altGraph = pressed;
					fireAltGraphChangeListeners();
				}
			} else if (code == KeyEvent.VK_CONTROL) {
				if (ctrl != pressed) {
					ctrl = pressed;
					fireControlChangeListeners();
				}
			} else if (code == KeyEvent.VK_META) {
				if (meta != pressed) {
					meta = pressed;
					fireMetaChangeListeners();
				}
			} else if (code == KeyEvent.VK_SHIFT) {
				if (shift != pressed) {
					shift = pressed;
					fireShiftChangeListeners();
				}
			}
		}
	};

	private static void track(Component c) {
		c.addKeyListener(keyListener);

		if (c instanceof Container) {
			Container container = (Container) c;
			for (int a = 0; a < container.getComponentCount(); a++) {
				track(container.getComponent(a));
			}
		}
	}

	private static boolean alt = false;
	private static boolean altGraph = false;
	private static boolean meta = false;
	private static boolean shift = false;
	private static boolean ctrl = false;

	private static boolean securityProblem = false;
	static {
		try {
			Toolkit.getDefaultToolkit().addAWTEventListener(
					new AWTEventListener() {
						public void eventDispatched(AWTEvent e) {
							if (e instanceof KeyEvent) {
								KeyEvent k = (KeyEvent) e;
								boolean pressed = k.getID() == KeyEvent.KEY_PRESSED;
								int code = k.getKeyCode();
								switch (code) {
								case KeyEvent.VK_ALT:
									if (alt != pressed) {
										alt = pressed;
										fireAltChangeListeners();
									}
									break;
								case KeyEvent.VK_ALT_GRAPH:
									if (altGraph != pressed) {
										altGraph = pressed;
										fireAltGraphChangeListeners();
									}
									break;
								case KeyEvent.VK_META:
									if (meta != pressed) {
										meta = pressed;
										fireMetaChangeListeners();
									}
									break;
								case KeyEvent.VK_SHIFT:
									if (shift != pressed) {
										shift = pressed;
										fireShiftChangeListeners();
									}
									break;
								case KeyEvent.VK_CONTROL:
									if (ctrl != pressed) {
										ctrl = pressed;
										fireControlChangeListeners();
									}
									break;
								}
							}
						}
					}, AWTEvent.KEY_EVENT_MASK);
		} catch (SecurityException e) {
			System.err
					.println("the following exception means the ModifierTracker cannot globally listen to modifiers.");
			e.printStackTrace();
			securityProblem = true;
		}
	}

	public static boolean isActive() {
		return !securityProblem;
	}

	private static List<ChangeListener> altListeners;
	private static List<ChangeListener> altGraphListeners;
	private static List<ChangeListener> metaListeners;
	private static List<ChangeListener> shiftListeners;
	private static List<ChangeListener> ctrlListeners;

	public static int getModifiers() {
		return (alt ? InputEvent.ALT_MASK : 0)
				+ (altGraph ? InputEvent.ALT_GRAPH_MASK : 0)
				+ (shift ? InputEvent.SHIFT_MASK : 0)
				+ (ctrl ? InputEvent.CTRL_MASK : 0)
				+ (meta ? InputEvent.META_MASK : 0);

	}

	public static void addAltChangeListener(ChangeListener l) {
		if (altListeners == null)
			altListeners = new ArrayList<>();
		if (altListeners.contains(l))
			return;
		altListeners.add(l);
	}

	public static void addAltGraphChangeListener(ChangeListener l) {
		if (altGraphListeners == null)
			altGraphListeners = new ArrayList<>();
		if (altGraphListeners.contains(l))
			return;
		altGraphListeners.add(l);
	}

	public static void addMetaChangeListener(ChangeListener l) {
		if (metaListeners == null)
			metaListeners = new ArrayList<>();
		if (metaListeners.contains(l))
			return;
		metaListeners.add(l);
	}

	public static void addShiftChangeListener(ChangeListener l) {
		if (shiftListeners == null)
			shiftListeners = new ArrayList<>();
		if (shiftListeners.contains(l))
			return;
		shiftListeners.add(l);
	}

	public static void addControlChangeListener(ChangeListener l) {
		if (ctrlListeners == null)
			ctrlListeners = new ArrayList<>();
		if (ctrlListeners.contains(l))
			return;
		ctrlListeners.add(l);
	}

	public static boolean isAltDown() {
		return alt;
	}

	public static boolean isAltGraphyDown() {
		return altGraph;
	}

	public static boolean isShiftDown() {
		return shift;
	}

	public static boolean isMetaDown() {
		return meta;
	}

	public static boolean isControlDown() {
		return ctrl;
	}

	public static void removeAltChangeListener(ChangeListener l) {
		if (altListeners == null)
			return;
		altListeners.remove(l);
	}

	public static void removeAltGraphChangeListener(ChangeListener l) {
		if (altGraphListeners == null)
			return;
		altGraphListeners.remove(l);
	}

	public static void removeMetaChangeListener(ChangeListener l) {
		if (metaListeners == null)
			return;
		metaListeners.remove(l);
	}

	public static void removeShiftChangeListener(ChangeListener l) {
		if (shiftListeners == null)
			return;
		shiftListeners.remove(l);
	}

	public static void removeControlChangeListener(ChangeListener l) {
		if (ctrlListeners == null)
			return;
		ctrlListeners.remove(l);
	}

	private static void fireAltGraphChangeListeners() {
		if (altGraphListeners == null)
			return;
		for (int a = 0; a < altGraphListeners.size(); a++) {
			ChangeListener l = altGraphListeners.get(a);
			try {
				l.stateChanged(new ChangeEvent(ModifierTracker.class));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private static void fireAltChangeListeners() {
		if (altListeners == null)
			return;
		for (int a = 0; a < altListeners.size(); a++) {
			ChangeListener l = altListeners.get(a);
			try {
				l.stateChanged(new ChangeEvent(ModifierTracker.class));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private static void fireControlChangeListeners() {
		if (ctrlListeners == null)
			return;
		for (int a = 0; a < ctrlListeners.size(); a++) {
			ChangeListener l = ctrlListeners.get(a);
			try {
				l.stateChanged(new ChangeEvent(ModifierTracker.class));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private static void fireMetaChangeListeners() {
		if (metaListeners == null)
			return;
		for (int a = 0; a < metaListeners.size(); a++) {
			ChangeListener l = metaListeners.get(a);
			try {
				l.stateChanged(new ChangeEvent(ModifierTracker.class));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	private static void fireShiftChangeListeners() {
		if (shiftListeners == null)
			return;
		for (int a = 0; a < shiftListeners.size(); a++) {
			ChangeListener l = shiftListeners.get(a);
			try {
				l.stateChanged(new ChangeEvent(ModifierTracker.class));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
}
```


Overlapping Code:
```
c class ModifierTracker {
/**
* Add KeyListeners to everything in an applet.
* <P>
* Unsigned applets can't simply add an event listener to the toolkit for
* security reasons, so this method provides an alternative approach.
* <P>
* This alternative should work in controlled environments where components
* are not added to an applet after this method is called, but in other
* cases it might fail.
* 
* @param applet
* the applet to track
*/
public static void track(JApplet applet) {
if (isActive() == false) {
track(applet.getContentPane());
}
}
private static KeyListener keyListener = new KeyListener() {
public void keyTyped(KeyEvent e) {
}
public void keyPressed(KeyEvent e) {
key(e.getKeyCode(), true);
}
public void keyReleased(KeyEvent e) {
key(e.getKeyCode(), false);
}
private void key(int code, boolean pressed) {
if (code == KeyEvent.VK_ALT) {
if (alt != pressed) {
alt = pressed;
fireAltChangeListeners();
}
} else if (code == KeyEvent.VK_ALT_GRAPH) {
if (altGraph != pressed) {
altGraph = pressed;
fireAltGraphChangeListeners();
}
} else if (code == KeyEvent.VK_CONTROL) {
if (ctrl != pressed) {
ctrl = pressed;
fireControlChangeListeners();
}
} else if (code == KeyEvent.VK_META) {
if (meta != pressed) {
meta = pressed;
fireMetaChangeListeners();
}
} else if (code == KeyEvent.VK_SHIFT) {
if (shift != pressed) {
shift = pressed;
fireShiftChangeListeners();
}
}
}
};
private static void track(Component c) {
c.addKeyListener(keyListener);
if (c instanceof Container) {
Container container = (Container) c;
for (int a = 0; a < container.getComponentCount(); a++) {
track(container.getComponent(a));
}
}
}
private static boolean alt = false;
private static boolean altGraph = false;
private static boolean meta = false;
private static boolean shift = false;
private static boolean ctrl = false;
private static boolean securityProblem = false;
static {
try {
Toolkit.getDefaultToolkit().addAWTEventListener(
new AWTEventListener() {
public void eventDispatched(AWTEvent e) {
if (e instanceof KeyEvent) {
KeyEvent k = (KeyEvent) e;
boolean pressed = k.getID() == KeyEvent.KEY_PRESSED;
int code = k.getKeyCode();
switch (code) {
case Ke
```
<Overlap Ratio: 0.9754990925589837>

---

--- 311 --
Question ID: 51bff49a942c9d459e11636bd060b4ceea922d06_0
Original Code:
```
class WorkItemParamsTest extends AbstractCodegenTest {

	@Test
	void testBasicServiceProcessTask() throws Exception {
		Application app = generateCodeProcessesOnly("servicetask/WorkItemParams.bpmn");
		assertThat(app).isNotNull();

		Process<? extends Model> p = app.processes().processById("WorkItemParamsTest_1_0");

		ProcessInstance<?> processInstance = p.createInstance(p.createModel());
		processInstance.start();

		assertThat(processInstance.startDate()).isNotNull();
		assertThat(processInstance.status()).isEqualTo(ProcessInstance.STATE_COMPLETED);
		Model result = (Model) processInstance.variables();
		Map<String, Object> data = result.toMap();
		assertThat(data).hasSize(4).containsKeys("boolValue", "intValue", "floatValue", "stringValue");
		assertThat(data.get("boolValue")).isNotNull().isEqualTo(Boolean.FALSE);
		assertThat(data.get("intValue")).isNotNull().isEqualTo(101);
		assertThat(data.get("floatValue")).isNotNull().isEqualTo(2.1f);
		assertThat(data.get("stringValue")).isNotNull().isEqualTo("foofoo");
	}

}
```


Overlapping Code:
```
ItemParamsTest extends AbstractCodegenTest {
@Test
void testBasicServiceProcessTask() throws Exception {
Application app = generateCodeProcessesOnly("servicetask/WorkItemParams.bpmn");
assertThat(app).isNotNull();
Process<? extends Model> p = app.processes().processById("WorkItemParamsTest_1_0");
ProcessInstance<?> processInstance = p.createInstance(p.createModel());
processInstance.start();
assertThat(processInstance.startDate()).isNotNull();
assertThat(processInstance.status()).isEqualTo(ProcessInstance.STATE_COMPLETED);
Model result = (Model) processInstance.variables();
Map<String, Object> data = result.toMap();
assertThat(data).hasSize(4).containsKeys("boolValue", "intValue", "floatValue", "stringValue");
assertThat(data.get("boolValue")).isNotNull().isEqualTo(Boolean.FALSE);
assertThat(data.get("intValue")).isNotNull().isEqualTo(101);
assertThat(data.get("floatValue")).isNotNull().isEqualTo(2.1f);
assertThat(data.get("stringValue"
```
<Overlap Ratio: 0.950950950950951>

---

--- 312 --
Question ID: 2c991f3981ee40868f85178cd22aa2a64a123490_2
Original Code:
```
class SampleRB_de extends ListResourceBundle {
	@Override
	protected Object[][] getContents() {
		Object[][] resources = new Object[3][2];
		resources[0][0] = "title";
		resources[0][1] = "Mein Programm";
		resources[1][0] = "StopText";
		resources[1][1] = "Anschlag";
		resources[2][0] = "StartText";
		resources[2][1] = "Anfang";
		return resources;
	}
}
```


Overlapping Code:
```
 extends ListResourceBundle {
@Override
protected Object[][] getContents() {
Object[][] resources = new Object[3][2];
resources[0][0] = "title";
resources[0][1] = "Mein Programm";
resources[1][0] = "StopText";
resources[1][1] = "Anschlag";
resources[2][0] = "StartText";
resources[2][1] = "Anfang";
return resources;
```
<Overlap Ratio: 0.9376854599406528>

---

--- 313 --
Question ID: 78e3280be407b82ae1c39910a09eeccd26a5b911_0
Original Code:
```
public class EphemeralFsFileSystemCheckerTest {

    FileSystem fs;
    Path root;
    Path file;
    
    @Before
    public void setUp() throws IOException {
        fs = EphemeralFsFileSystemBuilder
                .unixFs()
                .build();
        root = fs.getRootDirectories().iterator().next();
        file = root.resolve("file");
        Files.write(file, new byte[] {1,2,3});
        
    }
    
    @After
    public void tearDown() throws IOException {
        fs.close();
    }
    
    @Test
    public void testDontThrowIfChannelClosed() throws Exception {
        Files.newByteChannel(file).close();
        EphemeralFsFileSystemChecker.assertNoOpenResources(fs);
    }
    
    @Test
    public void testThrowIfChannelOpen() throws Exception {
        Files.newByteChannel(file);
        assertNotOpenThrows();
    }
    
    @Test
    public void testThrowIfChannelOpenFileDeleted() throws Exception {
        Files.newByteChannel(file);
        Files.delete(file);
        assertNotOpenThrows();
    }

    @Test
    public void testDontThrowIfAsyncChannelClosed() throws Exception {
        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null).close();
        fs.close();
    }
    
    @Test
    public void testThrowIfAsyncChannelOpen() throws Exception {
        fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null);
        assertNotOpenThrows();
    }

    @Test
    public void testDontThrowIfDirectoryStreamClosed() throws Exception {
        Files.newDirectoryStream(root).close();
        fs.close();
    }
    
    @Test
    public void testThrowIfDirectoryStreamOpen() throws Exception {
        Files.newDirectoryStream(root);
        assertNotOpenThrows();
    }
    
    @Test
    public void testDontThrowIfWatchServiceClosed() throws Exception {
        fs.newWatchService().close();
        fs.close();
    }
    
    @Test
    public void testThrowIfWatchServiceOpen() throws Exception {
        fs.newWatchService();
        assertNotOpenThrows();
    }
    
    
    @Test
    public void testDirtyFile() throws Exception {
        Files.write(file, new byte[] {1});
        assertFsyncFileThrows(file);
    }

    @Test
    public void testDirtyFileInSubDir() throws Exception {
        Path dir = Files.createDirectory(root.resolve("dir"));
        Path fileInDir = Files.createFile(dir.resolve("fileInDir"));
        assertFsyncFileThrows(dir);
        FileSyncTest.sync(fileInDir);
        EphemeralFsFileSystemChecker.assertAllFilesFsynced(dir);
    }
    
    
    @Test
    public void testDsyncNonExistentFile() throws Exception {
        try {
            EphemeralFsFileSystemChecker.assertAllFilesFsynced(root.resolve("doesNotExist"));
            fail();
        } catch(IllegalArgumentException e) {
            //pass
        }
    }
    
    @Test
    public void testCleanFile() throws Exception {
        FileSyncTest.sync(file);
        EphemeralFsFileSystemChecker.assertAllFilesFsynced(file);
    }

    @Test
    public void testFsyncDirOnFile() throws Exception {
        try {
            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(file, false);
            fail();
        } catch(IllegalArgumentException e) {
            //pass
        }
    }
    
    @Test
    public void testFsyncDirOnNonExistent() throws Exception {
        try {
            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root.resolve("dir"), false);
            fail();
        } catch(IllegalArgumentException e) {
            //pass
        }
    }
    
    
    @Test
    public void testFsyncDirOnDirtyDirs() throws Exception {
        Path dir = Files.createDirectory(root.resolve("dir"));
        Files.createFile(dir.resolve("fileInDir"));
        FileSyncTest.sync(root);
        
        assertFsyncDirectoryThrows(root, true);
        assertFsyncDirectoryThrows(dir, true);
        assertFsyncDirectoryThrows(dir, false);
        
        FileSyncTest.sync(dir);
        
        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(root, true);
        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, true);
        EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(dir, false);
    }
    
    private void assertNotOpenThrows() {
        boolean notThrown = false;
        try {
            EphemeralFsFileSystemChecker.assertNoOpenResources(fs);
            notThrown = true;
        } catch(AssertionError e) {
            assertTrue(e.getMessage().contains("Failed to close"));
        }
        if(notThrown) {
            fail();
        }
    }
    
    private void assertFsyncFileThrows(Path path) {
        boolean notThrown = false;
        try {
            EphemeralFsFileSystemChecker.assertAllFilesFsynced(path);
            notThrown = true;
        } catch(AssertionError e) {
            assertTrue(e.getMessage().contains("Failed to sync"));
        }
        if(notThrown) {
            fail();
        }
    }
    
    
    private void assertFsyncDirectoryThrows(Path path, boolean recursive) {
        boolean notThrown = false;
        try {
            EphemeralFsFileSystemChecker.assertAllDirectoriesFsynced(path, recursive);
            notThrown = true;
        } catch(AssertionError e) {
            assertTrue(e.getMessage().contains("Failed to sync"));
        }
        if(notThrown) {
            fail();
        }
    }
}
```


Overlapping Code:
```
mCheckerTest {
FileSystem fs;
Path root;
Path file;

@Before
public void setUp() throws IOException {
fs = EphemeralFsFileSystemBuilder
.unixFs()
.build();
root = fs.getRootDirectories().iterator().next();
file = root.resolve("file");
Files.write(file, new byte[] {1,2,3});

}

@After
public void tearDown() throws IOException {
fs.close();
}

@Test
public void testDontThrowIfChannelClosed() throws Exception {
Files.newByteChannel(file).close();
EphemeralFsFileSystemChecker.assertNoOpenResources(fs);
}

@Test
public void testThrowIfChannelOpen() throws Exception {
Files.newByteChannel(file);
assertNotOpenThrows();
}

@Test
public void testThrowIfChannelOpenFileDeleted() throws Exception {
Files.newByteChannel(file);
Files.delete(file);
assertNotOpenThrows();
}
@Test
public void testDontThrowIfAsyncChannelClosed() throws Exception {
fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null).close();
fs.close();
}

@Test
public void testThrowIfAsyncChannelOpen() throws Exception {
fs.provider().newAsynchronousFileChannel(file, new HashSet<OpenOption>(), null);
assertNotOpenThrows();
}
@Test
public void testDontThrowIfDirectoryStreamClosed() throws Exception {
Files.newDirectoryStream(root).close();
fs.close();
}

@Test
public void testThrowIfDirectoryStreamOpen() throws Exception {
Files.newDirectoryStream(root);
assertNotOpenThrows();
}

@Test
public void testDontThrowIfWatchServiceClosed() throws Exception {
fs.newWatchService().close();
fs.close();
}

@Test
public void testThrowIfWatchServiceOpen() throws Exception {
fs.newWatchService();
assertNotOpenThrows();
}


@Test
public void testDirtyFile() throws Exception {
Files.write(file, new byte[] {1});
assertFsyncFileThrows(file);
}
@Test
public void testDirtyFileInSubDir() throws Exception {
Path dir = Files.createDirectory(root.resolve("dir"));
Path fileInDir = Files.createFile(dir.resolve("fileInDir"));
assertFsyncFileThrows(dir);
FileSyncTest.s
```
<Overlap Ratio: 0.975975975975976>

---

--- 314 --
Question ID: 268727d4258eb44915280346d7d83aa32e8b49d4_0
Original Code:
```
public class Operators {

  public static int operators() {
    int x1 = -4;
    int x2 =  x1--;
    int x3 = ++x2; // !!!-3
    if (x2 > x3) {
      --x3;
    } else {
      x1++;
    }
    return x1 + x2 + x3;
  }

  public static void main(String[] args) {
    System.out.println(operators());
  }
}
```


Overlapping Code:
```
erators {
public static int operators() {
int x1 = -4;
int x2 = x1--;
int x3 = ++x2; // !!!-3
if (x2 > x3) {
--x3;
} else {
x1++;
}
return x1 + x2 + x3;
}
public static void main(String[] args) {
System.out.println(o
```
<Overlap Ratio: 0.8744939271255061>

---

--- 315 --
Question ID: 95f062987e4f33a4b0ff85b3fdd299b38fc36e6a_0
Original Code:
```
@ControllerAdvice
@RestController
@Slf4j
public class ExceptionHandlerConfig {

        /**
         * AuthenticationException Shiro认证异常
         */
        @ExceptionHandler(value = {AuthenticationException.class, AuthorizationException.class})
        public String authenticationExceptionHandler(Exception e, HttpServletResponse response){
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            log.info("" + e);
            return "👻 权限异常！";
        }

        @ExceptionHandler(value = Exception.class)
        public String exceptionHandler(Exception e, HttpServletResponse response){
            response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            log.info("" + e);
            return "👻 系统异常！";
        }
}
```


Overlapping Code:
```
llerAdvice
@RestController
@Slf4j
public class ExceptionHandlerConfig {
/**
* AuthenticationException Shiro认证异常
*/
@ExceptionHandler(value = {AuthenticationException.class, AuthorizationException.class})
public String authenticationExceptionHandler(Exception e, HttpServletResponse response){
response.setStatus(HttpStatus.UNAUTHORIZED.value());
log.info("" + e);
return "👻 权限异常！";
}
@ExceptionHandler(value = Exception.class)
public String exceptionHandler(Exception e, HttpServletResponse response){
response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
log.info("" + e);
return "👻 系统异常！";

```
<Overlap Ratio: 0.9836065573770492>

---

--- 316 --
Question ID: 17aab48110d4c8199b5eccf69aa83aeaad5dada4_0
Original Code:
```
public class YAxisBuilder {
    private Boolean show;
    private Boolean showAlways;
    private String seriesName;
    private Boolean opposite;
    private Boolean logarithmic;
    private Double tickAmount;
    private Boolean forceNiceScale;
    private Object min;
    private Object max;
    private Boolean floating;
    private Double decimalsInFloat;
    private Labels labels;
    private AxisBorder axisBorder;
    private AxisTicks axisTicks;
    private Title title;
    private Crosshairs crosshairs;
    private com.github.appreciated.apexcharts.config.Tooltip tooltip;

    private YAxisBuilder() {
    }

    public static YAxisBuilder get() {
        return new YAxisBuilder();
    }

    public YAxisBuilder withShow(Boolean show) {
        this.show = show;
        return this;
    }

    public YAxisBuilder withShowAlways(Boolean showAlways) {
        this.showAlways = showAlways;
        return this;
    }

    public YAxisBuilder withSeriesName(String seriesName) {
        this.seriesName = seriesName;
        return this;
    }

    public YAxisBuilder withOpposite(Boolean opposite) {
        this.opposite = opposite;
        return this;
    }

    public YAxisBuilder withLogarithmic(Boolean logarithmic) {
        this.logarithmic = logarithmic;
        return this;
    }

    public YAxisBuilder withTickAmount(Double tickAmount) {
        this.tickAmount = tickAmount;
        return this;
    }

    public YAxisBuilder withForceNiceScale(Boolean forceNiceScale) {
        this.forceNiceScale = forceNiceScale;
        return this;
    }

    public YAxisBuilder withMin(Double min) {
        this.min = min;
        return this;
    }

    public YAxisBuilder withMax(Double max) {
        this.max = max;
        return this;
    }

    public YAxisBuilder withMin(Object min) {
        this.min = min;
        return this;
    }

    public YAxisBuilder withMax(Object max) {
        this.max = max;
        return this;
    }

    public YAxisBuilder withMin(LocalDate min) {
        ZoneId zoneId = ZoneId.systemDefault();
        this.min = min.atStartOfDay(zoneId).toInstant().toEpochMilli();
        return this;
    }

    public YAxisBuilder withMax(LocalDate max) {
        ZoneId zoneId = ZoneId.systemDefault();
        this.max = max.atStartOfDay(zoneId).toInstant().toEpochMilli();
        return this;
    }

    public YAxisBuilder withFloating(Boolean floating) {
        this.floating = floating;
        return this;
    }

    public YAxisBuilder withDecimalsInFloat(Double decimalsInFloat) {
        this.decimalsInFloat = decimalsInFloat;
        return this;
    }

    public YAxisBuilder withLabels(Labels labels) {
        this.labels = labels;
        return this;
    }

    public YAxisBuilder withAxisBorder(AxisBorder axisBorder) {
        this.axisBorder = axisBorder;
        return this;
    }

    public YAxisBuilder withAxisTicks(AxisTicks axisTicks) {
        this.axisTicks = axisTicks;
        return this;
    }

    public YAxisBuilder withTitle(Title title) {
        this.title = title;
        return this;
    }

    public YAxisBuilder withCrosshairs(Crosshairs crosshairs) {
        this.crosshairs = crosshairs;
        return this;
    }

    public YAxisBuilder withTooltip(Tooltip tooltip) {
        this.tooltip = tooltip;
        return this;
    }

    public YAxis build() {
        YAxis yAxis = new YAxis();
        yAxis.setShow(show);
        yAxis.setShowAlways(showAlways);
        yAxis.setSeriesName(seriesName);
        yAxis.setOpposite(opposite);
        yAxis.setLogarithmic(logarithmic);
        yAxis.setTickAmount(tickAmount);
        yAxis.setForceNiceScale(forceNiceScale);
        yAxis.setMin(min);
        yAxis.setMax(max);
        yAxis.setFloating(floating);
        yAxis.setDecimalsInFloat(decimalsInFloat);
        yAxis.setLabels(labels);
        yAxis.setAxisBorder(axisBorder);
        yAxis.setAxisTicks(axisTicks);
        yAxis.setTitle(title);
        yAxis.setCrosshairs(crosshairs);
        yAxis.setTooltip(tooltip);
        return yAxis;
    }
}
```


Overlapping Code:
```
lic class YAxisBuilder {
private Boolean show;
private Boolean showAlways;
private String seriesName;
private Boolean opposite;
private Boolean logarithmic;
private Double tickAmount;
private Boolean forceNiceScale;
private Object min;
private Object max;
private Boolean floating;
private Double decimalsInFloat;
private Labels labels;
private AxisBorder axisBorder;
private AxisTicks axisTicks;
private Title title;
private Crosshairs crosshairs;
private com.github.appreciated.apexcharts.config.Tooltip tooltip;
private YAxisBuilder() {
}
public static YAxisBuilder get() {
return new YAxisBuilder();
}
public YAxisBuilder withShow(Boolean show) {
this.show = show;
return this;
}
public YAxisBuilder withShowAlways(Boolean showAlways) {
this.showAlways = showAlways;
return this;
}
public YAxisBuilder withSeriesName(String seriesName) {
this.seriesName = seriesName;
return this;
}
public YAxisBuilder withOpposite(Boolean opposite) {
this.opposite = opposite;
return this;
}
public YAxisBuilder withLogarithmic(Boolean logarithmic) {
this.logarithmic = logarithmic;
return this;
}
public YAxisBuilder withTickAmount(Double tickAmount) {
this.tickAmount = tickAmount;
return this;
}
public YAxisBuilder withForceNiceScale(Boolean forceNiceScale) {
this.forceNiceScale = forceNiceScale;
return this;
}
public YAxisBuilder withMin(Double min) {
this.min = min;
return this;
}
public YAxisBuilder withMax(Double max) {
this.max = max;
return this;
}
public YAxisBuilder withMin(Object min) {
this.min = min;
return this;
}
public YAxisBuilder withMax(Object max) {
this.max = max;
return this;
}
public YAxisBuilder withMin(LocalDate min) {
ZoneId zoneId = ZoneId.systemDefault();
this.min = min.atStartOfDay(zoneId).toInstant().toEpochMilli();
return this;
}
public YAxisBuilder withMax(LocalDate max) {
ZoneId zoneId = ZoneId.systemDefault();
this.max = max.atStartOfDay(zoneId).toInstant().toEpochMilli();
return this;
}
public YAxisBuilder withFloating(Boolean floating) {
this.floating = floating;
return this
```
<Overlap Ratio: 0.9911504424778761>

---

--- 317 --
Question ID: 7c43dd937fac5c40d6836f13b06aafc9cd02960e_0
Original Code:
```
public class YearAddFunction
        extends BaseFEELFunction {

    public YearAddFunction() {
        super( "yearAdd" );
    }

    public FEELFnResult<TemporalAccessor> invoke(@ParameterName("datestring") String datetime, @ParameterName( "years to add" ) BigDecimal years) {
        if ( datetime == null ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "cannot be null" ) );
        }
        if ( years == null ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "years to add", "cannot be null" ) );
        }

        try {
            Object r = null;
            if( datetime.contains( "T" ) ) {
                r = BuiltInFunctions.getFunction( DateAndTimeFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );
            } else {
                r = BuiltInFunctions.getFunction( DateFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );
            }

            if ( r != null && r instanceof TemporalAccessor ) {
                return invoke( (TemporalAccessor) r, years );
            } else {
                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "date-parsing exception" ) );
            }
        } catch ( DateTimeException e ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "date-parsing exception", e ) );
        }
    }

    public FEELFnResult<TemporalAccessor> invoke(@ParameterName("datetime") TemporalAccessor datetime, @ParameterName( "years to add" ) BigDecimal years) {
        if ( datetime == null ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datetime", "cannot be null" ) );
        }
        if ( years == null ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "years to add", "cannot be null" ) );
        }

        try {
            if( datetime instanceof Temporal ) {
                return FEELFnResult.ofResult( ((Temporal) datetime).plus( years.longValue(), ChronoUnit.YEARS ) );
            } else {
                return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datetime", "invalid 'date' or 'date and time' parameter" ) );
            }
        } catch ( DateTimeException e ) {
            return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datetime", "invalid 'date' or 'date and time' parameter", e ) );
        }
    }

}
```


Overlapping Code:
```
public class YearAddFunction
extends BaseFEELFunction {
public YearAddFunction() {
super( "yearAdd" );
}
public FEELFnResult<TemporalAccessor> invoke(@ParameterName("datestring") String datetime, @ParameterName( "years to add" ) BigDecimal years) {
if ( datetime == null ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "cannot be null" ) );
}
if ( years == null ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "years to add", "cannot be null" ) );
}
try {
Object r = null;
if( datetime.contains( "T" ) ) {
r = BuiltInFunctions.getFunction( DateAndTimeFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );
} else {
r = BuiltInFunctions.getFunction( DateFunction.class ).invoke( datetime ).cata( BuiltInType.justNull(), Function.identity() );
}
if ( r != null && r instanceof TemporalAccessor ) {
return invoke( (TemporalAccessor) r, years );
} else {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "date-parsing exception" ) );
}
} catch ( DateTimeException e ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datestring", "date-parsing exception", e ) );
}
}
public FEELFnResult<TemporalAccessor> invoke(@ParameterName("datetime") TemporalAccessor datetime, @ParameterName( "years to add" ) BigDecimal years) {
if ( datetime == null ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datetime", "cannot be null" ) );
}
if ( years == null ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "years to add", "cannot be null" ) );
}
try {
if( datetime instanceof Temporal ) {
return FEELFnResult.ofResult( ((Temporal) datetime).plus( years.longValue(), ChronoUnit.YEARS ) );
} else {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "datetime", "invalid 'date' or 'date and time' parameter" ) );
}
} catch ( DateTimeException e ) {
return FEELFnResult.ofError( new InvalidParametersEvent( Severity.ERROR, "d
```
<Overlap Ratio: 0.9956395348837209>

---

--- 318 --
Question ID: 5096ebbeb2dd16a8c2746b0924aa06ed2bf0f702_0
Original Code:
```
public class UncloakWorkingFolderTask extends WorkingFolderTask {
    public UncloakWorkingFolderTask(final Shell shell, final TFSRepository repository, final String serverPath) {
        super(shell, repository, serverPath, true);
    }

    @Override
    public BaseDialog getDialog() {
        final Workspace workspace = repository.getWorkspace();
        final String localPath = getLocalPathHint(workspace, serverPath);

        return new UncloakFolderMappingDialog(getShell(), workspace, serverPath, localPath);
    }

    @Override
    public TFSCommand getCommand() {
        final WorkingFolder workingFolder = repository.getWorkspace().getExactMappingForServerPath(serverPath);
        return new DeleteWorkingFolderCommand(repository, workingFolder);
    }

    @Override
    public void getLatest() {
        final String title = Messages.getString("UncloakWorkingFolderTask.Uncloak"); //$NON-NLS-1$
        getLatestForServerPath(title);
    }
}
```


Overlapping Code:
```
cloakWorkingFolderTask extends WorkingFolderTask {
public UncloakWorkingFolderTask(final Shell shell, final TFSRepository repository, final String serverPath) {
super(shell, repository, serverPath, true);
}
@Override
public BaseDialog getDialog() {
final Workspace workspace = repository.getWorkspace();
final String localPath = getLocalPathHint(workspace, serverPath);
return new UncloakFolderMappingDialog(getShell(), workspace, serverPath, localPath);
}
@Override
public TFSCommand getCommand() {
final WorkingFolder workingFolder = repository.getWorkspace().getExactMappingForServerPath(serverPath);
return new DeleteWorkingFolderCommand(repository, workingFolder);
}
@Override
public void getLatest() {
final String title = Messages.getString("UncloakWorkingFolderTask.Uncloak"); //$NON-NLS-1$
g
```
<Overlap Ratio: 0.9433962264150944>

---

--- 319 --
Question ID: dc5a24894ccbf1611f745866f805653d9f7ec629_0
Original Code:
```
public class AppAboutActivity extends BaseActivityWrapper {
    @BindView(R.id.app_content_tv)
    TextView appContentTv;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        initService(false);
        super.onCreate(savedInstanceState);
        showBottomView(false);
        setContentView(R.layout.activity_app_about);
        ButterKnife.bind(this);
        appContentTv.setMovementMethod(LinkMovementMethod.getInstance());
        StringUtil.removeUnderlines((Spannable)appContentTv.getText());

    }

    @OnClick(R.id.m_return_img)
    public void onViewClicked() {
        finish();
    }
}
```


Overlapping Code:
```
Activity extends BaseActivityWrapper {
@BindView(R.id.app_content_tv)
TextView appContentTv;
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
initService(false);
super.onCreate(savedInstanceState);
showBottomView(false);
setContentView(R.layout.activity_app_about);
ButterKnife.bind(this);
appContentTv.setMovementMethod(LinkMovementMethod.getInstance());
StringUtil.removeUnderlines((Spannable)appContentTv.getText());
}
@OnClick(R.id.m_return_img)
public void onViewClicked() {
finish();

```
<Overlap Ratio: 0.9553903345724907>

---

--- 320 --
Question ID: d2d4d994e88adb0d92194d9e58a8abdb41fd6618_0
Original Code:
```
public class HydrateFunction extends LevenbergMarquardtFunction {

    private static final long serialVersionUID = 1000;
    static Logger logger = LogManager.getLogger(HydrateFunction.class);

    /** Creates new Test */
    public HydrateFunction() {
        // params = new double[3];
    }

    @Override
	public double calcValue(double[] dependentValues) {
        try {
            thermoOps.hydrateFormationTemperature(1);
            // System.out.println("temperature " + system.getTemperature());
        } catch (Exception e) {
            logger.error(e.toString());
        }
        return system.getTemperature();
    }

    @Override
	public double calcTrueValue(double val) {
        return val;
    }

    @Override
	public void setFittingParams(int i, double value) {
        int structure = 1;
        params[i] = value;
//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setDGfHydrate(value, structure);
//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setDHfHydrate(value, structure);
        // int k=0;

//        if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setEmptyHydrateVapourPressureConstant(0,0, value);
//        if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setEmptyHydrateVapourPressureConstant(0,1, value);

        // for(int k=0;k<system.getNumberOfPhases();k++){
        // if(i==0)
        // system.getPhase(k).getComponent(0).setLennardJonesEnergyParameter(value);
        // if(i==1)
        // system.getPhase(k).getComponent(0).setLennardJonesMolecularDiameter(value);
        // if(i==2) system.getPhase(k).getComponent(0).setSphericalCoreRadius(value);
        // }

        if (i == 0) {
            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesEnergyParameterHydrate(value);
        }
        if (i == 1) {
            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesMolecularDiameterHydrate(value);
        }
        if (i == 2) {
            ((ComponentHydrate) system.getPhase(4).getComponent(0)).setSphericalCoreRadiusHydrate(value);
        }
//

    }
}
```


Overlapping Code:
```
ic class HydrateFunction extends LevenbergMarquardtFunction {
private static final long serialVersionUID = 1000;
static Logger logger = LogManager.getLogger(HydrateFunction.class);
/** Creates new Test */
public HydrateFunction() {
// params = new double[3];
}
@Override
public double calcValue(double[] dependentValues) {
try {
thermoOps.hydrateFormationTemperature(1);
// System.out.println("temperature " + system.getTemperature());
} catch (Exception e) {
logger.error(e.toString());
}
return system.getTemperature();
}
@Override
public double calcTrueValue(double val) {
return val;
}
@Override
public void setFittingParams(int i, double value) {
int structure = 1;
params[i] = value;
// if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setDGfHydrate(value, structure);
// if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setDHfHydrate(value, structure);
// int k=0;
// if(i==0) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setEmptyHydrateVapourPressureConstant(0,0, value);
// if(i==1) ((ComponentHydrate) system.getPhase(4).getComponent("water")).setEmptyHydrateVapourPressureConstant(0,1, value);
// for(int k=0;k<system.getNumberOfPhases();k++){
// if(i==0)
// system.getPhase(k).getComponent(0).setLennardJonesEnergyParameter(value);
// if(i==1)
// system.getPhase(k).getComponent(0).setLennardJonesMolecularDiameter(value);
// if(i==2) system.getPhase(k).getComponent(0).setSphericalCoreRadius(value);
// }
if (i == 0) {
((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesEnergyParameterHydrate(value);
}
if (i == 1) {
((ComponentHydrate) system.getPhase(4).getComponent(0)).setLennardJonesMolecularDiameterHydrate(value);
}
if (i == 2) {
((ComponentHydrate) system.getPhase(4).getComponent(0)).setSphericalCoreRadiusHydrate(value)
```
<Overlap Ratio: 0.9923788786064235>

---

--- 321 --
Question ID: 9e30f407c877c4796ee2d53cec7425a3b27cacc5_0
Original Code:
```
public class TurnToAngleNoPIDCommand extends CommandBase {
  /**
   * Creates a new DriveForwardDistance.
   */
  DriveTrainSubsystem driveTrain;
  private Gyro gyro;
  private double targetAngle;
  private boolean resetGyro = true;
  private double inputSpeed = 0.8; //don't turn too fast

  public TurnToAngleNoPIDCommand(DriveTrainSubsystem inpuDriveTrain, double targetAngle) {
    // Use addRequirements() here to declare subsystem dependencies.
    driveTrain = inpuDriveTrain;

    this.targetAngle = targetAngle;

    // gyroPIDSubsystem = new GyroPIDSubsystem();
    gyro = Gyro.getInstance();
    addRequirements(driveTrain);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    if (resetGyro) {
      gyro.reset();
    }

    this.targetAngle += gyro.getYaw(); //if not set to zero, adjust to whatever the initial value is

    driveTrain.resetEncoders();
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    double turnSpeed = inputSpeed * Math.signum(targetAngle); 
    System.out.println("executing turn to angle");
    System.out.println("yaw:" + gyro.getYaw());
    SmartDashboard.putNumber("yaw", gyro.getYaw());
    // SmartDashboard.putNumber("yaw",gyroPIDSubsystem.getGyroSubsystem().getYaw());
    // SmartDashboard.putNumber("gyroPIDSubsystem.getMeasurement()", gyroPIDSubsystem.getMeasurement());

    SmartDashboard.putNumber("turnSpeed", turnSpeed);
    SmartDashboard.putNumber("leftSpeed", driveTrain.getLeftDriveEncoderVelocity());
    SmartDashboard.putNumber("rightSpeed", driveTrain.getRightDriveEncoderVelocity());

    driveTrain.arcadeDrive(0, turnSpeed);
    // driveTrain.driveDistance(distance);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    if (interrupted) {
      System.out.println("turn to angle interrupted");
    }

    driveTrain.arcadeDrive(0,0);
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    // return false;

    // return gyroPIDSubsystem.getController().atSetpoint();
    if (targetAngle < 0)
      return gyro.getYaw() <= targetAngle;
    else
      return gyro.getYaw() >= targetAngle;
  }
}
```


Overlapping Code:
```
Command extends CommandBase {
/**
* Creates a new DriveForwardDistance.
*/
DriveTrainSubsystem driveTrain;
private Gyro gyro;
private double targetAngle;
private boolean resetGyro = true;
private double inputSpeed = 0.8; //don't turn too fast
public TurnToAngleNoPIDCommand(DriveTrainSubsystem inpuDriveTrain, double targetAngle) {
// Use addRequirements() here to declare subsystem dependencies.
driveTrain = inpuDriveTrain;
this.targetAngle = targetAngle;
// gyroPIDSubsystem = new GyroPIDSubsystem();
gyro = Gyro.getInstance();
addRequirements(driveTrain);
}
// Called when the command is initially scheduled.
@Override
public void initialize() {
if (resetGyro) {
gyro.reset();
}
this.targetAngle += gyro.getYaw(); //if not set to zero, adjust to whatever the initial value is
driveTrain.resetEncoders();
}
// Called every time the scheduler runs while the command is scheduled.
@Override
public void execute() {
double turnSpeed = inputSpeed * Math.signum(targetAngle); 
System.out.println("executing turn to angle");
System.out.println("yaw:" + gyro.getYaw());
SmartDashboard.putNumber("yaw", gyro.getYaw());
// SmartDashboard.putNumber("yaw",gyroPIDSubsystem.getGyroSubsystem().getYaw());
// SmartDashboard.putNumber("gyroPIDSubsystem.getMeasurement()", gyroPIDSubsystem.getMeasurement());
SmartDashboard.putNumber("turnSpeed", turnSpeed);
SmartDashboard.putNumber("leftSpeed", driveTrain.getLeftDriveEncoderVelocity());
SmartDashboard.putNumber("rightSpeed", driveTrain.getRightDriveEncoderVelocity());
driveTrain.arcadeDrive(0, turnSpeed);
// driveTrain.driveDistance(distance);
}
// Called once the command ends or is interrupted.
@Override
public void end(boolean interrupted) {
if (interrupted) {
System.out.println("turn to angle interrupted");
}
driveTrain.arcadeDrive(0,0);
}
// Returns true when the command should end.
@Override
public boolean isFinished() {
// return false;
// return gyroPIDSubsystem.getController().atSetpoint();
if (targetAngle < 0)
return gyro.getYaw() <= targetAngle;
e
```
<Overlap Ratio: 0.9649207111965401>

---

--- 322 --
Question ID: fe89af7acaa65eceae4b9f95b8e9df9bd5e37b91_0
Original Code:
```
@SuppressWarnings("serial")
public class JerichoDocumentPreprocessing implements DocumentPreprocessing {

	@Override
	public String preprocessRawDocument(String html) {
        Source source = new Source(html);
        source.fullSequentialParse();

        TextExtractor extractor = source.getFirstElement(HTMLElementName.BODY).getTextExtractor();

        extractor.setConvertNonBreakingSpaces(true);
        extractor.setExcludeNonHTMLElements(false);
        extractor.setIncludeAttributes(false);

        return extractor.toString();
	}
}
```


Overlapping Code:
```
l")
public class JerichoDocumentPreprocessing implements DocumentPreprocessing {
@Override
public String preprocessRawDocument(String html) {
Source source = new Source(html);
source.fullSequentialParse();
TextExtractor extractor = source.getFirstElement(HTMLElementName.BODY).getTextExtractor();
extractor.setConvertNonBreakingSpaces(true);
extractor.setExcludeNonHTMLElements(false);
extractor.setIncludeAttributes(false);
return extractor.toString
```
<Overlap Ratio: 0.9355509355509356>

---

--- 323 --
Question ID: 30478cddac65a94789f4ba4ae10d6f93c87e8f41_0
Original Code:
```
@RequestScoped
@PingInterceptorBinding
public class PingCDIBean {

    private static int helloHitCount = 0;
    private static int getBeanManagerHitCountJNDI = 0;
    private static int getBeanManagerHitCountSPI = 0;

    
    public int hello() {
        return ++helloHitCount;
    }

    public int getBeanMangerViaJNDI() throws Exception {
        BeanManager beanManager = (BeanManager) new InitialContext().lookup("java:comp/BeanManager");
        Set<Bean<?>> beans = beanManager.getBeans(Object.class);
        if (beans.size() > 0) {
            return ++getBeanManagerHitCountJNDI;
        }
        return 0;

    }
    
    public int getBeanMangerViaCDICurrent() throws Exception {
        BeanManager beanManager = CDI.current().getBeanManager();
        Set<Bean<?>> beans = beanManager.getBeans(Object.class);
        
        if (beans.size() > 0) {
            return ++getBeanManagerHitCountSPI;
        }
        return 0;

    }
}
```


Overlapping Code:
```
orBinding
public class PingCDIBean {
private static int helloHitCount = 0;
private static int getBeanManagerHitCountJNDI = 0;
private static int getBeanManagerHitCountSPI = 0;

public int hello() {
return ++helloHitCount;
}
public int getBeanMangerViaJNDI() throws Exception {
BeanManager beanManager = (BeanManager) new InitialContext().lookup("java:comp/BeanManager");
Set<Bean<?>> beans = beanManager.getBeans(Object.class);
if (beans.size() > 0) {
return ++getBeanManagerHitCountJNDI;
}
return 0;
}

public int getBeanMangerViaCDICurrent() throws Exception {
BeanManager beanManager = CDI.current().getBeanManager();
Set<Bean<?>> beans = beanManager.getBeans(Object.class);

if (beans.size() > 0) {
return ++getBeanManagerHitCountSPI;
}
return 0;
```
<Overlap Ratio: 0.9578544061302682>

---

--- 324 --
Question ID: 2339cd96ccf7d09c03ebd8f3b8526b46b481fa02_0
Original Code:
```
@ApplicationScoped @Alternative
@SuppressWarnings("nls")
public class TestMetricsAccessor implements IMetricsAccessor {

    /**
     * Constructor.
     */
    public TestMetricsAccessor() {
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsage(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, java.util.Date, java.util.Date)
     */
    @Override
    public UsageHistogramBean getUsage(String organizationId, String apiId, String version,
            HistogramIntervalType interval, DateTime from, DateTime to) {
        UsageHistogramBean rval = new UsageHistogramBean();
        rval.getData().add(new UsageDataPoint("2015-06-01T00:00:00.000Z", 17));
        rval.getData().add(new UsageDataPoint("2015-06-01T01:00:00.000Z", 1));
        rval.getData().add(new UsageDataPoint("2015-06-01T02:00:00.000Z", 1));
        rval.getData().add(new UsageDataPoint("2015-06-01T03:00:00.000Z", 29));
        rval.getData().add(new UsageDataPoint("2015-06-01T04:00:00.000Z", 19));
        rval.getData().add(new UsageDataPoint("2015-06-01T05:00:00.000Z", 52));
        rval.getData().add(new UsageDataPoint("2015-06-01T06:00:00.000Z", 6));
        rval.getData().add(new UsageDataPoint("2015-06-01T07:00:00.000Z", 4));
        rval.getData().add(new UsageDataPoint("2015-06-01T08:00:00.000Z", 5));
        rval.getData().add(new UsageDataPoint("2015-06-01T09:00:00.000Z", 27));
        rval.getData().add(new UsageDataPoint("2015-06-01T10:00:00.000Z", 19));
        rval.getData().add(new UsageDataPoint("2015-06-01T11:00:00.000Z", 52));
        rval.getData().add(new UsageDataPoint("2015-06-01T12:00:00.000Z", 6));
        rval.getData().add(new UsageDataPoint("2015-06-01T13:00:00.000Z", 4));
        rval.getData().add(new UsageDataPoint("2015-06-01T14:00:00.000Z", 2));
        rval.getData().add(new UsageDataPoint("2015-06-01T15:00:00.000Z", 17));
        rval.getData().add(new UsageDataPoint("2015-06-01T16:00:00.000Z", 1));
        rval.getData().add(new UsageDataPoint("2015-06-01T17:00:00.000Z", 1));
        rval.getData().add(new UsageDataPoint("2015-06-01T18:00:00.000Z", 29));
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerClient(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)
     */
    @Override
    public UsagePerClientBean getUsagePerClient(String organizationId, String apiId, String version,
            DateTime from, DateTime to) {
        UsagePerClientBean rval = new UsagePerClientBean();
        rval.getData().put("my-client", 120384L);
        rval.getData().put("foo-client", 1263L);
        rval.getData().put("bar-client", 726392L);
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerPlan(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)
     */
    @Override
    public UsagePerPlanBean getUsagePerPlan(String organizationId, String apiId, String version,
            DateTime from, DateTime to) {
        UsagePerPlanBean rval = new UsagePerPlanBean();
        rval.getData().put("Gold", 120384L);
        rval.getData().put("Silver", 921263L);
        rval.getData().put("Platinum", 726392L);
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStats(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, org.joda.time.DateTime, org.joda.time.DateTime)
     */
    @Override
    public ResponseStatsHistogramBean getResponseStats(String organizationId, String apiId,
            String version, HistogramIntervalType interval, DateTime from, DateTime to) {
        ResponseStatsHistogramBean rval = new ResponseStatsHistogramBean();
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsSummary(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)
     */
    @Override
    public ResponseStatsSummaryBean getResponseStatsSummary(String organizationId, String apiId,
            String version, DateTime from, DateTime to) {
        ResponseStatsSummaryBean rval = new ResponseStatsSummaryBean();
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerClient(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)
     */
    @Override
    public ResponseStatsPerClientBean getResponseStatsPerClient(String organizationId, String apiId,
            String version, DateTime from, DateTime to) {
        ResponseStatsPerClientBean rval = new ResponseStatsPerClientBean();
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getResponseStatsPerPlan(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)
     */
    @Override
    public ResponseStatsPerPlanBean getResponseStatsPerPlan(String organizationId, String apiId,
            String version, DateTime from, DateTime to) {
        ResponseStatsPerPlanBean rval = new ResponseStatsPerPlanBean();
        return rval;
    }

    /**
     * @see io.apiman.manager.api.core.IMetricsAccessor#getClientUsagePerApi(java.lang.String, java.lang.String, java.lang.String, org.joda.time.DateTime, org.joda.time.DateTime)
     */
    @Override
    public ClientUsagePerApiBean getClientUsagePerApi(String organizationId, String clientId,
            String version, DateTime from, DateTime to) {
        ClientUsagePerApiBean rval = new ClientUsagePerApiBean();
        return rval;
    }

}
```


Overlapping Code:
```
cationScoped @Alternative
@SuppressWarnings("nls")
public class TestMetricsAccessor implements IMetricsAccessor {
/**
* Constructor.
*/
public TestMetricsAccessor() {
}
/**
* @see io.apiman.manager.api.core.IMetricsAccessor#getUsage(java.lang.String, java.lang.String, java.lang.String, io.apiman.manager.api.beans.metrics.HistogramIntervalType, java.util.Date, java.util.Date)
*/
@Override
public UsageHistogramBean getUsage(String organizationId, String apiId, String version,
HistogramIntervalType interval, DateTime from, DateTime to) {
UsageHistogramBean rval = new UsageHistogramBean();
rval.getData().add(new UsageDataPoint("2015-06-01T00:00:00.000Z", 17));
rval.getData().add(new UsageDataPoint("2015-06-01T01:00:00.000Z", 1));
rval.getData().add(new UsageDataPoint("2015-06-01T02:00:00.000Z", 1));
rval.getData().add(new UsageDataPoint("2015-06-01T03:00:00.000Z", 29));
rval.getData().add(new UsageDataPoint("2015-06-01T04:00:00.000Z", 19));
rval.getData().add(new UsageDataPoint("2015-06-01T05:00:00.000Z", 52));
rval.getData().add(new UsageDataPoint("2015-06-01T06:00:00.000Z", 6));
rval.getData().add(new UsageDataPoint("2015-06-01T07:00:00.000Z", 4));
rval.getData().add(new UsageDataPoint("2015-06-01T08:00:00.000Z", 5));
rval.getData().add(new UsageDataPoint("2015-06-01T09:00:00.000Z", 27));
rval.getData().add(new UsageDataPoint("2015-06-01T10:00:00.000Z", 19));
rval.getData().add(new UsageDataPoint("2015-06-01T11:00:00.000Z", 52));
rval.getData().add(new UsageDataPoint("2015-06-01T12:00:00.000Z", 6));
rval.getData().add(new UsageDataPoint("2015-06-01T13:00:00.000Z", 4));
rval.getData().add(new UsageDataPoint("2015-06-01T14:00:00.000Z", 2));
rval.getData().add(new UsageDataPoint("2015-06-01T15:00:00.000Z", 17));
rval.getData().add(new UsageDataPoint("2015-06-01T16:00:00.000Z", 1));
rval.getData().add(new UsageDataPoint("2015-06-01T17:00:00.000Z", 1));
rval.getData().add(new UsageDataPoint("2015-06-01T18:00:00.000Z", 29));
return rval;
}
/**
* @see io.apiman.manager.api.core.IMetricsAccessor#getUsagePerClient(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date)
*/
@Override
public UsagePerClientBean getUsagePerClient(String organizationId, String apiId, String version
```
<Overlap Ratio: 0.996875>

---

--- 325 --
Question ID: fb925714d072e06f4e7b9e268ecb909c0d04c1f2_0
Original Code:
```
class Solution {
    public int findLucky(int[] arr) {
        int freq[]=new int[501];
        for(int i=0;i<arr.length;i++)
        {
            freq[arr[i]]++;
        }
        int ans=-1;
        for(int i=1;i<=500;i++)
        {
            if(freq[i]==i)
                ans=i;
        }
        return ans;
    }
}
```


Overlapping Code:
```
class Solution {
public int findLucky(int[] arr) {
int freq[]=new int[501];
for(int i=0;i<arr.length;i++)
{
freq[arr[i]]++;
}
int ans=-1;
for(int i=1;i<=500;i++)
{
if(fre
```
<Overlap Ratio: 0.8374384236453202>

---

--- 326 --
Question ID: a724e49954381bd673f0197b70e942ef91509410_0
Original Code:
```
public class BarChartComponent extends JComponent {

    /**
     * The empty space between the x and the y axis of the window.
     */
    private static final int TOP_BOTTOM_GAP = 20;

    /**
     * The fixed gap between the description under x axis and x axis, and the description under y axis and y axis.
     */
    private static final int FIXED_GAP = 10;

    /**
     * Default maximum y value.
     */
    private static final int DEFAULT_MAX_Y_VALUE = 20;

    /**
     * Reference to {@link BarChart}.
     */
    private BarChart barChart;


    /**
     * The color of mesh.
     */
    private static final Color MESH_COLOR = new Color(255, 230, 179);

    /**
     * The color of bars.
     */
    private static final Color COLUMN_COLOR = new Color(244, 119, 71);

    /**
     * The default font.
     */
    private static final Font DEFAULT_FONT = new Font("default", Font.BOLD, 16);


    /**
     * Creates an instance onf {@link BarChartComponent}.
     *
     * @param barChart reference to bar chart.
     */
    public BarChartComponent(BarChart barChart) {
        this.barChart = barChart;
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        int availableWidth = getWidth();
        int availableHeight = getHeight();
        Graphics2D g2d = (Graphics2D) g;
        //default font
        g2d.setFont(DEFAULT_FONT);
        FontMetrics fm = g2d.getFontMetrics();
        int stringHeight = fm.getHeight();

        drawAxesDescriptionAndPath(availableWidth, availableHeight, g2d, fm);


        List<XYValue> values = barChart.getValues();
        g2d.setColor(Color.BLACK);

        float x = (float) (TOP_BOTTOM_GAP + stringHeight / 2.0);
        float y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;

        List<Integer> yValues = getYValues(barChart.getMinY(), barChart.getMaxY(), barChart.getStep());

        int maxValue = DEFAULT_MAX_Y_VALUE;
        Optional<Integer> val = yValues.stream().max(Integer::compareTo);
        if (val.isPresent()) {
            maxValue = val.get();
        }


        int widthOfYNumbers = fm.stringWidth(String.valueOf(maxValue));
        double realStepY = (double) (availableHeight - stringHeight - TOP_BOTTOM_GAP
                - FIXED_GAP - 10) / yValues.size();
        double unitStepY = realStepY / barChart.getStep();

        x += FIXED_GAP + widthOfYNumbers;
        y = drawNumbersOnYAxis(availableWidth, g2d, fm, x, y, yValues, realStepY);

        double maxY = y + realStepY;
        y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;
        x += FIXED_GAP / 2.0;
        drawYAxis(g2d, x, y);
        drawXAxis(availableWidth, g2d, fm, x, y);

        double widthOfOneColumn = (availableWidth - x - FIXED_GAP * 4) / values.size();
        double startXOfColumns = x;
        int minValue = 0;
        if (barChart.getMinY() < 0) {
            minValue = -barChart.getMinY();
        }
        drawColumnsAndData(g2d, fm, values, y, unitStepY, maxY, minValue, widthOfOneColumn, startXOfColumns);
    }

    @Override
    public Dimension getPreferredSize() {
        return super.getPreferredSize();
    }

    /**
     * Draws columns from the given data, draws shadows and vertical part of mesh.
     *
     * @param g2d              the graphics used for drawing
     * @param fm               font metrics.
     * @param values           pairs x,y.
     * @param y                y coordinate.
     * @param unitStepY        the difference between two points on y axis.
     * @param maxY             the maximum y value.
     * @param widthOfOneColumn the width of one column.
     * @param startXOfColumns  the start x coordinate of columns.
     */
    private void drawColumnsAndData(Graphics2D g2d, FontMetrics fm, List<XYValue> values,
                                    float y, double unitStepY, double maxY, int minY, double widthOfOneColumn,
                                    double startXOfColumns) {
        values = values.stream().sorted(Comparator.comparingInt(XYValue::getX)).collect(Collectors.toList());
        for (XYValue value : values) {

            // draw shadow
            g2d.setColor(Color.LIGHT_GRAY);
            Rectangle2D shadowColumn = new Rectangle2D.Double(startXOfColumns + FIXED_GAP,
                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY + FIXED_GAP / 2.0,
                    widthOfOneColumn, unitStepY * value.getY() + minY * unitStepY - FIXED_GAP / 2.0);
            g2d.fill(shadowColumn);

            //draw column
            g2d.setColor(COLUMN_COLOR);
            Rectangle2D column = new Rectangle2D.Double(startXOfColumns + 1,
                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY, widthOfOneColumn,
                    unitStepY * value.getY() + minY * unitStepY);
            g2d.fill(column);

            //draw x value of column
            g2d.setColor(Color.BLACK);
            String val = String.valueOf(value.getX());
            g2d.drawString(val, (float) (startXOfColumns + widthOfOneColumn / 2.0 - fm.stringWidth(val) / 2.0),
                    y + FIXED_GAP);

            //draw columns separator
            startXOfColumns += widthOfOneColumn;
            Line2D delimiter = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,
                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY * unitStepY);
            g2d.setColor(Color.LIGHT_GRAY);
            g2d.draw(delimiter);

            //draw mesh by x axis
            g2d.setColor(MESH_COLOR);
            Line2D xMeshLine = new Line2D.Double(startXOfColumns,
                    y - fm.getAscent() / 2.0 + 1 - value.getY() * unitStepY - minY*unitStepY, startXOfColumns, maxY);
            g2d.draw(xMeshLine);

            //draw end of the column
            g2d.setColor(Color.BLACK);
            Line2D xColumnEnd = new Line2D.Double(startXOfColumns, y - fm.getAscent() / 2.0 + 1,
                    startXOfColumns, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);
            g2d.draw(xColumnEnd);

        }
    }

    /**
     * Draws x axis and arrow on the end of x axis.
     *
     * @param availableWidth the size of window.
     * @param g2d            the graphics used for drawing.
     * @param fm             font metrics.
     * @param x              the x coordinate.
     * @param y              the y coordinate.
     */
    private void drawXAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y) {
        //draw x axis
        Line2D xAxis = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, availableWidth - 2 * FIXED_GAP,
                y - fm.getAscent() / 2.0 + 1);
        g2d.draw(xAxis);

        //draw arrow on x axis
        Path2D arrowX = new Path2D.Double();
        double firstXX = availableWidth - 2 * FIXED_GAP;
        double firstXY = y - fm.getAscent() / 2.0 + 1 - FIXED_GAP / 2.0;
        arrowX.moveTo(firstXX, firstXY);
        arrowX.lineTo(firstXX, y - fm.getAscent() / 2.0 + 1 + FIXED_GAP / 2.0);
        arrowX.lineTo(firstXX + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1);
        arrowX.closePath();
        g2d.fill(arrowX);
    }

    /**
     * Draws y axis and arrow on the end of y axis.
     *
     * @param g2d the graphics used for drawing
     * @param x   x coordinate.
     * @param y   y coordinate.
     */
    private void drawYAxis(Graphics2D g2d, float x, float y) {
        //draw y axis
        Line2D yAxis = new Line2D.Double(x, FIXED_GAP / 2.0 + 1, x, y);
        g2d.draw(yAxis);

        //draw arrow on y axis
        Path2D arrowY = new Path2D.Double();
        double firstXYAxis = x - FIXED_GAP / 2.0;
        double firstYYAxis = FIXED_GAP;
        arrowY.moveTo(firstXYAxis, firstYYAxis);
        arrowY.lineTo(x + FIXED_GAP / 2.0, firstYYAxis);
        arrowY.lineTo(x, FIXED_GAP / 2.0 - 1);
        arrowY.closePath();
        g2d.fill(arrowY);
    }

    /**
     * Draws numbers ond y axis and horizontal part of mesh.
     *
     * @param availableWidth the width of window
     * @param g2d            the graphics used for drawing
     * @param fm             font metrics.
     * @param x              x coordinate.
     * @param y              y coordinate.
     * @param yValues        the values on y axis.
     * @param realStepY      the real step on y axis.
     * @return y coordinate of last number.
     */
    private float drawNumbersOnYAxis(int availableWidth, Graphics2D g2d, FontMetrics fm, float x, float y,
                                     List<Integer> yValues, double realStepY) {
        //draw values on y axis and mesh by y axis
        for (Integer value : yValues) {
            String str = String.valueOf(value);
            Line2D lineNextToNumber = new Line2D.Double(x, y - fm.getAscent() / 2.0 + 1, x + FIXED_GAP / 2.0,
                    y - fm.getAscent() / 2.0 + 1);
            Line2D meshLine = new Line2D.Double(x + FIXED_GAP / 2.0, y - fm.getAscent() / 2.0 + 1,
                    availableWidth - TOP_BOTTOM_GAP, y - fm.getAscent() / 2.0 + 1);
            g2d.drawString(str, x - fm.stringWidth(str), y);
            g2d.draw(lineNextToNumber);
            g2d.setColor(MESH_COLOR);
            g2d.draw(meshLine);
            g2d.setColor(Color.BLACK);
            y -= realStepY;
        }
        return y;
    }

    /**
     * Draws the description under y and x axes and the path to the file from which the data was loaded.
     *
     * @param availableWidth  the width of window.
     * @param availableHeight the height of window.
     * @param g2d             the graphics used for drawing.
     * @param fm              font metrics.
     */
    private void drawAxesDescriptionAndPath(int availableWidth, int availableHeight, Graphics2D g2d, FontMetrics fm) {
        //draw the description under y axis
        AffineTransform defaultAt = g2d.getTransform();
        AffineTransform transform = new AffineTransform();
        transform.rotate(-Math.PI / 2);
        g2d.setTransform(transform);

        String descriptionY = barChart.getDescriptionY();
        int stringWidthY = fm.stringWidth(descriptionY);
        g2d.drawString(descriptionY, (float) (-availableHeight / 2.0 - stringWidthY / 2.0), TOP_BOTTOM_GAP);

        //draw the description under x axis and path to the file
        g2d.setTransform(defaultAt);

        String descriptionX = barChart.getDescriptionX();
        int stringWidthX = fm.stringWidth(descriptionX);
        g2d.drawString(descriptionX, (float) (availableWidth / 2.0 - stringWidthX / 2.0),
                (float) availableHeight - TOP_BOTTOM_GAP);
    }


    /**
     * Generates values on y axis.
     *
     * @param minY the minimum y value.
     * @param maxY the maximum y value.
     * @param step the difference between two points on y axis.
     * @return values on y axis that will be marked on the graph.
     */
    private List<Integer> getYValues(int minY, int maxY, int step) {
        List<Integer> list = new ArrayList<>();
        for (int y = minY; y <= maxY; y += step) {
            list.add(y);
        }
        return list;
    }
}
```


Overlapping Code:
```
lic class BarChartComponent extends JComponent {
/**
* The empty space between the x and the y axis of the window.
*/
private static final int TOP_BOTTOM_GAP = 20;
/**
* The fixed gap between the description under x axis and x axis, and the description under y axis and y axis.
*/
private static final int FIXED_GAP = 10;
/**
* Default maximum y value.
*/
private static final int DEFAULT_MAX_Y_VALUE = 20;
/**
* Reference to {@link BarChart}.
*/
private BarChart barChart;
/**
* The color of mesh.
*/
private static final Color MESH_COLOR = new Color(255, 230, 179);
/**
* The color of bars.
*/
private static final Color COLUMN_COLOR = new Color(244, 119, 71);
/**
* The default font.
*/
private static final Font DEFAULT_FONT = new Font("default", Font.BOLD, 16);
/**
* Creates an instance onf {@link BarChartComponent}.
*
* @param barChart reference to bar chart.
*/
public BarChartComponent(BarChart barChart) {
this.barChart = barChart;
}
@Override
protected void paintComponent(Graphics g) {
super.paintComponent(g);
int availableWidth = getWidth();
int availableHeight = getHeight();
Graphics2D g2d = (Graphics2D) g;
//default font
g2d.setFont(DEFAULT_FONT);
FontMetrics fm = g2d.getFontMetrics();
int stringHeight = fm.getHeight();
drawAxesDescriptionAndPath(availableWidth, availableHeight, g2d, fm);
List<XYValue> values = barChart.getValues();
g2d.setColor(Color.BLACK);
float x = (float) (TOP_BOTTOM_GAP + stringHeight / 2.0);
float y = availableHeight - stringHeight - TOP_BOTTOM_GAP - 2 * FIXED_GAP;
List<Integer> yValues = getYValues(barChart.getMinY(), barChart.getMaxY(), barChart.getStep());
int maxValue = DEFAULT_MAX_Y_VALUE;
Optional<Integer> val = yValues.stream().max(Integer::compareTo);
if (val.isPresent()) {
maxValue = val.get();
}
int widthOfYNumbers = fm.stringWidth(String.valueOf(maxValue));
double realStepY = (double) (availableHeight - stringHeight - TOP_BOTTOM_GAP
- FIXED_GAP - 10) / yValues.size();
double unitStepY = realStepY / barChart.getStep();
x += FIXED_GAP + widthOfYNumbers;
y = drawNumbersOnYAxis(availableWidth, g2d, fm, 
```
<Overlap Ratio: 0.9894837476099426>

---

--- 327 --
Question ID: 9839329bf34ca1dbc2e66e0539ab09221d896203_0
Original Code:
```
final class DirectStatementRetriever extends AbstractStatementRetriever {

    private static final long DO_NOT_CACHE_RESULT = 0L;
    private static final int HTTP_CONNECTION_TIMEOUT_MILLIS = 5000;
    private static final int HTTP_CONNECTION_BACKOFF_MILLIS = 3000;
    private static final int HTTP_CONNECTION_RETRY = 3;
    private static final long HTTP_CONTENT_SIZE_LIMIT_IN_BYTES = 1024 * 1024;
    private static final int MAX_INCLUDE_LEVEL = 1;
    private static final String WELL_KNOWN_STATEMENT_PATH = "/.well-known/assetlinks.json";

    private final URLFetcher mUrlFetcher;
    private final AndroidPackageInfoFetcher mAndroidFetcher;

    /**
     * An immutable value type representing the retrieved statements and the expiration date.
     */
    public static class Result implements AbstractStatementRetriever.Result {

        private final List<Statement> mStatements;
        private final Long mExpireMillis;

        @Override
        public List<Statement> getStatements() {
            return mStatements;
        }

        @Override
        public long getExpireMillis() {
            return mExpireMillis;
        }

        private Result(List<Statement> statements, Long expireMillis) {
            mStatements = statements;
            mExpireMillis = expireMillis;
        }

        public static Result create(List<Statement> statements, Long expireMillis) {
            return new Result(statements, expireMillis);
        }

        @Override
        public String toString() {
            StringBuilder result = new StringBuilder();
            result.append("Result: ");
            result.append(mStatements.toString());
            result.append(", mExpireMillis=");
            result.append(mExpireMillis);
            return result.toString();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            Result result = (Result) o;

            if (!mExpireMillis.equals(result.mExpireMillis)) {
                return false;
            }
            if (!mStatements.equals(result.mStatements)) {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            int result = mStatements.hashCode();
            result = 31 * result + mExpireMillis.hashCode();
            return result;
        }
    }

    public DirectStatementRetriever(URLFetcher urlFetcher,
                                    AndroidPackageInfoFetcher androidFetcher) {
        this.mUrlFetcher = urlFetcher;
        this.mAndroidFetcher = androidFetcher;
    }

    @Override
    public Result retrieveStatements(AbstractAsset source) throws AssociationServiceException {
        if (source instanceof AndroidAppAsset) {
            return retrieveFromAndroid((AndroidAppAsset) source);
        } else if (source instanceof WebAsset) {
            return retrieveFromWeb((WebAsset) source);
        } else {
            throw new AssociationServiceException("Namespace is not supported.");
        }
    }

    private String computeAssociationJsonUrl(WebAsset asset) {
        try {
            return new URL(asset.getScheme(), asset.getDomain(), asset.getPort(),
                    WELL_KNOWN_STATEMENT_PATH)
                    .toExternalForm();
        } catch (MalformedURLException e) {
            throw new AssertionError("Invalid domain name in database.");
        }
    }

    private Result retrieveStatementFromUrl(String urlString, int maxIncludeLevel,
                                            AbstractAsset source)
            throws AssociationServiceException {
        List<Statement> statements = new ArrayList<Statement>();
        if (maxIncludeLevel < 0) {
            return Result.create(statements, DO_NOT_CACHE_RESULT);
        }

        WebContent webContent;
        try {
            URL url = new URL(urlString);
            if (!source.followInsecureInclude()
                    && !url.getProtocol().toLowerCase().equals("https")) {
                return Result.create(statements, DO_NOT_CACHE_RESULT);
            }
            webContent = mUrlFetcher.getWebContentFromUrlWithRetry(url,
                    HTTP_CONTENT_SIZE_LIMIT_IN_BYTES, HTTP_CONNECTION_TIMEOUT_MILLIS,
                    HTTP_CONNECTION_BACKOFF_MILLIS, HTTP_CONNECTION_RETRY);
        } catch (IOException | InterruptedException e) {
            return Result.create(statements, DO_NOT_CACHE_RESULT);
        }

        try {
            ParsedStatement result = StatementParser
                    .parseStatementList(webContent.getContent(), source);
            statements.addAll(result.getStatements());
            for (String delegate : result.getDelegates()) {
                statements.addAll(
                        retrieveStatementFromUrl(delegate, maxIncludeLevel - 1, source)
                                .getStatements());
            }
            return Result.create(statements, webContent.getExpireTimeMillis());
        } catch (JSONException | IOException e) {
            return Result.create(statements, DO_NOT_CACHE_RESULT);
        }
    }

    private Result retrieveFromWeb(WebAsset asset)
            throws AssociationServiceException {
        return retrieveStatementFromUrl(computeAssociationJsonUrl(asset), MAX_INCLUDE_LEVEL, asset);
    }

    private Result retrieveFromAndroid(AndroidAppAsset asset) throws AssociationServiceException {
        try {
            List<String> delegates = new ArrayList<String>();
            List<Statement> statements = new ArrayList<Statement>();

            List<String> certFps = mAndroidFetcher.getCertFingerprints(asset.getPackageName());
            if (!Utils.hasCommonString(certFps, asset.getCertFingerprints())) {
                throw new AssociationServiceException(
                        "Specified certs don't match the installed app.");
            }

            AndroidAppAsset actualSource = AndroidAppAsset.create(asset.getPackageName(), certFps);
            for (String statementJson : mAndroidFetcher.getStatements(asset.getPackageName())) {
                ParsedStatement result =
                        StatementParser.parseStatement(statementJson, actualSource);
                statements.addAll(result.getStatements());
                delegates.addAll(result.getDelegates());
            }

            for (String delegate : delegates) {
                statements.addAll(retrieveStatementFromUrl(delegate, MAX_INCLUDE_LEVEL,
                        actualSource).getStatements());
            }

            return Result.create(statements, DO_NOT_CACHE_RESULT);
        } catch (JSONException | IOException | NameNotFoundException e) {
            Log.w(DirectStatementRetriever.class.getSimpleName(), e);
            return Result.create(Collections.<Statement>emptyList(), DO_NOT_CACHE_RESULT);
        }
    }
}
```


Overlapping Code:
```
rectStatementRetriever extends AbstractStatementRetriever {
private static final long DO_NOT_CACHE_RESULT = 0L;
private static final int HTTP_CONNECTION_TIMEOUT_MILLIS = 5000;
private static final int HTTP_CONNECTION_BACKOFF_MILLIS = 3000;
private static final int HTTP_CONNECTION_RETRY = 3;
private static final long HTTP_CONTENT_SIZE_LIMIT_IN_BYTES = 1024 * 1024;
private static final int MAX_INCLUDE_LEVEL = 1;
private static final String WELL_KNOWN_STATEMENT_PATH = "/.well-known/assetlinks.json";
private final URLFetcher mUrlFetcher;
private final AndroidPackageInfoFetcher mAndroidFetcher;
/**
* An immutable value type representing the retrieved statements and the expiration date.
*/
public static class Result implements AbstractStatementRetriever.Result {
private final List<Statement> mStatements;
private final Long mExpireMillis;
@Override
public List<Statement> getStatements() {
return mStatements;
}
@Override
public long getExpireMillis() {
return mExpireMillis;
}
private Result(List<Statement> statements, Long expireMillis) {
mStatements = statements;
mExpireMillis = expireMillis;
}
public static Result create(List<Statement> statements, Long expireMillis) {
return new Result(statements, expireMillis);
}
@Override
public String toString() {
StringBuilder result = new StringBuilder();
result.append("Result: ");
result.append(mStatements.toString());
result.append(", mExpireMillis=");
result.append(mExpireMillis);
return result.toString();
}
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
Result result = (Result) o;
if (!mExpireMillis.equals(result.mExpireMillis)) {
return false;
}
if (!mStatements.equals(result.mStatements)) {
return false;
}
return true;
}
@Override
public int hashCode() {
int result = mStatements.hashCode();
result = 31 * result + mExpireMillis.hashCode();
```
<Overlap Ratio: 0.9900990099009901>

---

--- 328 --
Question ID: fce4702d5e677d0eb1413d1bfd1d1edc76bbc07b_0
Original Code:
```
@Slf4j
 public class StudentScoreListener
  implements ActionListener
{

  private RubricsService rubricsService = ComponentManager.get(RubricsService.class);

  /**
   * Standard process action method.
   * @param ae ActionEvent
   * @throws AbortProcessingException
   */
  public void processAction(ActionEvent ae) throws
    AbortProcessingException
  {
    log.debug("StudentScore LISTENER.");
    StudentScoresBean bean = (StudentScoresBean) ContextUtil.lookupBean("studentScores");

    // we probably want to change the poster to be consistent
    String publishedId = ContextUtil.lookupParam("publishedIdd");
    
    log.debug("Calling studentScores.");
    if (!studentScores(publishedId, bean, false))
    {
      throw new RuntimeException("failed to call studentScores.");
    }

  }

  /**
   * This will populate the StudentScoresBean with the data associated with the
   * particular versioned assessment based on the publishedId.
   *
   * @param publishedId String
   * @param bean StudentScoresBean
   * @return boolean
   */
  public boolean studentScores(
    String publishedId, StudentScoresBean bean, boolean isValueChange)
  {
    log.debug("studentScores()");
    try
    {
//  SAK-4121, do not pass studentName as f:param, will cause javascript error if name contains apostrophe 
//    bean.setStudentName(cu.lookupParam("studentName"));

      bean.setPublishedId(publishedId);
      String studentId = ContextUtil.lookupParam("studentid");
      bean.setStudentId(studentId);
      AgentFacade agent = new AgentFacade(studentId);
      bean.setStudentName(agent.getFirstName() + " " + agent.getLastName());
      bean.setLastName(agent.getLastName());
      bean.setFirstName(agent.getFirstName());
      bean.setAssessmentGradingId(ContextUtil.lookupParam("gradingData"));
      bean.setItemId(ContextUtil.lookupParam("itemId"));
      bean.setEmail(agent.getEmail());
      
      DeliveryBean dbean = (DeliveryBean) ContextUtil.lookupBean("delivery");
      dbean.setActionString("gradeAssessment");

      DeliveryActionListener listener = new DeliveryActionListener();
      listener.processAction(null);
      
      // Added for SAK-13930
      DeliveryBean updatedDeliveryBean = (DeliveryBean) ContextUtil.lookupBean("delivery");
      List<SectionContentsBean> parts = updatedDeliveryBean.getPageContents().getPartsContents();
      for (SectionContentsBean part : parts) {
        List<ItemContentsBean> items = part.getItemContents();
        for (ItemContentsBean question : items) {
          question.setRubricStateDetails("");
          if (question.getGradingComment() != null && !question.getGradingComment().equals("")) {
            question.setGradingComment(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(question.getGradingComment()));
          }
        }
      } // End of SAK-13930

      GradingService service = new GradingService();
      AssessmentGradingData adata= (AssessmentGradingData) service.load(bean.getAssessmentGradingId(), false);
      bean.setComments(ComponentManager.get(FormattedText.class).convertFormattedTextToPlaintext(adata.getComments()));
      buildItemContentsMap(dbean, publishedId);

      return true;
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return false;
    }
  }
  
  private void buildItemContentsMap(DeliveryBean dbean, String publishedId) {
	  Map<Long, ItemContentsBean> itemContentsMap = new HashMap<>();

      dbean.getPageContents().getPartsContents().stream()
              .filter(Objects::nonNull)
              .forEach(p -> p.getItemContents().stream()
                      .filter(Objects::nonNull)
                      .forEach(i -> {
                          i.setHasAssociatedRubric(rubricsService.hasAssociatedRubric(RubricsConstants.RBCS_TOOL_SAMIGO, RubricsConstants.RBCS_PUBLISHED_ASSESSMENT_ENTITY_PREFIX + publishedId + "." + i.getItemData().getItemId()));
                          i.getItemGradingDataArray()
                                  .forEach(d -> itemContentsMap.put(d.getItemGradingId(), i));
                      }));

	  dbean.setItemContentsMap(itemContentsMap);
  }
}
```


Overlapping Code:
```
c class StudentScoreListener
implements ActionListener
{
private RubricsService rubricsService = ComponentManager.get(RubricsService.class);
/**
* Standard process action method.
* @param ae ActionEvent
* @throws AbortProcessingException
*/
public void processAction(ActionEvent ae) throws
AbortProcessingException
{
log.debug("StudentScore LISTENER.");
StudentScoresBean bean = (StudentScoresBean) ContextUtil.lookupBean("studentScores");
// we probably want to change the poster to be consistent
String publishedId = ContextUtil.lookupParam("publishedIdd");

log.debug("Calling studentScores.");
if (!studentScores(publishedId, bean, false))
{
throw new RuntimeException("failed to call studentScores.");
}
}
/**
* This will populate the StudentScoresBean with the data associated with the
* particular versioned assessment based on the publishedId.
*
* @param publishedId String
* @param bean StudentScoresBean
* @return boolean
*/
public boolean studentScores(
String publishedId, StudentScoresBean bean, boolean isValueChange)
{
log.debug("studentScores()");
try
{
// SAK-4121, do not pass studentName as f:param, will cause javascript error if name contains apostrophe 
// bean.setStudentName(cu.lookupParam("studentName"));
bean.setPublishedId(publishedId);
String studentId = ContextUtil.lookupParam("studentid");
bean.setStudentId(studentId);
AgentFacade agent = new AgentFacade(studentId);
bean.setStudentName(agent.getFirstName() + " " + agent.getLastName());
bean.setLastName(agent.getLastName());
bean.setFirstName(agent.getFirstName());
bean.setAssessmentGradingId(ContextUtil.lookupParam("gradingData"));
bean.setItemId(ContextUtil.lookupParam("itemId"));
bean.setEmail(agent.getEmail());

DeliveryBean dbean = (DeliveryBean) ContextUtil.lookupBean("delivery");
dbean.setActionString("gradeAssessment");
DeliveryActionListener listener = new DeliveryActionListener();
listener.processAction(null);

// Added for SAK-13930
DeliveryBean updatedDeliveryBean = (DeliveryBean) ContextUtil.lookupBean("delivery");
List<SectionContentsBean> parts = updatedDeliveryBean.getPageContents().getPartsContents();
for (SectionContentsBean part : parts) {
List<ItemContentsBean> item
```
<Overlap Ratio: 0.9754244861483468>

---

--- 329 --
Question ID: bc930ab27697be84632cebdde642c18e3bb706f3_0
Original Code:
```
@RestController
@RequestMapping("/sysMenu")
@Api(tags = "菜单")
@Slf4j
@AllArgsConstructor
public class SysMenuController extends BaseController {

    private final SysMenuService sysMenuService;

    /**
     * 菜单 新增
     * @param sysMenu sysMenu
     * @return Result
     */
    @PostMapping("/add")
    @ApiOperation(value = "新增", notes = "新增")
    public Result add(@RequestBody SysMenu sysMenu) {
        Result result = new Result();
        try {
            sysMenuService.insertSysMenu(sysMenu);
        } catch (Exception e) {
            log.error(e.getMessage());
            result.setCode(Result.ERROR_BUSINESS);
            result.setMessage(e.getMessage());
        }
        return result;
    }

    /**
     * 菜单 删除
     * @param id id
     * @return Result
     */
    @PostMapping("/delete")
    @ApiOperation(value = "删除", notes = "删除")
    public Result delete(@RequestParam("id") Integer id) {
        Result result = new Result();
        try {
            sysMenuService.deleteSysMenu(id);
        } catch (Exception e) {
            log.error(e.getMessage());
            result.setCode(Result.ERROR_BUSINESS);
            result.setMessage(e.getMessage());
        }
        return result;
    }

    /**
     * 菜单 查看详情
     * @param id id
     * @return Result
     */
    @GetMapping("/detail")
    @ApiOperation(value = "查看详情", notes = "查看详情")
    public Result detail(@RequestParam("id") Integer id) {
        Result result = new Result();
        try {
            result.setData(sysMenuService.findSysMenuById(id));
        } catch (Exception e) {
            log.error(e.getMessage());
            result.setCode(Result.ERROR_BUSINESS);
            result.setMessage(e.getMessage());
        }
        return result;
    }

    /**
     * 菜单 更新
     * @param sysMenu sysMenu
     * @return Result
     */
    @PostMapping("/update")
    @ApiOperation(value = "更新", notes = "更新")
    public Result update(@RequestBody SysMenu sysMenu) {
        Result result = new Result();
        try {
            sysMenuService.updateSysMenu(sysMenu);
        } catch (Exception e) {
            log.error(e.getMessage());
            result.setCode(Result.ERROR_BUSINESS);
            result.setMessage(e.getMessage());
        }
        return result;
    }

    /**
     * 菜单 分页查询
     * @param page page
     * @param sysMenuRequest sysMenuRequest
     * @return Result
     */
    @PostMapping("/findPage")
    @ApiOperation(value = "分页查询", notes = "分页查询")
    public Result findPage(Page page, SysMenuRequest sysMenuRequest) {
        Result result = new Result();
        try {
            result.setData(sysMenuService.findSysMenuPage(page, sysMenuRequest));
        } catch (Exception e) {
            log.error(e.getMessage());
            result.setCode(Result.ERROR_BUSINESS);
            result.setMessage(e.getMessage());
        }
        return result;
    }
}
```


Overlapping Code:
```
ysMenu")
@Api(tags = "菜单")
@Slf4j
@AllArgsConstructor
public class SysMenuController extends BaseController {
private final SysMenuService sysMenuService;
/**
* 菜单 新增
* @param sysMenu sysMenu
* @return Result
*/
@PostMapping("/add")
@ApiOperation(value = "新增", notes = "新增")
public Result add(@RequestBody SysMenu sysMenu) {
Result result = new Result();
try {
sysMenuService.insertSysMenu(sysMenu);
} catch (Exception e) {
log.error(e.getMessage());
result.setCode(Result.ERROR_BUSINESS);
result.setMessage(e.getMessage());
}
return result;
}
/**
* 菜单 删除
* @param id id
* @return Result
*/
@PostMapping("/delete")
@ApiOperation(value = "删除", notes = "删除")
public Result delete(@RequestParam("id") Integer id) {
Result result = new Result();
try {
sysMenuService.deleteSysMenu(id);
} catch (Exception e) {
log.error(e.getMessage());
result.setCode(Result.ERROR_BUSINESS);
result.setMessage(e.getMessage());
}
return result;
}
/**
* 菜单 查看详情
* @param id id
* @return Result
*/
@GetMapping("/detail")
@ApiOperation(value = "查看详情", notes = "查看详情")
public Result detail(@RequestParam("id") Integer id) {
Result result = new Result();
try {
result.setData(sysMenuService.findSysMenuById(id));
} catch (Exception e) {
log.error(e.getMessage());
result.setCode(Result.ERROR_BUSINESS);
result.setMessage(e.getMessage());
}
return result;
}
/**
* 菜单 更新
* @param sysMenu sysMenu
* @return Result
*/
@PostMapping("/update")
@ApiOperation(value = "更新", notes = "更新")
public Result update(@RequestBody SysMenu sysMenu) {
Result result = new Result();
try {
sysMenuService.updateSysMenu(sysMenu);
} catch (Exception e) {
log.error(e.getMessage());
result.setCode(Result.ERROR_BUSINESS);
result.setMessage(e.getMessage());
}
return result;
}
/**
* 菜单 分页查询
* @param page page
* @param sysMenuRequest sysMenuRequest
* @return Result
*/
@PostMapping("/findPage")
@ApiOperation(value = "分页查询", notes = "分页查询")
public Res
```
<Overlap Ratio: 0.981404958677686>

---

--- 330 --
Question ID: 75b6031078551de6ded6f770baf25ff4cf923d05_0
Original Code:
```
public class ImCommit extends Function {
	
	public Node optimize(Context ctx) {
		return this;
	}

	public Object calculate(Context ctx) {
		if (param == null) {
			MessageManager mm = EngineMessage.get();
			throw new RQException(ImConnection.m_prjName + mm.getMessage("function.missingParam"));
		}
		option = this.getOption();
		
		Object client = param.getLeafExpression().calculate(ctx);
		if ((client instanceof ImConnection)) {
			ImConnection cli = (ImConnection)client;
			if (option!=null && option.indexOf("a")>-1){
				cli.m_consumer.commitAsync();
			}else{
				cli.m_consumer.commitSync();
			}
		}else{
			MessageManager mm = EngineMessage.get();
			throw new RQException(ImConnection.m_prjName + mm.getMessage("function.paramTypeError"));
		}
		
		return null;
	}
}
```


Overlapping Code:
```
s Function {

public Node optimize(Context ctx) {
return this;
}
public Object calculate(Context ctx) {
if (param == null) {
MessageManager mm = EngineMessage.get();
throw new RQException(ImConnection.m_prjName + mm.getMessage("function.missingParam"));
}
option = this.getOption();

Object client = param.getLeafExpression().calculate(ctx);
if ((client instanceof ImConnection)) {
ImConnection cli = (ImConnection)client;
if (option!=null && option.indexOf("a")>-1){
cli.m_consumer.commitAsync();
}else{
cli.m_consumer.commitSync();
}
}else{
MessageManager mm = EngineMessage.get();
throw new RQException(ImConnection.m_prjName + mm.getMessage("function.paramTypeError"));
}

r
```
<Overlap Ratio: 0.9403606102635229>

---

--- 331 --
Question ID: b5ffab6c0829ecce7539a90a86f83f6d5f5bfd61_0
Original Code:
```
public class solution {

    // Complete the happyLadybugs function below.
    static String happyLadybugs(String b) {
        b = b.toLowerCase();
        // we'll note if string has _ then we can swap places
        boolean canSwap = false;
        boolean isEmpty = true;
        // initialise char freq array
        int[] chars = new int[26];
        for (int i = 0; i < b.length(); i++) {
            if (b.charAt(i) == '_') {
                canSwap = true;
            } else {
                // note the char frequencies
                chars[((int) b.charAt(i)) - 97]++;
                isEmpty = false;
            }
        }
        // if the string is empty there are no unhappy lady bugs
        if (isEmpty) {
            return "YES";
        }
        // if there is only one ladybug we can't make it happy
        if (b.length() <= 1) {
            return "NO";
        }
        // if there exists only one ladybug of any color, we can't make them happy
        for (int i = 0; i < 26; i++) {
            if (chars[i] == 1) {
                return "NO";
            }
        }
        // for i=0 if right ladybug is not of same color and we can't swap,return NO
        for (int i = 0; i < b.length(); i++) {
            if (i == 0) {
                if (b.charAt(i) != b.charAt(i + 1) && !canSwap) {
                    return "NO";
                }
                // for rightmost ladybug, if ladybug is not of same color and we can't swap
                // return NO
            } else if (i == b.length() - 1) {
                if (b.charAt(i) != b.charAt(i - 1) && !canSwap) {
                    return "NO";
                }
                // if adjacent ladybug is not of same color and we can't swap, return NO
            } else {
                if (b.charAt(i) != b.charAt(i - 1) && b.charAt(i) != b.charAt(i + 1) && !canSwap) {
                    return "NO";
                }
            }
        }
        return "YES";
    }

    private static final Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) throws IOException {
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int g = scanner.nextInt();
        scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

        for (int gItr = 0; gItr < g; gItr++) {
            int n = scanner.nextInt();
            scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

            String b = scanner.nextLine();

            String result = happyLadybugs(b);

            bufferedWriter.write(result);
            bufferedWriter.newLine();
        }

        bufferedWriter.close();

        scanner.close();
    }
}
```


Overlapping Code:
```
lution {
// Complete the happyLadybugs function below.
static String happyLadybugs(String b) {
b = b.toLowerCase();
// we'll note if string has _ then we can swap places
boolean canSwap = false;
boolean isEmpty = true;
// initialise char freq array
int[] chars = new int[26];
for (int i = 0; i < b.length(); i++) {
if (b.charAt(i) == '_') {
canSwap = true;
} else {
// note the char frequencies
chars[((int) b.charAt(i)) - 97]++;
isEmpty = false;
}
}
// if the string is empty there are no unhappy lady bugs
if (isEmpty) {
return "YES";
}
// if there is only one ladybug we can't make it happy
if (b.length() <= 1) {
return "NO";
}
// if there exists only one ladybug of any color, we can't make them happy
for (int i = 0; i < 26; i++) {
if (chars[i] == 1) {
return "NO";
}
}
// for i=0 if right ladybug is not of same color and we can't swap,return NO
for (int i = 0; i < b.length(); i++) {
if (i == 0) {
if (b.charAt(i) != b.charAt(i + 1) && !canSwap) {
return "NO";
}
// for rightmost ladybug, if ladybug is not of same color and we can't swap
// return NO
} else if (i == b.length() - 1) {
if (b.charAt(i) != b.charAt(i - 1) && !canSwap) {
return "NO";
}
// if adjacent ladybug is not of same color and we can't swap, return NO
} else {
if (b.charAt(i) != b.charAt(i - 1) && b.charAt(i) != b.charAt(i + 1) && !canSwap) {
return "NO";
}
}
}
return "YES";
}
private static final Scanner scanner = new Scanner(System.in);
public static void main(String[] args) throws IOException {
BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));
int g = scanner.nextInt();
scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");
for (int gItr = 0; gItr < g; gItr++) {
int n = scanner.nextInt();
scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");
String b = scanner.n
```
<Overlap Ratio: 0.9862561847168774>

---

--- 332 --
Question ID: 2e2b06c7d8ad0a86be19473e3d9962250b68326b_0
Original Code:
```
public class MessageDeserializer extends StdDeserializer<Message> {

    public MessageDeserializer(){
        this(null);
    }

    public MessageDeserializer(Class<?> vc) {
        super(vc);
    }

    @Override
    public Message deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
        JsonNode node = p.getCodec().readTree(p);

        String key = node.fieldNames().next();

        JsonNode subNode = node.get(key);

        Message message = new Message();
        message.key = key;

        Iterator<String> it = subNode.fieldNames();

        while(it.hasNext()){
            String lang = it.next();
            message.addMessage(lang, subNode.get(lang).textValue());
        }


        return message;
    }
}
```


Overlapping Code:
```
blic class MessageDeserializer extends StdDeserializer<Message> {
public MessageDeserializer(){
this(null);
}
public MessageDeserializer(Class<?> vc) {
super(vc);
}
@Override
public Message deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
JsonNode node = p.getCodec().readTree(p);
String key = node.fieldNames().next();
JsonNode subNode = node.get(key);
Message message = new Message();
message.key = key;
Iterator<String> it = subNode.fieldNames();
while(it.hasNext()){
String lang = it.next();
message.addMessage(lang, subNo
```
<Overlap Ratio: 0.9170812603648425>

---

--- 333 --
Question ID: 61412ed9ea68eb3c1dc72df816617296bd698e49_0
Original Code:
```
public class DaskTable implements TranslatableTable {
	// List of columns (name, column type)
	private final ArrayList<Pair<String, SqlTypeName>> tableColumns;
	// Name of this table
	private final String name;
	// Any statistics information we have
	private final DaskStatistics statistics;

	/// Construct a new table with the given name and estimated row count
	public DaskTable(final String name, final Double rowCount) {
		this.name = name;
		this.tableColumns = new ArrayList<Pair<String, SqlTypeName>>();
		this.statistics = new DaskStatistics(rowCount);
	}

	/// Construct a new table with the given name
	public DaskTable(final String name) {
		this(name, null);
	}

	/// Add a column with the given type
	public void addColumn(final String columnName, final SqlTypeName columnType) {
		this.tableColumns.add(new Pair<>(columnName, columnType));
	}

	/// return the table name
	public String getTableName() {
		return this.name;
	}

	/// calcite method: Get the type of a row of this table (using the type factory)
	@Override
	public RelDataType getRowType(final RelDataTypeFactory relDataTypeFactory) {
		final RelDataTypeFactory.Builder builder = new RelDataTypeFactory.Builder(relDataTypeFactory);
		for (final Pair<String, SqlTypeName> column : tableColumns) {
			final String name = column.getKey();
			final SqlTypeName type = column.getValue();
			builder.add(name, relDataTypeFactory.createSqlType(type));
			builder.nullable(true);
		}
		return builder.build();
	}

	/// calcite method: statistics of this table (not implemented)
	@Override
	public Statistic getStatistic() {
		return this.statistics;
	}

	/// calcite method: the type -> it is a table
	@Override
	public Schema.TableType getJdbcTableType() {
		return Schema.TableType.TABLE;
	}

	/// calcite method: it is not rolled up (I think?)
	@Override
	public boolean isRolledUp(final String string) {
		return false;
	}

	/// calcite method: no need to implement this, as it is not rolled up
	@Override
	public boolean rolledUpColumnValidInsideAgg(final String string, final SqlCall sc, final SqlNode sn,
			final CalciteConnectionConfig ccc) {
		throw new AssertionError("This should not be called!");
	}

	@Override
	public RelNode toRel(ToRelContext context, RelOptTable relOptTable) {
		RelTraitSet traitSet = context.getCluster().traitSet();
		return new LogicalTableScan(context.getCluster(), traitSet, context.getTableHints(), relOptTable);
	}

	private final class DaskStatistics implements Statistic {
		private final Double rowCount;

		public DaskStatistics(final Double rowCount) {
			this.rowCount = rowCount;
		}

		@Override
		public Double getRowCount() {
			return this.rowCount;
		}
	}
}
```


Overlapping Code:
```
anslatableTable {
// List of columns (name, column type)
private final ArrayList<Pair<String, SqlTypeName>> tableColumns;
// Name of this table
private final String name;
// Any statistics information we have
private final DaskStatistics statistics;
/// Construct a new table with the given name and estimated row count
public DaskTable(final String name, final Double rowCount) {
this.name = name;
this.tableColumns = new ArrayList<Pair<String, SqlTypeName>>();
this.statistics = new DaskStatistics(rowCount);
}
/// Construct a new table with the given name
public DaskTable(final String name) {
this(name, null);
}
/// Add a column with the given type
public void addColumn(final String columnName, final SqlTypeName columnType) {
this.tableColumns.add(new Pair<>(columnName, columnType));
}
/// return the table name
public String getTableName() {
return this.name;
}
/// calcite method: Get the type of a row of this table (using the type factory)
@Override
public RelDataType getRowType(final RelDataTypeFactory relDataTypeFactory) {
final RelDataTypeFactory.Builder builder = new RelDataTypeFactory.Builder(relDataTypeFactory);
for (final Pair<String, SqlTypeName> column : tableColumns) {
final String name = column.getKey();
final SqlTypeName type = column.getValue();
builder.add(name, relDataTypeFactory.createSqlType(type));
builder.nullable(true);
}
return builder.build();
}
/// calcite method: statistics of this table (not implemented)
@Override
public Statistic getStatistic() {
return this.statistics;
}
/// calcite method: the type -> it is a table
@Override
public Schema.TableType getJdbcTableType() {
return Schema.TableType.TABLE;
}
/// calcite method: it is not rolled up (I think?)
@Override
public boolean isRolledUp(final String string) {
return false;
}
/// calcite method: no need to implement this, as it is not rolled up
@Override
public boolean rolledUpColumnValidInsideAgg(final String string, final SqlCall sc, final SqlNode sn,
final CalciteConnectionConfig ccc) {
throw new AssertionError("This should not be called!");
}
@Override
public RelNode toRel(ToRelContext context, RelOptTable relOptTable) {
RelTraitSet traitSet = context.getCluster().traitSet();
return new LogicalTableScan(context.getCluster(), traitSet, context.getTableHints(), relOptTable);
}
private final class DaskStatistics implements Statistic 
```
<Overlap Ratio: 0.9803921568627451>

---

--- 334 --
Question ID: 57ba7d72efdcffb8f098ab8b148e3b6b750b8ee8_0
Original Code:
```
public class TestPropertyQueryString {
    @Test
    public void testBuildResponseKeys() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        String properties = arp.buildResponseKeyExpression(createResponseKeys());
        Assert.assertEquals(
                "<response-keys = address-fqdn:0000000000000:ipaddress-v4 , key2:value2:field2>",
                properties);
    }

    @Test
    public void testBuildRequestKeys() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        String properties = arp.buildRequestKeyExpression(createRequestKeys());
        Assert.assertEquals(
                "<request-keys = class-type:interface-ip-address , address_fqdn:00000000000000 , address_type:v4>",
                properties);
    }

    @Test
    public void testEncoding() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();

        String expected1 = "&lt;class-type&gt;";
        String encoded1 = arp.encode("<class-type>");
        Assert.assertEquals(expected1, encoded1);

        String expected2 = "&lt;&lt;&lt;metallica&lt;&gt;iron_maiden&gt;&gt;&gt;";
        String encoded2 = arp.encode("<<<metallica<>iron_maiden>>>");
        Assert.assertEquals(expected2, encoded2);

        String expected3 = "band-list&colon;metallica&comma;ironmaiden";
        String encoded3 = arp.encode("band-list:metallica,ironmaiden");
        Assert.assertEquals(expected3, encoded3);

        String expected4 = "motorhead&equals;lemmy";
        String encoded4 = arp.encode("motorhead=lemmy");
        Assert.assertEquals(expected4, encoded4);

        String expected5 = "DreamTheater";
        String encoded5 = arp.encode("  DreamTheater  ");
        Assert.assertEquals(expected5, encoded5);
    }

    @Test
    public void testBuildRuleType() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        String input = "IPV4";
        String expected = "<rule-type = IPV4>";
        Assert.assertEquals(expected, arp.buildRuleType(input));
    }

    @Test
    public void testRuleTypeSetNull() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        String expected = "<rule-type = >";
        Assert.assertEquals(expected, arp.buildRuleType(null));
    }

    @Test
    public void testBuildRequestKeysWithKeyNull() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();
        requestKeyList.add(null);
        String properties = arp.buildRequestKeyExpression(requestKeyList);
        Assert.assertEquals("<request-keys = >", properties);
    }

    @Test
    public void testBuildResponseKeysWithKeyNull() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();
        responseKeyList.add(null);
        String properties = arp.buildResponseKeyExpression(responseKeyList);
        Assert.assertEquals("<response-keys = >", properties);
    }

    @Test
    public void testBuildSourceSystem() {
        ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
        Assert.assertEquals("<source-system = source>", arp.buildSourceSystem("source"));
    }

    // @Test
    private List<RequestKey> createRequestKeys() {
        // Create RequestKey object 1
        RequestKey requestKey1 = new RequestKey();
        requestKey1.setKeyName("class-type");
        requestKey1.setKeyValue("interface-ip-address");

        // Create RequestKey object 2
        RequestKey requestKey2 = new RequestKey();
        requestKey2.setKeyName("address_fqdn");
        requestKey2.setKeyValue("00000000000000");

        // Create RequestKey object 3
        RequestKey requestKey3 = new RequestKey();
        requestKey3.setKeyName("address_type");
        requestKey3.setKeyValue("v4");

        // Add the RequestKey Objects to the List
        List<RequestKey> requestKeyList = new ArrayList<RequestKey>();
        requestKeyList.add(requestKey1);
        requestKeyList.add(requestKey2);
        requestKeyList.add(requestKey3);
        return requestKeyList;
    }

    // @Test
    private List<ResponseKey> createResponseKeys() {
        // Create RequestKey object 1
        ResponseKey responseKey1 = new ResponseKey();

        responseKey1.setUniqueKeyName("address-fqdn");
        responseKey1.setUniqueKeyValue("0000000000000");
        responseKey1.setFieldKeyName("ipaddress-v4");

        ResponseKey responseKey2 = new ResponseKey();
        responseKey2.setUniqueKeyName("key2");
        responseKey2.setUniqueKeyValue("value2");
        responseKey2.setFieldKeyName("field2");

        // Add the RequestKey Objects to the List
        List<ResponseKey> responseKeyList = new ArrayList<ResponseKey>();
        responseKeyList.add(responseKey1);
        responseKeyList.add(responseKey2);

        return responseKeyList;
    }
}
```


Overlapping Code:
```
Test
public void testBuildResponseKeys() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
String properties = arp.buildResponseKeyExpression(createResponseKeys());
Assert.assertEquals(
"<response-keys = address-fqdn:0000000000000:ipaddress-v4 , key2:value2:field2>",
properties);
}
@Test
public void testBuildRequestKeys() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
String properties = arp.buildRequestKeyExpression(createRequestKeys());
Assert.assertEquals(
"<request-keys = class-type:interface-ip-address , address_fqdn:00000000000000 , address_type:v4>",
properties);
}
@Test
public void testEncoding() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
String expected1 = "&lt;class-type&gt;";
String encoded1 = arp.encode("<class-type>");
Assert.assertEquals(expected1, encoded1);
String expected2 = "&lt;&lt;&lt;metallica&lt;&gt;iron_maiden&gt;&gt;&gt;";
String encoded2 = arp.encode("<<<metallica<>iron_maiden>>>");
Assert.assertEquals(expected2, encoded2);
String expected3 = "band-list&colon;metallica&comma;ironmaiden";
String encoded3 = arp.encode("band-list:metallica,ironmaiden");
Assert.assertEquals(expected3, encoded3);
String expected4 = "motorhead&equals;lemmy";
String encoded4 = arp.encode("motorhead=lemmy");
Assert.assertEquals(expected4, encoded4);
String expected5 = "DreamTheater";
String encoded5 = arp.encode(" DreamTheater ");
Assert.assertEquals(expected5, encoded5);
}
@Test
public void testBuildRuleType() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
String input = "IPV4";
String expected = "<rule-type = IPV4>";
Assert.assertEquals(expected, arp.buildRuleType(input));
}
@Test
public void testRuleTypeSetNull() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
String expected = "<rule-type = >";
Assert.assertEquals(expected, arp.buildRuleType(null));
}
@Test
public void testBuildRequestKeysWithKeyNull() {
ArtifactProcessorImpl arp = new ArtifactProcessorImpl();
List<RequestKey> requestKeyList = new Array
```
<Overlap Ratio: 0.9779951100244498>

---

--- 335 --
Question ID: 7f3b0708d23d5e1ee48dbe7838e969a42e3dc380_0
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class AndSpecificationTest {

  @Test
  public void should_satisfied_all() throws Exception {
    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();

    AndSpecification<String> specification = new AndSpecification(a, b);
    assertTrue(specification.isSatisfiedBy("test"));
  }

  @Test
  public void should_fail_if_any_fail_all() throws Exception {
    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();

    AndSpecification<String> specification = new AndSpecification(a, b.not());
    assertFalse(specification.isSatisfiedBy("test"));
  }

  @Test
  public void should_print() throws Exception {
    AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
    AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();

    AndSpecification<String> specification = new AndSpecification(a, b.not());
    Pattern pattern = Pattern.compile("AND\\(.*\\)");
    assertTrue(pattern.matcher(specification.toString()).matches());
  }
}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class AndSpecificationTest {
@Test
public void should_satisfied_all() throws Exception {
AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();
AndSpecification<String> specification = new AndSpecification(a, b);
assertTrue(specification.isSatisfiedBy("test"));
}
@Test
public void should_fail_if_any_fail_all() throws Exception {
AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();
AndSpecification<String> specification = new AndSpecification(a, b.not());
assertFalse(specification.isSatisfiedBy("test"));
}
@Test
public void should_print() throws Exception {
AlwaysSatisfiedSpecification a = new AlwaysSatisfiedSpecification();
AlwaysSatisfiedSpecification b = new AlwaysSatisfiedSpecification();
AndSpecification<String> specification = new AndSpecification(a, b.not());
Pattern pattern = Pattern.compile("AND\\(.*\\)");
assertTrue(pattern.matcher(specification.toString()).matches());
}
}
```
<Overlap Ratio: 1.0>

---

--- 336 --
Question ID: c959354b1f0ae950f1191e59c6ff6ced48071446_0
Original Code:
```
public class DefaultDistributionParameter<ParameterType,ConditionalType extends ClosedFormDistribution<?>>
    extends AbstractNamed
    implements DistributionParameter<ParameterType,ConditionalType>
{

    /**
     * Distribution from which to pull the parameters.
     */
    protected ConditionalType conditionalDistribution;

    /**
     * Setter for the parameter, the read method.
     */
    transient protected Method parameterSetter;

    /**
     * Getter for the parameter, the write method.
     */
    transient protected Method parameterGetter;

    /**
     * Name of the mean property, {@value}.
     */
    public static final String MEAN_NAME = "mean";

    /**
     * Setter for the mean, {@value}.
     */
    public static final String MEAN_SETTER = "setMean";

    /**
     * Getter for the mean, {@value}.
     */
    public static final String MEAN_GETTER = "getMean";

    /** 
     * Creates a new instance of DefaultDistributionParameter 
     * @param conditionalDistribution
     * Distribution from which to pull the parameters.
     * @param parameterName
     * Name of the parameter
     */
    public DefaultDistributionParameter(
        final ConditionalType conditionalDistribution,
        final String parameterName )
    {
        super( parameterName );
        this.setConditionalDistribution(conditionalDistribution);
    }

    /**
     * Creates a new instance of DefaultDistributionParameter
     * @param conditionalDistribution
     * Distribution from which to pull the parameters.
     * @param descriptor
     * PropertyDescriptor from the Introspector that has a setter and a getter.
     */
    public DefaultDistributionParameter(
        final ConditionalType conditionalDistribution,
        final PropertyDescriptor descriptor )
    {
        this( conditionalDistribution, descriptor.getName() );
        this.parameterGetter = descriptor.getReadMethod();
        this.parameterSetter = descriptor.getWriteMethod();
    }

    @Override
    public DefaultDistributionParameter<ParameterType,ConditionalType> clone()
    {
        @SuppressWarnings("unchecked")
        DefaultDistributionParameter<ParameterType,ConditionalType> clone =
            (DefaultDistributionParameter<ParameterType,ConditionalType>) super.clone();
        clone.setConditionalDistribution(
            ObjectUtil.cloneSafe(this.getConditionalDistribution() ) );
        return clone;
    }

    /**
     * Assigns the getter and setter from the given conditionalDistribution and parameter
     * name.
     * @param conditionalDistribution
     * Distribution from which to pull the parameters.
     * @param parameterName
     * Name of the parameter
     */
    protected void assignParameterMethods(
        final Distribution<?> conditionalDistribution,
        final String parameterName )
    {

        this.parameterGetter = null;
        this.parameterSetter = null;

        // Mean is a special case...
        // Note: We can't use BeanInfo and Introspection on PropertyDescriptor
        // because the signature of the getters and setters could be
        // inconsistent.  For example, a class could have a method of
        // "Double getMean()", but the setter might be "void setMean(double)".
        // Because the getter returns Double, but the setter takes a double,
        // the Bean Introspection is too clever and doesn't consider them
        // as getters and setters for the same property.  Thus, we have to
        // include our little hack below.
        if( parameterName.equals( MEAN_NAME ) )
        {
            for( Method method : conditionalDistribution.getClass().getMethods() )
            {
                String methodString = method.getName();
                if( methodString.contains( MEAN_GETTER ) )
                {
                    this.parameterGetter = method;
                }
                else if( methodString.contains( MEAN_SETTER ) )
                {
                    this.parameterSetter = method;
                }
            }
        }
        else
        {
            try
            {
                BeanInfo beaninfo =
                    Introspector.getBeanInfo(conditionalDistribution.getClass());
                for (PropertyDescriptor descriptor : beaninfo.getPropertyDescriptors())
                {
                    String propertyName = descriptor.getName();
                    if (propertyName.equals(parameterName))
                    {
                        this.parameterGetter = descriptor.getReadMethod();
                        this.parameterSetter = descriptor.getWriteMethod();
                        break;
                    }
                }
            }
            catch (IntrospectionException ex)
            {
                throw new RuntimeException( ex );
            }

        }

        if( this.parameterGetter == null )
        {
            throw new IllegalArgumentException(
                "Could not find getter: " + parameterName + " in class " + this.getConditionalDistribution() );
        }
        if( this.parameterSetter == null )
        {
            throw new IllegalArgumentException(
                "Could not find setter: " + parameterName + " in class " + this.getConditionalDistribution() );
        }

    }


    @SuppressWarnings("unchecked")
    @Override
    public ParameterType getValue()
    {
        ParameterType retval = null;
        try
        {
            if( this.parameterGetter == null )
            {
                this.assignParameterMethods(
                    this.getConditionalDistribution(), this.getName() );
            }
            retval = (ParameterType) this.parameterGetter.invoke(
                this.getConditionalDistribution());
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }

        return retval;
    }

    @Override
    public void setValue(
        final ParameterType value )
    {
        try
        {
            if( this.parameterGetter == null )
            {
                this.assignParameterMethods(
                    this.getConditionalDistribution(), this.getName() );
            }
            this.parameterSetter.invoke( this.getConditionalDistribution(), value );
        }
        catch (Exception e)
        {
            throw new RuntimeException( e );
        }
    }


    @Override
    public ConditionalType getConditionalDistribution()
    {
        return this.conditionalDistribution;
    }

    /**
     * Setter for conditionalDistribution
     * @param conditionalDistribution
     * Conditional conditionalDistribution associated with the parameter.
     */
    protected void setConditionalDistribution(
        final ConditionalType conditionalDistribution)
    {
        this.conditionalDistribution = conditionalDistribution;
    }

    @Override
    public void setName(
        final String name)
    {
        this.parameterGetter = null;
        this.parameterSetter = null;
        super.setName(name);
    }
    
}
```


Overlapping Code:
```
blic class DefaultDistributionParameter<ParameterType,ConditionalType extends ClosedFormDistribution<?>>
extends AbstractNamed
implements DistributionParameter<ParameterType,ConditionalType>
{
/**
* Distribution from which to pull the parameters.
*/
protected ConditionalType conditionalDistribution;
/**
* Setter for the parameter, the read method.
*/
transient protected Method parameterSetter;
/**
* Getter for the parameter, the write method.
*/
transient protected Method parameterGetter;
/**
* Name of the mean property, {@value}.
*/
public static final String MEAN_NAME = "mean";
/**
* Setter for the mean, {@value}.
*/
public static final String MEAN_SETTER = "setMean";
/**
* Getter for the mean, {@value}.
*/
public static final String MEAN_GETTER = "getMean";
/** 
* Creates a new instance of DefaultDistributionParameter 
* @param conditionalDistribution
* Distribution from which to pull the parameters.
* @param parameterName
* Name of the parameter
*/
public DefaultDistributionParameter(
final ConditionalType conditionalDistribution,
final String parameterName )
{
super( parameterName );
this.setConditionalDistribution(conditionalDistribution);
}
/**
* Creates a new instance of DefaultDistributionParameter
* @param conditionalDistribution
* Distribution from which to pull the parameters.
* @param descriptor
* PropertyDescriptor from the Introspector that has a setter and a getter.
*/
public DefaultDistributionParameter(
final ConditionalType conditionalDistribution,
final PropertyDescriptor descriptor )
{
this( conditionalDistribution, descriptor.getName() );
this.parameterGetter = descriptor.getReadMethod();
this.parameterSetter = descriptor.getWriteMethod();
}
@Override
public DefaultDistributionParameter<ParameterType,ConditionalType> clone()
{
@SuppressWarnings("unchecked")
DefaultDistributionParameter<ParameterType,ConditionalType> clone =
(DefaultDistributionParameter<ParameterType,ConditionalType>) super.clone();
clone.setConditionalDistribution(
ObjectUtil.cloneSafe(this.getConditionalDistribution() ) );
return clone;
}
/**
* Assigns the getter and setter
```
<Overlap Ratio: 0.9868421052631579>

---

--- 337 --
Question ID: 9c67837ea760b121b225a8bd8fc5b55c664154a0_0
Original Code:
```
public class DecoratedRunnableScheduledFuture<V> extends Decorated implements RunnableScheduledFuture<V> {

    private final RunnableScheduledFuture<V> target;

    /**
     * Create a new DecoratedRunnableScheduledFuture. Private, use factory to create.
     *
     * @param target the RunnableScheduledFuture to decorate
     */
    private DecoratedRunnableScheduledFuture(final RunnableScheduledFuture<V> target) {
        this.target = target;
    }

    /**
     * Factory method to decorate a RunnableScheduledFuture only if it is not already a DecoratedRunnableScheduledFuture.
     *
     * @param target the RunnableScheduledFuture to consider for decoration
     * @return a DecoratedRunnableScheduledFuture representing the input RunnableScheduledFuture
     */
    public static RunnableScheduledFuture maybeCreate(RunnableScheduledFuture target) {
        if (target == null) {
            return null;
        }

        if (target instanceof DecoratedRunnableScheduledFuture) {
            return target;
        }

        return new DecoratedRunnableScheduledFuture(target);
    }

    /**
     * When the RunnableScheduledFuture is executed, perform DiSCo TransactionContext propagation, as necessary
     *
     * {@inheritDoc}
     */
    @Override
    public void run() {
        before();
        try {
            target.run();
        } catch (Throwable t) {
            throw t;
        } finally {
            after();
        }
    }

    // Delegate all abstract methods

    /**
     * {@inheritDoc}
     */
    @Override
    public int compareTo(Delayed o) {
        return target.compareTo(o);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isPeriodic() {
        return this.target.isPeriodic();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isDone() {
        return this.target.isDone();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getDelay(TimeUnit unit) {
        return this.target.getDelay(unit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return this.target.cancel(mayInterruptIfRunning);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isCancelled() {
        return this.target.isCancelled();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public V get() throws InterruptedException, ExecutionException {
        return this.target.get();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return this.target.get(timeout, unit);
    }
}
```


Overlapping Code:
```
ableScheduledFuture<V> extends Decorated implements RunnableScheduledFuture<V> {
private final RunnableScheduledFuture<V> target;
/**
* Create a new DecoratedRunnableScheduledFuture. Private, use factory to create.
*
* @param target the RunnableScheduledFuture to decorate
*/
private DecoratedRunnableScheduledFuture(final RunnableScheduledFuture<V> target) {
this.target = target;
}
/**
* Factory method to decorate a RunnableScheduledFuture only if it is not already a DecoratedRunnableScheduledFuture.
*
* @param target the RunnableScheduledFuture to consider for decoration
* @return a DecoratedRunnableScheduledFuture representing the input RunnableScheduledFuture
*/
public static RunnableScheduledFuture maybeCreate(RunnableScheduledFuture target) {
if (target == null) {
return null;
}
if (target instanceof DecoratedRunnableScheduledFuture) {
return target;
}
return new DecoratedRunnableScheduledFuture(target);
}
/**
* When the RunnableScheduledFuture is executed, perform DiSCo TransactionContext propagation, as necessary
*
* {@inheritDoc}
*/
@Override
public void run() {
before();
try {
target.run();
} catch (Throwable t) {
throw t;
} finally {
after();
}
}
// Delegate all abstract methods
/**
* {@inheritDoc}
*/
@Override
public int compareTo(Delayed o) {
return target.compareTo(o);
}
/**
* {@inheritDoc}
*/
@Override
public boolean isPeriodic() {
return this.target.isPeriodic();
}
/**
* {@inheritDoc}
*/
@Override
public boolean isDone() {
return this.target.isDone();
}
/**
* {@inheritDoc}
*/
@Override
public long getDelay(TimeUnit unit) {
return this.target.getDelay(unit);
}
/**
* {@inheritDoc}
*/
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
return this.target.cancel(mayInterruptIfRunning);
}
/**
* {@inheritDoc}
*/
@Override
public boolean isCancelled() {
return this.target.isCancelled();
}
/**
* {@inheritDoc}
*/
@Override
public V get() throws InterruptedException, ExecutionException {
return this.
```
<Overlap Ratio: 0.9803921568627451>

---

--- 338 --
Question ID: d145e6fa0afcbf8e2f0105387cfbf41db1ea9f21_0
Original Code:
```
public class Leetcode2Test {
    Leetcode2 leetcode = new Leetcode2();

    @Test
    public void addTwoNumbers() {
        ListNode result = leetcode.addTwoNumbers(getNodeList("2,4,3"), getNodeList("5,6,4"));
        ListNode expect = getNodeList("7,0,8");
        while (expect != null) {
            assertEquals(expect,result);
            result = result.next;
            expect = expect.next;
        }
    }

    @Test
    public void addTwoNumbersCase2() {
        ListNode result = leetcode.addTwoNumbers(getNodeList("5"), getNodeList("5"));
        ListNode expect = getNodeList("0,1");
        while (expect != null) {
            assertEquals(expect,result);
            result = result.next;
            expect = expect.next;
        }
    }

    @Test
    public void addTwoNumbersCase3() {
        ListNode result = leetcode.addTwoNumbers(getNodeList("1"), getNodeList("9,9"));
        ListNode expect = getNodeList("0,0,1");
        while (expect != null) {
            assertEquals(expect,result);
            result = result.next;
            expect = expect.next;
        }
    }

    public static ListNode getNodeList(String str) {
        ListNode fake = new ListNode(0);
        ListNode t = fake;
        String[] nodes = str.split(",");
        for (String s : nodes) {
            int val = Integer.parseInt(s);
            ListNode node = new ListNode(val);
            t.next = node;
            t = t.next;
        }
        return fake.next;
    }
}
```


Overlapping Code:
```
eetcode2 leetcode = new Leetcode2();
@Test
public void addTwoNumbers() {
ListNode result = leetcode.addTwoNumbers(getNodeList("2,4,3"), getNodeList("5,6,4"));
ListNode expect = getNodeList("7,0,8");
while (expect != null) {
assertEquals(expect,result);
result = result.next;
expect = expect.next;
}
}
@Test
public void addTwoNumbersCase2() {
ListNode result = leetcode.addTwoNumbers(getNodeList("5"), getNodeList("5"));
ListNode expect = getNodeList("0,1");
while (expect != null) {
assertEquals(expect,result);
result = result.next;
expect = expect.next;
}
}
@Test
public void addTwoNumbersCase3() {
ListNode result = leetcode.addTwoNumbers(getNodeList("1"), getNodeList("9,9"));
ListNode expect = getNodeList("0,0,1");
while (expect != null) {
assertEquals(expect,result);
result = result.next;
expect = expect.next;
}
}
public static ListNode getNodeList(String str) {
ListNode fake = new ListNode(0);
ListNode t = fake;
String[] nodes = str.split(",");
for (String s : nodes) {
int val = Integer.parseInt(s);
ListNode node = new ListNode(val);
t.
```
<Overlap Ratio: 0.9308510638297872>

---

--- 339 --
Question ID: 5c3e5ea23f017e18e35e8f905b98d3180d7cbdbd_0
Original Code:
```
public class BlockEnhancedInterface extends AEBaseTileBlock {

    public static final int MAX_TIER = 3;
    private static final PropertyBool OMNIDIRECTIONAL = PropertyBool.create("omnidirectional");
    private static final PropertyDirection FACING = PropertyDirection.create("facing");
    private final int tier;

    public BlockEnhancedInterface(int tier) {
        super(Material.IRON);
        if (tier == 1) {
            setTileEntity(TileEnhancedInterfaceTier1.class);
        } else if (tier == 2) {
            setTileEntity(TileEnhancedInterfaceTier2.class);
        } else if (tier == 3) {
            setTileEntity(TileEnhancedInterfaceTier3.class);
        }

        this.tier = tier;
    }


    @Override
    protected IProperty<?>[] getAEStates() {
        return new IProperty[]{OMNIDIRECTIONAL};
    }

    @Override
    protected BlockStateContainer createBlockState() {
        return new BlockStateContainer(this, OMNIDIRECTIONAL, FACING);
    }

    @Nonnull
    @Override
    public IBlockState getActualState(@Nonnull IBlockState state, @Nonnull IBlockAccess world, @Nonnull BlockPos pos) {
        TileEnhancedInterfaceBase te = this.getTileEntity(world, pos);
        return te == null ? state
                : state.withProperty(OMNIDIRECTIONAL, te.isOmniDirectional()).withProperty(FACING, te.getForward());
    }

    @Override
    public boolean onActivated(final World world, final BlockPos pos, final EntityPlayer player, final EnumHand hand, final @Nullable ItemStack heldItem, final EnumFacing side, final float hitX, final float hitY, final float hitZ) {
        if (player.isSneaking()) {
            return false;
        }

        TileEntity tile = world.getTileEntity(pos);
        if (tile instanceof TileEnhancedInterfaceBase) {

            if (!world.isRemote) {
                Ae2uGuiHandler.openGui(player, this.tier, tile, AEPartLocation.fromFacing(side));
            }

            return true;
        }

        return false;
    }

    @Nullable
    @Override
    public TileEntity createTileEntity(@Nonnull World world, @Nonnull IBlockState state) {
        switch (this.tier) {
            case 2:
                return new TileEnhancedInterfaceTier2();
            case 3:
                return new TileEnhancedInterfaceTier3();
            case 1:
            default:
                return new TileEnhancedInterfaceTier1();
        }

    }

    @Override
    protected boolean hasCustomRotation() {
        return true;
    }

    @Override
    protected void customRotateBlock(final IOrientable rotatable, final EnumFacing axis) {
        if (rotatable instanceof TileEnhancedInterfaceBase) {
            ((TileEnhancedInterfaceBase) rotatable).setSide(axis);
        }
    }

}
```


Overlapping Code:
```
xtends AEBaseTileBlock {
public static final int MAX_TIER = 3;
private static final PropertyBool OMNIDIRECTIONAL = PropertyBool.create("omnidirectional");
private static final PropertyDirection FACING = PropertyDirection.create("facing");
private final int tier;
public BlockEnhancedInterface(int tier) {
super(Material.IRON);
if (tier == 1) {
setTileEntity(TileEnhancedInterfaceTier1.class);
} else if (tier == 2) {
setTileEntity(TileEnhancedInterfaceTier2.class);
} else if (tier == 3) {
setTileEntity(TileEnhancedInterfaceTier3.class);
}
this.tier = tier;
}
@Override
protected IProperty<?>[] getAEStates() {
return new IProperty[]{OMNIDIRECTIONAL};
}
@Override
protected BlockStateContainer createBlockState() {
return new BlockStateContainer(this, OMNIDIRECTIONAL, FACING);
}
@Nonnull
@Override
public IBlockState getActualState(@Nonnull IBlockState state, @Nonnull IBlockAccess world, @Nonnull BlockPos pos) {
TileEnhancedInterfaceBase te = this.getTileEntity(world, pos);
return te == null ? state
: state.withProperty(OMNIDIRECTIONAL, te.isOmniDirectional()).withProperty(FACING, te.getForward());
}
@Override
public boolean onActivated(final World world, final BlockPos pos, final EntityPlayer player, final EnumHand hand, final @Nullable ItemStack heldItem, final EnumFacing side, final float hitX, final float hitY, final float hitZ) {
if (player.isSneaking()) {
return false;
}
TileEntity tile = world.getTileEntity(pos);
if (tile instanceof TileEnhancedInterfaceBase) {
if (!world.isRemote) {
Ae2uGuiHandler.openGui(player, this.tier, tile, AEPartLocation.fromFacing(side));
}
return true;
}
return false;
}
@Nullable
@Override
public TileEntity createTileEntity(@Nonnull World world, @Nonnull IBlockState state) {
switch (this.tier) {
case 2:
return new TileEnhancedInterfaceTier2();
case 3:
return new TileEnhancedInterfaceTier3();
case 1:
default:
return new TileEnhancedInterfaceTier1();
}
}
@Override
protected boolean hasCustomRota
```
<Overlap Ratio: 0.9701492537313433>

---

--- 340 --
Question ID: 3b7b2f703dc11a8c7580e54214320e6c33a6a3b9_0
Original Code:
```
public final class HelloWorldPostServer {
	public static final int PORT = getFreePort();
	public static final String HELLO_WORLD = "Hello, World!";

	public static AsyncHttpServer helloWorldServer(Eventloop primaryEventloop, int port) {
		return AsyncHttpServer.create(primaryEventloop,
				request -> request.loadBody()
						.map(body -> HttpResponse.ok200()
								.withBody(encodeAscii(HELLO_WORLD + body.getString(UTF_8)))))
				.withListenPort(port);
	}

	public static void main(String[] args) throws Exception {
		Eventloop primaryEventloop = Eventloop.create().withFatalErrorHandler(rethrowOnAnyError()).withCurrentThread();

		AsyncHttpServer httpServerListener = helloWorldServer(primaryEventloop, PORT);

		System.out.println("Start HelloWorld HTTP Server on :" + PORT);
		httpServerListener.listen();

		primaryEventloop.run();
	}

}
```


Overlapping Code:
```
l class HelloWorldPostServer {
public static final int PORT = getFreePort();
public static final String HELLO_WORLD = "Hello, World!";
public static AsyncHttpServer helloWorldServer(Eventloop primaryEventloop, int port) {
return AsyncHttpServer.create(primaryEventloop,
request -> request.loadBody()
.map(body -> HttpResponse.ok200()
.withBody(encodeAscii(HELLO_WORLD + body.getString(UTF_8)))))
.withListenPort(port);
}
public static void main(String[] args) throws Exception {
Eventloop primaryEventloop = Eventloop.create().withFatalErrorHandler(rethrowOnAnyError()).withCurrentThread();
AsyncHttpServer httpServerListener = helloWorldServer(primaryEventloop, PORT);
System.out.println("Start HelloWorld HTTP Server on :" + PORT);
httpServerListener.listen();
pr
```
<Overlap Ratio: 0.9550561797752809>

---

--- 341 --
Question ID: 817f15d3b59e5820fc10f0d483d0655a72ab1876_0
Original Code:
```
class ConvexTriangleCallback extends TriangleCallback {

	//protected final BulletStack stack = BulletStack.get();
	
	private CollisionObject convexBody;
	private CollisionObject triBody;

	private final Vector3f aabbMin = new Vector3f();
	private final Vector3f aabbMax = new Vector3f();

	private ManifoldResult resultOut;

	private Dispatcher dispatcher;
	private DispatcherInfo dispatchInfoPtr;
	private float collisionMarginTriangle;
	
	public int triangleCount;
	public PersistentManifold manifoldPtr;
	
	public ConvexTriangleCallback(Dispatcher dispatcher, CollisionObject body0, CollisionObject body1, boolean isSwapped) {
		this.dispatcher = dispatcher;
		this.dispatchInfoPtr = null;

		convexBody = isSwapped ? body1 : body0;
		triBody = isSwapped ? body0 : body1;

		//
		// create the manifold from the dispatcher 'manifold pool'
		//
		manifoldPtr = dispatcher.getNewManifold(convexBody, triBody);

		clearCache();
	}
	
	public void destroy() {
		clearCache();
		dispatcher.releaseManifold(manifoldPtr);
	}

	public void setTimeStepAndCounters(float collisionMarginTriangle, DispatcherInfo dispatchInfo, ManifoldResult resultOut) {
		this.dispatchInfoPtr = dispatchInfo;
		this.collisionMarginTriangle = collisionMarginTriangle;
		this.resultOut = resultOut;

		Stack stack = Stack.enter();
		// recalc aabbs
		Transform convexInTriangleSpace = stack.allocTransform();

		triBody.getWorldTransform(convexInTriangleSpace);
		convexInTriangleSpace.inverse();
		convexInTriangleSpace.mul(convexBody.getWorldTransform(stack.allocTransform()));

		CollisionShape convexShape = (CollisionShape)convexBody.getCollisionShape();
		//CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);
		convexShape.getAabb(convexInTriangleSpace, aabbMin, aabbMax);
		float extraMargin = collisionMarginTriangle;
		Vector3f extra = stack.allocVector3f();
		extra.set(extraMargin, extraMargin, extraMargin);

		aabbMax.add(extra);
		aabbMin.sub(extra);
		stack.leave();
	}

	private CollisionAlgorithmConstructionInfo ci = new CollisionAlgorithmConstructionInfo();
	private TriangleShape tm = new TriangleShape();
	
	public void processTriangle(Vector3f[] triangle, int partId, int triangleIndex) {
		// just for debugging purposes
		//printf("triangle %d",m_triangleCount++);

		// aabb filter is already applied!	

		ci.dispatcher1 = dispatcher;

		CollisionObject ob = (CollisionObject) triBody;

		// debug drawing of the overlapping triangles
		if (dispatchInfoPtr != null && dispatchInfoPtr.debugDraw != null && dispatchInfoPtr.debugDraw.getDebugMode() > 0) {
		    Stack stack = Stack.enter();
			Vector3f color = stack.allocVector3f();
			color.set(255, 255, 0);
			Transform tr = ob.getWorldTransform(stack.allocTransform());

			Vector3f tmp1 = stack.allocVector3f();
			Vector3f tmp2 = stack.allocVector3f();

			tmp1.set(triangle[0]); tr.transform(tmp1);
			tmp2.set(triangle[1]); tr.transform(tmp2);
			dispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);

			tmp1.set(triangle[1]); tr.transform(tmp1);
			tmp2.set(triangle[2]); tr.transform(tmp2);
			dispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);

			tmp1.set(triangle[2]); tr.transform(tmp1);
			tmp2.set(triangle[0]); tr.transform(tmp2);
			dispatchInfoPtr.debugDraw.drawLine(tmp1, tmp2, color);

			//btVector3 center = triangle[0] + triangle[1]+triangle[2];
			//center *= btScalar(0.333333);
			//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[0]),tr(center),color);
			//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[1]),tr(center),color);
			//m_dispatchInfoPtr->m_debugDraw->drawLine(tr(triangle[2]),tr(center),color);
			stack.leave();
		}

		//btCollisionObject* colObj = static_cast<btCollisionObject*>(m_convexProxy->m_clientObject);

		if (convexBody.getCollisionShape().isConvex()) {
			tm.init(triangle[0], triangle[1], triangle[2]);
			tm.setMargin(collisionMarginTriangle);

			CollisionShape tmpShape = ob.getCollisionShape();
			ob.internalSetTemporaryCollisionShape(tm);

			CollisionAlgorithm colAlgo = ci.dispatcher1.findAlgorithm(convexBody, triBody, manifoldPtr);
			// this should use the btDispatcher, so the actual registered algorithm is used
			//		btConvexConvexAlgorithm cvxcvxalgo(m_manifoldPtr,ci,m_convexBody,m_triBody);

			resultOut.setShapeIdentifiers(-1, -1, partId, triangleIndex);
			//cvxcvxalgo.setShapeIdentifiers(-1,-1,partId,triangleIndex);
			//cvxcvxalgo.processCollision(m_convexBody,m_triBody,*m_dispatchInfoPtr,m_resultOut);
			colAlgo.processCollision(convexBody, triBody, dispatchInfoPtr, resultOut);
			//colAlgo.destroy();
			ci.dispatcher1.freeCollisionAlgorithm(colAlgo);
			ob.internalSetTemporaryCollisionShape(tmpShape);
		}
	}

	public void clearCache() {
		dispatcher.clearManifold(manifoldPtr);
	}

	public Vector3f getAabbMin(Vector3f out) {
		out.set(aabbMin);
		return out;
	}

	public Vector3f getAabbMax(Vector3f out) {
		out.set(aabbMax);
		return out;
	}
	
}
```


Overlapping Code:
```
gleCallback {
//protected final BulletStack stack = BulletStack.get();

private CollisionObject convexBody;
private CollisionObject triBody;
private final Vector3f aabbMin = new Vector3f();
private final Vector3f aabbMax = new Vector3f();
private ManifoldResult resultOut;
private Dispatcher dispatcher;
private DispatcherInfo dispatchInfoPtr;
private float collisionMarginTriangle;

public int triangleCount;
public PersistentManifold manifoldPtr;

public ConvexTriangleCallback(Dispatcher dispatcher, CollisionObject body0, CollisionObject body1, boolean isSwapped) {
this.dispatcher = dispatcher;
this.dispatchInfoPtr = null;
convexBody = isSwapped ? body1 : body0;
triBody = isSwapped ? body0 : body1;
//
// create the manifold from the dispatcher 'manifold pool'
//
manifoldPtr = dispatcher.getNewManifold(convexBody, triBody);
clearCache();
}

public void destroy() {
clearCache();
dispatcher.releaseManifold(manifoldPtr);
}
public void setTimeStepAndCounters(float collisionMarginTriangle, DispatcherInfo dispatchInfo, ManifoldResult resultOut) {
this.dispatchInfoPtr = dispatchInfo;
this.collisionMarginTriangle = collisionMarginTriangle;
this.resultOut = resultOut;
Stack stack = Stack.enter();
// recalc aabbs
Transform convexInTriangleSpace = stack.allocTransform();
triBody.getWorldTransform(convexInTriangleSpace);
convexInTriangleSpace.inverse();
convexInTriangleSpace.mul(convexBody.getWorldTransform(stack.allocTransform()));
CollisionShape convexShape = (CollisionShape)convexBody.getCollisionShape();
//CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);
convexShape.getAabb(convexInTriangleSpace, aabbMin, aabbMax);
float extraMargin = collisionMarginTriangle;
Vector3f extra = stack.allocVector3f();
extra.set(extraMargin, extraMargin, extraMargin);
aabbMax.add(extra);
aabbMin.sub(extra);
stack.leave();
}
private CollisionAlgorithmConstructionInfo ci = new CollisionAlgorithmConstructionInfo();
private TriangleShape tm = new TriangleShape();

public void processTriangle(Vector3f[] triangle, int partId, int triangleIndex) {
// just for debugging purposes
//printf("triangle %d",m_triangleCount++);
// aabb filter is already applied! 
ci.dispatcher1 = dispatcher;
CollisionObject ob = (CollisionObject) triBody;
// debug drawing of the ov
```
<Overlap Ratio: 0.964765100671141>

---

--- 342 --
Question ID: 4d4db1fbdc6bb8dd3fe1f879ace2edc5f528e17e_0
Original Code:
```
public abstract class AbstractExternalLinkUpdater 
implements ExternalLinkUpdater {

    protected final Log logger = LogFactory.getLog(getClass());
    
    private CSXDAO csxdao;
    
    public void setCSXDAO(CSXDAO csxdao) {
        this.csxdao = csxdao;
    } //- setCSXDAO
    
    private String label;
    
    /**
     * Sets the label that identifies this external source within the database
     * @param label A label to identify the external source. <b>Note:</b> This
     * value must match a value in the links_types table within the database.
     */
    public void setLabel(String label) {
        this.label = label;
    } //- setLabel
    
    /* (non-Javadoc)
     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#getPapersNoELink(java.lang.Long, java.lang.String)
     */
    public List<String> getPapersNoELink(Long amount, String lastID) {
        return csxdao.getPapersNoELink(label, lastID, amount);
    } //- getPapersNoELink

    /* (non-Javadoc)
     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(java.lang.String)
     */
    public void updateELinkForPaper(String doi) {

        try {
            Document doc = csxdao.getDocumentFromDB(doi);
            if (doc != null) {
                updateELinkForPaper(doc);
            }else{
                logger.info("No document was found for doi: " + doi);
            }
        }catch (DataAccessException e) {
            logger.error("An error occured updating external links for " +
            		"document: " + doi, e);
        }      
    } //- updateELinkForPaper


    /* (non-Javadoc)
     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(edu.psu.citeseerx.domain.Document)
     */
    public void updateELinkForPaper(Document doc) {
        try {
            String urlPortion = getUrlForPaper(doc);
            String doi = doc.getDatum(Document.DOI_KEY);
                
            if (urlPortion != null) {
                ExternalLink eLink = new ExternalLink();
                eLink.setLabel(label);
                eLink.setPaperID(doi);
                eLink.setUrl(urlPortion);
                csxdao.updateExternalLink(eLink);
            }else{
                if (csxdao.getExternalLinkExist(label, doi)) {
                    // The document has an elink for label but it's a wrong one
                    csxdao.deleteExternalLink(doi, label);
                }
            }
        }catch (DataAccessException e) {
            logger.error("An error occured updating external links for " +
                    "document: " + doc.getDatum(Document.DOI_KEY), e);
        }
        
    } //- updateELinkForPaper

    
    /* (non-Javadoc)
     * @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateExternalLinks()
     */
    public void updateExternalLinks() {
        String lastID = "";
        boolean finished = false;
        
        Long amount = new Long(1000);
        List<String> docIDs = new ArrayList<String>();
        logger.info("Starting updates for label: " + label);
        do {
            docIDs = getPapersNoELink(amount, lastID);
            if (docIDs.isEmpty()) {
                finished = true;
            }else{
                for (String doi : docIDs) {
                    logger.info("Updating External Link for document: " + doi + 
                            " using " + label + " label");
                    updateELinkForPaper(doi);
                    logger.info("External Link for document: " + doi + 
                            " using " + label + " label has been updated");
                }
                lastID = docIDs.get(docIDs.size()-1);
            }
        }while(!finished);
        logger.info("Updates for label: " + label + " has finished");
        
    } //- updateExternalLinks
    
    /* (non-Javadoc)
     * @see edu.psu.citeseerx.updates.UpdateListener#handleUpdate(edu.psu.citeseerx.domain.Document)
     */
    public void handleUpdate(Document doc) {
        logger.trace("Handling update for: " + doc.getDatum(Document.DOI_KEY));
        updateELinkForPaper(doc);
        logger.trace("Update for: " + doc.getDatum(Document.DOI_KEY) + 
                " finished");
    } //- handleUpdate

    /**
     * Child classes must override this method.
     * @see edu.psu.citeseerx.updates.external.links.ExternalLinkUpdater#getUrlForPaper(edu.psu.citeseerx.domain.Document)
     */
    public String getUrlForPaper(Document doc) {
        return null;
    } //- getUrlForPaper
}
```


Overlapping Code:
```
Updater 
implements ExternalLinkUpdater {
protected final Log logger = LogFactory.getLog(getClass());

private CSXDAO csxdao;

public void setCSXDAO(CSXDAO csxdao) {
this.csxdao = csxdao;
} //- setCSXDAO

private String label;

/**
* Sets the label that identifies this external source within the database
* @param label A label to identify the external source. <b>Note:</b> This
* value must match a value in the links_types table within the database.
*/
public void setLabel(String label) {
this.label = label;
} //- setLabel

/* (non-Javadoc)
* @see edu.psu.citeseerx.updates.ExternalLinkUpdater#getPapersNoELink(java.lang.Long, java.lang.String)
*/
public List<String> getPapersNoELink(Long amount, String lastID) {
return csxdao.getPapersNoELink(label, lastID, amount);
} //- getPapersNoELink
/* (non-Javadoc)
* @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(java.lang.String)
*/
public void updateELinkForPaper(String doi) {
try {
Document doc = csxdao.getDocumentFromDB(doi);
if (doc != null) {
updateELinkForPaper(doc);
}else{
logger.info("No document was found for doi: " + doi);
}
}catch (DataAccessException e) {
logger.error("An error occured updating external links for " +
"document: " + doi, e);
} 
} //- updateELinkForPaper
/* (non-Javadoc)
* @see edu.psu.citeseerx.updates.ExternalLinkUpdater#updateELinkForPaper(edu.psu.citeseerx.domain.Document)
*/
public void updateELinkForPaper(Document doc) {
try {
String urlPortion = getUrlForPaper(doc);
String doi = doc.getDatum(Document.DOI_KEY);

if (urlPortion != null) {
ExternalLink eLink = new ExternalLink();
eLink.setLabel(label);
eLink.setPaperID(doi);
eLink.setUrl(urlPortion);
csxdao.updateExternalLink(eLink);
}else{
if (csxdao.getExternalLinkExist(label, doi)) {
// The document has an elink for label but it's a wrong one
csxdao.deleteExternalLink(doi, label);
}
}
}catch (DataAccessException e) {
logg
```
<Overlap Ratio: 0.9768637532133676>

---

--- 343 --
Question ID: 85d09c0feb82a8da19c0a94321d5496929efa0b9_0
Original Code:
```
public class WorkerController {
    private static final Logger logger = LoggerFactory.getLogger(WorkerController.class);

    private final Keeper keeper;
    private final RestServer rest;

    public WorkerController(Keeper keeper, RestServer rest) {
        this.keeper = keeper;
        this.rest = rest;
    }

    public void startup() {
        keeper.start();
        rest.start(keeper);

        logger.info("Worker Controller started.");
    }

    public void shutdown() {
        rest.stop();
        keeper.stop();

        logger.info("Worker Controller stopped.");
    }
}
```


Overlapping Code:
```
public class WorkerController {
private static final Logger logger = LoggerFactory.getLogger(WorkerController.class);
private final Keeper keeper;
private final RestServer rest;
public WorkerController(Keeper keeper, RestServer rest) {
this.keeper = keeper;
this.rest = rest;
}
public void startup() {
keeper.start();
rest.start(keeper);
logger.info("Worker Controller started.");
}
public void shutdown() {
rest.stop();
keeper.stop();
logger.info("Worker Controller s
```
<Overlap Ratio: 0.970954356846473>

---

--- 344 --
Question ID: 397e2803a0780030cd16dfe99876ba33baa4cc6c_0
Original Code:
```
@Controller
@RequestMapping(value = "/item")
public class ItemController extends BaseController {
	private static final Logger logger = LoggerFactory.getLogger(ItemController.class);

	@Inject
	@Named("bidService")
	private BidService bidService;


	@RequestMapping(value = "/current/auction/{auctionId}", method = RequestMethod.GET)
	public @ResponseBody
	ItemRepresentation getCurrentItem(@PathVariable long auctionId, HttpServletResponse response) {
		String username = this.getSecurityUtil().getUsernameFromPrincipal();

		logger.info("ItemController::getCurrentItem auctionId = " + auctionId + ", username = " + username);

		ItemRepresentation returnItem = null;
		try {
			returnItem = bidService.getCurrentItem(auctionId);
		} catch (AuctionNotActiveException ex) {
			response.setStatus(HttpServletResponse.SC_GONE);
			response.setContentType("text/html");
			try {
				PrintWriter responseWriter = response.getWriter();
				responseWriter.print("AuctionComplete");
				responseWriter.close();
				return null;
			} catch (IOException e1) {
				logger.warn("ItemController::getCurrentItem: got IOException when writing AuctionComplete message to reponse"
						+ e1.getMessage());
			}
		}
		
		if (returnItem == null) {
			response.setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);
		}
		
		return returnItem;
	}

}
```


Overlapping Code:
```
roller
@RequestMapping(value = "/item")
public class ItemController extends BaseController {
private static final Logger logger = LoggerFactory.getLogger(ItemController.class);
@Inject
@Named("bidService")
private BidService bidService;
@RequestMapping(value = "/current/auction/{auctionId}", method = RequestMethod.GET)
public @ResponseBody
ItemRepresentation getCurrentItem(@PathVariable long auctionId, HttpServletResponse response) {
String username = this.getSecurityUtil().getUsernameFromPrincipal();
logger.info("ItemController::getCurrentItem auctionId = " + auctionId + ", username = " + username);
ItemRepresentation returnItem = null;
try {
returnItem = bidService.getCurrentItem(auctionId);
} catch (AuctionNotActiveException ex) {
response.setStatus(HttpServletResponse.SC_GONE);
response.setContentType("text/html");
try {
PrintWriter responseWriter = response.getWriter();
responseWriter.print("AuctionComplete");
responseWriter.close();
return null;
} catch (IOException e1) {
logger.warn("ItemController::getCurrentItem: got IOException when writing AuctionComplete message to reponse"
+ e1.getMessage());
}
}

if (returnItem == null) {
response.setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);
}

return returnI
```
<Overlap Ratio: 0.9895833333333334>

---

--- 345 --
Question ID: b6569873dcf589dd2f8992a4cd7e6cf1abf7e023_0
Original Code:
```
public class TestRobot extends AbstractAnalysis {
    
    Color darkred = new Color(160,0,0,0.5f);
    //Color green = new Color(34,139,34);

    public TestRobot() {
        super(new ChartFactory());
    }
    
    public static void main(String[] args) throws Exception {
        TestRobot d = new TestRobot();
        AnalysisLauncher.open(d);
    }
    
    @Override
    public void init() {
      
        Quality q = Quality.Advanced(); 
        q.setDepthActivated(true);
        q.setAlphaActivated(true);
        q.setAnimated(false); 
        q.setHiDPIEnabled(true); 
        
        // Create a chart Quality.Advanced()
        chart = new SwingChartFactory().newChart(q);
        chart.getView().setSquared(false);


        // die letzten Werte für alpha, a bzw. den korrespondierenden delta-Werte ist 0,
        // da das letzte Koordinatensystem einfach nur in Achsenrichtung um d verschoben ist

        // added zero values at the beginning to represent the basis coordinate system, needed to calculate mDH values
        // Werkskalibration UR5e
        double[] delta_theta_rad = new double[]{0d, -8.27430119976213518e-08, 0.732984551101984239, 5.46919521494736127, 0.0810043775014757245, -3.53724730506321805e-07, -9.97447025669062626e-08};
        double[] delta_a_m = new double[]{0d, 0.000156734465764371306, 0.109039760794650886, 0.00135049423466820917, 6.30167176077633267e-05, 8.98147062591837358e-05, 0};
        double[] delta_d_m = new double[]{0d, -7.63582045015809285e-05, 136.026368377065324, -143.146527922606964, 7.12049886607637639, -6.13561334270734671e-05, -0.000218168195914358876};
        double[] delta_alpha_rad= new double[]{0d, -0.000849612070594307767, 0.00209120614311242205, 0.0044565542371754396, -0.000376815598678081898, 0.000480742313784698894, 0};

        // Stuttgarter Werte bestimmt aus 20221115A
        /*double[] delta_theta_rad = new double[]{0, -6.0717e-04,  7.3364e-01,  5.4693e+00,  8.1761e-02, -1.7036e-04, 3.6291e-04};
        double[] delta_a_m = new double[]{0, 4.1994e-04,  1.0786e-01, -7.8398e-05,  9.4018e-04,  2.4728e-04, 1.0543e-04};
        double[] delta_d_m = new double[]{0, 8.0152e-04,  1.3603e+02, -1.4315e+02,  7.1207e+00,  2.0997e-04, -1.0959e-03};
        double[] delta_alpha_rad = new double[]{0, 0.0010,  0.0021,  0.0044, -0.0005,  0.0008,  0.0000};
        */
        double[] d_n_m_ = new double[]{0d, 0.1625, 0d, 0d, 0.1333, 0.0997, 0.0996};

        // Die zu bestimmenden Werte auf NaN gesetzt. Das sind die, bei denen
        // die nachfolgende Achse nahezu senkrecht steht.
        // Achtung: Länge des Arrays ist um 1 kleiner als die anderen, da der erste Wert d1,
        // Es gibt keinen d0-Wert
        double[] d_n_m = new double[]{Double.NaN, 0d, 0d, Double.NaN, Double.NaN, 0.0996-0.000218168195914358876};

        // use the signs of the nominal values to define the directions of a --> theta, a, alpha
        double[] a_n_m = new double[]{0d, 0d,  -0.425, -0.3922, 0d, 0d, 0d};
        // a0-a6
        // Vorzeichen von a1 ist auf UR-Seite nicht zu erkennen, aber a2-4 negativ, a5-6 positiv
        // DH4 ist damit seltsamerweise falsch
        //boolean[] sign_r = new boolean[]{false, true, true, true, true, true, true};
        boolean[] sign_r = new boolean[]{false, true, true, false, false, false, false};

        double[] alpha_n_rad = new double[]{0d, PI/2d, 0d, 0d, PI/2d, -PI/2d, 0d};

        // DH-Parameter inclusive manufacturer calibration offsets
        double[] d_m = new double[7];
        double[] a_m = new double[7];
        double[] alpha_rad = new double[7];
        double[] theta_rad = new double[7];
        for (int i=0;i<7;i++){
            d_m[i] = d_n_m_[i] + delta_d_m[i];
            a_m[i] = a_n_m[i]  + delta_a_m[i];
            alpha_rad[i] = alpha_n_rad[i] + delta_alpha_rad[i];
            theta_rad[i] = delta_theta_rad[i];
        }

        // geht so nicht, da auch bei den Positionen an denen die nominallen r-Werte
        // 0 sind könnte das Vorzeichen geflippt werden müssen
        /*for (int i=0;i<6;i++){
            sign_r[i] = a_n_m[i] < 0;
        }*/

        DHAxes axes = determineDHAxesFromDH(theta_rad, alpha_rad, d_m, a_m);
        float radius = (float) 0.01;
        float length = 0.4f;
        for (int i=0;i<axes.z.length;i++){
            Arrow arrow = new Arrow();
            //pos, dir, length
            double x = axes.c[i].x;
            double y = axes.c[i].y;
            double z = axes.c[i].z;
            double dx = axes.z[i].x;
            double dy = axes.z[i].y;
            double dz = axes.z[i].z;
            if (Math.abs(axes.c[i].y) > 1){
                System.out.println("Axis["+String.valueOf(i)+"] moved to o(y=0)!");
                // oder Ursprung so verschieben, dass y=0 wird
                double t = -y/dy;
                x +=t*dx;
                y = 0;
                z +=t*dz;
            }
            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), 
                    new Coord3d(dx,dy,dz), length),radius,10,0, darkred);
                arrow.setWireframeDisplayed(false);
            chart.add(arrow);
            
            // x-axes
            arrow = new Arrow();
            float xlength = 0.1f;
            arrow.setData(Utils2.createVector3d(new Coord3d(x,y,z), 
                    new Coord3d(axes.x[i].x,axes.x[i].y,axes.x[i].z), xlength),radius,10,0, Color.BLUE);
                arrow.setWireframeDisplayed(false);
            chart.add(arrow);
        }

        /*double radius = 2;
        Sphere sphere = new Sphere(new Coord3d(0,0,0),(float)radius,15,darkred);
        sphere.setWireframeColor(darkred);
        
        // hat alles nichts gebracht
        sphere.setFaceDisplayed(true);
        sphere.setWireframeColor(Color.CYAN);
        sphere.setWireframeDisplayed(true);
        sphere.setWireframeWidth(2);
        sphere.setReflectLight(true);
        chart.add(sphere);*/
        
        // This addition keeps the aspect ratio of the X and Y data
        // but makes X and Z square
        //chart.getView().setSquarifier(new XZSquarifier());
        //chart.getView().setSquared(true);
        
       
    }
    
    public record DHAxes(Vector3d[] z, Vector3d[] x, Point3d[] c){}
    
    /**
     * Determine DH-axes from DH parameters.
     * 
     * @param theta with 0 as first value in [°] (7 values for UR5e)
     * @param alpha with 0 as first value in [°] (7 values for UR5e)
     * @param d with 0 as first value in [m]
     * @param r with 0 as first value in [m]
     * @return axes of all of the DH frames.
     */
    public static DHAxes determineDHAxesFromDH(double[] theta, double[] alpha, double[] d, 
                                       /*double[] dn,*/ double[] r/*, boolean[] signR*/){
        
        Vector3d[] z = new Vector3d[alpha.length];
        Vector3d[] x = new Vector3d[alpha.length]; // reale Ausrichtung der x-Achsen
        Point3d[]  c = new Point3d[alpha.length];
        
        System.out.println("Denavit Hartenberg:");
        System.out.println("------------------");
        
        //  Basis-Koordinatensystem
        
        z[0] = new Vector3d(0d,0d,1d); // Ausrichtung er ersten Drehachse
        // x[0] zeigt von der vorherigen Achse, also dem Basis-System auf die erste
        // Achse also Globe2Base - um keine unnötigen delta-thetas zu erzeugen, sollte
        // x[0] in Richtung von z[2] in der neutral-pose zeigen, die die nach z[1] folgenden zweite joint-axis
        // sollte ja in der neutral-pose gerade die Ausgangs-x-Richtung definieren
        x[0] = new Vector3d(1d,0d,0d);
        c[0] = new Point3d(0d,0d,0d);
        System.out.println("o0= ("+String.valueOf(c[0].x)+","+String.valueOf(c[0].y)+","+String.valueOf(c[0].z)+")");
        System.out.println("z0= ("+String.valueOf(z[0].x)+","+String.valueOf(z[0].y)+","+String.valueOf(z[0].z)+")");
        
        Matrix4d dhm = new Matrix4d();
        dhm.setIdentity();
        
        //TODO
        // unklar, wie ich das Vorzeichen im Modell von a2-a4 berücksichten muss, 
        // außerdem unklar, warum a5-a6 kein Vorzeichen definiert
        // vermutlich muss ich beim Erstellen der matrix die Vorzeichen gar nicht berücksichtigen!!!!
        
        // 
        for (int i=1;i<alpha.length;i++){
            System.out.println("Input("+String.valueOf(i)+"): alpha="+String.valueOf(alpha[i]*180d/PI)+
                    "°, theta="+String.valueOf(theta[i]*180d/PI)+
                    "°, d="+String.valueOf(d[i]*1000d)+"mm, r="+String.valueOf(r[i]*1000)+"mm");
            
            // origin in lokalen Koordinaten
            Point3d cc = new Point3d(0d,0d,0d);
            // z-Richtung in lokalen Koordinaten
            Vector3d zz = new Vector3d(0d,0d,1d);
            // x-Richtung in lokalen Koordinaten
            Vector3d xx = new Vector3d(1d,0d,0d);
        
            dhm.mul(new DH(theta[i], alpha[i], d[i], r[i]).toMatrix4d());
            
            dhm.transform(cc);
            System.out.println("o"+String.valueOf(i)+"= ("+String.valueOf(cc.x)+","+String.valueOf(cc.y)+","+String.valueOf(cc.z)+")");
            c[i] = new Point3d(cc.x,cc.y,cc.z);
            
            dhm.transform(zz);
            System.out.println("z"+String.valueOf(i)+"= ("+String.valueOf(zz.x)+","+String.valueOf(zz.y)+","+String.valueOf(zz.z)+")");
            z[i] = new Vector3d(zz);
            
            dhm.transform(xx);
            System.out.println("x"+String.valueOf(i)+"= ("+String.valueOf(xx.x)+","+String.valueOf(xx.y)+","+String.valueOf(xx.z)+")");
            x[i] = new Vector3d(xx);
        }
        
        return new DHAxes(z,x,c);
    }
}
```


Overlapping Code:
```
tends AbstractAnalysis {

Color darkred = new Color(160,0,0,0.5f);
//Color green = new Color(34,139,34);
public TestRobot() {
super(new ChartFactory());
}

public static void main(String[] args) throws Exception {
TestRobot d = new TestRobot();
AnalysisLauncher.open(d);
}

@Override
public void init() {

Quality q = Quality.Advanced(); 
q.setDepthActivated(true);
q.setAlphaActivated(true);
q.setAnimated(false); 
q.setHiDPIEnabled(true); 

// Create a chart Quality.Advanced()
chart = new SwingChartFactory().newChart(q);
chart.getView().setSquared(false);
// die letzten Werte für alpha, a bzw. den korrespondierenden delta-Werte ist 0,
// da das letzte Koordinatensystem einfach nur in Achsenrichtung um d verschoben ist
// added zero values at the beginning to represent the basis coordinate system, needed to calculate mDH values
// Werkskalibration UR5e
double[] delta_theta_rad = new double[]{0d, -8.27430119976213518e-08, 0.732984551101984239, 5.46919521494736127, 0.0810043775014757245, -3.53724730506321805e-07, -9.97447025669062626e-08};
double[] delta_a_m = new double[]{0d, 0.000156734465764371306, 0.109039760794650886, 0.00135049423466820917, 6.30167176077633267e-05, 8.98147062591837358e-05, 0};
double[] delta_d_m = new double[]{0d, -7.63582045015809285e-05, 136.026368377065324, -143.146527922606964, 7.12049886607637639, -6.13561334270734671e-05, -0.000218168195914358876};
double[] delta_alpha_rad= new double[]{0d, -0.000849612070594307767, 0.00209120614311242205, 0.0044565542371754396, -0.000376815598678081898, 0.000480742313784698894, 0};
// Stuttgarter Werte bestimmt aus 20221115A
/*double[] delta_theta_rad = new double[]{0, -6.0717e-04, 7.3364e-01, 5.4693e+00, 8.1761e-02, -1.7036e-04, 3.6291e-04};
double[] delta_a_m = new double[]{0, 4.1994e-04, 1.0786e-01, -7.8398e-05, 9.4018e-04, 2.4728e-04, 1.0543e-04};
double[] delta_d_m = new double[]{0, 8.0152e-04, 1.3603e+02, -1.4315e+02, 7.1207e+00, 2.0997e-04, -1.0959e-03};
double[] delta_alpha_rad = new double[]{0, 0.0010, 0.0021, 0.0044, -0.0005, 0.0008, 0.0000};
*/
double[] d_n_m_ = new double[]{0d, 0.1625, 0d, 0d, 0.1333, 0.0997, 0.0996};
// Die zu bestimmenden We
```
<Overlap Ratio: 0.9746146872166818>

---

--- 346 --
Question ID: afc947e75177e90fcaafc651ac46d55f52c5a659_0
Original Code:
```
public class MultiPropertyKey {

	private MultiPropertyKeyPart[] properties;

	public MultiPropertyKey(int filterSize) {
		properties = new MultiPropertyKeyPart[0];
	}

	// Initial adding key values.
	public void add(String key, String value) {
		int newLength = properties.length + 1;
		MultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];
		
		System.arraycopy(properties, 0, tmpKeys, 0, properties.length);
		tmpKeys[newLength-1] = new MultiPropertyKeyPart(key, value);
		
		this.properties = tmpKeys;
		Arrays.sort(properties);
	}

	public void append(MultiPropertyKey other) {
		int newLength = properties.length + other.properties.length;
		MultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];
		
		System.arraycopy(properties, 0, tmpKeys, 0, properties.length);
		System.arraycopy(other.properties, 0, tmpKeys, properties.length, other.properties.length);
	
		this.properties = tmpKeys;
		Arrays.sort(properties);
	}

	@Override
	public int hashCode() {
		return Arrays.hashCode(properties);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (!(obj instanceof MultiPropertyKey)) {
			return false;
		}

		MultiPropertyKey other = (MultiPropertyKey) obj;

		if (properties.length != other.properties.length) {
			return false;
		}

		for (int i = 0; i < properties.length; i++) {
			if (!(properties[i].equals(other.properties[i]))) {
				return false;
			}
		}
		return true;
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < properties.length; i++) {
			builder.append(properties[i].key);
			builder.append('=');
			builder.append(properties[i].value);
			if (i < properties.length - 1) {
				builder.append(';');
			}
		}
		return builder.toString();
	}

	// (key=value) part of a multi property index (&(key1=val1)(key2=val2) .. )
	private class MultiPropertyKeyPart implements Comparable<MultiPropertyKeyPart> {
		
		private final String key;
		private final String value;

		public MultiPropertyKeyPart(String key, String value) {
			this.key = key;
			this.value = value;
		}

		@Override
		public int hashCode() {
			int h = 0;
			h += 31 * key.hashCode();
			h += value.hashCode();
			return h;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (!(obj instanceof MultiPropertyKeyPart))
				return false;

			MultiPropertyKeyPart object = (MultiPropertyKeyPart) obj;

			if (!(this.key.equals(object.key)))
				return false;
			if (!(this.value.equals(object.value)))
				return false;

			return true;
		}

		@Override
		public int compareTo(MultiPropertyKeyPart o) {
			if (this.key.compareTo(o.key) == 0) {
				return this.value.compareTo(o.value);
			}
			return this.key.compareTo(o.key);
		}
	}
}
```


Overlapping Code:
```
blic class MultiPropertyKey {
private MultiPropertyKeyPart[] properties;
public MultiPropertyKey(int filterSize) {
properties = new MultiPropertyKeyPart[0];
}
// Initial adding key values.
public void add(String key, String value) {
int newLength = properties.length + 1;
MultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];

System.arraycopy(properties, 0, tmpKeys, 0, properties.length);
tmpKeys[newLength-1] = new MultiPropertyKeyPart(key, value);

this.properties = tmpKeys;
Arrays.sort(properties);
}
public void append(MultiPropertyKey other) {
int newLength = properties.length + other.properties.length;
MultiPropertyKeyPart[] tmpKeys = new MultiPropertyKeyPart[newLength];

System.arraycopy(properties, 0, tmpKeys, 0, properties.length);
System.arraycopy(other.properties, 0, tmpKeys, properties.length, other.properties.length);

this.properties = tmpKeys;
Arrays.sort(properties);
}
@Override
public int hashCode() {
return Arrays.hashCode(properties);
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (!(obj instanceof MultiPropertyKey)) {
return false;
}
MultiPropertyKey other = (MultiPropertyKey) obj;
if (properties.length != other.properties.length) {
return false;
}
for (int i = 0; i < properties.length; i++) {
if (!(properties[i].equals(other.properties[i]))) {
return false;
}
}
return true;
}
@Override
public String toString() {
StringBuilder builder = new StringBuilder();
for (int i = 0; i < properties.length; i++) {
builder.append(properties[i].key);
builder.append('=');
builder.append(properties[i].value);
if (i < properties.length - 1) {
builder.append(';');
}
}
return builder.toString();
}
// (key=value) part of a multi property index (&(key1=val1)(key2=val2) .. )
private class MultiPropertyKeyPart implements Comparable<MultiPropertyKeyPart> {

private final String key;
private final String value;
public MultiPropertyKeyPart(String key, String value) {
this.key = key;
this.value = value;
}
@Override
public int hashCode() {
int h = 0;
h += 31 * key.hashCode();
h += value.hashCode();
return h;
}
@Override
public boolean equals(Object obj) {
if (this == obj)
return true;
if (!(obj instanceof MultiPropertyKeyPart))
return false;
MultiPropertyKeyPart object = (MultiPropertyKeyPart) obj;
if (!(this.key.equa
```
<Overlap Ratio: 0.9982638888888888>

---

--- 347 --
Question ID: 50742ed1f7441556a5fd21d3a32ea5052a53ca08_0
Original Code:
```
@SpringJUnitConfig({Jpa3JavaConfig.class})
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class Stock3CrudPagingRepositoryTest {


    @Autowired
    private Stock3CrudPagingService service;

    @Test
    void getAllStock() {
        List<Stock3Entity> stockList = service.getAll();
        stockList.forEach(System.out::println);
    }

    @Test
    void getAllStockSorted() {
        List<Stock3Entity> stockList = service.getAllSorted(Sort.by(Sort.Order.desc("id")));
        stockList.forEach(System.out::println);
    }

    @Test
    void getAllStockPagination() {
        Page<Stock3Entity> page = service.getAllPaginated(1, 2, "id");
        if (page.hasContent()) {
            System.out.println("Records exists in the response");
        } else {
            System.out.println("No Records exists in the response");
        }
        System.out.println("Total ELements : " + page.getTotalElements());
        System.out.println("Total Pages : " + page.getTotalPages());
        System.out.println("Count :" + page.stream().count());
        System.out.println("===PAGE RECORDS===");
        page.get().forEach(System.out::println);
    }

    @Test
    void saveWithTx() {
        Stock3Entity entity = new Stock3Entity();
        entity.setId("NSE:MINE");
        entity.setName("MY COMPANY");
        entity.setPrice(20.5);
        service.save(entity);

        List<Stock3Entity> stockList = service.getAll();
        stockList.forEach(System.out::println);
    }

    @Test
    void customQuery() {
       List<String> ids = service.getAllStockId();
       ids.forEach(System.out::println);
    }
}
```


Overlapping Code:
```
ringJUnitConfig({Jpa3JavaConfig.class})
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class Stock3CrudPagingRepositoryTest {
@Autowired
private Stock3CrudPagingService service;
@Test
void getAllStock() {
List<Stock3Entity> stockList = service.getAll();
stockList.forEach(System.out::println);
}
@Test
void getAllStockSorted() {
List<Stock3Entity> stockList = service.getAllSorted(Sort.by(Sort.Order.desc("id")));
stockList.forEach(System.out::println);
}
@Test
void getAllStockPagination() {
Page<Stock3Entity> page = service.getAllPaginated(1, 2, "id");
if (page.hasContent()) {
System.out.println("Records exists in the response");
} else {
System.out.println("No Records exists in the response");
}
System.out.println("Total ELements : " + page.getTotalElements());
System.out.println("Total Pages : " + page.getTotalPages());
System.out.println("Count :" + page.stream().count());
System.out.println("===PAGE RECORDS===");
page.get().forEach(System.out::println);
}
@Test
void saveWithTx() {
Stock3Entity entity = new Stock3Entity();
entity.setId("NSE:MINE");
entity.setName("MY COMPANY");
entity.setPrice(20.5);
service.save(entity);
List<Stock3Entity> stockList = service.getAll();
stockList.forEach(System.out::println);
}
@Test
void customQuery() {
List<String> ids = service.getAllS
```
<Overlap Ratio: 0.9629629629629629>

---

--- 348 --
Question ID: 1ad862fc89b4b1fa463566d8b67a997a46f58a86_0
Original Code:
```
@Stateless
@LocalBean
@Loggable
public class ItemService extends AbstractService<Item> implements Serializable
{


   // ======================================
   // =            Constructors            =
   // ======================================

   public ItemService()
   {
      super(Item.class);
   }

   // ======================================
   // =         Protected methods          =
   // ======================================

   @Override
   protected Predicate[] getSearchPredicates(Root<Item> root, Item example)
   {
      CriteriaBuilder builder = this.entityManager.getCriteriaBuilder();
      List<Predicate> predicatesList = new ArrayList<Predicate>();

      String name = example.getName();
      if (name != null && !"".equals(name))
      {
         predicatesList.add(builder.like(builder.lower(root.<String> get("name")), '%' + name.toLowerCase() + '%'));
      }
      String description = example.getDescription();
      if (description != null && !"".equals(description))
      {
         predicatesList.add(builder.like(builder.lower(root.<String> get("description")), '%' + description.toLowerCase() + '%'));
      }
      String imagePath = example.getImagePath();
      if (imagePath != null && !"".equals(imagePath))
      {
         predicatesList.add(builder.like(builder.lower(root.<String> get("imagePath")), '%' + imagePath.toLowerCase() + '%'));
      }
      Product product = example.getProduct();
      if (product != null)
      {
         predicatesList.add(builder.equal(root.get("product"), product));
      }

      return predicatesList.toArray(new Predicate[predicatesList.size()]);
   }
}
```


Overlapping Code:
```
lBean
@Loggable
public class ItemService extends AbstractService<Item> implements Serializable
{
// ======================================
// = Constructors =
// ======================================
public ItemService()
{
super(Item.class);
}
// ======================================
// = Protected methods =
// ======================================
@Override
protected Predicate[] getSearchPredicates(Root<Item> root, Item example)
{
CriteriaBuilder builder = this.entityManager.getCriteriaBuilder();
List<Predicate> predicatesList = new ArrayList<Predicate>();
String name = example.getName();
if (name != null && !"".equals(name))
{
predicatesList.add(builder.like(builder.lower(root.<String> get("name")), '%' + name.toLowerCase() + '%'));
}
String description = example.getDescription();
if (description != null && !"".equals(description))
{
predicatesList.add(builder.like(builder.lower(root.<String> get("description")), '%' + description.toLowerCase() + '%'));
}
String imagePath = example.getImagePath();
if (imagePath != null && !"".equals(imagePath))
{
predicatesList.add(builder.like(builder.lower(root.<String> get("imagePath")), '%' + imagePath.toLowerCase() + '%'));
}
Product product = example.getProduct();
if (product != null)
{
predicatesList.add(builder.equal(root.get("product"), product));
}
return predicatesList.toArray(new Predicate[predicatesList.size()]);
}

```
<Overlap Ratio: 0.9879089615931721>

---

--- 349 --
Question ID: ccadec7e2109772ac9b069ee2ee27eab1548818c_0
Original Code:
```
public class LogEntry implements Comparable<LogEntry>
{
    // Where the data values extracted from a single
    // log line are stored.
    private int[] dataValues;
    // At which index in dataValues the different fields
    // from a log line are stored.
    private static final int YEAR = 0, MONTH = 1, DAY = 2,
                             HOUR = 3, MINUTE = 4;
                      
    /**
     * Decompose a log line so that the individual fields
     * are available.
     * @param logline A single line from the log.
     */
    public LogEntry(String logline)
    {
        // The array to store the data for a single line.
        dataValues = new int[5];
        // Break up the log line.
        LoglineTokenizer tokenizer = new LoglineTokenizer();
        tokenizer.tokenize(logline,dataValues);
    }
    
    /**
     * @return The hour field from the log line.
     */
    public int getHour()
    {
        return dataValues[HOUR];
    }

    /**
     * @return The minute field from the log line.
     */
    public int getMinute()
    {
        return dataValues[MINUTE];
    }
    
    /**
     * Create a string representation of the data.
     * This is not necessarily identical with the
     * text of the original log line.
     * @return A string representing the data of this entry.
     */
    public String toString()
    {
        StringBuffer buffer = new StringBuffer();
        for(int value : dataValues) {
           // Prefix a leading zero on single digit numbers.
            if(value < 10) {
                buffer.append('0');
            }
            buffer.append(value);
            buffer.append(' ');
        }
        // Drop any trailing space.
        return buffer.toString().trim();
    }
    
    /**
     * Compare the date/time combination of this log entry
     * with another.
     * @param otherEntry The other entry to compare against.
     * @return A negative value if this entry comes before the other.
     *         A positive value if this entry comes after the other.
     *         Zero if the entries are the same.
     */
    public int compareTo(LogEntry otherEntry)
    {
        if(otherEntry == this) {
            // They are the same object.
            return 0;
        }
        else {
            // Compare corresponding fields.
            for(int i = 0; i < dataValues.length; i++) {
                int difference = dataValues[i] - otherEntry.dataValues[i];
                if(difference != 0) {
                    return difference;
                }
            }
            // No value is different, so the two entries represent
            // identical times.
            return 0;
        }
    }
}
```


Overlapping Code:
```
blic class LogEntry implements Comparable<LogEntry>
{
// Where the data values extracted from a single
// log line are stored.
private int[] dataValues;
// At which index in dataValues the different fields
// from a log line are stored.
private static final int YEAR = 0, MONTH = 1, DAY = 2,
HOUR = 3, MINUTE = 4;

/**
* Decompose a log line so that the individual fields
* are available.
* @param logline A single line from the log.
*/
public LogEntry(String logline)
{
// The array to store the data for a single line.
dataValues = new int[5];
// Break up the log line.
LoglineTokenizer tokenizer = new LoglineTokenizer();
tokenizer.tokenize(logline,dataValues);
}

/**
* @return The hour field from the log line.
*/
public int getHour()
{
return dataValues[HOUR];
}
/**
* @return The minute field from the log line.
*/
public int getMinute()
{
return dataValues[MINUTE];
}

/**
* Create a string representation of the data.
* This is not necessarily identical with the
* text of the original log line.
* @return A string representing the data of this entry.
*/
public String toString()
{
StringBuffer buffer = new StringBuffer();
for(int value : dataValues) {
// Prefix a leading zero on single digit numbers.
if(value < 10) {
buffer.append('0');
}
buffer.append(value);
buffer.append(' ');
}
// Drop any trailing space.
return buffer.toString().trim();
}

/**
* Compare the date/time combination of this log entry
* with another.
* @param otherEntry The other entry to compare against.
* @return A negative value if this entry comes before the other.
* A positive value if this entry comes after the other.
* Zero if the entries are the same.
*/
public int compareTo(LogEntry otherEntry)
{
if(otherEntry == this) {
// They are the same object.
return 0;
}
else {
// Compare corresponding fields.
for(int i = 0; i < dataValues.length; i++) {
int difference = dataValues[i] - other
```
<Overlap Ratio: 0.9771665801764401>

---

--- 350 --
Question ID: a85695ef802e7948648ed14b95efaf52ed62e4b2_0
Original Code:
```
class KeyFrequency<T extends Comparable<T>> implements Comparable<KeyFrequency<T>> {
    private T key;
    private int count;

    public KeyFrequency(T key, int count) {
        this.key = key;
        this.count = count;
    }

    public T getKey() {
        return key;
    }

    public int getCount() {
        return count;
    }

    @Override
    public boolean equals(Object obj) {

        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        @SuppressWarnings("unchecked")
        KeyFrequency<T> rhs = (KeyFrequency<T>) obj;

        return new EqualsBuilder().append(count, rhs.key).isEquals();
    }

    // Needs to be implemented to determine order for the TreeSet
    @Override
    public int compareTo(KeyFrequency<T> other) {
        // Ensures higher-counts (more frequent items) come first
        // the order becomes:  MOST-FREQUENT to LESS-FREQUENT in the TreeSet
        int compareTo = Integer.compare(other.count, this.count);
        if (compareTo == 0) {
            // If they are equal, we compare with the keys instead
            return other.key.compareTo(this.key);
        } else {
            return compareTo;
        }
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder().append(count).append(key).toHashCode();
    }
}
```


Overlapping Code:
```
Comparable<T>> implements Comparable<KeyFrequency<T>> {
private T key;
private int count;
public KeyFrequency(T key, int count) {
this.key = key;
this.count = count;
}
public T getKey() {
return key;
}
public int getCount() {
return count;
}
@Override
public boolean equals(Object obj) {
if (obj == null) {
return false;
}
if (obj == this) {
return true;
}
if (obj.getClass() != getClass()) {
return false;
}
@SuppressWarnings("unchecked")
KeyFrequency<T> rhs = (KeyFrequency<T>) obj;
return new EqualsBuilder().append(count, rhs.key).isEquals();
}
// Needs to be implemented to determine order for the TreeSet
@Override
public int compareTo(KeyFrequency<T> other) {
// Ensures higher-counts (more frequent items) come first
// the order becomes: MOST-FREQUENT to LESS-FREQUENT in the TreeSet
int compareTo = Integer.compare(other.count, this.count);
if (compareTo == 0) {
// If they are equal, we compare with the keys instead
return other.key.compareTo(this.key);
} else {
return compareTo;
}
}
@Override
public int hashCode() {
return new HashCodeBuilder().append(count).append(key).toHashCode();

```
<Overlap Ratio: 0.9717314487632509>

---

--- 351 --
Question ID: 295e757ccd9b473d77b2a3f31aaf1e984a636358_0
Original Code:
```
public class OldHostSupplierAdapter implements Supplier<List<Host>> {
    private final Supplier<Map<BigInteger, List<Host>>> source;
    
    public OldHostSupplierAdapter(Supplier<Map<BigInteger, List<Host>>> source) {
        this.source = source;
    }
    
    @Override
    public List<Host> get() {
        Map<BigInteger, List<Host>> tokenHostMap = source.get();
        Set<Host> hosts = Sets.newHashSet();
        for (Entry<BigInteger, List<Host>> entry : tokenHostMap.entrySet()) { 
            for (Host host : entry.getValue()) {
                if (!hosts.contains(host)) {
                    hosts.add(host);
                }
                
                String token = entry.getKey().toString();
                host.getTokenRanges().add(new TokenRangeImpl(token, token, null));
            }
        }
        return Lists.newArrayList(hosts);
    }

}
```


Overlapping Code:
```
lass OldHostSupplierAdapter implements Supplier<List<Host>> {
private final Supplier<Map<BigInteger, List<Host>>> source;

public OldHostSupplierAdapter(Supplier<Map<BigInteger, List<Host>>> source) {
this.source = source;
}

@Override
public List<Host> get() {
Map<BigInteger, List<Host>> tokenHostMap = source.get();
Set<Host> hosts = Sets.newHashSet();
for (Entry<BigInteger, List<Host>> entry : tokenHostMap.entrySet()) { 
for (Host host : entry.getValue()) {
if (!hosts.contains(host)) {
hosts.add(host);
}

String token = entry.getKey().toString();
host.getTokenRanges().add(new TokenRangeImpl(token, token, null));
}
}
return Lists.newArrayLis
```
<Overlap Ratio: 0.9687034277198212>

---

--- 352 --
Question ID: 0c9f503a5bfd09fe39a43e15dae71bfc345de3fb_0
Original Code:
```
@Repository
public class DynamicFieldRuleDao extends ACUITYDaoSupport implements IDynamicFieldRuleDao {

    @Override
    public FieldRule insertDynamicField(long mappingRuleId, String name) {
        getJdbcTemplate().update("insert into MAP_DYNAMIC_FIELD(MDFI_NAME, MDFI_MMR_ID) VALUES(?, ?)", name, mappingRuleId);
        return getDynamicFieldByMappingRuleId(mappingRuleId);
    }

    @Override
    public FieldRule getDynamicFieldByMappingRuleId(long mappingRuleId) {
        List<FieldRule> fieldRules = getJdbcTemplate().query("select * from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?", ROW_MAPPER, mappingRuleId);
        if (fieldRules.isEmpty()) {
            return null;
        }
        return fieldRules.get(0);
    }

    @Override
    public void deleteDynamicField(long mappingRuleId) {
        getJdbcTemplate().update("delete from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?", mappingRuleId);
    }

    @Override
    public List<FieldRule> selectAll() {
        return getJdbcTemplate().query("select * from MAP_DYNAMIC_FIELD", ROW_MAPPER);
    }

    private static final RowMapper<FieldRule> ROW_MAPPER = (rs, rowNum) -> {
        FieldRule fieldRule = new FieldRule();
        fieldRule.setId(rs.getLong("MDFI_ID"));
        fieldRule.setName(rs.getString("MDFI_NAME"));
        fieldRule.setType("String");
        fieldRule.setMandatory(false);
        FieldDescription fieldDescription = new FieldDescription();
        fieldDescription.setText(rs.getString("MDFI_NAME"));
        fieldDescription.setId(rs.getLong("MDFI_ID"));
        fieldRule.setDescription(fieldDescription);
        fieldRule.setEntityProcessOrder(999);
        fieldRule.setOrder(new BigDecimal(999));
        fieldRule.setDynamic(true);
        return fieldRule;
    };
}
```


Overlapping Code:
```
extends ACUITYDaoSupport implements IDynamicFieldRuleDao {
@Override
public FieldRule insertDynamicField(long mappingRuleId, String name) {
getJdbcTemplate().update("insert into MAP_DYNAMIC_FIELD(MDFI_NAME, MDFI_MMR_ID) VALUES(?, ?)", name, mappingRuleId);
return getDynamicFieldByMappingRuleId(mappingRuleId);
}
@Override
public FieldRule getDynamicFieldByMappingRuleId(long mappingRuleId) {
List<FieldRule> fieldRules = getJdbcTemplate().query("select * from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?", ROW_MAPPER, mappingRuleId);
if (fieldRules.isEmpty()) {
return null;
}
return fieldRules.get(0);
}
@Override
public void deleteDynamicField(long mappingRuleId) {
getJdbcTemplate().update("delete from MAP_DYNAMIC_FIELD where MDFI_MMR_ID = ?", mappingRuleId);
}
@Override
public List<FieldRule> selectAll() {
return getJdbcTemplate().query("select * from MAP_DYNAMIC_FIELD", ROW_MAPPER);
}
private static final RowMapper<FieldRule> ROW_MAPPER = (rs, rowNum) -> {
FieldRule fieldRule = new FieldRule();
fieldRule.setId(rs.getLong("MDFI_ID"));
fieldRule.setName(rs.getString("MDFI_NAME"));
fieldRule.setType("String");
fieldRule.setMandatory(false);
FieldDescription fieldDescription = new FieldDescription();
fieldDescription.setText(rs.getString("MDFI_NAME"));
fieldDescription.setId(rs.getLong("MDFI_ID"));
fieldRule.setDescription(fieldDescription);
fieldRule.setEntityProcessOrder(999);
fieldRule.setOrder(new BigDecimal(999));
fieldRule.setDynam
```
<Overlap Ratio: 0.9495743287491814>

---

--- 353 --
Question ID: a2f16597aa6277fc1e791fc750eb9adcb249e15f_0
Original Code:
```
public class RequestStartPledgeWar extends GameClientPacket
{
	private String _pledgeName;
	
	@Override
	protected void readImpl()
	{
		_pledgeName = readS();
	}
	
	@Override
	protected void runImpl()
	{
		final PlayerInstance player = getClient().getPlayer();
		if (player == null)
		{
			return;
		}
		
		final Clan playerClan = player.getClan();
		if (playerClan == null)
		{
			return;
		}
		
		if ((playerClan.getLevel() < 3) || (playerClan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))
		{
			player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		else if (!player.isClanLeader())
		{
			player.sendMessage("You can't declare war. You are not clan leader.");
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		
		final Clan clan = ClanTable.getInstance().getClanByName(_pledgeName);
		if (clan == null)
		{
			player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CANNOT_BE_DECLARED_AGAINST_A_CLAN_THAT_DOES_NOT_EXIST));
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		else if ((playerClan.getAllyId() == clan.getAllyId()) && (playerClan.getAllyId() != 0))
		{
			player.sendPacket(new SystemMessage(SystemMessageId.A_DECLARATION_OF_CLAN_WAR_AGAINST_AN_ALLIED_CLAN_CAN_T_BE_MADE));
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		else if ((clan.getLevel() < 3) || (clan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))
		{
			player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		else if (playerClan.isAtWarWith(clan.getClanId()))
		{
			final SystemMessage sm = new SystemMessage(SystemMessageId.YOU_HAVE_ALREADY_BEEN_AT_WAR_WITH_THE_S1_CLAN_5_DAYS_MUST_PASS_BEFORE_YOU_CAN_DECLARE_WAR_AGAIN); // msg id 628
			sm.addString(clan.getName());
			player.sendPacket(sm);
			player.sendPacket(ActionFailed.STATIC_PACKET);
			return;
		}
		
		// LOGGER.warning("RequestStartPledgeWar, leader: " + clan.getLeaderName() + " clan: "+ _clan.getName());
		
		// PlayerInstance leader = World.getInstance().getPlayer(clan.getLeaderName());
		
		// if(leader == null)
		// return;
		
		// if(leader != null && leader.isOnline() == 0)
		// {
		// player.sendMessage("Clan leader isn't online.");
		// player.sendPacket(ActionFailed.STATIC_PACKET);
		// return;
		// }
		
		// if (leader.isProcessingRequest())
		// {
		// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);
		// sm.addString(leader.getName());
		// player.sendPacket(sm);
		// return;
		// }
		
		// if (leader.isTransactionInProgress())
		// {
		// SystemMessage sm = new SystemMessage(SystemMessage.S1_IS_BUSY_TRY_LATER);
		// sm.addString(leader.getName());
		// player.sendPacket(sm);
		// return;
		// }
		
		// leader.setTransactionRequester(player);
		// player.setTransactionRequester(leader);
		// leader.sendPacket(new StartPledgeWar(_clan.getName(),player.getName()));
		ClanTable.getInstance().storeClanWars(player.getClanId(), clan.getClanId());
		for (PlayerInstance cha : World.getInstance().getAllPlayers())
		{
			if ((cha.getClan() == player.getClan()) || (cha.getClan() == clan))
			{
				cha.broadcastUserInfo();
			}
		}
	}
}
```


Overlapping Code:
```
lass RequestStartPledgeWar extends GameClientPacket
{
private String _pledgeName;

@Override
protected void readImpl()
{
_pledgeName = readS();
}

@Override
protected void runImpl()
{
final PlayerInstance player = getClient().getPlayer();
if (player == null)
{
return;
}

final Clan playerClan = player.getClan();
if (playerClan == null)
{
return;
}

if ((playerClan.getLevel() < 3) || (playerClan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))
{
player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}
else if (!player.isClanLeader())
{
player.sendMessage("You can't declare war. You are not clan leader.");
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}

final Clan clan = ClanTable.getInstance().getClanByName(_pledgeName);
if (clan == null)
{
player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CANNOT_BE_DECLARED_AGAINST_A_CLAN_THAT_DOES_NOT_EXIST));
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}
else if ((playerClan.getAllyId() == clan.getAllyId()) && (playerClan.getAllyId() != 0))
{
player.sendPacket(new SystemMessage(SystemMessageId.A_DECLARATION_OF_CLAN_WAR_AGAINST_AN_ALLIED_CLAN_CAN_T_BE_MADE));
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}
else if ((clan.getLevel() < 3) || (clan.getMembersCount() < Config.ALT_CLAN_MEMBERS_FOR_WAR))
{
player.sendPacket(new SystemMessage(SystemMessageId.A_CLAN_WAR_CAN_BE_DECLARED_ONLY_IF_THE_CLAN_IS_LEVEL_THREE_OR_ABOVE_AND_THE_NUMBER_OF_CLAN_MEMBERS_IS_FIFTEEN_OR_GREATER));
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}
else if (playerClan.isAtWarWith(clan.getClanId()))
{
final SystemMessage sm = new SystemMessage(SystemMessageId.YOU_HAVE_ALREADY_BEEN_AT_WAR_WITH_THE_S1_CLAN_5_DAYS_MUST_PASS_BEFORE_YOU_CAN_DECLARE_WAR_AGAIN); // msg id 628
sm.addString(clan.getName());
player.sendPacket(sm);
player.sendPacket(ActionFailed.STATIC_PACKET);
return;
}

// LOGGER.warning("RequestStartPledgeWar, leader: " + clan.getLeaderName() + " clan: "+ _clan.getName());

// PlayerInstance leader = World.getInstance().getPlayer(clan.getLeaderName());

// if(leader == null)
// return;

// if(leader != null && leader.isOnline() == 0)
// {
// play
```
<Overlap Ratio: 0.9957246686618213>

---

--- 354 --
Question ID: 3ac72c171a9ed59bb7665f2c369f7bf8ea09d788_0
Original Code:
```
public class Solution {
    public static void main(String[] args) {
        System.out.println(find(23));
        System.out.println(find(12));
    }

    public static boolean find(int num) {
        int slow = num, fast = num;
        do {
            slow = findSquareSum(slow); // move one step
            fast = findSquareSum(findSquareSum(fast)); // move two steps
        } while (slow != fast); // found the cycle

        return slow == 1; // see if the cycle is stuck on the number '1'
    }

    private static int findSquareSum(int num) {
        int sum = 0, digit;
        while (num > 0) {
            digit = num % 10;
            sum += digit * digit;
            num /= 10;
        }
        return sum;
    }
}
```


Overlapping Code:
```
public class Solution {
public static void main(String[] args) {
System.out.println(find(23));
System.out.println(find(12));
}
public static boolean find(int num) {
int slow = num, fast = num;
do {
slow = findSquareSum(slow); // move one step
fast = findSquareSum(findSquareSum(fast)); // move two steps
} while (slow != fast); // found the cycle
return slow == 1; // see if the cycle is stuck on the number '1'
}
private static int findSquareSum(int num) {
int sum = 0, digit;
while (num > 0) {
digit = num % 10;
sum += digit * digit;
num /= 10;
}
r
```
<Overlap Ratio: 0.975177304964539>

---

--- 355 --
Question ID: 3bc70e63acbe1c19bb491b824e4d6d5ab3c3b8f7_0
Original Code:
```
public class RawCustomResourceOperationsImpl extends OperationSupport implements Nameable<RawCustomResourceOperationsImpl>,
  Namespaceable<RawCustomResourceOperationsImpl>,
  AnyNamespaceable<RawCustomResourceOperationsImpl>,
  Listable<Map<String, Object>>,
  Gettable<Map<String, Object>>,
  GracePeriodConfigurable<RawCustomResourceOperationsImpl>,
  PropagationPolicyConfigurable<RawCustomResourceOperationsImpl>,
  DryRunable<RawCustomResourceOperationsImpl>,
  Deletable {

  private static final String METADATA = "metadata";
  private static final String RESOURCE_VERSION = "resourceVersion";
  private static final String STATUS_SUBRESOURCE_ENDPOINT = "/status";
  private final CustomResourceDefinitionContext customResourceDefinition;
  private final ObjectMapper objectMapper;
  private final ListOptions listOptions;
  private final long gracePeriodInSeconds;
  private final String deletionPropagation;
  private final boolean cascading;

  private enum HttpCallMethod { GET, POST, PUT, PATCH, DELETE }

  private RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext crdContext, String namespace, String name, long gracePeriodInSeconds, boolean cascading, String deletionPropagation, ListOptions listOptions, boolean dryRun) {
    super(client, config);
    this.customResourceDefinition = crdContext;
    this.objectMapper = PatchUtils.patchMapper();
    this.namespace = namespace;
    this.name = name;
    this.gracePeriodInSeconds = gracePeriodInSeconds;
    this.cascading = cascading;
    this.deletionPropagation = deletionPropagation;
    this.listOptions = listOptions;
    this.dryRun = dryRun;
  }

  public RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext customResourceDefinition) {
    this(client, config, customResourceDefinition, null, null, 0, false, DeletionPropagation.BACKGROUND.toString(), null, false);
  }

  @Override
  public RawCustomResourceOperationsImpl withName(String name) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);
  }

  @Override
  public RawCustomResourceOperationsImpl inNamespace(String namespace) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);
  }

  @Override
  public RawCustomResourceOperationsImpl inAnyNamespace() {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);
  }

  @Override
  public RawCustomResourceOperationsImpl withGracePeriod(long gracePeriodSeconds) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodSeconds, cascading, deletionPropagation, listOptions, dryRun);
  }

  @Override
  public RawCustomResourceOperationsImpl withPropagationPolicy(DeletionPropagation propagationPolicy) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy.toString(), listOptions, dryRun);
  }

  @Override
  public RawCustomResourceOperationsImpl dryRun(boolean isDryRun) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, isDryRun);
  }

  /**
   * Load a custom resource object from an inputstream into a HashMap
   *
   * @param fileInputStream file input stream
   * @return custom resource as HashMap
   * @throws IOException exception in case any read operation fails.
   */
  public Map<String, Object> load(InputStream fileInputStream) throws IOException {
    return convertJsonOrYamlStringToMap(IOHelpers.readFully(fileInputStream));
  }

  /**
   * Load a custom resource object from a JSON string into a HashMap
   *
   * @param objectAsJsonString object as JSON string
   * @return custom resource as HashMap
   * @throws IOException exception in case any problem in reading json.
   */
  public Map<String, Object> load(String objectAsJsonString) throws IOException {
    return convertJsonOrYamlStringToMap(objectAsJsonString);
  }

  /**
   * Create a custom resource which is a non-namespaced object.
   *
   * @param objectAsString object as JSON string
   * @return Object as HashMap
   * @throws IOException exception in case of any network/read problems
   */
  public Map<String, Object> create(String objectAsString) throws IOException {
    return validateAndSubmitRequest(objectAsString, HttpCallMethod.POST);
  }

  /**
   * Create a custom resource which is non-namespaced.
   *
   * @param object object a HashMap
   * @return Object as HashMap
   * @throws IOException in case of problems while reading HashMap
   */
  public Map<String, Object> create(Map<String, Object> object) throws IOException {
    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.POST);
  }

  /**
   * Create a custom resource which is a namespaced object.
   *
   * @param namespace namespace in which we want object to be created.
   * @param objectAsString Object as JSON string
   * @return Object as HashMap
   * @throws IOException in case of problems while reading JSON object
   */
  public Map<String, Object> create(String namespace, String objectAsString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsString);
  }

  /**
   * Create a custom resource which is non-namespaced object.
   *
   * @param objectAsStream object as a file input stream
   * @return Object as HashMap
   * @throws IOException in case of problems while reading file
   */
  public Map<String, Object> create(InputStream objectAsStream) throws IOException {
    return validateAndSubmitRequest(IOHelpers.readFully(objectAsStream), HttpCallMethod.POST);
  }

  /**
   * Create a custom resource which is a namespaced object.
   *
   * @param namespace namespace in which we want object to be created
   * @param objectAsStream object as file input stream
   * @return Object as HashMap
   * @throws IOException in case of problems while reading file
   */
  public Map<String, Object> create(String namespace, InputStream objectAsStream) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(objectAsStream);
  }

  /**
   * Create a custom resource which is a namespaced object.
   *
   * @param namespace namespace in which we want object to be created.
   * @param object object as a HashMap
   * @return Object as HashMap
   * @throws IOException in case of problems faced while serializing HashMap
   */
  public Map<String, Object> create(String namespace, Map<String, Object> object) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).create(object);
  }

  /**
   *
   * Create or replace a custom resource which is a non-namespaced object.
   *
   * @param objectAsString object as JSON string
   * @return Object as HashMap
   * @throws IOException in case of network/serializiation failures or failures from Kuberntes API
   */
  public Map<String, Object> createOrReplace(String objectAsString) throws IOException {
    return createOrReplaceObject(load(objectAsString));
  }

  /**
   * Create or replace a custom resource which is a non-namespced object.
   *
   * @param customResourceObject object as HashMap
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> createOrReplace(Map<String, Object> customResourceObject) throws IOException {
    return createOrReplaceObject(customResourceObject);
  }

  /**
   * Create or replace a custom resource which is non-namespaced object.
   *
   * @param inputStream object as file input stream
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> createOrReplace(InputStream inputStream) throws IOException {
    return createOrReplaceObject(load(inputStream));
  }

  /**
   * Create or replace a custom resource which is namespaced object.
   *
   * @param namespace desired namespace
   * @param objectAsString object as JSON String
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> createOrReplace(String namespace, String objectAsString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsString);
  }

  /**
   * Create or replace a custom resource which is namespaced object.
   *
   * @param namespace desired namespace
   * @param customResourceObject object as HashMap
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> createOrReplace(String namespace, Map<String, Object> customResourceObject) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(customResourceObject);
  }

  /**
   * Create or replace a custom resource which is namespaced object.
   *
   * @param namespace desired namespace
   * @param objectAsStream object as file input stream
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> createOrReplace(String namespace, InputStream objectAsStream) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).createOrReplace(objectAsStream);
  }

  private Map<String, Object> replace(String namespace, String name, Map<String, Object> object) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);
  }

  private Map<String, Object> replace(String name, Map<String, Object> object) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).replace(object);
  }

  private Map<String, Object> replace(Map<String, Object> object) throws IOException {
    return validateAndSubmitRequest(objectMapper.writeValueAsString(object), HttpCallMethod.PUT);
  }

  /**
   * Edit a custom resource object which is a non-namespaced object.
   *
   * @param name name of the custom resource
   * @param object new object as a HashMap
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(String name, Map<String, Object> object) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);
  }

  /**
   * Edit a custom resource object which is a non-namespaced object.
   *
   * @param name name of the custom resource
   * @param objectAsString new object as a JSON String
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(String name, String objectAsString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);
  }

  /**
   * Edit a custom resource object which is a namespaced object.
   *
   * @param namespace desired namespace
   * @param name name of the custom resource
   * @param object new object as a HashMap
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(String namespace, String name, Map<String, Object> object) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);
  }

  /**
   * Edit a custom resource object which is a namespaced object.
   *
   * @param namespace desired namespace
   * @param name name of the custom resource
   * @param objectAsString new object as a JSON string
   * @return Object as HashMap
   * @throws IOException in case of network/serialization failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(String namespace, String name, String objectAsString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(objectAsString);
  }

  /**
   * Edit a custom resource object.
   *
   * @param objectAsString new object as JSON string
   * @return Object as HashMap
   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(String objectAsString) throws IOException {
    Map<String, Object> object = convertJsonOrYamlStringToMap(objectAsString);
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).edit(object);
  }

  /**
   * Edit a custom resource object.
   *
   * @param object new object as Map
   * @return Object as HashMap
   * @throws IOException in case of network/serializatino failures or failures from Kubernetes API
   */
  public Map<String, Object> edit(Map<String, Object> object) throws IOException {
    String objectAsString = getPatchDiff(namespace, name, object);
    return validateAndSubmitRequest(objectAsString, HttpCallMethod.PATCH);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param name name of custom resource
   * @param objectAsMap custom resource as a HashMap
   * @return updated CustomResource as HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String name, Map<String, Object> objectAsMap) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param name name of CustomResource
   * @param objectAsJsonString CustomResource as a JSON string
   * @return updated CustomResource as a HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String name, String objectAsJsonString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param namespace namespace of CustomResource
   * @param name name of CustomResource
   * @param objectAsMap CustomResource as a HashMap
   * @return updated CustomResource as a HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String namespace, String name, Map<String, Object> objectAsMap) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsMap);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param name name of CustomResource
   * @param objectAsStream stream pointing to CustomResource
   * @return updated CustomResource as a HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String name, InputStream objectAsStream) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param namespace namespace of CustomResource
   * @param name name of CustomResource
   * @param objectAsStream CustomResource object as a stream
   * @return updated CustomResource as a HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String namespace, String name, InputStream objectAsStream) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsStream);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param namespace namespace of CustomResource
   * @param name name of CustomResource
   * @param objectAsJsonString CustomResource object as a JSON string
   * @return updated CustomResource as a HashMap
   * @throws IOException in case any failure to parse Map
   */
  public Map<String, Object> updateStatus(String namespace, String name, String objectAsJsonString) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).updateStatus(objectAsJsonString);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param objectAsJsonString CustomResource object as a JSON string
   * @return updated CustomResource as HashMap
   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API
   */
  public Map<String, Object> updateStatus(String objectAsJsonString) throws IOException {
    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectAsJsonString, HttpCallMethod.PUT);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param objectAsMap CustomResource object as a HashMap
   * @return updated CustomResource as HashMap
   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API
   */
  public Map<String, Object> updateStatus(Map<String, Object> objectAsMap) throws IOException {
    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, objectMapper.writeValueAsString(objectAsMap), HttpCallMethod.PUT);
  }

  /**
   * Update status related to a CustomResource, this method does a PUT request on /status endpoint related
   * to the CustomResource
   *
   * @param objectAsInputStream CustomResource object as a InputStream
   * @return updated CustomResource as HashMap
   * @throws IOException in case any failures to parse provided object or failure from Kubernetes API
   */
  public Map<String, Object> updateStatus(InputStream objectAsInputStream) throws IOException {
    return validateAndSubmitRequest(fetchUrl(null) + STATUS_SUBRESOURCE_ENDPOINT, IOHelpers.readFully(objectAsInputStream), HttpCallMethod.PUT);
  }

  @Override
  public Map<String, Object> get() {
    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);
  }

  /**
   * Get a custom resource from the cluster which is non-namespaced.
   *
   * @param name name of custom resource
   * @return Object as HashMap
   */
  public Map<String, Object> get(String name) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, null, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();
  }

  /**
   * Get a custom resource from the cluster which is namespaced.
   *
   * @param namespace desired namespace
   * @param name name of custom resource
   * @return Object as HashMap
   */
  public Map<String, Object> get(String namespace, String name) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).get();
  }

  /**
   * List all custom resources in all namespaces
   *
   * @return list of custom resources as HashMap
   */
  public Map<String, Object> list() {
    return makeCall(fetchUrl(null), null, HttpCallMethod.GET);
  }

  @Override
  public Map<String, Object> list(Integer limitVal, String continueVal) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder()
      .withLimit(limitVal.longValue())
      .withContinue(continueVal)
      .build(), dryRun).list();
  }

  @Override
  public Map<String, Object> list(ListOptions listOptions) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();
  }

  /**
   * List all custom resources in a specific namespace
   *
   * @param namespace desired namespace
   * @return list of custom resources as HashMap
   */
  public Map<String, Object> list(String namespace) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).list();
  }

  /**
   * List all custom resources in a specific namespace with some labels
   *
   * @param namespace desired namespace
   * @param labels labels as a HashMap
   * @return list of custom resources as HashMap
   */
  public Map<String, Object> list(String namespace, Map<String, String> labels) {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, null,
      gracePeriodInSeconds, cascading, deletionPropagation, new ListOptionsBuilder().withLabelSelector(getLabelsQueryParam(labels)).build(), dryRun).list();
  }

  /**
   * Delete all Namespaced Scoped Custom Resources in a specified namespace
   * <b>OR</b>
   * Delete a Cluster Scoped Custom Resource with specified name
   *
   * <p>
   * Note: This method behaves differently based on the scope of CRD:
   *
   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is
   * specified as parameter.
   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is
   * specified as parameter
   * </p>
   *
   * @param namespaceOrName desired namespace(if CRD is Namespaced) or name(If CRD is Cluster)
   * @return deleted objects as HashMap
   */
  public boolean delete(String namespaceOrName) {
    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, null);
  }

  /**
   * Delete all Namespaced Scoped Custom Resources in a specified namespace
   * <b>OR</b>
   * Delete a Cluster Scoped Custom Resource with specified name
   *
   * <p>
   * Note: This method behaves differently based on the scope of CRD:
   *
   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is
   * specified as parameter.
   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is
   * specified as parameter
   * </p>
   *
   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)
   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the "orphan"
   *                   finalizer will be added to/removed from the object's finalizers list.
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException in case of any network/parsing exception
   */
  public boolean delete(String namespaceOrName, boolean cascading) throws IOException {
    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));
  }

  /**
   * Delete all Namespaced Scoped Custom Resources in a specified namespace
   * <b>OR</b>
   * Delete a Cluster Scoped Custom Resource with specified name
   *
   * <p>
   * Note: This method behaves differently based on the scope of CRD:
   *
   * If specified CRD is of Namespaced scope, this method would delete all Custom Resources in namespace which is
   * specified as parameter.
   * If specified CRD is of Cluster scope, this method would delete a Custom Resource matching the name which is
   * specified as parameter
   * </p>
   *
   * @param namespaceOrName desired namespace(If CRD is Namespaced) or name(If CRD is Cluster)
   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.
   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException in case of any network/object parse problems
   */
  public boolean delete(String namespaceOrName, DeleteOptions deleteOptions) throws IOException {
    return pickNamespaceOrNameBasedOnScopeAndDelete(namespaceOrName, objectMapper.writeValueAsString(deleteOptions));
  }

  /**
   * Delete a custom resource in a specific namespace
   *
   * @param namespace desired namespace
   * @param name custom resource's name
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException in case of any network/object parse problems
   */
  public boolean delete(String namespace, String name) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).delete();
  }

  /**
   * Delete a custom resource in a specific namespace
   *
   * @param namespace required namespace
   * @param name required name of custom resource
   * @param cascading whether dependent object need to be orphaned or not.  If true/false, the "orphan"
   *                   finalizer will be added to/removed from the object's finalizers list.
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException exception related to network/object parsing
   */
  public boolean delete(String namespace, String name, boolean cascading) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, null, listOptions, dryRun).delete();
  }

  /**
   * Delete a custom resource in a specific namespace
   *
   * @param namespace required namespace
   * @param name required name of custom resource
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents
   *                            may be set, but not both. The default policy is decided by the existing finalizer set in
   *                            the metadata.finalizers and the resource-specific default policy.
   *                            Acceptable values are:
   *                            'Orphan' - orphan the dependents;
   *                            'Background' - allow the garbage collector to delete the dependents in the background;
   *                            'Foreground' - a cascading policy that deletes all dependents in the foreground.
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException in case of network/object parse exception
   */
  public boolean delete(String namespace, String name, String propagationPolicy) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, propagationPolicy, listOptions, dryRun).delete();
  }

  /**
   * Delete a custom resource in a specific namespace
   *
   * @param namespace required namespace
   * @param name name of custom resource
   * @param deleteOptions object provided by Kubernetes API for more fine grained control over deletion.
   *                       For more information please see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#deleteoptions-v1-meta
   * @return a boolean value whether item was deleted or item didn't exist in server
   * @throws IOException in case of any network/object parse exception
   */
  public boolean delete(String namespace, String name, DeleteOptions deleteOptions) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name,
      gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun).handleDelete(objectMapper.writeValueAsString(deleteOptions));
  }

  @Override
  public Boolean delete() {
    try {
      return handleDelete(objectMapper.writeValueAsString(fetchDeleteOptions(cascading, null)));
    } catch (JsonProcessingException jpe) {
      throw KubernetesClientException.launderThrowable(jpe);
    }
  }

  /**
   * Watch custom resources in a specific namespace. Here Watcher is provided
   * for string type only. User has to deserialize object itself.
   *
   * @param namespace namespace to watch
   * @param watcher watcher object which reports updates with object
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(String namespace, Watcher<String> watcher) throws IOException {
    return watch(namespace, null, null, new ListOptionsBuilder().build(), watcher);
  }

  /**
   * Watch a custom resource in a specific namespace with some resourceVersion. Here
   * watcher is provided from string type only. User has to deserialize object itself.
   *
   * @param namespace namespace to watch
   * @param resourceVersion resource version since when to watch
   * @param watcher watcher object which reports updates
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(String namespace, String resourceVersion, Watcher<String> watcher) throws IOException {
    return watch(namespace, null, null, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);
  }

  /**
   * Watch a custom resource in a specific namespace with some resourceVersion. Here
   * watcher is provided from string type only. User has to deserialize object itself.
   *
   * @param namespace namespace to watch
   * @param options {@link ListOptions} list options for watching
   * @param watcher watcher object which reports updates
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(String namespace, ListOptions options, Watcher<String> watcher) throws IOException {
    return watch(namespace, null, null, options, watcher);
  }

  /**
   * Watchers custom resources across all namespaces. Here watcher is provided
   * for string type only. User has to deserialize object itself.
   *
   * @param watcher watcher object which reports events
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(Watcher<String> watcher) throws IOException {
    return watch(null, null, null, new ListOptionsBuilder().build(), watcher);
  }

  /**
   * Watch custom resources in the parameters specified.
   *
   * Most of the parameters except watcher are optional, they would be
   * skipped if passed null. Here watcher is provided for string type
   * only. User has to deserialize the object itself.
   *
   * @param namespace namespace to watch (optional
   * @param name name of custom resource (optional)
   * @param labels HashMap containing labels (optional)
   * @param resourceVersion resource version to start watch from
   * @param watcher watcher object which reports events
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(String namespace, String name, Map<String, String> labels, String resourceVersion, Watcher<String> watcher) throws IOException {
    return watch(namespace, name, labels, new ListOptionsBuilder().withResourceVersion(resourceVersion).build(), watcher);
  }

  /**
   * Watch custom resources in the parameters specified.
   *
   * Most of the parameters except watcher are optional, they would be
   * skipped if passed null. Here watcher is provided for string type
   * only. User has to deserialize the object itself.
   *
   * @param namespace namespace to watch (optional
   * @param name name of custom resource (optional)
   * @param labels HashMap containing labels (optional)
   * @param options {@link ListOptions} list options for watch
   * @param watcher watcher object which reports events
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(String namespace, String name, Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition,
      namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)
      .watch(labels, options, watcher);
  }

  /**
   * Watch custom resources in the parameters specified.
   *
   * Most of the parameters except watcher are optional, they would be
   * skipped if passed null. Here watcher is provided for string type
   * only. User has to deserialize the object itself.
   *
   * @param labels HashMap containing labels (optional)
   * @param options {@link ListOptions} list options for watch
   * @param watcher watcher object which reports events
   * @return watch object for watching resource
   * @throws IOException in case of network error
   */
  public Watch watch(Map<String, String> labels, ListOptions options, Watcher<String> watcher) throws IOException {
    if (options == null) {
      options = new ListOptions();
    }
    options.setWatch(true);
    HttpUrl.Builder watchUrlBuilder = fetchWatchUrl(labels, options);

    OkHttpClient.Builder clonedClientBuilder = client.newBuilder();
    clonedClientBuilder.readTimeout(getConfig() != null ?
      getConfig().getWebsocketTimeout() : Config.DEFAULT_WEBSOCKET_TIMEOUT, TimeUnit.MILLISECONDS);
    clonedClientBuilder.pingInterval(getConfig() != null ?
      getConfig().getWebsocketPingInterval() : Config.DEFAULT_WEBSOCKET_PING_INTERVAL, TimeUnit.MILLISECONDS);

    OkHttpClient clonedOkHttpClient = clonedClientBuilder.build();
    WatcherToggle<String> watcherToggle = new WatcherToggle<>(watcher, true);
    RawWatchConnectionManager watch = null;
    try {
      watch = new RawWatchConnectionManager(
        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,
        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,
        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,
        5);
      watch.waitUntilReady();
      return watch;
    } catch (KubernetesClientException ke) {

      if (ke.getCode() != 200) {
        if(watch != null){
          //release the watch
          watch.close();
        }

        throw ke;
      }

      if(watch != null){
        //release the watch after disabling the watcher (to avoid premature call to onClose)
        watcherToggle.disable();
        watch.close();
      }

      // If the HTTP return code is 200, we retry the watch again using a persistent hanging
      // HTTP GET. This is meant to handle cases like kubectl local proxy which does not support
      // websockets. Issue: https://github.com/kubernetes/kubernetes/issues/25126
      return new RawWatchConnectionManager(
        clonedOkHttpClient, watchUrlBuilder, options, objectMapper, watcher,
        getConfig() != null ? getConfig().getWatchReconnectLimit() : -1,
        getConfig() != null ? getConfig().getWatchReconnectInterval() : 1000,
        5);
    }
  }

  private Map<String, Object> createOrReplaceObject(Map<String, Object> objectAsMap) throws IOException {
    Map<String, Object> metadata = (Map<String, Object>) objectAsMap.get(METADATA);
    if (metadata == null) {
      throw KubernetesClientException.launderThrowable(new IllegalStateException("Invalid object provided -- metadata is required."));
    }

    Map<String, Object> ret;

    // can't include resourceVersion in create calls
    String originalResourceVersion = (String) metadata.get(RESOURCE_VERSION);
    metadata.remove(RESOURCE_VERSION);

    try {
      if(this.namespace != null) {
        ret = create(this.namespace, objectAsMap);
      } else {
        ret = create(objectAsMap);
      }
    } catch (KubernetesClientException exception) {
      if (exception.getCode() != HttpURLConnection.HTTP_CONFLICT) {
        throw exception;
      }

      try {
        String nameFromObject = (String) metadata.get("name");
        // re-add for edit call
        if (originalResourceVersion != null) {
          metadata.put(RESOURCE_VERSION, originalResourceVersion);
        } else {
          // we get resourceVersion from existing object
          // possible race condition if object has been deleted since the HTTP_CONFLICT exception?
          Map<String, Object> currentObjectAsMap = this.namespace != null ?
            get(namespace, nameFromObject) : get(nameFromObject);
          Map<String, Object> currentMetadata = (Map<String, Object>) currentObjectAsMap.get(METADATA);
          metadata.put(RESOURCE_VERSION, currentMetadata.get(RESOURCE_VERSION));
        }
        ret = this.namespace != null ?
          replace(this.namespace, nameFromObject, objectAsMap) : replace(nameFromObject, objectAsMap);
      } catch (NullPointerException nullPointerException) {
        throw KubernetesClientException.launderThrowable(new IllegalStateException("Invalid object provided -- metadata.name is required."));
      }
    }
    return ret;
  }

  /**
   * Converts yaml/json object as string to a HashMap.
   * This method checks whether
   *
   * @param objectAsString JSON or Yaml object as plain string
   * @return object being deserialized to a HashMap
   * @throws IOException in case of any parsing error
   */
  private Map<String, Object> convertJsonOrYamlStringToMap(String objectAsString) throws IOException {
    HashMap<String, Object> retVal = null;
    if (IOHelpers.isJSONValid(objectAsString)) {
      retVal =  objectMapper.readValue(objectAsString, HashMap.class);
    } else {
      retVal = objectMapper.readValue(IOHelpers.convertYamlToJson(objectAsString), HashMap.class);
    }
    return retVal;
  }

  protected HttpUrl.Builder fetchWatchUrl(Map<String, String> labels, ListOptions options) throws MalformedURLException {
    String configuredName = this.name;
    // Get Url without resource name configured
    this.name = null;
    String resourceUrl = fetchUrl(labels);
    if (resourceUrl.endsWith("/")) {
      resourceUrl = resourceUrl.substring(0, resourceUrl.length() - 1);
    }
    URL url = new URL(resourceUrl);
    HttpUrl.Builder httpUrlBuilder = HttpUrl.get(url).newBuilder();

    if (configuredName != null) {
      httpUrlBuilder.addQueryParameter("fieldSelector", "metadata.name=" + configuredName);
    }

    HttpClientUtils.appendListOptionParams(httpUrlBuilder, options);
    return httpUrlBuilder;
  }

  private String fetchUrl(Map<String, String> labels) {
    if (config.getMasterUrl() == null) {
      return null;
    }

    HttpUrl.Builder urlBuilder = HttpUrl.get(getNamespacedUrl(namespace, name)).newBuilder();
    if (labels != null) {
      urlBuilder.addQueryParameter("labelSelector", getLabelsQueryParam(labels));
    }
    if (listOptions != null) {
      urlBuilder = HttpClientUtils.appendListOptionParams(urlBuilder, listOptions);
    }
    if (dryRun) {
      urlBuilder.addQueryParameter("dryRun", "All");
    }
    return urlBuilder.toString();
  }

  private String getNamespacedUrl(String namespace, String name) {
    StringBuilder urlBuilder = new StringBuilder(config.getMasterUrl());

    urlBuilder.append(config.getMasterUrl().endsWith("/") ? "" : "/");

    if (Utils.isNotNullOrEmpty(customResourceDefinition.getGroup())) {
      urlBuilder.append("apis/");
      urlBuilder.append(customResourceDefinition.getGroup())
        .append("/");
    } else {
      urlBuilder.append("api/");
    }
    urlBuilder.append(customResourceDefinition.getVersion())
      .append("/");

    if(customResourceDefinition.getScope().equals("Namespaced") && namespace != null) {
      urlBuilder.append("namespaces/").append(namespace).append("/");
    }
    urlBuilder.append(customResourceDefinition.getPlural());
    if (name != null) {
      urlBuilder.append("/").append(name);
    }
    return urlBuilder.toString();
  }

  private String getLabelsQueryParam(Map<String, String> labels) {
    StringBuilder labelQueryBuilder = new StringBuilder();
    for(Map.Entry<String, String> entry : labels.entrySet()) {
      if(labelQueryBuilder.length() > 0) {
        labelQueryBuilder.append(",");
      }
      labelQueryBuilder.append(entry.getKey()).append("=").append(entry.getValue());
    }
    return labelQueryBuilder.toString();
  }

  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod) {
    return makeCall(url, body, callMethod, true);
  }

  private Map<String, Object> makeCall(String url, String body, HttpCallMethod callMethod, boolean shouldRequestFailure) {
    Request request = (body == null) ? getRequest(url, callMethod) : getRequest(url, body, callMethod);
    try (Response response = client.newCall(request).execute()) {
      if (response.isSuccessful()) {
        String respBody = response.body().string();
        if(Utils.isNullOrEmpty(respBody))
          return new HashMap<>();
        else
          return objectMapper.readValue(respBody, HashMap.class);
      } else {
        return handleFailure(request, response, shouldRequestFailure);
      }
    } catch(Exception e) {
      throw KubernetesClientException.launderThrowable(e);
    }
  }

  private Map<String, Object> handleFailure(Request request, Response response, boolean shouldRequestFailure) throws IOException {
    if (shouldRequestFailure) {
      throw requestFailure(request, createStatus(response));
    }
    return objectMapper.readValue(response.body().string(), HashMap.class);
  }

  private boolean handleDelete(String requestBody) {
    Map<String, Object> response = makeCall(fetchUrl(null), requestBody, HttpCallMethod.DELETE, false);

    // In most cases Status object is sent on deletion, but when deprecated DeleteOptions.orphanDependents
    // is used; object which is being deleted is sent
    if (!response.isEmpty() && response.get("kind").toString().equals("Status")) {
      return response.get("status").toString().equals("Success");
    }
    return true;
  }

  private Map<String, Object> validateAndSubmitRequest(String objectAsString, HttpCallMethod httpCallMethod) throws IOException {
    return validateAndSubmitRequest(fetchUrl(null), objectAsString, httpCallMethod);
  }

  private Map<String, Object> validateAndSubmitRequest(String resourceUrl, String objectAsString, HttpCallMethod httpCallMethod) throws IOException {
    if (IOHelpers.isJSONValid(objectAsString)) {
      return makeCall(resourceUrl, objectAsString, httpCallMethod);
    } else {
      return makeCall(resourceUrl, IOHelpers.convertYamlToJson(objectAsString), httpCallMethod);
    }
  }

  private Request getRequest(String url, HttpCallMethod httpCallMethod) {
    Request.Builder requestBuilder = new Request.Builder();
    switch(httpCallMethod) {
      case GET:
        requestBuilder.get().url(url);
        break;
      case DELETE:
        requestBuilder.delete().url(url);
        break;
    }

    return requestBuilder.build();
  }

  private Request getRequest(String url, String body, HttpCallMethod httpCallMethod) {
    Request.Builder requestBuilder = new Request.Builder();
    RequestBody requestBody = RequestBody.create(MediaType.parse("application/json"), body);
    switch(httpCallMethod) {
      case DELETE:
        return requestBuilder.delete(requestBody).url(url).build();
      case POST:
        return requestBuilder.post(requestBody).url(url).build();
      case PUT:
        return requestBuilder.put(requestBody).url(url).build();
      case PATCH:
        return requestBuilder.patch(RequestBody.create(JSON_PATCH, body)).url(url).build();
    }
    return requestBuilder.build();
  }

  private String getPatchDiff(String namespace, String customResourceName, Map<String, Object> customResource) throws IOException {
    Map<String, Object> oldObject = get(namespace, customResourceName);

    // Exclude changes to the status
    oldObject.put("status", null);
    customResource.put("status", null);

    JsonNode newone = JsonDiff.asJson(PatchUtils.patchMapper().valueToTree(oldObject), PatchUtils.patchMapper().valueToTree(customResource));

    return objectMapper.writeValueAsString(newone);
  }

  private DeleteOptions fetchDeleteOptions(boolean cascading, String propagationPolicy) {
    DeleteOptionsBuilder deleteOptionsBuilder = new DeleteOptionsBuilder();
    String resolvedPropagationPolicy = resolvePropagationPolicy(propagationPolicy);
    if (resolvedPropagationPolicy != null) {
      deleteOptionsBuilder.withPropagationPolicy(resolvedPropagationPolicy);
    } else {
      deleteOptionsBuilder.withOrphanDependents(!cascading);
    }
    if (this.gracePeriodInSeconds > 0) {
      deleteOptionsBuilder.withGracePeriodSeconds(this.gracePeriodInSeconds);
    }
    if (this.dryRun) {
      deleteOptionsBuilder.withDryRun(Collections.singletonList("All"));
    }
    return deleteOptionsBuilder.build();
  }

  private String resolvePropagationPolicy(String propagationPolicyProvided) {
    if (propagationPolicyProvided != null) {
      return propagationPolicyProvided;
    } else if (this.deletionPropagation != null) {
      return this.deletionPropagation;
    }
    return null;
  }

  private boolean pickNamespaceOrNameBasedOnScopeAndDelete(String namespaceOrName, String deleteOptionsAsString) {
    String operationNamespace = null;
    String operationName = null;
    if (customResourceDefinition.getScope().equals("Namespaced")) {
      operationNamespace = namespaceOrName;
    } else {
      operationName = namespaceOrName;
    }
    return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, operationNamespace, operationName, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun)
      .handleDelete(deleteOptionsAsString);
  }
}
```


Overlapping Code:
```
RawCustomResourceOperationsImpl extends OperationSupport implements Nameable<RawCustomResourceOperationsImpl>,
Namespaceable<RawCustomResourceOperationsImpl>,
AnyNamespaceable<RawCustomResourceOperationsImpl>,
Listable<Map<String, Object>>,
Gettable<Map<String, Object>>,
GracePeriodConfigurable<RawCustomResourceOperationsImpl>,
PropagationPolicyConfigurable<RawCustomResourceOperationsImpl>,
DryRunable<RawCustomResourceOperationsImpl>,
Deletable {
private static final String METADATA = "metadata";
private static final String RESOURCE_VERSION = "resourceVersion";
private static final String STATUS_SUBRESOURCE_ENDPOINT = "/status";
private final CustomResourceDefinitionContext customResourceDefinition;
private final ObjectMapper objectMapper;
private final ListOptions listOptions;
private final long gracePeriodInSeconds;
private final String deletionPropagation;
private final boolean cascading;
private enum HttpCallMethod { GET, POST, PUT, PATCH, DELETE }
private RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext crdContext, String namespace, String name, long gracePeriodInSeconds, boolean cascading, String deletionPropagation, ListOptions listOptions, boolean dryRun) {
super(client, config);
this.customResourceDefinition = crdContext;
this.objectMapper = PatchUtils.patchMapper();
this.namespace = namespace;
this.name = name;
this.gracePeriodInSeconds = gracePeriodInSeconds;
this.cascading = cascading;
this.deletionPropagation = deletionPropagation;
this.listOptions = listOptions;
this.dryRun = dryRun;
}
public RawCustomResourceOperationsImpl(OkHttpClient client, Config config, CustomResourceDefinitionContext customResourceDefinition) {
this(client, config, customResourceDefinition, null, null, 0, false, DeletionPropagation.BACKGROUND.toString(), null, false);
}
@Override
public RawCustomResourceOperationsImpl withName(String name) {
return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);
}
@Override
public RawCustomResourceOperationsImpl inNamespace(String namespace) {
return new RawCustomResourceOperationsImpl(client, config, customResourceDefinition, namespace, name, gracePeriodInSeconds, cascading, deletionPropagation, listOptions, dryRun);
}
@Override
pub
```
<Overlap Ratio: 0.9941176470588236>

---

--- 356 --
Question ID: 4f553d5c585d4988755d56c55275e6546d2f4137_0
Original Code:
```
public class RtpSource {
    /**
     * RFC 3550: The dropout parameter MAX_DROPOUT should be a small fraction of the 16-bit sequence
     * number space to give a reasonable probability that new sequence numbers after a restart will
     * not fall in the acceptable range for sequence numbers from before the restart.
     */
    private static final int MAX_DROPOUT = 3000;

    /**
     * RFC 3550: the sequence number is considered valid if it is no more than MAX_DROPOUT ahead of
     * maxSeq nor more than MAX_MISORDER behind
     */
    private static final int MAX_MISORDER = 100;

    /**
     * RFC 3550: RTP sequence number module
     */
    private static final int RTP_SEQ_MOD = (1 << 16);

    /**
     * CNAME value
     */
    private static String sCname = "anonymous@127.0.0.1";

    /**
     * Source is not valid until MIN_SEQUENTIAL packets with sequential sequence numbers have been
     * received.
     */
    private static int MIN_SEQUENCIAL = 0;

    /**
     * Is this source and ActiveSender.
     */
    public boolean activeSender;

    /**
     * Source description
     */
    public int ssrc;

    /**
     * Highest Sequence number received from this source
     */
    private int maxSeq;

    /**
     * Keep track of the wrapping around of RTP sequence numbers, since RTP Seq No. are only 16 bits
     */
    private int cycles;

    /**
     * Sequence Number of the first RTP packet received from this source
     */
    private int baseSeq;

    /**
     * Last 'bad' sequence number + 1
     */
    private int badSeq;

    /**
     * Sequence packets till source is valid
     */
    private int probation;

    /**
     * Packets received
     */
    private int received;

    /**
     * Packet expected at last interval
     */
    private int expectedPrior;

    /**
     * Packet received at last interval
     */
    private int receivedPrior;

    /**
     * Estimated jitter.
     */
    public long jitter;

    /**
     * Last SR Packet timestamp
     */
    private long lastSenderReport;

    /**
     * Constructor requires an SSRC for it to be a valid source. The constructor initializes all the
     * source class members to a default value
     * 
     * @param sourceSSRC SSRC of the new source
     */
    RtpSource(int sourceSSRC) {
        ssrc = sourceSSRC;
        lastSenderReport = 0;
        probation = MIN_SEQUENCIAL;
        jitter = 0;
        initSeq(-1);
    }

    /**
     * Generates the extended sequence number.
     * 
     * @param seq Original sequence number
     * @return Extended sequence number
     */
    public int generateExtendedSequenceNumber(int seq) {
        return seq + (RTP_SEQ_MOD * cycles);
    }

    /**
     * Updates the statistics related to Sender Reports. Should be invoked when a RTCP Sender Report
     * is received.
     * 
     * @param srp Sender Report
     */
    public void receivedSenderReport(RtcpSenderReportPacket srp) {
        // RFC 3550: last SR timestamp (LSR): 32 bits - The middle 32 bits out
        // of 64 in the NTP timestamp received as part of the most recent RTCP
        // sender report
        lastSenderReport = (((srp.ntptimestampmsw << 32) | srp.ntptimestamplsw) & 0x0000ffffffff0000L) >>> 16;
    }

    /**
     * Updates the statistics related to RTP packets Should be invoked every time this source
     * receive an RTP Packet .
     * 
     * @param packet
     */
    public void receiveRtpPacket(RtpPacket packet) {
        if (baseSeq == -1) {
            // First packet received
            initSeq(packet.seqnum);
        }
        updateSeq(packet.seqnum);
    }

    /**
     * Generate the Reception Report
     * 
     * @return ReceptionReport
     */
    public ReceptionReport generateReceptionReport() {
        ReceptionReport report = new ReceptionReport(ssrc);
        updateReceptionReport(report);
        return report;
    }

    /**
     * Updates the reception report with latest data. The statistics calculation is based on the
     * algorithms present in RFC 3550
     * 
     * @param report Reception report to update
     */
    public void updateReceptionReport(ReceptionReport report) {
        // Calculate the number of packets lost
        int extendedMax = getExtendedSequenceNumber();
        int expected = extendedMax - baseSeq + 1;
        report.setCumulativeNumberOfPacketsLost(expected - received);

        // TODO : Calculate the delay after last sender report received
        report.setDelaySinceLastSenderReport(0);
        report.setExtendedHighestSequenceNumberReceived(getExtendedSequenceNumber());

        // Calculate the fraction lost
        long expectedInterval = expected - expectedPrior;
        expectedPrior = expected;
        int receivedInterval = received - receivedPrior;
        receivedPrior = received;
        long lostInterval = expectedInterval - receivedInterval;
        if (expectedInterval == 0 || lostInterval <= 0) {
            report.setFractionLost(0);
        } else {
            report.setFractionLost((lostInterval << 8) / (double) expectedInterval);
        }

        // TODO : Calculate jitter
        report.setInterarrivalJitter(0);

        report.setLastSenderReport(lastSenderReport);
        report.setSsrc(ssrc);
    }

    /**
     * Set the Source description
     * 
     * @param ssrc
     */
    public void setSsrc(int ssrc) {
        this.ssrc = ssrc;
    }

    /**
     * Initiate sequence. RFC 3550
     * 
     * @param sequenceNumber
     */
    private void initSeq(int sequenceNumber) {
        baseSeq = sequenceNumber;
        maxSeq = sequenceNumber;
        badSeq = RTP_SEQ_MOD + 1; // so seq == bad_seq is false
        cycles = 0;
        received = 0;
        receivedPrior = 0;
        expectedPrior = 0;
    }

    /**
     * Ensures that a source is declared valid only after MIN_SEQUENTIAL packets have been received
     * in sequence.It also validates the sequence number seq of a newly received packet and updates
     * the sequence state. Algorithm in the RFC 3550 (Appendix A.1)
     * 
     * @param seq Sequence Number
     */
    private int updateSeq(int seq) {
        long udelta = seq - maxSeq;

        // Source is not valid until MIN_SEQUENTIAL packets with sequential
        // sequence numbers have been received.
        if (probation > 0) {
            if (seq == maxSeq + 1) {
                probation--;
                maxSeq = seq;
                if (probation == 0) {
                    initSeq(seq);
                    received++;
                    return 1;
                }
            } else {
                probation = MIN_SEQUENCIAL - 1;
                maxSeq = seq;
                return 1;
            }
            return 0;
        } else if (udelta < MAX_DROPOUT) {
            // in order, with permissible gap
            if (seq < maxSeq && (udelta >= (MAX_MISORDER * -1))) {
                // late packet within interval
                received++;
                return 1;
            }

            if (seq < maxSeq) {
                // Sequence number wrapped - count another 64K cycle.
                cycles++;
            }
            maxSeq = seq;
        } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {
            // the sequence number made a very large jump
            if (seq == badSeq) {
                // Two sequential packets -- assume that the other side
                // restarted without telling us so just re-sync
                // (i.e., pretend this was the first packet).
                initSeq(seq);
            } else {
                badSeq = (seq + 1) & (RTP_SEQ_MOD - 1);
                return 0;
            }
        } else {
            // duplicate or reordered packet
        }
        received++;
        return 1;
    }

    /**
     * Return the extended sequence number for a source considering that sequences cycle.
     * 
     * @return Extended sequence number
     */
    private int getExtendedSequenceNumber() {
        return generateExtendedSequenceNumber(maxSeq);
    }

    /**
     * Gets Cname
     * 
     * @return Cname
     */
    public static String getCname() {
        return sCname;
    }

    /**
     * Sets Cname
     * 
     * @param cname
     */
    public static void setCname(String cname) {
        sCname = cname;
    }
}
```


Overlapping Code:
```
50: The dropout parameter MAX_DROPOUT should be a small fraction of the 16-bit sequence
* number space to give a reasonable probability that new sequence numbers after a restart will
* not fall in the acceptable range for sequence numbers from before the restart.
*/
private static final int MAX_DROPOUT = 3000;
/**
* RFC 3550: the sequence number is considered valid if it is no more than MAX_DROPOUT ahead of
* maxSeq nor more than MAX_MISORDER behind
*/
private static final int MAX_MISORDER = 100;
/**
* RFC 3550: RTP sequence number module
*/
private static final int RTP_SEQ_MOD = (1 << 16);
/**
* CNAME value
*/
private static String sCname = "anonymous@127.0.0.1";
/**
* Source is not valid until MIN_SEQUENTIAL packets with sequential sequence numbers have been
* received.
*/
private static int MIN_SEQUENCIAL = 0;
/**
* Is this source and ActiveSender.
*/
public boolean activeSender;
/**
* Source description
*/
public int ssrc;
/**
* Highest Sequence number received from this source
*/
private int maxSeq;
/**
* Keep track of the wrapping around of RTP sequence numbers, since RTP Seq No. are only 16 bits
*/
private int cycles;
/**
* Sequence Number of the first RTP packet received from this source
*/
private int baseSeq;
/**
* Last 'bad' sequence number + 1
*/
private int badSeq;
/**
* Sequence packets till source is valid
*/
private int probation;
/**
* Packets received
*/
private int received;
/**
* Packet expected at last interval
*/
private int expectedPrior;
/**
* Packet received at last interval
*/
private int receivedPrior;
/**
* Estimated jitter.
*/
public long jitter;
/**
* Last SR Packet timestamp
*/
private long lastSenderReport;
/**
* Constructor requires an SSRC for it to be a valid source. The constructor initializes all the
* source class members to a default value
* 
* @param sourceSSRC SSRC of the new source
*/
RtpSource(int sourceSSRC) {
ssrc = sourceSSRC;
lastSenderReport = 0;
probation = MIN_SEQUENCIAL;
jitter = 0;
initSeq(-1);
}
/**
* Generates th
```
<Overlap Ratio: 0.9689922480620154>

---

--- 357 --
Question ID: d9fde3935e0f4cf0e79cbc41426ba6d918af0902_0
Original Code:
```
public class GraphSparqlStep extends BaseStep implements StepInterface {

	private static int MAX_ATTEMPTS = 4;

	public GraphSparqlStep(StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,
			Trans trans) {
		super(stepMeta, stepDataInterface, copyNr, transMeta, trans);
	}

	/**
	 * Metodo chamado para cada linha que entra no step.
	 */
	// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta
	// SPARQL
	public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {
		GraphSparqlStepMeta meta = (GraphSparqlStepMeta) smi;
		GraphSparqlStepData data = (GraphSparqlStepData) sdi;

		// Obtem linha do fluxo de entrada
		final Object[] row = getRow();

		if (first) {
			// Executa apenas uma vez. Variavel first definida na superclasse
			first = false;

			// Obtem todas as colunas ate o step anterior.
			// Chamar apenas apos chamar getRow()
			RowMetaInterface rowMeta = getInputRowMeta(row != null);
			data.outputRowMeta = rowMeta.clone();

			// Adiciona os metadados do step atual
			meta.getFields(data.outputRowMeta, getStepname(), null, null, this);

			data.inputRowSize = rowMeta.size();

			// Obtem string de consulta e constroi o objeto consulta
			String queryStr = GraphSparqlStepUtils.toFullQueryString(meta.getPrefixes(), meta.getQueryString());
			try {
				data.originalQuery = QueryFactory.create(queryStr);
			} catch (QueryException e) {
				// Se consulta for invalida nao pode continuar
				throw new KettleException(e);
			}

			// Se nao usar SAX o execSelect() nao funciona
			ARQ.set(ARQ.useSAX, true);

			// Offset e Limit para Construct/select/describe quando limit nao
			// especificado
			if (!data.originalQuery.hasLimit() && (data.originalQuery.getQueryType() != Query.QueryTypeAsk)
					&& (data.originalQuery.getQueryType() != Query.QueryTypeDescribe)) {
				// Consulta eh quebrada em varias usando OFFSET e LIMIT
				data.offset = data.originalQuery.hasOffset() ? data.originalQuery.getOffset() : 0;
				data.limit = 1000;
				data.runAtOnce = false;
			} else {
				data.runAtOnce = true;
			}

			data.remainingTries = MAX_ATTEMPTS;

			return true;
		}

		Query query = null;
		if (data.runAtOnce) {
			// Roda consulta num unico HTTP Request
			query = data.originalQuery;

			while (data.remainingTries > 0) {
				// Tenta executar consulta ate MAX_ATTEMPTS vezes
				try {
					runQueryAndPutResults(query, meta, data, row);

					setOutputDone();
					return false; // Nao ha mais resultados, ie, processRow()
									// nao sera' chamado novamente
				} catch (Throwable e) {
					handleError(e, MAX_ATTEMPTS - data.remainingTries + 1);
				}

				data.remainingTries--;
			}
		} else {
			// Cria consulta que representa o bloco atual
			query = data.originalQuery.cloneQuery();
			query.setOffset(data.offset);
			query.setLimit(data.limit);

			while (data.remainingTries > 0) { // Tenta executar este bloco ate'
												// MAX_ATTEMPTS vezes
				try {
					int numRows = runQueryAndPutResults(query, meta, data, row);

					if (numRows > 0) { // Este bloco de consulta rodou
						data.offset += data.limit;
						data.remainingTries = MAX_ATTEMPTS;

						return true;
					} else { // Nao ha mais resultados, ie, processRow() nao
								// sera'
								// chamado novamente
						setOutputDone();
						return false;
					}
				} catch (Throwable e) {
					handleError(e, MAX_ATTEMPTS - data.remainingTries + 1);
				}

				data.remainingTries--;
			}
		}

		// Nao funfou!
		StringBuilder sb = new StringBuilder();
		sb.append("Todas as tentativas de executar a consulta falharam. ");
		sb.append("Verifique conexão de rede e o SPARQL Endpoint.\n");
		sb.append("Endpoint: ");
		sb.append(meta.getEndpointUri());
		sb.append('\n');
		sb.append("Grafo padrão: ");
		sb.append(meta.getDefaultGraph());
		sb.append('\n');
		sb.append("Consulta:\n");
		sb.append(query.toString());
		sb.append('\n');

		throw new KettleException(sb.toString());
	}

	private RowMetaInterface getInputRowMeta(boolean hasInputRow) {

		RowMetaInterface rowMeta = null;
		if (hasInputRow)
			rowMeta = getInputRowMeta();
		else
			rowMeta = new RowMeta();

		return rowMeta;
	}

	private void handleError(Throwable e, int attempts) {

		try {
			String msg = String.format("Falha ao executar consulta (tentativa %d de %d): ", attempts, MAX_ATTEMPTS);

			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			baos.write(msg.getBytes());

			e.printStackTrace(new PrintWriter(baos, true));

			long sleepTime = (long) (500 * Math.pow(2, attempts));
			msg = String.format("Tentando novamente em %d milissegundos...", sleepTime);
			baos.write(msg.getBytes());

			log.logBasic(baos.toString());

			Thread.sleep(sleepTime);

		} catch (IOException e1) {
			e1.printStackTrace();
		} catch (InterruptedException e2) {
			e2.printStackTrace();
		}
	}

	// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta
	// SPARQL
	private int runQueryAndPutResults(Query query, GraphSparqlStepMeta meta, GraphSparqlStepData data, Object[] row)
			throws KettleStepException {
		int numPutRows = 0;
		QueryExecution qexec = GraphSparqlStepUtils.createQueryExecution(query, meta.getEndpointUri(),
				meta.getDefaultGraph());

		try {
			Model model = null;
			switch (query.getQueryType()) {
			case Query.QueryTypeAsk:
				Boolean result = qexec.execAsk();
				incrementLinesInput();
				putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, result));
				break;

			case Query.QueryTypeConstruct:
				model = qexec.execConstruct();
				ResIterator resourceSet = model.listSubjects();
				int count = 0;
				while (resourceSet.hasNext()) {
					Resource resource = resourceSet.nextResource();
					// gets a subgraph
					Model subjectItemGraph = createSubjectItemGraph(resource, model);

					// send a subGraph to the next step
					incrementLinesInput();
					putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));
					count++;
				}
				if (count == 0) {
					incrementLinesInput();
					putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));
				}
				break;

			case Query.QueryTypeDescribe:
				model = qexec.execDescribe();
				ResIterator resourceSetD = model.listSubjects();
				int countD = 0;
				while (resourceSetD.hasNext()) {
					Resource resource = resourceSetD.nextResource();
					// gets a subgraph
					Model subjectItemGraph = createSubjectItemGraph(resource, model);

					// send a subGraph to the next step
					incrementLinesInput();
					putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, subjectItemGraph));
					countD++;
				}
				if (countD == 0) {
					incrementLinesInput();
					putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, model));
				}

				// incrementLinesInput();
				// putRow(data.outputRowMeta, RowDataUtil.addValueData(row,
				// data.inputRowSize, model));
				break;

			case Query.QueryTypeSelect:
				ResultSet resultSet = qexec.execSelect();
				model = resultSet.getResourceModel();

				Object extra = (model != null) ? model : resultSet;
				incrementLinesInput();
				putRow(data.outputRowMeta, RowDataUtil.addValueData(row, data.inputRowSize, extra));
				break;
			}
		} finally {
			qexec.close();
		}

		return numPutRows;
	}

	// Creates a subGraph with a Resource and its Properties
	private Model createSubjectItemGraph(Resource resource, Model model) {
		Model subjectItemGraph = null;
		Selector s = new SimpleSelector(resource, (Property) null, (RDFNode) null);
		subjectItemGraph = model.query(s);
		// StmtIterator i = model.listStatements(s);

		return subjectItemGraph;
	}
}
```


Overlapping Code:
```
Step extends BaseStep implements StepInterface {
private static int MAX_ATTEMPTS = 4;
public GraphSparqlStep(StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,
Trans trans) {
super(stepMeta, stepDataInterface, copyNr, transMeta, trans);
}
/**
* Metodo chamado para cada linha que entra no step.
*/
// Rogers(Nov/2012): Correcao de bug na ordenacao dos campos da consulta
// SPARQL
public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {
GraphSparqlStepMeta meta = (GraphSparqlStepMeta) smi;
GraphSparqlStepData data = (GraphSparqlStepData) sdi;
// Obtem linha do fluxo de entrada
final Object[] row = getRow();
if (first) {
// Executa apenas uma vez. Variavel first definida na superclasse
first = false;
// Obtem todas as colunas ate o step anterior.
// Chamar apenas apos chamar getRow()
RowMetaInterface rowMeta = getInputRowMeta(row != null);
data.outputRowMeta = rowMeta.clone();
// Adiciona os metadados do step atual
meta.getFields(data.outputRowMeta, getStepname(), null, null, this);
data.inputRowSize = rowMeta.size();
// Obtem string de consulta e constroi o objeto consulta
String queryStr = GraphSparqlStepUtils.toFullQueryString(meta.getPrefixes(), meta.getQueryString());
try {
data.originalQuery = QueryFactory.create(queryStr);
} catch (QueryException e) {
// Se consulta for invalida nao pode continuar
throw new KettleException(e);
}
// Se nao usar SAX o execSelect() nao funciona
ARQ.set(ARQ.useSAX, true);
// Offset e Limit para Construct/select/describe quando limit nao
// especificado
if (!data.originalQuery.hasLimit() && (data.originalQuery.getQueryType() != Query.QueryTypeAsk)
&& (data.originalQuery.getQueryType() != Query.QueryTypeDescribe)) {
// Consulta eh quebrada em varias usando OFFSET e LIMIT
data.offset = data.originalQuery.hasOffset() ? data.originalQuery.getOffset() : 0;
data.limit = 1000;
data.runAtOnce = false;
} else {
data.runAtOnce = true;
}
data.remainingTries = MAX_ATTEMPTS;
return true;
}
Query query = null;
if (data.runAtOnce) {
// Roda consulta num unico HTTP Request
query = data.originalQuery;
while (data.remainingTries > 0) {
// Tenta executar consulta ate MAX_ATTEMPTS vezes
try {
runQueryAndPutResults(query, meta, data, r
```
<Overlap Ratio: 0.9779507133592736>

---

--- 358 --
Question ID: da92e01aa58179a72fb9cac6c9d5d236561eb669_0
Original Code:
```
public class AdR2ElementParserTest extends MarshallingTestCase {

	@Test
	public void testParseNullNode() throws Exception {
		Node node = createNode("<something nullFlavor=\"NI\" />");
		AD ad = (AD) (new AdR2ElementParser()).parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
		assertEquals("null returned", null, ad.getValue());
	}

	private ParseContext createContext(String type, VersionNumber version) {
		return ParseContextImpl.create(type, PostalAddress.class, version, null, null, ConformanceLevel.POPULATED, null, null, false);
	}

	@Test
	public void testParseEmptyNode() throws Exception {
		Node node = createNode("<something/>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
        assertNotNull("empty node", ad.getValue());
        assertTrue("empty node value", ad.getValue().getParts().isEmpty());
	}

	@Test
	public void testParseTextNode() throws Exception {
		Node node = createNode("<something>text value</something>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
		assertEquals("correct number of parts", 1, ad.getValue().getParts().size());
        assertPostalAddressPartAsExpected("text node", ad.getValue().getParts().get(0), null, "text value");
	}
	
	@Test
	public void testParseTextNodeWithAttributes() throws Exception {
		Node node = createNode("<something representation=\"TXT\" mediaType=\"text/plain\">text value</something>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
		assertEquals("correct number of parts", 1, ad.getValue().getParts().size());
		assertNull(ad.getValue().getIsNotOrdered());
        assertPostalAddressPartAsExpected("text node with attributes", ad.getValue().getParts().get(0), null, "text value");
	}

	@Test
    public void testParseAll() throws Exception {
		Date useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);
		Date useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);

        Node node = createNode(
                  "<something isNotOrdered=\"true\"> " +
	                  "<city>city name</city>" +
	                  "freeform" +
	                  "<delimiter>,</delimiter>" +
	                  "\n" +
	                  "<state>Ontario</state>" +
	                  "<useablePeriod operator=\"P\" value=\"20080625\" />" +
	                  "<useablePeriod value=\"20120903\" />" +
                  "</something>");
        
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
        
        PostalAddress postalAddress = ad.getValue();
        
        assertEquals("number of name uses", 0, postalAddress.getUses().size());
        assertEquals("number of name parts", 4, postalAddress.getParts().size());
        assertEquals("number of useablePeriods", 2, postalAddress.getUseablePeriods().size());
        
        assertTrue((boolean)ad.getValue().getIsNotOrdered()); //cast for .NET translation
        
        assertPostalAddressPartAsExpected("city", postalAddress.getParts().get(0), PostalAddressPartType.CITY, "city name");
        assertPostalAddressPartAsExpected("free", postalAddress.getParts().get(1), null, "freeform");
        assertPostalAddressPartAsExpected("delimiter comma", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, ",");
        assertPostalAddressPartAsExpected("state", postalAddress.getParts().get(3), PostalAddressPartType.STATE, "Ontario");
        
        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));
        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));
        
        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));
        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));
    }

	@Test
    public void testParseUseablePeriodOutOfOrder() throws Exception {
		Date useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);
		Date useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);

        Node node = createNode(
                  "<something isNotOrdered=\"true\"> " +
	                  "<city>city name</city>" +
	                  "freeform" +
	                  "<useablePeriod operator=\"P\" value=\"20080625\" />" +
	                  "<delimiter>,</delimiter>" +
	                  "\n" +
	                  "<state>Ontario</state>" +
	                  "<useablePeriod value=\"20120903\" />" +
                  "</something>");
        
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertFalse(this.xmlResult.isValid());
		assertEquals(1, this.xmlResult.getHl7Errors().size());
        
        PostalAddress postalAddress = ad.getValue();
        
        assertEquals("number of name uses", 0, postalAddress.getUses().size());
        assertEquals("number of name parts", 4, postalAddress.getParts().size());
        assertEquals("number of useablePeriods", 2, postalAddress.getUseablePeriods().size());
        
        assertTrue((boolean)ad.getValue().getIsNotOrdered());//cast for .NET translation
        
        assertPostalAddressPartAsExpected("city", postalAddress.getParts().get(0), PostalAddressPartType.CITY, "city name");
        assertPostalAddressPartAsExpected("free", postalAddress.getParts().get(1), null, "freeform");
        assertPostalAddressPartAsExpected("delimiter comma", postalAddress.getParts().get(2), PostalAddressPartType.DELIMITER, ",");
        assertPostalAddressPartAsExpected("state", postalAddress.getParts().get(3), PostalAddressPartType.STATE, "Ontario");
        
        assertTrue(postalAddress.getUseablePeriods().containsKey(useable1));
        assertEquals(SetOperator.PERIODIC_HULL, postalAddress.getUseablePeriods().get(useable1));
        
        assertTrue(postalAddress.getUseablePeriods().containsKey(useable2));
        assertEquals(SetOperator.INCLUDE, postalAddress.getUseablePeriods().get(useable2));
    }
	
	@Test
    public void testParseFailure() throws Exception {
        Node node = createNode("<something><monkey>prefix 1</monkey>Organization name<delimiter>,</delimiter><suffix>Inc</suffix></something>");
        
        new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
        assertFalse(this.xmlResult.isValid());
        assertEquals("message", "Address part type not valid: monkey (<monkey>)", this.xmlResult.getHl7Errors().get(0).getMessage());
    }
    
    private void assertPostalAddressPartAsExpected(String message, PostalAddressPart postalAddressPart, PostalAddressPartType expectedType, String expectedValue) {
        assertEquals(message + " type", expectedType, postalAddressPart.getType());
        assertEquals(message + " value", expectedValue, postalAddressPart.getValue());
    }
    
	@Test
    public void testUsesNoUse() throws Exception {
        Node node = createNode("<something/>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
        assertEquals("zero uses", 0, ad.getValue().getUses().size());
    }
    
	@Test
    public void testUsesOneUse() throws Exception {
        Node node = createNode("<something use=\"H\"/>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
        assertEquals("one use", 1, ad.getValue().getUses().size());
        Iterator<ca.infoway.messagebuilder.domainvalue.PostalAddressUse> iterator = ad.getValue().getUses().iterator();
        if (iterator.hasNext()) { //.NET
        	assertTrue("contains HOME use", iterator.next().getCodeValue().equals(PostalAddressUse.HOME.getCodeValue()));
        }
    }
    
	@Test
    public void testUsesMultipleUses() throws Exception {
        Node node = createNode("<something use=\"H PHYS PST\"/>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertTrue(this.xmlResult.isValid());
        
		Set<String> uses = new HashSet<String>();
        PostalAddress postalAddress = ad.getValue();
		for (ca.infoway.messagebuilder.domainvalue.PostalAddressUse postalAddressUse : postalAddress.getUses()) {
			uses.add(postalAddressUse.getCodeValue());
		}
		
		assertEquals("three uses", 3, postalAddress.getUses().size());
        assertTrue("contains HOME use", uses.contains(X_BasicPostalAddressUse.HOME.getCodeValue()));
        assertTrue("contains PHYS use", uses.contains(X_BasicPostalAddressUse.PHYSICAL.getCodeValue()));
        assertTrue("contains POSTAL use", uses.contains(X_BasicPostalAddressUse.POSTAL.getCodeValue()));
    }
    
	@Test
    public void testUsesUnknownUse() throws Exception {
        Node node = createNode("<something use=\"XXX\"/>");
        AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
		assertFalse(this.xmlResult.isValid());
		assertEquals(1, this.xmlResult.getHl7Errors().size());
		assertEquals("no uses", 0, ad.getValue().getUses().size());
    }
}
```


Overlapping Code:
```
lementParserTest extends MarshallingTestCase {
@Test
public void testParseNullNode() throws Exception {
Node node = createNode("<something nullFlavor=\"NI\" />");
AD ad = (AD) (new AdR2ElementParser()).parse(createContext("AD", V02R02), node, this.xmlResult);
assertTrue(this.xmlResult.isValid());
assertEquals("null returned", null, ad.getValue());
}
private ParseContext createContext(String type, VersionNumber version) {
return ParseContextImpl.create(type, PostalAddress.class, version, null, null, ConformanceLevel.POPULATED, null, null, false);
}
@Test
public void testParseEmptyNode() throws Exception {
Node node = createNode("<something/>");
AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
assertTrue(this.xmlResult.isValid());
assertNotNull("empty node", ad.getValue());
assertTrue("empty node value", ad.getValue().getParts().isEmpty());
}
@Test
public void testParseTextNode() throws Exception {
Node node = createNode("<something>text value</something>");
AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
assertTrue(this.xmlResult.isValid());
assertEquals("correct number of parts", 1, ad.getValue().getParts().size());
assertPostalAddressPartAsExpected("text node", ad.getValue().getParts().get(0), null, "text value");
}

@Test
public void testParseTextNodeWithAttributes() throws Exception {
Node node = createNode("<something representation=\"TXT\" mediaType=\"text/plain\">text value</something>");
AD ad = (AD) new AdR2ElementParser().parse(createContext("AD", V02R02), node, this.xmlResult);
assertTrue(this.xmlResult.isValid());
assertEquals("correct number of parts", 1, ad.getValue().getParts().size());
assertNull(ad.getValue().getIsNotOrdered());
assertPostalAddressPartAsExpected("text node with attributes", ad.getValue().getParts().get(0), null, "text value");
}
@Test
public void testParseAll() throws Exception {
Date useable1 = DateUtil.getDate(2008, 5, 25, 0, 0, 0, 0);
Date useable2 = DateUtil.getDate(2012, 8, 3, 0, 0, 0, 0);
Node node = createNode(
"<something isNotOrdered=\"true\"> " +
"<city>city name</city>" +
"freeform"
```
<Overlap Ratio: 0.9746606334841629>

---

--- 359 --
Question ID: 18d95165dd89de4af5d4038d82f2b9dcec616e6c_0
Original Code:
```
public class DeclutterableText implements Declutterable
{
    protected GeographicText text;
    protected Vec4 point;
    protected double eyeDistance;
    protected DeclutteringTextRenderer textRenderer;
    protected boolean enableDecluttering = true;
    protected Rectangle2D textBounds; // cached text bounds
    protected Font boundsFont; // font used by cached text bounds

    /**
     * Construct an object for specified text and position.
     *
     * @param text         the text to display.
     * @param point        the Cartesian location of the text.
     * @param eyeDistance  the distance to consider the text from the eye.
     * @param textRenderer the text renderer to use to draw the text.
     */
    DeclutterableText(GeographicText text, Vec4 point, double eyeDistance, DeclutteringTextRenderer textRenderer)
    {
        this.text = text;
        this.point = point;
        this.eyeDistance = eyeDistance;
        this.textRenderer = textRenderer;
    }

    /**
     * Indicates whether this text should participate in decluttering.
     *
     * @return true (the default) if it should participate, otherwise false.
     */
    public boolean isEnableDecluttering()
    {
        return this.enableDecluttering;
    }

    public double getDistanceFromEye()
    {
        return this.eyeDistance;
    }

    public GeographicText getText()
    {
        return text;
    }

    public Vec4 getPoint()
    {
        return point;
    }

    public Rectangle2D getBounds(DrawContext dc)
    {
        Font font = this.getText().getFont();
        if (font == null)
            font = this.textRenderer.getDefaultFont();

        if (this.textBounds != null && this.boundsFont == font)
            return this.textBounds;

        try
        {
            this.textBounds = this.textRenderer.computeTextBounds(dc, this);
            this.boundsFont = font;
        }
        catch (Exception e)
        {
            Logging.logger().log(java.util.logging.Level.SEVERE, "generic.ExceptionWhileRenderingText", e);
        }

        return this.textBounds;
    }

    /** {@inheritDoc} */
    public void render(DrawContext dc)
    {
        try
        {
            if (this.getBounds(dc) == null)
                return;

            this.textRenderer.drawText(dc, this, 1, 1);
        }
        catch (Exception e)
        {
            Logging.logger().log(java.util.logging.Level.SEVERE, "generic.ExceptionWhileRenderingText", e);
        }
    }

    public void pick(DrawContext dc, java.awt.Point pickPoint)
    {
        // TODO
    }
}
```


Overlapping Code:
```
bleText implements Declutterable
{
protected GeographicText text;
protected Vec4 point;
protected double eyeDistance;
protected DeclutteringTextRenderer textRenderer;
protected boolean enableDecluttering = true;
protected Rectangle2D textBounds; // cached text bounds
protected Font boundsFont; // font used by cached text bounds
/**
* Construct an object for specified text and position.
*
* @param text the text to display.
* @param point the Cartesian location of the text.
* @param eyeDistance the distance to consider the text from the eye.
* @param textRenderer the text renderer to use to draw the text.
*/
DeclutterableText(GeographicText text, Vec4 point, double eyeDistance, DeclutteringTextRenderer textRenderer)
{
this.text = text;
this.point = point;
this.eyeDistance = eyeDistance;
this.textRenderer = textRenderer;
}
/**
* Indicates whether this text should participate in decluttering.
*
* @return true (the default) if it should participate, otherwise false.
*/
public boolean isEnableDecluttering()
{
return this.enableDecluttering;
}
public double getDistanceFromEye()
{
return this.eyeDistance;
}
public GeographicText getText()
{
return text;
}
public Vec4 getPoint()
{
return point;
}
public Rectangle2D getBounds(DrawContext dc)
{
Font font = this.getText().getFont();
if (font == null)
font = this.textRenderer.getDefaultFont();
if (this.textBounds != null && this.boundsFont == font)
return this.textBounds;
try
{
this.textBounds = this.textRenderer.computeTextBounds(dc, this);
this.boundsFont = font;
}
catch (Exception e)
{
Logging.logger().log(java.util.logging.Level.SEVERE, "generic.ExceptionWhileRenderingText", e);
}
return this.textBounds;
}
/** {@inheritDoc} */
public void render(DrawContext dc)
{
try
{
if (this.getBounds(dc) == null)
return;
this.textRenderer.drawText(dc, this, 1, 1);
}
catch (Exception e)
{
Logging.logger().log(java.util.logging.Level.SEVERE, "generic.ExceptionWhileRenderingText", e);
}
}
publi
```
<Overlap Ratio: 0.984375>

---

--- 360 --
Question ID: 5471a6f78601740bd0ac1ab416a1b3e5eeb4aa3f_0
Original Code:
```
@Slf4j
@Aspect
@Component
public class GuavaRateLimiterAspect {
    private static final ConcurrentMap<String, com.google.common.util.concurrent.RateLimiter> RATE_LIMITER_CACHE = new ConcurrentHashMap<>();

    @Pointcut("@annotation(com.sakura.common.ratelimit.guava.RateLimiter)")
    public void rateLimit() {

    }

    @Around("rateLimit()")
    public Object pointcut(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        // 通过 AnnotationUtils.findAnnotation 获取 RateLimiter 注解
        RateLimiter rateLimiter = AnnotationUtils.findAnnotation(method, RateLimiter.class);
        if (rateLimiter != null && rateLimiter.qps() > RateLimiter.NOT_LIMITED) {
            double qps = rateLimiter.qps();
            if (RATE_LIMITER_CACHE.get(method.getName()) == null) {
                // 初始化 QPS
                RATE_LIMITER_CACHE.put(method.getName(), com.google.common.util.concurrent.RateLimiter.create(qps));
            }

            log.debug("【{}】的QPS设置为: {}", method.getName(), RATE_LIMITER_CACHE.get(method.getName()).getRate());
            // 尝试获取令牌
            if (RATE_LIMITER_CACHE.get(method.getName()) != null && !RATE_LIMITER_CACHE.get(method.getName()).tryAcquire(rateLimiter.timeout(), rateLimiter.timeUnit())) {
                throw new YWarmingException("手速太快了，慢点儿吧~");
            }
        }
        return point.proceed();
    }
}
```


Overlapping Code:
```
mponent
public class GuavaRateLimiterAspect {
private static final ConcurrentMap<String, com.google.common.util.concurrent.RateLimiter> RATE_LIMITER_CACHE = new ConcurrentHashMap<>();
@Pointcut("@annotation(com.sakura.common.ratelimit.guava.RateLimiter)")
public void rateLimit() {
}
@Around("rateLimit()")
public Object pointcut(ProceedingJoinPoint point) throws Throwable {
MethodSignature signature = (MethodSignature) point.getSignature();
Method method = signature.getMethod();
// 通过 AnnotationUtils.findAnnotation 获取 RateLimiter 注解
RateLimiter rateLimiter = AnnotationUtils.findAnnotation(method, RateLimiter.class);
if (rateLimiter != null && rateLimiter.qps() > RateLimiter.NOT_LIMITED) {
double qps = rateLimiter.qps();
if (RATE_LIMITER_CACHE.get(method.getName()) == null) {
// 初始化 QPS
RATE_LIMITER_CACHE.put(method.getName(), com.google.common.util.concurrent.RateLimiter.create(qps));
}
log.debug("【{}】的QPS设置为: {}", method.getName(), RATE_LIMITER_CACHE.get(method.getName()).getRate());
// 尝试获取令牌
if (RATE_LIMITER_CACHE.get(method.getName()) != null && !RATE_LIMITER_CACHE.get(method.getName()).tryAcquire(rateLimiter.timeout(), rateLimiter.timeUnit())) {
throw new YWarmingException("手速太
```
<Overlap Ratio: 0.9516256938937351>

---

--- 361 --
Question ID: 31eec84d544bfd37ee508a0621391c6beecda158_0
Original Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class SourceFlowConfig implements Serializable, Cloneable, StructuredPojo {

    /**
     * <p>
     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     * account.
     * </p>
     */
    private String connectorProfileName;
    /**
     * <p>
     * The type of connector, such as Salesforce, Marketo, and so on.
     * </p>
     */
    private String connectorType;
    /**
     * <p>
     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields
     * specified in the configuration are used when querying for the incremental data pull.
     * </p>
     */
    private IncrementalPullConfig incrementalPullConfig;
    /**
     * <p>
     * Specifies the information that is required to query a particular source connector.
     * </p>
     */
    private SourceConnectorProperties sourceConnectorProperties;

    /**
     * <p>
     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     * account.
     * </p>
     * 
     * @param connectorProfileName
     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     *        account.
     */

    public void setConnectorProfileName(String connectorProfileName) {
        this.connectorProfileName = connectorProfileName;
    }

    /**
     * <p>
     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     * account.
     * </p>
     * 
     * @return The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     *         account.
     */

    public String getConnectorProfileName() {
        return this.connectorProfileName;
    }

    /**
     * <p>
     * The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     * account.
     * </p>
     * 
     * @param connectorProfileName
     *        The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
     *        account.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public SourceFlowConfig withConnectorProfileName(String connectorProfileName) {
        setConnectorProfileName(connectorProfileName);
        return this;
    }

    /**
     * <p>
     * The type of connector, such as Salesforce, Marketo, and so on.
     * </p>
     * 
     * @param connectorType
     *        The type of connector, such as Salesforce, Marketo, and so on.
     * @see SourceConnectorType
     */

    public void setConnectorType(String connectorType) {
        this.connectorType = connectorType;
    }

    /**
     * <p>
     * The type of connector, such as Salesforce, Marketo, and so on.
     * </p>
     * 
     * @return The type of connector, such as Salesforce, Marketo, and so on.
     * @see SourceConnectorType
     */

    public String getConnectorType() {
        return this.connectorType;
    }

    /**
     * <p>
     * The type of connector, such as Salesforce, Marketo, and so on.
     * </p>
     * 
     * @param connectorType
     *        The type of connector, such as Salesforce, Marketo, and so on.
     * @return Returns a reference to this object so that method calls can be chained together.
     * @see SourceConnectorType
     */

    public SourceFlowConfig withConnectorType(String connectorType) {
        setConnectorType(connectorType);
        return this;
    }

    /**
     * <p>
     * The type of connector, such as Salesforce, Marketo, and so on.
     * </p>
     * 
     * @param connectorType
     *        The type of connector, such as Salesforce, Marketo, and so on.
     * @return Returns a reference to this object so that method calls can be chained together.
     * @see SourceConnectorType
     */

    public SourceFlowConfig withConnectorType(SourceConnectorType connectorType) {
        this.connectorType = connectorType.toString();
        return this;
    }

    /**
     * <p>
     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields
     * specified in the configuration are used when querying for the incremental data pull.
     * </p>
     * 
     * @param incrementalPullConfig
     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the
     *        fields specified in the configuration are used when querying for the incremental data pull.
     */

    public void setIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {
        this.incrementalPullConfig = incrementalPullConfig;
    }

    /**
     * <p>
     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields
     * specified in the configuration are used when querying for the incremental data pull.
     * </p>
     * 
     * @return Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided,
     *         the fields specified in the configuration are used when querying for the incremental data pull.
     */

    public IncrementalPullConfig getIncrementalPullConfig() {
        return this.incrementalPullConfig;
    }

    /**
     * <p>
     * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields
     * specified in the configuration are used when querying for the incremental data pull.
     * </p>
     * 
     * @param incrementalPullConfig
     *        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the
     *        fields specified in the configuration are used when querying for the incremental data pull.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public SourceFlowConfig withIncrementalPullConfig(IncrementalPullConfig incrementalPullConfig) {
        setIncrementalPullConfig(incrementalPullConfig);
        return this;
    }

    /**
     * <p>
     * Specifies the information that is required to query a particular source connector.
     * </p>
     * 
     * @param sourceConnectorProperties
     *        Specifies the information that is required to query a particular source connector.
     */

    public void setSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {
        this.sourceConnectorProperties = sourceConnectorProperties;
    }

    /**
     * <p>
     * Specifies the information that is required to query a particular source connector.
     * </p>
     * 
     * @return Specifies the information that is required to query a particular source connector.
     */

    public SourceConnectorProperties getSourceConnectorProperties() {
        return this.sourceConnectorProperties;
    }

    /**
     * <p>
     * Specifies the information that is required to query a particular source connector.
     * </p>
     * 
     * @param sourceConnectorProperties
     *        Specifies the information that is required to query a particular source connector.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public SourceFlowConfig withSourceConnectorProperties(SourceConnectorProperties sourceConnectorProperties) {
        setSourceConnectorProperties(sourceConnectorProperties);
        return this;
    }

    /**
     * Returns a string representation of this object. This is useful for testing and debugging. Sensitive data will be
     * redacted from this string using a placeholder value.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getConnectorProfileName() != null)
            sb.append("ConnectorProfileName: ").append(getConnectorProfileName()).append(",");
        if (getConnectorType() != null)
            sb.append("ConnectorType: ").append(getConnectorType()).append(",");
        if (getIncrementalPullConfig() != null)
            sb.append("IncrementalPullConfig: ").append(getIncrementalPullConfig()).append(",");
        if (getSourceConnectorProperties() != null)
            sb.append("SourceConnectorProperties: ").append(getSourceConnectorProperties());
        sb.append("}");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;

        if (obj instanceof SourceFlowConfig == false)
            return false;
        SourceFlowConfig other = (SourceFlowConfig) obj;
        if (other.getConnectorProfileName() == null ^ this.getConnectorProfileName() == null)
            return false;
        if (other.getConnectorProfileName() != null && other.getConnectorProfileName().equals(this.getConnectorProfileName()) == false)
            return false;
        if (other.getConnectorType() == null ^ this.getConnectorType() == null)
            return false;
        if (other.getConnectorType() != null && other.getConnectorType().equals(this.getConnectorType()) == false)
            return false;
        if (other.getIncrementalPullConfig() == null ^ this.getIncrementalPullConfig() == null)
            return false;
        if (other.getIncrementalPullConfig() != null && other.getIncrementalPullConfig().equals(this.getIncrementalPullConfig()) == false)
            return false;
        if (other.getSourceConnectorProperties() == null ^ this.getSourceConnectorProperties() == null)
            return false;
        if (other.getSourceConnectorProperties() != null && other.getSourceConnectorProperties().equals(this.getSourceConnectorProperties()) == false)
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;

        hashCode = prime * hashCode + ((getConnectorProfileName() == null) ? 0 : getConnectorProfileName().hashCode());
        hashCode = prime * hashCode + ((getConnectorType() == null) ? 0 : getConnectorType().hashCode());
        hashCode = prime * hashCode + ((getIncrementalPullConfig() == null) ? 0 : getIncrementalPullConfig().hashCode());
        hashCode = prime * hashCode + ((getSourceConnectorProperties() == null) ? 0 : getSourceConnectorProperties().hashCode());
        return hashCode;
    }

    @Override
    public SourceFlowConfig clone() {
        try {
            return (SourceFlowConfig) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException("Got a CloneNotSupportedException from Object.clone() " + "even though we're Cloneable!", e);
        }
    }

    @com.amazonaws.annotation.SdkInternalApi
    @Override
    public void marshall(ProtocolMarshaller protocolMarshaller) {
        com.amazonaws.services.customerprofiles.model.transform.SourceFlowConfigMarshaller.getInstance().marshall(this, protocolMarshaller);
    }
}
```


Overlapping Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class SourceFlowConfig implements Serializable, Cloneable, StructuredPojo {
/**
* <p>
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
* </p>
*/
private String connectorProfileName;
/**
* <p>
* The type of connector, such as Salesforce, Marketo, and so on.
* </p>
*/
private String connectorType;
/**
* <p>
* Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields
* specified in the configuration are used when querying for the incremental data pull.
* </p>
*/
private IncrementalPullConfig incrementalPullConfig;
/**
* <p>
* Specifies the information that is required to query a particular source connector.
* </p>
*/
private SourceConnectorProperties sourceConnectorProperties;
/**
* <p>
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
* </p>
* 
* @param connectorProfileName
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
*/
public void setConnectorProfileName(String connectorProfileName) {
this.connectorProfileName = connectorProfileName;
}
/**
* <p>
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
* </p>
* 
* @return The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
*/
public String getConnectorProfileName() {
return this.connectorProfileName;
}
/**
* <p>
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
* </p>
* 
* @param connectorProfileName
* The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS
* account.
* @return Returns a reference to this object so that method calls can be chained together.
*/
public SourceFlowConfig withConnectorProfileName(String connectorProfileName) {
setConnectorProfileName(connectorProfileName);
```
<Overlap Ratio: 1.0>

---

--- 362 --
Question ID: d5e047a7c49ab7607e2670476d0df4ef99587ae1_0
Original Code:
```
public class ClojureMonoidAggregator extends BaseOperation<Tuple> implements Aggregator<Tuple> {
  private final CombinerSpec combinerSpec;
  private transient IFn prepareFn;
  private transient IFn combineFn;
  private transient IFn presentFn;

  public ClojureMonoidAggregator(Fields fields, CombinerSpec combinerSpec) {
    super(fields);
    this.combinerSpec = combinerSpec;
  }

  @Override
  public void prepare(FlowProcess flowProcess, OperationCall<Tuple> operationCall) {
    prepareFn = combinerSpec.getPrepareFn();
    combineFn = combinerSpec.getCombineFn();
    presentFn = combinerSpec.getPresentFn();
  }

  public void start(FlowProcess fp, AggregatorCall<Tuple> call) {
    call.setContext(null);
  }

  public void aggregate(FlowProcess fp, AggregatorCall<Tuple> call) {
    ISeq fnArgs = RT.seq(Util.tupleToList(call.getArguments()));
    if (null != prepareFn) {
      fnArgs = RT.seq(Util.coerceToList(prepareFn.applyTo(fnArgs)));
    }
    Tuple context = call.getContext();

    if (null == context) {
      Tuple newContext = Tuple.size(1);
      newContext.set(0, fnArgs);
      call.setContext(newContext);
    } else {
      ISeq acc = (ISeq) context.getObject(0);
      ISeq ret = RT.seq(Util.coerceToList(combineFn.applyTo(Util.cat(acc, fnArgs))));
      context.set(0, ret);
    }
  }

  public void complete(FlowProcess flowProcess, AggregatorCall<Tuple> call) {
    Tuple context = call.getContext();

    if (null == context) {
      throw new RuntimeException("ClojureMonoidAggregator completed with any aggregate calls");
    } else {
      ISeq finalValue = (ISeq) context.getObject(0);
      call.setContext(null);
      if (null != presentFn) {
        call.getOutputCollector().add(
            Util.coerceToTuple(presentFn.applyTo(finalValue)));
      } else {
        call.getOutputCollector().add(
            Util.coerceToTuple(finalValue));
      }
    }
  }
}
```


Overlapping Code:
```
tends BaseOperation<Tuple> implements Aggregator<Tuple> {
private final CombinerSpec combinerSpec;
private transient IFn prepareFn;
private transient IFn combineFn;
private transient IFn presentFn;
public ClojureMonoidAggregator(Fields fields, CombinerSpec combinerSpec) {
super(fields);
this.combinerSpec = combinerSpec;
}
@Override
public void prepare(FlowProcess flowProcess, OperationCall<Tuple> operationCall) {
prepareFn = combinerSpec.getPrepareFn();
combineFn = combinerSpec.getCombineFn();
presentFn = combinerSpec.getPresentFn();
}
public void start(FlowProcess fp, AggregatorCall<Tuple> call) {
call.setContext(null);
}
public void aggregate(FlowProcess fp, AggregatorCall<Tuple> call) {
ISeq fnArgs = RT.seq(Util.tupleToList(call.getArguments()));
if (null != prepareFn) {
fnArgs = RT.seq(Util.coerceToList(prepareFn.applyTo(fnArgs)));
}
Tuple context = call.getContext();
if (null == context) {
Tuple newContext = Tuple.size(1);
newContext.set(0, fnArgs);
call.setContext(newContext);
} else {
ISeq acc = (ISeq) context.getObject(0);
ISeq ret = RT.seq(Util.coerceToList(combineFn.applyTo(Util.cat(acc, fnArgs))));
context.set(0, ret);
}
}
public void complete(FlowProcess flowProcess, AggregatorCall<Tuple> call) {
Tuple context = call.getContext();
if (null == context) {
throw new RuntimeException("ClojureMonoidAggregator completed with any aggregate calls");
} else {
ISeq finalValue = (ISeq) context.getObject(0);
call.setContext(null);
if (null != presentFn) {
call.getOutputCollector().add(
Util.coerceToTuple(presentFn.applyTo(finalValue)));
} else {
call.getOutputCollector().ad
```
<Overlap Ratio: 0.9512485136741974>

---

--- 363 --
Question ID: ee4a2733fb085d2ed19f2bd7c0153b0a71ce2b2c_0
Original Code:
```
public class SummarizeUMIBaseQualitiesTest {

	@Test(enabled=true)
	public void test1() {

		char [] b = {'A', 'A', 'A'};
		byte [] bases = getBases(b);
		byte [] qualities = {10,20,30};

		SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
		byte r = s.getMostCommonBase();
		Assert.assertEquals(r, (byte) 'A');

		int score = s.getSummarizedPhredScore();
		Assert.assertEquals(14, score);
	}

	@Test
	public void test2() {

		char [] b = {'A', 'A', 'A', 'A', 'A'};
		byte [] bases = getBases(b);
		byte [] qualities = {30,30,30,30,30};

		SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
		byte r = s.getMostCommonBase();
		Assert.assertEquals(r, (byte) 'A');

		int score = s.getSummarizedPhredScore();
		Assert.assertEquals(30, score);
	}

	@Test
	public void test3() {

		char [] b = {'A', 'A', 'T'};
		byte [] bases = getBases(b);
		byte [] qualities = {30, 30, 10};

		SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
		byte r = s.getMostCommonBase();
		Assert.assertEquals(r, (byte) 'A');

		int score = s.getSummarizedPhredScore();
		Assert.assertEquals(5, score);
	}

	@Test
	public void testMode () {
		char [] b = {'A', 'A', 'T', 'A', 'A', 'A', 'A'};
		byte [] bases = getBases(b);
		byte [] qualities = {20, 30, 10, 20, 25, 25, 25};

		SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
		int value = s.getSummarizedPhreadScoreByMode();
		Assert.assertSame(25, value);
	}




	private byte [] getBases (final char [] bases) {
		byte [] result = new byte [bases.length];
		StringUtil.charsToBytes(bases, 0, bases.length, result, 0);
		return (result);
	}
}
```


Overlapping Code:
```
zeUMIBaseQualitiesTest {
@Test(enabled=true)
public void test1() {
char [] b = {'A', 'A', 'A'};
byte [] bases = getBases(b);
byte [] qualities = {10,20,30};
SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
byte r = s.getMostCommonBase();
Assert.assertEquals(r, (byte) 'A');
int score = s.getSummarizedPhredScore();
Assert.assertEquals(14, score);
}
@Test
public void test2() {
char [] b = {'A', 'A', 'A', 'A', 'A'};
byte [] bases = getBases(b);
byte [] qualities = {30,30,30,30,30};
SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
byte r = s.getMostCommonBase();
Assert.assertEquals(r, (byte) 'A');
int score = s.getSummarizedPhredScore();
Assert.assertEquals(30, score);
}
@Test
public void test3() {
char [] b = {'A', 'A', 'T'};
byte [] bases = getBases(b);
byte [] qualities = {30, 30, 10};
SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
byte r = s.getMostCommonBase();
Assert.assertEquals(r, (byte) 'A');
int score = s.getSummarizedPhredScore();
Assert.assertEquals(5, score);
}
@Test
public void testMode () {
char [] b = {'A', 'A', 'T', 'A', 'A', 'A', 'A'};
byte [] bases = getBases(b);
byte [] qualities = {20, 30, 10, 20, 25, 25, 25};
SummarizeUMIBaseQualities s = new SummarizeUMIBaseQualities(bases, qualities);
int value = s.getSummarizedPhreadScoreByMode();
Assert.assertSame(25, value);
}
private byte [] getBases (final char [] bases) {
byte [] result = new byte [bases.length];
StringUtil.charsToBytes(bases, 0, bases.length, result, 0);
retu
```
<Overlap Ratio: 0.9773013871374527>

---

--- 364 --
Question ID: 8eaa37d9cc5cfaa3796e11223cb01e3f3e94329e_0
Original Code:
```
@ChannelHandler.Sharable
public class ConnectionCounter extends ChannelInboundHandlerAdapter {
    private final AtomicInteger connections;
    private final AtomicLong totalConnections;

    public ConnectionCounter(AtomicInteger connections, AtomicLong totalConnections) {
        this.connections = connections;
        this.totalConnections = totalConnections;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        connections.incrementAndGet();
        totalConnections.incrementAndGet();
        ctx.channel().closeFuture().addListener(f -> connections.decrementAndGet());

        super.channelActive(ctx);
    }

    public int getConnectionCount() {
        return connections.get();
    }

    public long getTotalConnections() {
        return totalConnections.get();
    }
}
```


Overlapping Code:
```
nCounter extends ChannelInboundHandlerAdapter {
private final AtomicInteger connections;
private final AtomicLong totalConnections;
public ConnectionCounter(AtomicInteger connections, AtomicLong totalConnections) {
this.connections = connections;
this.totalConnections = totalConnections;
}
@Override
public void channelActive(ChannelHandlerContext ctx) throws Exception {
connections.incrementAndGet();
totalConnections.incrementAndGet();
ctx.channel().closeFuture().addListener(f -> connections.decrementAndGet());
super.channelActive(ctx);
}
public int getConnectionCount() {
return connections.get();
}
public long getTotalConnections() {
return totalConnection
```
<Overlap Ratio: 0.9185082872928176>

---

--- 365 --
Question ID: 04fcbab2b88b36ec9855fcaf98a48bdd402cce18_0
Original Code:
```
public class PemEncrypt{
	static {
		if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
			Security.addProvider(new BouncyCastleProvider());
		}
	}
	/**
	 * Convert plain private key to PEM format and save to disk
	 */
    public static String storePrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums,
    		String destinationDirectory) throws Exception{
		CryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);
    	String encryptPkey = encryptPrivateKey(privateKey, eccTypeEnums);
    	String fileName = cryptoKeyPair.getAddress() + KeyFileTypeEnums.PEM_FILE.getKeyFilePostfix();
		return storePrivateKey(encryptPkey, fileName, destinationDirectory);
    }

	public static String storePrivateKey(String encryptKey,
										 String fileName, String destinationDirectory) throws Exception{
		String filePath = FileOperationUtils.generateFilePath(
				fileName,
				destinationDirectory);
		FileOperationUtils.writeFile(filePath, encryptKey);
		return filePath;
	}
    /**
     * Encrypt private key
     * @param privateKey
     * @param eccTypeEnums
     * @return Encrypted data
     * @throws IOException
     */
    public static String encryptPrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums) 
    		throws Exception {
       	CryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);
		BigInteger key = new BigInteger(1, Numeric.hexStringToByteArray(cryptoKeyPair.getHexPrivateKey()));

        //1. Encapsulate curve meta info and private key bytes in PKCS#8 format
    	ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(eccTypeEnums.getEccName());
    	X962Parameters params = new X962Parameters(curveOid);
    	ECPrivateKey keyStructure = new ECPrivateKey(256, key,
				new DERBitString(Numeric.hexStringToByteArray(cryptoKeyPair.getHexPublicKey())),
				null);
    	PrivateKeyInfo privateKeyInfo = new PrivateKeyInfo(
    				new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params),
    				keyStructure);
    		
    	//2. Serialize the private key data to output stream
    	ByteArrayOutputStream bos = new ByteArrayOutputStream();
        PemWriter w = new PemWriter (new OutputStreamWriter(bos));
    	try {
    	    ASN1Object o = (ASN1Object) privateKeyInfo.toASN1Primitive();
    	    w.writeObject (new PemObject ("PRIVATE KEY", o.getEncoded("DER")));
    	    w.flush();
    	    //3. Gather result and return.
    	    return new String(bos.toByteArray());
    	}
    	finally {
    		try {
    			if(w != null){
    			    w.close();
    			}
    		}
    		catch (Exception e) {
			}
		}
    }

    public static DecryptResult decryptFully(String encryptedKey) throws Exception{
		PemReader pemReader = new PemReader(new StringReader(encryptedKey));
		PemObject pemObject =pemReader.readPemObject();
		try {
			PKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());
			KeyFactory keyFacotry = KeyFactory.getInstance("EC", BouncyCastleProvider.PROVIDER_NAME);
			PrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);
			BCECPrivateKey k = (BCECPrivateKey)privateKey;
			byte[] rawkey = Numeric.toBytesPadded(k.getD(), 32);
			String curve = KeyUtils.getCurve(k);
			return new DecryptResult(rawkey, curve);
		}
		finally {
			try {
				if(pemReader != null){
					pemReader.close();
				}
			}
			catch (Exception e) {
			}
		}
	}
    /**
     * Decrypt encrypt key
     * @param encryptPrivateKey
     * @return
     * @throws IOException
     */
	public static byte[] decryptPrivateKey(String encryptPrivateKey) throws Exception{
		return decryptPrivateKey(new StringReader(encryptPrivateKey));
    }   
	
	/**
	 * Decrypt encrypt key from pem file
	 * @param filePath
	 * @return
	 * @throws IOException
	 */
	public static byte[] decryptPrivateKeyByFile(String filePath) 
			throws Exception{
	    FileInputStream fIn = null;
	    try {
	    	fIn = new FileInputStream(filePath);
	    	return decryptPrivateKey(new InputStreamReader(fIn));
	    }
	    finally {
    		try {
    			if(fIn != null) {
    				fIn.close();
    			}
    		}
    		catch (Exception e) {
			}
		}
    }
	
	private static byte[] decryptPrivateKey(Reader reader) throws Exception {
		PemReader pemReader = new PemReader(reader);
		PemObject pemObject =pemReader.readPemObject();
	    try {
			PKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(pemObject.getContent());
			KeyFactory keyFacotry = KeyFactory.getInstance("EC", BouncyCastleProvider.PROVIDER_NAME);

			PrivateKey privateKey =  keyFacotry.generatePrivate(encodedKeySpec);
			BCECPrivateKey bcecPrivateKey = (BCECPrivateKey)privateKey;
		    return Numeric.toBytesPadded(bcecPrivateKey.getD(),32);
	    }
	    finally {
    		try {
    			if(pemReader != null){
					pemReader.close();
    			}
    		}
    		catch (Exception e) {
			}
		}
	}
}
```


Overlapping Code:
```
static {
if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
Security.addProvider(new BouncyCastleProvider());
}
}
/**
* Convert plain private key to PEM format and save to disk
*/
public static String storePrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums,
String destinationDirectory) throws Exception{
CryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);
String encryptPkey = encryptPrivateKey(privateKey, eccTypeEnums);
String fileName = cryptoKeyPair.getAddress() + KeyFileTypeEnums.PEM_FILE.getKeyFilePostfix();
return storePrivateKey(encryptPkey, fileName, destinationDirectory);
}
public static String storePrivateKey(String encryptKey,
String fileName, String destinationDirectory) throws Exception{
String filePath = FileOperationUtils.generateFilePath(
fileName,
destinationDirectory);
FileOperationUtils.writeFile(filePath, encryptKey);
return filePath;
}
/**
* Encrypt private key
* @param privateKey
* @param eccTypeEnums
* @return Encrypted data
* @throws IOException
*/
public static String encryptPrivateKey(byte[] privateKey, EccTypeEnums eccTypeEnums) 
throws Exception {
CryptoKeyPair cryptoKeyPair = KeyUtils.getCryptKeyPair(privateKey, eccTypeEnums);
BigInteger key = new BigInteger(1, Numeric.hexStringToByteArray(cryptoKeyPair.getHexPrivateKey()));
//1. Encapsulate curve meta info and private key bytes in PKCS#8 format
ASN1ObjectIdentifier curveOid = ECUtil.getNamedCurveOid(eccTypeEnums.getEccName());
X962Parameters params = new X962Parameters(curveOid);
ECPrivateKey keyStructure = new ECPrivateKey(256, key,
new DERBitString(Numeric.hexStringToByteArray(cryptoKeyPair.getHexPublicKey())),
null);
PrivateKeyInfo privateKeyInfo = new PrivateKeyInfo(
new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, params),
keyStructure);

//2. Serialize the private key data to output stream
ByteArrayOutputStream bos = new ByteArrayOutputStream();
PemWriter w = new PemWriter (new OutputStreamWriter(bos));
try {
ASN1Object o = (ASN1Object) privateKeyInfo.toASN1Primitive();
w.writeObject (new PemObject ("PRIVATE KEY", o.getEncoded("DER")));
w.flush();
//3. Gather result and return.
return new String(bos.toByteArray());
}
```
<Overlap Ratio: 0.9852481001341081>

---

--- 366 --
Question ID: 27b424150d3bd895974c0c7600095874e1077bf9_0
Original Code:
```
class PurgeTask extends BukkitRunnable {

    //how many players we should check for each tick
    private static final int INTERVAL_CHECK = 5;

    private final PurgeService purgeService;
    private final PermissionsManager permissionsManager;
    private final UUID sender;
    private final Set<String> toPurge;

    private final OfflinePlayer[] offlinePlayers;
    private final int totalPurgeCount;

    private int currentPage = 0;

    /**
     * Constructor.
     *
     * @param service the purge service
     * @param permissionsManager the permissions manager
     * @param sender the sender who initiated the purge, or null
     * @param toPurge lowercase names to purge
     * @param offlinePlayers offline players to map to the names
     */
    PurgeTask(PurgeService service, PermissionsManager permissionsManager, CommandSender sender,
              Set<String> toPurge, OfflinePlayer[] offlinePlayers) {
        this.purgeService = service;
        this.permissionsManager = permissionsManager;

        if (sender instanceof Player) {
            this.sender = ((Player) sender).getUniqueId();
        } else {
            this.sender = null;
        }

        this.toPurge = toPurge;
        this.totalPurgeCount = toPurge.size();
        this.offlinePlayers = offlinePlayers;
    }

    @Override
    public void run() {
        if (toPurge.isEmpty()) {
            //everything was removed
            finish();
            return;
        }

        Set<OfflinePlayer> playerPortion = new HashSet<>(INTERVAL_CHECK);
        Set<String> namePortion = new HashSet<>(INTERVAL_CHECK);
        for (int i = 0; i < INTERVAL_CHECK; i++) {
            int nextPosition = (currentPage * INTERVAL_CHECK) + i;
            if (offlinePlayers.length <= nextPosition) {
                //no more offline players on this page
                break;
            }

            OfflinePlayer offlinePlayer = offlinePlayers[nextPosition];
            if (offlinePlayer.getName() != null && toPurge.remove(offlinePlayer.getName().toLowerCase())) {
                try {
                    permissionsManager.loadUserData(offlinePlayer.getUniqueId());
                } catch (NoSuchMethodError e) {
                    permissionsManager.loadUserData(offlinePlayer.getName());
                }
                if (!permissionsManager.hasPermissionOffline(offlinePlayer, PlayerStatePermission.BYPASS_PURGE)) {
                    playerPortion.add(offlinePlayer);
                    namePortion.add(offlinePlayer.getName());
                }
            }
        }

        if (!toPurge.isEmpty() && playerPortion.isEmpty()) {
            ConsoleLogger.info("Finished lookup of offlinePlayers. Begin looking purging player names only");

            //we went through all offlineplayers but there are still names remaining
            for (String name : toPurge) {
                if (!permissionsManager.hasPermissionOffline(name, PlayerStatePermission.BYPASS_PURGE)) {
                    namePortion.add(name);
                }
            }
            toPurge.clear();
        }

        currentPage++;
        purgeService.executePurge(playerPortion, namePortion);
        if (currentPage % 20 == 0) {
            int completed = totalPurgeCount - toPurge.size();
            sendMessage("[AuthMe] Purge progress " + completed + '/' + totalPurgeCount);
        }
    }

    private void finish() {
        cancel();

        // Show a status message
        sendMessage(ChatColor.GREEN + "[AuthMe] Database has been purged successfully");

        ConsoleLogger.info("Purge finished!");
        purgeService.setPurging(false);
    }

    private void sendMessage(String message) {
        if (sender == null) {
            Bukkit.getConsoleSender().sendMessage(message);
        } else {
            Player player = Bukkit.getPlayer(sender);
            if (player != null) {
                player.sendMessage(message);
            }
        }
    }
}
```


Overlapping Code:
```
 {
//how many players we should check for each tick
private static final int INTERVAL_CHECK = 5;
private final PurgeService purgeService;
private final PermissionsManager permissionsManager;
private final UUID sender;
private final Set<String> toPurge;
private final OfflinePlayer[] offlinePlayers;
private final int totalPurgeCount;
private int currentPage = 0;
/**
* Constructor.
*
* @param service the purge service
* @param permissionsManager the permissions manager
* @param sender the sender who initiated the purge, or null
* @param toPurge lowercase names to purge
* @param offlinePlayers offline players to map to the names
*/
PurgeTask(PurgeService service, PermissionsManager permissionsManager, CommandSender sender,
Set<String> toPurge, OfflinePlayer[] offlinePlayers) {
this.purgeService = service;
this.permissionsManager = permissionsManager;
if (sender instanceof Player) {
this.sender = ((Player) sender).getUniqueId();
} else {
this.sender = null;
}
this.toPurge = toPurge;
this.totalPurgeCount = toPurge.size();
this.offlinePlayers = offlinePlayers;
}
@Override
public void run() {
if (toPurge.isEmpty()) {
//everything was removed
finish();
return;
}
Set<OfflinePlayer> playerPortion = new HashSet<>(INTERVAL_CHECK);
Set<String> namePortion = new HashSet<>(INTERVAL_CHECK);
for (int i = 0; i < INTERVAL_CHECK; i++) {
int nextPosition = (currentPage * INTERVAL_CHECK) + i;
if (offlinePlayers.length <= nextPosition) {
//no more offline players on this page
break;
}
OfflinePlayer offlinePlayer = offlinePlayers[nextPosition];
if (offlinePlayer.getName() != null && toPurge.remove(offlinePlayer.getName().toLowerCase())) {
try {
permissionsManager.loadUserData(offlinePlayer.getUniqueId());
} catch (NoSuchMethodError e) {
permissionsManager.loadUserData(offlinePlayer.getName());
}
if (!permissionsManager.hasPermissionOffline(offlinePlayer, PlayerStatePermission.BYPASS_PURGE)) {
```
<Overlap Ratio: 0.9600808489135927>

---

--- 367 --
Question ID: 96e9c7841997d0854c2b2f57244a45114f6d2b58_1
Original Code:
```
class MyClassLoader extends ClassLoader {

  @Override
  public Class<?> loadClass(String name) throws ClassNotFoundException {
    if (name.contains("Evil")) {
      return findClass(name);
    }
    return super.loadClass(name);
  }

  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
    File file = new File(
        this.getResource(".").getPath() + "/" + name.replace(".", "/") + ".class");
    if (file.exists()) {
      try {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        BufferedInputStream bufferedInputStream = new BufferedInputStream(
            new FileInputStream(file));
        byte[] bytes = new byte[1024];
        int size;
        while ((size = bufferedInputStream.read(bytes)) != -1) {
          byteArrayOutputStream.write(bytes, 0, size);
        }
        PermissionCollection pc = new Permissions();
        pc.add(new AllPermission());
        ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null,
            (Certificate[]) null), pc, this, null);
        Class<?> clazz = this.defineClass(name, byteArrayOutputStream.toByteArray(), 0,
            byteArrayOutputStream.size(), protectionDomain);
        return clazz;
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    return super.findClass(name);
  }
}
```


Overlapping Code:
```
ass MyClassLoader extends ClassLoader {
@Override
public Class<?> loadClass(String name) throws ClassNotFoundException {
if (name.contains("Evil")) {
return findClass(name);
}
return super.loadClass(name);
}
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
File file = new File(
this.getResource(".").getPath() + "/" + name.replace(".", "/") + ".class");
if (file.exists()) {
try {
ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
BufferedInputStream bufferedInputStream = new BufferedInputStream(
new FileInputStream(file));
byte[] bytes = new byte[1024];
int size;
while ((size = bufferedInputStream.read(bytes)) != -1) {
byteArrayOutputStream.write(bytes, 0, size);
}
PermissionCollection pc = new Permissions();
pc.add(new AllPermission());
ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null,
(Certificate[]) null), pc, this, null);
Class<?> clazz = this.defineClass(name, byteArrayOutputStream.toByteArray(), 0,
byteArrayOutputStream.size(), protectionDomain);
return clazz;
} catch (Exception e) {
e.printStackTrace();
}
}
return super.findClass
```
<Overlap Ratio: 0.9887054735013032>

---

--- 368 --
Question ID: 5c8c53208954b68f74dc57980015e9310165dec1_0
Original Code:
```
class SudokuBacktracking {
    // Driver code
    public static void main(String[] args) {
        int[][] grid = {{ 0, 7, 0, 0, 0, 0, 0, 0, 9 },
                        { 5, 1, 0, 4, 2, 0, 6, 0, 0 },
                        { 0, 8, 0, 3, 0, 0, 7, 0, 0 },
                        { 0, 0, 8, 0, 0, 1, 3, 7, 0 },
                        { 0, 2, 3, 0, 8, 0, 0, 4, 0 },
                        { 4, 0, 0, 9, 0, 0, 1, 0, 0 },
                        { 9, 6, 2, 8, 0, 0, 0, 3, 0 },
                        { 0, 0, 0, 0, 1, 0, 4, 0, 0 },
                        { 7, 0, 0, 2, 0, 3, 0, 9, 6 }};
        sudokuSolver(grid,0,0);
    }

    // This function is used to print the answer grid.
    public static void display(int[][] grid) {
        for(int a=0;a<grid.length;a++) {
            for(int b=0;b<grid[0].length;b++) {
                System.out.print(grid[a][b] + " ");
            }
            System.out.println();
        }
    }

    /* This function checks if a particular value from 1 to 9 can 
        be placed in the particular cell. If the value can be placed
        then it checks for the next column in the specific row */
    public static void sudokuSolver(int[][] grid, int row, int col) {
        // This is base condition, when all the cells of the grid are filled successfully.
        if(row == grid.length-1 && col == grid[0].length) {
            display(grid);
            System.out.println();
            return;
        }
        /* If all the columns of a particular row are filled successfully
            then the row is incremented and column is set to 0. */
        if(col == grid[0].length) {
            row = row + 1;
            col = 0;
        }
        if(grid[row][col] != 0) sudokuSolver(grid,row,col+1);
        else {
            for (int val=1;val<=9;val++) {
                if(isSafeForSudoku(grid,row,col,val)) {
                    grid[row][col] = val;
                    sudokuSolver(grid,row,col+1);
                    grid[row][col] = 0;
                }
            }
        }
    }

    /* This function checks if a particular value from 1 to 9 can be placed 
        in grid[row][col]. It checks for entire row, entire column and 
        the corresponding 3x3 box */
    public static boolean isSafeForSudoku(int[][] grid, int row, int col, int val) {
        // checking entire column
        for (int k=0;k<grid.length;k++) {
            if (grid[k][col] == val) return false;
        }
        // checking entire row
        for (int k=0;k<grid[0].length;k++) {
            if(grid[row][k] == val) return false;
        }
        // checking 3x3 box
        row = row - (row % 3);    // gives the starting index of row of particular 3x3 box
        col = col - (col % 3);    // gives the starting index of col of particular 3x3 box
        for(int k=0;k<3;k++) {
            for(int l=0;l<3;l++) {
                if(grid[row+k][col+l] == val) {
                    return false;
                }
            }
        }
        return true;
    }
    
}
```


Overlapping Code:
```
 {
// Driver code
public static void main(String[] args) {
int[][] grid = {{ 0, 7, 0, 0, 0, 0, 0, 0, 9 },
{ 5, 1, 0, 4, 2, 0, 6, 0, 0 },
{ 0, 8, 0, 3, 0, 0, 7, 0, 0 },
{ 0, 0, 8, 0, 0, 1, 3, 7, 0 },
{ 0, 2, 3, 0, 8, 0, 0, 4, 0 },
{ 4, 0, 0, 9, 0, 0, 1, 0, 0 },
{ 9, 6, 2, 8, 0, 0, 0, 3, 0 },
{ 0, 0, 0, 0, 1, 0, 4, 0, 0 },
{ 7, 0, 0, 2, 0, 3, 0, 9, 6 }};
sudokuSolver(grid,0,0);
}
// This function is used to print the answer grid.
public static void display(int[][] grid) {
for(int a=0;a<grid.length;a++) {
for(int b=0;b<grid[0].length;b++) {
System.out.print(grid[a][b] + " ");
}
System.out.println();
}
}
/* This function checks if a particular value from 1 to 9 can 
be placed in the particular cell. If the value can be placed
then it checks for the next column in the specific row */
public static void sudokuSolver(int[][] grid, int row, int col) {
// This is base condition, when all the cells of the grid are filled successfully.
if(row == grid.length-1 && col == grid[0].length) {
display(grid);
System.out.println();
return;
}
/* If all the columns of a particular row are filled successfully
then the row is incremented and column is set to 0. */
if(col == grid[0].length) {
row = row + 1;
col = 0;
}
if(grid[row][col] != 0) sudokuSolver(grid,row,col+1);
else {
for (int val=1;val<=9;val++) {
if(isSafeForSudoku(grid,row,col,val)) {
grid[row][col] = val;
sudokuSolver(grid,row,col+1);
grid[row][col] = 0;
}
}
}
}
/* This function checks if a particular value from 1 to 9 can be placed 
in grid[row][col]. It checks for entire row, entire column and 
the corresponding 3x3 box */
public static boolean isSafeForSudoku(int[][] grid, int row, int col, int val) {
// checking entire column
for (int k=0;k<grid.length;k++) {
if (grid[k][col] == val) return false;
}

```
<Overlap Ratio: 0.9677947598253275>

---

--- 369 --
Question ID: 0c3eba503fb8044e681ad301af929a519c1f7b16_0
Original Code:
```
public class CCC_2014_J5_S2 {

  public static Scanner scan = new Scanner(System.in);

  public static void main(String[] args) {
    int n = scan.nextInt();
    scan.nextLine();
    ArrayList<String> students1 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(" ")));
    ArrayList<String> students2 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(" ")));

  main:
    for (int x = 0; x < n; x++) {
      for (int y = 0; y < n; y++) {
        if (y == x)
          continue;
        if (students1.get(x).equals(students2.get(y)) && students2.get(x).equals(students1.get(y)))
          continue main;
      }
      System.out.println("bad");
      System.exit(0);
    }
    System.out.println("good");
  }
}
```


Overlapping Code:
```
lic class CCC_2014_J5_S2 {
public static Scanner scan = new Scanner(System.in);
public static void main(String[] args) {
int n = scan.nextInt();
scan.nextLine();
ArrayList<String> students1 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(" ")));
ArrayList<String> students2 = new ArrayList<String>(Arrays.asList(scan.nextLine().split(" ")));
main:
for (int x = 0; x < n; x++) {
for (int y = 0; y < n; y++) {
if (y == x)
continue;
if (students1.get(x).equals(students2.get(y)) && students2.get(x).equals(students1.get(y)))
continue main;
}
System.out.println("bad");
System.exit(0);
}
Syst
```
<Overlap Ratio: 0.9523809523809523>

---

--- 370 --
Question ID: 3cb1672ac4068fdc3bdb136a6273f1daeba3a1a4_0
Original Code:
```
public class IsSquare {

	public static void main(String[] args) {
		System.out.println("É " + isSquare(4));
	}

	public static boolean isSquare(int num) {
		if(num == 1 || num == 0)
			return true;
		double square = num / 2;
		double c = square;

		do {
			c = square;
			square = (c + (num / c)) / 2;
		} while ((c - square) != 0);

		if(square*square == num) 
			return true;
		return false;
	}
}
```


Overlapping Code:
```
public class IsSquare {
public static void main(String[] args) {
System.out.println("É " + isSquare(4));
}
public static boolean isSquare(int num) {
if(num == 1 || num == 0)
return true;
double square = num / 2;
double c = square;
do {
c = square;
square = (c + (num / c)) / 2;
} while ((c - square) != 0);
if(square*square == num) 
return true;
retu
```
<Overlap Ratio: 0.9641873278236914>

---

--- 371 --
Question ID: 74a486d9c1cc3db621e7ca7e8b915d6c21347da8_0
Original Code:
```
public class LogPolicySupport {
	/**
	 * Get the methods that should be mocked.
	 * 
	 * @param fullyQualifiedClassName
	 *            The fully-qualified name to the class that contains the
	 *            method.
	 * @param methodName
	 *            The name of the method that should be mocked.
	 * @param logFramework
	 *            The log framework that should be printed if the class
	 *            {@code fullyQualifiedClassName} cannot be found.
	 * @return The array of {@link Method}'s that should be mocked.
	 */
	public Method[] getLoggerMethods(String fullyQualifiedClassName, String methodName, String logFramework) {
		try {
			return Whitebox.getMethods(getType(fullyQualifiedClassName, logFramework), methodName);
		} catch (RuntimeException e) {
			throw e;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Get the class type representing the fully-qualified name.
	 * 
	 * @param name
	 *            The fully-qualified name of a class to get.
	 * @param logFramework
	 *            The log framework that should be printed if the class cannot
	 *            be found.
	 * @return The class representing the fully-qualified name.
	 * @throws Exception
	 *             If something unexpected goes wrong, for example if the class
	 *             cannot be found.
	 */
	public Class<?> getType(String name, String logFramework) throws Exception {
		final Class<?> loggerType;
		try {
			loggerType = Class.forName(name);
		} catch (ClassNotFoundException e) {
			final String message = String.format("Cannot find %s in the classpath which the %s policy requires.", logFramework, getClass()
					.getSimpleName());
			throw new RuntimeException(message, e);
		}
		return loggerType;
	}
}
```


Overlapping Code:
```
s LogPolicySupport {
/**
* Get the methods that should be mocked.
* 
* @param fullyQualifiedClassName
* The fully-qualified name to the class that contains the
* method.
* @param methodName
* The name of the method that should be mocked.
* @param logFramework
* The log framework that should be printed if the class
* {@code fullyQualifiedClassName} cannot be found.
* @return The array of {@link Method}'s that should be mocked.
*/
public Method[] getLoggerMethods(String fullyQualifiedClassName, String methodName, String logFramework) {
try {
return Whitebox.getMethods(getType(fullyQualifiedClassName, logFramework), methodName);
} catch (RuntimeException e) {
throw e;
} catch (Exception e) {
throw new RuntimeException(e);
}
}
/**
* Get the class type representing the fully-qualified name.
* 
* @param name
* The fully-qualified name of a class to get.
* @param logFramework
* The log framework that should be printed if the class cannot
* be found.
* @return The class representing the fully-qualified name.
* @throws Exception
* If something unexpected goes wrong, for example if the class
* cannot be found.
*/
public Class<?> getType(String name, String logFramework) throws Exception {
final Class<?> loggerType;
try {
loggerType = Class.forName(name);
} catch (ClassNotFoundException e) {
final String message = String.format("Cannot find %s in the classpath which the %s policy requires.", logFramework, getClass()
.getSimpleName());
throw new RuntimeException(message, e);
}
return log
```
<Overlap Ratio: 0.9848982271831911>

---

--- 372 --
Question ID: ff120e95581c5ddc211dfec12cd1d846bc4df051_0
Original Code:
```
public class ConcatStrings {
  public static void main(String[] args) {
    String a = "hello";
    String b = "world";
    String c = a + " " + b;
    String d = "" + 7 + 5.43 + -2L + 3.14f + "\n";
    System.out.println(a);
    System.out.println(b);
    System.out.println(c);
    System.out.println(d);
  }
}
```


Overlapping Code:
```
Strings {
public static void main(String[] args) {
String a = "hello";
String b = "world";
String c = a + " " + b;
String d = "" + 7 + 5.43 + -2L + 3.14f + "\n";
System.out.println(a);
System.out.println(b);
System.out.println(c);
System.out.println(d);
}
}
```
<Overlap Ratio: 0.9311594202898551>

---

--- 373 --
Question ID: c74136467b4366bb3bcce2faafdd1712def913a2_0
Original Code:
```
public class PartFactoryProvider extends GridStoreFactoryProvider
implements GridStoreFactoryProvider.ChainProvidable,
Extensibles.AsFactoryProvidable {

	@Override
	public GridStoreFactory getFactory() {
		return getFactory(
				Collections.<Class<?>>emptySet(),
				Collections.<Class<?>>emptySet());
	}

	@Override
	public GridStoreFactory getFactory(
			Set<Class<?>> chainProviderClasses,
			Set<Class<?>> visitedProviderClasses) {
		final Class<?> thisClass = PartFactoryProvider.class;

		final Set<Class<?>> exclusiveClasses = new HashSet<Class<?>>();
		exclusiveClasses.add(thisClass);
		exclusiveClasses.addAll(chainProviderClasses);
		exclusiveClasses.addAll(visitedProviderClasses);

		final List<ChainProvidable> providerList = ServiceProviderUtils.load(
				GridStoreFactoryProvider.class,
				ChainProvidable.class,
				ServiceProviderUtils.listClassLoaders(thisClass),
				exclusiveClasses);

		if (!providerList.isEmpty()) {
			final Set<Class<?>> nextVisitedClasses = new HashSet<Class<?>>();
			nextVisitedClasses.add(thisClass);
			nextVisitedClasses.addAll(visitedProviderClasses);

			return providerList.get(0).getFactory(
					chainProviderClasses, nextVisitedClasses);
		}

		return new PartFactory(
				ServiceProviderUtils.mergeChainClasses(
						chainProviderClasses, PartFactoryProvider.class),
				visitedProviderClasses,
				getBaseProvider());
	}

	@Override
	public Extensibles.AsStoreFactory getExtensibleFactory(
			Set<Class<?>> chainProviderClasses,
			Set<Class<?>> visitedProviderClasses) {
		final PartFactory base = new PartFactory(
				ServiceProviderUtils.mergeChainClasses(
						chainProviderClasses, PartFactoryProvider.class),
				visitedProviderClasses,
				getBaseProvider());
		return new PartFactory.ExtensibleFactory(base);
	}

	private static Extensibles.AsFactoryProvidable getBaseProvider() {
		return new SubnetGridStoreFactoryProvider();
	}

}
```


Overlapping Code:
```
ublic class PartFactoryProvider extends GridStoreFactoryProvider
implements GridStoreFactoryProvider.ChainProvidable,
Extensibles.AsFactoryProvidable {
@Override
public GridStoreFactory getFactory() {
return getFactory(
Collections.<Class<?>>emptySet(),
Collections.<Class<?>>emptySet());
}
@Override
public GridStoreFactory getFactory(
Set<Class<?>> chainProviderClasses,
Set<Class<?>> visitedProviderClasses) {
final Class<?> thisClass = PartFactoryProvider.class;
final Set<Class<?>> exclusiveClasses = new HashSet<Class<?>>();
exclusiveClasses.add(thisClass);
exclusiveClasses.addAll(chainProviderClasses);
exclusiveClasses.addAll(visitedProviderClasses);
final List<ChainProvidable> providerList = ServiceProviderUtils.load(
GridStoreFactoryProvider.class,
ChainProvidable.class,
ServiceProviderUtils.listClassLoaders(thisClass),
exclusiveClasses);
if (!providerList.isEmpty()) {
final Set<Class<?>> nextVisitedClasses = new HashSet<Class<?>>();
nextVisitedClasses.add(thisClass);
nextVisitedClasses.addAll(visitedProviderClasses);
return providerList.get(0).getFactory(
chainProviderClasses, nextVisitedClasses);
}
return new PartFactory(
ServiceProviderUtils.mergeChainClasses(
chainProviderClasses, PartFactoryProvider.class),
visitedProviderClasses,
getBaseProvider());
}
@Override
public Extensibles.AsStoreFactory getExtensibleFactory(
Set<Class<?>> chainProviderClasses,
Set<Class<?>> visitedProviderClasses) {
final PartFactory base = new PartFactory(
ServiceProviderUtils.mergeChainClasses(
chainProviderClasses, PartFactoryProvider.class),
visitedProviderClasses,
getBaseProvider());
return new PartFactory.ExtensibleFactory(base);
}
private static Extensibles.AsFactoryProvidable getBaseProvider() {
return new SubnetGridStoreFactoryP
```
<Overlap Ratio: 0.9915014164305949>

---

--- 374 --
Question ID: b417ebe95df69faf5bdcc32a6ba96e48adb4e5f2_0
Original Code:
```
class ByteTokenizerTest {

    @Test
    void compact() {
        ByteTokenizer tokenizer = new ByteTokenizer();
        tokenizer.add(ByteBuffer.wrap("hello world".getBytes()));
        Assertions.assertArrayEquals("hello".getBytes(), tokenizer.next(" ".getBytes()));
        Assertions.assertEquals(11, tokenizer.capacity());
        Assertions.assertEquals(5, tokenizer.remaining());
        tokenizer.compact();
        Assertions.assertEquals(5, tokenizer.capacity());
        Assertions.assertEquals(5, tokenizer.remaining());
        Assertions.assertArrayEquals("world".getBytes(), tokenizer.next(5));
        tokenizer.compact();
        Assertions.assertEquals(0, tokenizer.capacity());
        Assertions.assertEquals(0, tokenizer.remaining());
    }

    @Test
    void expandingArray() {
        ByteTokenizer tokenizer = new ByteTokenizer();
        Assertions.assertEquals(0, tokenizer.remaining());
        Assertions.assertEquals(0, tokenizer.size());
        Assertions.assertEquals(0, tokenizer.capacity());
        addAndAssert(tokenizer, "a", 1, 1, 1);
        addAndAssert(tokenizer, "b", 2, 2, 2);
        addAndAssert(tokenizer, "c", 3, 3, 4);
        addAndAssert(tokenizer, "xxxxxxx", 10, 10, 10);
    }

    static void addAndAssert(ByteTokenizer tokenizer, String data, int remaining, int size, int capacity) {
        tokenizer.add(ByteBuffer.wrap(data.getBytes()));
        Assertions.assertEquals(remaining, tokenizer.remaining());
        Assertions.assertEquals(size, tokenizer.size());
        Assertions.assertEquals(capacity, tokenizer.capacity());
    }

    @Test
    void noBytes() {
        ByteTokenizer tokenizer = new ByteTokenizer();
        Assertions.assertEquals(0, tokenizer.remaining());
        Assertions.assertNull(tokenizer.next(1));
        Assertions.assertNull(tokenizer.next(" ".getBytes()));
    }

    @Test
    void nextWithLength() {
        ByteTokenizer tokenizer = new ByteTokenizer();
        tokenizer.add(ByteBuffer.wrap("hello".getBytes()));
        Assertions.assertArrayEquals("h".getBytes(), tokenizer.next(1));
        Assertions.assertArrayEquals("ello".getBytes(), tokenizer.next(4));
        Assertions.assertNull(tokenizer.next(1));
    }

    @Test
    void nextWithDelimiter() {
        ByteTokenizer tokenizer = new ByteTokenizer();
        tokenizer.add(ByteBuffer.wrap("hello".getBytes()));
        tokenizer.add(ByteBuffer.wrap(" ".getBytes()));
        tokenizer.add(ByteBuffer.wrap("world".getBytes()));
        tokenizer.add(ByteBuffer.wrap("\r\n".getBytes()));
        Assertions.assertArrayEquals("hello".getBytes(), tokenizer.next(" ".getBytes()));
        Assertions.assertNull(tokenizer.next(" ".getBytes()));
        Assertions.assertArrayEquals("world".getBytes(), tokenizer.next("\r\n".getBytes()));
        Assertions.assertNull(tokenizer.next("\r\n".getBytes()));
    }

}
```


Overlapping Code:
```
kenizerTest {
@Test
void compact() {
ByteTokenizer tokenizer = new ByteTokenizer();
tokenizer.add(ByteBuffer.wrap("hello world".getBytes()));
Assertions.assertArrayEquals("hello".getBytes(), tokenizer.next(" ".getBytes()));
Assertions.assertEquals(11, tokenizer.capacity());
Assertions.assertEquals(5, tokenizer.remaining());
tokenizer.compact();
Assertions.assertEquals(5, tokenizer.capacity());
Assertions.assertEquals(5, tokenizer.remaining());
Assertions.assertArrayEquals("world".getBytes(), tokenizer.next(5));
tokenizer.compact();
Assertions.assertEquals(0, tokenizer.capacity());
Assertions.assertEquals(0, tokenizer.remaining());
}
@Test
void expandingArray() {
ByteTokenizer tokenizer = new ByteTokenizer();
Assertions.assertEquals(0, tokenizer.remaining());
Assertions.assertEquals(0, tokenizer.size());
Assertions.assertEquals(0, tokenizer.capacity());
addAndAssert(tokenizer, "a", 1, 1, 1);
addAndAssert(tokenizer, "b", 2, 2, 2);
addAndAssert(tokenizer, "c", 3, 3, 4);
addAndAssert(tokenizer, "xxxxxxx", 10, 10, 10);
}
static void addAndAssert(ByteTokenizer tokenizer, String data, int remaining, int size, int capacity) {
tokenizer.add(ByteBuffer.wrap(data.getBytes()));
Assertions.assertEquals(remaining, tokenizer.remaining());
Assertions.assertEquals(size, tokenizer.size());
Assertions.assertEquals(capacity, tokenizer.capacity());
}
@Test
void noBytes() {
ByteTokenizer tokenizer = new ByteTokenizer();
Assertions.assertEquals(0, tokenizer.remaining());
Assertions.assertNull(tokenizer.next(1));
Assertions.assertNull(tokenizer.next(" ".getBytes()));
}
@Test
void nextWithLength() {
ByteTokenizer tokenizer = new ByteTokenizer();
tokenizer.add(ByteBuffer.wrap("hello".getBytes()));
Assertions.assertArrayEquals("h".getBytes(), tokenizer.next(1));
Assertions.assertArrayEquals("ello".getBytes(), tokenizer.next(4));
Assertions.assertNull(tokenizer.next(1));
}
@Test
void nextWithDelimiter() {
ByteTokenizer tokenizer = new ByteTokenizer();
tokenizer.add(ByteBuffer.wrap("hello".getBytes()));
tokenizer.add(ByteBuffer.wrap(" ".getBytes()));
tokenizer.add(ByteBuffer.wrap("world".getB
```
<Overlap Ratio: 0.9882352941176471>

---

--- 375 --
Question ID: 173808021b4d348f18c162c0617b49a566289b7a_0
Original Code:
```
public class FlyingCapEntity extends Entity implements FlyingItemEntity {
	private static final TrackedData<Integer> COLOR = DataTracker.registerData(FlyingCapEntity.class, TrackedDataHandlerRegistry.INTEGER);
	
	// synced
	private ItemStack stack;
	private String throwerId;
	private Vec3d startAngle;
	private Vec3d startPos;
	private boolean leftThrower = false;
	public int ticksAtEnd;
	private PreferredCapSlot preferredSlot;
	// not synced
	@Nullable
	private PlayerEntity thrower;
	
	public FlyingCapEntity(EntityType<FlyingCapEntity> entityType, World world) {
		super(entityType, world);
	}
	
	public FlyingCapEntity(World world, ItemStack itemStack, PlayerEntity thrower, double x, double y, double z, PreferredCapSlot slot) {
		super(BingBingWahoo.FLYING_CAP, world);
		this.setItem(itemStack.copy());
		this.thrower = thrower;
		this.throwerId = thrower.getUuidAsString();
		this.startAngle = thrower.getRotationVec(0).normalize().multiply(0.1);
		setPos(x, y, z);
		this.startPos = getPos();
		this.preferredSlot = slot;
	}
	
	public void sendData(ServerPlayerEntity player) {
		NbtCompound data = new NbtCompound();
		writeCustomDataToNbt(data);
		PacketByteBuf buf = PacketByteBufs.create()
				.writeNbt(data)
				.writeString(getUuidAsString());
		ServerPlayNetworking.send(player, CAP_ENTITY_SPAWN, buf);
	}
	
	@Override
	public void onStartedTrackingBy(ServerPlayerEntity player) {
		super.onStartedTrackingBy(player);
		sendData(player);
	}
	
	@Override
	protected void initDataTracker() {
		dataTracker.startTracking(COLOR, 0xFFFFFF);
	}
	
	public void setItem(ItemStack stack) {
		this.stack = stack;
		if (stack.getItem() instanceof MysteriousCapItem cap) {
			setColor(cap.getColor(stack));
		}
	}
	
	public void setColor(int color) {
		dataTracker.set(COLOR, color);
	}
	
	@Override
	public void readCustomDataFromNbt(NbtCompound nbt) {
		ItemStack stack = ItemStack.fromNbt(nbt.getCompound("Item"));
		setItem(stack);
		this.throwerId = nbt.getString("Thrower");
		this.startAngle = new Vec3d(nbt.getDouble("StartAngleX"), nbt.getDouble("StartAngleY"), nbt.getDouble("StartAngleZ"));
		this.startPos = new Vec3d(nbt.getDouble("StartPosX"), nbt.getDouble("StartPosY"), nbt.getDouble("StartPosZ"));
		this.leftThrower = nbt.getBoolean("LeftThrower");
		this.ticksAtEnd = nbt.getInt("TicksAtEnd");
		this.preferredSlot = PreferredCapSlot.values()[nbt.getInt("PreferredSlot")];
	}
	
	@Override
	public void writeCustomDataToNbt(NbtCompound nbt) {
		nbt.put("Item", getStack().writeNbt(new NbtCompound()));
		nbt.putString("Thrower", throwerId);
		nbt.putDouble("StartAngleX", startAngle.getX());
		nbt.putDouble("StartAngleY", startAngle.getY());
		nbt.putDouble("StartAngleZ", startAngle.getZ());
		nbt.putDouble("StartPosX", startPos.getX());
		nbt.putDouble("StartPosY", startPos.getY());
		nbt.putDouble("StartPosZ", startPos.getZ());
		nbt.putBoolean("LeftThrower", leftThrower);
		nbt.putInt("TicksAtEnd", ticksAtEnd);
		nbt.putInt("PreferredSlot", preferredSlot.ordinal());
	}
	
	@Override
	public void tick() {
		super.tick();
		tryFindThrower();
		tryMove();
		
		if (!world.isClient()) {
			List<Entity> collisions = world.getOtherEntities(this, getBoundingBox().stretch(getVelocity()).expand(1), e -> !e.isSpectator() && e.collides());
			
			if (shouldLeaveThrower(collisions)) {
				leftThrower = true;
			}
			
			for (Entity entity : collisions) {
				if (entity instanceof PlayerEntity thrower) {
					if ((leftThrower || ticksAtEnd != 0) && throwerId.equals(entity.getUuidAsString())) {
						if (!tryReequipCap()) { // set in correct slot
							if (!thrower.giveItemStack(getStack())) { // throw randomly in inventory
								world.spawnEntity(new ItemEntity(world, thrower.getX(), thrower.getY(), thrower.getZ(), getStack())); // drop on ground
							}
						}
						remove(KILLED);
						world.playSound(null,
								thrower.getX(),
								thrower.getY(),
								thrower.getZ(),
								SoundEvents.ENTITY_ITEM_PICKUP,
								SoundCategory.PLAYERS,
								0.2F,
								((thrower.getRandom().nextFloat() - thrower.getRandom().nextFloat()) * 0.7F + 1.0F) * 2.0F
						);
					}
				}
				
				
				if (entity instanceof LivingEntity living && !(entity instanceof PlayerEntity) && thrower instanceof ServerPlayerEntity player) {
					if (Identity.CONFIG.enableSwaps || player.hasPermissionLevel(3)) {
						LivingEntity copy = (LivingEntity) living.getType().create(world);
						if (copy != null) {
							copy.readNbt(living.writeNbt(new NbtCompound()));
							Components.CURRENT_IDENTITY.get(player).setIdentity(copy);
							player.calculateDimensions();
							player.teleport((ServerWorld) world, living.getX(), living.getY(), living.getZ(), living.getYaw(), living.getPitch());
							world.playSound(null, living.getX(), living.getY(), living.getZ(),
									SoundEvents.ENTITY_ENDERMAN_TELEPORT, SoundCategory.PLAYERS, 1, 1);
							NbtCompound captured = new NbtCompound();
							captured.put("Entity", living.writeNbt(new NbtCompound()));
							captured.putString("Type", Registry.ENTITY_TYPE.getId(living.getType()).toString());
							((ServerPlayerEntityExtensions) player).wahoo$setCaptured(captured);
							living.discard();
							ItemStack stack = getStack();
							if (!tryReequipCap()) { // set in correct slot
								if (!player.giveItemStack(stack)) { // throw randomly in inventory
									world.spawnEntity(new ItemEntity(world, player.getX(), player.getY(), player.getZ(), stack)); // drop on ground
								}
							}
							remove(KILLED);
						}
					}
				} else if (entity != thrower && entity instanceof LivingEntity living) {
					living.damage(DamageSource.thrownProjectile(this, thrower), 3);
					ticksAtEnd = 10;
					break;
				}
			}
			
			if (age > 500) kill();
		}
	}
	
	private boolean tryReequipCap() {
		if (thrower != null) {
			ItemStack stack = getStack();
			// first try preferred slot
			if (preferredSlot.shouldEquip(thrower, stack)) {
				preferredSlot.equip(thrower, stack);
				return true;
			}
			
			// then try all slots
			for (PreferredCapSlot slot : PreferredCapSlot.values()) {
				if (slot.shouldEquip(thrower, stack)) {
					slot.shouldEquip(thrower, stack);
					return true;
				}
			}
			
		}
		return false;
	}
	
	private void tryFindThrower() {
		if (thrower == null) {
			for (PlayerEntity player : world.getPlayers()) {
				if (player.getUuidAsString().equals(throwerId)) {
					thrower = player;
				}
			}
		}
	}
	
	private void tryMove() {
		if (thrower != null) {
			Vec3d toMove = Vec3d.ZERO;
			if (ticksAtEnd == 0) {
				double mult = Math.cos(age / 5f) * 10;
				toMove = startAngle.multiply(mult);
				// valley of the cosine wave - slow down as it approaches the end
				ticksAtEnd = mult <= 0 ? 1 : 0;
			} else {
				ticksAtEnd++;
				if (ticksAtEnd > 10) {
					if (thrower != null) {
						Vec3d distance = thrower.getEyePos().subtract(getPos());
						toMove = distance.multiply(0.2);
					}
				}
			}
			
			if (toMove != Vec3d.ZERO) {
				move(MovementType.SELF, toMove);
			}
		}
	}
	
	private boolean shouldLeaveThrower(List<Entity> collisions) {
		for(Entity entity : collisions) {
			if (entity.getUuidAsString().equals(throwerId)) {
				return false;
			}
		}
		
		return true;
	}
	
	@Override
	public boolean collides() {
		return true;
	}
	
	@Override
	public boolean canUsePortals() {
		return false;
	}
	
	@Override
	public void kill() {
		super.kill();
		dropStack(stack.copy());
	}

	@Override
	public ItemStack getStack() {
		return stack;
	}
	
	@Override
	public Packet<?> createSpawnPacket() {
		return new EntitySpawnS2CPacket(this);
	}
	
	public static void spawn(ServerPlayerEntity thrower, ItemStack capStack, PreferredCapSlot preferredSlot) {
		if (capStack != null && capStack.isOf(MYSTERIOUS_CAP)) {
			FlyingCapEntity cap = new FlyingCapEntity(thrower.world, capStack.copy(), thrower, thrower.getX(), thrower.getEyeY() - 0.1, thrower.getZ(), preferredSlot);
			thrower.world.spawnEntity(cap);
		}
	}
}
```


Overlapping Code:
```
Entity implements FlyingItemEntity {
private static final TrackedData<Integer> COLOR = DataTracker.registerData(FlyingCapEntity.class, TrackedDataHandlerRegistry.INTEGER);

// synced
private ItemStack stack;
private String throwerId;
private Vec3d startAngle;
private Vec3d startPos;
private boolean leftThrower = false;
public int ticksAtEnd;
private PreferredCapSlot preferredSlot;
// not synced
@Nullable
private PlayerEntity thrower;

public FlyingCapEntity(EntityType<FlyingCapEntity> entityType, World world) {
super(entityType, world);
}

public FlyingCapEntity(World world, ItemStack itemStack, PlayerEntity thrower, double x, double y, double z, PreferredCapSlot slot) {
super(BingBingWahoo.FLYING_CAP, world);
this.setItem(itemStack.copy());
this.thrower = thrower;
this.throwerId = thrower.getUuidAsString();
this.startAngle = thrower.getRotationVec(0).normalize().multiply(0.1);
setPos(x, y, z);
this.startPos = getPos();
this.preferredSlot = slot;
}

public void sendData(ServerPlayerEntity player) {
NbtCompound data = new NbtCompound();
writeCustomDataToNbt(data);
PacketByteBuf buf = PacketByteBufs.create()
.writeNbt(data)
.writeString(getUuidAsString());
ServerPlayNetworking.send(player, CAP_ENTITY_SPAWN, buf);
}

@Override
public void onStartedTrackingBy(ServerPlayerEntity player) {
super.onStartedTrackingBy(player);
sendData(player);
}

@Override
protected void initDataTracker() {
dataTracker.startTracking(COLOR, 0xFFFFFF);
}

public void setItem(ItemStack stack) {
this.stack = stack;
if (stack.getItem() instanceof MysteriousCapItem cap) {
setColor(cap.getColor(stack));
}
}

public void setColor(int color) {
dataTracker.set(COLOR, color);
}

@Override
public void readCustomDataFromNbt(NbtCompound nbt) {
ItemStack stack = ItemStack.fromNbt(nbt.getCompound("Item"));
setItem(stack);
this.throwerId = nbt.getString("Thrower");
this.startAngle = new Vec3d(nbt.getDouble("StartAngleX"), nbt.getDouble("StartAngleY"), nbt.getDouble("StartAngleZ"));
this.startPos = new Vec3d(nbt.getDouble("StartPosX"), nbt.getDouble("StartPosY"), nbt.getDouble("StartPosZ"));
this.leftThrower = nbt.getBoolean("LeftThrower");
this.ticksAtEnd = nbt.getInt("TicksAtEnd");
this.preferredSlot = PreferredCapSlot.values()[nbt.getInt("PreferredSlot")];
}

@Override
public void writeCustomDataToNbt(NbtCompound nbt) {
nbt.put
```
<Overlap Ratio: 0.9757017176372015>

---

--- 376 --
Question ID: 7c9b79d7800b1c2da0644539e482608dc1daaec6_0
Original Code:
```
public class TotalTradingValume extends KeyedProcessFunction<Long, TotalBuyCount, TotalBuyCount> {

    private ValueState<Long> totalValue;

    @Override
    public void open(Configuration parameters) throws Exception {
        totalValue = getRuntimeContext().getState(new ValueStateDescriptor<Long>("total-buy-count"
                , Long.class, 0L));
    }

    @Override
    public void processElement(TotalBuyCount value, Context ctx, Collector<TotalBuyCount> out) throws Exception {
        totalValue.update(totalValue.value() + value.getCount());

        ctx.timerService().registerEventTimeTimer(value.getWindowEnd() + 1);

    }

    @Override
    public void onTimer(long timestamp, OnTimerContext ctx, Collector<TotalBuyCount> out) throws Exception {
        Long count = totalValue.value();

        out.collect(new TotalBuyCount("buy", ctx.getCurrentKey(), count));
        totalValue.clear();

    }
}
```


Overlapping Code:
```
extends KeyedProcessFunction<Long, TotalBuyCount, TotalBuyCount> {
private ValueState<Long> totalValue;
@Override
public void open(Configuration parameters) throws Exception {
totalValue = getRuntimeContext().getState(new ValueStateDescriptor<Long>("total-buy-count"
, Long.class, 0L));
}
@Override
public void processElement(TotalBuyCount value, Context ctx, Collector<TotalBuyCount> out) throws Exception {
totalValue.update(totalValue.value() + value.getCount());
ctx.timerService().registerEventTimeTimer(value.getWindowEnd() + 1);
}
@Override
public void onTimer(long timestamp, OnTimerContext ctx, Collector<TotalBuyCount> out) throws Exception {
Long count = totalValue.value();
out.collect(new TotalBuyCount("buy", ctx.getCurrentKey(), count)
```
<Overlap Ratio: 0.9282178217821783>

---

--- 377 --
Question ID: 712595250bef07f4676f2d0c370b36502bfb16b8_0
Original Code:
```
public class CervejaEntityListener {
	
	@Autowired
	private FotoStorage fotoStorage;
	
	@PostLoad
	public void postLoad(final Cerveja cerveja) {
		SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);
		
		cerveja.setUrlFoto(fotoStorage.getUrl(cerveja.getFotoOuMock()));
		cerveja.setUrlThumbnailFoto(fotoStorage.getUrl(FotoStorage.THUMBNAIL_PREFIX + cerveja.getFotoOuMock()));
		
	}

}
```


Overlapping Code:
```
aEntityListener {

@Autowired
private FotoStorage fotoStorage;

@PostLoad
public void postLoad(final Cerveja cerveja) {
SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this);

cerveja.setUrlFoto(fotoStorage.getUrl(cerveja.getFotoOuMock()));
cerveja.setUrlThumbnailFoto(fotoStorage.getUrl(FotoStorage.THUMBNAIL_PREFIX + cerveja.getFo
```
<Overlap Ratio: 0.9043927648578811>

---

--- 378 --
Question ID: 553ac2961251b17fe305cb3a660f476888ad224f_0
Original Code:
```
public class PooledExecutorWithDMStats extends ThreadPoolExecutor {

  private final PoolStatHelper poolStatHelper;

  private final ThreadsMonitoring threadsMonitoring;

  /**
   * Used to buffer up tasks that would be have been rejected. Only used (i.e. non-null) if
   * constructor queue is not a SynchronousQueue.
   */
  private BlockingQueue<Runnable> blockingWorkQueue;

  /**
   * Used to consume items off the bufferQueue and put them into the pools synchronous queue. Only
   * used (i.e. non-null) if constructor queue is not a SynchronousQueue.
   */
  private Thread bufferConsumer;

  /**
   * Create a new pool that uses the supplied Channel for queuing, and with all default parameter
   * settings except for pool size.
   **/
  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,
      BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, PoolStatHelper poolStatHelper,
      ThreadsMonitoring threadsMonitoring) {
    this(poolSize, keepAliveTime, unit, getSynchronousQueue(workQueue), threadFactory,
        newRejectedExecutionHandler(workQueue), poolStatHelper, threadsMonitoring);

    if (!(workQueue instanceof SynchronousQueue)) {
      blockingWorkQueue = workQueue;
      // create a thread that takes from bufferQueue and puts into result
      final BlockingQueue<Runnable> takeQueue = workQueue;
      final BlockingQueue<Runnable> putQueue = getQueue();
      Runnable r = () -> {
        try {
          for (;;) {
            SystemFailure.checkFailure();
            Runnable job = takeQueue.take();
            putQueue.put(job);
          }
        } catch (InterruptedException ie) {
          Thread.currentThread().interrupt();
          // this thread is being shutdown so just return;
        }
      };
      bufferConsumer = threadFactory.newThread(r);
      bufferConsumer.start();
    }
  }

  /**
   * Create a new pool
   */
  public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,
      SynchronousQueue<Runnable> workQueue, ThreadFactory threadFactory,
      RejectedExecutionHandler rejectedExecutionHandler, PoolStatHelper poolStatHelper,
      ThreadsMonitoring threadsMonitoring) {
    super(getCorePoolSize(poolSize), poolSize, keepAliveTime, unit, workQueue, threadFactory,
        rejectedExecutionHandler);

    this.poolStatHelper = poolStatHelper;
    this.threadsMonitoring = threadsMonitoring;
  }

  @Override
  public void shutdown() {
    try {
      super.shutdown();
    } finally {
      terminated();
    }
  }

  @Override
  protected void terminated() {
    if (bufferConsumer != null) {
      bufferConsumer.interrupt();
    }
    super.terminated();
  }

  @Override
  public List<Runnable> shutdownNow() {
    terminated();
    List<Runnable> l = super.shutdownNow();
    if (blockingWorkQueue != null) {
      blockingWorkQueue.drainTo(l);
    }
    return l;
  }

  @Override
  protected void beforeExecute(Thread t, Runnable r) {
    if (poolStatHelper != null) {
      poolStatHelper.startJob();
    }
    if (threadsMonitoring != null) {
      threadsMonitoring.startMonitor(ThreadsMonitoring.Mode.PooledExecutor);
    }
  }

  @Override
  protected void afterExecute(Runnable r, Throwable ex) {
    if (poolStatHelper != null) {
      poolStatHelper.endJob();
    }
    if (threadsMonitoring != null) {
      threadsMonitoring.endMonitor();
    }
  }

  private static int getCorePoolSize(int maxSize) {
    if (maxSize == Integer.MAX_VALUE) {
      return 0;
    }
    return 1;
  }

  /**
   * This handler does a put which will just wait until the queue has room.
   */
  public static class BlockHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
      if (executor.isShutdown()) {
        throw new RejectedExecutionException("executor has been shutdown");
      }
      try {
        executor.getQueue().put(r);
      } catch (InterruptedException ie) {
        Thread.currentThread().interrupt();
        throw new RejectedExecutionException("interrupted", ie);
      }
    }
  }
  /**
   * This handler fronts a synchronous queue, that is owned by the parent ThreadPoolExecutor, with a
   * the
   * client supplied BlockingQueue that supports storage (the buffer queue). A dedicated thread is
   * used to consume off the buffer queue and put into the synchronous queue.
   */
  public static class BufferHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
      if (executor.isShutdown()) {
        throw new RejectedExecutionException("executor has been shutdown");
      }
      try {
        PooledExecutorWithDMStats pool = (PooledExecutorWithDMStats) executor;
        pool.blockingWorkQueue.put(r);
      } catch (InterruptedException ie) {
        Thread.currentThread().interrupt();
        throw new RejectedExecutionException("interrupted", ie);
      }
    }
  }

  private static SynchronousQueue<Runnable> getSynchronousQueue(BlockingQueue<Runnable> q) {
    if (q instanceof SynchronousQueue) {
      return (SynchronousQueue<Runnable>) q;
    }
    return new SynchronousQueue<>();
  }

  private static RejectedExecutionHandler newRejectedExecutionHandler(BlockingQueue<Runnable> q) {
    if (q instanceof SynchronousQueue) {
      return new CallerRunsPolicy();
    }
    // create a thread that takes from bufferQueue and puts into result
    return new BufferHandler();
  }
}
```


Overlapping Code:
```
ends ThreadPoolExecutor {
private final PoolStatHelper poolStatHelper;
private final ThreadsMonitoring threadsMonitoring;
/**
* Used to buffer up tasks that would be have been rejected. Only used (i.e. non-null) if
* constructor queue is not a SynchronousQueue.
*/
private BlockingQueue<Runnable> blockingWorkQueue;
/**
* Used to consume items off the bufferQueue and put them into the pools synchronous queue. Only
* used (i.e. non-null) if constructor queue is not a SynchronousQueue.
*/
private Thread bufferConsumer;
/**
* Create a new pool that uses the supplied Channel for queuing, and with all default parameter
* settings except for pool size.
**/
public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,
BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, PoolStatHelper poolStatHelper,
ThreadsMonitoring threadsMonitoring) {
this(poolSize, keepAliveTime, unit, getSynchronousQueue(workQueue), threadFactory,
newRejectedExecutionHandler(workQueue), poolStatHelper, threadsMonitoring);
if (!(workQueue instanceof SynchronousQueue)) {
blockingWorkQueue = workQueue;
// create a thread that takes from bufferQueue and puts into result
final BlockingQueue<Runnable> takeQueue = workQueue;
final BlockingQueue<Runnable> putQueue = getQueue();
Runnable r = () -> {
try {
for (;;) {
SystemFailure.checkFailure();
Runnable job = takeQueue.take();
putQueue.put(job);
}
} catch (InterruptedException ie) {
Thread.currentThread().interrupt();
// this thread is being shutdown so just return;
}
};
bufferConsumer = threadFactory.newThread(r);
bufferConsumer.start();
}
}
/**
* Create a new pool
*/
public PooledExecutorWithDMStats(int poolSize, long keepAliveTime, TimeUnit unit,
SynchronousQueue<Runnable> workQueue, ThreadFactory threadFactory,
RejectedExecutionHandler rejectedExecutionHandler, PoolStatHelper poolStatHelper,
ThreadsMonitoring threadsMonitoring) {
super(getCorePoolSize(poolSize), poolSize, keepAliveTime, unit, workQueue, threadFactory,
rejectedExecutionHandler);
this.poolStatHelper = poolStatHelper;
this.threadsMonitoring = threadsMonitoring;
}
@Override
public void shutdown() {
try {
super.shutdo
```
<Overlap Ratio: 0.980009086778737>

---

--- 379 --
Question ID: e74d6907a55ef2f8af225b8dd516790681857636_0
Original Code:
```
public class LifeComponent extends Component implements Life{
	Integer life = 3;
	
    @Override
    public void onUpdate(double ptf) {
        entity.getViewComponent().clearChildren();
        Text lifeText = new Text("Lives: "  + life.toString());
        lifeText.setFill(Color.RED);
        lifeText.setFont(Font.font("Arial", 20));
        entity.getViewComponent().addChild(lifeText);
    }

	@Override
	public int getLife() {
		return life;
	}

	@Override
	public void setLife(int i) {
		life = i;
	}

	@Override
	public int decreaseLife(int i) {
		life -= i;
		return life;
	}
}
```


Overlapping Code:
```
ass LifeComponent extends Component implements Life{
Integer life = 3;

@Override
public void onUpdate(double ptf) {
entity.getViewComponent().clearChildren();
Text lifeText = new Text("Lives: " + life.toString());
lifeText.setFill(Color.RED);
lifeText.setFont(Font.font("Arial", 20));
entity.getViewComponent().addChild(lifeText);
}
@Override
public int getLife() {
return life;
}
@Override
public void setLife(int i) {
life = i;
}
@Override
public int decreaseLife(int i) {
life -= i;
return life;

```
<Overlap Ratio: 0.9765625>

---

--- 380 --
Question ID: 6c7fa746468082c1b73f6c4eaff43b6c3bdeef3f_0
Original Code:
```
public class TestableTrustKit extends TrustKit {
    private TestableTrustKit(Context context, TrustKitConfiguration trustKitConfiguration,
                             BackgroundReporter reporter) {
        super(context, trustKitConfiguration);
        TestableTrustManagerBuilder.setReporter(reporter);
    }


    public static TrustKit initializeWithNetworkSecurityConfiguration(@NonNull Context context,
                                                                      BackgroundReporter reporter) {
        TrustKit.initializeWithNetworkSecurityConfiguration(context);
        TestableTrustManagerBuilder.setReporter(reporter);
        return TrustKit.getInstance();
    }

    // This lets us directly specify domain settings without parsing an XML file and inject/mock
    // the background reporter
    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,
                            @NonNull Context context,
                            BackgroundReporter reporter) {
        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet));
        TestableTrustManagerBuilder.setReporter(reporter);
    }


    public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,
                            boolean shouldOverridePins,
                            @Nullable Set<Certificate> debugCaCerts,
                            @NonNull Context context,
                            BackgroundReporter reporter) {
        trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet,
                shouldOverridePins, debugCaCerts));
        TestableTrustManagerBuilder.setReporter(reporter);
    }

    public static void reset() {
        trustKitInstance = null;
        TestableTrustManagerBuilder.reset();
    }
}
```


Overlapping Code:
```
public class TestableTrustKit extends TrustKit {
private TestableTrustKit(Context context, TrustKitConfiguration trustKitConfiguration,
BackgroundReporter reporter) {
super(context, trustKitConfiguration);
TestableTrustManagerBuilder.setReporter(reporter);
}
public static TrustKit initializeWithNetworkSecurityConfiguration(@NonNull Context context,
BackgroundReporter reporter) {
TrustKit.initializeWithNetworkSecurityConfiguration(context);
TestableTrustManagerBuilder.setReporter(reporter);
return TrustKit.getInstance();
}
// This lets us directly specify domain settings without parsing an XML file and inject/mock
// the background reporter
public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,
@NonNull Context context,
BackgroundReporter reporter) {
trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet));
TestableTrustManagerBuilder.setReporter(reporter);
}
public static void init(@NonNull Set<DomainPinningPolicy> domainConfigSet,
boolean shouldOverridePins,
@Nullable Set<Certificate> debugCaCerts,
@NonNull Context context,
BackgroundReporter reporter) {
trustKitInstance = new TrustKit(context, new TestableTrustKitConfiguration(domainConfigSet,
shouldOverridePins, debugCaCerts));
TestableTrustManagerBuilder.setReporter(reporter);
}
public static void reset() {
trustKitInstance = null;
TestableTrustManagerBuilder.reset();

```
<Overlap Ratio: 0.9978617248752673>

---

--- 381 --
Question ID: a4d51c464101b86c3b0cf599d73b78ed99752f62_0
Original Code:
```
public class MessageUtil {

    private MessageUtil() {
        throw new IllegalAccessError("Utility class");
    }

    public static boolean hasFields(Message message) {
        return !message.getFields().isEmpty();
    }

    /**
     * Returns a list of bit fields used for field presence checks.
     */
    public static List<String> bitFieldNames(Message message) {
        int fieldCount = message.getFieldCount();
        if (fieldCount == 0) {
            return Collections.emptyList();
        }
        List<String> result = new ArrayList<>();
        int n = (fieldCount - 1) / 32 + 1;
        for (int i = 0; i < n; i++) {
            result.add("__bitField" + i);
        }
        return result;
    }

    public static String getOneofEnumClassName(Oneof oneof) {
        String name = oneof.getName();
        return Formatter.toPascalCase(name) + "Case";
    }

    /**
     * Returns a "not set" name for one-of enum constant.
     */
    public static String getOneofNotSetConstantName(Oneof oneof) {
        String name = oneof.getName();
        String underscored = Formatter.toUnderscoreCase(name);
        return Formatter.toUpperCase(underscored) + "_NOT_SET";
    }

    public static String getOneofCaseGetterName(Oneof oneof) {
        String name = oneof.getName();
        return "get" + Formatter.toPascalCase(name) + "Case";
    }

    public static String getOneofCaseCleanerName(Oneof oneof) {
        String name = oneof.getName();
        return "clear" + Formatter.toPascalCase(name);
    }

    public static String getOneofFieldName(Oneof oneof) {
        String name = oneof.getName();
        return Formatter.toCamelCase(name) + "__";
    }

    public static String getOneofCaseFieldName(Oneof oneof) {
        String name = oneof.getName();
        return Formatter.toCamelCase(name) + "Case__";
    }
}
```


Overlapping Code:
```
public class MessageUtil {
private MessageUtil() {
throw new IllegalAccessError("Utility class");
}
public static boolean hasFields(Message message) {
return !message.getFields().isEmpty();
}
/**
* Returns a list of bit fields used for field presence checks.
*/
public static List<String> bitFieldNames(Message message) {
int fieldCount = message.getFieldCount();
if (fieldCount == 0) {
return Collections.emptyList();
}
List<String> result = new ArrayList<>();
int n = (fieldCount - 1) / 32 + 1;
for (int i = 0; i < n; i++) {
result.add("__bitField" + i);
}
return result;
}
public static String getOneofEnumClassName(Oneof oneof) {
String name = oneof.getName();
return Formatter.toPascalCase(name) + "Case";
}
/**
* Returns a "not set" name for one-of enum constant.
*/
public static String getOneofNotSetConstantName(Oneof oneof) {
String name = oneof.getName();
String underscored = Formatter.toUnderscoreCase(name);
return Formatter.toUpperCase(underscored) + "_NOT_SET";
}
public static String getOneofCaseGetterName(Oneof oneof) {
String name = oneof.getName();
return "get" + Formatter.toPascalCase(name) + "Case";
}
public static String getOneofCaseCleanerName(Oneof oneof) {
String name = oneof.getName();
return "clear" + Formatter.toPascalCase(name);
}
public static String getOneofFieldName(Oneof oneof) {
String name = oneof.getName();
return Formatter.toCamelCase(name) + "__";
}
public static String getOneofCaseFieldName(Oneof oneof) {
String name = oneof.getName();
return Formatter.toCamelCase(name) + "Case__";
```
<Overlap Ratio: 0.9973941368078176>

---

--- 382 --
Question ID: 306644f4c481adbba4a4ad24f09fd723df6a4b34_0
Original Code:
```
public class BaseActivity extends AppCompatActivity {

    public BaseActivity baseActivity;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        baseActivity = this;
        RxActivityTool.addActivity(this);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
    }
}
```


Overlapping Code:
```
public class BaseActivity extends AppCompatActivity {
public BaseActivity baseActivity;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
baseActivity = this;
RxActivityTool.addActivity(this);
}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
super.onActivityResult(requestCode, resultCode, data);
}
}
```
<Overlap Ratio: 1.0>

---

--- 383 --
Question ID: 1f358335f6509eed32cebe6c1c4ecc98507950c3_0
Original Code:
```
public class ArrayHelperTest
    extends TestCase
{
    private final Allocator<Integer> alloc = allocator(Integer.class);

    public void testSubArray()
    {
        Integer[] orig = {1, 2, 3};

        verifyValues(subArray(alloc, orig, 0, 0));
        verifyValues(subArray(alloc, orig, 0, 1), 1);
        verifyValues(subArray(alloc, orig, 0, 2), 1, 2);
        verifyValues(subArray(alloc, orig, 0, 3), 1, 2, 3);

        verifyValues(subArray(alloc, orig, 1, 1));
        verifyValues(subArray(alloc, orig, 1, 2), 2);
        verifyValues(subArray(alloc, orig, 1, 3), 2, 3);

        verifyValues(subArray(alloc, orig, 2, 2));
        verifyValues(subArray(alloc, orig, 2, 3), 3);

        verifyValues(subArray(alloc, orig, 3, 3));
    }

    public void testSubArray2()
    {
        Integer[] a = {1, 2, 3};
        Integer[] b = {4, 5, 6};

        verifyValues(subArray(alloc, a, b, 0, 0));
        verifyValues(subArray(alloc, a, b, 0, 1), 1);
        verifyValues(subArray(alloc, a, b, 0, 2), 1, 2);
        verifyValues(subArray(alloc, a, b, 0, 3), 1, 2, 3);

        verifyValues(subArray(alloc, a, b, 1, 1));
        verifyValues(subArray(alloc, a, b, 1, 2), 2);
        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);

        verifyValues(subArray(alloc, a, b, 3, 3));
        verifyValues(subArray(alloc, a, b, 3, 4), 4);
        verifyValues(subArray(alloc, a, b, 3, 5), 4, 5);
        verifyValues(subArray(alloc, a, b, 3, 6), 4, 5, 6);

        verifyValues(subArray(alloc, a, b, 4, 4));
        verifyValues(subArray(alloc, a, b, 4, 5), 5);
        verifyValues(subArray(alloc, a, b, 4, 6), 5, 6);

        verifyValues(subArray(alloc, a, b, 2, 3), 3);
        verifyValues(subArray(alloc, a, b, 2, 4), 3, 4);
        verifyValues(subArray(alloc, a, b, 2, 5), 3, 4, 5);
        verifyValues(subArray(alloc, a, b, 2, 6), 3, 4, 5, 6);

        verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);
        verifyValues(subArray(alloc, a, b, 1, 4), 2, 3, 4);
        verifyValues(subArray(alloc, a, b, 1, 5), 2, 3, 4, 5);
        verifyValues(subArray(alloc, a, b, 1, 6), 2, 3, 4, 5, 6);

    }

    public void testAssign()
    {
        Integer[] orig = {1, 2, 3};

        verifyValues(assign(orig, 0, 9), 9, 2, 3);
        verifyValues(assign(orig, 1, 9), 1, 9, 3);
        verifyValues(assign(orig, 2, 9), 1, 2, 9);

        try {
            assign(orig, 3, 9);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
    }

    public void testAppend()
    {
        verifyValues(append(alloc, new Integer[0], 9), 9);
        verifyValues(append(alloc, new Integer[]{1}, 9), 1, 9);
    }

    public void testInsert()
    {
        verifyValues(insert(alloc, new Integer[0], 0, 9), 9);

        verifyValues(insert(new Integer[]{1}, 0, 9), 9, 1);
        verifyValues(insert(alloc, new Integer[]{1}, 1, 9), 1, 9);

        verifyValues(insert(alloc, new Integer[]{1, 2}, 0, 9), 9, 1, 2);
        verifyValues(insert(new Integer[]{1, 2}, 1, 9), 1, 9, 2);
        verifyValues(insert(alloc, new Integer[]{1, 2}, 2, 9), 1, 2, 9);
    }

    public void testDelete()
    {
        // length 1
        Integer[] orig = {1};
        verifyValues(ArrayHelper.<Integer>delete(alloc, orig, 0));

        // length 2
        orig = new Integer[]{1, 2};
        verifyValues(delete(alloc, orig, 0), 2);
        verifyValues(delete(orig, 1), 1);

        // length 3
        orig = new Integer[]{1, 2, 3};
        verifyValues(delete(alloc, orig, 0), 2, 3);
        verifyValues(delete(orig, 1), 1, 3);
        verifyValues(delete(alloc, orig, 2), 1, 2);
    }

    public void testConcat()
    {
        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{}));
        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{}), 1);
        verifyValues(concat(alloc, new Integer[]{}, new Integer[]{1}), 1);
        verifyValues(concat(alloc, new Integer[]{1}, new Integer[]{2}), 1, 2);
    }

    public void testAssignAppend()
    {
        try {
            assignAppend(alloc, new Integer[0], 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
        verifyValues(assignAppend(alloc, new Integer[]{1}, 9, 10), 9, 10);
        verifyValues(assignAppend(alloc, new Integer[]{1, 2}, 9, 10), 1, 9, 10);
    }

    public void testAssignTwo()
    {
        try {
            assignTwo(new Integer[]{}, 0, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
        try {
            assignTwo(new Integer[]{1}, 0, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
        try {
            assignTwo(new Integer[]{1, 2}, 1, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
        verifyValues(assignTwo(new Integer[]{1, 2}, 0, 9, 10), 9, 10);
        verifyValues(assignTwo(new Integer[]{
            1, 2, 3
        }, 0, 9, 10), 9, 10, 3);
        verifyValues(assignTwo(new Integer[]{
            1, 2, 3
        }, 1, 9, 10), 1, 9, 10);
    }

    public void testAssignInsertNode()
    {
        try {
            assignInsert(alloc, new Integer[]{}, 0, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
        try {
            assignInsert(alloc, new Integer[]{1}, 1, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }

        verifyValues(assignInsert(alloc, new Integer[]{1}, 0, 9, 10), 9, 10);
        verifyValues(assignInsert(alloc, new Integer[]{
            1, 2
        }, 0, 9, 10), 9, 10, 2);
        verifyValues(assignInsert(alloc, new Integer[]{
            1, 2
        }, 1, 9, 10), 1, 9, 10);

        try {
            assignInsert(alloc, new Integer[]{1, 2}, 2, 9, 10);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
    }

    public void testAssignDelete()
    {
        try {
            assignDelete(alloc, new Integer[]{1}, 0, 9);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }

        verifyValues(assignDelete(alloc, new Integer[]{1, 2}, 0, 9), 9);
        try {
            assignDelete(alloc, new Integer[]{1, 2}, 1, 9);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }

        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 0, 9), 9, 3);
        verifyValues(assignDelete(alloc, new Integer[]{1, 2, 3}, 1, 9), 1, 9);
        try {
            assignDelete(alloc, new Integer[]{1, 2, 3}, 2, 9);
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        }
    }

    public void testPrefix()
    {
        verifyValues(a(), prefix(alloc, a(), 0));
        verifyValues(a(), prefix(alloc, a(1), 0));
        verifyValues(a(), prefix(alloc, a(1, 2), 0));
        verifyValues(a(1), prefix(alloc, a(1, 2), 1));
        verifyValues(a(1, 2), prefix(alloc, a(1, 2), 2));
        verifyOutOfBounds(() -> prefix(alloc, a(), 1));
        verifyOutOfBounds(() -> prefix(alloc, a(1), 2));
    }

    public void testPrefixInsert()
    {
        verifyValues(a(9), prefixInsert(alloc, a(), 0, 0, 9));
        verifyValues(a(9), prefixInsert(alloc, a(1), 0, 0, 9));
        verifyValues(a(9, 1), prefixInsert(alloc, a(1), 1, 0, 9));
        verifyValues(a(1, 9), prefixInsert(alloc, a(1), 1, 1, 9));
        verifyValues(a(9), prefixInsert(alloc, a(1, 2), 0, 0, 9));
        verifyValues(a(9, 1), prefixInsert(alloc, a(1, 2), 1, 0, 9));
        verifyValues(a(1, 9), prefixInsert(alloc, a(1, 2), 1, 1, 9));
        verifyValues(a(1, 2, 9), prefixInsert(alloc, a(1, 2), 2, 2, 9));
        verifyOutOfBounds(() -> prefixInsert(alloc, a(), 1, 0, 9));
        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 2, 0, 9));
        verifyOutOfBounds(() -> prefixInsert(alloc, a(1), 1, 2, 9));
    }

    public void testSuffix()
    {
        verifyValues(a(), suffix(alloc, a(), 0));
        verifyValues(a(), suffix(alloc, a(1), 1));
        verifyValues(a(), suffix(alloc, a(1, 2), 2));
        verifyValues(a(2), suffix(alloc, a(1, 2), 1));
        verifyValues(a(1, 2), suffix(alloc, a(1, 2), 0));
        verifyValues(a(1, 2, 3), suffix(alloc, a(1, 2, 3), 0));
        verifyValues(a(2, 3), suffix(alloc, a(1, 2, 3), 1));
        verifyValues(a(3), suffix(alloc, a(1, 2, 3), 2));
        verifyValues(a(), suffix(alloc, a(1, 2, 3), 3));
        verifyOutOfBounds(() -> suffix(alloc, a(), 1));
        verifyOutOfBounds(() -> suffix(alloc, a(1), 2));
        verifyOutOfBounds(() -> suffix(alloc, a(1, 2), 3));
    }

    public void testSuffixInsert()
    {
        verifyValues(a(9), suffixInsert(alloc, a(), 0, 0, 9));
        verifyValues(a(9), suffixInsert(alloc, a(1), 1, 1, 9));
        verifyValues(a(9, 1), suffixInsert(alloc, a(1), 0, 0, 9));
        verifyValues(a(1, 9), suffixInsert(alloc, a(1), 0, 1, 9));
        verifyValues(a(9), suffixInsert(alloc, a(1, 2), 2, 2, 9));
        verifyValues(a(2, 9), suffixInsert(alloc, a(1, 2), 1, 2, 9));
        verifyValues(a(9, 2), suffixInsert(alloc, a(1, 2), 1, 1, 9));
        verifyValues(a(9, 1, 2), suffixInsert(alloc, a(1, 2), 0, 0, 9));
        verifyValues(a(1, 9, 2), suffixInsert(alloc, a(1, 2), 0, 1, 9));
        verifyValues(a(1, 2, 9), suffixInsert(alloc, a(1, 2), 0, 2, 9));
        verifyOutOfBounds(() -> suffixInsert(alloc, a(), 1, 1, 9));
        verifyOutOfBounds(() -> suffixInsert(alloc, a(1), 2, 1, 9));
        verifyOutOfBounds(() -> suffixInsert(alloc, a(1, 2), 1, 0, 9));
    }

    public void testReverse()
    {
        verifyValues(reverse(alloc, new Integer[0]));
        verifyValues(reverse(alloc, new Integer[]{1}), 1);
        verifyValues(reverse(alloc, new Integer[]{1, 2}), 2, 1);
        verifyValues(reverse(alloc, new Integer[]{1, 2, 3}), 3, 2, 1);
        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4}), 4, 3, 2, 1);
        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5}), 5, 4, 3, 2, 1);
        verifyValues(reverse(alloc, new Integer[]{1, 2, 3, 4, 5, 6}), 6, 5, 4, 3, 2, 1);
    }

    private void verifyOutOfBounds(Callable<Integer[]> op)
    {
        try {
            op.call();
            fail();
        } catch (ArrayIndexOutOfBoundsException ignored) {
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    private <T> void verifyValues(T[] actual,
                                  Integer... expected)
    {
        assertEquals(asList(expected), asList(actual));
    }

    private Integer[] a(Integer... values)
    {
        return values;
    }
}
```


Overlapping Code:
```
private final Allocator<Integer> alloc = allocator(Integer.class);
public void testSubArray()
{
Integer[] orig = {1, 2, 3};
verifyValues(subArray(alloc, orig, 0, 0));
verifyValues(subArray(alloc, orig, 0, 1), 1);
verifyValues(subArray(alloc, orig, 0, 2), 1, 2);
verifyValues(subArray(alloc, orig, 0, 3), 1, 2, 3);
verifyValues(subArray(alloc, orig, 1, 1));
verifyValues(subArray(alloc, orig, 1, 2), 2);
verifyValues(subArray(alloc, orig, 1, 3), 2, 3);
verifyValues(subArray(alloc, orig, 2, 2));
verifyValues(subArray(alloc, orig, 2, 3), 3);
verifyValues(subArray(alloc, orig, 3, 3));
}
public void testSubArray2()
{
Integer[] a = {1, 2, 3};
Integer[] b = {4, 5, 6};
verifyValues(subArray(alloc, a, b, 0, 0));
verifyValues(subArray(alloc, a, b, 0, 1), 1);
verifyValues(subArray(alloc, a, b, 0, 2), 1, 2);
verifyValues(subArray(alloc, a, b, 0, 3), 1, 2, 3);
verifyValues(subArray(alloc, a, b, 1, 1));
verifyValues(subArray(alloc, a, b, 1, 2), 2);
verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);
verifyValues(subArray(alloc, a, b, 3, 3));
verifyValues(subArray(alloc, a, b, 3, 4), 4);
verifyValues(subArray(alloc, a, b, 3, 5), 4, 5);
verifyValues(subArray(alloc, a, b, 3, 6), 4, 5, 6);
verifyValues(subArray(alloc, a, b, 4, 4));
verifyValues(subArray(alloc, a, b, 4, 5), 5);
verifyValues(subArray(alloc, a, b, 4, 6), 5, 6);
verifyValues(subArray(alloc, a, b, 2, 3), 3);
verifyValues(subArray(alloc, a, b, 2, 4), 3, 4);
verifyValues(subArray(alloc, a, b, 2, 5), 3, 4, 5);
verifyValues(subArray(alloc, a, b, 2, 6), 3, 4, 5, 6);
verifyValues(subArray(alloc, a, b, 1, 3), 2, 3);
verifyValues(subArray(alloc, a, b, 1, 4), 2, 3, 4);
verifyValues(subArray(alloc, a, b, 1, 5), 2, 3, 4, 5);
verifyValues(subArray(alloc, a, b, 1, 6), 2, 3, 4, 5, 6);
}
public void testAssign()
{
Integer[] orig = {1, 2, 3};
verifyValues(assign(orig, 0, 9), 9, 2, 3);
verifyValues(assign(orig, 1, 9), 1, 9, 3);
verifyValues(assign(orig, 2, 9), 1, 2, 9);
try {
assign(orig, 3, 9);
fail();
} catch (ArrayIndexOutOfBoundsException ignored) {
}
}
public void 
```
<Overlap Ratio: 0.976374156219865>

---

