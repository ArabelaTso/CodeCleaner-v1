{"hexsha": "003bff82f46166c3f5ea8b56bd51cf687810f60a", "ext": "java", "lang": "Java", "content": "@Entity\n@Table(name = \"coordinador\")\n@XmlRootElement\n@NamedQueries({\n    @NamedQuery(name = \"Coordinador.findAll\", query = \"SELECT c FROM Coordinador c\"),\n    @NamedQuery(name = \"Coordinador.findByCooIdentificador\", query = \"SELECT c FROM Coordinador c WHERE c.cooIdentificador = :cooIdentificador\"),\n    @NamedQuery(name = \"Coordinador.findByCooNombre\", query = \"SELECT c FROM Coordinador c WHERE c.cooNombre = :cooNombre\"),\n    @NamedQuery(name = \"Coordinador.findByCooContrasena\", query = \"SELECT c FROM Coordinador c WHERE c.cooContrasena = :cooContrasena\"),\n    @NamedQuery(name = \"Coordinador.findByCooCorreo\", query = \"SELECT c FROM Coordinador c WHERE c.cooCorreo = :cooCorreo\"),\n    @NamedQuery(name = \"Coordinador.findByCooUsuario\", query = \"SELECT c FROM Coordinador c WHERE c.cooUsuario = :cooUsuario\")})\npublic class Coordinador implements Serializable {\n\n    @JoinColumn(name = \"usuario_id\", referencedColumnName = \"id\")\n    @ManyToOne(optional = false)\n    private Usuario usuarioId;\n\n    // Versi\u00f3n de la base de datos\n    private static final long serialVersionUID = 1L;\n    // Clave identificadora del coordinador\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Basic(optional = false)\n    @Column(name = \"coo_identificador\")\n    private Integer cooIdentificador;\n    // Nombre del coordinador\n    @Size(max = 45)\n    @Column(name = \"coo_nombre\")\n    private String cooNombre;\n    // Contrase\u00f1a del coordinador\n    @Size(max = 40)\n    @Column(name = \"coo_contrasena\")\n    private String cooContrasena;\n    // Correo del coordinador\n    @Size(max = 30)\n    @Column(name = \"coo_correo\")\n    private String cooCorreo;\n    // Usuario del coordinador\n    @Size(max = 20)\n    @Column(name = \"coo_usuario\")\n    private String cooUsuario;   \n    @OneToMany(cascade = CascadeType.ALL, mappedBy = \"coordinador\")\n    private List<Doctorado> doctoradoList;\n\n    /* Coordinador */\n    public Coordinador() {\n    }\n\n    public Coordinador(Integer cooIdentificador) {\n        this.cooIdentificador = cooIdentificador;\n    }\n\n    /* Getters y Setters */\n    public Integer getCooIdentificador() {\n        return cooIdentificador;\n    }\n\n    public void setCooIdentificador(Integer cooIdentificador) {\n        this.cooIdentificador = cooIdentificador;\n    }\n\n    public String getCooNombre() {\n        return cooNombre;\n    }\n\n    public void setCooNombre(String cooNombre) {\n        this.cooNombre = cooNombre;\n    }\n\n    public String getCooContrasena() {\n        return cooContrasena;\n    }\n\n    public void setCooContrasena(String cooContrasena) {\n        this.cooContrasena = cooContrasena;\n    }\n\n    public String getCooCorreo() {\n        return cooCorreo;\n    }\n\n    public void setCooCorreo(String cooCorreo) {\n        this.cooCorreo = cooCorreo;\n    }\n\n    public String getCooUsuario() {\n        return cooUsuario;\n    }\n\n    public void setCooUsuario(String cooUsuario) {\n        this.cooUsuario = cooUsuario;\n    }\n\n    @XmlTransient\n    public List<Doctorado> getDoctoradoList() {\n        return doctoradoList;\n    }\n\n    public void setDoctoradoList(List<Doctorado> doctoradoList) {\n        this.doctoradoList = doctoradoList;\n    }\n    \n    public Usuario getUsuarioId() {\n        return usuarioId;\n    }\n\n    public void setUsuarioId(Usuario usuarioId) {\n        this.usuarioId = usuarioId;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 0;\n        hash += (cooIdentificador != null ? cooIdentificador.hashCode() : 0);\n        return hash;\n    }\n\n    @Override\n    public boolean equals(Object object) {\n        // TODO: Warning - this method won't work in the case the id fields are not set\n        if (!(object instanceof Coordinador)) {\n            return false;\n        }\n        Coordinador other = (Coordinador) object;\n        if ((this.cooIdentificador == null && other.cooIdentificador != null) || (this.cooIdentificador != null && !this.cooIdentificador.equals(other.cooIdentificador))) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"co.unicauca.proyectobase.entidades.Coordinador[ cooIdentificador=\" + cooIdentificador + \" ]\";\n    }    \n}", "class_id": 0, "repo": "Tisandg/SGDPostgrados", "file": "src/java/co/unicauca/proyectobase/entidades/Coordinador.java", "last_update_at": "2018-05-06T08:30:59+00:00", "question_id": "003bff82f46166c3f5ea8b56bd51cf687810f60a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity\n@Table(name = \"coordinador\")\n@XmlRootElement\n@NamedQueries({\n    @NamedQuery(name = \"Coordinador.findAll\", query = \"SELECT c FROM Coordinador c\"),\n    @NamedQuery(name = \"Coordinador.findByCooIdentificador\", query = \"SELECT c FROM Coordinador c WHERE c.cooIdentificador = :cooIdentificador\"),\n    @NamedQuery(name = \"Coordinador.findByCooNombre\", query = \"SELECT c FROM Coordinador c WHERE c.cooNombre = :cooNombre\"),\n    @NamedQuery(name = \"Coordinador.findByCooContrasena\", query = \"SELECT c FROM Coordinador c WHERE c.cooContrasena = :cooContrasena\"),\n    @NamedQuery(name = \"Coordinador.findByCooCorreo\", query = \"SELECT c FROM Coordinador c WHERE c.cooCorreo = :cooCorreo\"),\n    @NamedQuery(name = \"Coordinador.findByCooUsuario\", query = \"SELECT c FROM Coordinador c WHERE c.cooUsuario = :cooUsuario\")})\npublic class Coordinador implements Serializable {\n    @JoinColumn(name = \"usuario_id\", referencedColumnName = \"id\")\n    @ManyToOne(optional = false)\n    private Usuario usuarioId;\n    // Versi\u00f3n de la base de datos\n    private static final long serialVersionUID = 1L;\n    // Clave identificadora del coordinador\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Basic(optional = false)\n    @Column(name = \"coo_identificador\")\n    private Integer cooIdentificador;\n    // Nombre del coordinador\n    @Size(max = 45)\n    @Column(name = \"coo_nombre\")\n    private String cooNombre;\n    // Contrase\u00f1a del coordinador\n    @Size(max = 40)\n    @Column(name = \"coo_contrasena\")\n    private String cooContrasena;\n    // Correo del coordinador\n    @Size(max = 30)\n    @Column(name = \"coo_correo\")\n    private String cooCorreo;\n    // Usuario del coordinador\n    @Size(max = 20)\n    @Column(name = \"coo_usuario\")\n    private String cooUsuario;   \n    @OneToMany(cascade = CascadeType.ALL, mappedBy = \"coordinador\")\n    private List<Doctorado> doctoradoList;\n    /* Coordinador */\n    public Coordinador() {\n    }\n    public Coordinador(Integer cooIdentificador) {\n        this.cooIdentificador = cooIdentificador;\n    }\n    /* Getters y Setters */\n    public Integer getCooIdentificador() {\n        return cooIdentificador;\n    }\n    public void setCooIdentificador(Integer cooIdentificador) {\n        this.cooIdentificador = cooIdentificador;\n    }\n    public String getCooNombre() {\n        return cooNombre;\n    }\n    public void setCooNombre(String cooNombre) {\n        this.cooNombre = cooNombre;\n    }\n    public String getCooContrasena() {\n        return cooContrasena;\n    }\n    public void setCooContrasena(String cooContrasena) {\n        this.cooContrasena = cooContrasena;\n    }\n    public String getCooCorreo() {\n        return cooCorreo;\n    }\n    public void setCooCorreo(String cooCorreo) {\n        this.cooCorreo = cooCorreo;\n    }\n    public String getCooUsuario() {\n        return cooUsuario;\n    }\n    public void setCooUsuario(String cooUsuario) {\n        this.cooUsuario = cooUsuario;\n    }\n    @XmlTransient\n    public List<Doctorado> getDoctoradoList() {\n        return doctoradoList;\n    }\n    public void setDoctoradoList(List<Doctorado> doctoradoList) {\n        this.doctoradoList = doctoradoList;\n    }\n    public Usuario getUsuarioId() {\n        return usuarioId;\n    }\n    public void setUsuarioId(Usuario usuarioId) {\n        this.usuarioId = usuarioId;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 0;\n        hash += (cooIdentificador != null ? cooIdentificador.hashCode() : 0);\n        return hash;\n    }\n    @Override\n    public boolean equals(Object object) {\n        // TODO: Warning - this method won't work in the case the id fields are not set\n        if (!(object instanceof Coordinador)) {\n            return false;\n        }\n        Coordinador other = (Coordinador) object;\n        if ((this.cooIdentificador == null && other.cooIdentificador != null) || (this.cooIdentificador != null && !this.cooIdentificador.equals(other.cooIdentificador))) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public String toString() {\n        return \"co.unicauca.proyectobase.entidades.Coordinador[ cooIdentificador=\" + cooIdentificador + \" ]\";\n    }    \n"]], "pred": {"ppl": 1.2289307117462158, "ppl_lower": 1.4244250059127808, "ppl/lowercase_ppl": -1.7161181178094143, "ppl/zlib": 0.00018488291591515569, "Min_5.0% Prob": 3.5830576338020026, "Min_10.0% Prob": 2.000390375361723, "Min_20.0% Prob": 1.029107875765904, "Min_30.0% Prob": 0.6884734347999839, "Min_40.0% Prob": 0.5154368666955327, "Min_50.0% Prob": 0.41263754134510194, "Min_60.0% Prob": 0.3440040751206363}}
{"hexsha": "25c270fe8d00ff3346947add33e1a7e77fea446c", "ext": "java", "lang": "Java", "content": "public class PreDefienedStream {\n\tpublic static void main(String[] args) throws IOException{\n\t\tPrintStream ps=System.out;\n\t\tps.println(\"hello there!\");\n\t\t\n\t\tps.println(\"Input a character:\");\n\t\tInputStream is=System.in;\n\t\tchar ch=(char)is.read();\n\t\tps.println(\"Your character is : \"+ch);\n\t}\n}", "class_id": 0, "repo": "AlphaBAT69/Java-Programs", "file": "IOPackage/PreDefienedStream.java", "last_update_at": "2018-01-26T12:33:16+00:00", "question_id": "25c270fe8d00ff3346947add33e1a7e77fea446c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PreDefienedStream {\n\tpublic static void main(String[] args) throws IOException{\n\t\tPrintStream ps=System.out;\n\t\tps.println(\"hello there!\");\n\t\t\n\t\tps.println(\"Input a character:\");\n\t\tInputStream is=System.in;\n\t\tchar ch=(char)is.read();\n\t\tps.println(\"Your character is : \"+ch);\n\t}\n"]], "pred": {"ppl": 3.2255825996398926, "ppl_lower": 3.6069533824920654, "ppl/lowercase_ppl": -1.0954219079258838, "ppl/zlib": 0.006036667963832109, "Min_5.0% Prob": 8.314057350158691, "Min_10.0% Prob": 6.818993886311849, "Min_20.0% Prob": 4.675068767447221, "Min_30.0% Prob": 3.5708241627134125, "Min_40.0% Prob": 2.8642659997328734, "Min_50.0% Prob": 2.330392429719166, "Min_60.0% Prob": 1.9541321798401363}}
{"hexsha": "0eb3bbf321da36588e118b1a0efebe766f702702", "ext": "java", "lang": "Java", "content": "class UtilityListWithCriticalObjects extends UtilityList {\r\n\t/** This bit vectors stores the list of transaction containing the itemset represented\r\n\t * by this utility-list\r\n\t */\r\n\tBitSet tidset = new BitSet(); \r\n\t\r\n\t/** This array of bitsets represents the critical objects of the itemsets represented by\r\n\t *  this utility-list (see the DefMe paper for more details about critical objects \r\n\t */\r\n\tBitSet crit[] = null;\r\n\t\r\n\t/**\r\n\t * Constructor.\r\n\t * @param item the item that is used for this utility list\r\n\t */\r\n\tpublic UtilityListWithCriticalObjects(Integer item){\r\n\t\tsuper(item);\r\n//\t\tthis;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Method to add an element to this utility list and update the sums at the same time.\r\n\t */\r\n\tpublic void addElement(Element element){\r\n\t\tsumIutils += element.iutils;\r\n\t\tsumRutils += element.rutils;\r\n\t\telements.add(element);\r\n\t\ttidset.set(element.tid);\r\n\t}\r\n\t\r\n}", "class_id": 0, "repo": "ndretn/RSBASPM", "file": "src/main/java/ca/pfv/spmf/algorithms/frequentpatterns/hui_miner/UtilityListWithCriticalObjects.java", "last_update_at": "2018-08-09T05:06:54+00:00", "question_id": "0eb3bbf321da36588e118b1a0efebe766f702702", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class UtilityListWithCriticalObjects extends UtilityList {\r\n\t/** This bit vectors stores the list of transaction containing the itemset represented\r\n\t * by this utility-list\r\n\t */\r\n\tBitSet tidset = new BitSet(); \r\n\t\r\n\t/** This array of bitsets represents the critical objects of the itemsets represented by\r\n\t *  this utility-list (see the DefMe paper for more details about critical objects \r\n\t */\r\n\tBitSet crit[] = null;\r\n\t\r\n\t/**\r\n\t * Constructor.\r\n\t * @param item the item that is used for this utility list\r\n\t */\r\n\tpublic UtilityListWithCriticalObjects(Integer item){\r\n\t\tsuper(item);\r\n//\t\tthis;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Method to add an element to this utility list and update the sums at the same time.\r\n\t */\r\n\tpublic void addElement(Element element){\r\n\t\tsumIutils += element.iutils;\r\n\t\tsumRutils += element.rutils;\r\n\t\telements.add(element);\r\n\t\ttidset.set(element.tid);\r\n\t}\r\n\t\r\n"]], "pred": {"ppl": 4.082079887390137, "ppl_lower": 4.995349407196045, "ppl/lowercase_ppl": -1.1435374476400442, "ppl/zlib": 0.0033976005672593608, "Min_5.0% Prob": 8.713317467616154, "Min_10.0% Prob": 7.569474862172053, "Min_20.0% Prob": 5.471994732910732, "Min_30.0% Prob": 4.245317943394184, "Min_40.0% Prob": 3.398503847211321, "Min_50.0% Prob": 2.7823358093624684, "Min_60.0% Prob": 2.3408568232140925}}
{"hexsha": "b77c659fcfdaa812df9ef1097e903318901ccce2", "ext": "java", "lang": "Java", "content": "public class UserTest {\r\n    /**\r\n     * property - TEST_NAME.\r\n     */\r\n    static final String TEST_NAME = \"name\";\r\n    /**\r\n     * property - TEST_CITY.\r\n     */\r\n    static final String TEST_CITY = \"city\";\r\n    /**\r\n     * property - TEST_ID.\r\n     */\r\n    private static final int TEST_ID = 99;\r\n    /**\r\n     * property - new object User for testing.\r\n     */\r\n    private User userOne = new User();\r\n\r\n    /**\r\n     * Test create new object User through a constructor with empty values.\r\n     */\r\n    @Test\r\n    public void whenConstructorNotNewUserThenGetIdOne() {\r\n        User userTwo = new User();\r\n        final int expectedId = userTwo.getId() != 0 ? userTwo.getId() : 0;\r\n        assertThat(userTwo.getId(), is(expectedId));\r\n    }\r\n\r\n    /**\r\n     * Test create new object User through the designer with the specified id.\r\n     */\r\n    @Test\r\n    public void whenConstructorIdNewUserThenGetIdOne() {\r\n        User userTwo = new User(TEST_ID);\r\n        assertThat(userTwo.getId(), is(TEST_ID));\r\n    }\r\n\r\n    /**\r\n     * Test create new object User through the designer with the specified: id, name, city.\r\n     */\r\n    @Test\r\n    public void whenConstructorAllNewUserThenGetIdTwo() {\r\n        User userTwo = new User(TEST_ID, TEST_NAME, TEST_CITY);\r\n        assertThat(userTwo.getId(), is(TEST_ID));\r\n        assertThat(userTwo.getName(), is(TEST_NAME));\r\n        assertThat(userTwo.getCity(), is(TEST_CITY));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property id.\r\n     */\r\n    @Test\r\n    public void whenSetIdThenGetId() {\r\n        userOne.setId(TEST_ID);\r\n        assertThat(userOne.getId(), is(TEST_ID));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property name.\r\n     */\r\n    @Test\r\n    public void whenSetNameThenGetName() {\r\n        userOne.setName(TEST_NAME);\r\n        assertThat(userOne.getName(), is(TEST_NAME));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property city.\r\n     */\r\n    @Test\r\n    public void whenSetCityThenGetCity() {\r\n        userOne.setCity(TEST_CITY);\r\n        assertThat(userOne.getCity(), is(TEST_CITY));\r\n    }\r\n}", "class_id": 0, "repo": "forvvard09/job4j_CoursesJunior", "file": "1_Trainee/03_CollectionsLite/02_Generics/task_1_03_02_01/src/test/java/ru/spoddubnyak/UserTest.java", "last_update_at": "2018-01-15T22:14:34+00:00", "question_id": "b77c659fcfdaa812df9ef1097e903318901ccce2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UserTest {\r\n    /**\r\n     * property - TEST_NAME.\r\n     */\r\n    static final String TEST_NAME = \"name\";\r\n    /**\r\n     * property - TEST_CITY.\r\n     */\r\n    static final String TEST_CITY = \"city\";\r\n    /**\r\n     * property - TEST_ID.\r\n     */\r\n    private static final int TEST_ID = 99;\r\n    /**\r\n     * property - new object User for testing.\r\n     */\r\n    private User userOne = new User();\r\n\r\n    /**\r\n     * Test create new object User through a constructor with empty values.\r\n     */\r\n    @Test\r\n    public void whenConstructorNotNewUserThenGetIdOne() {\r\n        User userTwo = new User();\r\n        final int expectedId = userTwo.getId() != 0 ? userTwo.getId() : 0;\r\n        assertThat(userTwo.getId(), is(expectedId));\r\n    }\r\n\r\n    /**\r\n     * Test create new object User through the designer with the specified id.\r\n     */\r\n    @Test\r\n    public void whenConstructorIdNewUserThenGetIdOne() {\r\n        User userTwo = new User(TEST_ID);\r\n        assertThat(userTwo.getId(), is(TEST_ID));\r\n    }\r\n\r\n    /**\r\n     * Test create new object User through the designer with the specified: id, name, city.\r\n     */\r\n    @Test\r\n    public void whenConstructorAllNewUserThenGetIdTwo() {\r\n        User userTwo = new User(TEST_ID, TEST_NAME, TEST_CITY);\r\n        assertThat(userTwo.getId(), is(TEST_ID));\r\n        assertThat(userTwo.getName(), is(TEST_NAME));\r\n        assertThat(userTwo.getCity(), is(TEST_CITY));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property id.\r\n     */\r\n    @Test\r\n    public void whenSetIdThenGetId() {\r\n        userOne.setId(TEST_ID);\r\n        assertThat(userOne.getId(), is(TEST_ID));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property name.\r\n     */\r\n    @Test\r\n    public void whenSetNameThenGetName() {\r\n        userOne.setName(TEST_NAME);\r\n        assertThat(userOne.getName(), is(TEST_NAME));\r\n    }\r\n\r\n    /**\r\n     * Test setter and getter property city.\r\n     */\r\n    @Test\r\n    public void whenSetCityThenGetCity() {\r\n        userOne.setCity(TEST_CITY);\r\n        assertThat(userOne.getCity(), is(TEST_CITY));\r\n    }\r\n"]], "pred": {"ppl": 1.5703967809677124, "ppl_lower": 1.770751953125, "ppl/lowercase_ppl": -1.2660501695002284, "ppl/zlib": 0.0009099361172605302, "Min_5.0% Prob": 5.8251927345991135, "Min_10.0% Prob": 3.9547944894203773, "Min_20.0% Prob": 2.220156856225087, "Min_30.0% Prob": 1.5033882656349586, "Min_40.0% Prob": 1.1274493956381733, "Min_50.0% Prob": 0.9035608693036005, "Min_60.0% Prob": 0.7536302198929227}}
{"hexsha": "6c63cf1b710e22cbc392114c3e041061166e3295", "ext": "java", "lang": "Java", "content": "@RunWith(Arquillian.class)\npublic class MonitorArquillianTest {\n\n    @Deployment(testable = false)\n    public static Archive createDeployment() {\n        JARArchive deployment = ShrinkWrap.create(JARArchive.class);\n        deployment.add(EmptyAsset.INSTANCE, \"nothing\");\n        return deployment;\n    }\n\n    @RunAsClient\n    @Test\n    public void testEndpoints() throws Exception {\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/node\"), Charset.forName(\"UTF-8\")));\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/heap\"), Charset.forName(\"UTF-8\")));\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/threads\"), Charset.forName(\"UTF-8\")));\n    }\n}", "class_id": 0, "repo": "MarianMacik/thorntail", "file": "testsuite/testsuite-monitor/src/test/java/org/wildfly/swarm/monitor/MonitorArquillianTest.java", "last_update_at": "2018-12-05T18:08:25+00:00", "question_id": "6c63cf1b710e22cbc392114c3e041061166e3295", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Arquillian.class)\npublic class MonitorArquillianTest {\n    @Deployment(testable = false)\n    public static Archive createDeployment() {\n        JARArchive deployment = ShrinkWrap.create(JARArchive.class);\n        deployment.add(EmptyAsset.INSTANCE, \"nothing\");\n        return deployment;\n    }\n    @RunAsClient\n    @Test\n    public void testEndpoints() throws Exception {\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/node\"), Charset.forName(\"UTF-8\")));\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/heap\"), Charset.forName(\"UTF-8\")));\n        System.out.println(IOUtils.toString(new URL(\"http://127.0.0.1:8080/threads\"), Charset.forName(\"UTF-8\")));\n    }\n"]], "pred": {"ppl": 1.5793708562850952, "ppl_lower": 2.5884649753570557, "ppl/lowercase_ppl": -2.080984076982111, "ppl/zlib": 0.001376586070827339, "Min_5.0% Prob": 6.18779714902242, "Min_10.0% Prob": 3.974797525405884, "Min_20.0% Prob": 2.218774015412611, "Min_30.0% Prob": 1.5279044550108283, "Min_40.0% Prob": 1.14477305363535, "Min_50.0% Prob": 0.9135347154733608, "Min_60.0% Prob": 0.7645711369121605}}
{"hexsha": "f2258efb122ee9e15c630901fb34f36efbd14550", "ext": "java", "lang": "Java", "content": "@AllArgsConstructor\n@NotThreadSafe\npublic class MerkleTreeFactory {\n\n  private final MessageDigest digest;\n\n  /**\n   * Calculates new {@link MerkleTree} given leaves.\n   *\n   * @param leafs the bottom-most level of the tree (e.g. leaves)\n   * @return valid {@link MerkleTree}\n   * @throws IllegalArgumentException when number of leaves is not at least 1\n   */\n  public MerkleTree createFromLeaves(@NonNull final List<Hash> leafs) {\n    ArrayTree<Hash> tree = ArrayTreeFactory.createWithNLeafs(leafs.size());  // throws\n\n    List<Hash> nextLevel = new ArrayList<>(tree.size());\n\n    while (!leafs.isEmpty()) {\n      // copy current level (`leafs`) inside our tree at given positions\n      int leftmostLevelNode = ceilToPowerOf2(leafs.size()) - 1;\n      for (int i = 0; i < leafs.size(); i++) {\n        tree.set(leftmostLevelNode + i, leafs.get(i));\n      }\n\n      // calculate next level\n      while (leafs.size() > 1) {\n        // we can get 2 elements\n        val left = leafs.remove(0);\n        val right = leafs.remove(0);\n\n        if (nonNull(left) && nonNull(right)) {\n          nextLevel.add(\n              Util.hash(digest, left, right)\n          );\n        } else if (nonNull(left)) {\n          nextLevel.add(left);\n        } else if (nonNull(right)) {\n          nextLevel.add(right);\n        } else {\n          // both null\n          nextLevel.add(null);\n        }\n      }\n\n      if (leafs.size() == 1) {\n        // orphan element; we do not calculate hash from it, just pass it to the next level\n        nextLevel.add(\n            leafs.remove(0)\n        );\n      }\n\n      if (nextLevel.size() == 1) {\n        // this is root\n        tree.set(0, nextLevel.remove(0));\n        break;\n      }\n\n      // level is clear at this point\n      assert leafs.isEmpty();\n      leafs.addAll(nextLevel);\n      nextLevel.clear();\n    }\n\n    return new MerkleTree(digest, tree);\n  }\n\n  /**\n   * Creates new Merkle Tree from tree bytes. Performs validity check. This method should be used\n   * always when you read the tree from the untrusted source.\n   *\n   * @param tree merkle tree as described in {@link MerkleTree}\n   * @return valid {@link MerkleTree}\n   * @throws RootHashMismatchException when <code>tree</code> is not valid (roots are different).\n   */\n  public MerkleTree createFromFullTree(@NonNull final ArrayTree<Hash> tree)\n      throws RootHashMismatchException {\n    MerkleTree mt = new MerkleTree(digest, tree);\n    MerkleTree check = createFromLeaves(tree.getLeaves());\n\n    if (!mt.getRoot().equals(check.getRoot())) {\n      throw new RootHashMismatchException(mt.getRoot(), check.getRoot());\n    }\n\n    return mt;\n  }\n}", "class_id": 0, "repo": "soramitsu/sora-crypto-java", "file": "src/main/java/jp/co/soramitsu/sora/sdk/crypto/merkle/MerkleTreeFactory.java", "last_update_at": "2018-08-20T20:34:54+00:00", "question_id": "f2258efb122ee9e15c630901fb34f36efbd14550", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@AllArgsConstructor\n@NotThreadSafe\npublic class MerkleTreeFactory {\n  private final MessageDigest digest;\n  /**\n   * Calculates new {@link MerkleTree} given leaves.\n   *\n   * @param leafs the bottom-most level of the tree (e.g. leaves)\n   * @return valid {@link MerkleTree}\n   * @throws IllegalArgumentException when number of leaves is not at least 1\n   */\n  public MerkleTree createFromLeaves(@NonNull final List<Hash> leafs) {\n    ArrayTree<Hash> tree = ArrayTreeFactory.createWithNLeafs(leafs.size());  // throws\n    List<Hash> nextLevel = new ArrayList<>(tree.size());\n    while (!leafs.isEmpty()) {\n      // copy current level (`leafs`) inside our tree at given positions\n      int leftmostLevelNode = ceilToPowerOf2(leafs.size()) - 1;\n      for (int i = 0; i < leafs.size(); i++) {\n        tree.set(leftmostLevelNode + i, leafs.get(i));\n      }\n      // calculate next level\n      while (leafs.size() > 1) {\n        // we can get 2 elements\n        val left = leafs.remove(0);\n        val right = leafs.remove(0);\n        if (nonNull(left) && nonNull(right)) {\n          nextLevel.add(\n              Util.hash(digest, left, right)\n          );\n        } else if (nonNull(left)) {\n          nextLevel.add(left);\n        } else if (nonNull(right)) {\n          nextLevel.add(right);\n        } else {\n          // both null\n          nextLevel.add(null);\n        }\n      }\n      if (leafs.size() == 1) {\n        // orphan element; we do not calculate hash from it, just pass it to the next level\n        nextLevel.add(\n            leafs.remove(0)\n        );\n      }\n      if (nextLevel.size() == 1) {\n        // this is root\n        tree.set(0, nextLevel.remove(0));\n        break;\n      }\n      // level is clear at this point\n      assert leafs.isEmpty();\n      leafs.addAll(nextLevel);\n      nextLevel.clear();\n    }\n    return new MerkleTree(digest, tree);\n  }\n  /**\n   * Creates new Merkle Tree from tree bytes. Performs validity check. This method should be used\n   * always when you read the tree from the untrusted source.\n   *\n   * @param tree merkle tree as described in {@link MerkleTree}\n   * @return valid {@link MerkleTree}\n   * @throws RootHashMismatchException when <code>tree</code> is not valid (roots are different).\n   */\n  public MerkleTree createFromFullTree(@NonNull final ArrayTree<Hash> tree)\n      throws RootHashMismatchException {\n    MerkleTree mt = new MerkleTree(digest, tree);\n    MerkleTree check = createFromLeaves(tree.getLeaves());\n    if (!mt.getRoot().equals(check.getRoot())) {\n      throw new RootHashMismatchException(mt.getRoot(), check.getRoot());\n    }\n    return mt;\n  }\n"]], "pred": {"ppl": 2.4780924320220947, "ppl_lower": 2.64186954498291, "ppl/lowercase_ppl": -1.0705217782761358, "ppl/zlib": 0.0009056777281132067, "Min_5.0% Prob": 7.586339880780476, "Min_10.0% Prob": 5.769435359770993, "Min_20.0% Prob": 3.9023099139512305, "Min_30.0% Prob": 2.8654732263710603, "Min_40.0% Prob": 2.2336565561772113, "Min_50.0% Prob": 1.8050337883894547, "Min_60.0% Prob": 1.5107425795401446}}
{"hexsha": "9670c6463531fbc79af00027460e80f1335f9bd1", "ext": "java", "lang": "Java", "content": "public class TinyLog\n{\n    private BundleContext context;\n    private LogService log_service;\n\n    public TinyLog ()\n    {\n        context = FrameworkUtil.getBundle (this.getClass ()).getBundleContext ();\n    }\n\n    private String conv_str (Object obj)\n    {\n        if (obj == null)\n        {\n            return (\"null\");\n        }\n        else if (obj instanceof Object[])\n        {\n            Object[] obj_list = (Object[])obj;\n            String result = \"\";\n\n            for (int i = 0; i < obj_list.length; i++)\n            {\n                if (!result.isEmpty ())\n                {\n                    result += \",\";\n                }\n                result += conv_str (obj_list [i]);\n            }\n\n            return (\"[\" + result + \"]\");\n        }\n\n        return (obj.toString ());\n    }\n\n    @SuppressWarnings (\"unchecked\")\n    private LogService get_log_service ()\n    {\n        if (log_service != null)\n        {\n            try\n            {\n                // LogService still valid?\n                FrameworkUtil.getBundle (log_service.getClass ());\n            }\n            catch (IllegalStateException oops)\n            {\n                log_service = null;\n            }\n        }\n\n        if (log_service == null)\n        {\n            ServiceReference ref = context.getServiceReference (LogService.class.getName());\n\n            if (ref != null)\n            {\n                log_service = (LogService) context.getService(ref);\n            }\n        }\n\n        return (log_service);\n    }\n\n    private void write_log (int level, String msg, Object... args)\n    {\n        int i = 0;\n\n        while (msg.contains (\"{}\"))\n        {\n            if (i == args.length)\n            {\n                break;\n            }\n\n            msg = msg.replaceFirst (\"\\\\{\\\\}\", (args [i] == null)? \"null\": conv_str (args [i]));\n            i++;\n        }\n\n        Throwable t = null;\n\n        for (i = 0; i < args.length; i++)\n        {\n            if (args [i] instanceof Throwable)\n            {\n                // Our beloved ugly stack trace\n                t = (Throwable)args [i];\n                break;\n            }\n        }\n\n        if (t == null)\n        {\n            get_log_service ().log (level, msg);\n        }\n        else\n        {\n            get_log_service ().log (level, msg, t);\n        }\n    }\n\n    public void debug (String msg, Object... args)\n    {\n        write_log (LogService.LOG_DEBUG, msg, args);\n    }\n\n    public void info (String msg, Object... args)\n    {\n        write_log (LogService.LOG_INFO, msg, args);\n    }\n\n    public void warn (String msg, Object... args)\n    {\n        write_log (LogService.LOG_WARNING, msg, args);\n    }\n\n    public void error (String msg, Object... args)\n    {\n        write_log (LogService.LOG_ERROR, msg, args);\n    }\n}", "class_id": 0, "repo": "neoautus/lucidj", "file": "extras/bootstrap/src/org/lucidj/bootstrap/TinyLog.java", "last_update_at": "2018-05-05T18:00:59+00:00", "question_id": "9670c6463531fbc79af00027460e80f1335f9bd1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TinyLog\n{\n    private BundleContext context;\n    private LogService log_service;\n    public TinyLog ()\n    {\n        context = FrameworkUtil.getBundle (this.getClass ()).getBundleContext ();\n    }\n    private String conv_str (Object obj)\n    {\n        if (obj == null)\n        {\n            return (\"null\");\n        }\n        else if (obj instanceof Object[])\n        {\n            Object[] obj_list = (Object[])obj;\n            String result = \"\";\n            for (int i = 0; i < obj_list.length; i++)\n            {\n                if (!result.isEmpty ())\n                {\n                    result += \",\";\n                }\n                result += conv_str (obj_list [i]);\n            }\n            return (\"[\" + result + \"]\");\n        }\n        return (obj.toString ());\n    }\n    @SuppressWarnings (\"unchecked\")\n    private LogService get_log_service ()\n    {\n        if (log_service != null)\n        {\n            try\n            {\n                // LogService still valid?\n                FrameworkUtil.getBundle (log_service.getClass ());\n            }\n            catch (IllegalStateException oops)\n            {\n                log_service = null;\n            }\n        }\n        if (log_service == null)\n        {\n            ServiceReference ref = context.getServiceReference (LogService.class.getName());\n            if (ref != null)\n            {\n                log_service = (LogService) context.getService(ref);\n            }\n        }\n        return (log_service);\n    }\n    private void write_log (int level, String msg, Object... args)\n    {\n        int i = 0;\n        while (msg.contains (\"{}\"))\n        {\n            if (i == args.length)\n            {\n                break;\n            }\n            msg = msg.replaceFirst (\"\\\\{\\\\}\", (args [i] == null)? \"null\": conv_str (args [i]));\n            i++;\n        }\n        Throwable t = null;\n        for (i = 0; i < args.length; i++)\n        {\n            if (args [i] instanceof Throwable)\n            {\n                // Our beloved ugly stack trace\n                t = (Throwable)args [i];\n                break;\n            }\n        }\n        if (t == null)\n        {\n            get_log_service ().log (level, msg);\n        }\n        else\n        {\n            get_log_service ().log (level, msg, t);\n        }\n    }\n    public void debug (String msg, Object... args)\n    {\n        write_log (LogService.LOG_DEBUG, msg, args);\n    }\n    public void info (String msg, Object... args)\n    {\n        write_log (LogService.LOG_INFO, msg, args);\n    }\n    public void warn (String msg, Object... args)\n    {\n        write_log (LogService.LOG_WARNING, msg, args);\n    }\n    public void error (String msg, Object... args)\n    {\n        write_log (LogService.LOG_ERROR, msg, args);\n    }\n"]], "pred": {"ppl": 1.5144025087356567, "ppl_lower": 1.682920217514038, "ppl/lowercase_ppl": -1.2542269846183638, "ppl/zlib": 0.0005130049165621813, "Min_5.0% Prob": 5.284130230928079, "Min_10.0% Prob": 3.470831336119236, "Min_20.0% Prob": 2.008043107713104, "Min_30.0% Prob": 1.374370601912171, "Min_40.0% Prob": 1.0364299873244904, "Min_50.0% Prob": 0.8302055751209899, "Min_60.0% Prob": 0.6919768647062858}}
{"hexsha": "1ca131f129f86a544fb635527878ac72aefa3458", "ext": "java", "lang": "Java", "content": "@Api(value = \"Page API\")\n@RestController\n@RequestMapping(\"/api/v1/cms/pages\")\npublic class PageController extends _BaseApi<Page> {\n\n\t@Autowired\n\tPageService pageService;\n\n\t@Override\n\tpublic void delete(long id) {\n\t\tPage p = this.pageService.get(id);\n\t\tif (p != null) {\n\t\t\tthis.pageService.deleteAllAttachments(p.getId(), p.getBoTypeId());\n\t\t}\n\t\tsuper.delete(id);\n\t}\n\n\t@Override\n\tpublic Object upload(MultipartFile file, HttpServletRequest request) throws IllegalStateException, IOException {\n\t\tFileInfo fi = (FileInfo) super.upload(file, request);\n\n\t\tAttachment attachment = new Attachment();\n\t\tattachment.setPath(fi.getRelativePath());\n\t\tattachment.setExtensionName(fi.getExtensionName());\n\t\tattachment.setFileName(fi.getName());\n\t\tattachment.setFileType(fi.getType());\n\t\tattachment.setBoId(Long.parseLong(request.getParameter(\"boId\")));\n\t\tattachment.setBoTypeId(Long.parseLong(request.getParameter(\"boTypeId\")));\n\t\tthis.pageService.addAttachment(attachment);\n\n\t\treturn attachment;\n\t}\n\n}", "class_id": 0, "repo": "limingxu/web-framework-for-java", "file": "src/main/java/net/bndy/wf/modules/cms/api/PageController.java", "last_update_at": "2018-06-25T17:33:05+00:00", "question_id": "1ca131f129f86a544fb635527878ac72aefa3458", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Api(value = \"Page API\")\n@RestController\n@RequestMapping(\"/api/v1/cms/pages\")\npublic class PageController extends _BaseApi<Page> {\n\t@Autowired\n\tPageService pageService;\n\t@Override\n\tpublic void delete(long id) {\n\t\tPage p = this.pageService.get(id);\n\t\tif (p != null) {\n\t\t\tthis.pageService.deleteAllAttachments(p.getId(), p.getBoTypeId());\n\t\t}\n\t\tsuper.delete(id);\n\t}\n\t@Override\n\tpublic Object upload(MultipartFile file, HttpServletRequest request) throws IllegalStateException, IOException {\n\t\tFileInfo fi = (FileInfo) super.upload(file, request);\n\t\tAttachment attachment = new Attachment();\n\t\tattachment.setPath(fi.getRelativePath());\n\t\tattachment.setExtensionName(fi.getExtensionName());\n\t\tattachment.setFileName(fi.getName());\n\t\tattachment.setFileType(fi.getType());\n\t\tattachment.setBoId(Long.parseLong(request.getParameter(\"boId\")));\n\t\tattachment.setBoTypeId(Long.parseLong(request.getParameter(\"boTypeId\")));\n\t\tthis.pageService.addAttachment(attachment);\n\t\treturn attachment;\n\t}\n"]], "pred": {"ppl": 2.038100004196167, "ppl_lower": 2.594198226928711, "ppl/lowercase_ppl": -1.3388390404995425, "ppl/zlib": 0.0015614429898444275, "Min_5.0% Prob": 6.484822899103165, "Min_10.0% Prob": 4.839964043010365, "Min_20.0% Prob": 3.194486253189318, "Min_30.0% Prob": 2.2922292131185533, "Min_40.0% Prob": 1.7647147557901262, "Min_50.0% Prob": 1.4181125726394668, "Min_60.0% Prob": 1.187666498613544}}
{"hexsha": "bb913a430ade86c7ba7a428cb00aa1d67efe018f", "ext": "java", "lang": "Java", "content": "public class Migration {\n\n    public static void rekey(\n            Account from,\n            Account to,\n            Callback1<List<String>> callback\n    ) {\n        checkValid(() -> from != null && to != null, \"account is null\");\n        checkValid(\n                () -> !from.getAccountNumber().equals(to.getAccountNumber()),\n                \"cannot use same account for rekey\"\n        );\n        getOwningBitmarks(from).thenCompose(bitmarks -> offer(\n                bitmarks,\n                from,\n                to\n        )).thenCompose(offers -> respond(offers, to)).whenComplete(\n                (txIds, throwable) -> {\n                    if (throwable != null) {\n                        callback.onError(throwable instanceof CompletionException\n                                         ? throwable.getCause()\n                                         : throwable);\n                    } else {\n                        callback.onSuccess(txIds);\n                    }\n                });\n    }\n\n    private static CompletableFuture<List<String>> respond(\n            List<OfferRecord> offers,\n            Account receiver\n    ) {\n        if (offers.isEmpty()) {\n            return CompletableFuture.supplyAsync(ArrayList::new);\n        }\n\n        return CompletableFuture.supplyAsync(() -> offers.stream()\n                .map(offer -> {\n                    TransferResponseParams param = TransferResponseParams.accept(\n                            offer);\n                    param.sign(receiver.getAuthKeyPair());\n                    return param;\n                })\n                .map(param -> CompletableFuture.supplyAsync(() -> {\n                    try {\n                        return Awaitility.<String>await(callback -> Bitmark.respond(\n                                param,\n                                callback\n                        ));\n                    } catch (Throwable e) {\n                        throw new CompletionException(e);\n                    }\n                }))\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList()));\n    }\n\n    private static CompletableFuture<List<OfferRecord>> offer(\n            List<BitmarkRecord> bitmarks,\n            Account sender,\n            Account receiver\n    ) {\n        if (bitmarks.isEmpty()) {\n            return CompletableFuture.supplyAsync(ArrayList::new);\n        }\n\n        return CompletableFuture.supplyAsync(() -> {\n            List<Pair<String, TransferOfferParams>> params = bitmarks.stream()\n                    .map(bm -> {\n                        TransferOfferParams param = new TransferOfferParams(\n                                receiver.toAddress(),\n                                bm.getHeadId()\n                        );\n                        param.sign(sender.getAuthKeyPair());\n                        return new Pair<>(bm.getId(), param);\n                    })\n                    .collect(Collectors.toList());\n\n            return params.stream()\n                    .map(p -> CompletableFuture.supplyAsync(\n                            () -> {\n                                try {\n                                    String bitmarkId = p.first();\n                                    TransferOfferParams param = p.second();\n                                    Awaitility.<String>await(callback -> Bitmark\n                                            .offer(param, callback));\n                                    GetBitmarkResponse res = await(callback -> Bitmark\n                                            .get(bitmarkId, callback));\n                                    return res.getBitmark().getOffer();\n                                } catch (Throwable e) {\n                                    throw new CompletionException(e);\n                                }\n                            }))\n                    .map(CompletableFuture::join)\n                    .collect(Collectors.toList());\n        });\n    }\n\n    private static CompletableFuture<List<BitmarkRecord>> getOwningBitmarks(\n            Account owner\n    ) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                final List<BitmarkRecord> bitmarks = new ArrayList<>();\n\n                boolean existing = true;\n                Long offset = null;\n                while (existing) {\n                    BitmarkQueryBuilder builder = new BitmarkQueryBuilder().ownedBy(\n                            owner.getAccountNumber())\n                            .to(\"earlier\")\n                            .limit(100)\n                            .pending(false);\n                    if (offset != null) {\n                        builder.at(offset);\n                    }\n                    GetBitmarksResponse res = await(callback -> Bitmark.list(\n                            builder,\n                            callback\n                    ));\n                    List<BitmarkRecord> bms = res.getBitmarks();\n                    existing = bms.size() == 100;\n                    if (existing) {\n                        offset = bms.get(bms.size() - 1).getOffset();\n                    }\n                    bitmarks.addAll(bms);\n                }\n                return bitmarks;\n            } catch (Throwable e) {\n                throw new CompletionException(e);\n            }\n        });\n    }\n}", "class_id": 0, "repo": "bitmark-inc/bitmark-sdk-java", "file": "java-sdk/src/main/java/com/bitmark/sdk/features/Migration.java", "last_update_at": "2018-09-21T05:01:42+00:00", "question_id": "bb913a430ade86c7ba7a428cb00aa1d67efe018f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Migration {\n    public static void rekey(\n            Account from,\n            Account to,\n            Callback1<List<String>> callback\n    ) {\n        checkValid(() -> from != null && to != null, \"account is null\");\n        checkValid(\n                () -> !from.getAccountNumber().equals(to.getAccountNumber()),\n                \"cannot use same account for rekey\"\n        );\n        getOwningBitmarks(from).thenCompose(bitmarks -> offer(\n                bitmarks,\n                from,\n                to\n        )).thenCompose(offers -> respond(offers, to)).whenComplete(\n                (txIds, throwable) -> {\n                    if (throwable != null) {\n                        callback.onError(throwable instanceof CompletionException\n                                         ? throwable.getCause()\n                                         : throwable);\n                    } else {\n                        callback.onSuccess(txIds);\n                    }\n                });\n    }\n    private static CompletableFuture<List<String>> respond(\n            List<OfferRecord> offers,\n            Account receiver\n    ) {\n        if (offers.isEmpty()) {\n            return CompletableFuture.supplyAsync(ArrayList::new);\n        }\n        return CompletableFuture.supplyAsync(() -> offers.stream()\n                .map(offer -> {\n                    TransferResponseParams param = TransferResponseParams.accept(\n                            offer);\n                    param.sign(receiver.getAuthKeyPair());\n                    return param;\n                })\n                .map(param -> CompletableFuture.supplyAsync(() -> {\n                    try {\n                        return Awaitility.<String>await(callback -> Bitmark.respond(\n                                param,\n                                callback\n                        ));\n                    } catch (Throwable e) {\n                        throw new CompletionException(e);\n                    }\n                }))\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList()));\n    }\n    private static CompletableFuture<List<OfferRecord>> offer(\n            List<BitmarkRecord> bitmarks,\n            Account sender,\n            Account receiver\n    ) {\n        if (bitmarks.isEmpty()) {\n            return CompletableFuture.supplyAsync(ArrayList::new);\n        }\n        return CompletableFuture.supplyAsync(() -> {\n            List<Pair<String, TransferOfferParams>> params = bitmarks.stream()\n                    .map(bm -> {\n                        TransferOfferParams param = new TransferOfferParams(\n                                receiver.toAddress(),\n                                bm.getHeadId()\n                        );\n                        param.sign(sender.getAuthKeyPair());\n                        return new Pair<>(bm.getId(), param);\n                    })\n                    .collect(Collectors.toList());\n            return params.stream()\n                    .map(p -> CompletableFuture.supplyAsync(\n                            () -> {\n                                try {\n                                    String bitmarkId = p.first();\n                                    TransferOfferParams param = p.second();\n                                    Awaitility.<String>await(callback -> Bitmark\n                                            .offer(param, callback));\n                                    GetBitmarkResponse res = await(callback -> Bitmark\n                                            .get(bitmarkId, callback));\n                                    return res.getBitmark().getOffer();\n                                } catch (Throwable e) {\n                                    throw new CompletionException(e);\n                                }\n                            }))\n                    .map(CompletableFuture::join)\n                    .collect(Collectors.toList());\n        });\n    }\n    private static CompletableFuture<List<BitmarkRecord>> getOwningBitmarks(\n            Account owner\n    ) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                final List<BitmarkRecord> bitmarks = new ArrayList<>();\n                boolean existing = true;\n                Long offset = null;\n                while (existing) {\n                    BitmarkQueryBuilder builder = new BitmarkQueryBuilder().ownedBy(\n                            owner.getAccountNumber())\n                            .to(\"earlier\")\n                            .limit(100)\n                            .pending(false);\n                    if (offset != null) {\n                        builder.at(offset);\n                    }\n                    GetBitmarksResponse res = await(callback -> Bitmark.list(\n                            builder,\n                            callback\n                    ));\n                    List<BitmarkRecord> bms = res.getBitmarks();\n                    existing = bms.size() == 100;\n                    if (existing) {\n                        offset = bms.get(bms.size() - 1).getOffset();\n                    }\n                    bitmarks.addAll(bms);\n                }\n                return bitmarks;\n            } catch (Throwable e) {\n                throw new CompletionException(e);\n            }\n        });\n    }\n"]], "pred": {"ppl": 1.9011973142623901, "ppl_lower": 2.0939078330993652, "ppl/lowercase_ppl": -1.150273416450601, "ppl/zlib": 0.0005331816208322088, "Min_5.0% Prob": 6.461911444570504, "Min_10.0% Prob": 4.762532339376562, "Min_20.0% Prob": 2.9826461769202175, "Min_30.0% Prob": 2.1025709834168937, "Min_40.0% Prob": 1.5970857322379983, "Min_50.0% Prob": 1.2837605567124113, "Min_60.0% Prob": 1.0715705822183952}}
{"hexsha": "1a66b5926a436792c4e6e85893917c876d89113e", "ext": "java", "lang": "Java", "content": "public class IntervalsResourceTest\n{\n  private InventoryView inventoryView;\n  private DruidServer server;\n  private List<DataSegment> dataSegmentList;\n  private HttpServletRequest request;\n\n  @Before\n  public void setUp()\n  {\n    inventoryView = EasyMock.createStrictMock(InventoryView.class);\n    server = EasyMock.createStrictMock(DruidServer.class);\n    request = EasyMock.createStrictMock(HttpServletRequest.class);\n\n    dataSegmentList = new ArrayList<>();\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource1\",\n            Intervals.of(\"2010-01-01T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            20\n        )\n    );\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource1\",\n            Intervals.of(\"2010-01-22T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            10\n        )\n    );\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource2\",\n            Intervals.of(\"2010-01-01T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            5\n        )\n    );\n    server = new DruidServer(\"who\", \"host\", null, 1234, ServerType.HISTORICAL, \"tier1\", 0);\n    server.addDataSegment(dataSegmentList.get(0).getIdentifier(), dataSegmentList.get(0));\n    server.addDataSegment(dataSegmentList.get(1).getIdentifier(), dataSegmentList.get(1));\n    server.addDataSegment(dataSegmentList.get(2).getIdentifier(), dataSegmentList.get(2));\n  }\n\n  @Test\n  public void testGetIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    expectedIntervals.add(Intervals.of(\"2010-01-22T00:00:00.000Z/2010-01-23T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n\n    Response response = intervalsResource.getIntervals(request);\n    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();\n    Assert.assertEquals(2, actualIntervals.size());\n    Assert.assertEquals(expectedIntervals.get(1), actualIntervals.firstKey());\n    Assert.assertEquals(10L, actualIntervals.get(expectedIntervals.get(1)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(1)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.lastKey());\n    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"count\"));\n\n  }\n\n  @Test\n  public void testSimpleGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", \"simple\", null, request);\n    Map<Interval, Map<String, Object>> actualIntervals = (Map) response.getEntity();\n    Assert.assertEquals(1, actualIntervals.size());\n    Assert.assertTrue(actualIntervals.containsKey(expectedIntervals.get(0)));\n    Assert.assertEquals(25L, actualIntervals.get(expectedIntervals.get(0)).get(\"size\"));\n    Assert.assertEquals(2, actualIntervals.get(expectedIntervals.get(0)).get(\"count\"));\n\n  }\n\n  @Test\n  public void testFullGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", null, \"full\", request);\n    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();\n    Assert.assertEquals(1, actualIntervals.size());\n    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.firstKey());\n    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"count\"));\n\n  }\n\n  @Test\n  public void testGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", null, null, request);\n    Map<String, Object> actualIntervals = (Map) response.getEntity();\n    Assert.assertEquals(2, actualIntervals.size());\n    Assert.assertEquals(25L, actualIntervals.get(\"size\"));\n    Assert.assertEquals(2, actualIntervals.get(\"count\"));\n  }\n\n  @After\n  public void tearDown()\n  {\n    EasyMock.verify(inventoryView);\n  }\n\n}", "class_id": 0, "repo": "elloooooo/druid", "file": "server/src/test/java/io/druid/server/http/IntervalsResourceTest.java", "last_update_at": "2018-08-12T14:17:32+00:00", "question_id": "1a66b5926a436792c4e6e85893917c876d89113e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IntervalsResourceTest\n{\n  private InventoryView inventoryView;\n  private DruidServer server;\n  private List<DataSegment> dataSegmentList;\n  private HttpServletRequest request;\n  @Before\n  public void setUp()\n  {\n    inventoryView = EasyMock.createStrictMock(InventoryView.class);\n    server = EasyMock.createStrictMock(DruidServer.class);\n    request = EasyMock.createStrictMock(HttpServletRequest.class);\n    dataSegmentList = new ArrayList<>();\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource1\",\n            Intervals.of(\"2010-01-01T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            20\n        )\n    );\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource1\",\n            Intervals.of(\"2010-01-22T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            10\n        )\n    );\n    dataSegmentList.add(\n        new DataSegment(\n            \"datasource2\",\n            Intervals.of(\"2010-01-01T00:00:00.000Z/P1D\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            0x9,\n            5\n        )\n    );\n    server = new DruidServer(\"who\", \"host\", null, 1234, ServerType.HISTORICAL, \"tier1\", 0);\n    server.addDataSegment(dataSegmentList.get(0).getIdentifier(), dataSegmentList.get(0));\n    server.addDataSegment(dataSegmentList.get(1).getIdentifier(), dataSegmentList.get(1));\n    server.addDataSegment(dataSegmentList.get(2).getIdentifier(), dataSegmentList.get(2));\n  }\n  @Test\n  public void testGetIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    expectedIntervals.add(Intervals.of(\"2010-01-22T00:00:00.000Z/2010-01-23T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n    Response response = intervalsResource.getIntervals(request);\n    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();\n    Assert.assertEquals(2, actualIntervals.size());\n    Assert.assertEquals(expectedIntervals.get(1), actualIntervals.firstKey());\n    Assert.assertEquals(10L, actualIntervals.get(expectedIntervals.get(1)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(1)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.lastKey());\n    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"count\"));\n  }\n  @Test\n  public void testSimpleGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", \"simple\", null, request);\n    Map<Interval, Map<String, Object>> actualIntervals = (Map) response.getEntity();\n    Assert.assertEquals(1, actualIntervals.size());\n    Assert.assertTrue(actualIntervals.containsKey(expectedIntervals.get(0)));\n    Assert.assertEquals(25L, actualIntervals.get(expectedIntervals.get(0)).get(\"size\"));\n    Assert.assertEquals(2, actualIntervals.get(expectedIntervals.get(0)).get(\"count\"));\n  }\n  @Test\n  public void testFullGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n    List<Interval> expectedIntervals = new ArrayList<>();\n    expectedIntervals.add(Intervals.of(\"2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z\"));\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", null, \"full\", request);\n    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();\n    Assert.assertEquals(1, actualIntervals.size());\n    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.firstKey());\n    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource1\").get(\"count\"));\n    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"size\"));\n    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get(\"datasource2\").get(\"count\"));\n  }\n  @Test\n  public void testGetSpecificIntervals()\n  {\n    EasyMock.expect(inventoryView.getInventory()).andReturn(\n        ImmutableList.of(server)\n    ).atLeastOnce();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();\n    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(\n        new AuthenticationResult(\"druid\", \"druid\", null)\n    ).once();\n    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);\n    EasyMock.expectLastCall().times(1);\n    EasyMock.replay(inventoryView, request);\n    IntervalsResource intervalsResource = new IntervalsResource(\n        inventoryView,\n        new AuthConfig(),\n        AuthTestUtils.TEST_AUTHORIZER_MAPPER\n    );\n    Response response = intervalsResource.getSpecificIntervals(\"2010-01-01T00:00:00.000Z/P1D\", null, null, request);\n    Map<String, Object> actualIntervals = (Map) response.getEntity();\n    Assert.assertEquals(2, actualIntervals.size());\n    Assert.assertEquals(25L, actualIntervals.get(\"size\"));\n    Assert.assertEquals(2, actualIntervals.get(\"count\"));\n  }\n  @After\n  public void tearDown()\n  {\n    EasyMock.verify(inventoryView);\n  }\n"]], "pred": {"ppl": 1.3392741680145264, "ppl_lower": 1.746569037437439, "ppl/lowercase_ppl": -1.908936125046712, "ppl/zlib": 0.0002712421555693389, "Min_5.0% Prob": 3.9789421511631384, "Min_10.0% Prob": 2.5486196373023238, "Min_20.0% Prob": 1.4269624997441674, "Min_30.0% Prob": 0.970441573488167, "Min_40.0% Prob": 0.729625041347252, "Min_50.0% Prob": 0.5846299868896732, "Min_60.0% Prob": 0.48746163735047876}}
{"hexsha": "2b57b96e136592281b17f49acc9e388761918984", "ext": "java", "lang": "Java", "content": "class EmbeddedInternalConnectionPool {\n    private final ConcurrentPool<EmbeddedInternalConnection> pool;\n    private volatile boolean closed;\n\n    EmbeddedInternalConnectionPool(final EmbeddedInternalConnectionFactory internalConnectionFactory) {\n        this.pool = new ConcurrentPool<EmbeddedInternalConnection>(Integer.MAX_VALUE,\n                new EmbeddedConnectionItemFactory(internalConnectionFactory));\n    }\n\n    InternalConnection get() {\n        isTrue(\"Embedded connection pool is open\", !closed);\n        return getPooledConnection();\n    }\n\n    void close() {\n        if (!closed) {\n            pool.close();\n            closed = true;\n        }\n    }\n\n    private static class EmbeddedConnectionItemFactory implements ConcurrentPool.ItemFactory<EmbeddedInternalConnection> {\n        private final EmbeddedInternalConnectionFactory internalConnectionFactory;\n\n        EmbeddedConnectionItemFactory(final EmbeddedInternalConnectionFactory internalConnectionFactory) {\n            this.internalConnectionFactory = internalConnectionFactory;\n        }\n\n        @Override\n        public EmbeddedInternalConnection create(final boolean initialize) {\n            return internalConnectionFactory.create();\n        }\n\n        @Override\n        public void close(final EmbeddedInternalConnection embeddedInternalConnection) {\n            embeddedInternalConnection.close();\n        }\n\n        @Override\n        public ConcurrentPool.Prune shouldPrune(final EmbeddedInternalConnection embeddedInternalConnection) {\n            return ConcurrentPool.Prune.NO;\n        }\n    }\n\n    private InternalConnection getPooledConnection() {\n        PooledConnection connection = new PooledConnection(pool.get());\n        if (!connection.opened()) {\n            connection.open();\n        }\n        return connection;\n    }\n\n    private class PooledConnection implements InternalConnection {\n        private final EmbeddedInternalConnection wrapped;\n        private final AtomicBoolean isClosed = new AtomicBoolean();\n\n        PooledConnection(final EmbeddedInternalConnection wrapped) {\n            this.wrapped = wrapped;\n        }\n\n        @Override\n        public ConnectionDescription getDescription() {\n            return wrapped.getDescription();\n        }\n\n        @Override\n        public void open() {\n            wrapped.open();\n        }\n\n        @Override\n        public void openAsync(final SingleResultCallback<Void> callback) {\n            wrapped.openAsync(callback);\n        }\n\n        @Override\n        public void close() {\n            // All but the first call is a no-op\n            if (!isClosed.getAndSet(true)) {\n                pool.release(wrapped, wrapped.isClosed());\n            }\n        }\n\n        @Override\n        public boolean opened() {\n            return wrapped.opened();\n        }\n\n        @Override\n        public boolean isClosed() {\n            return wrapped.isClosed();\n        }\n\n        @Override\n        public <T> T sendAndReceive(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext) {\n            return wrapped.sendAndReceive(message, decoder, sessionContext);\n        }\n\n        @Override\n        public <T> void sendAndReceiveAsync(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext,\n                                            final SingleResultCallback<T> callback) {\n            wrapped.sendAndReceiveAsync(message, decoder, sessionContext, callback);\n        }\n\n        @Override\n        public void sendMessage(final List<ByteBuf> byteBuffers, final int lastRequestId) {\n            wrapped.sendMessage(byteBuffers, lastRequestId);\n        }\n\n        @Override\n        public ResponseBuffers receiveMessage(final int responseTo) {\n            return wrapped.receiveMessage(responseTo);\n        }\n\n        @Override\n        public void sendMessageAsync(final List<ByteBuf> byteBuffers, final int lastRequestId, final SingleResultCallback<Void> callback) {\n            wrapped.sendMessageAsync(byteBuffers, lastRequestId, callback);\n        }\n\n        @Override\n        public void receiveMessageAsync(final int responseTo, final SingleResultCallback<ResponseBuffers> callback) {\n            wrapped.receiveMessageAsync(responseTo, callback);\n        }\n\n        @Override\n        public ByteBuf getBuffer(final int size) {\n            return wrapped.getBuffer(size);\n        }\n    }\n\n}", "class_id": 0, "repo": "mebigfatguy/mongo-java-driver", "file": "driver-embedded/src/main/com/mongodb/embedded/client/EmbeddedInternalConnectionPool.java", "last_update_at": "2018-12-19T06:13:26+00:00", "question_id": "2b57b96e136592281b17f49acc9e388761918984", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class EmbeddedInternalConnectionPool {\n    private final ConcurrentPool<EmbeddedInternalConnection> pool;\n    private volatile boolean closed;\n    EmbeddedInternalConnectionPool(final EmbeddedInternalConnectionFactory internalConnectionFactory) {\n        this.pool = new ConcurrentPool<EmbeddedInternalConnection>(Integer.MAX_VALUE,\n                new EmbeddedConnectionItemFactory(internalConnectionFactory));\n    }\n    InternalConnection get() {\n        isTrue(\"Embedded connection pool is open\", !closed);\n        return getPooledConnection();\n    }\n    void close() {\n        if (!closed) {\n            pool.close();\n            closed = true;\n        }\n    }\n    private static class EmbeddedConnectionItemFactory implements ConcurrentPool.ItemFactory<EmbeddedInternalConnection> {\n        private final EmbeddedInternalConnectionFactory internalConnectionFactory;\n        EmbeddedConnectionItemFactory(final EmbeddedInternalConnectionFactory internalConnectionFactory) {\n            this.internalConnectionFactory = internalConnectionFactory;\n        }\n        @Override\n        public EmbeddedInternalConnection create(final boolean initialize) {\n            return internalConnectionFactory.create();\n        }\n        @Override\n        public void close(final EmbeddedInternalConnection embeddedInternalConnection) {\n            embeddedInternalConnection.close();\n        }\n        @Override\n        public ConcurrentPool.Prune shouldPrune(final EmbeddedInternalConnection embeddedInternalConnection) {\n            return ConcurrentPool.Prune.NO;\n        }\n    }\n    private InternalConnection getPooledConnection() {\n        PooledConnection connection = new PooledConnection(pool.get());\n        if (!connection.opened()) {\n            connection.open();\n        }\n        return connection;\n    }\n    private class PooledConnection implements InternalConnection {\n        private final EmbeddedInternalConnection wrapped;\n        private final AtomicBoolean isClosed = new AtomicBoolean();\n        PooledConnection(final EmbeddedInternalConnection wrapped) {\n            this.wrapped = wrapped;\n        }\n        @Override\n        public ConnectionDescription getDescription() {\n            return wrapped.getDescription();\n        }\n        @Override\n        public void open() {\n            wrapped.open();\n        }\n        @Override\n        public void openAsync(final SingleResultCallback<Void> callback) {\n            wrapped.openAsync(callback);\n        }\n        @Override\n        public void close() {\n            // All but the first call is a no-op\n            if (!isClosed.getAndSet(true)) {\n                pool.release(wrapped, wrapped.isClosed());\n            }\n        }\n        @Override\n        public boolean opened() {\n            return wrapped.opened();\n        }\n        @Override\n        public boolean isClosed() {\n            return wrapped.isClosed();\n        }\n        @Override\n        public <T> T sendAndReceive(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext) {\n            return wrapped.sendAndReceive(message, decoder, sessionContext);\n        }\n        @Override\n        public <T> void sendAndReceiveAsync(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext,\n                                            final SingleResultCallback<T> callback) {\n            wrapped.sendAndReceiveAsync(message, decoder, sessionContext, callback);\n        }\n        @Override\n        public void sendMessage(final List<ByteBuf> byteBuffers, final int lastRequestId) {\n            wrapped.sendMessage(byteBuffers, lastRequestId);\n        }\n        @Override\n        public ResponseBuffers receiveMessage(final int responseTo) {\n            return wrapped.receiveMessage(responseTo);\n        }\n        @Override\n        public void sendMessageAsync(final List<ByteBuf> byteBuffers, final int lastRequestId, final SingleResultCallback<Void> callback) {\n            wrapped.sendMessageAsync(byteBuffers, lastRequestId, callback);\n        }\n        @Override\n        public void receiveMessageAsync(final int responseTo, final SingleResultCallback<ResponseBuffers> callback) {\n            wrapped.receiveMessageAsync(responseTo, callback);\n        }\n        @Override\n        public ByteBuf getBuffer(final int size) {\n            return wrapped.getBuffer(size);\n        }\n    }\n"]], "pred": {"ppl": 1.3910009860992432, "ppl_lower": 1.771034598350525, "ppl/lowercase_ppl": -1.7318878310911818, "ppl/zlib": 0.00036346213860678474, "Min_5.0% Prob": 4.477579962973501, "Min_10.0% Prob": 2.8665640225597455, "Min_20.0% Prob": 1.6078832025329273, "Min_30.0% Prob": 1.0975530893827965, "Min_40.0% Prob": 0.8242660919955788, "Min_50.0% Prob": 0.6603446891242019, "Min_60.0% Prob": 0.5506621166784734}}
{"hexsha": "417ebb05ad718a619e0b1d2a468e5237325991e2", "ext": "java", "lang": "Java", "content": "public class CloudStackUsageTypes {\n\n    /**\n     * Access list of vanilla usage record types\n     *\n     * @return list\n     */\n    public static List<String> getList() {\n        List<String> list = new ArrayList<String>();\n\n        // we have to add them manually\n        list.add(new VMUsageData().getMeterNameForRunning());\n        list.add(new VMUsageData().getMeterNameForAllocated());\n        list.add(new IPUsageData().getMeterName());\n        list.add(new NetworkUsageData().getMeterNameForOutgoing());\n        list.add(new NetworkUsageData().getMeterNameForIncoming());\n        list.add(new VolumeUsageData().getMeterName());\n        list.add(new TemplateAndIsoUsageData().getMeterNameTemplate());\n        list.add(new TemplateAndIsoUsageData().getMeterNameISO());\n        list.add(new SnapshotUsageData().getMeterName());\n        list.add(new PolicyOrRuleUsageData().getMeterNameBalancer());\n        list.add(new PolicyOrRuleUsageData().getMeterNameForwarder());\n        list.add(new NetworkOfferingUsageData().getMeterName());\n        list.add(new VPNUserUsageData().getMeterName());\n\n        return list;\n    }\n\n}", "class_id": 0, "repo": "icclab/cyclops-udr", "file": "src/main/java/ch/icclab/cyclops/services/iaas/cloudstack/model/CloudStackUsageTypes.java", "last_update_at": "2018-04-23T09:39:54+00:00", "question_id": "417ebb05ad718a619e0b1d2a468e5237325991e2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CloudStackUsageTypes {\n    /**\n     * Access list of vanilla usage record types\n     *\n     * @return list\n     */\n    public static List<String> getList() {\n        List<String> list = new ArrayList<String>();\n        // we have to add them manually\n        list.add(new VMUsageData().getMeterNameForRunning());\n        list.add(new VMUsageData().getMeterNameForAllocated());\n        list.add(new IPUsageData().getMeterName());\n        list.add(new NetworkUsageData().getMeterNameForOutgoing());\n        list.add(new NetworkUsageData().getMeterNameForIncoming());\n        list.add(new VolumeUsageData().getMeterName());\n        list.add(new TemplateAndIsoUsageData().getMeterNameTemplate());\n        list.add(new TemplateAndIsoUsageData().getMeterNameISO());\n        list.add(new SnapshotUsageData().getMeterName());\n        list.add(new PolicyOrRuleUsageData().getMeterNameBalancer());\n        list.add(new PolicyOrRuleUsageData().getMeterNameForwarder());\n        list.add(new NetworkOfferingUsageData().getMeterName());\n        list.add(new VPNUserUsageData().getMeterName());\n        return list;\n    }\n"]], "pred": {"ppl": 2.4156699180603027, "ppl_lower": 3.0329203605651855, "ppl/lowercase_ppl": -1.2579992610507174, "ppl/zlib": 0.002556454050490845, "Min_5.0% Prob": 8.797498494386673, "Min_10.0% Prob": 6.487083330750465, "Min_20.0% Prob": 4.125900899991393, "Min_30.0% Prob": 2.9230089620687068, "Min_40.0% Prob": 2.199720639331165, "Min_50.0% Prob": 1.766934005659282, "Min_60.0% Prob": 1.4752512996982532}}
{"hexsha": "93326e75e3397b8a07e7421f3c95872f50434f89", "ext": "java", "lang": "Java", "content": "public class DateUtil {\n\n    public DateUtil() {\n        super();\n    }\n\n    public static boolean checkIfPeriodIsValid(String startDate, String endDate) {\n        int[] startPeriod = Arrays.stream(startDate.split(\"-\")).mapToInt(Integer::parseInt).toArray();\n        int[] endPeriod = Arrays.stream(endDate.split(\"-\")).mapToInt(Integer::parseInt).toArray();\n\n        // CHECK IF THE DATE IS BEFORE THE CURRENT DATE\n        int[] todaySplit = Arrays.stream(getCurrentDateAsString().split(\"-\"))\n                .mapToInt(Integer::parseInt)\n                .toArray();\n\n        if (todaySplit[0] > startPeriod[0] || todaySplit[1] > startPeriod[1] || todaySplit[2] > startPeriod[2]) {\n            throw new ApplicationRuntimeException(\"You cannot choose start date earlier than today!\");\n        }\n\n        // CHECK IF THE END DATE IS BEFORE THE START DATE\n        if (startPeriod[0] > endPeriod[0] || startPeriod[1] > endPeriod[1] || startPeriod[2] > endPeriod[2]) {\n            throw new ApplicationRuntimeException(\"Start date must be before End date!\");\n        }\n\n        return true;\n    }\n\n    public static String getTimeLapseOfSession(String startHour, String endHour) {\n        //da predpolojim che podava startHour vuv format hh:MM\n        String[] startHourTokens = startHour.split(\":\");\n        String[] endHourTokens = endHour.split(\":\");\n\n        TimeDiffUtil start = new TimeDiffUtil(Integer.parseInt(startHourTokens[0]), Integer.parseInt(startHourTokens[1]), 00);\n        TimeDiffUtil end = new TimeDiffUtil(Integer.parseInt(endHourTokens[0]), Integer.parseInt(endHourTokens[1]), 00);\n\n        TimeDiffUtil diff = TimeDiffUtil.difference(start, end);\n\n        return diff.getHours() + \":\" + diff.getMinutes();\n\n    }\n\n    public static int comparatorByStringDates(String dateOne, String dateTwo) {\n        Comparator<String> comparator = (x, y) -> {\n            int[] xColect = Arrays.stream(x.split(\"-\"))\n                    .mapToInt(Integer::parseInt)\n                    .toArray();\n\n            int[] yCollect = Arrays.stream(y.split(\"-\"))\n                    .mapToInt(Integer::parseInt)\n                    .toArray();\n\n            int year1 = xColect[0];\n            int month1 = xColect[1];\n            int day1 = xColect[2];\n\n            int year2 = yCollect[0];\n            int month2 = yCollect[1];\n            int day2 = yCollect[2];\n\n\n            if (year1 - year2 != 0) {\n                return year1 - year2;\n            }\n\n            if (month1 - month2 != 0) {\n                return month1 - month2;\n            }\n\n            if (day1 - day2 != 0) {\n                return day1 - day2;\n            }\n\n            return 0;\n        };\n\n        return comparator.compare(dateOne, dateTwo);\n    }\n\n    public static String getCurrentDateAsString() {\n        return LocalDate.now().toString();\n    }\n\n    public static String getCurrentTimeAsString() {\n        String[] runtime = LocalDateTime.now().toString().split(\":\");\n        return runtime[0].substring(runtime[0].length() - 2) + \":\" + runtime[1];\n    }\n\n\n}", "class_id": 0, "repo": "MarianDeninski/WebApplicationConference", "file": "src/main/java/com/teamthree/conferencescheduler/app_utils/DateUtil.java", "last_update_at": "2018-07-07T02:28:58+00:00", "question_id": "93326e75e3397b8a07e7421f3c95872f50434f89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DateUtil {\n    public DateUtil() {\n        super();\n    }\n    public static boolean checkIfPeriodIsValid(String startDate, String endDate) {\n        int[] startPeriod = Arrays.stream(startDate.split(\"-\")).mapToInt(Integer::parseInt).toArray();\n        int[] endPeriod = Arrays.stream(endDate.split(\"-\")).mapToInt(Integer::parseInt).toArray();\n        // CHECK IF THE DATE IS BEFORE THE CURRENT DATE\n        int[] todaySplit = Arrays.stream(getCurrentDateAsString().split(\"-\"))\n                .mapToInt(Integer::parseInt)\n                .toArray();\n        if (todaySplit[0] > startPeriod[0] || todaySplit[1] > startPeriod[1] || todaySplit[2] > startPeriod[2]) {\n            throw new ApplicationRuntimeException(\"You cannot choose start date earlier than today!\");\n        }\n        // CHECK IF THE END DATE IS BEFORE THE START DATE\n        if (startPeriod[0] > endPeriod[0] || startPeriod[1] > endPeriod[1] || startPeriod[2] > endPeriod[2]) {\n            throw new ApplicationRuntimeException(\"Start date must be before End date!\");\n        }\n        return true;\n    }\n    public static String getTimeLapseOfSession(String startHour, String endHour) {\n        //da predpolojim che podava startHour vuv format hh:MM\n        String[] startHourTokens = startHour.split(\":\");\n        String[] endHourTokens = endHour.split(\":\");\n        TimeDiffUtil start = new TimeDiffUtil(Integer.parseInt(startHourTokens[0]), Integer.parseInt(startHourTokens[1]), 00);\n        TimeDiffUtil end = new TimeDiffUtil(Integer.parseInt(endHourTokens[0]), Integer.parseInt(endHourTokens[1]), 00);\n        TimeDiffUtil diff = TimeDiffUtil.difference(start, end);\n        return diff.getHours() + \":\" + diff.getMinutes();\n    }\n    public static int comparatorByStringDates(String dateOne, String dateTwo) {\n        Comparator<String> comparator = (x, y) -> {\n            int[] xColect = Arrays.stream(x.split(\"-\"))\n                    .mapToInt(Integer::parseInt)\n                    .toArray();\n            int[] yCollect = Arrays.stream(y.split(\"-\"))\n                    .mapToInt(Integer::parseInt)\n                    .toArray();\n            int year1 = xColect[0];\n            int month1 = xColect[1];\n            int day1 = xColect[2];\n            int year2 = yCollect[0];\n            int month2 = yCollect[1];\n            int day2 = yCollect[2];\n            if (year1 - year2 != 0) {\n                return year1 - year2;\n            }\n            if (month1 - month2 != 0) {\n                return month1 - month2;\n            }\n            if (day1 - day2 != 0) {\n                return day1 - day2;\n            }\n            return 0;\n        };\n        return comparator.compare(dateOne, dateTwo);\n    }\n    public static String getCurrentDateAsString() {\n        return LocalDate.now().toString();\n    }\n    public static String getCurrentTimeAsString() {\n        String[] runtime = LocalDateTime.now().toString().split(\":\");\n        return runtime[0].substring(runtime[0].length() - 2) + \":\" + runtime[1];\n    }\n"]], "pred": {"ppl": 1.7653098106384277, "ppl_lower": 1.9035929441452026, "ppl/lowercase_ppl": -1.1327000548444182, "ppl/zlib": 0.0006321759789637501, "Min_5.0% Prob": 6.251372782389323, "Min_10.0% Prob": 4.50746158891254, "Min_20.0% Prob": 2.718120210369428, "Min_30.0% Prob": 1.8687193075339292, "Min_40.0% Prob": 1.416544859289834, "Min_50.0% Prob": 1.134747829296486, "Min_60.0% Prob": 0.9473727773398167}}
{"hexsha": "5e039a1cd824f069304af157c77c9d997b7f3a9a", "ext": "java", "lang": "Java", "content": "public class LogHelper\n{\n    private static Consumer<String> onNewLogEntry = null;\n\n    public static void log(LogLevel level, String message, Object... args)\n    {\n        logInternal(level, message, args);\n    }\n\n    public static void log(Exception ex)\n    {\n        logInternal(LogLevel.ERROR, \"%s: %s\", ex.getClass().getName(), ex.getLocalizedMessage());\n    }\n\n    private static void logInternal(LogLevel level, String message, Object... args)\n    {\n        String m = String.format(message, args);\n        String logMessage = String.format(\"%s [%s]: %s\", ZonedDateTime.now().toLocalTime(), level.toString(), m);\n\n        System.out.println(logMessage);\n        if (onNewLogEntry != null)\n        {\n            onNewLogEntry.accept(logMessage);\n        }\n    }\n\n    public static void setOnNewLogEntry(Consumer<String> onNewLogEntry)\n    {\n        LogHelper.onNewLogEntry = onNewLogEntry;\n    }\n}", "class_id": 0, "repo": "prayzzz/8160_smartcard-programming", "file": "hotelbuddyGui/src/main/java/application/log/LogHelper.java", "last_update_at": "2018-12-10T22:50:02+00:00", "question_id": "5e039a1cd824f069304af157c77c9d997b7f3a9a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LogHelper\n{\n    private static Consumer<String> onNewLogEntry = null;\n    public static void log(LogLevel level, String message, Object... args)\n    {\n        logInternal(level, message, args);\n    }\n    public static void log(Exception ex)\n    {\n        logInternal(LogLevel.ERROR, \"%s: %s\", ex.getClass().getName(), ex.getLocalizedMessage());\n    }\n    private static void logInternal(LogLevel level, String message, Object... args)\n    {\n        String m = String.format(message, args);\n        String logMessage = String.format(\"%s [%s]: %s\", ZonedDateTime.now().toLocalTime(), level.toString(), m);\n        System.out.println(logMessage);\n        if (onNewLogEntry != null)\n        {\n            onNewLogEntry.accept(logMessage);\n        }\n    }\n    public static void setOnNewLogEntry(Consumer<String> onNewLogEntry)\n    {\n        LogHelper.onNewLogEntry = onNewLogEntry;\n    }\n"]], "pred": {"ppl": 1.6600319147109985, "ppl_lower": 1.983904242515564, "ppl/lowercase_ppl": -1.351651468693529, "ppl/zlib": 0.0013924088678932886, "Min_5.0% Prob": 5.524230480194092, "Min_10.0% Prob": 3.77710137458948, "Min_20.0% Prob": 2.319718131652245, "Min_30.0% Prob": 1.6430592565219613, "Min_40.0% Prob": 1.2602947477783475, "Min_50.0% Prob": 1.009775660085407, "Min_60.0% Prob": 0.8456854051910341}}
{"hexsha": "a3fd86e4939c7d81c4d19871b4946f3105ad47aa", "ext": "java", "lang": "Java", "content": "public class PlayerHelper {\n\n    private static final String PLAYER_INVENTORY_PRIMARY_KEY = \"primary\";\n    private static final String PLAYER_INVENTORY_ARMOR_KEY = \"armor\";\n\n    private static Method getOnlinePlayers;\n    public static boolean newOnlinePlayersMethod = false;\n\n    static {\n        try {\n            getOnlinePlayers = Bukkit.class.getMethod(\"getOnlinePlayers\");\n            if (getOnlinePlayers.getReturnType() == Collection.class) {\n                newOnlinePlayersMethod = true;\n            }\n        } catch (NoSuchMethodException ex) {\n            SteelCore.logSevere(\"Failed to get getOnlinePlayers method!\");\n            ex.printStackTrace();\n        }\n    }\n\n    /**\n     * Pushes the inventory of the given player into persistent storage.\n     *\n     * @param player The {@link Player} to push the inventory of\n     * @throws IOException If an exception occurs while saving into persistent\n     *     storage\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static void pushInventory(Player player) throws IOException {\n        PlayerInventory inv = player.getInventory();\n        // the file to store the inventory in\n        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + \".yml\");\n        if (storage.exists()) { // verify file isn't already present on disk (meaning it wasn't popped the last time)\n            SteelCore.logVerbose(\"Inventory push requested for player \" + player.getName() + \", but \"\n                    + \"inventory was already present in persistent storage. Popping stored inventory first.\");\n            try {\n                popInventory(player);\n            } catch (InvalidConfigurationException ex) {\n                throw new IOException(ex); // this is probably a bad thing of me to do but it's for a fringe case anyway\n            }\n        }\n        YamlConfiguration yaml = new YamlConfiguration();\n        yaml.set(PLAYER_INVENTORY_PRIMARY_KEY, InventoryHelper.serializeInventory(inv));\n        yaml.set(PLAYER_INVENTORY_ARMOR_KEY, InventoryHelper.serializeInventory(inv.getArmorContents()));\n        yaml.save(storage); // save to disk\n        inv.clear(); // clear the inventory to complete the push to disk\n        inv.setArmorContents(new ItemStack[inv.getArmorContents().length]);\n        player.updateInventory();\n    }\n\n    /**\n     * Pops the inventory of the given player from persistent storage.\n     *\n     * @param player The {@link Player} to pop the inventory of\n     * @throws IllegalArgumentException If the inventory of the given\n     *     {@link Player} is not present in persistent storage\n     * @throws IOException If an exception occurs while loading from persistent\n     *     storage\n     * @throws InvalidConfigurationException If the stored inventory is invalid\n     */\n    //TODO: generalize some of this code for use with rollback storage\n    @SuppressWarnings(\"deprecation\")\n    public static void popInventory(Player player) throws IllegalArgumentException, IOException,\n            InvalidConfigurationException {\n        // the file to load the inventory from\n        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + \".yml\");\n        if (!storage.exists()) { // verify file is present on disk\n            throw new IllegalArgumentException(\"Inventory pop requested for player \" + player.getName() + \", but \"\n                    + \"inventory was not present in persistent storage!\");\n        }\n        YamlConfiguration yaml = new YamlConfiguration();\n        yaml.load(storage); // load from disk\n        if (!yaml.contains(PLAYER_INVENTORY_PRIMARY_KEY)) {\n            throw new InvalidConfigurationException(\"Stored inventory is missing required section \\\"\"\n                    + PLAYER_INVENTORY_PRIMARY_KEY + \"\\\"\");\n        }\n        player.getInventory().clear();\n        player.getInventory().setContents(\n                InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_PRIMARY_KEY))\n        );\n        if (yaml.contains(PLAYER_INVENTORY_ARMOR_KEY)) {\n            player.getInventory().setArmorContents(\n                    InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_ARMOR_KEY))\n            );\n        }\n        player.updateInventory();\n        //noinspection ResultOfMethodCallIgnored\n        storage.delete();\n    }\n\n    /**\n     * Stores the given {@link Player}'s current location to persistent storage.\n     *\n     * @param player The {@link Player} to store the location of\n     * @throws InvalidConfigurationException If an exception occurs while saving\n     *     to disk\n     * @throws IOException If an exception occurs while saving to disk\n     */\n    public static void storeLocation(Player player) throws InvalidConfigurationException, IOException {\n        CommonPlayerHelper.storeLocation(player.getUniqueId(),\n                LocationHelper.convertLocation(player.getLocation()));\n    }\n\n    /**\n     * Pops the given {@link Player}'s stored location from persistent storage,\n     * teleporting them to it.\n     *\n     * @param player The {@link Player} to load the location of and teleport\n     * @throws IllegalArgumentException If the player's location is not present\n     *     in the persistent store or if an error occurs during deserialization\n     * @throws InvalidConfigurationException If an exception occurs while\n     *     loading from disk\n     * @throws IOException If an exception occurs while saving to disk\n     */\n    public static void popLocation(Player player)\n            throws IllegalArgumentException, InvalidConfigurationException, IOException {\n        Optional<Location3D> retLoc = CommonPlayerHelper.getReturnLocation(player.getUniqueId());\n        if (!retLoc.isPresent()) {\n            throw new IllegalArgumentException(\"Location of player \" + player.getName()\n                    + \" not present in persistent store\");\n        }\n        player.teleport(LocationHelper.convertLocation(retLoc.get()));\n    }\n\n    /**\n     * Version-independent getOnlinePlayers() method.\n     *\n     * @return a list of online players\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Collection<? extends Player> getOnlinePlayers() {\n        try {\n            if (newOnlinePlayersMethod) {\n                return (Collection<? extends Player>) getOnlinePlayers.invoke(null);\n            } else {\n                return Arrays.asList((Player[]) getOnlinePlayers.invoke(null));\n            }\n        } catch (IllegalAccessException | InvocationTargetException ex) {\n            throw new RuntimeException(\"Failed to invoke getOnlinePlayers method!\", ex);\n        }\n    }\n\n}", "class_id": 0, "repo": "caseif/Steel", "file": "src/main/java/net/caseif/flint/steel/util/helper/PlayerHelper.java", "last_update_at": "2018-12-03T13:30:13+00:00", "question_id": "a3fd86e4939c7d81c4d19871b4946f3105ad47aa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlayerHelper {\n    private static final String PLAYER_INVENTORY_PRIMARY_KEY = \"primary\";\n    private static final String PLAYER_INVENTORY_ARMOR_KEY = \"armor\";\n    private static Method getOnlinePlayers;\n    public static boolean newOnlinePlayersMethod = false;\n    static {\n        try {\n            getOnlinePlayers = Bukkit.class.getMethod(\"getOnlinePlayers\");\n            if (getOnlinePlayers.getReturnType() == Collection.class) {\n                newOnlinePlayersMethod = true;\n            }\n        } catch (NoSuchMethodException ex) {\n            SteelCore.logSevere(\"Failed to get getOnlinePlayers method!\");\n            ex.printStackTrace();\n        }\n    }\n    /**\n     * Pushes the inventory of the given player into persistent storage.\n     *\n     * @param player The {@link Player} to push the inventory of\n     * @throws IOException If an exception occurs while saving into persistent\n     *     storage\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static void pushInventory(Player player) throws IOException {\n        PlayerInventory inv = player.getInventory();\n        // the file to store the inventory in\n        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + \".yml\");\n        if (storage.exists()) { // verify file isn't already present on disk (meaning it wasn't popped the last time)\n            SteelCore.logVerbose(\"Inventory push requested for player \" + player.getName() + \", but \"\n                    + \"inventory was already present in persistent storage. Popping stored inventory first.\");\n            try {\n                popInventory(player);\n            } catch (InvalidConfigurationException ex) {\n                throw new IOException(ex); // this is probably a bad thing of me to do but it's for a fringe case anyway\n            }\n        }\n        YamlConfiguration yaml = new YamlConfiguration();\n        yaml.set(PLAYER_INVENTORY_PRIMARY_KEY, InventoryHelper.serializeInventory(inv));\n        yaml.set(PLAYER_INVENTORY_ARMOR_KEY, InventoryHelper.serializeInventory(inv.getArmorContents()));\n        yaml.save(storage); // save to disk\n        inv.clear(); // clear the inventory to complete the push to disk\n        inv.setArmorContents(new ItemStack[inv.getArmorContents().length]);\n        player.updateInventory();\n    }\n    /**\n     * Pops the inventory of the given player from persistent storage.\n     *\n     * @param player The {@link Player} to pop the inventory of\n     * @throws IllegalArgumentException If the inventory of the given\n     *     {@link Player} is not present in persistent storage\n     * @throws IOException If an exception occurs while loading from persistent\n     *     storage\n     * @throws InvalidConfigurationException If the stored inventory is invalid\n     */\n    //TODO: generalize some of this code for use with rollback storage\n    @SuppressWarnings(\"deprecation\")\n    public static void popInventory(Player player) throws IllegalArgumentException, IOException,\n            InvalidConfigurationException {\n        // the file to load the inventory from\n        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + \".yml\");\n        if (!storage.exists()) { // verify file is present on disk\n            throw new IllegalArgumentException(\"Inventory pop requested for player \" + player.getName() + \", but \"\n                    + \"inventory was not present in persistent storage!\");\n        }\n        YamlConfiguration yaml = new YamlConfiguration();\n        yaml.load(storage); // load from disk\n        if (!yaml.contains(PLAYER_INVENTORY_PRIMARY_KEY)) {\n            throw new InvalidConfigurationException(\"Stored inventory is missing required section \\\"\"\n                    + PLAYER_INVENTORY_PRIMARY_KEY + \"\\\"\");\n        }\n        player.getInventory().clear();\n        player.getInventory().setContents(\n                InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_PRIMARY_KEY))\n        );\n        if (yaml.contains(PLAYER_INVENTORY_ARMOR_KEY)) {\n            player.getInventory().setArmorContents(\n                    InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_ARMOR_KEY))\n            );\n        }\n        player.updateInventory();\n        //noinspection ResultOfMethodCallIgnored\n        storage.delete();\n    }\n    /**\n     * Stores the given {@link Player}'s current location to persistent storage.\n     *\n     * @param player The {@link Player} to store the location of\n     * @throws InvalidConfigurationException If an exception occurs while saving\n     *     to disk\n     * @throws IOException If an exception occurs while saving to disk\n     */\n    public static void storeLocation(Player player) throws InvalidConfigurationException, IOException {\n        CommonPlayerHelper.storeLocation(player.getUniqueId(),\n                LocationHelper.convertLocation(player.getLocation()));\n    }\n    /**\n     * Pops the given {@link Player}'s stored location from persistent storage,\n     * teleporting them to it.\n     *\n     * @param player The {@link Player} to load the location of and teleport\n     * @throws IllegalArgumentException If the player's location is not present\n     *     in the persistent store or if an error occurs during deserialization\n     * @throws InvalidConfigurationException If an exception occurs while\n     *     loading from disk\n     * @throws IOException If an exception occurs while saving to disk\n     */\n    public static void popLocation(Player player)\n            throws IllegalArgumentException, InvalidConfigurationException, IOException {\n        Optional<Location3D> retLoc = CommonPlayerHelper.getReturnLocation(player.getUniqueId());\n        if (!retLoc.isPresent()) {\n            throw new IllegalArgumentException(\"Location of player \" + player.getName()\n                    + \" not present in persistent store\");\n        }\n        player.teleport(LocationHelper.convertLocation(retLoc.get()));\n    }\n    /**\n     * Version-independent getOnlinePlayers() method.\n     *\n     * @return a list of online players\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static Collection<? extends Player> getOnlinePlayers() {\n        try {\n            if (newOnlinePlayersMethod) {\n                return (Collection<? extends Player>) getOnlinePlayers.invoke(null);\n            } else {\n                return Arrays.asList((Player[]) getOnlinePlayers.invoke(null));\n            }\n        } catch (IllegalAccessException | InvocationTargetException ex) {\n            throw new RuntimeException(\"Failed to invoke getOnlinePlayers method!\", ex);\n        }\n    }\n"]], "pred": {"ppl": 1.9429678916931152, "ppl_lower": 2.2053234577178955, "ppl/lowercase_ppl": -1.1906871000154566, "ppl/zlib": 0.000389569879847166, "Min_5.0% Prob": 6.348821537167418, "Min_10.0% Prob": 4.6302461694268615, "Min_20.0% Prob": 2.97754342854023, "Min_30.0% Prob": 2.1491763382370954, "Min_40.0% Prob": 1.646556270825688, "Min_50.0% Prob": 1.3262300490567538, "Min_60.0% Prob": 1.1076911105774343}}
{"hexsha": "ebf7c5aad673e2ed5110bb23a90470b4111f2d08", "ext": "java", "lang": "Java", "content": "public class UseHotelRoom\r\n{\r\n    public static void main(String[] args)\r\n   {\r\n        HotelRoom h1 = new HotelRoom(200);\r\n        Suite s1 = new Suite(234);\r\n        \r\n        System.out.println(\"Testing setters and getters for hotel and Suite :\");\r\n        h1.setRoomNumber(4);\r\n        System.out.println(h1.getRoomNumber());\r\n        s1.setNightlyRate(54);\r\n        System.out.println(s1.getNightlyRate());\r\n        \r\n        HotelRoom[] array = new HotelRoom[5];\r\n        array[0] = new HotelRoom(101);\r\n        array[1] = new HotelRoom(102);\r\n        array[2] = new Suite(500);\r\n        array[3] = new Suite(501);\r\n        array[4] = new Suite(541);\r\n        \r\n        System.out.println(\"\\nTesting arrays : \");\r\n        for(HotelRoom x:array)\r\n        {\r\n            System.out.println(x);\r\n            System.out.println();\r\n        }\r\n        \r\n        ArrayList<HotelRoom> list = new ArrayList(Arrays.asList(array));\r\n        list.add(new HotelRoom(341));\r\n        list.add(new HotelRoom(342));\r\n        list.add(new HotelRoom(435));\r\n        list.add(new Suite(899));\r\n        list.add(new Suite(900));\r\n        \r\n        System.out.println(\"Testing ArrayList : \");\r\n        for(HotelRoom x:list)\r\n        {\r\n            System.out.println(x);\r\n            System.out.println();\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "dylanbobb/Data-Structures-OOP", "file": "Assignment 1/src/HotelRoom/UseHotelRoom.java", "last_update_at": "2018-04-30T21:27:56+00:00", "question_id": "ebf7c5aad673e2ed5110bb23a90470b4111f2d08", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UseHotelRoom\r\n{\r\n    public static void main(String[] args)\r\n   {\r\n        HotelRoom h1 = new HotelRoom(200);\r\n        Suite s1 = new Suite(234);\r\n        \r\n        System.out.println(\"Testing setters and getters for hotel and Suite :\");\r\n        h1.setRoomNumber(4);\r\n        System.out.println(h1.getRoomNumber());\r\n        s1.setNightlyRate(54);\r\n        System.out.println(s1.getNightlyRate());\r\n        \r\n        HotelRoom[] array = new HotelRoom[5];\r\n        array[0] = new HotelRoom(101);\r\n        array[1] = new HotelRoom(102);\r\n        array[2] = new Suite(500);\r\n        array[3] = new Suite(501);\r\n        array[4] = new Suite(541);\r\n        \r\n        System.out.println(\"\\nTesting arrays : \");\r\n        for(HotelRoom x:array)\r\n        {\r\n            System.out.println(x);\r\n            System.out.println();\r\n        }\r\n        \r\n        ArrayList<HotelRoom> list = new ArrayList(Arrays.asList(array));\r\n        list.add(new HotelRoom(341));\r\n        list.add(new HotelRoom(342));\r\n        list.add(new HotelRoom(435));\r\n        list.add(new Suite(899));\r\n        list.add(new Suite(900));\r\n        \r\n        System.out.println(\"Testing ArrayList : \");\r\n        for(HotelRoom x:list)\r\n        {\r\n            System.out.println(x);\r\n            System.out.println();\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 1.8578189611434937, "ppl_lower": 2.0525670051574707, "ppl/lowercase_ppl": -1.16094203191929, "ppl/zlib": 0.0016300084161954202, "Min_5.0% Prob": 5.9882788766514174, "Min_10.0% Prob": 4.244076034757826, "Min_20.0% Prob": 2.759328085184097, "Min_30.0% Prob": 2.002270124414388, "Min_40.0% Prob": 1.5352732751991867, "Min_50.0% Prob": 1.233715395783669, "Min_60.0% Prob": 1.0328307198086644}}
{"hexsha": "80aac1ac43b4f28347da6386a249e4e082bc6f92", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"deprecation\")\npublic class NetconfChangeListener implements ClusteredDataTreeChangeListener<Node>, AutoCloseable {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NetconfChangeListener.class);\n\n    private static final InstanceIdentifier<Node> NETCONF_NODE_TOPO_IID =\n            InstanceIdentifier.create(NetworkTopology.class)\n                    .child(Topology.class, new TopologyKey(new TopologyId(TopologyNetconf.QNAME.getLocalName())))\n                    .child(Node.class);\n    // Name of ODL controller NETCONF instance\n    private static final String CONTROLLER = \"controller-config\";\n\n    private final DeviceManagerService deviceManagerService;\n    private final DataBroker dataBroker;\n    private ListenerRegistration<NetconfChangeListener> dlcReg;\n\n    public NetconfChangeListener(DeviceManagerService deviceManagerService, DataBroker dataBroker) {\n        this.deviceManagerService = deviceManagerService;\n        this.dataBroker = dataBroker;\n    }\n\n    public void register() {\n        DataTreeIdentifier<Node> treeId = new DataTreeIdentifier<>(LogicalDatastoreType.OPERATIONAL, NETCONF_NODE_TOPO_IID);\n\n        dlcReg = dataBroker.registerDataTreeChangeListener(treeId, this);\n    }\n\n    @Override\n    public void close() {\n        if (dlcReg != null) {\n            dlcReg.close();\n        }\n    }\n    /*---------------------------------------------------------------------------\n     * Listener\n     */\n    @Override\n    public void onDataTreeChanged(Collection<DataTreeModification<Node>> changes) {\n        LOG.debug(\"OnDataChange, TreeChange, changes:{}\", changes.size());\n\n        for (final DataTreeModification<Node> change : changes) {\n            final DataObjectModification<Node> root = change.getRootNode();\n            final ModificationType modificationType = root.getModificationType();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Handle this modificationType:{} path:{} root:{}\", modificationType, change.getRootPath(),\n                        root);\n            }\n            switch (modificationType) {\n                case SUBTREE_MODIFIED:\n                    // Change of subtree information\n                    // update(change); OLD\n                    doProcessing(Action.UPDATE, root.getDataAfter());\n                    break;\n                case WRITE:\n                    // Create or modify top level node\n                    // Treat an overwrite as an update\n                    boolean update = root.getDataBefore() != null;\n                    if (update) {\n                        // update(change);\n                        doProcessing(Action.UPDATE, root.getDataAfter());\n                    } else {\n                        // add(change);\n                        doProcessing(Action.CREATE, root.getDataAfter());\n                    }\n                    break;\n                case DELETE:\n                    // Node removed\n                    // remove(change);\n                    doProcessing(Action.REMOVE, root.getDataBefore());\n                    break;\n            }\n        }\n    }\n\n    /*\n     * ---------------------------------------------------------------- Functions to select the right\n     * node from DataObjectModification\n     */\n\n    /**\n     * Process event and forward to clients\n     *\n     * @param action\n     * @param node Basis node\n     */\n    private void doProcessing(Action action, Node node) {\n\n        NodeId nodeId = null;\n        NetconfNode nnode = null;\n        NodeKey nodeKey = null;\n\n        try {\n            if (node != null) {\n                if ((nodeKey = node.key()) != null) {\n                    nodeId = nodeKey.getNodeId();\n                }\n                nnode = node.augmentation(NetconfNode.class);\n            }\n\n            if (node == null || nnode == null || nodeId == null || nodeKey == null) {\n            \tLOG.warn(\"Unexpected node {}, netconf node {} or key {} or id {}\", node, nnode, nodeKey, nodeId);\n            } else {\n            \tString nodeIdString = nodeId.getValue();\n            \t// Do not forward any controller related events to devicemanager\n            \tif (nodeIdString.equals(CONTROLLER)) {\n            \t\tLOG.debug(\"Stop processing for [{}]\", nodeIdString);\n            \t} else {\n\n            \t\tClusteredConnectionStatus ccsts = nnode.getClusteredConnectionStatus();\n        \t\t\tConnectionStatus csts = nnode.getConnectionStatus();\n          \t\t\tLOG.debug(\"NETCONF Node processing with id {} action {} status {} cluster status {}\", nodeIdString,\n            \t\t\t\t\taction, csts, ccsts);\n          \t\t\t// Action forwarded to devicehandler\n           \t\t\tdeviceManagerService.netconfChangeHandler(action, csts, nodeId, nnode);\n            \t}\n            }\n        } catch (NullPointerException e) {\n        \tLOG.warn(\"Unexpected null .. stop processing.\", e);\n        }\n    }\n\n}", "class_id": 0, "repo": "onap-oof-pci-poc/ccsdk", "file": "features/sdnr/wt/devicemanager/provider/src/main/java/org/onap/ccsdk/features/sdnr/wt/devicemanager/impl/listener/NetconfChangeListener.java", "last_update_at": "2018-11-13T09:58:04+00:00", "question_id": "80aac1ac43b4f28347da6386a249e4e082bc6f92", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"deprecation\")\npublic class NetconfChangeListener implements ClusteredDataTreeChangeListener<Node>, AutoCloseable {\n    private static final Logger LOG = LoggerFactory.getLogger(NetconfChangeListener.class);\n    private static final InstanceIdentifier<Node> NETCONF_NODE_TOPO_IID =\n            InstanceIdentifier.create(NetworkTopology.class)\n                    .child(Topology.class, new TopologyKey(new TopologyId(TopologyNetconf.QNAME.getLocalName())))\n                    .child(Node.class);\n    // Name of ODL controller NETCONF instance\n    private static final String CONTROLLER = \"controller-config\";\n    private final DeviceManagerService deviceManagerService;\n    private final DataBroker dataBroker;\n    private ListenerRegistration<NetconfChangeListener> dlcReg;\n    public NetconfChangeListener(DeviceManagerService deviceManagerService, DataBroker dataBroker) {\n        this.deviceManagerService = deviceManagerService;\n        this.dataBroker = dataBroker;\n    }\n    public void register() {\n        DataTreeIdentifier<Node> treeId = new DataTreeIdentifier<>(LogicalDatastoreType.OPERATIONAL, NETCONF_NODE_TOPO_IID);\n        dlcReg = dataBroker.registerDataTreeChangeListener(treeId, this);\n    }\n    @Override\n    public void close() {\n        if (dlcReg != null) {\n            dlcReg.close();\n        }\n    }\n    /*---------------------------------------------------------------------------\n     * Listener\n     */\n    @Override\n    public void onDataTreeChanged(Collection<DataTreeModification<Node>> changes) {\n        LOG.debug(\"OnDataChange, TreeChange, changes:{}\", changes.size());\n        for (final DataTreeModification<Node> change : changes) {\n            final DataObjectModification<Node> root = change.getRootNode();\n            final ModificationType modificationType = root.getModificationType();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Handle this modificationType:{} path:{} root:{}\", modificationType, change.getRootPath(),\n                        root);\n            }\n            switch (modificationType) {\n                case SUBTREE_MODIFIED:\n                    // Change of subtree information\n                    // update(change); OLD\n                    doProcessing(Action.UPDATE, root.getDataAfter());\n                    break;\n                case WRITE:\n                    // Create or modify top level node\n                    // Treat an overwrite as an update\n                    boolean update = root.getDataBefore() != null;\n                    if (update) {\n                        // update(change);\n                        doProcessing(Action.UPDATE, root.getDataAfter());\n                    } else {\n                        // add(change);\n                        doProcessing(Action.CREATE, root.getDataAfter());\n                    }\n                    break;\n                case DELETE:\n                    // Node removed\n                    // remove(change);\n                    doProcessing(Action.REMOVE, root.getDataBefore());\n                    break;\n            }\n        }\n    }\n    /*\n     * ---------------------------------------------------------------- Functions to select the right\n     * node from DataObjectModification\n     */\n    /**\n     * Process event and forward to clients\n     *\n     * @param action\n     * @param node Basis node\n     */\n    private void doProcessing(Action action, Node node) {\n        NodeId nodeId = null;\n        NetconfNode nnode = null;\n        NodeKey nodeKey = null;\n        try {\n            if (node != null) {\n                if ((nodeKey = node.key()) != null) {\n                    nodeId = nodeKey.getNodeId();\n                }\n                nnode = node.augmentation(NetconfNode.class);\n            }\n            if (node == null || nnode == null || nodeId == null || nodeKey == null) {\n            \tLOG.warn(\"Unexpected node {}, netconf node {} or key {} or id {}\", node, nnode, nodeKey, nodeId);\n            } else {\n            \tString nodeIdString = nodeId.getValue();\n            \t// Do not forward any controller related events to devicemanager\n            \tif (nodeIdString.equals(CONTROLLER)) {\n            \t\tLOG.debug(\"Stop processing for [{}]\", nodeIdString);\n            \t} else {\n            \t\tClusteredConnectionStatus ccsts = nnode.getClusteredConnectionStatus();\n        \t\t\tConnectionStatus csts = nnode.getConnectionStatus();\n          \t\t\tLOG.debug(\"NETCONF Node processing with id {} action {} status {} cluster status {}\", nodeIdString,\n            \t\t\t\t\taction, csts, ccsts);\n          \t\t\t// Action forwarded to devicehandler\n           \t\t\tdeviceManagerService.netconfChangeHandler(action, csts, nodeId, nnode);\n            \t}\n            }\n        } catch (NullPointerException e) {\n        \tLOG.warn(\"Unexpected null .. stop processing.\", e);\n        }\n    }\n"]], "pred": {"ppl": 2.3931686878204346, "ppl_lower": 2.8748717308044434, "ppl/lowercase_ppl": -1.2101603410477186, "ppl/zlib": 0.0005840818598633593, "Min_5.0% Prob": 7.137779310637829, "Min_10.0% Prob": 5.463191425099092, "Min_20.0% Prob": 3.7480057460420273, "Min_30.0% Prob": 2.7807161737890804, "Min_40.0% Prob": 2.1501483039561577, "Min_50.0% Prob": 1.739352782083759, "Min_60.0% Prob": 1.4544926895175074}}
{"hexsha": "52b08b4875222c79954eb4cfb0cec43fff40d3fd", "ext": "java", "lang": "Java", "content": "@org.springframework.web.bind.annotation.RestController\n@RequestMapping(\"/api\")\npublic class RestController {\n\n    @Resource\n    private ArticleService articleService;\n\n    @Resource\n    private UserService userService;\n\n    @Resource\n    private ArticleTagRelationshipService articleTagRelationshipService;\n\n    @GetMapping(\"/article/{title}\")\n    public String getArticle(@PathVariable String title) {\n        List<Article> articles = articleService.getArticlesByTitle(title);\n        return JSON.toJSONString(articles);\n    }\n\n    @DeleteMapping(\"/article/{title}\")\n    public String deleteArticle(@PathVariable String title) {\n        boolean delete = articleService.deleteArticleByTitle(title);\n        JSONObject result = new JSONObject();\n        result.put(\"result\", delete);\n        return result.toJSONString();\n    }\n\n    @GetMapping(\"/article\")\n    public String getArticles(@RequestParam(value = \"page\") int page,\n                              @RequestParam(value = \"pageNum\") int pageNum) {\n        List<Article> articles = articleService.getArticles(pageNum, page);\n        return JSON.toJSONString(articles);\n    }\n\n    @PostMapping(value = \"/article\", consumes = \"application/json\")\n    public String addArticle(@RequestBody Article article) {\n        JSONObject result = new JSONObject();\n        result.put(\"result\", articleService.insertArticle(article));\n//        System.out.println(\"Get params:\" + JSON.toJSONString(article)\n//                + \", result:\" + result.toJSONString());\n        return result.toJSONString();\n    }\n\n    @GetMapping(\"/articles\")\n    public String getArticlesByTagName(@RequestParam(value = \"tagName\") String tagName) {\n        List<Article> articles = articleService.getArticlesByTagName(tagName);\n        return JSON.toJSONString(articles);\n    }\n\n    @PostMapping(value = \"/auth\", consumes = \"application/json\")\n    public String authUser(@RequestBody User user) {\n        boolean authenticated = userService.authUser(user.getUsername(), user.getPassword());\n        JSONObject result = new JSONObject();\n        result.put(\"authenticated\", authenticated);\n        return result.toJSONString();\n    }\n}", "class_id": 0, "repo": "puyangsky/JavaBlog", "file": "src/main/java/com/puyangsky/blog/controller/RestController.java", "last_update_at": "2018-05-27T19:50:23+00:00", "question_id": "52b08b4875222c79954eb4cfb0cec43fff40d3fd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@org.springframework.web.bind.annotation.RestController\n@RequestMapping(\"/api\")\npublic class RestController {\n    @Resource\n    private ArticleService articleService;\n    @Resource\n    private UserService userService;\n    @Resource\n    private ArticleTagRelationshipService articleTagRelationshipService;\n    @GetMapping(\"/article/{title}\")\n    public String getArticle(@PathVariable String title) {\n        List<Article> articles = articleService.getArticlesByTitle(title);\n        return JSON.toJSONString(articles);\n    }\n    @DeleteMapping(\"/article/{title}\")\n    public String deleteArticle(@PathVariable String title) {\n        boolean delete = articleService.deleteArticleByTitle(title);\n        JSONObject result = new JSONObject();\n        result.put(\"result\", delete);\n        return result.toJSONString();\n    }\n    @GetMapping(\"/article\")\n    public String getArticles(@RequestParam(value = \"page\") int page,\n                              @RequestParam(value = \"pageNum\") int pageNum) {\n        List<Article> articles = articleService.getArticles(pageNum, page);\n        return JSON.toJSONString(articles);\n    }\n    @PostMapping(value = \"/article\", consumes = \"application/json\")\n    public String addArticle(@RequestBody Article article) {\n        JSONObject result = new JSONObject();\n        result.put(\"result\", articleService.insertArticle(article));\n//        System.out.println(\"Get params:\" + JSON.toJSONString(article)\n//                + \", result:\" + result.toJSONString());\n        return result.toJSONString();\n    }\n    @GetMapping(\"/articles\")\n    public String getArticlesByTagName(@RequestParam(value = \"tagName\") String tagName) {\n        List<Article> articles = articleService.getArticlesByTagName(tagName);\n        return JSON.toJSONString(articles);\n    }\n    @PostMapping(value = \"/auth\", consumes = \"application/json\")\n    public String authUser(@RequestBody User user) {\n        boolean authenticated = userService.authUser(user.getUsername(), user.getPassword());\n        JSONObject result = new JSONObject();\n        result.put(\"authenticated\", authenticated);\n        return result.toJSONString();\n    }\n"]], "pred": {"ppl": 1.5723222494125366, "ppl_lower": 1.7267804145812988, "ppl/lowercase_ppl": -1.2070582636397529, "ppl/zlib": 0.0007749206614105117, "Min_5.0% Prob": 4.902919451395671, "Min_10.0% Prob": 3.4585133205760608, "Min_20.0% Prob": 2.102534332871437, "Min_30.0% Prob": 1.4743459524981903, "Min_40.0% Prob": 1.1181619369606086, "Min_50.0% Prob": 0.9013796447627787, "Min_60.0% Prob": 0.7542716590181173}}
{"hexsha": "32576c889ad08eef6d94070d0d89d01d7568b99f", "ext": "java", "lang": "Java", "content": "public class SettingUp {\n\n    private static final AnimeObject[] animeArray = new AnimeObject[]{new AnimeObject(\"eureka\", 50)};\n    private static final Logger logger = LoggerFactory.getLogger(SettingUp.class);\n\n    @Deprecated\n    public static void insertPartitionDumpToDatabase() {\n        String insertScript = \"\";\n        int[][][] tripleArray;\n\n        logger.info(\"beginning to insert \" + animeArray.length + \" anime into the database\");\n\n        for (int animeNumber = 0; animeNumber < animeArray.length; animeNumber++) {\n            logger.info(\"animeNumber:\" + animeNumber);\n            try {\n                final int[] tmpPanels = new int[animeArray[animeNumber].getNumberOfEpisodes()];\n                for (int a = 1; a <= animeArray[animeNumber].getNumberOfEpisodes(); a++) {\n                    tmpPanels[a - 1] = Integer.valueOf(AkarinLogging.readFile(\n                            \"dev_output/description/\" + animeArray[animeNumber].getName() + \"_\" + a + \".txt\"));\n                }\n                animeArray[animeNumber].setPanels(tmpPanels);\n            } catch (final IOException e) {\n                logger.info(\"FAIL READING DESCRIPTION TEXT\");\n                logger.info(e.getMessage());\n            }\n            for (int episodeNumber = 1; episodeNumber <= animeArray[animeNumber]\n                    .getNumberOfEpisodes(); episodeNumber++) {\n                for (int panelNumber = 0; panelNumber < animeArray[animeNumber].getPanels()[episodeNumber\n                        - 1]; panelNumber++) {\n                    try (Connection connection = DatabaseManager.getConnection()) {\n\n                        final Statement stmt = connection.createStatement();\n\n                        tripleArray = AkarinLogging.parseIntegerPartitionTextOutput(\"dev_output/text/\"\n                                + animeArray[animeNumber].getName() + \"/\" + animeArray[animeNumber].getName() + \"_\"\n                                + episodeNumber + \"_\" + panelNumber + \".txt\");\n\n                        insertScript = ScriptCreator.insertIntoImagedbAnimeRgbInteger(animeArray[animeNumber].getName(),\n                                episodeNumber, panelNumber, tripleArray);\n\n                        logger.info(\"Executing script:\" + insertScript);\n                        stmt.executeUpdate(insertScript);\n\n                    } catch (final IOException | URISyntaxException e) {\n                        logger.info(\"id:\" + panelNumber);\n                        logger.info(e.getMessage());\n                    } catch (final SQLException e) {\n                        logger.info(\"id:\" + panelNumber);\n                        logger.info(\"query:\" + insertScript);\n                        logger.info(e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    @Deprecated\n    public static void createImageInfo() {\n        try {\n            final File DEV_OUTPUT_IMAGES_OUTPUT_PARTITION = new File(\"dev_output/images/output/partition\");\n            boolean isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.exists();\n            if (!isDirectoryExists) {\n                isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.mkdirs();\n            }\n            if (isDirectoryExists) {\n                logger.info(\"the directory \" + DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.getPath() + \" was created\");\n            }\n\n            String animeName;\n            for (AnimeObject anAnimeArray : animeArray) {\n                animeName = anAnimeArray.getName();\n                for (int episode = 1; episode <= anAnimeArray.getNumberOfEpisodes(); episode++) {\n                    final Java2DFrameConverter frameConverter = new Java2DFrameConverter();\n\n                    int frameIterator = 0; // the frame iterator\n                    int panelIterator = 0; // the panel iterator\n                    BufferedImage image; // the image\n                    Frame frame;\n\n                    FFmpegFrameGrabber g = new FFmpegFrameGrabber(\"videos/\" + animeName + \"/\" + animeName + \"_\" + episode + \".mkv\");\n                    g.start();\n\n                    while ((frame = g.grabImage()) != null) {\n                        image = frameConverter.getBufferedImage(frame);\n                        image = ImageProcessingTools.resizeImage(image);\n\n                        if (Partition.activeBool) {\n                            Partition.tripleArray = ImagePartition.getPartitionArray(image);\n\n                            if (Partition.writeToDatabase) {\n                                logger.info(animeName + \" \" + episode + \" \" + frameIterator);\n                                ImageProcessingDb.insertPartitionHash(animeName, episode, frameIterator,\n                                        ImageHashing.partitionHash(Partition.tripleArray));\n                            }\n\n                            if (Partition.writeLogBool) {\n                                Partition.imageDir = \"dev_output/images/output/partition/\" + animeName + \"/\"\n                                        + animeName + \"_\" + episode + \"_\" + panelIterator + \".png\";\n                                Partition.textDir = \"dev_output/text/partition/\" + animeName + \"/\" + animeName + \"_\"\n                                        + episode + \"_\" + panelIterator + \".txt\";\n                            }\n                        }\n\n                        if (GlobalDifference.activeBool) {\n                            GlobalDifference.tripleArray = ImageGlobalDifference.getGlobalDifference(image);\n\n                            if (GlobalDifference.writeLogBool) {\n                                GlobalDifference.imageDir = \"dev_output/images/output/globaldifference/\" + animeName\n                                        + \"/\" + animeName + \"_\" + episode + \"_\" + panelIterator + \".png\";\n                                GlobalDifference.textDir = \"dev_output/text/globaldifference/\" + animeName + \"/\"\n                                        + animeName + \"_\" + episode + \"_\" + panelIterator + \".txt\";\n                            }\n                        }\n\n                        if (BasicHistogramHash.activeBool) {\n                            try (Connection connection = DatabaseManager.getConnection()) {\n                                Statement statement = connection.createStatement();\n                                statement.executeUpdate(\"INSERT INTO imagedb_test (hash) VALUES ('\"\n                                        + ImageHashing.basicHistogramHash(ImageHashing.getRGBHistogram(image))\n                                        + \"');\");\n                            } catch (final SQLException | URISyntaxException e) {\n                                logger.warn(e.getMessage());\n                            }\n                        }\n\n                        if (CheckPanelDifference.activeBool) {\n\n                            if (panelIterator == 0) {\n                                CheckPanelDifference.oldArray = ImageProcessingTools\n                                        .getArrayFromBufferedImage(image);\n                                CheckPanelDifference.panelDifferenceCountArray = new int[CheckPanelDifference.oldArray.length][CheckPanelDifference.oldArray[0].length][3];\n                            } else {\n                                CheckPanelDifference.newArray = ImageProcessingTools\n                                        .getArrayFromBufferedImage(image);\n                                CheckPanelDifference.panelDifferenceArray = ImageProcessingTools\n                                        .checkArrayDifference(CheckPanelDifference.oldArray,\n                                                CheckPanelDifference.newArray);\n                                for (int y = 0; y < CheckPanelDifference.oldArray.length; y++) {\n                                    for (int x = 0; x < CheckPanelDifference.oldArray[y].length; x++) {\n                                        for (int z = 0; z < CheckPanelDifference.oldArray[y][x].length; z++) {\n                                            if (CheckPanelDifference.panelDifferenceArray[y][x][z]) {\n                                                CheckPanelDifference.panelDifferenceCountArray[y][x][z]++;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        panelIterator++;\n                        frameIterator++;\n                    }\n                    AkarinLogging.log(\"\" + panelIterator, \"dev_output/description/\" + animeName + \"_\" + episode + \".txt\");\n                    g.stop();\n                }\n            }\n        } catch (final IOException e) {\n            logger.warn(e.getMessage());\n        }\n\n    }\n\n    public static void prepareDatabases() {\n        TextboardDb.createTableBoards();\n            TextboardDb.createTableThreads();\n            TextboardDb.createTablePosts();\n            YaaposDb.createYaaposUser();\n            YaaposDb.createYaaposSpending();\n    }\n\n    static class CheckPanelDifference {\n        static final boolean activeBool = false;\n        public static boolean writeLogBool = false;\n\n        static int[][][] oldArray;\n        static int[][][] newArray;\n        static int[][][] panelDifferenceCountArray;\n\n        static boolean[][][] panelDifferenceArray;\n    }\n\n    static class Partition {\n        static final boolean activeBool = true;\n        static final boolean writeLogBool = false;\n        static final boolean writeToDatabase = true;\n        public static boolean printBool = false;\n\n        static int[][][] tripleArray;\n\n        static String imageDir;\n        static String textDir;\n    }\n\n    static class GlobalDifference {\n        static final boolean activeBool = false;\n        static final boolean writeLogBool = false;\n\n        static int[][][] tripleArray;\n\n        static String imageDir;\n        static String textDir;\n    }\n\n    static class BasicHistogramHash {\n        static final boolean activeBool = false;\n        public static boolean writeLogBool = false;\n    }\n\n    private static class globalAverageRGB {\n        public static float[][][] average = new float[ImageProcessingTools.DIVISOR_VALUE][ImageProcessingTools.DIVISOR_VALUE][3];\n    }\n}", "class_id": 0, "repo": "hbina/safetaiga", "file": "src/main/java/com/akarin/webapp/util/SettingUp.java", "last_update_at": "2018-11-11T02:48:22+00:00", "question_id": "32576c889ad08eef6d94070d0d89d01d7568b99f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SettingUp {\n    private static final AnimeObject[] animeArray = new AnimeObject[]{new AnimeObject(\"eureka\", 50)};\n    private static final Logger logger = LoggerFactory.getLogger(SettingUp.class);\n    @Deprecated\n    public static void insertPartitionDumpToDatabase() {\n        String insertScript = \"\";\n        int[][][] tripleArray;\n        logger.info(\"beginning to insert \" + animeArray.length + \" anime into the database\");\n        for (int animeNumber = 0; animeNumber < animeArray.length; animeNumber++) {\n            logger.info(\"animeNumber:\" + animeNumber);\n            try {\n                final int[] tmpPanels = new int[animeArray[animeNumber].getNumberOfEpisodes()];\n                for (int a = 1; a <= animeArray[animeNumber].getNumberOfEpisodes(); a++) {\n                    tmpPanels[a - 1] = Integer.valueOf(AkarinLogging.readFile(\n                            \"dev_output/description/\" + animeArray[animeNumber].getName() + \"_\" + a + \".txt\"));\n                }\n                animeArray[animeNumber].setPanels(tmpPanels);\n            } catch (final IOException e) {\n                logger.info(\"FAIL READING DESCRIPTION TEXT\");\n                logger.info(e.getMessage());\n            }\n            for (int episodeNumber = 1; episodeNumber <= animeArray[animeNumber]\n                    .getNumberOfEpisodes(); episodeNumber++) {\n                for (int panelNumber = 0; panelNumber < animeArray[animeNumber].getPanels()[episodeNumber\n                        - 1]; panelNumber++) {\n                    try (Connection connection = DatabaseManager.getConnection()) {\n                        final Statement stmt = connection.createStatement();\n                        tripleArray = AkarinLogging.parseIntegerPartitionTextOutput(\"dev_output/text/\"\n                                + animeArray[animeNumber].getName() + \"/\" + animeArray[animeNumber].getName() + \"_\"\n                                + episodeNumber + \"_\" + panelNumber + \".txt\");\n                        insertScript = ScriptCreator.insertIntoImagedbAnimeRgbInteger(animeArray[animeNumber].getName(),\n                                episodeNumber, panelNumber, tripleArray);\n                        logger.info(\"Executing script:\" + insertScript);\n                        stmt.executeUpdate(insertScript);\n                    } catch (final IOException | URISyntaxException e) {\n                        logger.info(\"id:\" + panelNumber);\n                        logger.info(e.getMessage());\n                    } catch (final SQLException e) {\n                        logger.info(\"id:\" + panelNumber);\n                        logger.info(\"query:\" + insertScript);\n                        logger.info(e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n    @Deprecated\n    public static void createImageInfo() {\n        try {\n            final File DEV_OUTPUT_IMAGES_OUTPUT_PARTITION = new File(\"dev_output/images/output/partition\");\n            boolean isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.exists();\n            if (!isDirectoryExists) {\n                isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.mkdirs();\n            }\n            if (isDirectoryExists) {\n                logger.info(\"the directory \" + DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.getPath() + \" was created\");\n            }\n            String animeName;\n            for (AnimeObject anAnimeArray : animeArray) {\n                animeName = anAnimeArray.getName();\n                for (int episode = 1; episode <= anAnimeArray.getNumberOfEpisodes(); episode++) {\n                    final Java2DFrameConverter frameConverter = new Java2DFrameConverter();\n                    int frameIterator = 0; // the frame iterator\n                    int panelIterator = 0; // the panel iterator\n                    BufferedImage image; // the image\n                    Frame frame;\n                    FFmpegFrameGrabber g = new FFmpegFrameGrabber(\"videos/\" + animeName + \"/\" + animeName + \"_\" + episode + \".mkv\");\n                    g.start();\n                    while ((frame = g.grabImage()) != null) {\n                        image = frameConverter.getBufferedImage(frame);\n                        image = ImageProcessingTools.resizeImage(image);\n                        if (Partition.activeBool) {\n                            Partition.tripleArray = ImagePartition.getPartitionArray(image);\n                            if (Partition.writeToDatabase) {\n                                logger.info(animeName + \" \" + episode + \" \" + frameIterator);\n                                ImageProcessingDb.insertPartitionHash(animeName, episode, frameIterator,\n                                        ImageHashing.partitionHash(Partition.tripleArray));\n                            }\n                            if (Partition.writeLogBool) {\n                                Partition.imageDir = \"dev_output/images/output/partition/\" + animeName + \"/\"\n                                        + animeName + \"_\" + episode + \"_\" + panelIterator + \".png\";\n                                Partition.textDir = \"dev_output/text/partition/\" + animeName + \"/\" + animeName + \"_\"\n                                        + episode + \"_\" + panelIterator + \".txt\";\n                            }\n                        }\n                        if (GlobalDifference.activeBool) {\n                            GlobalDifference.tripleArray = ImageGlobalDifference.getGlobalDifference(image);\n                            if (GlobalDifference.writeLogBool) {\n                                GlobalDifference.imageDir = \"dev_output/images/output/globaldifference/\" + animeName\n                                        + \"/\" + animeName + \"_\" + episode + \"_\" + panelIterator + \".png\";\n                                GlobalDifference.textDir = \"dev_output/text/globaldifference/\" + animeName + \"/\"\n                                        + animeName + \"_\" + episode + \"_\" + panelIterator + \".txt\";\n                            }\n                        }\n                        if (BasicHistogramHash.activeBool) {\n                            try (Connection connection = DatabaseManager.getConnection()) {\n                                Statement statement = connection.createStatement();\n                                statement.executeUpdate(\"INSERT INTO imagedb_test (hash) VALUES ('\"\n                                        + ImageHashing.basicHistogramHash(ImageHashing.getRGBHistogram(image))\n                                        + \"');\");\n                            } catch (final SQLException | URISyntaxException e) {\n                                logger.warn(e.getMessage());\n                            }\n                        }\n                        if (CheckPanelDifference.activeBool) {\n                            if (panelIterator == 0) {\n                                CheckPanelDifference.oldArray = ImageProcessingTools\n                                        .getArrayFromBufferedImage(image);\n                                CheckPanelDifference.panelDifferenceCountArray = new int[CheckPanelDifference.oldArray.length][CheckPanelDifference.oldArray[0].length][3];\n                            } else {\n                                CheckPanelDifference.newArray = ImageProcessingTools\n                                        .getArrayFromBufferedImage(image);\n                                CheckPanelDifference.panelDifferenceArray = ImageProcessingTools\n                                        .checkArrayDifference(CheckPanelDifference.oldArray,\n                                                CheckPanelDifference.newArray);\n                                for (int y = 0; y < CheckPanelDifference.oldArray.length; y++) {\n                                    for (int x = 0; x < CheckPanelDifference.oldArray[y].length; x++) {\n                                        for (int z = 0; z < CheckPanelDifference.oldArray[y][x].length; z++) {\n                                            if (CheckPanelDifference.panelDifferenceArray[y][x][z]) {\n                                                CheckPanelDifference.panelDifferenceCountArray[y][x][z]++;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        panelIterator++;\n                        frameIterator++;\n                    }\n                    AkarinLogging.log(\"\" + panelIterator, \"dev_output/description/\" + animeName + \"_\" + episode + \".txt\");\n                    g.stop();\n                }\n            }\n        } catch (final IOException e) {\n            logger.warn(e.getMessage());\n        }\n    }\n    public static void prepareDatabases() {\n        TextboardDb.createTableBoards();\n            TextboardDb.createTableThreads();\n            TextboardDb.createTablePosts();\n            YaaposDb.createYaaposUser();\n            YaaposDb.createYaaposSpending();\n    }\n    static class CheckPanelDifference {\n        static final boolean activeBool = false;\n        public static boolean writeLogBool = false;\n        static int[][][] oldArray;\n        static int[][][] newArray;\n        static int[][][] panelDifferenceCountArray;\n        static boolean[][][] panelDifferenceArray;\n    }\n    static class Partition {\n        static final boolean activeBool = true;\n        static final boolean writeLogBool = false;\n        static final boolean writeToDatabase = true;\n        public static boolean printBool = false;\n        static int[][][] tripleArray;\n        static String imageDir;\n        static String textDir;\n    }\n    static class GlobalDifference {\n        static final boolean activeBool = false;\n        static final boolean writeLogBool = false;\n        static int[][][] tripleArray;\n        static String imageDir;\n        static String textDir;\n    }\n    static class BasicHistogramHash {\n        static final boolean activeBool = false;\n        public static boolean writeLogBool = false;\n    }\n    private static class globalAverageRGB {\n        public static float[][][] average = new float[ImageProcessingTools.DIVISOR_VALUE][ImageProcessingTools.DIVISOR_VALUE][3];\n    }\n"]], "pred": {"ppl": 2.2765326499938965, "ppl_lower": 2.554682970046997, "ppl/lowercase_ppl": -1.1401253545982601, "ppl/zlib": 0.00039550649898035183, "Min_5.0% Prob": 7.061624339982575, "Min_10.0% Prob": 5.335744593657699, "Min_20.0% Prob": 3.6095087452262056, "Min_30.0% Prob": 2.6376709618599588, "Min_40.0% Prob": 2.0314901963532117, "Min_50.0% Prob": 1.6404676899795079, "Min_60.0% Prob": 1.3715348574416453}}
{"hexsha": "03a0534138b293b8d67ff732c39550ea5e768c2d", "ext": "java", "lang": "Java", "content": "public class RssTask extends AsyncTask<URL, Integer, ArrayList<Article>>\n{\n    private final static String TAG = \"Download Task\";\n    private ArticleListActivity mCallback;\n\n    public RssTask(ArticleListActivity callback)\n    {\n        mCallback = callback;\n    }\n\n    @Override\n    protected void onPreExecute()\n    {\n        Log.d(TAG, \"Sync started\");\n        /*\n        Intent intent = new Intent();\n        intent.setAction(MainActivity.SYNC_START);\n        mAcitivity.sendOrderedBroadcast(intent, null);\n        */\n    }\n\n    @Override\n    protected ArrayList<Article> doInBackground(URL... params)\n    {\n        RssHandler rh = new RssHandler();\n\n        try\n        {\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser sp;\n            sp = spf.newSAXParser();\n            XMLReader xr = sp.getXMLReader();\n\n            xr.setContentHandler(rh);\n            xr.parse(new InputSource(params[0].openStream()));\n        } catch (ParserConfigurationException e)\n        {\n            e.printStackTrace();\n        } catch (SAXException e)\n        {\n            e.printStackTrace();\n        } catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n\n        return rh.articleList;\n    }\n\n    protected void onPostExecute(ArrayList<Article> articles)\n    {\n        mCallback.onFetchArticles(articles);\n\n        Log.d(TAG, \"Sync ended\");\n\n        /*\n        mArticles.clear();\n        mArticles.addAll(articles);\n        mAdapter.notifyDataSetChanged();\n\n        Intent intent = new Intent();\n        intent.setAction(MainActivity.SYNC_DONE);\n\n        try\n        {\n            getActivity().sendOrderedBroadcast(intent, null);\n        } catch (NullPointerException e)\n        {\n            // Om man kommer hit s\u00e5 har anv\u00e4ndaren avslutat applikationen\n            // och denna async-task kan inte l\u00e4ngre greppa 'current\n            // activity'.\n        }\n        */\n    }\n}", "class_id": 0, "repo": "domolicious/dagens_nyheter", "file": "app/src/main/java/se/sunnyvale/magnus/freshdn/tasks/RssTask.java", "last_update_at": "2018-04-21T21:57:26+00:00", "question_id": "03a0534138b293b8d67ff732c39550ea5e768c2d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RssTask extends AsyncTask<URL, Integer, ArrayList<Article>>\n{\n    private final static String TAG = \"Download Task\";\n    private ArticleListActivity mCallback;\n    public RssTask(ArticleListActivity callback)\n    {\n        mCallback = callback;\n    }\n    @Override\n    protected void onPreExecute()\n    {\n        Log.d(TAG, \"Sync started\");\n        /*\n        Intent intent = new Intent();\n        intent.setAction(MainActivity.SYNC_START);\n        mAcitivity.sendOrderedBroadcast(intent, null);\n        */\n    }\n    @Override\n    protected ArrayList<Article> doInBackground(URL... params)\n    {\n        RssHandler rh = new RssHandler();\n        try\n        {\n            SAXParserFactory spf = SAXParserFactory.newInstance();\n            SAXParser sp;\n            sp = spf.newSAXParser();\n            XMLReader xr = sp.getXMLReader();\n            xr.setContentHandler(rh);\n            xr.parse(new InputSource(params[0].openStream()));\n        } catch (ParserConfigurationException e)\n        {\n            e.printStackTrace();\n        } catch (SAXException e)\n        {\n            e.printStackTrace();\n        } catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return rh.articleList;\n    }\n    protected void onPostExecute(ArrayList<Article> articles)\n    {\n        mCallback.onFetchArticles(articles);\n        Log.d(TAG, \"Sync ended\");\n        /*\n        mArticles.clear();\n        mArticles.addAll(articles);\n        mAdapter.notifyDataSetChanged();\n        Intent intent = new Intent();\n        intent.setAction(MainActivity.SYNC_DONE);\n        try\n        {\n            getActivity().sendOrderedBroadcast(intent, null);\n        } catch (NullPointerException e)\n        {\n            // Om man kommer hit s\u00e5 har anv\u00e4ndaren avslutat applikationen\n            // och denna async-task kan inte l\u00e4ngre greppa 'current\n            // activity'.\n        }\n        */\n    }\n"]], "pred": {"ppl": 1.9221757650375366, "ppl_lower": 2.3402764797210693, "ppl/lowercase_ppl": -1.3011844592758095, "ppl/zlib": 0.0008902694215229829, "Min_5.0% Prob": 6.557456750136155, "Min_10.0% Prob": 4.873168087922609, "Min_20.0% Prob": 3.042056523618244, "Min_30.0% Prob": 2.143653354067711, "Min_40.0% Prob": 1.6236025013916549, "Min_50.0% Prob": 1.3061695161723454, "Min_60.0% Prob": 1.0881318804512303}}
{"hexsha": "bc6860900299db3977f627e8e610e668e7a51f9f", "ext": "java", "lang": "Java", "content": "public class ConverterFactoryTest {\n\n\tprivate ConverterFactory factory = ConverterFactory.withDefaults().build();\n\n    \n    @Test\n    public void testNoOpConversion() {\n        Function<Object,Object> f = factory.getConverter(ArrayList.class, List.class);\n        assertEquals(Arrays.asList(\"a\",\"b\"), f.apply(Arrays.asList(\"a\",\"b\")));\n    }\n    \n    @Test\n    public void testUnsupportedConversion() {\n        assertThrows(()->factory.getConverter(ArrayList.class, Map.class), UnsupportedOperationException.class)\n        .hasNoCause();\n    }\n\n\t@Test\n\tpublic void testBasicStringConversion() {\n\t\ttest(\"1\", Integer.class, 1);\n\t\ttest(\"2\", Long.class, 2l);\n\t\ttest(\"123\", Double.class, 123d);\n\t\ttest(\"4\", Float.class, 4f);\n\t\ttest(\"5\", byte.class, (byte)5);\n\t\ttest(\"t\", Boolean.class, true);\n\t\ttest(\"f\", Boolean.class, false);\n\t\ttest(\"2014-06-03\",LocalDate.class, LocalDate.of(2014, 6, 3));\n\t}\n\t\n\t@Test\n\tpublic void testBasicNumberConversion() {\n\t\ttest(1, Long.class, 1l);\n\t\ttest(1l, Byte.class, (byte)1);\n\t\ttest(1l, Short.class, (short)1);\n\t\ttest(1l, Integer.class, 1);\n\t\ttest(1l, Long.class, 1l);\n\t\ttest(1l, Float.class, 1f);\n\t\ttest(1l, Double.class, 1d);\n\t\ttest(1l, BigInteger.class, BigInteger.ONE);\n\t\ttest(1l, BigDecimal.class, BigDecimal.ONE);\n\n\t\ttest(new byte[] {BigInteger.TEN.byteValue()}, BigInteger.class, BigInteger.TEN);\n\t\t\n\t\ttest(BigDecimal.valueOf(1), Long.class, 1l);\n\t\ttest(1, BigDecimal.class, BigDecimal.valueOf(1));\n\t\t\n\t\ttest(LONG_MAX, Long.class, Long.MAX_VALUE);\n\t}\n\n\t\n\t@Test\n\tpublic void testOverflow() {\n\t\toverflow(Long.MAX_VALUE, Integer.class, 1);\n\t\toverflow(Integer.MAX_VALUE, Short.class, (short)1);\n\t\toverflow(Short.MAX_VALUE, Byte.class, (byte)1);\n\t\toverflow(LONG_MAX.add(BigInteger.ONE), Long.class, 1l);\n\t}\n\n\tprivate <T> void test(Object from, Class<T> to, T expected) {\n\t\tassertEquals(expected, factory.convert(from, to));\n\t}\n\t\n\tprivate <T> void overflow(Object from, Class<T> to, T expected) {\n\t\tassertThrows(()->test(from, to, expected), IllegalArgumentException.class)\n        .hasNoCause();\n\t}\n\t\n}", "class_id": 0, "repo": "restup/up-framework", "file": "up-core/src/test/java/com/github/restup/bind/converter/ConverterFactoryTest.java", "last_update_at": "2018-02-24T15:20:02+00:00", "question_id": "bc6860900299db3977f627e8e610e668e7a51f9f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConverterFactoryTest {\n\tprivate ConverterFactory factory = ConverterFactory.withDefaults().build();\n    @Test\n    public void testNoOpConversion() {\n        Function<Object,Object> f = factory.getConverter(ArrayList.class, List.class);\n        assertEquals(Arrays.asList(\"a\",\"b\"), f.apply(Arrays.asList(\"a\",\"b\")));\n    }\n    @Test\n    public void testUnsupportedConversion() {\n        assertThrows(()->factory.getConverter(ArrayList.class, Map.class), UnsupportedOperationException.class)\n        .hasNoCause();\n    }\n\t@Test\n\tpublic void testBasicStringConversion() {\n\t\ttest(\"1\", Integer.class, 1);\n\t\ttest(\"2\", Long.class, 2l);\n\t\ttest(\"123\", Double.class, 123d);\n\t\ttest(\"4\", Float.class, 4f);\n\t\ttest(\"5\", byte.class, (byte)5);\n\t\ttest(\"t\", Boolean.class, true);\n\t\ttest(\"f\", Boolean.class, false);\n\t\ttest(\"2014-06-03\",LocalDate.class, LocalDate.of(2014, 6, 3));\n\t}\n\t\n\t@Test\n\tpublic void testBasicNumberConversion() {\n\t\ttest(1, Long.class, 1l);\n\t\ttest(1l, Byte.class, (byte)1);\n\t\ttest(1l, Short.class, (short)1);\n\t\ttest(1l, Integer.class, 1);\n\t\ttest(1l, Long.class, 1l);\n\t\ttest(1l, Float.class, 1f);\n\t\ttest(1l, Double.class, 1d);\n\t\ttest(1l, BigInteger.class, BigInteger.ONE);\n\t\ttest(1l, BigDecimal.class, BigDecimal.ONE);\n\t\ttest(new byte[] {BigInteger.TEN.byteValue()}, BigInteger.class, BigInteger.TEN);\n\t\t\n\t\ttest(BigDecimal.valueOf(1), Long.class, 1l);\n\t\ttest(1, BigDecimal.class, BigDecimal.valueOf(1));\n\t\t\n\t\ttest(LONG_MAX, Long.class, Long.MAX_VALUE);\n\t}\n\t\n\t@Test\n\tpublic void testOverflow() {\n\t\toverflow(Long.MAX_VALUE, Integer.class, 1);\n\t\toverflow(Integer.MAX_VALUE, Short.class, (short)1);\n\t\toverflow(Short.MAX_VALUE, Byte.class, (byte)1);\n\t\toverflow(LONG_MAX.add(BigInteger.ONE), Long.class, 1l);\n\t}\n\tprivate <T> void test(Object from, Class<T> to, T expected) {\n\t\tassertEquals(expected, factory.convert(from, to));\n\t}\n\t\n\tprivate <T> void overflow(Object from, Class<T> to, T expected) {\n\t\tassertThrows(()->test(from, to, expected), IllegalArgumentException.class)\n        .hasNoCause();\n\t}\n\t\n"]], "pred": {"ppl": 1.7762761116027832, "ppl_lower": 1.933868169784546, "ppl/lowercase_ppl": -1.1479552713414478, "ppl/zlib": 0.0008399402057468619, "Min_5.0% Prob": 5.86872578278566, "Min_10.0% Prob": 4.139833505337055, "Min_20.0% Prob": 2.6233286808250815, "Min_30.0% Prob": 1.86214910092506, "Min_40.0% Prob": 1.4208001447426286, "Min_50.0% Prob": 1.1435854644644958, "Min_60.0% Prob": 0.9570633233060186}}
{"hexsha": "f7251d3359d14487ed2dda0ef1ef2b1cda8c4b0a", "ext": "java", "lang": "Java", "content": "@Slf4j\n@RequiredArgsConstructor\npublic class InternalGroovyScriptDao extends BaseGroovyScriptDaoImpl {\n    private final ApplicationContext applicationContext;\n    private final CasConfigurationProperties casProperties;\n\n    @Override\n    public Map<String, List<Object>> getPersonAttributesFromMultivaluedAttributes(final Map<String, List<Object>> attributes) {\n        if (attributes.containsKey(\"username\")) {\n            val username = attributes.get(\"username\");\n            if (!username.isEmpty()) {\n                val results = new HashMap<String, List<Object>>();\n                val attrs = getAttributesForUser(username.get(0).toString());\n                LOGGER.debug(\"Groovy-based attributes found are [{}]\", attrs);\n                attrs.forEach((k, v) -> {\n                    val values = new ArrayList<Object>(CollectionUtils.toCollection(v));\n                    LOGGER.debug(\"Adding Groovy-based attribute [{}] with value(s) [{}]\", k, values);\n                    results.put(k, values);\n                });\n                return results;\n            }\n        }\n        return new HashMap<>(0);\n    }\n\n    @Override\n    public Map<String, Object> getAttributesForUser(final String uid) {\n        val finalAttributes = new HashMap<String, Object>();\n        casProperties.getAuthn().getAttributeRepository().getGroovy()\n            .forEach(groovy -> {\n                final Object[] args = {uid, LOGGER, casProperties, applicationContext};\n                final Map<String, Object> personAttributesMap =\n                    ScriptingUtils.executeGroovyScript(groovy.getLocation(), args, Map.class, true);\n                finalAttributes.putAll(personAttributesMap);\n            });\n\n        return finalAttributes;\n    }\n}", "class_id": 0, "repo": "atticus88/cas", "file": "core/cas-server-core-authentication-api/src/main/java/org/apereo/cas/authentication/principal/resolvers/InternalGroovyScriptDao.java", "last_update_at": "2018-11-25T03:11:30+00:00", "question_id": "f7251d3359d14487ed2dda0ef1ef2b1cda8c4b0a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\n@RequiredArgsConstructor\npublic class InternalGroovyScriptDao extends BaseGroovyScriptDaoImpl {\n    private final ApplicationContext applicationContext;\n    private final CasConfigurationProperties casProperties;\n    @Override\n    public Map<String, List<Object>> getPersonAttributesFromMultivaluedAttributes(final Map<String, List<Object>> attributes) {\n        if (attributes.containsKey(\"username\")) {\n            val username = attributes.get(\"username\");\n            if (!username.isEmpty()) {\n                val results = new HashMap<String, List<Object>>();\n                val attrs = getAttributesForUser(username.get(0).toString());\n                LOGGER.debug(\"Groovy-based attributes found are [{}]\", attrs);\n                attrs.forEach((k, v) -> {\n                    val values = new ArrayList<Object>(CollectionUtils.toCollection(v));\n                    LOGGER.debug(\"Adding Groovy-based attribute [{}] with value(s) [{}]\", k, values);\n                    results.put(k, values);\n                });\n                return results;\n            }\n        }\n        return new HashMap<>(0);\n    }\n    @Override\n    public Map<String, Object> getAttributesForUser(final String uid) {\n        val finalAttributes = new HashMap<String, Object>();\n        casProperties.getAuthn().getAttributeRepository().getGroovy()\n            .forEach(groovy -> {\n                final Object[] args = {uid, LOGGER, casProperties, applicationContext};\n                final Map<String, Object> personAttributesMap =\n                    ScriptingUtils.executeGroovyScript(groovy.getLocation(), args, Map.class, true);\n                finalAttributes.putAll(personAttributesMap);\n            });\n        return finalAttributes;\n    }\n"]], "pred": {"ppl": 1.9034122228622437, "ppl_lower": 2.790442705154419, "ppl/lowercase_ppl": -1.59434965756205, "ppl/zlib": 0.0010041313295313654, "Min_5.0% Prob": 5.525059700012207, "Min_10.0% Prob": 4.273495640073504, "Min_20.0% Prob": 2.8769078254699707, "Min_30.0% Prob": 2.077911637841709, "Min_40.0% Prob": 1.5899379569486047, "Min_50.0% Prob": 1.2854839658355826, "Min_60.0% Prob": 1.0751298598525494}}
{"hexsha": "10020f6a3b0388a9d7f4f25f6cf126f3d1d25c3f", "ext": "java", "lang": "Java", "content": "public abstract class d\n{\n  protected static final String ADDRESS = \"address\";\n  protected static final String AUTHOR = \"author\";\n  protected static final String COMMENT = \"comment\";\n  protected static final String CONTENT_TYPE = \"contentType\";\n  protected static final String CUSTOM_FLAG = \"customFlag\";\n  protected static final String EXECUTE_URL = \"executeUrl\";\n  protected static final String EXT_INFO = \"extInfo\";\n  protected static final String FILE_PATH = \"filePath\";\n  protected static final String GROPU_ID = \"gropuId\";\n  protected static final String HIDDEN = \"hidden\";\n  protected static final String IMAGE_ARRAY = \"imageArray\";\n  protected static final String IMAGE_DATA = \"imageData\";\n  protected static final String IMAGE_PATH = \"imagePath\";\n  protected static final String IMAGE_URL = \"imageUrl\";\n  protected static final String INSTALL_URL = \"installUrl\";\n  protected static final String IS_FAMILY = \"isFamily\";\n  protected static final String IS_FRIEND = \"isFriend\";\n  protected static final String IS_PUBLIC = \"isPublic\";\n  protected static final String IS_SHARE_TENCENT_WEIBO = \"isShareTencentWeibo\";\n  protected static final String LATITUDE = \"latitude\";\n  protected static final String LONGITUDE = \"longitude\";\n  protected static final String MUSIC_URL = \"musicUrl\";\n  protected static final String NOTEBOOK = \"notebook\";\n  protected static final String SAFETY_LEVEL = \"safetyLevel\";\n  protected static final String SCENCE = \"scene\";\n  protected static final String SHARE_TYPE = \"shareType\";\n  protected static final String SITE = \"site\";\n  protected static final String SITE_URL = \"siteUrl\";\n  protected static final String STACK = \"stack\";\n  protected static final String TAGS = \"tags\";\n  protected static final String TEXT = \"text\";\n  protected static final String TITLE = \"title\";\n  protected static final String TITLE_URL = \"titleUrl\";\n  protected static final String URL = \"url\";\n  protected static final String VENUE_DESCRIPTION = \"venueDescription\";\n  protected static final String VENUE_NAME = \"venueName\";\n  private HashMap<String, Object> params = new HashMap();\n\n  public d()\n  {\n  }\n\n  public d(String paramString)\n  {\n    this(new e().a(paramString));\n  }\n\n  public d(HashMap<String, Object> paramHashMap)\n  {\n    this();\n    if (paramHashMap != null)\n      this.params.putAll(paramHashMap);\n  }\n\n  public <T> T get(String paramString, Class<T> paramClass)\n  {\n    Object localObject = this.params.get(paramString);\n    if (localObject != null)\n      return paramClass.cast(localObject);\n    if ((Byte.class.equals(paramClass)) || (Byte.TYPE.equals(paramClass)))\n      return paramClass.cast(new Byte(0));\n    if ((Short.class.equals(paramClass)) || (Short.TYPE.equals(paramClass)))\n      return paramClass.cast(new Short(0));\n    if ((Integer.class.equals(paramClass)) || (Integer.TYPE.equals(paramClass)))\n      return paramClass.cast(new Integer(0));\n    if ((Long.class.equals(paramClass)) || (Long.TYPE.equals(paramClass)))\n      return paramClass.cast(new Long(0L));\n    if ((Float.class.equals(paramClass)) || (Float.TYPE.equals(paramClass)))\n      return paramClass.cast(new Float(0.0F));\n    if ((Double.class.equals(paramClass)) || (Double.TYPE.equals(paramClass)))\n      return paramClass.cast(new Double(0.0D));\n    if ((Boolean.class.equals(paramClass)) || (Boolean.TYPE.equals(paramClass)))\n      return paramClass.cast(Boolean.valueOf(false));\n    return null;\n  }\n\n  public String getAddress()\n  {\n    return (String)get(\"address\", String.class);\n  }\n\n  public String getAuthor()\n  {\n    return (String)get(\"author\", String.class);\n  }\n\n  public String getComment()\n  {\n    return (String)get(\"comment\", String.class);\n  }\n\n  public int getContentType()\n  {\n    return ((Integer)get(\"contentType\", Integer.class)).intValue();\n  }\n\n  public String[] getCustomFlag()\n  {\n    return (String[])get(\"customFlag\", [Ljava.lang.String.class);\n  }\n\n  public String getExecuteUrl()\n  {\n    return (String)get(\"executeUrl\", String.class);\n  }\n\n  public String getExtInfo()\n  {\n    return (String)get(\"extInfo\", String.class);\n  }\n\n  public String getFilePath()\n  {\n    return (String)get(\"filePath\", String.class);\n  }\n\n  public String getGroupId()\n  {\n    return (String)get(\"gropuId\", String.class);\n  }\n\n  public int getHidden()\n  {\n    return ((Integer)get(\"hidden\", Integer.class)).intValue();\n  }\n\n  public String[] getImageArray()\n  {\n    return (String[])get(\"imageArray\", [Ljava.lang.String.class);\n  }\n\n  public Bitmap getImageData()\n  {\n    return (Bitmap)get(\"imageData\", Bitmap.class);\n  }\n\n  public String getImagePath()\n  {\n    return (String)get(\"imagePath\", String.class);\n  }\n\n  public String getImageUrl()\n  {\n    return (String)get(\"imageUrl\", String.class);\n  }\n\n  public String getInstallUrl()\n  {\n    return (String)get(\"installUrl\", String.class);\n  }\n\n  public float getLatitude()\n  {\n    return ((Float)get(\"latitude\", Float.class)).floatValue();\n  }\n\n  public float getLongitude()\n  {\n    return ((Float)get(\"longitude\", Float.class)).floatValue();\n  }\n\n  public String getMusicUrl()\n  {\n    return (String)get(\"musicUrl\", String.class);\n  }\n\n  public String getNotebook()\n  {\n    return (String)get(\"notebook\", String.class);\n  }\n\n  public int getSafetyLevel()\n  {\n    return ((Integer)get(\"safetyLevel\", Integer.class)).intValue();\n  }\n\n  public int getScence()\n  {\n    return ((Integer)get(\"scene\", Integer.class)).intValue();\n  }\n\n  public int getShareType()\n  {\n    return ((Integer)get(\"shareType\", Integer.class)).intValue();\n  }\n\n  public String getSite()\n  {\n    return (String)get(\"site\", String.class);\n  }\n\n  public String getSiteUrl()\n  {\n    return (String)get(\"siteUrl\", String.class);\n  }\n\n  public String getStack()\n  {\n    return (String)get(\"stack\", String.class);\n  }\n\n  public String[] getTags()\n  {\n    return (String[])get(\"tags\", [Ljava.lang.String.class);\n  }\n\n  public String getText()\n  {\n    return (String)get(\"text\", String.class);\n  }\n\n  public String getTitle()\n  {\n    return (String)get(\"title\", String.class);\n  }\n\n  public String getTitleUrl()\n  {\n    return (String)get(\"titleUrl\", String.class);\n  }\n\n  public String getUrl()\n  {\n    return (String)get(\"url\", String.class);\n  }\n\n  public String getVenueDescription()\n  {\n    return (String)get(\"venueDescription\", String.class);\n  }\n\n  public String getVenueName()\n  {\n    return (String)get(\"venueName\", String.class);\n  }\n\n  public boolean isFamily()\n  {\n    return ((Boolean)get(\"isFamily\", Boolean.class)).booleanValue();\n  }\n\n  public boolean isFriend()\n  {\n    return ((Boolean)get(\"isFriend\", Boolean.class)).booleanValue();\n  }\n\n  public boolean isPublic()\n  {\n    return ((Boolean)get(\"isPublic\", Boolean.class)).booleanValue();\n  }\n\n  public boolean isShareTencentWeibo()\n  {\n    return ((Boolean)get(\"isShareTencentWeibo\", Boolean.class)).booleanValue();\n  }\n\n  public void set(String paramString, Object paramObject)\n  {\n    this.params.put(paramString, paramObject);\n  }\n\n  public void setAddress(String paramString)\n  {\n    set(\"address\", paramString);\n  }\n\n  public void setAuthor(String paramString)\n  {\n    set(\"author\", paramString);\n  }\n\n  public void setComment(String paramString)\n  {\n    set(\"comment\", paramString);\n  }\n\n  public void setContentType(int paramInt)\n  {\n    set(\"contentType\", Integer.valueOf(paramInt));\n  }\n\n  public void setCustomFlag(String[] paramArrayOfString)\n  {\n    set(\"customFlag\", paramArrayOfString);\n  }\n\n  public void setExecuteUrl()\n  {\n    set(\"executeUrl\", String.class);\n  }\n\n  public void setExtInfo(String paramString)\n  {\n    set(\"extInfo\", paramString);\n  }\n\n  public void setFamily(boolean paramBoolean)\n  {\n    set(\"isFamily\", Boolean.valueOf(paramBoolean));\n  }\n\n  public void setFilePath(String paramString)\n  {\n    set(\"filePath\", paramString);\n  }\n\n  public void setFriend(boolean paramBoolean)\n  {\n    set(\"isFriend\", Boolean.valueOf(paramBoolean));\n  }\n\n  public void setGroupId(String paramString)\n  {\n    set(\"gropuId\", paramString);\n  }\n\n  public void setHidden(int paramInt)\n  {\n    set(\"hidden\", Integer.valueOf(paramInt));\n  }\n\n  public void setImageArray(String[] paramArrayOfString)\n  {\n    set(\"imageArray\", paramArrayOfString);\n  }\n\n  public void setImageData(Bitmap paramBitmap)\n  {\n    set(\"imageData\", paramBitmap);\n  }\n\n  public void setImagePath(String paramString)\n  {\n    set(\"imagePath\", paramString);\n  }\n\n  public void setImageUrl(String paramString)\n  {\n    set(\"imageUrl\", paramString);\n  }\n\n  public void setInstallUrl()\n  {\n    set(\"installUrl\", String.class);\n  }\n\n  public void setLatitude(float paramFloat)\n  {\n    set(\"latitude\", Float.valueOf(paramFloat));\n  }\n\n  public void setLongitude(float paramFloat)\n  {\n    set(\"longitude\", Float.valueOf(paramFloat));\n  }\n\n  public void setMusicUrl(String paramString)\n  {\n    set(\"musicUrl\", paramString);\n  }\n\n  public void setNotebook(String paramString)\n  {\n    set(\"notebook\", paramString);\n  }\n\n  public void setPublic(boolean paramBoolean)\n  {\n    set(\"isPublic\", Boolean.valueOf(paramBoolean));\n  }\n\n  public void setSafetyLevel(int paramInt)\n  {\n    set(\"safetyLevel\", Integer.valueOf(paramInt));\n  }\n\n  public void setScence(int paramInt)\n  {\n    set(\"scene\", Integer.valueOf(paramInt));\n  }\n\n  public void setShareTencentWeibo(boolean paramBoolean)\n  {\n    set(\"isShareTencentWeibo\", Boolean.valueOf(paramBoolean));\n  }\n\n  public void setShareType(int paramInt)\n  {\n    set(\"shareType\", Integer.valueOf(paramInt));\n  }\n\n  public void setSite(String paramString)\n  {\n    set(\"site\", paramString);\n  }\n\n  public void setSiteUrl(String paramString)\n  {\n    set(\"siteUrl\", paramString);\n  }\n\n  public void setStack(String paramString)\n  {\n    set(\"stack\", paramString);\n  }\n\n  public void setTags(String[] paramArrayOfString)\n  {\n    set(\"tags\", paramArrayOfString);\n  }\n\n  public void setText(String paramString)\n  {\n    set(\"text\", paramString);\n  }\n\n  public void setTitle(String paramString)\n  {\n    set(\"title\", paramString);\n  }\n\n  public void setTitleUrl(String paramString)\n  {\n    set(\"titleUrl\", paramString);\n  }\n\n  public void setUrl(String paramString)\n  {\n    set(\"url\", paramString);\n  }\n\n  public void setVenueDescription(String paramString)\n  {\n    set(\"venueDescription\", paramString);\n  }\n\n  public void setVenueName(String paramString)\n  {\n    set(\"venueName\", paramString);\n  }\n\n  public HashMap<String, Object> toMap()\n  {\n    if (this.params == null)\n      return new HashMap();\n    return this.params;\n  }\n\n  public String toString()\n  {\n    try\n    {\n      String str = new e().a(this.params);\n      return str;\n    }\n    catch (Throwable localThrowable)\n    {\n      cn.sharesdk.framework.utils.d.a().w(localThrowable);\n    }\n    return null;\n  }\n}", "class_id": 0, "repo": "clilystudio/NetBook", "file": "allsrc/cn/sharesdk/framework/d.java", "last_update_at": "2018-02-04T12:23:55+00:00", "question_id": "10020f6a3b0388a9d7f4f25f6cf126f3d1d25c3f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class d\n{\n  protected static final String ADDRESS = \"address\";\n  protected static final String AUTHOR = \"author\";\n  protected static final String COMMENT = \"comment\";\n  protected static final String CONTENT_TYPE = \"contentType\";\n  protected static final String CUSTOM_FLAG = \"customFlag\";\n  protected static final String EXECUTE_URL = \"executeUrl\";\n  protected static final String EXT_INFO = \"extInfo\";\n  protected static final String FILE_PATH = \"filePath\";\n  protected static final String GROPU_ID = \"gropuId\";\n  protected static final String HIDDEN = \"hidden\";\n  protected static final String IMAGE_ARRAY = \"imageArray\";\n  protected static final String IMAGE_DATA = \"imageData\";\n  protected static final String IMAGE_PATH = \"imagePath\";\n  protected static final String IMAGE_URL = \"imageUrl\";\n  protected static final String INSTALL_URL = \"installUrl\";\n  protected static final String IS_FAMILY = \"isFamily\";\n  protected static final String IS_FRIEND = \"isFriend\";\n  protected static final String IS_PUBLIC = \"isPublic\";\n  protected static final String IS_SHARE_TENCENT_WEIBO = \"isShareTencentWeibo\";\n  protected static final String LATITUDE = \"latitude\";\n  protected static final String LONGITUDE = \"longitude\";\n  protected static final String MUSIC_URL = \"musicUrl\";\n  protected static final String NOTEBOOK = \"notebook\";\n  protected static final String SAFETY_LEVEL = \"safetyLevel\";\n  protected static final String SCENCE = \"scene\";\n  protected static final String SHARE_TYPE = \"shareType\";\n  protected static final String SITE = \"site\";\n  protected static final String SITE_URL = \"siteUrl\";\n  protected static final String STACK = \"stack\";\n  protected static final String TAGS = \"tags\";\n  protected static final String TEXT = \"text\";\n  protected static final String TITLE = \"title\";\n  protected static final String TITLE_URL = \"titleUrl\";\n  protected static final String URL = \"url\";\n  protected static final String VENUE_DESCRIPTION = \"venueDescription\";\n  protected static final String VENUE_NAME = \"venueName\";\n  private HashMap<String, Object> params = new HashMap();\n  public d()\n  {\n  }\n  public d(String paramString)\n  {\n    this(new e().a(paramString));\n  }\n  public d(HashMap<String, Object> paramHashMap)\n  {\n    this();\n    if (paramHashMap != null)\n      this.params.putAll(paramHashMap);\n  }\n  public <T> T get(String paramString, Class<T> paramClass)\n  {\n    Object localObject = this.params.get(paramString);\n    if (localObject != null)\n      return paramClass.cast(localObject);\n    if ((Byte.class.equals(paramClass)) || (Byte.TYPE.equals(paramClass)))\n      return paramClass.cast(new Byte(0));\n    if ((Short.class.equals(paramClass)) || (Short.TYPE.equals(paramClass)))\n      return paramClass.cast(new Short(0));\n    if ((Integer.class.equals(paramClass)) || (Integer.TYPE.equals(paramClass)))\n      return paramClass.cast(new Integer(0));\n    if ((Long.class.equals(paramClass)) || (Long.TYPE.equals(paramClass)))\n      return paramClass.cast(new Long(0L));\n    if ((Float.class.equals(paramClass)) || (Float.TYPE.equals(paramClass)))\n      return paramClass.cast(new Float(0.0F));\n    if ((Double.class.equals(paramClass)) || (Double.TYPE.equals(paramClass)))\n      return paramClass.cast(new Double(0.0D));\n    if ((Boolean.class.equals(paramClass)) || (Boolean.TYPE.equals(paramClass)))\n      return paramClass.cast(Boolean.valueOf(false));\n    return null;\n  }\n  public String getAddress()\n  {\n    return (String)get(\"address\", String.class);\n  }\n  public String getAuthor()\n  {\n    return (String)get(\"author\", String.class);\n  }\n  public String getComment()\n  {\n    return (String)get(\"comment\", String.class);\n  }\n  public int getContentType()\n  {\n    return ((Integer)get(\"contentType\", Integer.class)).intValue();\n  }\n  public String[] getCustomFlag()\n  {\n    return (String[])get(\"customFlag\", [Ljava.lang.String.class);\n  }\n  public String getExecuteUrl()\n  {\n    return (String)get(\"executeUrl\", String.class);\n  }\n  public String getExtInfo()\n  {\n    return (String)get(\"extInfo\", String.class);\n  }\n  public String getFilePath()\n  {\n    return (String)get(\"filePath\", String.class);\n  }\n  public String getGroupId()\n  {\n    return (String)get(\"gropuId\", String.class);\n  }\n  public int getHidden()\n  {\n    return ((Integer)get(\"hidden\", Integer.class)).intValue();\n  }\n  public String[] getImageArray()\n  {\n    return (String[])get(\"imageArray\", [Ljava.lang.String.class);\n  }\n  public Bitmap getImageData()\n  {\n    return (Bitmap)get(\"imageData\", Bitmap.class);\n  }\n  public String getImagePath()\n  {\n    return (String)get(\"imagePath\", String.class);\n  }\n  public String getImageUrl()\n  {\n    return (String)get(\"imageUrl\", String.class);\n  }\n  public String getInstallUrl()\n  {\n    return (String)get(\"installUrl\", String.class);\n  }\n  public float getLatitude()\n  {\n    return ((Float)get(\"latitude\", Float.class)).floatValue();\n  }\n  public float getLongitude()\n  {\n    return ((Float)get(\"longitude\", Float.class)).floatValue();\n  }\n  public String getMusicUrl()\n  {\n    return (String)get(\"musicUrl\", String.class);\n  }\n  public String getNotebook()\n  {\n    return (String)get(\"notebook\", String.class);\n  }\n  public int getSafetyLevel()\n  {\n    return ((Integer)get(\"safetyLevel\", Integer.class)).intValue();\n  }\n  public int getScence()\n  {\n    return ((Integer)get(\"scene\", Integer.class)).intValue();\n  }\n  public int getShareType()\n  {\n    return ((Integer)get(\"shareType\", Integer.class)).intValue();\n  }\n  public String getSite()\n  {\n    return (String)get(\"site\", String.class);\n  }\n  public String getSiteUrl()\n  {\n    return (String)get(\"siteUrl\", String.class);\n  }\n  public String getStack()\n  {\n    return (String)get(\"stack\", String.class);\n  }\n  public String[] getTags()\n  {\n    return (String[])get(\"tags\", [Ljava.lang.String.class);\n  }\n  public String getText()\n  {\n    return (String)get(\"text\", String.class);\n  }\n  public String getTitle()\n  {\n    return (String)get(\"title\", String.class);\n  }\n  public String getTitleUrl()\n  {\n    return (String)get(\"titleUrl\", String.class);\n  }\n  public String getUrl()\n  {\n    return (String)get(\"url\", String.class);\n  }\n  public String getVenueDescription()\n  {\n    return (String)get(\"venueDescription\", String.class);\n  }\n  public String getVenueName()\n  {\n    return (String)get(\"venueName\", String.class);\n  }\n  public boolean isFamily()\n  {\n    return ((Boolean)get(\"isFamily\", Boolean.class)).booleanValue();\n  }\n  public boolean isFriend()\n  {\n    return ((Boolean)get(\"isFriend\", Boolean.class)).booleanValue();\n  }\n  public boolean isPublic()\n  {\n    return ((Boolean)get(\"isPublic\", Boolean.class)).booleanValue();\n  }\n  public boolean isShareTencentWeibo()\n  {\n    return ((Boolean)get(\"isShareTencentWeibo\", Boolean.class)).booleanValue();\n  }\n  public void set(String paramString, Object paramObject)\n  {\n    this.params.put(paramString, paramObject);\n  }\n  public void setAddress(String paramString)\n  {\n    set(\"address\", paramString);\n  }\n  public void setAuthor(String paramString)\n  {\n    set(\"author\", paramString);\n  }\n  public void setComment(String paramString)\n  {\n    set(\"comment\", paramString);\n  }\n  public void setContentType(int paramInt)\n  {\n    set(\"contentType\", Integer.valueOf(paramInt));\n  }\n  public void setCustomFlag(String[] paramArrayOfString)\n  {\n    set(\"customFlag\", paramArrayOfString);\n  }\n  public void setExecuteUrl()\n  {\n    set(\"executeUrl\", String.class);\n  }\n  public void setExtInfo(String paramString)\n  {\n    set(\"extInfo\", paramString);\n  }\n  public void setFamily(boolean paramBoolean)\n  {\n    set(\"isFamily\", Boolean.valueOf(paramBoolean));\n  }\n  public void setFilePath(String paramString)\n  {\n    set(\"filePath\", paramString);\n  }\n  public void setFriend(boolean paramBoolean)\n  {\n    set(\"isFriend\", Boolean.valueOf(paramBoolean));\n  }\n  public void setGroupId(String paramString)\n  {\n    set(\"gropuId\", paramString);\n  }\n  public void setHidden(int paramInt)\n  {\n    set(\"hidden\", Integer.valueOf(paramInt));\n  }\n  public void setImageArray(String[] paramArrayOfString)\n  {\n    set(\"imageArray\", paramArrayOfString);\n  }\n  public void setImageData(Bitmap paramBitmap)\n  {\n    set(\"imageData\", paramBitmap);\n  }\n  public void setImagePath(String paramString)\n  {\n    set(\"imagePath\", paramString);\n  }\n  public void setImageUrl(String paramString)\n  {\n    set(\"imageUrl\", paramString);\n  }\n  public void setInstallUrl()\n  {\n    set(\"installUrl\", String.class);\n  }\n  public void setLatitude(float paramFloat)\n  {\n    set(\"latitude\", Float.valueOf(paramFloat));\n  }\n  public void setLongitude(float paramFloat)\n  {\n    set(\"longitude\", Float.valueOf(paramFloat));\n  }\n  public void setMusicUrl(String paramString)\n  {\n    set(\"musicUrl\", paramString);\n  }\n  public void setNotebook(String paramString)\n  {\n    set(\"notebook\", paramString);\n  }\n  public void setPublic(boolean paramBoolean)\n  {\n    set(\"isPublic\", Boolean.valueOf(paramBoolean));\n  }\n  public void setSafetyLevel(int paramInt)\n  {\n    set(\"safetyLevel\", Integer.valueOf(paramInt));\n  }\n  public void setScence(int paramInt)\n  {\n    set(\"scene\", Integer.valueOf(paramInt));\n  }\n  public void setShareTencentWeibo(boolean paramBoolean)\n  {\n    set(\"isShareTencentWeibo\", Boolean.valueOf(paramBoolean));\n  }\n  public void setShareType(int paramInt)\n  {\n    set(\"shareType\", Integer.valueOf(paramInt));\n  }\n  public void setSite(String paramString)\n  {\n    set(\"site\", paramString);\n  }\n  public void setSiteUrl(String paramString)\n  {\n    set(\"siteUrl\", paramString);\n  }\n  public void setStack(String paramString)\n  {\n    set(\"stack\", paramString);\n  }\n  public void setTags(String[] paramArrayOfString)\n  {\n    set(\"tags\", paramArrayOfString);\n  }\n  public void setText(String paramString)\n  {\n    set(\"text\", paramString);\n  }\n  public void setTitle(String paramString)\n  {\n    set(\"title\", paramString);\n  }\n  public void setTitleUrl(String paramString)\n  {\n    set(\"titleUrl\", paramString);\n  }\n  public void setUrl(String paramString)\n  {\n    set(\"url\", paramString);\n  }\n  public void setVenueDescription(String paramString)\n  {\n    set(\"venueDescription\", paramString);\n  }\n  public void setVenueName(String paramString)\n  {\n    set(\"venueName\", paramString);\n  }\n  public HashMap<String, Object> toMap()\n  {\n    if (this.params == null)\n      return new HashMap();\n    return this.params;\n  }\n  public String toString()\n  {\n    try\n    {\n      String str = new e().a(this.params);\n      return str;\n    }\n    catch (Throwable localThrowable)\n    {\n      cn.sharesdk.framework.utils.d.a().w(localThrowable);\n    }\n    return null;\n  }\n"]], "pred": {"ppl": 1.5081583261489868, "ppl_lower": 1.6738457679748535, "ppl/lowercase_ppl": -1.2536804695339754, "ppl/zlib": 0.00021996212788522078, "Min_5.0% Prob": 4.828726679671044, "Min_10.0% Prob": 3.359204681480632, "Min_20.0% Prob": 2.0046653320245884, "Min_30.0% Prob": 1.3661493316743207, "Min_40.0% Prob": 1.0259010155678414, "Min_50.0% Prob": 0.822014113719103, "Min_60.0% Prob": 0.6855401184603945}}
{"hexsha": "bddbe429e98d65a13bc788d7d12a025d69baee36", "ext": "java", "lang": "Java", "content": "public class BaseTestExpressions {\n\t@BeforeClass\n\tpublic static void createObjects(){\n\t\td1 = new DoubleExpression(1.0);\n\t\td2 = new DoubleExpression(2.0);\n\t\td3 = new DoubleExpression(3.0);\n\t\td0 = new DoubleExpression(0.0);\n\t\t\n\t\ts123 = SumExpression.create(d1,d2,d3);\n\t\tp223 = ProductExpression.create(d2,d2,d3);\n\t\t\n\t\tmin23 = MinExpression.create(d2, d3);\n\t\tdiv23 = DivExpression.create(d2, d3);\n\t\tpdiv23 = PEPADivExpression.create(d2, d3);\n\t\tpdiv20 = PEPADivExpression.create(d2, d0);\n\t}\n\t\n\tprotected static AbstractExpression d1, d2, d3, d0;\n\t\n\tprotected static AbstractExpression s123, p223, min23, div23, pdiv23, pdiv20;\n}", "class_id": 0, "repo": "anton23/gpanalyser", "file": "test-jexpressions/uk/ac/imperial/doc/jexpressions/testing/BaseTestExpressions.java", "last_update_at": "2018-02-13T20:52:12+00:00", "question_id": "bddbe429e98d65a13bc788d7d12a025d69baee36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BaseTestExpressions {\n\t@BeforeClass\n\tpublic static void createObjects(){\n\t\td1 = new DoubleExpression(1.0);\n\t\td2 = new DoubleExpression(2.0);\n\t\td3 = new DoubleExpression(3.0);\n\t\td0 = new DoubleExpression(0.0);\n\t\t\n\t\ts123 = SumExpression.create(d1,d2,d3);\n\t\tp223 = ProductExpression.create(d2,d2,d3);\n\t\t\n\t\tmin23 = MinExpression.create(d2, d3);\n\t\tdiv23 = DivExpression.create(d2, d3);\n\t\tpdiv23 = PEPADivExpression.create(d2, d3);\n\t\tpdiv20 = PEPADivExpression.create(d2, d0);\n\t}\n\t\n\tprotected static AbstractExpression d1, d2, d3, d0;\n\t\n\tprotected static AbstractExpression s123, p223, min23, div23, pdiv23, pdiv20;\n"]], "pred": {"ppl": 2.1227145195007324, "ppl_lower": 2.3267335891723633, "ppl/lowercase_ppl": -1.1219213650132727, "ppl/zlib": 0.003022874310660673, "Min_5.0% Prob": 7.446100748502291, "Min_10.0% Prob": 5.507526361025297, "Min_20.0% Prob": 3.5211778395580797, "Min_30.0% Prob": 2.4490135589614512, "Min_40.0% Prob": 1.875160007333418, "Min_50.0% Prob": 1.5033896246686913, "Min_60.0% Prob": 1.2530761619040276}}
{"hexsha": "376b3b617019608de4787f93beb8cc2aed87fbcf", "ext": "java", "lang": "Java", "content": "public class MailService {\r\n\tprivate Logger logger = LogManager.getLogger( this.getClass().getName() );\r\n\t\r\n\r\n\tpublic void sendUserRequest( User user ) throws Exception {\r\n\t\tlogger.debug(\"new user request \" + user.getFullName() );\r\n\t\tProperties props = new Properties();\r\n        Session session = Session.getDefaultInstance(props, null);\r\n\r\n        String msgBody = \"A new user is requesting access to Sagitarii system.<br>\";\r\n        msgBody += \"Full Name: \" + user.getFullName() + \"<br>\";\r\n        msgBody += \"Login Name: \" + user.getLoginName() + \"<br>\";\r\n        msgBody += \"Mail Address: \" + user.getUserMail() + \"<br>\";\r\n\r\n        try {\r\n        \tMimeMessage msg = new MimeMessage(session);\r\n            msg.setFrom(new InternetAddress(\"sagitarii@eic.cefet-rj.br\", \"Sagitarii Mail Service\"));\r\n            \r\n            UserService us = new UserService();\r\n            List<User> users = us.getList( UserType.ADMIN );\r\n            \r\n            for ( User admin : users ) {\r\n            \tmsg.addRecipient(Message.RecipientType.TO,\r\n                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));\r\n            }\r\n            \r\n            msg.setSubject(\"User Access Request: \"+ user.getFullName() );\r\n            msg.setText(msgBody, \"utf-8\", \"html\");\r\n            Transport.send(msg);\r\n\r\n        } catch ( Exception e) {\r\n\t\t\tlogger.error( e.getMessage() );\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tpublic void notifyUserChange( User user ) throws Exception {\r\n\t\tlogger.debug(\"send user change notification \" + user.getFullName() );\r\n\t\tProperties props = new Properties();\r\n        Session session = Session.getDefaultInstance(props, null);\r\n\r\n        String msgBody = \"An administrator updated your data.<br>\";\r\n        msgBody += \"Full Name: \" + user.getFullName() + \"<br>\";\r\n        msgBody += \"Login Name: \" + user.getLoginName() + \"<br>\";\r\n        msgBody += \"Mail Address: \" + user.getUserMail() + \"<br>\";\r\n        msgBody += \"Type: \" + user.getType() + \"<br>\";\r\n\r\n        try {\r\n        \tMimeMessage msg = new MimeMessage(session);\r\n            msg.setFrom(new InternetAddress(\"sagitarii@eic.cefet-rj.br\", \"Sagitarii Mail Service\"));\r\n            \r\n            UserService us = new UserService();\r\n            List<User> users = us.getList( UserType.ADMIN );\r\n            \r\n            for ( User admin : users ) {\r\n            \tmsg.addRecipient(Message.RecipientType.TO,\r\n                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));\r\n            }\r\n            \r\n            msg.setSubject(\"Your user data was updated\");\r\n            msg.setText(msgBody, \"utf-8\", \"html\");\r\n            Transport.send(msg);\r\n\r\n        } catch ( Exception e) {\r\n\t\t\tlogger.error( e.getMessage() );\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n}", "class_id": 0, "repo": "icemagno/webomt", "file": "src/main/java/br/com/cmabreu/webomt/persistence/services/MailService.java", "last_update_at": "2018-11-20T06:45:17+00:00", "question_id": "376b3b617019608de4787f93beb8cc2aed87fbcf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MailService {\r\n\tprivate Logger logger = LogManager.getLogger( this.getClass().getName() );\r\n\t\r\n\r\n\tpublic void sendUserRequest( User user ) throws Exception {\r\n\t\tlogger.debug(\"new user request \" + user.getFullName() );\r\n\t\tProperties props = new Properties();\r\n        Session session = Session.getDefaultInstance(props, null);\r\n\r\n        String msgBody = \"A new user is requesting access to Sagitarii system.<br>\";\r\n        msgBody += \"Full Name: \" + user.getFullName() + \"<br>\";\r\n        msgBody += \"Login Name: \" + user.getLoginName() + \"<br>\";\r\n        msgBody += \"Mail Address: \" + user.getUserMail() + \"<br>\";\r\n\r\n        try {\r\n        \tMimeMessage msg = new MimeMessage(session);\r\n            msg.setFrom(new InternetAddress(\"sagitarii@eic.cefet-rj.br\", \"Sagitarii Mail Service\"));\r\n            \r\n            UserService us = new UserService();\r\n            List<User> users = us.getList( UserType.ADMIN );\r\n            \r\n            for ( User admin : users ) {\r\n            \tmsg.addRecipient(Message.RecipientType.TO,\r\n                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));\r\n            }\r\n            \r\n            msg.setSubject(\"User Access Request: \"+ user.getFullName() );\r\n            msg.setText(msgBody, \"utf-8\", \"html\");\r\n            Transport.send(msg);\r\n\r\n        } catch ( Exception e) {\r\n\t\t\tlogger.error( e.getMessage() );\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tpublic void notifyUserChange( User user ) throws Exception {\r\n\t\tlogger.debug(\"send user change notification \" + user.getFullName() );\r\n\t\tProperties props = new Properties();\r\n        Session session = Session.getDefaultInstance(props, null);\r\n\r\n        String msgBody = \"An administrator updated your data.<br>\";\r\n        msgBody += \"Full Name: \" + user.getFullName() + \"<br>\";\r\n        msgBody += \"Login Name: \" + user.getLoginName() + \"<br>\";\r\n        msgBody += \"Mail Address: \" + user.getUserMail() + \"<br>\";\r\n        msgBody += \"Type: \" + user.getType() + \"<br>\";\r\n\r\n        try {\r\n        \tMimeMessage msg = new MimeMessage(session);\r\n            msg.setFrom(new InternetAddress(\"sagitarii@eic.cefet-rj.br\", \"Sagitarii Mail Service\"));\r\n            \r\n            UserService us = new UserService();\r\n            List<User> users = us.getList( UserType.ADMIN );\r\n            \r\n            for ( User admin : users ) {\r\n            \tmsg.addRecipient(Message.RecipientType.TO,\r\n                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));\r\n            }\r\n            \r\n            msg.setSubject(\"Your user data was updated\");\r\n            msg.setText(msgBody, \"utf-8\", \"html\");\r\n            Transport.send(msg);\r\n\r\n        } catch ( Exception e) {\r\n\t\t\tlogger.error( e.getMessage() );\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n"]], "pred": {"ppl": 1.601222038269043, "ppl_lower": 1.8022279739379883, "ppl/lowercase_ppl": -1.2511996871559132, "ppl/zlib": 0.0006953723953279458, "Min_5.0% Prob": 4.935868722200394, "Min_10.0% Prob": 3.642313799262047, "Min_20.0% Prob": 2.226363125629723, "Min_30.0% Prob": 1.5466548670005995, "Min_40.0% Prob": 1.1740497403554735, "Min_50.0% Prob": 0.9404429723856165, "Min_60.0% Prob": 0.7850435055228128}}
{"hexsha": "06d7c92df3b2ba6eafb76808dffd6ef5b816bdcb", "ext": "java", "lang": "Java", "content": "public class WordCount extends Configured implements Tool {\n\n    public static class MapClass extends MapReduceBase\n            implements Mapper<LongWritable, Text, Text, IntWritable>\n    {\n        private Text word = new Text();\n        private final static IntWritable one = new IntWritable( 1 );\n\n        public void map( LongWritable key, // Offset into the file\n                         Text value,\n                         OutputCollector<Text, IntWritable> output,\n                         Reporter reporter) throws IOException\n        {\n            // Get the value as a String\n            String text = value.toString().toLowerCase();\n\n            // Replace all non-characters\n            text = text.replaceAll( \"'\", \"\" );\n            text = text.replaceAll( \"[^a-zA-Z]\", \" \" );\n\n            // Iterate over all of the words in the string\n            StringTokenizer st = new StringTokenizer( text );\n            while( st.hasMoreTokens() )\n            {\n                // Get the next token and set it as the text for our \"word\" variable\n                word.set( st.nextToken() );\n\n                // Output this word as the key and 1 as the value\n                output.collect( word, one );\n            }\n        }\n    }\n\n    public static class Reduce extends MapReduceBase\n            implements Reducer<Text, IntWritable, Text, IntWritable>\n    {\n        public void reduce( Text key, Iterator<IntWritable> values,\n                            OutputCollector<Text, IntWritable> output,\n                            Reporter reporter) throws IOException\n        {\n            // Iterate over all of the values (counts of occurrences of this word)\n            int count = 0;\n            while( values.hasNext() )\n            {\n                // Add the value to our count\n                count += values.next().get();\n            }\n\n            // Output the word with its count (wrapped in an IntWritable)\n            output.collect( key, new IntWritable( count ) );\n        }\n    }\n\n\n    public int run(String[] args) throws Exception\n    {\n        // Create a configuration\n        Configuration conf = getConf();\n\n        // Create a job from the default configuration that will use the WordCount class\n        JobConf job = new JobConf( conf, WordCount.class );\n\n        // Define our input path as the first command line argument and our output path as the second\n        Path in = new Path( args[0] );\n        Path out = new Path( args[1] );\n\n        // Create File Input/Output formats for these paths (in the job)\n        FileInputFormat.setInputPaths( job, in );\n        FileOutputFormat.setOutputPath( job, out );\n\n        // Configure the job: name, mapper, reducer, and combiner\n        job.setJobName( \"WordCount\" );\n        job.setMapperClass( MapClass.class );\n        job.setReducerClass( Reduce.class );\n        job.setCombinerClass( Reduce.class );\n\n        // Configure the output\n        job.setOutputFormat( TextOutputFormat.class );\n        job.setOutputKeyClass( Text.class );\n        job.setOutputValueClass( IntWritable.class );\n\n        // Run the job\n        JobClient.runJob(job);\n        return 0;\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        // Start the WordCount MapReduce application\n        int res = ToolRunner.run( new Configuration(),\n                new WordCount(),\n                args );\n        System.exit( res );\n    }\n}", "class_id": 0, "repo": "spencerwuwu/j-ReCoVer", "file": "benchmarks/collected-2018/filtered/github_50-250_34.java", "last_update_at": "2018-10-02T16:14:43+00:00", "question_id": "06d7c92df3b2ba6eafb76808dffd6ef5b816bdcb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WordCount extends Configured implements Tool {\n    public static class MapClass extends MapReduceBase\n            implements Mapper<LongWritable, Text, Text, IntWritable>\n    {\n        private Text word = new Text();\n        private final static IntWritable one = new IntWritable( 1 );\n        public void map( LongWritable key, // Offset into the file\n                         Text value,\n                         OutputCollector<Text, IntWritable> output,\n                         Reporter reporter) throws IOException\n        {\n            // Get the value as a String\n            String text = value.toString().toLowerCase();\n            // Replace all non-characters\n            text = text.replaceAll( \"'\", \"\" );\n            text = text.replaceAll( \"[^a-zA-Z]\", \" \" );\n            // Iterate over all of the words in the string\n            StringTokenizer st = new StringTokenizer( text );\n            while( st.hasMoreTokens() )\n            {\n                // Get the next token and set it as the text for our \"word\" variable\n                word.set( st.nextToken() );\n                // Output this word as the key and 1 as the value\n                output.collect( word, one );\n            }\n        }\n    }\n    public static class Reduce extends MapReduceBase\n            implements Reducer<Text, IntWritable, Text, IntWritable>\n    {\n        public void reduce( Text key, Iterator<IntWritable> values,\n                            OutputCollector<Text, IntWritable> output,\n                            Reporter reporter) throws IOException\n        {\n            // Iterate over all of the values (counts of occurrences of this word)\n            int count = 0;\n            while( values.hasNext() )\n            {\n                // Add the value to our count\n                count += values.next().get();\n            }\n            // Output the word with its count (wrapped in an IntWritable)\n            output.collect( key, new IntWritable( count ) );\n        }\n    }\n    public int run(String[] args) throws Exception\n    {\n        // Create a configuration\n        Configuration conf = getConf();\n        // Create a job from the default configuration that will use the WordCount class\n        JobConf job = new JobConf( conf, WordCount.class );\n        // Define our input path as the first command line argument and our output path as the second\n        Path in = new Path( args[0] );\n        Path out = new Path( args[1] );\n        // Create File Input/Output formats for these paths (in the job)\n        FileInputFormat.setInputPaths( job, in );\n        FileOutputFormat.setOutputPath( job, out );\n        // Configure the job: name, mapper, reducer, and combiner\n        job.setJobName( \"WordCount\" );\n        job.setMapperClass( MapClass.class );\n        job.setReducerClass( Reduce.class );\n        job.setCombinerClass( Reduce.class );\n        // Configure the output\n        job.setOutputFormat( TextOutputFormat.class );\n        job.setOutputKeyClass( Text.class );\n        job.setOutputValueClass( IntWritable.class );\n        // Run the job\n        JobClient.runJob(job);\n        return 0;\n    }\n    public static void main(String[] args) throws Exception\n    {\n        // Start the WordCount MapReduce application\n        int res = ToolRunner.run( new Configuration(),\n                new WordCount(),\n                args );\n        System.exit( res );\n    }\n"]], "pred": {"ppl": 1.692137598991394, "ppl_lower": 1.9499702453613281, "ppl/lowercase_ppl": -1.2696264882660364, "ppl/zlib": 0.00046465775720710116, "Min_5.0% Prob": 5.095898622690245, "Min_10.0% Prob": 3.908936877360289, "Min_20.0% Prob": 2.4484826099872588, "Min_30.0% Prob": 1.7195623767183308, "Min_40.0% Prob": 1.3094231091439723, "Min_50.0% Prob": 1.0508400316107762, "Min_60.0% Prob": 0.8763157420750962}}
{"hexsha": "9e11ce42f9ad2d7abf716ef541e0b07f2051435f", "ext": "java", "lang": "Java", "content": "public class ItemBaseCyclic extends Item {\n\n  public static final String ENERGYTTMAX = \"energyttmax\";\n  public static final String ENERGYTT = \"energytt\";\n  public static final float INACCURACY_DEFAULT = 1.0F;\n  public static final float VELOCITY_MAX = 1.5F;\n  private boolean hasEnergy;\n\n  public ItemBaseCyclic(Properties properties) {\n    super(properties);\n    ItemRegistry.ITEMSFIXME.add(this);\n  }\n\n  public void setUsesEnergy() {\n    this.hasEnergy = true;\n  }\n\n  protected void shootMe(Level world, Player shooter, Projectile ball, float pitch, float velocityFactor) {\n    if (world.isClientSide) {\n      return;\n    }\n    Vec3 vector3d1 = shooter.getUpVector(1.0F);\n    // pitch is degrees so can be -10, +10, etc\n    Quaternion quaternion = new Quaternion(new Vector3f(vector3d1), pitch, true);\n    Vec3 vector3d = shooter.getViewVector(1.0F);\n    Vector3f vector3f = new Vector3f(vector3d);\n    vector3f.transform(quaternion);\n    ball.shoot(vector3f.x(), vector3f.y(), vector3f.z(), velocityFactor * VELOCITY_MAX, INACCURACY_DEFAULT);\n    //    worldIn.playSound(null, player.getPosX(), player.getPosY(), player.getPosZ(),\n    //        SoundEvents.ENTITY_ENDER_PEARL_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (random.nextFloat() * 0.4F + 0.8F));\n    world.addFreshEntity(ball);\n  }\n\n  protected ItemStack findAmmo(Player player, Item item) {\n    for (int i = 0; i < player.getInventory().getContainerSize(); ++i) {\n      ItemStack itemstack = player.getInventory().getItem(i);\n      if (itemstack.getItem() == item) {\n        return itemstack;\n      }\n    }\n    return ItemStack.EMPTY;\n  }\n\n  public void tryRepairWith(ItemStack stackToRepair, Player player, Item target) {\n    if (stackToRepair.isDamaged()) {\n      ItemStack torches = this.findAmmo(player, target);\n      if (!torches.isEmpty()) {\n        torches.shrink(1);\n        UtilItemStack.repairItem(stackToRepair);\n      }\n    }\n  }\n\n  public float getChargedPercent(ItemStack stack, int chargeTimer) {\n    return BowItem.getPowerForTime(this.getUseDuration(stack) - chargeTimer);\n  }\n\n  @Override\n  public boolean isBarVisible(ItemStack stack) {\n    if (hasEnergy) {\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      return storage != null; // && storage.getEnergyStored() > 0;\n    }\n    return super.isBarVisible(stack);\n  }\n\n  @Override\n  @OnlyIn(Dist.CLIENT)\n  public void appendHoverText(ItemStack stack, Level worldIn, List<Component> tooltip, TooltipFlag flagIn) {\n    tooltip.add(new TranslatableComponent(getDescriptionId() + \".tooltip\").withStyle(ChatFormatting.GRAY));\n    if (this.hasEnergy) {\n      int current = 0;\n      int energyttmax = 0;\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      if (storage != null) {\n        current = storage.getEnergyStored();\n        energyttmax = storage.getMaxEnergyStored();\n        tooltip.add(new TranslatableComponent(current + \"/\" + energyttmax).withStyle(ChatFormatting.RED));\n      }\n    }\n  }\n\n  @Override\n  public int getBarWidth(ItemStack stack) {\n    if (hasEnergy) {\n      float current = 0;\n      float max = 0;\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      if (storage != null) {\n        current = storage.getEnergyStored();\n        max = storage.getMaxEnergyStored();\n      }\n      return (max == 0) ? 0 : Math.round(13.0F * current / max);\n    }\n    return super.getBarWidth(stack);\n  }\n\n  @OnlyIn(Dist.CLIENT)\n  public void registerClient() {}\n\n  @Override\n  public ICapabilityProvider initCapabilities(ItemStack stack, CompoundTag nbt) {\n    if (this.hasEnergy) {\n      return new CapabilityProviderEnergyStack(16000);\n    }\n    return super.initCapabilities(stack, nbt);\n  }\n\n  // ShareTag for server->client capability data sync\n  @Override\n  public CompoundTag getShareTag(ItemStack stack) {\n    if (hasEnergy) {\n      CompoundTag nbt = stack.getOrCreateTag();\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      //on server  this runs . also has correct values.\n      //set data for sync to client\n      if (storage != null) {\n        nbt.putInt(ENERGYTT, storage.getEnergyStored());\n        nbt.putInt(ENERGYTTMAX, storage.getMaxEnergyStored());\n      }\n      return nbt;\n    }\n    return super.getShareTag(stack);\n  }\n\n  //clientside read tt\n  @Override\n  public void readShareTag(ItemStack stack, CompoundTag nbt) {\n    if (hasEnergy && nbt != null) {\n      CompoundTag stackTag = stack.getOrCreateTag();\n      stackTag.putInt(ENERGYTT, nbt.getInt(ENERGYTT));\n      stackTag.putInt(ENERGYTTMAX, nbt.getInt(ENERGYTTMAX));\n    }\n    super.readShareTag(stack, nbt);\n  }\n}", "class_id": 0, "repo": "henkelmax/Cyclic", "file": "src/main/java/com/lothrazar/cyclic/item/ItemBaseCyclic.java", "last_update_at": "2018-11-29T15:52:20+00:00", "question_id": "9e11ce42f9ad2d7abf716ef541e0b07f2051435f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ItemBaseCyclic extends Item {\n  public static final String ENERGYTTMAX = \"energyttmax\";\n  public static final String ENERGYTT = \"energytt\";\n  public static final float INACCURACY_DEFAULT = 1.0F;\n  public static final float VELOCITY_MAX = 1.5F;\n  private boolean hasEnergy;\n  public ItemBaseCyclic(Properties properties) {\n    super(properties);\n    ItemRegistry.ITEMSFIXME.add(this);\n  }\n  public void setUsesEnergy() {\n    this.hasEnergy = true;\n  }\n  protected void shootMe(Level world, Player shooter, Projectile ball, float pitch, float velocityFactor) {\n    if (world.isClientSide) {\n      return;\n    }\n    Vec3 vector3d1 = shooter.getUpVector(1.0F);\n    // pitch is degrees so can be -10, +10, etc\n    Quaternion quaternion = new Quaternion(new Vector3f(vector3d1), pitch, true);\n    Vec3 vector3d = shooter.getViewVector(1.0F);\n    Vector3f vector3f = new Vector3f(vector3d);\n    vector3f.transform(quaternion);\n    ball.shoot(vector3f.x(), vector3f.y(), vector3f.z(), velocityFactor * VELOCITY_MAX, INACCURACY_DEFAULT);\n    //    worldIn.playSound(null, player.getPosX(), player.getPosY(), player.getPosZ(),\n    //        SoundEvents.ENTITY_ENDER_PEARL_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (random.nextFloat() * 0.4F + 0.8F));\n    world.addFreshEntity(ball);\n  }\n  protected ItemStack findAmmo(Player player, Item item) {\n    for (int i = 0; i < player.getInventory().getContainerSize(); ++i) {\n      ItemStack itemstack = player.getInventory().getItem(i);\n      if (itemstack.getItem() == item) {\n        return itemstack;\n      }\n    }\n    return ItemStack.EMPTY;\n  }\n  public void tryRepairWith(ItemStack stackToRepair, Player player, Item target) {\n    if (stackToRepair.isDamaged()) {\n      ItemStack torches = this.findAmmo(player, target);\n      if (!torches.isEmpty()) {\n        torches.shrink(1);\n        UtilItemStack.repairItem(stackToRepair);\n      }\n    }\n  }\n  public float getChargedPercent(ItemStack stack, int chargeTimer) {\n    return BowItem.getPowerForTime(this.getUseDuration(stack) - chargeTimer);\n  }\n  @Override\n  public boolean isBarVisible(ItemStack stack) {\n    if (hasEnergy) {\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      return storage != null; // && storage.getEnergyStored() > 0;\n    }\n    return super.isBarVisible(stack);\n  }\n  @Override\n  @OnlyIn(Dist.CLIENT)\n  public void appendHoverText(ItemStack stack, Level worldIn, List<Component> tooltip, TooltipFlag flagIn) {\n    tooltip.add(new TranslatableComponent(getDescriptionId() + \".tooltip\").withStyle(ChatFormatting.GRAY));\n    if (this.hasEnergy) {\n      int current = 0;\n      int energyttmax = 0;\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      if (storage != null) {\n        current = storage.getEnergyStored();\n        energyttmax = storage.getMaxEnergyStored();\n        tooltip.add(new TranslatableComponent(current + \"/\" + energyttmax).withStyle(ChatFormatting.RED));\n      }\n    }\n  }\n  @Override\n  public int getBarWidth(ItemStack stack) {\n    if (hasEnergy) {\n      float current = 0;\n      float max = 0;\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      if (storage != null) {\n        current = storage.getEnergyStored();\n        max = storage.getMaxEnergyStored();\n      }\n      return (max == 0) ? 0 : Math.round(13.0F * current / max);\n    }\n    return super.getBarWidth(stack);\n  }\n  @OnlyIn(Dist.CLIENT)\n  public void registerClient() {}\n  @Override\n  public ICapabilityProvider initCapabilities(ItemStack stack, CompoundTag nbt) {\n    if (this.hasEnergy) {\n      return new CapabilityProviderEnergyStack(16000);\n    }\n    return super.initCapabilities(stack, nbt);\n  }\n  // ShareTag for server->client capability data sync\n  @Override\n  public CompoundTag getShareTag(ItemStack stack) {\n    if (hasEnergy) {\n      CompoundTag nbt = stack.getOrCreateTag();\n      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);\n      //on server  this runs . also has correct values.\n      //set data for sync to client\n      if (storage != null) {\n        nbt.putInt(ENERGYTT, storage.getEnergyStored());\n        nbt.putInt(ENERGYTTMAX, storage.getMaxEnergyStored());\n      }\n      return nbt;\n    }\n    return super.getShareTag(stack);\n  }\n  //clientside read tt\n  @Override\n  public void readShareTag(ItemStack stack, CompoundTag nbt) {\n    if (hasEnergy && nbt != null) {\n      CompoundTag stackTag = stack.getOrCreateTag();\n      stackTag.putInt(ENERGYTT, nbt.getInt(ENERGYTT));\n      stackTag.putInt(ENERGYTTMAX, nbt.getInt(ENERGYTTMAX));\n    }\n    super.readShareTag(stack, nbt);\n  }\n"]], "pred": {"ppl": 1.784783124923706, "ppl_lower": 2.4428906440734863, "ppl/lowercase_ppl": -1.5418380697539422, "ppl/zlib": 0.00036992139796159835, "Min_5.0% Prob": 6.149376691556444, "Min_10.0% Prob": 4.395381288201201, "Min_20.0% Prob": 2.7098147442527845, "Min_30.0% Prob": 1.9002874878302118, "Min_40.0% Prob": 1.4406454549387353, "Min_50.0% Prob": 1.1576826387046748, "Min_60.0% Prob": 0.9662103728895634}}
{"hexsha": "3b3070aaeb72a56bbd5331b654fcaafaa9e4086f", "ext": "java", "lang": "Java", "content": "public class ObjectToSQLMapper extends SQLMapper implements IObjectToSQLMapper {\n\n\tpublic ObjectToSQLMapper(Connection connection, String packageName, String sourceVersion, String targetVersion) {\n\t\tsuper(connection, packageName, sourceVersion, targetVersion);\n\t}\n\n\t@Override\n\tpublic void newObject(String tableName) throws SpecmateException {\n\t\tString failmsg = \"Migration: Could not add table \" + tableName + \".\";\n\t\tList<String> queries = new ArrayList<>();\n\n\t\tqueries.add(\"CREATE TABLE \" + tableName + \"(\" + \"CDO_ID BIGINT NOT NULL, \" + \"CDO_VERSION INTEGER NOT NULL, \"\n\t\t\t\t+ \"CDO_CREATED BIGINT NOT NULL, \" + \"CDO_REVISED BIGINT NOT NULL, \" + \"CDO_RESOURCE BIGINT NOT NULL, \"\n\t\t\t\t+ \"CDO_CONTAINER BIGINT NOT NULL, \" + \"CDO_FEATURE INTEGER NOT NULL)\");\n\n\t\tqueries.add(\"CREATE UNIQUE INDEX \" + SQLUtil.createTimebasedIdentifier(\"PK\", H2ProviderConfig.MAX_ID_LENGTH)\n\t\t\t\t+ \" ON \" + tableName + \" (CDO_ID ASC, CDO_VERSION ASC)\");\n\n\t\tqueries.add(\"CREATE INDEX \" + SQLUtil.createTimebasedIdentifier(\"I\", H2ProviderConfig.MAX_ID_LENGTH) + \" ON \"\n\t\t\t\t+ tableName + \" (CDO_REVISED ASC)\");\n\n\t\tqueries.add(\"ALTER TABLE \" + tableName + \" ADD CONSTRAINT \"\n\t\t\t\t+ SQLUtil.createTimebasedIdentifier(\"C\", H2ProviderConfig.MAX_ID_LENGTH)\n\t\t\t\t+ \" PRIMARY KEY (CDO_ID, CDO_VERSION)\");\n\n\t\tqueries.add(insertExternalObjectReference(tableName));\n\t\tSQLUtil.executeStatements(queries, connection, failmsg);\n\t}\n}", "class_id": 0, "repo": "NeroZhangTianpeng/specmate", "file": "bundles/specmate-dbprovider-h2/src/specmate/dbprovider/h2/ObjectToSQLMapper.java", "last_update_at": "2018-12-13T13:58:13+00:00", "question_id": "3b3070aaeb72a56bbd5331b654fcaafaa9e4086f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ObjectToSQLMapper extends SQLMapper implements IObjectToSQLMapper {\n\tpublic ObjectToSQLMapper(Connection connection, String packageName, String sourceVersion, String targetVersion) {\n\t\tsuper(connection, packageName, sourceVersion, targetVersion);\n\t}\n\t@Override\n\tpublic void newObject(String tableName) throws SpecmateException {\n\t\tString failmsg = \"Migration: Could not add table \" + tableName + \".\";\n\t\tList<String> queries = new ArrayList<>();\n\t\tqueries.add(\"CREATE TABLE \" + tableName + \"(\" + \"CDO_ID BIGINT NOT NULL, \" + \"CDO_VERSION INTEGER NOT NULL, \"\n\t\t\t\t+ \"CDO_CREATED BIGINT NOT NULL, \" + \"CDO_REVISED BIGINT NOT NULL, \" + \"CDO_RESOURCE BIGINT NOT NULL, \"\n\t\t\t\t+ \"CDO_CONTAINER BIGINT NOT NULL, \" + \"CDO_FEATURE INTEGER NOT NULL)\");\n\t\tqueries.add(\"CREATE UNIQUE INDEX \" + SQLUtil.createTimebasedIdentifier(\"PK\", H2ProviderConfig.MAX_ID_LENGTH)\n\t\t\t\t+ \" ON \" + tableName + \" (CDO_ID ASC, CDO_VERSION ASC)\");\n\t\tqueries.add(\"CREATE INDEX \" + SQLUtil.createTimebasedIdentifier(\"I\", H2ProviderConfig.MAX_ID_LENGTH) + \" ON \"\n\t\t\t\t+ tableName + \" (CDO_REVISED ASC)\");\n\t\tqueries.add(\"ALTER TABLE \" + tableName + \" ADD CONSTRAINT \"\n\t\t\t\t+ SQLUtil.createTimebasedIdentifier(\"C\", H2ProviderConfig.MAX_ID_LENGTH)\n\t\t\t\t+ \" PRIMARY KEY (CDO_ID, CDO_VERSION)\");\n\t\tqueries.add(insertExternalObjectReference(tableName));\n\t\tSQLUtil.executeStatements(queries, connection, failmsg);\n\t}\n"]], "pred": {"ppl": 2.124393939971924, "ppl_lower": 2.481182098388672, "ppl/lowercase_ppl": -1.2060402282876044, "ppl/zlib": 0.0013479187065808316, "Min_5.0% Prob": 7.27731857697169, "Min_10.0% Prob": 5.343451355894406, "Min_20.0% Prob": 3.429331224411726, "Min_30.0% Prob": 2.4379370348206884, "Min_40.0% Prob": 1.8741413238289442, "Min_50.0% Prob": 1.5035219523085912, "Min_60.0% Prob": 1.2568478205401836}}
{"hexsha": "bbf24f4f98cb56512205ac6c13984c95a0538c30", "ext": "java", "lang": "Java", "content": "public class Advent041 {\n\n    public static void main(String[] args) throws Exception {\n        String input = new String(Files.readAllBytes(Paths.get(Advent040.class.getClassLoader().getResource(\"2016/input_4.txt\").toURI())));\n        Pattern sectorP = Pattern.compile(\"(\\\\d+)\");\n        String[] rows = input.split(\"\\n\");\n        System.out.println(\"a: \" + (int)'a');\n        System.out.println(\"z: \" + (int)'z');\n        System.out.println(\"A: \" + (int)'A');\n        System.out.println(\"Z: \" + (int)'Z');\n        System.out.println(\"-: \" + (int)'-');\n        System.out.println(\" : \" + (int)' ');\n        int A = 65, Z = 90, a = 97, z = 122;\n        int gapSize = a - Z - 1; // 6\n        int phantomEndIndex = z - gapSize;\n        int cycle = phantomEndIndex - A + 1;\n        // calculate index from 65 to 115 (phantom end) and then add gap size to result\n        Integer sectorId = null;\n        for (String row : rows) {\n            Matcher sectorM = sectorP.matcher(row);\n            sectorM.find();\n            Integer caesarShift = Integer.valueOf(sectorM.group());\n\n            String encoded = row.substring(0, row.indexOf(caesarShift+\"\"));\n            StringBuilder sb = new StringBuilder();\n            for (int code : encoded.toCharArray()) {\n                if (code == (int)'-') {\n                    code = 32;\n                } else {\n                    // normalize the gap between Z - a\n                    if (code > Z) {\n                        code = code - gapSize;\n                    }\n                    int left = caesarShift - cycle * (caesarShift / cycle);\n                    if ((code - A) + left >= cycle) {\n                        code = A + (left - (phantomEndIndex - code) - 1);\n                    } else {\n                        code = code + left;\n                    }\n                    // return the gap back\n                    if (code > Z) {\n                        code = code + gapSize;\n                    }\n                }\n//                System.out.print(code + \" \");\n                sb.append((char)code);\n            }\n            System.out.println(sb.toString());\n            if (sb.toString().toLowerCase().contains(\"northpole object\")) {\n                sectorId = caesarShift;\n            }\n        }\n        System.out.println(\"---\");\n        System.out.println(\"SectorId with North Pole objects: \" + sectorId);\n    }\n}", "class_id": 0, "repo": "velxeor/adventofcode", "file": "src/main/java/com/luckystar/advent2016/Advent041.java", "last_update_at": "2018-03-07T17:18:22+00:00", "question_id": "bbf24f4f98cb56512205ac6c13984c95a0538c30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Advent041 {\n    public static void main(String[] args) throws Exception {\n        String input = new String(Files.readAllBytes(Paths.get(Advent040.class.getClassLoader().getResource(\"2016/input_4.txt\").toURI())));\n        Pattern sectorP = Pattern.compile(\"(\\\\d+)\");\n        String[] rows = input.split(\"\\n\");\n        System.out.println(\"a: \" + (int)'a');\n        System.out.println(\"z: \" + (int)'z');\n        System.out.println(\"A: \" + (int)'A');\n        System.out.println(\"Z: \" + (int)'Z');\n        System.out.println(\"-: \" + (int)'-');\n        System.out.println(\" : \" + (int)' ');\n        int A = 65, Z = 90, a = 97, z = 122;\n        int gapSize = a - Z - 1; // 6\n        int phantomEndIndex = z - gapSize;\n        int cycle = phantomEndIndex - A + 1;\n        // calculate index from 65 to 115 (phantom end) and then add gap size to result\n        Integer sectorId = null;\n        for (String row : rows) {\n            Matcher sectorM = sectorP.matcher(row);\n            sectorM.find();\n            Integer caesarShift = Integer.valueOf(sectorM.group());\n            String encoded = row.substring(0, row.indexOf(caesarShift+\"\"));\n            StringBuilder sb = new StringBuilder();\n            for (int code : encoded.toCharArray()) {\n                if (code == (int)'-') {\n                    code = 32;\n                } else {\n                    // normalize the gap between Z - a\n                    if (code > Z) {\n                        code = code - gapSize;\n                    }\n                    int left = caesarShift - cycle * (caesarShift / cycle);\n                    if ((code - A) + left >= cycle) {\n                        code = A + (left - (phantomEndIndex - code) - 1);\n                    } else {\n                        code = code + left;\n                    }\n                    // return the gap back\n                    if (code > Z) {\n                        code = code + gapSize;\n                    }\n                }\n//                System.out.print(code + \" \");\n                sb.append((char)code);\n            }\n            System.out.println(sb.toString());\n            if (sb.toString().toLowerCase().contains(\"northpole object\")) {\n                sectorId = caesarShift;\n            }\n        }\n        System.out.println(\"---\");\n        System.out.println(\"SectorId with North Pole objects: \" + sectorId);\n    }\n"]], "pred": {"ppl": 2.4218955039978027, "ppl_lower": 3.0210695266723633, "ppl/lowercase_ppl": -1.2499127149696094, "ppl/zlib": 0.0010530363091554424, "Min_5.0% Prob": 7.064662759954279, "Min_10.0% Prob": 5.472621917724609, "Min_20.0% Prob": 3.735130892859565, "Min_30.0% Prob": 2.7859253541077718, "Min_40.0% Prob": 2.171093822574174, "Min_50.0% Prob": 1.758404682924938, "Min_60.0% Prob": 1.4737926852004029}}
{"hexsha": "3d65c8b08719fa1d075000c214e0e5ce5ba9d10f", "ext": "java", "lang": "Java", "content": "public class DefaultValidator implements Validator {\n  private final List<Rule> rules = new LinkedList<Rule>();\n  private final List<Tester> testers = new LinkedList<Tester>();\n\n  public DefaultValidator(List<Rule> rules, List<Tester> testers) {\n    this.rules.addAll(rules);\n    this.testers.addAll(testers);\n  }\n\n  public void validate(PojoClass pojoClass) {\n    ValidationHelper.runValidation(pojoClass, this.rules, this.testers);\n  }\n\n  public void validate(List<PojoClass> pojoClasses) {\n    for (PojoClass pojoClass : pojoClasses)\n      validate(pojoClass);\n  }\n\n  public List<PojoClass> validate(String packageName, PojoClassFilter... filters) {\n    PojoClassFilter pojoClassFilter = new FilterChain(filters);\n    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClasses(packageName, pojoClassFilter);\n    validate(pojoClasses);\n    return pojoClasses;\n  }\n\n  public List<PojoClass> validateRecursively(String packageName, PojoClassFilter... filters) {\n    PojoClassFilter pojoClassFilter = new FilterChain(filters);\n    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClassesRecursively(packageName, pojoClassFilter);\n    validate(pojoClasses);\n    return pojoClasses;\n  }\n}", "class_id": 0, "repo": "max-norris/openpojo", "file": "src/main/java/com/openpojo/validation/impl/DefaultValidator.java", "last_update_at": "2018-03-07T12:35:41+00:00", "question_id": "3d65c8b08719fa1d075000c214e0e5ce5ba9d10f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultValidator implements Validator {\n  private final List<Rule> rules = new LinkedList<Rule>();\n  private final List<Tester> testers = new LinkedList<Tester>();\n  public DefaultValidator(List<Rule> rules, List<Tester> testers) {\n    this.rules.addAll(rules);\n    this.testers.addAll(testers);\n  }\n  public void validate(PojoClass pojoClass) {\n    ValidationHelper.runValidation(pojoClass, this.rules, this.testers);\n  }\n  public void validate(List<PojoClass> pojoClasses) {\n    for (PojoClass pojoClass : pojoClasses)\n      validate(pojoClass);\n  }\n  public List<PojoClass> validate(String packageName, PojoClassFilter... filters) {\n    PojoClassFilter pojoClassFilter = new FilterChain(filters);\n    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClasses(packageName, pojoClassFilter);\n    validate(pojoClasses);\n    return pojoClasses;\n  }\n  public List<PojoClass> validateRecursively(String packageName, PojoClassFilter... filters) {\n    PojoClassFilter pojoClassFilter = new FilterChain(filters);\n    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClassesRecursively(packageName, pojoClassFilter);\n    validate(pojoClasses);\n    return pojoClasses;\n  }\n"]], "pred": {"ppl": 1.5703670978546143, "ppl_lower": 1.7884933948516846, "ppl/lowercase_ppl": -1.2881929131550782, "ppl/zlib": 0.001331296201528249, "Min_5.0% Prob": 5.129707336425781, "Min_10.0% Prob": 3.5769190192222595, "Min_20.0% Prob": 2.15377268816034, "Min_30.0% Prob": 1.4913925257407956, "Min_40.0% Prob": 1.1291026978675898, "Min_50.0% Prob": 0.9011630395489091, "Min_60.0% Prob": 0.7524503602030417}}
{"hexsha": "1e85f5e16bc02c980256ff551a737acba3b1e565", "ext": "java", "lang": "Java", "content": "public class LocalizationManagerTest {\n  private Logger log;\n  private Logger cachedLogger;\n  private LocalizationManager localizationManager;\n  private ExecutorService executorService;\n\n  @Before\n  public void setup() {\n    log = mock( Logger.class );\n    cachedLogger = LocalizationManager.getLog();\n    localizationManager = new LocalizationManager();\n    executorService = mock( ExecutorService.class );\n  }\n\n  @After\n  public void teardown() {\n    LocalizationManager.setLog( cachedLogger );\n  }\n\n  @Test\n  public void testLocalizationManager() throws IOException, ParseException {\n    localizationManager.setExecutorService( executorService );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n\n    assertBundleNullCacheNullRegexp( Pattern.compile( \"messages\" ),\n      \"de\", \"DE\" );\n\n    localizationManager.bundleChanged( makeMockBundleNull( 1L, Bundle.ACTIVE ) );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"messages\", null );\n\n    localizationManager.setExecutorService( null );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"messages\", null );\n    localizationManager.bundleChanged( makeMockBundle( 1L, Bundle.ACTIVE, \"i18n/bundle/messages.properties\",\n      \"i18n/bundle/messages_fr.properties\", \"i18n/bundle/messages_de_DE.properties\" ) );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"de\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\" );\n    assertBundleKeyEquals( \"key_de_DE\", \"bundle/messages\", \"key\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\", \"DE\" );\n\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"de\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\" );\n    assertBundlePatternKeyEquals( \"key_de_DE\", Pattern.compile( \".*messages\" ), \"key\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\", \"DE\" );\n\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle2\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 2\", \"bundle/messages\", \"key2\", \"fr\" );\n\n    assertBundlePatternKeyEquals( \"key_fr_bundle2\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 2\", Pattern.compile( \".*messages\" ), \"key2\", \"fr\" );\n\n    //test bundle 2L stopping\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.RESOLVED, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n\n    localizationManager.bundleChanged( makeMockBundle( 3L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.3\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle3\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 3\", \"bundle/messages\", \"key3\", \"fr\" );\n\n    assertBundlePatternKeyEquals( \"key_fr_bundle3\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 3\", Pattern.compile( \".*messages\" ), \"key3\", \"fr\" );\n\n    localizationManager.bundleChanged( makeMockBundle( 4L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.4\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 3\", \"bundle/messages\", \"key3\", \"fr\" );\n\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 3\", Pattern.compile( \".*messages\" ), \"key3\", \"fr\" );\n\n    localizationManager.bundleChanged( makeMockBundle( 5L, Bundle.ACTIVE, \"fakepath\" ) );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"de\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\" );\n    assertBundleKeyEquals( \"key_de_DE\", \"bundle/messages\", \"key\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\", \"DE\" );\n\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"de\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\" );\n    assertBundlePatternKeyEquals( \"key_de_DE\", Pattern.compile( \".*messages\" ), \"key\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"\" );\n  }\n\n  @Test\n  public void testLocalosationManagerWrongCache()\n    throws IOException, ParseException, ExecutionException, InterruptedException {\n    localizationManager.setExecutorService( mockExecutorServiceWithCacheTrowingError() );\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleNullCacheNull(\"bundle/messages\", \"key\", \"fr\" );\n  }\n\n  private ExecutorService mockExecutorServiceWithCacheTrowingError() throws ExecutionException, InterruptedException {\n    Future<Map<String, OSGIResourceBundle>> mockF = mock( Future.class );\n    when( mockF.get() ).thenThrow( InterruptedException.class );\n    ExecutorService service = mock( ExecutorService.class );\n    when( service.submit( Matchers.any( Callable.class ) ) ).thenReturn( mockF );\n    return service;\n  }\n\n  private void assertBundleKeyEquals( String expected, String key, String valueKey,\n                                      String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings.length == 1 ) {\n      locale = new Locale( localeStrings[ 0 ] );\n    } else if ( localeStrings.length == 2 ) {\n      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n    } else {\n      throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n    }\n    assertEquals( expected, localizationManager.getResourceBundle( key, locale ).getString( valueKey ) );\n  }\n\n  private void assertBundlePatternKeyEquals( String expected, Pattern keyRegex, String valueKey,\n                                             String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings.length == 1 ) {\n      locale = new Locale( localeStrings[ 0 ] );\n    } else if ( localeStrings.length == 2 ) {\n      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n    } else {\n      throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n    }\n    assertEquals( expected,\n      localizationManager.getResourceBundles( keyRegex, locale ).get( 0 ).getString( valueKey ) );\n  }\n\n  private void assertBundleNullCacheNull( String key, String... localeStrings ) {\n    Locale locale = null;\n\n    if ( localeStrings != null ) {\n      if ( localeStrings.length == 1 ) {\n        locale = new Locale( localeStrings[ 0 ] );\n      } else if ( localeStrings.length == 2 ) {\n        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n      } else {\n        throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n      }\n    }\n    assertNull( localizationManager.getResourceBundle( key, locale ) );\n\n  }\n\n  private void assertBundleNullCacheNullRegexp( Pattern keyRegex, String... localeStrings ) {\n    Locale locale = null;\n\n    if ( localeStrings != null ) {\n      if ( localeStrings.length == 1 ) {\n        locale = new Locale( localeStrings[ 0 ] );\n      } else if ( localeStrings.length == 2 ) {\n        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n      } else {\n        throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n      }\n    }\n    assertNull( localizationManager.getResourceBundles( keyRegex, locale ) );\n\n  }\n\n  private Bundle makeMockBundle( Long bundleId, int bundleStatus, String... propertiesPaths ) {\n    Bundle bundle = mock( Bundle.class );\n    when( bundle.getState() ).thenReturn( bundleStatus );\n    when( bundle.getBundleId() ).thenReturn( bundleId );\n    List<URL> propertiesFiles = new ArrayList<URL>();\n    for ( String path : propertiesPaths ) {\n      propertiesFiles.add( getClass().getClassLoader().getResource( path ) );\n    }\n    when( bundle.findEntries( \"i18n\", \"*.properties*\", true ) )\n      .thenReturn( new Vector<URL>( propertiesFiles ).elements() );\n    return bundle;\n  }\n\n  private Bundle makeMockBundleNull( Long bundleId, int bundleStatus ) {\n    Bundle bundle = mock( Bundle.class );\n    when( bundle.getState() ).thenReturn( bundleStatus );\n    when( bundle.getBundleId() ).thenReturn( bundleId );\n    when( bundle.findEntries( \"i18n\", \"*.properties*\", true ) ).thenReturn( null );\n    return bundle;\n  }\n}", "class_id": 0, "repo": "pentaho-nbaker/pentaho-osgi-bundles", "file": "pentaho-i18n-bundle/src/test/java/org/pentaho/osgi/i18n/impl/LocalizationManagerTest.java", "last_update_at": "2018-05-29T12:21:02+00:00", "question_id": "1e85f5e16bc02c980256ff551a737acba3b1e565", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalizationManagerTest {\n  private Logger log;\n  private Logger cachedLogger;\n  private LocalizationManager localizationManager;\n  private ExecutorService executorService;\n  @Before\n  public void setup() {\n    log = mock( Logger.class );\n    cachedLogger = LocalizationManager.getLog();\n    localizationManager = new LocalizationManager();\n    executorService = mock( ExecutorService.class );\n  }\n  @After\n  public void teardown() {\n    LocalizationManager.setLog( cachedLogger );\n  }\n  @Test\n  public void testLocalizationManager() throws IOException, ParseException {\n    localizationManager.setExecutorService( executorService );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n    assertBundleNullCacheNullRegexp( Pattern.compile( \"messages\" ),\n      \"de\", \"DE\" );\n    localizationManager.bundleChanged( makeMockBundleNull( 1L, Bundle.ACTIVE ) );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"messages\", null );\n    localizationManager.setExecutorService( null );\n    assertBundleNullCacheNull( \"messages\", \"de\", \"DE\" );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"messages\", null );\n    localizationManager.bundleChanged( makeMockBundle( 1L, Bundle.ACTIVE, \"i18n/bundle/messages.properties\",\n      \"i18n/bundle/messages_fr.properties\", \"i18n/bundle/messages_de_DE.properties\" ) );\n    assertBundleNullCacheNull( null, \"de\", \"DE\" );\n    assertBundleNullCacheNull( \"\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"de\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\" );\n    assertBundleKeyEquals( \"key_de_DE\", \"bundle/messages\", \"key\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"de\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\" );\n    assertBundlePatternKeyEquals( \"key_de_DE\", Pattern.compile( \".*messages\" ), \"key\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\", \"DE\" );\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle2\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 2\", \"bundle/messages\", \"key2\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle2\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 2\", Pattern.compile( \".*messages\" ), \"key2\", \"fr\" );\n    //test bundle 2L stopping\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.RESOLVED, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleKeyEquals( \"key_fr\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    localizationManager.bundleChanged( makeMockBundle( 3L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.3\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle3\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 3\", \"bundle/messages\", \"key3\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle3\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 3\", Pattern.compile( \".*messages\" ), \"key3\", \"fr\" );\n    localizationManager.bundleChanged( makeMockBundle( 4L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.4\" ) );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key for priority 3\", \"bundle/messages\", \"key3\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key for priority 3\", Pattern.compile( \".*messages\" ), \"key3\", \"fr\" );\n    localizationManager.bundleChanged( makeMockBundle( 5L, Bundle.ACTIVE, \"fakepath\" ) );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"fakeLocale\" );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\" );\n    assertBundleKeyEquals( \"key_fr_bundle4\", \"bundle/messages\", \"key\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"fr\", \"FR\" );\n    assertBundleKeyEquals( \"key\", \"bundle/messages\", \"key\", \"de\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\" );\n    assertBundleKeyEquals( \"key_de_DE\", \"bundle/messages\", \"key\", \"de\", \"DE\" );\n    assertBundleKeyEquals( \"defaultKey\", \"bundle/messages\", \"defaultKey\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"fakeLocale\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\" );\n    assertBundlePatternKeyEquals( \"key_fr_bundle4\", Pattern.compile( \".*messages\" ), \"key\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"fr\", \"FR\" );\n    assertBundlePatternKeyEquals( \"key\", Pattern.compile( \".*messages\" ), \"key\", \"de\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\" );\n    assertBundlePatternKeyEquals( \"key_de_DE\", Pattern.compile( \".*messages\" ), \"key\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"de\", \"DE\" );\n    assertBundlePatternKeyEquals( \"defaultKey\", Pattern.compile( \".*messages\" ), \"defaultKey\", \"\" );\n  }\n  @Test\n  public void testLocalosationManagerWrongCache()\n    throws IOException, ParseException, ExecutionException, InterruptedException {\n    localizationManager.setExecutorService( mockExecutorServiceWithCacheTrowingError() );\n    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, \"i18n/bundle/messages_fr.properties.2\" ) );\n    assertBundleNullCacheNull(\"bundle/messages\", \"key\", \"fr\" );\n  }\n  private ExecutorService mockExecutorServiceWithCacheTrowingError() throws ExecutionException, InterruptedException {\n    Future<Map<String, OSGIResourceBundle>> mockF = mock( Future.class );\n    when( mockF.get() ).thenThrow( InterruptedException.class );\n    ExecutorService service = mock( ExecutorService.class );\n    when( service.submit( Matchers.any( Callable.class ) ) ).thenReturn( mockF );\n    return service;\n  }\n  private void assertBundleKeyEquals( String expected, String key, String valueKey,\n                                      String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings.length == 1 ) {\n      locale = new Locale( localeStrings[ 0 ] );\n    } else if ( localeStrings.length == 2 ) {\n      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n    } else {\n      throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n    }\n    assertEquals( expected, localizationManager.getResourceBundle( key, locale ).getString( valueKey ) );\n  }\n  private void assertBundlePatternKeyEquals( String expected, Pattern keyRegex, String valueKey,\n                                             String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings.length == 1 ) {\n      locale = new Locale( localeStrings[ 0 ] );\n    } else if ( localeStrings.length == 2 ) {\n      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n    } else {\n      throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n    }\n    assertEquals( expected,\n      localizationManager.getResourceBundles( keyRegex, locale ).get( 0 ).getString( valueKey ) );\n  }\n  private void assertBundleNullCacheNull( String key, String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings != null ) {\n      if ( localeStrings.length == 1 ) {\n        locale = new Locale( localeStrings[ 0 ] );\n      } else if ( localeStrings.length == 2 ) {\n        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n      } else {\n        throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n      }\n    }\n    assertNull( localizationManager.getResourceBundle( key, locale ) );\n  }\n  private void assertBundleNullCacheNullRegexp( Pattern keyRegex, String... localeStrings ) {\n    Locale locale = null;\n    if ( localeStrings != null ) {\n      if ( localeStrings.length == 1 ) {\n        locale = new Locale( localeStrings[ 0 ] );\n      } else if ( localeStrings.length == 2 ) {\n        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );\n      } else {\n        throw new RuntimeException( \"Expected either 1 or 2 locale strings\" );\n      }\n    }\n    assertNull( localizationManager.getResourceBundles( keyRegex, locale ) );\n  }\n  private Bundle makeMockBundle( Long bundleId, int bundleStatus, String... propertiesPaths ) {\n    Bundle bundle = mock( Bundle.class );\n    when( bundle.getState() ).thenReturn( bundleStatus );\n    when( bundle.getBundleId() ).thenReturn( bundleId );\n    List<URL> propertiesFiles = new ArrayList<URL>();\n    for ( String path : propertiesPaths ) {\n      propertiesFiles.add( getClass().getClassLoader().getResource( path ) );\n    }\n    when( bundle.findEntries( \"i18n\", \"*.properties*\", true ) )\n      .thenReturn( new Vector<URL>( propertiesFiles ).elements() );\n    return bundle;\n  }\n  private Bundle makeMockBundleNull( Long bundleId, int bundleStatus ) {\n    Bundle bundle = mock( Bundle.class );\n    when( bundle.getState() ).thenReturn( bundleStatus );\n    when( bundle.getBundleId() ).thenReturn( bundleId );\n    when( bundle.findEntries( \"i18n\", \"*.properties*\", true ) ).thenReturn( null );\n    return bundle;\n  }\n"]], "pred": {"ppl": 1.5666688680648804, "ppl_lower": 1.6780452728271484, "ppl/lowercase_ppl": -1.1529740819788252, "ppl/zlib": 0.000310478302347657, "Min_5.0% Prob": 5.617513759463441, "Min_10.0% Prob": 3.7438596837660847, "Min_20.0% Prob": 2.1585027950943685, "Min_30.0% Prob": 1.4819988469696708, "Min_40.0% Prob": 1.1182188870235001, "Min_50.0% Prob": 0.8973337132292353, "Min_60.0% Prob": 0.7487397425945508}}
{"hexsha": "21e6d1f68ec564073171918e84a7e46c57e46827", "ext": "java", "lang": "Java", "content": "public class LoginActivity extends AbstractDkqActivity {\n\n    @NonNull\n    static Intent createLaunchIntent( final Context context ) {\n        return new Intent( context, LoginActivity.class );\n    }\n\n    private TextInputLayout usernameContainer;\n    private TextInputEditText usernameField;\n    private TextInputLayout passwordContainer;\n    private TextInputEditText passwordField;\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n        usernameContainer = findViewById(R.id.usernameContainer);\n        usernameField = findViewById(R.id.usernameField);\n        usernameField.setOnFocusChangeListener((view, hasFocus) -> {\n            if( !hasFocus ) {\n                isRequired( usernameContainer );\n            }\n        });\n        passwordContainer = findViewById(R.id.passwordContainer);\n        passwordField = findViewById(R.id.passwordField);\n        passwordField.setOnFocusChangeListener((view, hasFocus) -> {\n            if( !hasFocus ) {\n                isRequired( passwordContainer );\n            }\n        });\n        passwordField.setOnEditorActionListener((v, actionId, event) -> {\n            if (actionId == EditorInfo.IME_ACTION_DONE) {\n                login(null);\n                return true;\n            }\n            return false;\n        });\n    }\n\n    public void login( @Nullable final View view ) {\n        isRequired( usernameContainer );\n        isRequired( passwordContainer );\n\n        final String username = usernameField.getText().toString();\n        final String password = passwordField.getText().toString();\n        if( TextUtils.equals( username,DkqConstants.Account.USERNAME) && TextUtils.equals( password,DkqConstants.Account.PASSWORD ) ) {\n            usernameContainer.setError( null );\n            passwordContainer.setError( null );\n            openMainActivity();\n        } else {\n            final String loginError = getString( R.string.error_login );\n            usernameContainer.setError( loginError );\n            passwordContainer.setError( loginError );\n        }\n    }\n\n    private void isRequired( final TextInputLayout input ) {\n        final EditText editText = input.getEditText();\n        if( editText == null ) {\n            // nothing to validate\n            return;\n        }\n\n        final String error = getString( R.string.error_required );\n        if( TextUtils.isEmpty( editText.getText().toString() ) ) {\n            input.setError( error );\n        } else if( TextUtils.equals( error, input.getError() ) ) {\n            input.setError( null );\n        }\n    }\n\n    private void openMainActivity() {\n        startActivity( MainActivity.createLaunchIntent( this ).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK) );\n        finish();\n    }\n\n    public void register( final View view) {\n        new AlertDialog.Builder( this )\n                .setMessage(R.string.no_registration_text)\n                .setPositiveButton(R.string.close_word, null)\n                .create()\n                .show();\n    }\n}", "class_id": 0, "repo": "felixWackernagel/dkq", "file": "app/src/main/java/de/wackernagel/dkq/ui/LoginActivity.java", "last_update_at": "2018-06-30T07:55:15+00:00", "question_id": "21e6d1f68ec564073171918e84a7e46c57e46827", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoginActivity extends AbstractDkqActivity {\n    @NonNull\n    static Intent createLaunchIntent( final Context context ) {\n        return new Intent( context, LoginActivity.class );\n    }\n    private TextInputLayout usernameContainer;\n    private TextInputEditText usernameField;\n    private TextInputLayout passwordContainer;\n    private TextInputEditText passwordField;\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n        usernameContainer = findViewById(R.id.usernameContainer);\n        usernameField = findViewById(R.id.usernameField);\n        usernameField.setOnFocusChangeListener((view, hasFocus) -> {\n            if( !hasFocus ) {\n                isRequired( usernameContainer );\n            }\n        });\n        passwordContainer = findViewById(R.id.passwordContainer);\n        passwordField = findViewById(R.id.passwordField);\n        passwordField.setOnFocusChangeListener((view, hasFocus) -> {\n            if( !hasFocus ) {\n                isRequired( passwordContainer );\n            }\n        });\n        passwordField.setOnEditorActionListener((v, actionId, event) -> {\n            if (actionId == EditorInfo.IME_ACTION_DONE) {\n                login(null);\n                return true;\n            }\n            return false;\n        });\n    }\n    public void login( @Nullable final View view ) {\n        isRequired( usernameContainer );\n        isRequired( passwordContainer );\n        final String username = usernameField.getText().toString();\n        final String password = passwordField.getText().toString();\n        if( TextUtils.equals( username,DkqConstants.Account.USERNAME) && TextUtils.equals( password,DkqConstants.Account.PASSWORD ) ) {\n            usernameContainer.setError( null );\n            passwordContainer.setError( null );\n            openMainActivity();\n        } else {\n            final String loginError = getString( R.string.error_login );\n            usernameContainer.setError( loginError );\n            passwordContainer.setError( loginError );\n        }\n    }\n    private void isRequired( final TextInputLayout input ) {\n        final EditText editText = input.getEditText();\n        if( editText == null ) {\n            // nothing to validate\n            return;\n        }\n        final String error = getString( R.string.error_required );\n        if( TextUtils.isEmpty( editText.getText().toString() ) ) {\n            input.setError( error );\n        } else if( TextUtils.equals( error, input.getError() ) ) {\n            input.setError( null );\n        }\n    }\n    private void openMainActivity() {\n        startActivity( MainActivity.createLaunchIntent( this ).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK) );\n        finish();\n    }\n    public void register( final View view) {\n        new AlertDialog.Builder( this )\n                .setMessage(R.string.no_registration_text)\n                .setPositiveButton(R.string.close_word, null)\n                .create()\n                .show();\n    }\n"]], "pred": {"ppl": 1.602573275566101, "ppl_lower": 1.764917254447937, "ppl/lowercase_ppl": -1.2046034723035164, "ppl/zlib": 0.0005098493346481889, "Min_5.0% Prob": 5.277662785429704, "Min_10.0% Prob": 3.6335994491451666, "Min_20.0% Prob": 2.205030204034319, "Min_30.0% Prob": 1.547163246142552, "Min_40.0% Prob": 1.1740930123449442, "Min_50.0% Prob": 0.9414735314127437, "Min_60.0% Prob": 0.7865193927247678}}
{"hexsha": "9943ca665a00c0b2e14f0beb32dcbabf2653cdcd", "ext": "java", "lang": "Java", "content": "@Service\n@Transactional\npublic class WikidataItemService {\n    private static final String TYPE = \"item\";\n\n\n    public List<WikidataItem> searchWikidataItems(String keyword, String language)\n            throws MediaWikiApiErrorException {\n        WikibaseDataFetcher wbdf = WikibaseDataFetcher.getWikidataDataFetcher();\n\n        WbGetEntitiesSearchData criteria = new WbGetEntitiesSearchData();\n        criteria.type = TYPE;\n        criteria.search = keyword;\n        criteria.language = language;\n        List<WbSearchEntitiesResult> searchResults = wbdf.searchEntities(criteria);\n\n        List<WikidataItem> results = new ArrayList<>();\n        searchResults.stream().forEach(searchResult -> results\n                .add(new WikidataItem(searchResult.getTitle(), searchResult.getLabel(), searchResult.getDescription())));\n        return results;\n    }\n}", "class_id": 0, "repo": "SWE-574-Spring-2018/Spring2018Swe574", "file": "src/main/java/com/linkyway/service/WikidataItemService.java", "last_update_at": "2018-06-05T18:06:43+00:00", "question_id": "9943ca665a00c0b2e14f0beb32dcbabf2653cdcd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\n@Transactional\npublic class WikidataItemService {\n    private static final String TYPE = \"item\";\n    public List<WikidataItem> searchWikidataItems(String keyword, String language)\n            throws MediaWikiApiErrorException {\n        WikibaseDataFetcher wbdf = WikibaseDataFetcher.getWikidataDataFetcher();\n        WbGetEntitiesSearchData criteria = new WbGetEntitiesSearchData();\n        criteria.type = TYPE;\n        criteria.search = keyword;\n        criteria.language = language;\n        List<WbSearchEntitiesResult> searchResults = wbdf.searchEntities(criteria);\n        List<WikidataItem> results = new ArrayList<>();\n        searchResults.stream().forEach(searchResult -> results\n                .add(new WikidataItem(searchResult.getTitle(), searchResult.getLabel(), searchResult.getDescription())));\n        return results;\n    }\n"]], "pred": {"ppl": 2.357758045196533, "ppl_lower": 3.3045847415924072, "ppl/lowercase_ppl": -1.3936052583621612, "ppl/zlib": 0.00229949379804506, "Min_5.0% Prob": 6.457911057905718, "Min_10.0% Prob": 5.02548209103671, "Min_20.0% Prob": 3.5925112194485136, "Min_30.0% Prob": 2.6499008063007805, "Min_40.0% Prob": 2.101258917980724, "Min_50.0% Prob": 1.705783393332916, "Min_60.0% Prob": 1.42618152723812}}
{"hexsha": "91f85df2b19ffc6280b29d7542f65f0cb9ff258b", "ext": "java", "lang": "Java", "content": "public class lesson1 extends Applet { // notice'lesson01', which is also the name of the file : lesson01.java\n SimpleUniverse simpleU; // this is the SimpleUniverse Class that is used for Java3D\n\t\n\tpublic lesson1 (){  // this constructor is sometimes needed, even when empty as in here    \n\t}    \n\n\tpublic void init() { \n\t// this function will be called by both applications and applets\n\t//this is usually the first function to write        \n\tsetLayout(new BorderLayout()); // standard Java code for BorderLayout\n\n\t// Canvas3D is where all the action will be taking place, don't worry, after adding it\n\t// to your layout, you don't have to touch it.    \t\n\tCanvas3D c = new Canvas3D(SimpleUniverse.getPreferredConfiguration()); \n\n\t// add Canvas3D to center of BorderLayout\n \tadd(\"Center\", c);    \n\n\tsimpleU= new SimpleUniverse(c); // setup the SimpleUniverse, attach the Canvas3D\n\n\t\n\t//This is very important, the SceneGraph (where all the action takes place) is created\n\t//by calling a function which here is called 'createSceneGraph'.\n\t//The function is not necessary, you can put all your code here, but it is a \n\t//standard in Java3D to create your SceneGraph contents in the function 'createSceneGraph'\n\n \tBranchGroup scene = createSceneGraph(); \n\n\t//set the ViewingPlatform (where the User is) to nominal, more on this in the next lesson\n     simpleU.getViewingPlatform().setNominalViewingTransform();\n\n\t// this will optimize your SceneGraph, not necessary, but it will allow your program to run faster.\n     scene.compile(); \n     simpleU.addBranchGraph(scene); //add your SceneGraph to the SimpleUniverse   \n }\n\n public BranchGroup createSceneGraph() {      \n\t//Here we will create a basic SceneGraph with a ColorCube object\n\n\t// This BranchGroup is the root of the SceneGraph, 'objRoot' is the name I use,\n\t// and it is typically the standard name for it, but can be named anything.\n\tBranchGroup objRoot = new BranchGroup(); \n\n\t// create a ColorCube object of size 0.5\n\tColorCube c = new ColorCube(0.5f);\n\t\n\t// add ColorCube to SceneGraph\n\tobjRoot.addChild(c);\n\n\t// return Scene Graph\n\treturn objRoot;\n\t}\n\n public void destroy() {\t// this function will allow Java3D to clean up upon quiting\n\tsimpleU.removeAllLocales();    \n }  \n\n public static void main(String[] args) {\n\t// if called as an application, a 500x500 window will be opened    \n     Frame frame = new MainFrame(new lesson1(), 500, 500);    \n }\n}", "class_id": 0, "repo": "ppdesai434/Interactive-3D-Experience", "file": "FinalDemo/src/tutorials/lesson1.java", "last_update_at": "2018-08-17T06:48:30+00:00", "question_id": "91f85df2b19ffc6280b29d7542f65f0cb9ff258b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class lesson1 extends Applet { // notice'lesson01', which is also the name of the file : lesson01.java\n SimpleUniverse simpleU; // this is the SimpleUniverse Class that is used for Java3D\n\t\n\tpublic lesson1 (){  // this constructor is sometimes needed, even when empty as in here    \n\t}    \n\tpublic void init() { \n\t// this function will be called by both applications and applets\n\t//this is usually the first function to write        \n\tsetLayout(new BorderLayout()); // standard Java code for BorderLayout\n\t// Canvas3D is where all the action will be taking place, don't worry, after adding it\n\t// to your layout, you don't have to touch it.    \t\n\tCanvas3D c = new Canvas3D(SimpleUniverse.getPreferredConfiguration()); \n\t// add Canvas3D to center of BorderLayout\n \tadd(\"Center\", c);    \n\tsimpleU= new SimpleUniverse(c); // setup the SimpleUniverse, attach the Canvas3D\n\t\n\t//This is very important, the SceneGraph (where all the action takes place) is created\n\t//by calling a function which here is called 'createSceneGraph'.\n\t//The function is not necessary, you can put all your code here, but it is a \n\t//standard in Java3D to create your SceneGraph contents in the function 'createSceneGraph'\n \tBranchGroup scene = createSceneGraph(); \n\t//set the ViewingPlatform (where the User is) to nominal, more on this in the next lesson\n     simpleU.getViewingPlatform().setNominalViewingTransform();\n\t// this will optimize your SceneGraph, not necessary, but it will allow your program to run faster.\n     scene.compile(); \n     simpleU.addBranchGraph(scene); //add your SceneGraph to the SimpleUniverse   \n }\n public BranchGroup createSceneGraph() {      \n\t//Here we will create a basic SceneGraph with a ColorCube object\n\t// This BranchGroup is the root of the SceneGraph, 'objRoot' is the name I use,\n\t// and it is typically the standard name for it, but can be named anything.\n\tBranchGroup objRoot = new BranchGroup(); \n\t// create a ColorCube object of size 0.5\n\tColorCube c = new ColorCube(0.5f);\n\t\n\t// add ColorCube to SceneGraph\n\tobjRoot.addChild(c);\n\t// return Scene Graph\n\treturn objRoot;\n\t}\n public void destroy() {\t// this function will allow Java3D to clean up upon quiting\n\tsimpleU.removeAllLocales();    \n }  \n public static void main(String[] args) {\n\t// if called as an application, a 500x500 window will be opened    \n     Frame frame = new MainFrame(new lesson1(), 500, 500);    \n }\n"]], "pred": {"ppl": 4.596735954284668, "ppl_lower": 5.265084743499756, "ppl/lowercase_ppl": -1.088996674991465, "ppl/zlib": 0.0014032626278490696, "Min_5.0% Prob": 8.296865436008998, "Min_10.0% Prob": 6.793734798968678, "Min_20.0% Prob": 5.159426580012684, "Min_30.0% Prob": 4.15358654583726, "Min_40.0% Prob": 3.4479570673223128, "Min_50.0% Prob": 2.90637311614862, "Min_60.0% Prob": 2.4990964930887536}}
{"hexsha": "7fe767735439be440673ed769e77c88f39c34a20", "ext": "java", "lang": "Java", "content": "@Mojo( name = \"unpack\", requiresDependencyResolution = ResolutionScope.TEST, inheritByDefault = false )\n@Deprecated\npublic class UnpackMojo\n    extends AbstractMojo\n{\n\n    /**\n     */\n    @Component\n    private MavenProject project;\n\n    /**\n     */\n    @Component\n    private ArchiverManager archiverManager;\n\n    /**\n     * Directory to unpack JARs into if needed\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/assembly/work\", required = true )\n    protected File workDirectory;\n\n    /**\n     * Unpacks the archive file.\n     *\n     * @throws MojoExecutionException\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        final Set<Artifact> dependencies = new LinkedHashSet<Artifact>();\n\n        if ( project.getArtifact() != null && project.getArtifact().getFile() != null )\n        {\n            dependencies.add( project.getArtifact() );\n        }\n\n        @SuppressWarnings( \"unchecked\" )\n        final Set<Artifact> projectArtifacts = project.getArtifacts();\n        if ( projectArtifacts != null )\n        {\n            dependencies.addAll( projectArtifacts );\n        }\n\n        for (final Artifact artifact : dependencies) {\n            final String name = artifact.getFile().getName();\n\n            final File tempLocation = new File(workDirectory, name.substring(0, name.lastIndexOf('.')));\n            boolean process = false;\n            if (!tempLocation.exists()) {\n                tempLocation.mkdirs();\n                process = true;\n            } else if (artifact.getFile().lastModified() > tempLocation.lastModified()) {\n                process = true;\n            }\n\n            if (process) {\n                final File file = artifact.getFile();\n                try {\n                    AssemblyFileUtils.unpack(file, tempLocation, archiverManager);\n                } catch (final NoSuchArchiverException e) {\n                    getLog().info(\"Skip unpacking dependency file with unknown extension: \" + file.getPath());\n                } catch (final ArchiveExpansionException e) {\n                    throw new MojoExecutionException(\"Error unpacking dependency file: \" + file, e);\n                }\n            }\n        }\n    }\n\n}", "class_id": 0, "repo": "epabst/maven-plugins", "file": "maven-assembly-plugin/src/main/java/org/apache/maven/plugin/assembly/mojos/UnpackMojo.java", "last_update_at": "2018-06-06T13:56:44+00:00", "question_id": "7fe767735439be440673ed769e77c88f39c34a20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Mojo( name = \"unpack\", requiresDependencyResolution = ResolutionScope.TEST, inheritByDefault = false )\n@Deprecated\npublic class UnpackMojo\n    extends AbstractMojo\n{\n    /**\n     */\n    @Component\n    private MavenProject project;\n    /**\n     */\n    @Component\n    private ArchiverManager archiverManager;\n    /**\n     * Directory to unpack JARs into if needed\n     */\n    @Parameter( defaultValue = \"${project.build.directory}/assembly/work\", required = true )\n    protected File workDirectory;\n    /**\n     * Unpacks the archive file.\n     *\n     * @throws MojoExecutionException\n     */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        final Set<Artifact> dependencies = new LinkedHashSet<Artifact>();\n        if ( project.getArtifact() != null && project.getArtifact().getFile() != null )\n        {\n            dependencies.add( project.getArtifact() );\n        }\n        @SuppressWarnings( \"unchecked\" )\n        final Set<Artifact> projectArtifacts = project.getArtifacts();\n        if ( projectArtifacts != null )\n        {\n            dependencies.addAll( projectArtifacts );\n        }\n        for (final Artifact artifact : dependencies) {\n            final String name = artifact.getFile().getName();\n            final File tempLocation = new File(workDirectory, name.substring(0, name.lastIndexOf('.')));\n            boolean process = false;\n            if (!tempLocation.exists()) {\n                tempLocation.mkdirs();\n                process = true;\n            } else if (artifact.getFile().lastModified() > tempLocation.lastModified()) {\n                process = true;\n            }\n            if (process) {\n                final File file = artifact.getFile();\n                try {\n                    AssemblyFileUtils.unpack(file, tempLocation, archiverManager);\n                } catch (final NoSuchArchiverException e) {\n                    getLog().info(\"Skip unpacking dependency file with unknown extension: \" + file.getPath());\n                } catch (final ArchiveExpansionException e) {\n                    throw new MojoExecutionException(\"Error unpacking dependency file: \" + file, e);\n                }\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.7715257406234741, "ppl_lower": 2.3774361610412598, "ppl/lowercase_ppl": -1.514446144643576, "ppl/zlib": 0.0007051062584821739, "Min_5.0% Prob": 5.504658733095441, "Min_10.0% Prob": 4.054731756448746, "Min_20.0% Prob": 2.576364905433317, "Min_30.0% Prob": 1.8453722912599058, "Min_40.0% Prob": 1.416296238416092, "Min_50.0% Prob": 1.1404426329060864, "Min_60.0% Prob": 0.9544535928351038}}
{"hexsha": "272d4fe4c1ada43e98084850e2683d0a9b2b6540", "ext": "java", "lang": "Java", "content": "public class SethomeCommand extends Executor{\n\t\n\tprivate static final FileConfiguration cfg = Main.getInstance().getConfig();\n\n\tpublic SethomeCommand() {\n\t\tsuper(cfg.getString(\"commands.sethome.name\"), \n\t\t\t\tcfg.getString(\"commands.sethome.description\"), \n\t\t\t\tcfg.getString(\"commands.sethome.usage\"), \"sethome\", \n\t\t\t\tcfg.getStringList(\"commands.sethome.aliases\"), true);\n\t\t\n\t}\n\n\t@Override\n\tpublic void onExecute(CommandSender sender, String[] args) {\n\t\tPlayer p = (Player)sender;\n\t\tUser u = User.get(p);\n\t\tif(!u.hasGuild()){\n\t\t\tUtil.sendMessage(p, Messages.PlayerDontHasGuild);\n\t\t\treturn;\n\t\t}\n\t\tGuild g = u.getGuild();\n\t\tRegion r = RegionManager.inWhich(p.getLocation());\n\t\tif(!(r == g.getRegion())) {\n\t\t\tUtil.sendMessage(p, Messages.PlayerMustBeInGuild);\n\t\t\treturn;\n\t\t}\n\t\tLocation loc = p.getLocation();\n\t\tg.setHome(loc);\n\t\tg.save();\n\t\tDataManager.reload(false, false);\n\t\tUtil.sendMessage(p, Messages.SethomeSuccess);\n\t\treturn;\n\t}\n\n}", "class_id": 0, "repo": "tpacce/qGuilds", "file": "src/java/pl/za/xvacuum/guilds/commands/user/SethomeCommand.java", "last_update_at": "2018-08-14T09:31:05+00:00", "question_id": "272d4fe4c1ada43e98084850e2683d0a9b2b6540", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SethomeCommand extends Executor{\n\t\n\tprivate static final FileConfiguration cfg = Main.getInstance().getConfig();\n\tpublic SethomeCommand() {\n\t\tsuper(cfg.getString(\"commands.sethome.name\"), \n\t\t\t\tcfg.getString(\"commands.sethome.description\"), \n\t\t\t\tcfg.getString(\"commands.sethome.usage\"), \"sethome\", \n\t\t\t\tcfg.getStringList(\"commands.sethome.aliases\"), true);\n\t\t\n\t}\n\t@Override\n\tpublic void onExecute(CommandSender sender, String[] args) {\n\t\tPlayer p = (Player)sender;\n\t\tUser u = User.get(p);\n\t\tif(!u.hasGuild()){\n\t\t\tUtil.sendMessage(p, Messages.PlayerDontHasGuild);\n\t\t\treturn;\n\t\t}\n\t\tGuild g = u.getGuild();\n\t\tRegion r = RegionManager.inWhich(p.getLocation());\n\t\tif(!(r == g.getRegion())) {\n\t\t\tUtil.sendMessage(p, Messages.PlayerMustBeInGuild);\n\t\t\treturn;\n\t\t}\n\t\tLocation loc = p.getLocation();\n\t\tg.setHome(loc);\n\t\tg.save();\n\t\tDataManager.reload(false, false);\n\t\tUtil.sendMessage(p, Messages.SethomeSuccess);\n\t\treturn;\n\t}\n"]], "pred": {"ppl": 1.9239107370376587, "ppl_lower": 2.48530650138855, "ppl/lowercase_ppl": -1.3912770535934067, "ppl/zlib": 0.0014939725038725722, "Min_5.0% Prob": 6.448792135014253, "Min_10.0% Prob": 4.633738504137312, "Min_20.0% Prob": 2.9749039915246023, "Min_30.0% Prob": 2.121604135938894, "Min_40.0% Prob": 1.6206800317639238, "Min_50.0% Prob": 1.3039798139069, "Min_60.0% Prob": 1.0929692864774891}}
{"hexsha": "5e808c8ac63aa4afc64c02c3a32d490251540631", "ext": "java", "lang": "Java", "content": "public class EntidadeUtilsTest {\n\t\n\t@Test\n\tpublic void deveValidarEntidadeOuCodigoNulos() {\n\t\tassertTrue(EntidadeUtils.isNull(null));\n\t\tassertTrue(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(null)));\n\t\tassertFalse(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(1L)));\n\t}\n\t\n\t@Test\n\tpublic void deveValidarEntidadeOuCodigoNaoNulos() {\n\t\tassertFalse(EntidadeUtils.isNotNull(null));\n\t\tassertFalse(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(null)));\n\t\tassertTrue(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(1L)));\n\t}\n\t\n\tprivate class EntidadeUtilsTestEntidade implements Entidade {\n\t\t\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t\n\t\tprivate Long id;\n\t\t\n\t\tpublic EntidadeUtilsTestEntidade(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t}\n\t\n}", "class_id": 0, "repo": "luiznazari/senior-pdv", "file": "src/test/java/desafio/senior/pdv/utils/EntidadeUtilsTest.java", "last_update_at": "2018-09-14T18:29:06+00:00", "question_id": "5e808c8ac63aa4afc64c02c3a32d490251540631", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EntidadeUtilsTest {\n\t\n\t@Test\n\tpublic void deveValidarEntidadeOuCodigoNulos() {\n\t\tassertTrue(EntidadeUtils.isNull(null));\n\t\tassertTrue(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(null)));\n\t\tassertFalse(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(1L)));\n\t}\n\t\n\t@Test\n\tpublic void deveValidarEntidadeOuCodigoNaoNulos() {\n\t\tassertFalse(EntidadeUtils.isNotNull(null));\n\t\tassertFalse(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(null)));\n\t\tassertTrue(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(1L)));\n\t}\n\t\n\tprivate class EntidadeUtilsTestEntidade implements Entidade {\n\t\t\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t\n\t\tprivate Long id;\n\t\t\n\t\tpublic EntidadeUtilsTestEntidade(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\t\n\t}\n\t\n"]], "pred": {"ppl": 1.3963626623153687, "ppl_lower": 1.6296452283859253, "ppl/lowercase_ppl": -1.4627287028470866, "ppl/zlib": 0.0012053095933584976, "Min_5.0% Prob": 4.63122396171093, "Min_10.0% Prob": 2.913630783557892, "Min_20.0% Prob": 1.6164507572330646, "Min_30.0% Prob": 1.1076023196524913, "Min_40.0% Prob": 0.8335994552751934, "Min_50.0% Prob": 0.6670157663612324, "Min_60.0% Prob": 0.5584095422176202}}
{"hexsha": "2ddc4a07970d8ff4ae630f5a409afd82f94739ac", "ext": "java", "lang": "Java", "content": "public  final class DeviceCredentials extends\n    com.google.protobuf.GeneratedMessageV3 implements\n    // @@protoc_insertion_point(message_implements:opencannabis.device.DeviceCredentials)\n    DeviceCredentialsOrBuilder {\nprivate static final long serialVersionUID = 0L;\n  // Use DeviceCredentials.newBuilder() to construct.\n  private DeviceCredentials(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n    super(builder);\n  }\n  private DeviceCredentials() {\n    publicKey_ = com.google.protobuf.ByteString.EMPTY;\n    privateKey_ = com.google.protobuf.ByteString.EMPTY;\n    sha256_ = \"\";\n    identity_ = \"\";\n    authorities_ = java.util.Collections.emptyList();\n  }\n\n  @java.lang.Override\n  public final com.google.protobuf.UnknownFieldSet\n  getUnknownFields() {\n    return this.unknownFields;\n  }\n  private DeviceCredentials(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    this();\n    if (extensionRegistry == null) {\n      throw new java.lang.NullPointerException();\n    }\n    int mutable_bitField0_ = 0;\n    com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n        com.google.protobuf.UnknownFieldSet.newBuilder();\n    try {\n      boolean done = false;\n      while (!done) {\n        int tag = input.readTag();\n        switch (tag) {\n          case 0:\n            done = true;\n            break;\n          case 10: {\n\n            publicKey_ = input.readBytes();\n            break;\n          }\n          case 18: {\n\n            privateKey_ = input.readBytes();\n            break;\n          }\n          case 26: {\n            java.lang.String s = input.readStringRequireUtf8();\n\n            sha256_ = s;\n            break;\n          }\n          case 34: {\n            java.lang.String s = input.readStringRequireUtf8();\n\n            identity_ = s;\n            break;\n          }\n          case 42: {\n            if (!((mutable_bitField0_ & 0x00000010) != 0)) {\n              authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>();\n              mutable_bitField0_ |= 0x00000010;\n            }\n            authorities_.add(input.readBytes());\n            break;\n          }\n          default: {\n            if (!parseUnknownField(\n                input, unknownFields, extensionRegistry, tag)) {\n              done = true;\n            }\n            break;\n          }\n        }\n      }\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n      throw e.setUnfinishedMessage(this);\n    } catch (java.io.IOException e) {\n      throw new com.google.protobuf.InvalidProtocolBufferException(\n          e).setUnfinishedMessage(this);\n    } finally {\n      if (((mutable_bitField0_ & 0x00000010) != 0)) {\n        authorities_ = java.util.Collections.unmodifiableList(authorities_); // C\n      }\n      this.unknownFields = unknownFields.build();\n      makeExtensionsImmutable();\n    }\n  }\n  public static final com.google.protobuf.Descriptors.Descriptor\n      getDescriptor() {\n    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n  }\n\n  @java.lang.Override\n  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internalGetFieldAccessorTable() {\n    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable\n        .ensureFieldAccessorsInitialized(\n            io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);\n  }\n\n  private int bitField0_;\n  public static final int PUBLIC_KEY_FIELD_NUMBER = 1;\n  private com.google.protobuf.ByteString publicKey_;\n  /**\n   * <pre>\n   * Raw bytes for a device's public key.\n   * </pre>\n   *\n   * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getPublicKey() {\n    return publicKey_;\n  }\n\n  public static final int PRIVATE_KEY_FIELD_NUMBER = 2;\n  private com.google.protobuf.ByteString privateKey_;\n  /**\n   * <pre>\n   * Raw bytes for the device's private key.\n   * </pre>\n   *\n   * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getPrivateKey() {\n    return privateKey_;\n  }\n\n  public static final int SHA256_FIELD_NUMBER = 3;\n  private volatile java.lang.Object sha256_;\n  /**\n   * <pre>\n   * SHA256 hash of this device's public key.\n   * </pre>\n   *\n   * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n   */\n  public java.lang.String getSha256() {\n    java.lang.Object ref = sha256_;\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      sha256_ = s;\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * SHA256 hash of this device's public key.\n   * </pre>\n   *\n   * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n   */\n  public com.google.protobuf.ByteString\n      getSha256Bytes() {\n    java.lang.Object ref = sha256_;\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      sha256_ = b;\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n\n  public static final int IDENTITY_FIELD_NUMBER = 4;\n  private volatile java.lang.Object identity_;\n  /**\n   * <pre>\n   * A device's raw identity payload.\n   * </pre>\n   *\n   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public java.lang.String getIdentity() {\n    java.lang.Object ref = identity_;\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      identity_ = s;\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * A device's raw identity payload.\n   * </pre>\n   *\n   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString\n      getIdentityBytes() {\n    java.lang.Object ref = identity_;\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      identity_ = b;\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n\n  public static final int AUTHORITIES_FIELD_NUMBER = 5;\n  private java.util.List<com.google.protobuf.ByteString> authorities_;\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public java.util.List<com.google.protobuf.ByteString>\n      getAuthoritiesList() {\n    return authorities_;\n  }\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public int getAuthoritiesCount() {\n    return authorities_.size();\n  }\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getAuthorities(int index) {\n    return authorities_.get(index);\n  }\n\n  private byte memoizedIsInitialized = -1;\n  @java.lang.Override\n  public final boolean isInitialized() {\n    byte isInitialized = memoizedIsInitialized;\n    if (isInitialized == 1) return true;\n    if (isInitialized == 0) return false;\n\n    memoizedIsInitialized = 1;\n    return true;\n  }\n\n  @java.lang.Override\n  public void writeTo(com.google.protobuf.CodedOutputStream output)\n                      throws java.io.IOException {\n    if (!publicKey_.isEmpty()) {\n      output.writeBytes(1, publicKey_);\n    }\n    if (!privateKey_.isEmpty()) {\n      output.writeBytes(2, privateKey_);\n    }\n    if (!getSha256Bytes().isEmpty()) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sha256_);\n    }\n    if (!getIdentityBytes().isEmpty()) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, identity_);\n    }\n    for (int i = 0; i < authorities_.size(); i++) {\n      output.writeBytes(5, authorities_.get(i));\n    }\n    unknownFields.writeTo(output);\n  }\n\n  @java.lang.Override\n  public int getSerializedSize() {\n    int size = memoizedSize;\n    if (size != -1) return size;\n\n    size = 0;\n    if (!publicKey_.isEmpty()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(1, publicKey_);\n    }\n    if (!privateKey_.isEmpty()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(2, privateKey_);\n    }\n    if (!getSha256Bytes().isEmpty()) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sha256_);\n    }\n    if (!getIdentityBytes().isEmpty()) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, identity_);\n    }\n    {\n      int dataSize = 0;\n      for (int i = 0; i < authorities_.size(); i++) {\n        dataSize += com.google.protobuf.CodedOutputStream\n          .computeBytesSizeNoTag(authorities_.get(i));\n      }\n      size += dataSize;\n      size += 1 * getAuthoritiesList().size();\n    }\n    size += unknownFields.getSerializedSize();\n    memoizedSize = size;\n    return size;\n  }\n\n  @java.lang.Override\n  public boolean equals(final java.lang.Object obj) {\n    if (obj == this) {\n     return true;\n    }\n    if (!(obj instanceof io.opencannabis.schema.device.DeviceCredentials)) {\n      return super.equals(obj);\n    }\n    io.opencannabis.schema.device.DeviceCredentials other = (io.opencannabis.schema.device.DeviceCredentials) obj;\n\n    if (!getPublicKey()\n        .equals(other.getPublicKey())) return false;\n    if (!getPrivateKey()\n        .equals(other.getPrivateKey())) return false;\n    if (!getSha256()\n        .equals(other.getSha256())) return false;\n    if (!getIdentity()\n        .equals(other.getIdentity())) return false;\n    if (!getAuthoritiesList()\n        .equals(other.getAuthoritiesList())) return false;\n    if (!unknownFields.equals(other.unknownFields)) return false;\n    return true;\n  }\n\n  @java.lang.Override\n  public int hashCode() {\n    if (memoizedHashCode != 0) {\n      return memoizedHashCode;\n    }\n    int hash = 41;\n    hash = (19 * hash) + getDescriptor().hashCode();\n    hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;\n    hash = (53 * hash) + getPublicKey().hashCode();\n    hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;\n    hash = (53 * hash) + getPrivateKey().hashCode();\n    hash = (37 * hash) + SHA256_FIELD_NUMBER;\n    hash = (53 * hash) + getSha256().hashCode();\n    hash = (37 * hash) + IDENTITY_FIELD_NUMBER;\n    hash = (53 * hash) + getIdentity().hashCode();\n    if (getAuthoritiesCount() > 0) {\n      hash = (37 * hash) + AUTHORITIES_FIELD_NUMBER;\n      hash = (53 * hash) + getAuthoritiesList().hashCode();\n    }\n    hash = (29 * hash) + unknownFields.hashCode();\n    memoizedHashCode = hash;\n    return hash;\n  }\n\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.nio.ByteBuffer data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.nio.ByteBuffer data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.ByteString data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.ByteString data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(byte[] data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      byte[] data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.CodedInputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n\n  @java.lang.Override\n  public Builder newBuilderForType() { return newBuilder(); }\n  public static Builder newBuilder() {\n    return DEFAULT_INSTANCE.toBuilder();\n  }\n  public static Builder newBuilder(io.opencannabis.schema.device.DeviceCredentials prototype) {\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n  }\n  @java.lang.Override\n  public Builder toBuilder() {\n    return this == DEFAULT_INSTANCE\n        ? new Builder() : new Builder().mergeFrom(this);\n  }\n\n  @java.lang.Override\n  protected Builder newBuilderForType(\n      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n    Builder builder = new Builder(parent);\n    return builder;\n  }\n  /**\n   * <pre>\n   * Credentials that assert a device's identity or authorization.\n   * </pre>\n   *\n   * Protobuf type {@code opencannabis.device.DeviceCredentials}\n   */\n  public static final class Builder extends\n      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n      // @@protoc_insertion_point(builder_implements:opencannabis.device.DeviceCredentials)\n      io.opencannabis.schema.device.DeviceCredentialsOrBuilder {\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);\n    }\n\n    // Construct using io.opencannabis.schema.device.DeviceCredentials.newBuilder()\n    private Builder() {\n      maybeForceBuilderInitialization();\n    }\n\n    private Builder(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      super(parent);\n      maybeForceBuilderInitialization();\n    }\n    private void maybeForceBuilderInitialization() {\n      if (com.google.protobuf.GeneratedMessageV3\n              .alwaysUseFieldBuilders) {\n      }\n    }\n    @java.lang.Override\n    public Builder clear() {\n      super.clear();\n      publicKey_ = com.google.protobuf.ByteString.EMPTY;\n\n      privateKey_ = com.google.protobuf.ByteString.EMPTY;\n\n      sha256_ = \"\";\n\n      identity_ = \"\";\n\n      authorities_ = java.util.Collections.emptyList();\n      bitField0_ = (bitField0_ & ~0x00000010);\n      return this;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.Descriptor\n        getDescriptorForType() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {\n      return io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance();\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials build() {\n      io.opencannabis.schema.device.DeviceCredentials result = buildPartial();\n      if (!result.isInitialized()) {\n        throw newUninitializedMessageException(result);\n      }\n      return result;\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials buildPartial() {\n      io.opencannabis.schema.device.DeviceCredentials result = new io.opencannabis.schema.device.DeviceCredentials(this);\n      int from_bitField0_ = bitField0_;\n      int to_bitField0_ = 0;\n      result.publicKey_ = publicKey_;\n      result.privateKey_ = privateKey_;\n      result.sha256_ = sha256_;\n      result.identity_ = identity_;\n      if (((bitField0_ & 0x00000010) != 0)) {\n        authorities_ = java.util.Collections.unmodifiableList(authorities_);\n        bitField0_ = (bitField0_ & ~0x00000010);\n      }\n      result.authorities_ = authorities_;\n      result.bitField0_ = to_bitField0_;\n      onBuilt();\n      return result;\n    }\n\n    @java.lang.Override\n    public Builder clone() {\n      return super.clone();\n    }\n    @java.lang.Override\n    public Builder setField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.setField(field, value);\n    }\n    @java.lang.Override\n    public Builder clearField(\n        com.google.protobuf.Descriptors.FieldDescriptor field) {\n      return super.clearField(field);\n    }\n    @java.lang.Override\n    public Builder clearOneof(\n        com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n      return super.clearOneof(oneof);\n    }\n    @java.lang.Override\n    public Builder setRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        int index, java.lang.Object value) {\n      return super.setRepeatedField(field, index, value);\n    }\n    @java.lang.Override\n    public Builder addRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.addRepeatedField(field, value);\n    }\n    @java.lang.Override\n    public Builder mergeFrom(com.google.protobuf.Message other) {\n      if (other instanceof io.opencannabis.schema.device.DeviceCredentials) {\n        return mergeFrom((io.opencannabis.schema.device.DeviceCredentials)other);\n      } else {\n        super.mergeFrom(other);\n        return this;\n      }\n    }\n\n    public Builder mergeFrom(io.opencannabis.schema.device.DeviceCredentials other) {\n      if (other == io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance()) return this;\n      if (other.getPublicKey() != com.google.protobuf.ByteString.EMPTY) {\n        setPublicKey(other.getPublicKey());\n      }\n      if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {\n        setPrivateKey(other.getPrivateKey());\n      }\n      if (!other.getSha256().isEmpty()) {\n        sha256_ = other.sha256_;\n        onChanged();\n      }\n      if (!other.getIdentity().isEmpty()) {\n        identity_ = other.identity_;\n        onChanged();\n      }\n      if (!other.authorities_.isEmpty()) {\n        if (authorities_.isEmpty()) {\n          authorities_ = other.authorities_;\n          bitField0_ = (bitField0_ & ~0x00000010);\n        } else {\n          ensureAuthoritiesIsMutable();\n          authorities_.addAll(other.authorities_);\n        }\n        onChanged();\n      }\n      this.mergeUnknownFields(other.unknownFields);\n      onChanged();\n      return this;\n    }\n\n    @java.lang.Override\n    public final boolean isInitialized() {\n      return true;\n    }\n\n    @java.lang.Override\n    public Builder mergeFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      io.opencannabis.schema.device.DeviceCredentials parsedMessage = null;\n      try {\n        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        parsedMessage = (io.opencannabis.schema.device.DeviceCredentials) e.getUnfinishedMessage();\n        throw e.unwrapIOException();\n      } finally {\n        if (parsedMessage != null) {\n          mergeFrom(parsedMessage);\n        }\n      }\n      return this;\n    }\n    private int bitField0_;\n\n    private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getPublicKey() {\n      return publicKey_;\n    }\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setPublicKey(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  \n      publicKey_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearPublicKey() {\n      \n      publicKey_ = getDefaultInstance().getPublicKey();\n      onChanged();\n      return this;\n    }\n\n    private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getPrivateKey() {\n      return privateKey_;\n    }\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setPrivateKey(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  \n      privateKey_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearPrivateKey() {\n      \n      privateKey_ = getDefaultInstance().getPrivateKey();\n      onChanged();\n      return this;\n    }\n\n    private java.lang.Object sha256_ = \"\";\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public java.lang.String getSha256() {\n      java.lang.Object ref = sha256_;\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        sha256_ = s;\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public com.google.protobuf.ByteString\n        getSha256Bytes() {\n      java.lang.Object ref = sha256_;\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        sha256_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder setSha256(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  \n      sha256_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder clearSha256() {\n      \n      sha256_ = getDefaultInstance().getSha256();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder setSha256Bytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      \n      sha256_ = value;\n      onChanged();\n      return this;\n    }\n\n    private java.lang.Object identity_ = \"\";\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public java.lang.String getIdentity() {\n      java.lang.Object ref = identity_;\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        identity_ = s;\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString\n        getIdentityBytes() {\n      java.lang.Object ref = identity_;\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        identity_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setIdentity(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  \n      identity_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearIdentity() {\n      \n      identity_ = getDefaultInstance().getIdentity();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setIdentityBytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      \n      identity_ = value;\n      onChanged();\n      return this;\n    }\n\n    private java.util.List<com.google.protobuf.ByteString> authorities_ = java.util.Collections.emptyList();\n    private void ensureAuthoritiesIsMutable() {\n      if (!((bitField0_ & 0x00000010) != 0)) {\n        authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>(authorities_);\n        bitField0_ |= 0x00000010;\n       }\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public java.util.List<com.google.protobuf.ByteString>\n        getAuthoritiesList() {\n      return ((bitField0_ & 0x00000010) != 0) ?\n               java.util.Collections.unmodifiableList(authorities_) : authorities_;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public int getAuthoritiesCount() {\n      return authorities_.size();\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getAuthorities(int index) {\n      return authorities_.get(index);\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setAuthorities(\n        int index, com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureAuthoritiesIsMutable();\n      authorities_.set(index, value);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder addAuthorities(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureAuthoritiesIsMutable();\n      authorities_.add(value);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder addAllAuthorities(\n        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {\n      ensureAuthoritiesIsMutable();\n      com.google.protobuf.AbstractMessageLite.Builder.addAll(\n          values, authorities_);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearAuthorities() {\n      authorities_ = java.util.Collections.emptyList();\n      bitField0_ = (bitField0_ & ~0x00000010);\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final Builder setUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.setUnknownFields(unknownFields);\n    }\n\n    @java.lang.Override\n    public final Builder mergeUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.mergeUnknownFields(unknownFields);\n    }\n\n\n    // @@protoc_insertion_point(builder_scope:opencannabis.device.DeviceCredentials)\n  }\n\n  // @@protoc_insertion_point(class_scope:opencannabis.device.DeviceCredentials)\n  private static final io.opencannabis.schema.device.DeviceCredentials DEFAULT_INSTANCE;\n  static {\n    DEFAULT_INSTANCE = new io.opencannabis.schema.device.DeviceCredentials();\n  }\n\n  public static io.opencannabis.schema.device.DeviceCredentials getDefaultInstance() {\n    return DEFAULT_INSTANCE;\n  }\n\n  private static final com.google.protobuf.Parser<DeviceCredentials>\n      PARSER = new com.google.protobuf.AbstractParser<DeviceCredentials>() {\n    @java.lang.Override\n    public DeviceCredentials parsePartialFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return new DeviceCredentials(input, extensionRegistry);\n    }\n  };\n\n  public static com.google.protobuf.Parser<DeviceCredentials> parser() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public com.google.protobuf.Parser<DeviceCredentials> getParserForType() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {\n    return DEFAULT_INSTANCE;\n  }\n\n}", "class_id": 0, "repo": "Bloombox/Java", "file": "src/main/java/io/opencannabis/schema/device/DeviceCredentials.java", "last_update_at": "2018-05-26T05:29:46+00:00", "question_id": "2ddc4a07970d8ff4ae630f5a409afd82f94739ac", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public  final class DeviceCredentials extends\n    com.google.protobuf.GeneratedMessageV3 implements\n    // @@protoc_insertion_point(message_implements:opencannabis.device.DeviceCredentials)\n    DeviceCredentialsOrBuilder {\nprivate static final long serialVersionUID = 0L;\n  // Use DeviceCredentials.newBuilder() to construct.\n  private DeviceCredentials(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n    super(builder);\n  }\n  private DeviceCredentials() {\n    publicKey_ = com.google.protobuf.ByteString.EMPTY;\n    privateKey_ = com.google.protobuf.ByteString.EMPTY;\n    sha256_ = \"\";\n    identity_ = \"\";\n    authorities_ = java.util.Collections.emptyList();\n  }\n  @java.lang.Override\n  public final com.google.protobuf.UnknownFieldSet\n  getUnknownFields() {\n    return this.unknownFields;\n  }\n  private DeviceCredentials(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    this();\n    if (extensionRegistry == null) {\n      throw new java.lang.NullPointerException();\n    }\n    int mutable_bitField0_ = 0;\n    com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n        com.google.protobuf.UnknownFieldSet.newBuilder();\n    try {\n      boolean done = false;\n      while (!done) {\n        int tag = input.readTag();\n        switch (tag) {\n          case 0:\n            done = true;\n            break;\n          case 10: {\n            publicKey_ = input.readBytes();\n            break;\n          }\n          case 18: {\n            privateKey_ = input.readBytes();\n            break;\n          }\n          case 26: {\n            java.lang.String s = input.readStringRequireUtf8();\n            sha256_ = s;\n            break;\n          }\n          case 34: {\n            java.lang.String s = input.readStringRequireUtf8();\n            identity_ = s;\n            break;\n          }\n          case 42: {\n            if (!((mutable_bitField0_ & 0x00000010) != 0)) {\n              authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>();\n              mutable_bitField0_ |= 0x00000010;\n            }\n            authorities_.add(input.readBytes());\n            break;\n          }\n          default: {\n            if (!parseUnknownField(\n                input, unknownFields, extensionRegistry, tag)) {\n              done = true;\n            }\n            break;\n          }\n        }\n      }\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n      throw e.setUnfinishedMessage(this);\n    } catch (java.io.IOException e) {\n      throw new com.google.protobuf.InvalidProtocolBufferException(\n          e).setUnfinishedMessage(this);\n    } finally {\n      if (((mutable_bitField0_ & 0x00000010) != 0)) {\n        authorities_ = java.util.Collections.unmodifiableList(authorities_); // C\n      }\n      this.unknownFields = unknownFields.build();\n      makeExtensionsImmutable();\n    }\n  }\n  public static final com.google.protobuf.Descriptors.Descriptor\n      getDescriptor() {\n    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n  }\n  @java.lang.Override\n  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internalGetFieldAccessorTable() {\n    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable\n        .ensureFieldAccessorsInitialized(\n            io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);\n  }\n  private int bitField0_;\n  public static final int PUBLIC_KEY_FIELD_NUMBER = 1;\n  private com.google.protobuf.ByteString publicKey_;\n  /**\n   * <pre>\n   * Raw bytes for a device's public key.\n   * </pre>\n   *\n   * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getPublicKey() {\n    return publicKey_;\n  }\n  public static final int PRIVATE_KEY_FIELD_NUMBER = 2;\n  private com.google.protobuf.ByteString privateKey_;\n  /**\n   * <pre>\n   * Raw bytes for the device's private key.\n   * </pre>\n   *\n   * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getPrivateKey() {\n    return privateKey_;\n  }\n  public static final int SHA256_FIELD_NUMBER = 3;\n  private volatile java.lang.Object sha256_;\n  /**\n   * <pre>\n   * SHA256 hash of this device's public key.\n   * </pre>\n   *\n   * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n   */\n  public java.lang.String getSha256() {\n    java.lang.Object ref = sha256_;\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      sha256_ = s;\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * SHA256 hash of this device's public key.\n   * </pre>\n   *\n   * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n   */\n  public com.google.protobuf.ByteString\n      getSha256Bytes() {\n    java.lang.Object ref = sha256_;\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      sha256_ = b;\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n  public static final int IDENTITY_FIELD_NUMBER = 4;\n  private volatile java.lang.Object identity_;\n  /**\n   * <pre>\n   * A device's raw identity payload.\n   * </pre>\n   *\n   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public java.lang.String getIdentity() {\n    java.lang.Object ref = identity_;\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      identity_ = s;\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * A device's raw identity payload.\n   * </pre>\n   *\n   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString\n      getIdentityBytes() {\n    java.lang.Object ref = identity_;\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      identity_ = b;\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n  public static final int AUTHORITIES_FIELD_NUMBER = 5;\n  private java.util.List<com.google.protobuf.ByteString> authorities_;\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public java.util.List<com.google.protobuf.ByteString>\n      getAuthoritiesList() {\n    return authorities_;\n  }\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public int getAuthoritiesCount() {\n    return authorities_.size();\n  }\n  /**\n   * <pre>\n   * Repeated PEM authority payloads, asserted as trusted by the server.\n   * </pre>\n   *\n   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n   */\n  public com.google.protobuf.ByteString getAuthorities(int index) {\n    return authorities_.get(index);\n  }\n  private byte memoizedIsInitialized = -1;\n  @java.lang.Override\n  public final boolean isInitialized() {\n    byte isInitialized = memoizedIsInitialized;\n    if (isInitialized == 1) return true;\n    if (isInitialized == 0) return false;\n    memoizedIsInitialized = 1;\n    return true;\n  }\n  @java.lang.Override\n  public void writeTo(com.google.protobuf.CodedOutputStream output)\n                      throws java.io.IOException {\n    if (!publicKey_.isEmpty()) {\n      output.writeBytes(1, publicKey_);\n    }\n    if (!privateKey_.isEmpty()) {\n      output.writeBytes(2, privateKey_);\n    }\n    if (!getSha256Bytes().isEmpty()) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sha256_);\n    }\n    if (!getIdentityBytes().isEmpty()) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, identity_);\n    }\n    for (int i = 0; i < authorities_.size(); i++) {\n      output.writeBytes(5, authorities_.get(i));\n    }\n    unknownFields.writeTo(output);\n  }\n  @java.lang.Override\n  public int getSerializedSize() {\n    int size = memoizedSize;\n    if (size != -1) return size;\n    size = 0;\n    if (!publicKey_.isEmpty()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(1, publicKey_);\n    }\n    if (!privateKey_.isEmpty()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(2, privateKey_);\n    }\n    if (!getSha256Bytes().isEmpty()) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sha256_);\n    }\n    if (!getIdentityBytes().isEmpty()) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, identity_);\n    }\n    {\n      int dataSize = 0;\n      for (int i = 0; i < authorities_.size(); i++) {\n        dataSize += com.google.protobuf.CodedOutputStream\n          .computeBytesSizeNoTag(authorities_.get(i));\n      }\n      size += dataSize;\n      size += 1 * getAuthoritiesList().size();\n    }\n    size += unknownFields.getSerializedSize();\n    memoizedSize = size;\n    return size;\n  }\n  @java.lang.Override\n  public boolean equals(final java.lang.Object obj) {\n    if (obj == this) {\n     return true;\n    }\n    if (!(obj instanceof io.opencannabis.schema.device.DeviceCredentials)) {\n      return super.equals(obj);\n    }\n    io.opencannabis.schema.device.DeviceCredentials other = (io.opencannabis.schema.device.DeviceCredentials) obj;\n    if (!getPublicKey()\n        .equals(other.getPublicKey())) return false;\n    if (!getPrivateKey()\n        .equals(other.getPrivateKey())) return false;\n    if (!getSha256()\n        .equals(other.getSha256())) return false;\n    if (!getIdentity()\n        .equals(other.getIdentity())) return false;\n    if (!getAuthoritiesList()\n        .equals(other.getAuthoritiesList())) return false;\n    if (!unknownFields.equals(other.unknownFields)) return false;\n    return true;\n  }\n  @java.lang.Override\n  public int hashCode() {\n    if (memoizedHashCode != 0) {\n      return memoizedHashCode;\n    }\n    int hash = 41;\n    hash = (19 * hash) + getDescriptor().hashCode();\n    hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;\n    hash = (53 * hash) + getPublicKey().hashCode();\n    hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;\n    hash = (53 * hash) + getPrivateKey().hashCode();\n    hash = (37 * hash) + SHA256_FIELD_NUMBER;\n    hash = (53 * hash) + getSha256().hashCode();\n    hash = (37 * hash) + IDENTITY_FIELD_NUMBER;\n    hash = (53 * hash) + getIdentity().hashCode();\n    if (getAuthoritiesCount() > 0) {\n      hash = (37 * hash) + AUTHORITIES_FIELD_NUMBER;\n      hash = (53 * hash) + getAuthoritiesList().hashCode();\n    }\n    hash = (29 * hash) + unknownFields.hashCode();\n    memoizedHashCode = hash;\n    return hash;\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.nio.ByteBuffer data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.nio.ByteBuffer data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.ByteString data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.ByteString data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(byte[] data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      byte[] data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.CodedInputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  @java.lang.Override\n  public Builder newBuilderForType() { return newBuilder(); }\n  public static Builder newBuilder() {\n    return DEFAULT_INSTANCE.toBuilder();\n  }\n  public static Builder newBuilder(io.opencannabis.schema.device.DeviceCredentials prototype) {\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n  }\n  @java.lang.Override\n  public Builder toBuilder() {\n    return this == DEFAULT_INSTANCE\n        ? new Builder() : new Builder().mergeFrom(this);\n  }\n  @java.lang.Override\n  protected Builder newBuilderForType(\n      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n    Builder builder = new Builder(parent);\n    return builder;\n  }\n  /**\n   * <pre>\n   * Credentials that assert a device's identity or authorization.\n   * </pre>\n   *\n   * Protobuf type {@code opencannabis.device.DeviceCredentials}\n   */\n  public static final class Builder extends\n      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n      // @@protoc_insertion_point(builder_implements:opencannabis.device.DeviceCredentials)\n      io.opencannabis.schema.device.DeviceCredentialsOrBuilder {\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n    }\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);\n    }\n    // Construct using io.opencannabis.schema.device.DeviceCredentials.newBuilder()\n    private Builder() {\n      maybeForceBuilderInitialization();\n    }\n    private Builder(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      super(parent);\n      maybeForceBuilderInitialization();\n    }\n    private void maybeForceBuilderInitialization() {\n      if (com.google.protobuf.GeneratedMessageV3\n              .alwaysUseFieldBuilders) {\n      }\n    }\n    @java.lang.Override\n    public Builder clear() {\n      super.clear();\n      publicKey_ = com.google.protobuf.ByteString.EMPTY;\n      privateKey_ = com.google.protobuf.ByteString.EMPTY;\n      sha256_ = \"\";\n      identity_ = \"\";\n      authorities_ = java.util.Collections.emptyList();\n      bitField0_ = (bitField0_ & ~0x00000010);\n      return this;\n    }\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.Descriptor\n        getDescriptorForType() {\n      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {\n      return io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance();\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials build() {\n      io.opencannabis.schema.device.DeviceCredentials result = buildPartial();\n      if (!result.isInitialized()) {\n        throw newUninitializedMessageException(result);\n      }\n      return result;\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.device.DeviceCredentials buildPartial() {\n      io.opencannabis.schema.device.DeviceCredentials result = new io.opencannabis.schema.device.DeviceCredentials(this);\n      int from_bitField0_ = bitField0_;\n      int to_bitField0_ = 0;\n      result.publicKey_ = publicKey_;\n      result.privateKey_ = privateKey_;\n      result.sha256_ = sha256_;\n      result.identity_ = identity_;\n      if (((bitField0_ & 0x00000010) != 0)) {\n        authorities_ = java.util.Collections.unmodifiableList(authorities_);\n        bitField0_ = (bitField0_ & ~0x00000010);\n      }\n      result.authorities_ = authorities_;\n      result.bitField0_ = to_bitField0_;\n      onBuilt();\n      return result;\n    }\n    @java.lang.Override\n    public Builder clone() {\n      return super.clone();\n    }\n    @java.lang.Override\n    public Builder setField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.setField(field, value);\n    }\n    @java.lang.Override\n    public Builder clearField(\n        com.google.protobuf.Descriptors.FieldDescriptor field) {\n      return super.clearField(field);\n    }\n    @java.lang.Override\n    public Builder clearOneof(\n        com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n      return super.clearOneof(oneof);\n    }\n    @java.lang.Override\n    public Builder setRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        int index, java.lang.Object value) {\n      return super.setRepeatedField(field, index, value);\n    }\n    @java.lang.Override\n    public Builder addRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.addRepeatedField(field, value);\n    }\n    @java.lang.Override\n    public Builder mergeFrom(com.google.protobuf.Message other) {\n      if (other instanceof io.opencannabis.schema.device.DeviceCredentials) {\n        return mergeFrom((io.opencannabis.schema.device.DeviceCredentials)other);\n      } else {\n        super.mergeFrom(other);\n        return this;\n      }\n    }\n    public Builder mergeFrom(io.opencannabis.schema.device.DeviceCredentials other) {\n      if (other == io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance()) return this;\n      if (other.getPublicKey() != com.google.protobuf.ByteString.EMPTY) {\n        setPublicKey(other.getPublicKey());\n      }\n      if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {\n        setPrivateKey(other.getPrivateKey());\n      }\n      if (!other.getSha256().isEmpty()) {\n        sha256_ = other.sha256_;\n        onChanged();\n      }\n      if (!other.getIdentity().isEmpty()) {\n        identity_ = other.identity_;\n        onChanged();\n      }\n      if (!other.authorities_.isEmpty()) {\n        if (authorities_.isEmpty()) {\n          authorities_ = other.authorities_;\n          bitField0_ = (bitField0_ & ~0x00000010);\n        } else {\n          ensureAuthoritiesIsMutable();\n          authorities_.addAll(other.authorities_);\n        }\n        onChanged();\n      }\n      this.mergeUnknownFields(other.unknownFields);\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final boolean isInitialized() {\n      return true;\n    }\n    @java.lang.Override\n    public Builder mergeFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      io.opencannabis.schema.device.DeviceCredentials parsedMessage = null;\n      try {\n        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        parsedMessage = (io.opencannabis.schema.device.DeviceCredentials) e.getUnfinishedMessage();\n        throw e.unwrapIOException();\n      } finally {\n        if (parsedMessage != null) {\n          mergeFrom(parsedMessage);\n        }\n      }\n      return this;\n    }\n    private int bitField0_;\n    private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getPublicKey() {\n      return publicKey_;\n    }\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setPublicKey(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n      publicKey_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw bytes for a device's public key.\n     * </pre>\n     *\n     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearPublicKey() {\n      publicKey_ = getDefaultInstance().getPublicKey();\n      onChanged();\n      return this;\n    }\n    private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getPrivateKey() {\n      return privateKey_;\n    }\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setPrivateKey(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n      privateKey_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw bytes for the device's private key.\n     * </pre>\n     *\n     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearPrivateKey() {\n      privateKey_ = getDefaultInstance().getPrivateKey();\n      onChanged();\n      return this;\n    }\n    private java.lang.Object sha256_ = \"\";\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public java.lang.String getSha256() {\n      java.lang.Object ref = sha256_;\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        sha256_ = s;\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public com.google.protobuf.ByteString\n        getSha256Bytes() {\n      java.lang.Object ref = sha256_;\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        sha256_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder setSha256(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n      sha256_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder clearSha256() {\n      sha256_ = getDefaultInstance().getSha256();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * SHA256 hash of this device's public key.\n     * </pre>\n     *\n     * <code>string sha256 = 3 [(.gen_bq_schema.description) = \"SHA256 hash of this device&#92;'s public key.\"];</code>\n     */\n    public Builder setSha256Bytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      sha256_ = value;\n      onChanged();\n      return this;\n    }\n    private java.lang.Object identity_ = \"\";\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public java.lang.String getIdentity() {\n      java.lang.Object ref = identity_;\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        identity_ = s;\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString\n        getIdentityBytes() {\n      java.lang.Object ref = identity_;\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        identity_ = b;\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setIdentity(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n      identity_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearIdentity() {\n      identity_ = getDefaultInstance().getIdentity();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * A device's raw identity payload.\n     * </pre>\n     *\n     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setIdentityBytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      identity_ = value;\n      onChanged();\n      return this;\n    }\n    private java.util.List<com.google.protobuf.ByteString> authorities_ = java.util.Collections.emptyList();\n    private void ensureAuthoritiesIsMutable() {\n      if (!((bitField0_ & 0x00000010) != 0)) {\n        authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>(authorities_);\n        bitField0_ |= 0x00000010;\n       }\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public java.util.List<com.google.protobuf.ByteString>\n        getAuthoritiesList() {\n      return ((bitField0_ & 0x00000010) != 0) ?\n               java.util.Collections.unmodifiableList(authorities_) : authorities_;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public int getAuthoritiesCount() {\n      return authorities_.size();\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public com.google.protobuf.ByteString getAuthorities(int index) {\n      return authorities_.get(index);\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder setAuthorities(\n        int index, com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureAuthoritiesIsMutable();\n      authorities_.set(index, value);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder addAuthorities(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureAuthoritiesIsMutable();\n      authorities_.add(value);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder addAllAuthorities(\n        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {\n      ensureAuthoritiesIsMutable();\n      com.google.protobuf.AbstractMessageLite.Builder.addAll(\n          values, authorities_);\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Repeated PEM authority payloads, asserted as trusted by the server.\n     * </pre>\n     *\n     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>\n     */\n    public Builder clearAuthorities() {\n      authorities_ = java.util.Collections.emptyList();\n      bitField0_ = (bitField0_ & ~0x00000010);\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final Builder setUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.setUnknownFields(unknownFields);\n    }\n    @java.lang.Override\n    public final Builder mergeUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.mergeUnknownFields(unknownFields);\n    }\n    // @@protoc_insertion_point(builder_scope:opencannabis.device.DeviceCredentials)\n  }\n  // @@protoc_insertion_point(class_scope:opencannabis.device.DeviceCredentials)\n  private static final io.opencannabis.schema.device.DeviceCredentials DEFAULT_INSTANCE;\n  static {\n    DEFAULT_INSTANCE = new io.opencannabis.schema.device.DeviceCredentials();\n  }\n  public static io.opencannabis.schema.device.DeviceCredentials getDefaultInstance() {\n    return DEFAULT_INSTANCE;\n  }\n  private static final com.google.protobuf.Parser<DeviceCredentials>\n      PARSER = new com.google.protobuf.AbstractParser<DeviceCredentials>() {\n    @java.lang.Override\n    public DeviceCredentials parsePartialFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return new DeviceCredentials(input, extensionRegistry);\n    }\n  };\n  public static com.google.protobuf.Parser<DeviceCredentials> parser() {\n    return PARSER;\n  }\n  @java.lang.Override\n  public com.google.protobuf.Parser<DeviceCredentials> getParserForType() {\n    return PARSER;\n  }\n  @java.lang.Override\n  public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {\n    return DEFAULT_INSTANCE;\n  }\n"]], "pred": {"ppl": 1.098447561264038, "ppl_lower": 1.311692476272583, "ppl/lowercase_ppl": -2.8895038346440254, "ppl/zlib": 2.1565887696252955e-05, "Min_5.0% Prob": 1.874551043279615, "Min_10.0% Prob": 0.9416041718048327, "Min_20.0% Prob": 0.4708610051226845, "Min_30.0% Prob": 0.3139110450690296, "Min_40.0% Prob": 0.23485876861035446, "Min_50.0% Prob": 0.18797931638468895, "Min_60.0% Prob": 0.1567006703105975}}
{"hexsha": "5e98922bdd63d58191123ae7cb9c99005c2c15d1", "ext": "java", "lang": "Java", "content": "public class GFSlackDeviceInfoAttachment extends GFSlackAttachment implements Parcelable, Type {\n\n    public static final Creator<GFSlackDeviceInfoAttachment> CREATOR = new Creator<GFSlackDeviceInfoAttachment>() {\n        @Override\n        public GFSlackDeviceInfoAttachment createFromParcel(Parcel in) {\n            return new GFSlackDeviceInfoAttachment(in);\n        }\n\n        @Override\n        public GFSlackDeviceInfoAttachment[] newArray(int size) {\n            return new GFSlackDeviceInfoAttachment[size];\n        }\n    };\n\n    private String make;\n    private String model;\n    private String deviceResolution;\n    private String deviceDensity;\n    private String release;\n    private String api;\n\n    public GFSlackDeviceInfoAttachment() {\n        super();\n        init();\n    }\n\n    public GFSlackDeviceInfoAttachment(Builder builder) {\n        super(builder);\n        init();\n        make = builder.make;\n        model = builder.model;\n        deviceResolution = builder.deviceResolution;\n        deviceDensity = builder.deviceDensity;\n        release = builder.release;\n        api = builder.api;\n        setValues();\n    }\n\n    protected GFSlackDeviceInfoAttachment(Parcel in) {\n        super(in);\n        init();\n        make = in.readString();\n        model = in.readString();\n        deviceResolution = in.readString();\n        deviceDensity = in.readString();\n        release = in.readString();\n        api = in.readString();\n        setValues();\n    }\n\n    private void init() {\n        setTitle(\"Device Info\");\n        setColor(\"#03A9F4\");\n        getFields().get(0).setShort(false);\n    }\n\n    public String getMake() {\n        return make;\n    }\n\n    public void setMake(String make) {\n        this.make = make;\n        setValues();\n    }\n\n    public String getModel() {\n        return model;\n    }\n\n    public void setModel(String model) {\n        this.model = model;\n        setValues();\n    }\n\n    public String getDeviceResolution() {\n        return deviceResolution;\n    }\n\n    public void setDeviceResolution(String deviceResolution) {\n        this.deviceResolution = deviceResolution;\n        setValues();\n    }\n\n    public String getDeviceDensity() {\n        return deviceDensity;\n    }\n\n    public void setDeviceDensity(String deviceDensity) {\n        this.deviceDensity = deviceDensity;\n        setValues();\n    }\n\n    public String getRelease() {\n        return release;\n    }\n\n    public void setRelease(String release) {\n        this.release = release;\n        setValues();\n    }\n\n    public String getApi() {\n        return api;\n    }\n\n    public void setApi(String api) {\n        this.api = api;\n        setValues();\n    }\n\n    private void setValues() {\n        GFSlackAttachment.Builder builder = new GFSlackAttachment.Builder();\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Make: \");\n        sb.append(make);\n        sb.append(\"\\n\");\n        sb.append(\"Model: \");\n        sb.append(model);\n        sb.append(\"\\n\");\n\n        sb.append(\"Resolution: \");\n        sb.append(deviceResolution);\n        sb.append(\"\\n\");\n        sb.append(\"Density: \");\n        sb.append(deviceDensity);\n\n        sb.append(\"\\n\");\n        sb.append(\"Release: \");\n        sb.append(release);\n        sb.append(\"\\n\");\n        sb.append(\"Api: \");\n        sb.append(api);\n        setText(sb.toString());\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(make);\n        dest.writeString(model);\n        dest.writeString(deviceResolution);\n        dest.writeString(deviceDensity);\n        dest.writeString(release);\n        dest.writeString(api);\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    public static class SimpleBuilder extends Builder {\n\n        public SimpleBuilder(Context context) {\n            this(context.getResources().getDisplayMetrics());\n        }\n\n        public SimpleBuilder(Resources resources) {\n            this(resources.getDisplayMetrics());\n        }\n\n        public SimpleBuilder(DisplayMetrics displayMetrics) {\n            setMake(truncateAt(Build.MANUFACTURER, 20));\n            setModel(truncateAt(Build.MODEL, 20));\n\n            setDeviceResolution(displayMetrics.heightPixels + \"x\" + displayMetrics.widthPixels);\n            buildDensityString(displayMetrics);\n\n            setRelease(Build.VERSION.RELEASE);\n            setApi(String.valueOf(Build.VERSION.SDK_INT));\n        }\n\n        @Override\n        public SimpleBuilder setFallback(String fallback) {\n            super.setFallback(fallback);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setColor(String color) {\n            super.setColor(color);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setTitle(String title) {\n            super.setTitle(title);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setText(String text) {\n            super.setText(text);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setExtraTextFields(Map<String, String> extraTextFields) {\n            super.setExtraTextFields(extraTextFields);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setFooter(String footer) {\n            super.setFooter(footer);\n\n            return this;\n        }\n\n        @Override\n        public SimpleBuilder setFooterIcon(String footerIcon) {\n            super.setFooterIcon(footerIcon);\n\n            return this;\n        }\n\n        private String truncateAt(String string, int length) {\n            return string.length() > length ? string.substring(0, length) : string;\n        }\n\n        private void buildDensityString(DisplayMetrics displayMetrics) {\n            String density;\n            switch (displayMetrics.densityDpi) {\n                case DisplayMetrics.DENSITY_260:\n                case DisplayMetrics.DENSITY_280:\n                case DisplayMetrics.DENSITY_300:\n                    density = \"hdpi/xhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_340:\n                case DisplayMetrics.DENSITY_360:\n                case DisplayMetrics.DENSITY_400:\n                case DisplayMetrics.DENSITY_420:\n                    density = \"xhdpi/xxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_560:\n                    density = \"xxhdpi/xxxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_LOW:\n                    density = \"ldpi\";\n                    break;\n                case DisplayMetrics.DENSITY_MEDIUM:\n                    density = \"mdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_HIGH:\n                    density = \"hdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XHIGH:\n                    density = \"xhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XXHIGH:\n                    density = \"xxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XXXHIGH:\n                    density = \"xxxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_TV:\n                    density = \"tvdpi\";\n                    break;\n                default:\n                    density = \"unknown\";\n            }\n\n            setDeviceDensity(displayMetrics.densityDpi + \"dpi (\" + density + \")\");\n        }\n    }\n\n    public static class Builder extends GFSlackAttachment.Builder {\n\n        private String make;\n        private String model;\n        private String deviceResolution;\n        private String deviceDensity;\n        private String release;\n        private String api;\n\n        public Builder setMake(String make) {\n            this.make = make;\n\n            return this;\n        }\n\n        public Builder setModel(String model) {\n            this.model = model;\n\n            return this;\n        }\n\n        public Builder setDeviceResolution(String deviceResolution) {\n            this.deviceResolution = deviceResolution;\n\n            return this;\n        }\n\n        public Builder setDeviceDensity(String deviceDensity) {\n            this.deviceDensity = deviceDensity;\n\n            return this;\n        }\n\n        public Builder setRelease(String release) {\n            this.release = release;\n\n            return this;\n        }\n\n        public Builder setApi(String api) {\n            this.api = api;\n\n            return this;\n        }\n\n        @Override\n        public Builder setFallback(String fallback) {\n            super.setFallback(fallback);\n\n            return this;\n        }\n\n        @Override\n        public Builder setColor(String color) {\n            super.setColor(color);\n\n            return this;\n        }\n\n        @Override\n        public Builder setTitle(String title) {\n            super.setTitle(title);\n\n            return this;\n        }\n\n        @Override\n        public Builder setText(String text) {\n            super.setText(text);\n\n            return this;\n        }\n\n        @Override\n        public Builder setExtraTextFields(Map<String, String> extraTextFields) {\n            super.setExtraTextFields(extraTextFields);\n\n            return this;\n        }\n\n        @Override\n        public Builder setFooter(String footer) {\n            super.setFooter(footer);\n\n            return this;\n        }\n\n        @Override\n        public Builder setFooterIcon(String footerIcon) {\n            super.setFooterIcon(footerIcon);\n\n            return this;\n        }\n\n        @Override\n        public GFSlackDeviceInfoAttachment build() {\n            return new GFSlackDeviceInfoAttachment(this);\n        }\n    }\n}", "class_id": 0, "repo": "gfranks/GFSlackPoster", "file": "library/src/main/java/com/github/gfranks/slack/poster/model/GFSlackDeviceInfoAttachment.java", "last_update_at": "2018-01-08T02:56:57+00:00", "question_id": "5e98922bdd63d58191123ae7cb9c99005c2c15d1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GFSlackDeviceInfoAttachment extends GFSlackAttachment implements Parcelable, Type {\n    public static final Creator<GFSlackDeviceInfoAttachment> CREATOR = new Creator<GFSlackDeviceInfoAttachment>() {\n        @Override\n        public GFSlackDeviceInfoAttachment createFromParcel(Parcel in) {\n            return new GFSlackDeviceInfoAttachment(in);\n        }\n        @Override\n        public GFSlackDeviceInfoAttachment[] newArray(int size) {\n            return new GFSlackDeviceInfoAttachment[size];\n        }\n    };\n    private String make;\n    private String model;\n    private String deviceResolution;\n    private String deviceDensity;\n    private String release;\n    private String api;\n    public GFSlackDeviceInfoAttachment() {\n        super();\n        init();\n    }\n    public GFSlackDeviceInfoAttachment(Builder builder) {\n        super(builder);\n        init();\n        make = builder.make;\n        model = builder.model;\n        deviceResolution = builder.deviceResolution;\n        deviceDensity = builder.deviceDensity;\n        release = builder.release;\n        api = builder.api;\n        setValues();\n    }\n    protected GFSlackDeviceInfoAttachment(Parcel in) {\n        super(in);\n        init();\n        make = in.readString();\n        model = in.readString();\n        deviceResolution = in.readString();\n        deviceDensity = in.readString();\n        release = in.readString();\n        api = in.readString();\n        setValues();\n    }\n    private void init() {\n        setTitle(\"Device Info\");\n        setColor(\"#03A9F4\");\n        getFields().get(0).setShort(false);\n    }\n    public String getMake() {\n        return make;\n    }\n    public void setMake(String make) {\n        this.make = make;\n        setValues();\n    }\n    public String getModel() {\n        return model;\n    }\n    public void setModel(String model) {\n        this.model = model;\n        setValues();\n    }\n    public String getDeviceResolution() {\n        return deviceResolution;\n    }\n    public void setDeviceResolution(String deviceResolution) {\n        this.deviceResolution = deviceResolution;\n        setValues();\n    }\n    public String getDeviceDensity() {\n        return deviceDensity;\n    }\n    public void setDeviceDensity(String deviceDensity) {\n        this.deviceDensity = deviceDensity;\n        setValues();\n    }\n    public String getRelease() {\n        return release;\n    }\n    public void setRelease(String release) {\n        this.release = release;\n        setValues();\n    }\n    public String getApi() {\n        return api;\n    }\n    public void setApi(String api) {\n        this.api = api;\n        setValues();\n    }\n    private void setValues() {\n        GFSlackAttachment.Builder builder = new GFSlackAttachment.Builder();\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Make: \");\n        sb.append(make);\n        sb.append(\"\\n\");\n        sb.append(\"Model: \");\n        sb.append(model);\n        sb.append(\"\\n\");\n        sb.append(\"Resolution: \");\n        sb.append(deviceResolution);\n        sb.append(\"\\n\");\n        sb.append(\"Density: \");\n        sb.append(deviceDensity);\n        sb.append(\"\\n\");\n        sb.append(\"Release: \");\n        sb.append(release);\n        sb.append(\"\\n\");\n        sb.append(\"Api: \");\n        sb.append(api);\n        setText(sb.toString());\n    }\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(make);\n        dest.writeString(model);\n        dest.writeString(deviceResolution);\n        dest.writeString(deviceDensity);\n        dest.writeString(release);\n        dest.writeString(api);\n    }\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n    public static class SimpleBuilder extends Builder {\n        public SimpleBuilder(Context context) {\n            this(context.getResources().getDisplayMetrics());\n        }\n        public SimpleBuilder(Resources resources) {\n            this(resources.getDisplayMetrics());\n        }\n        public SimpleBuilder(DisplayMetrics displayMetrics) {\n            setMake(truncateAt(Build.MANUFACTURER, 20));\n            setModel(truncateAt(Build.MODEL, 20));\n            setDeviceResolution(displayMetrics.heightPixels + \"x\" + displayMetrics.widthPixels);\n            buildDensityString(displayMetrics);\n            setRelease(Build.VERSION.RELEASE);\n            setApi(String.valueOf(Build.VERSION.SDK_INT));\n        }\n        @Override\n        public SimpleBuilder setFallback(String fallback) {\n            super.setFallback(fallback);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setColor(String color) {\n            super.setColor(color);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setTitle(String title) {\n            super.setTitle(title);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setText(String text) {\n            super.setText(text);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setExtraTextFields(Map<String, String> extraTextFields) {\n            super.setExtraTextFields(extraTextFields);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setFooter(String footer) {\n            super.setFooter(footer);\n            return this;\n        }\n        @Override\n        public SimpleBuilder setFooterIcon(String footerIcon) {\n            super.setFooterIcon(footerIcon);\n            return this;\n        }\n        private String truncateAt(String string, int length) {\n            return string.length() > length ? string.substring(0, length) : string;\n        }\n        private void buildDensityString(DisplayMetrics displayMetrics) {\n            String density;\n            switch (displayMetrics.densityDpi) {\n                case DisplayMetrics.DENSITY_260:\n                case DisplayMetrics.DENSITY_280:\n                case DisplayMetrics.DENSITY_300:\n                    density = \"hdpi/xhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_340:\n                case DisplayMetrics.DENSITY_360:\n                case DisplayMetrics.DENSITY_400:\n                case DisplayMetrics.DENSITY_420:\n                    density = \"xhdpi/xxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_560:\n                    density = \"xxhdpi/xxxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_LOW:\n                    density = \"ldpi\";\n                    break;\n                case DisplayMetrics.DENSITY_MEDIUM:\n                    density = \"mdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_HIGH:\n                    density = \"hdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XHIGH:\n                    density = \"xhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XXHIGH:\n                    density = \"xxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_XXXHIGH:\n                    density = \"xxxhdpi\";\n                    break;\n                case DisplayMetrics.DENSITY_TV:\n                    density = \"tvdpi\";\n                    break;\n                default:\n                    density = \"unknown\";\n            }\n            setDeviceDensity(displayMetrics.densityDpi + \"dpi (\" + density + \")\");\n        }\n    }\n    public static class Builder extends GFSlackAttachment.Builder {\n        private String make;\n        private String model;\n        private String deviceResolution;\n        private String deviceDensity;\n        private String release;\n        private String api;\n        public Builder setMake(String make) {\n            this.make = make;\n            return this;\n        }\n        public Builder setModel(String model) {\n            this.model = model;\n            return this;\n        }\n        public Builder setDeviceResolution(String deviceResolution) {\n            this.deviceResolution = deviceResolution;\n            return this;\n        }\n        public Builder setDeviceDensity(String deviceDensity) {\n            this.deviceDensity = deviceDensity;\n            return this;\n        }\n        public Builder setRelease(String release) {\n            this.release = release;\n            return this;\n        }\n        public Builder setApi(String api) {\n            this.api = api;\n            return this;\n        }\n        @Override\n        public Builder setFallback(String fallback) {\n            super.setFallback(fallback);\n            return this;\n        }\n        @Override\n        public Builder setColor(String color) {\n            super.setColor(color);\n            return this;\n        }\n        @Override\n        public Builder setTitle(String title) {\n            super.setTitle(title);\n            return this;\n        }\n        @Override\n        public Builder setText(String text) {\n            super.setText(text);\n            return this;\n        }\n        @Override\n        public Builder setExtraTextFields(Map<String, String> extraTextFields) {\n            super.setExtraTextFields(extraTextFields);\n            return this;\n        }\n        @Override\n        public Builder setFooter(String footer) {\n            super.setFooter(footer);\n            return this;\n        }\n        @Override\n        public Builder setFooterIcon(String footerIcon) {\n            super.setFooterIcon(footerIcon);\n            return this;\n        }\n        @Override\n        public GFSlackDeviceInfoAttachment build() {\n            return new GFSlackDeviceInfoAttachment(this);\n        }\n    }\n"]], "pred": {"ppl": 1.3052154779434204, "ppl_lower": 1.405038595199585, "ppl/lowercase_ppl": -1.276672077815397, "ppl/zlib": 0.00016848079971052237, "Min_5.0% Prob": 4.300478533202527, "Min_10.0% Prob": 2.549352866761825, "Min_20.0% Prob": 1.329994649735882, "Min_30.0% Prob": 0.8894768458238675, "Min_40.0% Prob": 0.6659935203060385, "Min_50.0% Prob": 0.5331808405803241, "Min_60.0% Prob": 0.44450144099473665}}
{"hexsha": "8a0928ed87f81b4dc9e855ed048771059cbe1556", "ext": "java", "lang": "Java", "content": "public class ComentarioDetailDTO extends ComentarioDTO{\n    \n    private ClienteDTO cliente; \n    \n    private SucursalDTO sucursal;\n    \n    private List<FotoDTO> fotos;\n    \n    /**\n     * Constructor vac\u00edo, heredado para inicializaci\u00f3n de JaxRS\n     */\n    \n    public ComentarioDetailDTO(){     \n        super();\n    }\n       \n    /**\n     * Crea un objeto ComentarioDetailDTO a partir de un objeto ComentarioEntity\n     * incluyendo los atributos de ComentarioDTO.\n     *\n     * @param entity Entidad ComentarioEntity desde la cual se va a crear el nuevo\n     * objeto.\n     *\n     */\n    public ComentarioDetailDTO(ComentarioEntity entity) {\n        super(entity);\n        \n        if (entity != null) {\n            \n            cliente = new ClienteDTO(entity.getCliente());\n            \n            sucursal = new SucursalDTO(entity.getSucursal());\n            \n            fotos = new ArrayList<>();\n            for (FotoEntity entityFoto : entity.getFotos()) {\n                fotos.add(new FotoDTO(entityFoto));\n            }\n        }\n    }\n    \n     /**\n     * Convierte un objeto ComentarioDetailDTO a ComentarioEntity incluyendo los\n     * atributos de ComentarioDTO.\n     *\n     * @return Nueva objeto ComentarioEntity.\n     *\n     */\n    @Override\n    public ComentarioEntity toEntity() {\n        ComentarioEntity entity = super.toEntity();\n        \n        if (getCliente() != null) {            \n            entity.setCliente(getCliente().toEntity());\n        }\n        \n        if (getSucursal() != null) {            \n            entity.setSucursal(getSucursal().toEntity());\n        }\n        \n        if (getFotos() != null) {\n            List<FotoEntity> fotosEntity = new ArrayList<>();\n            for (FotoDTO dtoFoto : getFotos()) {\n                fotosEntity.add(dtoFoto.toEntity());\n            }\n            entity.setFotos(fotosEntity);\n        }\n        \n        return entity;\n    }\n\n    /**\n     * @return the cliente\n     */\n    public ClienteDTO getCliente() {\n        return cliente;\n    }\n\n    /**\n     * @param cliente the cliente to set\n     */\n    public void setCliente(ClienteDTO cliente) {\n        this.cliente = cliente;\n    }\n\n    /**\n     * @return the sucursal\n     */\n    public SucursalDTO getSucursal() {\n        return sucursal;\n    }\n\n    /**\n     * @param sucursal the sucursal to set\n     */\n    public void setSucursal(SucursalDTO sucursal) {\n        this.sucursal = sucursal;\n    }\n\n    /**\n     * @return the fotos\n     */\n    public List<FotoDTO> getFotos() {\n        return fotos;\n    }\n\n    /**\n     * @param fotos the fotos to set\n     */\n    public void setFotos(List<FotoDTO> fotos) {\n        this.fotos = fotos;\n    }\n    \n    \n}", "class_id": 0, "repo": "Uniandes-isis2603/s1_puntosfidelidad", "file": "puntosfidelidad-web/src/main/java/co/edu/uniandes/csw/puntosfidelidad/dtos/ComentarioDetailDTO.java", "last_update_at": "2018-08-06T16:07:51+00:00", "question_id": "8a0928ed87f81b4dc9e855ed048771059cbe1556", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ComentarioDetailDTO extends ComentarioDTO{\n    private ClienteDTO cliente; \n    private SucursalDTO sucursal;\n    private List<FotoDTO> fotos;\n    /**\n     * Constructor vac\u00edo, heredado para inicializaci\u00f3n de JaxRS\n     */\n    public ComentarioDetailDTO(){     \n        super();\n    }\n    /**\n     * Crea un objeto ComentarioDetailDTO a partir de un objeto ComentarioEntity\n     * incluyendo los atributos de ComentarioDTO.\n     *\n     * @param entity Entidad ComentarioEntity desde la cual se va a crear el nuevo\n     * objeto.\n     *\n     */\n    public ComentarioDetailDTO(ComentarioEntity entity) {\n        super(entity);\n        if (entity != null) {\n            cliente = new ClienteDTO(entity.getCliente());\n            sucursal = new SucursalDTO(entity.getSucursal());\n            fotos = new ArrayList<>();\n            for (FotoEntity entityFoto : entity.getFotos()) {\n                fotos.add(new FotoDTO(entityFoto));\n            }\n        }\n    }\n     /**\n     * Convierte un objeto ComentarioDetailDTO a ComentarioEntity incluyendo los\n     * atributos de ComentarioDTO.\n     *\n     * @return Nueva objeto ComentarioEntity.\n     *\n     */\n    @Override\n    public ComentarioEntity toEntity() {\n        ComentarioEntity entity = super.toEntity();\n        if (getCliente() != null) {            \n            entity.setCliente(getCliente().toEntity());\n        }\n        if (getSucursal() != null) {            \n            entity.setSucursal(getSucursal().toEntity());\n        }\n        if (getFotos() != null) {\n            List<FotoEntity> fotosEntity = new ArrayList<>();\n            for (FotoDTO dtoFoto : getFotos()) {\n                fotosEntity.add(dtoFoto.toEntity());\n            }\n            entity.setFotos(fotosEntity);\n        }\n        return entity;\n    }\n    /**\n     * @return the cliente\n     */\n    public ClienteDTO getCliente() {\n        return cliente;\n    }\n    /**\n     * @param cliente the cliente to set\n     */\n    public void setCliente(ClienteDTO cliente) {\n        this.cliente = cliente;\n    }\n    /**\n     * @return the sucursal\n     */\n    public SucursalDTO getSucursal() {\n        return sucursal;\n    }\n    /**\n     * @param sucursal the sucursal to set\n     */\n    public void setSucursal(SucursalDTO sucursal) {\n        this.sucursal = sucursal;\n    }\n    /**\n     * @return the fotos\n     */\n    public List<FotoDTO> getFotos() {\n        return fotos;\n    }\n    /**\n     * @param fotos the fotos to set\n     */\n    public void setFotos(List<FotoDTO> fotos) {\n        this.fotos = fotos;\n    }\n"]], "pred": {"ppl": 1.243337869644165, "ppl_lower": 1.396896243095398, "ppl/lowercase_ppl": -1.5346805792231402, "ppl/zlib": 0.00031383226727425075, "Min_5.0% Prob": 3.599535429761523, "Min_10.0% Prob": 2.027744014824138, "Min_20.0% Prob": 1.0697461620849722, "Min_30.0% Prob": 0.7226675558835268, "Min_40.0% Prob": 0.5441303817158126, "Min_50.0% Prob": 0.4358183487326674, "Min_60.0% Prob": 0.36333620074095535}}
{"hexsha": "bade8124eea566f93d411e155eb6253801699711", "ext": "java", "lang": "Java", "content": "class AndroidSupportProject implements Project {\n\n    static final String MARKER = \"AndroidSupport\";\n\n    AndroidSupportProject(SourceUnit unit) {\n    }\n\n    /**\n     * @return bootclasspath to compile Android base framework (should include libcore classes)\n     */\n    @Override\n    public List<String> getBootClassPath() {\n        return getLibraries(new String[]{\n                \"../../out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/classes.jar\",\n                \"sdk/android-sdk.jar\" // this entry is for testing purposes only, see sgtest/java-android-support-framework\n        });\n    }\n\n    /**\n     *\n     * @return classpath to use (include framework's output, junit)\n     */\n    @Override\n    public List<String> getClassPath() {\n        return getLibraries(new String[]{\n                \"../../out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar\"\n        });\n    }\n\n    /**\n     * @return source directories that contain files generated from .logtags and\n     * directories that contain R.java and Manifest.java\n     */\n    @Override\n    public List<String> getSourcePath() throws IOException {\n        List<String> sourcePath = new ArrayList<>();\n        // include java directories generated from .logtags and AIDL and the ones containing R.java\n        File intermediate = new File(\"../../out/target/common/obj/JAVA_LIBRARIES\");\n        if (intermediate.isDirectory()) {\n            Files.walkFileTree(intermediate.toPath(), new GeneratedDirectoriesCollector(sourcePath));\n        }\n        return sourcePath;\n    }\n\n    @Override\n    public RawDependency getDepForJAR(Path jarFile) throws Exception {\n        return null;\n    }\n\n    @Override\n    public String getSourceCodeVersion() throws Exception {\n        return DEFAULT_SOURCE_CODE_VERSION;\n    }\n\n    @Override\n    public String getSourceCodeEncoding() throws ModelBuildingException, IOException {\n        return null;\n    }\n\n    /**\n     * Creates source unit from a given directory\n     * @return source unit\n     * @throws IOException\n     */\n    static SourceUnit createSourceUnit() throws IOException {\n\n\n        final SourceUnit unit = new SourceUnit();\n        unit.Type = SourceUnit.DEFAULT_TYPE;\n        unit.Name = MARKER;\n        unit.Dir = \".\";\n        unit.Files = new ArrayList<>();\n        Files.walkFileTree(PathUtil.CWD, new SourceFilesCollector(unit.Files));\n        unit.Data.Type = MARKER;\n        return unit;\n    }\n\n    public static boolean is(SourceUnit unit) {\n        return MARKER.equals(unit.Data.Type);\n    }\n\n    /**\n     * @param files files to search for\n     * @return list of existing files resolved relative to current working directory\n     */\n    private List<String> getLibraries(String files[]) {\n        List<String> ret = Arrays.stream(files).filter(s -> new File(s).isFile()).collect(Collectors.toList());\n        return ret.isEmpty() ? null : ret;\n    }\n\n    /**\n     * Walks file tree and collects source directories which contain generated java files if there are any\n     */\n    private static final class GeneratedDirectoriesCollector extends SimpleFileVisitor<Path> {\n\n        private Collection<String> dirs;\n\n        GeneratedDirectoriesCollector(Collection<String> dirs) {\n            this.dirs = dirs;\n        }\n\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n            String name = dir.getFileName().toString();\n            if (name.equals(\"src\")) {\n                // special case: src/java\n                if (!new File(dir.toFile(), \"java\").isDirectory()) {\n                    dirs.add(dir.toAbsolutePath().normalize().toString());\n                    return FileVisitResult.SKIP_SUBTREE;\n                }\n            } else if (name.equals(\"java\")) {\n                dirs.add(dir.toAbsolutePath().normalize().toString());\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            return FileVisitResult.CONTINUE;\n        }\n    }\n\n    /**\n     * Walks file tree and collects source files for Android Support.\n     * Excludes tests, \"customtabs\", \"previewsdk\", and \"percent\" folders\n     */\n    private static final class SourceFilesCollector extends SimpleFileVisitor<Path> {\n\n        private Collection<String> files;\n\n        SourceFilesCollector(Collection<String> files) {\n            this.files = files;\n        }\n\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n            String name = dir.getFileName().toString();\n            if (name.equals(\"test\") ||\n                    name.equals(\"tests\") ||\n                    name.equals(\"percent\") ||\n                    name.equals(\"jvm-tests\") ||\n                    name.equals(\"customtabs\") ||\n                    name.equals(\"androidTest\") ||\n                    name.equals(\"previewsdk\") ||\n                    name.equals(\"static\") ||\n                    name.equals(\"animated\")) {\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            return FileVisitResult.CONTINUE;\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n            String filename = file.toString();\n            if (filename.endsWith(\".java\")) {\n                files.add(PathUtil.relativizeCwd(file));\n            }\n            return FileVisitResult.CONTINUE;\n        }\n    }\n\n}", "class_id": 0, "repo": "sourcegraph/srclib-java", "file": "src/main/java/com/sourcegraph/javagraph/AndroidSupportProject.java", "last_update_at": "2018-01-23T05:14:46+00:00", "question_id": "bade8124eea566f93d411e155eb6253801699711", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AndroidSupportProject implements Project {\n    static final String MARKER = \"AndroidSupport\";\n    AndroidSupportProject(SourceUnit unit) {\n    }\n    /**\n     * @return bootclasspath to compile Android base framework (should include libcore classes)\n     */\n    @Override\n    public List<String> getBootClassPath() {\n        return getLibraries(new String[]{\n                \"../../out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/classes.jar\",\n                \"sdk/android-sdk.jar\" // this entry is for testing purposes only, see sgtest/java-android-support-framework\n        });\n    }\n    /**\n     *\n     * @return classpath to use (include framework's output, junit)\n     */\n    @Override\n    public List<String> getClassPath() {\n        return getLibraries(new String[]{\n                \"../../out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar\"\n        });\n    }\n    /**\n     * @return source directories that contain files generated from .logtags and\n     * directories that contain R.java and Manifest.java\n     */\n    @Override\n    public List<String> getSourcePath() throws IOException {\n        List<String> sourcePath = new ArrayList<>();\n        // include java directories generated from .logtags and AIDL and the ones containing R.java\n        File intermediate = new File(\"../../out/target/common/obj/JAVA_LIBRARIES\");\n        if (intermediate.isDirectory()) {\n            Files.walkFileTree(intermediate.toPath(), new GeneratedDirectoriesCollector(sourcePath));\n        }\n        return sourcePath;\n    }\n    @Override\n    public RawDependency getDepForJAR(Path jarFile) throws Exception {\n        return null;\n    }\n    @Override\n    public String getSourceCodeVersion() throws Exception {\n        return DEFAULT_SOURCE_CODE_VERSION;\n    }\n    @Override\n    public String getSourceCodeEncoding() throws ModelBuildingException, IOException {\n        return null;\n    }\n    /**\n     * Creates source unit from a given directory\n     * @return source unit\n     * @throws IOException\n     */\n    static SourceUnit createSourceUnit() throws IOException {\n        final SourceUnit unit = new SourceUnit();\n        unit.Type = SourceUnit.DEFAULT_TYPE;\n        unit.Name = MARKER;\n        unit.Dir = \".\";\n        unit.Files = new ArrayList<>();\n        Files.walkFileTree(PathUtil.CWD, new SourceFilesCollector(unit.Files));\n        unit.Data.Type = MARKER;\n        return unit;\n    }\n    public static boolean is(SourceUnit unit) {\n        return MARKER.equals(unit.Data.Type);\n    }\n    /**\n     * @param files files to search for\n     * @return list of existing files resolved relative to current working directory\n     */\n    private List<String> getLibraries(String files[]) {\n        List<String> ret = Arrays.stream(files).filter(s -> new File(s).isFile()).collect(Collectors.toList());\n        return ret.isEmpty() ? null : ret;\n    }\n    /**\n     * Walks file tree and collects source directories which contain generated java files if there are any\n     */\n    private static final class GeneratedDirectoriesCollector extends SimpleFileVisitor<Path> {\n        private Collection<String> dirs;\n        GeneratedDirectoriesCollector(Collection<String> dirs) {\n            this.dirs = dirs;\n        }\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n            String name = dir.getFileName().toString();\n            if (name.equals(\"src\")) {\n                // special case: src/java\n                if (!new File(dir.toFile(), \"java\").isDirectory()) {\n                    dirs.add(dir.toAbsolutePath().normalize().toString());\n                    return FileVisitResult.SKIP_SUBTREE;\n                }\n            } else if (name.equals(\"java\")) {\n                dirs.add(dir.toAbsolutePath().normalize().toString());\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            return FileVisitResult.CONTINUE;\n        }\n    }\n    /**\n     * Walks file tree and collects source files for Android Support.\n     * Excludes tests, \"customtabs\", \"previewsdk\", and \"percent\" folders\n     */\n    private static final class SourceFilesCollector extends SimpleFileVisitor<Path> {\n        private Collection<String> files;\n        SourceFilesCollector(Collection<String> files) {\n            this.files = files;\n        }\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n            String name = dir.getFileName().toString();\n            if (name.equals(\"test\") ||\n                    name.equals(\"tests\") ||\n                    name.equals(\"percent\") ||\n                    name.equals(\"jvm-tests\") ||\n                    name.equals(\"customtabs\") ||\n                    name.equals(\"androidTest\") ||\n                    name.equals(\"previewsdk\") ||\n                    name.equals(\"static\") ||\n                    name.equals(\"animated\")) {\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            return FileVisitResult.CONTINUE;\n        }\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n            String filename = file.toString();\n            if (filename.endsWith(\".java\")) {\n                files.add(PathUtil.relativizeCwd(file));\n            }\n            return FileVisitResult.CONTINUE;\n        }\n    }\n"]], "pred": {"ppl": 2.6119191646575928, "ppl_lower": 3.0404508113861084, "ppl/lowercase_ppl": -1.1582365027388164, "ppl/zlib": 0.0006226233873245363, "Min_5.0% Prob": 7.704173798654594, "Min_10.0% Prob": 6.026408181470983, "Min_20.0% Prob": 4.163987287703683, "Min_30.0% Prob": 3.075788297586971, "Min_40.0% Prob": 2.3693050139544938, "Min_50.0% Prob": 1.9138511295290026, "Min_60.0% Prob": 1.6000801431103253}}
{"hexsha": "c007516efa7c6eccb55e1a9b76a54599901db7ad", "ext": "java", "lang": "Java", "content": "public class CrawlerCheckNewObject extends AbstractCrawler {\n\n\n\tprivate static final Logger LOGGER = Logger.getLogger(CrawlerCheckNewObject.class);\n\n\t/**\n\t * Walker sur tag_tmp_site.\n\t */\n\tprivate final TagTmpSiteImpl.RecordWalker<TagTmpSite> mWalker;\n\n\t/**\n\t * R\u00e9f\u00e9rence sur le client.\n\t */\n\tprivate final JabberComponent mComponent;\n\n\tpublic CrawlerCheckNewObject(String[] inArgs) {\n\t\tsuper(inArgs);\n\n\t\tthis.mWalker = new TagTmpSiteImpl.RecordWalker<TagTmpSite>() {\n\n\t\t\tpublic void process(TagTmpSite inTagTmpSite) {\n\t\t\t\tprocessTagTmpSite(inTagTmpSite);\n\t\t\t}\n\t\t};\n\n\t\tthis.mComponent = JabberComponentManager.getComponent(Constantes.XMPP_PLATFORM_COMPONENT);\n\t}\n\n\tprivate void processTagTmpSite(TagTmpSite inTagTmpSite) {\n\n\t\tfinal String theSerial = inTagTmpSite.getSerial();\n\t\tfinal HARDWARE theHardware = inTagTmpSite.getHardware();\n\t\tfinal String theIp = inTagTmpSite.getIp();\n\t\tif (theHardware.checkIdentifier(theSerial)) { // pour blinder les mac tr\u00e8s bien pourrite m\u00eame si elle est v\u00e9rifi\u00e9 en amont!!\n\n\t\t\tfinal VObject theObject = Factories.VOBJECT.findBySerial(theSerial);\n\t\t\tif (theObject == null) { // il n'existe pas donc on l'essaye de l'inscrire\n\t\t\t\tfinal MessageDraft theMessageDraft = Provisionning.addObjectInQueue(theIp, theSerial, theHardware);\n\t\t\t\tif (!theMessageDraft.getSequenceList().isEmpty()) {\n\t\t\t\t\t// Envoi du message pour s'inscrire\n\t\t\t\t\tfinal Packet thePacket = this.mComponent.getPacket(theMessageDraft, JabberMessageFactory.IDLE_MODE);\n\t\t\t\t\tString thePacketXml = thePacket.toXML();\n\t\t\t\t\tthePacketXml = thePacketXml.replaceAll(Provisionning.VIRTUAL_SERIAL_HARDWARE_4.toLowerCase(), theSerial);\n\t\t\t\t\tthis.mComponent.sendPacket(thePacketXml);\n\t\t\t\t}\n\t\t\t} else { // l'objet est d\u00e9j\u00e0 associ\u00e9\n\t\t\t\tinTagTmpSite.delete();\n\t\t\t}\n\t\t} else {\n\t\t\tCrawlerCheckNewObject.LOGGER.fatal(\" Bad serial in tag_tmp_site : \" + theSerial);\n\t\t}\n\n\t}\n\n\t@Override\n\tprotected void process() {\n\t\tCrawlerCheckNewObject.LOGGER.info(\" total : \" + TagTmpSiteImpl.walkCheckNewObject(this.mWalker));\n\t}\n}", "class_id": 0, "repo": "nguillaumin/nabaztag-server", "file": "net.violet.platform/src/main/java/net/violet/platform/daemons/crawlers/gestion/CrawlerCheckNewObject.java", "last_update_at": "2018-03-29T08:10:12+00:00", "question_id": "c007516efa7c6eccb55e1a9b76a54599901db7ad", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CrawlerCheckNewObject extends AbstractCrawler {\n\tprivate static final Logger LOGGER = Logger.getLogger(CrawlerCheckNewObject.class);\n\t/**\n\t * Walker sur tag_tmp_site.\n\t */\n\tprivate final TagTmpSiteImpl.RecordWalker<TagTmpSite> mWalker;\n\t/**\n\t * R\u00e9f\u00e9rence sur le client.\n\t */\n\tprivate final JabberComponent mComponent;\n\tpublic CrawlerCheckNewObject(String[] inArgs) {\n\t\tsuper(inArgs);\n\t\tthis.mWalker = new TagTmpSiteImpl.RecordWalker<TagTmpSite>() {\n\t\t\tpublic void process(TagTmpSite inTagTmpSite) {\n\t\t\t\tprocessTagTmpSite(inTagTmpSite);\n\t\t\t}\n\t\t};\n\t\tthis.mComponent = JabberComponentManager.getComponent(Constantes.XMPP_PLATFORM_COMPONENT);\n\t}\n\tprivate void processTagTmpSite(TagTmpSite inTagTmpSite) {\n\t\tfinal String theSerial = inTagTmpSite.getSerial();\n\t\tfinal HARDWARE theHardware = inTagTmpSite.getHardware();\n\t\tfinal String theIp = inTagTmpSite.getIp();\n\t\tif (theHardware.checkIdentifier(theSerial)) { // pour blinder les mac tr\u00e8s bien pourrite m\u00eame si elle est v\u00e9rifi\u00e9 en amont!!\n\t\t\tfinal VObject theObject = Factories.VOBJECT.findBySerial(theSerial);\n\t\t\tif (theObject == null) { // il n'existe pas donc on l'essaye de l'inscrire\n\t\t\t\tfinal MessageDraft theMessageDraft = Provisionning.addObjectInQueue(theIp, theSerial, theHardware);\n\t\t\t\tif (!theMessageDraft.getSequenceList().isEmpty()) {\n\t\t\t\t\t// Envoi du message pour s'inscrire\n\t\t\t\t\tfinal Packet thePacket = this.mComponent.getPacket(theMessageDraft, JabberMessageFactory.IDLE_MODE);\n\t\t\t\t\tString thePacketXml = thePacket.toXML();\n\t\t\t\t\tthePacketXml = thePacketXml.replaceAll(Provisionning.VIRTUAL_SERIAL_HARDWARE_4.toLowerCase(), theSerial);\n\t\t\t\t\tthis.mComponent.sendPacket(thePacketXml);\n\t\t\t\t}\n\t\t\t} else { // l'objet est d\u00e9j\u00e0 associ\u00e9\n\t\t\t\tinTagTmpSite.delete();\n\t\t\t}\n\t\t} else {\n\t\t\tCrawlerCheckNewObject.LOGGER.fatal(\" Bad serial in tag_tmp_site : \" + theSerial);\n\t\t}\n\t}\n\t@Override\n\tprotected void process() {\n\t\tCrawlerCheckNewObject.LOGGER.info(\" total : \" + TagTmpSiteImpl.walkCheckNewObject(this.mWalker));\n\t}\n"]], "pred": {"ppl": 2.8502461910247803, "ppl_lower": 3.522489547729492, "ppl/lowercase_ppl": -1.2021782869537834, "ppl/zlib": 0.0011702853333692635, "Min_5.0% Prob": 8.500636616268674, "Min_10.0% Prob": 6.709299901326498, "Min_20.0% Prob": 4.507466740166115, "Min_30.0% Prob": 3.318379883481338, "Min_40.0% Prob": 2.570482265376887, "Min_50.0% Prob": 2.086372461318179, "Min_60.0% Prob": 1.7433677485817118}}
{"hexsha": "fafdaa6c81f3967bad13b9cc30b9c6454a88ec12", "ext": "java", "lang": "Java", "content": "@Component\n@Path(\"/clouds/{cloudId}/comments\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n@Api(value = \"Comments\", produces = \"application/json\")\npublic class CommentsProvider {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(CommentsProvider.class);\n\n\t@Value(\"${info.api.version}\")\n\tprivate String apiVersion;\n\n\t@POST\n\t@Path(\"/\")\n\t@ApiOperation(value = \"Create new comment\", response = JsonObj.class)\n\tpublic Response create(\n\t\t\t@HeaderParam(\"Authorization\") String auth,\n\t\t\t@ApiParam @PathParam(\"cloudId\") String cloudId,\n\t\t\t@ApiParam JsonObj request\n\t) throws InvalidInputException, NotFoundException, NotAuthorizedException {\n\t\tLOG.info(\"POST:{}/clouds/{}/comments\", apiVersion, cloudId);\n\t\tJsonObj result = CommentsService.createComment(auth, cloudId, request);\n\t\treturn Response.status(Status.OK).entity(result).build();\n\t}\n\n\t@GET\n\t@Path(\"/search\")\n\t@ApiOperation(value = \"Query comments for node\", response = JsonObj.class)\n\tpublic Response get(\n\t\t\t@HeaderParam(\"Authorization\") String auth,\n\t\t\t@ApiParam @PathParam(\"cloudId\") String cloudId,\n\t\t\t@ApiParam @QueryParam(\"nodeId\") String nodeId, \n\t\t\t@ApiParam @QueryParam(\"query\") String query,\n\t\t\t@ApiParam @QueryParam(\"projection\") String projection,\n\t\t\t@ApiParam @QueryParam(\"limit\") int limit\n\t) throws NotAuthorizedException {\n\t\tLOG.info(\"GET:{}/clouds/{}/comments/search/{}?query={}&projection={}&limit={}\", apiVersion, cloudId, nodeId, query, projection, limit);\n\t\tJsonObj result = CommentsService.getCommentsforNode(auth, cloudId, nodeId, query, projection, limit);\n\t\treturn Response.status(Status.OK).entity(result).build();\n\t}\n\n}", "class_id": 0, "repo": "Grokery/grokerylab", "file": "api/src/main/java/io/grokery/lab/api/spring/providers/CommentsProvider.java", "last_update_at": "2018-05-30T05:27:42+00:00", "question_id": "fafdaa6c81f3967bad13b9cc30b9c6454a88ec12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\n@Path(\"/clouds/{cloudId}/comments\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n@Api(value = \"Comments\", produces = \"application/json\")\npublic class CommentsProvider {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(CommentsProvider.class);\n\t@Value(\"${info.api.version}\")\n\tprivate String apiVersion;\n\t@POST\n\t@Path(\"/\")\n\t@ApiOperation(value = \"Create new comment\", response = JsonObj.class)\n\tpublic Response create(\n\t\t\t@HeaderParam(\"Authorization\") String auth,\n\t\t\t@ApiParam @PathParam(\"cloudId\") String cloudId,\n\t\t\t@ApiParam JsonObj request\n\t) throws InvalidInputException, NotFoundException, NotAuthorizedException {\n\t\tLOG.info(\"POST:{}/clouds/{}/comments\", apiVersion, cloudId);\n\t\tJsonObj result = CommentsService.createComment(auth, cloudId, request);\n\t\treturn Response.status(Status.OK).entity(result).build();\n\t}\n\t@GET\n\t@Path(\"/search\")\n\t@ApiOperation(value = \"Query comments for node\", response = JsonObj.class)\n\tpublic Response get(\n\t\t\t@HeaderParam(\"Authorization\") String auth,\n\t\t\t@ApiParam @PathParam(\"cloudId\") String cloudId,\n\t\t\t@ApiParam @QueryParam(\"nodeId\") String nodeId, \n\t\t\t@ApiParam @QueryParam(\"query\") String query,\n\t\t\t@ApiParam @QueryParam(\"projection\") String projection,\n\t\t\t@ApiParam @QueryParam(\"limit\") int limit\n\t) throws NotAuthorizedException {\n\t\tLOG.info(\"GET:{}/clouds/{}/comments/search/{}?query={}&projection={}&limit={}\", apiVersion, cloudId, nodeId, query, projection, limit);\n\t\tJsonObj result = CommentsService.getCommentsforNode(auth, cloudId, nodeId, query, projection, limit);\n\t\treturn Response.status(Status.OK).entity(result).build();\n\t}\n"]], "pred": {"ppl": 1.7567269802093506, "ppl_lower": 2.1947124004364014, "ppl/lowercase_ppl": -1.3950619480684652, "ppl/zlib": 0.0009297894511233984, "Min_5.0% Prob": 6.40046950340271, "Min_10.0% Prob": 4.275775911761265, "Min_20.0% Prob": 2.6227666910956886, "Min_30.0% Prob": 1.841406331245416, "Min_40.0% Prob": 1.4035585353004874, "Min_50.0% Prob": 1.1239955792443652, "Min_60.0% Prob": 0.9388203096776254}}
{"hexsha": "621ecba9574f30c177e33a6e5a64136fe557507c", "ext": "java", "lang": "Java", "content": "public class GetShuffle extends AbstractItemAction {\n\n\t/**\n\t * Returns the preferences of the given object.\n\t * \n\t * @throws InvalidParameterException\n\t * @see net.violet.platform.api.actions.Action#processRequest(java.util.Map)\n\t */\n\n\t@Override\n\tprotected Object doProcessRequest(ActionParam inParam) throws InvalidParameterException {\n\n\t\tfinal APICaller caller = inParam.getCaller();\n\t\tfinal StatusMusic type = getLibraryTypeId(inParam);\n\t\tfinal String thelanguageCode = inParam.getString(\"language\", true);\n\t\tfinal ObjectLangData languageData = ObjectLangData.getByISOCode(thelanguageCode);\n\n\t\tfinal MusicData theMusicData = MusicData.findRandomByLang(type, languageData);\n\n\t\treturn new ItemInformationMap(caller, theMusicData);\n\t}\n\n\t/**\n\t * @see net.violet.platform.api.actions.Action#isCacheable()\n\t */\n\tpublic boolean isCacheable() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Object informations may be cached one day\n\t * \n\t * @see net.violet.platform.api.actions.Action#getExpirationTime()\n\t */\n\tpublic long getExpirationTime() {\n\t\treturn Constantes.ONE_DAY_IN_S;\n\t}\n\n\t/**\n\t * Read Only action\n\t * \n\t * @see net.violet.platform.api.actions.Action#getType()\n\t */\n\tpublic ActionType getType() {\n\t\treturn ActionType.GET;\n\t}\n\n\t@Override\n\tpublic List<ApplicationClass> getAuthorizedApplicationClasses() {\n\t\treturn Application.CLASSES_ALL;\n\t}\n\n}", "class_id": 0, "repo": "nguillaumin/nabaztag-server", "file": "net.violet.platform/src/main/java/net/violet/platform/api/actions/libraries/GetShuffle.java", "last_update_at": "2018-03-29T08:10:12+00:00", "question_id": "621ecba9574f30c177e33a6e5a64136fe557507c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetShuffle extends AbstractItemAction {\n\t/**\n\t * Returns the preferences of the given object.\n\t * \n\t * @throws InvalidParameterException\n\t * @see net.violet.platform.api.actions.Action#processRequest(java.util.Map)\n\t */\n\t@Override\n\tprotected Object doProcessRequest(ActionParam inParam) throws InvalidParameterException {\n\t\tfinal APICaller caller = inParam.getCaller();\n\t\tfinal StatusMusic type = getLibraryTypeId(inParam);\n\t\tfinal String thelanguageCode = inParam.getString(\"language\", true);\n\t\tfinal ObjectLangData languageData = ObjectLangData.getByISOCode(thelanguageCode);\n\t\tfinal MusicData theMusicData = MusicData.findRandomByLang(type, languageData);\n\t\treturn new ItemInformationMap(caller, theMusicData);\n\t}\n\t/**\n\t * @see net.violet.platform.api.actions.Action#isCacheable()\n\t */\n\tpublic boolean isCacheable() {\n\t\treturn true;\n\t}\n\t/**\n\t * Object informations may be cached one day\n\t * \n\t * @see net.violet.platform.api.actions.Action#getExpirationTime()\n\t */\n\tpublic long getExpirationTime() {\n\t\treturn Constantes.ONE_DAY_IN_S;\n\t}\n\t/**\n\t * Read Only action\n\t * \n\t * @see net.violet.platform.api.actions.Action#getType()\n\t */\n\tpublic ActionType getType() {\n\t\treturn ActionType.GET;\n\t}\n\t@Override\n\tpublic List<ApplicationClass> getAuthorizedApplicationClasses() {\n\t\treturn Application.CLASSES_ALL;\n\t}\n"]], "pred": {"ppl": 1.8455381393432617, "ppl_lower": 3.1406471729278564, "ppl/lowercase_ppl": -1.867629267556563, "ppl/zlib": 0.0010638383843829212, "Min_5.0% Prob": 6.727990922473726, "Min_10.0% Prob": 4.920053645621898, "Min_20.0% Prob": 2.918752947757984, "Min_30.0% Prob": 2.030224372045352, "Min_40.0% Prob": 1.5292915560562035, "Min_50.0% Prob": 1.227882866192961, "Min_60.0% Prob": 1.0211720038584515}}
{"hexsha": "231b9d7a658cd195792984fa56050128b035442c", "ext": "java", "lang": "Java", "content": "public class BasicGroup implements CoGroup {\n\n    private String name;\n\n    Map<String, Co> members;\n\n    public BasicGroup(String name) {\n        this.name = name;\n        members = new ConcurrentHashMap<>();\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#name()\n     */\n    @Override\n    public String name() {\n        return name;\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#members()\n     */\n    @Override\n    public Collection<Co> members() {\n        return members.values();\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#join(coca.co.Co)\n     */\n    @Override\n    public boolean join(Co co) {\n        try {\n            return members.putIfAbsent(co.id(), of(co)) == null;\n        } finally {\n            Co p = members.get(co.id());\n            if (p != null && p instanceof CoProxy) ((CoProxy) p).lastAccess(System.currentTimeMillis());\n        }\n    }\n\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#quit(coca.co.Co)\n     */\n    @Override\n    public boolean quit(Co co) {\n        return members.remove(co.id()) != null;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) return false;\n        if (obj instanceof CoGroup) { return ((CoGroup) obj).name().equals(name()); }\n        return false;\n    }\n\n    @Override\n    public boolean contain(Co member) {\n        return members.containsKey(member.id());\n    }\n\n    @Override\n    public String toString() {\n        return name + \" \" + members.toString();\n    }\n\n    public static final CoProxy of(Co co) {\n        return new CoProxy(co.id());\n    }\n\n    public static class CoProxy implements Co {\n\n        private String id;\n        private long lastAccess; // clear this if lastAccess + timeout < now\n\n        public CoProxy(String id) {\n            this.id = id;\n        }\n\n        public long lastAccess() {\n            return lastAccess;\n        }\n\n        public CoProxy lastAccess(long lastAccess) {\n            this.lastAccess = lastAccess;\n            return this;\n        }\n\n        @Override\n        public void close() throws IOException {\n\n        }\n\n        @Override\n        public String id() {\n            return id;\n        }\n\n        @Override\n        public Co init(CoConf conf) {\n            return null;\n        }\n\n        @Override\n        public CoConf conf() {\n            return null;\n        }\n\n        @Override\n        public boolean isClosed() {\n            return false;\n        }\n\n        @Override\n        public Collection<CoGroup> groups() {\n            return null;\n        }\n\n        @Override\n        public CoGroup group(String name, boolean addIfNil) {\n            return null;\n        }\n\n        @Override\n        public CoFuture<InsResult> join(String name) throws CoException {\n            return null;\n        }\n\n        @Override\n        public CoFuture<InsResult> quit(String name) throws CoException {\n            return null;\n        }\n\n        @Override\n        public CoFuture<InsResult> pub(CoIns<?> ins) throws CoException {\n            return null;\n        }\n\n        @Override\n        public CoIns<?> sub(long timeout, TimeUnit unit) throws CoException, InterruptedException {\n            return null;\n        }\n\n        @Override\n        public Co insFactory(CoInsFactory insFactory) {\n            return null;\n        }\n\n        @Override\n        public CoInsFactory insFactory() {\n            return null;\n        }\n\n        @Override\n        public Co io(CoIO io) {\n            return null;\n        }\n\n        @Override\n        public CoIO io() {\n            return null;\n        }\n\n        @Override\n        public Co withListener(String name, CoListener l) {\n            return null;\n        }\n\n        @Override\n        public CoListener removeListener(String name) {\n            return null;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) return false;\n            if (obj instanceof Co) return ((Co) obj).id().equals(id);\n            return false;\n        }\n\n    }\n\n    @Override\n    public Co find(String id) {\n        return members.get(id);\n    }\n\n}", "class_id": 0, "repo": "dzh/coca", "file": "coca-co/src/main/java/coca/co/BasicGroup.java", "last_update_at": "2018-12-05T09:41:49+00:00", "question_id": "231b9d7a658cd195792984fa56050128b035442c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BasicGroup implements CoGroup {\n    private String name;\n    Map<String, Co> members;\n    public BasicGroup(String name) {\n        this.name = name;\n        members = new ConcurrentHashMap<>();\n    }\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#name()\n     */\n    @Override\n    public String name() {\n        return name;\n    }\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#members()\n     */\n    @Override\n    public Collection<Co> members() {\n        return members.values();\n    }\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#join(coca.co.Co)\n     */\n    @Override\n    public boolean join(Co co) {\n        try {\n            return members.putIfAbsent(co.id(), of(co)) == null;\n        } finally {\n            Co p = members.get(co.id());\n            if (p != null && p instanceof CoProxy) ((CoProxy) p).lastAccess(System.currentTimeMillis());\n        }\n    }\n    /*\n     * (non-Javadoc)\n     * @see coca.co.CoGroup#quit(coca.co.Co)\n     */\n    @Override\n    public boolean quit(Co co) {\n        return members.remove(co.id()) != null;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) return false;\n        if (obj instanceof CoGroup) { return ((CoGroup) obj).name().equals(name()); }\n        return false;\n    }\n    @Override\n    public boolean contain(Co member) {\n        return members.containsKey(member.id());\n    }\n    @Override\n    public String toString() {\n        return name + \" \" + members.toString();\n    }\n    public static final CoProxy of(Co co) {\n        return new CoProxy(co.id());\n    }\n    public static class CoProxy implements Co {\n        private String id;\n        private long lastAccess; // clear this if lastAccess + timeout < now\n        public CoProxy(String id) {\n            this.id = id;\n        }\n        public long lastAccess() {\n            return lastAccess;\n        }\n        public CoProxy lastAccess(long lastAccess) {\n            this.lastAccess = lastAccess;\n            return this;\n        }\n        @Override\n        public void close() throws IOException {\n        }\n        @Override\n        public String id() {\n            return id;\n        }\n        @Override\n        public Co init(CoConf conf) {\n            return null;\n        }\n        @Override\n        public CoConf conf() {\n            return null;\n        }\n        @Override\n        public boolean isClosed() {\n            return false;\n        }\n        @Override\n        public Collection<CoGroup> groups() {\n            return null;\n        }\n        @Override\n        public CoGroup group(String name, boolean addIfNil) {\n            return null;\n        }\n        @Override\n        public CoFuture<InsResult> join(String name) throws CoException {\n            return null;\n        }\n        @Override\n        public CoFuture<InsResult> quit(String name) throws CoException {\n            return null;\n        }\n        @Override\n        public CoFuture<InsResult> pub(CoIns<?> ins) throws CoException {\n            return null;\n        }\n        @Override\n        public CoIns<?> sub(long timeout, TimeUnit unit) throws CoException, InterruptedException {\n            return null;\n        }\n        @Override\n        public Co insFactory(CoInsFactory insFactory) {\n            return null;\n        }\n        @Override\n        public CoInsFactory insFactory() {\n            return null;\n        }\n        @Override\n        public Co io(CoIO io) {\n            return null;\n        }\n        @Override\n        public CoIO io() {\n            return null;\n        }\n        @Override\n        public Co withListener(String name, CoListener l) {\n            return null;\n        }\n        @Override\n        public CoListener removeListener(String name) {\n            return null;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) return false;\n            if (obj instanceof Co) return ((Co) obj).id().equals(id);\n            return false;\n        }\n    }\n    @Override\n    public Co find(String id) {\n        return members.get(id);\n    }\n"]], "pred": {"ppl": 1.6769311428070068, "ppl_lower": 1.7914291620254517, "ppl/lowercase_ppl": -1.1277615305258757, "ppl/zlib": 0.0005570748084619858, "Min_5.0% Prob": 6.161893994200463, "Min_10.0% Prob": 4.307635323674071, "Min_20.0% Prob": 2.5019830566118744, "Min_30.0% Prob": 1.7128558261380866, "Min_40.0% Prob": 1.2895264989220534, "Min_50.0% Prob": 1.0339043613636243, "Min_60.0% Prob": 0.8623958227982772}}
{"hexsha": "7a8070a7512549a8df51b8c467b75d3b783f8d84", "ext": "java", "lang": "Java", "content": "public class MathUtil {\n\n    public static float roundToTick(double value, float tick) {\n        if (tick <= 0) {\n            return (float) value;\n        }\n\n        float tickMod = tick * 100;\n        float round = Math.round( ( value * 100 )/ (tickMod)) * (tickMod);\n        return round / 100;\n    }\n\n}", "class_id": 0, "repo": "ganeshwani7/RobinhoodAdvanced", "file": "src/main/java/com/cheddar/util/MathUtil.java", "last_update_at": "2018-08-23T05:27:17+00:00", "question_id": "7a8070a7512549a8df51b8c467b75d3b783f8d84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MathUtil {\n    public static float roundToTick(double value, float tick) {\n        if (tick <= 0) {\n            return (float) value;\n        }\n        float tickMod = tick * 100;\n        float round = Math.round( ( value * 100 )/ (tickMod)) * (tickMod);\n        return round / 100;\n    }\n"]], "pred": {"ppl": 3.1626999378204346, "ppl_lower": 4.014786720275879, "ppl/lowercase_ppl": -1.2071849485167438, "ppl/zlib": 0.006853726627978833, "Min_5.0% Prob": 6.7587203025817875, "Min_10.0% Prob": 5.64720389842987, "Min_20.0% Prob": 4.188292241096496, "Min_30.0% Prob": 3.3028597474098205, "Min_40.0% Prob": 2.6793477907776833, "Min_50.0% Prob": 2.242226452231407, "Min_60.0% Prob": 1.9133475343386332}}
{"hexsha": "e74cf115db2f058681004583ad26f64020b11f72", "ext": "java", "lang": "Java", "content": "@NotThreadSafe\npublic class JUnitRunListenerAdapter extends RunListener {\n\n    private static final Pattern JAVA_CLASS_NAME_PATTERN = Pattern.compile(\"[\\\\._$\\\\p{Alnum}]+\");\n\n    private final SuiteNotifier notifier;\n    private final Deque<TestNotifier> activeTestsStack = new ArrayDeque<>();\n    private final Map<Description, TestId> descriptionIds = new HashMap<>();\n    private Description rootDescription;\n\n    public JUnitRunListenerAdapter(SuiteNotifier notifier) {\n        this.notifier = notifier;\n    }\n\n    @Override\n    public void testRunStarted(Description description) {\n        rootDescription = description;\n        fireTestFound(TestId.ROOT, description);\n    }\n\n    private void fireTestFound(TestId testId, Description description) {\n        TestId previousValue = descriptionIds.put(description, testId);\n        if (previousValue == null) {\n            notifier.fireTestFound(testId, formatTestName(description));\n        }\n\n        TestId childId = testId.getFirstChild();\n        for (Description child : description.getChildren()) {\n            fireTestFound(childId, child);\n            childId = childId.getNextSibling();\n        }\n    }\n\n    private static String formatTestName(Description description) {\n        String methodName = description.getMethodName();\n        if (methodName != null) {\n            return methodName;\n        }\n        String className = description.getClassName();\n        if (isJavaClassName(className)) {\n            return simpleClassName(className);\n        }\n        // not a class name, but actually free-form text\n        return className;\n    }\n\n    private static boolean isJavaClassName(String s) {\n        return JAVA_CLASS_NAME_PATTERN.matcher(s).matches();\n    }\n\n    private static String simpleClassName(String name) {\n        name = name.substring(name.lastIndexOf('.') + 1);\n        name = name.substring(name.lastIndexOf('$') + 1);\n        return name;\n    }\n\n    @Override\n    public void testRunFinished(Result result) {\n    }\n\n    @Override\n    public void testStarted(Description description) {\n        TestId id = descriptionIds.get(description);\n        if (id == null) {\n            // Hoping that the runner added this description as a child to the top-level description\n            fireTestFound(TestId.ROOT, rootDescription);\n            id = descriptionIds.get(description);\n        }\n        if (id == null) {\n            // Fallback if we have no way of knowing this description's parent\n            id = nextUnassignedChildOf(TestId.ROOT);\n            fireTestFound(id, description);\n        }\n        startTestAndItsParents(id);\n    }\n\n    private TestId nextUnassignedChildOf(TestId parent) {\n        Set<TestId> assignedIds = new HashSet<>(descriptionIds.values());\n        TestId id = parent.getFirstChild();\n        while (assignedIds.contains(id)) {\n            id = id.getNextSibling();\n        }\n        return id;\n    }\n\n    private void startTestAndItsParents(TestId testId) {\n        if (!testId.isRoot()) {\n            startTestAndItsParents(testId.getParent());\n        }\n        TestNotifier tn = notifier.fireTestStarted(testId);\n        activeTestsStack.push(tn);\n    }\n\n    @Override\n    public void testFinished(Description description) {\n        finishAllTests();\n    }\n\n    private void finishAllTests() {\n        while (!activeTestsStack.isEmpty()) {\n            TestNotifier tn = activeTestsStack.pop();\n            tn.fireTestFinished();\n        }\n    }\n\n    @Override\n    public void testFailure(Failure failure) {\n        TestNotifier tn = activeTestsStack.peek();\n        if (tn != null) {\n            tn.fireFailure(failure.getException());\n        }\n    }\n\n    @Override\n    public void testAssumptionFailure(Failure failure) {\n        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here\n        failure.getException().printStackTrace();\n    }\n\n    @Override\n    public void testIgnored(Description description) {\n        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here\n    }\n}", "class_id": 0, "repo": "orfjackal/jumi", "file": "jumi-core/src/main/java/fi/jumi/core/junit/JUnitRunListenerAdapter.java", "last_update_at": "2018-04-24T06:38:14+00:00", "question_id": "e74cf115db2f058681004583ad26f64020b11f72", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@NotThreadSafe\npublic class JUnitRunListenerAdapter extends RunListener {\n    private static final Pattern JAVA_CLASS_NAME_PATTERN = Pattern.compile(\"[\\\\._$\\\\p{Alnum}]+\");\n    private final SuiteNotifier notifier;\n    private final Deque<TestNotifier> activeTestsStack = new ArrayDeque<>();\n    private final Map<Description, TestId> descriptionIds = new HashMap<>();\n    private Description rootDescription;\n    public JUnitRunListenerAdapter(SuiteNotifier notifier) {\n        this.notifier = notifier;\n    }\n    @Override\n    public void testRunStarted(Description description) {\n        rootDescription = description;\n        fireTestFound(TestId.ROOT, description);\n    }\n    private void fireTestFound(TestId testId, Description description) {\n        TestId previousValue = descriptionIds.put(description, testId);\n        if (previousValue == null) {\n            notifier.fireTestFound(testId, formatTestName(description));\n        }\n        TestId childId = testId.getFirstChild();\n        for (Description child : description.getChildren()) {\n            fireTestFound(childId, child);\n            childId = childId.getNextSibling();\n        }\n    }\n    private static String formatTestName(Description description) {\n        String methodName = description.getMethodName();\n        if (methodName != null) {\n            return methodName;\n        }\n        String className = description.getClassName();\n        if (isJavaClassName(className)) {\n            return simpleClassName(className);\n        }\n        // not a class name, but actually free-form text\n        return className;\n    }\n    private static boolean isJavaClassName(String s) {\n        return JAVA_CLASS_NAME_PATTERN.matcher(s).matches();\n    }\n    private static String simpleClassName(String name) {\n        name = name.substring(name.lastIndexOf('.') + 1);\n        name = name.substring(name.lastIndexOf('$') + 1);\n        return name;\n    }\n    @Override\n    public void testRunFinished(Result result) {\n    }\n    @Override\n    public void testStarted(Description description) {\n        TestId id = descriptionIds.get(description);\n        if (id == null) {\n            // Hoping that the runner added this description as a child to the top-level description\n            fireTestFound(TestId.ROOT, rootDescription);\n            id = descriptionIds.get(description);\n        }\n        if (id == null) {\n            // Fallback if we have no way of knowing this description's parent\n            id = nextUnassignedChildOf(TestId.ROOT);\n            fireTestFound(id, description);\n        }\n        startTestAndItsParents(id);\n    }\n    private TestId nextUnassignedChildOf(TestId parent) {\n        Set<TestId> assignedIds = new HashSet<>(descriptionIds.values());\n        TestId id = parent.getFirstChild();\n        while (assignedIds.contains(id)) {\n            id = id.getNextSibling();\n        }\n        return id;\n    }\n    private void startTestAndItsParents(TestId testId) {\n        if (!testId.isRoot()) {\n            startTestAndItsParents(testId.getParent());\n        }\n        TestNotifier tn = notifier.fireTestStarted(testId);\n        activeTestsStack.push(tn);\n    }\n    @Override\n    public void testFinished(Description description) {\n        finishAllTests();\n    }\n    private void finishAllTests() {\n        while (!activeTestsStack.isEmpty()) {\n            TestNotifier tn = activeTestsStack.pop();\n            tn.fireTestFinished();\n        }\n    }\n    @Override\n    public void testFailure(Failure failure) {\n        TestNotifier tn = activeTestsStack.peek();\n        if (tn != null) {\n            tn.fireFailure(failure.getException());\n        }\n    }\n    @Override\n    public void testAssumptionFailure(Failure failure) {\n        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here\n        failure.getException().printStackTrace();\n    }\n    @Override\n    public void testIgnored(Description description) {\n        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here\n    }\n"]], "pred": {"ppl": 1.7920219898223877, "ppl_lower": 1.9050003290176392, "ppl/lowercase_ppl": -1.1048052852782622, "ppl/zlib": 0.0004964634770925042, "Min_5.0% Prob": 6.271599087060666, "Min_10.0% Prob": 4.522029007182402, "Min_20.0% Prob": 2.7508285185870003, "Min_30.0% Prob": 1.9226486706266217, "Min_40.0% Prob": 1.453469796693704, "Min_50.0% Prob": 1.1665134514825977, "Min_60.0% Prob": 0.9731357672611072}}
{"hexsha": "33b73c4832113bc45c088d29a0aae831f884b9cc", "ext": "java", "lang": "Java", "content": "public class Main {\n    public static void main(String[] args) throws IOException {\n        File inputFile = new File(args[0]);\n        \n        BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile));\n        String lineInFile;\n        \n        while ( (lineInFile = bufferedReader.readLine()) != null ) {\n            lineInFile = lineInFile.trim();\n            \n            if (lineInFile.equals(\"\")) {\n            \tlineInFile = bufferedReader.readLine(); // escape Enter key press\n            }\n            \n            String[] sets = lineInFile.split(\";\");\n            String[] firstSetNumbers = sets[0].split(\",\");\n            String[] secondSetNumbers = sets[1].split(\",\");\n            \n            StringBuilder intersection = new StringBuilder();\n            \n            int i = 0;\n            int j = 0;\n            \n            while ( i < firstSetNumbers.length ) {\n            \tif ( firstSetNumbers[i].equals(secondSetNumbers[j] ) ) {\n            \t\twhile ( i < firstSetNumbers.length &&\n            \t\t\t\tj < secondSetNumbers.length &&\n            \t\t\t\tfirstSetNumbers[i].equals(secondSetNumbers[j]) ) \n            \t\t{\n            \t\t\tintersection.append( firstSetNumbers[i] + \",\" );\n            \t\t\ti++;\n            \t\t\tj++;\n            \t\t}\n            \t\tbreak;\n            \t}\n            \telse {\n            \t\ti++;\n            \t}\n            }\n            \n            if (intersection.length() > 0) {\n            \tSystem.out.println( intersection.substring(0, intersection.length()-1) );\n            }\n            else {\n            \tSystem.out.println();\n            }\n        }\n        \n        bufferedReader.close();\n    }\n}", "class_id": 0, "repo": "dvt32/cpp-journey", "file": "Java/CodeEval/Set Intersection.java", "last_update_at": "2018-05-24T11:30:05+00:00", "question_id": "33b73c4832113bc45c088d29a0aae831f884b9cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Main {\n    public static void main(String[] args) throws IOException {\n        File inputFile = new File(args[0]);\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile));\n        String lineInFile;\n        while ( (lineInFile = bufferedReader.readLine()) != null ) {\n            lineInFile = lineInFile.trim();\n            if (lineInFile.equals(\"\")) {\n            \tlineInFile = bufferedReader.readLine(); // escape Enter key press\n            }\n            String[] sets = lineInFile.split(\";\");\n            String[] firstSetNumbers = sets[0].split(\",\");\n            String[] secondSetNumbers = sets[1].split(\",\");\n            StringBuilder intersection = new StringBuilder();\n            int i = 0;\n            int j = 0;\n            while ( i < firstSetNumbers.length ) {\n            \tif ( firstSetNumbers[i].equals(secondSetNumbers[j] ) ) {\n            \t\twhile ( i < firstSetNumbers.length &&\n            \t\t\t\tj < secondSetNumbers.length &&\n            \t\t\t\tfirstSetNumbers[i].equals(secondSetNumbers[j]) ) \n            \t\t{\n            \t\t\tintersection.append( firstSetNumbers[i] + \",\" );\n            \t\t\ti++;\n            \t\t\tj++;\n            \t\t}\n            \t\tbreak;\n            \t}\n            \telse {\n            \t\ti++;\n            \t}\n            }\n            if (intersection.length() > 0) {\n            \tSystem.out.println( intersection.substring(0, intersection.length()-1) );\n            }\n            else {\n            \tSystem.out.println();\n            }\n        }\n        bufferedReader.close();\n    }\n"]], "pred": {"ppl": 1.5827854871749878, "ppl_lower": 1.8506836891174316, "ppl/lowercase_ppl": -1.3405347333832789, "ppl/zlib": 0.0009202129487050462, "Min_5.0% Prob": 5.296229623612904, "Min_10.0% Prob": 3.6467858275701834, "Min_20.0% Prob": 2.1599582378891693, "Min_30.0% Prob": 1.4952468322661088, "Min_40.0% Prob": 1.1410039805261225, "Min_50.0% Prob": 0.9162116121551996, "Min_60.0% Prob": 0.7646935856119083}}
{"hexsha": "be6b957ca144bfb7eb19b51308ca855e7fdc65c4", "ext": "java", "lang": "Java", "content": "@Service\r\npublic class UserService extends BaseService<UserMapper, User> {\r\n\r\n\tpublic int find(int time) {\r\n\t\treturn dao.find(time);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param user\r\n\t * @return\r\n\t */\r\n\t@Transactional\r\n\tpublic Result<User> doBiz(User user) {\r\n\t\tlogger.info(\"start doBiz\");\r\n\r\n\t\tUser u = this.queryForUpdateOne(user);\r\n\r\n\t\tlogger.info(u);\r\n\r\n\t\tlogger.info(\"debug dot\");\r\n\r\n\t\tif (u == null) {\r\n\t\t\treturn Result.fail(\"aaa\");\r\n\t\t}\r\n\t\tif (\"123\".equals(u.getName())) {\r\n\t\t\treturn Result.fail(\"bbb\");\r\n\t\t}\r\n\r\n\t\treturn Result.ok(u);\r\n\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "duzhi/spring-boot-example", "file": "spring-boot-example-rest/src/main/java/com/daimabaike/springboot/mybatis/sys/service/UserService.java", "last_update_at": "2018-09-22T10:43:51+00:00", "question_id": "be6b957ca144bfb7eb19b51308ca855e7fdc65c4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\r\npublic class UserService extends BaseService<UserMapper, User> {\r\n\r\n\tpublic int find(int time) {\r\n\t\treturn dao.find(time);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param user\r\n\t * @return\r\n\t */\r\n\t@Transactional\r\n\tpublic Result<User> doBiz(User user) {\r\n\t\tlogger.info(\"start doBiz\");\r\n\r\n\t\tUser u = this.queryForUpdateOne(user);\r\n\r\n\t\tlogger.info(u);\r\n\r\n\t\tlogger.info(\"debug dot\");\r\n\r\n\t\tif (u == null) {\r\n\t\t\treturn Result.fail(\"aaa\");\r\n\t\t}\r\n\t\tif (\"123\".equals(u.getName())) {\r\n\t\t\treturn Result.fail(\"bbb\");\r\n\t\t}\r\n\r\n\t\treturn Result.ok(u);\r\n\r\n\t}\r\n\r\n"]], "pred": {"ppl": 2.8385584354400635, "ppl_lower": 3.3360507488250732, "ppl/lowercase_ppl": -1.1547895473628733, "ppl/zlib": 0.003536597729319293, "Min_5.0% Prob": 7.88137336210771, "Min_10.0% Prob": 5.937383695082231, "Min_20.0% Prob": 4.255102929743853, "Min_30.0% Prob": 3.2383788589275246, "Min_40.0% Prob": 2.552823806012219, "Min_50.0% Prob": 2.0787534231489353, "Min_60.0% Prob": 1.7426669121240124}}
{"hexsha": "98debbf21c6e1a1c1fa8fa8982ad8c30a3ee25b2", "ext": "java", "lang": "Java", "content": "public class SReporterParam extends SUserParam implements SArgumentInterface {\r\n    \r\n    /**\r\n     * Creates a reporter param from user param.\r\n     * @param userParam User param.\r\n     * @throws Exception \r\n     */\r\n    public SReporterParam(final SUserParam userParam) throws Exception {\r\n        super(userParam);\r\n    }\r\n    \r\n    /**\r\n     * Creates a reporter param from XML element param.\r\n     * @param elementParam XML element param.\r\n     * @throws Exception \r\n     */\r\n    public SReporterParam(final SElementParam elementParam) throws Exception {\r\n        super(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString(), \r\n                SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), \r\n                SReporterUtils.castDataType(SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), \r\n                        elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString()));\r\n    }\r\n\r\n    @Override\r\n    public boolean isComplete() {\r\n        return moValue != null;\r\n    }\r\n\r\n    @Override\r\n    public void combine(final SXmlElement element) throws Exception {\r\n        if (!(element instanceof SElementParam)) {\r\n            throw new IllegalArgumentException(\"Invalid argument data!\");\r\n        }\r\n        \r\n        SElementParam elementParam = (SElementParam) element;\r\n        \r\n        if (msName.compareTo(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString()) != 0) {\r\n            throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_NAME + \"' does not match!\");\r\n        }\r\n        \r\n        if (meDataType != SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString())) {\r\n            throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_DATA_TYPE + \"' does not match!\");\r\n        }\r\n        \r\n        if (moValue == null) {\r\n            String defaultValue = elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString();\r\n            if (defaultValue == null || defaultValue.isEmpty()) {\r\n                throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_DEFAULT_VALUE + \"' does not exist for '\" + elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString() + \"'.\");\r\n            }\r\n            else {\r\n                moValue = SReporterUtils.castDataType(meDataType, defaultValue);\r\n            }\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "swaplicado/rbi10", "file": "src/reporter/SReporterParam.java", "last_update_at": "2018-07-19T14:42:54+00:00", "question_id": "98debbf21c6e1a1c1fa8fa8982ad8c30a3ee25b2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SReporterParam extends SUserParam implements SArgumentInterface {\r\n    \r\n    /**\r\n     * Creates a reporter param from user param.\r\n     * @param userParam User param.\r\n     * @throws Exception \r\n     */\r\n    public SReporterParam(final SUserParam userParam) throws Exception {\r\n        super(userParam);\r\n    }\r\n    \r\n    /**\r\n     * Creates a reporter param from XML element param.\r\n     * @param elementParam XML element param.\r\n     * @throws Exception \r\n     */\r\n    public SReporterParam(final SElementParam elementParam) throws Exception {\r\n        super(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString(), \r\n                SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), \r\n                SReporterUtils.castDataType(SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), \r\n                        elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString()));\r\n    }\r\n\r\n    @Override\r\n    public boolean isComplete() {\r\n        return moValue != null;\r\n    }\r\n\r\n    @Override\r\n    public void combine(final SXmlElement element) throws Exception {\r\n        if (!(element instanceof SElementParam)) {\r\n            throw new IllegalArgumentException(\"Invalid argument data!\");\r\n        }\r\n        \r\n        SElementParam elementParam = (SElementParam) element;\r\n        \r\n        if (msName.compareTo(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString()) != 0) {\r\n            throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_NAME + \"' does not match!\");\r\n        }\r\n        \r\n        if (meDataType != SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString())) {\r\n            throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_DATA_TYPE + \"' does not match!\");\r\n        }\r\n        \r\n        if (moValue == null) {\r\n            String defaultValue = elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString();\r\n            if (defaultValue == null || defaultValue.isEmpty()) {\r\n                throw new IllegalArgumentException(\"Attribute '\" + SElementParam.ATTRIB_DEFAULT_VALUE + \"' does not exist for '\" + elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString() + \"'.\");\r\n            }\r\n            else {\r\n                moValue = SReporterUtils.castDataType(meDataType, defaultValue);\r\n            }\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 1.7440403699874878, "ppl_lower": 1.9548817873001099, "ppl/lowercase_ppl": -1.2051857852952321, "ppl/zlib": 0.0009088308384762813, "Min_5.0% Prob": 6.461375561627475, "Min_10.0% Prob": 4.37460048696888, "Min_20.0% Prob": 2.6476733706780333, "Min_30.0% Prob": 1.8333859763928313, "Min_40.0% Prob": 1.3871384461118437, "Min_50.0% Prob": 1.112713000587007, "Min_60.0% Prob": 0.9280875256147226}}
{"hexsha": "cc2369190d41a97affa456090dc24dd8ae5eb6b7", "ext": "java", "lang": "Java", "content": "public  final class Hash extends\n    com.google.protobuf.GeneratedMessageV3 implements\n    // @@protoc_insertion_point(message_implements:opencannabis.crypto.Hash)\n    HashOrBuilder {\nprivate static final long serialVersionUID = 0L;\n  // Use Hash.newBuilder() to construct.\n  private Hash(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n    super(builder);\n  }\n  private Hash() {\n    algorithm_ = 0;\n  }\n\n  @java.lang.Override\n  public final com.google.protobuf.UnknownFieldSet\n  getUnknownFields() {\n    return this.unknownFields;\n  }\n  private Hash(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    this();\n    if (extensionRegistry == null) {\n      throw new java.lang.NullPointerException();\n    }\n    int mutable_bitField0_ = 0;\n    com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n        com.google.protobuf.UnknownFieldSet.newBuilder();\n    try {\n      boolean done = false;\n      while (!done) {\n        int tag = input.readTag();\n        switch (tag) {\n          case 0:\n            done = true;\n            break;\n          case 8: {\n            int rawValue = input.readEnum();\n\n            algorithm_ = rawValue;\n            break;\n          }\n          case 18: {\n            digestCase_ = 2;\n            digest_ = input.readBytes();\n            break;\n          }\n          case 26: {\n            java.lang.String s = input.readStringRequireUtf8();\n            digestCase_ = 3;\n            digest_ = s;\n            break;\n          }\n          case 34: {\n            java.lang.String s = input.readStringRequireUtf8();\n            digestCase_ = 4;\n            digest_ = s;\n            break;\n          }\n          default: {\n            if (!parseUnknownField(\n                input, unknownFields, extensionRegistry, tag)) {\n              done = true;\n            }\n            break;\n          }\n        }\n      }\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n      throw e.setUnfinishedMessage(this);\n    } catch (java.io.IOException e) {\n      throw new com.google.protobuf.InvalidProtocolBufferException(\n          e).setUnfinishedMessage(this);\n    } finally {\n      this.unknownFields = unknownFields.build();\n      makeExtensionsImmutable();\n    }\n  }\n  public static final com.google.protobuf.Descriptors.Descriptor\n      getDescriptor() {\n    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n  }\n\n  @java.lang.Override\n  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internalGetFieldAccessorTable() {\n    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable\n        .ensureFieldAccessorsInitialized(\n            io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);\n  }\n\n  private int digestCase_ = 0;\n  private java.lang.Object digest_;\n  public enum DigestCase\n      implements com.google.protobuf.Internal.EnumLite {\n    RAW(2),\n    HEX(3),\n    B64(4),\n    DIGEST_NOT_SET(0);\n    private final int value;\n    private DigestCase(int value) {\n      this.value = value;\n    }\n    /**\n     * @deprecated Use {@link #forNumber(int)} instead.\n     */\n    @java.lang.Deprecated\n    public static DigestCase valueOf(int value) {\n      return forNumber(value);\n    }\n\n    public static DigestCase forNumber(int value) {\n      switch (value) {\n        case 2: return RAW;\n        case 3: return HEX;\n        case 4: return B64;\n        case 0: return DIGEST_NOT_SET;\n        default: return null;\n      }\n    }\n    public int getNumber() {\n      return this.value;\n    }\n  };\n\n  public DigestCase\n  getDigestCase() {\n    return DigestCase.forNumber(\n        digestCase_);\n  }\n\n  public static final int ALGORITHM_FIELD_NUMBER = 1;\n  private int algorithm_;\n  /**\n   * <pre>\n   * Specifies the algorithm in use.\n   * </pre>\n   *\n   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n   */\n  public int getAlgorithmValue() {\n    return algorithm_;\n  }\n  /**\n   * <pre>\n   * Specifies the algorithm in use.\n   * </pre>\n   *\n   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n   */\n  public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {\n    @SuppressWarnings(\"deprecation\")\n    io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);\n    return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;\n  }\n\n  public static final int RAW_FIELD_NUMBER = 2;\n  /**\n   * <pre>\n   * Raw binary output of the hash algorithm.\n   * </pre>\n   *\n   * <code>bytes raw = 2;</code>\n   */\n  public com.google.protobuf.ByteString getRaw() {\n    if (digestCase_ == 2) {\n      return (com.google.protobuf.ByteString) digest_;\n    }\n    return com.google.protobuf.ByteString.EMPTY;\n  }\n\n  public static final int HEX_FIELD_NUMBER = 3;\n  /**\n   * <pre>\n   * Hex-encoded digest value.\n   * </pre>\n   *\n   * <code>string hex = 3;</code>\n   */\n  public java.lang.String getHex() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 3) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      if (digestCase_ == 3) {\n        digest_ = s;\n      }\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * Hex-encoded digest value.\n   * </pre>\n   *\n   * <code>string hex = 3;</code>\n   */\n  public com.google.protobuf.ByteString\n      getHexBytes() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 3) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      if (digestCase_ == 3) {\n        digest_ = b;\n      }\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n\n  public static final int B64_FIELD_NUMBER = 4;\n  /**\n   * <pre>\n   * Base64-encoded digest value.\n   * </pre>\n   *\n   * <code>string b64 = 4;</code>\n   */\n  public java.lang.String getB64() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 4) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      if (digestCase_ == 4) {\n        digest_ = s;\n      }\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * Base64-encoded digest value.\n   * </pre>\n   *\n   * <code>string b64 = 4;</code>\n   */\n  public com.google.protobuf.ByteString\n      getB64Bytes() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 4) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      if (digestCase_ == 4) {\n        digest_ = b;\n      }\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n\n  private byte memoizedIsInitialized = -1;\n  @java.lang.Override\n  public final boolean isInitialized() {\n    byte isInitialized = memoizedIsInitialized;\n    if (isInitialized == 1) return true;\n    if (isInitialized == 0) return false;\n\n    memoizedIsInitialized = 1;\n    return true;\n  }\n\n  @java.lang.Override\n  public void writeTo(com.google.protobuf.CodedOutputStream output)\n                      throws java.io.IOException {\n    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {\n      output.writeEnum(1, algorithm_);\n    }\n    if (digestCase_ == 2) {\n      output.writeBytes(\n          2, (com.google.protobuf.ByteString) digest_);\n    }\n    if (digestCase_ == 3) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, digest_);\n    }\n    if (digestCase_ == 4) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, digest_);\n    }\n    unknownFields.writeTo(output);\n  }\n\n  @java.lang.Override\n  public int getSerializedSize() {\n    int size = memoizedSize;\n    if (size != -1) return size;\n\n    size = 0;\n    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeEnumSize(1, algorithm_);\n    }\n    if (digestCase_ == 2) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(\n            2, (com.google.protobuf.ByteString) digest_);\n    }\n    if (digestCase_ == 3) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, digest_);\n    }\n    if (digestCase_ == 4) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, digest_);\n    }\n    size += unknownFields.getSerializedSize();\n    memoizedSize = size;\n    return size;\n  }\n\n  @java.lang.Override\n  public boolean equals(final java.lang.Object obj) {\n    if (obj == this) {\n     return true;\n    }\n    if (!(obj instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash)) {\n      return super.equals(obj);\n    }\n    io.opencannabis.schema.crypto.primitives.integrity.Hash other = (io.opencannabis.schema.crypto.primitives.integrity.Hash) obj;\n\n    if (algorithm_ != other.algorithm_) return false;\n    if (!getDigestCase().equals(other.getDigestCase())) return false;\n    switch (digestCase_) {\n      case 2:\n        if (!getRaw()\n            .equals(other.getRaw())) return false;\n        break;\n      case 3:\n        if (!getHex()\n            .equals(other.getHex())) return false;\n        break;\n      case 4:\n        if (!getB64()\n            .equals(other.getB64())) return false;\n        break;\n      case 0:\n      default:\n    }\n    if (!unknownFields.equals(other.unknownFields)) return false;\n    return true;\n  }\n\n  @java.lang.Override\n  public int hashCode() {\n    if (memoizedHashCode != 0) {\n      return memoizedHashCode;\n    }\n    int hash = 41;\n    hash = (19 * hash) + getDescriptor().hashCode();\n    hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;\n    hash = (53 * hash) + algorithm_;\n    switch (digestCase_) {\n      case 2:\n        hash = (37 * hash) + RAW_FIELD_NUMBER;\n        hash = (53 * hash) + getRaw().hashCode();\n        break;\n      case 3:\n        hash = (37 * hash) + HEX_FIELD_NUMBER;\n        hash = (53 * hash) + getHex().hashCode();\n        break;\n      case 4:\n        hash = (37 * hash) + B64_FIELD_NUMBER;\n        hash = (53 * hash) + getB64().hashCode();\n        break;\n      case 0:\n      default:\n    }\n    hash = (29 * hash) + unknownFields.hashCode();\n    memoizedHashCode = hash;\n    return hash;\n  }\n\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.nio.ByteBuffer data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.nio.ByteBuffer data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.ByteString data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.ByteString data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(byte[] data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      byte[] data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.CodedInputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n\n  @java.lang.Override\n  public Builder newBuilderForType() { return newBuilder(); }\n  public static Builder newBuilder() {\n    return DEFAULT_INSTANCE.toBuilder();\n  }\n  public static Builder newBuilder(io.opencannabis.schema.crypto.primitives.integrity.Hash prototype) {\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n  }\n  @java.lang.Override\n  public Builder toBuilder() {\n    return this == DEFAULT_INSTANCE\n        ? new Builder() : new Builder().mergeFrom(this);\n  }\n\n  @java.lang.Override\n  protected Builder newBuilderForType(\n      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n    Builder builder = new Builder(parent);\n    return builder;\n  }\n  /**\n   * <pre>\n   * Specifies the hash portion of hashed data, along with the algorithm used to calculate the digest enclosed. This\n   * particular container does not specify or otherwise contain the original referenced data.\n   * </pre>\n   *\n   * Protobuf type {@code opencannabis.crypto.Hash}\n   */\n  public static final class Builder extends\n      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n      // @@protoc_insertion_point(builder_implements:opencannabis.crypto.Hash)\n      io.opencannabis.schema.crypto.primitives.integrity.HashOrBuilder {\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);\n    }\n\n    // Construct using io.opencannabis.schema.crypto.primitives.integrity.Hash.newBuilder()\n    private Builder() {\n      maybeForceBuilderInitialization();\n    }\n\n    private Builder(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      super(parent);\n      maybeForceBuilderInitialization();\n    }\n    private void maybeForceBuilderInitialization() {\n      if (com.google.protobuf.GeneratedMessageV3\n              .alwaysUseFieldBuilders) {\n      }\n    }\n    @java.lang.Override\n    public Builder clear() {\n      super.clear();\n      algorithm_ = 0;\n\n      digestCase_ = 0;\n      digest_ = null;\n      return this;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.Descriptor\n        getDescriptorForType() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance();\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash build() {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash result = buildPartial();\n      if (!result.isInitialized()) {\n        throw newUninitializedMessageException(result);\n      }\n      return result;\n    }\n\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash buildPartial() {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash result = new io.opencannabis.schema.crypto.primitives.integrity.Hash(this);\n      result.algorithm_ = algorithm_;\n      if (digestCase_ == 2) {\n        result.digest_ = digest_;\n      }\n      if (digestCase_ == 3) {\n        result.digest_ = digest_;\n      }\n      if (digestCase_ == 4) {\n        result.digest_ = digest_;\n      }\n      result.digestCase_ = digestCase_;\n      onBuilt();\n      return result;\n    }\n\n    @java.lang.Override\n    public Builder clone() {\n      return super.clone();\n    }\n    @java.lang.Override\n    public Builder setField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.setField(field, value);\n    }\n    @java.lang.Override\n    public Builder clearField(\n        com.google.protobuf.Descriptors.FieldDescriptor field) {\n      return super.clearField(field);\n    }\n    @java.lang.Override\n    public Builder clearOneof(\n        com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n      return super.clearOneof(oneof);\n    }\n    @java.lang.Override\n    public Builder setRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        int index, java.lang.Object value) {\n      return super.setRepeatedField(field, index, value);\n    }\n    @java.lang.Override\n    public Builder addRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.addRepeatedField(field, value);\n    }\n    @java.lang.Override\n    public Builder mergeFrom(com.google.protobuf.Message other) {\n      if (other instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash) {\n        return mergeFrom((io.opencannabis.schema.crypto.primitives.integrity.Hash)other);\n      } else {\n        super.mergeFrom(other);\n        return this;\n      }\n    }\n\n    public Builder mergeFrom(io.opencannabis.schema.crypto.primitives.integrity.Hash other) {\n      if (other == io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance()) return this;\n      if (other.algorithm_ != 0) {\n        setAlgorithmValue(other.getAlgorithmValue());\n      }\n      switch (other.getDigestCase()) {\n        case RAW: {\n          setRaw(other.getRaw());\n          break;\n        }\n        case HEX: {\n          digestCase_ = 3;\n          digest_ = other.digest_;\n          onChanged();\n          break;\n        }\n        case B64: {\n          digestCase_ = 4;\n          digest_ = other.digest_;\n          onChanged();\n          break;\n        }\n        case DIGEST_NOT_SET: {\n          break;\n        }\n      }\n      this.mergeUnknownFields(other.unknownFields);\n      onChanged();\n      return this;\n    }\n\n    @java.lang.Override\n    public final boolean isInitialized() {\n      return true;\n    }\n\n    @java.lang.Override\n    public Builder mergeFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash parsedMessage = null;\n      try {\n        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        parsedMessage = (io.opencannabis.schema.crypto.primitives.integrity.Hash) e.getUnfinishedMessage();\n        throw e.unwrapIOException();\n      } finally {\n        if (parsedMessage != null) {\n          mergeFrom(parsedMessage);\n        }\n      }\n      return this;\n    }\n    private int digestCase_ = 0;\n    private java.lang.Object digest_;\n    public DigestCase\n        getDigestCase() {\n      return DigestCase.forNumber(\n          digestCase_);\n    }\n\n    public Builder clearDigest() {\n      digestCase_ = 0;\n      digest_ = null;\n      onChanged();\n      return this;\n    }\n\n\n    private int algorithm_ = 0;\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public int getAlgorithmValue() {\n      return algorithm_;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder setAlgorithmValue(int value) {\n      algorithm_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {\n      @SuppressWarnings(\"deprecation\")\n      io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);\n      return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder setAlgorithm(io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm value) {\n      if (value == null) {\n        throw new NullPointerException();\n      }\n      \n      algorithm_ = value.getNumber();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder clearAlgorithm() {\n      \n      algorithm_ = 0;\n      onChanged();\n      return this;\n    }\n\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public com.google.protobuf.ByteString getRaw() {\n      if (digestCase_ == 2) {\n        return (com.google.protobuf.ByteString) digest_;\n      }\n      return com.google.protobuf.ByteString.EMPTY;\n    }\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public Builder setRaw(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 2;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public Builder clearRaw() {\n      if (digestCase_ == 2) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public java.lang.String getHex() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 3) {\n        ref = digest_;\n      }\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        if (digestCase_ == 3) {\n          digest_ = s;\n        }\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public com.google.protobuf.ByteString\n        getHexBytes() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 3) {\n        ref = digest_;\n      }\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        if (digestCase_ == 3) {\n          digest_ = b;\n        }\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder setHex(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 3;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder clearHex() {\n      if (digestCase_ == 3) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder setHexBytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      digestCase_ = 3;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public java.lang.String getB64() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 4) {\n        ref = digest_;\n      }\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        if (digestCase_ == 4) {\n          digest_ = s;\n        }\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public com.google.protobuf.ByteString\n        getB64Bytes() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 4) {\n        ref = digest_;\n      }\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        if (digestCase_ == 4) {\n          digest_ = b;\n        }\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder setB64(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 4;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder clearB64() {\n      if (digestCase_ == 4) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder setB64Bytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      digestCase_ = 4;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final Builder setUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.setUnknownFields(unknownFields);\n    }\n\n    @java.lang.Override\n    public final Builder mergeUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.mergeUnknownFields(unknownFields);\n    }\n\n\n    // @@protoc_insertion_point(builder_scope:opencannabis.crypto.Hash)\n  }\n\n  // @@protoc_insertion_point(class_scope:opencannabis.crypto.Hash)\n  private static final io.opencannabis.schema.crypto.primitives.integrity.Hash DEFAULT_INSTANCE;\n  static {\n    DEFAULT_INSTANCE = new io.opencannabis.schema.crypto.primitives.integrity.Hash();\n  }\n\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstance() {\n    return DEFAULT_INSTANCE;\n  }\n\n  private static final com.google.protobuf.Parser<Hash>\n      PARSER = new com.google.protobuf.AbstractParser<Hash>() {\n    @java.lang.Override\n    public Hash parsePartialFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return new Hash(input, extensionRegistry);\n    }\n  };\n\n  public static com.google.protobuf.Parser<Hash> parser() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public com.google.protobuf.Parser<Hash> getParserForType() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {\n    return DEFAULT_INSTANCE;\n  }\n\n}", "class_id": 0, "repo": "Bloombox/Java", "file": "src/main/java/io/opencannabis/schema/crypto/primitives/integrity/Hash.java", "last_update_at": "2018-05-26T05:29:46+00:00", "question_id": "cc2369190d41a97affa456090dc24dd8ae5eb6b7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public  final class Hash extends\n    com.google.protobuf.GeneratedMessageV3 implements\n    // @@protoc_insertion_point(message_implements:opencannabis.crypto.Hash)\n    HashOrBuilder {\nprivate static final long serialVersionUID = 0L;\n  // Use Hash.newBuilder() to construct.\n  private Hash(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n    super(builder);\n  }\n  private Hash() {\n    algorithm_ = 0;\n  }\n  @java.lang.Override\n  public final com.google.protobuf.UnknownFieldSet\n  getUnknownFields() {\n    return this.unknownFields;\n  }\n  private Hash(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    this();\n    if (extensionRegistry == null) {\n      throw new java.lang.NullPointerException();\n    }\n    int mutable_bitField0_ = 0;\n    com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n        com.google.protobuf.UnknownFieldSet.newBuilder();\n    try {\n      boolean done = false;\n      while (!done) {\n        int tag = input.readTag();\n        switch (tag) {\n          case 0:\n            done = true;\n            break;\n          case 8: {\n            int rawValue = input.readEnum();\n            algorithm_ = rawValue;\n            break;\n          }\n          case 18: {\n            digestCase_ = 2;\n            digest_ = input.readBytes();\n            break;\n          }\n          case 26: {\n            java.lang.String s = input.readStringRequireUtf8();\n            digestCase_ = 3;\n            digest_ = s;\n            break;\n          }\n          case 34: {\n            java.lang.String s = input.readStringRequireUtf8();\n            digestCase_ = 4;\n            digest_ = s;\n            break;\n          }\n          default: {\n            if (!parseUnknownField(\n                input, unknownFields, extensionRegistry, tag)) {\n              done = true;\n            }\n            break;\n          }\n        }\n      }\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n      throw e.setUnfinishedMessage(this);\n    } catch (java.io.IOException e) {\n      throw new com.google.protobuf.InvalidProtocolBufferException(\n          e).setUnfinishedMessage(this);\n    } finally {\n      this.unknownFields = unknownFields.build();\n      makeExtensionsImmutable();\n    }\n  }\n  public static final com.google.protobuf.Descriptors.Descriptor\n      getDescriptor() {\n    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n  }\n  @java.lang.Override\n  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internalGetFieldAccessorTable() {\n    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable\n        .ensureFieldAccessorsInitialized(\n            io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);\n  }\n  private int digestCase_ = 0;\n  private java.lang.Object digest_;\n  public enum DigestCase\n      implements com.google.protobuf.Internal.EnumLite {\n    RAW(2),\n    HEX(3),\n    B64(4),\n    DIGEST_NOT_SET(0);\n    private final int value;\n    private DigestCase(int value) {\n      this.value = value;\n    }\n    /**\n     * @deprecated Use {@link #forNumber(int)} instead.\n     */\n    @java.lang.Deprecated\n    public static DigestCase valueOf(int value) {\n      return forNumber(value);\n    }\n    public static DigestCase forNumber(int value) {\n      switch (value) {\n        case 2: return RAW;\n        case 3: return HEX;\n        case 4: return B64;\n        case 0: return DIGEST_NOT_SET;\n        default: return null;\n      }\n    }\n    public int getNumber() {\n      return this.value;\n    }\n  };\n  public DigestCase\n  getDigestCase() {\n    return DigestCase.forNumber(\n        digestCase_);\n  }\n  public static final int ALGORITHM_FIELD_NUMBER = 1;\n  private int algorithm_;\n  /**\n   * <pre>\n   * Specifies the algorithm in use.\n   * </pre>\n   *\n   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n   */\n  public int getAlgorithmValue() {\n    return algorithm_;\n  }\n  /**\n   * <pre>\n   * Specifies the algorithm in use.\n   * </pre>\n   *\n   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n   */\n  public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {\n    @SuppressWarnings(\"deprecation\")\n    io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);\n    return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;\n  }\n  public static final int RAW_FIELD_NUMBER = 2;\n  /**\n   * <pre>\n   * Raw binary output of the hash algorithm.\n   * </pre>\n   *\n   * <code>bytes raw = 2;</code>\n   */\n  public com.google.protobuf.ByteString getRaw() {\n    if (digestCase_ == 2) {\n      return (com.google.protobuf.ByteString) digest_;\n    }\n    return com.google.protobuf.ByteString.EMPTY;\n  }\n  public static final int HEX_FIELD_NUMBER = 3;\n  /**\n   * <pre>\n   * Hex-encoded digest value.\n   * </pre>\n   *\n   * <code>string hex = 3;</code>\n   */\n  public java.lang.String getHex() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 3) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      if (digestCase_ == 3) {\n        digest_ = s;\n      }\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * Hex-encoded digest value.\n   * </pre>\n   *\n   * <code>string hex = 3;</code>\n   */\n  public com.google.protobuf.ByteString\n      getHexBytes() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 3) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      if (digestCase_ == 3) {\n        digest_ = b;\n      }\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n  public static final int B64_FIELD_NUMBER = 4;\n  /**\n   * <pre>\n   * Base64-encoded digest value.\n   * </pre>\n   *\n   * <code>string b64 = 4;</code>\n   */\n  public java.lang.String getB64() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 4) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      return (java.lang.String) ref;\n    } else {\n      com.google.protobuf.ByteString bs = \n          (com.google.protobuf.ByteString) ref;\n      java.lang.String s = bs.toStringUtf8();\n      if (digestCase_ == 4) {\n        digest_ = s;\n      }\n      return s;\n    }\n  }\n  /**\n   * <pre>\n   * Base64-encoded digest value.\n   * </pre>\n   *\n   * <code>string b64 = 4;</code>\n   */\n  public com.google.protobuf.ByteString\n      getB64Bytes() {\n    java.lang.Object ref = \"\";\n    if (digestCase_ == 4) {\n      ref = digest_;\n    }\n    if (ref instanceof java.lang.String) {\n      com.google.protobuf.ByteString b = \n          com.google.protobuf.ByteString.copyFromUtf8(\n              (java.lang.String) ref);\n      if (digestCase_ == 4) {\n        digest_ = b;\n      }\n      return b;\n    } else {\n      return (com.google.protobuf.ByteString) ref;\n    }\n  }\n  private byte memoizedIsInitialized = -1;\n  @java.lang.Override\n  public final boolean isInitialized() {\n    byte isInitialized = memoizedIsInitialized;\n    if (isInitialized == 1) return true;\n    if (isInitialized == 0) return false;\n    memoizedIsInitialized = 1;\n    return true;\n  }\n  @java.lang.Override\n  public void writeTo(com.google.protobuf.CodedOutputStream output)\n                      throws java.io.IOException {\n    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {\n      output.writeEnum(1, algorithm_);\n    }\n    if (digestCase_ == 2) {\n      output.writeBytes(\n          2, (com.google.protobuf.ByteString) digest_);\n    }\n    if (digestCase_ == 3) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, digest_);\n    }\n    if (digestCase_ == 4) {\n      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, digest_);\n    }\n    unknownFields.writeTo(output);\n  }\n  @java.lang.Override\n  public int getSerializedSize() {\n    int size = memoizedSize;\n    if (size != -1) return size;\n    size = 0;\n    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeEnumSize(1, algorithm_);\n    }\n    if (digestCase_ == 2) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(\n            2, (com.google.protobuf.ByteString) digest_);\n    }\n    if (digestCase_ == 3) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, digest_);\n    }\n    if (digestCase_ == 4) {\n      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, digest_);\n    }\n    size += unknownFields.getSerializedSize();\n    memoizedSize = size;\n    return size;\n  }\n  @java.lang.Override\n  public boolean equals(final java.lang.Object obj) {\n    if (obj == this) {\n     return true;\n    }\n    if (!(obj instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash)) {\n      return super.equals(obj);\n    }\n    io.opencannabis.schema.crypto.primitives.integrity.Hash other = (io.opencannabis.schema.crypto.primitives.integrity.Hash) obj;\n    if (algorithm_ != other.algorithm_) return false;\n    if (!getDigestCase().equals(other.getDigestCase())) return false;\n    switch (digestCase_) {\n      case 2:\n        if (!getRaw()\n            .equals(other.getRaw())) return false;\n        break;\n      case 3:\n        if (!getHex()\n            .equals(other.getHex())) return false;\n        break;\n      case 4:\n        if (!getB64()\n            .equals(other.getB64())) return false;\n        break;\n      case 0:\n      default:\n    }\n    if (!unknownFields.equals(other.unknownFields)) return false;\n    return true;\n  }\n  @java.lang.Override\n  public int hashCode() {\n    if (memoizedHashCode != 0) {\n      return memoizedHashCode;\n    }\n    int hash = 41;\n    hash = (19 * hash) + getDescriptor().hashCode();\n    hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;\n    hash = (53 * hash) + algorithm_;\n    switch (digestCase_) {\n      case 2:\n        hash = (37 * hash) + RAW_FIELD_NUMBER;\n        hash = (53 * hash) + getRaw().hashCode();\n        break;\n      case 3:\n        hash = (37 * hash) + HEX_FIELD_NUMBER;\n        hash = (53 * hash) + getHex().hashCode();\n        break;\n      case 4:\n        hash = (37 * hash) + B64_FIELD_NUMBER;\n        hash = (53 * hash) + getB64().hashCode();\n        break;\n      case 0:\n      default:\n    }\n    hash = (29 * hash) + unknownFields.hashCode();\n    memoizedHashCode = hash;\n    return hash;\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.nio.ByteBuffer data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.nio.ByteBuffer data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.ByteString data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.ByteString data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(byte[] data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      byte[] data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.CodedInputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  @java.lang.Override\n  public Builder newBuilderForType() { return newBuilder(); }\n  public static Builder newBuilder() {\n    return DEFAULT_INSTANCE.toBuilder();\n  }\n  public static Builder newBuilder(io.opencannabis.schema.crypto.primitives.integrity.Hash prototype) {\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n  }\n  @java.lang.Override\n  public Builder toBuilder() {\n    return this == DEFAULT_INSTANCE\n        ? new Builder() : new Builder().mergeFrom(this);\n  }\n  @java.lang.Override\n  protected Builder newBuilderForType(\n      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n    Builder builder = new Builder(parent);\n    return builder;\n  }\n  /**\n   * <pre>\n   * Specifies the hash portion of hashed data, along with the algorithm used to calculate the digest enclosed. This\n   * particular container does not specify or otherwise contain the original referenced data.\n   * </pre>\n   *\n   * Protobuf type {@code opencannabis.crypto.Hash}\n   */\n  public static final class Builder extends\n      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n      // @@protoc_insertion_point(builder_implements:opencannabis.crypto.Hash)\n      io.opencannabis.schema.crypto.primitives.integrity.HashOrBuilder {\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n    }\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);\n    }\n    // Construct using io.opencannabis.schema.crypto.primitives.integrity.Hash.newBuilder()\n    private Builder() {\n      maybeForceBuilderInitialization();\n    }\n    private Builder(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      super(parent);\n      maybeForceBuilderInitialization();\n    }\n    private void maybeForceBuilderInitialization() {\n      if (com.google.protobuf.GeneratedMessageV3\n              .alwaysUseFieldBuilders) {\n      }\n    }\n    @java.lang.Override\n    public Builder clear() {\n      super.clear();\n      algorithm_ = 0;\n      digestCase_ = 0;\n      digest_ = null;\n      return this;\n    }\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.Descriptor\n        getDescriptorForType() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {\n      return io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance();\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash build() {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash result = buildPartial();\n      if (!result.isInitialized()) {\n        throw newUninitializedMessageException(result);\n      }\n      return result;\n    }\n    @java.lang.Override\n    public io.opencannabis.schema.crypto.primitives.integrity.Hash buildPartial() {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash result = new io.opencannabis.schema.crypto.primitives.integrity.Hash(this);\n      result.algorithm_ = algorithm_;\n      if (digestCase_ == 2) {\n        result.digest_ = digest_;\n      }\n      if (digestCase_ == 3) {\n        result.digest_ = digest_;\n      }\n      if (digestCase_ == 4) {\n        result.digest_ = digest_;\n      }\n      result.digestCase_ = digestCase_;\n      onBuilt();\n      return result;\n    }\n    @java.lang.Override\n    public Builder clone() {\n      return super.clone();\n    }\n    @java.lang.Override\n    public Builder setField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.setField(field, value);\n    }\n    @java.lang.Override\n    public Builder clearField(\n        com.google.protobuf.Descriptors.FieldDescriptor field) {\n      return super.clearField(field);\n    }\n    @java.lang.Override\n    public Builder clearOneof(\n        com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n      return super.clearOneof(oneof);\n    }\n    @java.lang.Override\n    public Builder setRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        int index, java.lang.Object value) {\n      return super.setRepeatedField(field, index, value);\n    }\n    @java.lang.Override\n    public Builder addRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.addRepeatedField(field, value);\n    }\n    @java.lang.Override\n    public Builder mergeFrom(com.google.protobuf.Message other) {\n      if (other instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash) {\n        return mergeFrom((io.opencannabis.schema.crypto.primitives.integrity.Hash)other);\n      } else {\n        super.mergeFrom(other);\n        return this;\n      }\n    }\n    public Builder mergeFrom(io.opencannabis.schema.crypto.primitives.integrity.Hash other) {\n      if (other == io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance()) return this;\n      if (other.algorithm_ != 0) {\n        setAlgorithmValue(other.getAlgorithmValue());\n      }\n      switch (other.getDigestCase()) {\n        case RAW: {\n          setRaw(other.getRaw());\n          break;\n        }\n        case HEX: {\n          digestCase_ = 3;\n          digest_ = other.digest_;\n          onChanged();\n          break;\n        }\n        case B64: {\n          digestCase_ = 4;\n          digest_ = other.digest_;\n          onChanged();\n          break;\n        }\n        case DIGEST_NOT_SET: {\n          break;\n        }\n      }\n      this.mergeUnknownFields(other.unknownFields);\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final boolean isInitialized() {\n      return true;\n    }\n    @java.lang.Override\n    public Builder mergeFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      io.opencannabis.schema.crypto.primitives.integrity.Hash parsedMessage = null;\n      try {\n        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        parsedMessage = (io.opencannabis.schema.crypto.primitives.integrity.Hash) e.getUnfinishedMessage();\n        throw e.unwrapIOException();\n      } finally {\n        if (parsedMessage != null) {\n          mergeFrom(parsedMessage);\n        }\n      }\n      return this;\n    }\n    private int digestCase_ = 0;\n    private java.lang.Object digest_;\n    public DigestCase\n        getDigestCase() {\n      return DigestCase.forNumber(\n          digestCase_);\n    }\n    public Builder clearDigest() {\n      digestCase_ = 0;\n      digest_ = null;\n      onChanged();\n      return this;\n    }\n    private int algorithm_ = 0;\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public int getAlgorithmValue() {\n      return algorithm_;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder setAlgorithmValue(int value) {\n      algorithm_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {\n      @SuppressWarnings(\"deprecation\")\n      io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);\n      return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder setAlgorithm(io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm value) {\n      if (value == null) {\n        throw new NullPointerException();\n      }\n      algorithm_ = value.getNumber();\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Specifies the algorithm in use.\n     * </pre>\n     *\n     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>\n     */\n    public Builder clearAlgorithm() {\n      algorithm_ = 0;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public com.google.protobuf.ByteString getRaw() {\n      if (digestCase_ == 2) {\n        return (com.google.protobuf.ByteString) digest_;\n      }\n      return com.google.protobuf.ByteString.EMPTY;\n    }\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public Builder setRaw(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 2;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Raw binary output of the hash algorithm.\n     * </pre>\n     *\n     * <code>bytes raw = 2;</code>\n     */\n    public Builder clearRaw() {\n      if (digestCase_ == 2) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public java.lang.String getHex() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 3) {\n        ref = digest_;\n      }\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        if (digestCase_ == 3) {\n          digest_ = s;\n        }\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public com.google.protobuf.ByteString\n        getHexBytes() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 3) {\n        ref = digest_;\n      }\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        if (digestCase_ == 3) {\n          digest_ = b;\n        }\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder setHex(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 3;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder clearHex() {\n      if (digestCase_ == 3) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n    /**\n     * <pre>\n     * Hex-encoded digest value.\n     * </pre>\n     *\n     * <code>string hex = 3;</code>\n     */\n    public Builder setHexBytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      digestCase_ = 3;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public java.lang.String getB64() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 4) {\n        ref = digest_;\n      }\n      if (!(ref instanceof java.lang.String)) {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        java.lang.String s = bs.toStringUtf8();\n        if (digestCase_ == 4) {\n          digest_ = s;\n        }\n        return s;\n      } else {\n        return (java.lang.String) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public com.google.protobuf.ByteString\n        getB64Bytes() {\n      java.lang.Object ref = \"\";\n      if (digestCase_ == 4) {\n        ref = digest_;\n      }\n      if (ref instanceof String) {\n        com.google.protobuf.ByteString b = \n            com.google.protobuf.ByteString.copyFromUtf8(\n                (java.lang.String) ref);\n        if (digestCase_ == 4) {\n          digest_ = b;\n        }\n        return b;\n      } else {\n        return (com.google.protobuf.ByteString) ref;\n      }\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder setB64(\n        java.lang.String value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  digestCase_ = 4;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder clearB64() {\n      if (digestCase_ == 4) {\n        digestCase_ = 0;\n        digest_ = null;\n        onChanged();\n      }\n      return this;\n    }\n    /**\n     * <pre>\n     * Base64-encoded digest value.\n     * </pre>\n     *\n     * <code>string b64 = 4;</code>\n     */\n    public Builder setB64Bytes(\n        com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n      digestCase_ = 4;\n      digest_ = value;\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final Builder setUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.setUnknownFields(unknownFields);\n    }\n    @java.lang.Override\n    public final Builder mergeUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.mergeUnknownFields(unknownFields);\n    }\n    // @@protoc_insertion_point(builder_scope:opencannabis.crypto.Hash)\n  }\n  // @@protoc_insertion_point(class_scope:opencannabis.crypto.Hash)\n  private static final io.opencannabis.schema.crypto.primitives.integrity.Hash DEFAULT_INSTANCE;\n  static {\n    DEFAULT_INSTANCE = new io.opencannabis.schema.crypto.primitives.integrity.Hash();\n  }\n  public static io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstance() {\n    return DEFAULT_INSTANCE;\n  }\n  private static final com.google.protobuf.Parser<Hash>\n      PARSER = new com.google.protobuf.AbstractParser<Hash>() {\n    @java.lang.Override\n    public Hash parsePartialFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return new Hash(input, extensionRegistry);\n    }\n  };\n  public static com.google.protobuf.Parser<Hash> parser() {\n    return PARSER;\n  }\n  @java.lang.Override\n  public com.google.protobuf.Parser<Hash> getParserForType() {\n    return PARSER;\n  }\n  @java.lang.Override\n  public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {\n    return DEFAULT_INSTANCE;\n  }\n"]], "pred": {"ppl": 1.0754940509796143, "ppl_lower": 1.3167322874069214, "ppl/lowercase_ppl": -3.780607373477506, "ppl/zlib": 1.7303884524641377e-05, "Min_5.0% Prob": 1.4550578486466526, "Min_10.0% Prob": 0.7297882485487636, "Min_20.0% Prob": 0.3649559495193613, "Min_30.0% Prob": 0.24331013322042505, "Min_40.0% Prob": 0.18203812501356514, "Min_50.0% Prob": 0.14570238141377898, "Min_60.0% Prob": 0.12145849794164448}}
{"hexsha": "fa98542eb2cf1a97f76954f575041a15a89d52de", "ext": "java", "lang": "Java", "content": "public class Score implements Comparable<Score> {\r\n\r\n\tprivate double score;\r\n\tprivate SemanticTrajectory t;\r\n\r\n\tpublic Score(double score, SemanticTrajectory t) {\r\n\t\tthis.score = score;\r\n\t\tthis.setTrajectory(t);\r\n\t}\r\n\r\n\tpublic double getScore() {\r\n\t\treturn this.score;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int compareTo(Score score2) {\r\n\t\tif (this.score < score2.getScore()) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (this.score > score2.getScore()) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tpublic SemanticTrajectory getTrajectory() {\r\n\t\treturn t;\r\n\t}\r\n\r\n\tpublic void setTrajectory(SemanticTrajectory t) {\r\n\t\tthis.t = t;\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "lehmann/ArtigoMSM_UFSC", "file": "artigo/src/main/java/br/ufsc/ftsm/Score.java", "last_update_at": "2018-11-07T06:32:50+00:00", "question_id": "fa98542eb2cf1a97f76954f575041a15a89d52de", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Score implements Comparable<Score> {\r\n\r\n\tprivate double score;\r\n\tprivate SemanticTrajectory t;\r\n\r\n\tpublic Score(double score, SemanticTrajectory t) {\r\n\t\tthis.score = score;\r\n\t\tthis.setTrajectory(t);\r\n\t}\r\n\r\n\tpublic double getScore() {\r\n\t\treturn this.score;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int compareTo(Score score2) {\r\n\t\tif (this.score < score2.getScore()) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tif (this.score > score2.getScore()) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tpublic SemanticTrajectory getTrajectory() {\r\n\t\treturn t;\r\n\t}\r\n\r\n\tpublic void setTrajectory(SemanticTrajectory t) {\r\n\t\tthis.t = t;\r\n\t}\r\n\r\n"]], "pred": {"ppl": 1.437844157218933, "ppl_lower": 1.6639807224273682, "ppl/lowercase_ppl": -1.40223031370342, "ppl/zlib": 0.0015387494862372736, "Min_5.0% Prob": 5.079000386324796, "Min_10.0% Prob": 3.2708821633587712, "Min_20.0% Prob": 1.8022029225496536, "Min_30.0% Prob": 1.2121845203858446, "Min_40.0% Prob": 0.9084763958658043, "Min_50.0% Prob": 0.7259323869874904, "Min_60.0% Prob": 0.608547656582898}}
{"hexsha": "52e2a64bbe42dbbf2abcec5408ef604a3081114b", "ext": "java", "lang": "Java", "content": "@edu.umd.cs.findbugs.annotations.SuppressWarnings(\n        value=\"RV_RETURN_VALUE_IGNORED\", \n        justification=\"Designed to ignore.\")\n\npublic class DynamicFamilyIT extends BaseHBaseManagedTimeTableReuseIT {\n    private static final String WEB_STATS = generateRandomString();\n    private static final String WEB_STATS_SCHEMA_NAME = \"\";\n    private static final byte[] A_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier(\"A\"));\n    private static final byte[] B_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier(\"B\"));\n    private static final String USER_ID1 = \"u0001\";\n    private static final String USER_ID2 = \"u0002\";\n    private static final String USER_ID3 = \"u0003\";\n    private static final byte[] USER_ID1_BYTES = Bytes.toBytes(USER_ID1);\n    private static final byte[] USER_ID2_BYTES = Bytes.toBytes(USER_ID2);\n    private static final byte[] USER_ID3_BYTES = Bytes.toBytes(USER_ID3);\n    \n    private static final String MAX_CLICK_COUNT_PREFIX = SchemaUtil.normalizeIdentifier(\"MaxClickCount_\");\n    private static final byte[] MAX_CLICK_COUNT_DYNCOL_PREFIX = Bytes.toBytes(MAX_CLICK_COUNT_PREFIX);\n    private static final Integer ENTRY1_CLICK_COUNT = 12;\n    private static final Integer ENTRY2_CLICK_COUNT = 34;\n    private static final Integer ENTRY3_CLICK_COUNT = 56;\n    \n    private static final String LAST_LOGIN_TIME_PREFIX = SchemaUtil.normalizeIdentifier(\"LastLoginTime_\");\n    private static final byte[] LAST_LOGIN_TIME_DYNCOL_PREFIX = Bytes.toBytes(LAST_LOGIN_TIME_PREFIX);\n    \n    private static final Time ENTRY1_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+60000);\n    private static final Time ENTRY1_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+120000);\n    \n    private static final Time ENTRY2_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+180000);\n    private static final Time ENTRY2_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+240000);\n    \n    private static final Time ENTRY3_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+300000);\n    private static final Time ENTRY3_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+360000);\n    private static final Time ENTRY3_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+420000);\n\n    @Before\n    public void doBeforeTestSetup() throws Exception {\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(getUrl(), props);\n        String ddl = \"create table if not exists  \" + WEB_STATS\n                + \"   (entry varchar not null primary key,\"\n                + \"    a.dummy varchar,\" \n                + \"    b.dummy varchar)\";\n        conn.createStatement().execute(ddl);\n        conn.close();\n        initTableValues();\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private static void initTableValues() throws Exception {\n        ConnectionQueryServices services = driver.getConnectionQueryServices(getUrl(), PropertiesUtil.deepCopy(TEST_PROPERTIES));\n        HTableInterface hTable = services.getTable(SchemaUtil.getTableNameAsBytes(WEB_STATS_SCHEMA_NAME,WEB_STATS));\n        try {\n            // Insert rows using standard HBase mechanism with standard HBase \"types\"\n            Put put;\n            List<Row> mutations = new ArrayList<Row>();\n            put = new Put(Bytes.toBytes(\"entry1\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID2_BYTES), PInteger.INSTANCE.toBytes(ENTRY1_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID1_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID2_LOGIN_TIME));\n            mutations.add(put);\n            \n            put = new Put(Bytes.toBytes(\"entry2\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID3_BYTES), PInteger.INSTANCE.toBytes(ENTRY2_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID2_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID3_LOGIN_TIME));\n            mutations.add(put);\n            \n            put = new Put(Bytes.toBytes(\"entry3\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID1_BYTES), PInteger.INSTANCE.toBytes(ENTRY3_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID1_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID2_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID3_LOGIN_TIME));\n            mutations.add(put);\n\n            hTable.batch(mutations);\n\n        } finally {\n            hTable.close();\n        }\n    }\n\n    private static Pair<String,Integer> getMaxClickCountValue(ResultSet rs) throws SQLException {\n        ResultSetMetaData rsmd = rs.getMetaData();\n        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n            String colName = rsmd.getColumnName(i);\n            if (colName.startsWith(MAX_CLICK_COUNT_PREFIX)) {\n                String userId = colName.substring(MAX_CLICK_COUNT_PREFIX.length());\n                Integer clickCount = rs.getInt(colName);\n                return new Pair<String,Integer>(userId,clickCount);\n            }\n        }\n        return null;\n    }\n    \n    private static Time getLastLoginTimeValue(ResultSet rs, String userId) throws SQLException {\n        String colName = LAST_LOGIN_TIME_PREFIX + userId;\n        try {\n            return rs.getTime(colName);\n        } catch (SQLException e) {\n            // Ignore COLUMN_NOT_FOUND error b/c it means that this user didn't login\n            if (e.getErrorCode() == SQLExceptionCode.COLUMN_NOT_FOUND.getErrorCode()) {\n                return null;\n            }\n            throw e;\n        }\n    }\n    \n    /**\n     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,\n     * since it is a wildcard.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testGetAllDynColsInFamily() throws Exception {\n        String query = \"SELECT A.* FROM \" + WEB_STATS + \" WHERE entry='entry1'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);\n            // This fails for two reasons: 1) all column qualifiers in column family A\n            // are not returned in the result, and 2) the dynamic columns are not available\n            // through ResultSetMetaData.\n            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());\n            \n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,\n     * since it is a wildcard.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testGetAllDynCols() throws Exception {\n        String query = \"SELECT * FROM \" + WEB_STATS + \"WHERE entry='entry1'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);\n            // This fails because the dynamic columns are not available through ResultSetMetaData\n            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());\n            \n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Since the dynamic columns are not in double quotes, the column name is normalized by being upper cased.\n     * In this case, since USER_ID is case sensitive, it will not find the columns\n     */\n    @Test\n    public void testGetCaseInsensitiveDynCol() throws Exception {\n        String query = \"SELECT B.* FROM \"+ WEB_STATS+ \"(\" +\n                \"B.\" + LAST_LOGIN_TIME_PREFIX + USER_ID2 + \" TIME,\" + \n                \"B.\" + LAST_LOGIN_TIME_PREFIX + USER_ID3 + \" TIME) WHERE entry='entry2'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID2));\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID3));\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID1));\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * Since dynamic columns are not in double quotes, the column name is not normalized, but instead\n     * is left as is. This should succeed, since the user ID case is matched\n     */\n    // FIXME @Test\n    public void testGetCaseSensitiveDynCol() throws Exception {\n        String query = \"SELECT B.* FROM \"+WEB_STATS +\"(\" +\n                \"B.\\\"\" + LAST_LOGIN_TIME_PREFIX + USER_ID2 + \"\\\"\" + \" TIME,\" + \n                \"B.\\\"\" + LAST_LOGIN_TIME_PREFIX + USER_ID3 + \"\\\"\" + \" TIME) WHERE entry='entry2'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(ENTRY2_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID2));\n            assertEquals(ENTRY2_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID3));\n            assertEquals(null, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));\n\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n\n    /**\n     * We have to make sure that static columns that are projected are in the expected order.\n     * Dynamic columns should be projected as well, but we cannot guarantee their order.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testProjectStaticAndDynamic() throws Exception {\n        String query = \"SELECT ENTRY, A.DUMMY, B.DUMMY, A.*,B.* FROM \"+ WEB_STATS +\" WHERE entry='entry3'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(\"entry3\", rs.getString(1));\n            assertEquals(null, rs.getString(2));\n            assertEquals(null, rs.getString(3));\n            Pair<String,Integer> clickCountUserIdAndValue = getMaxClickCountValue(rs);\n            assertEquals(USER_ID1_BYTES,clickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY3_CLICK_COUNT,clickCountUserIdAndValue.getSecond());\n            \n            assertEquals(ENTRY3_USER_ID1_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));\n            assertEquals(ENTRY3_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID2_BYTES)));\n            assertEquals(ENTRY3_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID3_BYTES)));\n\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n\n    @Test(expected = ColumnFamilyNotFoundException.class)\n    public void testDynamicFamilyException() throws Exception {\n        String query = \"SELECT C.* FROM \" + WEB_STATS;\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            statement.executeQuery();\n        } finally {\n            conn.close();\n        }\n    }\n\n    @Test(expected = PhoenixParserException.class)\n    public void testDynamicFamilyFunctionException() throws Exception {\n        String query = \"SELECT count(C.*) FROM \" + WEB_STATS;\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            statement.executeQuery();\n        } finally {\n            conn.close();\n        }\n    }\n\n    @Test\n    public void testSelectEntireColumnFamily() throws Exception {\n        ResultSet rs;\n        Connection conn = DriverManager.getConnection(getUrl());\n        conn.setAutoCommit(true);\n        String tableName = generateRandomString();\n        conn.createStatement().execute(\"CREATE TABLE \" + tableName\n            + \" (Id VARCHAR NOT NULL PRIMARY KEY, COLFAM1.A VARCHAR, COLFAM1.B VARCHAR, COLFAM2.A VARCHAR )\");\n        conn.createStatement().execute(\"UPSERT INTO \" + tableName\n            + \" (Id, COLFAM1.A, COLFAM1.B, COLFAM2.A) values ('row-2', '100', '200', '300')\");\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.A,COLFAM1.B FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.* FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.*,COLFAM1.A FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n    }\n}", "class_id": 0, "repo": "CharmsStyler/phoenix", "file": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DynamicFamilyIT.java", "last_update_at": "2018-03-09T09:13:49+00:00", "question_id": "52e2a64bbe42dbbf2abcec5408ef604a3081114b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@edu.umd.cs.findbugs.annotations.SuppressWarnings(\n        value=\"RV_RETURN_VALUE_IGNORED\", \n        justification=\"Designed to ignore.\")\npublic class DynamicFamilyIT extends BaseHBaseManagedTimeTableReuseIT {\n    private static final String WEB_STATS = generateRandomString();\n    private static final String WEB_STATS_SCHEMA_NAME = \"\";\n    private static final byte[] A_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier(\"A\"));\n    private static final byte[] B_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier(\"B\"));\n    private static final String USER_ID1 = \"u0001\";\n    private static final String USER_ID2 = \"u0002\";\n    private static final String USER_ID3 = \"u0003\";\n    private static final byte[] USER_ID1_BYTES = Bytes.toBytes(USER_ID1);\n    private static final byte[] USER_ID2_BYTES = Bytes.toBytes(USER_ID2);\n    private static final byte[] USER_ID3_BYTES = Bytes.toBytes(USER_ID3);\n    private static final String MAX_CLICK_COUNT_PREFIX = SchemaUtil.normalizeIdentifier(\"MaxClickCount_\");\n    private static final byte[] MAX_CLICK_COUNT_DYNCOL_PREFIX = Bytes.toBytes(MAX_CLICK_COUNT_PREFIX);\n    private static final Integer ENTRY1_CLICK_COUNT = 12;\n    private static final Integer ENTRY2_CLICK_COUNT = 34;\n    private static final Integer ENTRY3_CLICK_COUNT = 56;\n    private static final String LAST_LOGIN_TIME_PREFIX = SchemaUtil.normalizeIdentifier(\"LastLoginTime_\");\n    private static final byte[] LAST_LOGIN_TIME_DYNCOL_PREFIX = Bytes.toBytes(LAST_LOGIN_TIME_PREFIX);\n    private static final Time ENTRY1_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+60000);\n    private static final Time ENTRY1_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+120000);\n    private static final Time ENTRY2_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+180000);\n    private static final Time ENTRY2_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+240000);\n    private static final Time ENTRY3_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+300000);\n    private static final Time ENTRY3_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+360000);\n    private static final Time ENTRY3_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+420000);\n    @Before\n    public void doBeforeTestSetup() throws Exception {\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(getUrl(), props);\n        String ddl = \"create table if not exists  \" + WEB_STATS\n                + \"   (entry varchar not null primary key,\"\n                + \"    a.dummy varchar,\" \n                + \"    b.dummy varchar)\";\n        conn.createStatement().execute(ddl);\n        conn.close();\n        initTableValues();\n    }\n    @SuppressWarnings(\"deprecation\")\n    private static void initTableValues() throws Exception {\n        ConnectionQueryServices services = driver.getConnectionQueryServices(getUrl(), PropertiesUtil.deepCopy(TEST_PROPERTIES));\n        HTableInterface hTable = services.getTable(SchemaUtil.getTableNameAsBytes(WEB_STATS_SCHEMA_NAME,WEB_STATS));\n        try {\n            // Insert rows using standard HBase mechanism with standard HBase \"types\"\n            Put put;\n            List<Row> mutations = new ArrayList<Row>();\n            put = new Put(Bytes.toBytes(\"entry1\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID2_BYTES), PInteger.INSTANCE.toBytes(ENTRY1_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID1_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID2_LOGIN_TIME));\n            mutations.add(put);\n            put = new Put(Bytes.toBytes(\"entry2\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID3_BYTES), PInteger.INSTANCE.toBytes(ENTRY2_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID2_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID3_LOGIN_TIME));\n            mutations.add(put);\n            put = new Put(Bytes.toBytes(\"entry3\"));\n            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);\n            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID1_BYTES), PInteger.INSTANCE.toBytes(ENTRY3_CLICK_COUNT));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID1_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID2_LOGIN_TIME));\n            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID3_LOGIN_TIME));\n            mutations.add(put);\n            hTable.batch(mutations);\n        } finally {\n            hTable.close();\n        }\n    }\n    private static Pair<String,Integer> getMaxClickCountValue(ResultSet rs) throws SQLException {\n        ResultSetMetaData rsmd = rs.getMetaData();\n        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n            String colName = rsmd.getColumnName(i);\n            if (colName.startsWith(MAX_CLICK_COUNT_PREFIX)) {\n                String userId = colName.substring(MAX_CLICK_COUNT_PREFIX.length());\n                Integer clickCount = rs.getInt(colName);\n                return new Pair<String,Integer>(userId,clickCount);\n            }\n        }\n        return null;\n    }\n    private static Time getLastLoginTimeValue(ResultSet rs, String userId) throws SQLException {\n        String colName = LAST_LOGIN_TIME_PREFIX + userId;\n        try {\n            return rs.getTime(colName);\n        } catch (SQLException e) {\n            // Ignore COLUMN_NOT_FOUND error b/c it means that this user didn't login\n            if (e.getErrorCode() == SQLExceptionCode.COLUMN_NOT_FOUND.getErrorCode()) {\n                return null;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,\n     * since it is a wildcard.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testGetAllDynColsInFamily() throws Exception {\n        String query = \"SELECT A.* FROM \" + WEB_STATS + \" WHERE entry='entry1'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);\n            // This fails for two reasons: 1) all column qualifiers in column family A\n            // are not returned in the result, and 2) the dynamic columns are not available\n            // through ResultSetMetaData.\n            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n    /**\n     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,\n     * since it is a wildcard.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testGetAllDynCols() throws Exception {\n        String query = \"SELECT * FROM \" + WEB_STATS + \"WHERE entry='entry1'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);\n            // This fails because the dynamic columns are not available through ResultSetMetaData\n            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n    /**\n     * Since the dynamic columns are not in double quotes, the column name is normalized by being upper cased.\n     * In this case, since USER_ID is case sensitive, it will not find the columns\n     */\n    @Test\n    public void testGetCaseInsensitiveDynCol() throws Exception {\n        String query = \"SELECT B.* FROM \"+ WEB_STATS+ \"(\" +\n                \"B.\" + LAST_LOGIN_TIME_PREFIX + USER_ID2 + \" TIME,\" + \n                \"B.\" + LAST_LOGIN_TIME_PREFIX + USER_ID3 + \" TIME) WHERE entry='entry2'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID2));\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID3));\n            assertEquals(null, getLastLoginTimeValue(rs, USER_ID1));\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n    /**\n     * Since dynamic columns are not in double quotes, the column name is not normalized, but instead\n     * is left as is. This should succeed, since the user ID case is matched\n     */\n    // FIXME @Test\n    public void testGetCaseSensitiveDynCol() throws Exception {\n        String query = \"SELECT B.* FROM \"+WEB_STATS +\"(\" +\n                \"B.\\\"\" + LAST_LOGIN_TIME_PREFIX + USER_ID2 + \"\\\"\" + \" TIME,\" + \n                \"B.\\\"\" + LAST_LOGIN_TIME_PREFIX + USER_ID3 + \"\\\"\" + \" TIME) WHERE entry='entry2'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(ENTRY2_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID2));\n            assertEquals(ENTRY2_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID3));\n            assertEquals(null, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n    /**\n     * We have to make sure that static columns that are projected are in the expected order.\n     * Dynamic columns should be projected as well, but we cannot guarantee their order.\n     * @throws Exception\n     */\n    // FIXME @Test\n    public void testProjectStaticAndDynamic() throws Exception {\n        String query = \"SELECT ENTRY, A.DUMMY, B.DUMMY, A.*,B.* FROM \"+ WEB_STATS +\" WHERE entry='entry3'\";\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            ResultSet rs = statement.executeQuery();\n            assertTrue(rs.next());\n            assertEquals(\"entry3\", rs.getString(1));\n            assertEquals(null, rs.getString(2));\n            assertEquals(null, rs.getString(3));\n            Pair<String,Integer> clickCountUserIdAndValue = getMaxClickCountValue(rs);\n            assertEquals(USER_ID1_BYTES,clickCountUserIdAndValue.getFirst());\n            assertEquals(ENTRY3_CLICK_COUNT,clickCountUserIdAndValue.getSecond());\n            assertEquals(ENTRY3_USER_ID1_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));\n            assertEquals(ENTRY3_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID2_BYTES)));\n            assertEquals(ENTRY3_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID3_BYTES)));\n            assertFalse(rs.next());\n        } finally {\n            conn.close();\n        }\n    }\n    @Test(expected = ColumnFamilyNotFoundException.class)\n    public void testDynamicFamilyException() throws Exception {\n        String query = \"SELECT C.* FROM \" + WEB_STATS;\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            statement.executeQuery();\n        } finally {\n            conn.close();\n        }\n    }\n    @Test(expected = PhoenixParserException.class)\n    public void testDynamicFamilyFunctionException() throws Exception {\n        String query = \"SELECT count(C.*) FROM \" + WEB_STATS;\n        String url = getUrl() + \";\";\n        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n        Connection conn = DriverManager.getConnection(url, props);\n        try {\n            PreparedStatement statement = conn.prepareStatement(query);\n            statement.executeQuery();\n        } finally {\n            conn.close();\n        }\n    }\n    @Test\n    public void testSelectEntireColumnFamily() throws Exception {\n        ResultSet rs;\n        Connection conn = DriverManager.getConnection(getUrl());\n        conn.setAutoCommit(true);\n        String tableName = generateRandomString();\n        conn.createStatement().execute(\"CREATE TABLE \" + tableName\n            + \" (Id VARCHAR NOT NULL PRIMARY KEY, COLFAM1.A VARCHAR, COLFAM1.B VARCHAR, COLFAM2.A VARCHAR )\");\n        conn.createStatement().execute(\"UPSERT INTO \" + tableName\n            + \" (Id, COLFAM1.A, COLFAM1.B, COLFAM2.A) values ('row-2', '100', '200', '300')\");\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.A,COLFAM1.B FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.* FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n        rs = conn.createStatement().executeQuery(\"SELECT COLFAM1.*,COLFAM1.A FROM \" + tableName);\n        assertTrue(rs.next());\n        assertEquals(\"100\",rs.getString(1));\n        assertEquals(\"200\",rs.getString(2));\n        assertFalse(rs.next());\n    }\n"]], "pred": {"ppl": 1.656528115272522, "ppl_lower": 2.4422171115875244, "ppl/lowercase_ppl": -1.7690984158552447, "ppl/zlib": 0.0001801298769845623, "Min_5.0% Prob": 5.8219871053508685, "Min_10.0% Prob": 4.154037078221639, "Min_20.0% Prob": 2.437816762675842, "Min_30.0% Prob": 1.6711330100942672, "Min_40.0% Prob": 1.2589273804429837, "Min_50.0% Prob": 1.0096627476410083, "Min_60.0% Prob": 0.8421241301822143}}
{"hexsha": "3583a2c1703a891f08e8861bd356608838d740c5", "ext": "java", "lang": "Java", "content": "public class EditCounterActivity extends AppCompatActivity {\n\n    private Counter counter;\n    private int counterIndex;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_edit_counter);\n\n        Intent intent = getIntent();\n        String counterTitle = intent.getStringExtra(IntentConstants.INTENT_COUNTER_TITLE);\n        Integer counterInitialValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, 0);\n        Date counterDate = new Date(intent.getLongExtra(IntentConstants.INTENT_COUNTER_DATE, 0));\n        String counterComment = intent.getStringExtra(IntentConstants.INTENT_COUNTER_COMMENT);\n        Integer counterCurrentValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, 0);\n        counterIndex = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INDEX, 0);\n\n        counter = new Counter(counterTitle, counterDate, counterInitialValue, counterComment);\n        counter.setCurrentValue(counterCurrentValue);\n\n        TextView titleView = (TextView)findViewById(R.id.editCounterTitle);\n        titleView.setText(counterTitle);\n        TextView initialValueView = (TextView)findViewById(R.id.editCounterInitialValue);\n        initialValueView.setText(counterInitialValue.toString());\n        TextView currentValueView = (TextView)findViewById(R.id.editCounterCurrentValue);\n        currentValueView.setText(counterCurrentValue.toString());\n        TextView commentView = (TextView)findViewById(R.id.editCounterComment);\n        commentView.setText(counterComment);\n    }\n\n    /**\n     * Checks if all data in the form is valid. Then, finishes the activity\n     * and sends data back to the previous activity.\n     * @param v\n     */\n    public void saveEdits(View v) {\n        String counterTitle = ((EditText) findViewById(R.id.editCounterTitle)).getText().toString();\n        Date date = new Date();\n        String initialValueString = ((EditText) findViewById(R.id.editCounterInitialValue)).getText().toString();\n        String currentValueString = ((EditText) findViewById(R.id.editCounterCurrentValue)).getText().toString();\n        String comment = ((EditText) findViewById(R.id.editCounterComment)).getText().toString();\n\n        if (counterTitle.equals(\"\")) {\n            Toast.makeText(getApplicationContext(), \"Please enter a title\", Toast.LENGTH_SHORT).show();\n        } else if (initialValueString.equals(\"\")) {\n            Toast.makeText(getApplicationContext(), \"Please enter an initial value\", Toast.LENGTH_SHORT).show();\n        } else if (currentValueString.equals(\"\")) {\n           Toast.makeText(getApplicationContext(), \"Please enter a current value\", Toast.LENGTH_SHORT).show();\n        } else if (Integer.parseInt(initialValueString) < 0) {\n            Toast.makeText(getApplicationContext(), \"The initial value must be positive\", Toast.LENGTH_SHORT).show();\n        } else if (Integer.parseInt(currentValueString) < 0) {\n            Toast.makeText(getApplicationContext(), \"The current value must be positive\", Toast.LENGTH_SHORT).show();\n        }\n        else {\n            Intent intent = new Intent();\n            intent.putExtra(IntentConstants.INTENT_COUNTER_TITLE, counterTitle);\n            intent.putExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, Integer.parseInt(initialValueString));\n            intent.putExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, Integer.parseInt(currentValueString));\n            intent.putExtra(IntentConstants.INTENT_COUNTER_DATE, date.getTime());\n            intent.putExtra(IntentConstants.INTENT_COUNTER_COMMENT, comment);\n            intent.putExtra(IntentConstants.INTENT_COUNTER_INDEX, counterIndex);\n            setResult(IntentConstants.EDIT_COUNTER_INTENT_RESPONSE, intent);\n            finish();\n        }\n    }\n}", "class_id": 0, "repo": "Megasonic988/weixiang-CountBook", "file": "app/src/main/java/com/ualberta/kevin/countbook/EditCounterActivity.java", "last_update_at": "2018-10-03T21:21:37+00:00", "question_id": "3583a2c1703a891f08e8861bd356608838d740c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EditCounterActivity extends AppCompatActivity {\n    private Counter counter;\n    private int counterIndex;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_edit_counter);\n        Intent intent = getIntent();\n        String counterTitle = intent.getStringExtra(IntentConstants.INTENT_COUNTER_TITLE);\n        Integer counterInitialValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, 0);\n        Date counterDate = new Date(intent.getLongExtra(IntentConstants.INTENT_COUNTER_DATE, 0));\n        String counterComment = intent.getStringExtra(IntentConstants.INTENT_COUNTER_COMMENT);\n        Integer counterCurrentValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, 0);\n        counterIndex = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INDEX, 0);\n        counter = new Counter(counterTitle, counterDate, counterInitialValue, counterComment);\n        counter.setCurrentValue(counterCurrentValue);\n        TextView titleView = (TextView)findViewById(R.id.editCounterTitle);\n        titleView.setText(counterTitle);\n        TextView initialValueView = (TextView)findViewById(R.id.editCounterInitialValue);\n        initialValueView.setText(counterInitialValue.toString());\n        TextView currentValueView = (TextView)findViewById(R.id.editCounterCurrentValue);\n        currentValueView.setText(counterCurrentValue.toString());\n        TextView commentView = (TextView)findViewById(R.id.editCounterComment);\n        commentView.setText(counterComment);\n    }\n    /**\n     * Checks if all data in the form is valid. Then, finishes the activity\n     * and sends data back to the previous activity.\n     * @param v\n     */\n    public void saveEdits(View v) {\n        String counterTitle = ((EditText) findViewById(R.id.editCounterTitle)).getText().toString();\n        Date date = new Date();\n        String initialValueString = ((EditText) findViewById(R.id.editCounterInitialValue)).getText().toString();\n        String currentValueString = ((EditText) findViewById(R.id.editCounterCurrentValue)).getText().toString();\n        String comment = ((EditText) findViewById(R.id.editCounterComment)).getText().toString();\n        if (counterTitle.equals(\"\")) {\n            Toast.makeText(getApplicationContext(), \"Please enter a title\", Toast.LENGTH_SHORT).show();\n        } else if (initialValueString.equals(\"\")) {\n            Toast.makeText(getApplicationContext(), \"Please enter an initial value\", Toast.LENGTH_SHORT).show();\n        } else if (currentValueString.equals(\"\")) {\n           Toast.makeText(getApplicationContext(), \"Please enter a current value\", Toast.LENGTH_SHORT).show();\n        } else if (Integer.parseInt(initialValueString) < 0) {\n            Toast.makeText(getApplicationContext(), \"The initial value must be positive\", Toast.LENGTH_SHORT).show();\n        } else if (Integer.parseInt(currentValueString) < 0) {\n            Toast.makeText(getApplicationContext(), \"The current value must be positive\", Toast.LENGTH_SHORT).show();\n        }\n        else {\n            Intent intent = new Intent();\n            intent.putExtra(IntentConstants.INTENT_COUNTER_TITLE, counterTitle);\n            intent.putExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, Integer.parseInt(initialValueString));\n            intent.putExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, Integer.parseInt(currentValueString));\n            intent.putExtra(IntentConstants.INTENT_COUNTER_DATE, date.getTime());\n            intent.putExtra(IntentConstants.INTENT_COUNTER_COMMENT, comment);\n            intent.putExtra(IntentConstants.INTENT_COUNTER_INDEX, counterIndex);\n            setResult(IntentConstants.EDIT_COUNTER_INTENT_RESPONSE, intent);\n            finish();\n        }\n    }\n"]], "pred": {"ppl": 1.3438838720321655, "ppl_lower": 1.4641557931900024, "ppl/lowercase_ppl": -1.290005009436207, "ppl/zlib": 0.0003209162145818472, "Min_5.0% Prob": 3.8784669613351626, "Min_10.0% Prob": 2.547833718815628, "Min_20.0% Prob": 1.4390359676766151, "Min_30.0% Prob": 0.9786279751621441, "Min_40.0% Prob": 0.7373560031814197, "Min_50.0% Prob": 0.5907547051372121, "Min_60.0% Prob": 0.4925075584913083}}
{"hexsha": "73580f86dc1928c74bd9c4351f580b9c6f313051", "ext": "java", "lang": "Java", "content": "public class MessagePreProcessor implements EventHandler<InboundEventContainer> {\n\n    private static final Log log = LogFactory.getLog(MessagePreProcessor.class);\n    private final MessageIDGenerator idGenerator;\n\n    private final ArrayList<AndesMessage> messageList;\n\n    public MessagePreProcessor() {\n        idGenerator = new MessageIDGenerator();\n        messageList = new ArrayList<>();\n    }\n\n    @Override\n    public void onEvent(InboundEventContainer inboundEvent, long sequence, boolean endOfBatch ) throws Exception {\n        InboundEventContainer.Type eventType = inboundEvent.getEventType();\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"[ sequence \" + sequence + \"] Event type \" + eventType);\n        }\n\n        switch (eventType) {\n            case MESSAGE_EVENT:\n                // NOTE: This is the MESSAGE_EVENT and this is the first processing event for this message\n                // published to ring. Therefore there should be exactly one message in the list.\n                // NO NEED TO CHECK FOR LIST SIZE\n                AndesMessage message = inboundEvent.popMessage();\n                updateRoutingInformation(inboundEvent, message, sequence);\n                break;\n            case TRANSACTION_COMMIT_EVENT:\n                preProcessTransaction(inboundEvent, sequence);\n                break;\n            case DTX_ONE_PHASE_COMMIT_EVENT:\n            case DTX_COMMIT_EVENT:\n                preProcessDtxCommit(inboundEvent);\n                break;\n            case DTX_ROLLBACK_EVENT:\n                preProcessDtxRollback(inboundEvent);\n                break;\n            case SAFE_ZONE_DECLARE_EVENT:\n                setSafeZoneLimit(inboundEvent, sequence);\n                break;\n            case PUBLISHER_RECOVERY_EVENT:\n                inboundEvent.setRecoveryEventMessageId(idGenerator.getNextId());\n                break;\n            default:\n                if (log.isDebugEnabled()) {\n                    log.debug(\"[ sequence \" + sequence + \"] Unhandled event \" + inboundEvent.eventInfo());\n                }\n                break;\n        }\n    }\n\n    /**\n     * Pre-process Dtx rollback messages. Acknowledged but not yet commited messages are given a new message id to be\n     * restored.\n     *\n     * @param eventContainer {@link InboundEventContainer}\n     */\n    private void preProcessDtxRollback(InboundEventContainer eventContainer) {\n\n        List<AndesPreparedMessageMetadata> dequeueList = eventContainer.getDtxBranch().getMessagesToRestore();\n        for (AndesPreparedMessageMetadata messageMetadata: dequeueList) {\n            messageMetadata.setMessageID(idGenerator.getNextId());\n        }\n    }\n\n    /**\n     * Pre process Dtx commit related incoming messages. Messages are cloned as needed for in topic scenarios\n     * @param eventContainer\n     */\n    private void preProcessDtxCommit(InboundEventContainer eventContainer) {\n        // Routing information of all the messages of current transaction is updated.\n        // Messages duplicated as needed.\n        ArrayList<AndesMessage> clonedMessages = new ArrayList<>();\n        Collection<AndesMessage> enqueueList = eventContainer.getDtxBranch().getEnqueueList();\n\n        for (AndesMessage message : enqueueList) {\n            setMessageID(message);\n            clonedMessages.addAll(preProcessIncomingMessage(eventContainer, message));\n        }\n\n        // Internal message list of transaction object is updated to reflect the messages\n        // actually written to DB\n        eventContainer.getDtxBranch().setMessagesToStore(clonedMessages);\n    }\n\n    /**\n     * Pre process transaction related messages.\n     * @param eventContainer InboundEventContainer\n     * @param sequence Disruptor ring sequence number.\n     * @throws AndesException\n     */\n    private void preProcessTransaction(InboundEventContainer eventContainer, long sequence) throws AndesException {\n\n        // Routing information of all the messages of current transaction is updated.\n        // Messages duplicated as needed.\n        Collection<AndesMessage> messageList = eventContainer.getTransactionEvent().getQueuedMessages();\n        for (AndesMessage message : messageList) {\n            updateRoutingInformation(eventContainer, message, sequence);\n        }\n\n        // Internal message list of transaction object is updated to reflect the messages\n        // to be written to DB\n        eventContainer.getTransactionEvent().setMessagesToStore(eventContainer.getMessageList());\n    }\n\n    /**\n     * Calculate the current safe zone for this node (using the last generated message ID)\n     * @param event event\n     * @param sequence position of the event at the event ring buffer\n     */\n    private void setSafeZoneLimit(InboundEventContainer event, long sequence) {\n        long safeZoneLimit = idGenerator.getNextId();\n        event.setSafeZoneLimit(safeZoneLimit);\n        if(log.isDebugEnabled()){\n            log.debug(\"[ Sequence \" + sequence + \" ] Pre processing message. Setting the Safe Zone \" + safeZoneLimit);\n        }\n    }\n\n    /**\n     * Route the message to queue/queues of subscribers matching in AMQP way. Hierarchical topic message routing is\n     * evaluated here. This will duplicate message for each \"subscription destination (not message destination)\" at\n     * different nodes\n     *\n     * @param event InboundEventContainer containing the message list\n     * @param message Routing details updated for the given {@link org.wso2.andes.kernel.AndesMessage}\n     * @param sequence Disruptor slot sequence number\n     */\n    private void updateRoutingInformation(InboundEventContainer event, AndesMessage message, long sequence) {\n\n        AndesChannel andesChannel = event.getChannel();\n\n        // Messages are processed in the order they arrive at ring buffer By this processor.\n        // By setting message ID through message pre processor we assure, even in a multi publisher scenario, there is\n        // no message id ordering issue at node level.\n        setMessageID(message);\n\n        if(log.isDebugEnabled()){\n            log.debug(\"[ Sequence \" + sequence + \" ] Pre processing message. Message ID \"\n                    + message.getMetadata().getMessageID());\n        }\n\n        List<? extends AndesMessage> messages = preProcessIncomingMessage(event, message);\n        for (AndesMessage andesMessage: messages) {\n            event.addMessage(andesMessage, andesChannel);\n        }\n    }\n\n    /**\n     * Pre process the message and clone the message if needed on topic scenarios.\n     *\n     * @param event InboundEventContainer containing the message list\n     * @param message {@link AndesMessage}\n     * @return List of {@link AndesMessage}\n     */\n    private List<AndesMessage> preProcessIncomingMessage(InboundEventContainer event, AndesMessage message) {\n\n        boolean isMessageRouted = false;\n\n        // Get storage queues bound to the message router\n        String messageRouterName = message.getMetadata().getMessageRouterName();\n        AndesMessageRouter messageRouter = AndesContext.getInstance().\n                getMessageRouterRegistry().getMessageRouter(messageRouterName);\n\n        // Do topic matching with the routing key of the message and get a list of\n        // mating binding keys\n        Set<StorageQueue> matchingQueues = messageRouter.getMatchingStorageQueues(message);\n        messageList.clear(); // clear any previous entries\n\n        boolean originalMessageConsumed = false;\n\n        for (StorageQueue matchingQueue : matchingQueues) {\n\n            if (!originalMessageConsumed) {\n                message.getMetadata().setStorageQueueName(matchingQueue.getName());\n\n                // add the topic wise cloned message to the events list. Message writers will pick that and\n                // write it.\n                messageList.add(message);\n                originalMessageConsumed = true;\n\n            } else {\n                AndesMessage clonedMessage = cloneAndesMessageMetadataAndContent(message);\n\n                //Message should be written to storage queue name. This is\n                //determined by destination of the message. So should be\n                //updated (but internal metadata will have topic name as usual)\n                clonedMessage.getMetadata().setStorageQueueName(matchingQueue.getName());\n\n                // Update cloned message metadata if isCompressed set true.\n                if (clonedMessage.getMetadata().isCompressed()) {\n                    clonedMessage.getMetadata().updateMetadata(true);\n                }\n\n                if (MessageTracer.isEnabled()) {\n                    MessageTracer.trace(message, MessageTracer.MESSAGE_CLONED + clonedMessage.getMetadata()\n                            .getMessageID() + \" for \" + clonedMessage.getMetadata().getStorageQueueName());\n                }\n\n                // add the topic wise cloned message to the events list. Message writers will pick that and\n                // write it.\n                messageList.add(clonedMessage);\n            }\n\n            isMessageRouted = true;\n        }\n\n        // TODO: validate this\n        // If retain enabled, need to store the retained message. Set the retained message\n        // so the message writer will persist the retained message\n        if (message.getMetadata().isRetain()) {\n            event.retainMessage = message;\n        }\n\n        // If there is no matching subscriber at the moment there is no point of storing the message\n        if (!isMessageRouted) {\n\n            // Even though we drop the message pub ack needs to be sent\n            event.pubAckHandler.ack(message.getMetadata());\n\n            // Adding metrics meter for ack rate\n            Meter ackMeter = MetricManager.meter(MetricsConstants.ACK_SENT_RATE, Level.INFO);\n            ackMeter.mark();\n\n            // Since inbound message has no routes, inbound message list will be cleared.\n            messageList.clear();\n            log.info(\"Message routing key: \" + message.getMetadata().getDestination() + \" No routes in \" +\n                    \"cluster. Ignoring Message id \" + message.getMetadata().getMessageID());\n        }\n        return messageList;\n    }\n\n    /**\n     * Create a clone of the message\n     *\n     * @param message message to be cloned\n     * @return Cloned reference of AndesMessage\n     */\n    private AndesMessage cloneAndesMessageMetadataAndContent(AndesMessage message) {\n        long newMessageId = idGenerator.getNextId();\n        AndesMessageMetadata clonedMetadata = message.getMetadata().shallowCopy(newMessageId);\n        AndesMessage clonedMessage = new AndesMessage(clonedMetadata);\n\n        // Duplicate message content\n        List<AndesMessagePart> messageParts = message.getContentChunkList();\n        for (AndesMessagePart messagePart : messageParts) {\n            clonedMessage.addMessagePart(messagePart.shallowCopy(newMessageId));\n        }\n\n        return clonedMessage;\n\n    }\n\n    /**\n     * Set Message ID for AndesMessage.\n     * @param message messageID\n     */\n    private void setMessageID(AndesMessage message) {\n        long messageId = idGenerator.getNextId();\n\n        message.getMetadata().setMessageID(messageId);\n\n        // Tracing message\n        if (MessageTracer.isEnabled()) {\n            MessageTracer.trace(messageId, message.getMetadata().getDestination(), MessageTracer.MESSAGE_ID_MAPPED);\n        }\n\n        for (AndesMessagePart messagePart: message.getContentChunkList()) {\n            messagePart.setMessageID(messageId);\n        }\n    }\n\n    /**\n     * Generates IDs. This id generator cannot be used in a multi threaded environment. Removed any locking behaviour to\n     * improve id generation in single threaded approach\n     */\n    private static class MessageIDGenerator {\n\n        /** REFERENCE_START time set to 2011 */\n        private static final long REFERENCE_START = 41L * 365L * 24L * 60L * 60L * 1000L;\n        private int uniqueIdForNode;\n        private long lastTimestamp;\n        private long lastID;\n        private int offset;\n\n        MessageIDGenerator() {\n            uniqueIdForNode = 0;\n            lastTimestamp = 0;\n            lastID = 0;\n            offset = 0;\n        }\n\n        /**\n         * Out of 64 bits for long, we will use the range as follows\n         * [1 sign bit][45bits for time spent from reference time in milliseconds][8bit node id][10 bit offset for ID\n         * falls within the same timestamp]\n         * This assumes there will not be more than 1024 hits within a given millisecond. Range is sufficient for\n         * 6029925857 years.\n         *\n         * @return Generated ID\n         */\n        long getNextId() {\n\n            // id might change at runtime. Hence reading the value\n            uniqueIdForNode = ClusterResourceHolder.getInstance().getClusterManager().getUniqueIdForLocalNode();\n            long ts = System.currentTimeMillis();\n\n            if (ts == lastTimestamp) {\n                offset = offset + 1;\n            } else {\n                offset = 0;\n            }\n            lastTimestamp = ts;\n            long id = (ts - REFERENCE_START) * 256 * 1024 + uniqueIdForNode * 1024 + offset;\n            if (lastID == id) {\n                throw new RuntimeException(\"duplicate ids detected. This should never happen\");\n            }\n            lastID = id;\n            return id;\n        }\n    }\n}", "class_id": 0, "repo": "bhathiya/andes", "file": "modules/andes-core/broker/src/main/java/org/wso2/andes/kernel/disruptor/inbound/MessagePreProcessor.java", "last_update_at": "2018-04-20T10:12:21+00:00", "question_id": "73580f86dc1928c74bd9c4351f580b9c6f313051", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessagePreProcessor implements EventHandler<InboundEventContainer> {\n    private static final Log log = LogFactory.getLog(MessagePreProcessor.class);\n    private final MessageIDGenerator idGenerator;\n    private final ArrayList<AndesMessage> messageList;\n    public MessagePreProcessor() {\n        idGenerator = new MessageIDGenerator();\n        messageList = new ArrayList<>();\n    }\n    @Override\n    public void onEvent(InboundEventContainer inboundEvent, long sequence, boolean endOfBatch ) throws Exception {\n        InboundEventContainer.Type eventType = inboundEvent.getEventType();\n        if (log.isDebugEnabled()) {\n            log.debug(\"[ sequence \" + sequence + \"] Event type \" + eventType);\n        }\n        switch (eventType) {\n            case MESSAGE_EVENT:\n                // NOTE: This is the MESSAGE_EVENT and this is the first processing event for this message\n                // published to ring. Therefore there should be exactly one message in the list.\n                // NO NEED TO CHECK FOR LIST SIZE\n                AndesMessage message = inboundEvent.popMessage();\n                updateRoutingInformation(inboundEvent, message, sequence);\n                break;\n            case TRANSACTION_COMMIT_EVENT:\n                preProcessTransaction(inboundEvent, sequence);\n                break;\n            case DTX_ONE_PHASE_COMMIT_EVENT:\n            case DTX_COMMIT_EVENT:\n                preProcessDtxCommit(inboundEvent);\n                break;\n            case DTX_ROLLBACK_EVENT:\n                preProcessDtxRollback(inboundEvent);\n                break;\n            case SAFE_ZONE_DECLARE_EVENT:\n                setSafeZoneLimit(inboundEvent, sequence);\n                break;\n            case PUBLISHER_RECOVERY_EVENT:\n                inboundEvent.setRecoveryEventMessageId(idGenerator.getNextId());\n                break;\n            default:\n                if (log.isDebugEnabled()) {\n                    log.debug(\"[ sequence \" + sequence + \"] Unhandled event \" + inboundEvent.eventInfo());\n                }\n                break;\n        }\n    }\n    /**\n     * Pre-process Dtx rollback messages. Acknowledged but not yet commited messages are given a new message id to be\n     * restored.\n     *\n     * @param eventContainer {@link InboundEventContainer}\n     */\n    private void preProcessDtxRollback(InboundEventContainer eventContainer) {\n        List<AndesPreparedMessageMetadata> dequeueList = eventContainer.getDtxBranch().getMessagesToRestore();\n        for (AndesPreparedMessageMetadata messageMetadata: dequeueList) {\n            messageMetadata.setMessageID(idGenerator.getNextId());\n        }\n    }\n    /**\n     * Pre process Dtx commit related incoming messages. Messages are cloned as needed for in topic scenarios\n     * @param eventContainer\n     */\n    private void preProcessDtxCommit(InboundEventContainer eventContainer) {\n        // Routing information of all the messages of current transaction is updated.\n        // Messages duplicated as needed.\n        ArrayList<AndesMessage> clonedMessages = new ArrayList<>();\n        Collection<AndesMessage> enqueueList = eventContainer.getDtxBranch().getEnqueueList();\n        for (AndesMessage message : enqueueList) {\n            setMessageID(message);\n            clonedMessages.addAll(preProcessIncomingMessage(eventContainer, message));\n        }\n        // Internal message list of transaction object is updated to reflect the messages\n        // actually written to DB\n        eventContainer.getDtxBranch().setMessagesToStore(clonedMessages);\n    }\n    /**\n     * Pre process transaction related messages.\n     * @param eventContainer InboundEventContainer\n     * @param sequence Disruptor ring sequence number.\n     * @throws AndesException\n     */\n    private void preProcessTransaction(InboundEventContainer eventContainer, long sequence) throws AndesException {\n        // Routing information of all the messages of current transaction is updated.\n        // Messages duplicated as needed.\n        Collection<AndesMessage> messageList = eventContainer.getTransactionEvent().getQueuedMessages();\n        for (AndesMessage message : messageList) {\n            updateRoutingInformation(eventContainer, message, sequence);\n        }\n        // Internal message list of transaction object is updated to reflect the messages\n        // to be written to DB\n        eventContainer.getTransactionEvent().setMessagesToStore(eventContainer.getMessageList());\n    }\n    /**\n     * Calculate the current safe zone for this node (using the last generated message ID)\n     * @param event event\n     * @param sequence position of the event at the event ring buffer\n     */\n    private void setSafeZoneLimit(InboundEventContainer event, long sequence) {\n        long safeZoneLimit = idGenerator.getNextId();\n        event.setSafeZoneLimit(safeZoneLimit);\n        if(log.isDebugEnabled()){\n            log.debug(\"[ Sequence \" + sequence + \" ] Pre processing message. Setting the Safe Zone \" + safeZoneLimit);\n        }\n    }\n    /**\n     * Route the message to queue/queues of subscribers matching in AMQP way. Hierarchical topic message routing is\n     * evaluated here. This will duplicate message for each \"subscription destination (not message destination)\" at\n     * different nodes\n     *\n     * @param event InboundEventContainer containing the message list\n     * @param message Routing details updated for the given {@link org.wso2.andes.kernel.AndesMessage}\n     * @param sequence Disruptor slot sequence number\n     */\n    private void updateRoutingInformation(InboundEventContainer event, AndesMessage message, long sequence) {\n        AndesChannel andesChannel = event.getChannel();\n        // Messages are processed in the order they arrive at ring buffer By this processor.\n        // By setting message ID through message pre processor we assure, even in a multi publisher scenario, there is\n        // no message id ordering issue at node level.\n        setMessageID(message);\n        if(log.isDebugEnabled()){\n            log.debug(\"[ Sequence \" + sequence + \" ] Pre processing message. Message ID \"\n                    + message.getMetadata().getMessageID());\n        }\n        List<? extends AndesMessage> messages = preProcessIncomingMessage(event, message);\n        for (AndesMessage andesMessage: messages) {\n            event.addMessage(andesMessage, andesChannel);\n        }\n    }\n    /**\n     * Pre process the message and clone the message if needed on topic scenarios.\n     *\n     * @param event InboundEventContainer containing the message list\n     * @param message {@link AndesMessage}\n     * @return List of {@link AndesMessage}\n     */\n    private List<AndesMessage> preProcessIncomingMessage(InboundEventContainer event, AndesMessage message) {\n        boolean isMessageRouted = false;\n        // Get storage queues bound to the message router\n        String messageRouterName = message.getMetadata().getMessageRouterName();\n        AndesMessageRouter messageRouter = AndesContext.getInstance().\n                getMessageRouterRegistry().getMessageRouter(messageRouterName);\n        // Do topic matching with the routing key of the message and get a list of\n        // mating binding keys\n        Set<StorageQueue> matchingQueues = messageRouter.getMatchingStorageQueues(message);\n        messageList.clear(); // clear any previous entries\n        boolean originalMessageConsumed = false;\n        for (StorageQueue matchingQueue : matchingQueues) {\n            if (!originalMessageConsumed) {\n                message.getMetadata().setStorageQueueName(matchingQueue.getName());\n                // add the topic wise cloned message to the events list. Message writers will pick that and\n                // write it.\n                messageList.add(message);\n                originalMessageConsumed = true;\n            } else {\n                AndesMessage clonedMessage = cloneAndesMessageMetadataAndContent(message);\n                //Message should be written to storage queue name. This is\n                //determined by destination of the message. So should be\n                //updated (but internal metadata will have topic name as usual)\n                clonedMessage.getMetadata().setStorageQueueName(matchingQueue.getName());\n                // Update cloned message metadata if isCompressed set true.\n                if (clonedMessage.getMetadata().isCompressed()) {\n                    clonedMessage.getMetadata().updateMetadata(true);\n                }\n                if (MessageTracer.isEnabled()) {\n                    MessageTracer.trace(message, MessageTracer.MESSAGE_CLONED + clonedMessage.getMetadata()\n                            .getMessageID() + \" for \" + clonedMessage.getMetadata().getStorageQueueName());\n                }\n                // add the topic wise cloned message to the events list. Message writers will pick that and\n                // write it.\n                messageList.add(clonedMessage);\n            }\n            isMessageRouted = true;\n        }\n        // TODO: validate this\n        // If retain enabled, need to store the retained message. Set the retained message\n        // so the message writer will persist the retained message\n        if (message.getMetadata().isRetain()) {\n            event.retainMessage = message;\n        }\n        // If there is no matching subscriber at the moment there is no point of storing the message\n        if (!isMessageRouted) {\n            // Even though we drop the message pub ack needs to be sent\n            event.pubAckHandler.ack(message.getMetadata());\n            // Adding metrics meter for ack rate\n            Meter ackMeter = MetricManager.meter(MetricsConstants.ACK_SENT_RATE, Level.INFO);\n            ackMeter.mark();\n            // Since inbound message has no routes, inbound message list will be cleared.\n            messageList.clear();\n            log.info(\"Message routing key: \" + message.getMetadata().getDestination() + \" No routes in \" +\n                    \"cluster. Ignoring Message id \" + message.getMetadata().getMessageID());\n        }\n        return messageList;\n    }\n    /**\n     * Create a clone of the message\n     *\n     * @param message message to be cloned\n     * @return Cloned reference of AndesMessage\n     */\n    private AndesMessage cloneAndesMessageMetadataAndContent(AndesMessage message) {\n        long newMessageId = idGenerator.getNextId();\n        AndesMessageMetadata clonedMetadata = message.getMetadata().shallowCopy(newMessageId);\n        AndesMessage clonedMessage = new AndesMessage(clonedMetadata);\n        // Duplicate message content\n        List<AndesMessagePart> messageParts = message.getContentChunkList();\n        for (AndesMessagePart messagePart : messageParts) {\n            clonedMessage.addMessagePart(messagePart.shallowCopy(newMessageId));\n        }\n        return clonedMessage;\n    }\n    /**\n     * Set Message ID for AndesMessage.\n     * @param message messageID\n     */\n    private void setMessageID(AndesMessage message) {\n        long messageId = idGenerator.getNextId();\n        message.getMetadata().setMessageID(messageId);\n        // Tracing message\n        if (MessageTracer.isEnabled()) {\n            MessageTracer.trace(messageId, message.getMetadata().getDestination(), MessageTracer.MESSAGE_ID_MAPPED);\n        }\n        for (AndesMessagePart messagePart: message.getContentChunkList()) {\n            messagePart.setMessageID(messageId);\n        }\n    }\n    /**\n     * Generates IDs. This id generator cannot be used in a multi threaded environment. Removed any locking behaviour to\n     * improve id generation in single threaded approach\n     */\n    private static class MessageIDGenerator {\n        /** REFERENCE_START time set to 2011 */\n        private static final long REFERENCE_START = 41L * 365L * 24L * 60L * 60L * 1000L;\n        private int uniqueIdForNode;\n        private long lastTimestamp;\n        private long lastID;\n        private int offset;\n        MessageIDGenerator() {\n            uniqueIdForNode = 0;\n            lastTimestamp = 0;\n            lastID = 0;\n            offset = 0;\n        }\n        /**\n         * Out of 64 bits for long, we will use the range as follows\n         * [1 sign bit][45bits for time spent from reference time in milliseconds][8bit node id][10 bit offset for ID\n         * falls within the same timestamp]\n         * This assumes there will not be more than 1024 hits within a given millisecond. Range is sufficient for\n         * 6029925857 years.\n         *\n         * @return Generated ID\n         */\n        long getNextId() {\n            // id might change at runtime. Hence reading the value\n            uniqueIdForNode = ClusterResourceHolder.getInstance().getClusterManager().getUniqueIdForLocalNode();\n            long ts = System.currentTimeMillis();\n            if (ts == lastTimestamp) {\n                offset = offset + 1;\n            } else {\n                offset = 0;\n            }\n            lastTimestamp = ts;\n            long id = (ts - REFERENCE_START) * 256 * 1024 + uniqueIdForNode * 1024 + offset;\n            if (lastID == id) {\n                throw new RuntimeException(\"duplicate ids detected. This should never happen\");\n            }\n            lastID = id;\n            return id;\n        }\n    }\n"]], "pred": {"ppl": 2.58968448638916, "ppl_lower": 2.834307909011841, "ppl/lowercase_ppl": -1.0948589760342506, "ppl/zlib": 0.0002608377325558748, "Min_5.0% Prob": 7.60154790504306, "Min_10.0% Prob": 5.822503328323364, "Min_20.0% Prob": 4.023894633148231, "Min_30.0% Prob": 3.013573340925516, "Min_40.0% Prob": 2.339645726355772, "Min_50.0% Prob": 1.8950931307679286, "Min_60.0% Prob": 1.5856126460533886}}
{"hexsha": "f03537ad24b223dc556fd880c911c59d2cc730d1", "ext": "java", "lang": "Java", "content": "@RequiresApi(api = Build.VERSION_CODES.M)\npublic class SigaMeJobService extends JobService {\n    public SigaMeJobService() {\n    }\n\n\n    @Override\n    public boolean onStartJob(JobParameters params) {\n        Intent service = new Intent(getApplicationContext(), SigaMeService.class);\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n            getApplicationContext().startForegroundService(service);\n        else\n            getApplicationContext().startService(service);\n\n        AndroidUtil.scheduleJob(getApplicationContext()); // reschedule the job\n        return true;\n    }\n\n    @Override\n    public boolean onStopJob(JobParameters params) {\n        return false;\n    }\n\n\n}", "class_id": 0, "repo": "OconvStream/ColihRedirect", "file": "app/src/main/java/app/notofficial/jw/colihredirect/SigaMeJobService.java", "last_update_at": "2018-08-16T12:06:49+00:00", "question_id": "f03537ad24b223dc556fd880c911c59d2cc730d1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RequiresApi(api = Build.VERSION_CODES.M)\npublic class SigaMeJobService extends JobService {\n    public SigaMeJobService() {\n    }\n    @Override\n    public boolean onStartJob(JobParameters params) {\n        Intent service = new Intent(getApplicationContext(), SigaMeService.class);\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n            getApplicationContext().startForegroundService(service);\n        else\n            getApplicationContext().startService(service);\n        AndroidUtil.scheduleJob(getApplicationContext()); // reschedule the job\n        return true;\n    }\n    @Override\n    public boolean onStopJob(JobParameters params) {\n        return false;\n    }\n"]], "pred": {"ppl": 1.9984649419784546, "ppl_lower": 3.260258197784424, "ppl/lowercase_ppl": -1.7068769921113762, "ppl/zlib": 0.002270096251960581, "Min_5.0% Prob": 7.534165196948582, "Min_10.0% Prob": 5.180960761176215, "Min_20.0% Prob": 3.235077661436957, "Min_30.0% Prob": 2.2922170408747413, "Min_40.0% Prob": 1.7289320279818934, "Min_50.0% Prob": 1.3818947715804941, "Min_60.0% Prob": 1.1592009602416609}}
{"hexsha": "9d714c8b07d4b78f64eedddc78c756fc6e859940", "ext": "java", "lang": "Java", "content": "public class EchoClientHandler extends ChannelInboundHandlerAdapter {\n\n    private final ByteBuf message;\n\n    public EchoClientHandler() {\n        message = Unpooled.buffer(256);\n        message.writeBytes(\"hello netty\".getBytes(CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        ctx.writeAndFlush(message);\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        System.out.println(((ByteBuf) msg).toString(CharsetUtil.UTF_8));\n        ctx.write(msg);\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        ctx.flush();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        // Close the connection when an exception is raised.\n        cause.printStackTrace();\n        ctx.close();\n    }\n}", "class_id": 0, "repo": "ThinkInOpenSource/netty", "file": "test/src/main/java/com/luo/demo/netty/handler/EchoClientHandler.java", "last_update_at": "2018-09-15T08:34:16+00:00", "question_id": "9d714c8b07d4b78f64eedddc78c756fc6e859940", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EchoClientHandler extends ChannelInboundHandlerAdapter {\n    private final ByteBuf message;\n    public EchoClientHandler() {\n        message = Unpooled.buffer(256);\n        message.writeBytes(\"hello netty\".getBytes(CharsetUtil.UTF_8));\n    }\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        ctx.writeAndFlush(message);\n    }\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        System.out.println(((ByteBuf) msg).toString(CharsetUtil.UTF_8));\n        ctx.write(msg);\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        ctx.flush();\n    }\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        // Close the connection when an exception is raised.\n        cause.printStackTrace();\n        ctx.close();\n    }\n"]], "pred": {"ppl": 1.3154077529907227, "ppl_lower": 1.6783850193023682, "ppl/lowercase_ppl": -1.8888866464916179, "ppl/zlib": 0.000651179800202666, "Min_5.0% Prob": 4.025896989382231, "Min_10.0% Prob": 2.4500196134602583, "Min_20.0% Prob": 1.337635174664584, "Min_30.0% Prob": 0.9095561439059225, "Min_40.0% Prob": 0.684318546004392, "Min_50.0% Prob": 0.5477135675212221, "Min_60.0% Prob": 0.45892357851970517}}
{"hexsha": "a64a8d59f9facfd85555beac520568b4f8641d58", "ext": "java", "lang": "Java", "content": "class DutiesLoader extends Observable {\n    private static final String DATA_FILE = \"duties.txt\";\n\n    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n\n    private final File filesDir;\n\n    public DutiesLoader(File filesDir) {\n        this.filesDir = filesDir;\n    }\n\n    ArrayList<Duty> readDuties() {\n        File dutiesFile = new File(filesDir, DATA_FILE);\n        if (!dutiesFile.exists()) {\n            try {\n                dutiesFile.createNewFile();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        ArrayList<String> lines;\n        try {\n            lines = new ArrayList<>(FileUtils.readLines(dutiesFile));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        ArrayList<Duty> newDuties = new ArrayList<>();\n        ObjectReader reader = OBJECT_MAPPER.readerFor(Duty.class);\n        for (String line : lines) {\n            Duty duty;\n            try {\n                duty = reader.readValue(line);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            newDuties.add(duty);\n        }\n        return newDuties;\n    }\n\n    void saveDuties(List<Duty> duties) {\n        File dutiesFile = new File(filesDir, DATA_FILE);\n        ArrayList<String> lines = new ArrayList<>();\n        for (Duty duty : duties) {\n            ObjectWriter writer = OBJECT_MAPPER.writer();\n            try {\n                lines.add(writer.writeValueAsString(duty));\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        try {\n            FileUtils.writeLines(dutiesFile, lines);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        setChanged();\n        notifyObservers();\n    }\n}", "class_id": 0, "repo": "phillipao/sfjuryduty", "file": "app/src/main/java/com/philoertel/juryduty/DutiesLoader.java", "last_update_at": "2018-09-26T17:43:33+00:00", "question_id": "a64a8d59f9facfd85555beac520568b4f8641d58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DutiesLoader extends Observable {\n    private static final String DATA_FILE = \"duties.txt\";\n    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n    private final File filesDir;\n    public DutiesLoader(File filesDir) {\n        this.filesDir = filesDir;\n    }\n    ArrayList<Duty> readDuties() {\n        File dutiesFile = new File(filesDir, DATA_FILE);\n        if (!dutiesFile.exists()) {\n            try {\n                dutiesFile.createNewFile();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        ArrayList<String> lines;\n        try {\n            lines = new ArrayList<>(FileUtils.readLines(dutiesFile));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        ArrayList<Duty> newDuties = new ArrayList<>();\n        ObjectReader reader = OBJECT_MAPPER.readerFor(Duty.class);\n        for (String line : lines) {\n            Duty duty;\n            try {\n                duty = reader.readValue(line);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            newDuties.add(duty);\n        }\n        return newDuties;\n    }\n    void saveDuties(List<Duty> duties) {\n        File dutiesFile = new File(filesDir, DATA_FILE);\n        ArrayList<String> lines = new ArrayList<>();\n        for (Duty duty : duties) {\n            ObjectWriter writer = OBJECT_MAPPER.writer();\n            try {\n                lines.add(writer.writeValueAsString(duty));\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        try {\n            FileUtils.writeLines(dutiesFile, lines);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        setChanged();\n        notifyObservers();\n    }\n"]], "pred": {"ppl": 1.4040637016296387, "ppl_lower": 1.7085822820663452, "ppl/lowercase_ppl": -1.5784037618516293, "ppl/zlib": 0.000621558014845136, "Min_5.0% Prob": 4.747531242370606, "Min_10.0% Prob": 2.928360714631922, "Min_20.0% Prob": 1.6521292694059073, "Min_30.0% Prob": 1.1219868191755284, "Min_40.0% Prob": 0.8460989168699027, "Min_50.0% Prob": 0.6780901916096826, "Min_60.0% Prob": 0.5654279079240309}}
{"hexsha": "8c50434f3bc55f4ad1f803e9a189b6c6567b621f", "ext": "java", "lang": "Java", "content": "@Log4j\n@Stateless(name = DaoSharedDataValidatorCommand.COMMAND)\npublic class DaoSharedDataValidatorCommand implements Command {\n\tpublic static final String COMMAND = \"DaoSharedDataValidatorCommand\";\n\n\t@Resource\n\tprivate SessionContext daoContext;\n\n\t@EJB\n\tprivate TimetableDAO timetableDAO;\n\n\t@Override\n\t@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n\tpublic boolean execute(Context context) throws Exception {\n\t\tboolean result = Constant.ERROR;\n\t\tMonitor monitor = MonitorFactory.start(COMMAND);\n\t\tValidationData data = (ValidationData) context.get(Constant.VALIDATION_DATA);\n\t\tInitialContext initialContext = (InitialContext) context.get(Constant.INITIAL_CONTEXT);\n\t\tif (!context.containsKey(Constant.SOURCE)) {\n\t\t\tcontext.put(Constant.SOURCE, Constant.SOURCE_DATABASE);\n\t\t}\n\n\t\ttry {\n\n\t\t\tdata.getTimetables().clear();\n\t\t\tdata.getTimetables().addAll(timetableDAO.findAll());\n\n\t\t\tCommand validateSharedData = CommandFactory.create(initialContext,\n\t\t\t\t\tSharedDataValidatorCommand.class.getName());\n\t\t\tresult = validateSharedData.execute(context);\n\t\t\tdaoContext.setRollbackOnly();\n\t\t} finally {\n\t\t\tlog.info(Color.MAGENTA + monitor.stop() + Color.NORMAL);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static class DefaultCommandFactory extends CommandFactory {\n\n\t\t@Override\n\t\tprotected Command create(InitialContext context) throws IOException {\n\t\t\tCommand result = null;\n\t\t\ttry {\n\t\t\t\tString name = \"java:app/mobi.chouette.exchange.validator/\" + COMMAND;\n\t\t\t\tresult = (Command) context.lookup(name);\n\t\t\t} catch (NamingException e) {\n\t\t\t\t// try another way on test context\n\t\t\t\tString name = \"java:module/\" + COMMAND;\n\t\t\t\ttry {\n\t\t\t\t\tresult = (Command) context.lookup(name);\n\t\t\t\t} catch (NamingException e1) {\n\t\t\t\t\tlog.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic {\n\t\tCommandFactory.register(DaoSharedDataValidatorCommand.class.getName(), new DefaultCommandFactory());\n\t}\n\n}", "class_id": 0, "repo": "entur/chouette-core-iev", "file": "mobi.chouette.exchange.validator/src/main/java/mobi/chouette/exchange/validator/DaoSharedDataValidatorCommand.java", "last_update_at": "2018-05-25T14:53:36+00:00", "question_id": "8c50434f3bc55f4ad1f803e9a189b6c6567b621f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Log4j\n@Stateless(name = DaoSharedDataValidatorCommand.COMMAND)\npublic class DaoSharedDataValidatorCommand implements Command {\n\tpublic static final String COMMAND = \"DaoSharedDataValidatorCommand\";\n\t@Resource\n\tprivate SessionContext daoContext;\n\t@EJB\n\tprivate TimetableDAO timetableDAO;\n\t@Override\n\t@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n\tpublic boolean execute(Context context) throws Exception {\n\t\tboolean result = Constant.ERROR;\n\t\tMonitor monitor = MonitorFactory.start(COMMAND);\n\t\tValidationData data = (ValidationData) context.get(Constant.VALIDATION_DATA);\n\t\tInitialContext initialContext = (InitialContext) context.get(Constant.INITIAL_CONTEXT);\n\t\tif (!context.containsKey(Constant.SOURCE)) {\n\t\t\tcontext.put(Constant.SOURCE, Constant.SOURCE_DATABASE);\n\t\t}\n\t\ttry {\n\t\t\tdata.getTimetables().clear();\n\t\t\tdata.getTimetables().addAll(timetableDAO.findAll());\n\t\t\tCommand validateSharedData = CommandFactory.create(initialContext,\n\t\t\t\t\tSharedDataValidatorCommand.class.getName());\n\t\t\tresult = validateSharedData.execute(context);\n\t\t\tdaoContext.setRollbackOnly();\n\t\t} finally {\n\t\t\tlog.info(Color.MAGENTA + monitor.stop() + Color.NORMAL);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static class DefaultCommandFactory extends CommandFactory {\n\t\t@Override\n\t\tprotected Command create(InitialContext context) throws IOException {\n\t\t\tCommand result = null;\n\t\t\ttry {\n\t\t\t\tString name = \"java:app/mobi.chouette.exchange.validator/\" + COMMAND;\n\t\t\t\tresult = (Command) context.lookup(name);\n\t\t\t} catch (NamingException e) {\n\t\t\t\t// try another way on test context\n\t\t\t\tString name = \"java:module/\" + COMMAND;\n\t\t\t\ttry {\n\t\t\t\t\tresult = (Command) context.lookup(name);\n\t\t\t\t} catch (NamingException e1) {\n\t\t\t\t\tlog.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\tstatic {\n\t\tCommandFactory.register(DaoSharedDataValidatorCommand.class.getName(), new DefaultCommandFactory());\n\t}\n"]], "pred": {"ppl": 1.684581995010376, "ppl_lower": 2.2937562465667725, "ppl/lowercase_ppl": -1.591875290129187, "ppl/zlib": 0.0006669021212928619, "Min_5.0% Prob": 6.1866243423954135, "Min_10.0% Prob": 4.229884280098809, "Min_20.0% Prob": 2.507467206538193, "Min_30.0% Prob": 1.7250677100260845, "Min_40.0% Prob": 1.3056528292427676, "Min_50.0% Prob": 1.0441818322507523, "Min_60.0% Prob": 0.8695312279021472}}
{"hexsha": "99ac7f2d67b578310b72527f6584ccba754cc888", "ext": "java", "lang": "Java", "content": "public class SearchManagerImpl implements SearchManager {\n\n    // Log\n    @SuppressWarnings(\"unused\")\n    private static Log log = LogFactoryUtil.getLog(SearchManagerImpl.class);\n\n    /**\n     * Returns a list of buddies based on the search query. The search will be performed\n     * in first name, middle name, last name, screen name and email.\n     *\n     * @param userId      Long\n     * @param searchQuery String\n     * @param start       of the list\n     * @param end         of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    @Override\n    public List<Buddy> searchBuddies(Long userId, String searchQuery, int start, int end) throws Exception {\n        // Get selected list strategy\n        Environment.BuddyListStrategy strategy = Environment.getBuddyListStrategy();\n        // Get the info if the deactivated user should be ignored\n        boolean ignoreDeactivatedUser = Environment.getBuddyListIgnoreDeactivatedUser();\n        // Some sites or groups may be excluded\n        String[] excludedSites = Environment.getBuddyListSiteExcludes();\n        String[] excludedGroups = Environment.getBuddyListGroupExcludes();\n        // Relation types\n        Environment.BuddyListSocialRelation[] relationTypes = Environment.getBuddyListSocialRelations();\n\n        // All buddies\n        if (strategy == BuddyListStrategy.ALL) {\n            return searchAllBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, start, end\n            );\n        }\n        // Buddies from sites\n        else if (strategy == BuddyListStrategy.SITES) {\n            return searchSitesBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, start, end\n            );\n        }\n        // Buddies by social relations\n        else if (strategy == BuddyListStrategy.SOCIAL) {\n            return searchSocialBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, relationTypes, start, end\n            );\n        }\n        // Buddies by social relations together with sites\n        else if (strategy == BuddyListStrategy.SITES_AND_SOCIAL) {\n            return searchSitesAndSocialBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, relationTypes, start, end\n            );\n        }\n        // Buddies by user groups\n        else if (strategy == BuddyListStrategy.USER_GROUPS) {\n            return searchUserGroupsBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedGroups, start, end\n            );\n        }\n        // Unknown\n        else {\n            throw new Exception(\"Unknown buddy list strategy\");\n        }\n    }\n\n\n    /**\n     * Returns a list of buddies related to the user based on the search query\n     *\n     * @param userId                Long\n     * @param searchQuery           String\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchAllBuddies(Long userId,\n                                         String searchQuery,\n                                         boolean ignoreDefaultUser,\n                                         boolean ignoreDeactivatedUser,\n                                         int start,\n                                         int end) throws Exception {\n\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchAllBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, start, end\n        );\n\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n\n    /**\n     * Returns a list of buddies. The list is made of all buddies based on the search query in the sites\n     * where the user participates\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedSites         names of sites (groups) that should be excluded from the group collection\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSitesBuddies(Long userId,\n                                           String searchQuery,\n                                           boolean ignoreDefaultUser,\n                                           boolean ignoreDeactivatedUser,\n                                           String[] excludedSites,\n                                           int start,\n                                           int end) throws Exception {\n\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchSitesBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end\n        );\n\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query with whom the user\n     * has a social relationships given in the parameter.\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param relationTypes         an array of relation types enums\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSocialBuddies(Long userId,\n                                            String searchQuery,\n                                            boolean ignoreDefaultUser,\n                                            boolean ignoreDeactivatedUser,\n                                            BuddyListSocialRelation[] relationTypes,\n                                            int start,\n                                            int end) throws Exception {\n\n        // Get int codes from relation types since the persistence consumes an int array only.\n        int[] relationCodes = new int[relationTypes.length];\n        for (int i = 0; i < relationTypes.length; i++) {\n            relationCodes[i] = relationTypes[i].getCode();\n        }\n\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchSocialBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationCodes, start, end\n        );\n\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query that are\n     * in the same site and have a social relation given in parameter\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedSites         names of sites (groups) that should be excluded from the group collection\n     * @param relationTypes         an array of relation types enums\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return a list of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSitesAndSocialBuddies(Long userId,\n                                                    String searchQuery,\n                                                    boolean ignoreDefaultUser,\n                                                    boolean ignoreDeactivatedUser,\n                                                    String[] excludedSites,\n                                                    BuddyListSocialRelation[] relationTypes,\n                                                    int start,\n                                                    int end) throws Exception {\n\n        // Get site buddies\n        List<Buddy> siteBuddies = searchSitesBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end\n        );\n\n        // Get social buddies\n        List<Buddy> socialBuddies = searchSocialBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationTypes, start, end\n        );\n\n        // Add it to set since we want to get rid of duplicates\n        Set<Buddy> mergedBuddies = new HashSet<Buddy>();\n        mergedBuddies.addAll(siteBuddies);\n        mergedBuddies.addAll(socialBuddies);\n\n        return new LinkedList<Buddy>(mergedBuddies);\n    }\n\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query that are\n     * in the same user group as the user.\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedGroups        names of groups that should be excluded from the list of buddies\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return a list of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchUserGroupsBuddies(Long userId,\n                                                String searchQuery,\n                                                boolean ignoreDefaultUser,\n                                                boolean ignoreDeactivatedUser,\n                                                String[] excludedGroups,\n                                                int start,\n                                                int end) throws Exception {\n\n        // Get user groups\n        List<Object[]> users = SettingsLocalServiceUtil.searchUserGroupsBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedGroups, start, end\n        );\n\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n\n    /**\n     * Deserialize user objects to the list of buddies\n     *\n     * @param userObjects a list of user data stored in an object array\n     * @return List of buddies\n     */\n    private List<Buddy> deserializeBuddyListFromUserObjects(List<Object[]> userObjects) {\n\n        // Deserialize user info in plain objects to buddy\n        List<Buddy> buddies = new LinkedList<Buddy>();\n        for (Object[] userObject : userObjects) {\n            // Deserialize\n            Buddy buddy = Buddy.fromPlainObject(userObject, 0);\n            // Add to list\n            buddies.add(buddy);\n        }\n\n        return buddies;\n    }\n}", "class_id": 0, "repo": "marcelmika/lims", "file": "docroot/WEB-INF/src/com/marcelmika/lims/persistence/manager/SearchManagerImpl.java", "last_update_at": "2018-09-23T22:59:23+00:00", "question_id": "99ac7f2d67b578310b72527f6584ccba754cc888", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SearchManagerImpl implements SearchManager {\n    // Log\n    @SuppressWarnings(\"unused\")\n    private static Log log = LogFactoryUtil.getLog(SearchManagerImpl.class);\n    /**\n     * Returns a list of buddies based on the search query. The search will be performed\n     * in first name, middle name, last name, screen name and email.\n     *\n     * @param userId      Long\n     * @param searchQuery String\n     * @param start       of the list\n     * @param end         of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    @Override\n    public List<Buddy> searchBuddies(Long userId, String searchQuery, int start, int end) throws Exception {\n        // Get selected list strategy\n        Environment.BuddyListStrategy strategy = Environment.getBuddyListStrategy();\n        // Get the info if the deactivated user should be ignored\n        boolean ignoreDeactivatedUser = Environment.getBuddyListIgnoreDeactivatedUser();\n        // Some sites or groups may be excluded\n        String[] excludedSites = Environment.getBuddyListSiteExcludes();\n        String[] excludedGroups = Environment.getBuddyListGroupExcludes();\n        // Relation types\n        Environment.BuddyListSocialRelation[] relationTypes = Environment.getBuddyListSocialRelations();\n        // All buddies\n        if (strategy == BuddyListStrategy.ALL) {\n            return searchAllBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, start, end\n            );\n        }\n        // Buddies from sites\n        else if (strategy == BuddyListStrategy.SITES) {\n            return searchSitesBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, start, end\n            );\n        }\n        // Buddies by social relations\n        else if (strategy == BuddyListStrategy.SOCIAL) {\n            return searchSocialBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, relationTypes, start, end\n            );\n        }\n        // Buddies by social relations together with sites\n        else if (strategy == BuddyListStrategy.SITES_AND_SOCIAL) {\n            return searchSitesAndSocialBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, relationTypes, start, end\n            );\n        }\n        // Buddies by user groups\n        else if (strategy == BuddyListStrategy.USER_GROUPS) {\n            return searchUserGroupsBuddies(\n                    userId, searchQuery, true, ignoreDeactivatedUser, excludedGroups, start, end\n            );\n        }\n        // Unknown\n        else {\n            throw new Exception(\"Unknown buddy list strategy\");\n        }\n    }\n    /**\n     * Returns a list of buddies related to the user based on the search query\n     *\n     * @param userId                Long\n     * @param searchQuery           String\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchAllBuddies(Long userId,\n                                         String searchQuery,\n                                         boolean ignoreDefaultUser,\n                                         boolean ignoreDeactivatedUser,\n                                         int start,\n                                         int end) throws Exception {\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchAllBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, start, end\n        );\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n    /**\n     * Returns a list of buddies. The list is made of all buddies based on the search query in the sites\n     * where the user participates\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedSites         names of sites (groups) that should be excluded from the group collection\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSitesBuddies(Long userId,\n                                           String searchQuery,\n                                           boolean ignoreDefaultUser,\n                                           boolean ignoreDeactivatedUser,\n                                           String[] excludedSites,\n                                           int start,\n                                           int end) throws Exception {\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchSitesBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end\n        );\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query with whom the user\n     * has a social relationships given in the parameter.\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param relationTypes         an array of relation types enums\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return List of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSocialBuddies(Long userId,\n                                            String searchQuery,\n                                            boolean ignoreDefaultUser,\n                                            boolean ignoreDeactivatedUser,\n                                            BuddyListSocialRelation[] relationTypes,\n                                            int start,\n                                            int end) throws Exception {\n        // Get int codes from relation types since the persistence consumes an int array only.\n        int[] relationCodes = new int[relationTypes.length];\n        for (int i = 0; i < relationTypes.length; i++) {\n            relationCodes[i] = relationTypes[i].getCode();\n        }\n        // Get from persistence\n        List<Object[]> users = SettingsLocalServiceUtil.searchSocialBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationCodes, start, end\n        );\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query that are\n     * in the same site and have a social relation given in parameter\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedSites         names of sites (groups) that should be excluded from the group collection\n     * @param relationTypes         an array of relation types enums\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return a list of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchSitesAndSocialBuddies(Long userId,\n                                                    String searchQuery,\n                                                    boolean ignoreDefaultUser,\n                                                    boolean ignoreDeactivatedUser,\n                                                    String[] excludedSites,\n                                                    BuddyListSocialRelation[] relationTypes,\n                                                    int start,\n                                                    int end) throws Exception {\n        // Get site buddies\n        List<Buddy> siteBuddies = searchSitesBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end\n        );\n        // Get social buddies\n        List<Buddy> socialBuddies = searchSocialBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationTypes, start, end\n        );\n        // Add it to set since we want to get rid of duplicates\n        Set<Buddy> mergedBuddies = new HashSet<Buddy>();\n        mergedBuddies.addAll(siteBuddies);\n        mergedBuddies.addAll(socialBuddies);\n        return new LinkedList<Buddy>(mergedBuddies);\n    }\n    /**\n     * Returns a list of buddies. This list is made of all buddies based on the search query that are\n     * in the same user group as the user.\n     *\n     * @param userId                which should be excluded from the list\n     * @param searchQuery           search query string\n     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded\n     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded\n     * @param excludedGroups        names of groups that should be excluded from the list of buddies\n     * @param start                 of the list\n     * @param end                   of the list\n     * @return a list of buddies\n     * @throws Exception\n     */\n    private List<Buddy> searchUserGroupsBuddies(Long userId,\n                                                String searchQuery,\n                                                boolean ignoreDefaultUser,\n                                                boolean ignoreDeactivatedUser,\n                                                String[] excludedGroups,\n                                                int start,\n                                                int end) throws Exception {\n        // Get user groups\n        List<Object[]> users = SettingsLocalServiceUtil.searchUserGroupsBuddies(\n                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedGroups, start, end\n        );\n        // Return deserialized result\n        return deserializeBuddyListFromUserObjects(users);\n    }\n    /**\n     * Deserialize user objects to the list of buddies\n     *\n     * @param userObjects a list of user data stored in an object array\n     * @return List of buddies\n     */\n    private List<Buddy> deserializeBuddyListFromUserObjects(List<Object[]> userObjects) {\n        // Deserialize user info in plain objects to buddy\n        List<Buddy> buddies = new LinkedList<Buddy>();\n        for (Object[] userObject : userObjects) {\n            // Deserialize\n            Buddy buddy = Buddy.fromPlainObject(userObject, 0);\n            // Add to list\n            buddies.add(buddy);\n        }\n        return buddies;\n    }\n"]], "pred": {"ppl": 1.9144521951675415, "ppl_lower": 2.087066411972046, "ppl/lowercase_ppl": -1.1329284531065096, "ppl/zlib": 0.00037046863761832445, "Min_5.0% Prob": 7.171667444939707, "Min_10.0% Prob": 5.0654915956889885, "Min_20.0% Prob": 3.0479111899347866, "Min_30.0% Prob": 2.1329312281183945, "Min_40.0% Prob": 1.6166913012329553, "Min_50.0% Prob": 1.2984824510776016, "Min_60.0% Prob": 1.0834248379457037}}
{"hexsha": "cef7ccefd45b7b0a2984b821ad88cb0d91bd9cf0", "ext": "java", "lang": "Java", "content": "public class MinRemoveValidParan {\n\n    //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\n    public static void main( String[] args ) {\n        String str = \"lee(t(c)o)de)\";\n\n        System.out.println(minRemoveToMakeValid(str));\n    }\n\n    //similar to MinimumAddParnanValid\n    //Runtime: 19 ms, faster than 51.31% of Java\n    private static String minRemoveToMakeValid( String s ) {\n        Stack<Integer> stack = new Stack<>();\n\n        HashSet<Integer> removeIndices = new HashSet<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                stack.push(i);\n            else if (s.charAt(i) == ')') {\n                if (!stack.isEmpty())\n                    stack.pop();\n                else\n                    removeIndices.add(i);\n            }\n        }\n\n        //pop until brackets got balanced\n        while (!stack.isEmpty()) {\n            removeIndices.add(stack.pop());\n        }\n\n        //not appending the indices of brackets which are not balanced..\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (!removeIndices.contains(i))\n                sb.append(s.charAt(i));\n        }\n\n        return sb.toString();\n    }\n}", "class_id": 0, "repo": "prdp89/interview", "file": "src/com/interview/companies/fb/MinRemoveValidParan.java", "last_update_at": "2018-03-29T07:45:26+00:00", "question_id": "cef7ccefd45b7b0a2984b821ad88cb0d91bd9cf0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MinRemoveValidParan {\n    //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\n    public static void main( String[] args ) {\n        String str = \"lee(t(c)o)de)\";\n        System.out.println(minRemoveToMakeValid(str));\n    }\n    //similar to MinimumAddParnanValid\n    //Runtime: 19 ms, faster than 51.31% of Java\n    private static String minRemoveToMakeValid( String s ) {\n        Stack<Integer> stack = new Stack<>();\n        HashSet<Integer> removeIndices = new HashSet<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                stack.push(i);\n            else if (s.charAt(i) == ')') {\n                if (!stack.isEmpty())\n                    stack.pop();\n                else\n                    removeIndices.add(i);\n            }\n        }\n        //pop until brackets got balanced\n        while (!stack.isEmpty()) {\n            removeIndices.add(stack.pop());\n        }\n        //not appending the indices of brackets which are not balanced..\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (!removeIndices.contains(i))\n                sb.append(s.charAt(i));\n        }\n        return sb.toString();\n    }\n"]], "pred": {"ppl": 1.8957008123397827, "ppl_lower": 2.2891790866851807, "ppl/lowercase_ppl": -1.294884377629053, "ppl/zlib": 0.0011866207643457258, "Min_5.0% Prob": 7.371170361836751, "Min_10.0% Prob": 4.962113547969508, "Min_20.0% Prob": 3.0454373967647554, "Min_30.0% Prob": 2.113970445469022, "Min_40.0% Prob": 1.5919711376726626, "Min_50.0% Prob": 1.2806506455143825, "Min_60.0% Prob": 1.0654357007280406}}
{"hexsha": "d652044c69f807aa99b44cd18e14e2977bde6388", "ext": "java", "lang": "Java", "content": "public class Test {\n    public static void main(String... args) throws Exception {\n        new Test().run();\n    }\n\n    final File testSrc;\n    final File pluginSrc;\n    final File pluginClasses ;\n    final File pluginJar;\n    final List<String> ref1;\n    final List<String> ref2;\n    final JavaCompiler compiler;\n    final StandardJavaFileManager fm;\n    ToolBox tb = new ToolBox();\n\n    Test() throws Exception {\n        testSrc = new File(tb.testSrc);\n        pluginSrc = new File(testSrc, \"ShowTypePlugin.java\");\n        pluginClasses = new File(\"plugin\");\n        tb.createDirectories(pluginClasses.toPath());\n        pluginJar = new File(\"plugin.jar\");\n        ref1 = tb.readAllLines((new File(testSrc,\"Identifiers.out\")).toPath());\n        ref2 = tb.readAllLines((new File(testSrc,\"Identifiers_PI.out\")).toPath());\n        compiler = ToolProvider.getSystemJavaCompiler();\n        fm = compiler.getStandardFileManager(null, null, null);\n    }\n\n    void run() throws Exception {\n        try {\n            // compile the plugin explicitly, to a non-standard directory\n            // so that we don't find it on the wrong path by accident\n            new JavacTask(tb)\n              .options(\"-d\", pluginClasses.getPath())\n              .files(pluginSrc.getPath())\n              .run();\n\n            File plugin = new File(pluginClasses.getPath(), \"META-INF/services/com.sun.source.util.Plugin\");\n            tb.writeFile(plugin.getPath(), \"ShowTypePlugin\\n\");\n            new JarTask(tb)\n              .run(\"cf\", pluginJar.getPath(), \"-C\", pluginClasses.getPath(), \".\");\n\n            testCommandLine(\"-Xplugin:showtype\", ref1);\n            testCommandLine(\"-Xplugin:showtype PI\", ref2);\n            testAPI(\"-Xplugin:showtype\", ref1);\n            testAPI(\"-Xplugin:showtype PI\", ref2);\n\n            if (errors > 0)\n                throw new Exception(errors + \" errors occurred\");\n        } finally {\n            fm.close();\n        }\n    }\n\n    void testAPI(String opt, List<String> ref) throws Exception {\n        File identifiers = new File(testSrc, \"Identifiers.java\");\n        fm.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, Arrays.asList(pluginJar));\n        fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(\".\")));\n        List<String> options = Arrays.asList(opt);\n        Iterable<? extends JavaFileObject> files = fm.getJavaFileObjects(identifiers);\n\n        System.err.println(\"test api: \" + options + \" \" + files);\n        Task.Result result = new JavacTask(tb, Task.Mode.API)\n                                  .fileManager(fm)\n                                  .options(opt)\n                                  .files(identifiers.toPath())\n                                  .run(Task.Expect.SUCCESS)\n                                  .writeAll();\n        String out = result.getOutput(Task.OutputKind.DIRECT);\n        checkOutput(out, ref);\n    }\n\n    void testCommandLine(String opt, List<String> ref) {\n        File identifiers = new File(testSrc, \"Identifiers.java\");\n        String[] args = {\n            \"-d\", \".\",\n            \"-processorpath\", pluginJar.getPath(),\n            opt,\n            identifiers.getPath() };\n\n        System.err.println(\"test command line: \" + Arrays.asList(args));\n        Task.Result result = new JavacTask(tb, Task.Mode.CMDLINE)\n                                  .options(args)\n                                  .run(Task.Expect.SUCCESS)\n                                  .writeAll();\n        String out = result.getOutput(Task.OutputKind.DIRECT);\n        checkOutput(out, ref);\n    }\n\n    private void checkOutput(String out, List<String> ref) {\n        List<String> lines = Arrays.asList(out\n                .replaceAll(\".*?([A-Za-z.]+:[0-9]+: .*)\", \"$1\") // remove file directory\n                .split(\"[\\r\\n]+\"));                             // allow for newline formats\n        if (!lines.equals(ref)) {\n            error(\"unexpected output\");\n        }\n    }\n\n    private void error(String msg) {\n        System.err.println(msg);\n        errors++;\n    }\n\n    int errors;\n}", "class_id": 0, "repo": "iootclab/openjdk", "file": "openjdk11/test/langtools/tools/javac/plugin/showtype/Test.java", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "d652044c69f807aa99b44cd18e14e2977bde6388", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Test {\n    public static void main(String... args) throws Exception {\n        new Test().run();\n    }\n    final File testSrc;\n    final File pluginSrc;\n    final File pluginClasses ;\n    final File pluginJar;\n    final List<String> ref1;\n    final List<String> ref2;\n    final JavaCompiler compiler;\n    final StandardJavaFileManager fm;\n    ToolBox tb = new ToolBox();\n    Test() throws Exception {\n        testSrc = new File(tb.testSrc);\n        pluginSrc = new File(testSrc, \"ShowTypePlugin.java\");\n        pluginClasses = new File(\"plugin\");\n        tb.createDirectories(pluginClasses.toPath());\n        pluginJar = new File(\"plugin.jar\");\n        ref1 = tb.readAllLines((new File(testSrc,\"Identifiers.out\")).toPath());\n        ref2 = tb.readAllLines((new File(testSrc,\"Identifiers_PI.out\")).toPath());\n        compiler = ToolProvider.getSystemJavaCompiler();\n        fm = compiler.getStandardFileManager(null, null, null);\n    }\n    void run() throws Exception {\n        try {\n            // compile the plugin explicitly, to a non-standard directory\n            // so that we don't find it on the wrong path by accident\n            new JavacTask(tb)\n              .options(\"-d\", pluginClasses.getPath())\n              .files(pluginSrc.getPath())\n              .run();\n            File plugin = new File(pluginClasses.getPath(), \"META-INF/services/com.sun.source.util.Plugin\");\n            tb.writeFile(plugin.getPath(), \"ShowTypePlugin\\n\");\n            new JarTask(tb)\n              .run(\"cf\", pluginJar.getPath(), \"-C\", pluginClasses.getPath(), \".\");\n            testCommandLine(\"-Xplugin:showtype\", ref1);\n            testCommandLine(\"-Xplugin:showtype PI\", ref2);\n            testAPI(\"-Xplugin:showtype\", ref1);\n            testAPI(\"-Xplugin:showtype PI\", ref2);\n            if (errors > 0)\n                throw new Exception(errors + \" errors occurred\");\n        } finally {\n            fm.close();\n        }\n    }\n    void testAPI(String opt, List<String> ref) throws Exception {\n        File identifiers = new File(testSrc, \"Identifiers.java\");\n        fm.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, Arrays.asList(pluginJar));\n        fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(\".\")));\n        List<String> options = Arrays.asList(opt);\n        Iterable<? extends JavaFileObject> files = fm.getJavaFileObjects(identifiers);\n        System.err.println(\"test api: \" + options + \" \" + files);\n        Task.Result result = new JavacTask(tb, Task.Mode.API)\n                                  .fileManager(fm)\n                                  .options(opt)\n                                  .files(identifiers.toPath())\n                                  .run(Task.Expect.SUCCESS)\n                                  .writeAll();\n        String out = result.getOutput(Task.OutputKind.DIRECT);\n        checkOutput(out, ref);\n    }\n    void testCommandLine(String opt, List<String> ref) {\n        File identifiers = new File(testSrc, \"Identifiers.java\");\n        String[] args = {\n            \"-d\", \".\",\n            \"-processorpath\", pluginJar.getPath(),\n            opt,\n            identifiers.getPath() };\n        System.err.println(\"test command line: \" + Arrays.asList(args));\n        Task.Result result = new JavacTask(tb, Task.Mode.CMDLINE)\n                                  .options(args)\n                                  .run(Task.Expect.SUCCESS)\n                                  .writeAll();\n        String out = result.getOutput(Task.OutputKind.DIRECT);\n        checkOutput(out, ref);\n    }\n    private void checkOutput(String out, List<String> ref) {\n        List<String> lines = Arrays.asList(out\n                .replaceAll(\".*?([A-Za-z.]+:[0-9]+: .*)\", \"$1\") // remove file directory\n                .split(\"[\\r\\n]+\"));                             // allow for newline formats\n        if (!lines.equals(ref)) {\n            error(\"unexpected output\");\n        }\n    }\n    private void error(String msg) {\n        System.err.println(msg);\n        errors++;\n    }\n    int errors;\n"]], "pred": {"ppl": 1.8058781623840332, "ppl_lower": 2.4689040184020996, "ppl/lowercase_ppl": -1.5291074147519679, "ppl/zlib": 0.00047397513234185044, "Min_5.0% Prob": 6.104882282369277, "Min_10.0% Prob": 4.439858261276694, "Min_20.0% Prob": 2.7563734302918115, "Min_30.0% Prob": 1.9325184857144075, "Min_40.0% Prob": 1.4689756668830851, "Min_50.0% Prob": 1.1808851218496226, "Min_60.0% Prob": 0.9857245652775355}}
{"hexsha": "240bf8060b22fd49e32e2bbba78248e881a5c84a", "ext": "java", "lang": "Java", "content": "public class AlienFXActionMorph extends AlienFXActionBlink{\t\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate ColorModel model = new ColorModel();\n\t\n\tpublic AlienFXActionMorph(Color c, Color c2) {\n\t\tsuper(c);\n\t\tmodel.setColor(c2);\n\t\tmodel.addObserver(new ModelObserver(model));\n\t}\n\t\n\tpublic Color getMorphToColor() {\n\t\treturn model.getColor();\n\t}\n\t\n\tpublic ColorModel getMorphToColorModel(){\n\t\treturn model;\n\t}\n\t\n\t@Override\n\tpublic Color getTrailingColor() {\n\t\treturn getMorphToColor();\n\t}\n\t\n\t@Override\n\tpublic ColorModel getTrailingColorModel() {\n\t\treturn model;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn AlienFXTexts.ACTION_MORPH_TEXT;\n\t}\n\t\n\tpublic AlienFXAction clone() {\n\t\treturn new AlienFXActionMorph(getColor(), getMorphToColor());\n\t}\n\t\n\tpublic void loaded() {\n\t\tsuper.loaded();\n\t\tmodel.addObserver(new ModelObserver(model));\n\t}\n\t\n\tpublic void setMorphToColor(Color morphToColor) {\n\t\tmodel.setColor(morphToColor);\n\t\tsetChanged();\n\t\tnotifyObservers(this);\n\t}\n}", "class_id": 0, "repo": "brendonjkding/AlienFxLite", "file": "src/java/uk/co/progger/alienFXLite/alienfx/AlienFXActionMorph.java", "last_update_at": "2018-02-06T07:38:15+00:00", "question_id": "240bf8060b22fd49e32e2bbba78248e881a5c84a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AlienFXActionMorph extends AlienFXActionBlink{\t\n\tprivate static final long serialVersionUID = 1L;\n\tprivate ColorModel model = new ColorModel();\n\t\n\tpublic AlienFXActionMorph(Color c, Color c2) {\n\t\tsuper(c);\n\t\tmodel.setColor(c2);\n\t\tmodel.addObserver(new ModelObserver(model));\n\t}\n\t\n\tpublic Color getMorphToColor() {\n\t\treturn model.getColor();\n\t}\n\t\n\tpublic ColorModel getMorphToColorModel(){\n\t\treturn model;\n\t}\n\t\n\t@Override\n\tpublic Color getTrailingColor() {\n\t\treturn getMorphToColor();\n\t}\n\t\n\t@Override\n\tpublic ColorModel getTrailingColorModel() {\n\t\treturn model;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn AlienFXTexts.ACTION_MORPH_TEXT;\n\t}\n\t\n\tpublic AlienFXAction clone() {\n\t\treturn new AlienFXActionMorph(getColor(), getMorphToColor());\n\t}\n\t\n\tpublic void loaded() {\n\t\tsuper.loaded();\n\t\tmodel.addObserver(new ModelObserver(model));\n\t}\n\t\n\tpublic void setMorphToColor(Color morphToColor) {\n\t\tmodel.setColor(morphToColor);\n\t\tsetChanged();\n\t\tnotifyObservers(this);\n\t}\n"]], "pred": {"ppl": 2.179023265838623, "ppl_lower": 2.4241175651550293, "ppl/lowercase_ppl": -1.1368519943615398, "ppl/zlib": 0.0021222799269928158, "Min_5.0% Prob": 6.912752740523395, "Min_10.0% Prob": 4.9155904565538675, "Min_20.0% Prob": 3.3606889128684996, "Min_30.0% Prob": 2.4653240495695257, "Min_40.0% Prob": 1.9249233406908968, "Min_50.0% Prob": 1.5477339931379603, "Min_60.0% Prob": 1.2967147533781826}}
{"hexsha": "ad3c6e2345d2f23dacc98842b3bf0859b8ad29a7", "ext": "java", "lang": "Java", "content": "class StagedModeAccumulator<T> extends ModeAccumulatorImpl<T> {\n\n    private final ModeAccumulator<T> previousStage;\n\n    StagedModeAccumulator(final ModeAccumulator<T> previousStage) {\n        this.previousStage = previousStage;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return super.isEmpty() && this.previousStage.isEmpty();\n    }\n\n    @Override\n    public Bag<T> getValues() {\n        final Bag<T> values = new HashBag<>(super.getValues());\n\n        values.addAll(this.previousStage.getValues());\n        return values;\n    }\n\n    @Override\n    public String toString() {\n        //noinspection DuplicateStringLiteralInspection\n        return MoreObjects.toStringHelper(this)\n                .add(\"previousStage\", this.previousStage)\n                .toString();\n    }\n}", "class_id": 0, "repo": "JPDSousa/rookit", "file": "rookit-accumulator/rookit-accumulator-core/src/main/java/accumulator/opaque/StagedModeAccumulator.java", "last_update_at": "2018-01-06T19:08:47+00:00", "question_id": "ad3c6e2345d2f23dacc98842b3bf0859b8ad29a7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class StagedModeAccumulator<T> extends ModeAccumulatorImpl<T> {\n    private final ModeAccumulator<T> previousStage;\n    StagedModeAccumulator(final ModeAccumulator<T> previousStage) {\n        this.previousStage = previousStage;\n    }\n    @Override\n    public boolean isEmpty() {\n        return super.isEmpty() && this.previousStage.isEmpty();\n    }\n    @Override\n    public Bag<T> getValues() {\n        final Bag<T> values = new HashBag<>(super.getValues());\n        values.addAll(this.previousStage.getValues());\n        return values;\n    }\n    @Override\n    public String toString() {\n        //noinspection DuplicateStringLiteralInspection\n        return MoreObjects.toStringHelper(this)\n                .add(\"previousStage\", this.previousStage)\n                .toString();\n    }\n"]], "pred": {"ppl": 1.973340392112732, "ppl_lower": 2.5818686485290527, "ppl/lowercase_ppl": -1.3954313868419324, "ppl/zlib": 0.002228615532149382, "Min_5.0% Prob": 7.012101823633367, "Min_10.0% Prob": 5.104836615649137, "Min_20.0% Prob": 3.195006709207188, "Min_30.0% Prob": 2.2359287519798134, "Min_40.0% Prob": 1.6984622420912439, "Min_50.0% Prob": 1.3631454868665474, "Min_60.0% Prob": 1.137335990989496}}
{"hexsha": "20a70f427e5eae6e24a424a59041d0a32ecd9de2", "ext": "java", "lang": "Java", "content": "public class Task11165 {\r\n    public int[] changed(int[] array, int n, int m) {\r\n        int[] mediumResult = new int[array.length * 3];\r\n        int count = 0;\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (array[i] > n) {\r\n                mediumResult[i + count] = n;\r\n                count++;\r\n                mediumResult[i + count] = array[i];\r\n            }\r\n            if (array[i] < m) {\r\n                mediumResult[i + count] = array[i];\r\n                count++;\r\n                mediumResult[i + count] = m;\r\n            }\r\n        }\r\n        int[] result = new int[array.length + count];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = mediumResult[i];\r\n        }\r\n        return result;\r\n    }\r\n}", "class_id": 0, "repo": "Massimilian/Vasily-Maslov", "file": "chapter_002/src/main/java/ru/job4j/homeworks/tasks/Task11165.java", "last_update_at": "2018-07-14T14:13:05+00:00", "question_id": "20a70f427e5eae6e24a424a59041d0a32ecd9de2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Task11165 {\r\n    public int[] changed(int[] array, int n, int m) {\r\n        int[] mediumResult = new int[array.length * 3];\r\n        int count = 0;\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (array[i] > n) {\r\n                mediumResult[i + count] = n;\r\n                count++;\r\n                mediumResult[i + count] = array[i];\r\n            }\r\n            if (array[i] < m) {\r\n                mediumResult[i + count] = array[i];\r\n                count++;\r\n                mediumResult[i + count] = m;\r\n            }\r\n        }\r\n        int[] result = new int[array.length + count];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = mediumResult[i];\r\n        }\r\n        return result;\r\n    }\r\n"]], "pred": {"ppl": 1.7444959878921509, "ppl_lower": 1.8001867532730103, "ppl/lowercase_ppl": -1.0564719992384557, "ppl/zlib": 0.0023882647286731984, "Min_5.0% Prob": 6.027925339612094, "Min_10.0% Prob": 4.209669548532237, "Min_20.0% Prob": 2.5957975627287575, "Min_30.0% Prob": 1.8137633852336719, "Min_40.0% Prob": 1.3802330553855584, "Min_50.0% Prob": 1.109869853488129, "Min_60.0% Prob": 0.9266444395491988}}
{"hexsha": "3fc11ba4baa216b5230960773ff3e9fd9138895f", "ext": "java", "lang": "Java", "content": "public class UserRoleTest\n{\n\n    private EntityManagerFactory emf;\n\n    /** The em. */\n    private EntityManager em;\n\n    /**\n     * Sets the up.\n     */\n    @Before\n    public void setUp()\n    {\n        emf = Persistence.createEntityManagerFactory(\"mongoTest\");\n        em = emf.createEntityManager();\n    }\n\n    /**\n     * Test association.\n     */\n    @Test\n    public void testPersist()\n    {\n        RoleMongo rol = new RoleMongo();\n        rol.setRolId(1);\n        rol.setName(\"Administrador\");\n        User u = new User();\n        u.setAge(15);\n        u.setEmail(\"usuario1@infos.com\");\n        u.setName(\"usuario1\");\n        u.setUserId(1);\n        u.setLastName(\"apellido1\");\n        User u2 = new User();\n        u2.setAge(17);\n        u2.setEmail(\"usuario2@infos.com\");\n        u2.setName(\"usuario2\");\n        u2.setUserId(2);\n        u2.setLastName(\"apellido2\");\n        u.setUserRol(rol);\n        u2.setUserRol(rol);\n        List<User> users = new ArrayList<User>();\n        users.add(u);\n        users.add(u2);\n        rol.setSegUsuarioList(users);\n        em.persist(rol);\n\n    }\n\n    /**\n     * Test findby role.\n     */\n    @Test\n    public void testFindbyRole()\n    {\n        testPersist();\n        String query = \"Select r from RoleMongo r\";\n        Query q = em.createQuery(query);\n        List<RoleMongo> roles = q.getResultList();\n        Assert.assertNotNull(roles);\n        Assert.assertEquals(1, roles.size());\n    }\n\n    /**\n     * Test findby user.\n     */\n    @Test\n    public void testFindbyUser()\n    {\n        testPersist();\n        List<User> users = getAllUsers();\n        Assert.assertNotNull(users);\n        Assert.assertEquals(2, users.size());\n    }\n\n    /**\n     * Tear down.\n     */\n    @After\n    public void tearDown()\n    {\n        RoleMongo rol = em.find(RoleMongo.class, 1);\n        if (rol != null)\n        {\n            em.remove(rol);\n        }\n\n        MongoUtils.dropDatabase(emf, \"mongoTest\");\n        em.close();\n\n        em = null;\n        emf.close();\n    }\n\n    /**\n     * @return\n     */\n    private List<User> getAllUsers()\n    {\n        String query = \"Select u from User u\";\n        Query q = em.createQuery(query);\n        List<User> users = q.getResultList();\n        return users;\n    }\n}", "class_id": 0, "repo": "gburd/Kundera", "file": "src/kundera-mongo/src/test/java/com/impetus/client/crud/UserRoleTest.java", "last_update_at": "2018-01-27T12:13:16+00:00", "question_id": "3fc11ba4baa216b5230960773ff3e9fd9138895f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UserRoleTest\n{\n    private EntityManagerFactory emf;\n    /** The em. */\n    private EntityManager em;\n    /**\n     * Sets the up.\n     */\n    @Before\n    public void setUp()\n    {\n        emf = Persistence.createEntityManagerFactory(\"mongoTest\");\n        em = emf.createEntityManager();\n    }\n    /**\n     * Test association.\n     */\n    @Test\n    public void testPersist()\n    {\n        RoleMongo rol = new RoleMongo();\n        rol.setRolId(1);\n        rol.setName(\"Administrador\");\n        User u = new User();\n        u.setAge(15);\n        u.setEmail(\"usuario1@infos.com\");\n        u.setName(\"usuario1\");\n        u.setUserId(1);\n        u.setLastName(\"apellido1\");\n        User u2 = new User();\n        u2.setAge(17);\n        u2.setEmail(\"usuario2@infos.com\");\n        u2.setName(\"usuario2\");\n        u2.setUserId(2);\n        u2.setLastName(\"apellido2\");\n        u.setUserRol(rol);\n        u2.setUserRol(rol);\n        List<User> users = new ArrayList<User>();\n        users.add(u);\n        users.add(u2);\n        rol.setSegUsuarioList(users);\n        em.persist(rol);\n    }\n    /**\n     * Test findby role.\n     */\n    @Test\n    public void testFindbyRole()\n    {\n        testPersist();\n        String query = \"Select r from RoleMongo r\";\n        Query q = em.createQuery(query);\n        List<RoleMongo> roles = q.getResultList();\n        Assert.assertNotNull(roles);\n        Assert.assertEquals(1, roles.size());\n    }\n    /**\n     * Test findby user.\n     */\n    @Test\n    public void testFindbyUser()\n    {\n        testPersist();\n        List<User> users = getAllUsers();\n        Assert.assertNotNull(users);\n        Assert.assertEquals(2, users.size());\n    }\n    /**\n     * Tear down.\n     */\n    @After\n    public void tearDown()\n    {\n        RoleMongo rol = em.find(RoleMongo.class, 1);\n        if (rol != null)\n        {\n            em.remove(rol);\n        }\n        MongoUtils.dropDatabase(emf, \"mongoTest\");\n        em.close();\n        em = null;\n        emf.close();\n    }\n    /**\n     * @return\n     */\n    private List<User> getAllUsers()\n    {\n        String query = \"Select u from User u\";\n        Query q = em.createQuery(query);\n        List<User> users = q.getResultList();\n        return users;\n    }\n"]], "pred": {"ppl": 1.6028352975845337, "ppl_lower": 1.7952954769134521, "ppl/lowercase_ppl": -1.240359723464333, "ppl/zlib": 0.0006817545115439394, "Min_5.0% Prob": 5.6112335694802775, "Min_10.0% Prob": 3.866508980055113, "Min_20.0% Prob": 2.246509723415311, "Min_30.0% Prob": 1.5520916314536681, "Min_40.0% Prob": 1.1727880968355993, "Min_50.0% Prob": 0.9429182801095228, "Min_60.0% Prob": 0.785764405173635}}
{"hexsha": "4cf2b02648798413dbfd2bef7368b982b182d53a", "ext": "java", "lang": "Java", "content": "public class StatisticsPersisterTest {\n\n    private ObservationsRepository repository;\n\n    @BeforeMethod\n    public void setUp() throws Exception {\n        repository = mock(ObservationsRepository.class);\n\n    }\n\n    @Test\n    public void testStartScheduler() throws Exception {\n        StatisticsPersister persister = new StatisticsPersister(1,1,3);\n        persister.startScheduler(repository, \"testprefix\");\n        Thread.sleep(1500);\n        verify(repository).persistAndResetStatistics(eq(\"testprefix\"), eq(1L));\n\n    }\n\n\n}", "class_id": 0, "repo": "valuereporter/_deprecated-Valuereporter", "file": "src/test/java/org/valuereporter/scheduler/StatisticsPersisterTest.java", "last_update_at": "2018-12-03T18:41:19+00:00", "question_id": "4cf2b02648798413dbfd2bef7368b982b182d53a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatisticsPersisterTest {\n    private ObservationsRepository repository;\n    @BeforeMethod\n    public void setUp() throws Exception {\n        repository = mock(ObservationsRepository.class);\n    }\n    @Test\n    public void testStartScheduler() throws Exception {\n        StatisticsPersister persister = new StatisticsPersister(1,1,3);\n        persister.startScheduler(repository, \"testprefix\");\n        Thread.sleep(1500);\n        verify(repository).persistAndResetStatistics(eq(\"testprefix\"), eq(1L));\n    }\n"]], "pred": {"ppl": 3.0865330696105957, "ppl_lower": 4.130945682525635, "ppl/lowercase_ppl": -1.2586027916644458, "ppl/zlib": 0.004385402634512366, "Min_5.0% Prob": 8.66174806867327, "Min_10.0% Prob": 6.613920518330166, "Min_20.0% Prob": 4.480387777090073, "Min_30.0% Prob": 3.4114131459168027, "Min_40.0% Prob": 2.727878473699093, "Min_50.0% Prob": 2.2196062964872576, "Min_60.0% Prob": 1.8751326718751122}}
{"hexsha": "65196942232bf864dc2c40e5226176c75b1b569b", "ext": "java", "lang": "Java", "content": "@RequiredArgsConstructor\n@RestController\n@RequestMapping(path = \"power-outlets\")\npublic class PowerOutletController {\n\n    private final PowerOutletService powerOutletService;\n    private final RoomService roomService;\n\n    private ExecutorService executorService;\n\n    @PostConstruct\n    public void init() {\n        executorService = Executors.newFixedThreadPool(4);\n    }\n\n    @GetMapping\n    public List<PowerOutlet> getPowerOutlets() {\n        ResponseEntity<Resources<Resource<PowerOutlet>>> response = powerOutletService.determinePowerOutlets();\n        Collection<Resource<PowerOutlet>> content = response.getBody().getContent();\n        Map<String, Room> rooms = determineRooms(content);\n        return content.stream()\n                .peek(resource -> resource.getContent().setRoom(rooms.get(resource.getLink(\"room\").getHref())))\n                .map(Resource::getContent)\n                .collect(Collectors.toList());\n    }\n\n    private Map<String, Room> determineRooms(Collection<Resource<PowerOutlet>> powerOutlets) {\n        return powerOutlets.stream()\n                .map(resource -> resource.getLink(\"room\"))\n                .filter(Objects::nonNull)\n                .map(Link::getHref)\n                .distinct()\n                .map(href -> new Entry<Callable<Room>>(href, () -> roomService.determineRoom(href)))\n                .map(entry -> new Entry<>(entry.getKey(), executorService.submit(entry.getValue())))\n                .collect(Collectors.toMap(Entry::getKey, this::resolveFuture));\n    }\n\n    private Room resolveFuture(Entry<Future<Room>> entry) {\n        try {\n            return entry.getValue().get();\n        } catch(InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @RequiredArgsConstructor\n    @Getter\n    private static class Entry<V> {\n\n        private final String key;\n        private final V value;\n    }\n}", "class_id": 0, "repo": "gossie/home-automatisation", "file": "gateway-service/src/main/java/com/github/gossie/home/gatewayservice/poweroutlet/PowerOutletController.java", "last_update_at": "2018-06-20T08:31:54+00:00", "question_id": "65196942232bf864dc2c40e5226176c75b1b569b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RequiredArgsConstructor\n@RestController\n@RequestMapping(path = \"power-outlets\")\npublic class PowerOutletController {\n    private final PowerOutletService powerOutletService;\n    private final RoomService roomService;\n    private ExecutorService executorService;\n    @PostConstruct\n    public void init() {\n        executorService = Executors.newFixedThreadPool(4);\n    }\n    @GetMapping\n    public List<PowerOutlet> getPowerOutlets() {\n        ResponseEntity<Resources<Resource<PowerOutlet>>> response = powerOutletService.determinePowerOutlets();\n        Collection<Resource<PowerOutlet>> content = response.getBody().getContent();\n        Map<String, Room> rooms = determineRooms(content);\n        return content.stream()\n                .peek(resource -> resource.getContent().setRoom(rooms.get(resource.getLink(\"room\").getHref())))\n                .map(Resource::getContent)\n                .collect(Collectors.toList());\n    }\n    private Map<String, Room> determineRooms(Collection<Resource<PowerOutlet>> powerOutlets) {\n        return powerOutlets.stream()\n                .map(resource -> resource.getLink(\"room\"))\n                .filter(Objects::nonNull)\n                .map(Link::getHref)\n                .distinct()\n                .map(href -> new Entry<Callable<Room>>(href, () -> roomService.determineRoom(href)))\n                .map(entry -> new Entry<>(entry.getKey(), executorService.submit(entry.getValue())))\n                .collect(Collectors.toMap(Entry::getKey, this::resolveFuture));\n    }\n    private Room resolveFuture(Entry<Future<Room>> entry) {\n        try {\n            return entry.getValue().get();\n        } catch(InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    @RequiredArgsConstructor\n    @Getter\n    private static class Entry<V> {\n        private final String key;\n        private final V value;\n    }\n"]], "pred": {"ppl": 1.681389331817627, "ppl_lower": 2.170323371887207, "ppl/lowercase_ppl": -1.4912349933568214, "ppl/zlib": 0.0007498130373415968, "Min_5.0% Prob": 6.727967490752538, "Min_10.0% Prob": 4.222568222454616, "Min_20.0% Prob": 2.4353890744122593, "Min_30.0% Prob": 1.7024858108902938, "Min_40.0% Prob": 1.2942506389776667, "Min_50.0% Prob": 1.0391350799991963, "Min_60.0% Prob": 0.8665877131738989}}
{"hexsha": "30fb1f555589dc920e3a5c9ea7000387ab1ca324", "ext": "java", "lang": "Java", "content": "public class IperfUtils {\n\n    private static final String Iperf_TAG = \"Iperf\";\n\n    /**\n     * create iperf binary from raw to data directory\n     * and change its attribute to be executed\n     *\n     * @param context context\n     */\n    public static void createIperf(Context context) {\n        try {\n            InputStream is = context.getResources().openRawResource(R.raw.iperf3);\n            FileOutputStream fos = context.openFileOutput(\"iperf3\", Context.MODE_PRIVATE);\n\n            int len;\n            byte[] buf = new byte[1024];\n            while ((len = is.read(buf)) > 0) {\n                fos.write(buf, 0, len);\n            }\n\n            is.close();\n            fos.close();\n\n            Runtime.getRuntime().exec(\n                    new String[]{\n                            \"chmod\",\n                            \"755\",\n                            context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3\"});\n\n        } catch (Exception e) {\n            Log.e(Iperf_TAG, \"Exception in creating iperf, error message = \" + e.getMessage());\n        }\n    }\n\n    /**\n     * run iperf command and collect the output string for usage\n     *\n     * @param context      context\n     * @param iperfOptions iperf options\n     * @return iperf output, if ok return the normal result, if contains error return null\n     */\n    public static IperfResult runIperf(Context context, IperfOptions iperfOptions) {\n        IperfResult iperfResult = new IperfResult();\n        iperfResult.setResultType(IperfResultType.RIGHT);\n\n        String str = \"\";\n\n        try {\n            //Process process = Runtime.getRuntime().exec(\n            // new String[] {\n            //\"su\",\n            //\"-c\",\n            //context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3 \"\n            // + iperfOptions.toString()});\n            Process process = Runtime.getRuntime().exec(context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3 \"\n                    + iperfOptions.toString());\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                str += line;\n            }\n\n            br.close();\n\n            // waits for the command to finish\n            process.waitFor();\n\n            // if output contains error, the returned result is error message\n            if (str.equals(\"\")) {\n                iperfResult.setResultType(IperfResultType.IS_NULL);\n            } else if (!str.equals(\"\") && str.contains(\"error\")) {\n                iperfResult.setResultType(IperfResultType.GET_ERROR);\n            }\n\n        } catch (IOException e) {\n            Log.e(Iperf_TAG, \"Error running iperf, error msg = \" + e.getMessage());\n            str = e.getMessage();\n            iperfResult.setResultType(IperfResultType.GET_EXCEPTION);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        iperfResult.setResult(str);\n\n        return iperfResult;\n    }\n\n    /**\n     * find the pid of iperf by using and parsing the ps command output\n     *\n     * @return pid of iperf\n     */\n    public static String getIperfPID() {\n        String pid = null;\n\n        try {\n            // run ps to get the process list\n            Process process = Runtime.getRuntime().exec(\"ps\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n            // find the pid column, for it varies with different versions of ps\n            int pidColumn = 0;\n            int i = 0;\n            String line;\n\n            // split first line by regular expression, which matches one or many whitespaces\n            line = br.readLine();\n            String[] columnNames = line.split(\"\\\\s+\");\n            for (String col : columnNames) {\n                if (col.equalsIgnoreCase(\"PID\")) {\n                    pidColumn = i;\n                    break;\n                }\n                i++;\n            }\n\n            // parse process list to find iperf entry\n            while ((line = br.readLine()) != null) {\n                if (line.contains(\"iperf3\") && line.contains(\"cn.dizhangcs.crowdsignal.bandwidthtester\")\n                        && !line.contains(\"sh -c\")) {\n\n                    // split the line by white space\n                    String strs[] = line.split(\"\\\\s+\");\n                    pid = strs[pidColumn];\n                    break;\n                }\n            }\n\n            br.close();\n\n        } catch (IOException ie) {\n            Log.e(Iperf_TAG, \"Error getting tcpdump pid, error msg = \" + ie.getMessage());\n        }\n\n        return pid;\n    }\n\n    /**\n     * Check to see if iperf is running\n     *\n     * @return whether iperf is running\n     */\n    public static boolean isIperfRunning() {\n        return getIperfPID() != null;\n    }\n\n    public static void stopIperf() {\n        try {\n            String pid = getIperfPID();\n\n            // iperf is not running\n            if (pid == null) {\n                return;\n            }\n\n            Process process = Runtime.getRuntime().exec(new String[]{\"su\", \"-c\", \"kill \" + pid});\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n\n            //check errors\n            String line;\n            while ((line = br.readLine()) != null) {\n                Log.e(Iperf_TAG, \"kill tcpdump error, error msg = \" + line);\n            }\n\n            br.close();\n\n        } catch (IOException e) {\n            Log.e(Iperf_TAG, \"kill iperf error, error msg = \" + e.getMessage());\n        }\n    }\n}", "class_id": 0, "repo": "dizhang/EnergyTool", "file": "app/src/main/java/cn/edu/tsinghua/cs/energytool/iperf/util/IperfUtils.java", "last_update_at": "2018-05-31T07:09:01+00:00", "question_id": "30fb1f555589dc920e3a5c9ea7000387ab1ca324", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IperfUtils {\n    private static final String Iperf_TAG = \"Iperf\";\n    /**\n     * create iperf binary from raw to data directory\n     * and change its attribute to be executed\n     *\n     * @param context context\n     */\n    public static void createIperf(Context context) {\n        try {\n            InputStream is = context.getResources().openRawResource(R.raw.iperf3);\n            FileOutputStream fos = context.openFileOutput(\"iperf3\", Context.MODE_PRIVATE);\n            int len;\n            byte[] buf = new byte[1024];\n            while ((len = is.read(buf)) > 0) {\n                fos.write(buf, 0, len);\n            }\n            is.close();\n            fos.close();\n            Runtime.getRuntime().exec(\n                    new String[]{\n                            \"chmod\",\n                            \"755\",\n                            context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3\"});\n        } catch (Exception e) {\n            Log.e(Iperf_TAG, \"Exception in creating iperf, error message = \" + e.getMessage());\n        }\n    }\n    /**\n     * run iperf command and collect the output string for usage\n     *\n     * @param context      context\n     * @param iperfOptions iperf options\n     * @return iperf output, if ok return the normal result, if contains error return null\n     */\n    public static IperfResult runIperf(Context context, IperfOptions iperfOptions) {\n        IperfResult iperfResult = new IperfResult();\n        iperfResult.setResultType(IperfResultType.RIGHT);\n        String str = \"\";\n        try {\n            //Process process = Runtime.getRuntime().exec(\n            // new String[] {\n            //\"su\",\n            //\"-c\",\n            //context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3 \"\n            // + iperfOptions.toString()});\n            Process process = Runtime.getRuntime().exec(context.getFilesDir().getAbsolutePath() + File.separator + \"iperf3 \"\n                    + iperfOptions.toString());\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = br.readLine()) != null) {\n                str += line;\n            }\n            br.close();\n            // waits for the command to finish\n            process.waitFor();\n            // if output contains error, the returned result is error message\n            if (str.equals(\"\")) {\n                iperfResult.setResultType(IperfResultType.IS_NULL);\n            } else if (!str.equals(\"\") && str.contains(\"error\")) {\n                iperfResult.setResultType(IperfResultType.GET_ERROR);\n            }\n        } catch (IOException e) {\n            Log.e(Iperf_TAG, \"Error running iperf, error msg = \" + e.getMessage());\n            str = e.getMessage();\n            iperfResult.setResultType(IperfResultType.GET_EXCEPTION);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        iperfResult.setResult(str);\n        return iperfResult;\n    }\n    /**\n     * find the pid of iperf by using and parsing the ps command output\n     *\n     * @return pid of iperf\n     */\n    public static String getIperfPID() {\n        String pid = null;\n        try {\n            // run ps to get the process list\n            Process process = Runtime.getRuntime().exec(\"ps\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            // find the pid column, for it varies with different versions of ps\n            int pidColumn = 0;\n            int i = 0;\n            String line;\n            // split first line by regular expression, which matches one or many whitespaces\n            line = br.readLine();\n            String[] columnNames = line.split(\"\\\\s+\");\n            for (String col : columnNames) {\n                if (col.equalsIgnoreCase(\"PID\")) {\n                    pidColumn = i;\n                    break;\n                }\n                i++;\n            }\n            // parse process list to find iperf entry\n            while ((line = br.readLine()) != null) {\n                if (line.contains(\"iperf3\") && line.contains(\"cn.dizhangcs.crowdsignal.bandwidthtester\")\n                        && !line.contains(\"sh -c\")) {\n                    // split the line by white space\n                    String strs[] = line.split(\"\\\\s+\");\n                    pid = strs[pidColumn];\n                    break;\n                }\n            }\n            br.close();\n        } catch (IOException ie) {\n            Log.e(Iperf_TAG, \"Error getting tcpdump pid, error msg = \" + ie.getMessage());\n        }\n        return pid;\n    }\n    /**\n     * Check to see if iperf is running\n     *\n     * @return whether iperf is running\n     */\n    public static boolean isIperfRunning() {\n        return getIperfPID() != null;\n    }\n    public static void stopIperf() {\n        try {\n            String pid = getIperfPID();\n            // iperf is not running\n            if (pid == null) {\n                return;\n            }\n            Process process = Runtime.getRuntime().exec(new String[]{\"su\", \"-c\", \"kill \" + pid});\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            //check errors\n            String line;\n            while ((line = br.readLine()) != null) {\n                Log.e(Iperf_TAG, \"kill tcpdump error, error msg = \" + line);\n            }\n            br.close();\n        } catch (IOException e) {\n            Log.e(Iperf_TAG, \"kill iperf error, error msg = \" + e.getMessage());\n        }\n    }\n"]], "pred": {"ppl": 1.9821397066116333, "ppl_lower": 2.1202971935272217, "ppl/lowercase_ppl": -1.0984823388312772, "ppl/zlib": 0.00043192987444364125, "Min_5.0% Prob": 6.315728299758014, "Min_10.0% Prob": 4.6552239866817695, "Min_20.0% Prob": 3.064477477295726, "Min_30.0% Prob": 2.2121635559532375, "Min_40.0% Prob": 1.6953106684505501, "Min_50.0% Prob": 1.3664287827223713, "Min_60.0% Prob": 1.1410748326784792}}
{"hexsha": "aec70f0913dc1b41f1d3f19ea64e5929fac5acc8", "ext": "java", "lang": "Java", "content": "public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));\n\n        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\");\n\n        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();\n        registrar.setEnvironment(environment);\n\n        for (AnnotationAttributes element : annotationAttributes) {\n\n            registrar.registerBeanDefinitions(element, registry);\n\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n\n        this.environment = (ConfigurableEnvironment) environment;\n\n    }\n\n}", "class_id": 0, "repo": "GiftedDrogon/dubbo-parent", "file": "dubbo-config/dubbo-config-spring/src/main/java/com/alibaba/dubbo/config/spring/context/annotation/DubboConfigBindingsRegistrar.java", "last_update_at": "2018-10-30T12:40:17+00:00", "question_id": "aec70f0913dc1b41f1d3f19ea64e5929fac5acc8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n    private ConfigurableEnvironment environment;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));\n        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\");\n        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();\n        registrar.setEnvironment(environment);\n        for (AnnotationAttributes element : annotationAttributes) {\n            registrar.registerBeanDefinitions(element, registry);\n        }\n    }\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n"]], "pred": {"ppl": 1.5956573486328125, "ppl_lower": 2.5242695808410645, "ppl/lowercase_ppl": -1.9815534333770468, "ppl/zlib": 0.0012802350195575496, "Min_5.0% Prob": 5.485247221860019, "Min_10.0% Prob": 3.679961971614672, "Min_20.0% Prob": 2.16659613809687, "Min_30.0% Prob": 1.5414134734443257, "Min_40.0% Prob": 1.165100216944801, "Min_50.0% Prob": 0.9327314630056084, "Min_60.0% Prob": 0.7816561573805908}}
{"hexsha": "6b03f3560c4931fc445ef56e0258273d847dd4c8", "ext": "java", "lang": "Java", "content": "public class msg_gps_global_origin extends MAVLinkMessage {\n  public static final int MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN = 49;\n  private static final long serialVersionUID = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;\n  public msg_gps_global_origin(int sysId, int componentId) {\n    messageType = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;\n    this.sysId = sysId;\n    this.componentId = componentId;\n    length = 12;\n}\n\n  /**\n   * Latitude (WGS84), in degrees * 1E7\n   */\n  public long latitude;\n  /**\n   * Longitude (WGS84), in degrees * 1E7\n   */\n  public long longitude;\n  /**\n   * Altitude (WGS84), in meters * 1000 (positive for up)\n   */\n  public long altitude;\n/**\n * Decode message with raw data\n */\npublic void decode(ByteBuffer dis) throws IOException {\n  latitude = (int)dis.getInt();\n  longitude = (int)dis.getInt();\n  altitude = (int)dis.getInt();\n}\n/**\n * Encode message with raw data and other informations\n */\npublic byte[] encode() throws IOException {\n  byte[] buffer = new byte[8+12];\n   ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);\n  dos.put((byte)0xFE);\n  dos.put((byte)(length & 0x00FF));\n  dos.put((byte)(sequence & 0x00FF));\n  dos.put((byte)(sysId & 0x00FF));\n  dos.put((byte)(componentId & 0x00FF));\n  dos.put((byte)(messageType & 0x00FF));\n  dos.putInt((int)(latitude&0x00FFFFFFFF));\n  dos.putInt((int)(longitude&0x00FFFFFFFF));\n  dos.putInt((int)(altitude&0x00FFFFFFFF));\n  int crc = MAVLinkCRC.crc_calculate_encode(buffer, 12);\n  crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);\n  byte crcl = (byte) (crc & 0x00FF);\n  byte crch = (byte) ((crc >> 8) & 0x00FF);\n  buffer[18] = crcl;\n  buffer[19] = crch;\n  return buffer;\n}\npublic String toString() {\nreturn \"MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN : \" +   \"  latitude=\"+latitude+  \"  longitude=\"+longitude+  \"  altitude=\"+altitude;}\n}", "class_id": 0, "repo": "chrisphillips/Telemetry-For-DJI", "file": "TelemetryServer/app/src/main/java/org/mavlink/messages/ardupilotmega/msg_gps_global_origin.java", "last_update_at": "2018-02-20T19:26:12+00:00", "question_id": "6b03f3560c4931fc445ef56e0258273d847dd4c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class msg_gps_global_origin extends MAVLinkMessage {\n  public static final int MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN = 49;\n  private static final long serialVersionUID = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;\n  public msg_gps_global_origin(int sysId, int componentId) {\n    messageType = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;\n    this.sysId = sysId;\n    this.componentId = componentId;\n    length = 12;\n}\n  /**\n   * Latitude (WGS84), in degrees * 1E7\n   */\n  public long latitude;\n  /**\n   * Longitude (WGS84), in degrees * 1E7\n   */\n  public long longitude;\n  /**\n   * Altitude (WGS84), in meters * 1000 (positive for up)\n   */\n  public long altitude;\n/**\n * Decode message with raw data\n */\npublic void decode(ByteBuffer dis) throws IOException {\n  latitude = (int)dis.getInt();\n  longitude = (int)dis.getInt();\n  altitude = (int)dis.getInt();\n}\n/**\n * Encode message with raw data and other informations\n */\npublic byte[] encode() throws IOException {\n  byte[] buffer = new byte[8+12];\n   ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);\n  dos.put((byte)0xFE);\n  dos.put((byte)(length & 0x00FF));\n  dos.put((byte)(sequence & 0x00FF));\n  dos.put((byte)(sysId & 0x00FF));\n  dos.put((byte)(componentId & 0x00FF));\n  dos.put((byte)(messageType & 0x00FF));\n  dos.putInt((int)(latitude&0x00FFFFFFFF));\n  dos.putInt((int)(longitude&0x00FFFFFFFF));\n  dos.putInt((int)(altitude&0x00FFFFFFFF));\n  int crc = MAVLinkCRC.crc_calculate_encode(buffer, 12);\n  crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);\n  byte crcl = (byte) (crc & 0x00FF);\n  byte crch = (byte) ((crc >> 8) & 0x00FF);\n  buffer[18] = crcl;\n  buffer[19] = crch;\n  return buffer;\n}\npublic String toString() {\nreturn \"MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN : \" +   \"  latitude=\"+latitude+  \"  longitude=\"+longitude+  \"  altitude=\"+altitude;}\n"]], "pred": {"ppl": 1.0989786386489868, "ppl_lower": 1.5095248222351074, "ppl/lowercase_ppl": -4.36310141826629, "ppl/zlib": 0.0001309032429299543, "Min_5.0% Prob": 1.8413227975771234, "Min_10.0% Prob": 0.9442169659745854, "Min_20.0% Prob": 0.47205956550955697, "Min_30.0% Prob": 0.3156557610771888, "Min_40.0% Prob": 0.23625505761452012, "Min_50.0% Prob": 0.18875900483466657, "Min_60.0% Prob": 0.15751239867032835}}
{"hexsha": "af65d9b6a962703dcf28e346b2997125676cfed1", "ext": "java", "lang": "Java", "content": "public class MessagesRenderer extends UINotificationRenderer {\n\n    private static final Logger logger = Logger.getLogger(MessagesRenderer.class.getName());\n\n    @Override\n    public void encodeEnd(FacesContext context, UIComponent component) throws IOException {\n        Messages uiMessages = (Messages) component;\n        ResponseWriter writer = context.getResponseWriter();\n        String clientId = uiMessages.getClientId(context);\n        Map<String, List<FacesMessage>> messagesMap = new HashMap<>();\n        boolean globalOnly = uiMessages.isGlobalOnly();\n        String containerClass = uiMessages.isShowIcon() ? Messages.CONTAINER_CLASS : Messages.ICONLESS_CONTAINER_CLASS;\n        String style = uiMessages.getStyle();\n        String styleClass = uiMessages.getStyleClass();\n        styleClass = (styleClass == null) ? containerClass : containerClass + \" \" + styleClass;\n\n        String _for = uiMessages.getFor();\n        List<FacesMessage> messages = new ArrayList<>();\n        if (!isValueBlank(_for)) {\n            String forType = uiMessages.getForType();\n            Iterator<FacesMessage> messagesIterator = context.getMessages(_for);\n\n            // key case\n            if (forType == null || forType.equals(\"key\")) {\n                while (messagesIterator.hasNext()) {\n                    messages.add(messagesIterator.next());\n                }\n            }\n\n            // clientId / SearchExpression case\n            if (forType == null || forType.equals(\"expression\")) {\n                UIComponent forComponent = SearchExpressionFacade.resolveComponent(\n                        context, uiMessages, _for, SearchExpressionHint.IGNORE_NO_RESULT);\n                if (forComponent != null) {\n                    String forComponentClientId = forComponent.getClientId(context);\n                    if (!_for.equals(forComponentClientId)) {\n                        messagesIterator = context.getMessages(forComponentClientId);\n                        while (messagesIterator.hasNext()) {\n                            FacesMessage next = messagesIterator.next();\n                            if (!messages.contains(next)) {\n                                messages.add(next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            Iterator<FacesMessage> messagesIterator = uiMessages.isGlobalOnly() ? context.getMessages(null) : context.getMessages();\n            while (messagesIterator.hasNext()) {\n                messages.add(messagesIterator.next());\n            }\n        }\n\n        for (int i = 0; i < messages.size(); i++) {\n            FacesMessage message = messages.get(i);\n            FacesMessage.Severity severity = message.getSeverity();\n\n            if (severity.equals(FacesMessage.SEVERITY_INFO)) {\n                addMessage(uiMessages, message, messagesMap, \"info\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_WARN)) {\n                addMessage(uiMessages, message, messagesMap, \"warn\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_ERROR)) {\n                addMessage(uiMessages, message, messagesMap, \"error\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_FATAL)) {\n                addMessage(uiMessages, message, messagesMap, \"fatal\");\n            }\n        }\n\n        writer.startElement(\"div\", uiMessages);\n        writer.writeAttribute(\"id\", clientId, \"id\");\n        writer.writeAttribute(\"class\", styleClass, null);\n\n        if (style != null) {\n            writer.writeAttribute(\"style\", style, null);\n        }\n\n        writer.writeAttribute(\"aria-live\", \"polite\", null);\n\n        if (PrimeApplicationContext.getCurrentInstance(context).getConfig().isClientSideValidationEnabled()) {\n            writer.writeAttribute(\"data-global\", String.valueOf(globalOnly), null);\n            writer.writeAttribute(\"data-summary\", uiMessages.isShowSummary(), null);\n            writer.writeAttribute(\"data-detail\", uiMessages.isShowDetail(), null);\n            writer.writeAttribute(\"data-severity\", getClientSideSeverity(uiMessages.getSeverity()), null);\n            writer.writeAttribute(\"data-redisplay\", String.valueOf(uiMessages.isRedisplay()), null);\n        }\n\n        for (String severity : messagesMap.keySet()) {\n            List<FacesMessage> severityMessages = messagesMap.get(severity);\n\n            if (severityMessages.size() > 0) {\n                encodeSeverityMessages(context, uiMessages, severity, severityMessages);\n            }\n        }\n\n        writer.endElement(\"div\");\n    }\n\n    protected void addMessage(Messages uiMessages, FacesMessage message, Map<String, List<FacesMessage>> messagesMap, String severity) {\n        if (shouldRender(uiMessages, message, severity)) {\n            List<FacesMessage> severityMessages = messagesMap.get(severity);\n\n            if (severityMessages == null) {\n                severityMessages = new ArrayList<>();\n                messagesMap.put(severity, severityMessages);\n            }\n\n            severityMessages.add(message);\n        }\n    }\n\n    protected void encodeSeverityMessages(FacesContext context, Messages uiMessages, String severity, List<FacesMessage> messages) throws IOException {\n        ResponseWriter writer = context.getResponseWriter();\n        String styleClassPrefix = Messages.SEVERITY_PREFIX_CLASS + severity;\n        boolean escape = uiMessages.isEscape();\n\n        writer.startElement(\"div\", null);\n        writer.writeAttribute(\"class\", styleClassPrefix + \" ui-corner-all\", null);\n\n        if (uiMessages.isClosable()) {\n            encodeCloseIcon(context, uiMessages);\n        }\n\n        if (uiMessages.isShowIcon()) {\n            writer.startElement(\"span\", null);\n            writer.writeAttribute(\"class\", styleClassPrefix + \"-icon\", null);\n            writer.endElement(\"span\");\n        }\n\n        writer.startElement(\"ul\", null);\n\n        for (int i = 0; i < messages.size(); i++) {\n            FacesMessage message = messages.get(i);\n            writer.startElement(\"li\", null);\n\n            writer.writeAttribute(\"role\", \"alert\", null);\n            writer.writeAttribute(\"aria-atomic\", \"true\", null);\n\n            String summary = message.getSummary() != null ? message.getSummary() : \"\";\n            String detail = message.getDetail() != null ? message.getDetail() : summary;\n\n            if (uiMessages.isShowSummary()) {\n                writer.startElement(\"span\", null);\n                writer.writeAttribute(\"class\", styleClassPrefix + \"-summary\", null);\n\n                if (escape) {\n                    writer.writeText(summary, null);\n                }\n                else {\n                    writer.write(summary);\n                }\n\n                writer.endElement(\"span\");\n            }\n\n            if (uiMessages.isShowDetail()) {\n                writer.startElement(\"span\", null);\n                writer.writeAttribute(\"class\", styleClassPrefix + \"-detail\", null);\n\n                if (escape) {\n                    writer.writeText(detail, null);\n                }\n                else {\n                    writer.write(detail);\n                }\n\n                writer.endElement(\"span\");\n            }\n\n            writer.endElement(\"li\");\n\n            message.rendered();\n        }\n\n        writer.endElement(\"ul\");\n\n        writer.endElement(\"div\");\n    }\n\n    protected void encodeCloseIcon(FacesContext context, Messages uiMessages) throws IOException {\n        ResponseWriter writer = context.getResponseWriter();\n\n        writer.startElement(\"a\", null);\n        writer.writeAttribute(\"href\", \"#\", null);\n        writer.writeAttribute(\"class\", Messages.CLOSE_LINK_CLASS, null);\n        writer.writeAttribute(\"onclick\", \"$(this).parent().slideUp();return false;\", null);\n\n        writer.startElement(\"span\", null);\n        writer.writeAttribute(\"class\", Messages.CLOSE_ICON_CLASS, null);\n        writer.endElement(\"span\");\n\n        writer.endElement(\"a\");\n    }\n}", "class_id": 0, "repo": "KadonWills/primefaces", "file": "src/main/java/org/primefaces/component/messages/MessagesRenderer.java", "last_update_at": "2018-08-27T13:42:27+00:00", "question_id": "af65d9b6a962703dcf28e346b2997125676cfed1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessagesRenderer extends UINotificationRenderer {\n    private static final Logger logger = Logger.getLogger(MessagesRenderer.class.getName());\n    @Override\n    public void encodeEnd(FacesContext context, UIComponent component) throws IOException {\n        Messages uiMessages = (Messages) component;\n        ResponseWriter writer = context.getResponseWriter();\n        String clientId = uiMessages.getClientId(context);\n        Map<String, List<FacesMessage>> messagesMap = new HashMap<>();\n        boolean globalOnly = uiMessages.isGlobalOnly();\n        String containerClass = uiMessages.isShowIcon() ? Messages.CONTAINER_CLASS : Messages.ICONLESS_CONTAINER_CLASS;\n        String style = uiMessages.getStyle();\n        String styleClass = uiMessages.getStyleClass();\n        styleClass = (styleClass == null) ? containerClass : containerClass + \" \" + styleClass;\n        String _for = uiMessages.getFor();\n        List<FacesMessage> messages = new ArrayList<>();\n        if (!isValueBlank(_for)) {\n            String forType = uiMessages.getForType();\n            Iterator<FacesMessage> messagesIterator = context.getMessages(_for);\n            // key case\n            if (forType == null || forType.equals(\"key\")) {\n                while (messagesIterator.hasNext()) {\n                    messages.add(messagesIterator.next());\n                }\n            }\n            // clientId / SearchExpression case\n            if (forType == null || forType.equals(\"expression\")) {\n                UIComponent forComponent = SearchExpressionFacade.resolveComponent(\n                        context, uiMessages, _for, SearchExpressionHint.IGNORE_NO_RESULT);\n                if (forComponent != null) {\n                    String forComponentClientId = forComponent.getClientId(context);\n                    if (!_for.equals(forComponentClientId)) {\n                        messagesIterator = context.getMessages(forComponentClientId);\n                        while (messagesIterator.hasNext()) {\n                            FacesMessage next = messagesIterator.next();\n                            if (!messages.contains(next)) {\n                                messages.add(next);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            Iterator<FacesMessage> messagesIterator = uiMessages.isGlobalOnly() ? context.getMessages(null) : context.getMessages();\n            while (messagesIterator.hasNext()) {\n                messages.add(messagesIterator.next());\n            }\n        }\n        for (int i = 0; i < messages.size(); i++) {\n            FacesMessage message = messages.get(i);\n            FacesMessage.Severity severity = message.getSeverity();\n            if (severity.equals(FacesMessage.SEVERITY_INFO)) {\n                addMessage(uiMessages, message, messagesMap, \"info\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_WARN)) {\n                addMessage(uiMessages, message, messagesMap, \"warn\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_ERROR)) {\n                addMessage(uiMessages, message, messagesMap, \"error\");\n            }\n            else if (severity.equals(FacesMessage.SEVERITY_FATAL)) {\n                addMessage(uiMessages, message, messagesMap, \"fatal\");\n            }\n        }\n        writer.startElement(\"div\", uiMessages);\n        writer.writeAttribute(\"id\", clientId, \"id\");\n        writer.writeAttribute(\"class\", styleClass, null);\n        if (style != null) {\n            writer.writeAttribute(\"style\", style, null);\n        }\n        writer.writeAttribute(\"aria-live\", \"polite\", null);\n        if (PrimeApplicationContext.getCurrentInstance(context).getConfig().isClientSideValidationEnabled()) {\n            writer.writeAttribute(\"data-global\", String.valueOf(globalOnly), null);\n            writer.writeAttribute(\"data-summary\", uiMessages.isShowSummary(), null);\n            writer.writeAttribute(\"data-detail\", uiMessages.isShowDetail(), null);\n            writer.writeAttribute(\"data-severity\", getClientSideSeverity(uiMessages.getSeverity()), null);\n            writer.writeAttribute(\"data-redisplay\", String.valueOf(uiMessages.isRedisplay()), null);\n        }\n        for (String severity : messagesMap.keySet()) {\n            List<FacesMessage> severityMessages = messagesMap.get(severity);\n            if (severityMessages.size() > 0) {\n                encodeSeverityMessages(context, uiMessages, severity, severityMessages);\n            }\n        }\n        writer.endElement(\"div\");\n    }\n    protected void addMessage(Messages uiMessages, FacesMessage message, Map<String, List<FacesMessage>> messagesMap, String severity) {\n        if (shouldRender(uiMessages, message, severity)) {\n            List<FacesMessage> severityMessages = messagesMap.get(severity);\n            if (severityMessages == null) {\n                severityMessages = new ArrayList<>();\n                messagesMap.put(severity, severityMessages);\n            }\n            severityMessages.add(message);\n        }\n    }\n    protected void encodeSeverityMessages(FacesContext context, Messages uiMessages, String severity, List<FacesMessage> messages) throws IOException {\n        ResponseWriter writer = context.getResponseWriter();\n        String styleClassPrefix = Messages.SEVERITY_PREFIX_CLASS + severity;\n        boolean escape = uiMessages.isEscape();\n        writer.startElement(\"div\", null);\n        writer.writeAttribute(\"class\", styleClassPrefix + \" ui-corner-all\", null);\n        if (uiMessages.isClosable()) {\n            encodeCloseIcon(context, uiMessages);\n        }\n        if (uiMessages.isShowIcon()) {\n            writer.startElement(\"span\", null);\n            writer.writeAttribute(\"class\", styleClassPrefix + \"-icon\", null);\n            writer.endElement(\"span\");\n        }\n        writer.startElement(\"ul\", null);\n        for (int i = 0; i < messages.size(); i++) {\n            FacesMessage message = messages.get(i);\n            writer.startElement(\"li\", null);\n            writer.writeAttribute(\"role\", \"alert\", null);\n            writer.writeAttribute(\"aria-atomic\", \"true\", null);\n            String summary = message.getSummary() != null ? message.getSummary() : \"\";\n            String detail = message.getDetail() != null ? message.getDetail() : summary;\n            if (uiMessages.isShowSummary()) {\n                writer.startElement(\"span\", null);\n                writer.writeAttribute(\"class\", styleClassPrefix + \"-summary\", null);\n                if (escape) {\n                    writer.writeText(summary, null);\n                }\n                else {\n                    writer.write(summary);\n                }\n                writer.endElement(\"span\");\n            }\n            if (uiMessages.isShowDetail()) {\n                writer.startElement(\"span\", null);\n                writer.writeAttribute(\"class\", styleClassPrefix + \"-detail\", null);\n                if (escape) {\n                    writer.writeText(detail, null);\n                }\n                else {\n                    writer.write(detail);\n                }\n                writer.endElement(\"span\");\n            }\n            writer.endElement(\"li\");\n            message.rendered();\n        }\n        writer.endElement(\"ul\");\n        writer.endElement(\"div\");\n    }\n    protected void encodeCloseIcon(FacesContext context, Messages uiMessages) throws IOException {\n        ResponseWriter writer = context.getResponseWriter();\n        writer.startElement(\"a\", null);\n        writer.writeAttribute(\"href\", \"#\", null);\n        writer.writeAttribute(\"class\", Messages.CLOSE_LINK_CLASS, null);\n        writer.writeAttribute(\"onclick\", \"$(this).parent().slideUp();return false;\", null);\n        writer.startElement(\"span\", null);\n        writer.writeAttribute(\"class\", Messages.CLOSE_ICON_CLASS, null);\n        writer.endElement(\"span\");\n        writer.endElement(\"a\");\n    }\n"]], "pred": {"ppl": 1.4994837045669556, "ppl_lower": 1.835156798362732, "ppl/lowercase_ppl": -1.4986390448738405, "ppl/zlib": 0.0002378865836191623, "Min_5.0% Prob": 4.653626914117851, "Min_10.0% Prob": 3.2220182465571985, "Min_20.0% Prob": 1.9391857714337462, "Min_30.0% Prob": 1.341668093857033, "Min_40.0% Prob": 1.0106909306888403, "Min_50.0% Prob": 0.8103896046135713, "Min_60.0% Prob": 0.6759164582379238}}
{"hexsha": "e4aa5d3572166d942c40e6fc10a5a587137ec1c5", "ext": "java", "lang": "Java", "content": "@WebServlet(\"/register\")\n@MultipartConfig(fileSizeThreshold=1024*1024*10,maxFileSize=1024*1024*10,maxRequestSize=1024*1024*20)\npublic class RegisterServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/register.jsp\");\n\t\trequestDispatcher.forward(request, response);\n\t}\n\t\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\t// get request parameters for userID and password\n\t\tString email = request.getParameter(\"email\");\n\t\tString plainPassword = request.getParameter(\"password\");\n\t\tString username = request.getParameter(\"username\");\n\t\tString firstname = request.getParameter(\"firstname\");\n\t\tString lastname = request.getParameter(\"lastname\");\n\t\t\n\t\tString locality = request.getParameter(\"locality\");\n\t\tString country = request.getParameter(\"country\");\n\t\tString lat = request.getParameter(\"lat\");\n\t\tString lng = request.getParameter(\"lng\");\n\n\t\t// use bcrypt for password\n\t\tString password = BCrypt.hashpw(plainPassword, BCrypt.gensalt(12));    \n\t    \n\t\tMongoConnection mongo = MongoConnection.getInstance();\n\t\tMongoDatabase database = mongo.database;\n\t\t\n\t\tboolean isEmailFound = MongoUtil.searchEmail(email, database);\n\t\t\n\t\tif (isEmailFound) {\n\t\t\trequest.setAttribute(\"message\", \"Email already registered, please sign in instead\");\n\t\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/login.jsp\");\n\t\t\trequestDispatcher.forward(request, response);\t\t\t\n\t\t\t\n\t\t} else {\n\t\t\tObjectId _id = new ObjectId();\n\n\t\t\tString avatar = \"\";\n\t\t\t\n\t\t\ttry {\n\t\t\t\tPart filePart = request.getPart(\"userAvatar\");\n\t\t\t\tif (filePart.getSize() > 0) {\n\t\t\t\t\tavatar = AmazonS3Util.awsUpload(filePart, _id.toString());\n\t\t\t\t}\n\t\t\t} catch (final Exception e) {\n\t\t\t\tSystem.out.println(\"Upload failed\" + e.getMessage());\n\t\t\t}\n\t\t    \n\t\t\tDocument doc = new Document(\"_id\", _id)\n\t\t\t\t\t.append(\"email\", email)\n\t\t\t\t\t.append(\"password\", password)\n\t\t\t\t\t.append(\"username\", username)\n\t\t\t\t\t.append(\"registered\", MiscUtil.nowToString());\n\t\t\t\n\t\t\tif (firstname != null && !firstname.isEmpty()) doc.append(\"firstname\", firstname);\n\t\t\tif (lastname != null && !lastname.isEmpty()) doc.append(\"lastname\", lastname);\n\t\t\tif (avatar != null && !avatar.isEmpty()) doc.append(\"avatar\", avatar);\n\t\t\t\n\t\t\tDocument locationDoc = new Document();\n\t\t\tif (locality != null && !locality.isEmpty()) locationDoc.append(\"locality\", locality);\n\t\t\tif (country != null && !country.isEmpty()) locationDoc.append(\"country\", country);\n\t\t\tif (lat != null && !lat.isEmpty()) locationDoc.append(\"lat\", Double.parseDouble(lat));\n\t\t\tif (lng != null && !lng.isEmpty()) locationDoc.append(\"lng\", Double.parseDouble(lng));\n\t\t\tif (!locationDoc.isEmpty()) doc.append(\"location\", locationDoc);\n\t\t\t\t\t\n\t\t\tMongoCollection<Document> collection = database.getCollection(\"users\");\n\t\t\tcollection.insertOne(doc);\n\n\t\t\t//get the old session and invalidate\n            HttpSession oldSession = request.getSession(false);\n            if (oldSession != null) {\n                oldSession.invalidate();\n            }\n\t\t\t\n            //generate a new session\n            HttpSession newSession = request.getSession(true);\n            \n            newSession.setAttribute(\"username\", username);\n            newSession.setAttribute(\"_id\", _id);\n            \n            //setting session to expire\n            newSession.setMaxInactiveInterval(15*60);\n\n            Cookie cookie = new Cookie(\"username\", username);\n            response.addCookie(cookie);\t\n            \n            response.sendRedirect(\"app/dashboard\");\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "lexctk/BookExchange", "file": "src/main/java/com/bookexchange/servlets/authentication/RegisterServlet.java", "last_update_at": "2018-11-01T23:59:01+00:00", "question_id": "e4aa5d3572166d942c40e6fc10a5a587137ec1c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebServlet(\"/register\")\n@MultipartConfig(fileSizeThreshold=1024*1024*10,maxFileSize=1024*1024*10,maxRequestSize=1024*1024*20)\npublic class RegisterServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/register.jsp\");\n\t\trequestDispatcher.forward(request, response);\n\t}\n\t\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// get request parameters for userID and password\n\t\tString email = request.getParameter(\"email\");\n\t\tString plainPassword = request.getParameter(\"password\");\n\t\tString username = request.getParameter(\"username\");\n\t\tString firstname = request.getParameter(\"firstname\");\n\t\tString lastname = request.getParameter(\"lastname\");\n\t\t\n\t\tString locality = request.getParameter(\"locality\");\n\t\tString country = request.getParameter(\"country\");\n\t\tString lat = request.getParameter(\"lat\");\n\t\tString lng = request.getParameter(\"lng\");\n\t\t// use bcrypt for password\n\t\tString password = BCrypt.hashpw(plainPassword, BCrypt.gensalt(12));    \n\t    \n\t\tMongoConnection mongo = MongoConnection.getInstance();\n\t\tMongoDatabase database = mongo.database;\n\t\t\n\t\tboolean isEmailFound = MongoUtil.searchEmail(email, database);\n\t\t\n\t\tif (isEmailFound) {\n\t\t\trequest.setAttribute(\"message\", \"Email already registered, please sign in instead\");\n\t\t\tRequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/login.jsp\");\n\t\t\trequestDispatcher.forward(request, response);\t\t\t\n\t\t\t\n\t\t} else {\n\t\t\tObjectId _id = new ObjectId();\n\t\t\tString avatar = \"\";\n\t\t\t\n\t\t\ttry {\n\t\t\t\tPart filePart = request.getPart(\"userAvatar\");\n\t\t\t\tif (filePart.getSize() > 0) {\n\t\t\t\t\tavatar = AmazonS3Util.awsUpload(filePart, _id.toString());\n\t\t\t\t}\n\t\t\t} catch (final Exception e) {\n\t\t\t\tSystem.out.println(\"Upload failed\" + e.getMessage());\n\t\t\t}\n\t\t    \n\t\t\tDocument doc = new Document(\"_id\", _id)\n\t\t\t\t\t.append(\"email\", email)\n\t\t\t\t\t.append(\"password\", password)\n\t\t\t\t\t.append(\"username\", username)\n\t\t\t\t\t.append(\"registered\", MiscUtil.nowToString());\n\t\t\t\n\t\t\tif (firstname != null && !firstname.isEmpty()) doc.append(\"firstname\", firstname);\n\t\t\tif (lastname != null && !lastname.isEmpty()) doc.append(\"lastname\", lastname);\n\t\t\tif (avatar != null && !avatar.isEmpty()) doc.append(\"avatar\", avatar);\n\t\t\t\n\t\t\tDocument locationDoc = new Document();\n\t\t\tif (locality != null && !locality.isEmpty()) locationDoc.append(\"locality\", locality);\n\t\t\tif (country != null && !country.isEmpty()) locationDoc.append(\"country\", country);\n\t\t\tif (lat != null && !lat.isEmpty()) locationDoc.append(\"lat\", Double.parseDouble(lat));\n\t\t\tif (lng != null && !lng.isEmpty()) locationDoc.append(\"lng\", Double.parseDouble(lng));\n\t\t\tif (!locationDoc.isEmpty()) doc.append(\"location\", locationDoc);\n\t\t\t\t\t\n\t\t\tMongoCollection<Document> collection = database.getCollection(\"users\");\n\t\t\tcollection.insertOne(doc);\n\t\t\t//get the old session and invalidate\n            HttpSession oldSession = request.getSession(false);\n            if (oldSession != null) {\n                oldSession.invalidate();\n            }\n\t\t\t\n            //generate a new session\n            HttpSession newSession = request.getSession(true);\n            newSession.setAttribute(\"username\", username);\n            newSession.setAttribute(\"_id\", _id);\n            //setting session to expire\n            newSession.setMaxInactiveInterval(15*60);\n            Cookie cookie = new Cookie(\"username\", username);\n            response.addCookie(cookie);\t\n            response.sendRedirect(\"app/dashboard\");\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.572824239730835, "ppl_lower": 1.8039644956588745, "ppl/lowercase_ppl": -1.3027645589637455, "ppl/zlib": 0.00035603214003532675, "Min_5.0% Prob": 5.2693306558272415, "Min_10.0% Prob": 3.6553790522556677, "Min_20.0% Prob": 2.172366743651675, "Min_30.0% Prob": 1.489437220946831, "Min_40.0% Prob": 1.1252117803488793, "Min_50.0% Prob": 0.9041719346648035, "Min_60.0% Prob": 0.7550583886686062}}
{"hexsha": "d7ceb4df3cee3a8fd86da9044f015697da822d20", "ext": "java", "lang": "Java", "content": "@Component\npublic class DefaultAccessAuthenticator implements AccessAuthenticator {\n\n  private static final Logger logger = LoggerFactory.getLogger(DefaultAccessAuthenticator.class);\n\n  @Autowired\n  @Lazy\n  private ObjectMapper objectMapper;\n\n  @Override\n  public String generateAccessToken(TokenInfo tokenInfo) {\n    return generateAccessToken(tokenInfo, Preferences.getSystemSk());\n  }\n\n  @Override\n  public String generateAccessToken(TokenInfo tokenInfo, String secretKey) {\n    try {\n      String token = objectMapper.writeValueAsString(tokenInfo);\n      token = EncryptionUtil.aes(token, secretKey, true);\n      return token;\n    } catch (final Exception ex) {\n      logger.error(\"Failed to generate api access token!\", ex);\n    }\n    return null;\n  }\n\n  @Override\n  public TokenInfo parseAccessToken(String tokenString) {\n    return parseAccessToken(tokenString, Preferences.getSystemSk());\n  }\n\n  @Override\n  public TokenInfo parseAccessToken(String tokenString, String secretKey) {\n    TokenInfo tokenInfo = null;\n    if (!StringUtils.isEmpty(tokenString)) {\n      final String decrypted = EncryptionUtil.aes(tokenString, secretKey, false);\n      if (StringUtils.isNotEmpty(decrypted)) {\n        try {\n          tokenInfo = objectMapper.readValue(decrypted, TokenInfo.class);\n        } catch (final Exception ex) {\n          logger.error(String.format(\"Failed to parse token: \\\"%s\\\"\", tokenString), ex);\n          logger.error(String.format(\"Decrypted data is: %s\", decrypted));\n        }\n      }\n    }\n    return tokenInfo;\n  }\n\n  @Override\n  public int verifyAccessToken(String tokenString) {\n    return verifyAccessToken(tokenString, Preferences.getSystemSk());\n  }\n\n  @Override\n  public int verifyAccessToken(String tokenString, String secretKey) {\n    final TokenInfo tokenInfo = parseAccessToken(tokenString, secretKey);\n    if (tokenInfo == null) {\n      return TokenInfo.TOKEN_ERROR_INVALID;\n    } else if ((tokenInfo.getExpiryTime() >= 0)\n        && (tokenInfo.getExpiryTime() < System.currentTimeMillis())) {\n      return TokenInfo.TOKEN_ERROR_EXPIRED;\n    }\n    return 0;\n  }\n\n}", "class_id": 0, "repo": "hankai520/cordwood", "file": "source/cordwood-core/src/main/java/ren/hankai/cordwood/web/security/support/DefaultAccessAuthenticator.java", "last_update_at": "2018-12-06T04:05:31+00:00", "question_id": "d7ceb4df3cee3a8fd86da9044f015697da822d20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class DefaultAccessAuthenticator implements AccessAuthenticator {\n  private static final Logger logger = LoggerFactory.getLogger(DefaultAccessAuthenticator.class);\n  @Autowired\n  @Lazy\n  private ObjectMapper objectMapper;\n  @Override\n  public String generateAccessToken(TokenInfo tokenInfo) {\n    return generateAccessToken(tokenInfo, Preferences.getSystemSk());\n  }\n  @Override\n  public String generateAccessToken(TokenInfo tokenInfo, String secretKey) {\n    try {\n      String token = objectMapper.writeValueAsString(tokenInfo);\n      token = EncryptionUtil.aes(token, secretKey, true);\n      return token;\n    } catch (final Exception ex) {\n      logger.error(\"Failed to generate api access token!\", ex);\n    }\n    return null;\n  }\n  @Override\n  public TokenInfo parseAccessToken(String tokenString) {\n    return parseAccessToken(tokenString, Preferences.getSystemSk());\n  }\n  @Override\n  public TokenInfo parseAccessToken(String tokenString, String secretKey) {\n    TokenInfo tokenInfo = null;\n    if (!StringUtils.isEmpty(tokenString)) {\n      final String decrypted = EncryptionUtil.aes(tokenString, secretKey, false);\n      if (StringUtils.isNotEmpty(decrypted)) {\n        try {\n          tokenInfo = objectMapper.readValue(decrypted, TokenInfo.class);\n        } catch (final Exception ex) {\n          logger.error(String.format(\"Failed to parse token: \\\"%s\\\"\", tokenString), ex);\n          logger.error(String.format(\"Decrypted data is: %s\", decrypted));\n        }\n      }\n    }\n    return tokenInfo;\n  }\n  @Override\n  public int verifyAccessToken(String tokenString) {\n    return verifyAccessToken(tokenString, Preferences.getSystemSk());\n  }\n  @Override\n  public int verifyAccessToken(String tokenString, String secretKey) {\n    final TokenInfo tokenInfo = parseAccessToken(tokenString, secretKey);\n    if (tokenInfo == null) {\n      return TokenInfo.TOKEN_ERROR_INVALID;\n    } else if ((tokenInfo.getExpiryTime() >= 0)\n        && (tokenInfo.getExpiryTime() < System.currentTimeMillis())) {\n      return TokenInfo.TOKEN_ERROR_EXPIRED;\n    }\n    return 0;\n  }\n"]], "pred": {"ppl": 1.6384391784667969, "ppl_lower": 1.8325724601745605, "ppl/lowercase_ppl": -1.2267908309078308, "ppl/zlib": 0.000749232273468247, "Min_5.0% Prob": 5.264606599150033, "Min_10.0% Prob": 3.7938343019321046, "Min_20.0% Prob": 2.3358464444804397, "Min_30.0% Prob": 1.6215853799473157, "Min_40.0% Prob": 1.2305588010936341, "Min_50.0% Prob": 0.9874372223873629, "Min_60.0% Prob": 0.8234113753369611}}
{"hexsha": "ce9dfd48e9f0d8afa563abbbea460bdba9eb0271", "ext": "java", "lang": "Java", "content": "public class CaseQueryServiceTest {\n\n    private static final String[] LAST_MODIFIED = {\"2018\", \"1\", \"1\", \"0\", \"0\", \"0\", \"0\"};\n\n    @Mock\n    private RestTemplate restTemplate;\n\n    @Mock\n    private HttpHeadersFactory headers;\n\n    @Mock\n    private AppInsights appInsights;\n\n    @Mock\n    private CCDDataStoreAPIConfiguration ccdDataStoreAPIConfiguration;\n\n    @Mock\n    private IdamAuthenticateUserService idamAuthenticateUserService;\n\n    @Mock\n    private ServiceAuthTokenGenerator serviceAuthTokenGenerator;\n\n    @Mock\n    private FileSystemResourceService fileSystemResourceService;\n\n    @Captor\n    private ArgumentCaptor<HttpEntity<String>> entityCaptor;\n\n    @InjectMocks\n    private CaseQueryService caseQueryService;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        when(serviceAuthTokenGenerator.generate()).thenReturn(\"Bearer 321\");\n        when(idamAuthenticateUserService.getIdamOauth2Token()).thenReturn(\"Bearer 123\");\n        when(headers.getAuthorizationHeaders()).thenReturn(new HttpHeaders());\n\n        when(ccdDataStoreAPIConfiguration.getHost()).thenReturn(\"http://localhost\");\n        when(ccdDataStoreAPIConfiguration.getCaseMatchingPath()).thenReturn(\"/path\");\n\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, 1L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);\n\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases);\n    }\n\n    @Test\n    public void findCasesWithDatedDocumentReturnsCaseList() {\n        List<ReturnedCaseDetails> cases =\n            caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\", \"2021-01-01\");\n\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseList() {\n        caseQueryService.dataExtractPaginationSize = 1;\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePages() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 5);\n        ReturnedCases returnedCases2 = getReturnedCases(2, 3, 5);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n\n        assertEquals(5, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesExact() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 6);\n        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 6);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n\n        assertEquals(6, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertThat(cases.get(5).getId(), is(5L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n        assertEquals(\"Smith5\", cases.get(5).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesPlus() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 7);\n        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 7);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 6, 7);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n            returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n\n        assertEquals(7, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertThat(cases.get(5).getId(), is(5L));\n        assertThat(cases.get(6).getId(), is(6L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n        assertEquals(\"Smith5\", cases.get(5).getData().getDeceasedSurname());\n        assertEquals(\"Smith6\", cases.get(6).getData().getDeceasedSurname());\n    }\n\n    private ReturnedCases getReturnedCases(int numCases, int caseIndex, int total) {\n        ArrayList<ReturnedCaseDetails> allReturnedCases = new ArrayList<>();\n        for (int i = 0; i < numCases; i++) {\n            CaseData caseData = CaseData.builder()\n                .deceasedSurname(\"Smith\" + (caseIndex + i))\n                .build();\n            allReturnedCases.add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, Long.valueOf(caseIndex + i)));\n        }\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>()\n                .addAll(allReturnedCases)\n                .build();\n        return new ReturnedCases(caseList, total);\n    }\n\n    @Test\n    public void findCasesInitiatedBySchedulerReturnsCaseList() {\n        when(headers.getAuthorizationHeaders()).thenThrow(NullPointerException.class);\n        List<ReturnedCaseDetails> cases = caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListExela() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeExela(\"2019-01-01\", \"2019-02-05\");\n\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test(expected = ClientDataException.class)\n    public void findCasesWithDateRangeThrowsError() {\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>()\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 1L))\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 2L))\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 3L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);\n\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        caseQueryService.findCaseStateWithinDateRangeExela(\"2019-01-01\", \"2019-02-05\");\n    }\n\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListHMRC() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeHMRC(\"2019-01-01\", \"2019-02-05\");\n\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListSmeeAndFord() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeSmeeAndFord(\"2019-01-01\", \"2019-02-05\");\n\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void testHttpExceptionCaughtWithBadPost() {\n        when(restTemplate.postForObject(any(), any(), any())).thenThrow(HttpClientErrorException.class);\n\n        Assertions.assertThatThrownBy(() -> caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\"))\n            .isInstanceOf(CaseMatchingException.class);\n    }\n\n    @Test\n    public void findCasesForGrantDelayed() {\n        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantDelayed(\"2019-02-05\");\n\n        assertEquals(1, cases.size());\n        assertEquals(1, cases.get(0).getId().intValue());\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test\n    public void findCasesForGrantAwaitingDocs() {\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, 1L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);\n        when(restTemplate.postForObject(any(), entityCaptor.capture(), any())).thenReturn(returnedCases);\n\n        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantAwaitingDocumentation(\"2019-02-05\");\n\n        String expected = \"{\\\"from\\\":0,\\\"size\\\":0,\\\"query\\\":{\\\"bool\\\":{\\\"must\\\":[{\\\"bool\\\":{\\\"should\\\":[{\\\"match\\\":\"\n                + \"{\\\"state\\\":{\\\"query\\\":\\\"CasePrinted\\\",\\\"operator\\\":\\\"OR\\\",\\\"prefix_length\\\":0,\\\"max_expansions\\\":50,\"\n                + \"\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\\\"zero_terms_query\\\":\\\"NONE\\\",\"\n                + \"\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}}],\\\"adjust_pure_negative\\\":true,\"\n                + \"\\\"minimum_should_match\\\":\\\"1\\\",\\\"boost\\\":1.0}},{\\\"match\\\":\"\n                + \"{\\\"data.grantAwaitingDocumentationNotificationDate\\\":{\\\"query\\\":\\\"2019-02-05\\\",\\\"operator\\\":\\\"OR\\\",\"\n                + \"\\\"prefix_length\\\":0,\\\"max_expansions\\\":50,\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\"\n                + \"\\\"zero_terms_query\\\":\\\"NONE\\\",\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}},\"\n                + \"{\\\"match\\\":{\\\"data.paperForm\\\":{\\\"query\\\":\\\"No\\\",\\\"operator\\\":\\\"OR\\\",\\\"prefix_length\\\":0,\"\n                + \"\\\"max_expansions\\\":50,\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\\\"zero_terms_query\\\":\\\"NONE\\\",\"\n                + \"\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}}],\\\"must_not\\\":[{\\\"exists\\\":{\\\"field\\\":\"\n                + \"\\\"data.grantAwaitingDocumentatioNotificationSent\\\",\\\"boost\\\":1.0}},{\\\"exists\\\":{\\\"field\\\":\"\n                + \"\\\"data.evidenceHandled\\\",\\\"boost\\\":1.0}}],\\\"adjust_pure_negative\\\":true,\\\"boost\\\":1.0}},\"\n                + \"\\\"sort\\\":[{\\\"id\\\":{\\\"order\\\":\\\"asc\\\"}}]}\";\n        assertEquals(expected, entityCaptor.getValue().getBody());\n        assertEquals(1, cases.size());\n        assertEquals(1, cases.get(0).getId().intValue());\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n\n    @Test(expected = ClientDataException.class)\n    public void testExceptionWithNullFromRestTemplatePost() {\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);\n        caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\", \"2021-01-01\");\n    }\n}", "class_id": 0, "repo": "hmcts/probate-sol-ccd-services", "file": "src/test/java/uk/gov/hmcts/probate/service/CaseQueryServiceTest.java", "last_update_at": "2018-04-24T08:57:41+00:00", "question_id": "ce9dfd48e9f0d8afa563abbbea460bdba9eb0271", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CaseQueryServiceTest {\n    private static final String[] LAST_MODIFIED = {\"2018\", \"1\", \"1\", \"0\", \"0\", \"0\", \"0\"};\n    @Mock\n    private RestTemplate restTemplate;\n    @Mock\n    private HttpHeadersFactory headers;\n    @Mock\n    private AppInsights appInsights;\n    @Mock\n    private CCDDataStoreAPIConfiguration ccdDataStoreAPIConfiguration;\n    @Mock\n    private IdamAuthenticateUserService idamAuthenticateUserService;\n    @Mock\n    private ServiceAuthTokenGenerator serviceAuthTokenGenerator;\n    @Mock\n    private FileSystemResourceService fileSystemResourceService;\n    @Captor\n    private ArgumentCaptor<HttpEntity<String>> entityCaptor;\n    @InjectMocks\n    private CaseQueryService caseQueryService;\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        when(serviceAuthTokenGenerator.generate()).thenReturn(\"Bearer 321\");\n        when(idamAuthenticateUserService.getIdamOauth2Token()).thenReturn(\"Bearer 123\");\n        when(headers.getAuthorizationHeaders()).thenReturn(new HttpHeaders());\n        when(ccdDataStoreAPIConfiguration.getHost()).thenReturn(\"http://localhost\");\n        when(ccdDataStoreAPIConfiguration.getCaseMatchingPath()).thenReturn(\"/path\");\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, 1L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases);\n    }\n    @Test\n    public void findCasesWithDatedDocumentReturnsCaseList() {\n        List<ReturnedCaseDetails> cases =\n            caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\", \"2021-01-01\");\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseList() {\n        caseQueryService.dataExtractPaginationSize = 1;\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePages() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 5);\n        ReturnedCases returnedCases2 = getReturnedCases(2, 3, 5);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n        assertEquals(5, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesExact() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 6);\n        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 6);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n        assertEquals(6, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertThat(cases.get(5).getId(), is(5L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n        assertEquals(\"Smith5\", cases.get(5).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesPlus() {\n        caseQueryService.dataExtractPaginationSize = 3;\n        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 7);\n        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 7);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 6, 7);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n            returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n        assertEquals(7, cases.size());\n        assertThat(cases.get(0).getId(), is(0L));\n        assertThat(cases.get(1).getId(), is(1L));\n        assertThat(cases.get(2).getId(), is(2L));\n        assertThat(cases.get(3).getId(), is(3L));\n        assertThat(cases.get(4).getId(), is(4L));\n        assertThat(cases.get(5).getId(), is(5L));\n        assertThat(cases.get(6).getId(), is(6L));\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n        assertEquals(\"Smith1\", cases.get(1).getData().getDeceasedSurname());\n        assertEquals(\"Smith2\", cases.get(2).getData().getDeceasedSurname());\n        assertEquals(\"Smith3\", cases.get(3).getData().getDeceasedSurname());\n        assertEquals(\"Smith4\", cases.get(4).getData().getDeceasedSurname());\n        assertEquals(\"Smith5\", cases.get(5).getData().getDeceasedSurname());\n        assertEquals(\"Smith6\", cases.get(6).getData().getDeceasedSurname());\n    }\n    private ReturnedCases getReturnedCases(int numCases, int caseIndex, int total) {\n        ArrayList<ReturnedCaseDetails> allReturnedCases = new ArrayList<>();\n        for (int i = 0; i < numCases; i++) {\n            CaseData caseData = CaseData.builder()\n                .deceasedSurname(\"Smith\" + (caseIndex + i))\n                .build();\n            allReturnedCases.add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, Long.valueOf(caseIndex + i)));\n        }\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>()\n                .addAll(allReturnedCases)\n                .build();\n        return new ReturnedCases(caseList, total);\n    }\n    @Test\n    public void findCasesInitiatedBySchedulerReturnsCaseList() {\n        when(headers.getAuthorizationHeaders()).thenThrow(NullPointerException.class);\n        List<ReturnedCaseDetails> cases = caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\");\n        assertEquals(1, cases.size());\n        assertThat(cases.get(0).getId(), is(1L));\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListExela() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeExela(\"2019-01-01\", \"2019-02-05\");\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test(expected = ClientDataException.class)\n    public void findCasesWithDateRangeThrowsError() {\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>()\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 1L))\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 2L))\n                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 3L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        caseQueryService.findCaseStateWithinDateRangeExela(\"2019-01-01\", \"2019-02-05\");\n    }\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListHMRC() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeHMRC(\"2019-01-01\", \"2019-02-05\");\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findCasesWithDateRangeReturnsCaseListSmeeAndFord() {\n        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn(\"qry\");\n        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);\n        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);\n        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,\n                returnedCases3);\n        List<ReturnedCaseDetails> cases = caseQueryService\n            .findCaseStateWithinDateRangeSmeeAndFord(\"2019-01-01\", \"2019-02-05\");\n        assertEquals(3, cases.size());\n        assertEquals(0, cases.get(0).getId().intValue());\n        assertEquals(\"Smith0\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void testHttpExceptionCaughtWithBadPost() {\n        when(restTemplate.postForObject(any(), any(), any())).thenThrow(HttpClientErrorException.class);\n        Assertions.assertThatThrownBy(() -> caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\",\n            \"2021-01-01\"))\n            .isInstanceOf(CaseMatchingException.class);\n    }\n    @Test\n    public void findCasesForGrantDelayed() {\n        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantDelayed(\"2019-02-05\");\n        assertEquals(1, cases.size());\n        assertEquals(1, cases.get(0).getId().intValue());\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test\n    public void findCasesForGrantAwaitingDocs() {\n        CaseData caseData = CaseData.builder()\n            .deceasedSurname(\"Smith\")\n            .build();\n        List<ReturnedCaseDetails> caseList =\n            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,\n                LAST_MODIFIED, 1L))\n                .build();\n        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);\n        when(restTemplate.postForObject(any(), entityCaptor.capture(), any())).thenReturn(returnedCases);\n        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantAwaitingDocumentation(\"2019-02-05\");\n        String expected = \"{\\\"from\\\":0,\\\"size\\\":0,\\\"query\\\":{\\\"bool\\\":{\\\"must\\\":[{\\\"bool\\\":{\\\"should\\\":[{\\\"match\\\":\"\n                + \"{\\\"state\\\":{\\\"query\\\":\\\"CasePrinted\\\",\\\"operator\\\":\\\"OR\\\",\\\"prefix_length\\\":0,\\\"max_expansions\\\":50,\"\n                + \"\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\\\"zero_terms_query\\\":\\\"NONE\\\",\"\n                + \"\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}}],\\\"adjust_pure_negative\\\":true,\"\n                + \"\\\"minimum_should_match\\\":\\\"1\\\",\\\"boost\\\":1.0}},{\\\"match\\\":\"\n                + \"{\\\"data.grantAwaitingDocumentationNotificationDate\\\":{\\\"query\\\":\\\"2019-02-05\\\",\\\"operator\\\":\\\"OR\\\",\"\n                + \"\\\"prefix_length\\\":0,\\\"max_expansions\\\":50,\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\"\n                + \"\\\"zero_terms_query\\\":\\\"NONE\\\",\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}},\"\n                + \"{\\\"match\\\":{\\\"data.paperForm\\\":{\\\"query\\\":\\\"No\\\",\\\"operator\\\":\\\"OR\\\",\\\"prefix_length\\\":0,\"\n                + \"\\\"max_expansions\\\":50,\\\"fuzzy_transpositions\\\":true,\\\"lenient\\\":false,\\\"zero_terms_query\\\":\\\"NONE\\\",\"\n                + \"\\\"auto_generate_synonyms_phrase_query\\\":true,\\\"boost\\\":1.0}}}],\\\"must_not\\\":[{\\\"exists\\\":{\\\"field\\\":\"\n                + \"\\\"data.grantAwaitingDocumentatioNotificationSent\\\",\\\"boost\\\":1.0}},{\\\"exists\\\":{\\\"field\\\":\"\n                + \"\\\"data.evidenceHandled\\\",\\\"boost\\\":1.0}}],\\\"adjust_pure_negative\\\":true,\\\"boost\\\":1.0}},\"\n                + \"\\\"sort\\\":[{\\\"id\\\":{\\\"order\\\":\\\"asc\\\"}}]}\";\n        assertEquals(expected, entityCaptor.getValue().getBody());\n        assertEquals(1, cases.size());\n        assertEquals(1, cases.get(0).getId().intValue());\n        assertEquals(\"Smith\", cases.get(0).getData().getDeceasedSurname());\n    }\n    @Test(expected = ClientDataException.class)\n    public void testExceptionWithNullFromRestTemplatePost() {\n        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);\n        caseQueryService.findGrantIssuedCasesWithGrantIssuedDate(\"invokingService\", \"2021-01-01\");\n    }\n"]], "pred": {"ppl": 1.7479054927825928, "ppl_lower": 2.072195529937744, "ppl/lowercase_ppl": -1.3047724354492074, "ppl/zlib": 0.00026591343326565756, "Min_5.0% Prob": 5.759819479549632, "Min_10.0% Prob": 4.172537574581072, "Min_20.0% Prob": 2.599215668498301, "Min_30.0% Prob": 1.8302352089020941, "Min_40.0% Prob": 1.3895165890928878, "Min_50.0% Prob": 1.1163645409587077, "Min_60.0% Prob": 0.9315409450476524}}
{"hexsha": "6aead2c61aec01278e0159f02dc83b2505af0a18", "ext": "java", "lang": "Java", "content": "public class RoomRightsListComposer extends MessageComposer\n{\n    private final Room room;\n\n    public RoomRightsListComposer(Room room)\n    {\n        this.room = room;\n    }\n\n    @Override\n    public ServerMessage compose()\n    {\n        this.response.init(Outgoing.RoomRightsListComposer);\n        this.response.appendInt(this.room.getId());\n\n        THashMap<Integer, String> rightsMap = this.room.getUsersWithRights();\n\n        this.response.appendInt(rightsMap.size());\n\n        for(Map.Entry<Integer, String> set : rightsMap.entrySet())\n        {\n            this.response.appendInt(set.getKey());\n            this.response.appendString(set.getValue());\n        }\n\n        return this.response;\n    }\n}", "class_id": 0, "repo": "Jackxun123/ArcturusEmulator", "file": "src/main/java/com/eu/habbo/messages/outgoing/rooms/RoomRightsListComposer.java", "last_update_at": "2018-12-21T00:02:33+00:00", "question_id": "6aead2c61aec01278e0159f02dc83b2505af0a18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RoomRightsListComposer extends MessageComposer\n{\n    private final Room room;\n    public RoomRightsListComposer(Room room)\n    {\n        this.room = room;\n    }\n    @Override\n    public ServerMessage compose()\n    {\n        this.response.init(Outgoing.RoomRightsListComposer);\n        this.response.appendInt(this.room.getId());\n        THashMap<Integer, String> rightsMap = this.room.getUsersWithRights();\n        this.response.appendInt(rightsMap.size());\n        for(Map.Entry<Integer, String> set : rightsMap.entrySet())\n        {\n            this.response.appendInt(set.getKey());\n            this.response.appendString(set.getValue());\n        }\n        return this.response;\n    }\n"]], "pred": {"ppl": 1.6123301982879639, "ppl_lower": 2.16092848777771, "ppl/lowercase_ppl": -1.6130824852419927, "ppl/zlib": 0.0016192557991718316, "Min_5.0% Prob": 6.369971132278442, "Min_10.0% Prob": 4.082585908117748, "Min_20.0% Prob": 2.3378929928654717, "Min_30.0% Prob": 1.587481793489248, "Min_40.0% Prob": 1.1955752768442922, "Min_50.0% Prob": 0.9585634704900994, "Min_60.0% Prob": 0.799565006507605}}
{"hexsha": "00f5c7f8d4c96ef6669bf721485a9f705880267a", "ext": "java", "lang": "Java", "content": "public class AppSearchUtils {\n    public AppSearchUtils() {\n    }\n\n    @SuppressLint({\"InlinedApi\"})\n    public static void invokeAppSearch(Context context) {\n        TagRecorder.onTag(context, Tag.newInstance(30));\n        Intent intent = new Intent(\"com.baidu.appsearch.extinvoker.LAUNCH\");\n        intent.putExtra(\"backop\", \"0\");\n        intent.putExtra(\"id\", context.getPackageName());\n        intent.putExtra(\"func\", \"10\");\n        intent.putExtra(\"pkg\", context.getPackageName());\n        intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        context.startActivity(intent);\n    }\n\n    public static boolean canAsUpdate(Context context) {\n        try {\n            int versioncode = context.getPackageManager().getPackageInfo(\"com.baidu.appsearch\", PackageManager.GET_SIGNATURES).versionCode;\n            if (versioncode > 16782394) {\n                return true;\n            }\n        } catch (NameNotFoundException var2) {\n//            LogUtils.printE(var2.getMessage());\n        }\n\n        return false;\n    }\n}", "class_id": 0, "repo": "lujianzhao/bd_autoupdate_sdk", "file": "bd_autoupdate_sdk/src/main/java/com/baidu/autoupdatesdk/utils/AppSearchUtils.java", "last_update_at": "2018-11-17T15:12:07+00:00", "question_id": "00f5c7f8d4c96ef6669bf721485a9f705880267a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AppSearchUtils {\n    public AppSearchUtils() {\n    }\n    @SuppressLint({\"InlinedApi\"})\n    public static void invokeAppSearch(Context context) {\n        TagRecorder.onTag(context, Tag.newInstance(30));\n        Intent intent = new Intent(\"com.baidu.appsearch.extinvoker.LAUNCH\");\n        intent.putExtra(\"backop\", \"0\");\n        intent.putExtra(\"id\", context.getPackageName());\n        intent.putExtra(\"func\", \"10\");\n        intent.putExtra(\"pkg\", context.getPackageName());\n        intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        context.startActivity(intent);\n    }\n    public static boolean canAsUpdate(Context context) {\n        try {\n            int versioncode = context.getPackageManager().getPackageInfo(\"com.baidu.appsearch\", PackageManager.GET_SIGNATURES).versionCode;\n            if (versioncode > 16782394) {\n                return true;\n            }\n        } catch (NameNotFoundException var2) {\n//            LogUtils.printE(var2.getMessage());\n        }\n        return false;\n    }\n"]], "pred": {"ppl": 2.7373480796813965, "ppl_lower": 3.6590356826782227, "ppl/lowercase_ppl": -1.2881956686708993, "ppl/zlib": 0.002026136011259282, "Min_5.0% Prob": 8.573550432920456, "Min_10.0% Prob": 6.445026345551014, "Min_20.0% Prob": 4.360443293131315, "Min_30.0% Prob": 3.216675123998097, "Min_40.0% Prob": 2.5058518149531803, "Min_50.0% Prob": 2.0154469761700353, "Min_60.0% Prob": 1.6789429186919362}}
{"hexsha": "7b5a50330b3bf53c555e9dfa8837c89a0f3367cc", "ext": "java", "lang": "Java", "content": "public class ShowInstancesFromClassesViewAction extends ShowInstancesAction {\n  private static final String POPUP_ELEMENT_LABEL = \"Show Instances\";\n\n  @Override\n  protected void perform(AnActionEvent e) {\n    final Project project = e.getProject();\n    final ReferenceType selectedClass = getSelectedClass(e);\n    if (project != null && selectedClass != null) {\n      final XDebugSession debugSession = XDebuggerManager.getInstance(project).getCurrentSession();\n      if (debugSession != null) {\n        new InstancesWindow(debugSession, limit -> selectedClass.instances(limit), selectedClass.name()).show();\n      }\n    }\n  }\n\n  @Override\n  protected String getLabel() {\n    return POPUP_ELEMENT_LABEL;\n  }\n\n  @Override\n  protected int getInstancesCount(AnActionEvent e) {\n    ClassesTable.ReferenceCountProvider countProvider = e.getData(ClassesTable.REF_COUNT_PROVIDER_KEY);\n    ReferenceType selectedClass = getSelectedClass(e);\n    if (countProvider == null || selectedClass == null) {\n      return -1;\n    }\n\n    return countProvider.getTotalCount(selectedClass);\n  }\n}", "class_id": 0, "repo": "dmeybohm/intellij-community", "file": "java/debugger/impl/src/com/intellij/debugger/memory/action/ShowInstancesFromClassesViewAction.java", "last_update_at": "2018-12-29T09:53:42+00:00", "question_id": "7b5a50330b3bf53c555e9dfa8837c89a0f3367cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ShowInstancesFromClassesViewAction extends ShowInstancesAction {\n  private static final String POPUP_ELEMENT_LABEL = \"Show Instances\";\n  @Override\n  protected void perform(AnActionEvent e) {\n    final Project project = e.getProject();\n    final ReferenceType selectedClass = getSelectedClass(e);\n    if (project != null && selectedClass != null) {\n      final XDebugSession debugSession = XDebuggerManager.getInstance(project).getCurrentSession();\n      if (debugSession != null) {\n        new InstancesWindow(debugSession, limit -> selectedClass.instances(limit), selectedClass.name()).show();\n      }\n    }\n  }\n  @Override\n  protected String getLabel() {\n    return POPUP_ELEMENT_LABEL;\n  }\n  @Override\n  protected int getInstancesCount(AnActionEvent e) {\n    ClassesTable.ReferenceCountProvider countProvider = e.getData(ClassesTable.REF_COUNT_PROVIDER_KEY);\n    ReferenceType selectedClass = getSelectedClass(e);\n    if (countProvider == null || selectedClass == null) {\n      return -1;\n    }\n    return countProvider.getTotalCount(selectedClass);\n  }\n"]], "pred": {"ppl": 2.4200336933135986, "ppl_lower": 3.72159743309021, "ppl/lowercase_ppl": -1.4869660076988818, "ppl/zlib": 0.001986025759389959, "Min_5.0% Prob": 7.977350609643119, "Min_10.0% Prob": 6.005883447055159, "Min_20.0% Prob": 3.918131747488248, "Min_30.0% Prob": 2.838229658563485, "Min_40.0% Prob": 2.1964794663807092, "Min_50.0% Prob": 1.7676327557781257, "Min_60.0% Prob": 1.4734535143407208}}
{"hexsha": "6f1ff3bf54598e2af3ea2c0f266b628bba02a812", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class SearchEndpoint extends AbstractTwitchEndpoint {\n\n\t/**\n\t * Search Endpoint\n\t *\n\t * @param client The Twitch Client.\n\t */\n\tpublic SearchEndpoint(TwitchClient client) {\n\t\tsuper(client, client.getRestClient().getRestTemplate());\n\t}\n\n\t/**\n\t * Endpoint: Search Channels\n\t * Searches for channels based on a specified query parameter. A channel is returned if the query parameter is matched entirely or partially, in the channel description or game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.\n\t * @return A list of Channels matching the query.\n\t */\n\tpublic List<Channel> getChannels(String query, @Nullable Integer limit) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\n\t\t// Parameters\n\t\tif (limit != null) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"limit\", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));\n\t\t}\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", URLEncoder.encode(query)));\n\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/channels\", ChannelList.class).getChannels();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t/**\n\t * Endpoint: Search Games\n\t * Searches for games based on a specified query parameter. A game is returned if the query parameter is matched entirely or partially, in the game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param live  Whether only games that are live should be returned. This argument is optional.\n\t * @return A list of games matching the query.\n\t */\n\tpublic List<Game> getGames(String query, @Nullable Boolean live) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\n\t\t// Parameters\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", query));\n\t\tif (live != null && live) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"live\", live.toString()));\n\t\t}\n\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/games\", GameList.class).getGames();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t/**\n\t * Endpoint: Search Streams\n\t * Searches for streams based on a specified query parameter. A stream is returned if the query parameter is matched entirely or partially, in the channel description or game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.\n\t * @return A list of Streams matching the query.\n\t */\n\tpublic List<Stream> getStreams(String query, @Nullable Integer limit) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\n\t\t// Parameters\n\t\tif (limit != null) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"limit\", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));\n\t\t}\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", query));\n\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/streams\", StreamList.class).getStreams();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n}", "class_id": 0, "repo": "SZOKOZ/twitch4j", "file": "src/main/java/me/philippheuer/twitch4j/endpoints/SearchEndpoint.java", "last_update_at": "2018-09-26T18:09:14+00:00", "question_id": "6f1ff3bf54598e2af3ea2c0f266b628bba02a812", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class SearchEndpoint extends AbstractTwitchEndpoint {\n\t/**\n\t * Search Endpoint\n\t *\n\t * @param client The Twitch Client.\n\t */\n\tpublic SearchEndpoint(TwitchClient client) {\n\t\tsuper(client, client.getRestClient().getRestTemplate());\n\t}\n\t/**\n\t * Endpoint: Search Channels\n\t * Searches for channels based on a specified query parameter. A channel is returned if the query parameter is matched entirely or partially, in the channel description or game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.\n\t * @return A list of Channels matching the query.\n\t */\n\tpublic List<Channel> getChannels(String query, @Nullable Integer limit) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\t\t// Parameters\n\t\tif (limit != null) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"limit\", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));\n\t\t}\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", URLEncoder.encode(query)));\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/channels\", ChannelList.class).getChannels();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\t/**\n\t * Endpoint: Search Games\n\t * Searches for games based on a specified query parameter. A game is returned if the query parameter is matched entirely or partially, in the game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param live  Whether only games that are live should be returned. This argument is optional.\n\t * @return A list of games matching the query.\n\t */\n\tpublic List<Game> getGames(String query, @Nullable Boolean live) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\t\t// Parameters\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", query));\n\t\tif (live != null && live) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"live\", live.toString()));\n\t\t}\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/games\", GameList.class).getGames();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\t/**\n\t * Endpoint: Search Streams\n\t * Searches for streams based on a specified query parameter. A stream is returned if the query parameter is matched entirely or partially, in the channel description or game name.\n\t * Requires Scope: none\n\t *\n\t * @param query search query\n\t * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.\n\t * @return A list of Streams matching the query.\n\t */\n\tpublic List<Stream> getStreams(String query, @Nullable Integer limit) {\n\t\t// Endpoint\n\t\tRestTemplate restTemplate = this.restTemplate;\n\t\t// Parameters\n\t\tif (limit != null) {\n\t\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"limit\", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));\n\t\t}\n\t\trestTemplate.getInterceptors().add(new QueryRequestInterceptor(\"query\", query));\n\t\t// REST Request\n\t\ttry {\n\t\t\treturn restTemplate.getForObject(\"/search/streams\", StreamList.class).getStreams();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"Request failed: \" + ex.getMessage());\n\t\t\tlog.trace(ExceptionUtils.getStackTrace(ex));\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.4438704252243042, "ppl_lower": 1.5946805477142334, "ppl/lowercase_ppl": -1.2704566976685518, "ppl/zlib": 0.0004251473416900484, "Min_5.0% Prob": 4.494535539664474, "Min_10.0% Prob": 3.1373964887039336, "Min_20.0% Prob": 1.7977728247642517, "Min_30.0% Prob": 1.2195313260373142, "Min_40.0% Prob": 0.9165785022781283, "Min_50.0% Prob": 0.7347981579999991, "Min_60.0% Prob": 0.6128446010526705}}
{"hexsha": "2a63ae88b82dfa9318e34c2c4cc5d0d395254f1d", "ext": "java", "lang": "Java", "content": "public class RegisterCustomerAgentToBlackboardPlan extends OneShotBehaviour implements PlanBody {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tprivate Logger log;\r\n\r\n\t@Override\r\n\tpublic EndState getEndState() {\r\n\t\treturn EndState.SUCCESSFUL;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void init(PlanInstance planInstance) {\r\n\t\tlog=LogManager.getLogger();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void action() {\r\n\r\n\t\tAID bb_aid = AgentUtil.findBlackboardAgent(myAgent);\r\n\r\n\t\tNamedZoneData ZoneDataName1 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerConfirmedJobs).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerConfirmedJobs).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName2 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.newWorkOrderFromCustomer).\r\n\t\t\t\tMsgID(MessageIds.msgnewWorkOrderFromCustomer).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName3 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerJobsUnderNegotiation).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerJobsUnderNegotiation).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName4 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerCanceledOrders).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerCanceledOrders).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName5 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerChangeDDorders).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerChangeDDorders).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData[] ZoneDataNames =  { ZoneDataName1,\r\n\t\t\t\tZoneDataName2,ZoneDataName3, ZoneDataName4, ZoneDataName5 };\r\n\r\n\r\n\t\tAgentUtil.makeZoneBB(myAgent,ZoneDataNames);\r\n\r\n\t\tSubscriptionForm subform = new SubscriptionForm();\r\n\t\tAID target = new AID(ID.GlobalScheduler.LocalName, AID.ISLOCALNAME);\r\n\r\n\t\tString[] params = { ID.GlobalScheduler.ZoneData.GSAjobsUnderNegaotiation,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.GSAConfirmedOrder,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.completedJobByGSA ,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.dueDateChangeBatches,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.rejectedOrders};\r\n\r\n\t\tsubform.AddSubscriptionReq(target, params);\r\n\r\n\t\tAgentUtil.subscribeToParam(myAgent, bb_aid, subform);\r\n\t}\r\n}", "class_id": 0, "repo": "mskiitd/MAS-GUI", "file": "AgentProxy/src/mas/customerproxy/plan/RegisterCustomerAgentToBlackboardPlan.java", "last_update_at": "2018-02-13T05:51:21+00:00", "question_id": "2a63ae88b82dfa9318e34c2c4cc5d0d395254f1d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RegisterCustomerAgentToBlackboardPlan extends OneShotBehaviour implements PlanBody {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tprivate Logger log;\r\n\r\n\t@Override\r\n\tpublic EndState getEndState() {\r\n\t\treturn EndState.SUCCESSFUL;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void init(PlanInstance planInstance) {\r\n\t\tlog=LogManager.getLogger();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void action() {\r\n\r\n\t\tAID bb_aid = AgentUtil.findBlackboardAgent(myAgent);\r\n\r\n\t\tNamedZoneData ZoneDataName1 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerConfirmedJobs).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerConfirmedJobs).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName2 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.newWorkOrderFromCustomer).\r\n\t\t\t\tMsgID(MessageIds.msgnewWorkOrderFromCustomer).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName3 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerJobsUnderNegotiation).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerJobsUnderNegotiation).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName4 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerCanceledOrders).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerCanceledOrders).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData ZoneDataName5 = \r\n\t\t\t\tnew NamedZoneData.Builder(ID.Customer.ZoneData.customerChangeDDorders).\r\n\t\t\t\tMsgID(MessageIds.msgcustomerChangeDDorders).\r\n\t\t\t\tappendValue(false).\r\n\t\t\t\tbuild();\r\n\r\n\t\tNamedZoneData[] ZoneDataNames =  { ZoneDataName1,\r\n\t\t\t\tZoneDataName2,ZoneDataName3, ZoneDataName4, ZoneDataName5 };\r\n\r\n\r\n\t\tAgentUtil.makeZoneBB(myAgent,ZoneDataNames);\r\n\r\n\t\tSubscriptionForm subform = new SubscriptionForm();\r\n\t\tAID target = new AID(ID.GlobalScheduler.LocalName, AID.ISLOCALNAME);\r\n\r\n\t\tString[] params = { ID.GlobalScheduler.ZoneData.GSAjobsUnderNegaotiation,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.GSAConfirmedOrder,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.completedJobByGSA ,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.dueDateChangeBatches,\r\n\t\t\t\tID.GlobalScheduler.ZoneData.rejectedOrders};\r\n\r\n\t\tsubform.AddSubscriptionReq(target, params);\r\n\r\n\t\tAgentUtil.subscribeToParam(myAgent, bb_aid, subform);\r\n\t}\r\n"]], "pred": {"ppl": 2.273460865020752, "ppl_lower": 2.6051340103149414, "ppl/lowercase_ppl": -1.1658106572833389, "ppl/zlib": 0.0012042570096722981, "Min_5.0% Prob": 8.037147998809814, "Min_10.0% Prob": 6.166382530589162, "Min_20.0% Prob": 3.892793260238789, "Min_30.0% Prob": 2.7118955779148908, "Min_40.0% Prob": 2.052665235669567, "Min_50.0% Prob": 1.6417152408718678, "Min_60.0% Prob": 1.3697406775840524}}
{"hexsha": "71d017a0fe026f27a32d2391f1cd2efa785b2f98", "ext": "java", "lang": "Java", "content": "@Wire\npublic class BulletSystem extends EntityProcessingSystem {\n\n    @Mapper ComponentMapper<Bullet> sm;\n    @Mapper ComponentMapper<Position> pm;\n    @Mapper ComponentMapper<Physics> phm;\n    @Mapper ComponentMapper<Health> hm;\n    @Mapper ComponentMapper<Animation> am;\n    public ParticleSystem particleSystem;\n    public CombatSystem combatSystem;\n    private PlayerSystem playerSystem;\n\n    public BulletSystem() {\n        super(Aspect.getAspectForAll(Bullet.class, Position.class, Physics.class));\n    }\n\n    private Vector2 tmp = new Vector2();\n\n    @Override\n    protected void initialize() {\n        particleSystem = world.getSystem(ParticleSystem.class);\n        combatSystem = world.getSystem(CombatSystem.class);\n        playerSystem = world.getSystem(PlayerSystem.class);\n    }\n\n    @Override\n    protected void process(Entity e) {\n        Position position = pm.get(e);\n        Position playerPos = pm.get(ToxUtil.getPlayer());\n        Physics physics = phm.get(e);\n\n        // create vector that points from bullet to player;\n        int playerX = (int) (playerPos.x + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);\n        int playerY = (int) (playerPos.y + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);\n        tmp.set(playerX, playerY)\n                .sub(position.x + Animation.DEFAULT_SCALE * 5, position.y + Animation.DEFAULT_SCALE * 5);\n\n        if (tmp.len() > 20) {\n            tmp.nor().scl(1200);\n            am.get(e).rotation = tmp.angle();\n            physics.velocityX = tmp.x;\n            physics.velocityY = tmp.y;\n        } else {\n            particleSystem.explosion(playerX, playerY, Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE);\n            if (combatSystem.isAlive(ToxUtil.getPlayer())) {\n                combatSystem.damage(ToxUtil.getPlayer(), Math.max(0.1f, hm.get(ToxUtil.getPlayer()).maxHealth / 10));\n                if (!combatSystem.isAlive(ToxUtil.getPlayer())) {\n                    playerSystem.killPlayer(\"The Jailer\");\n                }\n            }\n            e.deleteFromWorld();\n        }\n    }\n}", "class_id": 0, "repo": "DaanVanYperen/tox", "file": "core/src/net/mostlyoriginal/tox/system/BulletSystem.java", "last_update_at": "2018-05-12T16:41:15+00:00", "question_id": "71d017a0fe026f27a32d2391f1cd2efa785b2f98", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Wire\npublic class BulletSystem extends EntityProcessingSystem {\n    @Mapper ComponentMapper<Bullet> sm;\n    @Mapper ComponentMapper<Position> pm;\n    @Mapper ComponentMapper<Physics> phm;\n    @Mapper ComponentMapper<Health> hm;\n    @Mapper ComponentMapper<Animation> am;\n    public ParticleSystem particleSystem;\n    public CombatSystem combatSystem;\n    private PlayerSystem playerSystem;\n    public BulletSystem() {\n        super(Aspect.getAspectForAll(Bullet.class, Position.class, Physics.class));\n    }\n    private Vector2 tmp = new Vector2();\n    @Override\n    protected void initialize() {\n        particleSystem = world.getSystem(ParticleSystem.class);\n        combatSystem = world.getSystem(CombatSystem.class);\n        playerSystem = world.getSystem(PlayerSystem.class);\n    }\n    @Override\n    protected void process(Entity e) {\n        Position position = pm.get(e);\n        Position playerPos = pm.get(ToxUtil.getPlayer());\n        Physics physics = phm.get(e);\n        // create vector that points from bullet to player;\n        int playerX = (int) (playerPos.x + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);\n        int playerY = (int) (playerPos.y + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);\n        tmp.set(playerX, playerY)\n                .sub(position.x + Animation.DEFAULT_SCALE * 5, position.y + Animation.DEFAULT_SCALE * 5);\n        if (tmp.len() > 20) {\n            tmp.nor().scl(1200);\n            am.get(e).rotation = tmp.angle();\n            physics.velocityX = tmp.x;\n            physics.velocityY = tmp.y;\n        } else {\n            particleSystem.explosion(playerX, playerY, Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE);\n            if (combatSystem.isAlive(ToxUtil.getPlayer())) {\n                combatSystem.damage(ToxUtil.getPlayer(), Math.max(0.1f, hm.get(ToxUtil.getPlayer()).maxHealth / 10));\n                if (!combatSystem.isAlive(ToxUtil.getPlayer())) {\n                    playerSystem.killPlayer(\"The Jailer\");\n                }\n            }\n            e.deleteFromWorld();\n        }\n    }\n"]], "pred": {"ppl": 1.9530774354934692, "ppl_lower": 2.455580711364746, "ppl/lowercase_ppl": -1.3420299073250732, "ppl/zlib": 0.0009659542577471078, "Min_5.0% Prob": 6.402317216319423, "Min_10.0% Prob": 4.738048678352719, "Min_20.0% Prob": 3.016166791671843, "Min_30.0% Prob": 2.1661257927174344, "Min_40.0% Prob": 1.6644717644108094, "Min_50.0% Prob": 1.3378683462469552, "Min_60.0% Prob": 1.1155592173945004}}
{"hexsha": "8aa3e95e01d2b98bbbbac9ab23a9db30fc944884", "ext": "java", "lang": "Java", "content": "public class RepeatedSubstrings\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString str = \"pwwde\";\n\t\tSystem.out.println(method1(str));\n\t\tSystem.out.println(method2(str));\n\t\tSystem.out.println(method3(str));\n\t}\n\n\t/**\n\t * \u81ea\u5df1\u7684\u89e3\u6cd5\n\t * @param str\n\t * @return\n\t */\n\tpublic static int method1(String str){\n\t\tMap<Character,Integer> map = new HashMap<>();\n\t\tchar[] ch = str.toCharArray();\n\t\tint max = 0;\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif(map.containsKey(ch[i])){\n\t\t\t\tint size = map.size();\n\t\t\t\tif(size > max){\n\t\t\t\t\tmax = size;\n\t\t\t\t}\n\t\t\t\ti = map.get(ch[i]);\n\t\t\t\tmap.clear();\n\t\t\t}else{\n\t\t\t\tmap.put(ch[i] , i);\n\t\t\t}\n\t\t}\n\t\tint size = map.size();\n\t\tif(size > max){\n\t\t\tmax = size;\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic static int method2(String str){\n\t\tint size = str.length();\n\t\tSet<Character> set = new HashSet<>();\n\t\tint max = 0,i = 0, j = 0;\n\t\twhile(i < size && j < size){\n\t\t\tif(!set.contains(str.charAt(j))){\n\t\t\t\tset.add(str.charAt(j));\n\t\t\t\tj++;\n\t\t\t\tmax = Math.max(max , j - i);\n\t\t\t}else{\n\t\t\t\tset.remove(str.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic static int method3(String str){\n\t\tint size = str.length();\n\t\tint max = 0;\n\t\tMap<Character, Integer> map = new HashMap<>();\n\t\tfor(int j = 0,i = 0; j < size; j++){\n\t\t\tif(map.containsKey(str.charAt(j))){\n\t\t\t\ti = map.get(str.charAt(j));\n\t\t\t}\n\t\t\tmax = Math.max(max,j - i + 1);\n\t\t\tmap.put(str.charAt(j),j + 1);\n\t\t}\n\t\treturn max;\n\t}\n}", "class_id": 0, "repo": "xp-zhao/learn-java", "file": "leetcode/src/main/java/RepeatedSubstrings.java", "last_update_at": "2018-12-07T02:43:06+00:00", "question_id": "8aa3e95e01d2b98bbbbac9ab23a9db30fc944884", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RepeatedSubstrings\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString str = \"pwwde\";\n\t\tSystem.out.println(method1(str));\n\t\tSystem.out.println(method2(str));\n\t\tSystem.out.println(method3(str));\n\t}\n\t/**\n\t * \u81ea\u5df1\u7684\u89e3\u6cd5\n\t * @param str\n\t * @return\n\t */\n\tpublic static int method1(String str){\n\t\tMap<Character,Integer> map = new HashMap<>();\n\t\tchar[] ch = str.toCharArray();\n\t\tint max = 0;\n\t\tfor(int i = 0; i < ch.length; i++){\n\t\t\tif(map.containsKey(ch[i])){\n\t\t\t\tint size = map.size();\n\t\t\t\tif(size > max){\n\t\t\t\t\tmax = size;\n\t\t\t\t}\n\t\t\t\ti = map.get(ch[i]);\n\t\t\t\tmap.clear();\n\t\t\t}else{\n\t\t\t\tmap.put(ch[i] , i);\n\t\t\t}\n\t\t}\n\t\tint size = map.size();\n\t\tif(size > max){\n\t\t\tmax = size;\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int method2(String str){\n\t\tint size = str.length();\n\t\tSet<Character> set = new HashSet<>();\n\t\tint max = 0,i = 0, j = 0;\n\t\twhile(i < size && j < size){\n\t\t\tif(!set.contains(str.charAt(j))){\n\t\t\t\tset.add(str.charAt(j));\n\t\t\t\tj++;\n\t\t\t\tmax = Math.max(max , j - i);\n\t\t\t}else{\n\t\t\t\tset.remove(str.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int method3(String str){\n\t\tint size = str.length();\n\t\tint max = 0;\n\t\tMap<Character, Integer> map = new HashMap<>();\n\t\tfor(int j = 0,i = 0; j < size; j++){\n\t\t\tif(map.containsKey(str.charAt(j))){\n\t\t\t\ti = map.get(str.charAt(j));\n\t\t\t}\n\t\t\tmax = Math.max(max,j - i + 1);\n\t\t\tmap.put(str.charAt(j),j + 1);\n\t\t}\n\t\treturn max;\n\t}\n"]], "pred": {"ppl": 1.4208018779754639, "ppl_lower": 1.5412755012512207, "ppl/lowercase_ppl": -1.2317310467780858, "ppl/zlib": 0.0006385843909603024, "Min_5.0% Prob": 4.570044712586836, "Min_10.0% Prob": 2.919701607841434, "Min_20.0% Prob": 1.6760643966721767, "Min_30.0% Prob": 1.1513063021832042, "Min_40.0% Prob": 0.8732575654743634, "Min_50.0% Prob": 0.7017167623041931, "Min_60.0% Prob": 0.5856779448498708}}
{"hexsha": "a086d7321caaa52e2f23a65babe0197032bcd427", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(\"by GAPIC\")\npublic class DlpServiceClientTest {\n  private static MockDlpService mockDlpService;\n  private static MockServiceHelper serviceHelper;\n  private DlpServiceClient client;\n  private LocalChannelProvider channelProvider;\n\n  @BeforeClass\n  public static void startStaticServer() {\n    mockDlpService = new MockDlpService();\n    serviceHelper =\n        new MockServiceHelper(\"in-process-1\", Arrays.<MockGrpcService>asList(mockDlpService));\n    serviceHelper.start();\n  }\n\n  @AfterClass\n  public static void stopServer() {\n    serviceHelper.stop();\n  }\n\n  @Before\n  public void setUp() throws IOException {\n    serviceHelper.reset();\n    channelProvider = serviceHelper.createChannelProvider();\n    DlpServiceSettings settings =\n        DlpServiceSettings.newBuilder()\n            .setTransportChannelProvider(channelProvider)\n            .setCredentialsProvider(NoCredentialsProvider.create())\n            .build();\n    client = DlpServiceClient.create(settings);\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    client.close();\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void inspectContentTest() {\n    InspectContentResponse expectedResponse = InspectContentResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n\n    String name = \"EMAIL_ADDRESS\";\n    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n    String type = \"text/plain\";\n    String value = \"My email is example@example.com.\";\n    ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();\n    List<ContentItem> items = Arrays.asList(itemsElement);\n\n    InspectContentResponse actualResponse = client.inspectContent(inspectConfig, items);\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    InspectContentRequest actualRequest = (InspectContentRequest) actualRequests.get(0);\n\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(items, actualRequest.getItemsList());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void inspectContentExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      String name = \"EMAIL_ADDRESS\";\n      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n      String type = \"text/plain\";\n      String value = \"My email is example@example.com.\";\n      ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();\n      List<ContentItem> items = Arrays.asList(itemsElement);\n\n      client.inspectContent(inspectConfig, items);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void deidentifyContentTest() {\n    DeidentifyContentResponse expectedResponse = DeidentifyContentResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n\n    DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();\n    InspectConfig inspectConfig = InspectConfig.newBuilder().build();\n    List<ContentItem> items = new ArrayList<>();\n\n    DeidentifyContentResponse actualResponse =\n        client.deidentifyContent(deidentifyConfig, inspectConfig, items);\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    DeidentifyContentRequest actualRequest = (DeidentifyContentRequest) actualRequests.get(0);\n\n    Assert.assertEquals(deidentifyConfig, actualRequest.getDeidentifyConfig());\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(items, actualRequest.getItemsList());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void deidentifyContentExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();\n      InspectConfig inspectConfig = InspectConfig.newBuilder().build();\n      List<ContentItem> items = new ArrayList<>();\n\n      client.deidentifyContent(deidentifyConfig, inspectConfig, items);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void analyzeDataSourceRiskTest() throws Exception {\n    RiskAnalysisOperationResult expectedResponse = RiskAnalysisOperationResult.newBuilder().build();\n    Operation resultOperation =\n        Operation.newBuilder()\n            .setName(\"analyzeDataSourceRiskTest\")\n            .setDone(true)\n            .setResponse(Any.pack(expectedResponse))\n            .build();\n    mockDlpService.addResponse(resultOperation);\n\n    PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();\n    BigQueryTable sourceTable = BigQueryTable.newBuilder().build();\n\n    RiskAnalysisOperationResult actualResponse =\n        client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    AnalyzeDataSourceRiskRequest actualRequest =\n        (AnalyzeDataSourceRiskRequest) actualRequests.get(0);\n\n    Assert.assertEquals(privacyMetric, actualRequest.getPrivacyMetric());\n    Assert.assertEquals(sourceTable, actualRequest.getSourceTable());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void analyzeDataSourceRiskExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();\n      BigQueryTable sourceTable = BigQueryTable.newBuilder().build();\n\n      client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();\n      Assert.fail(\"No exception raised\");\n    } catch (ExecutionException e) {\n      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());\n      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();\n      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void createInspectOperationTest() throws Exception {\n    ResultName name2 = ResultName.of(\"[RESULT]\");\n    InspectOperationResult expectedResponse =\n        InspectOperationResult.newBuilder().setName(name2.toString()).build();\n    Operation resultOperation =\n        Operation.newBuilder()\n            .setName(\"createInspectOperationTest\")\n            .setDone(true)\n            .setResponse(Any.pack(expectedResponse))\n            .build();\n    mockDlpService.addResponse(resultOperation);\n\n    String name = \"EMAIL_ADDRESS\";\n    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n    String url = \"gs://example_bucket/example_file.png\";\n    CloudStorageOptions.FileSet fileSet =\n        CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();\n    CloudStorageOptions cloudStorageOptions =\n        CloudStorageOptions.newBuilder().setFileSet(fileSet).build();\n    StorageConfig storageConfig =\n        StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();\n    OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();\n\n    InspectOperationResult actualResponse =\n        client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    CreateInspectOperationRequest actualRequest =\n        (CreateInspectOperationRequest) actualRequests.get(0);\n\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(storageConfig, actualRequest.getStorageConfig());\n    Assert.assertEquals(outputConfig, actualRequest.getOutputConfig());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void createInspectOperationExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      String name = \"EMAIL_ADDRESS\";\n      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n      String url = \"gs://example_bucket/example_file.png\";\n      CloudStorageOptions.FileSet fileSet =\n          CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();\n      CloudStorageOptions cloudStorageOptions =\n          CloudStorageOptions.newBuilder().setFileSet(fileSet).build();\n      StorageConfig storageConfig =\n          StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();\n      OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();\n\n      client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();\n      Assert.fail(\"No exception raised\");\n    } catch (ExecutionException e) {\n      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());\n      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();\n      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInspectFindingsTest() {\n    String nextPageToken = \"nextPageToken-1530815211\";\n    ListInspectFindingsResponse expectedResponse =\n        ListInspectFindingsResponse.newBuilder().setNextPageToken(nextPageToken).build();\n    mockDlpService.addResponse(expectedResponse);\n\n    ResultName name = ResultName.of(\"[RESULT]\");\n\n    ListInspectFindingsResponse actualResponse = client.listInspectFindings(name);\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListInspectFindingsRequest actualRequest = (ListInspectFindingsRequest) actualRequests.get(0);\n\n    Assert.assertEquals(name, ResultName.parse(actualRequest.getName()));\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInspectFindingsExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      ResultName name = ResultName.of(\"[RESULT]\");\n\n      client.listInspectFindings(name);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInfoTypesTest() {\n    ListInfoTypesResponse expectedResponse = ListInfoTypesResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n\n    String category = \"PII\";\n    String languageCode = \"en\";\n\n    ListInfoTypesResponse actualResponse = client.listInfoTypes(category, languageCode);\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListInfoTypesRequest actualRequest = (ListInfoTypesRequest) actualRequests.get(0);\n\n    Assert.assertEquals(category, actualRequest.getCategory());\n    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInfoTypesExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      String category = \"PII\";\n      String languageCode = \"en\";\n\n      client.listInfoTypes(category, languageCode);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listRootCategoriesTest() {\n    ListRootCategoriesResponse expectedResponse = ListRootCategoriesResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n\n    String languageCode = \"en\";\n\n    ListRootCategoriesResponse actualResponse = client.listRootCategories(languageCode);\n    Assert.assertEquals(expectedResponse, actualResponse);\n\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListRootCategoriesRequest actualRequest = (ListRootCategoriesRequest) actualRequests.get(0);\n\n    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listRootCategoriesExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n\n    try {\n      String languageCode = \"en\";\n\n      client.listRootCategories(languageCode);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n}", "class_id": 0, "repo": "mbrukman/gcloud-java", "file": "google-cloud-dlp/src/test/java/com/google/cloud/dlp/v2beta1/DlpServiceClientTest.java", "last_update_at": "2018-03-03T00:49:28+00:00", "question_id": "a086d7321caaa52e2f23a65babe0197032bcd427", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(\"by GAPIC\")\npublic class DlpServiceClientTest {\n  private static MockDlpService mockDlpService;\n  private static MockServiceHelper serviceHelper;\n  private DlpServiceClient client;\n  private LocalChannelProvider channelProvider;\n  @BeforeClass\n  public static void startStaticServer() {\n    mockDlpService = new MockDlpService();\n    serviceHelper =\n        new MockServiceHelper(\"in-process-1\", Arrays.<MockGrpcService>asList(mockDlpService));\n    serviceHelper.start();\n  }\n  @AfterClass\n  public static void stopServer() {\n    serviceHelper.stop();\n  }\n  @Before\n  public void setUp() throws IOException {\n    serviceHelper.reset();\n    channelProvider = serviceHelper.createChannelProvider();\n    DlpServiceSettings settings =\n        DlpServiceSettings.newBuilder()\n            .setTransportChannelProvider(channelProvider)\n            .setCredentialsProvider(NoCredentialsProvider.create())\n            .build();\n    client = DlpServiceClient.create(settings);\n  }\n  @After\n  public void tearDown() throws Exception {\n    client.close();\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void inspectContentTest() {\n    InspectContentResponse expectedResponse = InspectContentResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n    String name = \"EMAIL_ADDRESS\";\n    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n    String type = \"text/plain\";\n    String value = \"My email is example@example.com.\";\n    ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();\n    List<ContentItem> items = Arrays.asList(itemsElement);\n    InspectContentResponse actualResponse = client.inspectContent(inspectConfig, items);\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    InspectContentRequest actualRequest = (InspectContentRequest) actualRequests.get(0);\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(items, actualRequest.getItemsList());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void inspectContentExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      String name = \"EMAIL_ADDRESS\";\n      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n      String type = \"text/plain\";\n      String value = \"My email is example@example.com.\";\n      ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();\n      List<ContentItem> items = Arrays.asList(itemsElement);\n      client.inspectContent(inspectConfig, items);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void deidentifyContentTest() {\n    DeidentifyContentResponse expectedResponse = DeidentifyContentResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n    DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();\n    InspectConfig inspectConfig = InspectConfig.newBuilder().build();\n    List<ContentItem> items = new ArrayList<>();\n    DeidentifyContentResponse actualResponse =\n        client.deidentifyContent(deidentifyConfig, inspectConfig, items);\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    DeidentifyContentRequest actualRequest = (DeidentifyContentRequest) actualRequests.get(0);\n    Assert.assertEquals(deidentifyConfig, actualRequest.getDeidentifyConfig());\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(items, actualRequest.getItemsList());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void deidentifyContentExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();\n      InspectConfig inspectConfig = InspectConfig.newBuilder().build();\n      List<ContentItem> items = new ArrayList<>();\n      client.deidentifyContent(deidentifyConfig, inspectConfig, items);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void analyzeDataSourceRiskTest() throws Exception {\n    RiskAnalysisOperationResult expectedResponse = RiskAnalysisOperationResult.newBuilder().build();\n    Operation resultOperation =\n        Operation.newBuilder()\n            .setName(\"analyzeDataSourceRiskTest\")\n            .setDone(true)\n            .setResponse(Any.pack(expectedResponse))\n            .build();\n    mockDlpService.addResponse(resultOperation);\n    PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();\n    BigQueryTable sourceTable = BigQueryTable.newBuilder().build();\n    RiskAnalysisOperationResult actualResponse =\n        client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    AnalyzeDataSourceRiskRequest actualRequest =\n        (AnalyzeDataSourceRiskRequest) actualRequests.get(0);\n    Assert.assertEquals(privacyMetric, actualRequest.getPrivacyMetric());\n    Assert.assertEquals(sourceTable, actualRequest.getSourceTable());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void analyzeDataSourceRiskExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();\n      BigQueryTable sourceTable = BigQueryTable.newBuilder().build();\n      client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();\n      Assert.fail(\"No exception raised\");\n    } catch (ExecutionException e) {\n      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());\n      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();\n      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void createInspectOperationTest() throws Exception {\n    ResultName name2 = ResultName.of(\"[RESULT]\");\n    InspectOperationResult expectedResponse =\n        InspectOperationResult.newBuilder().setName(name2.toString()).build();\n    Operation resultOperation =\n        Operation.newBuilder()\n            .setName(\"createInspectOperationTest\")\n            .setDone(true)\n            .setResponse(Any.pack(expectedResponse))\n            .build();\n    mockDlpService.addResponse(resultOperation);\n    String name = \"EMAIL_ADDRESS\";\n    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n    String url = \"gs://example_bucket/example_file.png\";\n    CloudStorageOptions.FileSet fileSet =\n        CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();\n    CloudStorageOptions cloudStorageOptions =\n        CloudStorageOptions.newBuilder().setFileSet(fileSet).build();\n    StorageConfig storageConfig =\n        StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();\n    OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();\n    InspectOperationResult actualResponse =\n        client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    CreateInspectOperationRequest actualRequest =\n        (CreateInspectOperationRequest) actualRequests.get(0);\n    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());\n    Assert.assertEquals(storageConfig, actualRequest.getStorageConfig());\n    Assert.assertEquals(outputConfig, actualRequest.getOutputConfig());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void createInspectOperationExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      String name = \"EMAIL_ADDRESS\";\n      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();\n      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);\n      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\n      String url = \"gs://example_bucket/example_file.png\";\n      CloudStorageOptions.FileSet fileSet =\n          CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();\n      CloudStorageOptions cloudStorageOptions =\n          CloudStorageOptions.newBuilder().setFileSet(fileSet).build();\n      StorageConfig storageConfig =\n          StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();\n      OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();\n      client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();\n      Assert.fail(\"No exception raised\");\n    } catch (ExecutionException e) {\n      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());\n      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();\n      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInspectFindingsTest() {\n    String nextPageToken = \"nextPageToken-1530815211\";\n    ListInspectFindingsResponse expectedResponse =\n        ListInspectFindingsResponse.newBuilder().setNextPageToken(nextPageToken).build();\n    mockDlpService.addResponse(expectedResponse);\n    ResultName name = ResultName.of(\"[RESULT]\");\n    ListInspectFindingsResponse actualResponse = client.listInspectFindings(name);\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListInspectFindingsRequest actualRequest = (ListInspectFindingsRequest) actualRequests.get(0);\n    Assert.assertEquals(name, ResultName.parse(actualRequest.getName()));\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInspectFindingsExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      ResultName name = ResultName.of(\"[RESULT]\");\n      client.listInspectFindings(name);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInfoTypesTest() {\n    ListInfoTypesResponse expectedResponse = ListInfoTypesResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n    String category = \"PII\";\n    String languageCode = \"en\";\n    ListInfoTypesResponse actualResponse = client.listInfoTypes(category, languageCode);\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListInfoTypesRequest actualRequest = (ListInfoTypesRequest) actualRequests.get(0);\n    Assert.assertEquals(category, actualRequest.getCategory());\n    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listInfoTypesExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      String category = \"PII\";\n      String languageCode = \"en\";\n      client.listInfoTypes(category, languageCode);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listRootCategoriesTest() {\n    ListRootCategoriesResponse expectedResponse = ListRootCategoriesResponse.newBuilder().build();\n    mockDlpService.addResponse(expectedResponse);\n    String languageCode = \"en\";\n    ListRootCategoriesResponse actualResponse = client.listRootCategories(languageCode);\n    Assert.assertEquals(expectedResponse, actualResponse);\n    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();\n    Assert.assertEquals(1, actualRequests.size());\n    ListRootCategoriesRequest actualRequest = (ListRootCategoriesRequest) actualRequests.get(0);\n    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());\n    Assert.assertTrue(\n        channelProvider.isHeaderSent(\n            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),\n            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));\n  }\n  @Test\n  @SuppressWarnings(\"all\")\n  public void listRootCategoriesExceptionTest() throws Exception {\n    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);\n    mockDlpService.addException(exception);\n    try {\n      String languageCode = \"en\";\n      client.listRootCategories(languageCode);\n      Assert.fail(\"No exception raised\");\n    } catch (InvalidArgumentException e) {\n      // Expected exception\n    }\n  }\n"]], "pred": {"ppl": 1.1454558372497559, "ppl_lower": 1.7800636291503906, "ppl/lowercase_ppl": -4.246228111575976, "ppl/zlib": 6.841444277891649e-05, "Min_5.0% Prob": 2.623442194625443, "Min_10.0% Prob": 1.3573417361350912, "Min_20.0% Prob": 0.680730681244099, "Min_30.0% Prob": 0.45395885160508803, "Min_40.0% Prob": 0.3396605058466146, "Min_50.0% Prob": 0.2718674510762721, "Min_60.0% Prob": 0.2266320712961369}}
{"hexsha": "9f27eaf38684361a0bfa6e77909dd1cd92c9e4a6", "ext": "java", "lang": "Java", "content": "public class ElectricTimeActivity extends BaseActivity {\n\n    private ElectricTimesVH electricTimesVH;\n\n    @Override\n    protected void initViews() {\n        ViewDataBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_electric_time);\n        electricTimesVH = new ElectricTimesVH(this);\n        viewDataBinding.setVariable(BR.times, electricTimesVH);\n        BleUtils.send(new byte[]{0x01, 0x04, 0x00, 0x07, 0x00, 0x04});\n    }\n\n    @Override\n    protected void onDataReceived(byte[] datas) {\n        if (datas[0] == 0x01 && datas[1] == 0x04 && datas[2] == 0x08) {\n            electricTimesVH.isRefresh.set(false);\n            electricTimesVH.mainTimes.set((long) ByteUtils.bytesToInt2(datas, 3));\n            electricTimesVH.secondTimes.set((long) ByteUtils.bytesToInt2(datas, 7));\n        }\n    }\n\n}", "class_id": 0, "repo": "wangfeixixi/TestBrake", "file": "app/src/main/java/cn/com/reformer/brake/ElectricTimeActivity.java", "last_update_at": "2018-02-06T10:20:29+00:00", "question_id": "9f27eaf38684361a0bfa6e77909dd1cd92c9e4a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ElectricTimeActivity extends BaseActivity {\n    private ElectricTimesVH electricTimesVH;\n    @Override\n    protected void initViews() {\n        ViewDataBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_electric_time);\n        electricTimesVH = new ElectricTimesVH(this);\n        viewDataBinding.setVariable(BR.times, electricTimesVH);\n        BleUtils.send(new byte[]{0x01, 0x04, 0x00, 0x07, 0x00, 0x04});\n    }\n    @Override\n    protected void onDataReceived(byte[] datas) {\n        if (datas[0] == 0x01 && datas[1] == 0x04 && datas[2] == 0x08) {\n            electricTimesVH.isRefresh.set(false);\n            electricTimesVH.mainTimes.set((long) ByteUtils.bytesToInt2(datas, 3));\n            electricTimesVH.secondTimes.set((long) ByteUtils.bytesToInt2(datas, 7));\n        }\n    }\n"]], "pred": {"ppl": 2.283446788787842, "ppl_lower": 2.8712339401245117, "ppl/lowercase_ppl": -1.2774127412313756, "ppl/zlib": 0.0023258761996952488, "Min_5.0% Prob": 7.320440732515776, "Min_10.0% Prob": 5.77131148620888, "Min_20.0% Prob": 3.695940234444358, "Min_30.0% Prob": 2.6262639322912835, "Min_40.0% Prob": 2.027657781903808, "Min_50.0% Prob": 1.6409497143660519, "Min_60.0% Prob": 1.380446641672268}}
{"hexsha": "ede009c5513ac7499544d9490a7fc8e56ae68ed2", "ext": "java", "lang": "Java", "content": "public class DynamicRangeTestApp extends PApplet {\n\n\tDynamicRangeTimeRangeSlider timeRangeSlider;\n\n\tpublic void setup() {\n\t\tsize(800, 600);\n\t\tsmooth();\n\n\t\ttimeRangeSlider = new DynamicRangeTimeRangeSlider(this, 100, 200, 300, 16,\n\t\t\t\tnew DateTime(2011, 04, 11, 10, 0, 0), new DateTime(2011, 04, 11, 22, 0, 0), 60 * 10);\n\t\ttimeRangeSlider.setTickIntervalSeconds(60 * 10);\n\t}\n\n\tpublic void draw() {\n\t\tbackground(240);\n\n\t\ttimeRangeSlider.draw();\n\t}\n\n\tpublic void keyPressed() {\n\t\tif (key == 'i') {\n\t\t\ttimeRangeSlider.increaseRange();\n\t\t}\n\t\t\n\t\ttimeRangeSlider.onKeyPressed(key, keyCode);\n\t}\n\n\t// Gets called each time the time ranger slider has changed, both by user interaction as well as by animation\n\tpublic void timeUpdated(DateTime startDateTime, DateTime endDateTime) {\n\t\tprintln(\"timeUpdated to \" + startDateTime.toString(\"hh:mm\") + \" - \" + endDateTime.toString(\"hh:mm\"));\n\t}\n\n\tpublic void mouseMoved() {\n\t\ttimeRangeSlider.onMoved(mouseX, mouseY);\n\t}\n\n\tpublic void mouseDragged() {\n\t\ttimeRangeSlider.onDragged(mouseX, mouseY, pmouseX, pmouseY);\n\t}\n\n}", "class_id": 0, "repo": "tillnagel/timerangeslider", "file": "src/de/fhpotsdam/DynamicRangeTestApp.java", "last_update_at": "2018-08-18T05:05:25+00:00", "question_id": "ede009c5513ac7499544d9490a7fc8e56ae68ed2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DynamicRangeTestApp extends PApplet {\n\tDynamicRangeTimeRangeSlider timeRangeSlider;\n\tpublic void setup() {\n\t\tsize(800, 600);\n\t\tsmooth();\n\t\ttimeRangeSlider = new DynamicRangeTimeRangeSlider(this, 100, 200, 300, 16,\n\t\t\t\tnew DateTime(2011, 04, 11, 10, 0, 0), new DateTime(2011, 04, 11, 22, 0, 0), 60 * 10);\n\t\ttimeRangeSlider.setTickIntervalSeconds(60 * 10);\n\t}\n\tpublic void draw() {\n\t\tbackground(240);\n\t\ttimeRangeSlider.draw();\n\t}\n\tpublic void keyPressed() {\n\t\tif (key == 'i') {\n\t\t\ttimeRangeSlider.increaseRange();\n\t\t}\n\t\t\n\t\ttimeRangeSlider.onKeyPressed(key, keyCode);\n\t}\n\t// Gets called each time the time ranger slider has changed, both by user interaction as well as by animation\n\tpublic void timeUpdated(DateTime startDateTime, DateTime endDateTime) {\n\t\tprintln(\"timeUpdated to \" + startDateTime.toString(\"hh:mm\") + \" - \" + endDateTime.toString(\"hh:mm\"));\n\t}\n\tpublic void mouseMoved() {\n\t\ttimeRangeSlider.onMoved(mouseX, mouseY);\n\t}\n\tpublic void mouseDragged() {\n\t\ttimeRangeSlider.onDragged(mouseX, mouseY, pmouseX, pmouseY);\n\t}\n"]], "pred": {"ppl": 2.0702600479125977, "ppl_lower": 2.312300443649292, "ppl/lowercase_ppl": -1.1519480306349041, "ppl/zlib": 0.001571650596971452, "Min_5.0% Prob": 6.198500860305059, "Min_10.0% Prob": 4.751069358416966, "Min_20.0% Prob": 3.152302065775508, "Min_30.0% Prob": 2.3050007313962966, "Min_40.0% Prob": 1.783901798478245, "Min_50.0% Prob": 1.4476990642564556, "Min_60.0% Prob": 1.2135493318392}}
{"hexsha": "b0efe8049b2c9de6ace5fa8ef9ad38714c83ddbf", "ext": "java", "lang": "Java", "content": "@Component(immediate = true)\n@Service\npublic class TeTunnelPceManager implements TeTunnelPceService {\n\n    private static final Logger log = getLogger(TeTunnelPceManager.class);\n\n    private List<TeTunnelPce> pces = Lists.newLinkedList();\n\n    @Activate\n    protected void activate() {\n        pces.add(0, new DefaultTeTunnelPce());\n        log.info(\"Started\");\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        log.info(\"Stopped\");\n    }\n\n    @Override\n    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel) {\n        TeTunnelPce pce = null;\n        synchronized (pces) {\n            for (TeTunnelPce p : pces) {\n                if (p.isSuitable(teTunnel)) {\n                    pce = p;\n                }\n            }\n        }\n        if (pce != null) {\n            return pce.computePaths(teTunnel);\n        } else {\n            return ImmutableList.of();\n        }\n    }\n\n    @Override\n    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel,\n                                                           TeTunnelPce pce) {\n        return pce == null ? null : pce.computePaths(teTunnel);\n    }\n\n    @Override\n    public void registerPce(TeTunnelPce pce) {\n        synchronized (pces) {\n            int index = 0;\n            while (pces.get(index).getPriority() > pce.getPriority()) {\n                index++;\n            }\n\n            pces.add(index, pce);\n        }\n    }\n}", "class_id": 0, "repo": "ariscahyadi/onos-1.14-with-indopronos-app", "file": "apps/actn-mdsc/tetunnel-pce/src/main/java/org/onosproject/actn/mdsc/pce/impl/TeTunnelPceManager.java", "last_update_at": "2018-10-04T06:46:22+00:00", "question_id": "b0efe8049b2c9de6ace5fa8ef9ad38714c83ddbf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component(immediate = true)\n@Service\npublic class TeTunnelPceManager implements TeTunnelPceService {\n    private static final Logger log = getLogger(TeTunnelPceManager.class);\n    private List<TeTunnelPce> pces = Lists.newLinkedList();\n    @Activate\n    protected void activate() {\n        pces.add(0, new DefaultTeTunnelPce());\n        log.info(\"Started\");\n    }\n    @Deactivate\n    protected void deactivate() {\n        log.info(\"Stopped\");\n    }\n    @Override\n    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel) {\n        TeTunnelPce pce = null;\n        synchronized (pces) {\n            for (TeTunnelPce p : pces) {\n                if (p.isSuitable(teTunnel)) {\n                    pce = p;\n                }\n            }\n        }\n        if (pce != null) {\n            return pce.computePaths(teTunnel);\n        } else {\n            return ImmutableList.of();\n        }\n    }\n    @Override\n    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel,\n                                                           TeTunnelPce pce) {\n        return pce == null ? null : pce.computePaths(teTunnel);\n    }\n    @Override\n    public void registerPce(TeTunnelPce pce) {\n        synchronized (pces) {\n            int index = 0;\n            while (pces.get(index).getPriority() > pce.getPriority()) {\n                index++;\n            }\n            pces.add(index, pce);\n        }\n    }\n"]], "pred": {"ppl": 1.6926002502441406, "ppl_lower": 2.1895859241485596, "ppl/lowercase_ppl": -1.4891946574468902, "ppl/zlib": 0.0010546411945888943, "Min_5.0% Prob": 5.419505726207387, "Min_10.0% Prob": 3.839622836221348, "Min_20.0% Prob": 2.4549907953901724, "Min_30.0% Prob": 1.7291723403966788, "Min_40.0% Prob": 1.315264890880578, "Min_50.0% Prob": 1.050876871897624, "Min_60.0% Prob": 0.8772570360082922}}
{"hexsha": "b0d981efcf3f9e5edd02c27390100d5d39cbaa71", "ext": "java", "lang": "Java", "content": "public class Messenger {\n//\tIDiscordClient client;\n\t\n\t\n\t\n\tpublic Messenger(IDiscordClient c) {\n//\t\tthis.client = c;\n\t}\n//\tpublic Messenger() {\n//\t\t\n//\t}\n\t\n\tpublic Messenger() {\n\t\t\n\t}\n\t\n\t//sends a message\n\tpublic void sendMessage(IChannel channel, String message) {\n\t\t\n\n\t\tLogger.logBot(channel, message);\n\t\t\n        // this is so it can repeat sending messages when rate limited\n        RequestBuffer.request(() -> {\n            try{\n                channel.sendMessage(message);\n            } catch (DiscordException e){\n                System.err.println(\"Message could not be sent with error: \");\n                e.printStackTrace();\n            }\n\t\t\treturn ;\n        });\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tpublic IMessage sendMessageAndGet(IChannel c, String str) {\n\t\tLogger.logBot(c, str);\n        // this is so it can repeat sending messages when rate limited\n        return RequestBuffer.request(() -> {\n            try{\n                return c.sendMessage(str);\n            } catch (DiscordException e){\n                System.err.println(\"Message could not be sent with error: \");\n                e.printStackTrace();\n                return null;\n            }\n        }).get();\n\t}\n\t\n\t\n\t\n\t\n}", "class_id": 0, "repo": "Mee42/carson-bot", "file": "src/main/java/com/carson/classes/Messenger.java", "last_update_at": "2018-06-10T22:42:09+00:00", "question_id": "b0d981efcf3f9e5edd02c27390100d5d39cbaa71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Messenger {\n//\tIDiscordClient client;\n\t\n\t\n\t\n\tpublic Messenger(IDiscordClient c) {\n//\t\tthis.client = c;\n\t}\n//\tpublic Messenger() {\n//\t\t\n//\t}\n\t\n\tpublic Messenger() {\n\t\t\n\t}\n\t\n\t//sends a message\n\tpublic void sendMessage(IChannel channel, String message) {\n\t\t\n\t\tLogger.logBot(channel, message);\n\t\t\n        // this is so it can repeat sending messages when rate limited\n        RequestBuffer.request(() -> {\n            try{\n                channel.sendMessage(message);\n            } catch (DiscordException e){\n                System.err.println(\"Message could not be sent with error: \");\n                e.printStackTrace();\n            }\n\t\t\treturn ;\n        });\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tpublic IMessage sendMessageAndGet(IChannel c, String str) {\n\t\tLogger.logBot(c, str);\n        // this is so it can repeat sending messages when rate limited\n        return RequestBuffer.request(() -> {\n            try{\n                return c.sendMessage(str);\n            } catch (DiscordException e){\n                System.err.println(\"Message could not be sent with error: \");\n                e.printStackTrace();\n                return null;\n            }\n        }).get();\n\t}\n\t\n\t\n\t\n\t\n"]], "pred": {"ppl": 2.4119277000427246, "ppl_lower": 2.789334297180176, "ppl/lowercase_ppl": -1.165120760643322, "ppl/zlib": 0.00224598546762503, "Min_5.0% Prob": 6.923049253575942, "Min_10.0% Prob": 5.509115106919232, "Min_20.0% Prob": 3.723598170971525, "Min_30.0% Prob": 2.7389664145616384, "Min_40.0% Prob": 2.132225216507054, "Min_50.0% Prob": 1.736318631204723, "Min_60.0% Prob": 1.4650977988225908}}
{"hexsha": "63ffa144487f89d12fdecd5130e960448060408c", "ext": "java", "lang": "Java", "content": "public class Calculator {\n\t\n\t\n\t\n\t\n\tpublic static int add(int ... x) { // vararg syntax\n\t\tint sum=0;\n\t\tfor(int i=0;i<x.length;i++) {\n\t\t\tsum=sum+x[i];\n\t\t}\n\t\treturn sum; \n\t\t\n\t}\n\t\n\npublic static float add(float x, float y) {\n\treturn x+y;\n}\n\n\n\npublic static float add(float x, int y) {\n\n\treturn x+y;\n}\npublic static float add(int x, float y) {\n\treturn x+y;\n}\n\npublic float multiply(float x,float y) {\n\treturn x*y;\n}\n}", "class_id": 0, "repo": "muhammadmuzzammil1998/CollegeStuff", "file": "MCA/Java/Sir's code/Calculator.java", "last_update_at": "2018-10-02T18:54:22+00:00", "question_id": "63ffa144487f89d12fdecd5130e960448060408c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Calculator {\n\t\n\t\n\t\n\t\n\tpublic static int add(int ... x) { // vararg syntax\n\t\tint sum=0;\n\t\tfor(int i=0;i<x.length;i++) {\n\t\t\tsum=sum+x[i];\n\t\t}\n\t\treturn sum; \n\t\t\n\t}\n\t\npublic static float add(float x, float y) {\n\treturn x+y;\n}\npublic static float add(float x, int y) {\n\treturn x+y;\n}\npublic static float add(int x, float y) {\n\treturn x+y;\n}\npublic float multiply(float x,float y) {\n\treturn x*y;\n}\n"]], "pred": {"ppl": 2.124340772628784, "ppl_lower": 2.175612211227417, "ppl/lowercase_ppl": -1.0316520098526067, "ppl/zlib": 0.0038441914775585845, "Min_5.0% Prob": 5.720283296373156, "Min_10.0% Prob": 4.582594633102417, "Min_20.0% Prob": 3.1379551821284823, "Min_30.0% Prob": 2.338766876194212, "Min_40.0% Prob": 1.8283867438634236, "Min_50.0% Prob": 1.4752830339002085, "Min_60.0% Prob": 1.2448661594967776}}
{"hexsha": "311434067375bc2f1fdcff4a7dce4ef006ffe3bc", "ext": "java", "lang": "Java", "content": "public class IfStatement extends Statement {\n\n\tprivate final Expression condition;\n\tprivate final Statement trueStatement;\n\tprivate final Statement falseStatement;\n\n\tpublic IfStatement(int start, int end, Expression condition, Statement trueStatement, Statement falseStatement) {\n\t\tsuper(start, end);\n\n\t\tassert condition != null && trueStatement != null;\n\t\tthis.condition = condition;\n\t\tthis.trueStatement = trueStatement;\n\t\tthis.falseStatement = falseStatement;\n\t}\n\n\tpublic void traverse(ASTVisitor visitor) throws Exception {\n\t\tfinal boolean visit = visitor.visit(this);\n\t\tif (visit) {\n\t\t\tcondition.traverse(visitor);\n\t\t\ttrueStatement.traverse(visitor);\n\t\t\tif (falseStatement != null) {\n\t\t\t\tfalseStatement.traverse(visitor);\n\t\t\t}\n\t\t}\n\t\tvisitor.endvisit(this);\n\t}\n\n\tpublic int getKind() {\n\t\treturn ASTNodeKinds.IF_STATEMENT;\n\t}\n\n\tpublic Expression getCondition() {\n\t\treturn condition;\n\t}\n\n\tpublic Statement getFalseStatement() {\n\t\treturn falseStatement;\n\t}\n\n\tpublic Statement getTrueStatement() {\n\t\treturn trueStatement;\n\t}\n\n\t/**\n\t * We don't print anything - we use {@link ASTPrintVisitor} instead\n\t */\n\tpublic final void printNode(CorePrinter output) {\n\t}\n\n\tpublic String toString() {\n\t\treturn ASTPrintVisitor.toXMLString(this);\n\t}\n}", "class_id": 0, "repo": "NisalaNiroshana/developer-studio", "file": "jaggery/org.eclipse.php.core/src/org/eclipse/php/internal/core/compiler/ast/nodes/IfStatement.java", "last_update_at": "2018-10-26T12:52:03+00:00", "question_id": "311434067375bc2f1fdcff4a7dce4ef006ffe3bc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class IfStatement extends Statement {\n\tprivate final Expression condition;\n\tprivate final Statement trueStatement;\n\tprivate final Statement falseStatement;\n\tpublic IfStatement(int start, int end, Expression condition, Statement trueStatement, Statement falseStatement) {\n\t\tsuper(start, end);\n\t\tassert condition != null && trueStatement != null;\n\t\tthis.condition = condition;\n\t\tthis.trueStatement = trueStatement;\n\t\tthis.falseStatement = falseStatement;\n\t}\n\tpublic void traverse(ASTVisitor visitor) throws Exception {\n\t\tfinal boolean visit = visitor.visit(this);\n\t\tif (visit) {\n\t\t\tcondition.traverse(visitor);\n\t\t\ttrueStatement.traverse(visitor);\n\t\t\tif (falseStatement != null) {\n\t\t\t\tfalseStatement.traverse(visitor);\n\t\t\t}\n\t\t}\n\t\tvisitor.endvisit(this);\n\t}\n\tpublic int getKind() {\n\t\treturn ASTNodeKinds.IF_STATEMENT;\n\t}\n\tpublic Expression getCondition() {\n\t\treturn condition;\n\t}\n\tpublic Statement getFalseStatement() {\n\t\treturn falseStatement;\n\t}\n\tpublic Statement getTrueStatement() {\n\t\treturn trueStatement;\n\t}\n\t/**\n\t * We don't print anything - we use {@link ASTPrintVisitor} instead\n\t */\n\tpublic final void printNode(CorePrinter output) {\n\t}\n\tpublic String toString() {\n\t\treturn ASTPrintVisitor.toXMLString(this);\n\t}\n"]], "pred": {"ppl": 1.2790359258651733, "ppl_lower": 1.6428782939910889, "ppl/lowercase_ppl": -2.0172142404271876, "ppl/zlib": 0.0005338538204532216, "Min_5.0% Prob": 3.5290194875315617, "Min_10.0% Prob": 2.177354334256588, "Min_20.0% Prob": 1.2132715751918464, "Min_30.0% Prob": 0.8213544902670332, "Min_40.0% Prob": 0.6146194618847814, "Min_50.0% Prob": 0.4930037280939025, "Min_60.0% Prob": 0.4114271882966042}}
{"hexsha": "b18275f4e892e5e3b1039b05a4408790c98bda11", "ext": "java", "lang": "Java", "content": "public class DefaultResultSet extends AbstractResultSet {\n\n\tprivate final static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(\n\t\tDefaultResultSet.class.getName()\n\t);\n\n\tprivate boolean logContent = true;\n\n\n\tpublic DefaultResultSet(final String[] columnNames, final List<Object[]> rows) {\n\n\t\tlogger.info(()->\n\t\t\t\"DefaultResultSet(), rows.size: [\" + (rows != null? rows.size(): null) +\n\t\t\t\"], logContent: [\" + logContent + \"]\"\n\t\t);\n\n\t\tthis.columnNames = columnNames;\n\n\t\tif (logContent) {\n\t\t\tfor (String columnName: columnNames) {\n\t\t\t\tlogger.info(()-> \"\\tcolumnName: [\" + columnName + \"]\");\n\t\t\t}\n\t\t}\n\n\t\tthis.rows.addAll(rows);\n\n\t\tfor (int i = 0; i < rows.size(); i++) {\n\n\t\t\tfinal Object[] row = rows.get(i);\n\n\t\t\tfinal StringBuilder line = new StringBuilder();\n\n\t\t\tfor (Object item: row) {\n\t\t\t\tif (line.length() > 0)\n\t\t\t\t\tline.append(\", \");\n\t\t\t\tline.append(item);\n\t\t\t}\n\n\t\t\tif (logContent)\n\t\t\t\tlogger.info(\"\\trow[\" + i + \"]: \" + line);\n\t\t}\n\t}\n\n\n\tprivate int position = -1;\n\n\tprivate final String[] columnNames;\n\tprivate final List<Object[]> rows = new ArrayList<>();\n\n\n\t@Override\n\tpublic boolean next() throws SQLException {\n\n\t\tposition++;\n\n\t\tif (position >= rows.size())\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\n\tprivate boolean closed = false;\n\n\t@Override\n\tpublic void close() throws SQLException {\n\t\tclosed = true;\n\t}\n\n\n\t@Override\n\tpublic String getString(final String columnLabel) throws SQLException {\n\n\t\tfinal Object value = getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\n\t\twasNullFlag = (value == null);\n\n\t\treturn (value != null? value.toString(): null);\n\t}\n\n\t// XXX not used by hibernate\n\t@Override\n\tpublic String getString(final int columnIndex) throws SQLException {\n\n\t\tfinal Object value = getCurrentRow()[columnIndex - 1];\n\n\t\twasNullFlag = (value == null);\n\n\t\treturn (value != null? value.toString(): null);\n\t}\n\n\t// XXX not used by hibernate\n\t@Override\n\tpublic Object getObject(final int columnIndex) throws SQLException {\n\t\treturn getCurrentRow()[columnIndex - 1];\n\t}\n\n\n\n\tprotected int getColumnIndexByColumnName(final String columnName) {\n\n\t\tfor (int i = 0; i < columnNames.length; i++) {\n\t\t\tif (isEqual(columnNames[i], columnName))\n\t\t\t\treturn i;\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"cannot find column [\" + columnName + \"]\");\n\t}\n\n\n\tprotected boolean isEqual(final Object item0, final Object item1) {\n\t\tif ((item0 == null) && (item1 == null))\n\t\t\treturn true;\n\n\t\tif ((item0 == null) || (item1 == null))\n\t\t\treturn false;\n\n\t\treturn item0.equals(item1);\n\t}\n\n\n\tprotected Object[] getCurrentRow() {\n\n\t\tif (position < 0)\n\t\t\tthrow new IllegalArgumentException(\"position is < 0: [\" + position + \"]\");\n\n\t\tif (position >= rows.size())\n\t\t\tthrow new IllegalArgumentException(\"position > rows.size: [\" + position + \", \" + rows.size() + \"]\");\n\n\t\treturn rows.get(position);\n\t}\n\n\n\t@Override\n\tpublic short getShort(final String columnLabel) throws SQLException {\n\n\t\tfinal Short result = (Short) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\n\t\twasNullFlag = (result == null);\n\n\t\tif (result == null)\n\t\t\treturn -1;\n\n\t\treturn result.shortValue();\n\t}\n\n\t@Override\n\tpublic int getInt(final String columnLabel) throws SQLException {\n\n\t\tfinal Integer result = (Integer) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\n\t\twasNullFlag = (result == null);\n\n\t\tif (result == null)\n\t\t\treturn -1;\n\n\t\treturn result.intValue();\n\t}\n\n\t// XXX not used by hibernate\n\t@Override\n\tpublic int getInt(final int columnIndex) throws SQLException {\n\n\t\tfinal Integer result = (Integer) getCurrentRow()[columnIndex - 1];\n\n\t\twasNullFlag = (result == null);\n\n\t\tif (result == null)\n\t\t\treturn -1;\n\n\t\treturn result.intValue();\n\t}\n\n\n\t@Override\n\tpublic long getLong(final String columnLabel) throws SQLException {\n\n\t\tfinal Number result = (Number) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\n\t\twasNullFlag = (result == null);\n\n\t\tif (result == null)\n\t\t\treturn -1;\n\n\t\treturn result.longValue();\n\t}\n\n\t// XXX not used by hibernate\n\t@Override\n\tpublic long getLong(final int columnIndex) throws SQLException {\n\n\t\tfinal Number result = (Number) getCurrentRow()[columnIndex - 1];\n\n\t\twasNullFlag = (result == null);\n\n\t\tif (result == null)\n\t\t\treturn -1;\n\n\t\treturn result.longValue();\n\t}\n\n\n\t@Override\n\tpublic ResultSetMetaData getMetaData() throws SQLException {\n\t\treturn new DefaultResultSetMetaData(\n\t\t\tcolumnNames\n\t\t);\n\t}\n\n\t\n\tprivate boolean wasNullFlag = false;\n\n\t// XXX not used by hibernate\n\t@Override\n\tpublic boolean wasNull() throws SQLException {\n\t\treturn wasNullFlag;\n\t}\n\n}", "class_id": 0, "repo": "AntonYudin/cassandra-hibernate-orm-dialect", "file": "driver/src/main/java/com/antonyudin/cassandra/driver/DefaultResultSet.java", "last_update_at": "2018-10-27T23:37:55+00:00", "question_id": "b18275f4e892e5e3b1039b05a4408790c98bda11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultResultSet extends AbstractResultSet {\n\tprivate final static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(\n\t\tDefaultResultSet.class.getName()\n\t);\n\tprivate boolean logContent = true;\n\tpublic DefaultResultSet(final String[] columnNames, final List<Object[]> rows) {\n\t\tlogger.info(()->\n\t\t\t\"DefaultResultSet(), rows.size: [\" + (rows != null? rows.size(): null) +\n\t\t\t\"], logContent: [\" + logContent + \"]\"\n\t\t);\n\t\tthis.columnNames = columnNames;\n\t\tif (logContent) {\n\t\t\tfor (String columnName: columnNames) {\n\t\t\t\tlogger.info(()-> \"\\tcolumnName: [\" + columnName + \"]\");\n\t\t\t}\n\t\t}\n\t\tthis.rows.addAll(rows);\n\t\tfor (int i = 0; i < rows.size(); i++) {\n\t\t\tfinal Object[] row = rows.get(i);\n\t\t\tfinal StringBuilder line = new StringBuilder();\n\t\t\tfor (Object item: row) {\n\t\t\t\tif (line.length() > 0)\n\t\t\t\t\tline.append(\", \");\n\t\t\t\tline.append(item);\n\t\t\t}\n\t\t\tif (logContent)\n\t\t\t\tlogger.info(\"\\trow[\" + i + \"]: \" + line);\n\t\t}\n\t}\n\tprivate int position = -1;\n\tprivate final String[] columnNames;\n\tprivate final List<Object[]> rows = new ArrayList<>();\n\t@Override\n\tpublic boolean next() throws SQLException {\n\t\tposition++;\n\t\tif (position >= rows.size())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tprivate boolean closed = false;\n\t@Override\n\tpublic void close() throws SQLException {\n\t\tclosed = true;\n\t}\n\t@Override\n\tpublic String getString(final String columnLabel) throws SQLException {\n\t\tfinal Object value = getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\t\twasNullFlag = (value == null);\n\t\treturn (value != null? value.toString(): null);\n\t}\n\t// XXX not used by hibernate\n\t@Override\n\tpublic String getString(final int columnIndex) throws SQLException {\n\t\tfinal Object value = getCurrentRow()[columnIndex - 1];\n\t\twasNullFlag = (value == null);\n\t\treturn (value != null? value.toString(): null);\n\t}\n\t// XXX not used by hibernate\n\t@Override\n\tpublic Object getObject(final int columnIndex) throws SQLException {\n\t\treturn getCurrentRow()[columnIndex - 1];\n\t}\n\tprotected int getColumnIndexByColumnName(final String columnName) {\n\t\tfor (int i = 0; i < columnNames.length; i++) {\n\t\t\tif (isEqual(columnNames[i], columnName))\n\t\t\t\treturn i;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"cannot find column [\" + columnName + \"]\");\n\t}\n\tprotected boolean isEqual(final Object item0, final Object item1) {\n\t\tif ((item0 == null) && (item1 == null))\n\t\t\treturn true;\n\t\tif ((item0 == null) || (item1 == null))\n\t\t\treturn false;\n\t\treturn item0.equals(item1);\n\t}\n\tprotected Object[] getCurrentRow() {\n\t\tif (position < 0)\n\t\t\tthrow new IllegalArgumentException(\"position is < 0: [\" + position + \"]\");\n\t\tif (position >= rows.size())\n\t\t\tthrow new IllegalArgumentException(\"position > rows.size: [\" + position + \", \" + rows.size() + \"]\");\n\t\treturn rows.get(position);\n\t}\n\t@Override\n\tpublic short getShort(final String columnLabel) throws SQLException {\n\t\tfinal Short result = (Short) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\t\twasNullFlag = (result == null);\n\t\tif (result == null)\n\t\t\treturn -1;\n\t\treturn result.shortValue();\n\t}\n\t@Override\n\tpublic int getInt(final String columnLabel) throws SQLException {\n\t\tfinal Integer result = (Integer) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\t\twasNullFlag = (result == null);\n\t\tif (result == null)\n\t\t\treturn -1;\n\t\treturn result.intValue();\n\t}\n\t// XXX not used by hibernate\n\t@Override\n\tpublic int getInt(final int columnIndex) throws SQLException {\n\t\tfinal Integer result = (Integer) getCurrentRow()[columnIndex - 1];\n\t\twasNullFlag = (result == null);\n\t\tif (result == null)\n\t\t\treturn -1;\n\t\treturn result.intValue();\n\t}\n\t@Override\n\tpublic long getLong(final String columnLabel) throws SQLException {\n\t\tfinal Number result = (Number) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];\n\t\twasNullFlag = (result == null);\n\t\tif (result == null)\n\t\t\treturn -1;\n\t\treturn result.longValue();\n\t}\n\t// XXX not used by hibernate\n\t@Override\n\tpublic long getLong(final int columnIndex) throws SQLException {\n\t\tfinal Number result = (Number) getCurrentRow()[columnIndex - 1];\n\t\twasNullFlag = (result == null);\n\t\tif (result == null)\n\t\t\treturn -1;\n\t\treturn result.longValue();\n\t}\n\t@Override\n\tpublic ResultSetMetaData getMetaData() throws SQLException {\n\t\treturn new DefaultResultSetMetaData(\n\t\t\tcolumnNames\n\t\t);\n\t}\n\t\n\tprivate boolean wasNullFlag = false;\n\t// XXX not used by hibernate\n\t@Override\n\tpublic boolean wasNull() throws SQLException {\n\t\treturn wasNullFlag;\n\t}\n"]], "pred": {"ppl": 1.6017028093338013, "ppl_lower": 1.6891640424728394, "ppl/lowercase_ppl": -1.1128637793540237, "ppl/zlib": 0.0004255350669924188, "Min_5.0% Prob": 5.1310075311099785, "Min_10.0% Prob": 3.6265463443363415, "Min_20.0% Prob": 2.2036685084595398, "Min_30.0% Prob": 1.544476396507687, "Min_40.0% Prob": 1.1714110207860073, "Min_50.0% Prob": 0.941142224712177, "Min_60.0% Prob": 0.7855295956584505}}
{"hexsha": "c8ae3cf188459210d699c76a648243cf46944212", "ext": "java", "lang": "Java", "content": "class UALocationProvider {\n\n    @Nullable\n    private LocationAdapter availableAdapter;\n    private boolean isConnected = false;\n\n    private final List<LocationAdapter> adapters = new ArrayList<>();\n    private final Context context;\n    private final Intent locationUpdateIntent;\n\n    /**\n     * UALocationProvider constructor.\n     *\n     * @param context The application context.\n     * @param locationUpdateIntent The update intent to send for location responses.\n     */\n    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent) {\n        this.context = context;\n        this.locationUpdateIntent = locationUpdateIntent;\n\n        // This is to prevent a log message saying Google Play Services is unavailable on amazon devices.\n        if (PlayServicesUtils.isGooglePlayStoreAvailable(context) && PlayServicesUtils.isFusedLocationDependencyAvailable()) {\n            adapters.add(new FusedLocationAdapter(context));\n        }\n\n        adapters.add(new StandardLocationAdapter());\n    }\n\n    @VisibleForTesting\n    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent, LocationAdapter... adapters) {\n        this.context = context;\n        this.locationUpdateIntent = locationUpdateIntent;\n        this.adapters.addAll(Arrays.asList(adapters));\n    }\n\n    /**\n     * Cancels all location requests for the connected adapter's pending intent.\n     */\n    @WorkerThread\n    void cancelRequests() {\n        Logger.verbose(\"UALocationProvider - Canceling location requests.\");\n        connect();\n\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n            return;\n        }\n\n        try {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);\n            if (pendingIntent != null) {\n                availableAdapter.cancelLocationUpdates(context, pendingIntent);\n            }\n        } catch (Exception ex) {\n            Logger.error(\"Unable to cancel location updates: \" + ex.getMessage());\n        }\n    }\n\n    /**\n     * Requests location updates.\n     *\n     * @param options The request options.\n     * @throws IllegalStateException if the provider is not connected.\n     */\n    @WorkerThread\n    void requestLocationUpdates(@NonNull LocationRequestOptions options) {\n        connect();\n\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n            return;\n        }\n\n        Logger.verbose(\"UALocationProvider - Requesting location updates: \" + options);\n        try {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            availableAdapter.requestLocationUpdates(context, options, pendingIntent);\n        } catch (Exception ex) {\n            Logger.error(\"Unable to request location updates: \" + ex.getMessage());\n        }\n    }\n\n    /**\n     * Requests a single location update.\n     *\n     * @param options The request options.\n     * @return A pending location result.\n     */\n    @WorkerThread\n    Cancelable requestSingleLocation(@NonNull LocationRequestOptions options, ResultCallback<Location> resultCallback) {\n        connect();\n\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n        }\n\n        Logger.verbose(\"UALocationProvider - Requesting single location update: \" + options);\n\n        try {\n            return availableAdapter.requestSingleLocation(context, options, resultCallback);\n        } catch (Exception ex) {\n            Logger.error(\"Unable to request location: \" + ex.getMessage());\n        }\n\n        return null;\n    }\n\n    /**\n     * Connects to the provider.\n     */\n    @WorkerThread\n    private void connect() {\n        if (isConnected) {\n            return;\n        }\n\n        for (LocationAdapter adapter : adapters) {\n            Logger.verbose(\"UALocationProvider - Attempting to connect to location adapter: \" + adapter);\n\n            if (adapter.isAvailable(context)) {\n\n                if (availableAdapter == null) {\n                    Logger.verbose(\"UALocationProvider - Using adapter: \" + adapter);\n                    availableAdapter = adapter;\n                }\n\n                /*\n                 * Need to cancel requests on all providers regardless of the current\n                 * connected provider because pending intents persist between app starts\n                 * and there is no way to determine what provider was used previously.\n                 */\n                try {\n                    PendingIntent pendingIntent = PendingIntent.getService(context, adapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);\n                    if (pendingIntent != null) {\n                        adapter.cancelLocationUpdates(context, pendingIntent);\n                    }\n                } catch (Exception ex) {\n                    Logger.error(\"Unable to cancel location updates: \" + ex.getMessage());\n                }\n            } else {\n                Logger.verbose(\"UALocationProvider - Adapter unavailable: \" + adapter);\n            }\n        }\n\n        isConnected = true;\n    }\n\n\n    /**\n     * Called when a system location provider availability changes.\n     *\n     * @param options Current location request options.\n     */\n    @WorkerThread\n    void onSystemLocationProvidersChanged(@NonNull LocationRequestOptions options) {\n        Logger.verbose(\"UALocationProvider - Available location providers changed.\");\n\n        connect();\n\n        if (availableAdapter != null) {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            availableAdapter.onSystemLocationProvidersChanged(context, options, pendingIntent);\n        }\n    }\n\n    /**\n     * Checks if updates are currently being requested or not.\n     *\n     * @return {@code true} if updates are being requested, otherwise {@code false}.\n     */\n    @WorkerThread\n    boolean areUpdatesRequested() {\n        connect();\n\n        if (availableAdapter == null) {\n            return false;\n        }\n\n        return getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE) != null;\n    }\n}", "class_id": 0, "repo": "shobhitraaj/android-library", "file": "urbanairship-core/src/main/java/com/urbanairship/location/UALocationProvider.java", "last_update_at": "2018-11-16T07:49:46+00:00", "question_id": "c8ae3cf188459210d699c76a648243cf46944212", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class UALocationProvider {\n    @Nullable\n    private LocationAdapter availableAdapter;\n    private boolean isConnected = false;\n    private final List<LocationAdapter> adapters = new ArrayList<>();\n    private final Context context;\n    private final Intent locationUpdateIntent;\n    /**\n     * UALocationProvider constructor.\n     *\n     * @param context The application context.\n     * @param locationUpdateIntent The update intent to send for location responses.\n     */\n    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent) {\n        this.context = context;\n        this.locationUpdateIntent = locationUpdateIntent;\n        // This is to prevent a log message saying Google Play Services is unavailable on amazon devices.\n        if (PlayServicesUtils.isGooglePlayStoreAvailable(context) && PlayServicesUtils.isFusedLocationDependencyAvailable()) {\n            adapters.add(new FusedLocationAdapter(context));\n        }\n        adapters.add(new StandardLocationAdapter());\n    }\n    @VisibleForTesting\n    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent, LocationAdapter... adapters) {\n        this.context = context;\n        this.locationUpdateIntent = locationUpdateIntent;\n        this.adapters.addAll(Arrays.asList(adapters));\n    }\n    /**\n     * Cancels all location requests for the connected adapter's pending intent.\n     */\n    @WorkerThread\n    void cancelRequests() {\n        Logger.verbose(\"UALocationProvider - Canceling location requests.\");\n        connect();\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n            return;\n        }\n        try {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);\n            if (pendingIntent != null) {\n                availableAdapter.cancelLocationUpdates(context, pendingIntent);\n            }\n        } catch (Exception ex) {\n            Logger.error(\"Unable to cancel location updates: \" + ex.getMessage());\n        }\n    }\n    /**\n     * Requests location updates.\n     *\n     * @param options The request options.\n     * @throws IllegalStateException if the provider is not connected.\n     */\n    @WorkerThread\n    void requestLocationUpdates(@NonNull LocationRequestOptions options) {\n        connect();\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n            return;\n        }\n        Logger.verbose(\"UALocationProvider - Requesting location updates: \" + options);\n        try {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            availableAdapter.requestLocationUpdates(context, options, pendingIntent);\n        } catch (Exception ex) {\n            Logger.error(\"Unable to request location updates: \" + ex.getMessage());\n        }\n    }\n    /**\n     * Requests a single location update.\n     *\n     * @param options The request options.\n     * @return A pending location result.\n     */\n    @WorkerThread\n    Cancelable requestSingleLocation(@NonNull LocationRequestOptions options, ResultCallback<Location> resultCallback) {\n        connect();\n        if (availableAdapter == null) {\n            Logger.debug(\"UALocationProvider - Ignoring request, connected adapter unavailable.\");\n        }\n        Logger.verbose(\"UALocationProvider - Requesting single location update: \" + options);\n        try {\n            return availableAdapter.requestSingleLocation(context, options, resultCallback);\n        } catch (Exception ex) {\n            Logger.error(\"Unable to request location: \" + ex.getMessage());\n        }\n        return null;\n    }\n    /**\n     * Connects to the provider.\n     */\n    @WorkerThread\n    private void connect() {\n        if (isConnected) {\n            return;\n        }\n        for (LocationAdapter adapter : adapters) {\n            Logger.verbose(\"UALocationProvider - Attempting to connect to location adapter: \" + adapter);\n            if (adapter.isAvailable(context)) {\n                if (availableAdapter == null) {\n                    Logger.verbose(\"UALocationProvider - Using adapter: \" + adapter);\n                    availableAdapter = adapter;\n                }\n                /*\n                 * Need to cancel requests on all providers regardless of the current\n                 * connected provider because pending intents persist between app starts\n                 * and there is no way to determine what provider was used previously.\n                 */\n                try {\n                    PendingIntent pendingIntent = PendingIntent.getService(context, adapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);\n                    if (pendingIntent != null) {\n                        adapter.cancelLocationUpdates(context, pendingIntent);\n                    }\n                } catch (Exception ex) {\n                    Logger.error(\"Unable to cancel location updates: \" + ex.getMessage());\n                }\n            } else {\n                Logger.verbose(\"UALocationProvider - Adapter unavailable: \" + adapter);\n            }\n        }\n        isConnected = true;\n    }\n    /**\n     * Called when a system location provider availability changes.\n     *\n     * @param options Current location request options.\n     */\n    @WorkerThread\n    void onSystemLocationProvidersChanged(@NonNull LocationRequestOptions options) {\n        Logger.verbose(\"UALocationProvider - Available location providers changed.\");\n        connect();\n        if (availableAdapter != null) {\n            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            availableAdapter.onSystemLocationProvidersChanged(context, options, pendingIntent);\n        }\n    }\n    /**\n     * Checks if updates are currently being requested or not.\n     *\n     * @return {@code true} if updates are being requested, otherwise {@code false}.\n     */\n    @WorkerThread\n    boolean areUpdatesRequested() {\n        connect();\n        if (availableAdapter == null) {\n            return false;\n        }\n        return getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE) != null;\n    }\n"]], "pred": {"ppl": 1.668975830078125, "ppl_lower": 1.8553977012634277, "ppl/lowercase_ppl": -1.2067294092674186, "ppl/zlib": 0.00036122014308608095, "Min_5.0% Prob": 5.651488032995486, "Min_10.0% Prob": 3.949481551553689, "Min_20.0% Prob": 2.411487885111687, "Min_30.0% Prob": 1.6826014995477558, "Min_40.0% Prob": 1.2747980423435605, "Min_50.0% Prob": 1.0241214719121645, "Min_60.0% Prob": 0.8545367905283635}}
{"hexsha": "6b27097c9d7bc4760cbcca7f100c0c2d72e8f7b1", "ext": "java", "lang": "Java", "content": "public class netclient extends basesocket {\r\n\t\r\n\t//variables required to function that are specific to the client class\r\n\tprivate String ip = \"localhost\";\r\n\t\r\n\tpublic netclient(String ip, int portnumber){\r\n\t\tsuper(portnumber);\r\n\t\tthis.ip=ip;\r\n\t}\r\n\t\r\n\tpublic boolean connect(){\r\n\t\ttry{\r\n\t\t\tmainsocket = new Socket(ip, port);\r\n\t\t\ttry{mainsocket.setSoTimeout(1);}catch(Exception e){}\r\n\t\t\twriter = new PrintStream(mainsocket.getOutputStream());\r\n\t\t\treader = new BufferedReader(new InputStreamReader(mainsocket.getInputStream()));\r\n\t\t}catch(Exception e){disconnect(); return false;}\r\n\t\t\r\n\t\ttry{Thread.sleep(100);}catch(Exception e){}\r\n\t\t\r\n\t\t//return testconnection();\r\n\t\tconnected = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "RetroMelon/IntergalacticIntruders", "file": "src/com/Capslock/Engine/netclient.java", "last_update_at": "2018-04-24T12:02:59+00:00", "question_id": "6b27097c9d7bc4760cbcca7f100c0c2d72e8f7b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class netclient extends basesocket {\r\n\t\r\n\t//variables required to function that are specific to the client class\r\n\tprivate String ip = \"localhost\";\r\n\t\r\n\tpublic netclient(String ip, int portnumber){\r\n\t\tsuper(portnumber);\r\n\t\tthis.ip=ip;\r\n\t}\r\n\t\r\n\tpublic boolean connect(){\r\n\t\ttry{\r\n\t\t\tmainsocket = new Socket(ip, port);\r\n\t\t\ttry{mainsocket.setSoTimeout(1);}catch(Exception e){}\r\n\t\t\twriter = new PrintStream(mainsocket.getOutputStream());\r\n\t\t\treader = new BufferedReader(new InputStreamReader(mainsocket.getInputStream()));\r\n\t\t}catch(Exception e){disconnect(); return false;}\r\n\t\t\r\n\t\ttry{Thread.sleep(100);}catch(Exception e){}\r\n\t\t\r\n\t\t//return testconnection();\r\n\t\tconnected = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n"]], "pred": {"ppl": 2.640622854232788, "ppl_lower": 2.894894599914551, "ppl/lowercase_ppl": -1.0946781469993727, "ppl/zlib": 0.002645816945408276, "Min_5.0% Prob": 8.196286114779385, "Min_10.0% Prob": 6.032430223796679, "Min_20.0% Prob": 4.190666831058005, "Min_30.0% Prob": 3.0562167508261546, "Min_40.0% Prob": 2.39325066247294, "Min_50.0% Prob": 1.9295419133626497, "Min_60.0% Prob": 1.6189014070800372}}
{"hexsha": "af086e1d9ad7e16d326928927d976e32d121b702", "ext": "java", "lang": "Java", "content": "public class MultiThreadedSuperstepOutput<I extends WritableComparable,\n    V extends Writable, E extends Writable> implements\n    SuperstepOutput<I, V, E> {\n  /** Mapper context */\n  private final Mapper<?, ?, ?, ?>.Context context;\n  /** Configuration */\n  private ImmutableClassesGiraphConfiguration<I, V, E, ?> configuration;\n  /** Vertex output format, used to get new vertex writers */\n  private final VertexOutputFormat<I, V, E> vertexOutputFormat;\n  /**\n   * List of returned vertex writers, these can be reused and will all be\n   * closed in the end of the application\n   */\n  private final List<VertexWriter<I, V, E>> availableVertexWriters;\n  /** Vertex writes which were created by this class and are currently used */\n  private final Set<VertexWriter<I, V, E>> occupiedVertexWriters;\n\n  /**\n   * Constructor\n   *\n   * @param conf    Configuration\n   * @param context Mapper context\n   */\n  public MultiThreadedSuperstepOutput(\n      ImmutableClassesGiraphConfiguration<I, V, E, ?> conf,\n      Mapper<?, ?, ?, ?>.Context context) {\n    this.configuration = conf;\n    vertexOutputFormat = conf.createVertexOutputFormat();\n    this.context = context;\n    availableVertexWriters = Lists.newArrayList();\n    occupiedVertexWriters = Sets.newHashSet();\n  }\n\n  @Override\n  public synchronized SimpleVertexWriter<I, V, E> getVertexWriter() {\n    VertexWriter<I, V, E> vertexWriter;\n    if (availableVertexWriters.isEmpty()) {\n      try {\n        vertexWriter = vertexOutputFormat.createVertexWriter(context);\n        vertexWriter.setConf(\n            (ImmutableClassesGiraphConfiguration<I, V, E, Writable>)\n                configuration);\n        vertexWriter.initialize(context);\n      } catch (IOException e) {\n        throw new IllegalStateException(\"getVertexWriter: \" +\n            \"IOException occurred\", e);\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"getVertexWriter: \" +\n            \"InterruptedException occurred\", e);\n      }\n    } else {\n      vertexWriter =\n          availableVertexWriters.remove(availableVertexWriters.size() - 1);\n    }\n    occupiedVertexWriters.add(vertexWriter);\n    return vertexWriter;\n  }\n\n  @Override\n  public synchronized void returnVertexWriter(\n      SimpleVertexWriter<I, V, E> vertexWriter) {\n    VertexWriter<I, V, E> returnedWriter = (VertexWriter<I, V, E>) vertexWriter;\n    if (!occupiedVertexWriters.remove(returnedWriter)) {\n      throw new IllegalStateException(\"returnVertexWriter: \" +\n          \"Returned vertex writer which is not currently occupied!\");\n    }\n    availableVertexWriters.add(returnedWriter);\n  }\n\n  @Override\n  public synchronized void postApplication() throws IOException,\n      InterruptedException {\n    if (!occupiedVertexWriters.isEmpty()) {\n      throw new IllegalStateException(\"postApplication: \" +\n          occupiedVertexWriters.size() +\n          \" vertex writers were not returned!\");\n    }\n    for (VertexWriter<I, V, E> vertexWriter : availableVertexWriters) {\n      vertexWriter.close(context);\n    }\n  }\n}", "class_id": 0, "repo": "rvs/giraph", "file": "giraph-core/src/main/java/org/apache/giraph/io/superstep_output/MultiThreadedSuperstepOutput.java", "last_update_at": "2018-02-28T07:55:05+00:00", "question_id": "af086e1d9ad7e16d326928927d976e32d121b702", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MultiThreadedSuperstepOutput<I extends WritableComparable,\n    V extends Writable, E extends Writable> implements\n    SuperstepOutput<I, V, E> {\n  /** Mapper context */\n  private final Mapper<?, ?, ?, ?>.Context context;\n  /** Configuration */\n  private ImmutableClassesGiraphConfiguration<I, V, E, ?> configuration;\n  /** Vertex output format, used to get new vertex writers */\n  private final VertexOutputFormat<I, V, E> vertexOutputFormat;\n  /**\n   * List of returned vertex writers, these can be reused and will all be\n   * closed in the end of the application\n   */\n  private final List<VertexWriter<I, V, E>> availableVertexWriters;\n  /** Vertex writes which were created by this class and are currently used */\n  private final Set<VertexWriter<I, V, E>> occupiedVertexWriters;\n  /**\n   * Constructor\n   *\n   * @param conf    Configuration\n   * @param context Mapper context\n   */\n  public MultiThreadedSuperstepOutput(\n      ImmutableClassesGiraphConfiguration<I, V, E, ?> conf,\n      Mapper<?, ?, ?, ?>.Context context) {\n    this.configuration = conf;\n    vertexOutputFormat = conf.createVertexOutputFormat();\n    this.context = context;\n    availableVertexWriters = Lists.newArrayList();\n    occupiedVertexWriters = Sets.newHashSet();\n  }\n  @Override\n  public synchronized SimpleVertexWriter<I, V, E> getVertexWriter() {\n    VertexWriter<I, V, E> vertexWriter;\n    if (availableVertexWriters.isEmpty()) {\n      try {\n        vertexWriter = vertexOutputFormat.createVertexWriter(context);\n        vertexWriter.setConf(\n            (ImmutableClassesGiraphConfiguration<I, V, E, Writable>)\n                configuration);\n        vertexWriter.initialize(context);\n      } catch (IOException e) {\n        throw new IllegalStateException(\"getVertexWriter: \" +\n            \"IOException occurred\", e);\n      } catch (InterruptedException e) {\n        throw new IllegalStateException(\"getVertexWriter: \" +\n            \"InterruptedException occurred\", e);\n      }\n    } else {\n      vertexWriter =\n          availableVertexWriters.remove(availableVertexWriters.size() - 1);\n    }\n    occupiedVertexWriters.add(vertexWriter);\n    return vertexWriter;\n  }\n  @Override\n  public synchronized void returnVertexWriter(\n      SimpleVertexWriter<I, V, E> vertexWriter) {\n    VertexWriter<I, V, E> returnedWriter = (VertexWriter<I, V, E>) vertexWriter;\n    if (!occupiedVertexWriters.remove(returnedWriter)) {\n      throw new IllegalStateException(\"returnVertexWriter: \" +\n          \"Returned vertex writer which is not currently occupied!\");\n    }\n    availableVertexWriters.add(returnedWriter);\n  }\n  @Override\n  public synchronized void postApplication() throws IOException,\n      InterruptedException {\n    if (!occupiedVertexWriters.isEmpty()) {\n      throw new IllegalStateException(\"postApplication: \" +\n          occupiedVertexWriters.size() +\n          \" vertex writers were not returned!\");\n    }\n    for (VertexWriter<I, V, E> vertexWriter : availableVertexWriters) {\n      vertexWriter.close(context);\n    }\n  }\n"]], "pred": {"ppl": 1.5893503427505493, "ppl_lower": 1.8312252759933472, "ppl/lowercase_ppl": -1.3057461701881072, "ppl/zlib": 0.0005313364028344691, "Min_5.0% Prob": 5.2306941195232115, "Min_10.0% Prob": 3.6845151458878114, "Min_20.0% Prob": 2.215712184499124, "Min_30.0% Prob": 1.533352525383234, "Min_40.0% Prob": 1.1554243124318784, "Min_50.0% Prob": 0.9271029654892532, "Min_60.0% Prob": 0.7720674541137532}}
{"hexsha": "a4cf1ca82d68aca94e0e56a6c2211296df502f15", "ext": "java", "lang": "Java", "content": "class EquivContext implements StringConstants {\n\n    private static final int TRUNCATE_LENGTH = 15;\n\n    private final String name;\n\n    private final String type;\n\n    private String failedProperty;\n\n    private String a;\n\n    private String b;\n\n    public EquivContext(String name, Class<?> klazz) {\n        this.name = name;\n        this.type = klazz.getSimpleName().replaceAll(\"Immutable\", EMPTY_STRING);\n    }\n\n    public String id() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(type);\n\n        if (name != null) {\n            builder\n                .append(OPEN_BRACKET)\n                .append(QUOTE_MARK)\n                .append(name)\n                .append(QUOTE_MARK)\n                .append(CLOSE_BRACKET);\n        }\n\n        return builder.toString();\n    }\n\n    public boolean hasFailed() {\n        return this.failedProperty != null;\n    }\n\n    public String getFailed() {\n        return \"'\" + this.failedProperty + \"' is different\" + NEW_LINE +\n                        TAB + \"=> \" + QUOTE_MARK + this.a + QUOTE_MARK + NEW_LINE +\n                        TAB + \"=> \" + QUOTE_MARK + this.b + QUOTE_MARK + NEW_LINE;\n    }\n\n    private String truncate(String fullText, String diffText, int diffIndex) {\n        StringBuilder truncated = new StringBuilder();\n\n        //\n        // Adds a portion of the full text at the start of the value\n        // then include '...'\n        //\n        if (diffIndex > 0 && diffIndex <= TRUNCATE_LENGTH) {\n            truncated.append(fullText.substring(0, diffIndex));\n        } else if (diffIndex > TRUNCATE_LENGTH) {\n            truncated\n                .append(fullText.substring(0, TRUNCATE_LENGTH))\n                .append(SPACE).append(ELLIPSE).append(SPACE);\n        }\n\n        if (diffText.length() > 70) {\n            truncated.append(diffText.substring(0, 70)).append(SPACE).append(ELLIPSE);\n        } else {\n            truncated.append(diffText);\n        }\n\n        return truncated.toString();\n    }\n\n    public void setFail(String property, Object a, Object b) {\n        this.failedProperty = property;\n        String aStr = toString(a);\n        String bStr = toString(b);\n\n        int diffPos = StringUtils.indexOfDifference(aStr, bStr);\n        if (diffPos < 0) {\n            this.a = aStr;\n            this.b = bStr;\n            return;\n        }\n\n        String aDiff = aStr.substring(diffPos);\n        String bDiff = bStr.substring(diffPos);\n\n        this.a = truncate(aStr, aDiff, diffPos);\n        this.b = truncate(bStr, bDiff, diffPos);\n    }\n\n    private String toString(Object value) {\n        if (value instanceof Optional) {\n            Optional<?> ov = (Optional<?>) value;\n            Object v = ov.orElse(null);\n            if (v == null) {\n                return EMPTY_STRING;\n            } else {\n                return v.toString();\n            }\n        }\n\n        return value.toString();\n    }\n}", "class_id": 0, "repo": "janstey/syndesis", "file": "app/common/model/src/main/java/io/syndesis/common/model/support/EquivContext.java", "last_update_at": "2018-12-03T22:37:02+00:00", "question_id": "a4cf1ca82d68aca94e0e56a6c2211296df502f15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class EquivContext implements StringConstants {\n    private static final int TRUNCATE_LENGTH = 15;\n    private final String name;\n    private final String type;\n    private String failedProperty;\n    private String a;\n    private String b;\n    public EquivContext(String name, Class<?> klazz) {\n        this.name = name;\n        this.type = klazz.getSimpleName().replaceAll(\"Immutable\", EMPTY_STRING);\n    }\n    public String id() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(type);\n        if (name != null) {\n            builder\n                .append(OPEN_BRACKET)\n                .append(QUOTE_MARK)\n                .append(name)\n                .append(QUOTE_MARK)\n                .append(CLOSE_BRACKET);\n        }\n        return builder.toString();\n    }\n    public boolean hasFailed() {\n        return this.failedProperty != null;\n    }\n    public String getFailed() {\n        return \"'\" + this.failedProperty + \"' is different\" + NEW_LINE +\n                        TAB + \"=> \" + QUOTE_MARK + this.a + QUOTE_MARK + NEW_LINE +\n                        TAB + \"=> \" + QUOTE_MARK + this.b + QUOTE_MARK + NEW_LINE;\n    }\n    private String truncate(String fullText, String diffText, int diffIndex) {\n        StringBuilder truncated = new StringBuilder();\n        //\n        // Adds a portion of the full text at the start of the value\n        // then include '...'\n        //\n        if (diffIndex > 0 && diffIndex <= TRUNCATE_LENGTH) {\n            truncated.append(fullText.substring(0, diffIndex));\n        } else if (diffIndex > TRUNCATE_LENGTH) {\n            truncated\n                .append(fullText.substring(0, TRUNCATE_LENGTH))\n                .append(SPACE).append(ELLIPSE).append(SPACE);\n        }\n        if (diffText.length() > 70) {\n            truncated.append(diffText.substring(0, 70)).append(SPACE).append(ELLIPSE);\n        } else {\n            truncated.append(diffText);\n        }\n        return truncated.toString();\n    }\n    public void setFail(String property, Object a, Object b) {\n        this.failedProperty = property;\n        String aStr = toString(a);\n        String bStr = toString(b);\n        int diffPos = StringUtils.indexOfDifference(aStr, bStr);\n        if (diffPos < 0) {\n            this.a = aStr;\n            this.b = bStr;\n            return;\n        }\n        String aDiff = aStr.substring(diffPos);\n        String bDiff = bStr.substring(diffPos);\n        this.a = truncate(aStr, aDiff, diffPos);\n        this.b = truncate(bStr, bDiff, diffPos);\n    }\n    private String toString(Object value) {\n        if (value instanceof Optional) {\n            Optional<?> ov = (Optional<?>) value;\n            Object v = ov.orElse(null);\n            if (v == null) {\n                return EMPTY_STRING;\n            } else {\n                return v.toString();\n            }\n        }\n        return value.toString();\n    }\n"]], "pred": {"ppl": 1.8673015832901, "ppl_lower": 2.170835256576538, "ppl/lowercase_ppl": -1.2411833041169127, "ppl/zlib": 0.0007137078687382643, "Min_5.0% Prob": 6.3880731227786045, "Min_10.0% Prob": 4.671075108439424, "Min_20.0% Prob": 2.903005580222884, "Min_30.0% Prob": 2.0398368990814038, "Min_40.0% Prob": 1.5514456744859184, "Min_50.0% Prob": 1.2475874109275795, "Min_60.0% Prob": 1.0417728808796758}}
{"hexsha": "ce5034d512e499bd2aedc3051e77edee6f55e2fc", "ext": "java", "lang": "Java", "content": "@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath*:spring-context*.xml\")\npublic class FriendCircleMessageServiceImplTest {\n    @Autowired\n    private FriendCircleMessageService friendCircleMessageService;\n\n    @Autowired\n    private FriendCircleMessageMapper friendCircleMessageMapper;\n\n    @Autowired\n    private TimeLineMapper timeLineMapper;\n    @Test\n    public void getFriendMessage(){\n        List<FriendCircleMessage> friendCircleMessages = friendCircleMessageService.getFriendMessageByUid(3L);\n        System.out.println(friendCircleMessages);\n    }\n    @Test\n    public void insertMessage(){\n        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();\n        friendCircleMessage.setContent(\"3333\");\n        friendCircleMessage.setImage(\"1.png\");\n        friendCircleMessage.setUid(9L);\n        friendCircleMessage.setCreated(new Date());\n        System.out.println(friendCircleMessage.getId());\n        friendCircleMessageMapper.insert(friendCircleMessage);\n        System.out.println(friendCircleMessage.getId());\n    }\n\n    @Test\n    public void sendMessage(){\n        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();\n        friendCircleMessage.setContent(\"\u4eca\u5929\u662f\u7f8e\u597d\u7684\u4e00\u5929\");\n        friendCircleMessage.setPicture(\"1.png\");\n        friendCircleMessage.setUid(2L);\n        friendCircleMessage.setCreated(new Date());\n        friendCircleMessageService.sendFriendMessage(friendCircleMessage);\n    }\n    @Test\n    public void delete(){\n        friendCircleMessageService.delete(8L);\n    }\n    @Test\n    public void getOwnMessageByUid(){\n        List<FriendCircleMessage> ownMessage = friendCircleMessageMapper.getOwnMessageByUid(2L);\n        System.out.println(ownMessage);\n    }\n}", "class_id": 0, "repo": "jhgonggg/yba", "file": "yue/yue-ba/yue-ba-admin/src/test/java/FriendCircleMessageServiceImplTest.java", "last_update_at": "2018-12-25T07:01:12+00:00", "question_id": "ce5034d512e499bd2aedc3051e77edee6f55e2fc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath*:spring-context*.xml\")\npublic class FriendCircleMessageServiceImplTest {\n    @Autowired\n    private FriendCircleMessageService friendCircleMessageService;\n    @Autowired\n    private FriendCircleMessageMapper friendCircleMessageMapper;\n    @Autowired\n    private TimeLineMapper timeLineMapper;\n    @Test\n    public void getFriendMessage(){\n        List<FriendCircleMessage> friendCircleMessages = friendCircleMessageService.getFriendMessageByUid(3L);\n        System.out.println(friendCircleMessages);\n    }\n    @Test\n    public void insertMessage(){\n        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();\n        friendCircleMessage.setContent(\"3333\");\n        friendCircleMessage.setImage(\"1.png\");\n        friendCircleMessage.setUid(9L);\n        friendCircleMessage.setCreated(new Date());\n        System.out.println(friendCircleMessage.getId());\n        friendCircleMessageMapper.insert(friendCircleMessage);\n        System.out.println(friendCircleMessage.getId());\n    }\n    @Test\n    public void sendMessage(){\n        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();\n        friendCircleMessage.setContent(\"\u4eca\u5929\u662f\u7f8e\u597d\u7684\u4e00\u5929\");\n        friendCircleMessage.setPicture(\"1.png\");\n        friendCircleMessage.setUid(2L);\n        friendCircleMessage.setCreated(new Date());\n        friendCircleMessageService.sendFriendMessage(friendCircleMessage);\n    }\n    @Test\n    public void delete(){\n        friendCircleMessageService.delete(8L);\n    }\n    @Test\n    public void getOwnMessageByUid(){\n        List<FriendCircleMessage> ownMessage = friendCircleMessageMapper.getOwnMessageByUid(2L);\n        System.out.println(ownMessage);\n    }\n"]], "pred": {"ppl": 1.7055565118789673, "ppl_lower": 1.978786826133728, "ppl/lowercase_ppl": -1.2783196535124859, "ppl/zlib": 0.0011311259690839509, "Min_5.0% Prob": 5.581828494866689, "Min_10.0% Prob": 3.9086783662134286, "Min_20.0% Prob": 2.4681998862295735, "Min_30.0% Prob": 1.740612234185342, "Min_40.0% Prob": 1.3263581960595079, "Min_50.0% Prob": 1.0668698387106463, "Min_60.0% Prob": 0.8908405645392505}}
{"hexsha": "aae9342c99edf59bec717f8d099fa08a424e0c64", "ext": "java", "lang": "Java", "content": "public class LTS extends DirectedSparseMultigraph<GraphNode,GraphEdge>  {\n    private GraphNode initialNode;  // initial node of an LTS\n    private GraphNode sink;\n    private boolean isCounterexampleLTS;\n    STDOut outputWriter;\n    Map<Integer, GraphNode> specNodeIndex;\n\n    private GraphNode fakeFinalNode;\n    private Set<GraphEdge> fakeFinalEdges;\n\n    public LTS(STDOut outputWriter) {\n        super();\n        initialNode = null;\n        sink = null;\n        isCounterexampleLTS = false;\n        this.outputWriter = outputWriter;\n        specNodeIndex = null;\n    }\n\n/*    public LTS(DirectedSparseMultigraph<GraphNode, GraphEdge> graph, GraphNode initialNode) {\n        super();\n        this.initialNode = initialNode;\n        sink = null;\n        isCounterexampleLTS = false;\n    }*/\n\n    public STDOut getOutputWriter() {\n        return outputWriter;\n    }\n\n    public GraphNode getInitialNode() {\n        return initialNode;\n    }\n\n    public void setInitialNode(GraphNode node) {\n        this.initialNode = node;\n    }\n\n    private boolean hasSink() {\n        return sink != null;\n    }\n\n    public void setSink(GraphNode node) {\n        sink = node;\n    }\n\n    public GraphNode getSink() {\n        return sink;\n    }\n\n    public boolean isCounterexampleLTS() {\n        return isCounterexampleLTS;\n    }\n\n    public void setAsCounterexampleLTS() {\n        isCounterexampleLTS = true;\n    }\n\n    @Override\n    public Collection<GraphEdge> findEdgeSet(GraphNode n1, GraphNode n2) {\n        return super.findEdgeSet(n1, n2);\n    }\n\n    /**\n     *\n     * @return a collection with all the vertices but without the sink\n     */\n    public Collection<GraphNode> getVerticesWOSink(){\n        Collection<GraphNode> vertices = new HashSet<>();\n        vertices.addAll(super.getVertices());\n        vertices.remove(sink);\n        return vertices;\n    }\n\n    /**\n     * creates and return the sink\n     */\n    private GraphNode createSink() {\n        // the id of the sink graph is the id of the vertex with the highest id +1\n        // that is equivalent to the current size of the graph\n        //System.out.println(\"Creating sink\");\n        // sink = new GraphNode(super.getVertexCount());  // OLD VERSION, after script\n        // modification did not work anymore\n        sink = new GraphNode(-1); // sink is node with -1\n        super.addVertex(sink);   // TODO: check if this is necessary!\n        outputWriter.printComplete(\"Sink is: \"+ sink.toString(), true, true);\n        return sink;\n    }\n\n    @Override\n    public boolean addEdge(GraphEdge edge, GraphNode source, GraphNode dest) {\n       return super.addEdge(edge, source, dest, EdgeType.DIRECTED);\n        //Pair<GraphNode> pair = new Pair<>(source, dest);\n        //return super.addEdge(edge, pair, EdgeType.DIRECTED);\n        //return super.addEdge(edge, source, dest);\n    }\n\n    /**\n     * Add a correct transition to the Counterexample LTS (always out transitions)\n     * @param sourceNode\n     * @param edge\n     */\n    public void addCorrectTransition(GraphNode sourceNode, GraphEdge edge){\n        //System.out.println(\"Adding a correct transition\");\n        if (!hasSink()) {\n            //System.out.println(\"Lts does not have the sink, adding it now\");\n            createSink(); // create the sink node if not created yet\n        }\n        edge.setAsCorrect();\n        edge.setNodes(sourceNode, sink);\n        addEdge(edge, sourceNode, sink);\n    }\n\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Correct (green) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutCorrectTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isCorrect())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Incorrect (red) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutIncorrectTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isIncorrect())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Neutral (black) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutNeutralTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isNeutral())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all correct,\n     * false otherwise\n     */\n    public boolean areOutTransCorrect(GraphNode node) {\n        return (!getOutCorrectTransitions(node).isEmpty() &&\n                getOutIncorrectTransitions(node).isEmpty() &&\n                getOutNeutralTransitions(node).isEmpty());\n    }\n\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all incorrect,\n     * false otherwise\n     */\n    public boolean areOutTransIncorrect(GraphNode node) {\n        return (getOutCorrectTransitions(node).isEmpty() &&\n                !getOutIncorrectTransitions(node).isEmpty() &&\n                getOutNeutralTransitions(node).isEmpty());\n    }\n\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all neutral,\n     * false otherwise\n     */\n    public boolean areOutTransNeutral(GraphNode node) {\n        return (getOutCorrectTransitions(node).isEmpty() &&\n                getOutIncorrectTransitions(node).isEmpty() &&\n                !getOutNeutralTransitions(node).isEmpty());\n    }\n\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter belong to the\n     * following combinations (where G:correct, R:incorrect, B:neutral): B, B+R, B+G, B+R+G, R+G.\n     * Note that the presence of neutral allow to cover the first 4 combinations.\n     */\n    public boolean areOutTransMixed(GraphNode node) {\n        boolean redEmpty, greenEmpty, blackEmpty;\n\n        greenEmpty = getOutCorrectTransitions(node).isEmpty();\n        redEmpty = getOutIncorrectTransitions(node).isEmpty();\n        blackEmpty = getOutNeutralTransitions(node).isEmpty();\n\n        return !blackEmpty || (!greenEmpty && !redEmpty);\n    }\n\n\n    /**\n     * Add final edges for evaluating deadlock and livelocks\n     * FIXME: missing removal function, add it !\n     */\n    public void addFakeFinalEdges() {\n\n        // create fake final node\n        fakeFinalEdges = new HashSet<>();\n        fakeFinalNode = new GraphNode(-3);\n        this.addVertex(fakeFinalNode);\n\n        for (GraphNode node :  this.getVertices() ) {\n            if (this.getOutEdges(node).isEmpty()) {\n                // throw new NotImplementedException();\n                GraphEdge fakeFinalEdge = new GraphEdge(\"FINALEDGE\");\n                fakeFinalEdges.add(fakeFinalEdge);\n                this.addEdge(fakeFinalEdge, node, fakeFinalNode);\n            }\n        }\n    }\n\n    /**\n     * Shallow copy of an LTS\n     * @param other the LTS to copy\n     * @return the shallow copy\n     */\n    public static LTS copy(LTS other) {\n        LTS res = new LTS(other.getOutputWriter());\n        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?\n\n        for (GraphNode node : other.getVertices()) {\n            res.addVertex(node);\n            res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?\n        }\n        for (GraphEdge edge : other.getEdges()) {\n            GraphNode source = other.getSource(edge);\n            GraphNode dest = other.getDest(edge);\n            res.addEdge(edge, source, dest);\n        }\n\n        res.setInitialNode(other.getInitialNode());\n        if (other.hasSink()) {\n            res.setSink(other.getSink());\n        }\n        return res;\n    }\n\n    /**\n     * Shallow copy of a subset of the LTS\n     * @param other the LTS to copy\n     * @param nodesToCopy nodes representing the subset\n     * @return the shallow copy\n     */\n    public static LTS copySubset(LTS other, Collection nodesToCopy) {\n        LTS res = new LTS(other.getOutputWriter());\n        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?\n\n        for (GraphNode node : other.getVertices()) {\n            if (nodesToCopy.contains(node)) {\n                res.addVertex(node);\n                res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?\n            }\n        }\n        for (GraphEdge edge : other.getEdges()) {\n            GraphNode source = other.getSource(edge);\n            GraphNode dest = other.getDest(edge);\n            if (nodesToCopy.contains(source) && nodesToCopy.contains(dest)) {\n                res.addEdge(edge, source, dest);\n            }\n        }\n\n        res.setInitialNode(other.getInitialNode());\n        if (other.hasSink()) {\n            res.setSink(other.getSink());\n        }\n        return res;\n    }\n\n    @Override\n    public boolean removeEdge(GraphEdge edge) {\n        return super.removeEdge(edge);\n    }\n\n    /**\n     * Remove all the edges containing the action passed as parameter\n     * @param action the String describing the edges to remove\n     */\n    public void removeAllEdges(String action) {\n        /*boolean res = false;\n        for (GraphEdge edge : getEdges()) {\n            if (edge.getAction().equals(action))\n                res = removeEdge(edge);\n        }*/\n        new ArrayList<>(getEdges()).stream()\n                .filter(e -> e.getAction().equals(action))\n                .forEach(this::removeEdge);\n    }\n\n    /**\n     * Remove all the edges between the given set of nodes containing the action passed as parameter\n     * @param action the String describing the edges to remove\n     * @param nodes nodes representing sources and destinations of the edges to remove\n     */\n    public void removeAllEdges(String action, Collection nodes) {\n        /*boolean res = false;\n        for (GraphEdge edge : getEdges()) {\n            GraphNode source = getSource(edge);\n            GraphNode dest = getDest(edge);\n            if (nodes.contains(source) && nodes.contains(dest)) {\n                if (edge.getAction().equals(action))\n                    res = removeEdge(edge);\n            }\n        }*/\n        new ArrayList<>(getEdges()).stream()\n                .filter(e -> (e.getAction().equals(action) && nodes.contains(getSource(e)) && nodes\n                        .contains(getDest(e))))\n                .forEach(this::removeEdge);\n    }\n\n    /**\n     * Load a graph from an aut file\n     * @param baseDir directory\n     * @param testName name of the file to load\n     * @throws Exception // TODO: to implement correctly\n     * @return false if the size of the LTS is less or equal to 1, true otherwise\n     */\n    public boolean autLoaderOLD(String baseDir, String testName)  throws Exception  {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + testName + \".aut\"));\n        // TODO: check that the file is actually an aut file\n        // TODO: add exception in case of missing file\n\n        class GraphEdgeExt  {\n            GraphEdge edge;\n            GraphNode source;\n            GraphNode dest;\n\n            GraphEdgeExt(GraphEdge edge, GraphNode source, GraphNode dest) {\n                this.edge = edge;\n                this.source = source;\n                this.dest = dest;\n            }\n        }\n\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        Map<Integer, GraphNode> specNodeIndex = new HashMap<>();\n        //Map<GraphEdge, Pair> edgePairMap = new Hashtable<>();\n        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\"des\")) {\n                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(\",\")[0].trim());\n            } else {\n\n                String[] data = new String[]{\"\", \"\", \"\"};\n                int firstComma = line.indexOf(\",\");\n                int lastComma = line.lastIndexOf(\",\");\n                data[0] = line.substring(0, firstComma).replaceAll(\"[()]\", \"\");\n                data[1] = line.substring(firstComma + 1, lastComma);\n                data[2] = line.substring(lastComma + 1).replaceAll(\"[()]\", \"\");\n                // label with quotes\n                int firstIndx = line.indexOf(\"\\\"\");\n                if (firstIndx != -1) {\n                    int lastIndx = line.lastIndexOf(\"\\\"\");\n                    data[1] = line.substring(firstIndx + 1, lastIndx);\n                }\n\n                int fromNodeId = Integer.valueOf(data[0].trim());\n                String action = data[1].trim();\n                int toNodeId = Integer.valueOf(data[2].trim());\n\n                // TODO: see if it is possible to avoid \"i\" transitions directly on the script\n                if (!action.equals(\"i\")){ // this allows to avoid the final transitions \"i\"\n                    GraphEdge edge = new GraphEdge(action);\n                    GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                    if (fromNode == null) {\n                        fromNode = new GraphNode(fromNodeId);\n                        specNodeIndex.put(fromNodeId, fromNode);\n                    }\n                    GraphNode toNode = specNodeIndex.get(toNodeId);\n                    if (toNode == null) {\n                        toNode = new GraphNode(toNodeId);\n                        specNodeIndex.put(toNodeId, toNode);\n                    }\n                    edge.setNodes(fromNode, toNode);\n                    //addEdge(edge, fromNode, toNode);\n                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                    listEdges.add(edge);\n\n                    // FIXME: TRY TO AVOID THE NODE INDEX!\n                }\n\n            }\n            if (debugIterations%100000 == 0)\n                outputWriter.printComplete(\"autLoader: read \"+ debugIterations  + \" lines\", false,\n                        false);\n            debugIterations++;\n        }\n        br.close();\n\n        int debug = 0;\n        for (GraphEdge edge : listEdges) {\n            addEdge(edge, edge.source, edge.dest);\n            if (debug%100000 == 0)\n                outputWriter.printComplete(\"autLoader: inserted \"+ debug  + \" lines\", false,\n                        false);\n            debug++;\n        }\n\n        setInitialNode(specNodeIndex.get(specStartNodeId));\n        if (super.vertices.size() <= 1) {\n            outputWriter.printError(\"autLoader: possible ERROR, the loaded lts contains only a \" +\n                    \"node\", true, true);\n            // FIXME: should throw an exception in this case\n            return false;\n        }\n        return true;\n    }\n\n    public boolean autLoader(String baseDir, String testName, Boolean fast, boolean safety) throws\n            Exception  {\n        long startTime = System.currentTimeMillis();\n        List<GraphEdge> edgeList;\n        edgeList = fileReader(baseDir, testName, fast, safety);\n        boolean res = graphLoader(edgeList);\n        outputWriter.printComplete(\"autLoader: loading completed.\", true, false);\n        long endTime = System.currentTimeMillis();\n        outputWriter.printComplete(\"autLoader exec time: \" +\n                (endTime - startTime) + \" ms\\n\", true, false);\n        return res;\n    }\n\n\n    public List<GraphEdge> fileReader (String baseDir, String testName, boolean fast,\n                                       boolean safety)\n            throws Exception  {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + testName + \".aut\"));\n        // TODO: check that the file is actually an aut file\n        // TODO: add exception in case of missing file\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        specNodeIndex = new HashMap<>();\n        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\"des\")) {\n                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(\",\")[0].trim());\n            } else {\n\n                String[] data = new String[]{\"\", \"\", \"\"};\n                int firstComma = line.indexOf(\",\");\n                int lastComma = line.lastIndexOf(\",\");\n                data[0] = line.substring(0, firstComma).replaceAll(\"[()]\", \"\");\n                data[1] = line.substring(firstComma + 1, lastComma);\n                data[2] = line.substring(lastComma + 1).replaceAll(\"[()]\", \"\");\n                // label with quotes\n                int firstIndx = line.indexOf(\"\\\"\");\n                if (firstIndx != -1) {\n                    int lastIndx = line.lastIndexOf(\"\\\"\");\n                    data[1] = line.substring(firstIndx + 1, lastIndx);\n                }\n\n                int fromNodeId = Integer.valueOf(data[0].trim());\n                String action = data[1].trim();\n                int toNodeId = Integer.valueOf(data[2].trim());\n\n                // TODO: see if it is possible to avoid \"i\" transitions directly on the script\n                if (!safety || fast) {\n                    // \"i\" transitions are allowed in liveness mode or\n                    // in fast safety mode \"i\" transition are used only to detect\n                    // final transitions\n                    GraphEdge edge = new GraphEdge(action);\n                    GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                    if (fromNode == null) {\n                        fromNode = new GraphNode(fromNodeId);\n                        specNodeIndex.put(fromNodeId, fromNode);\n                    }\n                    GraphNode toNode = specNodeIndex.get(toNodeId);\n                    if (toNode == null) {\n                        toNode = new GraphNode(toNodeId);\n                        specNodeIndex.put(toNodeId, toNode);\n                    }\n                    edge.setNodes(fromNode, toNode);\n                    //addEdge(edge, fromNode, toNode);\n                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                    listEdges.add(edge);\n\n                    // FIXME: TRY TO AVOID THE NODE INDEX!\n                } else {\n                    // in normal safety mode, \"i\" transition cannot be used\n                    // (performs the i avoidance if normal mode is used)\n                    // this allows to avoid the final transitions \"i\"\n                    if (!action.equals(\"i\") ) {\n                        GraphEdge edge = new GraphEdge(action);\n                        GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                        if (fromNode == null) {\n                            fromNode = new GraphNode(fromNodeId);\n                            specNodeIndex.put(fromNodeId, fromNode);\n                        }\n                        GraphNode toNode = specNodeIndex.get(toNodeId);\n                        if (toNode == null) {\n                            toNode = new GraphNode(toNodeId);\n                            specNodeIndex.put(toNodeId, toNode);\n                        }\n                        edge.setNodes(fromNode, toNode);\n                        //addEdge(edge, fromNode, toNode);\n                        //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                        listEdges.add(edge);\n\n                        // FIXME: TRY TO AVOID THE NODE INDEX!\n                    }\n                }\n\n            }\n            if (debugIterations%100000 == 0)\n                outputWriter.printComplete(\"autLoader: read \"+ debugIterations  + \" lines\", false,\n                        false);\n            debugIterations++;\n        }\n        br.close();\n        setInitialNode(specNodeIndex.get(specStartNodeId));\n\n        outputWriter.printComplete(\"autLoader: read finished after \"+ debugIterations + \" \" +\n                \"iterations.\", true, false);\n\n        return listEdges;\n    }\n\n    public boolean graphLoader(List<GraphEdge> listEdges) {\n\n        int debug = 0;\n        for (GraphEdge edge : listEdges) {\n            addEdge(edge, edge.source, edge.dest);\n            if (debug%100000 == 0)\n                outputWriter.printComplete(\"autLoader: inserted \"+ debug  + \" lines\", false, true);\n            debug++;\n        }\n\n\n        outputWriter.printComplete(\"autLoader: loading finished after \"+ debug + \" \" +\n                \"iterations.\", true, true);\n\n        if (super.vertices.size() <= 1) {\n            outputWriter.printError(\"autLoader: possible ERROR, the loaded lts contains only a \" +\n                    \"node\", true, true);\n            // FIXME: should throw an exception in this case\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * If f option is chosen, it reads the table with the correspondence between states\n     * It extracts data from the table containing the equivalence between states\n     * @param baseDir\n     * @param tableFileName\n     * @throws Exception\n     */\n    public void equivTableLoader(String baseDir, String tableFileName, LTS fullLTS) throws\n            Exception {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + tableFileName\n                + \".prd\"));\n        // TODO: check that the file is actually a table file\n        // TODO: add exception in case of missing file\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        Map<Integer, Integer> cLTStoFullLTScorr = new HashMap<>(); // maps\n        // <nodeInTheCounterexLTS, nodeInTheFullLTS>\n        while ((line = br.readLine()) != null) {\n\n            String[] data = new String[]{\"\", \"\", \"\"};\n            int equalSign = line.indexOf(\"=\");\n            int comma = line.indexOf(\",\");\n            int openBrace = line.indexOf(\"{\");\n            //int closedBrace = line.indexOf(\"}\");\n            data[0] = line.substring(0, equalSign).replaceAll(\"[()]\", \"\");\n            data[1] = line.substring(openBrace + 1, comma);\n            //data[2] = line.substring(comma + 1, closedBrace).replaceAll(\"[()]\", \"\");\n\n            int cLTSState = Integer.valueOf(data[0].trim());\n            int fullState = Integer.valueOf(data[1].trim());\n            //int propState = Integer.valueOf(data[2].trim()); the index of the property is unused\n\n            cLTStoFullLTScorr.put(cLTSState, fullState);\n\n            if (debugIterations % 100000 == 0)\n                outputWriter.printComplete(\"equivTableLoader: read \" + debugIterations +\n                        \" lines\", false, true);\n            debugIterations++;\n        }\n        br.close();\n\n        // Now it loads the data in the Counterexample LTS as equivalences\n        for (Integer index : specNodeIndex.keySet()) {\n            GraphNode node = specNodeIndex.get(index);\n            node.setEquivalentInSpec(fullLTS.specNodeIndex.get(cLTStoFullLTScorr.get(index)));\n        }\n\n        outputWriter.printComplete(\"equivTableLoader: read finished after \" + debugIterations +\n                \" iterations.\", true, true);\n    }\n\n    /**\n     * Write the lts with colors in aut format, using colon to separate action and transition type\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean writeToAut(String baseDir, String fileName) {\n        String resFile = fileName+\"_clr-res.aut\";\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(\n                new FileOutputStream(baseDir + \"/\"+resFile, false), \"utf-8\"))) {\n\n            // writing header\n            writer.write(\"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\",\" +\n                    \" \" + this.getVertices().size()+\")\\n\");\n\n            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n            for (GraphNode node: orderedVertices) {\n                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n                for (GraphNode dest : orderedSuccessors) {\n                    for (GraphEdge edge : this.findEdgeSet(node, dest))\n                        writer.write(\"(\" + node.getId() +\", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                edge.getType() + \", \" + dest.getId() +\")\\n\");\n                }\n            }\n\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Write the lts with colors and neighbourhoods in aut format, using colon to separate action\n     * and transition type (for colors) and colon to separate state id and neighbourhood type (for\n     * neighbourhoods).\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean autDump(String baseDir, String fileName) {\n        String resFile = fileName+\"_res-dump.autx\";\n\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(\n                new FileOutputStream(baseDir + \"/\"+resFile, false), \"utf-8\"))) {\n\n            // writing header\n            writer.write(\"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\",\" +\n                    \" \" + this.getVertices().size()+\")\\n\");\n\n            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n            for (GraphNode node: orderedVertices) {\n                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n                for (GraphNode dest : orderedSuccessors) {\n                    for (GraphEdge edge : this.findEdgeSet(node, dest))\n                        if (node.isFrontier()) {\n                            writer.write(\"(\" + node.getId()+\":N:\"+node.getNeighbourhood()\n                                            .toStringShort()+ \", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                    edge.getType() + \", \" + dest.getId() +\")\\n\");\n                        } else {\n                        writer.write(\"(\" + node.getId()+\", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                edge.getType() + \", \" + dest.getId() +\")\\n\");\n                    }\n                }\n            }\n\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Regression check on given file (only liveness)\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean regressionCheck(String baseDir, String fileName) {\n        String resFile = fileName+\"_clr-res.aut\";\n        String expFile = fileName+\"_clr-exp.aut\";\n        int diffReturnValue = 2;  // 2 means error on diff\n        List<String> commands = Arrays.asList(\"diff\", resFile, expFile);\n\n        // checking existence of regression results file to mathc results\n        File f = new File(baseDir + \"/\"+ expFile);\n        if(!f.exists() || f.isDirectory()) {\n            System.out.println(expFile + \" is missing\");\n            return false;\n        }\n        // write file to aut\n        if (!writeToAut(baseDir, fileName)) {\n            return false;\n        }\n        try {\n            // diff = 0 means no differences, 1 means differences exist, 2 means error\n            diffReturnValue = CmdLineCaller.cmdCaller(commands, null, baseDir, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (diffReturnValue==0);\n    }\n\n    public String toSringAut() {\n        String str = \"\";\n        for (GraphNode node: this.getVertices()) {\n            for (GraphNode dest : this.getSuccessors(node)) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \"+ edge.getAction() + \", \" + dest.getId() +\") \" +\n                            edge.getType().toString() + \"\\n\";\n            }\n        }\n        return str;\n    }\n\n    @Deprecated\n    public String toStringAutColors() {\n        String str = \"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\", \" + this\n                .getVertices().size()+\")\\n\";\n        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n        for (GraphNode node: orderedVertices) {\n            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n            for (GraphNode dest : orderedSuccessors) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \\\"\"+ edge.getAction()+\"\\\":l\"+ edge.getType() +\n                            \", \" +\n                        dest.getId() +\")\\n\";\n            }\n        }\n        return str;\n    }\n\n    public String toSringAutPrefixSuffix() {\n        String str = \"\";\n        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n        for (GraphNode node: orderedVertices) {\n            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n            for (GraphNode dest : orderedSuccessors) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \"+ edge.getAction() + \", \" + dest.getId() +\") \" +\n                            edge.getType().toString() + \"\\n\";\n            }\n            str+= \"(\" + node.getId() +\", \"+ node.prefixSuffixToString() + \"\\n\";\n        }\n        return str;\n    }\n}", "class_id": 0, "repo": "gbarbon/clear", "file": "clear_tagged_lts_computer/src/clear_analyser/graph/LTS.java", "last_update_at": "2018-05-09T14:52:02+00:00", "question_id": "aae9342c99edf59bec717f8d099fa08a424e0c64", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LTS extends DirectedSparseMultigraph<GraphNode,GraphEdge>  {\n    private GraphNode initialNode;  // initial node of an LTS\n    private GraphNode sink;\n    private boolean isCounterexampleLTS;\n    STDOut outputWriter;\n    Map<Integer, GraphNode> specNodeIndex;\n    private GraphNode fakeFinalNode;\n    private Set<GraphEdge> fakeFinalEdges;\n    public LTS(STDOut outputWriter) {\n        super();\n        initialNode = null;\n        sink = null;\n        isCounterexampleLTS = false;\n        this.outputWriter = outputWriter;\n        specNodeIndex = null;\n    }\n/*    public LTS(DirectedSparseMultigraph<GraphNode, GraphEdge> graph, GraphNode initialNode) {\n        super();\n        this.initialNode = initialNode;\n        sink = null;\n        isCounterexampleLTS = false;\n    }*/\n    public STDOut getOutputWriter() {\n        return outputWriter;\n    }\n    public GraphNode getInitialNode() {\n        return initialNode;\n    }\n    public void setInitialNode(GraphNode node) {\n        this.initialNode = node;\n    }\n    private boolean hasSink() {\n        return sink != null;\n    }\n    public void setSink(GraphNode node) {\n        sink = node;\n    }\n    public GraphNode getSink() {\n        return sink;\n    }\n    public boolean isCounterexampleLTS() {\n        return isCounterexampleLTS;\n    }\n    public void setAsCounterexampleLTS() {\n        isCounterexampleLTS = true;\n    }\n    @Override\n    public Collection<GraphEdge> findEdgeSet(GraphNode n1, GraphNode n2) {\n        return super.findEdgeSet(n1, n2);\n    }\n    /**\n     *\n     * @return a collection with all the vertices but without the sink\n     */\n    public Collection<GraphNode> getVerticesWOSink(){\n        Collection<GraphNode> vertices = new HashSet<>();\n        vertices.addAll(super.getVertices());\n        vertices.remove(sink);\n        return vertices;\n    }\n    /**\n     * creates and return the sink\n     */\n    private GraphNode createSink() {\n        // the id of the sink graph is the id of the vertex with the highest id +1\n        // that is equivalent to the current size of the graph\n        //System.out.println(\"Creating sink\");\n        // sink = new GraphNode(super.getVertexCount());  // OLD VERSION, after script\n        // modification did not work anymore\n        sink = new GraphNode(-1); // sink is node with -1\n        super.addVertex(sink);   // TODO: check if this is necessary!\n        outputWriter.printComplete(\"Sink is: \"+ sink.toString(), true, true);\n        return sink;\n    }\n    @Override\n    public boolean addEdge(GraphEdge edge, GraphNode source, GraphNode dest) {\n       return super.addEdge(edge, source, dest, EdgeType.DIRECTED);\n        //Pair<GraphNode> pair = new Pair<>(source, dest);\n        //return super.addEdge(edge, pair, EdgeType.DIRECTED);\n        //return super.addEdge(edge, source, dest);\n    }\n    /**\n     * Add a correct transition to the Counterexample LTS (always out transitions)\n     * @param sourceNode\n     * @param edge\n     */\n    public void addCorrectTransition(GraphNode sourceNode, GraphEdge edge){\n        //System.out.println(\"Adding a correct transition\");\n        if (!hasSink()) {\n            //System.out.println(\"Lts does not have the sink, adding it now\");\n            createSink(); // create the sink node if not created yet\n        }\n        edge.setAsCorrect();\n        edge.setNodes(sourceNode, sink);\n        addEdge(edge, sourceNode, sink);\n    }\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Correct (green) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutCorrectTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isCorrect())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Incorrect (red) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutIncorrectTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isIncorrect())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n    /**\n     *\n     * @param node a node of this LTS\n     * @return the collection of Neutral (black) Transitions exiting from the given node\n     */\n    public Collection<GraphEdge> getOutNeutralTransitions(GraphNode node) {\n        Collection<GraphEdge> transitionSet = new HashSet<>();\n        for (GraphEdge edge : super.getOutEdges(node)) {\n            if (edge.isNeutral())\n                transitionSet.add(edge);\n            // TODO: implement following check, we cannot return edges if there are still UNSET edges\n            /*else if (edge.isUnset())\n                throw new Exception(); */\n        }\n        return transitionSet;\n    }\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all correct,\n     * false otherwise\n     */\n    public boolean areOutTransCorrect(GraphNode node) {\n        return (!getOutCorrectTransitions(node).isEmpty() &&\n                getOutIncorrectTransitions(node).isEmpty() &&\n                getOutNeutralTransitions(node).isEmpty());\n    }\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all incorrect,\n     * false otherwise\n     */\n    public boolean areOutTransIncorrect(GraphNode node) {\n        return (getOutCorrectTransitions(node).isEmpty() &&\n                !getOutIncorrectTransitions(node).isEmpty() &&\n                getOutNeutralTransitions(node).isEmpty());\n    }\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter are all neutral,\n     * false otherwise\n     */\n    public boolean areOutTransNeutral(GraphNode node) {\n        return (getOutCorrectTransitions(node).isEmpty() &&\n                getOutIncorrectTransitions(node).isEmpty() &&\n                !getOutNeutralTransitions(node).isEmpty());\n    }\n    /**\n     *\n     * @param node the chosen graph node\n     * @return true if the outgoing transitions for the node passed as parameter belong to the\n     * following combinations (where G:correct, R:incorrect, B:neutral): B, B+R, B+G, B+R+G, R+G.\n     * Note that the presence of neutral allow to cover the first 4 combinations.\n     */\n    public boolean areOutTransMixed(GraphNode node) {\n        boolean redEmpty, greenEmpty, blackEmpty;\n        greenEmpty = getOutCorrectTransitions(node).isEmpty();\n        redEmpty = getOutIncorrectTransitions(node).isEmpty();\n        blackEmpty = getOutNeutralTransitions(node).isEmpty();\n        return !blackEmpty || (!greenEmpty && !redEmpty);\n    }\n    /**\n     * Add final edges for evaluating deadlock and livelocks\n     * FIXME: missing removal function, add it !\n     */\n    public void addFakeFinalEdges() {\n        // create fake final node\n        fakeFinalEdges = new HashSet<>();\n        fakeFinalNode = new GraphNode(-3);\n        this.addVertex(fakeFinalNode);\n        for (GraphNode node :  this.getVertices() ) {\n            if (this.getOutEdges(node).isEmpty()) {\n                // throw new NotImplementedException();\n                GraphEdge fakeFinalEdge = new GraphEdge(\"FINALEDGE\");\n                fakeFinalEdges.add(fakeFinalEdge);\n                this.addEdge(fakeFinalEdge, node, fakeFinalNode);\n            }\n        }\n    }\n    /**\n     * Shallow copy of an LTS\n     * @param other the LTS to copy\n     * @return the shallow copy\n     */\n    public static LTS copy(LTS other) {\n        LTS res = new LTS(other.getOutputWriter());\n        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?\n        for (GraphNode node : other.getVertices()) {\n            res.addVertex(node);\n            res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?\n        }\n        for (GraphEdge edge : other.getEdges()) {\n            GraphNode source = other.getSource(edge);\n            GraphNode dest = other.getDest(edge);\n            res.addEdge(edge, source, dest);\n        }\n        res.setInitialNode(other.getInitialNode());\n        if (other.hasSink()) {\n            res.setSink(other.getSink());\n        }\n        return res;\n    }\n    /**\n     * Shallow copy of a subset of the LTS\n     * @param other the LTS to copy\n     * @param nodesToCopy nodes representing the subset\n     * @return the shallow copy\n     */\n    public static LTS copySubset(LTS other, Collection nodesToCopy) {\n        LTS res = new LTS(other.getOutputWriter());\n        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?\n        for (GraphNode node : other.getVertices()) {\n            if (nodesToCopy.contains(node)) {\n                res.addVertex(node);\n                res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?\n            }\n        }\n        for (GraphEdge edge : other.getEdges()) {\n            GraphNode source = other.getSource(edge);\n            GraphNode dest = other.getDest(edge);\n            if (nodesToCopy.contains(source) && nodesToCopy.contains(dest)) {\n                res.addEdge(edge, source, dest);\n            }\n        }\n        res.setInitialNode(other.getInitialNode());\n        if (other.hasSink()) {\n            res.setSink(other.getSink());\n        }\n        return res;\n    }\n    @Override\n    public boolean removeEdge(GraphEdge edge) {\n        return super.removeEdge(edge);\n    }\n    /**\n     * Remove all the edges containing the action passed as parameter\n     * @param action the String describing the edges to remove\n     */\n    public void removeAllEdges(String action) {\n        /*boolean res = false;\n        for (GraphEdge edge : getEdges()) {\n            if (edge.getAction().equals(action))\n                res = removeEdge(edge);\n        }*/\n        new ArrayList<>(getEdges()).stream()\n                .filter(e -> e.getAction().equals(action))\n                .forEach(this::removeEdge);\n    }\n    /**\n     * Remove all the edges between the given set of nodes containing the action passed as parameter\n     * @param action the String describing the edges to remove\n     * @param nodes nodes representing sources and destinations of the edges to remove\n     */\n    public void removeAllEdges(String action, Collection nodes) {\n        /*boolean res = false;\n        for (GraphEdge edge : getEdges()) {\n            GraphNode source = getSource(edge);\n            GraphNode dest = getDest(edge);\n            if (nodes.contains(source) && nodes.contains(dest)) {\n                if (edge.getAction().equals(action))\n                    res = removeEdge(edge);\n            }\n        }*/\n        new ArrayList<>(getEdges()).stream()\n                .filter(e -> (e.getAction().equals(action) && nodes.contains(getSource(e)) && nodes\n                        .contains(getDest(e))))\n                .forEach(this::removeEdge);\n    }\n    /**\n     * Load a graph from an aut file\n     * @param baseDir directory\n     * @param testName name of the file to load\n     * @throws Exception // TODO: to implement correctly\n     * @return false if the size of the LTS is less or equal to 1, true otherwise\n     */\n    public boolean autLoaderOLD(String baseDir, String testName)  throws Exception  {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + testName + \".aut\"));\n        // TODO: check that the file is actually an aut file\n        // TODO: add exception in case of missing file\n        class GraphEdgeExt  {\n            GraphEdge edge;\n            GraphNode source;\n            GraphNode dest;\n            GraphEdgeExt(GraphEdge edge, GraphNode source, GraphNode dest) {\n                this.edge = edge;\n                this.source = source;\n                this.dest = dest;\n            }\n        }\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        Map<Integer, GraphNode> specNodeIndex = new HashMap<>();\n        //Map<GraphEdge, Pair> edgePairMap = new Hashtable<>();\n        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\"des\")) {\n                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(\",\")[0].trim());\n            } else {\n                String[] data = new String[]{\"\", \"\", \"\"};\n                int firstComma = line.indexOf(\",\");\n                int lastComma = line.lastIndexOf(\",\");\n                data[0] = line.substring(0, firstComma).replaceAll(\"[()]\", \"\");\n                data[1] = line.substring(firstComma + 1, lastComma);\n                data[2] = line.substring(lastComma + 1).replaceAll(\"[()]\", \"\");\n                // label with quotes\n                int firstIndx = line.indexOf(\"\\\"\");\n                if (firstIndx != -1) {\n                    int lastIndx = line.lastIndexOf(\"\\\"\");\n                    data[1] = line.substring(firstIndx + 1, lastIndx);\n                }\n                int fromNodeId = Integer.valueOf(data[0].trim());\n                String action = data[1].trim();\n                int toNodeId = Integer.valueOf(data[2].trim());\n                // TODO: see if it is possible to avoid \"i\" transitions directly on the script\n                if (!action.equals(\"i\")){ // this allows to avoid the final transitions \"i\"\n                    GraphEdge edge = new GraphEdge(action);\n                    GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                    if (fromNode == null) {\n                        fromNode = new GraphNode(fromNodeId);\n                        specNodeIndex.put(fromNodeId, fromNode);\n                    }\n                    GraphNode toNode = specNodeIndex.get(toNodeId);\n                    if (toNode == null) {\n                        toNode = new GraphNode(toNodeId);\n                        specNodeIndex.put(toNodeId, toNode);\n                    }\n                    edge.setNodes(fromNode, toNode);\n                    //addEdge(edge, fromNode, toNode);\n                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                    listEdges.add(edge);\n                    // FIXME: TRY TO AVOID THE NODE INDEX!\n                }\n            }\n            if (debugIterations%100000 == 0)\n                outputWriter.printComplete(\"autLoader: read \"+ debugIterations  + \" lines\", false,\n                        false);\n            debugIterations++;\n        }\n        br.close();\n        int debug = 0;\n        for (GraphEdge edge : listEdges) {\n            addEdge(edge, edge.source, edge.dest);\n            if (debug%100000 == 0)\n                outputWriter.printComplete(\"autLoader: inserted \"+ debug  + \" lines\", false,\n                        false);\n            debug++;\n        }\n        setInitialNode(specNodeIndex.get(specStartNodeId));\n        if (super.vertices.size() <= 1) {\n            outputWriter.printError(\"autLoader: possible ERROR, the loaded lts contains only a \" +\n                    \"node\", true, true);\n            // FIXME: should throw an exception in this case\n            return false;\n        }\n        return true;\n    }\n    public boolean autLoader(String baseDir, String testName, Boolean fast, boolean safety) throws\n            Exception  {\n        long startTime = System.currentTimeMillis();\n        List<GraphEdge> edgeList;\n        edgeList = fileReader(baseDir, testName, fast, safety);\n        boolean res = graphLoader(edgeList);\n        outputWriter.printComplete(\"autLoader: loading completed.\", true, false);\n        long endTime = System.currentTimeMillis();\n        outputWriter.printComplete(\"autLoader exec time: \" +\n                (endTime - startTime) + \" ms\\n\", true, false);\n        return res;\n    }\n    public List<GraphEdge> fileReader (String baseDir, String testName, boolean fast,\n                                       boolean safety)\n            throws Exception  {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + testName + \".aut\"));\n        // TODO: check that the file is actually an aut file\n        // TODO: add exception in case of missing file\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        specNodeIndex = new HashMap<>();\n        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\"des\")) {\n                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(\",\")[0].trim());\n            } else {\n                String[] data = new String[]{\"\", \"\", \"\"};\n                int firstComma = line.indexOf(\",\");\n                int lastComma = line.lastIndexOf(\",\");\n                data[0] = line.substring(0, firstComma).replaceAll(\"[()]\", \"\");\n                data[1] = line.substring(firstComma + 1, lastComma);\n                data[2] = line.substring(lastComma + 1).replaceAll(\"[()]\", \"\");\n                // label with quotes\n                int firstIndx = line.indexOf(\"\\\"\");\n                if (firstIndx != -1) {\n                    int lastIndx = line.lastIndexOf(\"\\\"\");\n                    data[1] = line.substring(firstIndx + 1, lastIndx);\n                }\n                int fromNodeId = Integer.valueOf(data[0].trim());\n                String action = data[1].trim();\n                int toNodeId = Integer.valueOf(data[2].trim());\n                // TODO: see if it is possible to avoid \"i\" transitions directly on the script\n                if (!safety || fast) {\n                    // \"i\" transitions are allowed in liveness mode or\n                    // in fast safety mode \"i\" transition are used only to detect\n                    // final transitions\n                    GraphEdge edge = new GraphEdge(action);\n                    GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                    if (fromNode == null) {\n                        fromNode = new GraphNode(fromNodeId);\n                        specNodeIndex.put(fromNodeId, fromNode);\n                    }\n                    GraphNode toNode = specNodeIndex.get(toNodeId);\n                    if (toNode == null) {\n                        toNode = new GraphNode(toNodeId);\n                        specNodeIndex.put(toNodeId, toNode);\n                    }\n                    edge.setNodes(fromNode, toNode);\n                    //addEdge(edge, fromNode, toNode);\n                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                    listEdges.add(edge);\n                    // FIXME: TRY TO AVOID THE NODE INDEX!\n                } else {\n                    // in normal safety mode, \"i\" transition cannot be used\n                    // (performs the i avoidance if normal mode is used)\n                    // this allows to avoid the final transitions \"i\"\n                    if (!action.equals(\"i\") ) {\n                        GraphEdge edge = new GraphEdge(action);\n                        GraphNode fromNode = specNodeIndex.get(fromNodeId);\n                        if (fromNode == null) {\n                            fromNode = new GraphNode(fromNodeId);\n                            specNodeIndex.put(fromNodeId, fromNode);\n                        }\n                        GraphNode toNode = specNodeIndex.get(toNodeId);\n                        if (toNode == null) {\n                            toNode = new GraphNode(toNodeId);\n                            specNodeIndex.put(toNodeId, toNode);\n                        }\n                        edge.setNodes(fromNode, toNode);\n                        //addEdge(edge, fromNode, toNode);\n                        //edgePairMap.put(edge, new Pair<>(fromNode, toNode));\n                        listEdges.add(edge);\n                        // FIXME: TRY TO AVOID THE NODE INDEX!\n                    }\n                }\n            }\n            if (debugIterations%100000 == 0)\n                outputWriter.printComplete(\"autLoader: read \"+ debugIterations  + \" lines\", false,\n                        false);\n            debugIterations++;\n        }\n        br.close();\n        setInitialNode(specNodeIndex.get(specStartNodeId));\n        outputWriter.printComplete(\"autLoader: read finished after \"+ debugIterations + \" \" +\n                \"iterations.\", true, false);\n        return listEdges;\n    }\n    public boolean graphLoader(List<GraphEdge> listEdges) {\n        int debug = 0;\n        for (GraphEdge edge : listEdges) {\n            addEdge(edge, edge.source, edge.dest);\n            if (debug%100000 == 0)\n                outputWriter.printComplete(\"autLoader: inserted \"+ debug  + \" lines\", false, true);\n            debug++;\n        }\n        outputWriter.printComplete(\"autLoader: loading finished after \"+ debug + \" \" +\n                \"iterations.\", true, true);\n        if (super.vertices.size() <= 1) {\n            outputWriter.printError(\"autLoader: possible ERROR, the loaded lts contains only a \" +\n                    \"node\", true, true);\n            // FIXME: should throw an exception in this case\n            return false;\n        }\n        return true;\n    }\n    /**\n     * If f option is chosen, it reads the table with the correspondence between states\n     * It extracts data from the table containing the equivalence between states\n     * @param baseDir\n     * @param tableFileName\n     * @throws Exception\n     */\n    public void equivTableLoader(String baseDir, String tableFileName, LTS fullLTS) throws\n            Exception {\n        BufferedReader br = new BufferedReader(new FileReader(baseDir + \"/\" + tableFileName\n                + \".prd\"));\n        // TODO: check that the file is actually a table file\n        // TODO: add exception in case of missing file\n        String line;\n        int specStartNodeId = -1;\n        int debugIterations = 0;\n        Map<Integer, Integer> cLTStoFullLTScorr = new HashMap<>(); // maps\n        // <nodeInTheCounterexLTS, nodeInTheFullLTS>\n        while ((line = br.readLine()) != null) {\n            String[] data = new String[]{\"\", \"\", \"\"};\n            int equalSign = line.indexOf(\"=\");\n            int comma = line.indexOf(\",\");\n            int openBrace = line.indexOf(\"{\");\n            //int closedBrace = line.indexOf(\"}\");\n            data[0] = line.substring(0, equalSign).replaceAll(\"[()]\", \"\");\n            data[1] = line.substring(openBrace + 1, comma);\n            //data[2] = line.substring(comma + 1, closedBrace).replaceAll(\"[()]\", \"\");\n            int cLTSState = Integer.valueOf(data[0].trim());\n            int fullState = Integer.valueOf(data[1].trim());\n            //int propState = Integer.valueOf(data[2].trim()); the index of the property is unused\n            cLTStoFullLTScorr.put(cLTSState, fullState);\n            if (debugIterations % 100000 == 0)\n                outputWriter.printComplete(\"equivTableLoader: read \" + debugIterations +\n                        \" lines\", false, true);\n            debugIterations++;\n        }\n        br.close();\n        // Now it loads the data in the Counterexample LTS as equivalences\n        for (Integer index : specNodeIndex.keySet()) {\n            GraphNode node = specNodeIndex.get(index);\n            node.setEquivalentInSpec(fullLTS.specNodeIndex.get(cLTStoFullLTScorr.get(index)));\n        }\n        outputWriter.printComplete(\"equivTableLoader: read finished after \" + debugIterations +\n                \" iterations.\", true, true);\n    }\n    /**\n     * Write the lts with colors in aut format, using colon to separate action and transition type\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean writeToAut(String baseDir, String fileName) {\n        String resFile = fileName+\"_clr-res.aut\";\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(\n                new FileOutputStream(baseDir + \"/\"+resFile, false), \"utf-8\"))) {\n            // writing header\n            writer.write(\"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\",\" +\n                    \" \" + this.getVertices().size()+\")\\n\");\n            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n            for (GraphNode node: orderedVertices) {\n                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n                for (GraphNode dest : orderedSuccessors) {\n                    for (GraphEdge edge : this.findEdgeSet(node, dest))\n                        writer.write(\"(\" + node.getId() +\", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                edge.getType() + \", \" + dest.getId() +\")\\n\");\n                }\n            }\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Write the lts with colors and neighbourhoods in aut format, using colon to separate action\n     * and transition type (for colors) and colon to separate state id and neighbourhood type (for\n     * neighbourhoods).\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean autDump(String baseDir, String fileName) {\n        String resFile = fileName+\"_res-dump.autx\";\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(\n                new FileOutputStream(baseDir + \"/\"+resFile, false), \"utf-8\"))) {\n            // writing header\n            writer.write(\"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\",\" +\n                    \" \" + this.getVertices().size()+\")\\n\");\n            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n            for (GraphNode node: orderedVertices) {\n                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n                for (GraphNode dest : orderedSuccessors) {\n                    for (GraphEdge edge : this.findEdgeSet(node, dest))\n                        if (node.isFrontier()) {\n                            writer.write(\"(\" + node.getId()+\":N:\"+node.getNeighbourhood()\n                                            .toStringShort()+ \", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                    edge.getType() + \", \" + dest.getId() +\")\\n\");\n                        } else {\n                        writer.write(\"(\" + node.getId()+\", \\\"\"+ edge.getAction()+\"\\\":\"+\n                                edge.getType() + \", \" + dest.getId() +\")\\n\");\n                    }\n                }\n            }\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Regression check on given file (only liveness)\n     * @param baseDir\n     * @param fileName\n     * @return\n     */\n    public boolean regressionCheck(String baseDir, String fileName) {\n        String resFile = fileName+\"_clr-res.aut\";\n        String expFile = fileName+\"_clr-exp.aut\";\n        int diffReturnValue = 2;  // 2 means error on diff\n        List<String> commands = Arrays.asList(\"diff\", resFile, expFile);\n        // checking existence of regression results file to mathc results\n        File f = new File(baseDir + \"/\"+ expFile);\n        if(!f.exists() || f.isDirectory()) {\n            System.out.println(expFile + \" is missing\");\n            return false;\n        }\n        // write file to aut\n        if (!writeToAut(baseDir, fileName)) {\n            return false;\n        }\n        try {\n            // diff = 0 means no differences, 1 means differences exist, 2 means error\n            diffReturnValue = CmdLineCaller.cmdCaller(commands, null, baseDir, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (diffReturnValue==0);\n    }\n    public String toSringAut() {\n        String str = \"\";\n        for (GraphNode node: this.getVertices()) {\n            for (GraphNode dest : this.getSuccessors(node)) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \"+ edge.getAction() + \", \" + dest.getId() +\") \" +\n                            edge.getType().toString() + \"\\n\";\n            }\n        }\n        return str;\n    }\n    @Deprecated\n    public String toStringAutColors() {\n        String str = \"des (\"+ this.getInitialNode().getId()+\", \" + this.getEdges().size()+\", \" + this\n                .getVertices().size()+\")\\n\";\n        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n        for (GraphNode node: orderedVertices) {\n            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n            for (GraphNode dest : orderedSuccessors) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \\\"\"+ edge.getAction()+\"\\\":l\"+ edge.getType() +\n                            \", \" +\n                        dest.getId() +\")\\n\";\n            }\n        }\n        return str;\n    }\n    public String toSringAutPrefixSuffix() {\n        String str = \"\";\n        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());\n        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);\n        for (GraphNode node: orderedVertices) {\n            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));\n            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);\n            for (GraphNode dest : orderedSuccessors) {\n                for (GraphEdge edge : this.findEdgeSet(node, dest))\n                    str+= \"(\" + node.getId() +\", \"+ edge.getAction() + \", \" + dest.getId() +\") \" +\n                            edge.getType().toString() + \"\\n\";\n            }\n            str+= \"(\" + node.getId() +\", \"+ node.prefixSuffixToString() + \"\\n\";\n        }\n        return str;\n    }\n"]], "pred": {"ppl": 2.3861899375915527, "ppl_lower": 2.6043338775634766, "ppl/lowercase_ppl": -1.1005855081586327, "ppl/zlib": 0.0001611148435593201, "Min_5.0% Prob": 6.888776059244194, "Min_10.0% Prob": 5.304692488090665, "Min_20.0% Prob": 3.6862509268171646, "Min_30.0% Prob": 2.75262669839111, "Min_40.0% Prob": 2.1341249665887547, "Min_50.0% Prob": 1.7285883228081314, "Min_60.0% Prob": 1.447689004777209}}
{"hexsha": "a3c651d7e12167098cc21186289d50aede65e8f7", "ext": "java", "lang": "Java", "content": "@Mojo(threadSafe = true, name = \"upgrade\", requiresDirectInvocation = false, requiresProject = true)\npublic class StickyBoundsUpgradeMojo\n    extends AbstractMojo {\n\n  /**\n   * The Maven Project.\n   */\n  @Parameter(defaultValue = \"${project}\", required = true, readonly = true)\n  private MavenProject project;\n\n  /**\n   * The entry point to Aether, i.e. the component doing all the work.\n   * \n   */\n  @Component\n  private RepositorySystem repository;\n\n  /**\n   * The current repository/network configuration of Maven.\n   */\n  @Parameter(defaultValue = \"${repositorySystemSession}\", required = true, readonly = true)\n  private RepositorySystemSession session;\n\n  private Pattern range = Pattern.compile(\"\\\\[[0-9.\\\\-A-Za-z]+\\\\s*(,\\\\s*([0-9.\\\\-A-Za-z]+)?)\\\\)\");\n\n  /**\n   * The project's remote repositories to use for the resolution.\n   */\n  @Parameter(defaultValue = \"${project.remoteProjectRepositories}\", required = true, readonly = true)\n  private List<RemoteRepository> repositories;\n\n  @Parameter(defaultValue = \"false\")\n  private Boolean includeSnapshots = false;\n\n  @Parameter(defaultValue = \"false\")\n  private Boolean updateProperties = false;\n\n  @Parameter(defaultValue = \"false\")\n  private Boolean failImmediately = false;\n\n  /**\n   * The line separator used when rewriting the pom, this to defaults to your platform encoding but if you fix your encoding despite\n   * platform then you should use that.\n   */\n  @Parameter\n  private LineSeparator lineSeparator = LineSeparator.defaultValue();\n\n  Matcher matchVersion(String version) {\n    return range.matcher(version);\n  }\n\n  /**\n   * If bounds should be updated when there is no upgrade, useful for doing cascaded upgrades while minimising deltas\n   */\n  @Parameter()\n  private boolean acceptMinorVersionChanges = false;\n\n  Changes change = new Changes();\n\n  @Override\n  public void execute() throws MojoExecutionException {\n    Document pom = load();\n\n    change.acceptMinorVersionChanges(acceptMinorVersionChanges);\n\n    processProperties(pom);\n\n    processDependencies(pom);\n\n    processDependencyManagement(pom);\n\n    if (change.changed()) {\n      if (change.upgraded())\n        bumpMajorVersion(pom);\n      writeChanges(pom);\n    }\n  }\n\n  void bumpMajorVersion(Document pom) throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes project = pom.query(\"/mvn:project\", context);\n    if (project.size() == 0)\n      throw new MojoExecutionException(\"Pom is broken\");\n\n    Nodes nodes = pom.query(\"/mvn:project/mvn:version\", context);\n    if (nodes.size() != 1)\n      throw new MojoExecutionException(\"Version is not declared correctly\");\n\n    Element e = (Element) nodes.get(0);\n    String[] components = e.getValue().split(\"\\\\.\");\n    components[0] = Integer.toString(Integer.valueOf(components[0]) + 1);\n\n    String bumpedVersion = String.join(\".\", components);\n\n    Element newVersion = new Element(\"version\", \"http://maven.apache.org/POM/4.0.0\");\n    newVersion.appendChild(bumpedVersion);\n    ((Element) project.get(0)).replaceChild(e, newVersion);\n    // TODO check that the next version does not already exist\n  }\n\n  private void processDependencyManagement(Document pom)\n      throws MojoExecutionException {\n    if (project.getDependencyManagement() != null) {\n      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {\n        try {\n          String version = dependency.getVersion();\n          Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());\n\n          if (change.change(artifact.getVersion(), version)) {\n            updateDependencyManagement(pom, artifact, artifact.getVersion());\n          }\n        }\n        catch (MojoExecutionException e) {\n          fail(e);\n        }\n      }\n    }\n  }\n\n  private void processDependencies(Document pom)\n      throws MojoExecutionException {\n    for (Dependency dependency : project.getDependencies()) {\n      try {\n        String version = dependency.getVersion();\n        Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());\n\n        if (change.change(artifact.getVersion(), version)) {\n          updateDependency(pom, artifact, version);\n        }\n      }\n      catch (MojoExecutionException e) {\n        fail(e);\n      }\n    }\n  }\n\n  private void processProperties(Document pom)\n      throws MojoExecutionException {\n    for (String propertyName : project.getProperties().stringPropertyNames()) {\n      if (propertyName.endsWith(\".version\")) {\n        try {\n          final String version = project.getProperties().getProperty(propertyName);\n          Dependency dependency = findDependencyUsingVersionProperty(propertyName);\n          if (dependency != null) {\n            Artifact artifact = resolveLatestVersionRange(dependency, version);\n            if (change.change(artifact.getVersion(), version)) {\n              updateProperty(pom, propertyName, artifact.getVersion());\n            }\n          }\n          else {\n            getLog().warn(\"No dependency found using \" + propertyName);\n          }\n        }\n        catch (MojoExecutionException e) {\n          fail(e);\n        }\n      }\n    }\n  }\n\n  private void fail(MojoExecutionException e) throws MojoExecutionException {\n    if (!failImmediately) {\n      getLog().warn(e.getMessage());\n    }\n    else {\n      throw e;\n    }\n  }\n\n  Artifact resolveLatestVersionRange(Dependency dependency, String version) throws MojoExecutionException {\n    Matcher versionMatch = matchVersion(version);\n\n    if (versionMatch.matches()) {\n      Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),\n        dependency.getClassifier(), dependency.getType(), version.replaceFirst(versionMatch.group(1), \",\"));\n\n      Version highestVersion = highestVersion(artifact);\n      String newVersion = \"[\" + highestVersion.toString() + \",\" + majorVersionPlusOne(highestVersion) + \")\";\n\n      return artifact.setVersion(newVersion);\n    }\n    else {\n      return new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),\n        dependency.getClassifier(), dependency.getType(), version);\n    }\n  }\n\n  private Integer majorVersionPlusOne(Version highestVersion) {\n    String[] split = highestVersion.toString().split(\"\\\\.\");\n    return Integer.valueOf(split[0]) + 1;\n  }\n\n  private Dependency findDependencyUsingVersionProperty(String propertyName) {\n    for (Dependency dependency : project.getDependencies()) {\n      if (propertyName.equals(dependency.getArtifactId() + \".version\")) {\n        getLog()\n          .warn(\n            \"If you use dependency composition then you will find that version properties \"\n              + \"are really not that useful. Its an extra indirection that often you don't need. \"\n              + \"IMO people take the magic number refactoring too far\");\n        return dependency;\n      }\n    }\n    if (project.getDependencyManagement() != null) {\n      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {\n        if (propertyName.equals(dependency.getArtifactId() + \".version\")) {\n          getLog()\n            .warn(\n              \"Dependency Management is an anti pattern, think OO or functional, \"\n                + \"dependencies should be composed NOT inherited\");\n          return dependency;\n        }\n      }\n    }\n    return null;\n  }\n\n  private void writeChanges(Document pom) {\n    Serializer serializer = createSerialiser();\n    try {\n      serializer.write(pom);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private Serializer createSerialiser() {\n    try {\n      Serializer serializer = new StickySerializer(new FileOutputStream(project.getFile()), \"UTF-8\");\n      if (!System.lineSeparator().equals(lineSeparator.value()))\n        getLog().info(String.format(\"The line separator is configured to %s, not using system line separator\", lineSeparator));\n\n      serializer.setLineSeparator(lineSeparator.value());\n      return serializer;\n    }\n    catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n    catch (FileNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  protected Version highestVersion(Artifact artifact) throws MojoExecutionException {\n    VersionRangeRequest request = new VersionRangeRequest(artifact, repositories, null);\n    VersionRangeResult v = resolve(request);\n\n    if (!includeSnapshots) {\n      List<Version> filtered = new ArrayList<Version>();\n      for (Version aVersion : v.getVersions()) {\n        if (!aVersion.toString().endsWith(\"SNAPSHOT\")) {\n          filtered.add(aVersion);\n        }\n      }\n      v.setVersions(filtered);\n    }\n\n    if (v.getHighestVersion() == null) {\n      throw (v.getExceptions().isEmpty())\n        ? new MojoExecutionException(\"Failed to resolve \" + artifact.toString())\n        : new MojoExecutionException(\"Failed to resolve \" + artifact.toString(), v.getExceptions().get(0));\n    }\n\n    return v.getHighestVersion();\n  }\n\n  void updateProperty(Document pom, String propertyName, String newVersion) throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes nodes = pom.query(\"//mvn:properties\", context);\n\n    if (nodes.size() > 0) {\n      final Element propertiesElement = (Element) nodes.get(0);\n      Elements properties = propertiesElement.getChildElements();\n      for (int i = 0; i < properties.size(); i++) {\n        Element property = properties.get(i);\n        if (property.getLocalName().equals(propertyName)) {\n          Element newRange = new Element(propertyName, \"http://maven.apache.org/POM/4.0.0\");\n          newRange.appendChild(newVersion);\n          propertiesElement.replaceChild(property, newRange);\n        }\n      }\n    }\n  }\n\n  void updateDependency(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {\n    updateDependency(pom, dependencyPath(artifact.getArtifactId()), oldVersion, artifact);\n  }\n\n  void updateDependencyManagement(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {\n    updateDependency(pom, dependencyManagementPath(artifact.getArtifactId()), oldVersion, artifact);\n  }\n\n  private void updateDependency(Document pom, String dependencyPath, String oldVersion, Artifact artifact)\n      throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes nodes = pom.query(dependencyPath, context);\n\n    if (nodes.size() == 0) {\n      throw new MojoExecutionException(String.format(\"Missing <dependency> element for dependency %s, skipping.\",\n        artifact.getArtifactId()));\n    }\n\n    for (int i = 0; i < nodes.size(); i++) {\n      Node node = nodes.get(i);\n      ParentNode dependency = node.getParent();\n      Nodes classifier = dependency.query(\"mvn:classifier\", context);\n      if (classifier.size() != 0)\n        if (!classifier.get(0).getValue().equals(artifact.getClassifier()))\n          return;\n\n      final Nodes versionNodes = dependency.query(\"mvn:version\", context);\n      if (versionNodes.size() > 0) {\n        getLog().info(\"Upgrading dependency to \" + artifact.toString() + \" from \" + oldVersion);\n        Element version = (Element) versionNodes.get(0);\n        if (!version.getValue().startsWith(\"${\") || updateProperties) {\n          Element newRange = new Element(\"version\", \"http://maven.apache.org/POM/4.0.0\");\n          newRange.appendChild(artifact.getVersion());\n          dependency.replaceChild(version, newRange);\n        }\n      }\n      else {\n        throw new MojoExecutionException(String.format(\"Missing <version> element for dependency %s, skipping.\",\n          artifact.getArtifactId()));\n      }\n    }\n  }\n\n  private String dependencyPath(String artifactId) {\n    return \"//mvn:dependencies/mvn:dependency/mvn:artifactId[text()='\" + artifactId + \"']\";\n  }\n\n  private String dependencyManagementPath(String artifactId) {\n    return \"//mvn:dependencyManagement/mvn:dependencies/mvn:dependency/mvn:artifactId[text()='\" + artifactId + \"']\";\n  }\n\n  private Document load() {\n    try {\n      return new Builder().build(project.getFile());\n    }\n    catch (ValidityException e) {\n      throw new RuntimeException(e);\n    }\n    catch (ParsingException e) {\n      throw new RuntimeException(e);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private VersionRangeResult resolve(VersionRangeRequest request) {\n    try {\n      return repository.resolveVersionRange(session, request);\n    }\n    catch (VersionRangeResolutionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n}", "class_id": 0, "repo": "StickySource/bounds-maven-plugin", "file": "src/main/java/net/stickycode/plugin/bounds/StickyBoundsUpgradeMojo.java", "last_update_at": "2018-11-05T23:09:04+00:00", "question_id": "a3c651d7e12167098cc21186289d50aede65e8f7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Mojo(threadSafe = true, name = \"upgrade\", requiresDirectInvocation = false, requiresProject = true)\npublic class StickyBoundsUpgradeMojo\n    extends AbstractMojo {\n  /**\n   * The Maven Project.\n   */\n  @Parameter(defaultValue = \"${project}\", required = true, readonly = true)\n  private MavenProject project;\n  /**\n   * The entry point to Aether, i.e. the component doing all the work.\n   * \n   */\n  @Component\n  private RepositorySystem repository;\n  /**\n   * The current repository/network configuration of Maven.\n   */\n  @Parameter(defaultValue = \"${repositorySystemSession}\", required = true, readonly = true)\n  private RepositorySystemSession session;\n  private Pattern range = Pattern.compile(\"\\\\[[0-9.\\\\-A-Za-z]+\\\\s*(,\\\\s*([0-9.\\\\-A-Za-z]+)?)\\\\)\");\n  /**\n   * The project's remote repositories to use for the resolution.\n   */\n  @Parameter(defaultValue = \"${project.remoteProjectRepositories}\", required = true, readonly = true)\n  private List<RemoteRepository> repositories;\n  @Parameter(defaultValue = \"false\")\n  private Boolean includeSnapshots = false;\n  @Parameter(defaultValue = \"false\")\n  private Boolean updateProperties = false;\n  @Parameter(defaultValue = \"false\")\n  private Boolean failImmediately = false;\n  /**\n   * The line separator used when rewriting the pom, this to defaults to your platform encoding but if you fix your encoding despite\n   * platform then you should use that.\n   */\n  @Parameter\n  private LineSeparator lineSeparator = LineSeparator.defaultValue();\n  Matcher matchVersion(String version) {\n    return range.matcher(version);\n  }\n  /**\n   * If bounds should be updated when there is no upgrade, useful for doing cascaded upgrades while minimising deltas\n   */\n  @Parameter()\n  private boolean acceptMinorVersionChanges = false;\n  Changes change = new Changes();\n  @Override\n  public void execute() throws MojoExecutionException {\n    Document pom = load();\n    change.acceptMinorVersionChanges(acceptMinorVersionChanges);\n    processProperties(pom);\n    processDependencies(pom);\n    processDependencyManagement(pom);\n    if (change.changed()) {\n      if (change.upgraded())\n        bumpMajorVersion(pom);\n      writeChanges(pom);\n    }\n  }\n  void bumpMajorVersion(Document pom) throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes project = pom.query(\"/mvn:project\", context);\n    if (project.size() == 0)\n      throw new MojoExecutionException(\"Pom is broken\");\n    Nodes nodes = pom.query(\"/mvn:project/mvn:version\", context);\n    if (nodes.size() != 1)\n      throw new MojoExecutionException(\"Version is not declared correctly\");\n    Element e = (Element) nodes.get(0);\n    String[] components = e.getValue().split(\"\\\\.\");\n    components[0] = Integer.toString(Integer.valueOf(components[0]) + 1);\n    String bumpedVersion = String.join(\".\", components);\n    Element newVersion = new Element(\"version\", \"http://maven.apache.org/POM/4.0.0\");\n    newVersion.appendChild(bumpedVersion);\n    ((Element) project.get(0)).replaceChild(e, newVersion);\n    // TODO check that the next version does not already exist\n  }\n  private void processDependencyManagement(Document pom)\n      throws MojoExecutionException {\n    if (project.getDependencyManagement() != null) {\n      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {\n        try {\n          String version = dependency.getVersion();\n          Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());\n          if (change.change(artifact.getVersion(), version)) {\n            updateDependencyManagement(pom, artifact, artifact.getVersion());\n          }\n        }\n        catch (MojoExecutionException e) {\n          fail(e);\n        }\n      }\n    }\n  }\n  private void processDependencies(Document pom)\n      throws MojoExecutionException {\n    for (Dependency dependency : project.getDependencies()) {\n      try {\n        String version = dependency.getVersion();\n        Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());\n        if (change.change(artifact.getVersion(), version)) {\n          updateDependency(pom, artifact, version);\n        }\n      }\n      catch (MojoExecutionException e) {\n        fail(e);\n      }\n    }\n  }\n  private void processProperties(Document pom)\n      throws MojoExecutionException {\n    for (String propertyName : project.getProperties().stringPropertyNames()) {\n      if (propertyName.endsWith(\".version\")) {\n        try {\n          final String version = project.getProperties().getProperty(propertyName);\n          Dependency dependency = findDependencyUsingVersionProperty(propertyName);\n          if (dependency != null) {\n            Artifact artifact = resolveLatestVersionRange(dependency, version);\n            if (change.change(artifact.getVersion(), version)) {\n              updateProperty(pom, propertyName, artifact.getVersion());\n            }\n          }\n          else {\n            getLog().warn(\"No dependency found using \" + propertyName);\n          }\n        }\n        catch (MojoExecutionException e) {\n          fail(e);\n        }\n      }\n    }\n  }\n  private void fail(MojoExecutionException e) throws MojoExecutionException {\n    if (!failImmediately) {\n      getLog().warn(e.getMessage());\n    }\n    else {\n      throw e;\n    }\n  }\n  Artifact resolveLatestVersionRange(Dependency dependency, String version) throws MojoExecutionException {\n    Matcher versionMatch = matchVersion(version);\n    if (versionMatch.matches()) {\n      Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),\n        dependency.getClassifier(), dependency.getType(), version.replaceFirst(versionMatch.group(1), \",\"));\n      Version highestVersion = highestVersion(artifact);\n      String newVersion = \"[\" + highestVersion.toString() + \",\" + majorVersionPlusOne(highestVersion) + \")\";\n      return artifact.setVersion(newVersion);\n    }\n    else {\n      return new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),\n        dependency.getClassifier(), dependency.getType(), version);\n    }\n  }\n  private Integer majorVersionPlusOne(Version highestVersion) {\n    String[] split = highestVersion.toString().split(\"\\\\.\");\n    return Integer.valueOf(split[0]) + 1;\n  }\n  private Dependency findDependencyUsingVersionProperty(String propertyName) {\n    for (Dependency dependency : project.getDependencies()) {\n      if (propertyName.equals(dependency.getArtifactId() + \".version\")) {\n        getLog()\n          .warn(\n            \"If you use dependency composition then you will find that version properties \"\n              + \"are really not that useful. Its an extra indirection that often you don't need. \"\n              + \"IMO people take the magic number refactoring too far\");\n        return dependency;\n      }\n    }\n    if (project.getDependencyManagement() != null) {\n      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {\n        if (propertyName.equals(dependency.getArtifactId() + \".version\")) {\n          getLog()\n            .warn(\n              \"Dependency Management is an anti pattern, think OO or functional, \"\n                + \"dependencies should be composed NOT inherited\");\n          return dependency;\n        }\n      }\n    }\n    return null;\n  }\n  private void writeChanges(Document pom) {\n    Serializer serializer = createSerialiser();\n    try {\n      serializer.write(pom);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private Serializer createSerialiser() {\n    try {\n      Serializer serializer = new StickySerializer(new FileOutputStream(project.getFile()), \"UTF-8\");\n      if (!System.lineSeparator().equals(lineSeparator.value()))\n        getLog().info(String.format(\"The line separator is configured to %s, not using system line separator\", lineSeparator));\n      serializer.setLineSeparator(lineSeparator.value());\n      return serializer;\n    }\n    catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n    catch (FileNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  protected Version highestVersion(Artifact artifact) throws MojoExecutionException {\n    VersionRangeRequest request = new VersionRangeRequest(artifact, repositories, null);\n    VersionRangeResult v = resolve(request);\n    if (!includeSnapshots) {\n      List<Version> filtered = new ArrayList<Version>();\n      for (Version aVersion : v.getVersions()) {\n        if (!aVersion.toString().endsWith(\"SNAPSHOT\")) {\n          filtered.add(aVersion);\n        }\n      }\n      v.setVersions(filtered);\n    }\n    if (v.getHighestVersion() == null) {\n      throw (v.getExceptions().isEmpty())\n        ? new MojoExecutionException(\"Failed to resolve \" + artifact.toString())\n        : new MojoExecutionException(\"Failed to resolve \" + artifact.toString(), v.getExceptions().get(0));\n    }\n    return v.getHighestVersion();\n  }\n  void updateProperty(Document pom, String propertyName, String newVersion) throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes nodes = pom.query(\"//mvn:properties\", context);\n    if (nodes.size() > 0) {\n      final Element propertiesElement = (Element) nodes.get(0);\n      Elements properties = propertiesElement.getChildElements();\n      for (int i = 0; i < properties.size(); i++) {\n        Element property = properties.get(i);\n        if (property.getLocalName().equals(propertyName)) {\n          Element newRange = new Element(propertyName, \"http://maven.apache.org/POM/4.0.0\");\n          newRange.appendChild(newVersion);\n          propertiesElement.replaceChild(property, newRange);\n        }\n      }\n    }\n  }\n  void updateDependency(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {\n    updateDependency(pom, dependencyPath(artifact.getArtifactId()), oldVersion, artifact);\n  }\n  void updateDependencyManagement(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {\n    updateDependency(pom, dependencyManagementPath(artifact.getArtifactId()), oldVersion, artifact);\n  }\n  private void updateDependency(Document pom, String dependencyPath, String oldVersion, Artifact artifact)\n      throws MojoExecutionException {\n    XPathContext context = new XPathContext(\"mvn\", \"http://maven.apache.org/POM/4.0.0\");\n    Nodes nodes = pom.query(dependencyPath, context);\n    if (nodes.size() == 0) {\n      throw new MojoExecutionException(String.format(\"Missing <dependency> element for dependency %s, skipping.\",\n        artifact.getArtifactId()));\n    }\n    for (int i = 0; i < nodes.size(); i++) {\n      Node node = nodes.get(i);\n      ParentNode dependency = node.getParent();\n      Nodes classifier = dependency.query(\"mvn:classifier\", context);\n      if (classifier.size() != 0)\n        if (!classifier.get(0).getValue().equals(artifact.getClassifier()))\n          return;\n      final Nodes versionNodes = dependency.query(\"mvn:version\", context);\n      if (versionNodes.size() > 0) {\n        getLog().info(\"Upgrading dependency to \" + artifact.toString() + \" from \" + oldVersion);\n        Element version = (Element) versionNodes.get(0);\n        if (!version.getValue().startsWith(\"${\") || updateProperties) {\n          Element newRange = new Element(\"version\", \"http://maven.apache.org/POM/4.0.0\");\n          newRange.appendChild(artifact.getVersion());\n          dependency.replaceChild(version, newRange);\n        }\n      }\n      else {\n        throw new MojoExecutionException(String.format(\"Missing <version> element for dependency %s, skipping.\",\n          artifact.getArtifactId()));\n      }\n    }\n  }\n  private String dependencyPath(String artifactId) {\n    return \"//mvn:dependencies/mvn:dependency/mvn:artifactId[text()='\" + artifactId + \"']\";\n  }\n  private String dependencyManagementPath(String artifactId) {\n    return \"//mvn:dependencyManagement/mvn:dependencies/mvn:dependency/mvn:artifactId[text()='\" + artifactId + \"']\";\n  }\n  private Document load() {\n    try {\n      return new Builder().build(project.getFile());\n    }\n    catch (ValidityException e) {\n      throw new RuntimeException(e);\n    }\n    catch (ParsingException e) {\n      throw new RuntimeException(e);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private VersionRangeResult resolve(VersionRangeRequest request) {\n    try {\n      return repository.resolveVersionRange(session, request);\n    }\n    catch (VersionRangeResolutionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"]], "pred": {"ppl": 2.3954100608825684, "ppl_lower": 2.9329473972320557, "ppl/lowercase_ppl": -1.2317582237608082, "ppl/zlib": 0.0002822469892106671, "Min_5.0% Prob": 7.178446751014859, "Min_10.0% Prob": 5.612951781235489, "Min_20.0% Prob": 3.847630856668248, "Min_30.0% Prob": 2.8187907310872298, "Min_40.0% Prob": 2.1636345312727983, "Min_50.0% Prob": 1.743899284211332, "Min_60.0% Prob": 1.45674361076759}}
{"hexsha": "3b1f08a76ee36b53daeaae12d968617916543204", "ext": "java", "lang": "Java", "content": "public class Prefix extends Affix<String> {\n\n    public Prefix() {\n        super();\n    }\n\n    public Prefix(List<String> actions) {\n        super(actions);\n    }\n\n    public Prefix(Affix<String> affix) {\n        super(affix);\n    }\n\n    public Prefix(Prefix other) { super(other);}\n\n    /**\n     * @param action a string under analysis\n     * @param prefix a prefix\n     * @param actions the sequence of actions\n     * @return true if given action is coherent with the given prefix and the sequence, false\n     * otherwise\n     */\n    public static boolean checkActionCoherency(String action, List<String> actions,\n                                                  Prefix prefix) {\n        // FIXME: do not use sting comparison with join!\n        //return (prefix!=null) && StringUtils.join(actions, \"\").startsWith(\n        //        StringUtils.join(prefix.toList(), \"\") + action);\n\n        Prefix tmpPref = new Prefix(prefix);\n        tmpPref.add(action);\n        return (prefix!=null) && Collections.indexOfSubList(actions, tmpPref.toList())==0;\n\n\n\n    }\n    // TODO: produce new methods which is not static (I think Prefix can be this, instead of a\n    // parameter)\n}", "class_id": 0, "repo": "gbarbon/clear", "file": "clear_tagged_lts_computer/src/clear_analyser/affix/Prefix.java", "last_update_at": "2018-05-09T14:52:02+00:00", "question_id": "3b1f08a76ee36b53daeaae12d968617916543204", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Prefix extends Affix<String> {\n    public Prefix() {\n        super();\n    }\n    public Prefix(List<String> actions) {\n        super(actions);\n    }\n    public Prefix(Affix<String> affix) {\n        super(affix);\n    }\n    public Prefix(Prefix other) { super(other);}\n    /**\n     * @param action a string under analysis\n     * @param prefix a prefix\n     * @param actions the sequence of actions\n     * @return true if given action is coherent with the given prefix and the sequence, false\n     * otherwise\n     */\n    public static boolean checkActionCoherency(String action, List<String> actions,\n                                                  Prefix prefix) {\n        // FIXME: do not use sting comparison with join!\n        //return (prefix!=null) && StringUtils.join(actions, \"\").startsWith(\n        //        StringUtils.join(prefix.toList(), \"\") + action);\n        Prefix tmpPref = new Prefix(prefix);\n        tmpPref.add(action);\n        return (prefix!=null) && Collections.indexOfSubList(actions, tmpPref.toList())==0;\n    }\n    // TODO: produce new methods which is not static (I think Prefix can be this, instead of a\n    // parameter)\n"]], "pred": {"ppl": 3.72588849067688, "ppl_lower": 4.748961925506592, "ppl/lowercase_ppl": -1.184459607667813, "ppl/zlib": 0.002667962158979709, "Min_5.0% Prob": 7.691144645214081, "Min_10.0% Prob": 6.422568306326866, "Min_20.0% Prob": 4.963497381943923, "Min_30.0% Prob": 3.957204883195916, "Min_40.0% Prob": 3.178456049839049, "Min_50.0% Prob": 2.60352179353557, "Min_60.0% Prob": 2.18714821964578}}
{"hexsha": "a81b80b6816be37cc18949c1f01cbf7ab1925db6", "ext": "java", "lang": "Java", "content": "@SideOnly(Side.CLIENT)\n@Mod.EventBusSubscriber(value = Side.CLIENT, modid = ArcaneConstants.MODID)\npublic class ClientEvents\n{\n\t@SubscribeEvent\n\tpublic static void onClientTick(TickEvent.ClientTickEvent event)\n\t{\n\t\tMinecraft mc = Minecraft.getMinecraft();\n\t\tEntityPlayer player = mc.player;\n\n\t\tif(mc.world == null || mc.player == null)\n\t\t\treturn;\n\n\t\tif(KeyBindings.keySpellbook.isPressed())\n\t\t\tmc.displayGuiScreen(new GuiSpellBook());\n\n\t\tPlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);\n\t\tSpell sp = data.getSelectedSpells()[data.getSelectedIndex()];\n\t\tif(sp != null)\n\t\t{\n\t\t\tClientUtil.getMouseOverExtended(sp.getSpellReach());\n\t\t}\n\t\tint maxDawTime = 5000;\n\t\tif(KeyBindings.keyCastSpell.isPressed())\n\t\t{\n\t\t\tif(sp != null && !data.isHoldingCast())\n\t\t\t{\n\t\t\t\tSpellUtil.castSpellPress(sp, player);\n\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastSpell(sp.getRegistryName().toString()));\n\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\t\telse if(KeyBindings.keyCastSpell.isKeyDown())\n\t\t{\n\t\t\tif(sp != null)\n\t\t\t{\n\t\t\t\tif(data.getHoldTime() == -1)\n\t\t\t\t\tdata.setHoldTime(mc.world.getWorldTime());\n\n\t\t\t\tif(!data.isHoldingCast())\n\t\t\t\t{\n\t\t\t\t\tdata.setHoldingCast(true);\n\t\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastHold(sp.getRegistryName().toString()));\n\t\t\t\t}\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\n\t\tif(data.isHoldingCast() && !KeyBindings.keyCastSpell.isKeyDown())\n\t\t{\n\t\t\tif(sp != null)\n\t\t\t{\n\t\t\t\tif(data.getHoldTime() == -1)\n\t\t\t\t{\n\t\t\t\t\tdata.setHoldTime(-1);\n\t\t\t\t\tdata.setHoldingCast(false);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong holdTime = mc.player.getEntityWorld().getTotalWorldTime() -  data.getHoldTime();\n\t\t\t\tSpellUtil.castSpellHoldRelease(sp, player, holdTime);\n\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastRelease(sp.getRegistryName().toString()));\n\t\t\t\tdata.setHoldTime(-1);\n\t\t\t\tdata.setHoldingCast(false);\n\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\t}\n\n\t@SubscribeEvent\n\tpublic static void onTextureStitchPre(TextureStitchEvent.Pre event)\n\t{\n\t\tfor(Spell sp : SpellRegistry.SPELL_REGISTRY.getValues())\n\t\t{\n\t\t\tif(sp.getIconType() == Spell.IconType.TEXTURE)\n\t\t\t{\n\t\t\t\tTextureAtlasSprite spr = event.getMap().registerSprite(sp.getIconTexture());\n\t\t\t\tsp.setAtlasSprite(spr);\n\t\t\t}\n\t\t}\n\t}\n\n\t@SubscribeEvent\n\tpublic static void onHandRender(RenderHandEvent event)\n\t{\n\t\tPlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);\n\n\t\tboolean showTime = Minecraft.getMinecraft().world.getTotalWorldTime() - data.getHoldTime() >= 2;\n\t\tif(data.isHoldingCast() && Minecraft.getMinecraft().gameSettings.thirdPersonView == 0 && !Minecraft.getMinecraft().gameSettings.hideGUI && showTime)\n\t\t{\n\t\t\tevent.setCanceled(true);\n\t\t\tMinecraft mc = Minecraft.getMinecraft();\n\t\t\tAbstractClientPlayer pla = mc.player;\n\n\t\t\tfloat e = (float) (((Math.sin((mc.world.getTotalWorldTime()) / 2) * (Math.PI / 20)))) - mc.player.swingProgress;\n\t\t\tmc.getItemRenderer().renderItemInFirstPerson(pla, event.getPartialTicks(), 0, EnumHand.MAIN_HAND, 0, ItemStack.EMPTY, e);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "Lemonszz/Arcane", "file": "src/main/java/party/lemons/arcane/client/ClientEvents.java", "last_update_at": "2018-04-05T03:18:40+00:00", "question_id": "a81b80b6816be37cc18949c1f01cbf7ab1925db6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SideOnly(Side.CLIENT)\n@Mod.EventBusSubscriber(value = Side.CLIENT, modid = ArcaneConstants.MODID)\npublic class ClientEvents\n{\n\t@SubscribeEvent\n\tpublic static void onClientTick(TickEvent.ClientTickEvent event)\n\t{\n\t\tMinecraft mc = Minecraft.getMinecraft();\n\t\tEntityPlayer player = mc.player;\n\t\tif(mc.world == null || mc.player == null)\n\t\t\treturn;\n\t\tif(KeyBindings.keySpellbook.isPressed())\n\t\t\tmc.displayGuiScreen(new GuiSpellBook());\n\t\tPlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);\n\t\tSpell sp = data.getSelectedSpells()[data.getSelectedIndex()];\n\t\tif(sp != null)\n\t\t{\n\t\t\tClientUtil.getMouseOverExtended(sp.getSpellReach());\n\t\t}\n\t\tint maxDawTime = 5000;\n\t\tif(KeyBindings.keyCastSpell.isPressed())\n\t\t{\n\t\t\tif(sp != null && !data.isHoldingCast())\n\t\t\t{\n\t\t\t\tSpellUtil.castSpellPress(sp, player);\n\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastSpell(sp.getRegistryName().toString()));\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\t\telse if(KeyBindings.keyCastSpell.isKeyDown())\n\t\t{\n\t\t\tif(sp != null)\n\t\t\t{\n\t\t\t\tif(data.getHoldTime() == -1)\n\t\t\t\t\tdata.setHoldTime(mc.world.getWorldTime());\n\t\t\t\tif(!data.isHoldingCast())\n\t\t\t\t{\n\t\t\t\t\tdata.setHoldingCast(true);\n\t\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastHold(sp.getRegistryName().toString()));\n\t\t\t\t}\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\t\tif(data.isHoldingCast() && !KeyBindings.keyCastSpell.isKeyDown())\n\t\t{\n\t\t\tif(sp != null)\n\t\t\t{\n\t\t\t\tif(data.getHoldTime() == -1)\n\t\t\t\t{\n\t\t\t\t\tdata.setHoldTime(-1);\n\t\t\t\t\tdata.setHoldingCast(false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlong holdTime = mc.player.getEntityWorld().getTotalWorldTime() -  data.getHoldTime();\n\t\t\t\tSpellUtil.castSpellHoldRelease(sp, player, holdTime);\n\t\t\t\tArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastRelease(sp.getRegistryName().toString()));\n\t\t\t\tdata.setHoldTime(-1);\n\t\t\t\tdata.setHoldingCast(false);\n\t\t\t\tGuiManaBar.drawTime = maxDawTime;\n\t\t\t}\n\t\t}\n\t}\n\t@SubscribeEvent\n\tpublic static void onTextureStitchPre(TextureStitchEvent.Pre event)\n\t{\n\t\tfor(Spell sp : SpellRegistry.SPELL_REGISTRY.getValues())\n\t\t{\n\t\t\tif(sp.getIconType() == Spell.IconType.TEXTURE)\n\t\t\t{\n\t\t\t\tTextureAtlasSprite spr = event.getMap().registerSprite(sp.getIconTexture());\n\t\t\t\tsp.setAtlasSprite(spr);\n\t\t\t}\n\t\t}\n\t}\n\t@SubscribeEvent\n\tpublic static void onHandRender(RenderHandEvent event)\n\t{\n\t\tPlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);\n\t\tboolean showTime = Minecraft.getMinecraft().world.getTotalWorldTime() - data.getHoldTime() >= 2;\n\t\tif(data.isHoldingCast() && Minecraft.getMinecraft().gameSettings.thirdPersonView == 0 && !Minecraft.getMinecraft().gameSettings.hideGUI && showTime)\n\t\t{\n\t\t\tevent.setCanceled(true);\n\t\t\tMinecraft mc = Minecraft.getMinecraft();\n\t\t\tAbstractClientPlayer pla = mc.player;\n\t\t\tfloat e = (float) (((Math.sin((mc.world.getTotalWorldTime()) / 2) * (Math.PI / 20)))) - mc.player.swingProgress;\n\t\t\tmc.getItemRenderer().renderItemInFirstPerson(pla, event.getPartialTicks(), 0, EnumHand.MAIN_HAND, 0, ItemStack.EMPTY, e);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.731123924255371, "ppl_lower": 2.2046947479248047, "ppl/lowercase_ppl": -1.4406542215685736, "ppl/zlib": 0.000502077643885586, "Min_5.0% Prob": 5.732774972915649, "Min_10.0% Prob": 4.1082887579413025, "Min_20.0% Prob": 2.543618985543064, "Min_30.0% Prob": 1.792349136878852, "Min_40.0% Prob": 1.3638810459478852, "Min_50.0% Prob": 1.0968635327559977, "Min_60.0% Prob": 0.9154377887682567}}
{"hexsha": "ca033ea684f884699068a8548cc52f08bd2e8ff2", "ext": "java", "lang": "Java", "content": "public class TestAbstractDeserializer extends AbstractDeserializer {\n\n  private AbstractDeserializer abstractDeserializer = null;\n\n  private JsonParser jsonParser = Mockito.mock(JsonParser.class);\n\n  static ReaderHelpData readerHelpData = Mockito.mock(ReaderHelpData.class);\n\n  static Map<String, ReaderHelpData> readerHelpDataMap = new HashMap<>();\n\n  public static void setReaderHelpDataMap(Map<String, ReaderHelpData> readerHelpDataMap) {\n    TestAbstractDeserializer.readerHelpDataMap = readerHelpDataMap;\n    readerHelpDataMap.put(\"abc\", readerHelpData);\n    readerHelpDataMap.put(\"null\", readerHelpData);\n  }\n\n  static {\n    TestAbstractDeserializer.setReaderHelpDataMap(readerHelpDataMap);\n  }\n\n  public TestAbstractDeserializer() {\n    super(readerHelpDataMap);\n  }\n\n  @Before\n  public void setUp() throws Exception {\n    abstractDeserializer = new TestAbstractDeserializer();\n  }\n\n  @After\n  public void tearDown() throws Exception {\n    abstractDeserializer = null;\n    jsonParser = null;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testDeserialize() {\n    boolean status = false;\n    try {\n      DeserializationContext ctxt = Mockito.mock(DeserializationContext.class);\n      @SuppressWarnings(\"rawtypes\")\n      JsonDeserializer JsonDeserializer = Mockito.mock(JsonDeserializer.class);\n      Object object = null;\n      Mockito.when(jsonParser.nextFieldName()).thenReturn(\"abc\", (String) null);\n      Mockito.when(readerHelpData.getDeser()).thenReturn(JsonDeserializer);\n      Mockito.when(JsonDeserializer.deserialize(jsonParser, ctxt)).thenReturn(object);\n      Object deserializeObject = abstractDeserializer.deserialize(jsonParser, ctxt);\n      Assert.assertNotNull(deserializeObject);\n    } catch (Exception e) {\n      status = true;\n    }\n    Assert.assertFalse(status);\n  }\n\n  @Override\n  protected Object createResult() {\n    return null;\n  }\n\n  @Override\n  protected Object updateResult(Object result, Object value, ReaderHelpData helpData) {\n    /* Do not worry, overridden method*/\n    try {\n      Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_NULL);\n    } catch (Exception e) {\n    }\n    return new Object();\n  }\n}", "class_id": 0, "repo": "xuyiyun0929/incubator-servicecomb-java-chassis", "file": "common/common-protobuf/src/test/java/org/apache/servicecomb/codec/protobuf/jackson/TestAbstractDeserializer.java", "last_update_at": "2018-08-07T08:29:34+00:00", "question_id": "ca033ea684f884699068a8548cc52f08bd2e8ff2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestAbstractDeserializer extends AbstractDeserializer {\n  private AbstractDeserializer abstractDeserializer = null;\n  private JsonParser jsonParser = Mockito.mock(JsonParser.class);\n  static ReaderHelpData readerHelpData = Mockito.mock(ReaderHelpData.class);\n  static Map<String, ReaderHelpData> readerHelpDataMap = new HashMap<>();\n  public static void setReaderHelpDataMap(Map<String, ReaderHelpData> readerHelpDataMap) {\n    TestAbstractDeserializer.readerHelpDataMap = readerHelpDataMap;\n    readerHelpDataMap.put(\"abc\", readerHelpData);\n    readerHelpDataMap.put(\"null\", readerHelpData);\n  }\n  static {\n    TestAbstractDeserializer.setReaderHelpDataMap(readerHelpDataMap);\n  }\n  public TestAbstractDeserializer() {\n    super(readerHelpDataMap);\n  }\n  @Before\n  public void setUp() throws Exception {\n    abstractDeserializer = new TestAbstractDeserializer();\n  }\n  @After\n  public void tearDown() throws Exception {\n    abstractDeserializer = null;\n    jsonParser = null;\n  }\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testDeserialize() {\n    boolean status = false;\n    try {\n      DeserializationContext ctxt = Mockito.mock(DeserializationContext.class);\n      @SuppressWarnings(\"rawtypes\")\n      JsonDeserializer JsonDeserializer = Mockito.mock(JsonDeserializer.class);\n      Object object = null;\n      Mockito.when(jsonParser.nextFieldName()).thenReturn(\"abc\", (String) null);\n      Mockito.when(readerHelpData.getDeser()).thenReturn(JsonDeserializer);\n      Mockito.when(JsonDeserializer.deserialize(jsonParser, ctxt)).thenReturn(object);\n      Object deserializeObject = abstractDeserializer.deserialize(jsonParser, ctxt);\n      Assert.assertNotNull(deserializeObject);\n    } catch (Exception e) {\n      status = true;\n    }\n    Assert.assertFalse(status);\n  }\n  @Override\n  protected Object createResult() {\n    return null;\n  }\n  @Override\n  protected Object updateResult(Object result, Object value, ReaderHelpData helpData) {\n    /* Do not worry, overridden method*/\n    try {\n      Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_NULL);\n    } catch (Exception e) {\n    }\n    return new Object();\n  }\n"]], "pred": {"ppl": 1.8303059339523315, "ppl_lower": 2.004136800765991, "ppl/lowercase_ppl": -1.1500956939170666, "ppl/zlib": 0.0009117392607902569, "Min_5.0% Prob": 6.372752167284489, "Min_10.0% Prob": 4.522511133780847, "Min_20.0% Prob": 2.819452144549443, "Min_30.0% Prob": 1.9767310552107982, "Min_40.0% Prob": 1.5059505207320818, "Min_50.0% Prob": 1.2067147145659143, "Min_60.0% Prob": 1.0074662366248381}}
{"hexsha": "9987969a732df10b6c93795bbedeb7c2832caf4f", "ext": "java", "lang": "Java", "content": "public class OrderableRepository extends BaseRepository {\n\n    public static final String TAG = OrderableRepository.class.getName();\n    public static final String ORDERABLE_TABLE = \"orderables\";\n    public static final String ID = \"id\";\n    public static final String FULL_PRODUCT_CODE = \"full_product_code\";\n    public static final String FULL_PRODUCT_NAME = \"full_product_name\";\n    public static final String NET_CONTENT = \"net_content\";\n    public static final String PACK_ROUNDING_THRESHOLD = \"pack_rounding_threshold\";\n    public static final String ROUND_TO_ZERO = \"round_to_zero\";\n    public static final String DISPENSABLE_ID = \"dispensable_id\";\n    public static final String TRADE_ITEM_ID = \"trade_item_id\";\n    public static final String COMMODITY_TYPE_ID = \"commodity_type_id\";\n    public static final String DATE_UPDATED = \"date_updated\";\n\n    public static final String[] ORDERABLE_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT,\n            PACK_ROUNDING_THRESHOLD, ROUND_TO_ZERO, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID, DATE_UPDATED};\n    public static final String[] SELECT_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID};\n\n    public static final String CREATE_ORDERABLE_TABLE =\n\n            \"CREATE TABLE \" + ORDERABLE_TABLE\n                    + \"(\"\n                    + ID + \" VARCHAR NOT NULL PRIMARY KEY,\"\n                    + FULL_PRODUCT_CODE + \" VARCHAR NOT NULL,\"\n                    + FULL_PRODUCT_NAME + \" VARCHAR NOT NULL,\"\n                    + NET_CONTENT + \" INTEGER,\"\n                    + PACK_ROUNDING_THRESHOLD + \" INTEGER,\"\n                    + ROUND_TO_ZERO + \" TINYINT,\"\n                    + DISPENSABLE_ID + \" VARCHAR,\"\n                    + TRADE_ITEM_ID + \" VARCHAR,\"\n                    + COMMODITY_TYPE_ID + \" VARCHAR,\"\n                    + DATE_UPDATED + \" INTEGER\"\n                    + \")\";\n\n    private static final String CREATE_ORDERABLES_INDEX = \"CREATE INDEX \"\n            + ORDERABLE_TABLE + \"_INDEX ON \"\n            + ORDERABLE_TABLE + \"(\" + COMMODITY_TYPE_ID + \",\" + TRADE_ITEM_ID + \")\";\n\n    public OrderableRepository(Repository repository) {\n        super();\n    }\n\n    public static void createTable(SQLiteDatabase database) {\n        database.execSQL(CREATE_ORDERABLE_TABLE);\n        database.execSQL(CREATE_ORDERABLES_INDEX);\n    }\n\n    public void addOrUpdate(Orderable orderable) {\n\n        if (orderable == null) {\n            return;\n        }\n\n        if (orderable.getDateUpdated() == null) {\n            orderable.setDateUpdated(Calendar.getInstance().getTimeInMillis());\n        }\n\n        try {\n            SQLiteDatabase database = getWritableDatabase();\n\n            String query = String.format(INSERT_OR_REPLACE, ORDERABLE_TABLE);\n            query += \"(\" + StringUtils.repeat(\"?\", \",\", ORDERABLE_TABLE_COLUMNS.length) + \")\";\n            database.execSQL(query, createQueryValues(orderable));\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        }\n    }\n\n    public List<Orderable> findOrderables(String id, String fullProductCode, String fullProductName, String netContent, String dispensable, String tradeItemId, String commodityTypeId) {\n\n        List<Orderable> orderables = new ArrayList<>();\n        Cursor cursor = null;\n        try {\n\n            String[] selectionArgs = new String[]{id, fullProductCode, fullProductName, netContent, dispensable, tradeItemId, commodityTypeId};\n            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);\n\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);\n            orderables = readOrderables(cursor);\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderables;\n    }\n\n    public Orderable findOrderable(String id) {\n\n        Orderable orderable = null;\n        Cursor cursor = null;\n        try {\n            String[] selectionArgs = new String[]{id};\n            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);\n\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);\n            List<Orderable> orderables = readOrderables(cursor);\n            if (orderables.size() > 0) {\n                orderable = orderables.get(0);\n            }\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderable;\n    }\n\n    public String findOrderableIdByTradeItemId(String tradeItemId) {\n        Cursor cursor = null;\n        try {\n            String[] selectionArgs = new String[]{tradeItemId};\n            Pair<String, String[]> query = createQuery(selectionArgs, new String[]{TRADE_ITEM_ID});\n\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, new String[]{ID}, querySelectString, selectionArgs, null, null, null);\n            if (cursor.moveToFirst())\n                return cursor.getString(0);\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return null;\n    }\n\n\n    private List<Orderable> readOrderables(Cursor cursor) {\n\n        List<Orderable> orderables = new ArrayList<>();\n        try {\n            if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {\n                while (!cursor.isAfterLast()) {\n                    orderables.add(createOrderable(cursor));\n                    cursor.moveToNext();\n                }\n            }\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderables;\n    }\n\n    private Orderable createOrderable(Cursor cursor) {\n\n        return new Orderable(\n                cursor.getString(cursor.getColumnIndex(ID)),\n                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_CODE)),\n                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_NAME)),\n                cursor.getLong(cursor.getColumnIndex(NET_CONTENT)),\n                cursor.getLong(cursor.getColumnIndex(PACK_ROUNDING_THRESHOLD)),\n                convertIntToBoolean(cursor.getInt(cursor.getColumnIndex(ROUND_TO_ZERO))),\n                cursor.getString(cursor.getColumnIndex(DISPENSABLE_ID)),\n                cursor.getString(cursor.getColumnIndex(TRADE_ITEM_ID)),\n                cursor.getString(cursor.getColumnIndex(COMMODITY_TYPE_ID))\n        );\n    }\n\n    private Object[] createQueryValues(Orderable orderable) {\n\n        Object[] values = new Object[]{\n                orderable.getId(),\n                orderable.getFullProductCode(),\n                orderable.getFullProductName(),\n                orderable.getNetContent(),\n                orderable.getPackRoundingThreshold(),\n                convertBooleanToInt(orderable.isRoundToZero()),\n                orderable.getDispensableId(),\n                orderable.getTradeItemId(),\n                orderable.getCommodityTypeId(),\n                orderable.getDateUpdated()\n        };\n        return values;\n    }\n\n\n}", "class_id": 0, "repo": "opensrp/opensrp-client-stock", "file": "openlmis-stock/src/main/java/org/smartregister/stock/openlmis/repository/openlmis/OrderableRepository.java", "last_update_at": "2018-11-05T18:14:37+00:00", "question_id": "9987969a732df10b6c93795bbedeb7c2832caf4f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OrderableRepository extends BaseRepository {\n    public static final String TAG = OrderableRepository.class.getName();\n    public static final String ORDERABLE_TABLE = \"orderables\";\n    public static final String ID = \"id\";\n    public static final String FULL_PRODUCT_CODE = \"full_product_code\";\n    public static final String FULL_PRODUCT_NAME = \"full_product_name\";\n    public static final String NET_CONTENT = \"net_content\";\n    public static final String PACK_ROUNDING_THRESHOLD = \"pack_rounding_threshold\";\n    public static final String ROUND_TO_ZERO = \"round_to_zero\";\n    public static final String DISPENSABLE_ID = \"dispensable_id\";\n    public static final String TRADE_ITEM_ID = \"trade_item_id\";\n    public static final String COMMODITY_TYPE_ID = \"commodity_type_id\";\n    public static final String DATE_UPDATED = \"date_updated\";\n    public static final String[] ORDERABLE_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT,\n            PACK_ROUNDING_THRESHOLD, ROUND_TO_ZERO, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID, DATE_UPDATED};\n    public static final String[] SELECT_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID};\n    public static final String CREATE_ORDERABLE_TABLE =\n            \"CREATE TABLE \" + ORDERABLE_TABLE\n                    + \"(\"\n                    + ID + \" VARCHAR NOT NULL PRIMARY KEY,\"\n                    + FULL_PRODUCT_CODE + \" VARCHAR NOT NULL,\"\n                    + FULL_PRODUCT_NAME + \" VARCHAR NOT NULL,\"\n                    + NET_CONTENT + \" INTEGER,\"\n                    + PACK_ROUNDING_THRESHOLD + \" INTEGER,\"\n                    + ROUND_TO_ZERO + \" TINYINT,\"\n                    + DISPENSABLE_ID + \" VARCHAR,\"\n                    + TRADE_ITEM_ID + \" VARCHAR,\"\n                    + COMMODITY_TYPE_ID + \" VARCHAR,\"\n                    + DATE_UPDATED + \" INTEGER\"\n                    + \")\";\n    private static final String CREATE_ORDERABLES_INDEX = \"CREATE INDEX \"\n            + ORDERABLE_TABLE + \"_INDEX ON \"\n            + ORDERABLE_TABLE + \"(\" + COMMODITY_TYPE_ID + \",\" + TRADE_ITEM_ID + \")\";\n    public OrderableRepository(Repository repository) {\n        super();\n    }\n    public static void createTable(SQLiteDatabase database) {\n        database.execSQL(CREATE_ORDERABLE_TABLE);\n        database.execSQL(CREATE_ORDERABLES_INDEX);\n    }\n    public void addOrUpdate(Orderable orderable) {\n        if (orderable == null) {\n            return;\n        }\n        if (orderable.getDateUpdated() == null) {\n            orderable.setDateUpdated(Calendar.getInstance().getTimeInMillis());\n        }\n        try {\n            SQLiteDatabase database = getWritableDatabase();\n            String query = String.format(INSERT_OR_REPLACE, ORDERABLE_TABLE);\n            query += \"(\" + StringUtils.repeat(\"?\", \",\", ORDERABLE_TABLE_COLUMNS.length) + \")\";\n            database.execSQL(query, createQueryValues(orderable));\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        }\n    }\n    public List<Orderable> findOrderables(String id, String fullProductCode, String fullProductName, String netContent, String dispensable, String tradeItemId, String commodityTypeId) {\n        List<Orderable> orderables = new ArrayList<>();\n        Cursor cursor = null;\n        try {\n            String[] selectionArgs = new String[]{id, fullProductCode, fullProductName, netContent, dispensable, tradeItemId, commodityTypeId};\n            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);\n            orderables = readOrderables(cursor);\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderables;\n    }\n    public Orderable findOrderable(String id) {\n        Orderable orderable = null;\n        Cursor cursor = null;\n        try {\n            String[] selectionArgs = new String[]{id};\n            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);\n            List<Orderable> orderables = readOrderables(cursor);\n            if (orderables.size() > 0) {\n                orderable = orderables.get(0);\n            }\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderable;\n    }\n    public String findOrderableIdByTradeItemId(String tradeItemId) {\n        Cursor cursor = null;\n        try {\n            String[] selectionArgs = new String[]{tradeItemId};\n            Pair<String, String[]> query = createQuery(selectionArgs, new String[]{TRADE_ITEM_ID});\n            String querySelectString = query.first;\n            selectionArgs = query.second;\n            cursor = getReadableDatabase().query(ORDERABLE_TABLE, new String[]{ID}, querySelectString, selectionArgs, null, null, null);\n            if (cursor.moveToFirst())\n                return cursor.getString(0);\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return null;\n    }\n    private List<Orderable> readOrderables(Cursor cursor) {\n        List<Orderable> orderables = new ArrayList<>();\n        try {\n            if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {\n                while (!cursor.isAfterLast()) {\n                    orderables.add(createOrderable(cursor));\n                    cursor.moveToNext();\n                }\n            }\n        } catch (Exception e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        return orderables;\n    }\n    private Orderable createOrderable(Cursor cursor) {\n        return new Orderable(\n                cursor.getString(cursor.getColumnIndex(ID)),\n                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_CODE)),\n                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_NAME)),\n                cursor.getLong(cursor.getColumnIndex(NET_CONTENT)),\n                cursor.getLong(cursor.getColumnIndex(PACK_ROUNDING_THRESHOLD)),\n                convertIntToBoolean(cursor.getInt(cursor.getColumnIndex(ROUND_TO_ZERO))),\n                cursor.getString(cursor.getColumnIndex(DISPENSABLE_ID)),\n                cursor.getString(cursor.getColumnIndex(TRADE_ITEM_ID)),\n                cursor.getString(cursor.getColumnIndex(COMMODITY_TYPE_ID))\n        );\n    }\n    private Object[] createQueryValues(Orderable orderable) {\n        Object[] values = new Object[]{\n                orderable.getId(),\n                orderable.getFullProductCode(),\n                orderable.getFullProductName(),\n                orderable.getNetContent(),\n                orderable.getPackRoundingThreshold(),\n                convertBooleanToInt(orderable.isRoundToZero()),\n                orderable.getDispensableId(),\n                orderable.getTradeItemId(),\n                orderable.getCommodityTypeId(),\n                orderable.getDateUpdated()\n        };\n        return values;\n    }\n"]], "pred": {"ppl": 1.5205386877059937, "ppl_lower": 1.7851109504699707, "ppl/lowercase_ppl": -1.3827950894221948, "ppl/zlib": 0.0002606123581343171, "Min_5.0% Prob": 4.4571525863572665, "Min_10.0% Prob": 3.221857564122069, "Min_20.0% Prob": 1.9799347186789793, "Min_30.0% Prob": 1.3786376949424057, "Min_40.0% Prob": 1.0433914383513565, "Min_50.0% Prob": 0.8378857452096145, "Min_60.0% Prob": 0.6991126434923094}}
{"hexsha": "26d3e04e94977bd658535c0ae3e8a40dd48604cc", "ext": "java", "lang": "Java", "content": "public class EventStore {\n\n  /** Singleton instance of EventStore. */\n  private static EventStore instance;\n\n  /**\n   * Returns the singleton instance of EventStore that should be shared between all servlet classes.\n   * Do not call this function from a test; use getTestInstance() instead.\n   */\n  public static EventStore getInstance() {\n    if (instance == null) {\n      instance = new EventStore(PersistentStorageAgent.getInstance());\n    }\n    return instance;\n  }\n\n  /**\n   * Instance getter function used for testing. Supply a mock for PersistentStorageAgent.\n   *\n   * @param persistentStorageAgent a mock used for testing\n   */\n  public static EventStore getTestInstance(PersistentStorageAgent persistentStorageAgent) {\n    return new EventStore(persistentStorageAgent);\n  }\n\n  /**\n   * The PersistentStorageAgent responsible for loading Events from and saving Events to Datastore.\n   */\n  private PersistentStorageAgent persistentStorageAgent;\n\n  /** The in-memory list of Events. */\n  private List<Event> events;\n\n  /** This class is a singleton, so its constructor is private. Call getInstance() instead. */\n  private EventStore(PersistentStorageAgent persistentStorageAgent) {\n    this.persistentStorageAgent = persistentStorageAgent;\n    events = new ArrayList<>();\n  }\n\n  /** Access the current set of users known to the application. */\n  public List<Event> getAllEvents() {\n    return events;\n  }\n\n  /**\n   * Access the Event object with the given UUID.\n   *\n   * @return null if the UUID does not match any existing Event.\n   */\n  public Event getEvent(UUID id) {\n    for (Event event : events) {\n      if (event.getId().equals(id)) {\n        return event;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add a new event to the current set of events known to the application. This should only be called\n   * to add a new event, not to update an existing event.\n   */\n  public void addEvent(Event event) {\n    events.add(event);\n    persistentStorageAgent.writeThrough(event);\n  }\n\n  /**\n   * Sets the List of Events stored by this EventStore. This should only be called once, when the data\n   * is loaded from Datastore.\n   */\n  public void setEvents(List<Event> events) {\n    this.events = events;\n  }\n\n  public List<Event> getEventsSince(Instant lastSeen){\n    List<Event> eventsToShow = new ArrayList<Event>();\n        for (Event event: events){\n          Instant eventCreationTime = event.getCreationTime();\n          if(eventCreationTime.isAfter(lastSeen)){\n            eventsToShow.add(event);\n          }\n        }\n        return eventsToShow;\n  }\n\n}", "class_id": 0, "repo": "jasminechau2/CodeU-Nemo", "file": "src/main/java/codeu/model/store/basic/EventStore.java", "last_update_at": "2018-06-11T18:25:05+00:00", "question_id": "26d3e04e94977bd658535c0ae3e8a40dd48604cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EventStore {\n  /** Singleton instance of EventStore. */\n  private static EventStore instance;\n  /**\n   * Returns the singleton instance of EventStore that should be shared between all servlet classes.\n   * Do not call this function from a test; use getTestInstance() instead.\n   */\n  public static EventStore getInstance() {\n    if (instance == null) {\n      instance = new EventStore(PersistentStorageAgent.getInstance());\n    }\n    return instance;\n  }\n  /**\n   * Instance getter function used for testing. Supply a mock for PersistentStorageAgent.\n   *\n   * @param persistentStorageAgent a mock used for testing\n   */\n  public static EventStore getTestInstance(PersistentStorageAgent persistentStorageAgent) {\n    return new EventStore(persistentStorageAgent);\n  }\n  /**\n   * The PersistentStorageAgent responsible for loading Events from and saving Events to Datastore.\n   */\n  private PersistentStorageAgent persistentStorageAgent;\n  /** The in-memory list of Events. */\n  private List<Event> events;\n  /** This class is a singleton, so its constructor is private. Call getInstance() instead. */\n  private EventStore(PersistentStorageAgent persistentStorageAgent) {\n    this.persistentStorageAgent = persistentStorageAgent;\n    events = new ArrayList<>();\n  }\n  /** Access the current set of users known to the application. */\n  public List<Event> getAllEvents() {\n    return events;\n  }\n  /**\n   * Access the Event object with the given UUID.\n   *\n   * @return null if the UUID does not match any existing Event.\n   */\n  public Event getEvent(UUID id) {\n    for (Event event : events) {\n      if (event.getId().equals(id)) {\n        return event;\n      }\n    }\n    return null;\n  }\n  /**\n   * Add a new event to the current set of events known to the application. This should only be called\n   * to add a new event, not to update an existing event.\n   */\n  public void addEvent(Event event) {\n    events.add(event);\n    persistentStorageAgent.writeThrough(event);\n  }\n  /**\n   * Sets the List of Events stored by this EventStore. This should only be called once, when the data\n   * is loaded from Datastore.\n   */\n  public void setEvents(List<Event> events) {\n    this.events = events;\n  }\n  public List<Event> getEventsSince(Instant lastSeen){\n    List<Event> eventsToShow = new ArrayList<Event>();\n        for (Event event: events){\n          Instant eventCreationTime = event.getCreationTime();\n          if(eventCreationTime.isAfter(lastSeen)){\n            eventsToShow.add(event);\n          }\n        }\n        return eventsToShow;\n  }\n"]], "pred": {"ppl": 1.3159573078155518, "ppl_lower": 1.9470183849334717, "ppl/lowercase_ppl": -2.4267501163787415, "ppl/zlib": 0.00031852017576249135, "Min_5.0% Prob": 4.0621750144397515, "Min_10.0% Prob": 2.540991340858349, "Min_20.0% Prob": 1.3558750156875994, "Min_30.0% Prob": 0.911818070372825, "Min_40.0% Prob": 0.6853688131437026, "Min_50.0% Prob": 0.5486572533472305, "Min_60.0% Prob": 0.4583324527640328}}
{"hexsha": "58c0f14dafb4ef40ba3bdaa825c65b45219d745b", "ext": "java", "lang": "Java", "content": "@Component(service = WordReverseService.class)\npublic class WordReverseService {\n\n    /**\n     * Copied from\n     * http://codereview.stackexchange.com/questions/37364/reversing-words-in-a-string\n     *\n     * @param sentence\n     * @return\n     */\n    public String reverseWords(String sentence) {\n        StringBuilder sb = new StringBuilder(sentence.length() + 1);\n        String[] words = sentence.split(\" \");\n        for (int i = words.length - 1; i >= 0; i--) {\n            sb.append(words[i]).append(' ');\n        }\n        sb.setLength(sb.length() - 1);  // Strip trailing space\n        return sb.toString();\n    }\n\n}", "class_id": 0, "repo": "stackleader/camel-quickstarts", "file": "netty/com.stackleader.camel.quickstart.netty/src/main/java/com/stackleader/camel/quickstart/netty/WordReverseService.java", "last_update_at": "2018-07-31T16:11:19+00:00", "question_id": "58c0f14dafb4ef40ba3bdaa825c65b45219d745b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component(service = WordReverseService.class)\npublic class WordReverseService {\n    /**\n     * Copied from\n     * http://codereview.stackexchange.com/questions/37364/reversing-words-in-a-string\n     *\n     * @param sentence\n     * @return\n     */\n    public String reverseWords(String sentence) {\n        StringBuilder sb = new StringBuilder(sentence.length() + 1);\n        String[] words = sentence.split(\" \");\n        for (int i = words.length - 1; i >= 0; i--) {\n            sb.append(words[i]).append(' ');\n        }\n        sb.setLength(sb.length() - 1);  // Strip trailing space\n        return sb.toString();\n    }\n"]], "pred": {"ppl": 1.8712974786758423, "ppl_lower": 2.433058023452759, "ppl/lowercase_ppl": -1.4189330750694389, "ppl/zlib": 0.001864976277189525, "Min_5.0% Prob": 6.702264785766602, "Min_10.0% Prob": 4.423010562595568, "Min_20.0% Prob": 2.8179388563883934, "Min_30.0% Prob": 2.044517461145133, "Min_40.0% Prob": 1.551886925836662, "Min_50.0% Prob": 1.2534495661384426, "Min_60.0% Prob": 1.0493580610855766}}
{"hexsha": "7c58a78c593c9765dd580328aa7d10c9efe5284e", "ext": "java", "lang": "Java", "content": "public class ModuleManager {\n\n    private static final Logger logger = LogsCenter.getLogger(ModuleManager.class);\n\n    private static ModuleManager instance;\n\n    private ArrayList<Module> modules;\n\n    private ModuleManager() {\n        modules = new ArrayList<>();\n        readModuleList();\n    }\n\n    public static ModuleManager getInstance() {\n        if (instance == null) {\n            instance = new ModuleManager();\n        }\n        return instance;\n    }\n\n    /**\n     * Adds a new module to the in-memory array list\n     */\n    public void addModule(Module module) throws DuplicateModuleException {\n        if (doesModuleExist(module)) {\n            throw new DuplicateModuleException();\n        }\n        modules.add(module);\n    }\n\n    /**\n     * Replaces the given module {@code target} with {@code editedModule}\n     * {@code target} must already exist in Trajectory\n     */\n    public void updateModule(Module target, Module editedModule) {\n        requireAllNonNull(target, editedModule);\n\n        int targetIndex = modules.indexOf(target);\n\n        modules.set(targetIndex, editedModule);\n    }\n\n    /**\n     * Deletes a module from Trajectory. This method will also handle the deletion of the other components that\n     * rely on {@code Module}.\n     */\n    public void deleteModule(Module toDelete) {\n        modules.remove(toDelete);\n        ClassroomManager.getInstance().handleModuleDeletedByModuleCode(toDelete.getModuleCode().moduleCode);\n    }\n\n    public void enrolStudentInModule(Module module, Person student) {\n        module.addStudent(student);\n    }\n\n    public void removeStudentFromModule(Module module, Person student) {\n        module.removeStudent(student);\n    }\n\n    public boolean isStudentEnrolledInModule(Module module, Person student) {\n        return module.getEnrolledStudents().stream().anyMatch(s -> s.equals(student));\n    }\n\n    /**\n     * Overload for {@link #isStudentEnrolledInModule(Module, Person)} to accept {@code String} inputs.\n     * The module code and matric no. must be validated before calling this method, otherwise\n     * there is a risk of a {@code NullPointerException} being thrown.\n     */\n    public boolean isStudentEnrolledInModule(String moduleCode, String matricNo) {\n        Module module = getModuleByModuleCode(moduleCode);\n        Person student = StudentManager.getInstance().retrieveStudentByMatricNo(matricNo);\n        return isStudentEnrolledInModule(module, student);\n    }\n\n    /**\n     * Removes a deleted student from the modules that student was previously enrolled in.\n     */\n    public void handleStudentDeleted(Person student) {\n        for (Module module : modules) {\n            if (isStudentEnrolledInModule(module, student)) {\n                removeStudentFromModule(module, student);\n            }\n        }\n    }\n\n    /**\n     * Gets the module list from storage and converts it to a Module array list.\n     * Also reads the association data between Student and Module and stores it in-memory in the module.\n     */\n    private void readModuleList() {\n        ArrayList<XmlAdaptedModule> xmlModuleList = StorageController.getModuleStorage();\n        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = StorageController.getStudentModuleStorage();\n        try {\n            for (XmlAdaptedModule xmlModule : xmlModuleList) {\n                Module m = xmlModule.toModelType();\n                modules.add(m);\n\n                // Look for associations between this module and any students (i.e. any enrolled students?)\n                for (XmlAdaptedStudentModule xmlStudentModule : xmlAdaptedStudentModuleList) {\n                    if (xmlStudentModule.getModuleCode().equals(m.getModuleCode().moduleCode)) {\n                        Person student = StudentManager.getInstance()\n                                .retrieveStudentByMatricNo(xmlStudentModule.getStudentMatricNo());\n\n                        m.addStudent(student);\n                    }\n                }\n            }\n        } catch (NullPointerException npe) {\n            logger.info(\"Illegal values found when reading enrolled students: \" + npe.getMessage());\n        } catch (IllegalValueException ive) {\n            logger.info(\"Illegal values found when reading module list: \" + ive.getMessage());\n        }\n    }\n\n    /**\n     * Converts the Module array list and invokes the StorageController to save the current module list to file.\n     * Also passes info on the association between Student and Module to be saved to file.\n     */\n    public void saveModuleList() {\n        ArrayList<XmlAdaptedModule> xmlAdaptedModules =\n                modules.stream().map(XmlAdaptedModule::new).collect(Collectors.toCollection(ArrayList::new));\n        StorageController.setModuleStorage(xmlAdaptedModules);\n\n        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = new ArrayList<>();\n        for (Module m : modules) {\n            xmlAdaptedStudentModuleList.addAll(\n                    m.getEnrolledStudents()\n                            .stream()\n                            .map(s -> new XmlAdaptedStudentModule(\n                                    s.getMatricNo().matricNo, m.getModuleCode().moduleCode))\n                            .collect(Collectors.toCollection(ArrayList::new))\n            );\n        }\n        StorageController.setStudentModuleStorage(xmlAdaptedStudentModuleList);\n\n        StorageController.storeData();\n    }\n\n    /**\n     * Searches the list of modules for module codes and/or names that match any of the keywords.\n     * @return List of modules that match at least one keyword.\n     */\n    public List<Module> searchModulesWithKeywords(List<String> keywords) {\n        return modules.stream()\n                .filter(module ->\n                        keywords.stream().anyMatch(keyword ->\n                                StringUtil.containsWordIgnoreCase(module.getModuleCode().moduleCode, keyword)\n                                || StringUtil.containsWordIgnoreCase(module.getModuleName().moduleName, keyword)))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Searches the list of modules to find a module that matches the {@code moduleCode}\n     * @param moduleCode The target module's code to find\n     * @return The module object that matches the module code, or {@code null} if there isn't a matching module\n     */\n    public Module getModuleByModuleCode(String moduleCode) {\n        return this.modules.stream()\n                .filter(module -> module.getModuleCode().moduleCode.equals(moduleCode))\n                .findAny()\n                .orElse(null);\n    }\n\n    /**\n     * Checks if the input module already exists in Trajectory.\n     * @param module The module whose existence needs to be checked.\n     * @return True if the module exists; false otherwise.\n     */\n    public boolean doesModuleExist(Module module) {\n        return this.modules.stream().anyMatch(m -> m.isSameModule(module));\n    }\n\n    /**\n     * Checks if the input module code matches a module that exists in Trajectory.\n     * This is an overload to make it easier to check a module's existence without\n     * creating a whole {@oode Module} object.\n     * This overload adheres to the DRY principle by invoking the original\n     * {@link #doesModuleExist(Module)} mathod.\n     * @param moduleCode The module code that will be used to check for the module's existence.\n     * @return True if the module exists; false otherwise.\n     */\n    public boolean doesModuleExist(String moduleCode) {\n        Module module = getModuleByModuleCode(moduleCode);\n        if (module != null) {\n            return doesModuleExist(module);\n        }\n        return false;\n    }\n\n    /**\n     * Converts the given list of modules to a HTML table representation.\n     * @param moduleList\n     * @return\n     */\n    public String convertModulesToTableRepresentation(List<Module> moduleList) {\n        moduleList.sort(Comparator.comparing(m -> m.getModuleCode().toString()));\n\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(HtmlTableProcessor.getBanner(\"Module List\"));\n        sb.append(HtmlTableProcessor.renderTableStart(new ArrayList<>(\n                Arrays.asList(\"Module Code\", \"Module Name\"))));\n\n        sb.append(HtmlTableProcessor.getTableItemStart());\n        for (Module m : moduleList) {\n            ArrayList<String> dataRow = new ArrayList<>(Arrays.asList(\n                    m.getModuleCode().toString(),\n                    m.getModuleName().toString()\n            ));\n\n            sb.append(HtmlTableProcessor.renderTableItem(dataRow));\n        }\n        sb.append(HtmlTableProcessor.getTableItemEnd());\n\n        return sb.toString();\n    }\n\n    /**\n     * Converts the list of modules into a HTML table representation.\n     * Internally calls {@link #convertModulesToTableRepresentation(List)} to generate the HTML string\n     * to enforce DRY.\n     * @return\n     */\n    public String getModuleTableRepresentation() {\n        return convertModulesToTableRepresentation(modules);\n    }\n\n    /**\n     * Converts the given module into a HTML String for display in the {@code BrowserPanel}\n     */\n    public String getModuleAsHtmlRepresentation(Module module) {\n        final String listItemFormat = \"%1$s (%2$s)\";\n        StringBuilder sb = new StringBuilder();\n        StringBuilder studentEntries = new StringBuilder();\n\n        // Sort the students by name in alphabetical order\n        List<Person> enrolledStudents = new ArrayList<>(module.getEnrolledStudents());\n        enrolledStudents.sort(Comparator.comparing(s -> s.getName().fullName));\n\n        if (module.getEnrolledStudents().isEmpty()) {\n            studentEntries.append(\"There are no students enrolled in this module.\");\n        } else {\n            studentEntries.append(HtmlProcessor.getOrderedListStart());\n            for (Person s : enrolledStudents) {\n                studentEntries.append(HtmlProcessor.getListItem(\n                        String.format(listItemFormat, s.getName().toString(), s.getMatricNo())\n                ));\n            }\n            studentEntries.append(HtmlProcessor.getOrderedListEnd());\n        }\n\n        List<AbstractMap.SimpleEntry<String, String>> details = new ArrayList<>();\n        details.add(new AbstractMap.SimpleEntry<>(\"Module Code: \", module.getModuleCode().toString()));\n        details.add(new AbstractMap.SimpleEntry<>(\"Module Name: \", module.getModuleName().toString()));\n        details.add(new AbstractMap.SimpleEntry<>(\"Enrolled Students: \", studentEntries.toString()));\n\n        sb.append(HtmlProcessor.constructDetailedView(details));\n\n        return sb.toString();\n    }\n\n    public void clearModules() {\n        modules = new ArrayList<>();\n    }\n\n    public ArrayList<Module> getModules() {\n        return this.modules;\n    }\n}", "class_id": 0, "repo": "zhicaizack/main", "file": "src/main/java/seedu/address/model/module/ModuleManager.java", "last_update_at": "2018-09-15T15:47:42+00:00", "question_id": "7c58a78c593c9765dd580328aa7d10c9efe5284e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModuleManager {\n    private static final Logger logger = LogsCenter.getLogger(ModuleManager.class);\n    private static ModuleManager instance;\n    private ArrayList<Module> modules;\n    private ModuleManager() {\n        modules = new ArrayList<>();\n        readModuleList();\n    }\n    public static ModuleManager getInstance() {\n        if (instance == null) {\n            instance = new ModuleManager();\n        }\n        return instance;\n    }\n    /**\n     * Adds a new module to the in-memory array list\n     */\n    public void addModule(Module module) throws DuplicateModuleException {\n        if (doesModuleExist(module)) {\n            throw new DuplicateModuleException();\n        }\n        modules.add(module);\n    }\n    /**\n     * Replaces the given module {@code target} with {@code editedModule}\n     * {@code target} must already exist in Trajectory\n     */\n    public void updateModule(Module target, Module editedModule) {\n        requireAllNonNull(target, editedModule);\n        int targetIndex = modules.indexOf(target);\n        modules.set(targetIndex, editedModule);\n    }\n    /**\n     * Deletes a module from Trajectory. This method will also handle the deletion of the other components that\n     * rely on {@code Module}.\n     */\n    public void deleteModule(Module toDelete) {\n        modules.remove(toDelete);\n        ClassroomManager.getInstance().handleModuleDeletedByModuleCode(toDelete.getModuleCode().moduleCode);\n    }\n    public void enrolStudentInModule(Module module, Person student) {\n        module.addStudent(student);\n    }\n    public void removeStudentFromModule(Module module, Person student) {\n        module.removeStudent(student);\n    }\n    public boolean isStudentEnrolledInModule(Module module, Person student) {\n        return module.getEnrolledStudents().stream().anyMatch(s -> s.equals(student));\n    }\n    /**\n     * Overload for {@link #isStudentEnrolledInModule(Module, Person)} to accept {@code String} inputs.\n     * The module code and matric no. must be validated before calling this method, otherwise\n     * there is a risk of a {@code NullPointerException} being thrown.\n     */\n    public boolean isStudentEnrolledInModule(String moduleCode, String matricNo) {\n        Module module = getModuleByModuleCode(moduleCode);\n        Person student = StudentManager.getInstance().retrieveStudentByMatricNo(matricNo);\n        return isStudentEnrolledInModule(module, student);\n    }\n    /**\n     * Removes a deleted student from the modules that student was previously enrolled in.\n     */\n    public void handleStudentDeleted(Person student) {\n        for (Module module : modules) {\n            if (isStudentEnrolledInModule(module, student)) {\n                removeStudentFromModule(module, student);\n            }\n        }\n    }\n    /**\n     * Gets the module list from storage and converts it to a Module array list.\n     * Also reads the association data between Student and Module and stores it in-memory in the module.\n     */\n    private void readModuleList() {\n        ArrayList<XmlAdaptedModule> xmlModuleList = StorageController.getModuleStorage();\n        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = StorageController.getStudentModuleStorage();\n        try {\n            for (XmlAdaptedModule xmlModule : xmlModuleList) {\n                Module m = xmlModule.toModelType();\n                modules.add(m);\n                // Look for associations between this module and any students (i.e. any enrolled students?)\n                for (XmlAdaptedStudentModule xmlStudentModule : xmlAdaptedStudentModuleList) {\n                    if (xmlStudentModule.getModuleCode().equals(m.getModuleCode().moduleCode)) {\n                        Person student = StudentManager.getInstance()\n                                .retrieveStudentByMatricNo(xmlStudentModule.getStudentMatricNo());\n                        m.addStudent(student);\n                    }\n                }\n            }\n        } catch (NullPointerException npe) {\n            logger.info(\"Illegal values found when reading enrolled students: \" + npe.getMessage());\n        } catch (IllegalValueException ive) {\n            logger.info(\"Illegal values found when reading module list: \" + ive.getMessage());\n        }\n    }\n    /**\n     * Converts the Module array list and invokes the StorageController to save the current module list to file.\n     * Also passes info on the association between Student and Module to be saved to file.\n     */\n    public void saveModuleList() {\n        ArrayList<XmlAdaptedModule> xmlAdaptedModules =\n                modules.stream().map(XmlAdaptedModule::new).collect(Collectors.toCollection(ArrayList::new));\n        StorageController.setModuleStorage(xmlAdaptedModules);\n        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = new ArrayList<>();\n        for (Module m : modules) {\n            xmlAdaptedStudentModuleList.addAll(\n                    m.getEnrolledStudents()\n                            .stream()\n                            .map(s -> new XmlAdaptedStudentModule(\n                                    s.getMatricNo().matricNo, m.getModuleCode().moduleCode))\n                            .collect(Collectors.toCollection(ArrayList::new))\n            );\n        }\n        StorageController.setStudentModuleStorage(xmlAdaptedStudentModuleList);\n        StorageController.storeData();\n    }\n    /**\n     * Searches the list of modules for module codes and/or names that match any of the keywords.\n     * @return List of modules that match at least one keyword.\n     */\n    public List<Module> searchModulesWithKeywords(List<String> keywords) {\n        return modules.stream()\n                .filter(module ->\n                        keywords.stream().anyMatch(keyword ->\n                                StringUtil.containsWordIgnoreCase(module.getModuleCode().moduleCode, keyword)\n                                || StringUtil.containsWordIgnoreCase(module.getModuleName().moduleName, keyword)))\n                .collect(Collectors.toList());\n    }\n    /**\n     * Searches the list of modules to find a module that matches the {@code moduleCode}\n     * @param moduleCode The target module's code to find\n     * @return The module object that matches the module code, or {@code null} if there isn't a matching module\n     */\n    public Module getModuleByModuleCode(String moduleCode) {\n        return this.modules.stream()\n                .filter(module -> module.getModuleCode().moduleCode.equals(moduleCode))\n                .findAny()\n                .orElse(null);\n    }\n    /**\n     * Checks if the input module already exists in Trajectory.\n     * @param module The module whose existence needs to be checked.\n     * @return True if the module exists; false otherwise.\n     */\n    public boolean doesModuleExist(Module module) {\n        return this.modules.stream().anyMatch(m -> m.isSameModule(module));\n    }\n    /**\n     * Checks if the input module code matches a module that exists in Trajectory.\n     * This is an overload to make it easier to check a module's existence without\n     * creating a whole {@oode Module} object.\n     * This overload adheres to the DRY principle by invoking the original\n     * {@link #doesModuleExist(Module)} mathod.\n     * @param moduleCode The module code that will be used to check for the module's existence.\n     * @return True if the module exists; false otherwise.\n     */\n    public boolean doesModuleExist(String moduleCode) {\n        Module module = getModuleByModuleCode(moduleCode);\n        if (module != null) {\n            return doesModuleExist(module);\n        }\n        return false;\n    }\n    /**\n     * Converts the given list of modules to a HTML table representation.\n     * @param moduleList\n     * @return\n     */\n    public String convertModulesToTableRepresentation(List<Module> moduleList) {\n        moduleList.sort(Comparator.comparing(m -> m.getModuleCode().toString()));\n        StringBuilder sb = new StringBuilder();\n        sb.append(HtmlTableProcessor.getBanner(\"Module List\"));\n        sb.append(HtmlTableProcessor.renderTableStart(new ArrayList<>(\n                Arrays.asList(\"Module Code\", \"Module Name\"))));\n        sb.append(HtmlTableProcessor.getTableItemStart());\n        for (Module m : moduleList) {\n            ArrayList<String> dataRow = new ArrayList<>(Arrays.asList(\n                    m.getModuleCode().toString(),\n                    m.getModuleName().toString()\n            ));\n            sb.append(HtmlTableProcessor.renderTableItem(dataRow));\n        }\n        sb.append(HtmlTableProcessor.getTableItemEnd());\n        return sb.toString();\n    }\n    /**\n     * Converts the list of modules into a HTML table representation.\n     * Internally calls {@link #convertModulesToTableRepresentation(List)} to generate the HTML string\n     * to enforce DRY.\n     * @return\n     */\n    public String getModuleTableRepresentation() {\n        return convertModulesToTableRepresentation(modules);\n    }\n    /**\n     * Converts the given module into a HTML String for display in the {@code BrowserPanel}\n     */\n    public String getModuleAsHtmlRepresentation(Module module) {\n        final String listItemFormat = \"%1$s (%2$s)\";\n        StringBuilder sb = new StringBuilder();\n        StringBuilder studentEntries = new StringBuilder();\n        // Sort the students by name in alphabetical order\n        List<Person> enrolledStudents = new ArrayList<>(module.getEnrolledStudents());\n        enrolledStudents.sort(Comparator.comparing(s -> s.getName().fullName));\n        if (module.getEnrolledStudents().isEmpty()) {\n            studentEntries.append(\"There are no students enrolled in this module.\");\n        } else {\n            studentEntries.append(HtmlProcessor.getOrderedListStart());\n            for (Person s : enrolledStudents) {\n                studentEntries.append(HtmlProcessor.getListItem(\n                        String.format(listItemFormat, s.getName().toString(), s.getMatricNo())\n                ));\n            }\n            studentEntries.append(HtmlProcessor.getOrderedListEnd());\n        }\n        List<AbstractMap.SimpleEntry<String, String>> details = new ArrayList<>();\n        details.add(new AbstractMap.SimpleEntry<>(\"Module Code: \", module.getModuleCode().toString()));\n        details.add(new AbstractMap.SimpleEntry<>(\"Module Name: \", module.getModuleName().toString()));\n        details.add(new AbstractMap.SimpleEntry<>(\"Enrolled Students: \", studentEntries.toString()));\n        sb.append(HtmlProcessor.constructDetailedView(details));\n        return sb.toString();\n    }\n    public void clearModules() {\n        modules = new ArrayList<>();\n    }\n    public ArrayList<Module> getModules() {\n        return this.modules;\n    }\n"]], "pred": {"ppl": 1.9154680967330933, "ppl_lower": 2.2188291549682617, "ppl/lowercase_ppl": -1.2261941662235822, "ppl/zlib": 0.00023583527928124456, "Min_5.0% Prob": 5.802480477912753, "Min_10.0% Prob": 4.382009398703482, "Min_20.0% Prob": 2.9063735744532417, "Min_30.0% Prob": 2.10778219350218, "Min_40.0% Prob": 1.6118453500979104, "Min_50.0% Prob": 1.2980923768599497, "Min_60.0% Prob": 1.0838888737336592}}
{"hexsha": "eb6ae5230f949e152d9db09bb2d57628bbaaf898", "ext": "java", "lang": "Java", "content": "@Repository\npublic class ThreadDAOImpl implements ThreadDAO {\n\n  @Autowired\n  private SessionFactory sessionFactory;\n\n\n  public void setSessionFactory(SessionFactory sessionFactory) {\n    this.sessionFactory = sessionFactory;\n  }\n\n\n  @Override\n  public DBThread get(Long threadId) {\n    Session session = sessionFactory.getCurrentSession();\n    Criteria crit = session.createCriteria(DBThread.class)\n        .add(Restrictions.eq(\"threadId\", threadId));\n    DBThread value = (DBThread) crit.uniqueResult();\n    return value;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public List<DBThread> gets(String field, int offset, int limit) {\n    Session session = sessionFactory.getCurrentSession();\n    Criteria crit = session.createCriteria(DBThread.class);\n    crit.add(Restrictions.eq(\"enabled\", true));\n    crit.addOrder(Order.desc(field));\n    crit.setFirstResult(offset);\n    crit.setMaxResults(limit);\n    crit.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n    List<DBThread> list = crit.list();\n    return list;\n  }\n\n  @Override\n  public DBThread insert(DBThread val) {\n    Session session = sessionFactory.getCurrentSession();\n    session.persist(val);\n    session.flush();\n    return val;\n  }\n\n  @Override\n  public void update(DBThread val) {\n    Session session = sessionFactory.getCurrentSession();\n    session.update(val);\n  }\n\n\n  protected Session openSession() {\n    return sessionFactory.openSession();\n  }\n\n}", "class_id": 0, "repo": "apitore/apitore-service-dao", "file": "src/main/java/com/apitore/dao/impl/ThreadDAOImpl.java", "last_update_at": "2018-08-21T06:13:50+00:00", "question_id": "eb6ae5230f949e152d9db09bb2d57628bbaaf898", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Repository\npublic class ThreadDAOImpl implements ThreadDAO {\n  @Autowired\n  private SessionFactory sessionFactory;\n  public void setSessionFactory(SessionFactory sessionFactory) {\n    this.sessionFactory = sessionFactory;\n  }\n  @Override\n  public DBThread get(Long threadId) {\n    Session session = sessionFactory.getCurrentSession();\n    Criteria crit = session.createCriteria(DBThread.class)\n        .add(Restrictions.eq(\"threadId\", threadId));\n    DBThread value = (DBThread) crit.uniqueResult();\n    return value;\n  }\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public List<DBThread> gets(String field, int offset, int limit) {\n    Session session = sessionFactory.getCurrentSession();\n    Criteria crit = session.createCriteria(DBThread.class);\n    crit.add(Restrictions.eq(\"enabled\", true));\n    crit.addOrder(Order.desc(field));\n    crit.setFirstResult(offset);\n    crit.setMaxResults(limit);\n    crit.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n    List<DBThread> list = crit.list();\n    return list;\n  }\n  @Override\n  public DBThread insert(DBThread val) {\n    Session session = sessionFactory.getCurrentSession();\n    session.persist(val);\n    session.flush();\n    return val;\n  }\n  @Override\n  public void update(DBThread val) {\n    Session session = sessionFactory.getCurrentSession();\n    session.update(val);\n  }\n  protected Session openSession() {\n    return sessionFactory.openSession();\n  }\n"]], "pred": {"ppl": 1.5502604246139526, "ppl_lower": 1.8395687341690063, "ppl/lowercase_ppl": -1.3902811990101267, "ppl/zlib": 0.0008786030715391533, "Min_5.0% Prob": 5.665519440174103, "Min_10.0% Prob": 3.666623179505511, "Min_20.0% Prob": 2.1094557928392685, "Min_30.0% Prob": 1.440795358121395, "Min_40.0% Prob": 1.0955500025077756, "Min_50.0% Prob": 0.8773742864678542, "Min_60.0% Prob": 0.7308833573758602}}
{"hexsha": "c52341221e01d311fed1c6c693084960d0ac9299", "ext": "java", "lang": "Java", "content": "@WebAppConfiguration\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = TestConfig.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass DifferentialAnalyticsSearchServiceIT {\n    private static final SemanticQuery EMPTY_QUERY = SemanticQuery.create();\n\n    @Inject\n    private DataSource dataSource;\n\n    @Inject\n    private SpeciesFactory speciesFactory;\n\n    @Inject\n    private DifferentialAnalyticsSearchService subject;\n\n    private SemanticQuery query = SemanticQuery.create(\"zinc finger\");\n    private SemanticQuery condition = SemanticQuery.create(\"watering\");\n    private String species = \"oryza sativa\";\n\n    @BeforeAll\n    void populateDatabaseTables() {\n        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScripts(new ClassPathResource(\"fixtures/experiment-fixture.sql\"));\n        populator.execute(dataSource);\n    }\n\n    @AfterAll\n    void cleanDatabaseTables() {\n        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScripts(new ClassPathResource(\"fixtures/experiment-delete.sql\"));\n        populator.execute(dataSource);\n    }\n\n    @Test\n    void fetchDifferentialFacetsForSearch() {\n        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);\n        assertAboutFacets(result);\n    }\n\n    @Test\n    void fetchDifferentialResultsForSearch() {\n        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);\n        assertAboutResults(result);\n    }\n\n    @Test\n    void fetchDifferentialFacetsForQuery1() {\n        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);\n        assertAboutFacets(result);\n    }\n\n    @Test\n    void fetchDifferentialFacetsForQuery3() {\n        JsonObject result = subject.fetchFacets(query, condition, speciesFactory.create(species));\n        assertAboutFacets(result);\n    }\n\n    @Test\n    void fetchDifferentialResultsForQuery1() {\n        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);\n        assertAboutResults(result);\n    }\n    @Test\n    void fetchDifferentialResultsForQuery() {\n        JsonObject result = subject.fetchResults(query, condition, speciesFactory.create(species));\n        assertAboutResults(result);\n    }\n\n    private void assertAboutFacets(JsonObject result) {\n        assertThat(result.entrySet().size(), greaterThan(0));\n        for (Map.Entry<String, ?> e: result.entrySet()) {\n            assertThat(e.getKey(),\n                    isOneOf(\"kingdom\", \"species\", \"experimentType\", \"factors\", \"numReplicates\", \"regulation\"));\n        }\n    }\n\n    private void assertAboutResults(JsonObject result) {\n        assertTrue(result.has(\"results\"));\n        assertThat(result.get(\"results\").getAsJsonArray().size(), greaterThan(0));\n        for (JsonElement e: result.get(\"results\").getAsJsonArray()) {\n            assertTrue(e.getAsJsonObject().has(\"bioentityIdentifier\"));\n            assertTrue(e.getAsJsonObject().has(\"bioentityName\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentAccession\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentType\"));\n            assertTrue(e.getAsJsonObject().has(\"contrastId\"));\n            assertTrue(e.getAsJsonObject().has(\"foldChange\"));\n            assertTrue(e.getAsJsonObject().has(\"comparison\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentName\"));\n        }\n    }\n}", "class_id": 0, "repo": "gxa/atlas", "file": "gxa/src/test/java/uk/ac/ebi/atlas/solr/analytics/differential/DifferentialAnalyticsSearchServiceIT.java", "last_update_at": "2018-03-06T15:39:52+00:00", "question_id": "c52341221e01d311fed1c6c693084960d0ac9299", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@WebAppConfiguration\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = TestConfig.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass DifferentialAnalyticsSearchServiceIT {\n    private static final SemanticQuery EMPTY_QUERY = SemanticQuery.create();\n    @Inject\n    private DataSource dataSource;\n    @Inject\n    private SpeciesFactory speciesFactory;\n    @Inject\n    private DifferentialAnalyticsSearchService subject;\n    private SemanticQuery query = SemanticQuery.create(\"zinc finger\");\n    private SemanticQuery condition = SemanticQuery.create(\"watering\");\n    private String species = \"oryza sativa\";\n    @BeforeAll\n    void populateDatabaseTables() {\n        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScripts(new ClassPathResource(\"fixtures/experiment-fixture.sql\"));\n        populator.execute(dataSource);\n    }\n    @AfterAll\n    void cleanDatabaseTables() {\n        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n        populator.addScripts(new ClassPathResource(\"fixtures/experiment-delete.sql\"));\n        populator.execute(dataSource);\n    }\n    @Test\n    void fetchDifferentialFacetsForSearch() {\n        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);\n        assertAboutFacets(result);\n    }\n    @Test\n    void fetchDifferentialResultsForSearch() {\n        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);\n        assertAboutResults(result);\n    }\n    @Test\n    void fetchDifferentialFacetsForQuery1() {\n        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);\n        assertAboutFacets(result);\n    }\n    @Test\n    void fetchDifferentialFacetsForQuery3() {\n        JsonObject result = subject.fetchFacets(query, condition, speciesFactory.create(species));\n        assertAboutFacets(result);\n    }\n    @Test\n    void fetchDifferentialResultsForQuery1() {\n        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);\n        assertAboutResults(result);\n    }\n    @Test\n    void fetchDifferentialResultsForQuery() {\n        JsonObject result = subject.fetchResults(query, condition, speciesFactory.create(species));\n        assertAboutResults(result);\n    }\n    private void assertAboutFacets(JsonObject result) {\n        assertThat(result.entrySet().size(), greaterThan(0));\n        for (Map.Entry<String, ?> e: result.entrySet()) {\n            assertThat(e.getKey(),\n                    isOneOf(\"kingdom\", \"species\", \"experimentType\", \"factors\", \"numReplicates\", \"regulation\"));\n        }\n    }\n    private void assertAboutResults(JsonObject result) {\n        assertTrue(result.has(\"results\"));\n        assertThat(result.get(\"results\").getAsJsonArray().size(), greaterThan(0));\n        for (JsonElement e: result.get(\"results\").getAsJsonArray()) {\n            assertTrue(e.getAsJsonObject().has(\"bioentityIdentifier\"));\n            assertTrue(e.getAsJsonObject().has(\"bioentityName\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentAccession\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentType\"));\n            assertTrue(e.getAsJsonObject().has(\"contrastId\"));\n            assertTrue(e.getAsJsonObject().has(\"foldChange\"));\n            assertTrue(e.getAsJsonObject().has(\"comparison\"));\n            assertTrue(e.getAsJsonObject().has(\"experimentName\"));\n        }\n    }\n"]], "pred": {"ppl": 1.7129786014556885, "ppl_lower": 2.207793951034546, "ppl/lowercase_ppl": -1.4714681827768363, "ppl/zlib": 0.0006531962711297178, "Min_5.0% Prob": 6.409152994985166, "Min_10.0% Prob": 4.434479919813013, "Min_20.0% Prob": 2.580727159015594, "Min_30.0% Prob": 1.7751723369817152, "Min_40.0% Prob": 1.340425294357035, "Min_50.0% Prob": 1.07608407372289, "Min_60.0% Prob": 0.8979901175076318}}
{"hexsha": "b0b1bc8b5f5618af539d98868044fa261f40a73f", "ext": "java", "lang": "Java", "content": "public class FormalToJavaExt_c extends ToJavaExt_c {\n    private static final long serialVersionUID = SerialVersionUID.generate();\n\n    @Override\n    public Node toJava(JifToJavaRewriter rw) throws SemanticException {\n        Formal n = (Formal) node();\n        Formal newN = rw.nodeFactory().Formal(n.position(), n.flags(), n.type(),\n                n.id());\n        LocalInstance li = n.localInstance();\n\n        newN = newN.localInstance(\n                rw.typeSystem().localInstance(li.position(), li.flags(),\n                        rw.typeSystem().unknownType(li.position()), li.name()));\n        return newN;\n    }\n}", "class_id": 0, "repo": "GustavHenning/SoftwareSafetySecurity18", "file": "lib/jif-3.5.0/src/jif/translate/FormalToJavaExt_c.java", "last_update_at": "2018-04-24T12:01:51+00:00", "question_id": "b0b1bc8b5f5618af539d98868044fa261f40a73f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FormalToJavaExt_c extends ToJavaExt_c {\n    private static final long serialVersionUID = SerialVersionUID.generate();\n    @Override\n    public Node toJava(JifToJavaRewriter rw) throws SemanticException {\n        Formal n = (Formal) node();\n        Formal newN = rw.nodeFactory().Formal(n.position(), n.flags(), n.type(),\n                n.id());\n        LocalInstance li = n.localInstance();\n        newN = newN.localInstance(\n                rw.typeSystem().localInstance(li.position(), li.flags(),\n                        rw.typeSystem().unknownType(li.position()), li.name()));\n        return newN;\n    }\n"]], "pred": {"ppl": 3.0615885257720947, "ppl_lower": 5.126517295837402, "ppl/lowercase_ppl": -1.4606998038214978, "ppl/zlib": 0.0036447358545090513, "Min_5.0% Prob": 8.001938879489899, "Min_10.0% Prob": 6.5540501650641945, "Min_20.0% Prob": 4.569613613401141, "Min_30.0% Prob": 3.4483211018004507, "Min_40.0% Prob": 2.7183896890828305, "Min_50.0% Prob": 2.2166583954953074, "Min_60.0% Prob": 1.8721463729820724}}
{"hexsha": "f72cef719fbb63d62c00b96052ffeb973e0c42a3", "ext": "java", "lang": "Java", "content": "@Configuration(\"graphicalUserAuthenticationConfiguration\")\n@EnableConfigurationProperties(CasConfigurationProperties.class)\npublic class GraphicalUserAuthenticationConfiguration {\n\n    @Autowired\n    private CasConfigurationProperties casProperties;\n\n    @Autowired\n    @Qualifier(\"loginFlowRegistry\")\n    private FlowDefinitionRegistry loginFlowDefinitionRegistry;\n\n    @Autowired\n    @Qualifier(\"servicesManager\")\n    private ServicesManager servicesManager;\n\n    @Autowired\n    private ApplicationContext applicationContext;\n    \n    @Autowired\n    private FlowBuilderServices flowBuilderServices;\n\n    @ConditionalOnMissingBean(name = \"graphicalUserAuthenticationWebflowConfigurer\")\n    @Bean\n    @DependsOn(\"defaultWebflowConfigurer\")\n    public CasWebflowConfigurer graphicalUserAuthenticationWebflowConfigurer() {\n        final CasWebflowConfigurer w = new GraphicalUserAuthenticationWebflowConfigurer(flowBuilderServices, \n                loginFlowDefinitionRegistry, applicationContext, casProperties);\n        w.initialize();\n        return w;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(name = \"userGraphicalAuthenticationRepository\")\n    public UserGraphicalAuthenticationRepository userGraphicalAuthenticationRepository() {\n\n        final GraphicalUserAuthenticationProperties gua = casProperties.getAuthn().getGua();\n        if (gua.getResource().getLocation() != null) {\n            return new StaticUserGraphicalAuthenticationRepository();\n        }\n\n        if (StringUtils.isNotBlank(gua.getLdap().getLdapUrl())\n                && StringUtils.isNotBlank(gua.getLdap().getSearchFilter())\n                && StringUtils.isNotBlank(gua.getLdap().getBaseDn())\n                && StringUtils.isNotBlank(gua.getLdap().getImageAttribute())) {\n            return new LdapUserGraphicalAuthenticationRepository();\n        }\n\n        throw new BeanCreationException(\"A repository instance must be configured to locate user-defined graphics\");\n\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(name = \"acceptUserGraphicsForAuthenticationAction\")\n    public Action acceptUserGraphicsForAuthenticationAction() {\n        return new AcceptUserGraphicsForAuthenticationAction();\n    }\n\n    @Autowired\n    @Bean\n    public Action displayUserGraphicsBeforeAuthenticationAction(@Qualifier(\"userGraphicalAuthenticationRepository\")\n                                                                final UserGraphicalAuthenticationRepository repository) {\n        return new DisplayUserGraphicsBeforeAuthenticationAction(repository);\n    }\n\n    @Bean\n    public Action initializeLoginAction() {\n        return new PrepareForGraphicalAuthenticationAction(servicesManager);\n    }\n}", "class_id": 0, "repo": "yauheni-sidarenka/apereo-cas", "file": "support/cas-server-support-gua/src/main/java/org/apereo/cas/gua/config/GraphicalUserAuthenticationConfiguration.java", "last_update_at": "2018-12-15T09:09:52+00:00", "question_id": "f72cef719fbb63d62c00b96052ffeb973e0c42a3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration(\"graphicalUserAuthenticationConfiguration\")\n@EnableConfigurationProperties(CasConfigurationProperties.class)\npublic class GraphicalUserAuthenticationConfiguration {\n    @Autowired\n    private CasConfigurationProperties casProperties;\n    @Autowired\n    @Qualifier(\"loginFlowRegistry\")\n    private FlowDefinitionRegistry loginFlowDefinitionRegistry;\n    @Autowired\n    @Qualifier(\"servicesManager\")\n    private ServicesManager servicesManager;\n    @Autowired\n    private ApplicationContext applicationContext;\n    @Autowired\n    private FlowBuilderServices flowBuilderServices;\n    @ConditionalOnMissingBean(name = \"graphicalUserAuthenticationWebflowConfigurer\")\n    @Bean\n    @DependsOn(\"defaultWebflowConfigurer\")\n    public CasWebflowConfigurer graphicalUserAuthenticationWebflowConfigurer() {\n        final CasWebflowConfigurer w = new GraphicalUserAuthenticationWebflowConfigurer(flowBuilderServices, \n                loginFlowDefinitionRegistry, applicationContext, casProperties);\n        w.initialize();\n        return w;\n    }\n    @Bean\n    @ConditionalOnMissingBean(name = \"userGraphicalAuthenticationRepository\")\n    public UserGraphicalAuthenticationRepository userGraphicalAuthenticationRepository() {\n        final GraphicalUserAuthenticationProperties gua = casProperties.getAuthn().getGua();\n        if (gua.getResource().getLocation() != null) {\n            return new StaticUserGraphicalAuthenticationRepository();\n        }\n        if (StringUtils.isNotBlank(gua.getLdap().getLdapUrl())\n                && StringUtils.isNotBlank(gua.getLdap().getSearchFilter())\n                && StringUtils.isNotBlank(gua.getLdap().getBaseDn())\n                && StringUtils.isNotBlank(gua.getLdap().getImageAttribute())) {\n            return new LdapUserGraphicalAuthenticationRepository();\n        }\n        throw new BeanCreationException(\"A repository instance must be configured to locate user-defined graphics\");\n    }\n    @Bean\n    @ConditionalOnMissingBean(name = \"acceptUserGraphicsForAuthenticationAction\")\n    public Action acceptUserGraphicsForAuthenticationAction() {\n        return new AcceptUserGraphicsForAuthenticationAction();\n    }\n    @Autowired\n    @Bean\n    public Action displayUserGraphicsBeforeAuthenticationAction(@Qualifier(\"userGraphicalAuthenticationRepository\")\n                                                                final UserGraphicalAuthenticationRepository repository) {\n        return new DisplayUserGraphicsBeforeAuthenticationAction(repository);\n    }\n    @Bean\n    public Action initializeLoginAction() {\n        return new PrepareForGraphicalAuthenticationAction(servicesManager);\n    }\n"]], "pred": {"ppl": 1.6442679166793823, "ppl_lower": 2.3083157539367676, "ppl/lowercase_ppl": -1.6821358101592572, "ppl/zlib": 0.0007134795548155012, "Min_5.0% Prob": 5.681790677706401, "Min_10.0% Prob": 3.926350998096779, "Min_20.0% Prob": 2.357695338202686, "Min_30.0% Prob": 1.6373299376384631, "Min_40.0% Prob": 1.2397644264615981, "Min_50.0% Prob": 0.9944317315442903, "Min_60.0% Prob": 0.8292013724187686}}
{"hexsha": "2b9b079b4bb4f9b3f97e92da560029a5b16f5413", "ext": "java", "lang": "Java", "content": "public class TwoDimensional{\n\n\tpublic static void main(String... args){\n\t\n\t\tint[] x[] = new int[1][1]; //2d array\n\t\tint[] y,z [],ap[][]; //1d , 2d, 3d array , \n\n\t\t//int[] y, []z; this is not valid only after the variable if split\n\t\t\t\n\t\n\t}\n\n\n\n\n}", "class_id": 0, "repo": "jansen07/oca-review", "file": "chapter3/arrays/2dimensional/TwoDimensional.java", "last_update_at": "2018-09-20T01:49:36+00:00", "question_id": "2b9b079b4bb4f9b3f97e92da560029a5b16f5413", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TwoDimensional{\n\tpublic static void main(String... args){\n\t\n\t\tint[] x[] = new int[1][1]; //2d array\n\t\tint[] y,z [],ap[][]; //1d , 2d, 3d array , \n\t\t//int[] y, []z; this is not valid only after the variable if split\n\t\t\t\n\t\n\t}\n"]], "pred": {"ppl": 8.78579044342041, "ppl_lower": 9.763982772827148, "ppl/lowercase_ppl": -1.048577129529664, "ppl/zlib": 0.011810520076502086, "Min_5.0% Prob": 9.641642951965332, "Min_10.0% Prob": 8.388771247863769, "Min_20.0% Prob": 6.687888503074646, "Min_30.0% Prob": 5.515354577700297, "Min_40.0% Prob": 4.601864157653436, "Min_50.0% Prob": 3.9621128474964813, "Min_60.0% Prob": 3.468780903542628}}
{"hexsha": "6364c7e6510e3360dd4dbb7c6351aa86a28aea3b", "ext": "java", "lang": "Java", "content": "public class SelectionSort {\n        \n    private void swap(int array[] , int x , int y){\n        int temp = array[x];\n        array[x] = array[y];\n        array[y] = temp;\n    }\n    \n    public void sorting(int array[]){\n        //i is every item in array \n        for(int i = 0 ; i < array.length ; i++){\n            //Start after i to all right items\n            for(int a = i+1 ; a < array.length ; a++){\n                //if Next Item less than i will swap ^_^\n                if(array[i] > array[a]){\n                    swap(array,i,a);\n                }\n            }\n        }\n}\n}", "class_id": 0, "repo": "AmrDeveloper/DataStructuresAndAlgorithms", "file": "Algorithms/Sorting/SelectionSort.java", "last_update_at": "2018-08-30T23:45:22+00:00", "question_id": "6364c7e6510e3360dd4dbb7c6351aa86a28aea3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SelectionSort {\n    private void swap(int array[] , int x , int y){\n        int temp = array[x];\n        array[x] = array[y];\n        array[y] = temp;\n    }\n    public void sorting(int array[]){\n        //i is every item in array \n        for(int i = 0 ; i < array.length ; i++){\n            //Start after i to all right items\n            for(int a = i+1 ; a < array.length ; a++){\n                //if Next Item less than i will swap ^_^\n                if(array[i] > array[a]){\n                    swap(array,i,a);\n                }\n            }\n        }\n}\n"]], "pred": {"ppl": 2.9539108276367188, "ppl_lower": 2.8032243251800537, "ppl/lowercase_ppl": -0.9516588983250126, "ppl/zlib": 0.004041529838303377, "Min_5.0% Prob": 8.768413543701172, "Min_10.0% Prob": 7.323681943556842, "Min_20.0% Prob": 4.868619663374765, "Min_30.0% Prob": 3.5218296383435908, "Min_40.0% Prob": 2.6823306886213167, "Min_50.0% Prob": 2.152236175427044, "Min_60.0% Prob": 1.8093212070741824}}
{"hexsha": "62f53041d781faff39cb3333062d9690dbb55421", "ext": "java", "lang": "Java", "content": "@Startup\n@Singleton\n@TransactionManagement(TransactionManagementType.BEAN)\npublic class Bootstrap {\n\n    @Inject\n    private Logger logger;\n\n    @Inject\n    private EnvironmentInitializer initializer;\n\n    /**\n     * Initialize and do the job\n     */\n    @PostConstruct\n    protected void initialize() {\n        this.logger.info(\"Initializing application, this may take a few minutes...\");\n        this.initializer.initialize();\n        this.logger.info(\"Initialization finished!\");\n   }\n}", "class_id": 0, "repo": "bbroger/library", "file": "src/main/java/br/eti/arthurgregorio/library/infrastructure/initializer/Bootstrap.java", "last_update_at": "2018-12-30T14:58:00+00:00", "question_id": "62f53041d781faff39cb3333062d9690dbb55421", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Startup\n@Singleton\n@TransactionManagement(TransactionManagementType.BEAN)\npublic class Bootstrap {\n    @Inject\n    private Logger logger;\n    @Inject\n    private EnvironmentInitializer initializer;\n    /**\n     * Initialize and do the job\n     */\n    @PostConstruct\n    protected void initialize() {\n        this.logger.info(\"Initializing application, this may take a few minutes...\");\n        this.initializer.initialize();\n        this.logger.info(\"Initialization finished!\");\n   }\n"]], "pred": {"ppl": 3.1812806129455566, "ppl_lower": 5.272402286529541, "ppl/lowercase_ppl": -1.4365413788480494, "ppl/zlib": 0.0044171138328253316, "Min_5.0% Prob": 7.965732415517171, "Min_10.0% Prob": 6.376505494117737, "Min_20.0% Prob": 4.581005771954854, "Min_30.0% Prob": 3.5920166505707636, "Min_40.0% Prob": 2.795350352112128, "Min_50.0% Prob": 2.3074255033594664, "Min_60.0% Prob": 1.9448447984783617}}
{"hexsha": "3b1e40523bf18f4821c26240437a7878dc5132c6", "ext": "java", "lang": "Java", "content": "public class FragmentWriter {\n\n    public static <S extends MessageSchema<S>> void write(Pipe<S> pipe, int msgIdx) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(2==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeL(Pipe<S> pipe, int msgIdx, long field1) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeLV(Pipe<S> pipe, int msgIdx, long field1,\n    \t\t                                 byte[] field2Backing, int field2Position, int field2Length) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addByteArray(field2Backing, field2Position, field2Length, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    \n    public static <S extends MessageSchema<S>> void writeLL(Pipe<S> pipe, int msgIdx, long field1, long field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addLongValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeLI(Pipe<S> pipe, int msgIdx, long field1, int field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(5==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeII(Pipe<S> pipe, int msgIdx, int field1, int field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addIntValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeLII(Pipe<S> pipe, int msgIdx, long field1, int field2, int field3) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.addIntValue(field3, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    \n    public static <S extends MessageSchema<S>> void writeI(Pipe<S> pipe, int msgIdx, int field1) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(3==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addIntValue(field1, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n}", "class_id": 0, "repo": "nathantippy/PronghornPipes", "file": "src/main/java/com/ociweb/pronghorn/pipe/FragmentWriter.java", "last_update_at": "2018-06-11T02:53:00+00:00", "question_id": "3b1e40523bf18f4821c26240437a7878dc5132c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FragmentWriter {\n    public static <S extends MessageSchema<S>> void write(Pipe<S> pipe, int msgIdx) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(2==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeL(Pipe<S> pipe, int msgIdx, long field1) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeLV(Pipe<S> pipe, int msgIdx, long field1,\n    \t\t                                 byte[] field2Backing, int field2Position, int field2Length) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addByteArray(field2Backing, field2Position, field2Length, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeLL(Pipe<S> pipe, int msgIdx, long field1, long field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addLongValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeLI(Pipe<S> pipe, int msgIdx, long field1, int field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(5==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeII(Pipe<S> pipe, int msgIdx, int field1, int field2) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addIntValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeLII(Pipe<S> pipe, int msgIdx, long field1, int field2, int field3) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addLongValue(field1, pipe);\n    \tPipe.addIntValue(field2, pipe);\n    \tPipe.addIntValue(field3, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n    public static <S extends MessageSchema<S>> void writeI(Pipe<S> pipe, int msgIdx, int field1) {\n    \tassert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));\n    \tassert(3==Pipe.from(pipe).fragDataSize[msgIdx]) : \"This constant does not this fragment size\";\n    \t\n    \tint size = Pipe.addMsgIdx(pipe, msgIdx);\n    \tPipe.addIntValue(field1, pipe);\n    \tPipe.confirmLowLevelWrite(pipe, size);\n    \tPipe.publishWrites(pipe);        \n    }\n"]], "pred": {"ppl": 1.3907251358032227, "ppl_lower": 2.3654351234436035, "ppl/lowercase_ppl": -2.610357700348129, "ppl/zlib": 0.0006857074668370948, "Min_5.0% Prob": 5.113777053122427, "Min_10.0% Prob": 3.1326823184887567, "Min_20.0% Prob": 1.6406304513779926, "Min_30.0% Prob": 1.1001689415272886, "Min_40.0% Prob": 0.8243357455414836, "Min_50.0% Prob": 0.6601380363098526, "Min_60.0% Prob": 0.5503892237318643}}
{"hexsha": "8645fe0ceb9db2e3926ef11d399dddb1a7ba11ba", "ext": "java", "lang": "Java", "content": "public class Medias_array {\r\n    //Local Variables\r\n    private static String name;\r\n    private static String topic;\r\n    \r\n    //Object Variables\r\n    static ArrayList<Double> vector = new ArrayList();\r\n    static ArrayList<Storage> vectorMedia = new ArrayList();\r\n    static Scanner keyboard = new Scanner(System.in);\r\n    \r\n    //Constructor\r\n    public Medias_array() {\r\n    }\r\n    \r\n    //Program: main csll\r\n    public static void main(String[] args) {\r\n        \r\n        do {// Loop do...while - Name checking\r\n            \r\n            System.out.println(\"Introduce tu nombre - Tecla q para salir\");\r\n            name = keyboard.next(); //Variable name = User Name\r\n            \r\n            \r\n            if (!name.equals(\"q\")) { // Conditional if - Depending name.\r\n                do { //True branch - name!=q\r\n                    topic = Int_mat.int_mat(); // Int_mat.java calling - \r\n                    if (!name.equals(\"q\") || !topic.equals(\"q\")) {\r\n                        //max_mat= Int_cant.int_cant();\r\n                        Int_data.int_notas(vector,topic,vectorMedia,name);\r\n                        vector.clear();\r\n                    } else { // False branch - name=q\r\n                        break;\r\n                    }\r\n                } while (!topic.equals(\"q\")); //End - Subject checking\r\n            }\r\n            \r\n            \r\n            \r\n        } while (!name.equals(\"q\")); // End - Name checking\r\n        \r\n        //For each loop - Memory Writing - Nombre,Materia,Nota media de materia\r\n        for (Storage a:vectorMedia) {\r\n            System.out.println(a.getUser() + \"\\t\\t\" + a.getMateria() + \"\\t\\t\" + a.getNotamedia());\r\n        }\r\n        \r\n        \r\n        \r\n        //ArrayList<Double> vector = new ArrayList();\r\n        \r\n        \r\n        \r\n    \r\n    }\r\n    \r\n    /*public static void int_notas (ArrayList<Double> list, String materia) {\r\n            \r\n            //double mark;\r\n            //int cont=1;\r\n            //double media=0;\r\n            \r\n            System.out.println(\"\\nIntroducci\u00f3n de notas. N\u00famero negativo para salir\\n\");\r\n            do {\r\n                \r\n                System.out.println(\"\\tIntroducce la nota \" + cont + \" de la materia \" + materia);\r\n                mark=keyboard.nextDouble();\r\n                if (mark>=0) {\r\n                    list.add(mark);\r\n                }\r\n                cont++;\r\n            } while (mark>=0);\r\n//            list.forEach((a) -> {\r\n            for ( Double a:list ) {\r\n                media+=a;\r\n            }\r\n            media/=list.size(); // media=media/list.size();\r\n            System.out.println(\"\\nMedia de \" + materia + \": \" + df.format(media));\r\n    }*/\r\n\r\n    //Funci\u00f3n que devuelve la cantidad de materias\r\n    /*public static int int_cant() {\r\n        //int cant;\r\n        \r\n        System.out.println(\"Introduce la cantidad de materias de las que quieres obtener la media: \");\r\n        cant = keyboard.nextInt();\r\n        return cant;\r\n    }*/\r\n    \r\n    //Funci\u00f3n que devuelve el nombre de la materia\r\n    /*public static String int_mat() {\r\n        //String mat;\r\n        \r\n        System.out.println(\"Introduce la materia de la que quieres obtener la media: \");\r\n        mat = keyboard.next();\r\n        return mat;\r\n    }*/\r\n    \r\n}", "class_id": 0, "repo": "DAWIIProjectsJava/JAVA", "file": "181009_Medias_ArrayList_JAVA/medias_array/Medias_array.java", "last_update_at": "2018-10-09T14:43:22+00:00", "question_id": "8645fe0ceb9db2e3926ef11d399dddb1a7ba11ba", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Medias_array {\r\n    //Local Variables\r\n    private static String name;\r\n    private static String topic;\r\n    \r\n    //Object Variables\r\n    static ArrayList<Double> vector = new ArrayList();\r\n    static ArrayList<Storage> vectorMedia = new ArrayList();\r\n    static Scanner keyboard = new Scanner(System.in);\r\n    \r\n    //Constructor\r\n    public Medias_array() {\r\n    }\r\n    \r\n    //Program: main csll\r\n    public static void main(String[] args) {\r\n        \r\n        do {// Loop do...while - Name checking\r\n            \r\n            System.out.println(\"Introduce tu nombre - Tecla q para salir\");\r\n            name = keyboard.next(); //Variable name = User Name\r\n            \r\n            \r\n            if (!name.equals(\"q\")) { // Conditional if - Depending name.\r\n                do { //True branch - name!=q\r\n                    topic = Int_mat.int_mat(); // Int_mat.java calling - \r\n                    if (!name.equals(\"q\") || !topic.equals(\"q\")) {\r\n                        //max_mat= Int_cant.int_cant();\r\n                        Int_data.int_notas(vector,topic,vectorMedia,name);\r\n                        vector.clear();\r\n                    } else { // False branch - name=q\r\n                        break;\r\n                    }\r\n                } while (!topic.equals(\"q\")); //End - Subject checking\r\n            }\r\n            \r\n            \r\n            \r\n        } while (!name.equals(\"q\")); // End - Name checking\r\n        \r\n        //For each loop - Memory Writing - Nombre,Materia,Nota media de materia\r\n        for (Storage a:vectorMedia) {\r\n            System.out.println(a.getUser() + \"\\t\\t\" + a.getMateria() + \"\\t\\t\" + a.getNotamedia());\r\n        }\r\n        \r\n        \r\n        \r\n        //ArrayList<Double> vector = new ArrayList();\r\n        \r\n        \r\n        \r\n    \r\n    }\r\n    \r\n    /*public static void int_notas (ArrayList<Double> list, String materia) {\r\n            \r\n            //double mark;\r\n            //int cont=1;\r\n            //double media=0;\r\n            \r\n            System.out.println(\"\\nIntroducci\u00f3n de notas. N\u00famero negativo para salir\\n\");\r\n            do {\r\n                \r\n                System.out.println(\"\\tIntroducce la nota \" + cont + \" de la materia \" + materia);\r\n                mark=keyboard.nextDouble();\r\n                if (mark>=0) {\r\n                    list.add(mark);\r\n                }\r\n                cont++;\r\n            } while (mark>=0);\r\n//            list.forEach((a) -> {\r\n            for ( Double a:list ) {\r\n                media+=a;\r\n            }\r\n            media/=list.size(); // media=media/list.size();\r\n            System.out.println(\"\\nMedia de \" + materia + \": \" + df.format(media));\r\n    }*/\r\n\r\n    //Funci\u00f3n que devuelve la cantidad de materias\r\n    /*public static int int_cant() {\r\n        //int cant;\r\n        \r\n        System.out.println(\"Introduce la cantidad de materias de las que quieres obtener la media: \");\r\n        cant = keyboard.nextInt();\r\n        return cant;\r\n    }*/\r\n    \r\n    //Funci\u00f3n que devuelve el nombre de la materia\r\n    /*public static String int_mat() {\r\n        //String mat;\r\n        \r\n        System.out.println(\"Introduce la materia de la que quieres obtener la media: \");\r\n        mat = keyboard.next();\r\n        return mat;\r\n    }*/\r\n    \r\n"]], "pred": {"ppl": 3.003351926803589, "ppl_lower": 3.051616907119751, "ppl/lowercase_ppl": -1.0144968534350043, "ppl/zlib": 0.001062540071379289, "Min_5.0% Prob": 7.974138683742947, "Min_10.0% Prob": 6.281313361061944, "Min_20.0% Prob": 4.391416076797148, "Min_30.0% Prob": 3.322922541595557, "Min_40.0% Prob": 2.6389688744361077, "Min_50.0% Prob": 2.163563598029414, "Min_60.0% Prob": 1.8225649365591348}}
{"hexsha": "22f5e1ec7540c7cdb7c90cb303edde7dfb8d6272", "ext": "java", "lang": "Java", "content": "public class TrackerListManager extends GuiListManager<Button>\n{\n    private Button[] buttonItems;\n\n    /**\n     * Initialize a new Tracker Manager with a VBox element.\n     * Depending on the methods called, this object will manage the items\n     * in the vbox.\n     * @param vbox The VBox element that is used to display the users.\n     */\n    public TrackerListManager(VBox vbox) throws Exception\n    {\n        super(vbox);\n    }\n\n\n\n    //region GuiListManager implementation\n\n    @Override\n    protected Button[] listItems() throws Exception\n    {\n        // retrieve the tracker data and sort is alphabetically. \n        ArrayList<Tracker> data = TrackerHandler.handler().getAll();\n        Collections.sort(data, new TrackerComparator());\n\n\n\n        Button[] buttons = new Button[data.size()];\n\n        for (int i = 0; i < data.size(); i++)\n        {\n            Tracker tr = data.get(i);\n\n            Button button = new Button(tr.getName());\n            button.setMaxWidth(Double.MAX_VALUE);\n            //button.getStyleClass().add(\"trackerButton\");\n\n            // set button action\n            button.setOnAction(event ->\n            {\n                EditTrackerWindow controller = VistaNavigator.loadVista(VistaNavigator.AppStage.TRACKER_EDIT);\n                controller.init(tr);\n            });\n\n            buttons[i] = button;\n        }\n\n        this.buttonItems = buttons;\n\n        return buttons;\n    }\n\n    /**\n     * Requests the underlying subclass to dereference the current items.\n     */\n    @Override\n    protected void dereference()\n    {\n        if (this.buttonItems == null || this.buttonItems.length == 0)\n            return;\n\n        for (Button b : this.buttonItems)\n        {\n            b.setOnAction(null);\n        }\n\n        this.buttonItems = null;\n    }\n\n    //endregion\n}", "class_id": 0, "repo": "RosettaCube/Prodosia", "file": "src/main/java/com/Bluefix/Prodosia/GUI/Managers/ButtonListManager/TrackerListManager.java", "last_update_at": "2018-05-01T04:43:43+00:00", "question_id": "22f5e1ec7540c7cdb7c90cb303edde7dfb8d6272", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TrackerListManager extends GuiListManager<Button>\n{\n    private Button[] buttonItems;\n    /**\n     * Initialize a new Tracker Manager with a VBox element.\n     * Depending on the methods called, this object will manage the items\n     * in the vbox.\n     * @param vbox The VBox element that is used to display the users.\n     */\n    public TrackerListManager(VBox vbox) throws Exception\n    {\n        super(vbox);\n    }\n    //region GuiListManager implementation\n    @Override\n    protected Button[] listItems() throws Exception\n    {\n        // retrieve the tracker data and sort is alphabetically. \n        ArrayList<Tracker> data = TrackerHandler.handler().getAll();\n        Collections.sort(data, new TrackerComparator());\n        Button[] buttons = new Button[data.size()];\n        for (int i = 0; i < data.size(); i++)\n        {\n            Tracker tr = data.get(i);\n            Button button = new Button(tr.getName());\n            button.setMaxWidth(Double.MAX_VALUE);\n            //button.getStyleClass().add(\"trackerButton\");\n            // set button action\n            button.setOnAction(event ->\n            {\n                EditTrackerWindow controller = VistaNavigator.loadVista(VistaNavigator.AppStage.TRACKER_EDIT);\n                controller.init(tr);\n            });\n            buttons[i] = button;\n        }\n        this.buttonItems = buttons;\n        return buttons;\n    }\n    /**\n     * Requests the underlying subclass to dereference the current items.\n     */\n    @Override\n    protected void dereference()\n    {\n        if (this.buttonItems == null || this.buttonItems.length == 0)\n            return;\n        for (Button b : this.buttonItems)\n        {\n            b.setOnAction(null);\n        }\n        this.buttonItems = null;\n    }\n    //endregion\n"]], "pred": {"ppl": 2.7876529693603516, "ppl_lower": 3.203359365463257, "ppl/lowercase_ppl": -1.1355833466872818, "ppl/zlib": 0.0013348958491941794, "Min_5.0% Prob": 8.160458008448282, "Min_10.0% Prob": 6.156964847019741, "Min_20.0% Prob": 4.264756084704886, "Min_30.0% Prob": 3.1773951917278525, "Min_40.0% Prob": 2.509628498128482, "Min_50.0% Prob": 2.033412769921427, "Min_60.0% Prob": 1.7057883032676526}}
{"hexsha": "1704444939fcf69e719c1bbc4bdecfe0465c939a", "ext": "java", "lang": "Java", "content": "public class Home extends Fragment {\n\n        private SessionManager sessionManager;\n\n\n    public static Home newInstance() {\n        Home fragment = new Home();\n        return fragment;\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n      final View view = inflater.inflate(R.layout.fragment_home, container, false);\n            sessionManager=new SessionManager(getContext());\n            if(sessionManager.isLoggedIn()==false){\n                startActivity(new Intent(getActivity(),WalkThrough.class));\n            }\n\n\n\n        return view;\n\n\n    }\n\n\n}", "class_id": 0, "repo": "scholarbk/Kromfo", "file": "app/src/main/java/scholar/kromfo/Classes/Home.java", "last_update_at": "2018-05-16T13:12:05+00:00", "question_id": "1704444939fcf69e719c1bbc4bdecfe0465c939a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Home extends Fragment {\n        private SessionManager sessionManager;\n    public static Home newInstance() {\n        Home fragment = new Home();\n        return fragment;\n    }\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n      final View view = inflater.inflate(R.layout.fragment_home, container, false);\n            sessionManager=new SessionManager(getContext());\n            if(sessionManager.isLoggedIn()==false){\n                startActivity(new Intent(getActivity(),WalkThrough.class));\n            }\n        return view;\n    }\n"]], "pred": {"ppl": 2.0642518997192383, "ppl_lower": 2.7180490493774414, "ppl/lowercase_ppl": -1.379633925463718, "ppl/zlib": 0.0022578438772900785, "Min_5.0% Prob": 6.973569461277553, "Min_10.0% Prob": 4.847568813959757, "Min_20.0% Prob": 3.1191135221912014, "Min_30.0% Prob": 2.3023913534397775, "Min_40.0% Prob": 1.7941874932675135, "Min_50.0% Prob": 1.4507950157681597, "Min_60.0% Prob": 1.2110095591333352}}
{"hexsha": "0356139950e5a62f7f8bfe6a4c83f9528ef9d54d", "ext": "java", "lang": "Java", "content": "public class JobCopyParticipant extends CopyParticipant {\n\n\tprivate IFile modifiedResource;\n\tprivate static List<IFile> copiedFileList;\n\tprivate static String copyToPath;\n\tprivate static List<IFile> previousJobFiles;\n\t\n\n\n\t@Override\n\tprotected boolean initialize(Object element) {\n\t\tif (element instanceof IFile) {\n\t\t\tthis.modifiedResource = (IFile) element;\n\t\t\tif (modifiedResource == null && StringUtils.isEmpty(modifiedResource.toString())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic RefactoringStatus checkConditions(IProgressMonitor pm, CheckConditionsContext context)\n\t\t\tthrows OperationCanceledException {\n\t\treturn new RefactoringStatus();\n\t}\n\n\t@Override\n\tpublic Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {\n\t\t\n\t\tcopyToPath=getArguments().getDestination().toString();\n\t\tIWorkspaceRoot workSpaceRoot = ResourcesPlugin.getWorkspace().getRoot();\n\t\tIProject project = workSpaceRoot.getProject(copyToPath.split(\"/\")[1]);\n\t\tIFolder jobFolder = project.getFolder(copyToPath.substring(copyToPath.indexOf('/', 2)));\n\t\tpreviousJobFiles=new ArrayList<>();\n\t\tfor (IResource iResource : jobFolder.members()) {\n\t\t\tif (!(iResource instanceof IFolder)) {\n\t\t\t\tIFile iFile = (IFile) iResource;\n\t\t\t\t if (iFile.getFileExtension().equalsIgnoreCase(Messages.JOB_EXT)) {\n\t\t\t\t\t previousJobFiles.add(iFile);\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\tcopiedFileList.add(modifiedResource);\n\t\treturn null;\n\t}\n\n\t\n\t@Override\n\tpublic Change createPreChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {\n\t\treturn super.createPreChange(pm);\n\t}\n\n\n\tpublic static String getCopyToPath() {\n\t\treturn copyToPath;\n\t}\n\n\n\t\n\tpublic static List<IFile> getCopiedFileList() {\n\t\treturn copiedFileList;\n\t}\n\n\tpublic static void setCopiedFileList(List<IFile> copiedFileList) {\n\t\tJobCopyParticipant.copiedFileList = copiedFileList;\n\t}\n\n\tpublic static void cleanUpStaticResourcesAfterPasteOperation()\n\t{\n\t\tcopyToPath=null;\n\t\tcopiedFileList=null;\n\t\tpreviousJobFiles=null;\n\t}\n\t\n\tpublic static List<IFile> getPreviousJobFiles() {\n\t\treturn previousJobFiles;\n\t}\n\n\n\t\n}", "class_id": 0, "repo": "sandeepvasande/Hydrograph", "file": "hydrograph.ui/hydrograph.ui.graph/src/main/java/hydrograph/ui/graph/editor/JobCopyParticipant.java", "last_update_at": "2018-10-31T21:50:58+00:00", "question_id": "0356139950e5a62f7f8bfe6a4c83f9528ef9d54d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JobCopyParticipant extends CopyParticipant {\n\tprivate IFile modifiedResource;\n\tprivate static List<IFile> copiedFileList;\n\tprivate static String copyToPath;\n\tprivate static List<IFile> previousJobFiles;\n\t\n\t@Override\n\tprotected boolean initialize(Object element) {\n\t\tif (element instanceof IFile) {\n\t\t\tthis.modifiedResource = (IFile) element;\n\t\t\tif (modifiedResource == null && StringUtils.isEmpty(modifiedResource.toString())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t@Override\n\tpublic String getName() {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic RefactoringStatus checkConditions(IProgressMonitor pm, CheckConditionsContext context)\n\t\t\tthrows OperationCanceledException {\n\t\treturn new RefactoringStatus();\n\t}\n\t@Override\n\tpublic Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {\n\t\t\n\t\tcopyToPath=getArguments().getDestination().toString();\n\t\tIWorkspaceRoot workSpaceRoot = ResourcesPlugin.getWorkspace().getRoot();\n\t\tIProject project = workSpaceRoot.getProject(copyToPath.split(\"/\")[1]);\n\t\tIFolder jobFolder = project.getFolder(copyToPath.substring(copyToPath.indexOf('/', 2)));\n\t\tpreviousJobFiles=new ArrayList<>();\n\t\tfor (IResource iResource : jobFolder.members()) {\n\t\t\tif (!(iResource instanceof IFolder)) {\n\t\t\t\tIFile iFile = (IFile) iResource;\n\t\t\t\t if (iFile.getFileExtension().equalsIgnoreCase(Messages.JOB_EXT)) {\n\t\t\t\t\t previousJobFiles.add(iFile);\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\tcopiedFileList.add(modifiedResource);\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic Change createPreChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {\n\t\treturn super.createPreChange(pm);\n\t}\n\tpublic static String getCopyToPath() {\n\t\treturn copyToPath;\n\t}\n\t\n\tpublic static List<IFile> getCopiedFileList() {\n\t\treturn copiedFileList;\n\t}\n\tpublic static void setCopiedFileList(List<IFile> copiedFileList) {\n\t\tJobCopyParticipant.copiedFileList = copiedFileList;\n\t}\n\tpublic static void cleanUpStaticResourcesAfterPasteOperation()\n\t{\n\t\tcopyToPath=null;\n\t\tcopiedFileList=null;\n\t\tpreviousJobFiles=null;\n\t}\n\t\n\tpublic static List<IFile> getPreviousJobFiles() {\n\t\treturn previousJobFiles;\n\t}\n\t\n"]], "pred": {"ppl": 1.8016562461853027, "ppl_lower": 2.2486677169799805, "ppl/lowercase_ppl": -1.376472116666348, "ppl/zlib": 0.0007547517674428123, "Min_5.0% Prob": 5.4000575133732385, "Min_10.0% Prob": 4.076900814620542, "Min_20.0% Prob": 2.6574932991618843, "Min_30.0% Prob": 1.897290396704295, "Min_40.0% Prob": 1.4582360233392633, "Min_50.0% Prob": 1.172955983540132, "Min_60.0% Prob": 0.9807813355816685}}
{"hexsha": "87111a89083951f4f7e4c9f771a3827f1f875f2d", "ext": "java", "lang": "Java", "content": "public class FunctionCallExpression implements Expression\n{\n    private static final Pattern signaturePt = Pattern.compile(\"^(\\\\w+)\\\\s*\\\\((.*)\\\\)$\");\n\n    private final String functionName;\n    private final Expression[] argumentExpressions;\n    private final ExpressionMatcher origin;\n    private final FunctionHandler handler;\n    private final int hashCode;\n\n    FunctionCallExpression (ExpressionMatcher matcher, String text) throws ParseException\n    {\n        origin = matcher;\n\n        Matcher m = signaturePt.matcher(text);\n\n        if(!m.find())\n        {\n            throw new ParseException(\"Unable to parse function expression\", 0);\n        }\n\n        functionName = m.group(1);\n        String args = m.group(2).trim();\n\n        ArrayList<Expression> argList = new ArrayList<>();\n        if(args.length() > 0)\n        {\n            int offset = 0, nesting = 0;\n            boolean inQuotes = false;\n            for(int i = 0; i <= args.length(); i++)\n            {\n                char c = i < args.length() ? args.charAt(i) : 0;\n                if(nesting == 0 && (c == ',' && !inQuotes) || c == 0)\n                {\n                    Expression expression;\n\n                    try\n                    {\n                        expression = matcher.match(args.substring(offset, i).trim());\n                    }\n                    catch(RenderingException e)\n                    {\n                        throw new ParseException(\"Could not parse expression of argument \" + argList.size(), 0);\n                    }\n\n                    offset = i + 1;\n                    argList.add(expression);\n                    continue;\n                }\n\n                if(c == '\\'')\n                {\n                    inQuotes = !inQuotes;\n                }\n\n                if(!inQuotes && c == '(')\n                {\n                    nesting++;\n                }\n\n                if(!inQuotes && c == ')')\n                {\n                    nesting--;\n                }\n            }\n        }\n\n        argumentExpressions = argList.stream().toArray(Expression[]::new);\n        handler = origin.getFunctionCatalog().getHandler(functionName);\n\n        {\n            int result = functionName.hashCode();\n            result = 31 * result + Arrays.hashCode(argumentExpressions);\n            result = 31 * result + origin.hashCode();\n            result = 31 * result + (handler != null ? handler.hashCode() : 0);\n\n            hashCode = result;\n        }\n    }\n\n    public Object resolve (Scope scope)\n    {\n        final FunctionHandler _handler = handler != null ?\n            handler : origin.getFunctionCatalog().getHandler(functionName);\n\n        final Object result;\n\n        if(_handler != null)\n        {\n            result = _handler.apply\n            (\n                Arrays.stream(argumentExpressions)\n                    .map((x) -> scope.evaluate(x))\n                    .toArray(Object[]::new)\n            );\n        }\n        else\n        {\n            throw new RenderingException(\"Unknown function: \" + functionName);\n        }\n\n        return result;\n    }\n\n    @Override\n    public Function<Scope, Object> getResolver ()\n    {\n        return this::resolve;\n    }\n\n    public String getFunctionName ()\n    {\n        return functionName;\n    }\n\n    public Expression[] getArgumentExpressions ()\n    {\n        return argumentExpressions;\n    }\n\n    static boolean matches (String text)\n    {\n        return signaturePt.matcher(text).find();\n    }\n\n    @Override\n    public boolean equals (Object o)\n    {\n        if(this == o) return true;\n        if(o == null || getClass() != o.getClass()) return false;\n\n        FunctionCallExpression that = (FunctionCallExpression) o;\n\n        if(hashCode != that.hashCode) return false;\n        if(!functionName.equals(that.functionName)) return false;\n        if(!Arrays.equals(argumentExpressions, that.argumentExpressions)) return false;\n        if(!origin.equals(that.origin)) return false;\n        return handler != null ? handler.equals(that.handler) : that.handler == null;\n    }\n\n    @Override\n    public int hashCode ()\n    {\n        return hashCode;\n    }\n}", "class_id": 0, "repo": "Neticle/ark-templating", "file": "src/main/java/pt/neticle/ark/templating/structure/expressions/FunctionCallExpression.java", "last_update_at": "2018-03-12T20:56:52+00:00", "question_id": "87111a89083951f4f7e4c9f771a3827f1f875f2d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FunctionCallExpression implements Expression\n{\n    private static final Pattern signaturePt = Pattern.compile(\"^(\\\\w+)\\\\s*\\\\((.*)\\\\)$\");\n    private final String functionName;\n    private final Expression[] argumentExpressions;\n    private final ExpressionMatcher origin;\n    private final FunctionHandler handler;\n    private final int hashCode;\n    FunctionCallExpression (ExpressionMatcher matcher, String text) throws ParseException\n    {\n        origin = matcher;\n        Matcher m = signaturePt.matcher(text);\n        if(!m.find())\n        {\n            throw new ParseException(\"Unable to parse function expression\", 0);\n        }\n        functionName = m.group(1);\n        String args = m.group(2).trim();\n        ArrayList<Expression> argList = new ArrayList<>();\n        if(args.length() > 0)\n        {\n            int offset = 0, nesting = 0;\n            boolean inQuotes = false;\n            for(int i = 0; i <= args.length(); i++)\n            {\n                char c = i < args.length() ? args.charAt(i) : 0;\n                if(nesting == 0 && (c == ',' && !inQuotes) || c == 0)\n                {\n                    Expression expression;\n                    try\n                    {\n                        expression = matcher.match(args.substring(offset, i).trim());\n                    }\n                    catch(RenderingException e)\n                    {\n                        throw new ParseException(\"Could not parse expression of argument \" + argList.size(), 0);\n                    }\n                    offset = i + 1;\n                    argList.add(expression);\n                    continue;\n                }\n                if(c == '\\'')\n                {\n                    inQuotes = !inQuotes;\n                }\n                if(!inQuotes && c == '(')\n                {\n                    nesting++;\n                }\n                if(!inQuotes && c == ')')\n                {\n                    nesting--;\n                }\n            }\n        }\n        argumentExpressions = argList.stream().toArray(Expression[]::new);\n        handler = origin.getFunctionCatalog().getHandler(functionName);\n        {\n            int result = functionName.hashCode();\n            result = 31 * result + Arrays.hashCode(argumentExpressions);\n            result = 31 * result + origin.hashCode();\n            result = 31 * result + (handler != null ? handler.hashCode() : 0);\n            hashCode = result;\n        }\n    }\n    public Object resolve (Scope scope)\n    {\n        final FunctionHandler _handler = handler != null ?\n            handler : origin.getFunctionCatalog().getHandler(functionName);\n        final Object result;\n        if(_handler != null)\n        {\n            result = _handler.apply\n            (\n                Arrays.stream(argumentExpressions)\n                    .map((x) -> scope.evaluate(x))\n                    .toArray(Object[]::new)\n            );\n        }\n        else\n        {\n            throw new RenderingException(\"Unknown function: \" + functionName);\n        }\n        return result;\n    }\n    @Override\n    public Function<Scope, Object> getResolver ()\n    {\n        return this::resolve;\n    }\n    public String getFunctionName ()\n    {\n        return functionName;\n    }\n    public Expression[] getArgumentExpressions ()\n    {\n        return argumentExpressions;\n    }\n    static boolean matches (String text)\n    {\n        return signaturePt.matcher(text).find();\n    }\n    @Override\n    public boolean equals (Object o)\n    {\n        if(this == o) return true;\n        if(o == null || getClass() != o.getClass()) return false;\n        FunctionCallExpression that = (FunctionCallExpression) o;\n        if(hashCode != that.hashCode) return false;\n        if(!functionName.equals(that.functionName)) return false;\n        if(!Arrays.equals(argumentExpressions, that.argumentExpressions)) return false;\n        if(!origin.equals(that.origin)) return false;\n        return handler != null ? handler.equals(that.handler) : that.handler == null;\n    }\n    @Override\n    public int hashCode ()\n    {\n        return hashCode;\n    }\n"]], "pred": {"ppl": 1.610794186592102, "ppl_lower": 1.759294867515564, "ppl/lowercase_ppl": -1.1849815120001577, "ppl/zlib": 0.00041132643741983776, "Min_5.0% Prob": 5.192025993384567, "Min_10.0% Prob": 3.6658774520836626, "Min_20.0% Prob": 2.23680473455027, "Min_30.0% Prob": 1.5620750851588312, "Min_40.0% Prob": 1.1851345726942375, "Min_50.0% Prob": 0.9526610690280212, "Min_60.0% Prob": 0.7951534608638045}}
{"hexsha": "4fa466c2fd8417ee84935d8509578afcf0599b9b", "ext": "java", "lang": "Java", "content": "public class DefaultRetryManagerTest {\n    /**\n     * Used to mock the system clock.\n     */\n    private static final long FIXED_TIME = 100000L;\n    private Clock mockClock;\n\n    /**\n     * Handles mocking Clock using Java 1.8's Clock interface.\n     */\n    @Before\n    public void setup() {\n        // Set our clock to be fixed.\n        mockClock = Clock.fixed(Instant.ofEpochMilli(FIXED_TIME), ZoneId.of(\"UTC\"));\n    }\n\n    /**\n     * Tests that the open() set properties from the config.\n     */\n    @Test\n    public void testOpen() {\n        final int expectedMaxRetries = 44;\n        final long expectedMinRetryTimeMs = 4455;\n        final double expectedDelayMultiplier = 4.56;\n        final long expectedMaxDelayMs = 1000;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelayMs);\n\n        // Create instance and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.open(stormConfig);\n\n        assertEquals(\"Wrong max retries\", expectedMaxRetries, retryManager.getRetryLimit());\n        assertEquals(\"Wrong retry time\", expectedMinRetryTimeMs, retryManager.getInitialRetryDelayMs());\n        assertEquals(\"Wrong retry time\", expectedDelayMultiplier, retryManager.getRetryDelayMultiplier(), 0.001);\n        assertEquals(\"Wrong retry time\", expectedMaxDelayMs, retryManager.getRetryDelayMaxMs());\n    }\n\n    /**\n     * Tests that the open() uses default values if not configured.\n     */\n    @Test\n    public void testOpenWithNoConfigUsesDefaults() {\n        // Build config.\n        Map stormConfig = getDefaultConfig(null, null, null, null);\n\n        // Create instance and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.open(stormConfig);\n\n        assertEquals(\"Wrong max retries\", -1, retryManager.getRetryLimit());\n        assertEquals(\"Wrong retry time\", 2000, retryManager.getInitialRetryDelayMs());\n        assertEquals(\"Wrong max delay\", 15 * 60 * 1000, retryManager.getRetryDelayMaxMs());\n        assertEquals(\"Wrong delay multiplier\", 2.0, retryManager.getRetryDelayMultiplier(), 0.01);\n    }\n\n    /**\n     * Tests tracking a new failed messageIds.\n     */\n    @Test\n    public void testFailedSimpleCase() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 44.5;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        // Calculate the 1st retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        final MessageId messageId3 = new MessageId(\"MyTopic\", 0, 103L, consumerId);\n\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Mark 3rd as having failed\n        retryManager.failed(messageId3);\n\n        // Validate it has all three as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId3, 1, firstRetryTime, false);\n    }\n\n    /**\n     * Tests tracking a new failed messageId.\n     */\n    @Test\n    public void testFailedMultipleFails() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 11.25;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Now fail messageId1 a second time.\n        retryManager.failed(messageId1);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Now fail messageId1 a 3rd time.\n        retryManager.failed(messageId1);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Now fail messageId2 a 2nd time.\n        retryManager.failed(messageId2);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n    }\n\n    /**\n     * Tests what happens if a tuple fails more than our max fail limit.\n     */\n    @Test\n    public void testRetryDelayWhenExceedsMaxTimeDelaySetting() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a multiplier of 10\n        final double expectedDelayMultiplier = 5;\n\n        // Set a max delay of 12 seconds\n        final long expectedMaxDelay = 12000;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelay);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + expectedMaxDelay;\n\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n\n        // Now fail messageId1 a second time.\n        retryManager.failed(messageId1);\n\n        // Validate it incremented our delay time, still below configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n\n        // Now fail messageId1 a 3rd time.\n        retryManager.failed(messageId1);\n\n        // Validate its pinned at configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n\n        // Now fail messageId1 a 4th time.\n        retryManager.failed(messageId1);\n\n        // Validate its still pinned at configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 4, thirdRetryTime, false);\n    }\n\n\n    /**\n     * Tests that all previously un-tracked messageIds should be retried.\n     */\n    @Test\n    public void testRetryFurtherForUntrackedMessageId() {\n        // construct manager\n        final int expectedMaxRetries = 2;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n    }\n\n    /**\n     * Tests retryFurther always returns false if maxRetries is configured to 0.\n     */\n    @Test\n    public void testRetryFurtherForUntrackedMessageIdWithMaxRetriesSetToZero() {\n        // construct manager\n        final int expectedMaxRetries = 0;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n\n        for (int x = 0; x < 100; x++) {\n            assertFalse(\"Should always be false because we are configured to never retry\", retryManager.retryFurther(messageId));\n        }\n    }\n\n    /**\n     * Tests retryFurther always returns true if maxRetries is configured to a value less than 0.\n     */\n    @Test\n    public void testRetryFurtherWithMaxRetriesSetNegative() {\n        // construct manager\n        final int expectedMaxRetries = -1;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n\n        for (int x = 0;  x < 100; x++) {\n            // Fail tuple\n            retryManager.failed(messageId);\n\n            // See if we should retry\n            assertTrue(\"Should always be true because we are configured to always retry\", retryManager.retryFurther(messageId));\n        }\n    }\n\n    /**\n     * Tests what happens if a tuple fails more than our max fail limit.\n     */\n    @Test\n    public void testRetryFurtherWhenMessageExceedsRetryLimit() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 1.5;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Validate that we can retry both of these\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n\n        // Fail messageId1 a 2nd time\n        retryManager.failed(messageId1);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Validate that we can retry both of these\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n\n        // Fail messageId1 a 3rd time\n        retryManager.failed(messageId1);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n\n        // Validate that messageId1 cannot be retried, messageId2 can.\n        assertFalse(\"Should NOT be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n    }\n\n    /**\n     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.\n     */\n    @Test\n    public void testNextFailedMessageToRetryWithNothingExpired() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 4.2;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n\n        // Mark both as having been failed.\n        retryManager.failed(messageId1);\n        retryManager.failed(messageId2);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(\n            retryManager,\n            messageId1,\n            1,\n            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),\n            false\n        );\n        validateExpectedFailedMessageId(\n            retryManager,\n            messageId2,\n            1,\n            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),\n            false\n        );\n\n        // Ask for the next tuple to retry, should be empty\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n    }\n\n    /**\n     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.\n     */\n    @Test\n    public void testNextFailedMessageToRetryWithExpiring() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 6.2;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n\n        // Mark messageId1 as having failed\n        retryManager.failed(messageId1);\n\n        // Mark messageId2 as having failed twice\n        retryManager.failed(messageId2);\n        retryManager.failed(messageId2);\n\n        // Calculate the first and 2nd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n\n        // Ask for the next tuple to retry, should be empty\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n\n        // Now advance time by exactly expectedMinRetryTimeMs milliseconds\n        retryManager.setClock(\n            Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)), ZoneId.of(\"UTC\"))\n        );\n\n        // Now messageId1 should expire next,\n        MessageId nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();\n        assertNotNull(\"result should not be null\", nextMessageIdToBeRetried);\n        assertEquals(\"Should be our messageId1\", messageId1, nextMessageIdToBeRetried);\n\n        // Validate the internal state.\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n\n        // Calling nextFailedMessageToRetry should result in null.\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n\n        // Advance time again, by 2x expected retry time, plus a few MS\n        final long newFixedTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier) + 10;\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(newFixedTime), ZoneId.of(\"UTC\")));\n\n        // Now messageId1 should expire next,\n        nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();\n        assertNotNull(\"result should not be null\", nextMessageIdToBeRetried);\n\n        // Validate state.\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);\n\n        // call ack, validate its no longer tracked\n        retryManager.acked(messageId1);\n        validateTupleIsNotBeingTracked(retryManager, messageId1);\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);\n\n        // Calculate time for 3rd fail, against new fixed time\n        final long thirdRetryTime = newFixedTime + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n\n        // Mark tuple2 as having failed\n        retryManager.failed(messageId2);\n        validateTupleIsNotBeingTracked(retryManager, messageId1);\n        validateExpectedFailedMessageId(retryManager, messageId2, 3, thirdRetryTime, false);\n    }\n\n    /**\n     * Validates that when we have multiple failed tuples that need to be retried,\n     * we retry the earliest ones first.\n     */\n    @Test\n    public void testRetryEarliestFailed() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 0;\n        final double expectedDelayMultiplier = 0.5;\n\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        final MessageId messageId3 = new MessageId(\"MyTopic\", 0, 103L, consumerId);\n\n        // Fail messageId 1 @ T0\n        retryManager.failed(messageId1);\n\n        // Increment clock to T1 and fail messageId 2\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 100), ZoneId.of(\"UTC\")));\n        retryManager.failed(messageId2);\n\n        // Increment clock to T2 and fail messageId 3\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 200), ZoneId.of(\"UTC\")));\n        retryManager.failed(messageId3);\n\n        // call 3 times, see what comes out.\n        // We'd expect to get messageId1 since its the oldest, followed by messageId2, and then messageId3\n        final MessageId result1 = retryManager.nextFailedMessageToRetry();\n        final MessageId result2 = retryManager.nextFailedMessageToRetry();\n        final MessageId result3 = retryManager.nextFailedMessageToRetry();\n\n        assertEquals(\"Result1 should be messageId1\", messageId1, result1);\n        assertEquals(\"Result2 should be messageId1\", messageId2, result2);\n        assertEquals(\"Result3 should be messageId1\", messageId3, result3);\n    }\n\n    private void validateExpectedFailedMessageId(\n        DefaultRetryManager retryManager,\n        MessageId messageId,\n        int expectedFailCount,\n        long expectedRetryTime,\n        boolean expectedToBeInFlight\n    ) {\n        // Find its queue\n        Queue<MessageId> failQueue = retryManager.getFailedMessageIds().get(expectedRetryTime);\n        assertNotNull(\n            \"Queue should exist for our retry time of \" + expectedRetryTime + \" has [\" + retryManager.getFailedMessageIds().keySet() + \"]\",\n            failQueue\n        );\n        assertTrue(\"Queue should contain our tuple messageId\", failQueue.contains(messageId));\n\n        // This messageId should have the right number of fails associated with it.\n        assertEquals(\n            \"Should have expected number of fails\",\n            (Integer) expectedFailCount, retryManager.getNumberOfTimesFailed().get(messageId)\n        );\n\n        // Should this be marked as in flight?\n        assertEquals(\"Should or should not be in flight\", expectedToBeInFlight, retryManager.getRetriesInFlight().contains(messageId));\n    }\n\n    private void validateTupleNotInFailedSetButIsInFlight(DefaultRetryManager retryManager, MessageId messageId) {\n        // Loop through all failed tuples\n        for (Long key : retryManager.getFailedMessageIds().keySet()) {\n            Queue queue = retryManager.getFailedMessageIds().get(key);\n            assertFalse(\"Should not contain our messageId\", queue.contains(messageId));\n        }\n        assertTrue(\"Should be tracked as in flight\", retryManager.getRetriesInFlight().contains(messageId));\n    }\n\n    private void validateTupleIsNotBeingTracked(DefaultRetryManager retryManager, MessageId messageId) {\n        // Loop through all failed tuples\n        for (Long key : retryManager.getFailedMessageIds().keySet()) {\n            Queue queue = retryManager.getFailedMessageIds().get(key);\n            assertFalse(\"Should not contain our messageId\", queue.contains(messageId));\n        }\n        assertFalse(\"Should not be tracked as in flight\", retryManager.getRetriesInFlight().contains(messageId));\n        assertFalse(\"Should not have a fail count\", retryManager.getNumberOfTimesFailed().containsKey(messageId));\n    }\n\n    // Helper method\n    private Map getDefaultConfig(Integer maxRetries, Long minRetryTimeMs, Double delayMultiplier, Long expectedMaxDelayMs) {\n        Map stormConfig = Maps.newHashMap();\n        if (maxRetries != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_RETRY_LIMIT, maxRetries);\n        }\n        if (minRetryTimeMs != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_INITIAL_DELAY_MS, minRetryTimeMs);\n        }\n        if (delayMultiplier != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_DELAY_MULTIPLIER, delayMultiplier);\n        }\n        if (expectedMaxDelayMs != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_MAX_DELAY_MS, expectedMaxDelayMs);\n        }\n        return stormConfig;\n    }\n}", "class_id": 0, "repo": "mmoldavan/storm-dynamic-spout", "file": "src/test/java/com/salesforce/storm/spout/dynamic/retry/DefaultRetryManagerTest.java", "last_update_at": "2018-05-18T23:33:05+00:00", "question_id": "4fa466c2fd8417ee84935d8509578afcf0599b9b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DefaultRetryManagerTest {\n    /**\n     * Used to mock the system clock.\n     */\n    private static final long FIXED_TIME = 100000L;\n    private Clock mockClock;\n    /**\n     * Handles mocking Clock using Java 1.8's Clock interface.\n     */\n    @Before\n    public void setup() {\n        // Set our clock to be fixed.\n        mockClock = Clock.fixed(Instant.ofEpochMilli(FIXED_TIME), ZoneId.of(\"UTC\"));\n    }\n    /**\n     * Tests that the open() set properties from the config.\n     */\n    @Test\n    public void testOpen() {\n        final int expectedMaxRetries = 44;\n        final long expectedMinRetryTimeMs = 4455;\n        final double expectedDelayMultiplier = 4.56;\n        final long expectedMaxDelayMs = 1000;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelayMs);\n        // Create instance and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.open(stormConfig);\n        assertEquals(\"Wrong max retries\", expectedMaxRetries, retryManager.getRetryLimit());\n        assertEquals(\"Wrong retry time\", expectedMinRetryTimeMs, retryManager.getInitialRetryDelayMs());\n        assertEquals(\"Wrong retry time\", expectedDelayMultiplier, retryManager.getRetryDelayMultiplier(), 0.001);\n        assertEquals(\"Wrong retry time\", expectedMaxDelayMs, retryManager.getRetryDelayMaxMs());\n    }\n    /**\n     * Tests that the open() uses default values if not configured.\n     */\n    @Test\n    public void testOpenWithNoConfigUsesDefaults() {\n        // Build config.\n        Map stormConfig = getDefaultConfig(null, null, null, null);\n        // Create instance and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.open(stormConfig);\n        assertEquals(\"Wrong max retries\", -1, retryManager.getRetryLimit());\n        assertEquals(\"Wrong retry time\", 2000, retryManager.getInitialRetryDelayMs());\n        assertEquals(\"Wrong max delay\", 15 * 60 * 1000, retryManager.getRetryDelayMaxMs());\n        assertEquals(\"Wrong delay multiplier\", 2.0, retryManager.getRetryDelayMultiplier(), 0.01);\n    }\n    /**\n     * Tests tracking a new failed messageIds.\n     */\n    @Test\n    public void testFailedSimpleCase() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 44.5;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        // Calculate the 1st retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        final MessageId messageId3 = new MessageId(\"MyTopic\", 0, 103L, consumerId);\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Mark 3rd as having failed\n        retryManager.failed(messageId3);\n        // Validate it has all three as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId3, 1, firstRetryTime, false);\n    }\n    /**\n     * Tests tracking a new failed messageId.\n     */\n    @Test\n    public void testFailedMultipleFails() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 11.25;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Now fail messageId1 a second time.\n        retryManager.failed(messageId1);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Now fail messageId1 a 3rd time.\n        retryManager.failed(messageId1);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Now fail messageId2 a 2nd time.\n        retryManager.failed(messageId2);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n    }\n    /**\n     * Tests what happens if a tuple fails more than our max fail limit.\n     */\n    @Test\n    public void testRetryDelayWhenExceedsMaxTimeDelaySetting() {\n        // construct manager\n        final int expectedMaxRetries = 10;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a multiplier of 10\n        final double expectedDelayMultiplier = 5;\n        // Set a max delay of 12 seconds\n        final long expectedMaxDelay = 12000;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelay);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + expectedMaxDelay;\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        // Now fail messageId1 a second time.\n        retryManager.failed(messageId1);\n        // Validate it incremented our delay time, still below configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n        // Now fail messageId1 a 3rd time.\n        retryManager.failed(messageId1);\n        // Validate its pinned at configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        // Now fail messageId1 a 4th time.\n        retryManager.failed(messageId1);\n        // Validate its still pinned at configured max delay\n        validateExpectedFailedMessageId(retryManager, messageId1, 4, thirdRetryTime, false);\n    }\n    /**\n     * Tests that all previously un-tracked messageIds should be retried.\n     */\n    @Test\n    public void testRetryFurtherForUntrackedMessageId() {\n        // construct manager\n        final int expectedMaxRetries = 2;\n        final long expectedMinRetryTimeMs = 1000;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n        assertTrue(\"Should always be true because its untracked\", retryManager.retryFurther(messageId));\n    }\n    /**\n     * Tests retryFurther always returns false if maxRetries is configured to 0.\n     */\n    @Test\n    public void testRetryFurtherForUntrackedMessageIdWithMaxRetriesSetToZero() {\n        // construct manager\n        final int expectedMaxRetries = 0;\n        final long expectedMinRetryTimeMs = 1000;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n        for (int x = 0; x < 100; x++) {\n            assertFalse(\"Should always be false because we are configured to never retry\", retryManager.retryFurther(messageId));\n        }\n    }\n    /**\n     * Tests retryFurther always returns true if maxRetries is configured to a value less than 0.\n     */\n    @Test\n    public void testRetryFurtherWithMaxRetriesSetNegative() {\n        // construct manager\n        final int expectedMaxRetries = -1;\n        final long expectedMinRetryTimeMs = 1000;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId = new MessageId(\"MyTopic\", 0, 100L, consumerId);\n        for (int x = 0;  x < 100; x++) {\n            // Fail tuple\n            retryManager.failed(messageId);\n            // See if we should retry\n            assertTrue(\"Should always be true because we are configured to always retry\", retryManager.retryFurther(messageId));\n        }\n    }\n    /**\n     * Tests what happens if a tuple fails more than our max fail limit.\n     */\n    @Test\n    public void testRetryFurtherWhenMessageExceedsRetryLimit() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 1.5;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        // Calculate the 1st, 2nd, and 3rd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        // Mark first as having failed\n        retryManager.failed(messageId1);\n        // Validate it has failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        // Mark second as having failed\n        retryManager.failed(messageId2);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Validate that we can retry both of these\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n        // Fail messageId1 a 2nd time\n        retryManager.failed(messageId1);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Validate that we can retry both of these\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n        // Fail messageId1 a 3rd time\n        retryManager.failed(messageId1);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);\n        // Validate that messageId1 cannot be retried, messageId2 can.\n        assertFalse(\"Should NOT be able to retry\", retryManager.retryFurther(messageId1));\n        assertTrue(\"Should be able to retry\", retryManager.retryFurther(messageId2));\n    }\n    /**\n     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.\n     */\n    @Test\n    public void testNextFailedMessageToRetryWithNothingExpired() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 4.2;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        // Mark both as having been failed.\n        retryManager.failed(messageId1);\n        retryManager.failed(messageId2);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(\n            retryManager,\n            messageId1,\n            1,\n            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),\n            false\n        );\n        validateExpectedFailedMessageId(\n            retryManager,\n            messageId2,\n            1,\n            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),\n            false\n        );\n        // Ask for the next tuple to retry, should be empty\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n    }\n    /**\n     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.\n     */\n    @Test\n    public void testNextFailedMessageToRetryWithExpiring() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 1000;\n        // Use a wacky multiplier, because why not?\n        final double expectedDelayMultiplier = 6.2;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        // Mark messageId1 as having failed\n        retryManager.failed(messageId1);\n        // Mark messageId2 as having failed twice\n        retryManager.failed(messageId2);\n        retryManager.failed(messageId2);\n        // Calculate the first and 2nd fail retry times\n        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        // Validate it has first two as failed\n        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n        // Ask for the next tuple to retry, should be empty\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        // Now advance time by exactly expectedMinRetryTimeMs milliseconds\n        retryManager.setClock(\n            Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)), ZoneId.of(\"UTC\"))\n        );\n        // Now messageId1 should expire next,\n        MessageId nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();\n        assertNotNull(\"result should not be null\", nextMessageIdToBeRetried);\n        assertEquals(\"Should be our messageId1\", messageId1, nextMessageIdToBeRetried);\n        // Validate the internal state.\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);\n        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);\n        // Calling nextFailedMessageToRetry should result in null.\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        assertNull(\"Should be null\", retryManager.nextFailedMessageToRetry());\n        // Advance time again, by 2x expected retry time, plus a few MS\n        final long newFixedTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier) + 10;\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(newFixedTime), ZoneId.of(\"UTC\")));\n        // Now messageId1 should expire next,\n        nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();\n        assertNotNull(\"result should not be null\", nextMessageIdToBeRetried);\n        // Validate state.\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);\n        // call ack, validate its no longer tracked\n        retryManager.acked(messageId1);\n        validateTupleIsNotBeingTracked(retryManager, messageId1);\n        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);\n        // Calculate time for 3rd fail, against new fixed time\n        final long thirdRetryTime = newFixedTime + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);\n        // Mark tuple2 as having failed\n        retryManager.failed(messageId2);\n        validateTupleIsNotBeingTracked(retryManager, messageId1);\n        validateExpectedFailedMessageId(retryManager, messageId2, 3, thirdRetryTime, false);\n    }\n    /**\n     * Validates that when we have multiple failed tuples that need to be retried,\n     * we retry the earliest ones first.\n     */\n    @Test\n    public void testRetryEarliestFailed() {\n        // construct manager\n        final int expectedMaxRetries = 3;\n        final long expectedMinRetryTimeMs = 0;\n        final double expectedDelayMultiplier = 0.5;\n        // Build config.\n        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);\n        // Create instance, inject our mock clock,  and call open.\n        DefaultRetryManager retryManager = new DefaultRetryManager();\n        retryManager.setClock(mockClock);\n        retryManager.open(stormConfig);\n        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier(\"MyConsumerId\");\n        // Define our tuple message id\n        final MessageId messageId1 = new MessageId(\"MyTopic\", 0, 101L, consumerId);\n        final MessageId messageId2 = new MessageId(\"MyTopic\", 0, 102L, consumerId);\n        final MessageId messageId3 = new MessageId(\"MyTopic\", 0, 103L, consumerId);\n        // Fail messageId 1 @ T0\n        retryManager.failed(messageId1);\n        // Increment clock to T1 and fail messageId 2\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 100), ZoneId.of(\"UTC\")));\n        retryManager.failed(messageId2);\n        // Increment clock to T2 and fail messageId 3\n        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 200), ZoneId.of(\"UTC\")));\n        retryManager.failed(messageId3);\n        // call 3 times, see what comes out.\n        // We'd expect to get messageId1 since its the oldest, followed by messageId2, and then messageId3\n        final MessageId result1 = retryManager.nextFailedMessageToRetry();\n        final MessageId result2 = retryManager.nextFailedMessageToRetry();\n        final MessageId result3 = retryManager.nextFailedMessageToRetry();\n        assertEquals(\"Result1 should be messageId1\", messageId1, result1);\n        assertEquals(\"Result2 should be messageId1\", messageId2, result2);\n        assertEquals(\"Result3 should be messageId1\", messageId3, result3);\n    }\n    private void validateExpectedFailedMessageId(\n        DefaultRetryManager retryManager,\n        MessageId messageId,\n        int expectedFailCount,\n        long expectedRetryTime,\n        boolean expectedToBeInFlight\n    ) {\n        // Find its queue\n        Queue<MessageId> failQueue = retryManager.getFailedMessageIds().get(expectedRetryTime);\n        assertNotNull(\n            \"Queue should exist for our retry time of \" + expectedRetryTime + \" has [\" + retryManager.getFailedMessageIds().keySet() + \"]\",\n            failQueue\n        );\n        assertTrue(\"Queue should contain our tuple messageId\", failQueue.contains(messageId));\n        // This messageId should have the right number of fails associated with it.\n        assertEquals(\n            \"Should have expected number of fails\",\n            (Integer) expectedFailCount, retryManager.getNumberOfTimesFailed().get(messageId)\n        );\n        // Should this be marked as in flight?\n        assertEquals(\"Should or should not be in flight\", expectedToBeInFlight, retryManager.getRetriesInFlight().contains(messageId));\n    }\n    private void validateTupleNotInFailedSetButIsInFlight(DefaultRetryManager retryManager, MessageId messageId) {\n        // Loop through all failed tuples\n        for (Long key : retryManager.getFailedMessageIds().keySet()) {\n            Queue queue = retryManager.getFailedMessageIds().get(key);\n            assertFalse(\"Should not contain our messageId\", queue.contains(messageId));\n        }\n        assertTrue(\"Should be tracked as in flight\", retryManager.getRetriesInFlight().contains(messageId));\n    }\n    private void validateTupleIsNotBeingTracked(DefaultRetryManager retryManager, MessageId messageId) {\n        // Loop through all failed tuples\n        for (Long key : retryManager.getFailedMessageIds().keySet()) {\n            Queue queue = retryManager.getFailedMessageIds().get(key);\n            assertFalse(\"Should not contain our messageId\", queue.contains(messageId));\n        }\n        assertFalse(\"Should not be tracked as in flight\", retryManager.getRetriesInFlight().contains(messageId));\n        assertFalse(\"Should not have a fail count\", retryManager.getNumberOfTimesFailed().containsKey(messageId));\n    }\n    // Helper method\n    private Map getDefaultConfig(Integer maxRetries, Long minRetryTimeMs, Double delayMultiplier, Long expectedMaxDelayMs) {\n        Map stormConfig = Maps.newHashMap();\n        if (maxRetries != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_RETRY_LIMIT, maxRetries);\n        }\n        if (minRetryTimeMs != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_INITIAL_DELAY_MS, minRetryTimeMs);\n        }\n        if (delayMultiplier != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_DELAY_MULTIPLIER, delayMultiplier);\n        }\n        if (expectedMaxDelayMs != null) {\n            stormConfig.put(SpoutConfig.RETRY_MANAGER_MAX_DELAY_MS, expectedMaxDelayMs);\n        }\n        return stormConfig;\n    }\n"]], "pred": {"ppl": 1.9852063655853271, "ppl_lower": 2.1678249835968018, "ppl/lowercase_ppl": -1.1283338876951774, "ppl/zlib": 0.0002089344519338593, "Min_5.0% Prob": 6.613540682138181, "Min_10.0% Prob": 4.806491300171497, "Min_20.0% Prob": 3.1077054215996873, "Min_30.0% Prob": 2.2321619851137298, "Min_40.0% Prob": 1.7053104580304879, "Min_50.0% Prob": 1.3703826109016652, "Min_60.0% Prob": 1.1437700913184388}}
{"hexsha": "1a056898b8f77c85a861111da2ff9e3a2b25e035", "ext": "java", "lang": "Java", "content": "@ApiModel(value = \"Collection Set Response\")\npublic class CollectionResponse implements Comparable<CollectionResponse> {\n\n    @ApiModelProperty(value = \"Name of the collection\")\n    private String collectionName;\n\n    @ApiModelProperty(value = \"Array of Canned Sets\", dataType = \"CannedSetResponse[]\")\n    private CannedSetResponse[] cannedSets;\n\n\n    public CollectionResponse() {\n\n    }\n\n    public CollectionResponse(\n            @JsonProperty(\"collectionName\") String collectionName,\n            @JsonProperty(\"cannedSets\") CannedSetResponse[] cannedSets\n\n    ) {\n        this.collectionName = collectionName;\n        this.cannedSets = cannedSets;\n    }\n\n    public String getCollectionName() {\n        return collectionName;\n    }\n\n    public void setCollectionName(String collectionName) {\n        this.collectionName = collectionName;\n    }\n\n    public CannedSetResponse[] getCannedSets() {\n        return cannedSets;\n    }\n\n    public void setCannedSets(CannedSetResponse[] cannedSets) {\n        this.cannedSets = cannedSets;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n\n        CollectionResponse that = (CollectionResponse) o;\n\n        if (!Arrays.equals(cannedSets, that.cannedSets))\n            return false;\n        if (!collectionName.equals(that.collectionName))\n            return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = collectionName.hashCode();\n        result = 31 * result + Arrays.hashCode(cannedSets);\n        return result;\n    }\n\n    @Override\n    public int compareTo(CollectionResponse o) {\n        return collectionName.compareTo(o.collectionName);\n    }\n}", "class_id": 0, "repo": "OathAdPlatforms/aol-on-forecast", "file": "server/src/main/java/com/aol/one/reporting/forecastapi/server/model/response/CollectionResponse.java", "last_update_at": "2018-08-09T14:26:30+00:00", "question_id": "1a056898b8f77c85a861111da2ff9e3a2b25e035", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApiModel(value = \"Collection Set Response\")\npublic class CollectionResponse implements Comparable<CollectionResponse> {\n    @ApiModelProperty(value = \"Name of the collection\")\n    private String collectionName;\n    @ApiModelProperty(value = \"Array of Canned Sets\", dataType = \"CannedSetResponse[]\")\n    private CannedSetResponse[] cannedSets;\n    public CollectionResponse() {\n    }\n    public CollectionResponse(\n            @JsonProperty(\"collectionName\") String collectionName,\n            @JsonProperty(\"cannedSets\") CannedSetResponse[] cannedSets\n    ) {\n        this.collectionName = collectionName;\n        this.cannedSets = cannedSets;\n    }\n    public String getCollectionName() {\n        return collectionName;\n    }\n    public void setCollectionName(String collectionName) {\n        this.collectionName = collectionName;\n    }\n    public CannedSetResponse[] getCannedSets() {\n        return cannedSets;\n    }\n    public void setCannedSets(CannedSetResponse[] cannedSets) {\n        this.cannedSets = cannedSets;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        CollectionResponse that = (CollectionResponse) o;\n        if (!Arrays.equals(cannedSets, that.cannedSets))\n            return false;\n        if (!collectionName.equals(that.collectionName))\n            return false;\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        int result = collectionName.hashCode();\n        result = 31 * result + Arrays.hashCode(cannedSets);\n        return result;\n    }\n    @Override\n    public int compareTo(CollectionResponse o) {\n        return collectionName.compareTo(o.collectionName);\n    }\n"]], "pred": {"ppl": 1.3731452226638794, "ppl_lower": 1.580642819404602, "ppl/lowercase_ppl": -1.4437905817684658, "ppl/zlib": 0.0006329418992477484, "Min_5.0% Prob": 4.966155673066775, "Min_10.0% Prob": 2.920117901296032, "Min_20.0% Prob": 1.5607427002063818, "Min_30.0% Prob": 1.0525374468859463, "Min_40.0% Prob": 0.7916036718786333, "Min_50.0% Prob": 0.6338517467377289, "Min_60.0% Prob": 0.5284010926782245}}
{"hexsha": "80ee9eb9244a53e1a98ecd558017547a5c033cb8", "ext": "java", "lang": "Java", "content": "public class Fit3DSiteAlignment implements Fit3D {\n\n    private static final Logger logger = LoggerFactory.getLogger(Fit3DSiteAlignment.class);\n    private static final int PERMUTATION_CUTOFF = 3;\n\n    private final StructuralMotif site1;\n    private final StructuralMotif site2;\n\n    private final LinkedHashSet<List<LeafSubstructure<?>>> site1Partitions;\n    private final LinkedHashSet<List<LeafSubstructure<?>>> site2Partitions;\n\n    private final RepresentationScheme representationScheme;\n    private final Predicate<Atom> atomFilter;\n    private final double rmsdCutoff;\n    private final double distanceTolerance;\n    private final boolean exhaustive;\n    private final boolean restrictToExchanges;\n    private final SubstitutionMatrix substitutionMatrix;\n    private final boolean containsNonAminoAcids;\n    private final boolean kuhnMunkres;\n\n    private final double cutoffScore;\n    private final List<Fit3DMatch> matches;\n    private int currentAlignmentSize;\n    private LabeledRegularMatrix<List<LeafSubstructure<?>>> currentSimilarityMatrix;\n    private Pair<List<LeafSubstructure<?>>> currentBestMatchingPair;\n    private double currentBestScore;\n    private SubstructureSuperimposition currentBestSuperimposition;\n    private String alignmentString;\n    private boolean cutoffScoreReached;\n    private XieScore xieScore;\n    private PsScore psScore;\n    private List<Pair<LeafSubstructure<?>>> assignment;\n\n    public Fit3DSiteAlignment(Fit3DBuilder.Builder builder) throws SubstructureSuperimpositionException {\n        site1 = builder.site1.getCopy();\n        site2 = builder.site2.getCopy();\n\n        containsNonAminoAcids = site1.getAllLeafSubstructures().stream()\n                .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily)) ||\n                site1.getAllLeafSubstructures().stream()\n                        .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily));\n\n        if (containsNonAminoAcids) {\n            logger.warn(\"sites contain non-amino acid residues, no Xie and PS-scores can be calculated\");\n        }\n\n        exhaustive = builder.exhaustive;\n        kuhnMunkres = builder.kuhnMunkres;\n        restrictToExchanges = builder.restrictToExchanges;\n\n        // add exchanges against arbitrary types if not restricted\n        if (!restrictToExchanges) {\n            logger.warn(\"specified exchanges will be ignored for the Fit3DSite alignment and matched types will be arbitrary\");\n        }\n\n        currentAlignmentSize = 2;\n        currentBestScore = Double.MAX_VALUE;\n\n        logger.debug(\"calculating initial 2-partitions\");\n        site1Partitions = createInitialPartitions(site1);\n        site2Partitions = createInitialPartitions(site2);\n\n        cutoffScore = builder.cutoffScore;\n\n        atomFilter = builder.atomFilter;\n        representationScheme = builder.representationScheme;\n\n        rmsdCutoff = builder.rmsdCutoff;\n        distanceTolerance = builder.distanceTolerance;\n\n        substitutionMatrix = builder.substitutionMatrix;\n\n        // initialize\n        matches = new ArrayList<>();\n\n        logger.info(\"computing Fit3DSite alignment for {} (size: {}) against {} (size: {}) with cutoff score {}\", site1,\n                site1.size(), site2, site2.size(), cutoffScore);\n\n        // combinatorial extension alignment if Kuhn-Munkres is not used\n        if (!kuhnMunkres) {\n            logger.debug(\"using combinatorial extension to find alignment\");\n            calculateSimilarities();\n            extendAlignment();\n        } else {\n            logger.debug(\"using Kuhn-Munkres optimization with substitution matrix {} to find alignment\", substitutionMatrix);\n            calculateAssignment();\n            calculateAlignment();\n        }\n\n        Collections.sort(matches);\n    }\n\n    @Override\n    public PsScore getPsScore() {\n        return psScore;\n    }\n\n    @Override\n    public XieScore getXieScore() {\n        return xieScore;\n    }\n\n    @Override\n    public String getAlignmentString() {\n        return alignmentString;\n    }\n\n    /**\n     * Iteratively extends the alignment until a cutoff score is exceeded or one site is fully aligned.\n     */\n    private void extendAlignment() {\n\n        // iteratively extend alignment\n        while (currentBestScore <= cutoffScore) {\n            // terminate if one site is fully aligned\n            if (site1.size() == currentAlignmentSize || site2.size() == currentAlignmentSize) {\n                logger.debug(\"alignment fully terminated after {} iterations\", currentAlignmentSize);\n                break;\n            }\n            // extent site partitions\n            extendPartitions();\n            // recalculate similarities\n            calculateSimilarities();\n            if (cutoffScoreReached) {\n                logger.debug(\"alignment reached cutoff score of {}\", cutoffScore);\n                break;\n            }\n        }\n\n        if (currentBestSuperimposition != null) {\n            matches.add(Fit3DMatch.of(currentBestScore, currentBestSuperimposition));\n            if (!containsNonAminoAcids) {\n                calculateXieScore();\n                calculatePsScore();\n            }\n            outputSummary();\n        } else {\n            logger.debug(\"no suitable alignment could be found\");\n        }\n    }\n\n    private void calculatePsScore() {\n        psScore = PsScore.of(currentBestSuperimposition, site1.getNumberOfLeafSubstructures(),\n                site2.getNumberOfLeafSubstructures());\n    }\n\n    /**\n     * Calculates the ligand binding site similarity score according to dio:10.1093/bioinformatics/btp220.\n     */\n    private void calculateXieScore() {\n        xieScore = XieScore.of(substitutionMatrix, currentBestSuperimposition);\n    }\n\n    /**\n     * Writes the result (the best largest alignment) in string representation.\n     */\n    private void outputSummary() {\n        StringJoiner site1Joiner = new StringJoiner(\"|\", \"|\", \"|\");\n        StringJoiner site2Joiner = new StringJoiner(\"|\", \"|\", \"|\");\n        for (int i = 0; i < currentAlignmentSize; i++) {\n            site1Joiner.add(String.format(\"%-7s\", currentBestSuperimposition.getReference().get(i).toString()));\n            site2Joiner.add(String.format(\"%-7s\", currentBestSuperimposition.getCandidate().get(i).toString()));\n        }\n        alignmentString = String.format(\"%-7s\", \"s1size\") + \"|\" + site1.size() + \"\\n\" +\n                String.format(\"%-7s\", \"s2size\") + \"|\" + site2.size() + \"\\n\" +\n                site1.getAllLeafSubstructures().stream()\n                        .map(LeafSubstructure::toString)\n                        .map(s1 -> String.format(\"%-7s\", s1))\n                        .collect(Collectors.joining(\"|\", String.format(\"%-7s\", \"s1\") + \"|\", \"|\")) + \"\\n\" +\n                site2.getAllLeafSubstructures().stream()\n                        .map(LeafSubstructure::toString)\n                        .map(s1 -> String.format(\"%-7s\", s1))\n                        .collect(Collectors.joining(\"|\", String.format(\"%-7s\", \"s2\") + \"|\", \"|\")) + \"\\n\" +\n                String.format(\"%-7s\", \"RMSD\") + \"|\" + currentBestSuperimposition.getRmsd() + \"\\n\" +\n                String.format(\"%-7s\", \"frac\") + \"|\" + getAlignedResidueFraction() + \"\\n\" +\n                String.format(\"%-7s\", \"XieS\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getXieScore().getScore()) + \"\\n\" +\n                String.format(\"%-7s\", \"XieExp\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getXieScore().getSignificance()) + \"\\n\" +\n                String.format(\"%-7s\", \"PsS\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getPsScore().getScore()) + \"\\n\" +\n                String.format(\"%-7s\", \"PsExp\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getPsScore().getSignificance()) + \"\\n\" +\n                String.format(\"%-7s\", \"s1algn\") + site1Joiner.toString() + \"\\n\" + String.format(\"%-7s\", \"s2algn\") + site2Joiner.toString();\n        logger.debug(\"aligned {} residues (site 1 contains {} residues and site 2 contains {} residues)\\n{}\",\n                currentAlignmentSize, site1.size(), site2.size(), alignmentString);\n    }\n\n    /**\n     * Returns the fraction of successfully aligned residues.\n     *\n     * @return The fraction of aligned residues.\n     */\n    private double getAlignedResidueFraction() {\n        return (site1.size() > site2.size() ? currentAlignmentSize /\n                (double) site2.size() : currentAlignmentSize / (double) site1.size());\n    }\n\n    /**\n     * Extends the partitions of the sites in the current round.\n     */\n    private void extendPartitions() {\n\n        // increment counter for current size of alignment\n        currentAlignmentSize++;\n\n        // remove all old partitions\n        site1Partitions.clear();\n        site2Partitions.clear();\n\n        // create new partitions\n        for (LeafSubstructure<?> leafSubstructure : site1.getAllLeafSubstructures()) {\n            List<LeafSubstructure<?>> site1Partition = new ArrayList<>(currentBestMatchingPair.getFirst());\n            if (!site1Partition.contains(leafSubstructure)) {\n                site1Partition.add(leafSubstructure);\n            }\n            if (site1Partition.size() == currentAlignmentSize) {\n                // permute up to exhaustive cutoff to find ideal alignment seed\n                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {\n                    StreamPermutations.of(site1Partition.toArray(new LeafSubstructure<?>[0]))\n                            .map(s -> s.collect(Collectors.toList()))\n                            .forEach(site1Partitions::add);\n                } else {\n                    site1Partitions.add(site1Partition);\n                }\n            }\n        }\n        for (LeafSubstructure<?> leafSubstructure : site2.getAllLeafSubstructures()) {\n            List<LeafSubstructure<?>> site2Partition = new ArrayList<>(currentBestMatchingPair.getSecond());\n            if (!site2Partition.contains(leafSubstructure)) {\n                site2Partition.add(leafSubstructure);\n            }\n            if (site2Partition.size() == currentAlignmentSize) {\n                // permute up to exhaustive cutoff to find ideal alignment seed\n                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {\n                    StreamPermutations.of(site2Partition.toArray(new LeafSubstructure<?>[0]))\n                            .map(s -> s.collect(Collectors.toList()))\n                            .forEach(site2Partitions::add);\n                } else {\n                    site2Partitions.add(site2Partition);\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculates the similarity scores of the current round, either by naive superimposition or with a {@link\n     * Fit3DAlignment} if exchanges are defined.\n     */\n    private void calculateSimilarities() throws SubstructureSuperimpositionException {\n\n        // reset best score for new iteration\n        double localBestScore = Double.MAX_VALUE;\n\n        // initialize storage for best superimposition of round\n        SubstructureSuperimposition localBestSuperimposition = null;\n\n        double[][] temporarySimilarityMatrix = new double[site1Partitions.size()][site2Partitions.size()];\n\n        List<List<LeafSubstructure<?>>> rowLabels = new ArrayList<>();\n        List<List<LeafSubstructure<?>>> columnLabels = new ArrayList<>();\n        int i = 0;\n        for (List<LeafSubstructure<?>> site1Partition : site1Partitions) {\n            rowLabels.add(site1Partition);\n            int j = 0;\n            for (List<LeafSubstructure<?>> site2Partition : site2Partitions) {\n                if (!columnLabels.contains(site2Partition)) {\n                    columnLabels.add(site2Partition);\n                }\n\n                // use Fit3D if exchanges should be considered, otherwise use exhaustive alignment\n                if (restrictToExchanges) {\n                    // align the subset of sites with Fit3D\n                    StructuralMotif query = site1.getCopy();\n                    List<LeafSubstructure> queryLeavesToBeRemoved = site1.getAllLeafSubstructures().stream()\n                            .filter(leafSubstructure -> !site1Partition.contains(leafSubstructure))\n                            .collect(Collectors.toList());\n                    queryLeavesToBeRemoved.forEach(leafSubstructure -> query.removeLeafSubstructure(leafSubstructure.getIdentifier()));\n                    StructuralMotif target = site2.getCopy();\n                    List<LeafSubstructure> targetLeavesToBeRemoved = site2.getAllLeafSubstructures().stream()\n                            .filter(leafSubstructure -> !site2Partition.contains(leafSubstructure))\n                            .collect(Collectors.toList());\n                    targetLeavesToBeRemoved.forEach(target::removeLeafSubstructure);\n\n                    // configure Fit3D\n                    Fit3D fit3d;\n                    if (representationScheme != null) {\n                        fit3d = Fit3DBuilder.create()\n                                .query(query)\n                                .target(target)\n                                .representationScheme(representationScheme.getType())\n                                .rmsdCutoff(rmsdCutoff)\n                                .distanceTolerance(distanceTolerance)\n                                .run();\n                    } else {\n                        fit3d = Fit3DBuilder.create()\n                                .query(query)\n                                .target(target)\n                                .atomFilter(atomFilter)\n                                .rmsdCutoff(rmsdCutoff)\n                                .distanceTolerance(distanceTolerance)\n                                .run();\n                    }\n\n                    // collect results\n                    if (fit3d.getMatches().isEmpty()) {\n                        temporarySimilarityMatrix[i][j] = Double.MAX_VALUE;\n                    } else {\n                        Fit3DMatch bestMatch = fit3d.getMatches().get(0);\n                        double rmsd = bestMatch.getRmsd();\n                        temporarySimilarityMatrix[i][j] = rmsd;\n                        // test if current score is new global winner and cutoff is not exceeded\n                        if (rmsd < localBestScore) {\n                            localBestSuperimposition = bestMatch.getSubstructureSuperimposition();\n                            localBestScore = rmsd;\n                        }\n                    }\n                } else {\n                    SubstructureSuperimposition superimposition;\n                    if (representationScheme != null) {\n                        if (exhaustive) {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);\n                        } else {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);\n                        }\n                    } else {\n                        if (exhaustive) {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);\n                        } else {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);\n                        }\n                    }\n                    double rmsd = superimposition.getRmsd();\n                    temporarySimilarityMatrix[i][j] = rmsd;\n                    if (rmsd < localBestScore) {\n                        localBestSuperimposition = superimposition;\n                        localBestScore = rmsd;\n                    }\n                }\n                j++;\n            }\n            i++;\n        }\n\n        currentSimilarityMatrix = new LabeledRegularMatrix<>(temporarySimilarityMatrix);\n        currentSimilarityMatrix.setRowLabels(rowLabels);\n        currentSimilarityMatrix.setColumnLabels(columnLabels);\n\n        logger.debug(\"current similarity matrix is \\n{}\", currentSimilarityMatrix.getStringRepresentation());\n\n        // if the minimal element is ambiguous select the first\n        List<Pair<Integer>> minimalScores = Matrices.getPositionsOfMinimalElement(currentSimilarityMatrix);\n        if (!minimalScores.isEmpty()) {\n            List<LeafSubstructure<?>> first = currentSimilarityMatrix.getRowLabel(minimalScores.get(0).getFirst());\n            List<LeafSubstructure<?>> second = currentSimilarityMatrix.getColumnLabel(minimalScores.get(0).getSecond());\n            // if the alignment terminates in the next round do not set new best matching pair and score\n            double scoreValue = currentSimilarityMatrix.getValueFromPosition(minimalScores.get(0));\n            if (scoreValue > cutoffScore) {\n                logger.debug(\"cutoff score exceeded\");\n                currentAlignmentSize--;\n                cutoffScoreReached = true;\n                return;\n            }\n            currentBestMatchingPair = new Pair<>(first, second);\n            currentBestScore = scoreValue;\n            currentBestSuperimposition = localBestSuperimposition;\n            logger.debug(\"current best matching pair of size {} is {} with RMSD {}\", currentAlignmentSize,\n                    currentBestMatchingPair, currentBestScore);\n        } else {\n            if (currentAlignmentSize == 2) {\n                throw new Fit3DException(\"could not find minimal agreement of partitions in first iteration\");\n            }\n            logger.debug(\"no suitable alignment found in iteration {}\", currentAlignmentSize);\n            currentAlignmentSize--;\n            currentBestScore = Double.MAX_VALUE;\n        }\n    }\n\n    /**\n     * Creates the initial 2-partitions of the site alignment.\n     *\n     * @param structuralMotif The {@link StructuralMotif} for which the 2-partitions should be created.\n     * @return The generated set of 2-partitions.\n     */\n    private LinkedHashSet<List<LeafSubstructure<?>>> createInitialPartitions(StructuralMotif structuralMotif) {\n        LinkedHashSet<List<LeafSubstructure<?>>> partitions = new LinkedHashSet<>();\n        List<LeafSubstructure<?>> leafSubstructures = structuralMotif.getAllLeafSubstructures();\n        for (int i = 0; i < leafSubstructures.size() - 1; i++) {\n            for (int j = i + 1; j < leafSubstructures.size(); j++) {\n                List<LeafSubstructure<?>> partition1 = new ArrayList<>();\n                partition1.add(leafSubstructures.get(i));\n                partition1.add(leafSubstructures.get(j));\n                partitions.add(partition1);\n                if (!exhaustive) {\n                    // add first permutation of elements\n                    List<LeafSubstructure<?>> partition2 = new ArrayList<>();\n                    partition2.add(leafSubstructures.get(j));\n                    partition2.add(leafSubstructures.get(i));\n                    partitions.add(partition2);\n                }\n            }\n        }\n        return partitions;\n    }\n\n\n    /**\n     * Calculates the optimal assignment of the input sites using Kuhn-Munkres optimization and the given {@link SubstitutionMatrix}.\n     */\n    private void calculateAssignment() {\n        double[][] costValues = new double[site1.size()][site2.size()];\n        for (int i = 0; i < site1.getNumberOfLeafSubstructures(); i++) {\n            for (int j = 0; j < site2.getNumberOfLeafSubstructures(); j++) {\n                LeafSubstructure<?> residue1 = site1.getAllLeafSubstructures().get(i);\n                LeafSubstructure<?> residue2 = site2.getAllLeafSubstructures().get(j);\n                if (restrictToExchanges && residue1.getFamily() != residue2.getFamily()) {\n                    // exchanges do not penalize the score\n                    if (residue1.getExchangeableFamilies().contains(residue2.getFamily()) ||\n                            residue2.getExchangeableFamilies().contains(residue1.getFamily())) {\n                        continue;\n                    }\n                    costValues[i][j] = Double.MAX_VALUE;\n                    continue;\n                }\n                costValues[i][j] = substitutionMatrix.getMatrix().getValueForLabel(residue1.getFamily(), residue2.getFamily());\n            }\n        }\n        LabeledMatrix<LeafSubstructure<?>> costMatrix = new LabeledRegularMatrix<>(costValues);\n        costMatrix.setRowLabels(site1.getAllLeafSubstructures());\n        costMatrix.setColumnLabels(site2.getAllLeafSubstructures());\n\n        KuhnMunkres<LeafSubstructure<?>> kuhnMunkres = new KuhnMunkres<>(costMatrix);\n        assignment = kuhnMunkres.getAssignedPairs();\n\n        // remove last assigned pair if strong restriction to exchanges is desired\n        if (restrictToExchanges) {\n            assignment.remove(assignment.size() - 1);\n        }\n\n        String assignmentString = kuhnMunkres.getAssignedPairs().stream()\n                .map(pair -> pair.getFirst() + \"+\" + pair.getSecond() + \":\" + costMatrix.getValueForLabel(pair.getFirst(), pair.getSecond()))\n                .collect(Collectors.joining(\"\\n\"));\n\n        logger.debug(\"optimal assignment of binding sites is:\\n{}\", assignmentString);\n    }\n\n\n    /**\n     * Calculates the alignment of sites based on the Kuhn-Munkres assignment.\n     */\n    private void calculateAlignment() {\n        List<LeafSubstructure<?>> reference = assignment.stream()\n                .map(Pair::getFirst)\n                .collect(Collectors.toList());\n        List<LeafSubstructure<?>> candidate = assignment.stream()\n                .map(Pair::getSecond)\n                .collect(Collectors.toList());\n        currentAlignmentSize = reference.size();\n        if (representationScheme != null) {\n            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, representationScheme);\n        } else {\n            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, atomFilter);\n        }\n        currentBestScore = currentBestSuperimposition.getRmsd();\n        matches.add(Fit3DMatch.of(currentBestSuperimposition.getRmsd(), currentBestSuperimposition));\n        if (!containsNonAminoAcids) {\n            calculateXieScore();\n            calculatePsScore();\n        }\n        outputSummary();\n    }\n\n\n    @Override\n    public void writeMatches(Path outputDirectory) {\n        if (matches.isEmpty()) {\n            throw new Fit3DException(\"cannot write matches as they are currently empty\");\n        }\n        SubstructureSuperimposition bestSuperimposition = matches.get(0).getSubstructureSuperimposition();\n        List<LeafSubstructure<?>> mappedSite2 = bestSuperimposition.applyTo(site2.getCopy().getAllLeafSubstructures());\n        try {\n            StructureWriter.writeLeafSubstructures(site1.getAllLeafSubstructures(),\n                    outputDirectory.resolve(site1.getAllLeafSubstructures().stream()\n                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))\n                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + \"-\"\n                                    + leafSubstructure.getIdentifier().getSerial())\n                            .collect(Collectors.joining(\"_\", bestSuperimposition.getFormattedRmsd() + \"_\"\n                                    + site1.getAllLeafSubstructures().get(0).getPdbIdentifier()\n                                    + \"_\", \"\")) + \"_site1.pdb\"));\n            StructureWriter.writeLeafSubstructures(mappedSite2,\n                    outputDirectory.resolve(site2.getAllLeafSubstructures().stream()\n                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))\n                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + \"-\"\n                                    + leafSubstructure.getIdentifier().getSerial())\n                            .collect(Collectors.joining(\"_\", bestSuperimposition.getFormattedRmsd() + \"_\"\n                                    + site2.getAllLeafSubstructures().get(0).getPdbIdentifier()\n                                    + \"_\", \"\")) + \"_site2.pdb\"));\n        } catch (IOException e) {\n            logger.error(\"error writing Fit3DSite results\", e);\n        }\n    }\n\n    @Override\n    public List<Fit3DMatch> getMatches() {\n        return matches;\n    }\n\n    /**\n     * Returns the fraction of aligned residues, in respect to the smaller site.\n     */\n    @Override\n    public double getFraction() {\n        return getAlignedResidueFraction();\n    }\n}", "class_id": 0, "repo": "cleberecht/singa", "file": "singa-structure/src/main/java/bio/singa/structure/algorithms/superimposition/fit3d/Fit3DSiteAlignment.java", "last_update_at": "2018-03-27T10:23:26+00:00", "question_id": "80ee9eb9244a53e1a98ecd558017547a5c033cb8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Fit3DSiteAlignment implements Fit3D {\n    private static final Logger logger = LoggerFactory.getLogger(Fit3DSiteAlignment.class);\n    private static final int PERMUTATION_CUTOFF = 3;\n    private final StructuralMotif site1;\n    private final StructuralMotif site2;\n    private final LinkedHashSet<List<LeafSubstructure<?>>> site1Partitions;\n    private final LinkedHashSet<List<LeafSubstructure<?>>> site2Partitions;\n    private final RepresentationScheme representationScheme;\n    private final Predicate<Atom> atomFilter;\n    private final double rmsdCutoff;\n    private final double distanceTolerance;\n    private final boolean exhaustive;\n    private final boolean restrictToExchanges;\n    private final SubstitutionMatrix substitutionMatrix;\n    private final boolean containsNonAminoAcids;\n    private final boolean kuhnMunkres;\n    private final double cutoffScore;\n    private final List<Fit3DMatch> matches;\n    private int currentAlignmentSize;\n    private LabeledRegularMatrix<List<LeafSubstructure<?>>> currentSimilarityMatrix;\n    private Pair<List<LeafSubstructure<?>>> currentBestMatchingPair;\n    private double currentBestScore;\n    private SubstructureSuperimposition currentBestSuperimposition;\n    private String alignmentString;\n    private boolean cutoffScoreReached;\n    private XieScore xieScore;\n    private PsScore psScore;\n    private List<Pair<LeafSubstructure<?>>> assignment;\n    public Fit3DSiteAlignment(Fit3DBuilder.Builder builder) throws SubstructureSuperimpositionException {\n        site1 = builder.site1.getCopy();\n        site2 = builder.site2.getCopy();\n        containsNonAminoAcids = site1.getAllLeafSubstructures().stream()\n                .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily)) ||\n                site1.getAllLeafSubstructures().stream()\n                        .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily));\n        if (containsNonAminoAcids) {\n            logger.warn(\"sites contain non-amino acid residues, no Xie and PS-scores can be calculated\");\n        }\n        exhaustive = builder.exhaustive;\n        kuhnMunkres = builder.kuhnMunkres;\n        restrictToExchanges = builder.restrictToExchanges;\n        // add exchanges against arbitrary types if not restricted\n        if (!restrictToExchanges) {\n            logger.warn(\"specified exchanges will be ignored for the Fit3DSite alignment and matched types will be arbitrary\");\n        }\n        currentAlignmentSize = 2;\n        currentBestScore = Double.MAX_VALUE;\n        logger.debug(\"calculating initial 2-partitions\");\n        site1Partitions = createInitialPartitions(site1);\n        site2Partitions = createInitialPartitions(site2);\n        cutoffScore = builder.cutoffScore;\n        atomFilter = builder.atomFilter;\n        representationScheme = builder.representationScheme;\n        rmsdCutoff = builder.rmsdCutoff;\n        distanceTolerance = builder.distanceTolerance;\n        substitutionMatrix = builder.substitutionMatrix;\n        // initialize\n        matches = new ArrayList<>();\n        logger.info(\"computing Fit3DSite alignment for {} (size: {}) against {} (size: {}) with cutoff score {}\", site1,\n                site1.size(), site2, site2.size(), cutoffScore);\n        // combinatorial extension alignment if Kuhn-Munkres is not used\n        if (!kuhnMunkres) {\n            logger.debug(\"using combinatorial extension to find alignment\");\n            calculateSimilarities();\n            extendAlignment();\n        } else {\n            logger.debug(\"using Kuhn-Munkres optimization with substitution matrix {} to find alignment\", substitutionMatrix);\n            calculateAssignment();\n            calculateAlignment();\n        }\n        Collections.sort(matches);\n    }\n    @Override\n    public PsScore getPsScore() {\n        return psScore;\n    }\n    @Override\n    public XieScore getXieScore() {\n        return xieScore;\n    }\n    @Override\n    public String getAlignmentString() {\n        return alignmentString;\n    }\n    /**\n     * Iteratively extends the alignment until a cutoff score is exceeded or one site is fully aligned.\n     */\n    private void extendAlignment() {\n        // iteratively extend alignment\n        while (currentBestScore <= cutoffScore) {\n            // terminate if one site is fully aligned\n            if (site1.size() == currentAlignmentSize || site2.size() == currentAlignmentSize) {\n                logger.debug(\"alignment fully terminated after {} iterations\", currentAlignmentSize);\n                break;\n            }\n            // extent site partitions\n            extendPartitions();\n            // recalculate similarities\n            calculateSimilarities();\n            if (cutoffScoreReached) {\n                logger.debug(\"alignment reached cutoff score of {}\", cutoffScore);\n                break;\n            }\n        }\n        if (currentBestSuperimposition != null) {\n            matches.add(Fit3DMatch.of(currentBestScore, currentBestSuperimposition));\n            if (!containsNonAminoAcids) {\n                calculateXieScore();\n                calculatePsScore();\n            }\n            outputSummary();\n        } else {\n            logger.debug(\"no suitable alignment could be found\");\n        }\n    }\n    private void calculatePsScore() {\n        psScore = PsScore.of(currentBestSuperimposition, site1.getNumberOfLeafSubstructures(),\n                site2.getNumberOfLeafSubstructures());\n    }\n    /**\n     * Calculates the ligand binding site similarity score according to dio:10.1093/bioinformatics/btp220.\n     */\n    private void calculateXieScore() {\n        xieScore = XieScore.of(substitutionMatrix, currentBestSuperimposition);\n    }\n    /**\n     * Writes the result (the best largest alignment) in string representation.\n     */\n    private void outputSummary() {\n        StringJoiner site1Joiner = new StringJoiner(\"|\", \"|\", \"|\");\n        StringJoiner site2Joiner = new StringJoiner(\"|\", \"|\", \"|\");\n        for (int i = 0; i < currentAlignmentSize; i++) {\n            site1Joiner.add(String.format(\"%-7s\", currentBestSuperimposition.getReference().get(i).toString()));\n            site2Joiner.add(String.format(\"%-7s\", currentBestSuperimposition.getCandidate().get(i).toString()));\n        }\n        alignmentString = String.format(\"%-7s\", \"s1size\") + \"|\" + site1.size() + \"\\n\" +\n                String.format(\"%-7s\", \"s2size\") + \"|\" + site2.size() + \"\\n\" +\n                site1.getAllLeafSubstructures().stream()\n                        .map(LeafSubstructure::toString)\n                        .map(s1 -> String.format(\"%-7s\", s1))\n                        .collect(Collectors.joining(\"|\", String.format(\"%-7s\", \"s1\") + \"|\", \"|\")) + \"\\n\" +\n                site2.getAllLeafSubstructures().stream()\n                        .map(LeafSubstructure::toString)\n                        .map(s1 -> String.format(\"%-7s\", s1))\n                        .collect(Collectors.joining(\"|\", String.format(\"%-7s\", \"s2\") + \"|\", \"|\")) + \"\\n\" +\n                String.format(\"%-7s\", \"RMSD\") + \"|\" + currentBestSuperimposition.getRmsd() + \"\\n\" +\n                String.format(\"%-7s\", \"frac\") + \"|\" + getAlignedResidueFraction() + \"\\n\" +\n                String.format(\"%-7s\", \"XieS\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getXieScore().getScore()) + \"\\n\" +\n                String.format(\"%-7s\", \"XieExp\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getXieScore().getSignificance()) + \"\\n\" +\n                String.format(\"%-7s\", \"PsS\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getPsScore().getScore()) + \"\\n\" +\n                String.format(\"%-7s\", \"PsExp\") + \"|\" + (containsNonAminoAcids ? \"NaN\" : getPsScore().getSignificance()) + \"\\n\" +\n                String.format(\"%-7s\", \"s1algn\") + site1Joiner.toString() + \"\\n\" + String.format(\"%-7s\", \"s2algn\") + site2Joiner.toString();\n        logger.debug(\"aligned {} residues (site 1 contains {} residues and site 2 contains {} residues)\\n{}\",\n                currentAlignmentSize, site1.size(), site2.size(), alignmentString);\n    }\n    /**\n     * Returns the fraction of successfully aligned residues.\n     *\n     * @return The fraction of aligned residues.\n     */\n    private double getAlignedResidueFraction() {\n        return (site1.size() > site2.size() ? currentAlignmentSize /\n                (double) site2.size() : currentAlignmentSize / (double) site1.size());\n    }\n    /**\n     * Extends the partitions of the sites in the current round.\n     */\n    private void extendPartitions() {\n        // increment counter for current size of alignment\n        currentAlignmentSize++;\n        // remove all old partitions\n        site1Partitions.clear();\n        site2Partitions.clear();\n        // create new partitions\n        for (LeafSubstructure<?> leafSubstructure : site1.getAllLeafSubstructures()) {\n            List<LeafSubstructure<?>> site1Partition = new ArrayList<>(currentBestMatchingPair.getFirst());\n            if (!site1Partition.contains(leafSubstructure)) {\n                site1Partition.add(leafSubstructure);\n            }\n            if (site1Partition.size() == currentAlignmentSize) {\n                // permute up to exhaustive cutoff to find ideal alignment seed\n                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {\n                    StreamPermutations.of(site1Partition.toArray(new LeafSubstructure<?>[0]))\n                            .map(s -> s.collect(Collectors.toList()))\n                            .forEach(site1Partitions::add);\n                } else {\n                    site1Partitions.add(site1Partition);\n                }\n            }\n        }\n        for (LeafSubstructure<?> leafSubstructure : site2.getAllLeafSubstructures()) {\n            List<LeafSubstructure<?>> site2Partition = new ArrayList<>(currentBestMatchingPair.getSecond());\n            if (!site2Partition.contains(leafSubstructure)) {\n                site2Partition.add(leafSubstructure);\n            }\n            if (site2Partition.size() == currentAlignmentSize) {\n                // permute up to exhaustive cutoff to find ideal alignment seed\n                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {\n                    StreamPermutations.of(site2Partition.toArray(new LeafSubstructure<?>[0]))\n                            .map(s -> s.collect(Collectors.toList()))\n                            .forEach(site2Partitions::add);\n                } else {\n                    site2Partitions.add(site2Partition);\n                }\n            }\n        }\n    }\n    /**\n     * Calculates the similarity scores of the current round, either by naive superimposition or with a {@link\n     * Fit3DAlignment} if exchanges are defined.\n     */\n    private void calculateSimilarities() throws SubstructureSuperimpositionException {\n        // reset best score for new iteration\n        double localBestScore = Double.MAX_VALUE;\n        // initialize storage for best superimposition of round\n        SubstructureSuperimposition localBestSuperimposition = null;\n        double[][] temporarySimilarityMatrix = new double[site1Partitions.size()][site2Partitions.size()];\n        List<List<LeafSubstructure<?>>> rowLabels = new ArrayList<>();\n        List<List<LeafSubstructure<?>>> columnLabels = new ArrayList<>();\n        int i = 0;\n        for (List<LeafSubstructure<?>> site1Partition : site1Partitions) {\n            rowLabels.add(site1Partition);\n            int j = 0;\n            for (List<LeafSubstructure<?>> site2Partition : site2Partitions) {\n                if (!columnLabels.contains(site2Partition)) {\n                    columnLabels.add(site2Partition);\n                }\n                // use Fit3D if exchanges should be considered, otherwise use exhaustive alignment\n                if (restrictToExchanges) {\n                    // align the subset of sites with Fit3D\n                    StructuralMotif query = site1.getCopy();\n                    List<LeafSubstructure> queryLeavesToBeRemoved = site1.getAllLeafSubstructures().stream()\n                            .filter(leafSubstructure -> !site1Partition.contains(leafSubstructure))\n                            .collect(Collectors.toList());\n                    queryLeavesToBeRemoved.forEach(leafSubstructure -> query.removeLeafSubstructure(leafSubstructure.getIdentifier()));\n                    StructuralMotif target = site2.getCopy();\n                    List<LeafSubstructure> targetLeavesToBeRemoved = site2.getAllLeafSubstructures().stream()\n                            .filter(leafSubstructure -> !site2Partition.contains(leafSubstructure))\n                            .collect(Collectors.toList());\n                    targetLeavesToBeRemoved.forEach(target::removeLeafSubstructure);\n                    // configure Fit3D\n                    Fit3D fit3d;\n                    if (representationScheme != null) {\n                        fit3d = Fit3DBuilder.create()\n                                .query(query)\n                                .target(target)\n                                .representationScheme(representationScheme.getType())\n                                .rmsdCutoff(rmsdCutoff)\n                                .distanceTolerance(distanceTolerance)\n                                .run();\n                    } else {\n                        fit3d = Fit3DBuilder.create()\n                                .query(query)\n                                .target(target)\n                                .atomFilter(atomFilter)\n                                .rmsdCutoff(rmsdCutoff)\n                                .distanceTolerance(distanceTolerance)\n                                .run();\n                    }\n                    // collect results\n                    if (fit3d.getMatches().isEmpty()) {\n                        temporarySimilarityMatrix[i][j] = Double.MAX_VALUE;\n                    } else {\n                        Fit3DMatch bestMatch = fit3d.getMatches().get(0);\n                        double rmsd = bestMatch.getRmsd();\n                        temporarySimilarityMatrix[i][j] = rmsd;\n                        // test if current score is new global winner and cutoff is not exceeded\n                        if (rmsd < localBestScore) {\n                            localBestSuperimposition = bestMatch.getSubstructureSuperimposition();\n                            localBestScore = rmsd;\n                        }\n                    }\n                } else {\n                    SubstructureSuperimposition superimposition;\n                    if (representationScheme != null) {\n                        if (exhaustive) {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);\n                        } else {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);\n                        }\n                    } else {\n                        if (exhaustive) {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);\n                        } else {\n                            superimposition = SubstructureSuperimposer\n                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);\n                        }\n                    }\n                    double rmsd = superimposition.getRmsd();\n                    temporarySimilarityMatrix[i][j] = rmsd;\n                    if (rmsd < localBestScore) {\n                        localBestSuperimposition = superimposition;\n                        localBestScore = rmsd;\n                    }\n                }\n                j++;\n            }\n            i++;\n        }\n        currentSimilarityMatrix = new LabeledRegularMatrix<>(temporarySimilarityMatrix);\n        currentSimilarityMatrix.setRowLabels(rowLabels);\n        currentSimilarityMatrix.setColumnLabels(columnLabels);\n        logger.debug(\"current similarity matrix is \\n{}\", currentSimilarityMatrix.getStringRepresentation());\n        // if the minimal element is ambiguous select the first\n        List<Pair<Integer>> minimalScores = Matrices.getPositionsOfMinimalElement(currentSimilarityMatrix);\n        if (!minimalScores.isEmpty()) {\n            List<LeafSubstructure<?>> first = currentSimilarityMatrix.getRowLabel(minimalScores.get(0).getFirst());\n            List<LeafSubstructure<?>> second = currentSimilarityMatrix.getColumnLabel(minimalScores.get(0).getSecond());\n            // if the alignment terminates in the next round do not set new best matching pair and score\n            double scoreValue = currentSimilarityMatrix.getValueFromPosition(minimalScores.get(0));\n            if (scoreValue > cutoffScore) {\n                logger.debug(\"cutoff score exceeded\");\n                currentAlignmentSize--;\n                cutoffScoreReached = true;\n                return;\n            }\n            currentBestMatchingPair = new Pair<>(first, second);\n            currentBestScore = scoreValue;\n            currentBestSuperimposition = localBestSuperimposition;\n            logger.debug(\"current best matching pair of size {} is {} with RMSD {}\", currentAlignmentSize,\n                    currentBestMatchingPair, currentBestScore);\n        } else {\n            if (currentAlignmentSize == 2) {\n                throw new Fit3DException(\"could not find minimal agreement of partitions in first iteration\");\n            }\n            logger.debug(\"no suitable alignment found in iteration {}\", currentAlignmentSize);\n            currentAlignmentSize--;\n            currentBestScore = Double.MAX_VALUE;\n        }\n    }\n    /**\n     * Creates the initial 2-partitions of the site alignment.\n     *\n     * @param structuralMotif The {@link StructuralMotif} for which the 2-partitions should be created.\n     * @return The generated set of 2-partitions.\n     */\n    private LinkedHashSet<List<LeafSubstructure<?>>> createInitialPartitions(StructuralMotif structuralMotif) {\n        LinkedHashSet<List<LeafSubstructure<?>>> partitions = new LinkedHashSet<>();\n        List<LeafSubstructure<?>> leafSubstructures = structuralMotif.getAllLeafSubstructures();\n        for (int i = 0; i < leafSubstructures.size() - 1; i++) {\n            for (int j = i + 1; j < leafSubstructures.size(); j++) {\n                List<LeafSubstructure<?>> partition1 = new ArrayList<>();\n                partition1.add(leafSubstructures.get(i));\n                partition1.add(leafSubstructures.get(j));\n                partitions.add(partition1);\n                if (!exhaustive) {\n                    // add first permutation of elements\n                    List<LeafSubstructure<?>> partition2 = new ArrayList<>();\n                    partition2.add(leafSubstructures.get(j));\n                    partition2.add(leafSubstructures.get(i));\n                    partitions.add(partition2);\n                }\n            }\n        }\n        return partitions;\n    }\n    /**\n     * Calculates the optimal assignment of the input sites using Kuhn-Munkres optimization and the given {@link SubstitutionMatrix}.\n     */\n    private void calculateAssignment() {\n        double[][] costValues = new double[site1.size()][site2.size()];\n        for (int i = 0; i < site1.getNumberOfLeafSubstructures(); i++) {\n            for (int j = 0; j < site2.getNumberOfLeafSubstructures(); j++) {\n                LeafSubstructure<?> residue1 = site1.getAllLeafSubstructures().get(i);\n                LeafSubstructure<?> residue2 = site2.getAllLeafSubstructures().get(j);\n                if (restrictToExchanges && residue1.getFamily() != residue2.getFamily()) {\n                    // exchanges do not penalize the score\n                    if (residue1.getExchangeableFamilies().contains(residue2.getFamily()) ||\n                            residue2.getExchangeableFamilies().contains(residue1.getFamily())) {\n                        continue;\n                    }\n                    costValues[i][j] = Double.MAX_VALUE;\n                    continue;\n                }\n                costValues[i][j] = substitutionMatrix.getMatrix().getValueForLabel(residue1.getFamily(), residue2.getFamily());\n            }\n        }\n        LabeledMatrix<LeafSubstructure<?>> costMatrix = new LabeledRegularMatrix<>(costValues);\n        costMatrix.setRowLabels(site1.getAllLeafSubstructures());\n        costMatrix.setColumnLabels(site2.getAllLeafSubstructures());\n        KuhnMunkres<LeafSubstructure<?>> kuhnMunkres = new KuhnMunkres<>(costMatrix);\n        assignment = kuhnMunkres.getAssignedPairs();\n        // remove last assigned pair if strong restriction to exchanges is desired\n        if (restrictToExchanges) {\n            assignment.remove(assignment.size() - 1);\n        }\n        String assignmentString = kuhnMunkres.getAssignedPairs().stream()\n                .map(pair -> pair.getFirst() + \"+\" + pair.getSecond() + \":\" + costMatrix.getValueForLabel(pair.getFirst(), pair.getSecond()))\n                .collect(Collectors.joining(\"\\n\"));\n        logger.debug(\"optimal assignment of binding sites is:\\n{}\", assignmentString);\n    }\n    /**\n     * Calculates the alignment of sites based on the Kuhn-Munkres assignment.\n     */\n    private void calculateAlignment() {\n        List<LeafSubstructure<?>> reference = assignment.stream()\n                .map(Pair::getFirst)\n                .collect(Collectors.toList());\n        List<LeafSubstructure<?>> candidate = assignment.stream()\n                .map(Pair::getSecond)\n                .collect(Collectors.toList());\n        currentAlignmentSize = reference.size();\n        if (representationScheme != null) {\n            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, representationScheme);\n        } else {\n            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, atomFilter);\n        }\n        currentBestScore = currentBestSuperimposition.getRmsd();\n        matches.add(Fit3DMatch.of(currentBestSuperimposition.getRmsd(), currentBestSuperimposition));\n        if (!containsNonAminoAcids) {\n            calculateXieScore();\n            calculatePsScore();\n        }\n        outputSummary();\n    }\n    @Override\n    public void writeMatches(Path outputDirectory) {\n        if (matches.isEmpty()) {\n            throw new Fit3DException(\"cannot write matches as they are currently empty\");\n        }\n        SubstructureSuperimposition bestSuperimposition = matches.get(0).getSubstructureSuperimposition();\n        List<LeafSubstructure<?>> mappedSite2 = bestSuperimposition.applyTo(site2.getCopy().getAllLeafSubstructures());\n        try {\n            StructureWriter.writeLeafSubstructures(site1.getAllLeafSubstructures(),\n                    outputDirectory.resolve(site1.getAllLeafSubstructures().stream()\n                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))\n                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + \"-\"\n                                    + leafSubstructure.getIdentifier().getSerial())\n                            .collect(Collectors.joining(\"_\", bestSuperimposition.getFormattedRmsd() + \"_\"\n                                    + site1.getAllLeafSubstructures().get(0).getPdbIdentifier()\n                                    + \"_\", \"\")) + \"_site1.pdb\"));\n            StructureWriter.writeLeafSubstructures(mappedSite2,\n                    outputDirectory.resolve(site2.getAllLeafSubstructures().stream()\n                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))\n                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + \"-\"\n                                    + leafSubstructure.getIdentifier().getSerial())\n                            .collect(Collectors.joining(\"_\", bestSuperimposition.getFormattedRmsd() + \"_\"\n                                    + site2.getAllLeafSubstructures().get(0).getPdbIdentifier()\n                                    + \"_\", \"\")) + \"_site2.pdb\"));\n        } catch (IOException e) {\n            logger.error(\"error writing Fit3DSite results\", e);\n        }\n    }\n    @Override\n    public List<Fit3DMatch> getMatches() {\n        return matches;\n    }\n    /**\n     * Returns the fraction of aligned residues, in respect to the smaller site.\n     */\n    @Override\n    public double getFraction() {\n        return getAlignedResidueFraction();\n    }\n"]], "pred": {"ppl": 2.657994031906128, "ppl_lower": 2.9345788955688477, "ppl/lowercase_ppl": -1.1012634159805301, "ppl/zlib": 0.00020214468878329198, "Min_5.0% Prob": 7.703424416336358, "Min_10.0% Prob": 6.0604606048733585, "Min_20.0% Prob": 4.189324647772546, "Min_30.0% Prob": 3.1008699664882586, "Min_40.0% Prob": 2.410664076873609, "Min_50.0% Prob": 1.9493455056633269, "Min_60.0% Prob": 1.629714586933069}}
{"hexsha": "79d00d4d722a343f5b218c0cf9e9a29f25931d44", "ext": "java", "lang": "Java", "content": "public class odd_even {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner inp = new Scanner(System.in);\n\t\t\n\t\tSystem.out.print(\" Enter the Size of the Array : \");\n\t\tint size = inp.nextInt();\t\t\t// Getting the size of the Array input by the User\n\t\t\n\t\tint arr[] = new int[size];\n\t\t\n\t\tSystem.out.println(\" Enter the \" + \" Elements of the Array : \");\n\t\t\n\t\tfor ( int i = 0 ; i < size ; i++ ) {\n\t\t\tarr[i] = inp.nextInt();\t\t\t\t// Getting the Elements of the Array input by the User\n\t\t}\n\t\t\n\t\t// Printing the Even Numbers\n\t\tSystem.out.println(\"\\n The Even Numbers in the Array : \\n\");\n\t\t\n\t\tfor ( int loop : arr ) {\n\t\t\tif ( loop % 2 == 0 )\n\t\t\t\tSystem.out.println(\" \" + loop);\n\t\t}\n\t\t\n\t\t// Printing the Odd Numbers\n\t\tSystem.out.println(\"\\n The Odd Numbers in the Array : \\n\");\n\t\t\t\t\n\t\tfor ( int loop : arr ) {\n\t\t\tif ( loop % 2 != 0 )\n\t\t\t\tSystem.out.println(\" \" + loop);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "Nike98/personal-code", "file": "JAVA/Arrays/Odd Even Array/src/odd_even.java", "last_update_at": "2018-07-25T13:06:56+00:00", "question_id": "79d00d4d722a343f5b218c0cf9e9a29f25931d44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class odd_even {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner inp = new Scanner(System.in);\n\t\t\n\t\tSystem.out.print(\" Enter the Size of the Array : \");\n\t\tint size = inp.nextInt();\t\t\t// Getting the size of the Array input by the User\n\t\t\n\t\tint arr[] = new int[size];\n\t\t\n\t\tSystem.out.println(\" Enter the \" + \" Elements of the Array : \");\n\t\t\n\t\tfor ( int i = 0 ; i < size ; i++ ) {\n\t\t\tarr[i] = inp.nextInt();\t\t\t\t// Getting the Elements of the Array input by the User\n\t\t}\n\t\t\n\t\t// Printing the Even Numbers\n\t\tSystem.out.println(\"\\n The Even Numbers in the Array : \\n\");\n\t\t\n\t\tfor ( int loop : arr ) {\n\t\t\tif ( loop % 2 == 0 )\n\t\t\t\tSystem.out.println(\" \" + loop);\n\t\t}\n\t\t\n\t\t// Printing the Odd Numbers\n\t\tSystem.out.println(\"\\n The Odd Numbers in the Array : \\n\");\n\t\t\t\t\n\t\tfor ( int loop : arr ) {\n\t\t\tif ( loop % 2 != 0 )\n\t\t\t\tSystem.out.println(\" \" + loop);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.640091896057129, "ppl_lower": 1.7779923677444458, "ppl/lowercase_ppl": -1.1631777643024819, "ppl/zlib": 0.0014637641255841039, "Min_5.0% Prob": 5.495822065016803, "Min_10.0% Prob": 3.717944530078343, "Min_20.0% Prob": 2.291172566158431, "Min_30.0% Prob": 1.6092020713147663, "Min_40.0% Prob": 1.2270046711766294, "Min_50.0% Prob": 0.9877657298211541, "Min_60.0% Prob": 0.8253592224037718}}
{"hexsha": "f57cab796fe4c4589958e35066a2632ee32d4037", "ext": "java", "lang": "Java", "content": "class Element {\n    private final SubElement [] subElements;\n    \n    public Element(final Label l) {\n        this.subElements = new SubElement [] {l};\n    }\n    \n    public Element(final Label l, final Value v) {\n        this.subElements = new SubElement [] {l, v};\n    }\n    \n    public boolean isValue() {\n        return this.subElements.length > 1;\n    }\n    \n    public Label getLabel() {\n        return (Label)this.subElements[0];\n    }\n    \n    public Value getValue() {\n        if (!isValue()) {\n            return null;\n        }\n        return (Value)this.subElements[1];\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < subElements.length; i++) {\n            sb.append(subElements[i].toString());\n            if (i == 0) {\n                // Add colon after Label.\n                sb.append(':');\n                if (isValue()) {\n                    // Add space to intro the value.\n                    sb.append(' ');\n                }\n            }\n        }\n        return sb.toString();\n    }\n}", "class_id": 0, "repo": "BRIUG/EGIES", "file": "code/crawler/src/org/archive/util/anvl/Element.java", "last_update_at": "2018-09-16T10:02:58+00:00", "question_id": "f57cab796fe4c4589958e35066a2632ee32d4037", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Element {\n    private final SubElement [] subElements;\n    public Element(final Label l) {\n        this.subElements = new SubElement [] {l};\n    }\n    public Element(final Label l, final Value v) {\n        this.subElements = new SubElement [] {l, v};\n    }\n    public boolean isValue() {\n        return this.subElements.length > 1;\n    }\n    public Label getLabel() {\n        return (Label)this.subElements[0];\n    }\n    public Value getValue() {\n        if (!isValue()) {\n            return null;\n        }\n        return (Value)this.subElements[1];\n    }\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < subElements.length; i++) {\n            sb.append(subElements[i].toString());\n            if (i == 0) {\n                // Add colon after Label.\n                sb.append(':');\n                if (isValue()) {\n                    // Add space to intro the value.\n                    sb.append(' ');\n                }\n            }\n        }\n        return sb.toString();\n    }\n"]], "pred": {"ppl": 1.8544273376464844, "ppl_lower": 1.9618451595306396, "ppl/lowercase_ppl": -1.0911782657655464, "ppl/zlib": 0.0017396505226443275, "Min_5.0% Prob": 6.388929224014282, "Min_10.0% Prob": 4.605720667044322, "Min_20.0% Prob": 2.8685879160960517, "Min_30.0% Prob": 2.0214115228917864, "Min_40.0% Prob": 1.5364945423789322, "Min_50.0% Prob": 1.2348692023878296, "Min_60.0% Prob": 1.031159717656879}}
{"hexsha": "5a99d48bff937e53c5e5aba849659fa6f1cf86c3", "ext": "java", "lang": "Java", "content": "public class ClientCtl extends Screen {\n    ObservableList<ClientType> typesOfClient;\n    private MainScreensController mainScreensController = MainScreensController.getInstance();\n\n    private DataController mDataController = DataController.getInstance();\n\n    @FXML\n    private ResourceBundle resources;\n\n    @FXML\n    private URL location;\n\n    @FXML\n    private TextField ClientCpfField;\n\n    @FXML\n    private TextField ClientNameField;\n\n    @FXML\n    private TextField ClientEmailField;\n\n    @FXML\n    private TextField ClientPhoneField;\n\n    @FXML\n    private TextField clientStreetField;\n\n    @FXML\n    private TextField clientDistrictField;\n\n    @FXML\n    private TextField clientAdressNumberField;\n\n    @FXML\n    private TextField clientCityField;\n\n    @FXML\n    private ComboBox<State> state;\n\n    @FXML\n    private TextField clientCepField;\n\n    @FXML\n    private ToggleGroup clientType;\n\n    @FXML\n    private RadioButton radioPerson;\n\n    @FXML\n    private RadioButton radioCompany;\n\n    @FXML\n    private Button btnSaveClient;\n\n    private void insertValidation() {\n        ClientCpfField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n        ClientPhoneField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n        clientCepField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n    }\n\n    @FXML\n    void SaveClient(ActionEvent event) {\n        if(ClientCpfField.getText().length() != 11 && ClientCpfField.getText().length() != 14) {\n            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);\n            dialogoErro.setTitle(\"Erro!\");\n            dialogoErro.setHeaderText(\"CPF/CNPJ inv\u00e1lido!\");\n            dialogoErro.setContentText(\"Digite o CPF ou CNPJ sem pontua\u00e7\u00e3o, contendo 11 ou 14 caracteres\");\n            dialogoErro.showAndWait();\n            return;\n        }else if(!radioCompany.isSelected() && !radioPerson.isSelected()){\n            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);\n            dialogoErro.setTitle(\"Erro!\");\n            dialogoErro.setHeaderText(\"Tipo n\u00e3o selecionado\");\n            dialogoErro.setContentText(\"Selecione o tipo de pessoa: F\u00edsica ou Jur\u00eddica\");\n            dialogoErro.showAndWait();\n            return;\n        }else if(!Validation.isEveryInputFilled(\n                ClientCpfField.getText(),\n                clientStreetField.getText(),\n                clientAdressNumberField.getText(),\n                ClientNameField.getText(),\n                clientDistrictField.getText(),\n                ClientEmailField.getText(),\n                clientCityField.getText(),\n                ClientPhoneField.getText(),\n                clientCepField.getText())){\n            Validation.showErrorDialog(\n                    \"Oooops...\",\n                    \"Informa\u00e7\u00f5es inv\u00e1lidas\",\n                    \"Parece que h\u00e1 alguma campo sem preencher, volte ao form para validar\"\n            );\n            return;\n        }\n\n        //Creating City\n        City city = new City();\n        city.setCity(clientCityField.getText());\n        city.setUf(state.getSelectionModel().getSelectedItem().getUf());\n        mDataController.saveObject(city);\n\n        //Creating Address\n        Address address = new Address();\n        address.setCityByCityId(city);\n        address.setStateByStateId(state.getSelectionModel().getSelectedItem());\n        address.setDistrict(clientDistrictField.getText());\n        address.setPostalCode(clientCepField.getText());\n        address.setAddress(clientStreetField.getText());\n        address.setAddress2(clientAdressNumberField.getText());\n        mDataController.saveObject(address);\n\n        //Saving new\n\n        if(getCurrentClient() == null){\n            Client client  = new Client();\n            client.setAddressByAddressId(address);\n            client.setAddressNumber(clientAdressNumberField.toString());\n            client.setDocumentNumber(ClientCpfField.getText());\n            client.setName(ClientNameField.getText());\n            client.setEmail(ClientEmailField.getText());\n            client.setPhone(ClientPhoneField.getText());\n            //Verifiyng clientType\n            if (clientType.getSelectedToggle() == radioPerson) {\n                client.setClientTypeByClientTypeId(typesOfClient.get(0));\n            } else\n                client.setClientTypeByClientTypeId(typesOfClient.get(1));\n            mDataController.saveObject(client);\n            callClientsScreen();\n        }else{\n            getCurrentClient().setAddressByAddressId(address);\n            getCurrentClient().setAddressNumber(clientAdressNumberField.toString());\n            getCurrentClient().setDocumentNumber(ClientCpfField.getText());\n            getCurrentClient().setName(ClientNameField.getText());\n            getCurrentClient().setEmail(ClientEmailField.getText());\n            getCurrentClient().setPhone(ClientPhoneField.getText());\n            //Verifiyng clientType\n            if (clientType.getSelectedToggle() == radioPerson) {\n                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(0));\n            } else\n                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(1));\n            mDataController.updateObject(getCurrentClient());\n            callClientsScreen();\n        }\n    }\n\n    @FXML\n    void callClientsScreen() {\n        super.setCurrentClient(null);\n        mainScreensController.showNewMainScreen(\"/Screens/Clients/clients.fxml\");\n    }\n\n    public ResourceBundle getResources() {\n        return resources;\n    }\n\n    public void setResources(ResourceBundle resources) {\n        this.resources = resources;\n    }\n\n    @FXML\n    void initialize() {\n\n        typesOfClient = (ObservableList<ClientType>) mDataController.getAllObjectsOfType(ClientType.class);\n        ObservableList<State> states = (ObservableList<State>) DataController.getInstance().getAllObjectsOfType(State.class);\n        state.getItems().addAll(states);\n        state.getSelectionModel().selectFirst();\n        if (typesOfClient.isEmpty()) {\n            ClientType pessoaFisica = new ClientType();\n            pessoaFisica.setName(\"Pessoa F\u00edsica\");\n            typesOfClient.add(pessoaFisica);\n            mDataController.saveObject(pessoaFisica);\n            ClientType pessoaJuridica = new ClientType();\n            pessoaJuridica.setName(\"Pessoa Jur\u00eddica\");\n            typesOfClient.add(pessoaJuridica);\n            mDataController.saveObject(pessoaJuridica);\n        }\n        if (super.getCurrentClient() != null) {\n            clientCepField.setText(super.getCurrentClient().getAddressByAddressId().getPostalCode());\n            clientAdressNumberField.setText(super.getCurrentClient().getAddressByAddressId().getAddress2());\n            clientCityField.setText(super.getCurrentClient().getAddressByAddressId().getCityByCityId().getCity());\n            ClientCpfField.setText(super.getCurrentClient().getDocumentNumber());\n            ClientEmailField.setText(super.getCurrentClient().getEmail());\n            clientDistrictField.setText(super.getCurrentClient().getAddressByAddressId().getDistrict());\n            ClientNameField.setText(super.getCurrentClient().getName());\n            ClientPhoneField.setText(super.getCurrentClient().getPhone());\n            clientStreetField.setText(super.getCurrentClient().getAddressByAddressId().getAddress());\n        }\n        insertValidation();\n    }\n\n}", "class_id": 0, "repo": "kaueel/Organizer", "file": "src/main/java/Screens/Client/ClientCtl.java", "last_update_at": "2018-11-27T01:17:26+00:00", "question_id": "5a99d48bff937e53c5e5aba849659fa6f1cf86c3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ClientCtl extends Screen {\n    ObservableList<ClientType> typesOfClient;\n    private MainScreensController mainScreensController = MainScreensController.getInstance();\n    private DataController mDataController = DataController.getInstance();\n    @FXML\n    private ResourceBundle resources;\n    @FXML\n    private URL location;\n    @FXML\n    private TextField ClientCpfField;\n    @FXML\n    private TextField ClientNameField;\n    @FXML\n    private TextField ClientEmailField;\n    @FXML\n    private TextField ClientPhoneField;\n    @FXML\n    private TextField clientStreetField;\n    @FXML\n    private TextField clientDistrictField;\n    @FXML\n    private TextField clientAdressNumberField;\n    @FXML\n    private TextField clientCityField;\n    @FXML\n    private ComboBox<State> state;\n    @FXML\n    private TextField clientCepField;\n    @FXML\n    private ToggleGroup clientType;\n    @FXML\n    private RadioButton radioPerson;\n    @FXML\n    private RadioButton radioCompany;\n    @FXML\n    private Button btnSaveClient;\n    private void insertValidation() {\n        ClientCpfField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n        ClientPhoneField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n        clientCepField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));\n    }\n    @FXML\n    void SaveClient(ActionEvent event) {\n        if(ClientCpfField.getText().length() != 11 && ClientCpfField.getText().length() != 14) {\n            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);\n            dialogoErro.setTitle(\"Erro!\");\n            dialogoErro.setHeaderText(\"CPF/CNPJ inv\u00e1lido!\");\n            dialogoErro.setContentText(\"Digite o CPF ou CNPJ sem pontua\u00e7\u00e3o, contendo 11 ou 14 caracteres\");\n            dialogoErro.showAndWait();\n            return;\n        }else if(!radioCompany.isSelected() && !radioPerson.isSelected()){\n            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);\n            dialogoErro.setTitle(\"Erro!\");\n            dialogoErro.setHeaderText(\"Tipo n\u00e3o selecionado\");\n            dialogoErro.setContentText(\"Selecione o tipo de pessoa: F\u00edsica ou Jur\u00eddica\");\n            dialogoErro.showAndWait();\n            return;\n        }else if(!Validation.isEveryInputFilled(\n                ClientCpfField.getText(),\n                clientStreetField.getText(),\n                clientAdressNumberField.getText(),\n                ClientNameField.getText(),\n                clientDistrictField.getText(),\n                ClientEmailField.getText(),\n                clientCityField.getText(),\n                ClientPhoneField.getText(),\n                clientCepField.getText())){\n            Validation.showErrorDialog(\n                    \"Oooops...\",\n                    \"Informa\u00e7\u00f5es inv\u00e1lidas\",\n                    \"Parece que h\u00e1 alguma campo sem preencher, volte ao form para validar\"\n            );\n            return;\n        }\n        //Creating City\n        City city = new City();\n        city.setCity(clientCityField.getText());\n        city.setUf(state.getSelectionModel().getSelectedItem().getUf());\n        mDataController.saveObject(city);\n        //Creating Address\n        Address address = new Address();\n        address.setCityByCityId(city);\n        address.setStateByStateId(state.getSelectionModel().getSelectedItem());\n        address.setDistrict(clientDistrictField.getText());\n        address.setPostalCode(clientCepField.getText());\n        address.setAddress(clientStreetField.getText());\n        address.setAddress2(clientAdressNumberField.getText());\n        mDataController.saveObject(address);\n        //Saving new\n        if(getCurrentClient() == null){\n            Client client  = new Client();\n            client.setAddressByAddressId(address);\n            client.setAddressNumber(clientAdressNumberField.toString());\n            client.setDocumentNumber(ClientCpfField.getText());\n            client.setName(ClientNameField.getText());\n            client.setEmail(ClientEmailField.getText());\n            client.setPhone(ClientPhoneField.getText());\n            //Verifiyng clientType\n            if (clientType.getSelectedToggle() == radioPerson) {\n                client.setClientTypeByClientTypeId(typesOfClient.get(0));\n            } else\n                client.setClientTypeByClientTypeId(typesOfClient.get(1));\n            mDataController.saveObject(client);\n            callClientsScreen();\n        }else{\n            getCurrentClient().setAddressByAddressId(address);\n            getCurrentClient().setAddressNumber(clientAdressNumberField.toString());\n            getCurrentClient().setDocumentNumber(ClientCpfField.getText());\n            getCurrentClient().setName(ClientNameField.getText());\n            getCurrentClient().setEmail(ClientEmailField.getText());\n            getCurrentClient().setPhone(ClientPhoneField.getText());\n            //Verifiyng clientType\n            if (clientType.getSelectedToggle() == radioPerson) {\n                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(0));\n            } else\n                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(1));\n            mDataController.updateObject(getCurrentClient());\n            callClientsScreen();\n        }\n    }\n    @FXML\n    void callClientsScreen() {\n        super.setCurrentClient(null);\n        mainScreensController.showNewMainScreen(\"/Screens/Clients/clients.fxml\");\n    }\n    public ResourceBundle getResources() {\n        return resources;\n    }\n    public void setResources(ResourceBundle resources) {\n        this.resources = resources;\n    }\n    @FXML\n    void initialize() {\n        typesOfClient = (ObservableList<ClientType>) mDataController.getAllObjectsOfType(ClientType.class);\n        ObservableList<State> states = (ObservableList<State>) DataController.getInstance().getAllObjectsOfType(State.class);\n        state.getItems().addAll(states);\n        state.getSelectionModel().selectFirst();\n        if (typesOfClient.isEmpty()) {\n            ClientType pessoaFisica = new ClientType();\n            pessoaFisica.setName(\"Pessoa F\u00edsica\");\n            typesOfClient.add(pessoaFisica);\n            mDataController.saveObject(pessoaFisica);\n            ClientType pessoaJuridica = new ClientType();\n            pessoaJuridica.setName(\"Pessoa Jur\u00eddica\");\n            typesOfClient.add(pessoaJuridica);\n            mDataController.saveObject(pessoaJuridica);\n        }\n        if (super.getCurrentClient() != null) {\n            clientCepField.setText(super.getCurrentClient().getAddressByAddressId().getPostalCode());\n            clientAdressNumberField.setText(super.getCurrentClient().getAddressByAddressId().getAddress2());\n            clientCityField.setText(super.getCurrentClient().getAddressByAddressId().getCityByCityId().getCity());\n            ClientCpfField.setText(super.getCurrentClient().getDocumentNumber());\n            ClientEmailField.setText(super.getCurrentClient().getEmail());\n            clientDistrictField.setText(super.getCurrentClient().getAddressByAddressId().getDistrict());\n            ClientNameField.setText(super.getCurrentClient().getName());\n            ClientPhoneField.setText(super.getCurrentClient().getPhone());\n            clientStreetField.setText(super.getCurrentClient().getAddressByAddressId().getAddress());\n        }\n        insertValidation();\n    }\n"]], "pred": {"ppl": 1.8851176500320435, "ppl_lower": 2.0892770290374756, "ppl/lowercase_ppl": -1.1621915432381629, "ppl/zlib": 0.0003932941890585707, "Min_5.0% Prob": 6.181614398956299, "Min_10.0% Prob": 4.648497810550764, "Min_20.0% Prob": 2.9510395599930894, "Min_30.0% Prob": 2.0799667678919493, "Min_40.0% Prob": 1.5775273481069683, "Min_50.0% Prob": 1.267020351402899, "Min_60.0% Prob": 1.0574040029579272}}
{"hexsha": "d87551b82307b12235f7a32dbf20c53a669b0bbb", "ext": "java", "lang": "Java", "content": "public class LookupUtils {\r\n    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(LookupUtils.class);\r\n    private static final String[] searchList = new String[SearchOperator.QUERY_CHARACTERS.size()];\r\n\r\n    static {\r\n        int index = 0;\r\n        for (SearchOperator operator : SearchOperator.QUERY_CHARACTERS) {\r\n            searchList[index++] = operator.op();\r\n        }\r\n    }\r\n\r\n    private static final String[] replacementList = Collections.nCopies(searchList.length, \"\").toArray(new String[0]);\r\n\r\n    private LookupUtils() {}\r\n\r\n    /**\r\n     * Retrieves the value for the given parameter name to send as a lookup parameter.\r\n     *\r\n     * @param form form instance to retrieve values from\r\n     * @param request request object to retrieve parameters from\r\n     * @param lookupObjectClass data object class associated with the lookup, used to check whether the\r\n     * value needs to be encyrpted\r\n     * @param propertyName name of the property associated with the parameter, used to check whether the\r\n     * value needs to be encrypted\r\n     * @param parameterName name of the parameter to retrieve the value for\r\n     * @return String parameter value or empty string if no value was found\r\n     */\r\n    public static String retrieveLookupParameterValue(UifFormBase form, HttpServletRequest request,\r\n            Class<?> lookupObjectClass, String propertyName, String parameterName) {\r\n        String parameterValue = \"\";\r\n\r\n        // get literal parameter values first\r\n        if (StringUtils.startsWith(parameterName, \"'\") && StringUtils.endsWith(parameterName, \"'\")) {\r\n            parameterValue = StringUtils.substringBetween(parameterName, \"'\");\r\n        } else if (parameterValue.startsWith(KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX\r\n                + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER)) {\r\n            parameterValue = StringUtils.removeStart(parameterValue, KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX\r\n                    + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER);\r\n        }\r\n        // check if parameter is in request\r\n        else if (request.getParameterMap().containsKey(parameterName)) {\r\n            parameterValue = request.getParameter(parameterName);\r\n        }\r\n        // get parameter value from form object\r\n        else {\r\n            parameterValue = ObjectPropertyUtils.getPropertyValue(form, parameterName);\r\n            // TODO: should go through property editor for display\r\n        }\r\n\r\n        if (parameterValue != null && lookupObjectClass != null\r\n                && KRADServiceLocatorWeb.getDataObjectAuthorizationService()\r\n                .attributeValueNeedsToBeEncryptedOnFormsAndLinks(lookupObjectClass, propertyName)) {\r\n            try {\r\n                if (CoreApiServiceLocator.getEncryptionService().isEnabled()) {\r\n                    parameterValue = CoreApiServiceLocator.getEncryptionService().encrypt(parameterValue)\r\n                            + EncryptionService.ENCRYPTION_POST_PREFIX;\r\n                }\r\n            } catch (GeneralSecurityException e) {\r\n                LOG.error(\"Unable to encrypt value for property name: \" + propertyName);\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        return parameterValue;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default KRAD base lookup URL, used to build lookup URLs in code\r\n     *\r\n     * @return String base lookup URL (everything except query string)\r\n     */\r\n    public static String getBaseLookupUrl() {\r\n        return CoreApiServiceLocator.getKualiConfigurationService().getPropertyValueAsString(\r\n                KRADConstants.KRAD_LOOKUP_URL_KEY);\r\n    }\r\n\r\n    /**\r\n     * Uses the DataDictionary to determine whether to force uppercase the value, and if it should, then it does the\r\n     * uppercase, and returns the upper-cased value.\r\n     *\r\n     * @param dataObjectClass parent DO class that the fieldName is a member of\r\n     * @param fieldName name of the field to be forced to uppercase\r\n     * @param fieldValue value of the field that may be uppercased\r\n     * @return the correctly uppercased fieldValue if it should be uppercased, otherwise fieldValue is returned\r\n     *         unchanged\r\n     */\r\n    public static String forceUppercase(Class<?> dataObjectClass, String fieldName, String fieldValue) {\r\n        // short-circuit to exit if there isnt enough information to do the forceUppercase\r\n        if (StringUtils.isBlank(fieldValue)) {\r\n            return fieldValue;\r\n        }\r\n\r\n        // parameter validation\r\n        if (dataObjectClass == null) {\r\n            throw new IllegalArgumentException(\"Parameter dataObjectClass passed in with null value.\");\r\n        }\r\n\r\n        if (StringUtils.isBlank(fieldName)) {\r\n            throw new IllegalArgumentException(\"Parameter fieldName passed in with empty value.\");\r\n        }\r\n\r\n        if (!KRADServiceLocatorWeb.getDataDictionaryService().isAttributeDefined(dataObjectClass, fieldName)\r\n                .booleanValue()) {\r\n            return fieldValue;\r\n        }\r\n\r\n        boolean forceUpperCase = false;\r\n        try {\r\n            forceUpperCase = KRADServiceLocatorWeb.getDataDictionaryService()\r\n                    .getAttributeForceUppercase(dataObjectClass, fieldName).booleanValue();\r\n        } catch (UnknownBusinessClassAttributeException ubae) {\r\n            // do nothing, don't alter the fieldValue\r\n        }\r\n\r\n        if (forceUpperCase && !fieldValue.endsWith(EncryptionService.ENCRYPTION_POST_PREFIX)) {\r\n            return fieldValue.toUpperCase();\r\n        }\r\n\r\n        return fieldValue;\r\n    }\r\n\r\n    /**\r\n     * Uses the DataDictionary to determine whether to force uppercase the values, and if it should, then it does the\r\n     * uppercase, and returns the upper-cased Map of fieldname/fieldValue pairs.\r\n     *\r\n     * @param dataObjectClass parent DO class that the fieldName is a member of\r\n     * @param fieldValues a Map<String,String> where the key is the fieldName and the value is the fieldValue\r\n     * @return the same Map is returned, with the appropriate values uppercased (if any)\r\n     */\r\n    public static Map<String, String> forceUppercase(Class<?> dataObjectClass, Map<String, String> fieldValues) {\r\n        if (dataObjectClass == null) {\r\n            throw new IllegalArgumentException(\"Parameter boClass passed in with null value.\");\r\n        }\r\n\r\n        if (fieldValues == null) {\r\n            throw new IllegalArgumentException(\"Parameter fieldValues passed in with null value.\");\r\n        }\r\n\r\n        for (String fieldName : fieldValues.keySet()) {\r\n            fieldValues.put(fieldName, forceUppercase(dataObjectClass, fieldName, fieldValues.get(fieldName)));\r\n        }\r\n\r\n        return fieldValues;\r\n    }\r\n\r\n    /**\r\n     * Parses and returns the lookup result set limit, checking first for the limit for the specific view,\r\n     * then the class being looked up, and then the global application limit if there isn't a limit specific\r\n     * to this data object class.\r\n     *\r\n     * @param dataObjectClass class to get limit for\r\n     * @param lookupForm lookupForm to use.  May be null if the form is unknown. If lookupForm is null, only the\r\n     * dataObjectClass will be used to find the search results set limit\r\n     * @return result set limit\r\n     */\r\n    public static Integer getSearchResultsLimit(Class dataObjectClass, LookupForm lookupForm) {\r\n        Integer limit = KRADServiceLocatorWeb.getViewDictionaryService().getResultSetLimitForLookup(dataObjectClass,\r\n                lookupForm);\r\n        if (limit == null) {\r\n            limit = getApplicationSearchResultsLimit();\r\n        }\r\n\r\n        return limit;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default application search limit configured through a system parameter.\r\n     *\r\n     * @return default result set limit of the application\r\n     */\r\n    public static Integer getApplicationSearchResultsLimit() {\r\n        String limitString = CoreFrameworkServiceLocator.getParameterService()\r\n                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,\r\n                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,\r\n                        KRADConstants.SystemGroupParameterNames.LOOKUP_RESULTS_LIMIT);\r\n        if (limitString != null) {\r\n            return Integer.valueOf(limitString);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default application multiple value search limit configured through a system parameter.\r\n     *\r\n     * @return default multiple value result set limit of the application\r\n     */\r\n    public static Integer getApplicationMultipleValueSearchResultsLimit() {\r\n        String limitString = CoreFrameworkServiceLocator.getParameterService()\r\n                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,\r\n                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,\r\n                        KRADConstants.SystemGroupParameterNames.MULTIPLE_VALUE_LOOKUP_RESULTS_LIMIT);\r\n        if (limitString != null) {\r\n            return Integer.valueOf(limitString);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Determines what Timestamp should be used for active queries on effective dated records. Determination made as\r\n     * follows:\r\n     *\r\n     * <ul>\r\n     * <li>Use activeAsOfDate value from search values Map if value is not empty</li>\r\n     * <li>If search value given, try to convert to sql date, if conversion fails, try to convert to Timestamp</li>\r\n     * <li>If search value empty, use current Date</li>\r\n     * <li>If Timestamp value not given, create Timestamp from given Date setting the time as 1 second before midnight\r\n     * </ul>\r\n     *\r\n     * @param searchValues map containing search key/value pairs\r\n     * @return timestamp to be used for active criteria\r\n     */\r\n    public static Timestamp getActiveDateTimestampForCriteria(Map searchValues) {\r\n        Date activeDate = CoreApiServiceLocator.getDateTimeService().getCurrentSqlDate();\r\n\r\n        Timestamp activeTimestamp = null;\r\n        if (searchValues.containsKey(KRADPropertyConstants.ACTIVE_AS_OF_DATE)) {\r\n            String activeAsOfDate = (String) searchValues.get(KRADPropertyConstants.ACTIVE_AS_OF_DATE);\r\n            if (StringUtils.isNotBlank(activeAsOfDate)) {\r\n                try {\r\n                    activeDate = CoreApiServiceLocator.getDateTimeService()\r\n                            .convertToSqlDate(KRADUtils.clean(activeAsOfDate));\r\n                } catch (ParseException e) {\r\n                    // try to parse as timestamp\r\n                    try {\r\n                        activeTimestamp = CoreApiServiceLocator.getDateTimeService()\r\n                                .convertToSqlTimestamp(KRADUtils.clean(activeAsOfDate));\r\n                    } catch (ParseException e1) {\r\n                        throw new RuntimeException(\"Unable to convert date: \" + KRADUtils.clean(activeAsOfDate));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // if timestamp not given set to 1 second before midnight on the given date\r\n        if (activeTimestamp == null) {\r\n            Calendar cal = Calendar.getInstance();\r\n\r\n            cal.setTime(activeDate);\r\n            cal.set(Calendar.HOUR, cal.getMaximum(Calendar.HOUR));\r\n            cal.set(Calendar.MINUTE, cal.getMaximum(Calendar.MINUTE));\r\n            cal.set(Calendar.SECOND, cal.getMaximum(Calendar.SECOND));\r\n\r\n            activeTimestamp = new Timestamp(cal.getTime().getTime());\r\n        }\r\n\r\n        return activeTimestamp;\r\n    }\r\n\r\n    /**\r\n     * Changes from/to dates into the range operators the lookupable dao expects (\"..\",\">\" etc) this method modifies\r\n     * the passed in map and returns an updated search criteria map.\r\n     *\r\n     * @param searchCriteria map of criteria currently set for which the date criteria will be adjusted\r\n     * @return map updated search criteria\r\n     */\r\n    public static Map<String, String> preprocessDateFields(Map<String, String> searchCriteria) {\r\n        Map<String, String> fieldsToUpdate = new HashMap<String, String>();\r\n        Map<String, String> searchCriteriaUpdated = new HashMap<String, String>(searchCriteria);\r\n\r\n        Set<String> fieldsForLookup = searchCriteria.keySet();\r\n        for (String propName : fieldsForLookup) {\r\n            if (propName.startsWith(KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX)) {\r\n                String from_DateValue = searchCriteria.get(propName);\r\n                String dateFieldName =\r\n                        StringUtils.remove(propName, KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX);\r\n                String to_DateValue = searchCriteria.get(dateFieldName);\r\n                String newPropValue = to_DateValue;\r\n\r\n                if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isNotEmpty(to_DateValue)) {\r\n                    newPropValue = from_DateValue + SearchOperator.BETWEEN + to_DateValue;\r\n                } else if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isEmpty(to_DateValue)) {\r\n                    newPropValue = SearchOperator.GREATER_THAN_EQUAL.op() + from_DateValue;\r\n                } else if (StringUtils.isNotEmpty(to_DateValue) && StringUtils.isEmpty(from_DateValue)) {\r\n                    newPropValue = SearchOperator.LESS_THAN_EQUAL.op() + to_DateValue;\r\n                } // could optionally continue on else here\r\n\r\n                fieldsToUpdate.put(dateFieldName, newPropValue);\r\n            }\r\n        }\r\n\r\n        // update lookup values from found date values to update\r\n        Set<String> keysToUpdate = fieldsToUpdate.keySet();\r\n        for (String updateKey : keysToUpdate) {\r\n            searchCriteriaUpdated.put(updateKey, fieldsToUpdate.get(updateKey));\r\n        }\r\n\r\n        return searchCriteriaUpdated;\r\n    }\r\n\r\n    /**\r\n     * Checks whether any of the fieldValues being passed refer to a property within an ExternalizableBusinessObject.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of the lookup criteria values\r\n     * @return true if externalizable business object are contained, false otherwise\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static boolean hasExternalBusinessObjectProperty(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check whether the given property represents a property within an EBO starting with the sampleBo object given.\r\n     * This is used to determine if a criteria needs to be applied to the EBO first,\r\n     * before sending to the normal lookup DAO.\r\n     *\r\n     * @param sampleBo business object of the property to be tested\r\n     * @param propertyName property name to be tested\r\n     * @return true if the property is within an externalizable business object.\r\n     */\r\n    public static boolean isExternalBusinessObjectProperty(Object sampleBo, String propertyName) {\r\n        if (propertyName.indexOf(\".\") > 0 && !StringUtils.contains(propertyName, \"add.\")) {\r\n            Class<?> propertyClass =\r\n                    ObjectPropertyUtils.getPropertyType(sampleBo, StringUtils.substringBeforeLast(propertyName, \".\"));\r\n            if (propertyClass != null) {\r\n                return ExternalizableBusinessObjectUtils.isExternalizableBusinessObjectInterface(propertyClass);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a map stripped of any properties which refer to ExternalizableBusinessObjects. These values may not be\r\n     * passed into the lookup service, since the objects they refer to are not in the\r\n     * local database.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of lookup criteria from which to remove the externalizable business objects\r\n     * @return map of lookup criteria without externalizable business objects\r\n     */\r\n    public static Map<String, String> removeExternalizableBusinessObjectFieldValues(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Map<String, String> eboFieldValues = new HashMap<String, String>();\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (!isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                eboFieldValues.put(key, fieldValues.get(key));\r\n            }\r\n        }\r\n\r\n        return eboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Return the EBO fieldValue entries explicitly for the given eboPropertyName. (I.e., any properties with the given\r\n     * property name as a prefix.\r\n     *\r\n     * @param eboPropertyName the externalizable business object property name to retrieve\r\n     * @param fieldValues map of lookup criteria\r\n     * return map of lookup criteria for the given eboPropertyName\r\n     */\r\n    public static Map<String, String> getExternalizableBusinessObjectFieldValues(String eboPropertyName,\r\n            Map<String, String> fieldValues) {\r\n        Map<String, String> eboFieldValues = new HashMap<String, String>();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (key.startsWith(eboPropertyName + \".\")) {\r\n                eboFieldValues.put(StringUtils.substringAfterLast(key, \".\"), fieldValues.get(key));\r\n            }\r\n        }\r\n\r\n        return eboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Get the complete list of all properties referenced in the fieldValues that are ExternalizableBusinessObjects.\r\n     *\r\n     * <p>\r\n     * This is a list of the EBO object references themselves, not of the properties within them.\r\n     * </p>\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of lookup criteria from which to return the externalizable business objects\r\n     * @return map of lookup criteria that are externalizable business objects\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static List<String> getExternalizableBusinessObjectProperties(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Set<String> eboPropertyNames = new HashSet<String>();\r\n\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                eboPropertyNames.add(StringUtils.substringBeforeLast(key, \".\"));\r\n            }\r\n        }\r\n\r\n        return new ArrayList<String>(eboPropertyNames);\r\n    }\r\n\r\n    /**\r\n     * Given an property on the main BO class, return the defined type of the ExternalizableBusinessObject. This will\r\n     * be used by other code to determine the correct module service to call for the lookup.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param propertyName property of which the externalizable business object type is to be determined\r\n     * @return externalizable business object type\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static Class<? extends ExternalizableBusinessObject> getExternalizableBusinessObjectClass(Class<?> boClass,\r\n            String propertyName) throws IllegalAccessException, InstantiationException {\r\n        return (Class<? extends ExternalizableBusinessObject>) ObjectPropertyUtils\r\n                .getPropertyType(boClass.newInstance(), StringUtils.substringBeforeLast(propertyName, \".\"));\r\n    }\r\n\r\n    /**\r\n     * Looks for criteria against nested EBOs and performs a search against that EBO and updates the criteria.\r\n     *\r\n     * @param searchCriteria map of criteria currently set\r\n     * @param unbounded indicates whether the complete result should be returned.  When set to false the result is\r\n     * limited (if necessary) to the max search result limit configured.\r\n     * @return Map of adjusted criteria for nested EBOs\r\n     * @throws InstantiationException\r\n     * @throws IllegalAccessException\r\n     */\r\n    public static Map<String, String> adjustCriteriaForNestedEBOs(Class<?> dataObjectClass,\r\n            Map<String, String> searchCriteria,\r\n            boolean unbounded) throws InstantiationException, IllegalAccessException {\r\n        // remove the EBO criteria\r\n        Map<String, String> nonEboFieldValues = removeExternalizableBusinessObjectFieldValues(\r\n                dataObjectClass, searchCriteria);\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Non EBO properties removed: \" + nonEboFieldValues);\r\n        }\r\n\r\n        // get the list of EBO properties attached to this object\r\n        List<String> eboPropertyNames = getExternalizableBusinessObjectProperties(dataObjectClass, searchCriteria);\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"EBO properties: \" + eboPropertyNames);\r\n        }\r\n\r\n        // loop over those properties\r\n        for (String eboPropertyName : eboPropertyNames) {\r\n            // extract the properties as known to the EBO\r\n            Map<String, String> eboFieldValues = LookupUtils.getExternalizableBusinessObjectFieldValues(eboPropertyName,\r\n                    searchCriteria);\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"EBO properties for master EBO property: \" + eboPropertyName);\r\n                LOG.debug(\"properties: \" + eboFieldValues);\r\n            }\r\n\r\n            // run search against attached EBO's module service\r\n            ModuleService eboModuleService = KRADServiceLocatorWeb.getKualiModuleService().getResponsibleModuleService(\r\n                    getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName));\r\n\r\n            // KULRICE-4401 made eboResults an empty list and only filled if service is found.\r\n            List<?> eboResults = Collections.emptyList();\r\n            if (eboModuleService != null) {\r\n                eboResults = eboModuleService.getExternalizableBusinessObjectsListForLookup(\r\n                        getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName),\r\n                        (Map) eboFieldValues, unbounded);\r\n            } else {\r\n                LOG.debug(\"EBO ModuleService is null: \" + eboPropertyName);\r\n            }\r\n\r\n            // get the parent property type\r\n            Class<?> eboParentClass;\r\n            String eboParentPropertyName;\r\n            if (PropertyAccessorUtils.isNestedOrIndexedProperty(eboPropertyName)) {\r\n                eboParentPropertyName = StringUtils.substringBeforeLast(eboPropertyName, \".\");\r\n                try {\r\n                    eboParentClass = KradDataServiceLocator.getDataObjectService().wrap(dataObjectClass.newInstance()).getPropertyType(\r\n                            eboParentPropertyName);\r\n                } catch (Exception ex) {\r\n                    throw new RuntimeException(\r\n                            \"Unable to create an instance of the business object class: \" + dataObjectClass\r\n                                    .getName(), ex);\r\n                }\r\n            } else {\r\n                eboParentClass = dataObjectClass;\r\n                eboParentPropertyName = null;\r\n            }\r\n\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"determined EBO parent class/property name: \" + eboParentClass + \"/\" + eboParentPropertyName);\r\n            }\r\n\r\n            // look that up in the DD (BOMDS) find the appropriate relationship\r\n            // CHECK THIS: what if eboPropertyName is a nested attribute - need to strip off the\r\n            // eboParentPropertyName if not null\r\n            RelationshipDefinition rd = KRADServiceLocatorWeb.getLegacyDataAdapter().getDictionaryRelationship(\r\n                    eboParentClass, eboPropertyName);\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Obtained RelationshipDefinition for \" + eboPropertyName);\r\n                LOG.debug(rd);\r\n            }\r\n\r\n            // copy the needed properties (primary only) to the field values KULRICE-4446 do\r\n            // so only if the relationship definition exists\r\n            // NOTE: this will work only for single-field PK unless the ORM\r\n            // layer is directly involved\r\n            // (can't make (field1,field2) in ( (v1,v2),(v3,v4) ) style\r\n            // queries in the lookup framework\r\n            if (KRADUtils.isNotNull(rd)) {\r\n                if (rd.getPrimitiveAttributes().size() > 1) {\r\n                    throw new RuntimeException(\r\n                            \"EBO Links don't work for relationships with multiple-field primary keys.\");\r\n                }\r\n                String boProperty = rd.getPrimitiveAttributes().get(0).getSourceName();\r\n                String eboProperty = rd.getPrimitiveAttributes().get(0).getTargetName();\r\n                StringBuffer boPropertyValue = new StringBuffer();\r\n\r\n                // loop over the results, making a string that the lookup DAO will convert into an\r\n                // SQL \"IN\" clause\r\n                for (Object ebo : eboResults) {\r\n                    if (boPropertyValue.length() != 0) {\r\n                        boPropertyValue.append(SearchOperator.OR.op());\r\n                    }\r\n                    try {\r\n                        boPropertyValue.append(PropertyUtils.getProperty(ebo, eboProperty).toString());\r\n                    } catch (Exception ex) {\r\n                        LOG.warn(\"Unable to get value for \" + eboProperty + \" on \" + ebo);\r\n                    }\r\n                }\r\n\r\n                if (eboParentPropertyName == null) {\r\n                    // non-nested property containing the EBO\r\n                    nonEboFieldValues.put(boProperty, boPropertyValue.toString());\r\n                } else {\r\n                    // property nested within the main searched-for BO that contains the EBO\r\n                    nonEboFieldValues.put(eboParentPropertyName + \".\" + boProperty, boPropertyValue.toString());\r\n                }\r\n            }\r\n        }\r\n\r\n        return nonEboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Removes query characters (such as wildcards) from the given string value.\r\n     *\r\n     * @param criteriaValue string to clean\r\n     * @return string with query characters removed\r\n     */\r\n    public static String scrubQueryCharacters(String criteriaValue) {\r\n        return StringUtils.replaceEach(criteriaValue, searchList, replacementList);\r\n    }\r\n\r\n    /**\r\n     * Generates a key string in case of multivalue return. The values are extracted\r\n     * from the list of properties on the lineDataObject.\r\n     *\r\n     * If fieldConversionKeys is empty return the identifier string for the lineDataObject\r\n     *\r\n     * @param lineDataObject   Object from which to extract values\r\n     * @param fieldConversionKeys List of keys whose values have to be concatenated\r\n     * @return string representing the multivalue key \r\n     */\r\n    public static String generateMultiValueKey(Object lineDataObject, List<String> fieldConversionKeys) {\r\n        String lineIdentifier = \"\";\r\n\r\n        if(fieldConversionKeys == null || fieldConversionKeys.isEmpty()) {\r\n            lineIdentifier =\r\n                    KRADServiceLocatorWeb.getLegacyDataAdapter().getDataObjectIdentifierString(lineDataObject);\r\n        } else {\r\n            Collections.sort(fieldConversionKeys);\r\n            for (String fromFieldName : fieldConversionKeys) {\r\n                Object fromFieldValue = ObjectPropertyUtils.getPropertyValue(lineDataObject, fromFieldName);\r\n\r\n                if (fromFieldValue != null) {\r\n                    lineIdentifier += fromFieldValue;\r\n                }\r\n\r\n                lineIdentifier += \":\";\r\n            }\r\n            lineIdentifier = StringUtils.removeEnd(lineIdentifier, \":\");\r\n        }\r\n\r\n        return lineIdentifier;\r\n    }\r\n\r\n    /**\r\n     * Merges the lookup result selections that are part of the request with the selectedLookupResultsCache maintained in\r\n     * the session.\r\n     *\r\n     * @param form lookup form instance containing the selected results and lookup configuration\r\n     */\r\n    public static void refreshLookupResultSelections(LookupForm form) {\r\n\r\n        int displayStart = 0;\r\n        int displayLength = 0;\r\n\r\n        // avoid blowing the stack if the session expired\r\n        ViewPostMetadata viewPostMetadata = form.getViewPostMetadata();\r\n        if (viewPostMetadata != null) {\r\n\r\n            // only one concurrent request per view please\r\n            synchronized (viewPostMetadata) {\r\n                ComponentPostMetadata oldCollectionGroup = viewPostMetadata.getComponentPostMetadata(\"uLookupResults\");\r\n                displayStart = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_START);\r\n                displayLength = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_LENGTH);\r\n            }\r\n        }\r\n\r\n        List<? extends Object> lookupResults = (List<? extends Object>) form.getLookupResults();\r\n        List<String> fromFieldNames = form.getMultiValueReturnFields();\r\n\r\n        Set<String> selectedLines = form.getSelectedCollectionLines().get(UifPropertyPaths.LOOKUP_RESULTS);\r\n        Set<String> selectedLookupResultsCache = form.getSelectedLookupResultsCache();\r\n\r\n        selectedLines = (selectedLines == null) ? new HashSet<String>() : selectedLines;\r\n\r\n\r\n        for(int i = displayStart; i < displayStart + displayLength; i++ ) {\r\n            if(i >= form.getLookupResults().size()) break;\r\n\r\n            Object lineItem = lookupResults.get(i);\r\n            String lineIdentifier = LookupUtils.generateMultiValueKey(lineItem, fromFieldNames);\r\n\r\n            if(!selectedLines.contains(lineIdentifier)) {\r\n                 selectedLookupResultsCache.remove(lineIdentifier);\r\n            } else {\r\n                selectedLookupResultsCache.add(lineIdentifier);\r\n            }\r\n        }\r\n\r\n        selectedLines.addAll( selectedLookupResultsCache );\r\n\r\n        form.getSelectedCollectionLines().put(UifPropertyPaths.LOOKUP_RESULTS, selectedLines);\r\n    }\r\n\r\n}", "class_id": 0, "repo": "iu-uits-es/rice", "file": "rice-framework/krad-web-framework/src/main/java/org/kuali/rice/krad/lookup/LookupUtils.java", "last_update_at": "2018-12-05T18:45:26+00:00", "question_id": "d87551b82307b12235f7a32dbf20c53a669b0bbb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LookupUtils {\r\n    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(LookupUtils.class);\r\n    private static final String[] searchList = new String[SearchOperator.QUERY_CHARACTERS.size()];\r\n\r\n    static {\r\n        int index = 0;\r\n        for (SearchOperator operator : SearchOperator.QUERY_CHARACTERS) {\r\n            searchList[index++] = operator.op();\r\n        }\r\n    }\r\n\r\n    private static final String[] replacementList = Collections.nCopies(searchList.length, \"\").toArray(new String[0]);\r\n\r\n    private LookupUtils() {}\r\n\r\n    /**\r\n     * Retrieves the value for the given parameter name to send as a lookup parameter.\r\n     *\r\n     * @param form form instance to retrieve values from\r\n     * @param request request object to retrieve parameters from\r\n     * @param lookupObjectClass data object class associated with the lookup, used to check whether the\r\n     * value needs to be encyrpted\r\n     * @param propertyName name of the property associated with the parameter, used to check whether the\r\n     * value needs to be encrypted\r\n     * @param parameterName name of the parameter to retrieve the value for\r\n     * @return String parameter value or empty string if no value was found\r\n     */\r\n    public static String retrieveLookupParameterValue(UifFormBase form, HttpServletRequest request,\r\n            Class<?> lookupObjectClass, String propertyName, String parameterName) {\r\n        String parameterValue = \"\";\r\n\r\n        // get literal parameter values first\r\n        if (StringUtils.startsWith(parameterName, \"'\") && StringUtils.endsWith(parameterName, \"'\")) {\r\n            parameterValue = StringUtils.substringBetween(parameterName, \"'\");\r\n        } else if (parameterValue.startsWith(KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX\r\n                + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER)) {\r\n            parameterValue = StringUtils.removeStart(parameterValue, KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX\r\n                    + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER);\r\n        }\r\n        // check if parameter is in request\r\n        else if (request.getParameterMap().containsKey(parameterName)) {\r\n            parameterValue = request.getParameter(parameterName);\r\n        }\r\n        // get parameter value from form object\r\n        else {\r\n            parameterValue = ObjectPropertyUtils.getPropertyValue(form, parameterName);\r\n            // TODO: should go through property editor for display\r\n        }\r\n\r\n        if (parameterValue != null && lookupObjectClass != null\r\n                && KRADServiceLocatorWeb.getDataObjectAuthorizationService()\r\n                .attributeValueNeedsToBeEncryptedOnFormsAndLinks(lookupObjectClass, propertyName)) {\r\n            try {\r\n                if (CoreApiServiceLocator.getEncryptionService().isEnabled()) {\r\n                    parameterValue = CoreApiServiceLocator.getEncryptionService().encrypt(parameterValue)\r\n                            + EncryptionService.ENCRYPTION_POST_PREFIX;\r\n                }\r\n            } catch (GeneralSecurityException e) {\r\n                LOG.error(\"Unable to encrypt value for property name: \" + propertyName);\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        return parameterValue;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default KRAD base lookup URL, used to build lookup URLs in code\r\n     *\r\n     * @return String base lookup URL (everything except query string)\r\n     */\r\n    public static String getBaseLookupUrl() {\r\n        return CoreApiServiceLocator.getKualiConfigurationService().getPropertyValueAsString(\r\n                KRADConstants.KRAD_LOOKUP_URL_KEY);\r\n    }\r\n\r\n    /**\r\n     * Uses the DataDictionary to determine whether to force uppercase the value, and if it should, then it does the\r\n     * uppercase, and returns the upper-cased value.\r\n     *\r\n     * @param dataObjectClass parent DO class that the fieldName is a member of\r\n     * @param fieldName name of the field to be forced to uppercase\r\n     * @param fieldValue value of the field that may be uppercased\r\n     * @return the correctly uppercased fieldValue if it should be uppercased, otherwise fieldValue is returned\r\n     *         unchanged\r\n     */\r\n    public static String forceUppercase(Class<?> dataObjectClass, String fieldName, String fieldValue) {\r\n        // short-circuit to exit if there isnt enough information to do the forceUppercase\r\n        if (StringUtils.isBlank(fieldValue)) {\r\n            return fieldValue;\r\n        }\r\n\r\n        // parameter validation\r\n        if (dataObjectClass == null) {\r\n            throw new IllegalArgumentException(\"Parameter dataObjectClass passed in with null value.\");\r\n        }\r\n\r\n        if (StringUtils.isBlank(fieldName)) {\r\n            throw new IllegalArgumentException(\"Parameter fieldName passed in with empty value.\");\r\n        }\r\n\r\n        if (!KRADServiceLocatorWeb.getDataDictionaryService().isAttributeDefined(dataObjectClass, fieldName)\r\n                .booleanValue()) {\r\n            return fieldValue;\r\n        }\r\n\r\n        boolean forceUpperCase = false;\r\n        try {\r\n            forceUpperCase = KRADServiceLocatorWeb.getDataDictionaryService()\r\n                    .getAttributeForceUppercase(dataObjectClass, fieldName).booleanValue();\r\n        } catch (UnknownBusinessClassAttributeException ubae) {\r\n            // do nothing, don't alter the fieldValue\r\n        }\r\n\r\n        if (forceUpperCase && !fieldValue.endsWith(EncryptionService.ENCRYPTION_POST_PREFIX)) {\r\n            return fieldValue.toUpperCase();\r\n        }\r\n\r\n        return fieldValue;\r\n    }\r\n\r\n    /**\r\n     * Uses the DataDictionary to determine whether to force uppercase the values, and if it should, then it does the\r\n     * uppercase, and returns the upper-cased Map of fieldname/fieldValue pairs.\r\n     *\r\n     * @param dataObjectClass parent DO class that the fieldName is a member of\r\n     * @param fieldValues a Map<String,String> where the key is the fieldName and the value is the fieldValue\r\n     * @return the same Map is returned, with the appropriate values uppercased (if any)\r\n     */\r\n    public static Map<String, String> forceUppercase(Class<?> dataObjectClass, Map<String, String> fieldValues) {\r\n        if (dataObjectClass == null) {\r\n            throw new IllegalArgumentException(\"Parameter boClass passed in with null value.\");\r\n        }\r\n\r\n        if (fieldValues == null) {\r\n            throw new IllegalArgumentException(\"Parameter fieldValues passed in with null value.\");\r\n        }\r\n\r\n        for (String fieldName : fieldValues.keySet()) {\r\n            fieldValues.put(fieldName, forceUppercase(dataObjectClass, fieldName, fieldValues.get(fieldName)));\r\n        }\r\n\r\n        return fieldValues;\r\n    }\r\n\r\n    /**\r\n     * Parses and returns the lookup result set limit, checking first for the limit for the specific view,\r\n     * then the class being looked up, and then the global application limit if there isn't a limit specific\r\n     * to this data object class.\r\n     *\r\n     * @param dataObjectClass class to get limit for\r\n     * @param lookupForm lookupForm to use.  May be null if the form is unknown. If lookupForm is null, only the\r\n     * dataObjectClass will be used to find the search results set limit\r\n     * @return result set limit\r\n     */\r\n    public static Integer getSearchResultsLimit(Class dataObjectClass, LookupForm lookupForm) {\r\n        Integer limit = KRADServiceLocatorWeb.getViewDictionaryService().getResultSetLimitForLookup(dataObjectClass,\r\n                lookupForm);\r\n        if (limit == null) {\r\n            limit = getApplicationSearchResultsLimit();\r\n        }\r\n\r\n        return limit;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default application search limit configured through a system parameter.\r\n     *\r\n     * @return default result set limit of the application\r\n     */\r\n    public static Integer getApplicationSearchResultsLimit() {\r\n        String limitString = CoreFrameworkServiceLocator.getParameterService()\r\n                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,\r\n                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,\r\n                        KRADConstants.SystemGroupParameterNames.LOOKUP_RESULTS_LIMIT);\r\n        if (limitString != null) {\r\n            return Integer.valueOf(limitString);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the default application multiple value search limit configured through a system parameter.\r\n     *\r\n     * @return default multiple value result set limit of the application\r\n     */\r\n    public static Integer getApplicationMultipleValueSearchResultsLimit() {\r\n        String limitString = CoreFrameworkServiceLocator.getParameterService()\r\n                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,\r\n                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,\r\n                        KRADConstants.SystemGroupParameterNames.MULTIPLE_VALUE_LOOKUP_RESULTS_LIMIT);\r\n        if (limitString != null) {\r\n            return Integer.valueOf(limitString);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Determines what Timestamp should be used for active queries on effective dated records. Determination made as\r\n     * follows:\r\n     *\r\n     * <ul>\r\n     * <li>Use activeAsOfDate value from search values Map if value is not empty</li>\r\n     * <li>If search value given, try to convert to sql date, if conversion fails, try to convert to Timestamp</li>\r\n     * <li>If search value empty, use current Date</li>\r\n     * <li>If Timestamp value not given, create Timestamp from given Date setting the time as 1 second before midnight\r\n     * </ul>\r\n     *\r\n     * @param searchValues map containing search key/value pairs\r\n     * @return timestamp to be used for active criteria\r\n     */\r\n    public static Timestamp getActiveDateTimestampForCriteria(Map searchValues) {\r\n        Date activeDate = CoreApiServiceLocator.getDateTimeService().getCurrentSqlDate();\r\n\r\n        Timestamp activeTimestamp = null;\r\n        if (searchValues.containsKey(KRADPropertyConstants.ACTIVE_AS_OF_DATE)) {\r\n            String activeAsOfDate = (String) searchValues.get(KRADPropertyConstants.ACTIVE_AS_OF_DATE);\r\n            if (StringUtils.isNotBlank(activeAsOfDate)) {\r\n                try {\r\n                    activeDate = CoreApiServiceLocator.getDateTimeService()\r\n                            .convertToSqlDate(KRADUtils.clean(activeAsOfDate));\r\n                } catch (ParseException e) {\r\n                    // try to parse as timestamp\r\n                    try {\r\n                        activeTimestamp = CoreApiServiceLocator.getDateTimeService()\r\n                                .convertToSqlTimestamp(KRADUtils.clean(activeAsOfDate));\r\n                    } catch (ParseException e1) {\r\n                        throw new RuntimeException(\"Unable to convert date: \" + KRADUtils.clean(activeAsOfDate));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // if timestamp not given set to 1 second before midnight on the given date\r\n        if (activeTimestamp == null) {\r\n            Calendar cal = Calendar.getInstance();\r\n\r\n            cal.setTime(activeDate);\r\n            cal.set(Calendar.HOUR, cal.getMaximum(Calendar.HOUR));\r\n            cal.set(Calendar.MINUTE, cal.getMaximum(Calendar.MINUTE));\r\n            cal.set(Calendar.SECOND, cal.getMaximum(Calendar.SECOND));\r\n\r\n            activeTimestamp = new Timestamp(cal.getTime().getTime());\r\n        }\r\n\r\n        return activeTimestamp;\r\n    }\r\n\r\n    /**\r\n     * Changes from/to dates into the range operators the lookupable dao expects (\"..\",\">\" etc) this method modifies\r\n     * the passed in map and returns an updated search criteria map.\r\n     *\r\n     * @param searchCriteria map of criteria currently set for which the date criteria will be adjusted\r\n     * @return map updated search criteria\r\n     */\r\n    public static Map<String, String> preprocessDateFields(Map<String, String> searchCriteria) {\r\n        Map<String, String> fieldsToUpdate = new HashMap<String, String>();\r\n        Map<String, String> searchCriteriaUpdated = new HashMap<String, String>(searchCriteria);\r\n\r\n        Set<String> fieldsForLookup = searchCriteria.keySet();\r\n        for (String propName : fieldsForLookup) {\r\n            if (propName.startsWith(KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX)) {\r\n                String from_DateValue = searchCriteria.get(propName);\r\n                String dateFieldName =\r\n                        StringUtils.remove(propName, KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX);\r\n                String to_DateValue = searchCriteria.get(dateFieldName);\r\n                String newPropValue = to_DateValue;\r\n\r\n                if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isNotEmpty(to_DateValue)) {\r\n                    newPropValue = from_DateValue + SearchOperator.BETWEEN + to_DateValue;\r\n                } else if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isEmpty(to_DateValue)) {\r\n                    newPropValue = SearchOperator.GREATER_THAN_EQUAL.op() + from_DateValue;\r\n                } else if (StringUtils.isNotEmpty(to_DateValue) && StringUtils.isEmpty(from_DateValue)) {\r\n                    newPropValue = SearchOperator.LESS_THAN_EQUAL.op() + to_DateValue;\r\n                } // could optionally continue on else here\r\n\r\n                fieldsToUpdate.put(dateFieldName, newPropValue);\r\n            }\r\n        }\r\n\r\n        // update lookup values from found date values to update\r\n        Set<String> keysToUpdate = fieldsToUpdate.keySet();\r\n        for (String updateKey : keysToUpdate) {\r\n            searchCriteriaUpdated.put(updateKey, fieldsToUpdate.get(updateKey));\r\n        }\r\n\r\n        return searchCriteriaUpdated;\r\n    }\r\n\r\n    /**\r\n     * Checks whether any of the fieldValues being passed refer to a property within an ExternalizableBusinessObject.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of the lookup criteria values\r\n     * @return true if externalizable business object are contained, false otherwise\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static boolean hasExternalBusinessObjectProperty(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check whether the given property represents a property within an EBO starting with the sampleBo object given.\r\n     * This is used to determine if a criteria needs to be applied to the EBO first,\r\n     * before sending to the normal lookup DAO.\r\n     *\r\n     * @param sampleBo business object of the property to be tested\r\n     * @param propertyName property name to be tested\r\n     * @return true if the property is within an externalizable business object.\r\n     */\r\n    public static boolean isExternalBusinessObjectProperty(Object sampleBo, String propertyName) {\r\n        if (propertyName.indexOf(\".\") > 0 && !StringUtils.contains(propertyName, \"add.\")) {\r\n            Class<?> propertyClass =\r\n                    ObjectPropertyUtils.getPropertyType(sampleBo, StringUtils.substringBeforeLast(propertyName, \".\"));\r\n            if (propertyClass != null) {\r\n                return ExternalizableBusinessObjectUtils.isExternalizableBusinessObjectInterface(propertyClass);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a map stripped of any properties which refer to ExternalizableBusinessObjects. These values may not be\r\n     * passed into the lookup service, since the objects they refer to are not in the\r\n     * local database.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of lookup criteria from which to remove the externalizable business objects\r\n     * @return map of lookup criteria without externalizable business objects\r\n     */\r\n    public static Map<String, String> removeExternalizableBusinessObjectFieldValues(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Map<String, String> eboFieldValues = new HashMap<String, String>();\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (!isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                eboFieldValues.put(key, fieldValues.get(key));\r\n            }\r\n        }\r\n\r\n        return eboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Return the EBO fieldValue entries explicitly for the given eboPropertyName. (I.e., any properties with the given\r\n     * property name as a prefix.\r\n     *\r\n     * @param eboPropertyName the externalizable business object property name to retrieve\r\n     * @param fieldValues map of lookup criteria\r\n     * return map of lookup criteria for the given eboPropertyName\r\n     */\r\n    public static Map<String, String> getExternalizableBusinessObjectFieldValues(String eboPropertyName,\r\n            Map<String, String> fieldValues) {\r\n        Map<String, String> eboFieldValues = new HashMap<String, String>();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (key.startsWith(eboPropertyName + \".\")) {\r\n                eboFieldValues.put(StringUtils.substringAfterLast(key, \".\"), fieldValues.get(key));\r\n            }\r\n        }\r\n\r\n        return eboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Get the complete list of all properties referenced in the fieldValues that are ExternalizableBusinessObjects.\r\n     *\r\n     * <p>\r\n     * This is a list of the EBO object references themselves, not of the properties within them.\r\n     * </p>\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param fieldValues map of lookup criteria from which to return the externalizable business objects\r\n     * @return map of lookup criteria that are externalizable business objects\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static List<String> getExternalizableBusinessObjectProperties(Class<?> boClass,\r\n            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {\r\n        Set<String> eboPropertyNames = new HashSet<String>();\r\n\r\n        Object sampleBo = boClass.newInstance();\r\n        for (String key : fieldValues.keySet()) {\r\n            if (isExternalBusinessObjectProperty(sampleBo, key)) {\r\n                eboPropertyNames.add(StringUtils.substringBeforeLast(key, \".\"));\r\n            }\r\n        }\r\n\r\n        return new ArrayList<String>(eboPropertyNames);\r\n    }\r\n\r\n    /**\r\n     * Given an property on the main BO class, return the defined type of the ExternalizableBusinessObject. This will\r\n     * be used by other code to determine the correct module service to call for the lookup.\r\n     *\r\n     * @param boClass business object class of the lookup\r\n     * @param propertyName property of which the externalizable business object type is to be determined\r\n     * @return externalizable business object type\r\n     * @throws IllegalAccessException\r\n     * @throws InstantiationException\r\n     */\r\n    public static Class<? extends ExternalizableBusinessObject> getExternalizableBusinessObjectClass(Class<?> boClass,\r\n            String propertyName) throws IllegalAccessException, InstantiationException {\r\n        return (Class<? extends ExternalizableBusinessObject>) ObjectPropertyUtils\r\n                .getPropertyType(boClass.newInstance(), StringUtils.substringBeforeLast(propertyName, \".\"));\r\n    }\r\n\r\n    /**\r\n     * Looks for criteria against nested EBOs and performs a search against that EBO and updates the criteria.\r\n     *\r\n     * @param searchCriteria map of criteria currently set\r\n     * @param unbounded indicates whether the complete result should be returned.  When set to false the result is\r\n     * limited (if necessary) to the max search result limit configured.\r\n     * @return Map of adjusted criteria for nested EBOs\r\n     * @throws InstantiationException\r\n     * @throws IllegalAccessException\r\n     */\r\n    public static Map<String, String> adjustCriteriaForNestedEBOs(Class<?> dataObjectClass,\r\n            Map<String, String> searchCriteria,\r\n            boolean unbounded) throws InstantiationException, IllegalAccessException {\r\n        // remove the EBO criteria\r\n        Map<String, String> nonEboFieldValues = removeExternalizableBusinessObjectFieldValues(\r\n                dataObjectClass, searchCriteria);\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Non EBO properties removed: \" + nonEboFieldValues);\r\n        }\r\n\r\n        // get the list of EBO properties attached to this object\r\n        List<String> eboPropertyNames = getExternalizableBusinessObjectProperties(dataObjectClass, searchCriteria);\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"EBO properties: \" + eboPropertyNames);\r\n        }\r\n\r\n        // loop over those properties\r\n        for (String eboPropertyName : eboPropertyNames) {\r\n            // extract the properties as known to the EBO\r\n            Map<String, String> eboFieldValues = LookupUtils.getExternalizableBusinessObjectFieldValues(eboPropertyName,\r\n                    searchCriteria);\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"EBO properties for master EBO property: \" + eboPropertyName);\r\n                LOG.debug(\"properties: \" + eboFieldValues);\r\n            }\r\n\r\n            // run search against attached EBO's module service\r\n            ModuleService eboModuleService = KRADServiceLocatorWeb.getKualiModuleService().getResponsibleModuleService(\r\n                    getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName));\r\n\r\n            // KULRICE-4401 made eboResults an empty list and only filled if service is found.\r\n            List<?> eboResults = Collections.emptyList();\r\n            if (eboModuleService != null) {\r\n                eboResults = eboModuleService.getExternalizableBusinessObjectsListForLookup(\r\n                        getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName),\r\n                        (Map) eboFieldValues, unbounded);\r\n            } else {\r\n                LOG.debug(\"EBO ModuleService is null: \" + eboPropertyName);\r\n            }\r\n\r\n            // get the parent property type\r\n            Class<?> eboParentClass;\r\n            String eboParentPropertyName;\r\n            if (PropertyAccessorUtils.isNestedOrIndexedProperty(eboPropertyName)) {\r\n                eboParentPropertyName = StringUtils.substringBeforeLast(eboPropertyName, \".\");\r\n                try {\r\n                    eboParentClass = KradDataServiceLocator.getDataObjectService().wrap(dataObjectClass.newInstance()).getPropertyType(\r\n                            eboParentPropertyName);\r\n                } catch (Exception ex) {\r\n                    throw new RuntimeException(\r\n                            \"Unable to create an instance of the business object class: \" + dataObjectClass\r\n                                    .getName(), ex);\r\n                }\r\n            } else {\r\n                eboParentClass = dataObjectClass;\r\n                eboParentPropertyName = null;\r\n            }\r\n\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"determined EBO parent class/property name: \" + eboParentClass + \"/\" + eboParentPropertyName);\r\n            }\r\n\r\n            // look that up in the DD (BOMDS) find the appropriate relationship\r\n            // CHECK THIS: what if eboPropertyName is a nested attribute - need to strip off the\r\n            // eboParentPropertyName if not null\r\n            RelationshipDefinition rd = KRADServiceLocatorWeb.getLegacyDataAdapter().getDictionaryRelationship(\r\n                    eboParentClass, eboPropertyName);\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Obtained RelationshipDefinition for \" + eboPropertyName);\r\n                LOG.debug(rd);\r\n            }\r\n\r\n            // copy the needed properties (primary only) to the field values KULRICE-4446 do\r\n            // so only if the relationship definition exists\r\n            // NOTE: this will work only for single-field PK unless the ORM\r\n            // layer is directly involved\r\n            // (can't make (field1,field2) in ( (v1,v2),(v3,v4) ) style\r\n            // queries in the lookup framework\r\n            if (KRADUtils.isNotNull(rd)) {\r\n                if (rd.getPrimitiveAttributes().size() > 1) {\r\n                    throw new RuntimeException(\r\n                            \"EBO Links don't work for relationships with multiple-field primary keys.\");\r\n                }\r\n                String boProperty = rd.getPrimitiveAttributes().get(0).getSourceName();\r\n                String eboProperty = rd.getPrimitiveAttributes().get(0).getTargetName();\r\n                StringBuffer boPropertyValue = new StringBuffer();\r\n\r\n                // loop over the results, making a string that the lookup DAO will convert into an\r\n                // SQL \"IN\" clause\r\n                for (Object ebo : eboResults) {\r\n                    if (boPropertyValue.length() != 0) {\r\n                        boPropertyValue.append(SearchOperator.OR.op());\r\n                    }\r\n                    try {\r\n                        boPropertyValue.append(PropertyUtils.getProperty(ebo, eboProperty).toString());\r\n                    } catch (Exception ex) {\r\n                        LOG.warn(\"Unable to get value for \" + eboProperty + \" on \" + ebo);\r\n                    }\r\n                }\r\n\r\n                if (eboParentPropertyName == null) {\r\n                    // non-nested property containing the EBO\r\n                    nonEboFieldValues.put(boProperty, boPropertyValue.toString());\r\n                } else {\r\n                    // property nested within the main searched-for BO that contains the EBO\r\n                    nonEboFieldValues.put(eboParentPropertyName + \".\" + boProperty, boPropertyValue.toString());\r\n                }\r\n            }\r\n        }\r\n\r\n        return nonEboFieldValues;\r\n    }\r\n\r\n    /**\r\n     * Removes query characters (such as wildcards) from the given string value.\r\n     *\r\n     * @param criteriaValue string to clean\r\n     * @return string with query characters removed\r\n     */\r\n    public static String scrubQueryCharacters(String criteriaValue) {\r\n        return StringUtils.replaceEach(criteriaValue, searchList, replacementList);\r\n    }\r\n\r\n    /**\r\n     * Generates a key string in case of multivalue return. The values are extracted\r\n     * from the list of properties on the lineDataObject.\r\n     *\r\n     * If fieldConversionKeys is empty return the identifier string for the lineDataObject\r\n     *\r\n     * @param lineDataObject   Object from which to extract values\r\n     * @param fieldConversionKeys List of keys whose values have to be concatenated\r\n     * @return string representing the multivalue key \r\n     */\r\n    public static String generateMultiValueKey(Object lineDataObject, List<String> fieldConversionKeys) {\r\n        String lineIdentifier = \"\";\r\n\r\n        if(fieldConversionKeys == null || fieldConversionKeys.isEmpty()) {\r\n            lineIdentifier =\r\n                    KRADServiceLocatorWeb.getLegacyDataAdapter().getDataObjectIdentifierString(lineDataObject);\r\n        } else {\r\n            Collections.sort(fieldConversionKeys);\r\n            for (String fromFieldName : fieldConversionKeys) {\r\n                Object fromFieldValue = ObjectPropertyUtils.getPropertyValue(lineDataObject, fromFieldName);\r\n\r\n                if (fromFieldValue != null) {\r\n                    lineIdentifier += fromFieldValue;\r\n                }\r\n\r\n                lineIdentifier += \":\";\r\n            }\r\n            lineIdentifier = StringUtils.removeEnd(lineIdentifier, \":\");\r\n        }\r\n\r\n        return lineIdentifier;\r\n    }\r\n\r\n    /**\r\n     * Merges the lookup result selections that are part of the request with the selectedLookupResultsCache maintained in\r\n     * the session.\r\n     *\r\n     * @param form lookup form instance containing the selected results and lookup configuration\r\n     */\r\n    public static void refreshLookupResultSelections(LookupForm form) {\r\n\r\n        int displayStart = 0;\r\n        int displayLength = 0;\r\n\r\n        // avoid blowing the stack if the session expired\r\n        ViewPostMetadata viewPostMetadata = form.getViewPostMetadata();\r\n        if (viewPostMetadata != null) {\r\n\r\n            // only one concurrent request per view please\r\n            synchronized (viewPostMetadata) {\r\n                ComponentPostMetadata oldCollectionGroup = viewPostMetadata.getComponentPostMetadata(\"uLookupResults\");\r\n                displayStart = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_START);\r\n                displayLength = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_LENGTH);\r\n            }\r\n        }\r\n\r\n        List<? extends Object> lookupResults = (List<? extends Object>) form.getLookupResults();\r\n        List<String> fromFieldNames = form.getMultiValueReturnFields();\r\n\r\n        Set<String> selectedLines = form.getSelectedCollectionLines().get(UifPropertyPaths.LOOKUP_RESULTS);\r\n        Set<String> selectedLookupResultsCache = form.getSelectedLookupResultsCache();\r\n\r\n        selectedLines = (selectedLines == null) ? new HashSet<String>() : selectedLines;\r\n\r\n\r\n        for(int i = displayStart; i < displayStart + displayLength; i++ ) {\r\n            if(i >= form.getLookupResults().size()) break;\r\n\r\n            Object lineItem = lookupResults.get(i);\r\n            String lineIdentifier = LookupUtils.generateMultiValueKey(lineItem, fromFieldNames);\r\n\r\n            if(!selectedLines.contains(lineIdentifier)) {\r\n                 selectedLookupResultsCache.remove(lineIdentifier);\r\n            } else {\r\n                selectedLookupResultsCache.add(lineIdentifier);\r\n            }\r\n        }\r\n\r\n        selectedLines.addAll( selectedLookupResultsCache );\r\n\r\n        form.getSelectedCollectionLines().put(UifPropertyPaths.LOOKUP_RESULTS, selectedLines);\r\n    }\r\n\r\n"]], "pred": {"ppl": 2.126049518585205, "ppl_lower": 2.8414807319641113, "ppl/lowercase_ppl": -1.3845591528804304, "ppl/zlib": 0.00010945662045439479, "Min_5.0% Prob": 6.280934193555047, "Min_10.0% Prob": 4.822785557485094, "Min_20.0% Prob": 3.2986717042969724, "Min_30.0% Prob": 2.4293739602846256, "Min_40.0% Prob": 1.8701078170013312, "Min_50.0% Prob": 1.5071027337804932, "Min_60.0% Prob": 1.2582301698423022}}
{"hexsha": "1a2b353b463480ba065a12236116152940eaf6a6", "ext": "java", "lang": "Java", "content": "public class JweRsaDeserializer implements JweDeserializer {\n\n    private Serdes serdes;\n    private Base64.Decoder decoder;\n    private PrivateKeyTranslator privateKeyTranslator;\n    private CipherRSAFactory cipherRSAFactory;\n    private CipherSymmetricFactory cipherSymmetricFactory;\n\n    public JweRsaDeserializer(Serdes serdes, Base64.Decoder decoder, PrivateKeyTranslator privateKeyTranslator, CipherRSAFactory cipherRSAFactory, CipherSymmetricFactory cipherSymmetricFactory) {\n        this.serdes = serdes;\n        this.decoder = decoder;\n        this.privateKeyTranslator = privateKeyTranslator;\n        this.cipherRSAFactory = cipherRSAFactory;\n        this.cipherSymmetricFactory = cipherSymmetricFactory;\n    }\n\n    public JWE stringToJWE(String compactJWE, Key key) throws JsonToJwtException, DecryptException, CipherException, KeyException {\n        String[] jweParts = compactJWE.split(JWT_SPLITTER);\n        byte[] protectedHeader = decoder.decode(jweParts[0]);\n        byte[] encryptedKey = decoder.decode(jweParts[1]);\n        byte[] initVector = decoder.decode(jweParts[2]);\n        byte[] cipherText = decoder.decode(jweParts[3]);\n        byte[] authenticationTag = decoder.decode(jweParts[4]);\n\n        Header header;\n        try {\n            header = serdes.jsonBytesTo(protectedHeader, Header.class);\n        } catch (JsonException e) {\n            throw new JsonToJwtException(COMPACT_JWE_INVALID, e);\n        }\n\n        RSAKeyPair keyPair = (RSAKeyPair) key;\n        RSAPrivateCrtKey jdkKey;\n        try {\n            jdkKey = privateKeyTranslator.to(keyPair);\n        } catch (PrivateKeyException e) {\n            throw new KeyException(\"\", e);\n        }\n\n        Cipher rsaDecryptCipher;\n        try {\n            rsaDecryptCipher = cipherRSAFactory.forDecrypt(Transformation.RSA_OAEP, jdkKey);\n        } catch (CipherException e) {\n            throw e;\n        }\n\n        byte[] cek;\n        try {\n            cek = rsaDecryptCipher.doFinal(encryptedKey);\n        } catch (IllegalBlockSizeException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);\n        } catch (BadPaddingException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);\n        }\n\n        byte[] aad = jweParts[0].getBytes(StandardCharsets.US_ASCII);\n\n        Cipher symmetricCipher;\n        try {\n            symmetricCipher = cipherSymmetricFactory.forDecrypt(Transformation.AES_GCM_NO_PADDING, cek, initVector, aad);\n        } catch (CipherException e) {\n            throw e;\n        }\n\n        byte[] cipherTextWithAuthTag = cipherTextWithAuthTag(cipherText, authenticationTag);\n\n        byte[] payload;\n        try {\n            payload = symmetricCipher.doFinal(cipherTextWithAuthTag);\n        } catch (IllegalBlockSizeException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);\n        } catch (BadPaddingException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);\n        }\n\n        return new JWE(header, payload, cek, initVector, authenticationTag);\n    }\n}", "class_id": 0, "repo": "RootServices/jwt", "file": "src/main/java/net/tokensmith/jwt/jwe/serialization/rsa/JweRsaDeserializer.java", "last_update_at": "2018-09-26T10:42:11+00:00", "question_id": "1a2b353b463480ba065a12236116152940eaf6a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JweRsaDeserializer implements JweDeserializer {\n    private Serdes serdes;\n    private Base64.Decoder decoder;\n    private PrivateKeyTranslator privateKeyTranslator;\n    private CipherRSAFactory cipherRSAFactory;\n    private CipherSymmetricFactory cipherSymmetricFactory;\n    public JweRsaDeserializer(Serdes serdes, Base64.Decoder decoder, PrivateKeyTranslator privateKeyTranslator, CipherRSAFactory cipherRSAFactory, CipherSymmetricFactory cipherSymmetricFactory) {\n        this.serdes = serdes;\n        this.decoder = decoder;\n        this.privateKeyTranslator = privateKeyTranslator;\n        this.cipherRSAFactory = cipherRSAFactory;\n        this.cipherSymmetricFactory = cipherSymmetricFactory;\n    }\n    public JWE stringToJWE(String compactJWE, Key key) throws JsonToJwtException, DecryptException, CipherException, KeyException {\n        String[] jweParts = compactJWE.split(JWT_SPLITTER);\n        byte[] protectedHeader = decoder.decode(jweParts[0]);\n        byte[] encryptedKey = decoder.decode(jweParts[1]);\n        byte[] initVector = decoder.decode(jweParts[2]);\n        byte[] cipherText = decoder.decode(jweParts[3]);\n        byte[] authenticationTag = decoder.decode(jweParts[4]);\n        Header header;\n        try {\n            header = serdes.jsonBytesTo(protectedHeader, Header.class);\n        } catch (JsonException e) {\n            throw new JsonToJwtException(COMPACT_JWE_INVALID, e);\n        }\n        RSAKeyPair keyPair = (RSAKeyPair) key;\n        RSAPrivateCrtKey jdkKey;\n        try {\n            jdkKey = privateKeyTranslator.to(keyPair);\n        } catch (PrivateKeyException e) {\n            throw new KeyException(\"\", e);\n        }\n        Cipher rsaDecryptCipher;\n        try {\n            rsaDecryptCipher = cipherRSAFactory.forDecrypt(Transformation.RSA_OAEP, jdkKey);\n        } catch (CipherException e) {\n            throw e;\n        }\n        byte[] cek;\n        try {\n            cek = rsaDecryptCipher.doFinal(encryptedKey);\n        } catch (IllegalBlockSizeException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);\n        } catch (BadPaddingException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);\n        }\n        byte[] aad = jweParts[0].getBytes(StandardCharsets.US_ASCII);\n        Cipher symmetricCipher;\n        try {\n            symmetricCipher = cipherSymmetricFactory.forDecrypt(Transformation.AES_GCM_NO_PADDING, cek, initVector, aad);\n        } catch (CipherException e) {\n            throw e;\n        }\n        byte[] cipherTextWithAuthTag = cipherTextWithAuthTag(cipherText, authenticationTag);\n        byte[] payload;\n        try {\n            payload = symmetricCipher.doFinal(cipherTextWithAuthTag);\n        } catch (IllegalBlockSizeException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);\n        } catch (BadPaddingException e) {\n            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);\n        }\n        return new JWE(header, payload, cek, initVector, authenticationTag);\n    }\n"]], "pred": {"ppl": 1.5662322044372559, "ppl_lower": 1.785444736480713, "ppl/lowercase_ppl": -1.2919603148655436, "ppl/zlib": 0.0005366900302296386, "Min_5.0% Prob": 5.47581751147906, "Min_10.0% Prob": 3.7222561265031495, "Min_20.0% Prob": 2.16774779278785, "Min_30.0% Prob": 1.4872390984350607, "Min_40.0% Prob": 1.1217398133230745, "Min_50.0% Prob": 0.8968552116458566, "Min_60.0% Prob": 0.7479157430056056}}
{"hexsha": "c6a4705a17638f6fa4149a96356a8185e4118e3c", "ext": "java", "lang": "Java", "content": "public class GetAttribute extends SeleneseCommand<String> {\r\n  private ElementFinder finder;\r\n\r\n  public GetAttribute(ElementFinder finder) {\r\n    this.finder = finder;\r\n  }\r\n\r\n  @Override\r\n  protected String handleSeleneseCommand(WebDriver driver, String attributeLocator, String ignored) {\r\n    int attributePos = attributeLocator.lastIndexOf(\"@\");\r\n    String elementLocator = attributeLocator.substring(0, attributePos);\r\n    String attributeName = attributeLocator.substring(attributePos + 1);\r\n\r\n    // Find the element.\r\n    WebElement element = finder.findElement(driver, elementLocator);\r\n    return element.getAttribute(attributeName);\r\n  }\r\n}", "class_id": 0, "repo": "epall/selenium", "file": "selenium/src/java/org/openqa/selenium/internal/seleniumemulation/GetAttribute.java", "last_update_at": "2018-05-12T17:39:32+00:00", "question_id": "c6a4705a17638f6fa4149a96356a8185e4118e3c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GetAttribute extends SeleneseCommand<String> {\r\n  private ElementFinder finder;\r\n\r\n  public GetAttribute(ElementFinder finder) {\r\n    this.finder = finder;\r\n  }\r\n\r\n  @Override\r\n  protected String handleSeleneseCommand(WebDriver driver, String attributeLocator, String ignored) {\r\n    int attributePos = attributeLocator.lastIndexOf(\"@\");\r\n    String elementLocator = attributeLocator.substring(0, attributePos);\r\n    String attributeName = attributeLocator.substring(attributePos + 1);\r\n\r\n    // Find the element.\r\n    WebElement element = finder.findElement(driver, elementLocator);\r\n    return element.getAttribute(attributeName);\r\n  }\r\n"]], "pred": {"ppl": 1.6808174848556519, "ppl_lower": 2.3493404388427734, "ppl/lowercase_ppl": -1.6448431965038244, "ppl/zlib": 0.0018030565041425475, "Min_5.0% Prob": 5.883501589298248, "Min_10.0% Prob": 4.445771553937127, "Min_20.0% Prob": 2.6071980937438854, "Min_30.0% Prob": 1.7307817534042091, "Min_40.0% Prob": 1.3078604047659084, "Min_50.0% Prob": 1.0381270278159571, "Min_60.0% Prob": 0.868686486450315}}
{"hexsha": "a4675cd1c6d00c6fa40e0166973f29640e4807a1", "ext": "java", "lang": "Java", "content": "public class BoxLayoutTest\r\n{\r\n   public static void main(String[] args)\r\n   {  \r\n      BoxLayoutFrame frame = new BoxLayoutFrame();\r\n      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n      frame.setVisible(true);\r\n   }\r\n}", "class_id": 0, "repo": "yuweijun/books", "file": "corejava2e7/v1/v1ch9/BoxLayoutTest/BoxLayoutTest.java", "last_update_at": "2018-07-02T12:03:02+00:00", "question_id": "a4675cd1c6d00c6fa40e0166973f29640e4807a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BoxLayoutTest\r\n{\r\n   public static void main(String[] args)\r\n   {  \r\n      BoxLayoutFrame frame = new BoxLayoutFrame();\r\n      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n      frame.setVisible(true);\r\n   }\r\n"]], "pred": {"ppl": 2.1476874351501465, "ppl_lower": 2.876904249191284, "ppl/lowercase_ppl": -1.3824258810177315, "ppl/zlib": 0.004577195519139204, "Min_5.0% Prob": 7.553597291310628, "Min_10.0% Prob": 5.8266206468854636, "Min_20.0% Prob": 3.6018992917878285, "Min_30.0% Prob": 2.523036626123247, "Min_40.0% Prob": 1.9225587385839649, "Min_50.0% Prob": 1.5459748501224178, "Min_60.0% Prob": 1.2914402393978976}}
{"hexsha": "3f1e64ec78e442dcd00b91b4997b2e200e449310", "ext": "java", "lang": "Java", "content": "public class ForpladHelper {\n\n\tprivate final HibernateDAO dao;\n\n\tpublic ForpladHelper(HibernateDAO dao) {\n\t\tthis.dao = dao;\n\t}\n\n\tpublic Document initializeDocument(PlanMacro plan) {\n\t\tif (plan == null) {\n\t\t\tthrow new IllegalArgumentException(\"You must provide a PlanMacro to initialize a Forplad Document.\");\n\t\t}\n\n\t\tDocument document = this.retrieveByPlan(plan);\n\t\tif (document != null) {\n\t\t\tthrow new IllegalArgumentException(\"The provided PlanMacro already has a Document.\");\n\t\t}\n\n\t\tDocumentCreator creator = new DocumentCreator(plan);\n\t\tthis.dao.execute(creator);\n\n\t\treturn creator.document;\n\t}\n\n\tpublic Document retrieveByPlan(PlanMacro plan) {\n\t\tCriteria criteria = this.dao.newCriteria(Document.class).add(Restrictions.eq(\"plan\", plan));\n\t\treturn (Document) criteria.uniqueResult();\n\t}\n\n\t/**\n\t * Classe privada que insere a estrutura do documento FORPLAD em uma \u00fanica\n\t * transa\u00e7\u00e3o do banco de dados.\n\t * \n\t * @author Renato Oliveira\n\t *\n\t */\n\tprotected class DocumentCreator implements TransactionalOperation {\n\n\t\tpublic final Document document;\n\n\t\tpublic DocumentCreator(PlanMacro plan) {\n\t\t\tthis.document = new Document();\n\t\t\tthis.document.setPlan(plan);\n\t\t\tthis.document.setDescription(\"O PDI, elaborado para um per\u00edodo de cinco anos, \u00e9 o documento\"\n\t\t\t\t\t+ \" que identifica a IES no que diz respeito \u00e0 sua filosofia de trabalho, \u00e0 miss\u00e3o a que se prop\u00f5e, \"\n\t\t\t\t\t+ \"\u00e0s diretrizes pedag\u00f3gicas que orientam suas a\u00e7\u00f5es, \u00e0 sua estrutura organizacional \"\n\t\t\t\t\t+ \"e \u00e0s atividades acad\u00eamicas que desenvolve e/ou que pretende desenvolver \" + \"</br>\" + \"</br>\"\n\t\t\t\t\t+ \"</br>\" + \"Aten\u00e7\u00e3o: Evite colar textos formatados nas se\u00e7\u00f5es do Documento do PDI.\");\n\t\t\tthis.document.setTitle(\"Documento - \" + plan.getName());\n\t\t}\n\n\t\t@Override\n\t\tpublic void execute(Session session) throws HibernateException {\n\t\t\tDocumentSection section, subsection;\n\t\t\tDocumentAttribute attr;\n\t\t\tSchedule schedule;\n\t\t\tTableFields tableFields;\n\t\t\tTableStructure tableStructure;\n\t\t\tOptionsField optionsField;\n\n\t\t\tsession.persist(this.document);\n\n\t\t\t// SE\u00c7\u00d5ES N\u00c3O NUMERADAS - PR\u00c9 TEXTUAIS\n\n\t\t\t// Se\u00e7\u00e3o 1 - Ficha t\u00e9cnica\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Ficha t\u00e9cnica\");\n\t\t\tsection.setSequence(1); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Ficha T\u00e9cnica\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Cargo\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\t// Se\u00e7\u00e3o 2 - Hist\u00f3rico de vers\u00f5es\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Hist\u00f3rico de vers\u00f5es\");\n\t\t\tsection.setSequence(2); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Hist\u00f3rico de vers\u00f5es\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Data\");\n\t\t\ttableStructure.setType(DateField.generateId(DateField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Vers\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Descri\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Autor\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\t// Se\u00e7\u00e3o 3 - Lista de abrevia\u00e7\u00f5es\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Lista de abrevia\u00e7\u00f5es\");\n\t\t\tsection.setSequence(3); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Lista de abrevia\u00e7\u00f5es\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Sigla\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Descri\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\t// SE\u00c7\u00d5ES NUMERADAS\n\n\t\t\t// Se\u00e7\u00e3o 1 - Apresenta\u00e7\u00e3o\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Apresenta\u00e7\u00e3o\");\n\t\t\tsection.setSequence(1); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Apresenta\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 2 - M\u00e9todo\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"M\u00e9todo\");\n\t\t\tsection.setSequence(2); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do m\u00e9todo utilizado para a elabora\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 3 - Documentos de refer\u00eancia\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Documentos de refer\u00eancia\");\n\t\t\tsection.setSequence(3); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Documentos de refer\u00eancia mais utilizados para a elabora\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 4 - Resultados do PDI anterior\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Resultados do PDI anterior\");\n\t\t\tsection.setSequence(4); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Resultados do PDI anterior\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 5 - Perfil institucional\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil institucional\");\n\t\t\tsection.setSequence(5); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 5.1 - Hist\u00f3rico da IES\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Hist\u00f3rico da IES\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"An\u00e1lise do hist\u00f3rico de todos os campus da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 5.2 - Finalidade\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Finalidade\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Finalidade da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 5.3 - Miss\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Miss\u00e3o, vis\u00e3o e valores\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Miss\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Vis\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Valores\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Objetivos estrat\u00e9gicos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(StrategicObjective.generateId(StrategicObjective.class));\n\t\t\tattr.setSequence(4); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 5.4 - \u00c1rea(s) de atua\u00e7\u00e3o acad\u00eamica\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00c1rea(s) de atua\u00e7\u00e3o acad\u00eamica\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"\u00c1reas de atua\u00e7\u00e3o acad\u00eamica\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 6 - Projeto Pedag\u00f3gico Institucional (PPI)\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Projeto Pedag\u00f3gico Institucional (PPI)\");\n\t\t\tsection.setSequence(6); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 6.1 - Inser\u00e7\u00e3o regional\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Inser\u00e7\u00e3o regional\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.2 - Princ\u00edpios filos\u00f3ficos e t\u00e9cnico-metodol\u00f3gicos\n\t\t\t// gerais\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Princ\u00edpios filos\u00f3ficos e t\u00e9cnico-metodol\u00f3gicos gerais\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos princ\u00edpios que norteiam as pr\u00e1ticas acad\u00eamicas da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.3 - Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.4 - Pol\u00edticas de ensino\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de ensino\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de ensino\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.5 - Pol\u00edticas de extens\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de extens\u00e3o\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de extens\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.6 - Pol\u00edticas de pesquisa\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de pesquisa\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de pesquisa adotadas pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.7 - Pol\u00edticas de gest\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de gest\u00e3o\");\n\t\t\tsubsection.setSequence(7); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de gest\u00e3o adotadas pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 6.8 - Responsabilidade Social da IES\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Responsabilidade social da IES\");\n\t\t\tsubsection.setSequence(8); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o da contribui\u00e7\u00e3o \u00e0 inclus\u00e3o social e ao desenvolvimento econ\u00f4mico e social da regi\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 7 - Cronograma de implanta\u00e7\u00e3o e desenvolvimento da\n\t\t\t// institui\u00e7\u00e3o e dos cursos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Cronograma de implanta\u00e7\u00e3o e desenvolvimento da institui\u00e7\u00e3o e dos cursos\");\n\t\t\tsection.setSequence(7); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 7.1 - Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cursos ofertados pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome do Curso\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Habilita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Tecn\u00f3logo\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bacharelado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Licenciatura\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"MBA\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Mestrado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Doutorado\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Modalidade\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Presencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"\u00c0 dist\u00e2ncia\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semipresencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Regime de matr\u00edcula\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Anual\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semestral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bienal\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Fim valores do selectfield\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de turmas\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de Alunos por turma\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Turno de funcionamento\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores do select box\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Integral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Diurno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Noturno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Vespertino\");\n\t\t\tsession.persist(optionsField);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Situa\u00e7\u00e3o Atual\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cursos que ser\u00e3o expandidos ou abertos no futuro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome do Curso\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Habilita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Tecn\u00f3logo\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bacharelado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Licenciatura\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"MBA\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Mestrado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Doutorado\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Modalidade\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Presencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"\u00c0 dist\u00e2ncia\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semipresencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Turno de funcionamento\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores do select box\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Integral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Diurno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Noturno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Vespertino\");\n\t\t\tsession.persist(optionsField);\n\t\t\t/*\n\t\t\t * tableStructure = new TableStructure(); tableStructure.setLabel(\n\t\t\t * \"Turno de funcionamento\");\n\t\t\t * tableStructure.setType(TextField.generateId(TextField.class));\n\t\t\t * tableStructure.setTableFields(tableFields); session.persist(tableStructure);\n\t\t\t */\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de vagas autorizadas\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de vagas a solicitar\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano previsto para solicita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de expans\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(4); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Subse\u00e7\u00e3o 7.2 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de implanta\u00e7\u00e3o e desenvolvimento da institui\u00e7\u00e3o e dos cursos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 8 - Perfil do corpo docente\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil do corpo docente\");\n\t\t\tsection.setSequence(8); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 8.1 - Composi\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por classe/ano\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setInTotal(false);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Auxiliar\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Assistente\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Adjunto\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Associado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Titular\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por titula\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Gradua\u00e7\u00e3o\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Mestrado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Doutorado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"P\u00f3s-doutorado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por regime de trabalho\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Dedica\u00e7\u00e3o exclusiva\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"40h\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"20h\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\n\t\t\t// Subse\u00e7\u00e3o 8.2 - Plano de carreira\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Plano de carreira\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Plano de carreira\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 8.3 - Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 8.4 - Procedimentos para substitui\u00e7\u00e3o (definitiva e\n\t\t\t// eventual) dos professores do quadro\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Procedimentos para substitui\u00e7\u00e3o (definitiva e eventual) dos professores do quadro\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Procedimentos adotados pela IES, visando recomposi\u00e7\u00e3o e substitui\u00e7\u00e3o de professores do quadro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 8.5 - Cronograma\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma e plano de expans\u00e3o do corpo docente\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma e plano de expans\u00e3o do corpo docente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Subse\u00e7\u00e3o 8.6 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o do corpo docente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 9 - Perfil do corpo t\u00e9cnico administrativo\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil do corpo t\u00e9cnico administrativo\");\n\t\t\tsection.setSequence(9); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 9.1 - Composi\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 9.2 - Plano de carreira\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Plano de carreira\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Plano de carreira\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 9.3 - Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Apresentar os crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o de t\u00e9cnicos utilizados pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 9.4 - Procedimentos para substitui\u00e7\u00e3o (definitiva e\n\t\t\t// eventual) dos professores do quadro\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Procedimentos para substitui\u00e7\u00e3o (definitiva e eventual) dos t\u00e9cnicos do quadro\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o dos procedimentos adotados pela IES, visando recomposi\u00e7\u00e3o e substitui\u00e7\u00e3o de t\u00e9cnicos do quadro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 9.5 - Cronograma e plano de expans\u00e3o do corpo t\u00e9cnico\n\t\t\t// administrativo\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma e plano de expans\u00e3o do corpo t\u00e9cnico administrativo\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Subse\u00e7\u00e3o 9.6 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o do corpo t\u00e9cnico administrativo\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 10 - Organiza\u00e7\u00e3o administrativa da IES\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Organiza\u00e7\u00e3o administrativa da IES\");\n\t\t\tsection.setSequence(10); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 10.1 - Estrutura Organizacional, Inst\u00e2ncias de Decis\u00e3o e\n\t\t\t// Organograma Institucional e Acad\u00eamico\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection\n\t\t\t\t\t.setName(\"Estrutura organizacional, inst\u00e2ncias de decis\u00e3o e organograma institucional e acad\u00eamico\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever a estrutura organizacional da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 10.2 - \u00d3rg\u00e3os Colegiados\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00d3rg\u00e3os Colegiados\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever as compet\u00eancias e composi\u00e7\u00e3o de cada \u00f3rg\u00e3o colegiado\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 10.3 - \u00d3rg\u00e3os de apoio \u00e0s atividades acad\u00eamicas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00d3rg\u00e3os de apoio \u00e0s atividades acad\u00eamicas\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever as compet\u00eancias e composi\u00e7\u00e3o de cada \u00f3rg\u00e3o de apoio\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 11 - Pol\u00edticas de atendimento aos discentes\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Pol\u00edticas de atendimento aos discentes\");\n\t\t\tsection.setSequence(11); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 11.1 - Programas de apoio pedag\u00f3gico e financeiro\n\t\t\t// (bolsas)\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Programas de apoio pedag\u00f3gico e financeiro (bolsas)\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o de todos os programas de apoio pedag\u00f3gico e financeiro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 11.2 - Est\u00edmulos \u00e0 perman\u00eancia\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Est\u00edmulos \u00e0 perman\u00eancia\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Est\u00edmulos \u00e0 perman\u00eancia\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 11.3 - Organiza\u00e7\u00e3o estudantil\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Organiza\u00e7\u00e3o estudantil\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o dos espa\u00e7os para participa\u00e7\u00e3o e conviv\u00eancia estudantil, bem como dos \u00f3rg\u00e3os de representatividade discente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 11.4 - Acompanhamento dos egressos\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Acompanhamento dos egressos\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das formas de rela\u00e7\u00e3o com os egressos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 11.5 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de atendimento aos discentes\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 12 - Infraestrutura\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Infraestrutura\");\n\t\t\tsection.setSequence(12); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\n\t\t\t// Subse\u00e7\u00e3o 12.1 - Infraestrutura f\u00edsica\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Infraestrutura f\u00edsica\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Detalhar infraestrutura f\u00edsica\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 12.2 - Biblioteca\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Biblioteca\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Informa\u00e7\u00f5es sobre a biblioteca\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de expans\u00e3o do acervo\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Subse\u00e7\u00e3o 12.3 - Laborat\u00f3rios\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Laborat\u00f3rios\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Informa\u00e7\u00f5es sobre os laborat\u00f3rios\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 12.4 - Recursos tecnol\u00f3gicos e de \u00e1udio visual\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Recursos tecnol\u00f3gicos e de \u00e1udio visual\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever os recursos presentes na IES, e o planejamento de melhorias nessa \u00e1rea\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 12.5 - Plano de promo\u00e7\u00e3o de acessibilidade e de\n\t\t\t// atendimento diferenciado a portadores de necessidades especiais\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\n\t\t\t\t\t\"Plano de promo\u00e7\u00e3o de acessibilidade e de atendimento diferenciado a portadores de necessidades especiais\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"A\u00e7\u00f5es planejadas para promover acessibilidade aos portadores de necessidades especiais\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Subse\u00e7\u00e3o 12.6 - Cronograma de expans\u00e3o da infra-estrutura para o\n\t\t\t// per\u00edodo de vig\u00eancia do PDI\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma de expans\u00e3o da infraestrutura para o per\u00edodo de vig\u00eancia do PDI\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de implementa\u00e7\u00e3o das a\u00e7\u00f5es voltadas para a infraestrutura\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Subse\u00e7\u00e3o 12.7 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(7); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o da infraestrutura\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 13 - Avalia\u00e7\u00e3o e acompanhamento do desenvolvimento\n\t\t\t// institucional\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Avalia\u00e7\u00e3o e acompanhamento do desenvolvimento institucional\");\n\t\t\tsection.setSequence(13); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever os procedimentos utilizados para a realiza\u00e7\u00e3o da autoavalia\u00e7\u00e3o da IES\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 14 - Gest\u00e3o financeira e or\u00e7ament\u00e1ria\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Gest\u00e3o financeira e or\u00e7ament\u00e1ria\");\n\t\t\tsection.setSequence(14); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Apresentar a\u00e7\u00f5es relacionadas \u00e0 melhoria da gest\u00e3o financeira da IES, bem como demonstrar a sustentabilidade financeira\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 15 - Processo de monitoramento, controle e revis\u00e3o do PDI\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Processo de monitoramento, controle e revis\u00e3o do PDI\");\n\t\t\tsection.setSequence(15); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Apresentar o planejamento das atividades de controle que ocorrer\u00e3o durante a vig\u00eancia do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de execu\u00e7\u00e3o\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\n\t\t\t// Se\u00e7\u00e3o 16 - Plano para gest\u00e3o de riscos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Plano para gest\u00e3o de riscos\");\n\t\t\tsection.setSequence(16); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"An\u00e1lise de riscos e o plano em caso de ocorr\u00eancia\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 17 - Conclus\u00e3o\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Conclus\u00e3o\");\n\t\t\tsection.setSequence(17); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Conclus\u00e3o do documento de PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 18 - Anexos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Anexos\");\n\t\t\tsection.setSequence(18); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos anexos\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t\t// Se\u00e7\u00e3o 19 - Ap\u00eandice\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Ap\u00eandice\");\n\t\t\tsection.setSequence(19); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos ap\u00eandices\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\n\t\t}\n\n\t}\n}", "class_id": 0, "repo": "ifgoias/plataforma-for", "file": "backend-java/src/main/java/org/forpdi/planning/document/bootstrap/ForpladHelper.java", "last_update_at": "2018-12-12T17:59:49+00:00", "question_id": "3f1e64ec78e442dcd00b91b4997b2e200e449310", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ForpladHelper {\n\tprivate final HibernateDAO dao;\n\tpublic ForpladHelper(HibernateDAO dao) {\n\t\tthis.dao = dao;\n\t}\n\tpublic Document initializeDocument(PlanMacro plan) {\n\t\tif (plan == null) {\n\t\t\tthrow new IllegalArgumentException(\"You must provide a PlanMacro to initialize a Forplad Document.\");\n\t\t}\n\t\tDocument document = this.retrieveByPlan(plan);\n\t\tif (document != null) {\n\t\t\tthrow new IllegalArgumentException(\"The provided PlanMacro already has a Document.\");\n\t\t}\n\t\tDocumentCreator creator = new DocumentCreator(plan);\n\t\tthis.dao.execute(creator);\n\t\treturn creator.document;\n\t}\n\tpublic Document retrieveByPlan(PlanMacro plan) {\n\t\tCriteria criteria = this.dao.newCriteria(Document.class).add(Restrictions.eq(\"plan\", plan));\n\t\treturn (Document) criteria.uniqueResult();\n\t}\n\t/**\n\t * Classe privada que insere a estrutura do documento FORPLAD em uma \u00fanica\n\t * transa\u00e7\u00e3o do banco de dados.\n\t * \n\t * @author Renato Oliveira\n\t *\n\t */\n\tprotected class DocumentCreator implements TransactionalOperation {\n\t\tpublic final Document document;\n\t\tpublic DocumentCreator(PlanMacro plan) {\n\t\t\tthis.document = new Document();\n\t\t\tthis.document.setPlan(plan);\n\t\t\tthis.document.setDescription(\"O PDI, elaborado para um per\u00edodo de cinco anos, \u00e9 o documento\"\n\t\t\t\t\t+ \" que identifica a IES no que diz respeito \u00e0 sua filosofia de trabalho, \u00e0 miss\u00e3o a que se prop\u00f5e, \"\n\t\t\t\t\t+ \"\u00e0s diretrizes pedag\u00f3gicas que orientam suas a\u00e7\u00f5es, \u00e0 sua estrutura organizacional \"\n\t\t\t\t\t+ \"e \u00e0s atividades acad\u00eamicas que desenvolve e/ou que pretende desenvolver \" + \"</br>\" + \"</br>\"\n\t\t\t\t\t+ \"</br>\" + \"Aten\u00e7\u00e3o: Evite colar textos formatados nas se\u00e7\u00f5es do Documento do PDI.\");\n\t\t\tthis.document.setTitle(\"Documento - \" + plan.getName());\n\t\t}\n\t\t@Override\n\t\tpublic void execute(Session session) throws HibernateException {\n\t\t\tDocumentSection section, subsection;\n\t\t\tDocumentAttribute attr;\n\t\t\tSchedule schedule;\n\t\t\tTableFields tableFields;\n\t\t\tTableStructure tableStructure;\n\t\t\tOptionsField optionsField;\n\t\t\tsession.persist(this.document);\n\t\t\t// SE\u00c7\u00d5ES N\u00c3O NUMERADAS - PR\u00c9 TEXTUAIS\n\t\t\t// Se\u00e7\u00e3o 1 - Ficha t\u00e9cnica\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Ficha t\u00e9cnica\");\n\t\t\tsection.setSequence(1); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Ficha T\u00e9cnica\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Cargo\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Se\u00e7\u00e3o 2 - Hist\u00f3rico de vers\u00f5es\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Hist\u00f3rico de vers\u00f5es\");\n\t\t\tsection.setSequence(2); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Hist\u00f3rico de vers\u00f5es\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Data\");\n\t\t\ttableStructure.setType(DateField.generateId(DateField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Vers\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Descri\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Autor\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Se\u00e7\u00e3o 3 - Lista de abrevia\u00e7\u00f5es\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Lista de abrevia\u00e7\u00f5es\");\n\t\t\tsection.setSequence(3); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsection.setPreTextSection(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Lista de abrevia\u00e7\u00f5es\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Sigla\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Descri\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// SE\u00c7\u00d5ES NUMERADAS\n\t\t\t// Se\u00e7\u00e3o 1 - Apresenta\u00e7\u00e3o\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Apresenta\u00e7\u00e3o\");\n\t\t\tsection.setSequence(1); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Apresenta\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 2 - M\u00e9todo\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"M\u00e9todo\");\n\t\t\tsection.setSequence(2); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do m\u00e9todo utilizado para a elabora\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 3 - Documentos de refer\u00eancia\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Documentos de refer\u00eancia\");\n\t\t\tsection.setSequence(3); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Documentos de refer\u00eancia mais utilizados para a elabora\u00e7\u00e3o do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 4 - Resultados do PDI anterior\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Resultados do PDI anterior\");\n\t\t\tsection.setSequence(4); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Resultados do PDI anterior\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 5 - Perfil institucional\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil institucional\");\n\t\t\tsection.setSequence(5); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 5.1 - Hist\u00f3rico da IES\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Hist\u00f3rico da IES\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"An\u00e1lise do hist\u00f3rico de todos os campus da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 5.2 - Finalidade\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Finalidade\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Finalidade da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 5.3 - Miss\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Miss\u00e3o, vis\u00e3o e valores\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Miss\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Vis\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Valores\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Objetivos estrat\u00e9gicos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(StrategicObjective.generateId(StrategicObjective.class));\n\t\t\tattr.setSequence(4); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 5.4 - \u00c1rea(s) de atua\u00e7\u00e3o acad\u00eamica\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00c1rea(s) de atua\u00e7\u00e3o acad\u00eamica\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"\u00c1reas de atua\u00e7\u00e3o acad\u00eamica\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 6 - Projeto Pedag\u00f3gico Institucional (PPI)\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Projeto Pedag\u00f3gico Institucional (PPI)\");\n\t\t\tsection.setSequence(6); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 6.1 - Inser\u00e7\u00e3o regional\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Inser\u00e7\u00e3o regional\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.2 - Princ\u00edpios filos\u00f3ficos e t\u00e9cnico-metodol\u00f3gicos\n\t\t\t// gerais\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Princ\u00edpios filos\u00f3ficos e t\u00e9cnico-metodol\u00f3gicos gerais\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos princ\u00edpios que norteiam as pr\u00e1ticas acad\u00eamicas da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.3 - Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Organiza\u00e7\u00e3o did\u00e1tico-pedag\u00f3gica da institui\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.4 - Pol\u00edticas de ensino\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de ensino\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de ensino\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.5 - Pol\u00edticas de extens\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de extens\u00e3o\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de extens\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.6 - Pol\u00edticas de pesquisa\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de pesquisa\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de pesquisa adotadas pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.7 - Pol\u00edticas de gest\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Pol\u00edticas de gest\u00e3o\");\n\t\t\tsubsection.setSequence(7); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das pol\u00edticas de gest\u00e3o adotadas pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 6.8 - Responsabilidade Social da IES\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Responsabilidade social da IES\");\n\t\t\tsubsection.setSequence(8); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o da contribui\u00e7\u00e3o \u00e0 inclus\u00e3o social e ao desenvolvimento econ\u00f4mico e social da regi\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 7 - Cronograma de implanta\u00e7\u00e3o e desenvolvimento da\n\t\t\t// institui\u00e7\u00e3o e dos cursos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Cronograma de implanta\u00e7\u00e3o e desenvolvimento da institui\u00e7\u00e3o e dos cursos\");\n\t\t\tsection.setSequence(7); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 7.1 - Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o da situa\u00e7\u00e3o atual\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cursos ofertados pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome do Curso\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Habilita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Tecn\u00f3logo\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bacharelado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Licenciatura\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"MBA\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Mestrado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Doutorado\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Modalidade\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Presencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"\u00c0 dist\u00e2ncia\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semipresencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Regime de matr\u00edcula\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Anual\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semestral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bienal\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Fim valores do selectfield\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de turmas\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de Alunos por turma\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Turno de funcionamento\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores do select box\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Integral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Diurno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Noturno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Vespertino\");\n\t\t\tsession.persist(optionsField);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Situa\u00e7\u00e3o Atual\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cursos que ser\u00e3o expandidos ou abertos no futuro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Nome do Curso\");\n\t\t\ttableStructure.setType(TextField.generateId(TextField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Habilita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Tecn\u00f3logo\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Bacharelado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Licenciatura\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"MBA\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Mestrado\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Doutorado\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Modalidade\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores da habilita\u00e7\u00e3o\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Presencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"\u00c0 dist\u00e2ncia\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Semipresencial\");\n\t\t\tsession.persist(optionsField);\n\t\t\t// Novo campo da tabela\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Turno de funcionamento\");\n\t\t\ttableStructure.setType(SelectField.class.getCanonicalName());\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Valores do select box\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Integral\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Diurno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Noturno\");\n\t\t\tsession.persist(optionsField);\n\t\t\toptionsField = new OptionsField();\n\t\t\toptionsField.setAttributeId(attr.getId());\n\t\t\toptionsField.setColumnId(tableStructure.getId());\n\t\t\toptionsField.setDocument(true);\n\t\t\toptionsField.setLabel(\"Vespertino\");\n\t\t\tsession.persist(optionsField);\n\t\t\t/*\n\t\t\t * tableStructure = new TableStructure(); tableStructure.setLabel(\n\t\t\t * \"Turno de funcionamento\");\n\t\t\t * tableStructure.setType(TextField.generateId(TextField.class));\n\t\t\t * tableStructure.setTableFields(tableFields); session.persist(tableStructure);\n\t\t\t */\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de vagas autorizadas\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"N\u00ba de vagas a solicitar\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano previsto para solicita\u00e7\u00e3o\");\n\t\t\ttableStructure.setType(TextField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de expans\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(4); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Subse\u00e7\u00e3o 7.2 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de implanta\u00e7\u00e3o e desenvolvimento da institui\u00e7\u00e3o e dos cursos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 8 - Perfil do corpo docente\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil do corpo docente\");\n\t\t\tsection.setSequence(8); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 8.1 - Composi\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por classe/ano\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setInTotal(false);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Auxiliar\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Assistente\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Adjunto\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Associado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Titular\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por titula\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Gradua\u00e7\u00e3o\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Especializa\u00e7\u00e3o\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Mestrado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Doutorado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"P\u00f3s-doutorado\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Evolu\u00e7\u00e3o no quadro permanente de docentes por regime de trabalho\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TableField.class.getCanonicalName());\n\t\t\tattr.setSequence(3); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\ttableFields = new TableFields();\n\t\t\ttableFields.setAttributeId(attr.getId());\n\t\t\ttableFields.setIsDocument(true);\n\t\t\tsession.persist(tableFields);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Ano\");\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Dedica\u00e7\u00e3o exclusiva\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"40h\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"20h\");\n\t\t\ttableStructure.setInTotal(true);\n\t\t\ttableStructure.setType(NumberField.generateId(NumberField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\ttableStructure = new TableStructure();\n\t\t\ttableStructure.setLabel(\"Total\");\n\t\t\ttableStructure.setType(TotalField.generateId(TotalField.class));\n\t\t\ttableStructure.setTableFields(tableFields);\n\t\t\tsession.persist(tableStructure);\n\t\t\t// Subse\u00e7\u00e3o 8.2 - Plano de carreira\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Plano de carreira\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Plano de carreira\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 8.3 - Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 8.4 - Procedimentos para substitui\u00e7\u00e3o (definitiva e\n\t\t\t// eventual) dos professores do quadro\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Procedimentos para substitui\u00e7\u00e3o (definitiva e eventual) dos professores do quadro\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Procedimentos adotados pela IES, visando recomposi\u00e7\u00e3o e substitui\u00e7\u00e3o de professores do quadro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 8.5 - Cronograma\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma e plano de expans\u00e3o do corpo docente\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma e plano de expans\u00e3o do corpo docente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Subse\u00e7\u00e3o 8.6 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o do corpo docente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 9 - Perfil do corpo t\u00e9cnico administrativo\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Perfil do corpo t\u00e9cnico administrativo\");\n\t\t\tsection.setSequence(9); // N\u00famero da se\u00e7\u00e3o para ordenar na exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 9.1 - Composi\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Composi\u00e7\u00e3o\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 9.2 - Plano de carreira\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Plano de carreira\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Plano de carreira\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 9.3 - Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Apresentar os crit\u00e9rios de sele\u00e7\u00e3o e contrata\u00e7\u00e3o de t\u00e9cnicos utilizados pela IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 9.4 - Procedimentos para substitui\u00e7\u00e3o (definitiva e\n\t\t\t// eventual) dos professores do quadro\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Procedimentos para substitui\u00e7\u00e3o (definitiva e eventual) dos t\u00e9cnicos do quadro\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o dos procedimentos adotados pela IES, visando recomposi\u00e7\u00e3o e substitui\u00e7\u00e3o de t\u00e9cnicos do quadro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 9.5 - Cronograma e plano de expans\u00e3o do corpo t\u00e9cnico\n\t\t\t// administrativo\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma e plano de expans\u00e3o do corpo t\u00e9cnico administrativo\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Subse\u00e7\u00e3o 9.6 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o do corpo t\u00e9cnico administrativo\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 10 - Organiza\u00e7\u00e3o administrativa da IES\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Organiza\u00e7\u00e3o administrativa da IES\");\n\t\t\tsection.setSequence(10); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 10.1 - Estrutura Organizacional, Inst\u00e2ncias de Decis\u00e3o e\n\t\t\t// Organograma Institucional e Acad\u00eamico\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection\n\t\t\t\t\t.setName(\"Estrutura organizacional, inst\u00e2ncias de decis\u00e3o e organograma institucional e acad\u00eamico\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever a estrutura organizacional da IES\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 10.2 - \u00d3rg\u00e3os Colegiados\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00d3rg\u00e3os Colegiados\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever as compet\u00eancias e composi\u00e7\u00e3o de cada \u00f3rg\u00e3o colegiado\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 10.3 - \u00d3rg\u00e3os de apoio \u00e0s atividades acad\u00eamicas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"\u00d3rg\u00e3os de apoio \u00e0s atividades acad\u00eamicas\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever as compet\u00eancias e composi\u00e7\u00e3o de cada \u00f3rg\u00e3o de apoio\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 11 - Pol\u00edticas de atendimento aos discentes\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Pol\u00edticas de atendimento aos discentes\");\n\t\t\tsection.setSequence(11); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 11.1 - Programas de apoio pedag\u00f3gico e financeiro\n\t\t\t// (bolsas)\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Programas de apoio pedag\u00f3gico e financeiro (bolsas)\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o de todos os programas de apoio pedag\u00f3gico e financeiro\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 11.2 - Est\u00edmulos \u00e0 perman\u00eancia\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Est\u00edmulos \u00e0 perman\u00eancia\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Est\u00edmulos \u00e0 perman\u00eancia\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 11.3 - Organiza\u00e7\u00e3o estudantil\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Organiza\u00e7\u00e3o estudantil\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Descri\u00e7\u00e3o dos espa\u00e7os para participa\u00e7\u00e3o e conviv\u00eancia estudantil, bem como dos \u00f3rg\u00e3os de representatividade discente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 11.4 - Acompanhamento dos egressos\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Acompanhamento dos egressos\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o das formas de rela\u00e7\u00e3o com os egressos\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 11.5 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de atendimento aos discentes\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 12 - Infraestrutura\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Infraestrutura\");\n\t\t\tsection.setSequence(12); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(false);\n\t\t\tsession.persist(section);\n\t\t\t// Subse\u00e7\u00e3o 12.1 - Infraestrutura f\u00edsica\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Infraestrutura f\u00edsica\");\n\t\t\tsubsection.setSequence(1); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Detalhar infraestrutura f\u00edsica\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 12.2 - Biblioteca\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Biblioteca\");\n\t\t\tsubsection.setSequence(2); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Informa\u00e7\u00f5es sobre a biblioteca\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de expans\u00e3o do acervo\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Subse\u00e7\u00e3o 12.3 - Laborat\u00f3rios\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Laborat\u00f3rios\");\n\t\t\tsubsection.setSequence(3); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Informa\u00e7\u00f5es sobre os laborat\u00f3rios\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 12.4 - Recursos tecnol\u00f3gicos e de \u00e1udio visual\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Recursos tecnol\u00f3gicos e de \u00e1udio visual\");\n\t\t\tsubsection.setSequence(4); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever os recursos presentes na IES, e o planejamento de melhorias nessa \u00e1rea\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 12.5 - Plano de promo\u00e7\u00e3o de acessibilidade e de\n\t\t\t// atendimento diferenciado a portadores de necessidades especiais\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\n\t\t\t\t\t\"Plano de promo\u00e7\u00e3o de acessibilidade e de atendimento diferenciado a portadores de necessidades especiais\");\n\t\t\tsubsection.setSequence(5); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"A\u00e7\u00f5es planejadas para promover acessibilidade aos portadores de necessidades especiais\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Subse\u00e7\u00e3o 12.6 - Cronograma de expans\u00e3o da infra-estrutura para o\n\t\t\t// per\u00edodo de vig\u00eancia do PDI\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Cronograma de expans\u00e3o da infraestrutura para o per\u00edodo de vig\u00eancia do PDI\");\n\t\t\tsubsection.setSequence(6); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de implementa\u00e7\u00e3o das a\u00e7\u00f5es voltadas para a infraestrutura\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Subse\u00e7\u00e3o 12.7 - Objetivos e metas\n\t\t\tsubsection = new DocumentSection();\n\t\t\tsubsection.setDocument(document);\n\t\t\tsubsection.setName(\"Objetivos e metas\");\n\t\t\tsubsection.setSequence(7); // N\u00famero da subse\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsubsection.setParent(section);\n\t\t\tsubsection.setLeaf(true);\n\t\t\tsession.persist(subsection);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o do plano de expans\u00e3o da infraestrutura\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Selecione o plano de metas correspondente\");\n\t\t\tattr.setSection(subsection);\n\t\t\tattr.setType(SelectPlan.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 13 - Avalia\u00e7\u00e3o e acompanhamento do desenvolvimento\n\t\t\t// institucional\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Avalia\u00e7\u00e3o e acompanhamento do desenvolvimento institucional\");\n\t\t\tsection.setSequence(13); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descrever os procedimentos utilizados para a realiza\u00e7\u00e3o da autoavalia\u00e7\u00e3o da IES\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 14 - Gest\u00e3o financeira e or\u00e7ament\u00e1ria\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Gest\u00e3o financeira e or\u00e7ament\u00e1ria\");\n\t\t\tsection.setSequence(14); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Apresentar a\u00e7\u00f5es relacionadas \u00e0 melhoria da gest\u00e3o financeira da IES, bem como demonstrar a sustentabilidade financeira\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 15 - Processo de monitoramento, controle e revis\u00e3o do PDI\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Processo de monitoramento, controle e revis\u00e3o do PDI\");\n\t\t\tsection.setSequence(15); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\n\t\t\t\t\t\"Apresentar o planejamento das atividades de controle que ocorrer\u00e3o durante a vig\u00eancia do PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Cronograma de execu\u00e7\u00e3o\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(ScheduleField.class.getCanonicalName());\n\t\t\tattr.setSequence(2); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\tschedule = new Schedule();\n\t\t\tschedule.setPeriodicityEnable(false);\n\t\t\tschedule.setAttributeId(attr.getId());\n\t\t\tschedule.setIsDocument(true);\n\t\t\tsession.persist(schedule);\n\t\t\t// Se\u00e7\u00e3o 16 - Plano para gest\u00e3o de riscos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Plano para gest\u00e3o de riscos\");\n\t\t\tsection.setSequence(16); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"An\u00e1lise de riscos e o plano em caso de ocorr\u00eancia\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 17 - Conclus\u00e3o\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Conclus\u00e3o\");\n\t\t\tsection.setSequence(17); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Conclus\u00e3o do documento de PDI\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 18 - Anexos\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Anexos\");\n\t\t\tsection.setSequence(18); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos anexos\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t\t// Se\u00e7\u00e3o 19 - Ap\u00eandice\n\t\t\tsection = new DocumentSection();\n\t\t\tsection.setDocument(document);\n\t\t\tsection.setName(\"Ap\u00eandice\");\n\t\t\tsection.setSequence(19); // N\u00famero da se\u00e7\u00e3o para ordenar na\n\t\t\t\t\t\t\t\t\t\t// exibi\u00e7\u00e3o.\n\t\t\tsection.setLeaf(true);\n\t\t\tsession.persist(section);\n\t\t\tattr = new DocumentAttribute();\n\t\t\tattr.setName(\"Descri\u00e7\u00e3o dos ap\u00eandices\");\n\t\t\tattr.setSection(section);\n\t\t\tattr.setType(TextArea.generateId(TextArea.class));\n\t\t\tattr.setSequence(1); // Ordem do atributo dentro da se\u00e7\u00e3o\n\t\t\tattr.setRequired(false);\n\t\t\tsession.persist(attr);\n\t\t}\n\t}\n"]], "pred": {"ppl": 2.5917305946350098, "ppl_lower": 2.821082592010498, "ppl/lowercase_ppl": -1.0890397699321042, "ppl/zlib": 0.00018739193936111095, "Min_5.0% Prob": 7.6642758706036735, "Min_10.0% Prob": 6.023873109443515, "Min_20.0% Prob": 4.143623115969639, "Min_30.0% Prob": 3.053034564443663, "Min_40.0% Prob": 2.3557637312738704, "Min_50.0% Prob": 1.9014674651412815, "Min_60.0% Prob": 1.5882238410610772}}
{"hexsha": "90f86440400f8d8fdb2f40bee6e011fb5785e62d", "ext": "java", "lang": "Java", "content": "public class MQTTProtocolSupport {\n\n    /**\n     * Converts an MQTT formatted Topic name into a suitable ActiveMQ Destination\n     * name string.\n     *\n     * @param name\n     *        the MQTT formatted topic name.\n     *\n     * @return an destination name that fits the ActiveMQ conventions.\n     */\n    public static String convertMQTTToActiveMQ(String name) {\n        char[] chars = name.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            switch(chars[i]) {\n                case '#':\n                    chars[i] = '>';\n                    break;\n                case '>':\n                    chars[i] = '#';\n                    break;\n                case '+':\n                    chars[i] = '*';\n                    break;\n                case '*':\n                    chars[i] = '+';\n                    break;\n                case '/':\n                    chars[i] = '.';\n                    break;\n                case '.':\n                    chars[i] = '/';\n                    break;\n            }\n        }\n        String rc = new String(chars);\n        return rc;\n    }\n\n    /**\n     * Converts an ActiveMQ destination name into a correctly formatted\n     * MQTT destination name.\n     *\n     * @param destinationName\n     *        the ActiveMQ destination name to process.\n     *\n     * @return a destination name formatted for MQTT.\n     */\n    public static String convertActiveMQToMQTT(String destinationName) {\n        char[] chars = destinationName.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            switch(chars[i]) {\n                case '>':\n                    chars[i] = '#';\n                    break;\n                case '#':\n                    chars[i] = '>';\n                    break;\n                case '*':\n                    chars[i] = '+';\n                    break;\n                case '+':\n                    chars[i] = '*';\n                    break;\n                case '.':\n                    chars[i] = '/';\n                    break;\n                case '/':\n                    chars[i] = '.';\n                    break;\n            }\n        }\n        String rc = new String(chars);\n        return rc;\n    }\n\n    /**\n     * Given an MQTT header byte, determine the command type that the header\n     * represents.\n     *\n     * @param header\n     *        the byte value for the MQTT frame header.\n     *\n     * @return a string value for the given command type.\n     */\n    public static String commandType(byte header) {\n        byte messageType = (byte) ((header & 0xF0) >>> 4);\n        switch (messageType) {\n            case PINGREQ.TYPE:\n                return \"PINGREQ\";\n            case CONNECT.TYPE:\n                return \"CONNECT\";\n            case DISCONNECT.TYPE:\n                return \"DISCONNECT\";\n            case SUBSCRIBE.TYPE:\n                return \"SUBSCRIBE\";\n            case UNSUBSCRIBE.TYPE:\n                return \"UNSUBSCRIBE\";\n            case PUBLISH.TYPE:\n                return \"PUBLISH\";\n            case PUBACK.TYPE:\n                return \"PUBACK\";\n            case PUBREC.TYPE:\n                return \"PUBREC\";\n            case PUBREL.TYPE:\n                return \"PUBREL\";\n            case PUBCOMP.TYPE:\n                return \"PUBCOMP\";\n            default:\n                return \"UNKNOWN\";\n        }\n    }\n}", "class_id": 0, "repo": "Cinimex-Informatica/activemq", "file": "activemq-mqtt/src/main/java/org/apache/activemq/transport/mqtt/MQTTProtocolSupport.java", "last_update_at": "2018-01-18T10:42:04+00:00", "question_id": "90f86440400f8d8fdb2f40bee6e011fb5785e62d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MQTTProtocolSupport {\n    /**\n     * Converts an MQTT formatted Topic name into a suitable ActiveMQ Destination\n     * name string.\n     *\n     * @param name\n     *        the MQTT formatted topic name.\n     *\n     * @return an destination name that fits the ActiveMQ conventions.\n     */\n    public static String convertMQTTToActiveMQ(String name) {\n        char[] chars = name.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            switch(chars[i]) {\n                case '#':\n                    chars[i] = '>';\n                    break;\n                case '>':\n                    chars[i] = '#';\n                    break;\n                case '+':\n                    chars[i] = '*';\n                    break;\n                case '*':\n                    chars[i] = '+';\n                    break;\n                case '/':\n                    chars[i] = '.';\n                    break;\n                case '.':\n                    chars[i] = '/';\n                    break;\n            }\n        }\n        String rc = new String(chars);\n        return rc;\n    }\n    /**\n     * Converts an ActiveMQ destination name into a correctly formatted\n     * MQTT destination name.\n     *\n     * @param destinationName\n     *        the ActiveMQ destination name to process.\n     *\n     * @return a destination name formatted for MQTT.\n     */\n    public static String convertActiveMQToMQTT(String destinationName) {\n        char[] chars = destinationName.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            switch(chars[i]) {\n                case '>':\n                    chars[i] = '#';\n                    break;\n                case '#':\n                    chars[i] = '>';\n                    break;\n                case '*':\n                    chars[i] = '+';\n                    break;\n                case '+':\n                    chars[i] = '*';\n                    break;\n                case '.':\n                    chars[i] = '/';\n                    break;\n                case '/':\n                    chars[i] = '.';\n                    break;\n            }\n        }\n        String rc = new String(chars);\n        return rc;\n    }\n    /**\n     * Given an MQTT header byte, determine the command type that the header\n     * represents.\n     *\n     * @param header\n     *        the byte value for the MQTT frame header.\n     *\n     * @return a string value for the given command type.\n     */\n    public static String commandType(byte header) {\n        byte messageType = (byte) ((header & 0xF0) >>> 4);\n        switch (messageType) {\n            case PINGREQ.TYPE:\n                return \"PINGREQ\";\n            case CONNECT.TYPE:\n                return \"CONNECT\";\n            case DISCONNECT.TYPE:\n                return \"DISCONNECT\";\n            case SUBSCRIBE.TYPE:\n                return \"SUBSCRIBE\";\n            case UNSUBSCRIBE.TYPE:\n                return \"UNSUBSCRIBE\";\n            case PUBLISH.TYPE:\n                return \"PUBLISH\";\n            case PUBACK.TYPE:\n                return \"PUBACK\";\n            case PUBREC.TYPE:\n                return \"PUBREC\";\n            case PUBREL.TYPE:\n                return \"PUBREL\";\n            case PUBCOMP.TYPE:\n                return \"PUBCOMP\";\n            default:\n                return \"UNKNOWN\";\n        }\n    }\n"]], "pred": {"ppl": 1.4557455778121948, "ppl_lower": 1.5720242261886597, "ppl/lowercase_ppl": -1.2046396477913497, "ppl/zlib": 0.0005116051689264162, "Min_5.0% Prob": 4.850890013304624, "Min_10.0% Prob": 3.2114145883013694, "Min_20.0% Prob": 1.8240755888836344, "Min_30.0% Prob": 1.2455731908610064, "Min_40.0% Prob": 0.9370366760292845, "Min_50.0% Prob": 0.7513364711568026, "Min_60.0% Prob": 0.6256769674247412}}
{"hexsha": "fc55ef0a40a8c2c9934c98ee2821fcfa89fa2998", "ext": "java", "lang": "Java", "content": "public class InputHandler extends AbstractTagHandler {\n\n\t/**\n\t * \n\t */\n\tpublic InputHandler() {\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\n\t//this tag handler just creates the controller/htmlGenerator and returns\n\t//the original HTML, it acts as a mapping between the internal concept and\n\t//the provided input name \n\t@Override\n\tpublic boolean doStartTag(FormEntrySession session, PrintWriter out, Node parent, Node node)\n\t\t\tthrows BadFormDesignException {\n\t\ttry {\n\t\t\n\t\tFormEntryContext context = session.getContext();\n\t\t\n\t\tMap<String, String> attrs = getAttributes(node);\n\t\t\n\t\tInputElement elem = (InputElement)createElement(session, context, attrs, node);\n\t\t\n\t\t//output\n\t\tout.print(elem.generateHtml(context));\n\t\t\n\t\t//should be self closing\n\t\t//context.pushToStack(elem);\n\t\t\n\t}catch(Exception e) {\n\t\tthrow new IllegalStateException(\"Exception in InputHandler.doStartTag(): \" + ExceptionUtils.getStackTrace(e));\n\t}\n\n\t\t\n\t\t//Returns whether or not to handle the body also. (True = Yes)\n\t\t//inputs should have no child elements\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void doEndTag(FormEntrySession session, PrintWriter out, Node parent, Node node)\n\t\t\tthrows BadFormDesignException {\n\t\t\n\t\t//inputs are self closing, do nothing\n\t\t\n\t}\n\n\n\tpublic PassthroughElement createElement(FormEntrySession session, FormEntryContext context, Map<String, String> attrs, Node node) {\n\t\t\n\t\tInputElement elem = null;\n\t\t\t\n\t\tString inputType = attrs.get(\"type\");\n\t\t\n\t\t\n\t\t//HTML specs (inputs default to type text if blank or unknown)\n\t\tif(inputType == null || inputType.isEmpty()) {\n\t\t\tinputType = \"text\";\n\t\t\tattrs.put(\"type\", \"text\");\n\t\t}\n\t\t//throw new IllegalArgumentException(\"input type \" + inputType + \" type.equals(radio)\" + (inputType.equals(\"radio\")?\"true\":\"false\") );\n\t\t\n\t\tFieldsetElement parentFieldset = context.getHighestOnStack(FieldsetElement.class);\n\t\t\n\t\tif(inputType.equals(\"radio\")) {\n\n\t\t\telem = new RadioElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t} else if (inputType.equals(\"date\")) {\n\t\t\t\n\t\t\telem = new DateElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t\tif( elem.handlesSubmission() ) {\n\t\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t}\n\t\t\t\n\t\t}else if(inputType.equals(\"checkbox\")) {\n\t\t\t\n\t\t\telem = new CheckboxElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t\tif( elem.handlesSubmission()) {\n\t\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t}\n\t\t}else if(inputType.equals(\"number\")) {\n\t\t\t\n\t\t\telem = new NumberInputElement(session, attrs, node);\n\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t\n\t\t}\n\t\t//instantiate a new instance of our observation controller adapter\n\t\telse {\n\t\t\telem = new InputElement(session, attrs, node);\n\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t}\n\t\t\n\t\t\n\t\treturn elem;\n\t}\n\n}", "class_id": 0, "repo": "jsibley/mental-health", "file": "api/src/main/java/org/openmrs/module/mentalhealth/handlers/InputHandler.java", "last_update_at": "2018-09-17T20:59:01+00:00", "question_id": "fc55ef0a40a8c2c9934c98ee2821fcfa89fa2998", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class InputHandler extends AbstractTagHandler {\n\t/**\n\t * \n\t */\n\tpublic InputHandler() {\n\t\t// TODO Auto-generated constructor stub\n\t}\n\t//this tag handler just creates the controller/htmlGenerator and returns\n\t//the original HTML, it acts as a mapping between the internal concept and\n\t//the provided input name \n\t@Override\n\tpublic boolean doStartTag(FormEntrySession session, PrintWriter out, Node parent, Node node)\n\t\t\tthrows BadFormDesignException {\n\t\ttry {\n\t\t\n\t\tFormEntryContext context = session.getContext();\n\t\t\n\t\tMap<String, String> attrs = getAttributes(node);\n\t\t\n\t\tInputElement elem = (InputElement)createElement(session, context, attrs, node);\n\t\t\n\t\t//output\n\t\tout.print(elem.generateHtml(context));\n\t\t\n\t\t//should be self closing\n\t\t//context.pushToStack(elem);\n\t\t\n\t}catch(Exception e) {\n\t\tthrow new IllegalStateException(\"Exception in InputHandler.doStartTag(): \" + ExceptionUtils.getStackTrace(e));\n\t}\n\t\t\n\t\t//Returns whether or not to handle the body also. (True = Yes)\n\t\t//inputs should have no child elements\n\t\treturn false;\n\t}\n\t@Override\n\tpublic void doEndTag(FormEntrySession session, PrintWriter out, Node parent, Node node)\n\t\t\tthrows BadFormDesignException {\n\t\t\n\t\t//inputs are self closing, do nothing\n\t\t\n\t}\n\tpublic PassthroughElement createElement(FormEntrySession session, FormEntryContext context, Map<String, String> attrs, Node node) {\n\t\t\n\t\tInputElement elem = null;\n\t\t\t\n\t\tString inputType = attrs.get(\"type\");\n\t\t\n\t\t\n\t\t//HTML specs (inputs default to type text if blank or unknown)\n\t\tif(inputType == null || inputType.isEmpty()) {\n\t\t\tinputType = \"text\";\n\t\t\tattrs.put(\"type\", \"text\");\n\t\t}\n\t\t//throw new IllegalArgumentException(\"input type \" + inputType + \" type.equals(radio)\" + (inputType.equals(\"radio\")?\"true\":\"false\") );\n\t\t\n\t\tFieldsetElement parentFieldset = context.getHighestOnStack(FieldsetElement.class);\n\t\t\n\t\tif(inputType.equals(\"radio\")) {\n\t\t\telem = new RadioElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t} else if (inputType.equals(\"date\")) {\n\t\t\t\n\t\t\telem = new DateElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t\tif( elem.handlesSubmission() ) {\n\t\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t}\n\t\t\t\n\t\t}else if(inputType.equals(\"checkbox\")) {\n\t\t\t\n\t\t\telem = new CheckboxElement(session, attrs, node, parentFieldset);\n\t\t\t\n\t\t\tif( elem.handlesSubmission()) {\n\t\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t}\n\t\t}else if(inputType.equals(\"number\")) {\n\t\t\t\n\t\t\telem = new NumberInputElement(session, attrs, node);\n\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t\t\n\t\t}\n\t\t//instantiate a new instance of our observation controller adapter\n\t\telse {\n\t\t\telem = new InputElement(session, attrs, node);\n\t\t\tsession.getSubmissionController().addAction(elem);\n\t\t}\n\t\t\n\t\t\n\t\treturn elem;\n\t}\n"]], "pred": {"ppl": 2.74698543548584, "ppl_lower": 2.9065616130828857, "ppl/lowercase_ppl": -1.0558797345769575, "ppl/zlib": 0.0009801203735481528, "Min_5.0% Prob": 7.798757636028787, "Min_10.0% Prob": 6.174360161242277, "Min_20.0% Prob": 4.286759012454265, "Min_30.0% Prob": 3.181254496034101, "Min_40.0% Prob": 2.4825277580200016, "Min_50.0% Prob": 2.0079100730931527, "Min_60.0% Prob": 1.6798444694182801}}
{"hexsha": "9cf93c7824064e384f1cedb46f2a6b6395b54566", "ext": "java", "lang": "Java", "content": "public abstract class AbstractPartitionPrimaryReplicaAntiEntropyTask\n        implements PartitionSpecificRunnable, UrgentSystemOperation {\n\n    private static final int OPERATION_TRY_COUNT = 10;\n\n    private static final int OPERATION_TRY_PAUSE_MILLIS = 250;\n\n    protected final NodeEngineImpl nodeEngine;\n\n    protected final InternalPartitionServiceImpl partitionService;\n\n    protected final int partitionId;\n\n    public AbstractPartitionPrimaryReplicaAntiEntropyTask(NodeEngineImpl nodeEngine, int partitionId) {\n        this.nodeEngine = nodeEngine;\n        this.partitionService = (InternalPartitionServiceImpl) nodeEngine.getPartitionService();\n        this.partitionId = partitionId;\n    }\n\n    @Override\n    public int getPartitionId() {\n        return partitionId;\n    }\n\n    // works only on primary. backups are retained in PartitionBackupReplicaAntiEntropyTask\n    final Collection<ServiceNamespace> retainAndGetNamespaces() {\n        PartitionReplicationEvent event = new PartitionReplicationEvent(partitionId, 0);\n        Collection<FragmentedMigrationAwareService> services = nodeEngine.getServices(FragmentedMigrationAwareService.class);\n\n        Set<ServiceNamespace> namespaces = new HashSet<>();\n        for (FragmentedMigrationAwareService service : services) {\n            Collection<ServiceNamespace> serviceNamespaces = service.getAllServiceNamespaces(event);\n            if (serviceNamespaces != null) {\n                namespaces.addAll(serviceNamespaces);\n            }\n        }\n        namespaces.add(NonFragmentedServiceNamespace.INSTANCE);\n\n        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();\n        replicaManager.retainNamespaces(partitionId, namespaces);\n        return replicaManager.getNamespaces(partitionId);\n    }\n\n    final void invokePartitionBackupReplicaAntiEntropyOp(int replicaIndex, PartitionReplica target,\n                                                         Collection<ServiceNamespace> namespaces,\n                                                         BiConsumer<Object, Throwable> callback) {\n        if (skipSendingToTarget(target)) {\n            return;\n        }\n\n        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();\n        Map<ServiceNamespace, Long> versionMap = new HashMap<>();\n        for (ServiceNamespace ns : namespaces) {\n            long[] versions = replicaManager.getPartitionReplicaVersions(partitionId, ns);\n            long currentReplicaVersion = versions[replicaIndex - 1];\n\n            if (currentReplicaVersion > 0) {\n                versionMap.put(ns, currentReplicaVersion);\n            }\n        }\n\n        boolean hasCallback = (callback != null);\n\n        PartitionBackupReplicaAntiEntropyOperation op = new PartitionBackupReplicaAntiEntropyOperation(versionMap, hasCallback);\n        op.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(SERVICE_NAME);\n        OperationService operationService = nodeEngine.getOperationService();\n\n        if (hasCallback) {\n            operationService.createInvocationBuilder(SERVICE_NAME, op, target.address())\n                            .setTryCount(OPERATION_TRY_COUNT)\n                            .setTryPauseMillis(OPERATION_TRY_PAUSE_MILLIS)\n                            .invoke()\n                            .whenCompleteAsync(callback);\n        } else {\n            operationService.send(op, target.address());\n        }\n    }\n\n    private boolean skipSendingToTarget(PartitionReplica target) {\n        ClusterServiceImpl clusterService = nodeEngine.getNode().getClusterService();\n\n        assert !target.isIdentical(nodeEngine.getLocalMember()) : \"Could not send anti-entropy operation, because \"\n                + target + \" is local member itself! Local-member: \" + clusterService.getLocalMember()\n                + \", \" + partitionService.getPartition(partitionId);\n\n        if (clusterService.getMember(target.address(), target.uuid()) == null) {\n            ILogger logger = nodeEngine.getLogger(getClass());\n            if (logger.isFinestEnabled()) {\n                if (clusterService.isMissingMember(target.address(), target.uuid())) {\n                    logger.finest(\"Could not send anti-entropy operation, because \" + target + \" is a missing member. \"\n                            + partitionService.getPartition(partitionId));\n                } else {\n                    logger.finest(\"Could not send anti-entropy operation, because \" + target + \" is not a known member. \"\n                            + partitionService.getPartition(partitionId));\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n}", "class_id": 0, "repo": "PokimonZerg/hazelcast", "file": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/AbstractPartitionPrimaryReplicaAntiEntropyTask.java", "last_update_at": "2018-10-12T00:13:21+00:00", "question_id": "9cf93c7824064e384f1cedb46f2a6b6395b54566", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractPartitionPrimaryReplicaAntiEntropyTask\n        implements PartitionSpecificRunnable, UrgentSystemOperation {\n    private static final int OPERATION_TRY_COUNT = 10;\n    private static final int OPERATION_TRY_PAUSE_MILLIS = 250;\n    protected final NodeEngineImpl nodeEngine;\n    protected final InternalPartitionServiceImpl partitionService;\n    protected final int partitionId;\n    public AbstractPartitionPrimaryReplicaAntiEntropyTask(NodeEngineImpl nodeEngine, int partitionId) {\n        this.nodeEngine = nodeEngine;\n        this.partitionService = (InternalPartitionServiceImpl) nodeEngine.getPartitionService();\n        this.partitionId = partitionId;\n    }\n    @Override\n    public int getPartitionId() {\n        return partitionId;\n    }\n    // works only on primary. backups are retained in PartitionBackupReplicaAntiEntropyTask\n    final Collection<ServiceNamespace> retainAndGetNamespaces() {\n        PartitionReplicationEvent event = new PartitionReplicationEvent(partitionId, 0);\n        Collection<FragmentedMigrationAwareService> services = nodeEngine.getServices(FragmentedMigrationAwareService.class);\n        Set<ServiceNamespace> namespaces = new HashSet<>();\n        for (FragmentedMigrationAwareService service : services) {\n            Collection<ServiceNamespace> serviceNamespaces = service.getAllServiceNamespaces(event);\n            if (serviceNamespaces != null) {\n                namespaces.addAll(serviceNamespaces);\n            }\n        }\n        namespaces.add(NonFragmentedServiceNamespace.INSTANCE);\n        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();\n        replicaManager.retainNamespaces(partitionId, namespaces);\n        return replicaManager.getNamespaces(partitionId);\n    }\n    final void invokePartitionBackupReplicaAntiEntropyOp(int replicaIndex, PartitionReplica target,\n                                                         Collection<ServiceNamespace> namespaces,\n                                                         BiConsumer<Object, Throwable> callback) {\n        if (skipSendingToTarget(target)) {\n            return;\n        }\n        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();\n        Map<ServiceNamespace, Long> versionMap = new HashMap<>();\n        for (ServiceNamespace ns : namespaces) {\n            long[] versions = replicaManager.getPartitionReplicaVersions(partitionId, ns);\n            long currentReplicaVersion = versions[replicaIndex - 1];\n            if (currentReplicaVersion > 0) {\n                versionMap.put(ns, currentReplicaVersion);\n            }\n        }\n        boolean hasCallback = (callback != null);\n        PartitionBackupReplicaAntiEntropyOperation op = new PartitionBackupReplicaAntiEntropyOperation(versionMap, hasCallback);\n        op.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(SERVICE_NAME);\n        OperationService operationService = nodeEngine.getOperationService();\n        if (hasCallback) {\n            operationService.createInvocationBuilder(SERVICE_NAME, op, target.address())\n                            .setTryCount(OPERATION_TRY_COUNT)\n                            .setTryPauseMillis(OPERATION_TRY_PAUSE_MILLIS)\n                            .invoke()\n                            .whenCompleteAsync(callback);\n        } else {\n            operationService.send(op, target.address());\n        }\n    }\n    private boolean skipSendingToTarget(PartitionReplica target) {\n        ClusterServiceImpl clusterService = nodeEngine.getNode().getClusterService();\n        assert !target.isIdentical(nodeEngine.getLocalMember()) : \"Could not send anti-entropy operation, because \"\n                + target + \" is local member itself! Local-member: \" + clusterService.getLocalMember()\n                + \", \" + partitionService.getPartition(partitionId);\n        if (clusterService.getMember(target.address(), target.uuid()) == null) {\n            ILogger logger = nodeEngine.getLogger(getClass());\n            if (logger.isFinestEnabled()) {\n                if (clusterService.isMissingMember(target.address(), target.uuid())) {\n                    logger.finest(\"Could not send anti-entropy operation, because \" + target + \" is a missing member. \"\n                            + partitionService.getPartition(partitionId));\n                } else {\n                    logger.finest(\"Could not send anti-entropy operation, because \" + target + \" is not a known member. \"\n                            + partitionService.getPartition(partitionId));\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n"]], "pred": {"ppl": 1.8121401071548462, "ppl_lower": 2.477910280227661, "ppl/lowercase_ppl": -1.5263289517928325, "ppl/zlib": 0.0004651866404233133, "Min_5.0% Prob": 6.17459342993942, "Min_10.0% Prob": 4.462604162739773, "Min_20.0% Prob": 2.789669670895034, "Min_30.0% Prob": 1.955695291262826, "Min_40.0% Prob": 1.4820923950650655, "Min_50.0% Prob": 1.1893793297011164, "Min_60.0% Prob": 0.9920028642738742}}
{"hexsha": "c47eb33ce59d25967457b493da7dafa5ac1d96c7", "ext": "java", "lang": "Java", "content": "public class DiscordInvite implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String code;\n    private Guild guild;\n    private Channel channel;\n\n    public static long getSerialVersionUID() {\n        return serialVersionUID;\n    }\n\n    public String getCode() {\n        return code;\n    }\n\n    public void setCode(String code) {\n        this.code = code;\n    }\n\n    public Guild getGuild() {\n        return guild;\n    }\n\n    public void setGuild(Guild guild) {\n        this.guild = guild;\n    }\n\n    public Channel getChannel() {\n        return channel;\n    }\n\n    public void setChannel(Channel channel) {\n        this.channel = channel;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DiscordInvite that = (DiscordInvite) o;\n        return Objects.equals(code, that.code);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(code);\n    }\n\n    public static class Guild implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private String id;\n        private String name;\n        private String splash;\n        private String icon;\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getSplash() {\n            return splash;\n        }\n\n        public void setSplash(String splash) {\n            this.splash = splash;\n        }\n\n        public String getIcon() {\n            return icon;\n        }\n\n        public void setIcon(String icon) {\n            this.icon = icon;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Guild guild = (Guild) o;\n            return Objects.equals(id, guild.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(id);\n        }\n    }\n\n    public static class Channel implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private String id;\n        private String name;\n        private String type;\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Channel channel = (Channel) o;\n            return Objects.equals(id, channel.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(id);\n        }\n    }\n\n\n}", "class_id": 0, "repo": "quanticc/sentry", "file": "src/main/java/org/springframework/social/discord/api/DiscordInvite.java", "last_update_at": "2018-01-06T16:11:14+00:00", "question_id": "c47eb33ce59d25967457b493da7dafa5ac1d96c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DiscordInvite implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String code;\n    private Guild guild;\n    private Channel channel;\n    public static long getSerialVersionUID() {\n        return serialVersionUID;\n    }\n    public String getCode() {\n        return code;\n    }\n    public void setCode(String code) {\n        this.code = code;\n    }\n    public Guild getGuild() {\n        return guild;\n    }\n    public void setGuild(Guild guild) {\n        this.guild = guild;\n    }\n    public Channel getChannel() {\n        return channel;\n    }\n    public void setChannel(Channel channel) {\n        this.channel = channel;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        DiscordInvite that = (DiscordInvite) o;\n        return Objects.equals(code, that.code);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(code);\n    }\n    public static class Guild implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String id;\n        private String name;\n        private String splash;\n        private String icon;\n        public String getId() {\n            return id;\n        }\n        public void setId(String id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getSplash() {\n            return splash;\n        }\n        public void setSplash(String splash) {\n            this.splash = splash;\n        }\n        public String getIcon() {\n            return icon;\n        }\n        public void setIcon(String icon) {\n            this.icon = icon;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Guild guild = (Guild) o;\n            return Objects.equals(id, guild.id);\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(id);\n        }\n    }\n    public static class Channel implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String id;\n        private String name;\n        private String type;\n        public String getId() {\n            return id;\n        }\n        public void setId(String id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getType() {\n            return type;\n        }\n        public void setType(String type) {\n            this.type = type;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Channel channel = (Channel) o;\n            return Objects.equals(id, channel.id);\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(id);\n        }\n    }\n"]], "pred": {"ppl": 1.0981096029281616, "ppl_lower": 1.1798564195632935, "ppl/lowercase_ppl": -1.7672023978943352, "ppl/zlib": 0.0001514403861214465, "Min_5.0% Prob": 1.7424623722379857, "Min_10.0% Prob": 0.9307105045221494, "Min_20.0% Prob": 0.46878308333279617, "Min_30.0% Prob": 0.3124892432523933, "Min_40.0% Prob": 0.2342734358975992, "Min_50.0% Prob": 0.18735703656069166, "Min_60.0% Prob": 0.15608834379313158}}
{"hexsha": "714595ca868a7b730a2e6ab96aa0c598d000a050", "ext": "java", "lang": "Java", "content": "public class P06TriplesOfLetters {\n    public static void main(String[] args) {\n        Scanner console = new Scanner(System.in);\n\n        int n = Integer.parseInt(console.nextLine());\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n\n                    char firstLetter = (char) ('a' + i);\n                    char secondLetter = (char) ('a' + j);\n                    char thirdLetter = (char) ('a' + k);\n\n\t\t\t\t\t//printing with format\n                    System.out.printf(\"%c%c%c %n\", firstLetter, secondLetter, thirdLetter);\n                }\n            }\n        }\n    }\n}", "class_id": 0, "repo": "SoftUni-Tech-Module/Tech-Module-May-2018", "file": "Programmun-Fundamentals-Java/03-data-types-and-variables/lab/src/P06TriplesOfLetters.java", "last_update_at": "2018-08-18T13:08:20+00:00", "question_id": "714595ca868a7b730a2e6ab96aa0c598d000a050", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class P06TriplesOfLetters {\n    public static void main(String[] args) {\n        Scanner console = new Scanner(System.in);\n        int n = Integer.parseInt(console.nextLine());\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    char firstLetter = (char) ('a' + i);\n                    char secondLetter = (char) ('a' + j);\n                    char thirdLetter = (char) ('a' + k);\n\t\t\t\t\t//printing with format\n                    System.out.printf(\"%c%c%c %n\", firstLetter, secondLetter, thirdLetter);\n                }\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.5389642715454102, "ppl_lower": 2.078184127807617, "ppl/lowercase_ppl": -1.696771378771479, "ppl/zlib": 0.001496908469504019, "Min_5.0% Prob": 5.828966760635376, "Min_10.0% Prob": 3.916835618019104, "Min_20.0% Prob": 2.130603998536017, "Min_30.0% Prob": 1.4401085707809655, "Min_40.0% Prob": 1.081837380641555, "Min_50.0% Prob": 0.8649455884587951, "Min_60.0% Prob": 0.7202153259236366}}
{"hexsha": "21d0ffc93e5e187d33f004f35bb431c1341ffa81", "ext": "java", "lang": "Java", "content": "@ToString\npublic class FluentValidatorImpl<R> implements Fv.Validator<R> {\n    private static final PropertyUtilsBean PROPERTY_UTILS_BEAN = BeanUtilsBean.getInstance().getPropertyUtils();\n\n    private List<FluentValidatorBuilder.ValidationDataWithProperties> validationData = new ArrayList<>();\n\n    public FluentValidatorImpl(List<FluentValidatorBuilder.ValidationDataWithProperties> validationData) {\n        this.validationData = validationData;\n    }\n\n    public List<FluentValidatorBuilder.ValidationDataWithProperties> getValidationData() {\n        return validationData;\n    }\n\n    public Fv.Result<R> validate(R rootObject) {\n        Errors errors = Errors.ok();\n\n        for (FluentValidatorBuilder.ValidationDataWithProperties validationDataWithProperties : validationData) {\n            String property = validationDataWithProperties.getProperty();\n            Object value = getPropertyValue(rootObject, property);\n\n            Fv.Result result = validationDataWithProperties.getData().validate(rootObject, property, value);\n\n            if (result != null) {\n                errors.add(result.getErrors());\n            }\n        }\n\n        return Fv.Result.failure(rootObject, errors);\n    }\n\n    private Object getPropertyValue(R o, String property) {\n        try {\n            if (o == null) {\n                return null;\n            } else if (property == null) {\n                return o;\n            } else {\n                return PROPERTY_UTILS_BEAN.getNestedProperty(o, property);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "class_id": 0, "repo": "thedocs-io/soyuz-validator", "file": "src/main/java/io/thedocs/soyuz/validator/FluentValidatorImpl.java", "last_update_at": "2018-11-27T12:30:18+00:00", "question_id": "21d0ffc93e5e187d33f004f35bb431c1341ffa81", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ToString\npublic class FluentValidatorImpl<R> implements Fv.Validator<R> {\n    private static final PropertyUtilsBean PROPERTY_UTILS_BEAN = BeanUtilsBean.getInstance().getPropertyUtils();\n    private List<FluentValidatorBuilder.ValidationDataWithProperties> validationData = new ArrayList<>();\n    public FluentValidatorImpl(List<FluentValidatorBuilder.ValidationDataWithProperties> validationData) {\n        this.validationData = validationData;\n    }\n    public List<FluentValidatorBuilder.ValidationDataWithProperties> getValidationData() {\n        return validationData;\n    }\n    public Fv.Result<R> validate(R rootObject) {\n        Errors errors = Errors.ok();\n        for (FluentValidatorBuilder.ValidationDataWithProperties validationDataWithProperties : validationData) {\n            String property = validationDataWithProperties.getProperty();\n            Object value = getPropertyValue(rootObject, property);\n            Fv.Result result = validationDataWithProperties.getData().validate(rootObject, property, value);\n            if (result != null) {\n                errors.add(result.getErrors());\n            }\n        }\n        return Fv.Result.failure(rootObject, errors);\n    }\n    private Object getPropertyValue(R o, String property) {\n        try {\n            if (o == null) {\n                return null;\n            } else if (property == null) {\n                return o;\n            } else {\n                return PROPERTY_UTILS_BEAN.getNestedProperty(o, property);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n"]], "pred": {"ppl": 1.968521237373352, "ppl_lower": 2.3113930225372314, "ppl/lowercase_ppl": -1.2370764554662714, "ppl/zlib": 0.0013464863219695797, "Min_5.0% Prob": 6.635299170017243, "Min_10.0% Prob": 4.751250976324082, "Min_20.0% Prob": 3.058325445652008, "Min_30.0% Prob": 2.1824897014158817, "Min_40.0% Prob": 1.6806501881306215, "Min_50.0% Prob": 1.3504624639610106, "Min_60.0% Prob": 1.1297314367160847}}
{"hexsha": "1e86ab96d8b82bca2edc6dce1160b2febbc854be", "ext": "java", "lang": "Java", "content": "public class MyCommitsHighlighter implements VcsLogHighlighter {\n  @NotNull private final VcsLogData myLogData;\n  @NotNull private final VcsLogUi myLogUi;\n  private boolean myShouldHighlightUser = false;\n\n  public MyCommitsHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {\n    myLogData = logData;\n    myLogUi = logUi;\n  }\n\n  @NotNull\n  @Override\n  public VcsCommitStyle getStyle(@NotNull VcsShortCommitDetails details, boolean isSelected) {\n    if (!myLogUi.isHighlighterEnabled(Factory.ID)) return VcsCommitStyle.DEFAULT;\n    if (myShouldHighlightUser) {\n      VcsUser currentUser = myLogData.getCurrentUser().get(details.getRoot());\n      if (currentUser != null && VcsUserUtil.isSamePerson(currentUser, details.getAuthor())) {\n        return VcsCommitStyleFactory.bold();\n      }\n    }\n    return VcsCommitStyle.DEFAULT;\n  }\n\n  @Override\n  public void update(@NotNull VcsLogDataPack dataPack, boolean refreshHappened) {\n    myShouldHighlightUser = !isSingleUser() && !isFilteredByCurrentUser(dataPack.getFilters());\n  }\n\n  // returns true if only one user commits to this repository\n  private boolean isSingleUser() {\n    NotNullFunction<VcsUser, String> nameToString = user -> VcsUserUtil.getNameInStandardForm(VcsUserUtil.getShortPresentation(user));\n    Set<String> allUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getAllUsers(), nameToString));\n    Set<String> currentUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getCurrentUser().values(), nameToString));\n    return allUserNames.size() == currentUserNames.size() && currentUserNames.containsAll(allUserNames);\n  }\n\n  // returns true if filtered by \"me\"\n  private static boolean isFilteredByCurrentUser(@NotNull VcsLogFilterCollection filters) {\n    VcsLogUserFilter userFilter = filters.get(VcsLogFilterCollection.USER_FILTER);\n    if (userFilter == null) return false;\n    Collection<String> filterByName = ((VcsLogUserFilterImpl)userFilter).getUserNamesForPresentation();\n    if (Collections.singleton(VcsLogUserFilterImpl.ME).containsAll(filterByName)) return true;\n    return false;\n  }\n\n  public static class Factory implements VcsLogHighlighterFactory {\n    @NotNull public static final String ID = \"MY_COMMITS\";\n\n    @NotNull\n    @Override\n    public VcsLogHighlighter createHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {\n      return new MyCommitsHighlighter(logData, logUi);\n    }\n\n    @NotNull\n    @Override\n    public String getId() {\n      return ID;\n    }\n\n    @NotNull\n    @Override\n    public String getTitle() {\n      return \"My Commits\";\n    }\n\n    @Override\n    public boolean showMenuItem() {\n      return true;\n    }\n  }\n}", "class_id": 0, "repo": "fduminy/intellij-community", "file": "platform/vcs-log/impl/src/com/intellij/vcs/log/ui/highlighters/MyCommitsHighlighter.java", "last_update_at": "2018-12-29T09:53:42+00:00", "question_id": "1e86ab96d8b82bca2edc6dce1160b2febbc854be", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyCommitsHighlighter implements VcsLogHighlighter {\n  @NotNull private final VcsLogData myLogData;\n  @NotNull private final VcsLogUi myLogUi;\n  private boolean myShouldHighlightUser = false;\n  public MyCommitsHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {\n    myLogData = logData;\n    myLogUi = logUi;\n  }\n  @NotNull\n  @Override\n  public VcsCommitStyle getStyle(@NotNull VcsShortCommitDetails details, boolean isSelected) {\n    if (!myLogUi.isHighlighterEnabled(Factory.ID)) return VcsCommitStyle.DEFAULT;\n    if (myShouldHighlightUser) {\n      VcsUser currentUser = myLogData.getCurrentUser().get(details.getRoot());\n      if (currentUser != null && VcsUserUtil.isSamePerson(currentUser, details.getAuthor())) {\n        return VcsCommitStyleFactory.bold();\n      }\n    }\n    return VcsCommitStyle.DEFAULT;\n  }\n  @Override\n  public void update(@NotNull VcsLogDataPack dataPack, boolean refreshHappened) {\n    myShouldHighlightUser = !isSingleUser() && !isFilteredByCurrentUser(dataPack.getFilters());\n  }\n  // returns true if only one user commits to this repository\n  private boolean isSingleUser() {\n    NotNullFunction<VcsUser, String> nameToString = user -> VcsUserUtil.getNameInStandardForm(VcsUserUtil.getShortPresentation(user));\n    Set<String> allUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getAllUsers(), nameToString));\n    Set<String> currentUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getCurrentUser().values(), nameToString));\n    return allUserNames.size() == currentUserNames.size() && currentUserNames.containsAll(allUserNames);\n  }\n  // returns true if filtered by \"me\"\n  private static boolean isFilteredByCurrentUser(@NotNull VcsLogFilterCollection filters) {\n    VcsLogUserFilter userFilter = filters.get(VcsLogFilterCollection.USER_FILTER);\n    if (userFilter == null) return false;\n    Collection<String> filterByName = ((VcsLogUserFilterImpl)userFilter).getUserNamesForPresentation();\n    if (Collections.singleton(VcsLogUserFilterImpl.ME).containsAll(filterByName)) return true;\n    return false;\n  }\n  public static class Factory implements VcsLogHighlighterFactory {\n    @NotNull public static final String ID = \"MY_COMMITS\";\n    @NotNull\n    @Override\n    public VcsLogHighlighter createHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {\n      return new MyCommitsHighlighter(logData, logUi);\n    }\n    @NotNull\n    @Override\n    public String getId() {\n      return ID;\n    }\n    @NotNull\n    @Override\n    public String getTitle() {\n      return \"My Commits\";\n    }\n    @Override\n    public boolean showMenuItem() {\n      return true;\n    }\n  }\n"]], "pred": {"ppl": 1.6115223169326782, "ppl_lower": 2.218648672103882, "ppl/lowercase_ppl": -1.670018697750171, "ppl/zlib": 0.0005367595846163793, "Min_5.0% Prob": 5.424087059497833, "Min_10.0% Prob": 3.7534065894138666, "Min_20.0% Prob": 2.2593727831119375, "Min_30.0% Prob": 1.5681916622780874, "Min_40.0% Prob": 1.1906376261550646, "Min_50.0% Prob": 0.9534823889706824, "Min_60.0% Prob": 0.7957566227872672}}
{"hexsha": "624dc1f9b26fca3abea9621e672238fdf906c27a", "ext": "java", "lang": "Java", "content": "public final class FNProfTest extends AdvancedQueryTest {\r\n  /** Test method. */\r\n  @Test\r\n  public void mem() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_MEM.args(\"()\"));\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", false)), \"100\");\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", true)), \"100\");\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", true, \"label\")), \"100\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void time() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_TIME.args(\"()\"));\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", false)), \"100\");\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", true)), \"100\");\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", true, \"label\")), \"100\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void sleep() {\r\n    query(_PROF_SLEEP.args(\" 10\"));\r\n    query(_PROF_SLEEP.args(\" 1\"));\r\n    query(_PROF_SLEEP.args(\" 0\"));\r\n    query(_PROF_SLEEP.args(\" -1\"));\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void dump() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_DUMP.args(\"a\"), \"\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void currentMs() {\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void currentNs() {\r\n  }\r\n}", "class_id": 0, "repo": "rostam/basex", "file": "src/test/java/org/basex/test/query/func/FNProfTest.java", "last_update_at": "2018-12-24T14:16:13+00:00", "question_id": "624dc1f9b26fca3abea9621e672238fdf906c27a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class FNProfTest extends AdvancedQueryTest {\r\n  /** Test method. */\r\n  @Test\r\n  public void mem() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_MEM.args(\"()\"));\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", false)), \"100\");\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", true)), \"100\");\r\n      query(COUNT.args(_PROF_MEM.args(\" 1 to 100 \", true, \"label\")), \"100\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void time() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_TIME.args(\"()\"));\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", false)), \"100\");\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", true)), \"100\");\r\n      query(COUNT.args(_PROF_TIME.args(\" 1 to 100 \", true, \"label\")), \"100\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void sleep() {\r\n    query(_PROF_SLEEP.args(\" 10\"));\r\n    query(_PROF_SLEEP.args(\" 1\"));\r\n    query(_PROF_SLEEP.args(\" 0\"));\r\n    query(_PROF_SLEEP.args(\" -1\"));\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void dump() {\r\n    try {\r\n      System.setErr(NULL);\r\n      query(_PROF_DUMP.args(\"a\"), \"\");\r\n    } finally {\r\n      System.setErr(ERR);\r\n    }\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void currentMs() {\r\n  }\r\n\r\n  /** Test method. */\r\n  @Test\r\n  public void currentNs() {\r\n  }\r\n"]], "pred": {"ppl": 1.5466480255126953, "ppl_lower": 1.8171957731246948, "ppl/lowercase_ppl": -1.3696587736114743, "ppl/zlib": 0.0014022187299909405, "Min_5.0% Prob": 5.991454044977824, "Min_10.0% Prob": 3.819542659412731, "Min_20.0% Prob": 2.128217130228206, "Min_30.0% Prob": 1.4501404606972832, "Min_40.0% Prob": 1.0896126802440163, "Min_50.0% Prob": 0.871467317208286, "Min_60.0% Prob": 0.727945192984806}}
{"hexsha": "68a5442369dbbf4fb8e17e7df9cf0dedb72bd36c", "ext": "java", "lang": "Java", "content": "@RunWith(AndroidJUnit4.class)\npublic class TabInfoTest extends TestCase {\n\n    @Test\n\tpublic void testParcelable() {\n\t\tTabInfo tabInfo = new TabInfo();\n\t\ttabInfo.setTitle(\"test\");\n\t\ttabInfo.setActivityClazz(0, ListableFragment.class);\n\t\tListSettings settings = new ListSettings();\n\t\tsettings.setShowFavorite(true);\n\t\tsettings.addListItem(new ListItem(ListItemType.Attribute));\n\n\t\ttabInfo.getListSettings()[0] = settings;\n\t\tParcel parcel = Parcel.obtain();\n\n\t\ttabInfo.writeToParcel(parcel, 0);\n\n\t\tparcel.setDataPosition(0);\n\n\t\tTabInfo newTabInfo = new TabInfo(parcel);\n\t\tListSettings newSettings = newTabInfo.getListSettings()[0];\n\n\t\tassertEquals(\"test\", tabInfo.getTitle());\n\t\tassertEquals(settings.isShowFavorite(), newSettings.isShowFavorite());\n\t\tassertEquals(settings.getListItems().size(), newSettings.getListItems().size());\n\t}\n\n}", "class_id": 0, "repo": "KollegeX/DsaTabForMe", "file": "DsaTab/src/androidTest/java/com/dsatab/test/TabInfoTest.java", "last_update_at": "2018-07-05T22:48:57+00:00", "question_id": "68a5442369dbbf4fb8e17e7df9cf0dedb72bd36c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(AndroidJUnit4.class)\npublic class TabInfoTest extends TestCase {\n    @Test\n\tpublic void testParcelable() {\n\t\tTabInfo tabInfo = new TabInfo();\n\t\ttabInfo.setTitle(\"test\");\n\t\ttabInfo.setActivityClazz(0, ListableFragment.class);\n\t\tListSettings settings = new ListSettings();\n\t\tsettings.setShowFavorite(true);\n\t\tsettings.addListItem(new ListItem(ListItemType.Attribute));\n\t\ttabInfo.getListSettings()[0] = settings;\n\t\tParcel parcel = Parcel.obtain();\n\t\ttabInfo.writeToParcel(parcel, 0);\n\t\tparcel.setDataPosition(0);\n\t\tTabInfo newTabInfo = new TabInfo(parcel);\n\t\tListSettings newSettings = newTabInfo.getListSettings()[0];\n\t\tassertEquals(\"test\", tabInfo.getTitle());\n\t\tassertEquals(settings.isShowFavorite(), newSettings.isShowFavorite());\n\t\tassertEquals(settings.getListItems().size(), newSettings.getListItems().size());\n\t}\n"]], "pred": {"ppl": 2.2182016372680664, "ppl_lower": 2.8074212074279785, "ppl/lowercase_ppl": -1.2956828113262284, "ppl/zlib": 0.0021887274568539415, "Min_5.0% Prob": 7.934558255331857, "Min_10.0% Prob": 5.934569895267487, "Min_20.0% Prob": 3.694990831826414, "Min_30.0% Prob": 2.5904213311041104, "Min_40.0% Prob": 1.9833302878964263, "Min_50.0% Prob": 1.589694086750838, "Min_60.0% Prob": 1.3300348540987161}}
{"hexsha": "866183579d23753b98110009f3dd7b056e5fd23c", "ext": "java", "lang": "Java", "content": "public class MockJMSSession implements Session, QueueSession, TopicSession, AutoCloseable {\n\n    private final AtomicBoolean closed = new AtomicBoolean();\n    private final AtomicBoolean started = new AtomicBoolean();\n    private final ReentrantLock sendLock = new ReentrantLock();\n\n    private final Map<String, MockJMSMessageProducer> producers = new ConcurrentHashMap<>();\n    private final Map<String, MockJMSMessageConsumer> consumers = new ConcurrentHashMap<>();\n\n    private final Set<MockJMSSessionListener> sessionListeners = new HashSet<>();\n\n    private final String sessionId;\n    private final int sessionMode;\n    private final MockJMSConnection connection;\n\n    private final AtomicLong consumerIdGenerator = new AtomicLong();\n    private final AtomicLong producerIdGenerator = new AtomicLong();\n\n    private MessageListener messageListener;\n\n    public MockJMSSession(String sessionId, int sessionMode, MockJMSConnection connection) {\n        this.sessionMode = sessionMode;\n        this.connection = connection;\n        this.sessionId = sessionId;\n    }\n\n    @Override\n    public void close() throws JMSException {\n        if (closed.compareAndSet(false, true)) {\n            connection.removeSession(this);\n\n            for (MockJMSMessageProducer producer : producers.values()) {\n                producer.close();\n            }\n\n            for (MockJMSMessageConsumer consumer : consumers.values()) {\n                consumer.close();\n            }\n\n            for (MockJMSSessionListener listener : sessionListeners) {\n                listener.onSessionClosed(this);\n            }\n        }\n    }\n\n    public void start() throws JMSException {\n    }\n\n    public void stop() throws JMSException {\n    }\n\n    @Override\n    public boolean getTransacted() throws JMSException {\n        checkClosed();\n        return sessionMode == SESSION_TRANSACTED;\n    }\n\n    @Override\n    public int getAcknowledgeMode() throws JMSException {\n        checkClosed();\n        return sessionMode;\n    }\n\n    @Override\n    public void commit() throws JMSException {\n        checkClosed();\n\n        if (!getTransacted()) {\n            throw new IllegalStateException(\"Session is not transacted\");\n        }\n\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onSessionCommit(this);\n        }\n    }\n\n    @Override\n    public void rollback() throws JMSException {\n        checkClosed();\n\n        if (!getTransacted()) {\n            throw new IllegalStateException(\"Session is not transacted\");\n        }\n\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onSessionRollback(this);\n        }\n    }\n\n    @Override\n    public void recover() throws JMSException {\n        checkClosed();\n    }\n\n    @Override\n    public void unsubscribe(String name) throws JMSException {\n        checkClosed();\n    }\n\n    @Override\n    public MessageListener getMessageListener() throws JMSException {\n        checkClosed();\n        return messageListener;\n    }\n\n    @Override\n    public void setMessageListener(MessageListener listener) throws JMSException {\n        checkClosed();\n        this.messageListener = listener;\n    }\n\n    public String getSessionId() {\n        return sessionId;\n    }\n\n    public MockJMSConnection getConnection() {\n        return connection;\n    }\n\n    public void addSessionListener(MockJMSSessionListener listener) throws JMSException {\n        checkClosed();\n        if (listener != null) {\n            sessionListeners.add(listener);\n        }\n    }\n\n    public void removeSessionListener(MockJMSSessionListener listener) throws JMSException {\n        checkClosed();\n        sessionListeners.remove(listener);\n    }\n\n    //----- Message Factory Methods ------------------------------------------//\n\n    @Override\n    public BytesMessage createBytesMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSBytesMessage();\n    }\n\n    @Override\n    public MapMessage createMapMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSMapMessage();\n    }\n\n    @Override\n    public Message createMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSMessage();\n    }\n\n    @Override\n    public ObjectMessage createObjectMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSObjectMessage();\n    }\n\n    @Override\n    public ObjectMessage createObjectMessage(Serializable object) throws JMSException {\n        checkClosed();\n        MockJMSObjectMessage message = new MockJMSObjectMessage();\n        message.setObject(object);\n        return message;\n    }\n\n    @Override\n    public StreamMessage createStreamMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSStreamMessage();\n    }\n\n    @Override\n    public TextMessage createTextMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSTextMessage();\n    }\n\n    @Override\n    public TextMessage createTextMessage(String text) throws JMSException {\n        checkClosed();\n        MockJMSTextMessage message = new MockJMSTextMessage();\n        message.setText(text);\n        return message;\n    }\n\n    //----- Producer Factory Methods -----------------------------------------//\n\n    @Override\n    public MessageProducer createProducer(Destination destination) throws JMSException {\n        checkClosed();\n        return new MockJMSMessageProducer(this, getNextProducerId(), (MockJMSDestination) destination);\n    }\n\n    @Override\n    public QueueSender createSender(Queue queue) throws JMSException {\n        checkClosed();\n        return new MockJMSQueueSender(this, getNextProducerId(), (MockJMSDestination) queue);\n    }\n\n    @Override\n    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        return new MockJMSTopicPublisher(this, getNextProducerId(), (MockJMSDestination) topic);\n    }\n\n    //----- Consumer Factory Methods -----------------------------------------//\n\n    @Override\n    public TopicSubscriber createSubscriber(Topic topic) throws JMSException {\n        return createSubscriber(topic, null, false);\n    }\n\n    @Override\n    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);\n    }\n\n    @Override\n    public QueueReceiver createReceiver(Queue queue) throws JMSException {\n        return createReceiver(queue, null);\n    }\n\n    @Override\n    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(queue);\n        return new MockJMSQueueReceiver(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);\n    }\n\n    @Override\n    public MessageConsumer createConsumer(Destination destination) throws JMSException {\n        checkClosed();\n        return createConsumer(destination, null, false);\n    }\n\n    @Override\n    public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {\n        checkClosed();\n        return createConsumer(destination, messageSelector, false);\n    }\n\n    @Override\n    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(destination);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSDestination) destination, messageSelector, noLocal);\n    }\n\n    @Override\n    public TopicSubscriber createDurableSubscriber(Topic topic, String name) throws JMSException {\n        return createDurableSubscriber(topic, name, null, false);\n    }\n\n    @Override\n    public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);\n    }\n\n    //----- Browser Factory Methods ------------------------------------------//\n\n    @Override\n    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n        return createBrowser(queue, null);\n    }\n\n    @Override\n    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(queue);\n        return new MockJMSQueueBrowser(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);\n    }\n\n    //----- Destination Factory Methods --------------------------------------//\n\n    @Override\n    public Queue createQueue(String queueName) throws JMSException {\n        checkClosed();\n        return new MockJMSQueue(queueName);\n    }\n\n    @Override\n    public Topic createTopic(String topicName) throws JMSException {\n        checkClosed();\n        return new MockJMSTopic(topicName);\n    }\n\n    @Override\n    public TemporaryQueue createTemporaryQueue() throws JMSException {\n        checkClosed();\n        return connection.createTemporaryQueue();\n    }\n\n    @Override\n    public TemporaryTopic createTemporaryTopic() throws JMSException {\n        checkClosed();\n        return connection.createTemporaryTopic();\n    }\n\n    //----- JMS 2.0 Shared Consumer Creation ---------------------------------//\n\n    @Override\n    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n\n    @Override\n    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);\n    }\n\n    @Override\n    public MessageConsumer createDurableConsumer(Topic topic, String name) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n\n    @Override\n    public MessageConsumer createDurableConsumer(Topic topic, String name, String messageSelector, boolean noLocal)throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, noLocal);\n    }\n\n    @Override\n    public MessageConsumer createSharedDurableConsumer(Topic topic, String name) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n\n    @Override\n    public MessageConsumer createSharedDurableConsumer(Topic topic, String name, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);\n    }\n\n    //----- JEE Session methods not implemented ------------------------------//\n\n    @Override\n    public void run() {\n        throw new JMSRuntimeException(\"Not Supported\");\n    }\n\n    //----- Session access points for producer and consumer ------------------//\n\n    void send(MockJMSMessageProducer producer, Destination destination, Message message, int deliveryMode, int priority, long timeToLive, boolean disableMessageId, boolean disableTimestamp, long deliveryDelay, CompletionListener completionListener) throws JMSException {\n        sendLock.lock();\n        try {\n            message.setJMSDeliveryMode(deliveryMode);\n            message.setJMSPriority(priority);\n            message.setJMSRedelivered(false);\n            message.setJMSDestination(destination);\n\n            long timeStamp = System.currentTimeMillis();\n            boolean hasTTL = timeToLive > Message.DEFAULT_TIME_TO_LIVE;\n            boolean hasDelay = deliveryDelay > Message.DEFAULT_DELIVERY_DELAY;\n\n            if (!(message instanceof MockJMSMessage)) {\n                throw new IllegalStateException(\"Mock JMS client cannot handle foreign messages\");\n            }\n\n            if (!disableTimestamp) {\n                message.setJMSTimestamp(timeStamp);\n            } else {\n                message.setJMSTimestamp(0);\n            }\n\n            if (hasTTL) {\n                message.setJMSExpiration(timeStamp + timeToLive);\n            } else {\n                message.setJMSExpiration(0);\n            }\n\n            long messageSequence = producer.getNextMessageSequence();\n            String messageId = null;\n            if (!disableMessageId) {\n                messageId = producer.getProducerId() + \":\"+ messageSequence;\n            }\n\n            // Set the delivery time. Purposefully avoided doing this earlier so\n            // that we use the 'outbound' JmsMessage object reference when\n            // updating our own message instances, avoids using the interface\n            // in case the JMS 1.1 Message API is actually being used due to\n            // being on the classpath too.\n            long deliveryTime = timeStamp;\n            if (hasDelay) {\n                deliveryTime = timeStamp + deliveryDelay;\n            }\n\n            message.setJMSDeliveryTime(deliveryTime);\n\n            // Set the message ID\n            message.setJMSMessageID(messageId);\n\n            try {\n                connection.onMessageSend(this, message);\n            } catch (JMSException jmsEx) {\n                // If the synchronous portion of the send fails the completion be\n                // notified but might depending on the circumstances of the failures,\n                // remove it from the queue and check if is is already completed\n                // once we decide to add completion support to the mock\n                throw jmsEx;\n            }\n        } finally {\n            sendLock.unlock();\n        }\n    }\n\n    void acknowledge() throws JMSException {\n        // TODO Auto-generated method stub\n    }\n\n    static void validateSessionMode(int mode) {\n        switch (mode) {\n            case JMSContext.AUTO_ACKNOWLEDGE:\n            case JMSContext.CLIENT_ACKNOWLEDGE:\n            case JMSContext.DUPS_OK_ACKNOWLEDGE:\n            case JMSContext.SESSION_TRANSACTED:\n                return;\n            default:\n                throw new JMSRuntimeException(\"Invalid Session Mode: \" + mode);\n        }\n    }\n\n    //----- Internal Utility Methods -----------------------------------------//\n\n    private static void checkDestination(Destination dest) throws InvalidDestinationException {\n        if (dest == null) {\n            throw new InvalidDestinationException(\"Destination cannot be null\");\n        }\n    }\n\n    private void checkClosed() throws JMSException {\n        if (closed.get()) {\n            throw new JMSException(\"Session is closed\");\n        }\n    }\n\n    boolean isDestinationInUse(MockJMSTemporaryDestination destination) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n\n    protected String getNextConsumerId() {\n        return getSessionId() + \":\" + consumerIdGenerator.incrementAndGet();\n    }\n\n    protected String getNextProducerId() {\n        return getSessionId() + \":\" + producerIdGenerator.incrementAndGet();\n    }\n\n    protected void add(MockJMSMessageConsumer consumer) throws JMSException {\n        connection.onMessageConsumerCreate(this, consumer);\n        consumers.put(consumer.getConsumerId(), consumer);\n\n        if (started.get()) {\n            consumer.start();\n        }\n    }\n\n    protected void remove(MockJMSMessageConsumer consumer) throws JMSException {\n        consumers.remove(consumer.getConsumerId());\n        connection.onMessageConsumerClose(this, consumer);\n\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onConsumerClose(this, consumer);\n        }\n    }\n\n    protected void add(MockJMSMessageProducer producer) {\n        producers.put(producer.getProducerId(), producer);\n    }\n\n    protected void remove(MockJMSMessageProducer producer) throws JMSException {\n        producers.remove(producer.getProducerId());\n\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onProducerClose(this, producer);\n        }\n    }\n}", "class_id": 0, "repo": "tabish121/messy-pool", "file": "pooled-jms-pool/src/test/java/org/messaginghub/pooled/jms/mock/MockJMSSession.java", "last_update_at": "2018-05-17T14:14:45+00:00", "question_id": "866183579d23753b98110009f3dd7b056e5fd23c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockJMSSession implements Session, QueueSession, TopicSession, AutoCloseable {\n    private final AtomicBoolean closed = new AtomicBoolean();\n    private final AtomicBoolean started = new AtomicBoolean();\n    private final ReentrantLock sendLock = new ReentrantLock();\n    private final Map<String, MockJMSMessageProducer> producers = new ConcurrentHashMap<>();\n    private final Map<String, MockJMSMessageConsumer> consumers = new ConcurrentHashMap<>();\n    private final Set<MockJMSSessionListener> sessionListeners = new HashSet<>();\n    private final String sessionId;\n    private final int sessionMode;\n    private final MockJMSConnection connection;\n    private final AtomicLong consumerIdGenerator = new AtomicLong();\n    private final AtomicLong producerIdGenerator = new AtomicLong();\n    private MessageListener messageListener;\n    public MockJMSSession(String sessionId, int sessionMode, MockJMSConnection connection) {\n        this.sessionMode = sessionMode;\n        this.connection = connection;\n        this.sessionId = sessionId;\n    }\n    @Override\n    public void close() throws JMSException {\n        if (closed.compareAndSet(false, true)) {\n            connection.removeSession(this);\n            for (MockJMSMessageProducer producer : producers.values()) {\n                producer.close();\n            }\n            for (MockJMSMessageConsumer consumer : consumers.values()) {\n                consumer.close();\n            }\n            for (MockJMSSessionListener listener : sessionListeners) {\n                listener.onSessionClosed(this);\n            }\n        }\n    }\n    public void start() throws JMSException {\n    }\n    public void stop() throws JMSException {\n    }\n    @Override\n    public boolean getTransacted() throws JMSException {\n        checkClosed();\n        return sessionMode == SESSION_TRANSACTED;\n    }\n    @Override\n    public int getAcknowledgeMode() throws JMSException {\n        checkClosed();\n        return sessionMode;\n    }\n    @Override\n    public void commit() throws JMSException {\n        checkClosed();\n        if (!getTransacted()) {\n            throw new IllegalStateException(\"Session is not transacted\");\n        }\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onSessionCommit(this);\n        }\n    }\n    @Override\n    public void rollback() throws JMSException {\n        checkClosed();\n        if (!getTransacted()) {\n            throw new IllegalStateException(\"Session is not transacted\");\n        }\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onSessionRollback(this);\n        }\n    }\n    @Override\n    public void recover() throws JMSException {\n        checkClosed();\n    }\n    @Override\n    public void unsubscribe(String name) throws JMSException {\n        checkClosed();\n    }\n    @Override\n    public MessageListener getMessageListener() throws JMSException {\n        checkClosed();\n        return messageListener;\n    }\n    @Override\n    public void setMessageListener(MessageListener listener) throws JMSException {\n        checkClosed();\n        this.messageListener = listener;\n    }\n    public String getSessionId() {\n        return sessionId;\n    }\n    public MockJMSConnection getConnection() {\n        return connection;\n    }\n    public void addSessionListener(MockJMSSessionListener listener) throws JMSException {\n        checkClosed();\n        if (listener != null) {\n            sessionListeners.add(listener);\n        }\n    }\n    public void removeSessionListener(MockJMSSessionListener listener) throws JMSException {\n        checkClosed();\n        sessionListeners.remove(listener);\n    }\n    //----- Message Factory Methods ------------------------------------------//\n    @Override\n    public BytesMessage createBytesMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSBytesMessage();\n    }\n    @Override\n    public MapMessage createMapMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSMapMessage();\n    }\n    @Override\n    public Message createMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSMessage();\n    }\n    @Override\n    public ObjectMessage createObjectMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSObjectMessage();\n    }\n    @Override\n    public ObjectMessage createObjectMessage(Serializable object) throws JMSException {\n        checkClosed();\n        MockJMSObjectMessage message = new MockJMSObjectMessage();\n        message.setObject(object);\n        return message;\n    }\n    @Override\n    public StreamMessage createStreamMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSStreamMessage();\n    }\n    @Override\n    public TextMessage createTextMessage() throws JMSException {\n        checkClosed();\n        return new MockJMSTextMessage();\n    }\n    @Override\n    public TextMessage createTextMessage(String text) throws JMSException {\n        checkClosed();\n        MockJMSTextMessage message = new MockJMSTextMessage();\n        message.setText(text);\n        return message;\n    }\n    //----- Producer Factory Methods -----------------------------------------//\n    @Override\n    public MessageProducer createProducer(Destination destination) throws JMSException {\n        checkClosed();\n        return new MockJMSMessageProducer(this, getNextProducerId(), (MockJMSDestination) destination);\n    }\n    @Override\n    public QueueSender createSender(Queue queue) throws JMSException {\n        checkClosed();\n        return new MockJMSQueueSender(this, getNextProducerId(), (MockJMSDestination) queue);\n    }\n    @Override\n    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        return new MockJMSTopicPublisher(this, getNextProducerId(), (MockJMSDestination) topic);\n    }\n    //----- Consumer Factory Methods -----------------------------------------//\n    @Override\n    public TopicSubscriber createSubscriber(Topic topic) throws JMSException {\n        return createSubscriber(topic, null, false);\n    }\n    @Override\n    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);\n    }\n    @Override\n    public QueueReceiver createReceiver(Queue queue) throws JMSException {\n        return createReceiver(queue, null);\n    }\n    @Override\n    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(queue);\n        return new MockJMSQueueReceiver(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);\n    }\n    @Override\n    public MessageConsumer createConsumer(Destination destination) throws JMSException {\n        checkClosed();\n        return createConsumer(destination, null, false);\n    }\n    @Override\n    public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {\n        checkClosed();\n        return createConsumer(destination, messageSelector, false);\n    }\n    @Override\n    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(destination);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSDestination) destination, messageSelector, noLocal);\n    }\n    @Override\n    public TopicSubscriber createDurableSubscriber(Topic topic, String name) throws JMSException {\n        return createDurableSubscriber(topic, name, null, false);\n    }\n    @Override\n    public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);\n    }\n    //----- Browser Factory Methods ------------------------------------------//\n    @Override\n    public QueueBrowser createBrowser(Queue queue) throws JMSException {\n        return createBrowser(queue, null);\n    }\n    @Override\n    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(queue);\n        return new MockJMSQueueBrowser(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);\n    }\n    //----- Destination Factory Methods --------------------------------------//\n    @Override\n    public Queue createQueue(String queueName) throws JMSException {\n        checkClosed();\n        return new MockJMSQueue(queueName);\n    }\n    @Override\n    public Topic createTopic(String topicName) throws JMSException {\n        checkClosed();\n        return new MockJMSTopic(topicName);\n    }\n    @Override\n    public TemporaryQueue createTemporaryQueue() throws JMSException {\n        checkClosed();\n        return connection.createTemporaryQueue();\n    }\n    @Override\n    public TemporaryTopic createTemporaryTopic() throws JMSException {\n        checkClosed();\n        return connection.createTemporaryTopic();\n    }\n    //----- JMS 2.0 Shared Consumer Creation ---------------------------------//\n    @Override\n    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n    @Override\n    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);\n    }\n    @Override\n    public MessageConsumer createDurableConsumer(Topic topic, String name) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n    @Override\n    public MessageConsumer createDurableConsumer(Topic topic, String name, String messageSelector, boolean noLocal)throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, noLocal);\n    }\n    @Override\n    public MessageConsumer createSharedDurableConsumer(Topic topic, String name) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);\n    }\n    @Override\n    public MessageConsumer createSharedDurableConsumer(Topic topic, String name, String messageSelector) throws JMSException {\n        checkClosed();\n        checkDestination(topic);\n        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);\n    }\n    //----- JEE Session methods not implemented ------------------------------//\n    @Override\n    public void run() {\n        throw new JMSRuntimeException(\"Not Supported\");\n    }\n    //----- Session access points for producer and consumer ------------------//\n    void send(MockJMSMessageProducer producer, Destination destination, Message message, int deliveryMode, int priority, long timeToLive, boolean disableMessageId, boolean disableTimestamp, long deliveryDelay, CompletionListener completionListener) throws JMSException {\n        sendLock.lock();\n        try {\n            message.setJMSDeliveryMode(deliveryMode);\n            message.setJMSPriority(priority);\n            message.setJMSRedelivered(false);\n            message.setJMSDestination(destination);\n            long timeStamp = System.currentTimeMillis();\n            boolean hasTTL = timeToLive > Message.DEFAULT_TIME_TO_LIVE;\n            boolean hasDelay = deliveryDelay > Message.DEFAULT_DELIVERY_DELAY;\n            if (!(message instanceof MockJMSMessage)) {\n                throw new IllegalStateException(\"Mock JMS client cannot handle foreign messages\");\n            }\n            if (!disableTimestamp) {\n                message.setJMSTimestamp(timeStamp);\n            } else {\n                message.setJMSTimestamp(0);\n            }\n            if (hasTTL) {\n                message.setJMSExpiration(timeStamp + timeToLive);\n            } else {\n                message.setJMSExpiration(0);\n            }\n            long messageSequence = producer.getNextMessageSequence();\n            String messageId = null;\n            if (!disableMessageId) {\n                messageId = producer.getProducerId() + \":\"+ messageSequence;\n            }\n            // Set the delivery time. Purposefully avoided doing this earlier so\n            // that we use the 'outbound' JmsMessage object reference when\n            // updating our own message instances, avoids using the interface\n            // in case the JMS 1.1 Message API is actually being used due to\n            // being on the classpath too.\n            long deliveryTime = timeStamp;\n            if (hasDelay) {\n                deliveryTime = timeStamp + deliveryDelay;\n            }\n            message.setJMSDeliveryTime(deliveryTime);\n            // Set the message ID\n            message.setJMSMessageID(messageId);\n            try {\n                connection.onMessageSend(this, message);\n            } catch (JMSException jmsEx) {\n                // If the synchronous portion of the send fails the completion be\n                // notified but might depending on the circumstances of the failures,\n                // remove it from the queue and check if is is already completed\n                // once we decide to add completion support to the mock\n                throw jmsEx;\n            }\n        } finally {\n            sendLock.unlock();\n        }\n    }\n    void acknowledge() throws JMSException {\n        // TODO Auto-generated method stub\n    }\n    static void validateSessionMode(int mode) {\n        switch (mode) {\n            case JMSContext.AUTO_ACKNOWLEDGE:\n            case JMSContext.CLIENT_ACKNOWLEDGE:\n            case JMSContext.DUPS_OK_ACKNOWLEDGE:\n            case JMSContext.SESSION_TRANSACTED:\n                return;\n            default:\n                throw new JMSRuntimeException(\"Invalid Session Mode: \" + mode);\n        }\n    }\n    //----- Internal Utility Methods -----------------------------------------//\n    private static void checkDestination(Destination dest) throws InvalidDestinationException {\n        if (dest == null) {\n            throw new InvalidDestinationException(\"Destination cannot be null\");\n        }\n    }\n    private void checkClosed() throws JMSException {\n        if (closed.get()) {\n            throw new JMSException(\"Session is closed\");\n        }\n    }\n    boolean isDestinationInUse(MockJMSTemporaryDestination destination) {\n        // TODO Auto-generated method stub\n        return false;\n    }\n    protected String getNextConsumerId() {\n        return getSessionId() + \":\" + consumerIdGenerator.incrementAndGet();\n    }\n    protected String getNextProducerId() {\n        return getSessionId() + \":\" + producerIdGenerator.incrementAndGet();\n    }\n    protected void add(MockJMSMessageConsumer consumer) throws JMSException {\n        connection.onMessageConsumerCreate(this, consumer);\n        consumers.put(consumer.getConsumerId(), consumer);\n        if (started.get()) {\n            consumer.start();\n        }\n    }\n    protected void remove(MockJMSMessageConsumer consumer) throws JMSException {\n        consumers.remove(consumer.getConsumerId());\n        connection.onMessageConsumerClose(this, consumer);\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onConsumerClose(this, consumer);\n        }\n    }\n    protected void add(MockJMSMessageProducer producer) {\n        producers.put(producer.getProducerId(), producer);\n    }\n    protected void remove(MockJMSMessageProducer producer) throws JMSException {\n        producers.remove(producer.getProducerId());\n        for (MockJMSSessionListener listener : sessionListeners) {\n            listener.onProducerClose(this, producer);\n        }\n    }\n"]], "pred": {"ppl": 1.3080782890319824, "ppl_lower": 1.4542851448059082, "ppl/lowercase_ppl": -1.3945327608225633, "ppl/zlib": 9.516623148257064e-05, "Min_5.0% Prob": 3.4158445783689912, "Min_10.0% Prob": 2.2402082173263325, "Min_20.0% Prob": 1.3044785464219018, "Min_30.0% Prob": 0.8921372019168403, "Min_40.0% Prob": 0.6706211774594043, "Min_50.0% Prob": 0.5373800687369783, "Min_60.0% Prob": 0.4481111816626246}}
{"hexsha": "a2679d23e812c436850e9784c31f528b1d917068", "ext": "java", "lang": "Java", "content": "public class MockAuditJobStatusModel {\n    private final Gson gson = new Gson();\n    private final UUID jobId = UUID.randomUUID();\n    private final String timeAuditCreated = new Date(400).toString();\n    private final String timeLastSent = new Date(500).toString();\n    private final String status = AuditEntryStatus.SUCCESS.name();\n\n    public AuditJobStatusModel createRestModel() {\n        return new AuditJobStatusModel(jobId, timeAuditCreated, timeLastSent, status);\n    }\n\n    public String getRestModelJson() {\n        JsonObject json = new JsonObject();\n        json.addProperty(\"jobId\", jobId.toString());\n        json.addProperty(\"timeAuditCreated\", timeAuditCreated);\n        json.addProperty(\"timeLastSent\", timeLastSent);\n        json.addProperty(\"status\", status);\n\n        return json.toString();\n    }\n\n    public void verifyRestModel() throws JSONException {\n        String restModel = gson.toJson(createRestModel());\n        String json = getRestModelJson();\n        JSONAssert.assertEquals(restModel, json, false);\n    }\n\n    @Test\n    public void testConfiguration() throws JSONException {\n        verifyRestModel();\n    }\n\n}", "class_id": 0, "repo": "blackducksoftware/hub-notification-engine", "file": "src/test/java/com/synopsys/integration/alert/component/audit/mock/MockAuditJobStatusModel.java", "last_update_at": "2018-03-27T17:20:29+00:00", "question_id": "a2679d23e812c436850e9784c31f528b1d917068", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MockAuditJobStatusModel {\n    private final Gson gson = new Gson();\n    private final UUID jobId = UUID.randomUUID();\n    private final String timeAuditCreated = new Date(400).toString();\n    private final String timeLastSent = new Date(500).toString();\n    private final String status = AuditEntryStatus.SUCCESS.name();\n    public AuditJobStatusModel createRestModel() {\n        return new AuditJobStatusModel(jobId, timeAuditCreated, timeLastSent, status);\n    }\n    public String getRestModelJson() {\n        JsonObject json = new JsonObject();\n        json.addProperty(\"jobId\", jobId.toString());\n        json.addProperty(\"timeAuditCreated\", timeAuditCreated);\n        json.addProperty(\"timeLastSent\", timeLastSent);\n        json.addProperty(\"status\", status);\n        return json.toString();\n    }\n    public void verifyRestModel() throws JSONException {\n        String restModel = gson.toJson(createRestModel());\n        String json = getRestModelJson();\n        JSONAssert.assertEquals(restModel, json, false);\n    }\n    @Test\n    public void testConfiguration() throws JSONException {\n        verifyRestModel();\n    }\n"]], "pred": {"ppl": 2.1262826919555664, "ppl_lower": 2.5554182529449463, "ppl/lowercase_ppl": -1.243699236499799, "ppl/zlib": 0.001858067093633144, "Min_5.0% Prob": 7.3802132924397785, "Min_10.0% Prob": 5.292180761214225, "Min_20.0% Prob": 3.4351856831520324, "Min_30.0% Prob": 2.444489048029247, "Min_40.0% Prob": 1.8844653538886518, "Min_50.0% Prob": 1.5105079664860535, "Min_60.0% Prob": 1.2579954503643278}}
{"hexsha": "e02dae8b915d95607e4812c2501d2bde454c69fe", "ext": "java", "lang": "Java", "content": "public class TestConfigDeserializer  implements JsonDeserializer<TestConfig>\n\n{\n    // TODO: 16/08/17 overflow????\n    //convert to float if target and value fits in its range - maybe should not use easy to go out...\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public TestConfig deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {\n        System.out.println(\"Call deserialize\");\n        GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.registerTypeAdapter(Range.class,new RangeDeserializer());\n        gsonBuilder.registerTypeAdapter(Param.class, new ParamDeserializer());\n        gsonBuilder.registerTypeAdapter(Objective.class, new ObjectiveDeserializer());\n        Gson gson = gsonBuilder.create();\n        TestConfig t = gson.fromJson(jsonElement, TestConfig.class);\n\n        //TestConfig modified = null;\n        List<Param> pl = t.getScriptParametersReference();\n        if(t.getOptimizerParameters() == null )\n            return t;\n        List<Param> op = t.getOptimizerParameters();\n       for(Param p : op) {\n           for (Object pdo : p.getDependencies()) {\n               ParameterDependency pd = (ParameterDependency)pdo;\n               if(pd.getP()!=null)\n                   for(Param p1: t.getOptimizerParameters())\n                       if(p1.equals(pd.getP()))\n                           pd.setP(p1);\n           }\n       }\n        return t;\n\n    }\n\n}", "class_id": 0, "repo": "kppeterkiss/BlackBoxOptimizer", "file": "src/main/java/optimizer/config/TestConfigDeserializer.java", "last_update_at": "2018-04-09T07:06:53+00:00", "question_id": "e02dae8b915d95607e4812c2501d2bde454c69fe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestConfigDeserializer  implements JsonDeserializer<TestConfig>\n{\n    // TODO: 16/08/17 overflow????\n    //convert to float if target and value fits in its range - maybe should not use easy to go out...\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public TestConfig deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {\n        System.out.println(\"Call deserialize\");\n        GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.registerTypeAdapter(Range.class,new RangeDeserializer());\n        gsonBuilder.registerTypeAdapter(Param.class, new ParamDeserializer());\n        gsonBuilder.registerTypeAdapter(Objective.class, new ObjectiveDeserializer());\n        Gson gson = gsonBuilder.create();\n        TestConfig t = gson.fromJson(jsonElement, TestConfig.class);\n        //TestConfig modified = null;\n        List<Param> pl = t.getScriptParametersReference();\n        if(t.getOptimizerParameters() == null )\n            return t;\n        List<Param> op = t.getOptimizerParameters();\n       for(Param p : op) {\n           for (Object pdo : p.getDependencies()) {\n               ParameterDependency pd = (ParameterDependency)pdo;\n               if(pd.getP()!=null)\n                   for(Param p1: t.getOptimizerParameters())\n                       if(p1.equals(pd.getP()))\n                           pd.setP(p1);\n           }\n       }\n        return t;\n    }\n"]], "pred": {"ppl": 3.1943302154541016, "ppl_lower": 3.8326690196990967, "ppl/lowercase_ppl": -1.1568689015666358, "ppl/zlib": 0.001975131684740356, "Min_5.0% Prob": 8.409278964996338, "Min_10.0% Prob": 6.740761361471036, "Min_20.0% Prob": 4.8152613261850865, "Min_30.0% Prob": 3.6184690386299194, "Min_40.0% Prob": 2.833002329417845, "Min_50.0% Prob": 2.306698691554186, "Min_60.0% Prob": 1.935472866535429}}
{"hexsha": "153cac855d2407b3580bea93e786ff4e10c64e51", "ext": "java", "lang": "Java", "content": "@Service\npublic class ContractorServiceImpl implements ContractorService {\n\n    private final ContractorRepository contractorRepository;\n    private final ClientRepository clientRepository;\n\n    public ContractorServiceImpl(ContractorRepository contractorRepository, ClientRepository clientRepository) {\n        this.contractorRepository = contractorRepository;\n        this.clientRepository = clientRepository;\n    }\n\n\n    @Override\n    public Optional<Contractor> getContractorById(Long id) {\n        return Optional.ofNullable(contractorRepository.findById(id));\n    }\n\n    @Override\n    public void addContractor(Long id, Contractor contractor) {\n        contractor.setClient(clientRepository.findOne(id));\n        contractorRepository.save(contractor);\n    }\n\n    @Override\n    public Contractor updateContractor(Contractor contractor) {\n        Contractor temp = contractorRepository.findById(contractor.getId());\n        temp.setDescription(contractor.getDescription());\n        temp.setName(contractor.getName());\n\n        return contractorRepository.save(temp);\n    }\n\n    @Override\n    public void deleteContractorById(Long id) {\n        contractorRepository.delete(id);\n    }\n\n}", "class_id": 0, "repo": "Wolfinstein/crm_backend", "file": "src/main/java/com/crm/application/service/serviceImpl/ContractorServiceImpl.java", "last_update_at": "2018-08-30T07:17:30+00:00", "question_id": "153cac855d2407b3580bea93e786ff4e10c64e51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service\npublic class ContractorServiceImpl implements ContractorService {\n    private final ContractorRepository contractorRepository;\n    private final ClientRepository clientRepository;\n    public ContractorServiceImpl(ContractorRepository contractorRepository, ClientRepository clientRepository) {\n        this.contractorRepository = contractorRepository;\n        this.clientRepository = clientRepository;\n    }\n    @Override\n    public Optional<Contractor> getContractorById(Long id) {\n        return Optional.ofNullable(contractorRepository.findById(id));\n    }\n    @Override\n    public void addContractor(Long id, Contractor contractor) {\n        contractor.setClient(clientRepository.findOne(id));\n        contractorRepository.save(contractor);\n    }\n    @Override\n    public Contractor updateContractor(Contractor contractor) {\n        Contractor temp = contractorRepository.findById(contractor.getId());\n        temp.setDescription(contractor.getDescription());\n        temp.setName(contractor.getName());\n        return contractorRepository.save(temp);\n    }\n    @Override\n    public void deleteContractorById(Long id) {\n        contractorRepository.delete(id);\n    }\n"]], "pred": {"ppl": 1.5034174919128418, "ppl_lower": 1.7054563760757446, "ppl/lowercase_ppl": -1.3092452013229108, "ppl/zlib": 0.0012171368495412778, "Min_5.0% Prob": 4.775194065911429, "Min_10.0% Prob": 3.230520009994507, "Min_20.0% Prob": 1.9393850534126675, "Min_30.0% Prob": 1.340545051228041, "Min_40.0% Prob": 1.0160972928339294, "Min_50.0% Prob": 0.8163582854550974, "Min_60.0% Prob": 0.6814082191063455}}
{"hexsha": "2c099a0e683aae3b6d6a168dd6848cfb0831c823", "ext": "java", "lang": "Java", "content": "@Lesson(9)\n@ExtendWith({ParameterSupplier.class})\nclass OperationTest {\n\n    @Test\n    void zippingIntMonthIntToLocalDate(final Operations operations) {\n        final Flux<Integer> yearFlux = Flux.just(2018, 2018, 2017, 2018);\n        final Flux<Month> monthFlux = Flux.just(Month.JANUARY, Month.MARCH, Month.DECEMBER, Month.JANUARY);\n        final Flux<Integer> dayOfMonthFlux = Flux.just(2, 30, 31, 17);\n\n        final Flux<LocalDate> flux = operations.zipFluxToLocalDate(yearFlux, monthFlux, dayOfMonthFlux);\n\n        StepVerifier.create(flux)\n                .expectSubscription()\n                .expectNext(LocalDate.of(2018, Month.JANUARY, 2))\n                .expectNext(LocalDate.of(2018, Month.MARCH, 30))\n                .expectNext(LocalDate.of(2017, Month.DECEMBER, 31))\n                .expectNext(LocalDate.of(2018, Month.JANUARY, 17))\n                .verifyComplete();\n    }\n\n    @Test\n    void fastestMonoValue(final Operations operations) {\n        final Mono<String> left = Mono.defer(() -> Mono.delay(Duration.ofSeconds(20L)).map(l -> \"foo\"));\n        final Mono<String> right = Mono.defer(() -> Mono.delay(Duration.ofSeconds(19L)).map(l -> \"bar\"));\n        final Mono<String> mono = operations.fastestMonoValue(left, right);\n        StepVerifier.withVirtualTime(() -> mono)\n                .thenAwait(Duration.ofSeconds(19L))\n                .expectNext(\"bar\")\n                .verifyComplete();\n                \n    }\n\n    @Test\n    void firstEmittingNotMixed(final Operations operations) {\n        final Flux<String> left = Flux.defer(\n                () -> Flux.just(\"foo\", \"bar\", \"baz\").delaySequence(Duration.ofSeconds(10L)).delayElements(Duration.ofSeconds(2L)));\n        final Flux<String> right = Flux.defer(() -> Flux.interval(Duration.ofSeconds(9L), Duration.ofSeconds(3L)).map(v -> String.format(\"item-%d\", v)).take(3L));\n        StepVerifier.withVirtualTime(() -> operations.firstEmittingNotMixed(left, right))\n                .expectSubscription()\n                .expectNoEvent(Duration.ofSeconds(9L))\n                .expectNext(\"item-0\")\n                .expectNoEvent(Duration.ofSeconds(3L))\n                .expectNext(\"item-1\")\n                .expectNoEvent(Duration.ofSeconds(3L))\n                .expectNext(\"item-2\")\n                .verifyComplete();\n    }\n\n    @Test\n    void fluxCompletionByThen(final Operations operations) {\n        final Flux<Long> flux = Flux.defer(() -> Flux.interval(Duration.ofMillis(30L)).take(10));\n        StepVerifier.withVirtualTime(() -> operations.completeWithThen(flux))\n                .expectSubscription()\n                .expectNoEvent(Duration.ofMillis(30 * 10))\n                .verifyComplete();\n    }\n\n    @Test\n    void nullAwarenessStaticFactoryMethod(final Operations operations) {\n        final Mono<String> firstMono = operations.nullAwareMono(\"foo\");\n        final Mono<String> secondMono = operations.nullAwareMono(null);\n        assertAll(\n                () -> StepVerifier.create(firstMono.hasElement()).expectNext(true).verifyComplete(),\n                () -> StepVerifier.create(secondMono.hasElement()).expectNext(false).verifyComplete()\n        );\n    }\n\n    @Test\n    void emptyThenBar(final Operations operations) {\n        final Mono<String> foo = operations.returnBarWhenEmpty(Mono.just(\"foo\"));\n        final Mono<String> bar = operations.returnBarWhenEmpty(Mono.empty());\n        assertAll(\n                () -> StepVerifier.create(foo).expectNext(\"foo\").verifyComplete(),\n                () -> StepVerifier.create(bar).expectNext(\"bar\").verifyComplete()\n        );\n    }\n}", "class_id": 0, "repo": "mike-neck/java-til", "file": "reactor-tutorial/src/test/java/com/example/lesson/OperationTest.java", "last_update_at": "2018-03-08T05:02:38+00:00", "question_id": "2c099a0e683aae3b6d6a168dd6848cfb0831c823", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Lesson(9)\n@ExtendWith({ParameterSupplier.class})\nclass OperationTest {\n    @Test\n    void zippingIntMonthIntToLocalDate(final Operations operations) {\n        final Flux<Integer> yearFlux = Flux.just(2018, 2018, 2017, 2018);\n        final Flux<Month> monthFlux = Flux.just(Month.JANUARY, Month.MARCH, Month.DECEMBER, Month.JANUARY);\n        final Flux<Integer> dayOfMonthFlux = Flux.just(2, 30, 31, 17);\n        final Flux<LocalDate> flux = operations.zipFluxToLocalDate(yearFlux, monthFlux, dayOfMonthFlux);\n        StepVerifier.create(flux)\n                .expectSubscription()\n                .expectNext(LocalDate.of(2018, Month.JANUARY, 2))\n                .expectNext(LocalDate.of(2018, Month.MARCH, 30))\n                .expectNext(LocalDate.of(2017, Month.DECEMBER, 31))\n                .expectNext(LocalDate.of(2018, Month.JANUARY, 17))\n                .verifyComplete();\n    }\n    @Test\n    void fastestMonoValue(final Operations operations) {\n        final Mono<String> left = Mono.defer(() -> Mono.delay(Duration.ofSeconds(20L)).map(l -> \"foo\"));\n        final Mono<String> right = Mono.defer(() -> Mono.delay(Duration.ofSeconds(19L)).map(l -> \"bar\"));\n        final Mono<String> mono = operations.fastestMonoValue(left, right);\n        StepVerifier.withVirtualTime(() -> mono)\n                .thenAwait(Duration.ofSeconds(19L))\n                .expectNext(\"bar\")\n                .verifyComplete();\n    }\n    @Test\n    void firstEmittingNotMixed(final Operations operations) {\n        final Flux<String> left = Flux.defer(\n                () -> Flux.just(\"foo\", \"bar\", \"baz\").delaySequence(Duration.ofSeconds(10L)).delayElements(Duration.ofSeconds(2L)));\n        final Flux<String> right = Flux.defer(() -> Flux.interval(Duration.ofSeconds(9L), Duration.ofSeconds(3L)).map(v -> String.format(\"item-%d\", v)).take(3L));\n        StepVerifier.withVirtualTime(() -> operations.firstEmittingNotMixed(left, right))\n                .expectSubscription()\n                .expectNoEvent(Duration.ofSeconds(9L))\n                .expectNext(\"item-0\")\n                .expectNoEvent(Duration.ofSeconds(3L))\n                .expectNext(\"item-1\")\n                .expectNoEvent(Duration.ofSeconds(3L))\n                .expectNext(\"item-2\")\n                .verifyComplete();\n    }\n    @Test\n    void fluxCompletionByThen(final Operations operations) {\n        final Flux<Long> flux = Flux.defer(() -> Flux.interval(Duration.ofMillis(30L)).take(10));\n        StepVerifier.withVirtualTime(() -> operations.completeWithThen(flux))\n                .expectSubscription()\n                .expectNoEvent(Duration.ofMillis(30 * 10))\n                .verifyComplete();\n    }\n    @Test\n    void nullAwarenessStaticFactoryMethod(final Operations operations) {\n        final Mono<String> firstMono = operations.nullAwareMono(\"foo\");\n        final Mono<String> secondMono = operations.nullAwareMono(null);\n        assertAll(\n                () -> StepVerifier.create(firstMono.hasElement()).expectNext(true).verifyComplete(),\n                () -> StepVerifier.create(secondMono.hasElement()).expectNext(false).verifyComplete()\n        );\n    }\n    @Test\n    void emptyThenBar(final Operations operations) {\n        final Mono<String> foo = operations.returnBarWhenEmpty(Mono.just(\"foo\"));\n        final Mono<String> bar = operations.returnBarWhenEmpty(Mono.empty());\n        assertAll(\n                () -> StepVerifier.create(foo).expectNext(\"foo\").verifyComplete(),\n                () -> StepVerifier.create(bar).expectNext(\"bar\").verifyComplete()\n        );\n    }\n"]], "pred": {"ppl": 1.8370708227157593, "ppl_lower": 2.110217809677124, "ppl/lowercase_ppl": -1.2279268508331436, "ppl/zlib": 0.0006926792243224653, "Min_5.0% Prob": 6.582853859546137, "Min_10.0% Prob": 4.767645688617931, "Min_20.0% Prob": 2.8891663663819727, "Min_30.0% Prob": 2.004576715184193, "Min_40.0% Prob": 1.515006554943753, "Min_50.0% Prob": 1.2159016139827188, "Min_60.0% Prob": 1.0144607419969263}}
{"hexsha": "2ac66b8b935a5c3f37facf006d3fadd05afd602c", "ext": "java", "lang": "Java", "content": "public class SaturnThreadFactory implements ThreadFactory {\n\tprivate static final AtomicInteger poolNumber = new AtomicInteger(1);\n\tprivate AtomicInteger threadNumber = new AtomicInteger(1);\n\tprivate boolean isMultiple = true;\n\tprivate String threadName;\n\n\tpublic SaturnThreadFactory(String threadName) {\n\t\tthis.threadName = \"Saturn-\" + threadName + \"-\" + poolNumber.getAndIncrement() + \"-thread-\";\n\t}\n\n\tpublic SaturnThreadFactory(String threadName, boolean isMultiple) {\n\t\tthis.isMultiple = isMultiple;\n\t\tthis.threadName = threadName;\n\t}\n\n\t@Override\n\tpublic Thread newThread(Runnable r) {\n\t\tString name = isMultiple ? threadName + threadNumber.getAndIncrement() : threadName;\n\t\tThread t = new Thread(r, name);\n\t\tif (t.isDaemon()) {\n\t\t\tt.setDaemon(false);\n\t\t}\n\t\tif (t.getPriority() != Thread.NORM_PRIORITY) {\n\t\t\tt.setPriority(Thread.NORM_PRIORITY);\n\t\t}\n\t\treturn t;\n\t}\n}", "class_id": 0, "repo": "shulanztf/Saturn-3.0.1", "file": "saturn-core/src/main/java/com/vip/saturn/job/threads/SaturnThreadFactory.java", "last_update_at": "2018-12-04T04:03:35+00:00", "question_id": "2ac66b8b935a5c3f37facf006d3fadd05afd602c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SaturnThreadFactory implements ThreadFactory {\n\tprivate static final AtomicInteger poolNumber = new AtomicInteger(1);\n\tprivate AtomicInteger threadNumber = new AtomicInteger(1);\n\tprivate boolean isMultiple = true;\n\tprivate String threadName;\n\tpublic SaturnThreadFactory(String threadName) {\n\t\tthis.threadName = \"Saturn-\" + threadName + \"-\" + poolNumber.getAndIncrement() + \"-thread-\";\n\t}\n\tpublic SaturnThreadFactory(String threadName, boolean isMultiple) {\n\t\tthis.isMultiple = isMultiple;\n\t\tthis.threadName = threadName;\n\t}\n\t@Override\n\tpublic Thread newThread(Runnable r) {\n\t\tString name = isMultiple ? threadName + threadNumber.getAndIncrement() : threadName;\n\t\tThread t = new Thread(r, name);\n\t\tif (t.isDaemon()) {\n\t\t\tt.setDaemon(false);\n\t\t}\n\t\tif (t.getPriority() != Thread.NORM_PRIORITY) {\n\t\t\tt.setPriority(Thread.NORM_PRIORITY);\n\t\t}\n\t\treturn t;\n\t}\n"]], "pred": {"ppl": 1.377769947052002, "ppl_lower": 1.7596831321716309, "ppl/lowercase_ppl": -1.7634737570679797, "ppl/zlib": 0.0009156177476209465, "Min_5.0% Prob": 4.814279002802713, "Min_10.0% Prob": 2.8924992166716477, "Min_20.0% Prob": 1.5697151288642721, "Min_30.0% Prob": 1.060834546855996, "Min_40.0% Prob": 0.8045890107356265, "Min_50.0% Prob": 0.6426181292265175, "Min_60.0% Prob": 0.534598874411182}}
{"hexsha": "c54d436109ff0ccb4ff9484823430a5fa07758c7", "ext": "java", "lang": "Java", "content": "@Configuration\npublic class EnaAgentConfiguration {\n\n    static String SUBMITTABLE_PACKAGE = \"uk.ac.ebi.subs.data.submittable\";\n    static String COMPONENT_PACKAGE = \"uk.ac.ebi.subs.data.component\";\n\n    @Autowired\n    private ApplicationContext appContext;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/component/attribute_mapping.xml\")\n    Resource componentMappingResource;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/study_mapping.xml\")\n    Resource studyMappingResource;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/experiment_mapping.xml\")\n    Resource experimentMappingResource;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/run_mapping.xml\")\n    Resource runMappingResource;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/sample_mapping.xml\")\n    Resource sampleMappingResource;\n\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/seq_var_analysis_mapping.xml\")\n    Resource seqVarAnalysisMappingResource;\n\n    @Bean(name = \"study\")\n    Jaxb2Marshaller jaxb2StudyMarshaller() throws IOException {\n        Class enaStudyClass = ENAStudy.class;\n        return getJaxb2Marshaller(studyMappingResource, enaStudyClass);\n    }\n\n    @Bean(name = \"sample\")\n    Jaxb2Marshaller jaxb2SampleMarshaller() throws IOException {\n        Class enaSampleClass = ENASample.class;\n        return getJaxb2Marshaller(sampleMappingResource, enaSampleClass);\n    }\n\n    @Bean(name = \"experiment\")\n    Jaxb2Marshaller jaxb2ExperimentMarshaller() throws IOException {\n        Class enaExperimentClass = ENAExperiment.class;\n        return getJaxb2Marshaller(experimentMappingResource, enaExperimentClass);\n    }\n\n    @Bean(name = \"run\")\n    Jaxb2Marshaller jaxb2RunMarshaller() throws IOException {\n        Class enaRunClass = ENARun.class;\n        return getJaxb2Marshaller(runMappingResource, enaRunClass);\n    }\n\n    @Bean(name = \"analysis\")\n    Jaxb2Marshaller jaxb2SequenceVariationAnalysisMarshaller() throws IOException {\n        Class enaSequenceVariationAnalysisClass = ENASequenceVariationAnalysis.class;\n        return getJaxb2Marshaller(seqVarAnalysisMappingResource, enaSequenceVariationAnalysisClass);\n    }\n\n    private Jaxb2Marshaller getJaxb2Marshaller(Resource resource, Class enaStudyClass) throws IOException {\n        Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();\n        final HashMap<String, Object> jaxpHashMap = new HashMap<>();\n        jaxpHashMap.put(COMPONENT_PACKAGE, new StreamSource(componentMappingResource.getInputStream()));\n        jaxpHashMap.put(SUBMITTABLE_PACKAGE, new StreamSource(resource.getInputStream()));\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(JAXBContextProperties.OXM_METADATA_SOURCE, jaxpHashMap);\n        jaxb2Marshaller.setJaxbContextProperties(properties);\n        jaxb2Marshaller.setClassesToBeBound(enaStudyClass);\n        return jaxb2Marshaller;\n    }\n\n}", "class_id": 0, "repo": "EMBL-EBI-SUBS/subs-ena-core-service", "file": "src/main/java/uk/ac/ebi/subs/ena/config/EnaAgentConfiguration.java", "last_update_at": "2018-03-16T09:49:58+00:00", "question_id": "c54d436109ff0ccb4ff9484823430a5fa07758c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\npublic class EnaAgentConfiguration {\n    static String SUBMITTABLE_PACKAGE = \"uk.ac.ebi.subs.data.submittable\";\n    static String COMPONENT_PACKAGE = \"uk.ac.ebi.subs.data.component\";\n    @Autowired\n    private ApplicationContext appContext;\n    @Value(\"classpath:uk/ac/ebi/subs/data/component/attribute_mapping.xml\")\n    Resource componentMappingResource;\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/study_mapping.xml\")\n    Resource studyMappingResource;\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/experiment_mapping.xml\")\n    Resource experimentMappingResource;\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/run_mapping.xml\")\n    Resource runMappingResource;\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/sample_mapping.xml\")\n    Resource sampleMappingResource;\n    @Value(\"classpath:uk/ac/ebi/subs/data/submittable/seq_var_analysis_mapping.xml\")\n    Resource seqVarAnalysisMappingResource;\n    @Bean(name = \"study\")\n    Jaxb2Marshaller jaxb2StudyMarshaller() throws IOException {\n        Class enaStudyClass = ENAStudy.class;\n        return getJaxb2Marshaller(studyMappingResource, enaStudyClass);\n    }\n    @Bean(name = \"sample\")\n    Jaxb2Marshaller jaxb2SampleMarshaller() throws IOException {\n        Class enaSampleClass = ENASample.class;\n        return getJaxb2Marshaller(sampleMappingResource, enaSampleClass);\n    }\n    @Bean(name = \"experiment\")\n    Jaxb2Marshaller jaxb2ExperimentMarshaller() throws IOException {\n        Class enaExperimentClass = ENAExperiment.class;\n        return getJaxb2Marshaller(experimentMappingResource, enaExperimentClass);\n    }\n    @Bean(name = \"run\")\n    Jaxb2Marshaller jaxb2RunMarshaller() throws IOException {\n        Class enaRunClass = ENARun.class;\n        return getJaxb2Marshaller(runMappingResource, enaRunClass);\n    }\n    @Bean(name = \"analysis\")\n    Jaxb2Marshaller jaxb2SequenceVariationAnalysisMarshaller() throws IOException {\n        Class enaSequenceVariationAnalysisClass = ENASequenceVariationAnalysis.class;\n        return getJaxb2Marshaller(seqVarAnalysisMappingResource, enaSequenceVariationAnalysisClass);\n    }\n    private Jaxb2Marshaller getJaxb2Marshaller(Resource resource, Class enaStudyClass) throws IOException {\n        Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();\n        final HashMap<String, Object> jaxpHashMap = new HashMap<>();\n        jaxpHashMap.put(COMPONENT_PACKAGE, new StreamSource(componentMappingResource.getInputStream()));\n        jaxpHashMap.put(SUBMITTABLE_PACKAGE, new StreamSource(resource.getInputStream()));\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(JAXBContextProperties.OXM_METADATA_SOURCE, jaxpHashMap);\n        jaxb2Marshaller.setJaxbContextProperties(properties);\n        jaxb2Marshaller.setClassesToBeBound(enaStudyClass);\n        return jaxb2Marshaller;\n    }\n"]], "pred": {"ppl": 1.4524608850479126, "ppl_lower": 1.7018743753433228, "ppl/lowercase_ppl": -1.4245599397575734, "ppl/zlib": 0.0005301978408839475, "Min_5.0% Prob": 5.319536991741346, "Min_10.0% Prob": 3.458237352550671, "Min_20.0% Prob": 1.8473993403548226, "Min_30.0% Prob": 1.2408327637936296, "Min_40.0% Prob": 0.9340779299867703, "Min_50.0% Prob": 0.747036310519255, "Min_60.0% Prob": 0.6222503895835505}}
{"hexsha": "c4f0f769920be064bc206f26adb1a7c9996c545b", "ext": "java", "lang": "Java", "content": "public class Table2DViewer_JPanel extends javax.swing.JPanel {\n    \n    private int[] xi = null;\n    private int[] eta = null;\n    private double[][] v = null;\n    /**\n     * Creates new form Table2DViewer_JPanel\n     */\n    public Table2DViewer_JPanel() {\n        initComponents();\n    }\n    \n    /** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\n    private void initComponents() {\n        jTabbedPane1 = new javax.swing.JTabbedPane();\n        jPanel1 = new javax.swing.JPanel();\n        jScrollPane = new javax.swing.JScrollPane();\n        jTable = new javax.swing.JTable();\n        jPanel2 = new javax.swing.JPanel();\n\n        jScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n        jTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n                {null, null, null, null},\n                {null, null, null, null},\n                {null, null, null, null},\n                {null, null, null, null}\n            },\n            new String [] {\n                \"Title 1\", \"Title 2\", \"Title 3\", \"Title 4\"\n            }\n        ));\n        jTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);\n        jScrollPane.setViewportView(jTable);\n\n        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 395, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)\n        );\n        jTabbedPane1.addTab(\"table\", jPanel1);\n\n        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(0, 395, Short.MAX_VALUE)\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(0, 275, Short.MAX_VALUE)\n        );\n        jTabbedPane1.addTab(\"plot\", jPanel2);\n\n        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)\n        );\n    }// </editor-fold>//GEN-END:initComponents\n\n    public void setModelData(int[] xi, int[] eta, double[][] v) {\n        this.xi = xi;\n        this.eta = eta;\n        this.v = v;\n        String[] colnames = new String[xi.length+1];\n        Object [][] o = new Object[eta.length][xi.length+1];\n        colnames[0] = \"eta/xi\";\n        for (int i=1;i<=xi.length;i++) {\n            colnames[i] = String.valueOf(xi[i]);\n        }\n        for (int j=0;j<eta.length;j++) {\n            for (int i=1;i<=xi.length;i++) {\n                o[j][i] = String.valueOf(v[j][i]);\n            }\n        }\n        jTable = new JTable(o,colnames);\n    }\n\n    void setTableModel(AbstractTableModel tm) {\n        jTable.setModel(tm);\n        int cc = jTable.getColumnCount();\n        javax.swing.table.TableColumn tc = null;\n        for (int c=0;c<cc;c++) {\n            tc = jTable.getColumnModel().getColumn(c);\n            tc.setPreferredWidth(100);\n        }\n        jTable.validate();\n        jTable.repaint();\n        jScrollPane.validate();\n        jScrollPane.repaint();    \n    }\n    \n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JPanel jPanel2;\n    private javax.swing.JScrollPane jScrollPane;\n    private javax.swing.JTabbedPane jTabbedPane1;\n    private javax.swing.JTable jTable;\n    // End of variables declaration//GEN-END:variables\n    \n}", "class_id": 0, "repo": "wStockhausen/DisMELS", "file": "DisMELS_ROMS/src/wts/roms/gui/Table2DViewer_JPanel.java", "last_update_at": "2018-03-10T02:55:28+00:00", "question_id": "c4f0f769920be064bc206f26adb1a7c9996c545b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Table2DViewer_JPanel extends javax.swing.JPanel {\n    private int[] xi = null;\n    private int[] eta = null;\n    private double[][] v = null;\n    /**\n     * Creates new form Table2DViewer_JPanel\n     */\n    public Table2DViewer_JPanel() {\n        initComponents();\n    }\n    /** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\n    private void initComponents() {\n        jTabbedPane1 = new javax.swing.JTabbedPane();\n        jPanel1 = new javax.swing.JPanel();\n        jScrollPane = new javax.swing.JScrollPane();\n        jTable = new javax.swing.JTable();\n        jPanel2 = new javax.swing.JPanel();\n        jScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n        jTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n                {null, null, null, null},\n                {null, null, null, null},\n                {null, null, null, null},\n                {null, null, null, null}\n            },\n            new String [] {\n                \"Title 1\", \"Title 2\", \"Title 3\", \"Title 4\"\n            }\n        ));\n        jTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);\n        jScrollPane.setViewportView(jTable);\n        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 395, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)\n        );\n        jTabbedPane1.addTab(\"table\", jPanel1);\n        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(0, 395, Short.MAX_VALUE)\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(0, 275, Short.MAX_VALUE)\n        );\n        jTabbedPane1.addTab(\"plot\", jPanel2);\n        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)\n            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)\n        );\n    }// </editor-fold>//GEN-END:initComponents\n    public void setModelData(int[] xi, int[] eta, double[][] v) {\n        this.xi = xi;\n        this.eta = eta;\n        this.v = v;\n        String[] colnames = new String[xi.length+1];\n        Object [][] o = new Object[eta.length][xi.length+1];\n        colnames[0] = \"eta/xi\";\n        for (int i=1;i<=xi.length;i++) {\n            colnames[i] = String.valueOf(xi[i]);\n        }\n        for (int j=0;j<eta.length;j++) {\n            for (int i=1;i<=xi.length;i++) {\n                o[j][i] = String.valueOf(v[j][i]);\n            }\n        }\n        jTable = new JTable(o,colnames);\n    }\n    void setTableModel(AbstractTableModel tm) {\n        jTable.setModel(tm);\n        int cc = jTable.getColumnCount();\n        javax.swing.table.TableColumn tc = null;\n        for (int c=0;c<cc;c++) {\n            tc = jTable.getColumnModel().getColumn(c);\n            tc.setPreferredWidth(100);\n        }\n        jTable.validate();\n        jTable.repaint();\n        jScrollPane.validate();\n        jScrollPane.repaint();    \n    }\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JPanel jPanel2;\n    private javax.swing.JScrollPane jScrollPane;\n    private javax.swing.JTabbedPane jTabbedPane1;\n    private javax.swing.JTable jTable;\n    // End of variables declaration//GEN-END:variables\n"]], "pred": {"ppl": 1.1742091178894043, "ppl_lower": 1.4469956159591675, "ppl/lowercase_ppl": -2.3007553750990057, "ppl/zlib": 0.00012940759855811066, "Min_5.0% Prob": 2.897152405159146, "Min_10.0% Prob": 1.5761453060104567, "Min_20.0% Prob": 0.8042013663159427, "Min_30.0% Prob": 0.5367563773291657, "Min_40.0% Prob": 0.4016581805938659, "Min_50.0% Prob": 0.3214977365201142, "Min_60.0% Prob": 0.2680055390016307}}
{"hexsha": "67945b4b78eef54af2decc2a519ec0a79292bd3a", "ext": "java", "lang": "Java", "content": "public class SearchCriteriaNode extends DefaultMutableTreeNode {\r\n\r\n    private boolean _isEdited = false;\r\n    private boolean _isMergeCriterionNode = false;\r\n    private Table _table = null;\r\n    private int _sourceColNum = -1;\r\n\r\n    public SearchCriteriaNode(CriterionValue val) {\r\n        super(val);\r\n    }\r\n\r\n    public void setEdited(boolean b) {\r\n        _isEdited = b;\r\n    }\r\n\r\n    public boolean getEdited() {\r\n        return _isEdited;\r\n    }\r\n\r\n    public boolean isEdited() {\r\n        return getEdited();\r\n    }\r\n\r\n    public List getPropertyNodes() {\r\n        List propNodes = new ArrayList();\r\n        if (children != null) {\r\n            for (Iterator i = children.iterator(); i.hasNext();) {\r\n                SearchCriteriaNode child = (SearchCriteriaNode) i.next();\r\n                if (((CriterionValue) child.getUserObject()).getType() != CriterionValue.OBJECT_TYPE) {\r\n                    propNodes.add(child);\r\n                }\r\n            }\r\n        }\r\n        return propNodes;\r\n    }\r\n\r\n    public List getObjectNodes() {\r\n        List objNodes = new ArrayList();\r\n        if (children != null) {\r\n            for (Iterator i = children.iterator(); i.hasNext();) {\r\n                SearchCriteriaNode child = (SearchCriteriaNode) i.next();\r\n                if (((CriterionValue) child.getUserObject()).getType() == CriterionValue.OBJECT_TYPE) {\r\n                    objNodes.add(child);\r\n                }\r\n            }\r\n        }\r\n        return objNodes;\r\n    }\r\n\r\n    public boolean isProperty() {\r\n        return ((CriterionValue) userObject).getType() != CriterionValue.OBJECT_TYPE;\r\n    }\r\n\r\n    public boolean isObject() {\r\n        return ((CriterionValue) userObject).getType() == CriterionValue.OBJECT_TYPE;\r\n    }\r\n\r\n    public void setIsMergeCriterionNode(boolean b) {\r\n        _isMergeCriterionNode = b;\r\n    }\r\n\r\n    public boolean getIsMergeCriterionNode() {\r\n        return _isMergeCriterionNode;\r\n    }\r\n\r\n    public boolean isMergeCriterionNode() {\r\n        return getIsMergeCriterionNode();\r\n    }\r\n\r\n    public String getObjectName() {\r\n        return ((CriterionValue) userObject).getObjectName();\r\n    }\r\n\r\n    public String getPropertyName() {\r\n        return ((CriterionValue) userObject).getPropertyName();\r\n    }\r\n\r\n    public void setTable(Table t) {\r\n        _table = t;\r\n    }\r\n\r\n    public Table getTable() {\r\n        return _table;\r\n    }\r\n\r\n    public void setSourceColumnNumber(int n) {\r\n        _sourceColNum = n;\r\n    }\r\n\r\n    public int getSourceColumnNumber() {\r\n        return _sourceColNum;\r\n    }\r\n\r\n    public String getId() {\r\n        return ((CriterionValue) userObject).getId();\r\n    }\r\n\r\n    public String toXML() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        boolean empty = true;\r\n        CriterionValue val = (CriterionValue) userObject;\r\n        if (val.getType() == CriterionValue.OBJECT_TYPE) {\r\n            // then this is an object node\r\n            if (userObject != null\r\n                    && ((CriterionValue) userObject).isSelectAll()) {\r\n                empty = false;\r\n            }\r\n            else if (children != null) {\r\n                for (Iterator i = children.iterator(); i.hasNext();) {\r\n                    if (!((SearchCriteriaNode) i.next()).isEmpty()) {\r\n                        empty = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // then this is a property node\r\n            List vals = val.getValues();\r\n            if (vals != null && vals.size() > 0) {\r\n                empty = false;\r\n            }\r\n        }\r\n        return empty;\r\n    }\r\n\r\n    public SearchCriteriaNode findNonEmptyParent() {\r\n        SearchCriteriaNode theParent = null;\r\n        if (parent != null) {\r\n            SearchCriteriaNode aParent = (SearchCriteriaNode) parent;\r\n            if (!aParent.isEmpty()) {\r\n                theParent = aParent.findNonEmptyParent();\r\n            }\r\n        }\r\n        return theParent;\r\n    }\r\n\r\n    public void removeEmptyChildren() {\r\n        for (Enumeration nodes = postorderEnumeration(); nodes.hasMoreElements();) {\r\n            SearchCriteriaNode node = (SearchCriteriaNode) nodes.nextElement();\r\n            if (node.isEmpty()) {\r\n                node.removeFromParent();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean isPathItem() {\r\n        boolean isPI = false;\r\n        if (isObject() && parent != null) {\r\n            CriterionValue cv = (CriterionValue) ((DefaultMutableTreeNode) parent).getUserObject();\r\n            if (cv != null) {\r\n                SearchableObject so = cv.getSearchableObject();\r\n                List assocs = so.getAssociations();\r\n                search: for (Iterator i = assocs.iterator(); i.hasNext();) {\r\n                    Association assoc = (Association) i.next();\r\n                    List pis = assoc.getPathItems();\r\n                    for (Iterator j = pis.iterator(); j.hasNext();) {\r\n                        PathItem pi = (PathItem) j.next();\r\n                        MessageLog.printInfo(\"pi.getClassname() = \"\r\n                                + pi.getClassname()\r\n                                + \", this.getObjectName() = \"\r\n                                + this.getObjectName());\r\n                        if (pi.getClassname().equals(this.getObjectName())) {\r\n                            isPI = true;\r\n                            break search;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return isPI;\r\n    }\r\n\r\n    public SearchCriteriaNode getPathEndPointNode() {\r\n        SearchCriteriaNode endPointNode = null;\r\n        if (!this.isPathItem()) {\r\n            endPointNode = this;\r\n        }\r\n        else {\r\n            if (children != null) {\r\n                for (Iterator i = children.iterator(); i.hasNext();) {\r\n                    endPointNode = ((SearchCriteriaNode) i.next()).getPathEndPointNode();\r\n                }\r\n            }\r\n        }\r\n        return endPointNode;\r\n    }\r\n\r\n    public SearchCriteriaNode getPathBeginPointNode() {\r\n        SearchCriteriaNode beginPointNode = null;\r\n        if (!this.isPathItem()) {\r\n            beginPointNode = this;\r\n        }\r\n        else {\r\n            if (parent != null) {\r\n                beginPointNode = ((SearchCriteriaNode) parent).getPathBeginPointNode();\r\n            }\r\n        }\r\n        return beginPointNode;\r\n    }\r\n\r\n    public boolean isOntological() {\r\n        boolean isOnt = false;\r\n        if (userObject != null) {\r\n            if (((CriterionValue) userObject).getType() == CriterionValue.ONTOLOGICAL_TYPE) {\r\n                isOnt = true;\r\n            }\r\n        }\r\n        return isOnt;\r\n    }\r\n}", "class_id": 0, "repo": "NCIP/cabio", "file": "software/biogopher/src/gov/nih/nci/caBIOApp/ui/SearchCriteriaNode.java", "last_update_at": "2018-06-19T16:23:24+00:00", "question_id": "67945b4b78eef54af2decc2a519ec0a79292bd3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SearchCriteriaNode extends DefaultMutableTreeNode {\r\n\r\n    private boolean _isEdited = false;\r\n    private boolean _isMergeCriterionNode = false;\r\n    private Table _table = null;\r\n    private int _sourceColNum = -1;\r\n\r\n    public SearchCriteriaNode(CriterionValue val) {\r\n        super(val);\r\n    }\r\n\r\n    public void setEdited(boolean b) {\r\n        _isEdited = b;\r\n    }\r\n\r\n    public boolean getEdited() {\r\n        return _isEdited;\r\n    }\r\n\r\n    public boolean isEdited() {\r\n        return getEdited();\r\n    }\r\n\r\n    public List getPropertyNodes() {\r\n        List propNodes = new ArrayList();\r\n        if (children != null) {\r\n            for (Iterator i = children.iterator(); i.hasNext();) {\r\n                SearchCriteriaNode child = (SearchCriteriaNode) i.next();\r\n                if (((CriterionValue) child.getUserObject()).getType() != CriterionValue.OBJECT_TYPE) {\r\n                    propNodes.add(child);\r\n                }\r\n            }\r\n        }\r\n        return propNodes;\r\n    }\r\n\r\n    public List getObjectNodes() {\r\n        List objNodes = new ArrayList();\r\n        if (children != null) {\r\n            for (Iterator i = children.iterator(); i.hasNext();) {\r\n                SearchCriteriaNode child = (SearchCriteriaNode) i.next();\r\n                if (((CriterionValue) child.getUserObject()).getType() == CriterionValue.OBJECT_TYPE) {\r\n                    objNodes.add(child);\r\n                }\r\n            }\r\n        }\r\n        return objNodes;\r\n    }\r\n\r\n    public boolean isProperty() {\r\n        return ((CriterionValue) userObject).getType() != CriterionValue.OBJECT_TYPE;\r\n    }\r\n\r\n    public boolean isObject() {\r\n        return ((CriterionValue) userObject).getType() == CriterionValue.OBJECT_TYPE;\r\n    }\r\n\r\n    public void setIsMergeCriterionNode(boolean b) {\r\n        _isMergeCriterionNode = b;\r\n    }\r\n\r\n    public boolean getIsMergeCriterionNode() {\r\n        return _isMergeCriterionNode;\r\n    }\r\n\r\n    public boolean isMergeCriterionNode() {\r\n        return getIsMergeCriterionNode();\r\n    }\r\n\r\n    public String getObjectName() {\r\n        return ((CriterionValue) userObject).getObjectName();\r\n    }\r\n\r\n    public String getPropertyName() {\r\n        return ((CriterionValue) userObject).getPropertyName();\r\n    }\r\n\r\n    public void setTable(Table t) {\r\n        _table = t;\r\n    }\r\n\r\n    public Table getTable() {\r\n        return _table;\r\n    }\r\n\r\n    public void setSourceColumnNumber(int n) {\r\n        _sourceColNum = n;\r\n    }\r\n\r\n    public int getSourceColumnNumber() {\r\n        return _sourceColNum;\r\n    }\r\n\r\n    public String getId() {\r\n        return ((CriterionValue) userObject).getId();\r\n    }\r\n\r\n    public String toXML() {\r\n        return null;\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        boolean empty = true;\r\n        CriterionValue val = (CriterionValue) userObject;\r\n        if (val.getType() == CriterionValue.OBJECT_TYPE) {\r\n            // then this is an object node\r\n            if (userObject != null\r\n                    && ((CriterionValue) userObject).isSelectAll()) {\r\n                empty = false;\r\n            }\r\n            else if (children != null) {\r\n                for (Iterator i = children.iterator(); i.hasNext();) {\r\n                    if (!((SearchCriteriaNode) i.next()).isEmpty()) {\r\n                        empty = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // then this is a property node\r\n            List vals = val.getValues();\r\n            if (vals != null && vals.size() > 0) {\r\n                empty = false;\r\n            }\r\n        }\r\n        return empty;\r\n    }\r\n\r\n    public SearchCriteriaNode findNonEmptyParent() {\r\n        SearchCriteriaNode theParent = null;\r\n        if (parent != null) {\r\n            SearchCriteriaNode aParent = (SearchCriteriaNode) parent;\r\n            if (!aParent.isEmpty()) {\r\n                theParent = aParent.findNonEmptyParent();\r\n            }\r\n        }\r\n        return theParent;\r\n    }\r\n\r\n    public void removeEmptyChildren() {\r\n        for (Enumeration nodes = postorderEnumeration(); nodes.hasMoreElements();) {\r\n            SearchCriteriaNode node = (SearchCriteriaNode) nodes.nextElement();\r\n            if (node.isEmpty()) {\r\n                node.removeFromParent();\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean isPathItem() {\r\n        boolean isPI = false;\r\n        if (isObject() && parent != null) {\r\n            CriterionValue cv = (CriterionValue) ((DefaultMutableTreeNode) parent).getUserObject();\r\n            if (cv != null) {\r\n                SearchableObject so = cv.getSearchableObject();\r\n                List assocs = so.getAssociations();\r\n                search: for (Iterator i = assocs.iterator(); i.hasNext();) {\r\n                    Association assoc = (Association) i.next();\r\n                    List pis = assoc.getPathItems();\r\n                    for (Iterator j = pis.iterator(); j.hasNext();) {\r\n                        PathItem pi = (PathItem) j.next();\r\n                        MessageLog.printInfo(\"pi.getClassname() = \"\r\n                                + pi.getClassname()\r\n                                + \", this.getObjectName() = \"\r\n                                + this.getObjectName());\r\n                        if (pi.getClassname().equals(this.getObjectName())) {\r\n                            isPI = true;\r\n                            break search;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return isPI;\r\n    }\r\n\r\n    public SearchCriteriaNode getPathEndPointNode() {\r\n        SearchCriteriaNode endPointNode = null;\r\n        if (!this.isPathItem()) {\r\n            endPointNode = this;\r\n        }\r\n        else {\r\n            if (children != null) {\r\n                for (Iterator i = children.iterator(); i.hasNext();) {\r\n                    endPointNode = ((SearchCriteriaNode) i.next()).getPathEndPointNode();\r\n                }\r\n            }\r\n        }\r\n        return endPointNode;\r\n    }\r\n\r\n    public SearchCriteriaNode getPathBeginPointNode() {\r\n        SearchCriteriaNode beginPointNode = null;\r\n        if (!this.isPathItem()) {\r\n            beginPointNode = this;\r\n        }\r\n        else {\r\n            if (parent != null) {\r\n                beginPointNode = ((SearchCriteriaNode) parent).getPathBeginPointNode();\r\n            }\r\n        }\r\n        return beginPointNode;\r\n    }\r\n\r\n    public boolean isOntological() {\r\n        boolean isOnt = false;\r\n        if (userObject != null) {\r\n            if (((CriterionValue) userObject).getType() == CriterionValue.ONTOLOGICAL_TYPE) {\r\n                isOnt = true;\r\n            }\r\n        }\r\n        return isOnt;\r\n    }\r\n"]], "pred": {"ppl": 1.4515454769134521, "ppl_lower": 1.554565191268921, "ppl/lowercase_ppl": -1.184008979885534, "ppl/zlib": 0.00029180018400076324, "Min_5.0% Prob": 4.800113869648354, "Min_10.0% Prob": 3.2086166739463806, "Min_20.0% Prob": 1.8114484876540362, "Min_30.0% Prob": 1.2359984008826657, "Min_40.0% Prob": 0.9296791708816416, "Min_50.0% Prob": 0.7454319102361565, "Min_60.0% Prob": 0.6217210613554617}}
{"hexsha": "4a3b2ea03318813390aab74120fed8575db66981", "ext": "java", "lang": "Java", "content": "public class PotionNamePool {\n  \n  public static List<String> list = new ArrayList<String>();\n  \n  public static void clear() {\n    list.clear();\n    list.add(_(\"redPotion\"));\n    list.add(_(\"greenPotion\"));\n    list.add(_(\"bluePotion\"));\n    list.add(_(\"purplePotion\"));\n    list.add(_(\"yellowPotion\"));\n  }\n  \n  public static String get() {\n    return list.remove(RandomProvider.getRandom().nextInt(list.size()));\n  }\n\n}", "class_id": 0, "repo": "yoo2001818/RogueBox", "file": "src/main/java/kr/kkiro/roguebox/game/item/PotionNamePool.java", "last_update_at": "2018-03-09T15:25:22+00:00", "question_id": "4a3b2ea03318813390aab74120fed8575db66981", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PotionNamePool {\n  public static List<String> list = new ArrayList<String>();\n  public static void clear() {\n    list.clear();\n    list.add(_(\"redPotion\"));\n    list.add(_(\"greenPotion\"));\n    list.add(_(\"bluePotion\"));\n    list.add(_(\"purplePotion\"));\n    list.add(_(\"yellowPotion\"));\n  }\n  public static String get() {\n    return list.remove(RandomProvider.getRandom().nextInt(list.size()));\n  }\n"]], "pred": {"ppl": 2.438415050506592, "ppl_lower": 2.9530489444732666, "ppl/lowercase_ppl": -1.2148317635121155, "ppl/zlib": 0.00445674129389475, "Min_5.0% Prob": 8.483477036158243, "Min_10.0% Prob": 6.313099200908955, "Min_20.0% Prob": 4.07725222463961, "Min_30.0% Prob": 2.9293276980519294, "Min_40.0% Prob": 2.213117491453886, "Min_50.0% Prob": 1.7920381039269824, "Min_60.0% Prob": 1.4844752067562055}}
{"hexsha": "ba62e71cfec2c5fc8d36a69dc8937f018b88fe62", "ext": "java", "lang": "Java", "content": "@Path(\"/\")\n@Api(value = \"/kb\", description = \"Operations about knowledge base\", basePath = \"kb\")\npublic class KnowledgeBaseResource {\n    private KnowledgeBaseManager kbManager;\n    private NfpManager nfpManager;\n    private Logger log = LoggerFactory.getLogger(KnowledgeBaseResource.class);\n\n    @Inject\n    KnowledgeBaseResource(KnowledgeBaseManager knowledgeBaseManager, NfpManager nfpManager) {\n        this.kbManager = knowledgeBaseManager;\n        this.nfpManager = nfpManager;\n    }\n\n    @DELETE\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Clear all knowledge base\",\n            notes = \"BE CAREFUL! You can lose all your data. It returns a message which confirms that the knowledge base is empty.\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Knowledge base cleaned. All the concepts are deleted.\"),\n                    @ApiResponse(code = 304, message = \"Knowledge base could not be cleared.\"),\n                    @ApiResponse(code = 403, message = \"You have not got the appropriate permissions for clearing the knowledge base\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response clearServices() {\n        if (kbManager.clearKnowledgeBase()) {\n            return Response.status(Response.Status.OK).entity(createJsonMessage(\"Knowledge base cleaned. All the concepts are deleted.\")).build();\n        } else {\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createJsonMessage(\"Internal error\")).build();\n        }\n\n    }\n\n    @GET\n    @Path(\"subclasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Get subclasses of a concept\",\n            notes = \"It returns subclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of subclasses\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getSubclasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri,\n            @ApiParam(value = \"If this parameter is set as TRUE, the function will return only direct subclasses\", allowableValues = \"true,false\")\n            @QueryParam(\"direct\") String direct) {\n        try {\n            Set<URI> subclasses = kbManager.listSubClasses(new URI(uri), Boolean.parseBoolean(direct));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(subclasses))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n\n\n    @GET\n    @Path(\"superclasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Get superclasses of a concept\",\n            notes = \"It returns superclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of superclasses\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getSuperclasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri,\n            @ApiParam(value = \"If this parameter is set as TRUE, the function will return only direct superclasses\", allowableValues = \"true,false\")\n            @QueryParam(\"direct\") String direct) {\n        try {\n            Set<URI> classes = kbManager.listSuperClasses(new URI(uri), Boolean.parseBoolean(direct));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n\n    @GET\n    @Path(\"equivalentClasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List classes equivalent to a specific concept\",\n            notes = \"It returns a list of classes\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of equivalent classes\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getEquivalentClasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri\n    ) {\n        try {\n            Set<URI> classes = kbManager.listEquivalentClasses(new URI(uri));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n\n    @GET\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List concepts in the knowledge base\",\n            notes = \"It returns a list of concepts\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of concepts\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response listConcepts(\n            @ApiParam(value = \"URI of the model. If empty it will return all the concepts in the Knowledge Base\")\n            @QueryParam(\"uri\") String uri\n    ) {\n        try {\n            Set<URI> classes;\n            if (uri != null && !uri.equals(\"\")) {\n                classes = kbManager.listConcepts(new URI(uri));\n            } else {\n                classes = kbManager.listConcepts(null);\n            }\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n\n    @GET\n    @Path(\"linkedConcepts\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List concepts linked by a chain of properties\",\n            notes = \"It returns subclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Map of linked concepts\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response listLinkedConcepts(\n            @ApiParam(value = \"Chain of properties that specify the link between concepts\", required = true)\n            @QueryParam(\"property\") List<String> properties,\n            @ApiParam(value = \"Specify which property of the chain is transitive (e.g., rdfs:subClassOf)\")\n            @QueryParam(\"transitiveProperty\") List<String> transitiveProperties,\n            @ApiParam(value = \"Class of the source concept\")\n            @QueryParam(\"sourceClass\") String sourceClass,\n            @ApiParam(value = \"Class of the source concept\")\n            @QueryParam(\"targetClass\") String targetClass) {\n        try {\n            URI sourceClassUri = null;\n            URI targetClassUri = null;\n            Multimap<KnowledgeBaseResult, KnowledgeBaseResult> r = HashMultimap.create();\n            if (sourceClass != null) {\n                sourceClassUri = new URI(sourceClass);\n            }\n            if (targetClass != null) {\n                targetClassUri = new URI(targetClass);\n            }\n            List<URI> propertyUris = Lists.newArrayList();\n            for (String property : properties) {\n                propertyUris.add(new URI(property));\n            }\n            Set<URI> transitivePropertyUris = Sets.newHashSet();\n            for (String transitiveProperty : transitiveProperties) {\n                transitivePropertyUris.add(new URI(transitiveProperty));\n            }\n            Multimap<URI, URI> linkedConcepts = kbManager.listLinkedConcepts(propertyUris, sourceClassUri, targetClassUri, transitivePropertyUris);\n            createResultSet(linkedConcepts.keySet());\n            createResultSet(linkedConcepts.values());\n            for (URI source : linkedConcepts.keySet()) {\n                r.putAll(createResultSet(source), createResultSet(linkedConcepts.get(source)));\n            }\n\n            return Response.status(Response.Status.OK).entity(createJsonMessage(sourceClassUri, targetClassUri, propertyUris, r)).build();\n        } catch (Exception e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n\n    @GET\n    @Path(\"models\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List models available in the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of models\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getLoadedModels() {\n        Set<URI> r = kbManager.getLoadedModels();\n        return Response.status(Response.Status.OK).entity(createJsonMessage(r)).build();\n    }\n\n    @POST\n    @Path(\"models\")\n    @Consumes({\"application/rdf+xml\", \"text/turtle\", \"text/n3\", \"text/rdf+n3\", \"application/n-triples\"})\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Upload a model in the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Model uploaded\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response uploadModel(@ApiParam(value = \"URI of the remote ontology or URI that identifies a local model\", required = true)\n                                @QueryParam(\"uri\") String uri,\n                                @ApiParam(value = \"Ontology to by uploaded in the knowledge base\")\n                                String ontology,\n                                @ApiParam(value = \"Force the upload of the model\", allowableValues = \"true,false\")\n                                @QueryParam(\"forceUpdate\") String forceUpdate,\n                                @HeaderParam(\"Content-Type\") String contentType) {\n\n        try {\n            Model model = ModelFactory.createDefaultModel();\n            if (ontology == null || ontology.equals(\"\")) {\n                model.read(uri);\n            } else {\n                String lang = \"RDF/XML\";\n                if (contentType.equals(\"text/turtle\")) {\n                    lang = \"TTL\";\n                } else if (contentType.equals(\"text/n3\") || contentType.equals(\"text/rdf+n3\")) {\n                    lang = \"N3\";\n                } else if (contentType.equals(\"application/n-triples\")) {\n                    lang = \"N-TRIPLE\";\n                }\n\n                model.read(new ByteArrayInputStream(ontology.getBytes(StandardCharsets.UTF_8)), uri, lang);\n            }\n\n            kbManager.uploadModel(new URI(uri), model, Boolean.parseBoolean(forceUpdate));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(\"Model uploaded with success\")).build();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n\n    }\n\n    @DELETE\n    @Path(\"models\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Delete a model from the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of models\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response deleteModel(@ApiParam(value = \"URI of the remote ontology or URI that identifies a local model\", required = true)\n                                @QueryParam(\"uri\") String uri) {\n        try {\n            if (kbManager.deleteModel(new URI(uri))) {\n                return Response.status(Response.Status.OK).entity(createJsonMessage(\"Model deleted with success\")).build();\n            }\n            return Response.status(Response.Status.NOT_FOUND).entity(createJsonMessage(\"Model not found\")).build();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n\n    }\n\n    private String createJsonMessage(String text) {\n        JsonObject message = new JsonObject();\n        message.add(\"message\", new JsonPrimitive(text));\n        return message.toString();\n    }\n\n    private String createJsonMessage(Object o) {\n        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        return gson.toJson(o);\n    }\n\n    private String createJsonMessage(URI source, URI target, List<URI> properties, Multimap<KnowledgeBaseResult, KnowledgeBaseResult> map) {\n        Gson gson = new Gson();\n        JsonObject message = new JsonObject();\n        if (source != null) {\n            message.add(\"source\", gson.toJsonTree(source));\n        }\n        if (target != null) {\n            message.add(\"target\", gson.toJsonTree(target));\n        }\n        if (properties != null) {\n            message.add(\"properties\", gson.toJsonTree(properties));\n        }\n        JsonArray resultList = new JsonArray();\n        message.add(\"result\", resultList);\n        for (KnowledgeBaseResult s : map.keySet()) {\n            JsonObject entry = new JsonObject();\n            resultList.add(entry);\n            JsonElement sJson = gson.toJsonTree(s);\n            entry.add(\"source\", sJson);\n            JsonElement tJson = gson.toJsonTree(map.get(s));\n            entry.add(\"target\", tJson);\n        }\n        return message.toString();\n    }\n\n    private Set<KnowledgeBaseResult> createResultSet(Collection<URI> uris) {\n        Set<KnowledgeBaseResult> r = Sets.newLinkedHashSet();\n        Map<URI, Object> labels = nfpManager.getPropertyValueOfResources(new HashSet<URI>(uris), URI.create(RDFS.label.getURI()), String.class);\n        for (URI uri : uris) {\n            r.add(new KnowledgeBaseResult(uri, labels.get(uri)));\n        }\n        return r;\n    }\n\n    private KnowledgeBaseResult createResultSet(URI uri) {\n        Object label = nfpManager.getPropertyValue(uri, URI.create(RDFS.label.getURI()), String.class);\n        return new KnowledgeBaseResult(uri, label);\n    }\n\n}", "class_id": 0, "repo": "kmi/iserve", "file": "iserve-rest/src/main/java/uk/ac/open/kmi/iserve/rest/sal/resource/KnowledgeBaseResource.java", "last_update_at": "2018-11-15T07:06:44+00:00", "question_id": "ba62e71cfec2c5fc8d36a69dc8937f018b88fe62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Path(\"/\")\n@Api(value = \"/kb\", description = \"Operations about knowledge base\", basePath = \"kb\")\npublic class KnowledgeBaseResource {\n    private KnowledgeBaseManager kbManager;\n    private NfpManager nfpManager;\n    private Logger log = LoggerFactory.getLogger(KnowledgeBaseResource.class);\n    @Inject\n    KnowledgeBaseResource(KnowledgeBaseManager knowledgeBaseManager, NfpManager nfpManager) {\n        this.kbManager = knowledgeBaseManager;\n        this.nfpManager = nfpManager;\n    }\n    @DELETE\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Clear all knowledge base\",\n            notes = \"BE CAREFUL! You can lose all your data. It returns a message which confirms that the knowledge base is empty.\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Knowledge base cleaned. All the concepts are deleted.\"),\n                    @ApiResponse(code = 304, message = \"Knowledge base could not be cleared.\"),\n                    @ApiResponse(code = 403, message = \"You have not got the appropriate permissions for clearing the knowledge base\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response clearServices() {\n        if (kbManager.clearKnowledgeBase()) {\n            return Response.status(Response.Status.OK).entity(createJsonMessage(\"Knowledge base cleaned. All the concepts are deleted.\")).build();\n        } else {\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createJsonMessage(\"Internal error\")).build();\n        }\n    }\n    @GET\n    @Path(\"subclasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Get subclasses of a concept\",\n            notes = \"It returns subclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of subclasses\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getSubclasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri,\n            @ApiParam(value = \"If this parameter is set as TRUE, the function will return only direct subclasses\", allowableValues = \"true,false\")\n            @QueryParam(\"direct\") String direct) {\n        try {\n            Set<URI> subclasses = kbManager.listSubClasses(new URI(uri), Boolean.parseBoolean(direct));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(subclasses))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @GET\n    @Path(\"superclasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Get superclasses of a concept\",\n            notes = \"It returns superclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of superclasses\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getSuperclasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri,\n            @ApiParam(value = \"If this parameter is set as TRUE, the function will return only direct superclasses\", allowableValues = \"true,false\")\n            @QueryParam(\"direct\") String direct) {\n        try {\n            Set<URI> classes = kbManager.listSuperClasses(new URI(uri), Boolean.parseBoolean(direct));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @GET\n    @Path(\"equivalentClasses\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List classes equivalent to a specific concept\",\n            notes = \"It returns a list of classes\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of equivalent classes\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getEquivalentClasses(\n            @ApiParam(value = \"URI of the concept (e.g., http://schema.org/Action)\", required = true)\n            @QueryParam(\"uri\") String uri\n    ) {\n        try {\n            Set<URI> classes = kbManager.listEquivalentClasses(new URI(uri));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @GET\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List concepts in the knowledge base\",\n            notes = \"It returns a list of concepts\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of concepts\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response listConcepts(\n            @ApiParam(value = \"URI of the model. If empty it will return all the concepts in the Knowledge Base\")\n            @QueryParam(\"uri\") String uri\n    ) {\n        try {\n            Set<URI> classes;\n            if (uri != null && !uri.equals(\"\")) {\n                classes = kbManager.listConcepts(new URI(uri));\n            } else {\n                classes = kbManager.listConcepts(null);\n            }\n            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();\n        } catch (URISyntaxException e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @GET\n    @Path(\"linkedConcepts\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List concepts linked by a chain of properties\",\n            notes = \"It returns subclasses of a specific concept\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Map of linked concepts\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response listLinkedConcepts(\n            @ApiParam(value = \"Chain of properties that specify the link between concepts\", required = true)\n            @QueryParam(\"property\") List<String> properties,\n            @ApiParam(value = \"Specify which property of the chain is transitive (e.g., rdfs:subClassOf)\")\n            @QueryParam(\"transitiveProperty\") List<String> transitiveProperties,\n            @ApiParam(value = \"Class of the source concept\")\n            @QueryParam(\"sourceClass\") String sourceClass,\n            @ApiParam(value = \"Class of the source concept\")\n            @QueryParam(\"targetClass\") String targetClass) {\n        try {\n            URI sourceClassUri = null;\n            URI targetClassUri = null;\n            Multimap<KnowledgeBaseResult, KnowledgeBaseResult> r = HashMultimap.create();\n            if (sourceClass != null) {\n                sourceClassUri = new URI(sourceClass);\n            }\n            if (targetClass != null) {\n                targetClassUri = new URI(targetClass);\n            }\n            List<URI> propertyUris = Lists.newArrayList();\n            for (String property : properties) {\n                propertyUris.add(new URI(property));\n            }\n            Set<URI> transitivePropertyUris = Sets.newHashSet();\n            for (String transitiveProperty : transitiveProperties) {\n                transitivePropertyUris.add(new URI(transitiveProperty));\n            }\n            Multimap<URI, URI> linkedConcepts = kbManager.listLinkedConcepts(propertyUris, sourceClassUri, targetClassUri, transitivePropertyUris);\n            createResultSet(linkedConcepts.keySet());\n            createResultSet(linkedConcepts.values());\n            for (URI source : linkedConcepts.keySet()) {\n                r.putAll(createResultSet(source), createResultSet(linkedConcepts.get(source)));\n            }\n            return Response.status(Response.Status.OK).entity(createJsonMessage(sourceClassUri, targetClassUri, propertyUris, r)).build();\n        } catch (Exception e) {\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @GET\n    @Path(\"models\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"List models available in the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of models\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response getLoadedModels() {\n        Set<URI> r = kbManager.getLoadedModels();\n        return Response.status(Response.Status.OK).entity(createJsonMessage(r)).build();\n    }\n    @POST\n    @Path(\"models\")\n    @Consumes({\"application/rdf+xml\", \"text/turtle\", \"text/n3\", \"text/rdf+n3\", \"application/n-triples\"})\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Upload a model in the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"Model uploaded\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response uploadModel(@ApiParam(value = \"URI of the remote ontology or URI that identifies a local model\", required = true)\n                                @QueryParam(\"uri\") String uri,\n                                @ApiParam(value = \"Ontology to by uploaded in the knowledge base\")\n                                String ontology,\n                                @ApiParam(value = \"Force the upload of the model\", allowableValues = \"true,false\")\n                                @QueryParam(\"forceUpdate\") String forceUpdate,\n                                @HeaderParam(\"Content-Type\") String contentType) {\n        try {\n            Model model = ModelFactory.createDefaultModel();\n            if (ontology == null || ontology.equals(\"\")) {\n                model.read(uri);\n            } else {\n                String lang = \"RDF/XML\";\n                if (contentType.equals(\"text/turtle\")) {\n                    lang = \"TTL\";\n                } else if (contentType.equals(\"text/n3\") || contentType.equals(\"text/rdf+n3\")) {\n                    lang = \"N3\";\n                } else if (contentType.equals(\"application/n-triples\")) {\n                    lang = \"N-TRIPLE\";\n                }\n                model.read(new ByteArrayInputStream(ontology.getBytes(StandardCharsets.UTF_8)), uri, lang);\n            }\n            kbManager.uploadModel(new URI(uri), model, Boolean.parseBoolean(forceUpdate));\n            return Response.status(Response.Status.OK).entity(createJsonMessage(\"Model uploaded with success\")).build();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    @DELETE\n    @Path(\"models\")\n    @Produces({\"application/json\"})\n    @ApiOperation(value = \"Delete a model from the knowledge base\",\n            notes = \"It returns a list of models\")\n    @ApiResponses(\n            value = {\n                    @ApiResponse(code = 200, message = \"List of models\"),\n                    @ApiResponse(code = 400, message = \"Malformed input\"),\n                    @ApiResponse(code = 500, message = \"Internal error\")})\n    public Response deleteModel(@ApiParam(value = \"URI of the remote ontology or URI that identifies a local model\", required = true)\n                                @QueryParam(\"uri\") String uri) {\n        try {\n            if (kbManager.deleteModel(new URI(uri))) {\n                return Response.status(Response.Status.OK).entity(createJsonMessage(\"Model deleted with success\")).build();\n            }\n            return Response.status(Response.Status.NOT_FOUND).entity(createJsonMessage(\"Model not found\")).build();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();\n        }\n    }\n    private String createJsonMessage(String text) {\n        JsonObject message = new JsonObject();\n        message.add(\"message\", new JsonPrimitive(text));\n        return message.toString();\n    }\n    private String createJsonMessage(Object o) {\n        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n        return gson.toJson(o);\n    }\n    private String createJsonMessage(URI source, URI target, List<URI> properties, Multimap<KnowledgeBaseResult, KnowledgeBaseResult> map) {\n        Gson gson = new Gson();\n        JsonObject message = new JsonObject();\n        if (source != null) {\n            message.add(\"source\", gson.toJsonTree(source));\n        }\n        if (target != null) {\n            message.add(\"target\", gson.toJsonTree(target));\n        }\n        if (properties != null) {\n            message.add(\"properties\", gson.toJsonTree(properties));\n        }\n        JsonArray resultList = new JsonArray();\n        message.add(\"result\", resultList);\n        for (KnowledgeBaseResult s : map.keySet()) {\n            JsonObject entry = new JsonObject();\n            resultList.add(entry);\n            JsonElement sJson = gson.toJsonTree(s);\n            entry.add(\"source\", sJson);\n            JsonElement tJson = gson.toJsonTree(map.get(s));\n            entry.add(\"target\", tJson);\n        }\n        return message.toString();\n    }\n    private Set<KnowledgeBaseResult> createResultSet(Collection<URI> uris) {\n        Set<KnowledgeBaseResult> r = Sets.newLinkedHashSet();\n        Map<URI, Object> labels = nfpManager.getPropertyValueOfResources(new HashSet<URI>(uris), URI.create(RDFS.label.getURI()), String.class);\n        for (URI uri : uris) {\n            r.add(new KnowledgeBaseResult(uri, labels.get(uri)));\n        }\n        return r;\n    }\n    private KnowledgeBaseResult createResultSet(URI uri) {\n        Object label = nfpManager.getPropertyValue(uri, URI.create(RDFS.label.getURI()), String.class);\n        return new KnowledgeBaseResult(uri, label);\n    }\n"]], "pred": {"ppl": 1.6156572103500366, "ppl_lower": 1.8162800073623657, "ppl/lowercase_ppl": -1.2439825721864046, "ppl/zlib": 0.00018331746858602947, "Min_5.0% Prob": 5.324681712131874, "Min_10.0% Prob": 3.7696297203793243, "Min_20.0% Prob": 2.2921217411172154, "Min_30.0% Prob": 1.5839022230478674, "Min_40.0% Prob": 1.1955625300083883, "Min_50.0% Prob": 0.9592314120500536, "Min_60.0% Prob": 0.8003272853490135}}
{"hexsha": "caf5bc02b62aee2157362c589a423e0fac3df0df", "ext": "java", "lang": "Java", "content": "public class MovieSmallImg{\n\t\n\tpublic String movieSmallImg(String keyword,String mCode) throws DetailViewException,Exception {\n\t\tString result=new PosterAPI().getPosterResult(keyword);\n\t\t\n\t\tMovieService dvs = new MovieService();\n\t\tString page = \"\";\n\n\t\tif (result.substring(61, 62).equals(\"1\") && !chkNum(result.substring(62, 63)))\n\t\t\tpage = dvs.getSmallImage(result,mCode);\n\t\telse\n\t\t\tpage = dvs.getPowerSmallImage(result, keyword,mCode);\n\t\t\n\t\treturn page;\n\t}\n\t\n\tprivate boolean chkNum(String s) {\n\t\ttry {\n\t\t\tInteger.parseInt(s);\n\t\t\treturn true;\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "Hc3Project/Semi3", "file": "semiProject_1105/src/com/kh/semi/common/MovieSmallImg.java", "last_update_at": "2018-11-22T14:31:38+00:00", "question_id": "caf5bc02b62aee2157362c589a423e0fac3df0df", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MovieSmallImg{\n\t\n\tpublic String movieSmallImg(String keyword,String mCode) throws DetailViewException,Exception {\n\t\tString result=new PosterAPI().getPosterResult(keyword);\n\t\t\n\t\tMovieService dvs = new MovieService();\n\t\tString page = \"\";\n\t\tif (result.substring(61, 62).equals(\"1\") && !chkNum(result.substring(62, 63)))\n\t\t\tpage = dvs.getSmallImage(result,mCode);\n\t\telse\n\t\t\tpage = dvs.getPowerSmallImage(result, keyword,mCode);\n\t\t\n\t\treturn page;\n\t}\n\t\n\tprivate boolean chkNum(String s) {\n\t\ttry {\n\t\t\tInteger.parseInt(s);\n\t\t\treturn true;\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n"]], "pred": {"ppl": 3.681544303894043, "ppl_lower": 4.038407802581787, "ppl/lowercase_ppl": -1.0709858822812874, "ppl/zlib": 0.003913910846698568, "Min_5.0% Prob": 9.20204834504561, "Min_10.0% Prob": 7.2680847541145654, "Min_20.0% Prob": 5.210724561110787, "Min_30.0% Prob": 3.9671356159707774, "Min_40.0% Prob": 3.1392853771862774, "Min_50.0% Prob": 2.577389869612196, "Min_60.0% Prob": 2.169866191736166}}
{"hexsha": "10a0a4955734893361817a4dff40b79f385dbe75", "ext": "java", "lang": "Java", "content": "public class ToolchainProviderBuilder {\n  private final Map<String, Toolchain> toolchains = new HashMap<>();\n\n  public ToolchainProviderBuilder() {}\n\n  public ToolchainProviderBuilder withToolchain(NamedToolchain toolchain) {\n    toolchains.put(toolchain.getName(), toolchain.getToolchain());\n    return this;\n  }\n\n  public ToolchainProviderBuilder withToolchain(String name, Toolchain toolchain) {\n    toolchains.put(name, toolchain);\n    return this;\n  }\n\n  public ToolchainProvider build() {\n    return new SimpleToolchainProvider(toolchains);\n  }\n\n  private static class SimpleToolchainProvider extends BaseToolchainProvider {\n    private final ImmutableMap<String, Toolchain> toolchains;\n\n    private SimpleToolchainProvider(Map<String, Toolchain> toolchains) {\n      this.toolchains = ImmutableMap.copyOf(toolchains);\n    }\n\n    @Override\n    public Toolchain getByName(String toolchainName) {\n      return toolchains.get(toolchainName);\n    }\n\n    @Override\n    public boolean isToolchainPresent(String toolchainName) {\n      return toolchains.containsKey(toolchainName);\n    }\n\n    @Override\n    public boolean isToolchainCreated(String toolchainName) {\n      return isToolchainPresent(toolchainName);\n    }\n\n    @Override\n    public boolean isToolchainFailed(String toolchainName) {\n      return false;\n    }\n\n    @Override\n    public <T extends ToolchainWithCapability> Collection<String> getToolchainsWithCapability(\n        Class<T> capability) {\n      ImmutableList.Builder<String> featureSupportingToolchains = ImmutableList.builder();\n\n      for (Map.Entry<String, Toolchain> toolchainEntry : toolchains.entrySet()) {\n        if (capability.isAssignableFrom(toolchainEntry.getValue().getClass())) {\n          featureSupportingToolchains.add(toolchainEntry.getKey());\n        }\n      }\n\n      return featureSupportingToolchains.build();\n    }\n\n    @Override\n    public Optional<ToolchainInstantiationException> getToolchainInstantiationException(\n        String toolchainName) {\n      return Optional.empty();\n    }\n  }\n}", "class_id": 0, "repo": "fkorotkov/buck", "file": "test/com/facebook/buck/toolchain/impl/ToolchainProviderBuilder.java", "last_update_at": "2018-04-11T08:06:37+00:00", "question_id": "10a0a4955734893361817a4dff40b79f385dbe75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ToolchainProviderBuilder {\n  private final Map<String, Toolchain> toolchains = new HashMap<>();\n  public ToolchainProviderBuilder() {}\n  public ToolchainProviderBuilder withToolchain(NamedToolchain toolchain) {\n    toolchains.put(toolchain.getName(), toolchain.getToolchain());\n    return this;\n  }\n  public ToolchainProviderBuilder withToolchain(String name, Toolchain toolchain) {\n    toolchains.put(name, toolchain);\n    return this;\n  }\n  public ToolchainProvider build() {\n    return new SimpleToolchainProvider(toolchains);\n  }\n  private static class SimpleToolchainProvider extends BaseToolchainProvider {\n    private final ImmutableMap<String, Toolchain> toolchains;\n    private SimpleToolchainProvider(Map<String, Toolchain> toolchains) {\n      this.toolchains = ImmutableMap.copyOf(toolchains);\n    }\n    @Override\n    public Toolchain getByName(String toolchainName) {\n      return toolchains.get(toolchainName);\n    }\n    @Override\n    public boolean isToolchainPresent(String toolchainName) {\n      return toolchains.containsKey(toolchainName);\n    }\n    @Override\n    public boolean isToolchainCreated(String toolchainName) {\n      return isToolchainPresent(toolchainName);\n    }\n    @Override\n    public boolean isToolchainFailed(String toolchainName) {\n      return false;\n    }\n    @Override\n    public <T extends ToolchainWithCapability> Collection<String> getToolchainsWithCapability(\n        Class<T> capability) {\n      ImmutableList.Builder<String> featureSupportingToolchains = ImmutableList.builder();\n      for (Map.Entry<String, Toolchain> toolchainEntry : toolchains.entrySet()) {\n        if (capability.isAssignableFrom(toolchainEntry.getValue().getClass())) {\n          featureSupportingToolchains.add(toolchainEntry.getKey());\n        }\n      }\n      return featureSupportingToolchains.build();\n    }\n    @Override\n    public Optional<ToolchainInstantiationException> getToolchainInstantiationException(\n        String toolchainName) {\n      return Optional.empty();\n    }\n  }\n"]], "pred": {"ppl": 1.4585070610046387, "ppl_lower": 1.634798526763916, "ppl/lowercase_ppl": -1.3023375284994512, "ppl/zlib": 0.0006644601260429284, "Min_5.0% Prob": 5.298506200313568, "Min_10.0% Prob": 3.311860774244581, "Min_20.0% Prob": 1.845845086766141, "Min_30.0% Prob": 1.2562969829000177, "Min_40.0% Prob": 0.9427396191615197, "Min_50.0% Prob": 0.7557772698147667, "Min_60.0% Prob": 0.6303906432601336}}
{"hexsha": "96647287c4c9c2629c275a53bb63a71d0c256421", "ext": "java", "lang": "Java", "content": "public class JoinExample extends AuroraExample {\n\n  @Override\n  protected void generatePath(ExecutionPath path) {\n    path = path.addRandomTestGenerator(1, ExampleHelper.generateAttributeList(\"A\", \"B\"), 1000);\n    ExecutionPath secondPath = ExecutionPath.getExecutionPath();\n    secondPath = secondPath.addRandomTestGenerator(1, ExampleHelper.generateAttributeList(\"A\", \"C\"), 1000);\n    path = path.join(\"A\", 50, secondPath, true);\n    path = path.addTuplePrinter();\n  }\n\n}", "class_id": 0, "repo": "karmaresearch/ajira", "file": "src/nl/vu/cs/ajira/examples/aurora/examples/JoinExample.java", "last_update_at": "2018-11-18T09:58:09+00:00", "question_id": "96647287c4c9c2629c275a53bb63a71d0c256421", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JoinExample extends AuroraExample {\n  @Override\n  protected void generatePath(ExecutionPath path) {\n    path = path.addRandomTestGenerator(1, ExampleHelper.generateAttributeList(\"A\", \"B\"), 1000);\n    ExecutionPath secondPath = ExecutionPath.getExecutionPath();\n    secondPath = secondPath.addRandomTestGenerator(1, ExampleHelper.generateAttributeList(\"A\", \"C\"), 1000);\n    path = path.join(\"A\", 50, secondPath, true);\n    path = path.addTuplePrinter();\n  }\n"]], "pred": {"ppl": 4.73314094543457, "ppl_lower": 5.6387505531311035, "ppl/lowercase_ppl": -1.112617209242285, "ppl/zlib": 0.006587241651620072, "Min_5.0% Prob": 9.718728474208287, "Min_10.0% Prob": 8.213615145002093, "Min_20.0% Prob": 6.014390502657209, "Min_30.0% Prob": 4.59218265566715, "Min_40.0% Prob": 3.706001792037696, "Min_50.0% Prob": 3.029370297988256, "Min_60.0% Prob": 2.581626999170281}}
{"hexsha": "bad87a2146023ed2ae2f5034ba61fa7070b8a5bc", "ext": "java", "lang": "Java", "content": "public class CipherRSAFactory {\n    public static final String ALGORITHM_WAS_INVALID = \"Algorithm, %s, was invalid\";\n    public static final String PADDING_WAS_INVALID = \"Padding for algorithm, %s, was invalid\";\n    public static final String KEY_WAS_INVALID_INIT_CIPHER = \"Key was invalid when initializing cipher\";\n    public static final String ALGORITHM_WAS_INVALID_INIT_CIPHER = \"Algorithm, %s, was invalid when initializing cipher\";\n\n    public Cipher forEncrypt(Transformation transformation, Key key) throws CipherException {\n        AlgorithmParameterSpec spec = makeSpec(transformation);\n        Cipher cipher = makeCipher(transformation, key, Cipher.ENCRYPT_MODE, spec);\n        return cipher;\n    }\n\n    public Cipher forDecrypt(Transformation transformation, Key key) throws CipherException {\n        AlgorithmParameterSpec spec = makeSpec(transformation);\n        Cipher cipher = makeCipher(transformation, key, Cipher.DECRYPT_MODE, spec);\n        return cipher;\n    }\n\n    protected AlgorithmParameterSpec makeSpec(Transformation transformation) {\n        AlgorithmParameterSpec spec = null;\n        if (transformation == Transformation.RSA_OAEP) {\n            spec =  OAEPParameterSpec.DEFAULT;\n        }\n        return spec;\n    }\n\n    protected Cipher makeCipher(Transformation transformation, Key key, int mode, AlgorithmParameterSpec spec) throws CipherException {\n        Cipher cipher;\n        try {\n            cipher = Cipher.getInstance(transformation.getValue());\n        } catch (NoSuchAlgorithmException e) {\n            throw new CipherException(String.format(ALGORITHM_WAS_INVALID, transformation.getValue()), e);\n        } catch (NoSuchPaddingException e) {\n            throw new CipherException(String.format(PADDING_WAS_INVALID, transformation.getValue()), e);\n        }\n\n        try {\n            cipher.init(mode, key, spec);\n        } catch (InvalidKeyException e) {\n            throw new CipherException(KEY_WAS_INVALID_INIT_CIPHER, e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new CipherException(String.format(ALGORITHM_WAS_INVALID_INIT_CIPHER, transformation.getValue()), e);\n        }\n\n        return cipher;\n    }\n}", "class_id": 0, "repo": "RootServices/jwt", "file": "src/main/java/net/tokensmith/jwt/jwe/factory/CipherRSAFactory.java", "last_update_at": "2018-09-26T10:42:11+00:00", "question_id": "bad87a2146023ed2ae2f5034ba61fa7070b8a5bc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CipherRSAFactory {\n    public static final String ALGORITHM_WAS_INVALID = \"Algorithm, %s, was invalid\";\n    public static final String PADDING_WAS_INVALID = \"Padding for algorithm, %s, was invalid\";\n    public static final String KEY_WAS_INVALID_INIT_CIPHER = \"Key was invalid when initializing cipher\";\n    public static final String ALGORITHM_WAS_INVALID_INIT_CIPHER = \"Algorithm, %s, was invalid when initializing cipher\";\n    public Cipher forEncrypt(Transformation transformation, Key key) throws CipherException {\n        AlgorithmParameterSpec spec = makeSpec(transformation);\n        Cipher cipher = makeCipher(transformation, key, Cipher.ENCRYPT_MODE, spec);\n        return cipher;\n    }\n    public Cipher forDecrypt(Transformation transformation, Key key) throws CipherException {\n        AlgorithmParameterSpec spec = makeSpec(transformation);\n        Cipher cipher = makeCipher(transformation, key, Cipher.DECRYPT_MODE, spec);\n        return cipher;\n    }\n    protected AlgorithmParameterSpec makeSpec(Transformation transformation) {\n        AlgorithmParameterSpec spec = null;\n        if (transformation == Transformation.RSA_OAEP) {\n            spec =  OAEPParameterSpec.DEFAULT;\n        }\n        return spec;\n    }\n    protected Cipher makeCipher(Transformation transformation, Key key, int mode, AlgorithmParameterSpec spec) throws CipherException {\n        Cipher cipher;\n        try {\n            cipher = Cipher.getInstance(transformation.getValue());\n        } catch (NoSuchAlgorithmException e) {\n            throw new CipherException(String.format(ALGORITHM_WAS_INVALID, transformation.getValue()), e);\n        } catch (NoSuchPaddingException e) {\n            throw new CipherException(String.format(PADDING_WAS_INVALID, transformation.getValue()), e);\n        }\n        try {\n            cipher.init(mode, key, spec);\n        } catch (InvalidKeyException e) {\n            throw new CipherException(KEY_WAS_INVALID_INIT_CIPHER, e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new CipherException(String.format(ALGORITHM_WAS_INVALID_INIT_CIPHER, transformation.getValue()), e);\n        }\n        return cipher;\n    }\n"]], "pred": {"ppl": 1.4444351196289062, "ppl_lower": 1.8481171131134033, "ppl/lowercase_ppl": -1.6702114179524783, "ppl/zlib": 0.0006822232364804326, "Min_5.0% Prob": 5.12573504447937, "Min_10.0% Prob": 3.171676970521609, "Min_20.0% Prob": 1.7806971124873674, "Min_30.0% Prob": 1.2168444176050988, "Min_40.0% Prob": 0.91670925989977, "Min_50.0% Prob": 0.7343971157878466, "Min_60.0% Prob": 0.6138920043633513}}
{"hexsha": "04823fde620e02dc1f7c7a2a9855556048c2029a", "ext": "java", "lang": "Java", "content": "public class ExCursedWeaponLocation extends L2GameServerPacket\n{\n\tprivate final List<CursedWeaponInfo> _cursedWeaponInfo;\n\t\n\tpublic ExCursedWeaponLocation(List<CursedWeaponInfo> cursedWeaponInfo)\n\t{\n\t\t_cursedWeaponInfo = cursedWeaponInfo;\n\t}\n\t\n\t@Override\n\tprotected void writeImpl()\n\t{\n\t\twriteC(0xfe);\n\t\twriteH(0x47);\n\t\t\n\t\tif (!_cursedWeaponInfo.isEmpty())\n\t\t{\n\t\t\twriteD(_cursedWeaponInfo.size());\n\t\t\tfor (CursedWeaponInfo w : _cursedWeaponInfo)\n\t\t\t{\n\t\t\t\twriteD(w.id);\n\t\t\t\twriteD(w.activated);\n\t\t\t\t\n\t\t\t\twriteD(w.pos.getX());\n\t\t\t\twriteD(w.pos.getY());\n\t\t\t\twriteD(w.pos.getZ());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twriteD(0);\n\t\t\twriteD(0);\n\t\t}\n\t}\n\t\n\tpublic static class CursedWeaponInfo\n\t{\n\t\tpublic Location pos;\n\t\tpublic int id;\n\t\tpublic int activated; // 0 - not activated ? 1 - activated\n\t\t\n\t\tpublic CursedWeaponInfo(Location p, int ID, int status)\n\t\t{\n\t\t\tpos = p;\n\t\t\tid = ID;\n\t\t\tactivated = status;\n\t\t}\n\t\t\n\t}\n}", "class_id": 0, "repo": "RollingSoftware/L2J_HighFive_Hardcore", "file": "l2j_server/src/main/java/com/l2jserver/gameserver/network/serverpackets/ExCursedWeaponLocation.java", "last_update_at": "2018-06-05T20:47:59+00:00", "question_id": "04823fde620e02dc1f7c7a2a9855556048c2029a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExCursedWeaponLocation extends L2GameServerPacket\n{\n\tprivate final List<CursedWeaponInfo> _cursedWeaponInfo;\n\t\n\tpublic ExCursedWeaponLocation(List<CursedWeaponInfo> cursedWeaponInfo)\n\t{\n\t\t_cursedWeaponInfo = cursedWeaponInfo;\n\t}\n\t\n\t@Override\n\tprotected void writeImpl()\n\t{\n\t\twriteC(0xfe);\n\t\twriteH(0x47);\n\t\t\n\t\tif (!_cursedWeaponInfo.isEmpty())\n\t\t{\n\t\t\twriteD(_cursedWeaponInfo.size());\n\t\t\tfor (CursedWeaponInfo w : _cursedWeaponInfo)\n\t\t\t{\n\t\t\t\twriteD(w.id);\n\t\t\t\twriteD(w.activated);\n\t\t\t\t\n\t\t\t\twriteD(w.pos.getX());\n\t\t\t\twriteD(w.pos.getY());\n\t\t\t\twriteD(w.pos.getZ());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twriteD(0);\n\t\t\twriteD(0);\n\t\t}\n\t}\n\t\n\tpublic static class CursedWeaponInfo\n\t{\n\t\tpublic Location pos;\n\t\tpublic int id;\n\t\tpublic int activated; // 0 - not activated ? 1 - activated\n\t\t\n\t\tpublic CursedWeaponInfo(Location p, int ID, int status)\n\t\t{\n\t\t\tpos = p;\n\t\t\tid = ID;\n\t\t\tactivated = status;\n\t\t}\n\t\t\n\t}\n"]], "pred": {"ppl": 1.5255881547927856, "ppl_lower": 1.7869446277618408, "ppl/lowercase_ppl": -1.3743719742024147, "ppl/zlib": 0.0011415675972425438, "Min_5.0% Prob": 5.874845368521554, "Min_10.0% Prob": 3.8044666634049524, "Min_20.0% Prob": 2.0869204062840034, "Min_30.0% Prob": 1.4051975705696427, "Min_40.0% Prob": 1.0558512456395797, "Min_50.0% Prob": 0.8444857561118799, "Min_60.0% Prob": 0.7060434241412129}}
{"hexsha": "142f7fa91033369eeb5a00642c2ddf9f8d753aca", "ext": "java", "lang": "Java", "content": "public class ProgramHeartbeatTable {\n  private static final Gson GSON = TriggeringScheduleInfoAdapter.addTypeAdapters(new GsonBuilder()).create();\n  private final StructuredTable table;\n\n  // TODO: CDAP-14950 add service to clean up this table periodically\n  public ProgramHeartbeatTable(StructuredTableContext context) {\n    this.table = context.getTable(StoreDefinition.ProgramHeartbeatStore.PROGRAM_HEARTBEATS);\n  }\n\n  /**\n   * Write {@link RunRecordMeta} to heart beat table as value.\n   *\n   * @param runRecordMeta row value to write\n   * @param timestampInSeconds used for creating rowKey\n   */\n  public void writeRunRecordMeta(RunRecordMeta runRecordMeta, long timestampInSeconds) throws IOException {\n    List<Field<?>> fields = createRowKey(timestampInSeconds, runRecordMeta.getProgramRunId());\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD, GSON.toJson(runRecordMeta)));\n    table.upsert(fields);\n  }\n\n  @VisibleForTesting\n  public void deleteAll() throws IOException {\n    table.deleteAll(Range.all());\n  }\n\n  private List<Field<?>> createRowKey(long timestampInSeconds, ProgramRunId programRunId) {\n    List<Field<?>> fields = new ArrayList<>();\n    // add namespace at the beginning\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, programRunId.getNamespace()));\n    // add timestamp\n    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestampInSeconds));\n    // add program runId fields, skip namespace as that is part of row key\n    fields.add(\n      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD, programRunId.getApplication()));\n    fields.add(\n      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD, programRunId.getType().name()));\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD, programRunId.getProgram()));\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD, programRunId.getRun()));\n    return fields;\n  }\n\n  /**\n   * Add namespace and timestamp and return it as the scan key.\n   * @return scan key\n   */\n  private List<Field<?>> getScanKey(String namespace, long timestamp) {\n    List<Field<?>> fields = new ArrayList<>();\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, namespace));\n    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestamp));\n    return fields;\n  }\n\n  /**\n   * Scan the table for the time range for each of the namespace provided\n   * and return collection of latest {@link RunRecordMeta}\n   * we maintain the latest {@link RunRecordMeta} identified by {@link ProgramRunId},\n   * Since there can be more than one RunRecordMeta for the\n   * same runId due to multiple state changes and heart beat messages.\n   *\n   * @param startTimestampInSeconds inclusive start rowKey\n   * @param endTimestampInSeconds exclusive end rowKey\n   * @param namespaces set of namespaces\n   * @return collection of {@link RunRecordMeta}\n   */\n  public Collection<RunRecordMeta> scan(long startTimestampInSeconds, long endTimestampInSeconds,\n                                        Set<String> namespaces) throws IOException {\n    List<RunRecordMeta> resultRunRecordList = new ArrayList<>();\n    for (String namespace : namespaces) {\n      List<Field<?>> startRowKey = getScanKey(namespace, startTimestampInSeconds);\n      List<Field<?>> endRowKey = getScanKey(namespace, endTimestampInSeconds);\n      performScanAddToList(startRowKey, endRowKey, resultRunRecordList);\n    }\n    return resultRunRecordList;\n  }\n\n  /**\n   * Scan is executed based on the given startRowKey and endRowKey, for each of the scanned rows, we maintain\n   * the latest {@link RunRecordMeta} identified by its {@link ProgramRunId} in a map. Finally after scan is\n   * complete add the runrecords to the result list\n   *\n   * @param startRowKey byte array used as start row key in scan\n   * @param endRowKey byte array used as end row key in scan\n   * @param runRecordMetas result list to which the run records to be added\n   */\n  private void performScanAddToList(List<Field<?>> startRowKey, List<Field<?>> endRowKey,\n                                    List<RunRecordMeta> runRecordMetas) throws IOException {\n    try (CloseableIterator<StructuredRow> iterator =\n      table.scan(Range.create(startRowKey, Range.Bound.INCLUSIVE, endRowKey, Range.Bound.EXCLUSIVE),\n                 Integer.MAX_VALUE)) {\n      Map<ProgramRunId, RunRecordMeta> runIdToRunRecordMap = new HashMap<>();\n      while (iterator.hasNext()) {\n        StructuredRow row = iterator.next();\n        RunRecordMeta runRecordMeta = GSON.fromJson(row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD),\n                                                    RunRecordMeta.class);\n        ProgramRunId runId = getProgramRunIdFromRow(row);\n        runIdToRunRecordMap.put(runId, runRecordMeta);\n      }\n\n      // since the serialized runRecordMeta doesn't have programRunId (transient), we will create and\n      // add the programRunId to RunRecordMeta and add to result list\n\n      runIdToRunRecordMap.entrySet().forEach((entry) -> {\n        RunRecordMeta.Builder builder = RunRecordMeta.builder(entry.getValue());\n        builder.setProgramRunId(entry.getKey());\n        runRecordMetas.add(builder.build());\n      });\n    }\n  }\n\n  /**\n   * Return {@link ProgramRunId} from the row\n   */\n  private ProgramRunId getProgramRunIdFromRow(StructuredRow row) {\n    return new ProgramRunId(row.getString(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD),\n                            ProgramType.valueOf(\n                              row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD)),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD));\n  }\n}", "class_id": 0, "repo": "zuxqoj/cdap", "file": "cdap-app-fabric/src/main/java/io/cdap/cdap/reporting/ProgramHeartbeatTable.java", "last_update_at": "2018-10-30T06:06:50+00:00", "question_id": "142f7fa91033369eeb5a00642c2ddf9f8d753aca", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProgramHeartbeatTable {\n  private static final Gson GSON = TriggeringScheduleInfoAdapter.addTypeAdapters(new GsonBuilder()).create();\n  private final StructuredTable table;\n  // TODO: CDAP-14950 add service to clean up this table periodically\n  public ProgramHeartbeatTable(StructuredTableContext context) {\n    this.table = context.getTable(StoreDefinition.ProgramHeartbeatStore.PROGRAM_HEARTBEATS);\n  }\n  /**\n   * Write {@link RunRecordMeta} to heart beat table as value.\n   *\n   * @param runRecordMeta row value to write\n   * @param timestampInSeconds used for creating rowKey\n   */\n  public void writeRunRecordMeta(RunRecordMeta runRecordMeta, long timestampInSeconds) throws IOException {\n    List<Field<?>> fields = createRowKey(timestampInSeconds, runRecordMeta.getProgramRunId());\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD, GSON.toJson(runRecordMeta)));\n    table.upsert(fields);\n  }\n  @VisibleForTesting\n  public void deleteAll() throws IOException {\n    table.deleteAll(Range.all());\n  }\n  private List<Field<?>> createRowKey(long timestampInSeconds, ProgramRunId programRunId) {\n    List<Field<?>> fields = new ArrayList<>();\n    // add namespace at the beginning\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, programRunId.getNamespace()));\n    // add timestamp\n    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestampInSeconds));\n    // add program runId fields, skip namespace as that is part of row key\n    fields.add(\n      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD, programRunId.getApplication()));\n    fields.add(\n      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD, programRunId.getType().name()));\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD, programRunId.getProgram()));\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD, programRunId.getRun()));\n    return fields;\n  }\n  /**\n   * Add namespace and timestamp and return it as the scan key.\n   * @return scan key\n   */\n  private List<Field<?>> getScanKey(String namespace, long timestamp) {\n    List<Field<?>> fields = new ArrayList<>();\n    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, namespace));\n    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestamp));\n    return fields;\n  }\n  /**\n   * Scan the table for the time range for each of the namespace provided\n   * and return collection of latest {@link RunRecordMeta}\n   * we maintain the latest {@link RunRecordMeta} identified by {@link ProgramRunId},\n   * Since there can be more than one RunRecordMeta for the\n   * same runId due to multiple state changes and heart beat messages.\n   *\n   * @param startTimestampInSeconds inclusive start rowKey\n   * @param endTimestampInSeconds exclusive end rowKey\n   * @param namespaces set of namespaces\n   * @return collection of {@link RunRecordMeta}\n   */\n  public Collection<RunRecordMeta> scan(long startTimestampInSeconds, long endTimestampInSeconds,\n                                        Set<String> namespaces) throws IOException {\n    List<RunRecordMeta> resultRunRecordList = new ArrayList<>();\n    for (String namespace : namespaces) {\n      List<Field<?>> startRowKey = getScanKey(namespace, startTimestampInSeconds);\n      List<Field<?>> endRowKey = getScanKey(namespace, endTimestampInSeconds);\n      performScanAddToList(startRowKey, endRowKey, resultRunRecordList);\n    }\n    return resultRunRecordList;\n  }\n  /**\n   * Scan is executed based on the given startRowKey and endRowKey, for each of the scanned rows, we maintain\n   * the latest {@link RunRecordMeta} identified by its {@link ProgramRunId} in a map. Finally after scan is\n   * complete add the runrecords to the result list\n   *\n   * @param startRowKey byte array used as start row key in scan\n   * @param endRowKey byte array used as end row key in scan\n   * @param runRecordMetas result list to which the run records to be added\n   */\n  private void performScanAddToList(List<Field<?>> startRowKey, List<Field<?>> endRowKey,\n                                    List<RunRecordMeta> runRecordMetas) throws IOException {\n    try (CloseableIterator<StructuredRow> iterator =\n      table.scan(Range.create(startRowKey, Range.Bound.INCLUSIVE, endRowKey, Range.Bound.EXCLUSIVE),\n                 Integer.MAX_VALUE)) {\n      Map<ProgramRunId, RunRecordMeta> runIdToRunRecordMap = new HashMap<>();\n      while (iterator.hasNext()) {\n        StructuredRow row = iterator.next();\n        RunRecordMeta runRecordMeta = GSON.fromJson(row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD),\n                                                    RunRecordMeta.class);\n        ProgramRunId runId = getProgramRunIdFromRow(row);\n        runIdToRunRecordMap.put(runId, runRecordMeta);\n      }\n      // since the serialized runRecordMeta doesn't have programRunId (transient), we will create and\n      // add the programRunId to RunRecordMeta and add to result list\n      runIdToRunRecordMap.entrySet().forEach((entry) -> {\n        RunRecordMeta.Builder builder = RunRecordMeta.builder(entry.getValue());\n        builder.setProgramRunId(entry.getKey());\n        runRecordMetas.add(builder.build());\n      });\n    }\n  }\n  /**\n   * Return {@link ProgramRunId} from the row\n   */\n  private ProgramRunId getProgramRunIdFromRow(StructuredRow row) {\n    return new ProgramRunId(row.getString(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD),\n                            ProgramType.valueOf(\n                              row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD)),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD),\n                            row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD));\n  }\n"]], "pred": {"ppl": 1.9424412250518799, "ppl_lower": 2.341284990310669, "ppl/lowercase_ppl": -1.2812796556325217, "ppl/zlib": 0.00038511922588651523, "Min_5.0% Prob": 6.357808692782533, "Min_10.0% Prob": 4.821863167426166, "Min_20.0% Prob": 3.114252053639468, "Min_30.0% Prob": 2.1880733601602853, "Min_40.0% Prob": 1.6547415155124985, "Min_50.0% Prob": 1.3281855712500774, "Min_60.0% Prob": 1.1078018427911545}}
{"hexsha": "175620db3560eae7f1aeff3c0e4bfa9c0413cf8d", "ext": "java", "lang": "Java", "content": "public class MinimizationMethod {\r\n    protected int iteration;\r\n\r\n    protected double[] x;\r\n    protected double fx;\r\n\r\n    private EventListenerList listenerList = new EventListenerList();\r\n    private IterationEvent iterationEvent;\r\n    private OptimizationEvent optimizationEvent;\r\n\r\n    public int getIteration() {\r\n        return iteration;\r\n    }\r\n\r\n    public double[] getX() {\r\n        return x;\r\n    }\r\n\r\n    public double getFx() {\r\n        return fx;\r\n    }\r\n\r\n    public void addIterationListener(IterationListener l) {\r\n        listenerList.add(IterationListener.class, l);\r\n    }\r\n\r\n    public void removeIterationListener(IterationListener l) {\r\n        listenerList.remove(IterationListener.class, l);\r\n    }\r\n\r\n    public void addOptimizationListener(OptimizationListener l) {\r\n        listenerList.add(OptimizationListener.class, l);\r\n    }\r\n\r\n    public void removeOptimizationListener(OptimizationListener l) {\r\n        listenerList.remove(OptimizationListener.class, l);\r\n    }\r\n\r\n    protected void fireIterationStart() {\r\n        // Guaranteed to return a non-null array\r\n        Object[] listeners = listenerList.getListenerList();\r\n        // Process the listeners last to first, notifying\r\n        // those that are interested in this event\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == IterationListener.class) {\r\n                // Lazily create the event:\r\n                if (iterationEvent == null)\r\n                    iterationEvent = new IterationEvent(this);\r\n                ((IterationListener) listeners[i + 1]).IterationStart(iterationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireIterationEnd() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == IterationListener.class) {\r\n                if (iterationEvent == null)\r\n                    iterationEvent = new IterationEvent(this);\r\n                ((IterationListener) listeners[i + 1]).IterationEnd(iterationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireOptimizationStart() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == OptimizationListener.class) {\r\n                if (optimizationEvent == null)\r\n                    optimizationEvent = new OptimizationEvent(this);\r\n                ((OptimizationListener) listeners[i + 1]).OptimizationStart(optimizationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireOptimizationEnd() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == OptimizationListener.class) {\r\n                if (optimizationEvent == null)\r\n                    optimizationEvent = new OptimizationEvent(this);\r\n                ((OptimizationListener) listeners[i + 1]).OptimizationEnd(optimizationEvent);\r\n            }\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "kordikp/AutoMLprediction", "file": "implementation/fakegame/game-trainers/src/main/java/game/trainers/gradient/numopt/MinimizationMethod.java", "last_update_at": "2018-03-22T12:45:32+00:00", "question_id": "175620db3560eae7f1aeff3c0e4bfa9c0413cf8d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MinimizationMethod {\r\n    protected int iteration;\r\n\r\n    protected double[] x;\r\n    protected double fx;\r\n\r\n    private EventListenerList listenerList = new EventListenerList();\r\n    private IterationEvent iterationEvent;\r\n    private OptimizationEvent optimizationEvent;\r\n\r\n    public int getIteration() {\r\n        return iteration;\r\n    }\r\n\r\n    public double[] getX() {\r\n        return x;\r\n    }\r\n\r\n    public double getFx() {\r\n        return fx;\r\n    }\r\n\r\n    public void addIterationListener(IterationListener l) {\r\n        listenerList.add(IterationListener.class, l);\r\n    }\r\n\r\n    public void removeIterationListener(IterationListener l) {\r\n        listenerList.remove(IterationListener.class, l);\r\n    }\r\n\r\n    public void addOptimizationListener(OptimizationListener l) {\r\n        listenerList.add(OptimizationListener.class, l);\r\n    }\r\n\r\n    public void removeOptimizationListener(OptimizationListener l) {\r\n        listenerList.remove(OptimizationListener.class, l);\r\n    }\r\n\r\n    protected void fireIterationStart() {\r\n        // Guaranteed to return a non-null array\r\n        Object[] listeners = listenerList.getListenerList();\r\n        // Process the listeners last to first, notifying\r\n        // those that are interested in this event\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == IterationListener.class) {\r\n                // Lazily create the event:\r\n                if (iterationEvent == null)\r\n                    iterationEvent = new IterationEvent(this);\r\n                ((IterationListener) listeners[i + 1]).IterationStart(iterationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireIterationEnd() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == IterationListener.class) {\r\n                if (iterationEvent == null)\r\n                    iterationEvent = new IterationEvent(this);\r\n                ((IterationListener) listeners[i + 1]).IterationEnd(iterationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireOptimizationStart() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == OptimizationListener.class) {\r\n                if (optimizationEvent == null)\r\n                    optimizationEvent = new OptimizationEvent(this);\r\n                ((OptimizationListener) listeners[i + 1]).OptimizationStart(optimizationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void fireOptimizationEnd() {\r\n        Object[] listeners = listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == OptimizationListener.class) {\r\n                if (optimizationEvent == null)\r\n                    optimizationEvent = new OptimizationEvent(this);\r\n                ((OptimizationListener) listeners[i + 1]).OptimizationEnd(optimizationEvent);\r\n            }\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 1.1796118021011353, "ppl_lower": 1.2733309268951416, "ppl/lowercase_ppl": -1.4628183820635188, "ppl/zlib": 0.0002934021369114381, "Min_5.0% Prob": 2.9414621809633767, "Min_10.0% Prob": 1.614480516986876, "Min_20.0% Prob": 0.8221148584771788, "Min_30.0% Prob": 0.5508797757793218, "Min_40.0% Prob": 0.41273663257333365, "Min_50.0% Prob": 0.33071188399495016, "Min_60.0% Prob": 0.2752932065342773}}
{"hexsha": "0a1cff05ff48d038052763683036ba4a882695a9", "ext": "java", "lang": "Java", "content": "public class OracleSqlStatementBuilderSmallTest {\n    private OracleSqlStatementBuilder builder = new OracleSqlStatementBuilder();\n\n    @Test\n    public void changeDelimiterRegEx() {\n        assertNull(builder.changeDelimiterIfNecessary(\"BEGIN_DATE\", null));\n        assertEquals(\"/\", builder.changeDelimiterIfNecessary(\"BEGIN DATE\", null).getDelimiter());\n        assertEquals(\"/\", builder.changeDelimiterIfNecessary(\"BEGIN\", null).getDelimiter());\n    }\n\n    @Test\n    public void javaSource() {\n        builder.addLine(\"CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED \\\"JavaTest\\\" AS\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"public class JavaTest {\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"};\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"/\");\n        assertTrue(builder.isTerminated());\n    }\n\n    @Test\n    public void nvarchar() {\n        builder.addLine(\"INSERT INTO nvarchar2_test VALUES ( N'qwerty' );\");\n        assertTrue(builder.isTerminated());\n    }\n\n    @Test\n    public void notNvarchar() {\n        builder.addLine(\"INSERT INTO nvarchar2_test VALUES ( ' N' );\");\n        assertTrue(builder.isTerminated());\n    }\n}", "class_id": 0, "repo": "MichaelF25/flyway", "file": "flyway-core/src/test/java/org/flywaydb/core/internal/dbsupport/oracle/OracleSqlStatementBuilderSmallTest.java", "last_update_at": "2018-03-16T10:49:04+00:00", "question_id": "0a1cff05ff48d038052763683036ba4a882695a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OracleSqlStatementBuilderSmallTest {\n    private OracleSqlStatementBuilder builder = new OracleSqlStatementBuilder();\n    @Test\n    public void changeDelimiterRegEx() {\n        assertNull(builder.changeDelimiterIfNecessary(\"BEGIN_DATE\", null));\n        assertEquals(\"/\", builder.changeDelimiterIfNecessary(\"BEGIN DATE\", null).getDelimiter());\n        assertEquals(\"/\", builder.changeDelimiterIfNecessary(\"BEGIN\", null).getDelimiter());\n    }\n    @Test\n    public void javaSource() {\n        builder.addLine(\"CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED \\\"JavaTest\\\" AS\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"public class JavaTest {\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"};\");\n        assertFalse(builder.isTerminated());\n        builder.addLine(\"/\");\n        assertTrue(builder.isTerminated());\n    }\n    @Test\n    public void nvarchar() {\n        builder.addLine(\"INSERT INTO nvarchar2_test VALUES ( N'qwerty' );\");\n        assertTrue(builder.isTerminated());\n    }\n    @Test\n    public void notNvarchar() {\n        builder.addLine(\"INSERT INTO nvarchar2_test VALUES ( ' N' );\");\n        assertTrue(builder.isTerminated());\n    }\n"]], "pred": {"ppl": 2.3166391849517822, "ppl_lower": 2.7545928955078125, "ppl/lowercase_ppl": -1.2061046846864223, "ppl/zlib": 0.002289148523780622, "Min_5.0% Prob": 7.97115177266738, "Min_10.0% Prob": 6.020469104542451, "Min_20.0% Prob": 3.878011163594066, "Min_30.0% Prob": 2.7314156821140876, "Min_40.0% Prob": 2.094347726445699, "Min_50.0% Prob": 1.6806357553863973, "Min_60.0% Prob": 1.4005688810183738}}
{"hexsha": "cd0d61e49f08e02815678fe85a6ae68ea4725adf", "ext": "java", "lang": "Java", "content": "public class A_Lower implements Action {\n    public static final int LOWERSPEED = FRACUNIT*6;\n\n    @Override\n    public void doAction(MapObject mo) {}\n\n    @Override\n    public void doAction(Player player, PSprite psp) {\n    //    psp.sy += LOWERSPEED;\n    //\n    //    // Is already down.\n    //    if (psp.sy < WEAPONBOTTOM )\n    //\treturn;\n    //\n    //    // Player is dead.\n    //    if (player.playerstate == PST_DEAD)\n    //    {\n    //\tpsp.sy = WEAPONBOTTOM;\n    //\n    //\t// don't bring weapon back up\n    //\treturn;\t\t\n    //    }\n    //    \n    //    // The old weapon has been lowered off the screen,\n    //    // so change the weapon and start raising it\n    //    if (!player.health)\n    //    {\n    //\t// Player is dead, so keep the weapon off screen.\n    //\tP_SetPsprite (player,  ps_weapon, S_NULL);\n    //\treturn;\t\n    //    }\n    //\t\n    //    player.readyweapon = player.pendingweapon; \n    //\n    //    P_BringUpWeapon (player);\n    }\n    \n}", "class_id": 0, "repo": "maehem/Thump", "file": "game/src/main/java/thump/game/play/action/A_Lower.java", "last_update_at": "2018-11-16T02:15:55+00:00", "question_id": "cd0d61e49f08e02815678fe85a6ae68ea4725adf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class A_Lower implements Action {\n    public static final int LOWERSPEED = FRACUNIT*6;\n    @Override\n    public void doAction(MapObject mo) {}\n    @Override\n    public void doAction(Player player, PSprite psp) {\n    //    psp.sy += LOWERSPEED;\n    //\n    //    // Is already down.\n    //    if (psp.sy < WEAPONBOTTOM )\n    //\treturn;\n    //\n    //    // Player is dead.\n    //    if (player.playerstate == PST_DEAD)\n    //    {\n    //\tpsp.sy = WEAPONBOTTOM;\n    //\n    //\t// don't bring weapon back up\n    //\treturn;\t\t\n    //    }\n    //    \n    //    // The old weapon has been lowered off the screen,\n    //    // so change the weapon and start raising it\n    //    if (!player.health)\n    //    {\n    //\t// Player is dead, so keep the weapon off screen.\n    //\tP_SetPsprite (player,  ps_weapon, S_NULL);\n    //\treturn;\t\n    //    }\n    //\t\n    //    player.readyweapon = player.pendingweapon; \n    //\n    //    P_BringUpWeapon (player);\n    }\n"]], "pred": {"ppl": 3.166422128677368, "ppl_lower": 4.131221771240234, "ppl/lowercase_ppl": -1.2307568801226814, "ppl/zlib": 0.0026496604239853714, "Min_5.0% Prob": 7.6383837531594665, "Min_10.0% Prob": 6.154409899030413, "Min_20.0% Prob": 4.539860456330436, "Min_30.0% Prob": 3.513333795184181, "Min_40.0% Prob": 2.811963417487485, "Min_50.0% Prob": 2.2854295350103215, "Min_60.0% Prob": 1.9174643567635268}}
{"hexsha": "488e42b56e4d776b792180f90bd83d5f740166f7", "ext": "java", "lang": "Java", "content": "public abstract class PhaseBase implements IPhase {\n\n    protected final EntityDragon field_188661_a;\n\n    public PhaseBase(EntityDragon entityenderdragon) {\n        this.field_188661_a = entityenderdragon;\n    }\n\n    public boolean func_188654_a() {\n        return false;\n    }\n\n    public void func_188657_b() {}\n\n    public void func_188659_c() {}\n\n    public void func_188655_a(EntityEnderCrystal entityendercrystal, BlockPos blockposition, DamageSource damagesource, @Nullable EntityPlayer entityhuman) {}\n\n    public void func_188660_d() {}\n\n    public void func_188658_e() {}\n\n    public float func_188651_f() {\n        return 0.6F;\n    }\n\n    @Nullable\n    public Vec3d func_188650_g() {\n        return null;\n    }\n\n    public float func_188656_a(MultiPartEntityPart entitycomplexpart, DamageSource damagesource, float f) {\n        return f;\n    }\n\n    public float func_188653_h() {\n        float f = MathHelper.func_76133_a(this.field_188661_a.field_70159_w * this.field_188661_a.field_70159_w + this.field_188661_a.field_70179_y * this.field_188661_a.field_70179_y) + 1.0F;\n        float f1 = Math.min(f, 40.0F);\n\n        return 0.7F / f1 / f;\n    }\n}", "class_id": 0, "repo": "Akarin-project/AkarinModEdition", "file": "src/main/java/net/minecraft/entity/boss/dragon/phase/PhaseBase.java", "last_update_at": "2018-06-19T11:12:55+00:00", "question_id": "488e42b56e4d776b792180f90bd83d5f740166f7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class PhaseBase implements IPhase {\n    protected final EntityDragon field_188661_a;\n    public PhaseBase(EntityDragon entityenderdragon) {\n        this.field_188661_a = entityenderdragon;\n    }\n    public boolean func_188654_a() {\n        return false;\n    }\n    public void func_188657_b() {}\n    public void func_188659_c() {}\n    public void func_188655_a(EntityEnderCrystal entityendercrystal, BlockPos blockposition, DamageSource damagesource, @Nullable EntityPlayer entityhuman) {}\n    public void func_188660_d() {}\n    public void func_188658_e() {}\n    public float func_188651_f() {\n        return 0.6F;\n    }\n    @Nullable\n    public Vec3d func_188650_g() {\n        return null;\n    }\n    public float func_188656_a(MultiPartEntityPart entitycomplexpart, DamageSource damagesource, float f) {\n        return f;\n    }\n    public float func_188653_h() {\n        float f = MathHelper.func_76133_a(this.field_188661_a.field_70159_w * this.field_188661_a.field_70159_w + this.field_188661_a.field_70179_y * this.field_188661_a.field_70179_y) + 1.0F;\n        float f1 = Math.min(f, 40.0F);\n        return 0.7F / f1 / f;\n    }\n"]], "pred": {"ppl": 1.73679780960083, "ppl_lower": 2.0170226097106934, "ppl/lowercase_ppl": -1.2709560103568842, "ppl/zlib": 0.0012838211125852557, "Min_5.0% Prob": 5.738661805788676, "Min_10.0% Prob": 4.05522337804238, "Min_20.0% Prob": 2.5956033007385804, "Min_30.0% Prob": 1.823634781249582, "Min_40.0% Prob": 1.3812310039041897, "Min_50.0% Prob": 1.1057754039772039, "Min_60.0% Prob": 0.9212154346540469}}
{"hexsha": "f87eeb47cf1273332e2f03c3b1964a04606d9254", "ext": "java", "lang": "Java", "content": "public class TestSystemIdResolver extends LuceneTestCase {\n  \n  public void tearDown() throws Exception {\n    System.clearProperty(\"solr.allow.unsafe.resourceloading\");\n    super.tearDown();\n  }\n\n  private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {\n    final InputSource is = resolver.resolveEntity(null, null, base, systemId);\n    try {\n      assertEquals(\"Resolved SystemId does not match\", expectedSystemId, is.getSystemId());\n    } finally {\n      IOUtils.closeQuietly(is.getByteStream());\n    }\n  }\n  \n  public void testResolving() throws Exception {\n    final Path testHome = SolrTestCaseJ4.getFile(\"solr/collection1\").getParentFile().toPath();\n    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve(\"collection1\"), this.getClass().getClassLoader());\n    final SystemIdResolver resolver = new SystemIdResolver(loader);\n    final String fileUri = new File(testHome+\"/crazy-path-to-config.xml\").toURI().toASCIIString();\n    \n    assertEquals(\"solrres:/test.xml\", SystemIdResolver.createSystemIdFromResourceName(\"test.xml\"));\n    assertEquals(\"solrres://@/usr/local/etc/test.xml\", SystemIdResolver.createSystemIdFromResourceName(\"/usr/local/etc/test.xml\"));\n    assertEquals(\"solrres://@/test.xml\", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+\"test.xml\"));\n    \n    // check relative URI resolving\n    assertEquals(\"solrres:/test.xml\", resolver.resolveRelativeURI(\"solrres:/base.xml\", \"test.xml\").toASCIIString());\n    assertEquals(\"solrres://@/etc/test.xml\",\n      resolver.resolveRelativeURI(\"solrres://@/usr/local/etc/base.xml\", \"../../../etc/test.xml\").toASCIIString());\n    // special case: if relative URI starts with \"/\" convert to an absolute solrres://@/-URI\n    assertEquals(\"solrres://@/a/test.xml\", resolver.resolveRelativeURI(\"solrres:/base.xml\", \"/a/test.xml\").toASCIIString());\n    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved\n    assertEquals(fileUri, resolver.resolveRelativeURI(\"solrres:/base.xml\", fileUri).toASCIIString());\n    assertEquals(\"solrres:/base.xml\", resolver.resolveRelativeURI(fileUri, \"solrres:/base.xml\").toASCIIString());\n    \n    // do some real resolves to InputStreams with real existing files\n    assertEntityResolving(resolver, \"solrres:/schema.xml\", \"solrres:/solrconfig.xml\", \"schema.xml\");\n    assertEntityResolving(resolver, \"solrres:/org/apache/solr/util/TestSystemIdResolver.class\",\n      \"solrres:/org/apache/solr/util/RTimer.class\", \"TestSystemIdResolver.class\");\n    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+\"/collection1/conf/schema.xml\"),\n      SystemIdResolver.createSystemIdFromResourceName(testHome+\"/collection1/conf/solrconfig.xml\"), \"schema.xml\");\n    \n    // if somebody uses an absolute uri (e.g., file://) we should fail resolving:\n    IOException ioe = expectThrows(IOException.class, () -> {\n      resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", fileUri);\n    });\n    assertTrue(ioe.getMessage().startsWith(\"Cannot resolve absolute\"));\n    \n    ioe = expectThrows(IOException.class, () -> {\n      resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", \"http://lucene.apache.org/test.xml\");\n    });\n    assertTrue(ioe.getMessage().startsWith(\"Cannot resolve absolute\"));\n    \n    // check that we can't escape with absolute file paths:\n    for (String path : Arrays.asList(\"/etc/passwd\", \"/windows/notepad.exe\")) {\n      ioe = expectThrows(IOException.class, () -> {\n        resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", path);\n      });\n      assertTrue(ioe.getMessage().startsWith(\"Can't find resource\")\n          || ioe.getMessage().contains(\"is outside resource loader dir\"));\n    }\n  }\n\n  public void testUnsafeResolving() throws Exception {\n    System.setProperty(\"solr.allow.unsafe.resourceloading\", \"true\");\n    \n    final Path testHome = SolrTestCaseJ4.getFile(\"solr/collection1\").getParentFile().toPath();\n    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve(\"collection1\"), this.getClass().getClassLoader());\n    final SystemIdResolver resolver = new SystemIdResolver(loader);\n    \n    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+\"/crazy-path-to-schema.xml\"),\n      SystemIdResolver.createSystemIdFromResourceName(testHome+\"/crazy-path-to-config.xml\"), \"crazy-path-to-schema.xml\");    \n  }\n\n}", "class_id": 0, "repo": "sydneymiyashiro/LuceneCourseProject", "file": "solr/core/src/test/org/apache/solr/util/TestSystemIdResolver.java", "last_update_at": "2018-11-07T15:50:49+00:00", "question_id": "f87eeb47cf1273332e2f03c3b1964a04606d9254", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestSystemIdResolver extends LuceneTestCase {\n  public void tearDown() throws Exception {\n    System.clearProperty(\"solr.allow.unsafe.resourceloading\");\n    super.tearDown();\n  }\n  private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {\n    final InputSource is = resolver.resolveEntity(null, null, base, systemId);\n    try {\n      assertEquals(\"Resolved SystemId does not match\", expectedSystemId, is.getSystemId());\n    } finally {\n      IOUtils.closeQuietly(is.getByteStream());\n    }\n  }\n  public void testResolving() throws Exception {\n    final Path testHome = SolrTestCaseJ4.getFile(\"solr/collection1\").getParentFile().toPath();\n    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve(\"collection1\"), this.getClass().getClassLoader());\n    final SystemIdResolver resolver = new SystemIdResolver(loader);\n    final String fileUri = new File(testHome+\"/crazy-path-to-config.xml\").toURI().toASCIIString();\n    assertEquals(\"solrres:/test.xml\", SystemIdResolver.createSystemIdFromResourceName(\"test.xml\"));\n    assertEquals(\"solrres://@/usr/local/etc/test.xml\", SystemIdResolver.createSystemIdFromResourceName(\"/usr/local/etc/test.xml\"));\n    assertEquals(\"solrres://@/test.xml\", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+\"test.xml\"));\n    // check relative URI resolving\n    assertEquals(\"solrres:/test.xml\", resolver.resolveRelativeURI(\"solrres:/base.xml\", \"test.xml\").toASCIIString());\n    assertEquals(\"solrres://@/etc/test.xml\",\n      resolver.resolveRelativeURI(\"solrres://@/usr/local/etc/base.xml\", \"../../../etc/test.xml\").toASCIIString());\n    // special case: if relative URI starts with \"/\" convert to an absolute solrres://@/-URI\n    assertEquals(\"solrres://@/a/test.xml\", resolver.resolveRelativeURI(\"solrres:/base.xml\", \"/a/test.xml\").toASCIIString());\n    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved\n    assertEquals(fileUri, resolver.resolveRelativeURI(\"solrres:/base.xml\", fileUri).toASCIIString());\n    assertEquals(\"solrres:/base.xml\", resolver.resolveRelativeURI(fileUri, \"solrres:/base.xml\").toASCIIString());\n    // do some real resolves to InputStreams with real existing files\n    assertEntityResolving(resolver, \"solrres:/schema.xml\", \"solrres:/solrconfig.xml\", \"schema.xml\");\n    assertEntityResolving(resolver, \"solrres:/org/apache/solr/util/TestSystemIdResolver.class\",\n      \"solrres:/org/apache/solr/util/RTimer.class\", \"TestSystemIdResolver.class\");\n    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+\"/collection1/conf/schema.xml\"),\n      SystemIdResolver.createSystemIdFromResourceName(testHome+\"/collection1/conf/solrconfig.xml\"), \"schema.xml\");\n    // if somebody uses an absolute uri (e.g., file://) we should fail resolving:\n    IOException ioe = expectThrows(IOException.class, () -> {\n      resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", fileUri);\n    });\n    assertTrue(ioe.getMessage().startsWith(\"Cannot resolve absolute\"));\n    ioe = expectThrows(IOException.class, () -> {\n      resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", \"http://lucene.apache.org/test.xml\");\n    });\n    assertTrue(ioe.getMessage().startsWith(\"Cannot resolve absolute\"));\n    // check that we can't escape with absolute file paths:\n    for (String path : Arrays.asList(\"/etc/passwd\", \"/windows/notepad.exe\")) {\n      ioe = expectThrows(IOException.class, () -> {\n        resolver.resolveEntity(null, null, \"solrres:/solrconfig.xml\", path);\n      });\n      assertTrue(ioe.getMessage().startsWith(\"Can't find resource\")\n          || ioe.getMessage().contains(\"is outside resource loader dir\"));\n    }\n  }\n  public void testUnsafeResolving() throws Exception {\n    System.setProperty(\"solr.allow.unsafe.resourceloading\", \"true\");\n    final Path testHome = SolrTestCaseJ4.getFile(\"solr/collection1\").getParentFile().toPath();\n    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve(\"collection1\"), this.getClass().getClassLoader());\n    final SystemIdResolver resolver = new SystemIdResolver(loader);\n    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+\"/crazy-path-to-schema.xml\"),\n      SystemIdResolver.createSystemIdFromResourceName(testHome+\"/crazy-path-to-config.xml\"), \"crazy-path-to-schema.xml\");    \n  }\n"]], "pred": {"ppl": 2.185560464859009, "ppl_lower": 2.4895882606506348, "ppl/lowercase_ppl": -1.1665809597101164, "ppl/zlib": 0.0006575881423985695, "Min_5.0% Prob": 6.589261326135373, "Min_10.0% Prob": 4.994503315757303, "Min_20.0% Prob": 3.413072248884276, "Min_30.0% Prob": 2.5152464193456314, "Min_40.0% Prob": 1.9330675050543398, "Min_50.0% Prob": 1.5592905184775299, "Min_60.0% Prob": 1.3031612380679702}}
{"hexsha": "a7f136cf3ce0f087dee10f2b8c0f79b108004cd0", "ext": "java", "lang": "Java", "content": "@JsonIgnoreProperties(ignoreUnknown = true)\npublic class SubmitResult {\n\n    public String version;\n\n    @Override\n    public String toString() {\n        return \"SubmitResult{\" +\n                \"version='\" + version + '\\'' +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SubmitResult that = (SubmitResult) o;\n        return Objects.equals(version, that.version);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(version);\n    }\n}", "class_id": 0, "repo": "amahussein/vespa", "file": "controller-api/src/main/java/com/yahoo/vespa/hosted/controller/api/application/v4/model/SubmitResult.java", "last_update_at": "2018-12-30T05:42:18+00:00", "question_id": "a7f136cf3ce0f087dee10f2b8c0f79b108004cd0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JsonIgnoreProperties(ignoreUnknown = true)\npublic class SubmitResult {\n    public String version;\n    @Override\n    public String toString() {\n        return \"SubmitResult{\" +\n                \"version='\" + version + '\\'' +\n                '}';\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SubmitResult that = (SubmitResult) o;\n        return Objects.equals(version, that.version);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(version);\n    }\n"]], "pred": {"ppl": 1.4333988428115845, "ppl_lower": 2.0913543701171875, "ppl/lowercase_ppl": -2.0492017287039994, "ppl/zlib": 0.0013188587445939557, "Min_5.0% Prob": 5.295453757047653, "Min_10.0% Prob": 3.4733357951045036, "Min_20.0% Prob": 1.8199884941180546, "Min_30.0% Prob": 1.2130646800994873, "Min_40.0% Prob": 0.907434926611552, "Min_50.0% Prob": 0.7241896726870133, "Min_60.0% Prob": 0.6024000629748674}}
{"hexsha": "181494bbe3ba258298bdeefa47a65d06d3653636", "ext": "java", "lang": "Java", "content": "public class BukkitServerProvider implements ServerProvider {\n\t\n\t@Override\n\tpublic void broadcast(String message) {\n\t\tBukkit.broadcastMessage(message);\n\t}\n\t\n\t@Override\n\tpublic void broadcast(String message, String permission) {\n\t\tBukkit.broadcast(message, permission);\n\t}\n\t\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tpublic void scheduleAsync(Runnable r, long tickDelay) {\n\t\tBukkit.getScheduler().scheduleAsyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);\n\t}\n\t\n\t@Override\n\tpublic void scheduleSync(Runnable r, long tickDelay) {\n\t\tBukkit.getScheduler().scheduleSyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);\n\t}\n\t\n\t@Override\n\tpublic PortalWorld getWorld(String name) {\n\t\treturn new BukkitWorld(Bukkit.getWorld(name));\n\t}\n\t\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tpublic PortalItem getItem(int id) {\n\t\treturn new BukkitItem(new ItemStack(id));\n\t}\n\t\n\t@Override\n\tpublic PortalPlayer getPlayer(UUID uuid) {\n\t\t\n\t\tPlayer p = Bukkit.getPlayer(uuid);\n\t\tif (p == null) return null;\n\t\t\n\t\treturn new BukkitPortalPlayer(p);\n\t\t\n\t}\n\t\n\t@Override\n\tpublic PortalPlayer getPlayer(String name) {\n\t\t\n\t\tPlayer p = Bukkit.getPlayer(name);\n\t\tif (p == null) return null;\n\t\t\n\t\treturn new BukkitPortalPlayer(p);\n\t\t\n\t}\n\n\t@Override\n\tpublic String getUsername(UUID uuid) {\n\t\treturn Bukkit.getOfflinePlayer(uuid).getName();\n\t}\n\t\n}", "class_id": 0, "repo": "treyzania/ZaniPortals", "file": "plat-bukkit/src/main/java/com/treyzania/mc/zaniportals/adapters/BukkitServerProvider.java", "last_update_at": "2018-01-01T02:16:27+00:00", "question_id": "181494bbe3ba258298bdeefa47a65d06d3653636", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BukkitServerProvider implements ServerProvider {\n\t\n\t@Override\n\tpublic void broadcast(String message) {\n\t\tBukkit.broadcastMessage(message);\n\t}\n\t\n\t@Override\n\tpublic void broadcast(String message, String permission) {\n\t\tBukkit.broadcast(message, permission);\n\t}\n\t\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tpublic void scheduleAsync(Runnable r, long tickDelay) {\n\t\tBukkit.getScheduler().scheduleAsyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);\n\t}\n\t\n\t@Override\n\tpublic void scheduleSync(Runnable r, long tickDelay) {\n\t\tBukkit.getScheduler().scheduleSyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);\n\t}\n\t\n\t@Override\n\tpublic PortalWorld getWorld(String name) {\n\t\treturn new BukkitWorld(Bukkit.getWorld(name));\n\t}\n\t\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tpublic PortalItem getItem(int id) {\n\t\treturn new BukkitItem(new ItemStack(id));\n\t}\n\t\n\t@Override\n\tpublic PortalPlayer getPlayer(UUID uuid) {\n\t\t\n\t\tPlayer p = Bukkit.getPlayer(uuid);\n\t\tif (p == null) return null;\n\t\t\n\t\treturn new BukkitPortalPlayer(p);\n\t\t\n\t}\n\t\n\t@Override\n\tpublic PortalPlayer getPlayer(String name) {\n\t\t\n\t\tPlayer p = Bukkit.getPlayer(name);\n\t\tif (p == null) return null;\n\t\t\n\t\treturn new BukkitPortalPlayer(p);\n\t\t\n\t}\n\t@Override\n\tpublic String getUsername(UUID uuid) {\n\t\treturn Bukkit.getOfflinePlayer(uuid).getName();\n\t}\n\t\n"]], "pred": {"ppl": 1.4645572900772095, "ppl_lower": 1.6277822256088257, "ppl/lowercase_ppl": -1.2769352705040955, "ppl/zlib": 0.0009260995284624522, "Min_5.0% Prob": 5.301515817642212, "Min_10.0% Prob": 3.281856438765923, "Min_20.0% Prob": 1.8360066386227756, "Min_30.0% Prob": 1.2612476638735157, "Min_40.0% Prob": 0.9516072942946966, "Min_50.0% Prob": 0.7621139459231807, "Min_60.0% Prob": 0.6373160136508762}}
{"hexsha": "fe2e814968bfeafcce8655900f3834fea9ff1233", "ext": "java", "lang": "Java", "content": "public class HashcodeTestRunnerTest {\n\n    @Test\n    public void testRunOfDefaultHashCode() throws Exception {\n        Class clazz = SimpleClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        HashcodeTestRunner<SimpleClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);\n        assertTrue(tester.runTests().size() == 0, \"Hashcode should succeed when class does not provide a hashcode\");\n    }\n\n    @Test\n    public void testRunOfSpecializedHashCode() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        Set<String> fields = EqualsHashTestClass.getFieldsInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue( errors.size() == 0, errors.toString());\n    }\n\n    @Test\n    public void testRunOfSpecializedHashCodeFieldDontChangeCode() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue( errors.size() > 0, errors.toString());\n    }\n    @Test\n    public void testRunOfSpecializedHashCodeNoFields() throws Exception {\n        Class clazz = BadHashcodeClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        HashcodeTestRunner<BadHashcodeClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Two different instances returned same hash code\");\n    }\n\n    @Test\n    public void testRunOfSpecializedHashCodeFieldNoSetterOrGetter() throws Exception {\n        Class clazz = BadGetterSetterClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        HashcodeTestRunner<BadGetterSetterClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, BadGetterSetterClass.getFieldsInHashCode());\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() == 0, errors.toString());\n    }\n\n    @Test\n    public void testRunOfSpecializedHashcodeBadDefaultFields() throws Exception {\n        Class clazz = EqualsReturningNotEqualsDefaultValuesClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        Set<String> fields = EqualsReturningNotEqualsDefaultValuesClass.getFieldsInEqualsCode();\n\n        HashcodeTestRunner<EqualsReturningNotEqualsDefaultValuesClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Should have returned an error\");\n    }\n\n    @Test\n    public void testRunOfSpecializedHashCodeFailure() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n\n        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Should have returned an error\");\n    }\n}", "class_id": 0, "repo": "fossabot/pojot", "file": "src/test/java/net/digitaltsunami/pojot/HashcodeTestRunnerTest.java", "last_update_at": "2018-01-11T00:28:26+00:00", "question_id": "fe2e814968bfeafcce8655900f3834fea9ff1233", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HashcodeTestRunnerTest {\n    @Test\n    public void testRunOfDefaultHashCode() throws Exception {\n        Class clazz = SimpleClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        HashcodeTestRunner<SimpleClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);\n        assertTrue(tester.runTests().size() == 0, \"Hashcode should succeed when class does not provide a hashcode\");\n    }\n    @Test\n    public void testRunOfSpecializedHashCode() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        Set<String> fields = EqualsHashTestClass.getFieldsInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue( errors.size() == 0, errors.toString());\n    }\n    @Test\n    public void testRunOfSpecializedHashCodeFieldDontChangeCode() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue( errors.size() > 0, errors.toString());\n    }\n    @Test\n    public void testRunOfSpecializedHashCodeNoFields() throws Exception {\n        Class clazz = BadHashcodeClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        HashcodeTestRunner<BadHashcodeClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Two different instances returned same hash code\");\n    }\n    @Test\n    public void testRunOfSpecializedHashCodeFieldNoSetterOrGetter() throws Exception {\n        Class clazz = BadGetterSetterClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        HashcodeTestRunner<BadGetterSetterClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, BadGetterSetterClass.getFieldsInHashCode());\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() == 0, errors.toString());\n    }\n    @Test\n    public void testRunOfSpecializedHashcodeBadDefaultFields() throws Exception {\n        Class clazz = EqualsReturningNotEqualsDefaultValuesClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        Set<String> fields = EqualsReturningNotEqualsDefaultValuesClass.getFieldsInEqualsCode();\n        HashcodeTestRunner<EqualsReturningNotEqualsDefaultValuesClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Should have returned an error\");\n    }\n    @Test\n    public void testRunOfSpecializedHashCodeFailure() throws Exception {\n        Class clazz = EqualsHashTestClass.class;\n        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();\n        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);\n        List<String> errors = tester.runTests();\n        assertTrue(errors.size() > 0, \"Should have returned an error\");\n    }\n"]], "pred": {"ppl": 1.6036287546157837, "ppl_lower": 1.7195193767547607, "ppl/lowercase_ppl": -1.147745843745092, "ppl/zlib": 0.0008448462127279333, "Min_5.0% Prob": 5.861537261009216, "Min_10.0% Prob": 4.077737278277331, "Min_20.0% Prob": 2.305523792779682, "Min_30.0% Prob": 1.5667236125705266, "Min_40.0% Prob": 1.1783447269902185, "Min_50.0% Prob": 0.9447235754054231, "Min_60.0% Prob": 0.7879609230075713}}
{"hexsha": "9f25e878002a228b7b3c049717160813559b8baa", "ext": "java", "lang": "Java", "content": "public class DateUtilJUnitPerfTest extends TestCase {\n    public DateUtilJUnitPerfTest(String name) {\n        super(name);\n    }\n\n    @Before\n    public void setup() {\n\n    }\n\n    @After\n    public void tearDown() {\n\n    }\n\n    public void testCompareDateTime() {\n        String dateTime1 = \"20120111 01:02:03\";\n        String dateTime2 = \"20130111 01:02:03\";\n        String dateTime3 = \"20130111 01:02:03\";\n\n        Assert.assertEquals(-1, DateUtil.compareDateTime(dateTime1, dateTime2));\n        Assert.assertEquals(1, DateUtil.compareDateTime(dateTime2, dateTime1));\n        Assert.assertEquals(0, DateUtil.compareDateTime(dateTime2, dateTime3));\n    }\n\n    /*\n     * http://www.cnblogs.com/loggingselenium/archive/2013/01/08/2850605.html\n     */\n    public static junit.framework.Test compareDateTimeLoadTestMethod() {\n        int users = 5;\n        TestFactory factory = new TestMethodFactory(DateUtilJUnitPerfTest.class, \"testCompareDateTime\");\n        junit.framework.Test loadTest = new LoadTest(factory, users);\n        return loadTest;\n    }\n\n    public static junit.framework.Test suite() {\n        TestSuite suite = new TestSuite();\n        suite.addTest(compareDateTimeLoadTestMethod());\n        return suite;\n    }\n\n    public static void main(String args[]) {\n        junit.textui.TestRunner.run(suite());\n    }\n}", "class_id": 0, "repo": "lihongjie/tutorials", "file": "cache-lihongjie/KittyCache2/src/main/java/com/insightsource/concurrent/DateUtilJUnitPerfTest.java", "last_update_at": "2018-04-01T06:27:14+00:00", "question_id": "9f25e878002a228b7b3c049717160813559b8baa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DateUtilJUnitPerfTest extends TestCase {\n    public DateUtilJUnitPerfTest(String name) {\n        super(name);\n    }\n    @Before\n    public void setup() {\n    }\n    @After\n    public void tearDown() {\n    }\n    public void testCompareDateTime() {\n        String dateTime1 = \"20120111 01:02:03\";\n        String dateTime2 = \"20130111 01:02:03\";\n        String dateTime3 = \"20130111 01:02:03\";\n        Assert.assertEquals(-1, DateUtil.compareDateTime(dateTime1, dateTime2));\n        Assert.assertEquals(1, DateUtil.compareDateTime(dateTime2, dateTime1));\n        Assert.assertEquals(0, DateUtil.compareDateTime(dateTime2, dateTime3));\n    }\n    /*\n     * http://www.cnblogs.com/loggingselenium/archive/2013/01/08/2850605.html\n     */\n    public static junit.framework.Test compareDateTimeLoadTestMethod() {\n        int users = 5;\n        TestFactory factory = new TestMethodFactory(DateUtilJUnitPerfTest.class, \"testCompareDateTime\");\n        junit.framework.Test loadTest = new LoadTest(factory, users);\n        return loadTest;\n    }\n    public static junit.framework.Test suite() {\n        TestSuite suite = new TestSuite();\n        suite.addTest(compareDateTimeLoadTestMethod());\n        return suite;\n    }\n    public static void main(String args[]) {\n        junit.textui.TestRunner.run(suite());\n    }\n"]], "pred": {"ppl": 2.0009217262268066, "ppl_lower": 2.1788344383239746, "ppl/lowercase_ppl": -1.1228102078773823, "ppl/zlib": 0.0014330742510507458, "Min_5.0% Prob": 7.936820870354062, "Min_10.0% Prob": 5.317730232726696, "Min_20.0% Prob": 3.2294115800967162, "Min_30.0% Prob": 2.2553513625650914, "Min_40.0% Prob": 1.7178558102675847, "Min_50.0% Prob": 1.381972171264152, "Min_60.0% Prob": 1.158151346632059}}
{"hexsha": "31cbd67eb1521201e6b25ba68de40b1eb0bcb91a", "ext": "java", "lang": "Java", "content": "public class JvmInfo implements Streamable, Serializable, ToXContent {\n\n    private static JvmInfo INSTANCE;\n\n    static {\n        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n        // returns the <process id>@<host>\n        long pid;\n        String xPid = runtimeMXBean.getName();\n        try {\n            xPid = xPid.split(\"@\")[0];\n            pid = Long.parseLong(xPid);\n        } catch (Exception e) {\n            pid = -1;\n        }\n        JvmInfo info = new JvmInfo();\n        info.pid = pid;\n        info.startTime = runtimeMXBean.getStartTime();\n        info.version = runtimeMXBean.getSystemProperties().get(\"java.version\");\n        info.vmName = runtimeMXBean.getVmName();\n        info.vmVendor = runtimeMXBean.getVmVendor();\n        info.vmVersion = runtimeMXBean.getVmVersion();\n        info.mem = new Mem();\n        info.mem.heapInit = memoryMXBean.getHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getInit();\n        info.mem.heapMax = memoryMXBean.getHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getMax();\n        info.mem.nonHeapInit = memoryMXBean.getNonHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getInit();\n        info.mem.nonHeapMax = memoryMXBean.getNonHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getMax();\n        try {\n            Class<?> vmClass = Class.forName(\"sun.misc.VM\");\n            info.mem.directMemoryMax = (Long) vmClass.getMethod(\"maxDirectMemory\").invoke(null);\n        } catch (Throwable t) {\n            // ignore\n        }\n        info.inputArguments = runtimeMXBean.getInputArguments().toArray(new String[runtimeMXBean.getInputArguments().size()]);\n        info.bootClassPath = runtimeMXBean.getBootClassPath();\n        info.classPath = runtimeMXBean.getClassPath();\n        info.systemProperties = runtimeMXBean.getSystemProperties();\n\n        List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        info.gcCollectors = new String[gcMxBeans.size()];\n        for (int i = 0; i < gcMxBeans.size(); i++) {\n            GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);\n            info.gcCollectors[i] = gcMxBean.getName();\n        }\n\n        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n        info.memoryPools = new String[memoryPoolMXBeans.size()];\n        for (int i = 0; i < memoryPoolMXBeans.size(); i++) {\n            MemoryPoolMXBean memoryPoolMXBean = memoryPoolMXBeans.get(i);\n            info.memoryPools[i] = memoryPoolMXBean.getName();\n        }\n\n        INSTANCE = info;\n    }\n\n    public static JvmInfo jvmInfo() {\n        return INSTANCE;\n    }\n\n    long pid = -1;\n\n    String version = \"\";\n    String vmName = \"\";\n    String vmVersion = \"\";\n    String vmVendor = \"\";\n\n    long startTime = -1;\n\n    Mem mem;\n\n    String[] inputArguments;\n\n    String bootClassPath;\n\n    String classPath;\n\n    Map<String, String> systemProperties;\n\n    String[] gcCollectors = Strings.EMPTY_ARRAY;\n    String[] memoryPools = Strings.EMPTY_ARRAY;\n\n    private JvmInfo() {\n    }\n\n    /**\n     * The process id.\n     */\n    public long pid() {\n        return this.pid;\n    }\n\n    /**\n     * The process id.\n     */\n    public long getPid() {\n        return pid;\n    }\n\n    public String version() {\n        return this.version;\n    }\n\n    public String getVersion() {\n        return this.version;\n    }\n\n    public int versionAsInteger() {\n        try {\n            int i = 0;\n            String sVersion = \"\";\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n                if (version.charAt(i) != '.') {\n                    sVersion += version.charAt(i);\n                }\n            }\n            if (i == 0) {\n                return -1;\n            }\n            return Integer.parseInt(sVersion);\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n\n    public int versionUpdatePack() {\n        try {\n            int i = 0;\n            String sVersion = \"\";\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n                if (version.charAt(i) != '.') {\n                    sVersion += version.charAt(i);\n                }\n            }\n            if (i == 0) {\n                return -1;\n            }\n            Integer.parseInt(sVersion);\n            int from;\n            if (version.charAt(i) == '_') {\n                // 1.7.0_4\n                from = ++i;\n            } else if (version.charAt(i) == '-' && version.charAt(i + 1) == 'u') {\n                // 1.7.0-u2-b21\n                i = i + 2;\n                from = i;\n            } else {\n                return -1;\n            }\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n            }\n            if (from == i) {\n                return -1;\n            }\n            return Integer.parseInt(version.substring(from, i));\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n\n    public String vmName() {\n        return vmName;\n    }\n\n    public String getVmName() {\n        return vmName;\n    }\n\n    public String vmVersion() {\n        return vmVersion;\n    }\n\n    public String getVmVersion() {\n        return vmVersion;\n    }\n\n    public String vmVendor() {\n        return vmVendor;\n    }\n\n    public String getVmVendor() {\n        return vmVendor;\n    }\n\n    public long startTime() {\n        return startTime;\n    }\n\n    public long getStartTime() {\n        return startTime;\n    }\n\n    public Mem mem() {\n        return mem;\n    }\n\n    public Mem getMem() {\n        return mem();\n    }\n\n    public String[] inputArguments() {\n        return inputArguments;\n    }\n\n    public String[] getInputArguments() {\n        return inputArguments;\n    }\n\n    public String bootClassPath() {\n        return bootClassPath;\n    }\n\n    public String getBootClassPath() {\n        return bootClassPath;\n    }\n\n    public String classPath() {\n        return classPath;\n    }\n\n    public String getClassPath() {\n        return classPath;\n    }\n\n    public Map<String, String> systemProperties() {\n        return systemProperties;\n    }\n\n    public Map<String, String> getSystemProperties() {\n        return systemProperties;\n    }\n\n    @Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(Fields.JVM);\n        builder.field(Fields.PID, pid);\n        builder.field(Fields.VERSION, version);\n        builder.field(Fields.VM_NAME, vmName);\n        builder.field(Fields.VM_VERSION, vmVersion);\n        builder.field(Fields.VM_VENDOR, vmVendor);\n        builder.field(Fields.START_TIME, startTime);\n\n        builder.startObject(Fields.MEM);\n        builder.byteSizeField(Fields.HEAP_INIT_IN_BYTES, Fields.HEAP_INIT, mem.heapInit);\n        builder.byteSizeField(Fields.HEAP_MAX_IN_BYTES, Fields.HEAP_MAX, mem.heapMax);\n        builder.byteSizeField(Fields.NON_HEAP_INIT_IN_BYTES, Fields.NON_HEAP_INIT, mem.nonHeapInit);\n        builder.byteSizeField(Fields.NON_HEAP_MAX_IN_BYTES, Fields.NON_HEAP_MAX, mem.nonHeapMax);\n        builder.byteSizeField(Fields.DIRECT_MAX_IN_BYTES, Fields.DIRECT_MAX, mem.directMemoryMax);\n        builder.endObject();\n\n        builder.field(Fields.GC_COLLECTORS, gcCollectors);\n        builder.field(Fields.MEMORY_POOLS, memoryPools);\n\n        builder.endObject();\n        return builder;\n    }\n\n    static final class Fields {\n        static final XContentBuilderString JVM = new XContentBuilderString(\"jvm\");\n        static final XContentBuilderString PID = new XContentBuilderString(\"pid\");\n        static final XContentBuilderString VERSION = new XContentBuilderString(\"version\");\n        static final XContentBuilderString VM_NAME = new XContentBuilderString(\"vm_name\");\n        static final XContentBuilderString VM_VERSION = new XContentBuilderString(\"vm_version\");\n        static final XContentBuilderString VM_VENDOR = new XContentBuilderString(\"vm_vendor\");\n        static final XContentBuilderString START_TIME = new XContentBuilderString(\"start_time\");\n\n        static final XContentBuilderString MEM = new XContentBuilderString(\"mem\");\n        static final XContentBuilderString HEAP_INIT = new XContentBuilderString(\"heap_init\");\n        static final XContentBuilderString HEAP_INIT_IN_BYTES = new XContentBuilderString(\"heap_init_in_bytes\");\n        static final XContentBuilderString HEAP_MAX = new XContentBuilderString(\"heap_max\");\n        static final XContentBuilderString HEAP_MAX_IN_BYTES = new XContentBuilderString(\"heap_max_in_bytes\");\n        static final XContentBuilderString NON_HEAP_INIT = new XContentBuilderString(\"non_heap_init\");\n        static final XContentBuilderString NON_HEAP_INIT_IN_BYTES = new XContentBuilderString(\"non_heap_init_in_bytes\");\n        static final XContentBuilderString NON_HEAP_MAX = new XContentBuilderString(\"non_heap_max\");\n        static final XContentBuilderString NON_HEAP_MAX_IN_BYTES = new XContentBuilderString(\"non_heap_max_in_bytes\");\n        static final XContentBuilderString DIRECT_MAX = new XContentBuilderString(\"direct_max\");\n        static final XContentBuilderString DIRECT_MAX_IN_BYTES = new XContentBuilderString(\"direct_max_in_bytes\");\n        static final XContentBuilderString GC_COLLECTORS = new XContentBuilderString(\"gc_collectors\");\n        static final XContentBuilderString MEMORY_POOLS = new XContentBuilderString(\"memory_pools\");\n    }\n\n    public static JvmInfo readJvmInfo(StreamInput in) throws IOException {\n        JvmInfo jvmInfo = new JvmInfo();\n        jvmInfo.readFrom(in);\n        return jvmInfo;\n    }\n\n    @Override\n    public void readFrom(StreamInput in) throws IOException {\n        pid = in.readLong();\n        version = in.readString();\n        vmName = in.readString();\n        vmVersion = in.readString();\n        vmVendor = in.readString();\n        startTime = in.readLong();\n        inputArguments = new String[in.readInt()];\n        for (int i = 0; i < inputArguments.length; i++) {\n            inputArguments[i] = in.readString();\n        }\n        bootClassPath = in.readString();\n        classPath = in.readString();\n        systemProperties = new HashMap<String, String>();\n        int size = in.readInt();\n        for (int i = 0; i < size; i++) {\n            systemProperties.put(in.readString(), in.readString());\n        }\n        mem = new Mem();\n        mem.readFrom(in);\n        gcCollectors = in.readStringArray();\n        memoryPools = in.readStringArray();\n    }\n\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeLong(pid);\n        out.writeString(version);\n        out.writeString(vmName);\n        out.writeString(vmVersion);\n        out.writeString(vmVendor);\n        out.writeLong(startTime);\n        out.writeInt(inputArguments.length);\n        for (String inputArgument : inputArguments) {\n            out.writeString(inputArgument);\n        }\n        out.writeString(bootClassPath);\n        out.writeString(classPath);\n        out.writeInt(systemProperties.size());\n        for (Map.Entry<String, String> entry : systemProperties.entrySet()) {\n            out.writeString(entry.getKey());\n            out.writeString(entry.getValue());\n        }\n        mem.writeTo(out);\n        out.writeStringArray(gcCollectors);\n        out.writeStringArray(memoryPools);\n    }\n\n    public static class Mem implements Streamable, Serializable {\n\n        long heapInit = 0;\n        long heapMax = 0;\n        long nonHeapInit = 0;\n        long nonHeapMax = 0;\n        long directMemoryMax = 0;\n\n        Mem() {\n        }\n\n        public ByteSizeValue heapInit() {\n            return new ByteSizeValue(heapInit);\n        }\n\n        public ByteSizeValue getHeapInit() {\n            return heapInit();\n        }\n\n        public ByteSizeValue heapMax() {\n            return new ByteSizeValue(heapMax);\n        }\n\n        public ByteSizeValue getHeapMax() {\n            return heapMax();\n        }\n\n        public ByteSizeValue nonHeapInit() {\n            return new ByteSizeValue(nonHeapInit);\n        }\n\n        public ByteSizeValue getNonHeapInit() {\n            return nonHeapInit();\n        }\n\n        public ByteSizeValue nonHeapMax() {\n            return new ByteSizeValue(nonHeapMax);\n        }\n\n        public ByteSizeValue getNonHeapMax() {\n            return nonHeapMax();\n        }\n\n        public ByteSizeValue directMemoryMax() {\n            return new ByteSizeValue(directMemoryMax);\n        }\n\n        public ByteSizeValue getDirectMemoryMax() {\n            return directMemoryMax();\n        }\n\n        public static Mem readMem(StreamInput in) throws IOException {\n            Mem mem = new Mem();\n            mem.readFrom(in);\n            return mem;\n        }\n\n        @Override\n        public void readFrom(StreamInput in) throws IOException {\n            heapInit = in.readVLong();\n            heapMax = in.readVLong();\n            nonHeapInit = in.readVLong();\n            nonHeapMax = in.readVLong();\n            directMemoryMax = in.readVLong();\n        }\n\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeVLong(heapInit);\n            out.writeVLong(heapMax);\n            out.writeVLong(nonHeapInit);\n            out.writeVLong(nonHeapMax);\n            out.writeVLong(directMemoryMax);\n        }\n    }\n}", "class_id": 0, "repo": "davecroto/elasticsearch", "file": "src/main/java/org/elasticsearch/monitor/jvm/JvmInfo.java", "last_update_at": "2018-02-18T01:01:12+00:00", "question_id": "31cbd67eb1521201e6b25ba68de40b1eb0bcb91a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JvmInfo implements Streamable, Serializable, ToXContent {\n    private static JvmInfo INSTANCE;\n    static {\n        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n        // returns the <process id>@<host>\n        long pid;\n        String xPid = runtimeMXBean.getName();\n        try {\n            xPid = xPid.split(\"@\")[0];\n            pid = Long.parseLong(xPid);\n        } catch (Exception e) {\n            pid = -1;\n        }\n        JvmInfo info = new JvmInfo();\n        info.pid = pid;\n        info.startTime = runtimeMXBean.getStartTime();\n        info.version = runtimeMXBean.getSystemProperties().get(\"java.version\");\n        info.vmName = runtimeMXBean.getVmName();\n        info.vmVendor = runtimeMXBean.getVmVendor();\n        info.vmVersion = runtimeMXBean.getVmVersion();\n        info.mem = new Mem();\n        info.mem.heapInit = memoryMXBean.getHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getInit();\n        info.mem.heapMax = memoryMXBean.getHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getMax();\n        info.mem.nonHeapInit = memoryMXBean.getNonHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getInit();\n        info.mem.nonHeapMax = memoryMXBean.getNonHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getMax();\n        try {\n            Class<?> vmClass = Class.forName(\"sun.misc.VM\");\n            info.mem.directMemoryMax = (Long) vmClass.getMethod(\"maxDirectMemory\").invoke(null);\n        } catch (Throwable t) {\n            // ignore\n        }\n        info.inputArguments = runtimeMXBean.getInputArguments().toArray(new String[runtimeMXBean.getInputArguments().size()]);\n        info.bootClassPath = runtimeMXBean.getBootClassPath();\n        info.classPath = runtimeMXBean.getClassPath();\n        info.systemProperties = runtimeMXBean.getSystemProperties();\n        List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        info.gcCollectors = new String[gcMxBeans.size()];\n        for (int i = 0; i < gcMxBeans.size(); i++) {\n            GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);\n            info.gcCollectors[i] = gcMxBean.getName();\n        }\n        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n        info.memoryPools = new String[memoryPoolMXBeans.size()];\n        for (int i = 0; i < memoryPoolMXBeans.size(); i++) {\n            MemoryPoolMXBean memoryPoolMXBean = memoryPoolMXBeans.get(i);\n            info.memoryPools[i] = memoryPoolMXBean.getName();\n        }\n        INSTANCE = info;\n    }\n    public static JvmInfo jvmInfo() {\n        return INSTANCE;\n    }\n    long pid = -1;\n    String version = \"\";\n    String vmName = \"\";\n    String vmVersion = \"\";\n    String vmVendor = \"\";\n    long startTime = -1;\n    Mem mem;\n    String[] inputArguments;\n    String bootClassPath;\n    String classPath;\n    Map<String, String> systemProperties;\n    String[] gcCollectors = Strings.EMPTY_ARRAY;\n    String[] memoryPools = Strings.EMPTY_ARRAY;\n    private JvmInfo() {\n    }\n    /**\n     * The process id.\n     */\n    public long pid() {\n        return this.pid;\n    }\n    /**\n     * The process id.\n     */\n    public long getPid() {\n        return pid;\n    }\n    public String version() {\n        return this.version;\n    }\n    public String getVersion() {\n        return this.version;\n    }\n    public int versionAsInteger() {\n        try {\n            int i = 0;\n            String sVersion = \"\";\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n                if (version.charAt(i) != '.') {\n                    sVersion += version.charAt(i);\n                }\n            }\n            if (i == 0) {\n                return -1;\n            }\n            return Integer.parseInt(sVersion);\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    public int versionUpdatePack() {\n        try {\n            int i = 0;\n            String sVersion = \"\";\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n                if (version.charAt(i) != '.') {\n                    sVersion += version.charAt(i);\n                }\n            }\n            if (i == 0) {\n                return -1;\n            }\n            Integer.parseInt(sVersion);\n            int from;\n            if (version.charAt(i) == '_') {\n                // 1.7.0_4\n                from = ++i;\n            } else if (version.charAt(i) == '-' && version.charAt(i + 1) == 'u') {\n                // 1.7.0-u2-b21\n                i = i + 2;\n                from = i;\n            } else {\n                return -1;\n            }\n            for (; i < version.length(); i++) {\n                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {\n                    break;\n                }\n            }\n            if (from == i) {\n                return -1;\n            }\n            return Integer.parseInt(version.substring(from, i));\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    public String vmName() {\n        return vmName;\n    }\n    public String getVmName() {\n        return vmName;\n    }\n    public String vmVersion() {\n        return vmVersion;\n    }\n    public String getVmVersion() {\n        return vmVersion;\n    }\n    public String vmVendor() {\n        return vmVendor;\n    }\n    public String getVmVendor() {\n        return vmVendor;\n    }\n    public long startTime() {\n        return startTime;\n    }\n    public long getStartTime() {\n        return startTime;\n    }\n    public Mem mem() {\n        return mem;\n    }\n    public Mem getMem() {\n        return mem();\n    }\n    public String[] inputArguments() {\n        return inputArguments;\n    }\n    public String[] getInputArguments() {\n        return inputArguments;\n    }\n    public String bootClassPath() {\n        return bootClassPath;\n    }\n    public String getBootClassPath() {\n        return bootClassPath;\n    }\n    public String classPath() {\n        return classPath;\n    }\n    public String getClassPath() {\n        return classPath;\n    }\n    public Map<String, String> systemProperties() {\n        return systemProperties;\n    }\n    public Map<String, String> getSystemProperties() {\n        return systemProperties;\n    }\n    @Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(Fields.JVM);\n        builder.field(Fields.PID, pid);\n        builder.field(Fields.VERSION, version);\n        builder.field(Fields.VM_NAME, vmName);\n        builder.field(Fields.VM_VERSION, vmVersion);\n        builder.field(Fields.VM_VENDOR, vmVendor);\n        builder.field(Fields.START_TIME, startTime);\n        builder.startObject(Fields.MEM);\n        builder.byteSizeField(Fields.HEAP_INIT_IN_BYTES, Fields.HEAP_INIT, mem.heapInit);\n        builder.byteSizeField(Fields.HEAP_MAX_IN_BYTES, Fields.HEAP_MAX, mem.heapMax);\n        builder.byteSizeField(Fields.NON_HEAP_INIT_IN_BYTES, Fields.NON_HEAP_INIT, mem.nonHeapInit);\n        builder.byteSizeField(Fields.NON_HEAP_MAX_IN_BYTES, Fields.NON_HEAP_MAX, mem.nonHeapMax);\n        builder.byteSizeField(Fields.DIRECT_MAX_IN_BYTES, Fields.DIRECT_MAX, mem.directMemoryMax);\n        builder.endObject();\n        builder.field(Fields.GC_COLLECTORS, gcCollectors);\n        builder.field(Fields.MEMORY_POOLS, memoryPools);\n        builder.endObject();\n        return builder;\n    }\n    static final class Fields {\n        static final XContentBuilderString JVM = new XContentBuilderString(\"jvm\");\n        static final XContentBuilderString PID = new XContentBuilderString(\"pid\");\n        static final XContentBuilderString VERSION = new XContentBuilderString(\"version\");\n        static final XContentBuilderString VM_NAME = new XContentBuilderString(\"vm_name\");\n        static final XContentBuilderString VM_VERSION = new XContentBuilderString(\"vm_version\");\n        static final XContentBuilderString VM_VENDOR = new XContentBuilderString(\"vm_vendor\");\n        static final XContentBuilderString START_TIME = new XContentBuilderString(\"start_time\");\n        static final XContentBuilderString MEM = new XContentBuilderString(\"mem\");\n        static final XContentBuilderString HEAP_INIT = new XContentBuilderString(\"heap_init\");\n        static final XContentBuilderString HEAP_INIT_IN_BYTES = new XContentBuilderString(\"heap_init_in_bytes\");\n        static final XContentBuilderString HEAP_MAX = new XContentBuilderString(\"heap_max\");\n        static final XContentBuilderString HEAP_MAX_IN_BYTES = new XContentBuilderString(\"heap_max_in_bytes\");\n        static final XContentBuilderString NON_HEAP_INIT = new XContentBuilderString(\"non_heap_init\");\n        static final XContentBuilderString NON_HEAP_INIT_IN_BYTES = new XContentBuilderString(\"non_heap_init_in_bytes\");\n        static final XContentBuilderString NON_HEAP_MAX = new XContentBuilderString(\"non_heap_max\");\n        static final XContentBuilderString NON_HEAP_MAX_IN_BYTES = new XContentBuilderString(\"non_heap_max_in_bytes\");\n        static final XContentBuilderString DIRECT_MAX = new XContentBuilderString(\"direct_max\");\n        static final XContentBuilderString DIRECT_MAX_IN_BYTES = new XContentBuilderString(\"direct_max_in_bytes\");\n        static final XContentBuilderString GC_COLLECTORS = new XContentBuilderString(\"gc_collectors\");\n        static final XContentBuilderString MEMORY_POOLS = new XContentBuilderString(\"memory_pools\");\n    }\n    public static JvmInfo readJvmInfo(StreamInput in) throws IOException {\n        JvmInfo jvmInfo = new JvmInfo();\n        jvmInfo.readFrom(in);\n        return jvmInfo;\n    }\n    @Override\n    public void readFrom(StreamInput in) throws IOException {\n        pid = in.readLong();\n        version = in.readString();\n        vmName = in.readString();\n        vmVersion = in.readString();\n        vmVendor = in.readString();\n        startTime = in.readLong();\n        inputArguments = new String[in.readInt()];\n        for (int i = 0; i < inputArguments.length; i++) {\n            inputArguments[i] = in.readString();\n        }\n        bootClassPath = in.readString();\n        classPath = in.readString();\n        systemProperties = new HashMap<String, String>();\n        int size = in.readInt();\n        for (int i = 0; i < size; i++) {\n            systemProperties.put(in.readString(), in.readString());\n        }\n        mem = new Mem();\n        mem.readFrom(in);\n        gcCollectors = in.readStringArray();\n        memoryPools = in.readStringArray();\n    }\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeLong(pid);\n        out.writeString(version);\n        out.writeString(vmName);\n        out.writeString(vmVersion);\n        out.writeString(vmVendor);\n        out.writeLong(startTime);\n        out.writeInt(inputArguments.length);\n        for (String inputArgument : inputArguments) {\n            out.writeString(inputArgument);\n        }\n        out.writeString(bootClassPath);\n        out.writeString(classPath);\n        out.writeInt(systemProperties.size());\n        for (Map.Entry<String, String> entry : systemProperties.entrySet()) {\n            out.writeString(entry.getKey());\n            out.writeString(entry.getValue());\n        }\n        mem.writeTo(out);\n        out.writeStringArray(gcCollectors);\n        out.writeStringArray(memoryPools);\n    }\n    public static class Mem implements Streamable, Serializable {\n        long heapInit = 0;\n        long heapMax = 0;\n        long nonHeapInit = 0;\n        long nonHeapMax = 0;\n        long directMemoryMax = 0;\n        Mem() {\n        }\n        public ByteSizeValue heapInit() {\n            return new ByteSizeValue(heapInit);\n        }\n        public ByteSizeValue getHeapInit() {\n            return heapInit();\n        }\n        public ByteSizeValue heapMax() {\n            return new ByteSizeValue(heapMax);\n        }\n        public ByteSizeValue getHeapMax() {\n            return heapMax();\n        }\n        public ByteSizeValue nonHeapInit() {\n            return new ByteSizeValue(nonHeapInit);\n        }\n        public ByteSizeValue getNonHeapInit() {\n            return nonHeapInit();\n        }\n        public ByteSizeValue nonHeapMax() {\n            return new ByteSizeValue(nonHeapMax);\n        }\n        public ByteSizeValue getNonHeapMax() {\n            return nonHeapMax();\n        }\n        public ByteSizeValue directMemoryMax() {\n            return new ByteSizeValue(directMemoryMax);\n        }\n        public ByteSizeValue getDirectMemoryMax() {\n            return directMemoryMax();\n        }\n        public static Mem readMem(StreamInput in) throws IOException {\n            Mem mem = new Mem();\n            mem.readFrom(in);\n            return mem;\n        }\n        @Override\n        public void readFrom(StreamInput in) throws IOException {\n            heapInit = in.readVLong();\n            heapMax = in.readVLong();\n            nonHeapInit = in.readVLong();\n            nonHeapMax = in.readVLong();\n            directMemoryMax = in.readVLong();\n        }\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeVLong(heapInit);\n            out.writeVLong(heapMax);\n            out.writeVLong(nonHeapInit);\n            out.writeVLong(nonHeapMax);\n            out.writeVLong(directMemoryMax);\n        }\n    }\n"]], "pred": {"ppl": 1.285021424293518, "ppl_lower": 1.59734046459198, "ppl/lowercase_ppl": -1.8675677669148503, "ppl/zlib": 0.00010227381354410947, "Min_5.0% Prob": 3.66840585306579, "Min_10.0% Prob": 2.276523732379371, "Min_20.0% Prob": 1.239243087705736, "Min_30.0% Prob": 0.8359721675423869, "Min_40.0% Prob": 0.626760360906652, "Min_50.0% Prob": 0.5019348910103011, "Min_60.0% Prob": 0.418481307075316}}
{"hexsha": "8de92d28783d7456975c97221929990dc767c422", "ext": "java", "lang": "Java", "content": "public class FilterTools {\n\n    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ThreadSnapshotFilter> subclasses) {\n        Classifier cls = new Classifier();\n        cls.rootFilter = rootFilter;\n        cls.subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>(subclasses);\n        return cls;\n    }\n\n    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ClassificatorAST.Filter> subclasses, BasicFilterFactory filterFactory) {\n        Map<String, ThreadSnapshotFilter> subf = new LinkedHashMap<String, ThreadSnapshotFilter>();\n        for(String k: subclasses.keySet()) {\n            subf.put(k, filterFactory.build(subclasses.get(k)));\n        }\n        Classifier cls = new Classifier();\n        cls.rootFilter = rootFilter;\n        cls.subclasses = subf;\n        return cls;\n    }\n\n    public static SimpleTraceFilter toSimpleFilter(ThreadSnapshotFilter filter) {\n        Filter simpleFilter = new Filter();\n        simpleFilter.filter = filter;\n        return simpleFilter;\n    }\n    \n    private static class Classifier implements SimpleTraceFilter, SimpleTraceClassifier {\n\n        ThreadSnapshotFilter rootFilter;\n        Map<String, ThreadSnapshotFilter> subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>();\n        DummyThreadSnapshot dummy = new DummyThreadSnapshot();\n        \n        @Override\n        public String classify(StackFrame[] list) {\n            dummy.array = list;\n            if (rootFilter != null && !rootFilter.evaluate(dummy)) {\n                return null;\n            }\n            for(String key: subclasses.keySet()) {\n                ThreadSnapshotFilter filter = subclasses.get(key);\n                if (filter.evaluate(dummy)) {\n                    return key;\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public boolean evaluate(StackFrame[] list) {\n            return classify(list) != null;\n        }\n    }\n\n    private static class Filter implements SimpleTraceFilter {\n\n        ThreadSnapshotFilter filter;\n        DummyThreadSnapshot dummy = new DummyThreadSnapshot();\n        \n        @Override\n        public boolean evaluate(StackFrame[] list) {\n            dummy.array = list;\n            return filter.evaluate(dummy);\n        }\n    }\n    \n    private static class DummyThreadSnapshot extends AbstractStackFrameArray implements ThreadSnapshot {\n\n        private StackFrame[] array;\n        \n        @Override\n        protected StackFrame[] array() {\n            return array;\n        }\n\n        @Override\n        protected int from() {\n            return 0;\n        }\n\n        @Override\n        protected int to() {\n            return array.length;\n        }\n\n        @Override\n        public long threadId() {\n            return 0;\n        }\n\n        @Override\n        public String threadName() {\n            return null;\n        }\n\n        @Override\n        public long timestamp() {\n            return 0;\n        }\n\n        @Override\n        public StackFrameList stackTrace() {\n            return this;\n        }\n\n        @Override\n        public State threadState() {\n            return null;\n        }\n\n        @Override\n        public CounterCollection counters() {\n            return CounterArray.EMPTY;\n        }\n\n        //@Override\n        public boolean isEmpty() {\n            return depth() == 0;\n        }\n    }    \n}", "class_id": 0, "repo": "aragozin/stackviewer", "file": "src/test/java/org/gridkit/sjk/ssa/ui/FilterTools.java", "last_update_at": "2018-04-14T21:11:36+00:00", "question_id": "8de92d28783d7456975c97221929990dc767c422", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilterTools {\n    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ThreadSnapshotFilter> subclasses) {\n        Classifier cls = new Classifier();\n        cls.rootFilter = rootFilter;\n        cls.subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>(subclasses);\n        return cls;\n    }\n    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ClassificatorAST.Filter> subclasses, BasicFilterFactory filterFactory) {\n        Map<String, ThreadSnapshotFilter> subf = new LinkedHashMap<String, ThreadSnapshotFilter>();\n        for(String k: subclasses.keySet()) {\n            subf.put(k, filterFactory.build(subclasses.get(k)));\n        }\n        Classifier cls = new Classifier();\n        cls.rootFilter = rootFilter;\n        cls.subclasses = subf;\n        return cls;\n    }\n    public static SimpleTraceFilter toSimpleFilter(ThreadSnapshotFilter filter) {\n        Filter simpleFilter = new Filter();\n        simpleFilter.filter = filter;\n        return simpleFilter;\n    }\n    private static class Classifier implements SimpleTraceFilter, SimpleTraceClassifier {\n        ThreadSnapshotFilter rootFilter;\n        Map<String, ThreadSnapshotFilter> subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>();\n        DummyThreadSnapshot dummy = new DummyThreadSnapshot();\n        @Override\n        public String classify(StackFrame[] list) {\n            dummy.array = list;\n            if (rootFilter != null && !rootFilter.evaluate(dummy)) {\n                return null;\n            }\n            for(String key: subclasses.keySet()) {\n                ThreadSnapshotFilter filter = subclasses.get(key);\n                if (filter.evaluate(dummy)) {\n                    return key;\n                }\n            }\n            return null;\n        }\n        @Override\n        public boolean evaluate(StackFrame[] list) {\n            return classify(list) != null;\n        }\n    }\n    private static class Filter implements SimpleTraceFilter {\n        ThreadSnapshotFilter filter;\n        DummyThreadSnapshot dummy = new DummyThreadSnapshot();\n        @Override\n        public boolean evaluate(StackFrame[] list) {\n            dummy.array = list;\n            return filter.evaluate(dummy);\n        }\n    }\n    private static class DummyThreadSnapshot extends AbstractStackFrameArray implements ThreadSnapshot {\n        private StackFrame[] array;\n        @Override\n        protected StackFrame[] array() {\n            return array;\n        }\n        @Override\n        protected int from() {\n            return 0;\n        }\n        @Override\n        protected int to() {\n            return array.length;\n        }\n        @Override\n        public long threadId() {\n            return 0;\n        }\n        @Override\n        public String threadName() {\n            return null;\n        }\n        @Override\n        public long timestamp() {\n            return 0;\n        }\n        @Override\n        public StackFrameList stackTrace() {\n            return this;\n        }\n        @Override\n        public State threadState() {\n            return null;\n        }\n        @Override\n        public CounterCollection counters() {\n            return CounterArray.EMPTY;\n        }\n        //@Override\n        public boolean isEmpty() {\n            return depth() == 0;\n        }\n    }    \n"]], "pred": {"ppl": 1.8061836957931519, "ppl_lower": 1.949180245399475, "ppl/lowercase_ppl": -1.128874577287535, "ppl/zlib": 0.0008000218727922038, "Min_5.0% Prob": 6.587066458492744, "Min_10.0% Prob": 4.574157894375813, "Min_20.0% Prob": 2.7935630250048926, "Min_30.0% Prob": 1.9393577118217946, "Min_40.0% Prob": 1.4731333064581003, "Min_50.0% Prob": 1.1805040277362013, "Min_60.0% Prob": 0.985578414330259}}
{"hexsha": "69cd4c8caf8f1f53ec0db2a5f9d9fa670bd2c6c6", "ext": "java", "lang": "Java", "content": "public class CityTest {\n\n\n    @Test\n    public void testGson() {\n        Province p1=new Province(\"\u6d59\u6c5f\",\"ZheJiang\",18888);\n        System.out.println(p1.toString());\n\n        City c1=new City(p1,\"\u676d\u5dde\",343342);\n        System.out.println(c1.toString());\n\n        Gson gson = new Gson();\n        System.out.println(\"p1 to Json String:\"+gson.toJson(p1));\n        System.out.println(\"c1 to Json String:\"+gson.toJson(c1));\n        System.out.println(\"c1 to Json String:\"+c1.getJsonString());\n\n        City c2=gson.fromJson(\"{\\\"p\\\":{\\\"name_c\\\":\\\"\u6d59\u6c5f\\\",\\\"name_e\\\":\\\"ZheJiang\\\",\\\"population\\\":18888},\\\"name\\\":\\\"\u6e29\u5dde\\\",\\\"population\\\":4342}\",City.class);\n        System.out.println(\"c2:\"+c2.toString());\n\n    }\n\n\n\n}", "class_id": 0, "repo": "nanyi5452/cleanDemo", "file": "sqlitebyrx/src/test/java/com/example/xiaomao/sqlitebyrx/entityTests/CityTest.java", "last_update_at": "2018-07-22T09:34:48+00:00", "question_id": "69cd4c8caf8f1f53ec0db2a5f9d9fa670bd2c6c6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CityTest {\n    @Test\n    public void testGson() {\n        Province p1=new Province(\"\u6d59\u6c5f\",\"ZheJiang\",18888);\n        System.out.println(p1.toString());\n        City c1=new City(p1,\"\u676d\u5dde\",343342);\n        System.out.println(c1.toString());\n        Gson gson = new Gson();\n        System.out.println(\"p1 to Json String:\"+gson.toJson(p1));\n        System.out.println(\"c1 to Json String:\"+gson.toJson(c1));\n        System.out.println(\"c1 to Json String:\"+c1.getJsonString());\n        City c2=gson.fromJson(\"{\\\"p\\\":{\\\"name_c\\\":\\\"\u6d59\u6c5f\\\",\\\"name_e\\\":\\\"ZheJiang\\\",\\\"population\\\":18888},\\\"name\\\":\\\"\u6e29\u5dde\\\",\\\"population\\\":4342}\",City.class);\n        System.out.println(\"c2:\"+c2.toString());\n    }\n"]], "pred": {"ppl": 2.125579595565796, "ppl_lower": 2.3819994926452637, "ppl/lowercase_ppl": -1.1510464428475242, "ppl/zlib": 0.0023712091699406297, "Min_5.0% Prob": 5.6620570329519415, "Min_10.0% Prob": 4.321512893394187, "Min_20.0% Prob": 3.0845774173736573, "Min_30.0% Prob": 2.3527361075562165, "Min_40.0% Prob": 1.8463993116810515, "Min_50.0% Prob": 1.4971082033656484, "Min_60.0% Prob": 1.260365405277046}}
{"hexsha": "099e9c64012edec58e7e7bf17462aa6cdfba0a14", "ext": "java", "lang": "Java", "content": "public class GcmRefreshJob extends ContextJob implements InjectableType {\n\n  private static final String TAG = GcmRefreshJob.class.getSimpleName();\n\n  public static final String REGISTRATION_ID = \"312334754206\";\n\n  @Inject transient SignalServiceAccountManager textSecureAccountManager;\n  @Inject transient RedPhoneAccountManager      redPhoneAccountManager;\n\n  public GcmRefreshJob(Context context) {\n    super(context, JobParameters.newBuilder().withRequirement(new NetworkRequirement(context)).create());\n  }\n\n  @Override\n  public void onAdded() {}\n\n  @Override\n  public void onRun() throws Exception {\n    String registrationId = TextSecurePreferences.getGcmRegistrationId(context);\n\n    if (registrationId == null) {\n      Log.w(TAG, \"GCM registrationId expired, reregistering...\");\n      int result = GooglePlayServicesUtil.isGooglePlayServicesAvailable(context);\n\n      if (result != ConnectionResult.SUCCESS) {\n        notifyGcmFailure();\n      } else {\n        String gcmId = GoogleCloudMessaging.getInstance(context).register(REGISTRATION_ID);\n        textSecureAccountManager.setGcmId(Optional.of(gcmId));\n\n        try {\n          redPhoneAccountManager.setGcmId(Optional.of(gcmId));\n        } catch (UnauthorizedException e) {\n          Log.w(TAG, e);\n        }\n\n        TextSecurePreferences.setGcmRegistrationId(context, gcmId);\n        TextSecurePreferences.setWebsocketRegistered(context, true);\n      }\n    }\n  }\n\n  @Override\n  public void onCanceled() {\n    Log.w(TAG, \"GCM reregistration failed after retry attempt exhaustion!\");\n  }\n\n  @Override\n  public boolean onShouldRetry(Exception throwable) {\n    if (throwable instanceof NonSuccessfulResponseCodeException) return false;\n    return true;\n  }\n\n  private void notifyGcmFailure() {\n    Intent                     intent        = new Intent(context, PlayServicesProblemActivity.class);\n    PendingIntent              pendingIntent = PendingIntent.getActivity(context, 1122, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n    NotificationCompat.Builder builder       = new NotificationCompat.Builder(context);\n\n    builder.setSmallIcon(R.drawable.icon_notification);\n    builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(),\n                                                      R.drawable.ic_action_warning_red));\n    builder.setContentTitle(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));\n    builder.setContentText(context.getString(R.string.GcmRefreshJob_Signal_was_unable_to_register_with_Google_Play_Services));\n    builder.setTicker(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));\n    builder.setVibrate(new long[] {0, 1000});\n    builder.setContentIntent(pendingIntent);\n\n    ((NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE))\n        .notify(12, builder.build());\n  }\n\n}", "class_id": 0, "repo": "varkon/MilChat", "file": "src/ua/org/slovo/securesms/jobs/GcmRefreshJob.java", "last_update_at": "2018-04-15T13:30:15+00:00", "question_id": "099e9c64012edec58e7e7bf17462aa6cdfba0a14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class GcmRefreshJob extends ContextJob implements InjectableType {\n  private static final String TAG = GcmRefreshJob.class.getSimpleName();\n  public static final String REGISTRATION_ID = \"312334754206\";\n  @Inject transient SignalServiceAccountManager textSecureAccountManager;\n  @Inject transient RedPhoneAccountManager      redPhoneAccountManager;\n  public GcmRefreshJob(Context context) {\n    super(context, JobParameters.newBuilder().withRequirement(new NetworkRequirement(context)).create());\n  }\n  @Override\n  public void onAdded() {}\n  @Override\n  public void onRun() throws Exception {\n    String registrationId = TextSecurePreferences.getGcmRegistrationId(context);\n    if (registrationId == null) {\n      Log.w(TAG, \"GCM registrationId expired, reregistering...\");\n      int result = GooglePlayServicesUtil.isGooglePlayServicesAvailable(context);\n      if (result != ConnectionResult.SUCCESS) {\n        notifyGcmFailure();\n      } else {\n        String gcmId = GoogleCloudMessaging.getInstance(context).register(REGISTRATION_ID);\n        textSecureAccountManager.setGcmId(Optional.of(gcmId));\n        try {\n          redPhoneAccountManager.setGcmId(Optional.of(gcmId));\n        } catch (UnauthorizedException e) {\n          Log.w(TAG, e);\n        }\n        TextSecurePreferences.setGcmRegistrationId(context, gcmId);\n        TextSecurePreferences.setWebsocketRegistered(context, true);\n      }\n    }\n  }\n  @Override\n  public void onCanceled() {\n    Log.w(TAG, \"GCM reregistration failed after retry attempt exhaustion!\");\n  }\n  @Override\n  public boolean onShouldRetry(Exception throwable) {\n    if (throwable instanceof NonSuccessfulResponseCodeException) return false;\n    return true;\n  }\n  private void notifyGcmFailure() {\n    Intent                     intent        = new Intent(context, PlayServicesProblemActivity.class);\n    PendingIntent              pendingIntent = PendingIntent.getActivity(context, 1122, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n    NotificationCompat.Builder builder       = new NotificationCompat.Builder(context);\n    builder.setSmallIcon(R.drawable.icon_notification);\n    builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(),\n                                                      R.drawable.ic_action_warning_red));\n    builder.setContentTitle(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));\n    builder.setContentText(context.getString(R.string.GcmRefreshJob_Signal_was_unable_to_register_with_Google_Play_Services));\n    builder.setTicker(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));\n    builder.setVibrate(new long[] {0, 1000});\n    builder.setContentIntent(pendingIntent);\n    ((NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE))\n        .notify(12, builder.build());\n  }\n"]], "pred": {"ppl": 2.0654566287994385, "ppl_lower": 2.636256217956543, "ppl/lowercase_ppl": -1.3364004058899497, "ppl/zlib": 0.0006594102997416103, "Min_5.0% Prob": 6.977253832468173, "Min_10.0% Prob": 5.101907154408897, "Min_20.0% Prob": 3.292549038078727, "Min_30.0% Prob": 2.360669771729693, "Min_40.0% Prob": 1.8041989755304388, "Min_50.0% Prob": 1.4476459126431243, "Min_60.0% Prob": 1.209113357701765}}
{"hexsha": "e15072953d44f08d20d8ddb6630b4142699dd6e7", "ext": "java", "lang": "Java", "content": "public class WordIdMapCompilerTest {\n\n    @Test\n    public void testGrowableArray() {\n        WordIdMapCompiler.GrowableIntArray array = new WordIdMapCompiler.GrowableIntArray(5);\n        array.set(3, 1);\n        assertEquals(\"[0, 0, 0, 1]\", Arrays.toString(array.getArray()));\n        array.set(0, 2);\n        array.set(10, 3);\n        assertEquals(\"[2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3]\", Arrays.toString(array.getArray()));\n    }\n\n    @Test\n    public void testCompiler() throws IOException {\n        WordIdMapCompiler compiler = new WordIdMapCompiler();\n        compiler.addMapping(3, 1);\n        compiler.addMapping(3, 2);\n        compiler.addMapping(3, 3);\n        compiler.addMapping(10, 0);\n\n        File file = File.createTempFile(\"kuromoji-wordid-\", \".bin\");\n        file.deleteOnExit();\n\n        OutputStream output = new BufferedOutputStream(new FileOutputStream(file));\n\n        compiler.write(output);\n        output.close();\n\n        InputStream input = new BufferedInputStream(new FileInputStream(file));\n\n        WordIdMap wordIds = new WordIdMap(input);\n\n        assertEquals(\"[1, 2, 3]\", Arrays.toString(wordIds.lookUp(3)));\n        assertEquals(\"[0]\", Arrays.toString(wordIds.lookUp(10)));\n        assertEquals(\"[]\", Arrays.toString(wordIds.lookUp(1)));\n    }\n}", "class_id": 0, "repo": "johndemic/deeplearning4j", "file": "deeplearning4j-nlp-parent/deeplearning4j-nlp-japanese/src/test/java/com/atilika/kuromoji/compile/WordIdMapCompilerTest.java", "last_update_at": "2018-12-02T13:05:59+00:00", "question_id": "e15072953d44f08d20d8ddb6630b4142699dd6e7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WordIdMapCompilerTest {\n    @Test\n    public void testGrowableArray() {\n        WordIdMapCompiler.GrowableIntArray array = new WordIdMapCompiler.GrowableIntArray(5);\n        array.set(3, 1);\n        assertEquals(\"[0, 0, 0, 1]\", Arrays.toString(array.getArray()));\n        array.set(0, 2);\n        array.set(10, 3);\n        assertEquals(\"[2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3]\", Arrays.toString(array.getArray()));\n    }\n    @Test\n    public void testCompiler() throws IOException {\n        WordIdMapCompiler compiler = new WordIdMapCompiler();\n        compiler.addMapping(3, 1);\n        compiler.addMapping(3, 2);\n        compiler.addMapping(3, 3);\n        compiler.addMapping(10, 0);\n        File file = File.createTempFile(\"kuromoji-wordid-\", \".bin\");\n        file.deleteOnExit();\n        OutputStream output = new BufferedOutputStream(new FileOutputStream(file));\n        compiler.write(output);\n        output.close();\n        InputStream input = new BufferedInputStream(new FileInputStream(file));\n        WordIdMap wordIds = new WordIdMap(input);\n        assertEquals(\"[1, 2, 3]\", Arrays.toString(wordIds.lookUp(3)));\n        assertEquals(\"[0]\", Arrays.toString(wordIds.lookUp(10)));\n        assertEquals(\"[]\", Arrays.toString(wordIds.lookUp(1)));\n    }\n"]], "pred": {"ppl": 1.6753864288330078, "ppl_lower": 1.9591608047485352, "ppl/lowercase_ppl": -1.303215280159264, "ppl/zlib": 0.001234554647009342, "Min_5.0% Prob": 5.3428498148918155, "Min_10.0% Prob": 3.7088904700628142, "Min_20.0% Prob": 2.3274372241583214, "Min_30.0% Prob": 1.6740683592557908, "Min_40.0% Prob": 1.2851763768458222, "Min_50.0% Prob": 1.0314902732274136, "Min_60.0% Prob": 0.8599332163482905}}
{"hexsha": "b988d9d974cb5b731fb663b05fd6ef66706564d3", "ext": "java", "lang": "Java", "content": "public class AliasCombinationsFunctionsFirstNameTest {\n\n    @Test\n    public void shouldReturnEmptyListForEmptyFirstName() {\n        InputNames emptyFirstName = new InputNames(\"\", \"somename\", \"somename\");\n        assertThat(firstNameCombinations(emptyFirstName, emptyFirstName)).isEqualTo(emptyList());\n    }\n\n    @Test\n    public void shouldReturnEmptyListForOneName() {\n        InputNames oneFirstName = new InputNames(\"John\", \"somename\", \"somename\");\n\n        assertThat(firstNameCombinations(oneFirstName, oneFirstName)).isEqualTo(emptyList());\n    }\n\n    @Test\n    public void shouldReturnCombinationsForTwoNames() {\n        InputNames inputNames = new InputNames(\"John David\", \"somename\", \"somename\");\n\n        List<CandidateName> expected = asList(\n                new CandidateName(\"John\", \"David\"),\n                new CandidateName(\"David\", \"John\")\n        );\n\n        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);\n    }\n\n    @Test\n    public void shouldReturnCombinationsForThreeNames() {\n        InputNames inputNames = new InputNames(\"John David Greg\", \"somename\", \"somename\");\n\n        List<CandidateName> expected = asList(\n                new CandidateName(\"John\", \"David\"),\n                new CandidateName(\"John\", \"Greg\"),\n                new CandidateName(\"David\", \"John\"),\n                new CandidateName(\"David\", \"Greg\"),\n                new CandidateName(\"Greg\", \"John\"),\n                new CandidateName(\"Greg\", \"David\")\n        );\n\n        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);\n    }\n}", "class_id": 0, "repo": "UKHomeOffice/pttg-ip-hmrc", "file": "src/test/java/uk/gov/digital/ho/pttg/application/namematching/candidates/AliasCombinationsFunctionsFirstNameTest.java", "last_update_at": "2018-11-23T09:34:49+00:00", "question_id": "b988d9d974cb5b731fb663b05fd6ef66706564d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AliasCombinationsFunctionsFirstNameTest {\n    @Test\n    public void shouldReturnEmptyListForEmptyFirstName() {\n        InputNames emptyFirstName = new InputNames(\"\", \"somename\", \"somename\");\n        assertThat(firstNameCombinations(emptyFirstName, emptyFirstName)).isEqualTo(emptyList());\n    }\n    @Test\n    public void shouldReturnEmptyListForOneName() {\n        InputNames oneFirstName = new InputNames(\"John\", \"somename\", \"somename\");\n        assertThat(firstNameCombinations(oneFirstName, oneFirstName)).isEqualTo(emptyList());\n    }\n    @Test\n    public void shouldReturnCombinationsForTwoNames() {\n        InputNames inputNames = new InputNames(\"John David\", \"somename\", \"somename\");\n        List<CandidateName> expected = asList(\n                new CandidateName(\"John\", \"David\"),\n                new CandidateName(\"David\", \"John\")\n        );\n        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);\n    }\n    @Test\n    public void shouldReturnCombinationsForThreeNames() {\n        InputNames inputNames = new InputNames(\"John David Greg\", \"somename\", \"somename\");\n        List<CandidateName> expected = asList(\n                new CandidateName(\"John\", \"David\"),\n                new CandidateName(\"John\", \"Greg\"),\n                new CandidateName(\"David\", \"John\"),\n                new CandidateName(\"David\", \"Greg\"),\n                new CandidateName(\"Greg\", \"John\"),\n                new CandidateName(\"Greg\", \"David\")\n        );\n        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);\n    }\n"]], "pred": {"ppl": 1.6038073301315308, "ppl_lower": 1.7753264904022217, "ppl/lowercase_ppl": -1.2150892879593604, "ppl/zlib": 0.0014314557086596053, "Min_5.0% Prob": 6.127400523140317, "Min_10.0% Prob": 3.989953797917033, "Min_20.0% Prob": 2.2798627440271706, "Min_30.0% Prob": 1.5678418339445042, "Min_40.0% Prob": 1.178183829010432, "Min_50.0% Prob": 0.9462057557665154, "Min_60.0% Prob": 0.7871527724936819}}
{"hexsha": "22fdfe969053dc549bef8f8429d68e7938478eff", "ext": "java", "lang": "Java", "content": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        int n = version1.length();\n        int m = version2.length();\n\n        // compare level by level\n        boolean if1done = false;\n        boolean if2done = false;\n        \n        while(true) {\n            int val1;\n            if (if1done)\n                val1 = 0;\n            else {\n                int end1 = version1.indexOf('.');\n                if (end1 == -1) {\n                    val1 = Integer.valueOf(version1);\n                    if1done = true;\n                } else  {\n                    val1 = Integer.valueOf(version1.substring(0, end1));\n                    version1 = version1.substring(end1 + 1);\n                    n -= end1 + 1;\n                }\n            }\n                \n            int val2;\n            if (if2done)\n                val2 = 0;\n            else {\n                int end2 = version2.indexOf('.');\n                if (end2 == -1)\n                    val2 = Integer.valueOf(version2);\n                if (end2 == -1) {\n                    val2 = Integer.valueOf(version2);\n                    if2done = true;\n                } else {\n                    val2 = Integer.valueOf(version2.substring(0, end2));\n                    version2 = version2.substring(end2 + 1);\n                    n -= end2 + 1;\n                }\n            }\n            \n            \n            if (val1 > val2)\n                return 1;\n            else if (val1 < val2)\n                return -1;\n            else if (if1done && if2done)\n                return 0;\n        }\n    }\n}", "class_id": 0, "repo": "sculd/algorithm_challenge", "file": "eclipse_ws/CompareVersionNumbers/src/CompareVersionNumbers.java", "last_update_at": "2018-11-09T22:20:38+00:00", "question_id": "22fdfe969053dc549bef8f8429d68e7938478eff", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Solution {\n    public int compareVersion(String version1, String version2) {\n        int n = version1.length();\n        int m = version2.length();\n        // compare level by level\n        boolean if1done = false;\n        boolean if2done = false;\n        while(true) {\n            int val1;\n            if (if1done)\n                val1 = 0;\n            else {\n                int end1 = version1.indexOf('.');\n                if (end1 == -1) {\n                    val1 = Integer.valueOf(version1);\n                    if1done = true;\n                } else  {\n                    val1 = Integer.valueOf(version1.substring(0, end1));\n                    version1 = version1.substring(end1 + 1);\n                    n -= end1 + 1;\n                }\n            }\n            int val2;\n            if (if2done)\n                val2 = 0;\n            else {\n                int end2 = version2.indexOf('.');\n                if (end2 == -1)\n                    val2 = Integer.valueOf(version2);\n                if (end2 == -1) {\n                    val2 = Integer.valueOf(version2);\n                    if2done = true;\n                } else {\n                    val2 = Integer.valueOf(version2.substring(0, end2));\n                    version2 = version2.substring(end2 + 1);\n                    n -= end2 + 1;\n                }\n            }\n            if (val1 > val2)\n                return 1;\n            else if (val1 < val2)\n                return -1;\n            else if (if1done && if2done)\n                return 0;\n        }\n    }\n"]], "pred": {"ppl": 1.4656834602355957, "ppl_lower": 1.5948805809020996, "ppl/lowercase_ppl": -1.2209584547537247, "ppl/zlib": 0.0010061096300994974, "Min_5.0% Prob": 5.183623711268107, "Min_10.0% Prob": 3.3507336434863864, "Min_20.0% Prob": 1.8782140020103681, "Min_30.0% Prob": 1.264800013798311, "Min_40.0% Prob": 0.955092771116578, "Min_50.0% Prob": 0.7629946625817848, "Min_60.0% Prob": 0.6375541819147692}}
{"hexsha": "bc60dbb1269927fe1301f18bc2cc94ee85ca2703", "ext": "java", "lang": "Java", "content": "public class Example {\n    protected boolean less(Comparable x, Comparable y) {\n        return x.compareTo(y) < 0;\n    }\n\n    protected void exch(Comparable[] arr, int x, int y) {\n        Comparable temp = arr[x];\n        arr[x] = arr[y];\n        arr[y] = temp;\n    }\n\n    public boolean isSorted(Comparable[] arr) {\n        for (int i = 1; i < arr.length; ++i)\n            if (arr[i - 1].compareTo(arr[i]) > 0) return false;\n        return true;\n    }\n\n    public void show(Comparable[] arr) {\n        for (int i = 0; i < arr.length; ++i)\n            System.out.print(arr[i]+\" \");\n        System.out.println();\n    }\n\n\n    public  void sort(Comparable[] arr) {\n        // remain to impl\n    }\n\n\n}", "class_id": 0, "repo": "Andrewpqc/algorithms", "file": "Jalgorithms/src/sort/Example.java", "last_update_at": "2018-12-03T15:49:30+00:00", "question_id": "bc60dbb1269927fe1301f18bc2cc94ee85ca2703", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Example {\n    protected boolean less(Comparable x, Comparable y) {\n        return x.compareTo(y) < 0;\n    }\n    protected void exch(Comparable[] arr, int x, int y) {\n        Comparable temp = arr[x];\n        arr[x] = arr[y];\n        arr[y] = temp;\n    }\n    public boolean isSorted(Comparable[] arr) {\n        for (int i = 1; i < arr.length; ++i)\n            if (arr[i - 1].compareTo(arr[i]) > 0) return false;\n        return true;\n    }\n    public void show(Comparable[] arr) {\n        for (int i = 0; i < arr.length; ++i)\n            System.out.print(arr[i]+\" \");\n        System.out.println();\n    }\n    public  void sort(Comparable[] arr) {\n        // remain to impl\n    }\n"]], "pred": {"ppl": 1.6295623779296875, "ppl_lower": 1.7930853366851807, "ppl/lowercase_ppl": -1.1958305079366813, "ppl/zlib": 0.0016722996540197953, "Min_5.0% Prob": 6.177532871564229, "Min_10.0% Prob": 4.2195010383923846, "Min_20.0% Prob": 2.3710616674958445, "Min_30.0% Prob": 1.6308234065566978, "Min_40.0% Prob": 1.2218968704703967, "Min_50.0% Prob": 0.9751500633726942, "Min_60.0% Prob": 0.8165972703833412}}
{"hexsha": "3b6c1b2cc43e8d6dbe227f98f253fc63f1878407", "ext": "java", "lang": "Java", "content": "public final class OracleSegmentsExtractorRegistry implements SQLSegmentsExtractorRegistry {\n    \n    private static final Map<SQLStatementType, SQLStatementExtractor> EXTRACTORS = new HashMap<>();\n    \n    static {\n        registerDDL();\n    }\n    \n    private static void registerDDL() {\n        EXTRACTORS.put(SQLStatementType.CREATE_TABLE, new CreateTableExtractor());\n        EXTRACTORS.put(SQLStatementType.ALTER_TABLE, new OracleAlterTableExtractor());\n        EXTRACTORS.put(SQLStatementType.DROP_TABLE, new OracleDropTableExtractor());\n        EXTRACTORS.put(SQLStatementType.TRUNCATE_TABLE, new OracleTruncateTableExtractor());\n        EXTRACTORS.put(SQLStatementType.CREATE_INDEX, new CreateIndexExtractor());\n        EXTRACTORS.put(SQLStatementType.ALTER_INDEX, new OracleAlterIndexExtractor());\n        EXTRACTORS.put(SQLStatementType.DROP_INDEX, new OracleDropIndexExtractor());\n    }\n    \n    @Override\n    public SQLStatementExtractor getExtractor(final SQLStatementType type) {\n        return EXTRACTORS.get(type);\n    }\n}", "class_id": 0, "repo": "kaikai2000/sharding-sphere", "file": "sharding-core/src/main/java/io/shardingsphere/core/parsing/antlr/extractor/registry/dialect/OracleSegmentsExtractorRegistry.java", "last_update_at": "2018-12-06T23:48:36+00:00", "question_id": "3b6c1b2cc43e8d6dbe227f98f253fc63f1878407", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class OracleSegmentsExtractorRegistry implements SQLSegmentsExtractorRegistry {\n    private static final Map<SQLStatementType, SQLStatementExtractor> EXTRACTORS = new HashMap<>();\n    static {\n        registerDDL();\n    }\n    private static void registerDDL() {\n        EXTRACTORS.put(SQLStatementType.CREATE_TABLE, new CreateTableExtractor());\n        EXTRACTORS.put(SQLStatementType.ALTER_TABLE, new OracleAlterTableExtractor());\n        EXTRACTORS.put(SQLStatementType.DROP_TABLE, new OracleDropTableExtractor());\n        EXTRACTORS.put(SQLStatementType.TRUNCATE_TABLE, new OracleTruncateTableExtractor());\n        EXTRACTORS.put(SQLStatementType.CREATE_INDEX, new CreateIndexExtractor());\n        EXTRACTORS.put(SQLStatementType.ALTER_INDEX, new OracleAlterIndexExtractor());\n        EXTRACTORS.put(SQLStatementType.DROP_INDEX, new OracleDropIndexExtractor());\n    }\n    @Override\n    public SQLStatementExtractor getExtractor(final SQLStatementType type) {\n        return EXTRACTORS.get(type);\n    }\n"]], "pred": {"ppl": 1.457916021347046, "ppl_lower": 1.7936798334121704, "ppl/lowercase_ppl": -1.549752871920819, "ppl/zlib": 0.001167207533746762, "Min_5.0% Prob": 5.443067296346029, "Min_10.0% Prob": 3.2842510600884753, "Min_20.0% Prob": 1.8521369941532613, "Min_30.0% Prob": 1.2528466648629142, "Min_40.0% Prob": 0.9417522154806648, "Min_50.0% Prob": 0.7538377684215084, "Min_60.0% Prob": 0.6283071111067936}}
{"hexsha": "46e17bf80c0da7910855abeedcdca5059fe75ba8", "ext": "java", "lang": "Java", "content": "public class ZkClientCacheFactory {\n\n\tstatic ConcurrentHashMap<String, InteligentZKClient> cache = new ConcurrentHashMap<String, InteligentZKClient>();\n\t\n\tpublic static InteligentZKClient getZKClient(String server) {\n\t\treturn cache.get(server);\n\t}\n\t\n\tpublic static InteligentZKClient getZKClientIfNoneCreate(String server) {\n\t\tInteligentZKClient zk = cache.get(server);\n\t\tif(zk==null) {\n\t\t\tsynchronized (cache) {\n\t\t\t\tzk = cache.get(server);\n\t\t\t\tif(zk==null) {\n\t\t\t\t\tzk = new InteligentZKClient(server);\n\t\t\t\t\tcache.put(server, zk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!zk.isAvaliable()) {\n\t\t\tzk.reCreateClient();\n\t\t}\n\t\treturn zk;\n\t}\n\t\n\t\n}", "class_id": 0, "repo": "stoneapple/zooguardian", "file": "src/main/java/com/stone/zookeeper/zooguardians/cache/ZkClientCacheFactory.java", "last_update_at": "2018-03-27T16:53:10+00:00", "question_id": "46e17bf80c0da7910855abeedcdca5059fe75ba8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ZkClientCacheFactory {\n\tstatic ConcurrentHashMap<String, InteligentZKClient> cache = new ConcurrentHashMap<String, InteligentZKClient>();\n\t\n\tpublic static InteligentZKClient getZKClient(String server) {\n\t\treturn cache.get(server);\n\t}\n\t\n\tpublic static InteligentZKClient getZKClientIfNoneCreate(String server) {\n\t\tInteligentZKClient zk = cache.get(server);\n\t\tif(zk==null) {\n\t\t\tsynchronized (cache) {\n\t\t\t\tzk = cache.get(server);\n\t\t\t\tif(zk==null) {\n\t\t\t\t\tzk = new InteligentZKClient(server);\n\t\t\t\t\tcache.put(server, zk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!zk.isAvaliable()) {\n\t\t\tzk.reCreateClient();\n\t\t}\n\t\treturn zk;\n\t}\n\t\n\t\n"]], "pred": {"ppl": 1.7225946187973022, "ppl_lower": 1.976367712020874, "ppl/lowercase_ppl": -1.2527050728442009, "ppl/zlib": 0.0020916602057076445, "Min_5.0% Prob": 6.008650739987691, "Min_10.0% Prob": 4.184489121437073, "Min_20.0% Prob": 2.558546833395958, "Min_30.0% Prob": 1.7805826086799303, "Min_40.0% Prob": 1.3518868752196431, "Min_50.0% Prob": 1.0853694975078105, "Min_60.0% Prob": 0.9055568799066047}}
{"hexsha": "e3367750fcb59a445174be90215610b4f0827217", "ext": "java", "lang": "Java", "content": "public class DOMUtils {\n\tpublic static void stripWhitespace(Element node) throws XPathExpressionException{\n\t\tXPathFactory xf = XPathFactory.newInstance();\n\t\t// XPath to find empty text nodes.\n\t\tXPathExpression xe = xf.newXPath().compile(\"//text()[normalize-space(.) = '']\");  \n\t\tNodeList nl = (NodeList)xe.evaluate(node, XPathConstants.NODESET);\n\n\t\t// Remove each empty text node from document.\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t    Node empty = nl.item(i);\n\t\t    empty.getParentNode().removeChild(empty);\n\t\t}\n\t}\n\tpublic static void printDOM(Node node, OutputStream out){\n\t\ttry {\n\t\t\tprintDOM(node, out, \"UTF-8\");\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\tpublic static void printDOM(HiveMessage message, OutputStream out){\n\t\tprintDOM(message.dom, out);\n\t}\n\tpublic static void printDOM(Node node, OutputStream out, String encoding) throws TransformerException{\n\t\t    TransformerFactory tf = TransformerFactory.newInstance();\n\t\t    Transformer transformer;\n\t\t\t\ttransformer = tf.newTransformer();\n\t\t    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n\t\t    transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n\t\t    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\t\t    transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n\t\t    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\t\n\t\t    transformer.transform(new DOMSource(node), \n\t\t         new StreamResult(out));\n\t}\n\n}", "class_id": 0, "repo": "rwm/li2b2", "file": "xml/src/main/java/de/sekmi/li2b2/hive/DOMUtils.java", "last_update_at": "2018-03-09T10:13:06+00:00", "question_id": "e3367750fcb59a445174be90215610b4f0827217", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DOMUtils {\n\tpublic static void stripWhitespace(Element node) throws XPathExpressionException{\n\t\tXPathFactory xf = XPathFactory.newInstance();\n\t\t// XPath to find empty text nodes.\n\t\tXPathExpression xe = xf.newXPath().compile(\"//text()[normalize-space(.) = '']\");  \n\t\tNodeList nl = (NodeList)xe.evaluate(node, XPathConstants.NODESET);\n\t\t// Remove each empty text node from document.\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t    Node empty = nl.item(i);\n\t\t    empty.getParentNode().removeChild(empty);\n\t\t}\n\t}\n\tpublic static void printDOM(Node node, OutputStream out){\n\t\ttry {\n\t\t\tprintDOM(node, out, \"UTF-8\");\n\t\t} catch (TransformerException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\tpublic static void printDOM(HiveMessage message, OutputStream out){\n\t\tprintDOM(message.dom, out);\n\t}\n\tpublic static void printDOM(Node node, OutputStream out, String encoding) throws TransformerException{\n\t\t    TransformerFactory tf = TransformerFactory.newInstance();\n\t\t    Transformer transformer;\n\t\t\t\ttransformer = tf.newTransformer();\n\t\t    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n\t\t    transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n\t\t    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\t\t    transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n\t\t    transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\t\n\t\t    transformer.transform(new DOMSource(node), \n\t\t         new StreamResult(out));\n\t}\n"]], "pred": {"ppl": 1.6930603981018066, "ppl_lower": 1.9956002235412598, "ppl/lowercase_ppl": -1.3122417768956187, "ppl/zlib": 0.0008100581195502888, "Min_5.0% Prob": 5.633082752227783, "Min_10.0% Prob": 4.075556001663208, "Min_20.0% Prob": 2.4795485109090807, "Min_30.0% Prob": 1.7177938784658908, "Min_40.0% Prob": 1.3047852028161286, "Min_50.0% Prob": 1.0491158702895045, "Min_60.0% Prob": 0.8764605001856883}}
{"hexsha": "991adea834f02f0501ede9e084769835a451f54f", "ext": "java", "lang": "Java", "content": "public class FinalizeDemo {\n\n    public static void main(String[] args) {\n        new Demo1();\n        new Demo1();\n        new Demo1();\n        System.gc();    //\u542f\u52a8\u5783\u573e\u56de\u6536\u5668\u3002\u5783\u573e\u56de\u6536\u7ebf\u7a0b\u662f\u540e\u53f0\u7ebf\u7a0b\uff0c\u968f\u7740\u5176\u4ed6\u7ebf\u7a0b\u7684\u7ed3\u675f\u800c\u81ea\u52a8\u7ed3\u675f\n        System.out.println(\"Hello Threads\");\n    }\n\n}", "class_id": 0, "repo": "Ecloss/Java-EE", "file": "src/main/java/socket/demo/FinalizeDemo.java", "last_update_at": "2018-09-12T01:50:52+00:00", "question_id": "991adea834f02f0501ede9e084769835a451f54f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FinalizeDemo {\n    public static void main(String[] args) {\n        new Demo1();\n        new Demo1();\n        new Demo1();\n        System.gc();    //\u542f\u52a8\u5783\u573e\u56de\u6536\u5668\u3002\u5783\u573e\u56de\u6536\u7ebf\u7a0b\u662f\u540e\u53f0\u7ebf\u7a0b\uff0c\u968f\u7740\u5176\u4ed6\u7ebf\u7a0b\u7684\u7ed3\u675f\u800c\u81ea\u52a8\u7ed3\u675f\n        System.out.println(\"Hello Threads\");\n    }\n"]], "pred": {"ppl": 2.995614767074585, "ppl_lower": 3.801635265350342, "ppl/lowercase_ppl": -1.2171826516073376, "ppl/zlib": 0.004919952802552387, "Min_5.0% Prob": 7.732939338684082, "Min_10.0% Prob": 6.105058279904452, "Min_20.0% Prob": 4.446910780409108, "Min_30.0% Prob": 3.3682944704504574, "Min_40.0% Prob": 2.625391148354696, "Min_50.0% Prob": 2.1834844374342968, "Min_60.0% Prob": 1.8244400947098283}}
{"hexsha": "f87b63cecf3033d46701e6018dab097d4225a3d3", "ext": "java", "lang": "Java", "content": "@JsonIgnoreProperties(ignoreUnknown = true)\npublic class Field {\n    public final String fieldName;\n    final Datatype datatype;\n    final Optional<RegisterId> register;\n    final Cardinality cardinality;\n    final String text;\n\n    @JsonCreator\n    public Field(@JsonProperty(\"field\") String fieldName,\n                 @JsonProperty(\"datatype\") String datatype,\n                 @JsonProperty(\"register\") RegisterId register,\n                 @JsonProperty(\"cardinality\") Cardinality cardinality,\n                 @JsonProperty(\"text\") String text) {\n        this.fieldName = fieldName;\n        this.text = text;\n        this.register = Optional.ofNullable(register);\n        this.cardinality = cardinality;\n        this.datatype = DatatypeFactory.get(datatype);\n    }\n\n    public Optional<RegisterId> getRegister() {\n        return register;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public Cardinality getCardinality() {\n        return cardinality;\n    }\n\n    public Datatype getDatatype() {\n        return datatype;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Field field = (Field) o;\n\n        if (fieldName != null ? !fieldName.equals(field.fieldName) : field.fieldName != null) return false;\n        if (datatype != null ? !datatype.equals(field.datatype) : field.datatype != null) return false;\n        if (register != null ? !register.equals(field.register) : field.register != null) return false;\n        if (cardinality != field.cardinality) return false;\n        return text != null ? text.equals(field.text) : field.text == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = fieldName != null ? fieldName.hashCode() : 0;\n        result = 31 * result + (datatype != null ? datatype.hashCode() : 0);\n        result = 31 * result + (register != null ? register.hashCode() : 0);\n        result = 31 * result + (cardinality != null ? cardinality.hashCode() : 0);\n        result = 31 * result + (text != null ? text.hashCode() : 0);\n        return result;\n    }\n}", "class_id": 0, "repo": "openregister/openregister-java", "file": "src/main/java/uk/gov/register/core/Field.java", "last_update_at": "2018-09-06T20:51:16+00:00", "question_id": "f87b63cecf3033d46701e6018dab097d4225a3d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JsonIgnoreProperties(ignoreUnknown = true)\npublic class Field {\n    public final String fieldName;\n    final Datatype datatype;\n    final Optional<RegisterId> register;\n    final Cardinality cardinality;\n    final String text;\n    @JsonCreator\n    public Field(@JsonProperty(\"field\") String fieldName,\n                 @JsonProperty(\"datatype\") String datatype,\n                 @JsonProperty(\"register\") RegisterId register,\n                 @JsonProperty(\"cardinality\") Cardinality cardinality,\n                 @JsonProperty(\"text\") String text) {\n        this.fieldName = fieldName;\n        this.text = text;\n        this.register = Optional.ofNullable(register);\n        this.cardinality = cardinality;\n        this.datatype = DatatypeFactory.get(datatype);\n    }\n    public Optional<RegisterId> getRegister() {\n        return register;\n    }\n    @SuppressWarnings(\"unused\")\n    public Cardinality getCardinality() {\n        return cardinality;\n    }\n    public Datatype getDatatype() {\n        return datatype;\n    }\n    public String getText() {\n        return text;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Field field = (Field) o;\n        if (fieldName != null ? !fieldName.equals(field.fieldName) : field.fieldName != null) return false;\n        if (datatype != null ? !datatype.equals(field.datatype) : field.datatype != null) return false;\n        if (register != null ? !register.equals(field.register) : field.register != null) return false;\n        if (cardinality != field.cardinality) return false;\n        return text != null ? text.equals(field.text) : field.text == null;\n    }\n    @Override\n    public int hashCode() {\n        int result = fieldName != null ? fieldName.hashCode() : 0;\n        result = 31 * result + (datatype != null ? datatype.hashCode() : 0);\n        result = 31 * result + (register != null ? register.hashCode() : 0);\n        result = 31 * result + (cardinality != null ? cardinality.hashCode() : 0);\n        result = 31 * result + (text != null ? text.hashCode() : 0);\n        return result;\n    }\n"]], "pred": {"ppl": 1.3029565811157227, "ppl_lower": 1.4317246675491333, "ppl/lowercase_ppl": -1.3561261968328748, "ppl/zlib": 0.000429603856076696, "Min_5.0% Prob": 4.177870440483093, "Min_10.0% Prob": 2.4784857039568853, "Min_20.0% Prob": 1.3096470604764252, "Min_30.0% Prob": 0.8796601902542485, "Min_40.0% Prob": 0.6631229493219966, "Min_50.0% Prob": 0.529990224108741, "Min_60.0% Prob": 0.44126107371817314}}
{"hexsha": "ab189f6cf7c08aeeea8c4c3ccdb6a1c8b10ab39a", "ext": "java", "lang": "Java", "content": "public class LiveCdoFactory implements CdoFactory {\n\n    private final GlobalIdFactory globalIdFactory;\n    private ObjectAccessHook objectAccessHook;\n    private TypeMapper typeMapper;\n\n    public LiveCdoFactory(GlobalIdFactory globalIdFactory, ObjectAccessHook objectAccessHook, TypeMapper typeMapper) {\n        this.globalIdFactory = globalIdFactory;\n        this.objectAccessHook = objectAccessHook;\n        this.typeMapper = typeMapper;\n    }\n\n    @Override\n    public LiveCdo create(Object cdo, OwnerContext owner) {\n        GlobalId globalId = globalIdFactory.createId(cdo, owner);\n\n        ManagedType managedType = typeMapper.getJaversManagedType(globalId);\n\n        Optional<ObjectAccessProxy> objectAccessor = objectAccessHook.createAccessor(cdo);\n\n        if (objectAccessor.isPresent()) {\n            return new LazyCdoWrapper(objectAccessor.get().getObjectSupplier(), globalId, managedType);\n        }\n        else {\n            return new LiveCdoWrapper(cdo, globalId, managedType);\n        }\n    }\n\n    @Override\n    public String typeDesc() {\n        return \"live\";\n    }\n}", "class_id": 0, "repo": "gbondarchuk9/javers", "file": "javers-core/src/main/java/org/javers/core/graph/LiveCdoFactory.java", "last_update_at": "2018-07-06T06:53:56+00:00", "question_id": "ab189f6cf7c08aeeea8c4c3ccdb6a1c8b10ab39a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LiveCdoFactory implements CdoFactory {\n    private final GlobalIdFactory globalIdFactory;\n    private ObjectAccessHook objectAccessHook;\n    private TypeMapper typeMapper;\n    public LiveCdoFactory(GlobalIdFactory globalIdFactory, ObjectAccessHook objectAccessHook, TypeMapper typeMapper) {\n        this.globalIdFactory = globalIdFactory;\n        this.objectAccessHook = objectAccessHook;\n        this.typeMapper = typeMapper;\n    }\n    @Override\n    public LiveCdo create(Object cdo, OwnerContext owner) {\n        GlobalId globalId = globalIdFactory.createId(cdo, owner);\n        ManagedType managedType = typeMapper.getJaversManagedType(globalId);\n        Optional<ObjectAccessProxy> objectAccessor = objectAccessHook.createAccessor(cdo);\n        if (objectAccessor.isPresent()) {\n            return new LazyCdoWrapper(objectAccessor.get().getObjectSupplier(), globalId, managedType);\n        }\n        else {\n            return new LiveCdoWrapper(cdo, globalId, managedType);\n        }\n    }\n    @Override\n    public String typeDesc() {\n        return \"live\";\n    }\n"]], "pred": {"ppl": 2.2494912147521973, "ppl_lower": 2.9998435974121094, "ppl/lowercase_ppl": -1.3550692565550135, "ppl/zlib": 0.0021334317470237184, "Min_5.0% Prob": 7.349125249045236, "Min_10.0% Prob": 5.671080877040994, "Min_20.0% Prob": 3.665473383048485, "Min_30.0% Prob": 2.6234907314858655, "Min_40.0% Prob": 2.0228826775510087, "Min_50.0% Prob": 1.6179438447262966, "Min_60.0% Prob": 1.3533198521022727}}
{"hexsha": "92f5d7a974ce235cdfc003cc5f14c0011067d607", "ext": "java", "lang": "Java", "content": "public class StopWatchActivity extends AppCompatActivity implements\n        StopWatchActionsFragment.StopWatchActions,\n        StopWatch.StopWatchTickEvents {\n\n    private ActivityStopwatchBinding mBinding = null;\n    private StopWatch mStopWatch = null;\n    private List<Long> mLaps = null;\n    private List<TimedActivity> mTimedActivities = new ArrayList<>();\n\n    private void createLap() {\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n\n        // Add a new lap that starts at 0 to the list of laps.\n        mLaps.add(0, 0L);\n\n        if (lapTimesFragment != null) {\n            if (!mLaps.isEmpty()) {\n                lapTimesFragment.newLapTime(StopWatch.buildTimeStamp(mLaps.get(0)));\n            }\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and recieved a create lap event.\"\n            );\n        }\n    }\n\n    private void initializeFragments(long baseTime, List<String> times) {\n        // Inform the fragments to update their times.\n        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlElapsedTime.getId());\n\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n\n        if (elapsedTimeFragment != null) {\n            elapsedTimeFragment.updateElapsedTime(StopWatch.buildTimeStamp(baseTime));\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The elapsed time fragment does not exist and trying to initialize.\"\n            );\n        }\n\n        if (lapTimesFragment != null) {\n            lapTimesFragment.initializeLaps(times);\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and trying to initialize.\"\n            );\n        }\n    }\n\n    private void saveAndReturn() {\n        Bundle bundle = new Bundle();\n        long [] lapsToSave = new long [mLaps.size()];\n        long prevLap = 0L;\n        long totalTime = 0L;\n\n        // populate the array that will be passed back as a bundle.\n        for (int index = lapsToSave.length - 1; index >= 0; index--) {\n            lapsToSave[index] = mLaps.get(index) - prevLap;\n            prevLap = mLaps.get(index);\n        }\n\n        if (mLaps.size() > 0) {\n            totalTime = mLaps.get(0);\n        }\n\n        bundle.putLong(getString(R.string.key_total_time), totalTime);\n        bundle.putLongArray(getString(R.string.key_lap_times), lapsToSave);\n        bundle.putParcelableArrayList(\n                getString(R.string.key_timed_activities),\n                (ArrayList<TimedActivity>) mTimedActivities);\n\n        Intent intent = new Intent();\n        intent.putExtras(bundle);\n        setResult(RESULT_OK, intent);\n        finish();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        super.onOptionsItemSelected(item);\n\n        if (item != null) {\n            switch (item.getItemId()) {\n                case R.id.mi_save:\n                    mStopWatch.pause();\n                    saveAndReturn();\n                    break;\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        if (mStopWatch != null) {\n            mStopWatch.unRegisterCallback();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mStopWatch != null) {\n            mStopWatch.registerCallback(this);\n        }\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        long [] times = new long [mLaps.size()];\n\n        int index = 0;\n        for (long time : mLaps) {\n            times[index] = time;\n            index++;\n        }\n\n        if (mStopWatch != null) {\n            outState.putInt(\n                    getString(R.string.key_stopwatch_state),\n                    mStopWatch.getState().getStateValue());\n            outState.putLongArray(getString(R.string.key_lap_times), times);\n        }\n\n        outState.putParcelableArrayList(\n                getString(R.string.key_timed_activities),\n                (ArrayList<TimedActivity>) mTimedActivities);\n    }\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);\n        getWindow().setEnterTransition(new Slide());\n        getWindow().setExitTransition(new Slide());\n\n        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_stopwatch);\n        setSupportActionBar(mBinding.tbActivityStopwatchToolbar);\n        if (getSupportActionBar() != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        long baseTime = 0L;\n        List<String> timeStrings = new LinkedList<String>();\n        int stopWatchState = StopWatch.sSTOP_STATE_VALUE;\n\n        // Create the list of laps.\n        mLaps = new LinkedList<Long>();\n\n        if (savedInstanceState != null && !savedInstanceState.isEmpty()) {\n            // Obtain instance state data\n            long [] times = savedInstanceState.getLongArray(getString(R.string.key_lap_times));\n\n            if (times != null && times.length > 0) {\n                baseTime = times[0];\n                for (long time : times) {\n                    mLaps.add(time);\n                    timeStrings.add(StopWatch.buildTimeStamp(time));\n                    // Log.d(\"onCreate\", \"time found is \" + Long.toString(time));\n                }\n\n                // need to account for the first lap time.\n                if (mLaps.size() > 1) {\n                    timeStrings.set(0,\n                            StopWatch.buildTimeStamp(baseTime - mLaps.get(1)));\n                }\n            }\n\n            stopWatchState = savedInstanceState.getInt(getString(R.string.key_stopwatch_state),\n                    StopWatch.sSTOP_STATE_VALUE);\n\n            mTimedActivities = savedInstanceState.\n                    getParcelableArrayList(getString(R.string.key_timed_activities));\n        }\n        else {\n            // Check intent data\n            Bundle bundle = getIntent().getExtras();\n            if (bundle != null) {\n                mTimedActivities = bundle.\n                        getParcelableArrayList(getString(R.string.key_timed_activities));\n            }\n        }\n\n        if (mTimedActivities == null) {\n            mTimedActivities = new ArrayList<>();\n        }\n\n        // Create the stopwatch object.\n        mStopWatch = new StopWatch(this, StopWatch.sDEFAULT_TIME_INTERVAL, baseTime);\n\n        // Population of the activity fragments.\n        if (savedInstanceState == null) {\n            LapTimesFragment lapTimesFragment = new LapTimesFragment();\n            ElapsedTimeFragment elapsedTimeFragment = new ElapsedTimeFragment();\n            StopWatchActionsFragment stopWatchActionsFragment = new StopWatchActionsFragment();\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(mBinding.rlElapsedTime.getId(), elapsedTimeFragment)\n                    .add(mBinding.rlLapTimes.getId(), lapTimesFragment)\n                    .add(mBinding.rlStopwatchActions.getId(), stopWatchActionsFragment)\n                    .commit();\n        }\n        else {\n            // Populate the fragments associated with the StopWatchActivity.\n            initializeFragments(baseTime, timeStrings);\n\n            // Check the state\n            if (stopWatchState == StopWatch.sPLAY_STATE_VALUE) {\n                mStopWatch.play();\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater menuInflater = getMenuInflater();\n        menuInflater.inflate(R.menu.menu_stopwatch, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public void handleStopWatchAction(ACTIONS action) {\n        // Allows the StopWatchActionsFragment to inform the StopWatchActivity class about a user\n        // action on the supported StopWatchActions.\n        switch (action) {\n            case Start:\n                mStopWatch.play();\n                break;\n            case Stop:\n                mStopWatch.pause();\n                break;\n            case Lap:\n                createLap();\n                break;\n            case Reset:\n                mStopWatch.stop();\n                mLaps.clear();\n                tickEvent(0);\n                break;\n        }\n    }\n\n    @Override\n    public void tickEvent(long milliSecondsElapsed) {\n        Long lastLapTime = 0L;\n        String totalTimeDisplay = null, lapTimeDisplay = null;\n\n        if (mLaps.size() > 1) {\n            lastLapTime = mLaps.get(1);\n        }\n        else if (mLaps.size() == 0) {\n            mLaps.add(0L);\n        }\n\n        totalTimeDisplay = StopWatch.buildTimeStamp(milliSecondsElapsed);\n        lapTimeDisplay = StopWatch.buildTimeStamp(\n                milliSecondsElapsed - lastLapTime);\n        mLaps.set(0, milliSecondsElapsed);\n\n        // Inform the fragments to update their times.\n        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlElapsedTime.getId());\n\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n\n        if (elapsedTimeFragment != null) {\n            elapsedTimeFragment.updateElapsedTime(totalTimeDisplay);\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The elapsed time fragment does not exist and recieved a tick event.\"\n            );\n        }\n\n        if (lapTimesFragment != null) {\n            if (milliSecondsElapsed == 0) {\n                lapTimesFragment.resetLapTimes();\n            }\n            else {\n                lapTimesFragment.updateLapTime(lapTimeDisplay);\n            }\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and recieved a tick event.\"\n            );\n        }\n    }\n}", "class_id": 0, "repo": "awkonecki/timing", "file": "app/src/main/java/com/nebo/timing/StopWatchActivity.java", "last_update_at": "2018-11-04T04:18:47+00:00", "question_id": "92f5d7a974ce235cdfc003cc5f14c0011067d607", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StopWatchActivity extends AppCompatActivity implements\n        StopWatchActionsFragment.StopWatchActions,\n        StopWatch.StopWatchTickEvents {\n    private ActivityStopwatchBinding mBinding = null;\n    private StopWatch mStopWatch = null;\n    private List<Long> mLaps = null;\n    private List<TimedActivity> mTimedActivities = new ArrayList<>();\n    private void createLap() {\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n        // Add a new lap that starts at 0 to the list of laps.\n        mLaps.add(0, 0L);\n        if (lapTimesFragment != null) {\n            if (!mLaps.isEmpty()) {\n                lapTimesFragment.newLapTime(StopWatch.buildTimeStamp(mLaps.get(0)));\n            }\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and recieved a create lap event.\"\n            );\n        }\n    }\n    private void initializeFragments(long baseTime, List<String> times) {\n        // Inform the fragments to update their times.\n        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlElapsedTime.getId());\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n        if (elapsedTimeFragment != null) {\n            elapsedTimeFragment.updateElapsedTime(StopWatch.buildTimeStamp(baseTime));\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The elapsed time fragment does not exist and trying to initialize.\"\n            );\n        }\n        if (lapTimesFragment != null) {\n            lapTimesFragment.initializeLaps(times);\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and trying to initialize.\"\n            );\n        }\n    }\n    private void saveAndReturn() {\n        Bundle bundle = new Bundle();\n        long [] lapsToSave = new long [mLaps.size()];\n        long prevLap = 0L;\n        long totalTime = 0L;\n        // populate the array that will be passed back as a bundle.\n        for (int index = lapsToSave.length - 1; index >= 0; index--) {\n            lapsToSave[index] = mLaps.get(index) - prevLap;\n            prevLap = mLaps.get(index);\n        }\n        if (mLaps.size() > 0) {\n            totalTime = mLaps.get(0);\n        }\n        bundle.putLong(getString(R.string.key_total_time), totalTime);\n        bundle.putLongArray(getString(R.string.key_lap_times), lapsToSave);\n        bundle.putParcelableArrayList(\n                getString(R.string.key_timed_activities),\n                (ArrayList<TimedActivity>) mTimedActivities);\n        Intent intent = new Intent();\n        intent.putExtras(bundle);\n        setResult(RESULT_OK, intent);\n        finish();\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        super.onOptionsItemSelected(item);\n        if (item != null) {\n            switch (item.getItemId()) {\n                case R.id.mi_save:\n                    mStopWatch.pause();\n                    saveAndReturn();\n                    break;\n            }\n        }\n        return true;\n    }\n    @Override\n    protected void onPause() {\n        super.onPause();\n        if (mStopWatch != null) {\n            mStopWatch.unRegisterCallback();\n        }\n    }\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mStopWatch != null) {\n            mStopWatch.registerCallback(this);\n        }\n    }\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        long [] times = new long [mLaps.size()];\n        int index = 0;\n        for (long time : mLaps) {\n            times[index] = time;\n            index++;\n        }\n        if (mStopWatch != null) {\n            outState.putInt(\n                    getString(R.string.key_stopwatch_state),\n                    mStopWatch.getState().getStateValue());\n            outState.putLongArray(getString(R.string.key_lap_times), times);\n        }\n        outState.putParcelableArrayList(\n                getString(R.string.key_timed_activities),\n                (ArrayList<TimedActivity>) mTimedActivities);\n    }\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);\n        getWindow().setEnterTransition(new Slide());\n        getWindow().setExitTransition(new Slide());\n        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_stopwatch);\n        setSupportActionBar(mBinding.tbActivityStopwatchToolbar);\n        if (getSupportActionBar() != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n        long baseTime = 0L;\n        List<String> timeStrings = new LinkedList<String>();\n        int stopWatchState = StopWatch.sSTOP_STATE_VALUE;\n        // Create the list of laps.\n        mLaps = new LinkedList<Long>();\n        if (savedInstanceState != null && !savedInstanceState.isEmpty()) {\n            // Obtain instance state data\n            long [] times = savedInstanceState.getLongArray(getString(R.string.key_lap_times));\n            if (times != null && times.length > 0) {\n                baseTime = times[0];\n                for (long time : times) {\n                    mLaps.add(time);\n                    timeStrings.add(StopWatch.buildTimeStamp(time));\n                    // Log.d(\"onCreate\", \"time found is \" + Long.toString(time));\n                }\n                // need to account for the first lap time.\n                if (mLaps.size() > 1) {\n                    timeStrings.set(0,\n                            StopWatch.buildTimeStamp(baseTime - mLaps.get(1)));\n                }\n            }\n            stopWatchState = savedInstanceState.getInt(getString(R.string.key_stopwatch_state),\n                    StopWatch.sSTOP_STATE_VALUE);\n            mTimedActivities = savedInstanceState.\n                    getParcelableArrayList(getString(R.string.key_timed_activities));\n        }\n        else {\n            // Check intent data\n            Bundle bundle = getIntent().getExtras();\n            if (bundle != null) {\n                mTimedActivities = bundle.\n                        getParcelableArrayList(getString(R.string.key_timed_activities));\n            }\n        }\n        if (mTimedActivities == null) {\n            mTimedActivities = new ArrayList<>();\n        }\n        // Create the stopwatch object.\n        mStopWatch = new StopWatch(this, StopWatch.sDEFAULT_TIME_INTERVAL, baseTime);\n        // Population of the activity fragments.\n        if (savedInstanceState == null) {\n            LapTimesFragment lapTimesFragment = new LapTimesFragment();\n            ElapsedTimeFragment elapsedTimeFragment = new ElapsedTimeFragment();\n            StopWatchActionsFragment stopWatchActionsFragment = new StopWatchActionsFragment();\n            getSupportFragmentManager().beginTransaction()\n                    .add(mBinding.rlElapsedTime.getId(), elapsedTimeFragment)\n                    .add(mBinding.rlLapTimes.getId(), lapTimesFragment)\n                    .add(mBinding.rlStopwatchActions.getId(), stopWatchActionsFragment)\n                    .commit();\n        }\n        else {\n            // Populate the fragments associated with the StopWatchActivity.\n            initializeFragments(baseTime, timeStrings);\n            // Check the state\n            if (stopWatchState == StopWatch.sPLAY_STATE_VALUE) {\n                mStopWatch.play();\n            }\n        }\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater menuInflater = getMenuInflater();\n        menuInflater.inflate(R.menu.menu_stopwatch, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n    @Override\n    public void handleStopWatchAction(ACTIONS action) {\n        // Allows the StopWatchActionsFragment to inform the StopWatchActivity class about a user\n        // action on the supported StopWatchActions.\n        switch (action) {\n            case Start:\n                mStopWatch.play();\n                break;\n            case Stop:\n                mStopWatch.pause();\n                break;\n            case Lap:\n                createLap();\n                break;\n            case Reset:\n                mStopWatch.stop();\n                mLaps.clear();\n                tickEvent(0);\n                break;\n        }\n    }\n    @Override\n    public void tickEvent(long milliSecondsElapsed) {\n        Long lastLapTime = 0L;\n        String totalTimeDisplay = null, lapTimeDisplay = null;\n        if (mLaps.size() > 1) {\n            lastLapTime = mLaps.get(1);\n        }\n        else if (mLaps.size() == 0) {\n            mLaps.add(0L);\n        }\n        totalTimeDisplay = StopWatch.buildTimeStamp(milliSecondsElapsed);\n        lapTimeDisplay = StopWatch.buildTimeStamp(\n                milliSecondsElapsed - lastLapTime);\n        mLaps.set(0, milliSecondsElapsed);\n        // Inform the fragments to update their times.\n        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlElapsedTime.getId());\n        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()\n                .findFragmentById(mBinding.rlLapTimes.getId());\n        if (elapsedTimeFragment != null) {\n            elapsedTimeFragment.updateElapsedTime(totalTimeDisplay);\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The elapsed time fragment does not exist and recieved a tick event.\"\n            );\n        }\n        if (lapTimesFragment != null) {\n            if (milliSecondsElapsed == 0) {\n                lapTimesFragment.resetLapTimes();\n            }\n            else {\n                lapTimesFragment.updateLapTime(lapTimeDisplay);\n            }\n        }\n        else {\n            throw new java.lang.UnsupportedOperationException(\n                    \"The lap time fragment does not exist and recieved a tick event.\"\n            );\n        }\n    }\n"]], "pred": {"ppl": 1.8249258995056152, "ppl_lower": 1.9747525453567505, "ppl/lowercase_ppl": -1.1311696557484903, "ppl/zlib": 0.0002530666315521702, "Min_5.0% Prob": 5.937117819692574, "Min_10.0% Prob": 4.460328443377626, "Min_20.0% Prob": 2.821837563725079, "Min_30.0% Prob": 1.9750349363372997, "Min_40.0% Prob": 1.4965392027806246, "Min_50.0% Prob": 1.2023100529463848, "Min_60.0% Prob": 1.0034028318035302}}
{"hexsha": "147a7aaf84337926b56b394e01bf17b4732c073e", "ext": "java", "lang": "Java", "content": "@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class ProjectSource implements Serializable, Cloneable, StructuredPojo {\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     */\n    private String type;\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     */\n    private String location;\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     */\n    private String buildspec;\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     */\n    private SourceAuth auth;\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @see SourceType\n     */\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @return The type of repository that contains the source code to be built. Valid values include:</p>\n     *         <ul>\n     *         <li>\n     *         <p>\n     *         <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *         AWS CodePipeline.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>GITHUB</code>: The source code is in a GitHub repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *         </p>\n     *         </li>\n     * @see SourceType\n     */\n\n    public String getType() {\n        return this.type;\n    }\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceType\n     */\n\n    public ProjectSource withType(String type) {\n        setType(type);\n        return this;\n    }\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @see SourceType\n     */\n\n    public void setType(SourceType type) {\n        withType(type);\n    }\n\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceType\n     */\n\n    public ProjectSource withType(SourceType type) {\n        this.type = type.toString();\n        return this;\n    }\n\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param location\n     *        Information about the location of the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *        source code and the build spec (for example,\n     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *        that contains the source code (for example,\n     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and\n     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS\n     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)\n     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization\n     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have\n     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you\n     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To\n     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the\n     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the\n     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish\n     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild\n     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's\n     *        <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     */\n\n    public void setLocation(String location) {\n        this.location = location;\n    }\n\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @return Information about the location of the source code to be built. Valid values include:</p>\n     *         <ul>\n     *         <li>\n     *         <p>\n     *         For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *         <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *         is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *         source code and the build spec (for example,\n     *         <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *         that contains the source code (for example,\n     *         <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source\n     *         and the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the\n     *         AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *         reconnect) with GitHub, on the GitHub <b>Authorize application</b> page that displays, for\n     *         <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to allow AWS\n     *         CodeBuild to have access to. Then choose <b>Authorize application</b>. (After you have connected to your\n     *         GitHub account, you do not need to finish creating the build project, and you may then leave the AWS\n     *         CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the <code>source</code>\n     *         object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *         and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use\n     *         the AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *         reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *         choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to\n     *         finish creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS\n     *         CodeBuild to then use this connection, in the <code>source</code> object, set the <code>auth</code>\n     *         object's <code>type</code> value to <code>OAUTH</code>.\n     *         </p>\n     *         </li>\n     */\n\n    public String getLocation() {\n        return this.location;\n    }\n\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param location\n     *        Information about the location of the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *        source code and the build spec (for example,\n     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *        that contains the source code (for example,\n     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and\n     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS\n     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)\n     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization\n     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have\n     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you\n     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To\n     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the\n     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the\n     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish\n     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild\n     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's\n     *        <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public ProjectSource withLocation(String location) {\n        setLocation(location);\n        return this;\n    }\n\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @param buildspec\n     *        The build spec declaration to use for the builds in this build project.</p>\n     *        <p>\n     *        If this value is not specified, a build spec must be included along with the source code to be built.\n     */\n\n    public void setBuildspec(String buildspec) {\n        this.buildspec = buildspec;\n    }\n\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @return The build spec declaration to use for the builds in this build project.</p>\n     *         <p>\n     *         If this value is not specified, a build spec must be included along with the source code to be built.\n     */\n\n    public String getBuildspec() {\n        return this.buildspec;\n    }\n\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @param buildspec\n     *        The build spec declaration to use for the builds in this build project.</p>\n     *        <p>\n     *        If this value is not specified, a build spec must be included along with the source code to be built.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public ProjectSource withBuildspec(String buildspec) {\n        setBuildspec(buildspec);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @param auth\n     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *        <p>\n     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *        or <code>GITHUB</code>).\n     */\n\n    public void setAuth(SourceAuth auth) {\n        this.auth = auth;\n    }\n\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @return Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *         <p>\n     *         This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *         information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *         or <code>GITHUB</code>).\n     */\n\n    public SourceAuth getAuth() {\n        return this.auth;\n    }\n\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @param auth\n     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *        <p>\n     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *        or <code>GITHUB</code>).\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n\n    public ProjectSource withAuth(SourceAuth auth) {\n        setAuth(auth);\n        return this;\n    }\n\n    /**\n     * Returns a string representation of this object; useful for testing and debugging.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getType() != null)\n            sb.append(\"Type: \").append(getType()).append(\",\");\n        if (getLocation() != null)\n            sb.append(\"Location: \").append(getLocation()).append(\",\");\n        if (getBuildspec() != null)\n            sb.append(\"Buildspec: \").append(getBuildspec()).append(\",\");\n        if (getAuth() != null)\n            sb.append(\"Auth: \").append(getAuth());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof ProjectSource == false)\n            return false;\n        ProjectSource other = (ProjectSource) obj;\n        if (other.getType() == null ^ this.getType() == null)\n            return false;\n        if (other.getType() != null && other.getType().equals(this.getType()) == false)\n            return false;\n        if (other.getLocation() == null ^ this.getLocation() == null)\n            return false;\n        if (other.getLocation() != null && other.getLocation().equals(this.getLocation()) == false)\n            return false;\n        if (other.getBuildspec() == null ^ this.getBuildspec() == null)\n            return false;\n        if (other.getBuildspec() != null && other.getBuildspec().equals(this.getBuildspec()) == false)\n            return false;\n        if (other.getAuth() == null ^ this.getAuth() == null)\n            return false;\n        if (other.getAuth() != null && other.getAuth().equals(this.getAuth()) == false)\n            return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getType() == null) ? 0 : getType().hashCode());\n        hashCode = prime * hashCode + ((getLocation() == null) ? 0 : getLocation().hashCode());\n        hashCode = prime * hashCode + ((getBuildspec() == null) ? 0 : getBuildspec().hashCode());\n        hashCode = prime * hashCode + ((getAuth() == null) ? 0 : getAuth().hashCode());\n        return hashCode;\n    }\n\n    @Override\n    public ProjectSource clone() {\n        try {\n            return (ProjectSource) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Got a CloneNotSupportedException from Object.clone() \" + \"even though we're Cloneable!\", e);\n        }\n    }\n\n    @com.amazonaws.annotation.SdkInternalApi\n    @Override\n    public void marshall(ProtocolMarshaller protocolMarshaller) {\n        com.amazonaws.services.codebuild.model.transform.ProjectSourceMarshaller.getInstance().marshall(this, protocolMarshaller);\n    }\n}", "class_id": 0, "repo": "C2Devel/aws-sdk-java", "file": "aws-java-sdk-codebuild/src/main/java/com/amazonaws/services/codebuild/model/ProjectSource.java", "last_update_at": "2018-10-19T09:13:12+00:00", "question_id": "147a7aaf84337926b56b394e01bf17b4732c073e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class ProjectSource implements Serializable, Cloneable, StructuredPojo {\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     */\n    private String type;\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     */\n    private String location;\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     */\n    private String buildspec;\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     */\n    private SourceAuth auth;\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @see SourceType\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @return The type of repository that contains the source code to be built. Valid values include:</p>\n     *         <ul>\n     *         <li>\n     *         <p>\n     *         <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *         AWS CodePipeline.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>GITHUB</code>: The source code is in a GitHub repository.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *         </p>\n     *         </li>\n     * @see SourceType\n     */\n    public String getType() {\n        return this.type;\n    }\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceType\n     */\n    public ProjectSource withType(String type) {\n        setType(type);\n        return this;\n    }\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @see SourceType\n     */\n    public void setType(SourceType type) {\n        withType(type);\n    }\n    /**\n     * <p>\n     * The type of repository that contains the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS\n     * CodePipeline.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>GITHUB</code>: The source code is in a GitHub repository.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param type\n     *        The type of repository that contains the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in\n     *        AWS CodePipeline.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>GITHUB</code>: The source code is in a GitHub repository.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     * @see SourceType\n     */\n    public ProjectSource withType(SourceType type) {\n        this.type = type.toString();\n        return this;\n    }\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param location\n     *        Information about the location of the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *        source code and the build spec (for example,\n     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *        that contains the source code (for example,\n     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and\n     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS\n     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)\n     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization\n     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have\n     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you\n     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To\n     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the\n     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the\n     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish\n     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild\n     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's\n     *        <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     */\n    public void setLocation(String location) {\n        this.location = location;\n    }\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @return Information about the location of the source code to be built. Valid values include:</p>\n     *         <ul>\n     *         <li>\n     *         <p>\n     *         For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *         <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *         is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *         source code and the build spec (for example,\n     *         <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *         that contains the source code (for example,\n     *         <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source\n     *         and the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the\n     *         AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *         reconnect) with GitHub, on the GitHub <b>Authorize application</b> page that displays, for\n     *         <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to allow AWS\n     *         CodeBuild to have access to. Then choose <b>Authorize application</b>. (After you have connected to your\n     *         GitHub account, you do not need to finish creating the build project, and you may then leave the AWS\n     *         CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the <code>source</code>\n     *         object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *         </p>\n     *         </li>\n     *         <li>\n     *         <p>\n     *         For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *         and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use\n     *         the AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *         reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *         choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to\n     *         finish creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS\n     *         CodeBuild to then use this connection, in the <code>source</code> object, set the <code>auth</code>\n     *         object's <code>type</code> value to <code>OAUTH</code>.\n     *         </p>\n     *         </li>\n     */\n    public String getLocation() {\n        return this.location;\n    }\n    /**\n     * <p>\n     * Information about the location of the source code to be built. Valid values include:\n     * </p>\n     * <ul>\n     * <li>\n     * <p>\n     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is\n     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source\n     * code and the build spec (for example,\n     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that\n     * contains the source code (for example,\n     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the\n     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request\n     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize\n     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build\n     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this\n     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to\n     * <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * <li>\n     * <p>\n     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the\n     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild\n     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on\n     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you\n     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then\n     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the\n     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     * </p>\n     * </li>\n     * </ul>\n     * \n     * @param location\n     *        Information about the location of the source code to be built. Valid values include:</p>\n     *        <ul>\n     *        <li>\n     *        <p>\n     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,\n     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This\n     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the\n     *        source code and the build spec (for example,\n     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file\n     *        that contains the source code (for example,\n     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and\n     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS\n     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)\n     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization\n     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have\n     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you\n     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To\n     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the\n     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     *        <li>\n     *        <p>\n     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source\n     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the\n     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or\n     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,\n     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish\n     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild\n     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's\n     *        <code>type</code> value to <code>OAUTH</code>.\n     *        </p>\n     *        </li>\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public ProjectSource withLocation(String location) {\n        setLocation(location);\n        return this;\n    }\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @param buildspec\n     *        The build spec declaration to use for the builds in this build project.</p>\n     *        <p>\n     *        If this value is not specified, a build spec must be included along with the source code to be built.\n     */\n    public void setBuildspec(String buildspec) {\n        this.buildspec = buildspec;\n    }\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @return The build spec declaration to use for the builds in this build project.</p>\n     *         <p>\n     *         If this value is not specified, a build spec must be included along with the source code to be built.\n     */\n    public String getBuildspec() {\n        return this.buildspec;\n    }\n    /**\n     * <p>\n     * The build spec declaration to use for the builds in this build project.\n     * </p>\n     * <p>\n     * If this value is not specified, a build spec must be included along with the source code to be built.\n     * </p>\n     * \n     * @param buildspec\n     *        The build spec declaration to use for the builds in this build project.</p>\n     *        <p>\n     *        If this value is not specified, a build spec must be included along with the source code to be built.\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public ProjectSource withBuildspec(String buildspec) {\n        setBuildspec(buildspec);\n        return this;\n    }\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @param auth\n     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *        <p>\n     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *        or <code>GITHUB</code>).\n     */\n    public void setAuth(SourceAuth auth) {\n        this.auth = auth;\n    }\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @return Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *         <p>\n     *         This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *         information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *         or <code>GITHUB</code>).\n     */\n    public SourceAuth getAuth() {\n        return this.auth;\n    }\n    /**\n     * <p>\n     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.\n     * </p>\n     * <p>\n     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information\n     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or\n     * <code>GITHUB</code>).\n     * </p>\n     * \n     * @param auth\n     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>\n     *        <p>\n     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this\n     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>\n     *        or <code>GITHUB</code>).\n     * @return Returns a reference to this object so that method calls can be chained together.\n     */\n    public ProjectSource withAuth(SourceAuth auth) {\n        setAuth(auth);\n        return this;\n    }\n    /**\n     * Returns a string representation of this object; useful for testing and debugging.\n     *\n     * @return A string representation of this object.\n     *\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getType() != null)\n            sb.append(\"Type: \").append(getType()).append(\",\");\n        if (getLocation() != null)\n            sb.append(\"Location: \").append(getLocation()).append(\",\");\n        if (getBuildspec() != null)\n            sb.append(\"Buildspec: \").append(getBuildspec()).append(\",\");\n        if (getAuth() != null)\n            sb.append(\"Auth: \").append(getAuth());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (obj instanceof ProjectSource == false)\n            return false;\n        ProjectSource other = (ProjectSource) obj;\n        if (other.getType() == null ^ this.getType() == null)\n            return false;\n        if (other.getType() != null && other.getType().equals(this.getType()) == false)\n            return false;\n        if (other.getLocation() == null ^ this.getLocation() == null)\n            return false;\n        if (other.getLocation() != null && other.getLocation().equals(this.getLocation()) == false)\n            return false;\n        if (other.getBuildspec() == null ^ this.getBuildspec() == null)\n            return false;\n        if (other.getBuildspec() != null && other.getBuildspec().equals(this.getBuildspec()) == false)\n            return false;\n        if (other.getAuth() == null ^ this.getAuth() == null)\n            return false;\n        if (other.getAuth() != null && other.getAuth().equals(this.getAuth()) == false)\n            return false;\n        return true;\n    }\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n        hashCode = prime * hashCode + ((getType() == null) ? 0 : getType().hashCode());\n        hashCode = prime * hashCode + ((getLocation() == null) ? 0 : getLocation().hashCode());\n        hashCode = prime * hashCode + ((getBuildspec() == null) ? 0 : getBuildspec().hashCode());\n        hashCode = prime * hashCode + ((getAuth() == null) ? 0 : getAuth().hashCode());\n        return hashCode;\n    }\n    @Override\n    public ProjectSource clone() {\n        try {\n            return (ProjectSource) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Got a CloneNotSupportedException from Object.clone() \" + \"even though we're Cloneable!\", e);\n        }\n    }\n    @com.amazonaws.annotation.SdkInternalApi\n    @Override\n    public void marshall(ProtocolMarshaller protocolMarshaller) {\n        com.amazonaws.services.codebuild.model.transform.ProjectSourceMarshaller.getInstance().marshall(this, protocolMarshaller);\n    }\n"]], "pred": {"ppl": 1.1953107118606567, "ppl_lower": 1.3683693408966064, "ppl/lowercase_ppl": -1.7578976316641743, "ppl/zlib": 5.760612254181057e-05, "Min_5.0% Prob": 3.30251589884945, "Min_10.0% Prob": 1.75989969147771, "Min_20.0% Prob": 0.892081418268693, "Min_30.0% Prob": 0.5959672099903829, "Min_40.0% Prob": 0.4461156128739772, "Min_50.0% Prob": 0.3571277640973468, "Min_60.0% Prob": 0.29772110636020155}}
{"hexsha": "65e74ee3e9925ca00ecd3fc6b91d22884711ed15", "ext": "java", "lang": "Java", "content": "public class HotelAlertLinkCommand extends Command\n{\n    public HotelAlertLinkCommand()\n    {\n        super(\"cmd_hal\",  Emulator.getTexts().getValue(\"commands.keys.cmd_hal\").split(\";\"));\n    }\n\n    @Override\n    public boolean handle(GameClient gameClient, String[] params) throws Exception\n    {\n        if (params.length < 3)\n        {\n            return true;\n        }\n\n        String url = params[1];\n        String message = \"\";\n        for (int i = 2; i < params.length; i++)\n        {\n            message += params[i];\n            message += \" \";\n        }\n\n        message += \"\\r\\r-<b>\" + gameClient.getHabbo().getHabboInfo().getUsername() + \"</b>\";\n\n        Emulator.getGameServer().getGameClientManager().sendBroadcastResponse(new StaffAlertWithLinkComposer(message, url).compose());\n        return true;\n    }\n}", "class_id": 0, "repo": "Jackxun123/ArcturusEmulator", "file": "src/main/java/com/eu/habbo/habbohotel/commands/HotelAlertLinkCommand.java", "last_update_at": "2018-12-21T00:02:33+00:00", "question_id": "65e74ee3e9925ca00ecd3fc6b91d22884711ed15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HotelAlertLinkCommand extends Command\n{\n    public HotelAlertLinkCommand()\n    {\n        super(\"cmd_hal\",  Emulator.getTexts().getValue(\"commands.keys.cmd_hal\").split(\";\"));\n    }\n    @Override\n    public boolean handle(GameClient gameClient, String[] params) throws Exception\n    {\n        if (params.length < 3)\n        {\n            return true;\n        }\n        String url = params[1];\n        String message = \"\";\n        for (int i = 2; i < params.length; i++)\n        {\n            message += params[i];\n            message += \" \";\n        }\n        message += \"\\r\\r-<b>\" + gameClient.getHabbo().getHabboInfo().getUsername() + \"</b>\";\n        Emulator.getGameServer().getGameClientManager().sendBroadcastResponse(new StaffAlertWithLinkComposer(message, url).compose());\n        return true;\n    }\n"]], "pred": {"ppl": 2.457249402999878, "ppl_lower": 4.428811550140381, "ppl/lowercase_ppl": -1.6552400101968425, "ppl/zlib": 0.0021927868183170738, "Min_5.0% Prob": 8.911137017336758, "Min_10.0% Prob": 6.3486999636111054, "Min_20.0% Prob": 4.020837114212361, "Min_30.0% Prob": 2.8953891473157065, "Min_40.0% Prob": 2.218038958596422, "Min_50.0% Prob": 1.7980696869074788, "Min_60.0% Prob": 1.4963739072732258}}
{"hexsha": "dafcd543bd4fb8b3fd0e787bdf02e5a3dda45bd8", "ext": "java", "lang": "Java", "content": "public class DepartureWidgetProvider extends AppWidgetProvider {\n\n    public static final String EXTRA_STOP_SHORT_NAME = \"extra_stop_short_name\";\n    public static final String ACTION_OPEN_FAVORITE = \"action_open_favorite\";\n    public static final String EXTRA_STOP_NAME = \"extra_stop_name\";\n\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n        final int N = appWidgetIds.length;\n\n        // Perform this loop procedure for each App Widget that belongs to this provider\n        for (int i = 0; i < N; i++) {\n            final int appWidgetId = appWidgetIds[i];\n\n            // Create an Intent to launch ExampleActivity\n            final Intent remoteViewService = new Intent(context, DepartureWidgetRemoteViewService.class);\n            // Add the app widget ID to the intent extras.\n\n            // Get the layout for the App Widget and attach an on-click listener\n            // to the button\n            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_departure);\n\n            views.setRemoteAdapter(R.id.listView, remoteViewService);\n\n            // The empty view is displayed when the collection has no items.\n            // It should be in the same layout used to instantiate the RemoteViews\n            // object above.\n            views.setEmptyView(R.id.listView, R.id.emptyView);\n            // Tell the AppWidgetManager to perform an update on the current app widget\n            final Intent stopIntent = new Intent(context, StationDetailActivity.class);// StationDetailActivity.createIntent(context);\n            stopIntent.setAction(ACTION_OPEN_FAVORITE);\n            stopIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            stopIntent.setData(Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)));\n            Timber.d(\"uri: %s\", Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)).toString());\n            PendingIntent stopPendingIntent = PendingIntent.getActivity(context,\n                    appWidgetId,\n                    stopIntent,\n                    PendingIntent.FLAG_CANCEL_CURRENT);\n            views.setPendingIntentTemplate(R.id.listView, stopPendingIntent);\n            appWidgetManager.updateAppWidget(appWidgetId, views);\n        }\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Timber.d(\"recieved\");\n        AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n        if (intent.getAction().equals(ACTION_OPEN_FAVORITE)) {\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            final String shortName = intent.getStringExtra(EXTRA_STOP_SHORT_NAME);\n            final String name = intent.getStringExtra(EXTRA_STOP_NAME);\n            final Intent stationDetailIntent = StationDetailActivity.createIntent(context, shortName);\n            context.startActivity(stationDetailIntent);\n            //Toast.makeText(context, \"Touched view \" + shortName, Toast.LENGTH_SHORT).show();\n        }\n        super.onReceive(context, intent);\n    }\n}", "class_id": 0, "repo": "GuennisHueftgold/MannisHueftgold", "file": "mobile/src/main/java/com/semeshky/kvgspotter/widgets/DepartureWidgetProvider.java", "last_update_at": "2018-06-28T18:43:40+00:00", "question_id": "dafcd543bd4fb8b3fd0e787bdf02e5a3dda45bd8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DepartureWidgetProvider extends AppWidgetProvider {\n    public static final String EXTRA_STOP_SHORT_NAME = \"extra_stop_short_name\";\n    public static final String ACTION_OPEN_FAVORITE = \"action_open_favorite\";\n    public static final String EXTRA_STOP_NAME = \"extra_stop_name\";\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n        final int N = appWidgetIds.length;\n        // Perform this loop procedure for each App Widget that belongs to this provider\n        for (int i = 0; i < N; i++) {\n            final int appWidgetId = appWidgetIds[i];\n            // Create an Intent to launch ExampleActivity\n            final Intent remoteViewService = new Intent(context, DepartureWidgetRemoteViewService.class);\n            // Add the app widget ID to the intent extras.\n            // Get the layout for the App Widget and attach an on-click listener\n            // to the button\n            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_departure);\n            views.setRemoteAdapter(R.id.listView, remoteViewService);\n            // The empty view is displayed when the collection has no items.\n            // It should be in the same layout used to instantiate the RemoteViews\n            // object above.\n            views.setEmptyView(R.id.listView, R.id.emptyView);\n            // Tell the AppWidgetManager to perform an update on the current app widget\n            final Intent stopIntent = new Intent(context, StationDetailActivity.class);// StationDetailActivity.createIntent(context);\n            stopIntent.setAction(ACTION_OPEN_FAVORITE);\n            stopIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);\n            stopIntent.setData(Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)));\n            Timber.d(\"uri: %s\", Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)).toString());\n            PendingIntent stopPendingIntent = PendingIntent.getActivity(context,\n                    appWidgetId,\n                    stopIntent,\n                    PendingIntent.FLAG_CANCEL_CURRENT);\n            views.setPendingIntentTemplate(R.id.listView, stopPendingIntent);\n            appWidgetManager.updateAppWidget(appWidgetId, views);\n        }\n    }\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Timber.d(\"recieved\");\n        AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n        if (intent.getAction().equals(ACTION_OPEN_FAVORITE)) {\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            final String shortName = intent.getStringExtra(EXTRA_STOP_SHORT_NAME);\n            final String name = intent.getStringExtra(EXTRA_STOP_NAME);\n            final Intent stationDetailIntent = StationDetailActivity.createIntent(context, shortName);\n            context.startActivity(stationDetailIntent);\n            //Toast.makeText(context, \"Touched view \" + shortName, Toast.LENGTH_SHORT).show();\n        }\n        super.onReceive(context, intent);\n    }\n"]], "pred": {"ppl": 1.5348541736602783, "ppl_lower": 1.9805619716644287, "ppl/lowercase_ppl": -1.5950611628803257, "ppl/zlib": 0.00039743541340770766, "Min_5.0% Prob": 5.2528009821728965, "Min_10.0% Prob": 3.554559182829973, "Min_20.0% Prob": 2.060249317414833, "Min_30.0% Prob": 1.4161092754633677, "Min_40.0% Prob": 1.0689768870544036, "Min_50.0% Prob": 0.8567579839083902, "Min_60.0% Prob": 0.7143167926437058}}
{"hexsha": "1167f80672d250758464e2b5a4bdfea8c781f1b8", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class ProxyFactoryTest {\n\n    private TestClass proxy;\n\n    private CallInterceptor<TestClass> interceptor;\n\n    @Before\n    public void setUp() {\n        interceptor = new CallInterceptor<>(TestClass.class);\n\n        proxy = ProxyFactory.createProxy(TestClass.class, interceptor);\n    }\n\n    @Test\n    public void realMethodShouldNotBeCalled() {\n        proxy.delegate = mock(TestClass.class);\n        proxy.testMethod(\"foo\");\n\n        verify(proxy.delegate, never()).testMethod(anyString());\n    }\n\n    @Test\n    public void proxyRecordsArguementsUsedForCall() throws Throwable {\n        proxy.testMethod(\"bar\");\n\n        final Call<TestClass> call = interceptor.getInvocationRecordingResult();\n\n        assertThat(call.declaringClass()).isEqualTo(TestClass.class);\n        assertThat(call.method()).isEqualTo(TestClass.class.getDeclaredMethod(\"testMethod\", String.class));\n        assertThat(call.args()).containsExactly(\"bar\");\n    }\n\n    @Test\n    public void proxyDoesNotRecordCallsToObjectMethods() throws Throwable {\n        proxy.toString();\n\n        final Call<TestClass> call = interceptor.getInvocationRecordingResult();\n        assertThat(call.method()).isNull();\n    }\n\n    public static class TestClass {\n        TestClass delegate = mock(TestClass.class);\n\n        void testMethod(String name) {\n            delegate.testMethod(name);\n        }\n    }\n\n    @Test\n    public void failsWithFinalMethod() throws Exception {\n        assertThatThrownBy( //\n                () -> ProxyFactory.createProxy(FailingTestClass.class, new CallInterceptor<>(FailingTestClass.class)) //\n        )\n            .isInstanceOf(IllegalStateException.class) //\n            .hasMessage(\n                    \"The proxied class candidate com.mercateo.reflection.proxy.ProxyFactoryTest$FailingTestClass contains a final method 'test'\");\n    }\n\n    public static class FailingTestClass {\n        final public void test() {\n        }\n    }\n\n    @Test\n    public void skipsStaticMethod() throws Exception {\n        ProxyFactory.createProxy(NotFailingTestClass.class, new CallInterceptor<>(NotFailingTestClass.class));\n    }\n\n    public static class NotFailingTestClass {\n        static void test() {\n        }\n    }\n\n}", "class_id": 0, "repo": "Mercateo/reflection", "file": "src/test/java/com/mercateo/reflection/proxy/ProxyFactoryTest.java", "last_update_at": "2018-12-19T13:38:25+00:00", "question_id": "1167f80672d250758464e2b5a4bdfea8c781f1b8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class ProxyFactoryTest {\n    private TestClass proxy;\n    private CallInterceptor<TestClass> interceptor;\n    @Before\n    public void setUp() {\n        interceptor = new CallInterceptor<>(TestClass.class);\n        proxy = ProxyFactory.createProxy(TestClass.class, interceptor);\n    }\n    @Test\n    public void realMethodShouldNotBeCalled() {\n        proxy.delegate = mock(TestClass.class);\n        proxy.testMethod(\"foo\");\n        verify(proxy.delegate, never()).testMethod(anyString());\n    }\n    @Test\n    public void proxyRecordsArguementsUsedForCall() throws Throwable {\n        proxy.testMethod(\"bar\");\n        final Call<TestClass> call = interceptor.getInvocationRecordingResult();\n        assertThat(call.declaringClass()).isEqualTo(TestClass.class);\n        assertThat(call.method()).isEqualTo(TestClass.class.getDeclaredMethod(\"testMethod\", String.class));\n        assertThat(call.args()).containsExactly(\"bar\");\n    }\n    @Test\n    public void proxyDoesNotRecordCallsToObjectMethods() throws Throwable {\n        proxy.toString();\n        final Call<TestClass> call = interceptor.getInvocationRecordingResult();\n        assertThat(call.method()).isNull();\n    }\n    public static class TestClass {\n        TestClass delegate = mock(TestClass.class);\n        void testMethod(String name) {\n            delegate.testMethod(name);\n        }\n    }\n    @Test\n    public void failsWithFinalMethod() throws Exception {\n        assertThatThrownBy( //\n                () -> ProxyFactory.createProxy(FailingTestClass.class, new CallInterceptor<>(FailingTestClass.class)) //\n        )\n            .isInstanceOf(IllegalStateException.class) //\n            .hasMessage(\n                    \"The proxied class candidate com.mercateo.reflection.proxy.ProxyFactoryTest$FailingTestClass contains a final method 'test'\");\n    }\n    public static class FailingTestClass {\n        final public void test() {\n        }\n    }\n    @Test\n    public void skipsStaticMethod() throws Exception {\n        ProxyFactory.createProxy(NotFailingTestClass.class, new CallInterceptor<>(NotFailingTestClass.class));\n    }\n    public static class NotFailingTestClass {\n        static void test() {\n        }\n    }\n"]], "pred": {"ppl": 1.9916460514068604, "ppl_lower": 2.418283224105835, "ppl/lowercase_ppl": -1.281723188146243, "ppl/zlib": 0.0009913114508458035, "Min_5.0% Prob": 6.886686611175537, "Min_10.0% Prob": 4.874885746690094, "Min_20.0% Prob": 3.1359368592012125, "Min_30.0% Prob": 2.232923033363793, "Min_40.0% Prob": 1.7102155792773985, "Min_50.0% Prob": 1.3735183374925914, "Min_60.0% Prob": 1.148322818790684}}
{"hexsha": "35de4081b75a8c758fed2fee8348e1c234fe6700", "ext": "java", "lang": "Java", "content": "@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @Autowired\n    private AccountService accountService;\n\n\n\n    @GetMapping(\"/fetchAll\")\n    public List<AccountOutput> fetchAllExpenses(){\n        return accountService\n                .findAll ()\n                .parallelStream ()\n                .map ( (source) -> {\n                    AccountOutput accountOutput = new AccountOutput ( );\n                    BeanUtils.copyProperties ( source, accountOutput );\n                    return accountOutput;\n                })\n                .collect ( Collectors.toList ( ) );\n    }\n\n\n    @PostMapping(\"/add\")\n    public @ResponseBody AccountOutput addExpenses(@RequestBody AccountInput accountInput){\n\n        Account account = new Account () ;\n        BeanUtils.copyProperties ( accountInput, account );\n        accountService.saveOrUpdate ( account );\n        return new AccountOutput ();\n\n    }\n\n}", "class_id": 0, "repo": "psingarakannan/home-acc-mngmt", "file": "txn/txn-api/src/main/java/org/pradeep/txn/mngmt/api/controllers/AccountController.java", "last_update_at": "2018-12-28T06:30:04+00:00", "question_id": "35de4081b75a8c758fed2fee8348e1c234fe6700", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n    @Autowired\n    private AccountService accountService;\n    @GetMapping(\"/fetchAll\")\n    public List<AccountOutput> fetchAllExpenses(){\n        return accountService\n                .findAll ()\n                .parallelStream ()\n                .map ( (source) -> {\n                    AccountOutput accountOutput = new AccountOutput ( );\n                    BeanUtils.copyProperties ( source, accountOutput );\n                    return accountOutput;\n                })\n                .collect ( Collectors.toList ( ) );\n    }\n    @PostMapping(\"/add\")\n    public @ResponseBody AccountOutput addExpenses(@RequestBody AccountInput accountInput){\n        Account account = new Account () ;\n        BeanUtils.copyProperties ( accountInput, account );\n        accountService.saveOrUpdate ( account );\n        return new AccountOutput ();\n    }\n"]], "pred": {"ppl": 2.249518871307373, "ppl_lower": 2.7535793781280518, "ppl/lowercase_ppl": -1.2493909206637943, "ppl/zlib": 0.002258262836701588, "Min_5.0% Prob": 8.377957630157471, "Min_10.0% Prob": 5.893881979442778, "Min_20.0% Prob": 3.6176726576827822, "Min_30.0% Prob": 2.5575529146008193, "Min_40.0% Prob": 1.9838660955429077, "Min_50.0% Prob": 1.6023778104893516, "Min_60.0% Prob": 1.3500474137836136}}
{"hexsha": "772087cb0130c4cc2d77bf65db6698c16350a32d", "ext": "java", "lang": "Java", "content": "public class ScheduleAlarmManager {\n\n    private Context mContext;\n    private SwitchCompat mSwitchCompat = null;\n    private boolean mAlarmOn = false;\n    private ScheduleBroadcastReceiver mScheduleManager;\n\n    public ScheduleAlarmManager(Context context, SwitchCompat switchCompat) {\n\n        /**\n         *\n         */\n        this.mContext = context;\n        this.mSwitchCompat = switchCompat;\n\n        /**\n         *\n         */\n        mScheduleManager = new ScheduleBroadcastReceiver();\n\n        /**\n         *\n         */\n        mAlarmOn = isAlarmOn();\n        if (mAlarmOn) {\n            if (mSwitchCompat != null)\n                mSwitchCompat.setChecked(true);\n        } else {\n            if (mSwitchCompat != null)\n                mSwitchCompat.setChecked(false);\n        }\n    }\n\n    public boolean isAlarmOn() {\n\n        int alarm_time_breakfast = -1;\n        int alarm_time_launch = -1;\n        int alarm_time_dinner = -1;\n\n        try {\n            alarm_time_breakfast = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);\n            alarm_time_launch = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);\n            alarm_time_dinner = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);\n\n            if (alarm_time_breakfast == -1 || alarm_time_launch == -1 || alarm_time_dinner == -1) {\n                return false;\n            } else {\n                return true;\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n\n    public void toggleAlaram() {\n        if (mAlarmOn) {\n            makeAlarmOff();\n        } else {\n            makeAlarmOn();\n        }\n    }\n\n    public void makeAlarmOn() {\n        if (mSwitchCompat != null)\n            mSwitchCompat.setChecked(true);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, 730);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, 1130);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, 1720);\n\n        if (mScheduleManager != null) {\n            mScheduleManager.setAlarm(mContext);\n        }\n\n        mAlarmOn = true;\n    }\n\n    public void makeAlarmOff() {\n\n        if (mSwitchCompat != null)\n            mSwitchCompat.setChecked(false);\n\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);\n\n        if (mScheduleManager != null) {\n            mScheduleManager.cancelAlarm(mContext);\n        }\n        mAlarmOn = false;\n    }\n}", "class_id": 0, "repo": "JoonyoungYi/onepunch-android", "file": "app/src/main/java/com/forasterisk/ilkeok/utils/ScheduleAlarmManager.java", "last_update_at": "2018-03-09T05:33:54+00:00", "question_id": "772087cb0130c4cc2d77bf65db6698c16350a32d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ScheduleAlarmManager {\n    private Context mContext;\n    private SwitchCompat mSwitchCompat = null;\n    private boolean mAlarmOn = false;\n    private ScheduleBroadcastReceiver mScheduleManager;\n    public ScheduleAlarmManager(Context context, SwitchCompat switchCompat) {\n        /**\n         *\n         */\n        this.mContext = context;\n        this.mSwitchCompat = switchCompat;\n        /**\n         *\n         */\n        mScheduleManager = new ScheduleBroadcastReceiver();\n        /**\n         *\n         */\n        mAlarmOn = isAlarmOn();\n        if (mAlarmOn) {\n            if (mSwitchCompat != null)\n                mSwitchCompat.setChecked(true);\n        } else {\n            if (mSwitchCompat != null)\n                mSwitchCompat.setChecked(false);\n        }\n    }\n    public boolean isAlarmOn() {\n        int alarm_time_breakfast = -1;\n        int alarm_time_launch = -1;\n        int alarm_time_dinner = -1;\n        try {\n            alarm_time_breakfast = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);\n            alarm_time_launch = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);\n            alarm_time_dinner = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);\n            if (alarm_time_breakfast == -1 || alarm_time_launch == -1 || alarm_time_dinner == -1) {\n                return false;\n            } else {\n                return true;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n    public void toggleAlaram() {\n        if (mAlarmOn) {\n            makeAlarmOff();\n        } else {\n            makeAlarmOn();\n        }\n    }\n    public void makeAlarmOn() {\n        if (mSwitchCompat != null)\n            mSwitchCompat.setChecked(true);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, 730);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, 1130);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, 1720);\n        if (mScheduleManager != null) {\n            mScheduleManager.setAlarm(mContext);\n        }\n        mAlarmOn = true;\n    }\n    public void makeAlarmOff() {\n        if (mSwitchCompat != null)\n            mSwitchCompat.setChecked(false);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);\n        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);\n        if (mScheduleManager != null) {\n            mScheduleManager.cancelAlarm(mContext);\n        }\n        mAlarmOn = false;\n    }\n"]], "pred": {"ppl": 1.433882474899292, "ppl_lower": 1.513872742652893, "ppl/lowercase_ppl": -1.150631122756869, "ppl/zlib": 0.0005869475287975025, "Min_5.0% Prob": 4.814946134885152, "Min_10.0% Prob": 3.0597174295357297, "Min_20.0% Prob": 1.7392581117649872, "Min_30.0% Prob": 1.1936302993830943, "Min_40.0% Prob": 0.9013338483581763, "Min_50.0% Prob": 0.7204148443017571, "Min_60.0% Prob": 0.6008058656530344}}
{"hexsha": "2b422de92cf599fed5d455c1995f27b404ce322e", "ext": "java", "lang": "Java", "content": "public class Global extends GlobalSettings {\n\n\t @Override\n\t  public void onStart(Application app) {\n\t    System.out.println(\"Application has started\");\n\t    // OAuth\n\t    final Google2Client googleClient = new Google2Client (\n\t    \t\t\"134678913668-m92g9igaokp1jjknom4kbq5dnub66uhm.apps.googleusercontent.com\", \n\t    \t\t\"Ql5NPhYeLf5RuwC1w8FNjCYR\");\n\t    \n\t    final FacebookClient facebookClient = new FacebookClient(\"132736803558924\", \"e461422527aeedb32ee6c10834d3e19e\");\n\t    \n\t    final Clients clients = new Clients(\"http://localhost:9000/callback\", googleClient, facebookClient);\n\t    Config.setClients(clients);\n\t  }  \n\t  \n\t  @Override\n\t  public void onStop(Application app) {\n\t\t  System.out.println(\"Application shutdown...\");\n\t  }  \n}", "class_id": 0, "repo": "mahulkko/TowerDefencePlay", "file": "app/controllers/Global.java", "last_update_at": "2018-03-19T10:07:17+00:00", "question_id": "2b422de92cf599fed5d455c1995f27b404ce322e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Global extends GlobalSettings {\n\t @Override\n\t  public void onStart(Application app) {\n\t    System.out.println(\"Application has started\");\n\t    // OAuth\n\t    final Google2Client googleClient = new Google2Client (\n\t    \t\t\"134678913668-m92g9igaokp1jjknom4kbq5dnub66uhm.apps.googleusercontent.com\", \n\t    \t\t\"Ql5NPhYeLf5RuwC1w8FNjCYR\");\n\t    \n\t    final FacebookClient facebookClient = new FacebookClient(\"132736803558924\", \"e461422527aeedb32ee6c10834d3e19e\");\n\t    \n\t    final Clients clients = new Clients(\"http://localhost:9000/callback\", googleClient, facebookClient);\n\t    Config.setClients(clients);\n\t  }  \n\t  \n\t  @Override\n\t  public void onStop(Application app) {\n\t\t  System.out.println(\"Application shutdown...\");\n\t  }  \n"]], "pred": {"ppl": 5.919692039489746, "ppl_lower": 8.323954582214355, "ppl/lowercase_ppl": -1.1916752010386724, "ppl/zlib": 0.004490617240369563, "Min_5.0% Prob": 7.828050238745553, "Min_10.0% Prob": 6.563009689594137, "Min_20.0% Prob": 5.205819299665548, "Min_30.0% Prob": 4.459129674868151, "Min_40.0% Prob": 3.936206268051923, "Min_50.0% Prob": 3.4339920121270255, "Min_60.0% Prob": 2.949399907878563}}
{"hexsha": "cc8d3967434360dd9a5cdc85ebe3b54265a2cb0e", "ext": "java", "lang": "Java", "content": "@Service(\"requestSigner\")\npublic class CorsRequestSignerImpl implements CorsRequestSignerTemplate {\n    private static final Logger LOGGER = LoggerFactory.getLogger(CorsRequestSignerImpl.class);\n\n    private static final String PROTOCOL = \"https://\";\n    private static final String S3_URL = \"s3.amazonaws.com\";\n    private static final String MIME_TYPE = \"application/octet-stream\";\n    private static final String AMAZON_UPLOAD_HEADERS = \"x-amz-acl:private\";\n    private static final String AMAZON_SSE_HEADERS = \"x-amz-server-side-encryption:AES256\";\n    private static final String AMAZON_SECURITY_TOKEN_HEADER = \"x-amz-security-token\";\n    private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\n    private static final String UTF_8 = \"UTF-8\";\n\n    private final FileMetaDataRepository fileMetaDataRepository;\n    private final AWSCredentialsProvider credentialsProvider;\n    private final AmazonPropertiesProvider amazonPropertiesProvider;\n\n    @Inject\n    public CorsRequestSignerImpl(FileMetaDataRepository fileMetaDataRepository,\n                                 CloudStorageClientsProvider cloudStorageClientsProvider,\n                                 AmazonPropertiesProvider amazonPropertiesProvider) {\n        this.fileMetaDataRepository = fileMetaDataRepository;\n        this.credentialsProvider = cloudStorageClientsProvider.getS3FileOperationHandler().getCredentialsProvider();\n        this.amazonPropertiesProvider = amazonPropertiesProvider;\n    }\n\n    @Override\n    public String signSingleFileUploadRequest(long userId, String objectName) {\n        final String bucket = getBucketForSingleRequest(objectName);\n        long expireTime = new Date().getTime() / 1000 + (60 * 5); // 2000 minutes from now\n        objectName = urlencode(objectName);\n\n        String stringToSign = \"PUT\\n\\n\"\n            + MIME_TYPE + \"\\n\"\n            + expireTime + \"\\n\"\n            + AMAZON_UPLOAD_HEADERS + \"\\n\"\n            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + \"\\n\" : \"\")\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName;\n\n        String signature = urlencode(calculateRFC2104HMAC(stringToSign, getAmazonSecret()));\n\n        return urlencode(PROTOCOL + bucket + \".\" + S3_URL + DELIMITER + objectName\n                             + \"?AWSAccessKeyId=\" + getAmazonKey() + \"&Expires=\" +\n                             expireTime + \"&Signature=\" + signature\n        );\n    }\n\n    private String getAmazonKey() {\n        if (credentialsProvider != null) {\n            return credentialsProvider.getCredentials().getAWSAccessKeyId();\n        }\n\n        return \"\";\n    }\n\n    private String getAmazonSecret() {\n        if (credentialsProvider != null) {\n            return credentialsProvider.getCredentials().getAWSSecretKey();\n        }\n\n        return \"\";\n    }\n\n    @Override\n    public String getAmazonToken() {\n        if (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider) {\n            return ((BasicSessionCredentials) credentialsProvider.getCredentials()).getSessionToken();\n        }\n\n        return \"\";\n    }\n\n    @Override\n    public boolean useSessionToken() {\n        return (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider);\n    }\n\n    @Override\n    public SignedRequest signForSingleFileUploadRequest(long userId, String objectName) {\n        try {\n            return new SignedRequest(\n                null,\n                URLDecoder.decode(signSingleFileUploadRequest(userId, objectName), \"UTF-8\"),\n                null,\n                getAmazonToken()\n            );\n        } catch (UnsupportedEncodingException e) {\n            throw Throwables.propagate(e);\n        }\n    }\n\n    //new multipart upload request signing methods\n    //todo[tymchenko]: generify methods\n\n    @Override\n    public SignedRequest signInitialUploadRequest(long userId, String objectName) {\n        final String bucket = processObjectForInitialUploadRequest(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n\n        final String queryParams = \"?uploads\";\n        String stringToSign = \"POST\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + AMAZON_UPLOAD_HEADERS + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + \"\\n\" : \"\")\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName + queryParams;\n\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + bucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n\n\n    @Override\n    public SignedRequest signUploadPartRequest(long userId, String objectName, long partNumber, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n\n        final String queryParams = \"?partNumber=\" + partNumber + \"&uploadId=\" + uploadId;\n        String stringToSign = \"PUT\\n\\n\"\n            + MIME_TYPE + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n\n    @Override\n    public SignedRequest signListPartsRequest(long userId, String objectName, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n\n        final String queryParams = \"?uploadId=\" + uploadId;\n        String stringToSign = \"GET\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n\n\n    @Override\n    public SignedRequest signAbortUploadRequest(long userId, String objectName, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n\n        final String queryParams = \"?uploadId=\" + uploadId;\n        String stringToSign = \"DELETE\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n\n\n    @Override\n    public SignedRequest signCompleteUploadRequest(long userId,\n                                                   String objectName,\n                                                   String uploadId,\n                                                   boolean addCharsetToContentType) {\n        final String bucket = processCompleteUploadRequest(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n\n        final String queryParams = \"?uploadId=\" + uploadId;\n        final String textXmlContentType = \"text/xml\";\n        final String contentType = addCharsetToContentType\n            ? (textXmlContentType + \"; charset=UTF-8\")\n            : textXmlContentType;\n\n        String stringToSign = \"POST\\n\\n\"\n            + contentType + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName + queryParams;\n\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + bucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n\n    @Override\n    public boolean useServerSideEncryption() {\n        return amazonPropertiesProvider.isServersideEncryptionEnabled();\n    }\n\n    // --- Helper methods ----\n\n    private static String getAmzFormattedDate() {\n        final Date date = new Date();\n\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH);\n        return simpleDateFormat.format(date);\n    }\n\n    private static String urlencode(String s) {\n        try {\n            return URLEncoder.encode(s, UTF_8);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String calculateRFC2104HMAC(String data, String key) {\n        String result;\n        try {\n\n            // get an hmac_sha1 key from the raw key bytes\n            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);\n\n            // get an hmac_sha1 Mac instance and initialize with the signing key\n            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n            mac.init(signingKey);\n\n            // compute the hmac on input data bytes\n            byte[] rawHmac = mac.doFinal(data.getBytes());\n\n            // base64-encode the hmac\n            result = new String(Base64.encodeBase64(rawHmac), UTF_8);\n\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n\n        return result;\n    }\n\n    private String processObjectForInitialUploadRequest(String objectName) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(metaFile -> {\n            final String bucket = bucketForFileMetaData(metaFile);\n            metaFile.setFileUploadBucket(bucket);\n            fileMetaDataRepository.save(metaFile);\n            return bucket;\n        }).orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n\n    private String getBucketForSingleRequest(String object) {\n\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(object))\n            .map(this::bucketForFileMetaData)\n            .orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n\n    private String processCompleteUploadRequest(String objectName) {\n\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(input -> {\n            final String bucket = input.getFileUploadBucket();\n            input.setFileUploadBucket(null);\n            fileMetaDataRepository.save(input);\n            return bucket;\n        }).orElse(amazonPropertiesProvider.getActiveBucket());\n\n    }\n\n    private String bucketForFileMetaData(ActiveFileMetaData metaFile) {\n        return amazonPropertiesProvider.getActiveBucket();\n    }\n\n    private String getObjectBucket(String objectName) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName))\n            .map(ActiveFileMetaData::getFileUploadBucket)\n            .orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n\n}", "class_id": 0, "repo": "InfoClinika/chorus-opensource", "file": "chorus/model-impl/src/main/java/com/infoclinika/mssharing/model/internal/helper/CorsRequestSignerImpl.java", "last_update_at": "2018-03-22T06:54:50+00:00", "question_id": "cc8d3967434360dd9a5cdc85ebe3b54265a2cb0e", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Service(\"requestSigner\")\npublic class CorsRequestSignerImpl implements CorsRequestSignerTemplate {\n    private static final Logger LOGGER = LoggerFactory.getLogger(CorsRequestSignerImpl.class);\n    private static final String PROTOCOL = \"https://\";\n    private static final String S3_URL = \"s3.amazonaws.com\";\n    private static final String MIME_TYPE = \"application/octet-stream\";\n    private static final String AMAZON_UPLOAD_HEADERS = \"x-amz-acl:private\";\n    private static final String AMAZON_SSE_HEADERS = \"x-amz-server-side-encryption:AES256\";\n    private static final String AMAZON_SECURITY_TOKEN_HEADER = \"x-amz-security-token\";\n    private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\n    private static final String UTF_8 = \"UTF-8\";\n    private final FileMetaDataRepository fileMetaDataRepository;\n    private final AWSCredentialsProvider credentialsProvider;\n    private final AmazonPropertiesProvider amazonPropertiesProvider;\n    @Inject\n    public CorsRequestSignerImpl(FileMetaDataRepository fileMetaDataRepository,\n                                 CloudStorageClientsProvider cloudStorageClientsProvider,\n                                 AmazonPropertiesProvider amazonPropertiesProvider) {\n        this.fileMetaDataRepository = fileMetaDataRepository;\n        this.credentialsProvider = cloudStorageClientsProvider.getS3FileOperationHandler().getCredentialsProvider();\n        this.amazonPropertiesProvider = amazonPropertiesProvider;\n    }\n    @Override\n    public String signSingleFileUploadRequest(long userId, String objectName) {\n        final String bucket = getBucketForSingleRequest(objectName);\n        long expireTime = new Date().getTime() / 1000 + (60 * 5); // 2000 minutes from now\n        objectName = urlencode(objectName);\n        String stringToSign = \"PUT\\n\\n\"\n            + MIME_TYPE + \"\\n\"\n            + expireTime + \"\\n\"\n            + AMAZON_UPLOAD_HEADERS + \"\\n\"\n            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + \"\\n\" : \"\")\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName;\n        String signature = urlencode(calculateRFC2104HMAC(stringToSign, getAmazonSecret()));\n        return urlencode(PROTOCOL + bucket + \".\" + S3_URL + DELIMITER + objectName\n                             + \"?AWSAccessKeyId=\" + getAmazonKey() + \"&Expires=\" +\n                             expireTime + \"&Signature=\" + signature\n        );\n    }\n    private String getAmazonKey() {\n        if (credentialsProvider != null) {\n            return credentialsProvider.getCredentials().getAWSAccessKeyId();\n        }\n        return \"\";\n    }\n    private String getAmazonSecret() {\n        if (credentialsProvider != null) {\n            return credentialsProvider.getCredentials().getAWSSecretKey();\n        }\n        return \"\";\n    }\n    @Override\n    public String getAmazonToken() {\n        if (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider) {\n            return ((BasicSessionCredentials) credentialsProvider.getCredentials()).getSessionToken();\n        }\n        return \"\";\n    }\n    @Override\n    public boolean useSessionToken() {\n        return (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider);\n    }\n    @Override\n    public SignedRequest signForSingleFileUploadRequest(long userId, String objectName) {\n        try {\n            return new SignedRequest(\n                null,\n                URLDecoder.decode(signSingleFileUploadRequest(userId, objectName), \"UTF-8\"),\n                null,\n                getAmazonToken()\n            );\n        } catch (UnsupportedEncodingException e) {\n            throw Throwables.propagate(e);\n        }\n    }\n    //new multipart upload request signing methods\n    //todo[tymchenko]: generify methods\n    @Override\n    public SignedRequest signInitialUploadRequest(long userId, String objectName) {\n        final String bucket = processObjectForInitialUploadRequest(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n        final String queryParams = \"?uploads\";\n        String stringToSign = \"POST\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + AMAZON_UPLOAD_HEADERS + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + \"\\n\" : \"\")\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName + queryParams;\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + bucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n    @Override\n    public SignedRequest signUploadPartRequest(long userId, String objectName, long partNumber, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n        final String queryParams = \"?partNumber=\" + partNumber + \"&uploadId=\" + uploadId;\n        String stringToSign = \"PUT\\n\\n\"\n            + MIME_TYPE + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n    @Override\n    public SignedRequest signListPartsRequest(long userId, String objectName, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n        final String queryParams = \"?uploadId=\" + uploadId;\n        String stringToSign = \"GET\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n    @Override\n    public SignedRequest signAbortUploadRequest(long userId, String objectName, String uploadId) {\n        final String objectBucket = getObjectBucket(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n        final String queryParams = \"?uploadId=\" + uploadId;\n        String stringToSign = \"DELETE\\n\\n\"\n            + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + objectBucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n    @Override\n    public SignedRequest signCompleteUploadRequest(long userId,\n                                                   String objectName,\n                                                   String uploadId,\n                                                   boolean addCharsetToContentType) {\n        final String bucket = processCompleteUploadRequest(objectName);\n        final String formattedDate = getAmzFormattedDate();\n        objectName = urlencode(objectName);\n        final String queryParams = \"?uploadId=\" + uploadId;\n        final String textXmlContentType = \"text/xml\";\n        final String contentType = addCharsetToContentType\n            ? (textXmlContentType + \"; charset=UTF-8\")\n            : textXmlContentType;\n        String stringToSign = \"POST\\n\\n\"\n            + contentType + \"\\n\"\n            + \"\\n\"\n            + \"x-amz-date:\" + formattedDate + \"\\n\"\n            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + \":\" + getAmazonToken() + \"\\n\" : \"\")\n            + DELIMITER + bucket + DELIMITER + objectName + queryParams;\n        LOGGER.info(\" **** StringToSign: {}\", stringToSign);\n        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());\n        final String authorization = \"AWS \" + getAmazonKey() + \":\" + signature;\n        final String host = PROTOCOL + bucket + \".s3.amazonaws.com\" + DELIMITER + objectName + queryParams;\n        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());\n    }\n    @Override\n    public boolean useServerSideEncryption() {\n        return amazonPropertiesProvider.isServersideEncryptionEnabled();\n    }\n    // --- Helper methods ----\n    private static String getAmzFormattedDate() {\n        final Date date = new Date();\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH);\n        return simpleDateFormat.format(date);\n    }\n    private static String urlencode(String s) {\n        try {\n            return URLEncoder.encode(s, UTF_8);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static String calculateRFC2104HMAC(String data, String key) {\n        String result;\n        try {\n            // get an hmac_sha1 key from the raw key bytes\n            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);\n            // get an hmac_sha1 Mac instance and initialize with the signing key\n            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n            mac.init(signingKey);\n            // compute the hmac on input data bytes\n            byte[] rawHmac = mac.doFinal(data.getBytes());\n            // base64-encode the hmac\n            result = new String(Base64.encodeBase64(rawHmac), UTF_8);\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n        return result;\n    }\n    private String processObjectForInitialUploadRequest(String objectName) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(metaFile -> {\n            final String bucket = bucketForFileMetaData(metaFile);\n            metaFile.setFileUploadBucket(bucket);\n            fileMetaDataRepository.save(metaFile);\n            return bucket;\n        }).orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n    private String getBucketForSingleRequest(String object) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(object))\n            .map(this::bucketForFileMetaData)\n            .orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n    private String processCompleteUploadRequest(String objectName) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(input -> {\n            final String bucket = input.getFileUploadBucket();\n            input.setFileUploadBucket(null);\n            fileMetaDataRepository.save(input);\n            return bucket;\n        }).orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n    private String bucketForFileMetaData(ActiveFileMetaData metaFile) {\n        return amazonPropertiesProvider.getActiveBucket();\n    }\n    private String getObjectBucket(String objectName) {\n        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName))\n            .map(ActiveFileMetaData::getFileUploadBucket)\n            .orElse(amazonPropertiesProvider.getActiveBucket());\n    }\n"]], "pred": {"ppl": 1.8361992835998535, "ppl_lower": 2.4244816303253174, "ppl/lowercase_ppl": -1.4573324096407163, "ppl/zlib": 0.0002708100840346384, "Min_5.0% Prob": 6.30764747133442, "Min_10.0% Prob": 4.500798903259576, "Min_20.0% Prob": 2.8176992950486204, "Min_30.0% Prob": 1.985849586479804, "Min_40.0% Prob": 1.5096535642783915, "Min_50.0% Prob": 1.2140299387935936, "Min_60.0% Prob": 1.0135624674179244}}
{"hexsha": "0dc246c463f73a72b8278978cbb0a556b3f10dc2", "ext": "java", "lang": "Java", "content": "public class ExpressionFunction extends AbstractFunction implements XMLEntity {\n\tprivate static Variables varSet = new Variables();\n\tprivate Expression expr;\n\tprivate List<String> parameters;\n\tprivate String name;\n\n\tpublic static String listToString(List<String> l) {\n\t\tString r = \"\";\n\t\tif (l.isEmpty())\n\t\t\treturn r;\n\t\tfor (Object o : l) {\n\t\t\tr += o.toString() + \", \";\n\t\t}\n\t\treturn r.substring(0, r.length() - 2);\n\t}\n\n\tpublic static void stringToList(String s, List<String> result)\n\t\t\tthrows Exception {\n\t\tresult.clear();\n\t\ts = s.trim();\n\t\tif (s.length() > 0) {\n\t\t\tfor (String r : s.split(\",\")) {\n\t\t\t\tif (r.trim().isEmpty())\n\t\t\t\t\tthrow new Exception(\"Invalid parameter list format!\");\n\t\t\t\tresult.add(r.trim());\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic ExpressionFunction(String name, Expression expr,\n\t\t\tList<String> parameters) {\n\t\tthis.expr = expr;\n\t\tthis.parameters = parameters;\n\t\tthis.name = name;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\n\tpublic boolean isStatic() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getMinNbArg() {\n\t\treturn parameters.size();\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Object getValue(EntityInterface e, List<Object> args) {\n\t\tvarSet.clear();\n\t\tint index = 0;\n\t\tfor (String s : parameters)\n\t\t\tvarSet.affect(s, args.get(index++), null);\n\t\treturn expr.getObject(e, varSet);\n\t}\n\n\tpublic String toString() {\n\t\treturn name + \"(\" + parameters + \") = \" + expr.toString();\n\t}\n\n\t@Override\n\tpublic ExpressionFunction copy() {\n\t\treturn new ExpressionFunction(name, new Expression(expr),\n\t\t\t\tnew LinkedList<String>(parameters));\n\t}\n\n\tpublic void unregister() {\n\t\tFunctionList.unregister(this);\n\t}\n\n\t@Override\n\tpublic void fromXML(Element e, XMLCrossRef refs) throws Exception {\n\t\tname = e.getAttribute(\"name\");\n\t\texpr = new Expression(e.getAttribute(\"expr\"));\n\t\tparameters = new LinkedList<String>();\n\t\tstringToList(e.getAttribute(\"parameters\"), parameters);\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\n\t@Override\n\tpublic Element toXML(Document root, XMLCrossRef refs) throws Exception {\n\t\tElement e = root.createElement(this.getClass().getName());\n\t\te.setAttribute(\"name\", name);\n\t\te.setAttribute(\"parameters\", listToString(parameters));\n\t\te.setAttribute(\"expr\", expr.toString());\n\t\treturn e;\n\t}\n\n\tpublic List<String> getParameters() {\n\t\treturn parameters;\n\t}\n\n\tpublic Expression getExpression() {\n\t\treturn expr;\n\t}\n\n\tpublic void setName(String name) {\n\t\tFunctionList.unregister(this);\n\t\tthis.name = name;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\n\tpublic void setParameters(List<String> parameters) {\n\t\tFunctionList.unregister(this);\n\t\tthis.parameters = parameters;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\n\tpublic void setExpression(Expression expr) {\n\t\tthis.expr = expr;\n\t}\n\n\tpublic void setFunction(String name, String parameters) throws Exception {\n\t\tFunctionList.unregister(this);\n\t\tthis.name = name;\n\t\tthis.parameters = new LinkedList<String>();\n\t\tstringToList(parameters, this.parameters);\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n}", "class_id": 0, "repo": "damienmg/wmas", "file": "src/main/java/wmas/world/functions/ExpressionFunction.java", "last_update_at": "2018-12-12T03:36:08+00:00", "question_id": "0dc246c463f73a72b8278978cbb0a556b3f10dc2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExpressionFunction extends AbstractFunction implements XMLEntity {\n\tprivate static Variables varSet = new Variables();\n\tprivate Expression expr;\n\tprivate List<String> parameters;\n\tprivate String name;\n\tpublic static String listToString(List<String> l) {\n\t\tString r = \"\";\n\t\tif (l.isEmpty())\n\t\t\treturn r;\n\t\tfor (Object o : l) {\n\t\t\tr += o.toString() + \", \";\n\t\t}\n\t\treturn r.substring(0, r.length() - 2);\n\t}\n\tpublic static void stringToList(String s, List<String> result)\n\t\t\tthrows Exception {\n\t\tresult.clear();\n\t\ts = s.trim();\n\t\tif (s.length() > 0) {\n\t\t\tfor (String r : s.split(\",\")) {\n\t\t\t\tif (r.trim().isEmpty())\n\t\t\t\t\tthrow new Exception(\"Invalid parameter list format!\");\n\t\t\t\tresult.add(r.trim());\n\t\t\t}\n\t\t}\n\t}\n\tpublic ExpressionFunction(String name, Expression expr,\n\t\t\tList<String> parameters) {\n\t\tthis.expr = expr;\n\t\tthis.parameters = parameters;\n\t\tthis.name = name;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\tpublic boolean isStatic() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int getMinNbArg() {\n\t\treturn parameters.size();\n\t}\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t@Override\n\tpublic Object getValue(EntityInterface e, List<Object> args) {\n\t\tvarSet.clear();\n\t\tint index = 0;\n\t\tfor (String s : parameters)\n\t\t\tvarSet.affect(s, args.get(index++), null);\n\t\treturn expr.getObject(e, varSet);\n\t}\n\tpublic String toString() {\n\t\treturn name + \"(\" + parameters + \") = \" + expr.toString();\n\t}\n\t@Override\n\tpublic ExpressionFunction copy() {\n\t\treturn new ExpressionFunction(name, new Expression(expr),\n\t\t\t\tnew LinkedList<String>(parameters));\n\t}\n\tpublic void unregister() {\n\t\tFunctionList.unregister(this);\n\t}\n\t@Override\n\tpublic void fromXML(Element e, XMLCrossRef refs) throws Exception {\n\t\tname = e.getAttribute(\"name\");\n\t\texpr = new Expression(e.getAttribute(\"expr\"));\n\t\tparameters = new LinkedList<String>();\n\t\tstringToList(e.getAttribute(\"parameters\"), parameters);\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\t@Override\n\tpublic Element toXML(Document root, XMLCrossRef refs) throws Exception {\n\t\tElement e = root.createElement(this.getClass().getName());\n\t\te.setAttribute(\"name\", name);\n\t\te.setAttribute(\"parameters\", listToString(parameters));\n\t\te.setAttribute(\"expr\", expr.toString());\n\t\treturn e;\n\t}\n\tpublic List<String> getParameters() {\n\t\treturn parameters;\n\t}\n\tpublic Expression getExpression() {\n\t\treturn expr;\n\t}\n\tpublic void setName(String name) {\n\t\tFunctionList.unregister(this);\n\t\tthis.name = name;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\tpublic void setParameters(List<String> parameters) {\n\t\tFunctionList.unregister(this);\n\t\tthis.parameters = parameters;\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n\tpublic void setExpression(Expression expr) {\n\t\tthis.expr = expr;\n\t}\n\tpublic void setFunction(String name, String parameters) throws Exception {\n\t\tFunctionList.unregister(this);\n\t\tthis.name = name;\n\t\tthis.parameters = new LinkedList<String>();\n\t\tstringToList(parameters, this.parameters);\n\t\tFunctionList.registerSession(this, \"World attribute function\");\n\t}\n"]], "pred": {"ppl": 1.6463088989257812, "ppl_lower": 1.772741436958313, "ppl/lowercase_ppl": -1.14841750384666, "ppl/zlib": 0.0005349096041489309, "Min_5.0% Prob": 5.286492544061997, "Min_10.0% Prob": 3.792434268137988, "Min_20.0% Prob": 2.3338026591375765, "Min_30.0% Prob": 1.6294025574731672, "Min_40.0% Prob": 1.239172964913807, "Min_50.0% Prob": 0.9943039824898171, "Min_60.0% Prob": 0.8304040504309544}}
{"hexsha": "57e94172c3c81be30c6639edc92a8eccde650e72", "ext": "java", "lang": "Java", "content": "public class Ej3 {\r\n    public static void main(String[] args) {\r\n        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};\r\n        int fila = 1;\r\n        System.out.println(Ej3.mayor(matrix, fila));\r\n    }\r\n    \r\n    public static int mayor(int[][] matrix,int i)\r\n    {\r\n        int mayor = matrix[i][0];\r\n        int fila = 0;\r\n        for (int j = 0; j < matrix[i].length; j++) \r\n        {\r\n            if (matrix[i][j] > mayor) {\r\n                mayor = matrix[i][j];\r\n                fila=j;\r\n            }\r\n        }\r\n        return fila;\r\n    }  \r\n}", "class_id": 0, "repo": "GonzaBena/Escuela-Tecnica-N1-Otto-Krause", "file": "Programacion sobre Redes/Guia de Ejercicios 2/2-ej3/src/ej3/Ej3.java", "last_update_at": "2018-05-14T11:01:47+00:00", "question_id": "57e94172c3c81be30c6639edc92a8eccde650e72", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Ej3 {\r\n    public static void main(String[] args) {\r\n        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};\r\n        int fila = 1;\r\n        System.out.println(Ej3.mayor(matrix, fila));\r\n    }\r\n    \r\n    public static int mayor(int[][] matrix,int i)\r\n    {\r\n        int mayor = matrix[i][0];\r\n        int fila = 0;\r\n        for (int j = 0; j < matrix[i].length; j++) \r\n        {\r\n            if (matrix[i][j] > mayor) {\r\n                mayor = matrix[i][j];\r\n                fila=j;\r\n            }\r\n        }\r\n        return fila;\r\n    }  \r\n"]], "pred": {"ppl": 1.818799376487732, "ppl_lower": 2.02902889251709, "ppl/lowercase_ppl": -1.182856869263142, "ppl/zlib": 0.0023275354091574687, "Min_5.0% Prob": 5.711958567301433, "Min_10.0% Prob": 4.2422878993184945, "Min_20.0% Prob": 2.679998267638056, "Min_30.0% Prob": 1.9006882065842892, "Min_40.0% Prob": 1.4717107948351216, "Min_50.0% Prob": 1.1827765370997572, "Min_60.0% Prob": 0.9951999342101144}}
{"hexsha": "335c1e6d0f4454939550f571c6304e34f1650ef9", "ext": "java", "lang": "Java", "content": "public class Character {\n    public enum CASE {\n        lower,\n        upper\n    }\n\n    public enum SYMBOL {\n        a, b, c, d, e,\n        f, g, h, i, j,\n        k, l, m, n, o,\n        p, q, r, s, t,\n        u, v, w, x, y, z\n    }\n\n    public class Coordinate {\n        public final double x;\n        public final double y;\n\n        Coordinate(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    \n\n    public Character() {\n\n    }\n\n    public Character(SYMBOL symbol, CASE charCase) {\n        this.mSymbol = symbol;\n        this.mCase = charCase;\n\n        this.mOutline = new ArrayList<List<Coordinate>>();\n    }\n\n    public void clear() {\n        this.mOutline = new ArrayList<List<Coordinate>>();\n        this.mCurrentContour = null;\n    }\n\n    public void save(String fileName) throws ParserConfigurationException, TransformerException {\n\n        //Create DOM document creator\n        DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder  documentBuilder =  documentFactory.newDocumentBuilder();\n        Document document = documentBuilder.newDocument();\n\n        //Create root element\n        Element root =  document.createElement(\"glyph\");\n\n        //create root attribute\n        Attr attr = document.createAttribute(\"name\");\n        attr.setValue(mSymbol.toString());\n        root.setAttributeNode(attr);\n\n        attr = document.createAttribute(\"format\");\n        attr.setValue(\"2\");\n        root.setAttributeNode(attr);\n\n        //create advance element\n        Element advance = document.createElement(\"advance\");\n\n        // set width attribute\n        attr = document.createAttribute(\"width\");\n        attr.setValue(\"268\");\n        advance.setAttributeNode(attr);\n\n        // set height attribute\n        attr = document.createAttribute(\"height\");\n        attr.setValue(\"268\");\n        advance.setAttributeNode(attr);\n\n        // append advance to root\n        root.appendChild(advance);\n\n        //create unicode element\n        Element unicode = document.createElement(\"unicode\");\n\n        // Create hexcode element\n        String charCode;\n\n        if(mCase == CASE.upper) {\n            charCode = mSymbol.toString().toUpperCase();\n\n        } else {\n            charCode = mSymbol.toString().toLowerCase();\n        }\n\n        int charCodeInt = (int)charCode.charAt(0);\n\n\n        attr = document.createAttribute(\"hex\");\n\n        attr.setValue(\"00\" + Integer.toHexString(charCodeInt));\n        unicode.setAttributeNode(attr);\n\n        root.appendChild(unicode);\n\n        // create outline\n        Element outline = document.createElement(\"outline\");\n\n        // for contour in outline\n        for (List<Coordinate> contour : mOutline) {\n            //Create contour element\n            Element contourElement = document.createElement(\"contour\");\n\n            int i = 0;\n\n            //For each point in the contour\n            for (Coordinate point : contour) {\n                //Create points\n                Element pointElement = document.createElement(\"point\");\n\n                //Set x coordinate\n                attr = document.createAttribute(\"x\");\n                attr.setValue(Double.toString(\n                        point.x\n                ));\n                pointElement.setAttributeNode(attr);\n\n                //Set y coordinate\n                attr = document.createAttribute(\"y\");\n                attr.setValue(Double.toString(\n                        350 - point.y\n                ));\n                pointElement.setAttributeNode(attr);\n\n                //Set type\n                attr = document.createAttribute(\"type\");\n\n//                if (i == 0) {\n//                    attr.setValue(\"move\");\n//\n//                } else {\n//                    attr.setValue(\"line\");\n//                }\n\n                attr.setValue(\"line\");\n\n\n                pointElement.setAttributeNode(attr);\n\n                // append point to contour\n                contourElement.appendChild(pointElement);\n\n                i++;\n            }\n\n            // append contour to outline\n            outline.appendChild(contourElement);\n        }\n\n        // appent outline to root\n        root.appendChild(outline);\n\n        // append root to document\n        document.appendChild(root);\n\n        // create transformer\n        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n\n        //Set to indent for more legible output\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n        // create output stream to file\n        Result output = new StreamResult(new File(fileName));\n\n        // create input source\n        Source input = new DOMSource(document);\n\n        // transform document to file\n        transformer.transform(input, output);\n    }\n\n    public static Character load(String fileName, SYMBOL symbol, CASE charCase) throws ParserConfigurationException, IOException, SAXException {\n        Character character = new Character(symbol, charCase);\n\n        // grab file stream\n        File inputFile = new File(fileName);\n\n        // check if file exists and is valid\n        if(inputFile.exists() && !inputFile.isDirectory())\n        {\n            // create document builder\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            Element contourElement;\n            NodeList contours;\n\n            //Go through the points\n            contours = doc.getElementsByTagName(\"contour\");\n\n            //For each contour\n            for (int i = 0; i < contours.getLength(); i++)\n            {\n\n                //Get the contour\n                character.openContour(); //Make new contour\n                Node contourNode = contours.item(i);\n\n                if (contourNode.getNodeType() == Node.ELEMENT_NODE)\n                {\n\n                    contourElement = (Element) contourNode;\n\n                    //Get list of point elements from the contour\n                    NodeList points = contourElement.getElementsByTagName(\"point\");\n\n                    for (int pointIndex = 0; pointIndex < points.getLength(); pointIndex++)\n                    {\n                        Node pointNode = points.item(pointIndex);\n\n                        if (pointNode.getNodeType() == pointNode.ELEMENT_NODE) {\n                            Element pointElement = (Element) pointNode;\n\n                            // get point coordinates\n                            double x = Double.parseDouble(pointElement.getAttribute(\"x\"));\n                            double y = Double.parseDouble(pointElement.getAttribute(\"y\"));\n\n                            // add point to character\n                            character.addPoint(x, 350 - y);\n                        }\n                    }\n\n                    // End of contour\n                    character.closeContour();\n                }\n            }\n        }\n\n        // use openContour(), addPoint(), and closeContour()\n        // to update the character with the loaded points\n\n        return character;\n    }\n\n    public void openContour(double x, double y) {\n        mCurrentContour = new ArrayList<Coordinate>();\n        this.addPoint(x, y);\n    }\n\n    private void openContour()\n    {\n        mCurrentContour = new ArrayList<Coordinate>();\n    }\n\n    public void addPoint(double x, double y) {\n        mCurrentContour.add(new Coordinate(x, y));\n    }\n\n    public void closeContour(double x, double y) {\n        addPoint(x, y);\n        mOutline.add(mCurrentContour);\n    }\n\n    private void closeContour()\n    {\n        mOutline.add(mCurrentContour);\n    }\n\n    public List<List<Coordinate>> getOutline() {\n        return mOutline;\n    }\n\n    private SYMBOL mSymbol;\n    private CASE mCase;\n    private List<Coordinate> mCurrentContour;\n    private List<List<Coordinate>> mOutline;\n}", "class_id": 0, "repo": "codeWonderland/FontGenerator", "file": "src/model/Character.java", "last_update_at": "2018-12-02T13:03:07+00:00", "question_id": "335c1e6d0f4454939550f571c6304e34f1650ef9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Character {\n    public enum CASE {\n        lower,\n        upper\n    }\n    public enum SYMBOL {\n        a, b, c, d, e,\n        f, g, h, i, j,\n        k, l, m, n, o,\n        p, q, r, s, t,\n        u, v, w, x, y, z\n    }\n    public class Coordinate {\n        public final double x;\n        public final double y;\n        Coordinate(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    public Character() {\n    }\n    public Character(SYMBOL symbol, CASE charCase) {\n        this.mSymbol = symbol;\n        this.mCase = charCase;\n        this.mOutline = new ArrayList<List<Coordinate>>();\n    }\n    public void clear() {\n        this.mOutline = new ArrayList<List<Coordinate>>();\n        this.mCurrentContour = null;\n    }\n    public void save(String fileName) throws ParserConfigurationException, TransformerException {\n        //Create DOM document creator\n        DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder  documentBuilder =  documentFactory.newDocumentBuilder();\n        Document document = documentBuilder.newDocument();\n        //Create root element\n        Element root =  document.createElement(\"glyph\");\n        //create root attribute\n        Attr attr = document.createAttribute(\"name\");\n        attr.setValue(mSymbol.toString());\n        root.setAttributeNode(attr);\n        attr = document.createAttribute(\"format\");\n        attr.setValue(\"2\");\n        root.setAttributeNode(attr);\n        //create advance element\n        Element advance = document.createElement(\"advance\");\n        // set width attribute\n        attr = document.createAttribute(\"width\");\n        attr.setValue(\"268\");\n        advance.setAttributeNode(attr);\n        // set height attribute\n        attr = document.createAttribute(\"height\");\n        attr.setValue(\"268\");\n        advance.setAttributeNode(attr);\n        // append advance to root\n        root.appendChild(advance);\n        //create unicode element\n        Element unicode = document.createElement(\"unicode\");\n        // Create hexcode element\n        String charCode;\n        if(mCase == CASE.upper) {\n            charCode = mSymbol.toString().toUpperCase();\n        } else {\n            charCode = mSymbol.toString().toLowerCase();\n        }\n        int charCodeInt = (int)charCode.charAt(0);\n        attr = document.createAttribute(\"hex\");\n        attr.setValue(\"00\" + Integer.toHexString(charCodeInt));\n        unicode.setAttributeNode(attr);\n        root.appendChild(unicode);\n        // create outline\n        Element outline = document.createElement(\"outline\");\n        // for contour in outline\n        for (List<Coordinate> contour : mOutline) {\n            //Create contour element\n            Element contourElement = document.createElement(\"contour\");\n            int i = 0;\n            //For each point in the contour\n            for (Coordinate point : contour) {\n                //Create points\n                Element pointElement = document.createElement(\"point\");\n                //Set x coordinate\n                attr = document.createAttribute(\"x\");\n                attr.setValue(Double.toString(\n                        point.x\n                ));\n                pointElement.setAttributeNode(attr);\n                //Set y coordinate\n                attr = document.createAttribute(\"y\");\n                attr.setValue(Double.toString(\n                        350 - point.y\n                ));\n                pointElement.setAttributeNode(attr);\n                //Set type\n                attr = document.createAttribute(\"type\");\n//                if (i == 0) {\n//                    attr.setValue(\"move\");\n//\n//                } else {\n//                    attr.setValue(\"line\");\n//                }\n                attr.setValue(\"line\");\n                pointElement.setAttributeNode(attr);\n                // append point to contour\n                contourElement.appendChild(pointElement);\n                i++;\n            }\n            // append contour to outline\n            outline.appendChild(contourElement);\n        }\n        // appent outline to root\n        root.appendChild(outline);\n        // append root to document\n        document.appendChild(root);\n        // create transformer\n        Transformer transformer = TransformerFactory.newInstance().newTransformer();\n        //Set to indent for more legible output\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        // create output stream to file\n        Result output = new StreamResult(new File(fileName));\n        // create input source\n        Source input = new DOMSource(document);\n        // transform document to file\n        transformer.transform(input, output);\n    }\n    public static Character load(String fileName, SYMBOL symbol, CASE charCase) throws ParserConfigurationException, IOException, SAXException {\n        Character character = new Character(symbol, charCase);\n        // grab file stream\n        File inputFile = new File(fileName);\n        // check if file exists and is valid\n        if(inputFile.exists() && !inputFile.isDirectory())\n        {\n            // create document builder\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n            Element contourElement;\n            NodeList contours;\n            //Go through the points\n            contours = doc.getElementsByTagName(\"contour\");\n            //For each contour\n            for (int i = 0; i < contours.getLength(); i++)\n            {\n                //Get the contour\n                character.openContour(); //Make new contour\n                Node contourNode = contours.item(i);\n                if (contourNode.getNodeType() == Node.ELEMENT_NODE)\n                {\n                    contourElement = (Element) contourNode;\n                    //Get list of point elements from the contour\n                    NodeList points = contourElement.getElementsByTagName(\"point\");\n                    for (int pointIndex = 0; pointIndex < points.getLength(); pointIndex++)\n                    {\n                        Node pointNode = points.item(pointIndex);\n                        if (pointNode.getNodeType() == pointNode.ELEMENT_NODE) {\n                            Element pointElement = (Element) pointNode;\n                            // get point coordinates\n                            double x = Double.parseDouble(pointElement.getAttribute(\"x\"));\n                            double y = Double.parseDouble(pointElement.getAttribute(\"y\"));\n                            // add point to character\n                            character.addPoint(x, 350 - y);\n                        }\n                    }\n                    // End of contour\n                    character.closeContour();\n                }\n            }\n        }\n        // use openContour(), addPoint(), and closeContour()\n        // to update the character with the loaded points\n        return character;\n    }\n    public void openContour(double x, double y) {\n        mCurrentContour = new ArrayList<Coordinate>();\n        this.addPoint(x, y);\n    }\n    private void openContour()\n    {\n        mCurrentContour = new ArrayList<Coordinate>();\n    }\n    public void addPoint(double x, double y) {\n        mCurrentContour.add(new Coordinate(x, y));\n    }\n    public void closeContour(double x, double y) {\n        addPoint(x, y);\n        mOutline.add(mCurrentContour);\n    }\n    private void closeContour()\n    {\n        mOutline.add(mCurrentContour);\n    }\n    public List<List<Coordinate>> getOutline() {\n        return mOutline;\n    }\n    private SYMBOL mSymbol;\n    private CASE mCase;\n    private List<Coordinate> mCurrentContour;\n    private List<List<Coordinate>> mOutline;\n"]], "pred": {"ppl": 1.6763633489608765, "ppl_lower": 1.7897887229919434, "ppl/lowercase_ppl": -1.1267274761234891, "ppl/zlib": 0.00026575451331579215, "Min_5.0% Prob": 5.551070442386702, "Min_10.0% Prob": 3.9643503462567047, "Min_20.0% Prob": 2.4083461029564632, "Min_30.0% Prob": 1.686795416708086, "Min_40.0% Prob": 1.28241925723031, "Min_50.0% Prob": 1.0315685046931506, "Min_60.0% Prob": 0.8613758404225682}}
{"hexsha": "e39463d3d0481588ce4b9fabc095665bf256d3e5", "ext": "java", "lang": "Java", "content": "public class MediaRetrieverService extends Service {\n\n    private static final String TAG = \"MediaRetrieverService\";\n\n    private static final int TIMEOUT_MS = 6000;\n    private final Handler mHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            Runtime.getRuntime().exit(-1);\n        }\n    };\n\n    private final IBinder mBinder = new IMediaRetrieverService.Stub() {\n        public MediaMetadata getMetadata(String path) {\n            return MediaRetrieverService.this.getMetadata(path);\n        }\n    };\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mBinder;\n    }\n\n    public MediaMetadata getMetadata(String path) {\n        mHandler.sendEmptyMessageDelayed(0, TIMEOUT_MS);\n        IMediaMetadataRetriever retriever = MediaFactory.createMetadataRetriever(this);\n        try {\n            retriever.setDataSource(path);\n            return retriever.getMediaMetadata();\n        } catch (Throwable t) {\n            // something failed, return null instead\n            return null;\n        } finally {\n            mHandler.removeMessages(0);\n            try {\n                retriever.release();\n            } catch (Throwable t) {\n                // Ignore failures while cleaning up.\n            }\n        }\n    }\n\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        super.onStartCommand(intent, flags, startId);\n        return START_NOT_STICKY;\n    }\n\n}", "class_id": 0, "repo": "s-stark/aos-MediaLib", "file": "src/com/archos/mediaprovider/MediaRetrieverService.java", "last_update_at": "2018-09-10T03:15:07+00:00", "question_id": "e39463d3d0481588ce4b9fabc095665bf256d3e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MediaRetrieverService extends Service {\n    private static final String TAG = \"MediaRetrieverService\";\n    private static final int TIMEOUT_MS = 6000;\n    private final Handler mHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            Runtime.getRuntime().exit(-1);\n        }\n    };\n    private final IBinder mBinder = new IMediaRetrieverService.Stub() {\n        public MediaMetadata getMetadata(String path) {\n            return MediaRetrieverService.this.getMetadata(path);\n        }\n    };\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mBinder;\n    }\n    public MediaMetadata getMetadata(String path) {\n        mHandler.sendEmptyMessageDelayed(0, TIMEOUT_MS);\n        IMediaMetadataRetriever retriever = MediaFactory.createMetadataRetriever(this);\n        try {\n            retriever.setDataSource(path);\n            return retriever.getMediaMetadata();\n        } catch (Throwable t) {\n            // something failed, return null instead\n            return null;\n        } finally {\n            mHandler.removeMessages(0);\n            try {\n                retriever.release();\n            } catch (Throwable t) {\n                // Ignore failures while cleaning up.\n            }\n        }\n    }\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        super.onStartCommand(intent, flags, startId);\n        return START_NOT_STICKY;\n    }\n"]], "pred": {"ppl": 1.7060855627059937, "ppl_lower": 2.257355213165283, "ppl/lowercase_ppl": -1.524132210740137, "ppl/zlib": 0.0009856118114414455, "Min_5.0% Prob": 5.284356757214195, "Min_10.0% Prob": 3.844060769206599, "Min_20.0% Prob": 2.4435627112140903, "Min_30.0% Prob": 1.7437221660953144, "Min_40.0% Prob": 1.3304291233901056, "Min_50.0% Prob": 1.0681833275353785, "Min_60.0% Prob": 0.8910548018247625}}
{"hexsha": "f225f0513742ccfa077692d83b378c82e9f48bbd", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class CCROneHourTest {\n    private static final int timeLimit = 10000;\n\n    private static Engine engine = new Engine();\n\n    @Parameterized.Parameters(name = \"{index} Test: {1}\")\n    public static Collection<Object[]> data() {\n        List<Object[]> answers = new ArrayList<>();\n\n        for (int i = 0; i < splitUpBKs.length; i++) {\n            String pos = splitUpBKs[i];\n            Object[] objectAndName = new Object[2];\n            ExtendedPositionDescriptionParser.EPDObject EPDObject = ExtendedPositionDescriptionParser.parseEDPPosition(pos);\n            objectAndName[0] = EPDObject;\n            objectAndName[1] = EPDObject.getId();\n            answers.add(objectAndName);\n        }\n        return answers;\n    }\n\n    private static ExtendedPositionDescriptionParser.EPDObject EPDObject;\n\n    public CCROneHourTest(Object edp, Object name) {\n        EPDObject = (ExtendedPositionDescriptionParser.EPDObject) edp;\n    }\n\n    @Test\n    public void test() {\n        Engine.resetFull();\n        System.out.println(EPDObject.getFullString());\n        int[] winningMoves = EPDObject.getBestMoves();\n        int[] losingMoves = EPDObject.getAvoidMoves();\n        EngineSpecifications.PRINT_PV = false;\n                \n        SearchSpecs.basicTimeSearch(timeLimit);\n        final int move = engine.simpleSearch(EPDObject.getBoard());\n\n        Assert.assertTrue(contains(winningMoves, move) && !contains(losingMoves, move));\n    }\n\n    private static final String bkTests = \"\" +\n            \"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/2N1P3/PP3PPP/R1BQKBNR w KQkq - 0 1 id \\\"CCR01\\\"; bm Qb3;\\n\" +\n            \"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/1QN1P3/PP3PPP/R1B1KBNR b KQkq - 1 1 id \\\"CCR02\\\";bm Bc8;\\n\" +\n            \"r1bqk2r/ppp2ppp/2n5/4P3/2Bp2n1/5N1P/PP1N1PP1/R2Q1RK1 b kq - 1 10 id \\\"CCR03\\\"; bm Nh6; am Ne5;\\n\" +\n            \"r1bqrnk1/pp2bp1p/2p2np1/3p2B1/3P4/2NBPN2/PPQ2PPP/1R3RK1 w - - 1 12 id \\\"CCR04\\\"; bm b4;\\n\" +\n            \"rnbqkb1r/ppp1pppp/5n2/8/3PP3/2N5/PP3PPP/R1BQKBNR b KQkq - 3 5 id \\\"CCR05\\\"; bm e5; \\n\" +\n            \"rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/P1N5/1PQ1PPPP/R1B1KBNR b KQ - 1 5 id \\\"CCR06\\\"; bm Bcx3+;\\n\" +\n            \"r4rk1/3nppbp/bq1p1np1/2pP4/8/2N2NPP/PP2PPB1/R1BQR1K1 b - - 1 12 id \\\"CCR07\\\"; bm Rfb8;\\n\" +\n            \"rn1qkb1r/pb1p1ppp/1p2pn2/2p5/2PP4/5NP1/PP2PPBP/RNBQK2R w KQkq c6 1 6 id \\\"CCR08\\\"; bm d5;\\n\" +\n            \"r1bq1rk1/1pp2pbp/p1np1np1/3Pp3/2P1P3/2N1BP2/PP4PP/R1NQKB1R b KQ - 1 9 id \\\"CCR09\\\"; bm Nd4;\\n\" +\n            \"rnbqr1k1/1p3pbp/p2p1np1/2pP4/4P3/2N5/PP1NBPPP/R1BQ1RK1 w - - 1 11 id \\\"CCR10\\\"; bm a4;\\n\" +\n            \"rnbqkb1r/pppp1ppp/5n2/4p3/4PP2/2N5/PPPP2PP/R1BQKBNR b KQkq f3 1 3 id \\\"CCR11\\\"; bm d5;\\n\" +\n            \"r1bqk1nr/pppnbppp/3p4/8/2BNP3/8/PPP2PPP/RNBQK2R w KQkq - 2 6 id \\\"CCR12\\\"; bm Bxf7+;\\n\" +\n            \"rnbq1b1r/ppp2kpp/3p1n2/8/3PP3/8/PPP2PPP/RNBQKB1R b KQ d3 1 5 id \\\"CCR13\\\"; am Ne4; \\n\" +\n            \"rnbqkb1r/pppp1ppp/3n4/8/2BQ4/5N2/PPP2PPP/RNB2RK1 b kq - 1 6 id \\\"CCR14\\\"; am Nxc4;\\n\" +\n            \"r2q1rk1/2p1bppp/p2p1n2/1p2P3/4P1b1/1nP1BN2/PP3PPP/RN1QR1K1 w - - 1 12 id \\\"CCR15\\\"; bm exf6;\\n\" +\n            \"r1bqkb1r/2pp1ppp/p1n5/1p2p3/3Pn3/1B3N2/PPP2PPP/RNBQ1RK1 b kq - 2 7 id \\\"CCR16\\\"; bm d5;\\n\" +\n            \"r2qkbnr/2p2pp1/p1pp4/4p2p/4P1b1/5N1P/PPPP1PP1/RNBQ1RK1 w kq - 1 8 id \\\"CCR17\\\"; am hxg4;\\n\" +\n            \"r1bqkb1r/pp3ppp/2np1n2/4p1B1/3NP3/2N5/PPP2PPP/R2QKB1R w KQkq e6 1 7 id \\\"CCR18\\\"; bm Bxf6+;\\n\" +\n            \"rn1qk2r/1b2bppp/p2ppn2/1p6/3NP3/1BN5/PPP2PPP/R1BQR1K1 w kq - 5 10 id \\\"CCR19\\\"; am Bxe6;\\n\" +\n            \"r1b1kb1r/1pqpnppp/p1n1p3/8/3NP3/2N1B3/PPP1BPPP/R2QK2R w KQkq - 3 8 id \\\"CCR20\\\"; am Ndb5;\\n\" +\n            \"r1bqnr2/pp1ppkbp/4N1p1/n3P3/8/2N1B3/PPP2PPP/R2QK2R b KQ - 2 11 id \\\"CCR21\\\"; am Kxe6;\\n\" +\n            \"r3kb1r/pp1n1ppp/1q2p3/n2p4/3P1Bb1/2PB1N2/PPQ2PPP/RN2K2R w KQkq - 3 11 id \\\"CCR22\\\"; bm a4;\\n\" +\n            \"r1bq1rk1/pppnnppp/4p3/3pP3/1b1P4/2NB3N/PPP2PPP/R1BQK2R w KQ - 3 7 id \\\"CCR23\\\"; bm Bxh7+;\\n\" +\n            \"r2qkbnr/ppp1pp1p/3p2p1/3Pn3/4P1b1/2N2N2/PPP2PPP/R1BQKB1R w KQkq - 2 6 id \\\"CCR24\\\"; bm Nxe5;\\n\" +\n            \"rn2kb1r/pp2pppp/1qP2n2/8/6b1/1Q6/PP1PPPBP/RNB1K1NR b KQkq - 1 6 id \\\"CCR25\\\"; am Qxb3;\" +\n            \"\";\n\n    private static final String[] splitUpBKs = bkTests.split(\"\\n\");\n}", "class_id": 0, "repo": "louism33/chessPlusPlus", "file": "src/main/java/challenges/CCROneHourTest.java", "last_update_at": "2018-09-23T20:36:06+00:00", "question_id": "f225f0513742ccfa077692d83b378c82e9f48bbd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class CCROneHourTest {\n    private static final int timeLimit = 10000;\n    private static Engine engine = new Engine();\n    @Parameterized.Parameters(name = \"{index} Test: {1}\")\n    public static Collection<Object[]> data() {\n        List<Object[]> answers = new ArrayList<>();\n        for (int i = 0; i < splitUpBKs.length; i++) {\n            String pos = splitUpBKs[i];\n            Object[] objectAndName = new Object[2];\n            ExtendedPositionDescriptionParser.EPDObject EPDObject = ExtendedPositionDescriptionParser.parseEDPPosition(pos);\n            objectAndName[0] = EPDObject;\n            objectAndName[1] = EPDObject.getId();\n            answers.add(objectAndName);\n        }\n        return answers;\n    }\n    private static ExtendedPositionDescriptionParser.EPDObject EPDObject;\n    public CCROneHourTest(Object edp, Object name) {\n        EPDObject = (ExtendedPositionDescriptionParser.EPDObject) edp;\n    }\n    @Test\n    public void test() {\n        Engine.resetFull();\n        System.out.println(EPDObject.getFullString());\n        int[] winningMoves = EPDObject.getBestMoves();\n        int[] losingMoves = EPDObject.getAvoidMoves();\n        EngineSpecifications.PRINT_PV = false;\n        SearchSpecs.basicTimeSearch(timeLimit);\n        final int move = engine.simpleSearch(EPDObject.getBoard());\n        Assert.assertTrue(contains(winningMoves, move) && !contains(losingMoves, move));\n    }\n    private static final String bkTests = \"\" +\n            \"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/2N1P3/PP3PPP/R1BQKBNR w KQkq - 0 1 id \\\"CCR01\\\"; bm Qb3;\\n\" +\n            \"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/1QN1P3/PP3PPP/R1B1KBNR b KQkq - 1 1 id \\\"CCR02\\\";bm Bc8;\\n\" +\n            \"r1bqk2r/ppp2ppp/2n5/4P3/2Bp2n1/5N1P/PP1N1PP1/R2Q1RK1 b kq - 1 10 id \\\"CCR03\\\"; bm Nh6; am Ne5;\\n\" +\n            \"r1bqrnk1/pp2bp1p/2p2np1/3p2B1/3P4/2NBPN2/PPQ2PPP/1R3RK1 w - - 1 12 id \\\"CCR04\\\"; bm b4;\\n\" +\n            \"rnbqkb1r/ppp1pppp/5n2/8/3PP3/2N5/PP3PPP/R1BQKBNR b KQkq - 3 5 id \\\"CCR05\\\"; bm e5; \\n\" +\n            \"rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/P1N5/1PQ1PPPP/R1B1KBNR b KQ - 1 5 id \\\"CCR06\\\"; bm Bcx3+;\\n\" +\n            \"r4rk1/3nppbp/bq1p1np1/2pP4/8/2N2NPP/PP2PPB1/R1BQR1K1 b - - 1 12 id \\\"CCR07\\\"; bm Rfb8;\\n\" +\n            \"rn1qkb1r/pb1p1ppp/1p2pn2/2p5/2PP4/5NP1/PP2PPBP/RNBQK2R w KQkq c6 1 6 id \\\"CCR08\\\"; bm d5;\\n\" +\n            \"r1bq1rk1/1pp2pbp/p1np1np1/3Pp3/2P1P3/2N1BP2/PP4PP/R1NQKB1R b KQ - 1 9 id \\\"CCR09\\\"; bm Nd4;\\n\" +\n            \"rnbqr1k1/1p3pbp/p2p1np1/2pP4/4P3/2N5/PP1NBPPP/R1BQ1RK1 w - - 1 11 id \\\"CCR10\\\"; bm a4;\\n\" +\n            \"rnbqkb1r/pppp1ppp/5n2/4p3/4PP2/2N5/PPPP2PP/R1BQKBNR b KQkq f3 1 3 id \\\"CCR11\\\"; bm d5;\\n\" +\n            \"r1bqk1nr/pppnbppp/3p4/8/2BNP3/8/PPP2PPP/RNBQK2R w KQkq - 2 6 id \\\"CCR12\\\"; bm Bxf7+;\\n\" +\n            \"rnbq1b1r/ppp2kpp/3p1n2/8/3PP3/8/PPP2PPP/RNBQKB1R b KQ d3 1 5 id \\\"CCR13\\\"; am Ne4; \\n\" +\n            \"rnbqkb1r/pppp1ppp/3n4/8/2BQ4/5N2/PPP2PPP/RNB2RK1 b kq - 1 6 id \\\"CCR14\\\"; am Nxc4;\\n\" +\n            \"r2q1rk1/2p1bppp/p2p1n2/1p2P3/4P1b1/1nP1BN2/PP3PPP/RN1QR1K1 w - - 1 12 id \\\"CCR15\\\"; bm exf6;\\n\" +\n            \"r1bqkb1r/2pp1ppp/p1n5/1p2p3/3Pn3/1B3N2/PPP2PPP/RNBQ1RK1 b kq - 2 7 id \\\"CCR16\\\"; bm d5;\\n\" +\n            \"r2qkbnr/2p2pp1/p1pp4/4p2p/4P1b1/5N1P/PPPP1PP1/RNBQ1RK1 w kq - 1 8 id \\\"CCR17\\\"; am hxg4;\\n\" +\n            \"r1bqkb1r/pp3ppp/2np1n2/4p1B1/3NP3/2N5/PPP2PPP/R2QKB1R w KQkq e6 1 7 id \\\"CCR18\\\"; bm Bxf6+;\\n\" +\n            \"rn1qk2r/1b2bppp/p2ppn2/1p6/3NP3/1BN5/PPP2PPP/R1BQR1K1 w kq - 5 10 id \\\"CCR19\\\"; am Bxe6;\\n\" +\n            \"r1b1kb1r/1pqpnppp/p1n1p3/8/3NP3/2N1B3/PPP1BPPP/R2QK2R w KQkq - 3 8 id \\\"CCR20\\\"; am Ndb5;\\n\" +\n            \"r1bqnr2/pp1ppkbp/4N1p1/n3P3/8/2N1B3/PPP2PPP/R2QK2R b KQ - 2 11 id \\\"CCR21\\\"; am Kxe6;\\n\" +\n            \"r3kb1r/pp1n1ppp/1q2p3/n2p4/3P1Bb1/2PB1N2/PPQ2PPP/RN2K2R w KQkq - 3 11 id \\\"CCR22\\\"; bm a4;\\n\" +\n            \"r1bq1rk1/pppnnppp/4p3/3pP3/1b1P4/2NB3N/PPP2PPP/R1BQK2R w KQ - 3 7 id \\\"CCR23\\\"; bm Bxh7+;\\n\" +\n            \"r2qkbnr/ppp1pp1p/3p2p1/3Pn3/4P1b1/2N2N2/PPP2PPP/R1BQKB1R w KQkq - 2 6 id \\\"CCR24\\\"; bm Nxe5;\\n\" +\n            \"rn2kb1r/pp2pppp/1qP2n2/8/6b1/1Q6/PP1PPPBP/RNB1K1NR b KQkq - 1 6 id \\\"CCR25\\\"; am Qxb3;\" +\n            \"\";\n    private static final String[] splitUpBKs = bkTests.split(\"\\n\");\n"]], "pred": {"ppl": 2.828259229660034, "ppl_lower": 3.7928082942962646, "ppl/lowercase_ppl": -1.2822508440328235, "ppl/zlib": 0.0006857924862803933, "Min_5.0% Prob": 7.7488829575332945, "Min_10.0% Prob": 5.957856944963043, "Min_20.0% Prob": 4.133712340803707, "Min_30.0% Prob": 3.160461504280178, "Min_40.0% Prob": 2.5172480824961347, "Min_50.0% Prob": 2.0596723499363416, "Min_60.0% Prob": 1.7300390475421998}}
{"hexsha": "849440a30c7920d98667b01652e0d6d1d7ae9238", "ext": "java", "lang": "Java", "content": "public abstract class ISO8601TypeAdapter extends TypeAdapter<Date>{\n\n    private static final DateTimeFormatter iso8601Format = ISODateTimeFormat.dateTime();\n\n    public static final TypeAdapter<Date> DATE_ADAPTER = new ISO8601TypeAdapter() {\n        @Override\n        public void write(JsonWriter out, Date value) throws IOException {\n            if (value != null) {\n                out.value(iso8601Format.print(value.getTime()));\n            } else {\n                out.nullValue();\n            }\n        }\n\n        @Override\n        public Date read(JsonReader in) throws IOException {\n            JsonToken peek = in.peek();\n            if (peek == JsonToken.NULL) {\n                in.nextNull();\n                return null;\n            }\n            return iso8601Format.parseDateTime(in.nextString()).toDate();\n        }\n    };\n}", "class_id": 0, "repo": "sensorberg/android-sdk", "file": "android-sdk/src/main/java/com/sensorberg/sdk/model/ISO8601TypeAdapter.java", "last_update_at": "2018-03-05T13:11:47+00:00", "question_id": "849440a30c7920d98667b01652e0d6d1d7ae9238", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class ISO8601TypeAdapter extends TypeAdapter<Date>{\n    private static final DateTimeFormatter iso8601Format = ISODateTimeFormat.dateTime();\n    public static final TypeAdapter<Date> DATE_ADAPTER = new ISO8601TypeAdapter() {\n        @Override\n        public void write(JsonWriter out, Date value) throws IOException {\n            if (value != null) {\n                out.value(iso8601Format.print(value.getTime()));\n            } else {\n                out.nullValue();\n            }\n        }\n        @Override\n        public Date read(JsonReader in) throws IOException {\n            JsonToken peek = in.peek();\n            if (peek == JsonToken.NULL) {\n                in.nextNull();\n                return null;\n            }\n            return iso8601Format.parseDateTime(in.nextString()).toDate();\n        }\n    };\n"]], "pred": {"ppl": 1.4757263660430908, "ppl_lower": 2.0620341300964355, "ppl/lowercase_ppl": -1.8596745266727333, "ppl/zlib": 0.0010720394493993041, "Min_5.0% Prob": 4.893378821286288, "Min_10.0% Prob": 3.260826262560758, "Min_20.0% Prob": 1.8825270421802998, "Min_30.0% Prob": 1.290563045126019, "Min_40.0% Prob": 0.9740046380003068, "Min_50.0% Prob": 0.7806987104302442, "Min_60.0% Prob": 0.651127514850955}}
{"hexsha": "48e4b08bad4647f81d597086647d7a1fbaf3c222", "ext": "java", "lang": "Java", "content": "public class SparseVector<T> {\n//    private long length;\n//    private T defaultValue;\n\n//    private Map<Long, T> valuesByNdx;\n\n    private List<Data<T>> list;\n\n    public SparseVector() {\n//        this.length = length;\n//        this.defaultValue = defaultValue;\n//        this.valuesByNdx = new HashMap<>();\n        this.list = new LinkedList<>();\n    }\n\n//    public long getLength() {\n//        return length;\n//    }\n\n//    public T getDefaultValue() {\n//        return defaultValue;\n//    }\n\n    public void put(long ndx, T value) {\n//        if (value.equals(defaultValue)) {\n//            if (valuesByNdx.containsKey(ndx)) {\n//                valuesByNdx.remove(ndx);\n//            }\n//        } else {\n//            valuesByNdx.put(ndx, value);\n//        }\n        list.add(new Data<T>(ndx, value));\n    }\n\n//    public T get(long ndx) {\n//        return valuesByNdx.containsKey(ndx) ? valuesByNdx.get(ndx) : defaultValue;\n//    }\n//\n//    public boolean has(long ndx) {\n//        return valuesByNdx.containsKey(ndx);\n//    }\n\n    public Iterator<Data<T>> getIterator() {\n        return list.iterator();\n    }\n\n    public class Data<T> {\n        private long ndx;\n        private T value;\n\n        private Data(long ndx, T value) {\n            this.ndx = ndx;\n            this.value = value;\n        }\n\n        public long getNdx() {\n            return ndx;\n        }\n\n        public T getValue() {\n            return value;\n        }\n    }\n}", "class_id": 0, "repo": "othebe/information-retrieval", "file": "src/main/java/core/vectorizer/SparseVector.java", "last_update_at": "2018-03-08T23:19:04+00:00", "question_id": "48e4b08bad4647f81d597086647d7a1fbaf3c222", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SparseVector<T> {\n//    private long length;\n//    private T defaultValue;\n//    private Map<Long, T> valuesByNdx;\n    private List<Data<T>> list;\n    public SparseVector() {\n//        this.length = length;\n//        this.defaultValue = defaultValue;\n//        this.valuesByNdx = new HashMap<>();\n        this.list = new LinkedList<>();\n    }\n//    public long getLength() {\n//        return length;\n//    }\n//    public T getDefaultValue() {\n//        return defaultValue;\n//    }\n    public void put(long ndx, T value) {\n//        if (value.equals(defaultValue)) {\n//            if (valuesByNdx.containsKey(ndx)) {\n//                valuesByNdx.remove(ndx);\n//            }\n//        } else {\n//            valuesByNdx.put(ndx, value);\n//        }\n        list.add(new Data<T>(ndx, value));\n    }\n//    public T get(long ndx) {\n//        return valuesByNdx.containsKey(ndx) ? valuesByNdx.get(ndx) : defaultValue;\n//    }\n//\n//    public boolean has(long ndx) {\n//        return valuesByNdx.containsKey(ndx);\n//    }\n    public Iterator<Data<T>> getIterator() {\n        return list.iterator();\n    }\n    public class Data<T> {\n        private long ndx;\n        private T value;\n        private Data(long ndx, T value) {\n            this.ndx = ndx;\n            this.value = value;\n        }\n        public long getNdx() {\n            return ndx;\n        }\n        public T getValue() {\n            return value;\n        }\n    }\n"]], "pred": {"ppl": 1.4123653173446655, "ppl_lower": 1.5211161375045776, "ppl/lowercase_ppl": -1.214844711591881, "ppl/zlib": 0.000772406776151805, "Min_5.0% Prob": 4.0115495661030645, "Min_10.0% Prob": 2.894731607126153, "Min_20.0% Prob": 1.6579929663929889, "Min_30.0% Prob": 1.141964857258814, "Min_40.0% Prob": 0.8611496060846313, "Min_50.0% Prob": 0.68938843715864, "Min_60.0% Prob": 0.5763286624402543}}
{"hexsha": "c5b885aad96e3244e1712cb768cb78d6e20c3d2c", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"serial\")\r\npublic class AmountDAO\r\n\textends SetNameDescriptionDAO\r\n\timplements RenderableValue<String>\r\n{\r\n\r\n\t/**\r\n\t * Default currency set to U.S. dollar (USD).\r\n\t */\r\n\tpublic static final Currency DEFAULT_CURRENCY = Currency.USD;\r\n\t\r\n\tpublic enum Params\r\n\t\timplements GetNVConfig\r\n\t{\r\n\t\tCURRENCY(NVConfigManager.createNVConfig(\"currency\", \"Currency\", \"Currency\", true, true, Currency.class)),\r\n\t\tAMOUNT(NVConfigManager.createNVConfig(\"amount\", \"Amount\", \"Amount\", true, true, BigDecimal.class)),\r\n\t\t\r\n\t\t;\r\n\t\t\r\n\t\tprivate final NVConfig cType;\r\n\t\t\r\n\t\tParams(NVConfig c)\r\n\t\t{\r\n\t\t\tcType = c;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic NVConfig getNVConfig()\r\n\t\t{\r\n\t\t\treturn cType;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic static final NVConfigEntity NVC_AMOUNT_DAO = new NVConfigEntityLocal(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"amount_dao\", \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"AmountDAO\", \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAmountDAO.class, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSharedUtil.extractNVConfigs(Params.values()), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSetNameDescriptionDAO.NVC_NAME_DESCRIPTION_DAO\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t/**\r\n\t * The default constructor.\r\n\t */\r\n\tpublic AmountDAO()\r\n\t{\r\n\t\tsuper(NVC_AMOUNT_DAO);\r\n\t\tsetCurrency(DEFAULT_CURRENCY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO based on given amount (BigDecimal) and currency (Currency).\r\n\t * @param amount\r\n\t * @param currency\r\n\t */\r\n\tpublic AmountDAO(BigDecimal amount, Currency currency)\r\n\t{\r\n\t\tthis();\r\n\t\tsetAmount(amount);\r\n\t\tif (currency != null) {\r\n            setCurrency(currency);\r\n        }\r\n\t}\r\n\r\n    public AmountDAO(BigDecimal amount) {\r\n        this(amount, null);\r\n    }\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (String).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(String amount)\r\n\t{\r\n\t\tthis(new BigDecimal(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (long).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(long amount)\r\n\t{\r\n\t\tthis(new BigDecimal(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (float).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(float amount)\r\n\t{\r\n\t\tthis(BigDecimal.valueOf(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO based on given currency (Currency).\r\n\t * @param currency\r\n\t */\r\n\tpublic AmountDAO(Currency currency)\r\n\t{\r\n\t\tthis(null, currency);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the currency.\r\n\t * @return currency\r\n\t */\r\n\tpublic Currency getCurrency() \r\n\t{\r\n\t\treturn lookupValue(Params.CURRENCY);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean equals(Object obj)\r\n\t{\r\n\t\tif (obj != null)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (obj instanceof AmountDAO)\r\n\t\t\t{\r\n\t\t\t\tAmountDAO mvd = (AmountDAO) obj;\r\n\t\t\t\tif (mvd.getCurrency() == getCurrency() && mvd.getAmount().equals(getAmount()))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if (obj instanceof BigDecimal)\r\n\t\t\t{\r\n\t\t\t\treturn getAmount().equals(obj);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t/**\r\n\t * Sets the currency.\r\n\t * @param currency\r\n\t */\r\n\tpublic void setCurrency(Currency currency)\r\n\t{\r\n\t\tsetValue(Params.CURRENCY, currency);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the value.\r\n\t * @return value\r\n\t */\r\n\tpublic BigDecimal getAmount()\r\n\t{\r\n\t\tBigDecimal ret = lookupValue(Params.AMOUNT);\r\n\t\tif (ret != null)\r\n\t\t{\r\n\t\t    ret = ret.setScale(2);\r\n        }\r\n\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Sets the value.\r\n\t * @param value\r\n\t */\r\n\tpublic void setAmount(BigDecimal value)\r\n\t{\r\n\t\tsetValue(Params.AMOUNT, value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the value as String.\r\n\t */\r\n\t@Override\r\n\tpublic String toValue() \r\n\t{\r\n\t\treturn toString();\r\n\t}\r\n\r\n    /**\r\n     * Returns a string representation of the value and currency.\r\n     * Examples:\r\n     * Value = 100.00 and currency = USD ($), returns $100.00,\r\n     * Value = -100.00 and currency = USD ($), returns -$100.00\r\n     */\r\n    @Override\r\n    public String toString()\r\n    {\r\n        String ret = null;\r\n\r\n        if (getAmount() != null && getCurrency() != null)\r\n        {\r\n\r\n            if (getAmount().signum() < 0)\r\n            {\r\n                ret = \"-\" + getCurrency().getValue() + getAmount().abs();\r\n            }\r\n            else\r\n            {\r\n                ret = getCurrency().getValue() + getAmount();\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}", "class_id": 0, "repo": "fidusio/zoxweb-core", "file": "src/main/java/org/zoxweb/shared/accounting/AmountDAO.java", "last_update_at": "2018-03-18T07:54:33+00:00", "question_id": "c5b885aad96e3244e1712cb768cb78d6e20c3d2c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"serial\")\r\npublic class AmountDAO\r\n\textends SetNameDescriptionDAO\r\n\timplements RenderableValue<String>\r\n{\r\n\r\n\t/**\r\n\t * Default currency set to U.S. dollar (USD).\r\n\t */\r\n\tpublic static final Currency DEFAULT_CURRENCY = Currency.USD;\r\n\t\r\n\tpublic enum Params\r\n\t\timplements GetNVConfig\r\n\t{\r\n\t\tCURRENCY(NVConfigManager.createNVConfig(\"currency\", \"Currency\", \"Currency\", true, true, Currency.class)),\r\n\t\tAMOUNT(NVConfigManager.createNVConfig(\"amount\", \"Amount\", \"Amount\", true, true, BigDecimal.class)),\r\n\t\t\r\n\t\t;\r\n\t\t\r\n\t\tprivate final NVConfig cType;\r\n\t\t\r\n\t\tParams(NVConfig c)\r\n\t\t{\r\n\t\t\tcType = c;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic NVConfig getNVConfig()\r\n\t\t{\r\n\t\t\treturn cType;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic static final NVConfigEntity NVC_AMOUNT_DAO = new NVConfigEntityLocal(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"amount_dao\", \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"AmountDAO\", \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAmountDAO.class, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSharedUtil.extractNVConfigs(Params.values()), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSetNameDescriptionDAO.NVC_NAME_DESCRIPTION_DAO\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t/**\r\n\t * The default constructor.\r\n\t */\r\n\tpublic AmountDAO()\r\n\t{\r\n\t\tsuper(NVC_AMOUNT_DAO);\r\n\t\tsetCurrency(DEFAULT_CURRENCY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO based on given amount (BigDecimal) and currency (Currency).\r\n\t * @param amount\r\n\t * @param currency\r\n\t */\r\n\tpublic AmountDAO(BigDecimal amount, Currency currency)\r\n\t{\r\n\t\tthis();\r\n\t\tsetAmount(amount);\r\n\t\tif (currency != null) {\r\n            setCurrency(currency);\r\n        }\r\n\t}\r\n\r\n    public AmountDAO(BigDecimal amount) {\r\n        this(amount, null);\r\n    }\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (String).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(String amount)\r\n\t{\r\n\t\tthis(new BigDecimal(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (long).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(long amount)\r\n\t{\r\n\t\tthis(new BigDecimal(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO given the amount (float).\r\n\t * The default currency is applied.\r\n\t * @param amount\r\n\t */\r\n\tpublic AmountDAO(float amount)\r\n\t{\r\n\t\tthis(BigDecimal.valueOf(amount), null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * This constructor instantiates MoneyValueDAO based on given currency (Currency).\r\n\t * @param currency\r\n\t */\r\n\tpublic AmountDAO(Currency currency)\r\n\t{\r\n\t\tthis(null, currency);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the currency.\r\n\t * @return currency\r\n\t */\r\n\tpublic Currency getCurrency() \r\n\t{\r\n\t\treturn lookupValue(Params.CURRENCY);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean equals(Object obj)\r\n\t{\r\n\t\tif (obj != null)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif (obj instanceof AmountDAO)\r\n\t\t\t{\r\n\t\t\t\tAmountDAO mvd = (AmountDAO) obj;\r\n\t\t\t\tif (mvd.getCurrency() == getCurrency() && mvd.getAmount().equals(getAmount()))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if (obj instanceof BigDecimal)\r\n\t\t\t{\r\n\t\t\t\treturn getAmount().equals(obj);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t/**\r\n\t * Sets the currency.\r\n\t * @param currency\r\n\t */\r\n\tpublic void setCurrency(Currency currency)\r\n\t{\r\n\t\tsetValue(Params.CURRENCY, currency);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the value.\r\n\t * @return value\r\n\t */\r\n\tpublic BigDecimal getAmount()\r\n\t{\r\n\t\tBigDecimal ret = lookupValue(Params.AMOUNT);\r\n\t\tif (ret != null)\r\n\t\t{\r\n\t\t    ret = ret.setScale(2);\r\n        }\r\n\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Sets the value.\r\n\t * @param value\r\n\t */\r\n\tpublic void setAmount(BigDecimal value)\r\n\t{\r\n\t\tsetValue(Params.AMOUNT, value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the value as String.\r\n\t */\r\n\t@Override\r\n\tpublic String toValue() \r\n\t{\r\n\t\treturn toString();\r\n\t}\r\n\r\n    /**\r\n     * Returns a string representation of the value and currency.\r\n     * Examples:\r\n     * Value = 100.00 and currency = USD ($), returns $100.00,\r\n     * Value = -100.00 and currency = USD ($), returns -$100.00\r\n     */\r\n    @Override\r\n    public String toString()\r\n    {\r\n        String ret = null;\r\n\r\n        if (getAmount() != null && getCurrency() != null)\r\n        {\r\n\r\n            if (getAmount().signum() < 0)\r\n            {\r\n                ret = \"-\" + getCurrency().getValue() + getAmount().abs();\r\n            }\r\n            else\r\n            {\r\n                ret = getCurrency().getValue() + getAmount();\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n"]], "pred": {"ppl": 1.403625726699829, "ppl_lower": 1.6726864576339722, "ppl/lowercase_ppl": -1.5172328592045052, "ppl/zlib": 0.00027124695491294825, "Min_5.0% Prob": 4.827175065582874, "Min_10.0% Prob": 3.049965780739691, "Min_20.0% Prob": 1.6692962210406275, "Min_30.0% Prob": 1.1283661621300127, "Min_40.0% Prob": 0.8471102942109181, "Min_50.0% Prob": 0.6786205911648473, "Min_60.0% Prob": 0.5658129592914951}}
{"hexsha": "60a2cd4914e90ab72f60c9ce9f09bb0aea6eca91", "ext": "java", "lang": "Java", "content": "class Node {\n    Node left, right;\n    int data;\n\n    public Node(int data) {\n        this.data = data;\n    }\n\n    public void insert (int value) {\n        if (value < data) {\n            if (left == null) {\n                left = new Node(value);\n            }\n            else {\n                left.insert(value);\n            }\n        }\n        else {\n            if (right == null) {\n                right = new Node(value);\n            }\n            else {\n                right.insert(value);\n            }\n        }\n    }\n\n    public void printInOrder() {\n        if (left != null) {\n            left.printInOrder();\n        }\n        System.out.print(data + \" \");\n        if (right != null) {\n            right.printInOrder();\n        }\n    }\n\n    public void printPreOrder() {\n        System.out.print(data + \" \");\n        if (left != null) {\n            left.printPreOrder();\n        }\n        if (right != null) {\n            right.printPreOrder();\n        }\n    }\n\n    public void printPostOrder() {\n        if (left != null) {\n            left.printPostOrder();\n        }\n        if (right != null) {\n            right.printPostOrder();\n        }\n        System.out.print(data + \" \");\n    }\n\n    /**\n    * O(n) time algorithm.\n    * Uses O(n) space to store nodes in a queue to aid in traversal.\n    */\n    public void printLevelOrder() {\n        LinkedList<Node> queue = new LinkedList<>();\n        queue.add(this);\n        while (queue.size() > 0) {\n            Node head = queue.remove();\n            System.out.print(head.data + \" \");\n            // Add children of recently-printed node to queue, if they exist.\n            if (head.left != null) {\n                queue.add(head.left);\n            }\n            if (head.right != null) {\n                queue.add(head.right);\n            }\n        }\n    }\n}", "class_id": 1, "repo": "ottok92/UnB_2018-2", "file": "BasicSoftware/JVM-master/exp/ComplexJava/DataStructures/Trees/TreeTraversal.java", "last_update_at": "2018-12-01T17:40:24+00:00", "question_id": "60a2cd4914e90ab72f60c9ce9f09bb0aea6eca91", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Node {\n    Node left, right;\n    int data;\n    public Node(int data) {\n        this.data = data;\n    }\n    public void insert (int value) {\n        if (value < data) {\n            if (left == null) {\n                left = new Node(value);\n            }\n            else {\n                left.insert(value);\n            }\n        }\n        else {\n            if (right == null) {\n                right = new Node(value);\n            }\n            else {\n                right.insert(value);\n            }\n        }\n    }\n    public void printInOrder() {\n        if (left != null) {\n            left.printInOrder();\n        }\n        System.out.print(data + \" \");\n        if (right != null) {\n            right.printInOrder();\n        }\n    }\n    public void printPreOrder() {\n        System.out.print(data + \" \");\n        if (left != null) {\n            left.printPreOrder();\n        }\n        if (right != null) {\n            right.printPreOrder();\n        }\n    }\n    public void printPostOrder() {\n        if (left != null) {\n            left.printPostOrder();\n        }\n        if (right != null) {\n            right.printPostOrder();\n        }\n        System.out.print(data + \" \");\n    }\n    /**\n    * O(n) time algorithm.\n    * Uses O(n) space to store nodes in a queue to aid in traversal.\n    */\n    public void printLevelOrder() {\n        LinkedList<Node> queue = new LinkedList<>();\n        queue.add(this);\n        while (queue.size() > 0) {\n            Node head = queue.remove();\n            System.out.print(head.data + \" \");\n            // Add children of recently-printed node to queue, if they exist.\n            if (head.left != null) {\n                queue.add(head.left);\n            }\n            if (head.right != null) {\n                queue.add(head.right);\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.3863214254379272, "ppl_lower": 1.492525577545166, "ppl/lowercase_ppl": -1.2259760177123942, "ppl/zlib": 0.0006920630986576743, "Min_5.0% Prob": 4.497788496017456, "Min_10.0% Prob": 2.8167918382906447, "Min_20.0% Prob": 1.5810529259802069, "Min_30.0% Prob": 1.0824100213464012, "Min_40.0% Prob": 0.8136054111364325, "Min_50.0% Prob": 0.6533787515637708, "Min_60.0% Prob": 0.5439306691426085}}
{"hexsha": "43bb421c9ebf3eb625b5c03b105acc33142518f5", "ext": "java", "lang": "Java", "content": "public class ConfigurationList implements WorkspaceUpdateListener {\n    private Map<CElectionDescription, List<ConfigurationBatch>> configsByDescr =\n            new LinkedHashMap<CElectionDescription, List<ConfigurationBatch>>();\n    private Map<PropertyDescription, List<ConfigurationBatch>> configsByPropDescr =\n                new LinkedHashMap<PropertyDescription, List<ConfigurationBatch>>();\n    private Map<String, ConfigurationBatch> configsByName =\n            new LinkedHashMap<String, ConfigurationBatch>();\n\n    public final boolean canAdd(final ConfigurationBatch config) {\n        return !configsByName.containsKey(config.getName());\n    }\n\n    public final void add(final ConfigurationBatch config) {\n        if (configsByName.containsKey(config.getName())) {\n            throw new NotImplementedException();\n        } else {\n            configsByName.put(config.getName(), config);\n        }\n        if (!configsByDescr.containsKey(config.getDescr())) {\n            configsByDescr.put(config.getDescr(), new ArrayList<ConfigurationBatch>());\n        }\n        configsByDescr.get(config.getDescr()).add(config);\n        if (!configsByPropDescr.containsKey(config.getPropDescr())) {\n            configsByPropDescr.put(config.getPropDescr(),\n                                       new ArrayList<ConfigurationBatch>());\n        }\n        configsByPropDescr.get(config.getPropDescr()).add(config);\n    }\n\n    public final Map<CElectionDescription, List<ConfigurationBatch>> getConfigsByDescr() {\n        return configsByDescr;\n    }\n\n    public final Map<PropertyDescription, List<ConfigurationBatch>> getConfigsByPropDescr() {\n        return configsByPropDescr;\n    }\n\n    public final List<ConfigurationBatch>\n                getConfigsByPropDescr(final PropertyDescription currentPropDescr) {\n        if (configsByPropDescr.containsKey(currentPropDescr)) {\n            return configsByPropDescr.get(currentPropDescr);\n        }\n        return List.of();\n    }\n\n    public final void handleDescrChange(final CElectionDescription descr) {\n        if (configsByDescr.containsKey(descr)) {\n            for (final ConfigurationBatch tc : configsByDescr.get(descr)) {\n                tc.handleDescrChange();\n            }\n        }\n    }\n\n    public final List<PropertyCheckRun> getRuns() {\n        final List<PropertyCheckRun> list = new ArrayList<PropertyCheckRun>();\n        for (final CElectionDescription descr : configsByDescr.keySet()) {\n            final List<ConfigurationBatch> configBatches = configsByDescr.get(descr);\n            for (final ConfigurationBatch configBatch : configBatches) {\n                for (final Configuration config : configBatch.getConfigs()) {\n                    list.addAll(config.getRuns());\n                }\n            }\n        }\n        return list;\n    }\n\n    @Override\n    public final void handleExtractedFunctionLoops(final CElectionDescription descr,\n                                                   final CElectionDescriptionFunction func) {\n        handleDescrChange(descr);\n    }\n\n    @Override\n    public final void handleDescrChangeUpdatedFunctionCode(final CElectionDescription descr,\n                                                           final CElectionDescriptionFunction\n                                                                   function,\n                                                           final String code) {\n        handleDescrChange(descr);\n    }\n\n    @Override\n    public final void handleDescrChangeAddedVotingSigFunction(final CElectionDescription descr,\n                                                              final VotingSigFunction func) {\n        handleDescrChange(descr);\n    }\n\n    @Override\n    public final void handleDescrChangeRemovedFunction(final CElectionDescription descr,\n                                                       final CElectionDescriptionFunction func) {\n        handleDescrChange(descr);\n    }\n\n    private void handlePropDescrChanged(final PropertyDescription propDescr) {\n        if (configsByPropDescr.containsKey(propDescr)) {\n            for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {\n                tc.handlePropDescrChanged();\n            }\n        }\n\n    }\n\n    @Override\n    public final void handleWorkspaceUpdateAddedVarToPropDescr(final PropertyDescription\n                                                                        currentPropDescr,\n                                                               final SymbolicVariable var) {\n        handlePropDescrChanged(currentPropDescr);\n    }\n\n    @Override\n    public final void handlePropDescrChangedCode(final PropertyDescription propDescr) {\n        handlePropDescrChanged(propDescr);\n    }\n\n    @Override\n    public final void handlePropDescrRemovedVar(final PropertyDescription propDescr,\n                                                final SymbolicVariable selectedVar) {\n        handlePropDescrChanged(propDescr);\n    }\n\n    public final void deleteRun(final PropertyCheckRun run) {\n        run.getTc().deleteRun(run);\n    }\n\n    public final void deleteConfiguration(final ConfigurationBatch tc) {\n        configsByName.remove(tc.getName());\n        configsByDescr.get(tc.getDescr()).remove(tc);\n        final List<ConfigurationBatch> emptyList = new LinkedList<ConfigurationBatch>();\n        configsByPropDescr.getOrDefault(tc.getPropDescr(), emptyList).remove(tc);\n    }\n\n    public final void removeAll(final CElectionDescription descr) {\n        for (final ConfigurationBatch tc : configsByDescr.get(descr)) {\n            deleteConfiguration(tc);\n        }\n        configsByDescr.remove(descr);\n    }\n\n    public final void removeAll(final PropertyDescription propDescr) {\n        for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {\n            deleteConfiguration(tc);\n        }\n        configsByPropDescr.remove(propDescr);\n    }\n}", "class_id": 0, "repo": "VeriVote/beast", "file": "beast/src/main/java/edu/pse/beast/gui/configurationeditor/configuration/ConfigurationList.java", "last_update_at": "2018-08-23T07:10:03+00:00", "question_id": "43bb421c9ebf3eb625b5c03b105acc33142518f5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConfigurationList implements WorkspaceUpdateListener {\n    private Map<CElectionDescription, List<ConfigurationBatch>> configsByDescr =\n            new LinkedHashMap<CElectionDescription, List<ConfigurationBatch>>();\n    private Map<PropertyDescription, List<ConfigurationBatch>> configsByPropDescr =\n                new LinkedHashMap<PropertyDescription, List<ConfigurationBatch>>();\n    private Map<String, ConfigurationBatch> configsByName =\n            new LinkedHashMap<String, ConfigurationBatch>();\n    public final boolean canAdd(final ConfigurationBatch config) {\n        return !configsByName.containsKey(config.getName());\n    }\n    public final void add(final ConfigurationBatch config) {\n        if (configsByName.containsKey(config.getName())) {\n            throw new NotImplementedException();\n        } else {\n            configsByName.put(config.getName(), config);\n        }\n        if (!configsByDescr.containsKey(config.getDescr())) {\n            configsByDescr.put(config.getDescr(), new ArrayList<ConfigurationBatch>());\n        }\n        configsByDescr.get(config.getDescr()).add(config);\n        if (!configsByPropDescr.containsKey(config.getPropDescr())) {\n            configsByPropDescr.put(config.getPropDescr(),\n                                       new ArrayList<ConfigurationBatch>());\n        }\n        configsByPropDescr.get(config.getPropDescr()).add(config);\n    }\n    public final Map<CElectionDescription, List<ConfigurationBatch>> getConfigsByDescr() {\n        return configsByDescr;\n    }\n    public final Map<PropertyDescription, List<ConfigurationBatch>> getConfigsByPropDescr() {\n        return configsByPropDescr;\n    }\n    public final List<ConfigurationBatch>\n                getConfigsByPropDescr(final PropertyDescription currentPropDescr) {\n        if (configsByPropDescr.containsKey(currentPropDescr)) {\n            return configsByPropDescr.get(currentPropDescr);\n        }\n        return List.of();\n    }\n    public final void handleDescrChange(final CElectionDescription descr) {\n        if (configsByDescr.containsKey(descr)) {\n            for (final ConfigurationBatch tc : configsByDescr.get(descr)) {\n                tc.handleDescrChange();\n            }\n        }\n    }\n    public final List<PropertyCheckRun> getRuns() {\n        final List<PropertyCheckRun> list = new ArrayList<PropertyCheckRun>();\n        for (final CElectionDescription descr : configsByDescr.keySet()) {\n            final List<ConfigurationBatch> configBatches = configsByDescr.get(descr);\n            for (final ConfigurationBatch configBatch : configBatches) {\n                for (final Configuration config : configBatch.getConfigs()) {\n                    list.addAll(config.getRuns());\n                }\n            }\n        }\n        return list;\n    }\n    @Override\n    public final void handleExtractedFunctionLoops(final CElectionDescription descr,\n                                                   final CElectionDescriptionFunction func) {\n        handleDescrChange(descr);\n    }\n    @Override\n    public final void handleDescrChangeUpdatedFunctionCode(final CElectionDescription descr,\n                                                           final CElectionDescriptionFunction\n                                                                   function,\n                                                           final String code) {\n        handleDescrChange(descr);\n    }\n    @Override\n    public final void handleDescrChangeAddedVotingSigFunction(final CElectionDescription descr,\n                                                              final VotingSigFunction func) {\n        handleDescrChange(descr);\n    }\n    @Override\n    public final void handleDescrChangeRemovedFunction(final CElectionDescription descr,\n                                                       final CElectionDescriptionFunction func) {\n        handleDescrChange(descr);\n    }\n    private void handlePropDescrChanged(final PropertyDescription propDescr) {\n        if (configsByPropDescr.containsKey(propDescr)) {\n            for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {\n                tc.handlePropDescrChanged();\n            }\n        }\n    }\n    @Override\n    public final void handleWorkspaceUpdateAddedVarToPropDescr(final PropertyDescription\n                                                                        currentPropDescr,\n                                                               final SymbolicVariable var) {\n        handlePropDescrChanged(currentPropDescr);\n    }\n    @Override\n    public final void handlePropDescrChangedCode(final PropertyDescription propDescr) {\n        handlePropDescrChanged(propDescr);\n    }\n    @Override\n    public final void handlePropDescrRemovedVar(final PropertyDescription propDescr,\n                                                final SymbolicVariable selectedVar) {\n        handlePropDescrChanged(propDescr);\n    }\n    public final void deleteRun(final PropertyCheckRun run) {\n        run.getTc().deleteRun(run);\n    }\n    public final void deleteConfiguration(final ConfigurationBatch tc) {\n        configsByName.remove(tc.getName());\n        configsByDescr.get(tc.getDescr()).remove(tc);\n        final List<ConfigurationBatch> emptyList = new LinkedList<ConfigurationBatch>();\n        configsByPropDescr.getOrDefault(tc.getPropDescr(), emptyList).remove(tc);\n    }\n    public final void removeAll(final CElectionDescription descr) {\n        for (final ConfigurationBatch tc : configsByDescr.get(descr)) {\n            deleteConfiguration(tc);\n        }\n        configsByDescr.remove(descr);\n    }\n    public final void removeAll(final PropertyDescription propDescr) {\n        for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {\n            deleteConfiguration(tc);\n        }\n        configsByPropDescr.remove(propDescr);\n    }\n"]], "pred": {"ppl": 1.7173678874969482, "ppl_lower": 1.7387275695800781, "ppl/lowercase_ppl": -1.0228567070934957, "ppl/zlib": 0.0005473611546119515, "Min_5.0% Prob": 6.792234860214532, "Min_10.0% Prob": 4.557987543882108, "Min_20.0% Prob": 2.618938451450245, "Min_30.0% Prob": 1.7901760804424294, "Min_40.0% Prob": 1.3483348646153375, "Min_50.0% Prob": 1.08146540594238, "Min_60.0% Prob": 0.9021695268322937}}
{"hexsha": "f417c149d062210a7bf1d526402038faa1ed3c60", "ext": "java", "lang": "Java", "content": "public class AbstractITBatchIndexTest extends AbstractIndexerTest\n{\n  private static final Logger LOG = new Logger(AbstractITBatchIndexTest.class);\n\n  @Inject\n  IntegrationTestingConfig config;\n\n  @Inject\n  ClientInfoResourceTestClient clientInfoResourceTestClient;\n\n  void doIndexTestTest(\n      String dataSource,\n      String indexTaskFilePath,\n      String queryFilePath\n  ) throws IOException\n  {\n    submitTaskAndWait(indexTaskFilePath, dataSource);\n    try {\n      queryHelper.testQueriesFromFile(queryFilePath, 2);\n\n    }\n    catch (Exception e) {\n      LOG.error(e, \"Error while testing\");\n      throw new RuntimeException(e);\n    }\n  }\n\n  void doReindexTest(\n      String reindexDataSource,\n      String reindexTaskFilePath,\n      String queryFilePath\n  ) throws IOException\n  {\n    submitTaskAndWait(reindexTaskFilePath, reindexDataSource);\n    try {\n      queryHelper.testQueriesFromFile(queryFilePath, 2);\n      // verify excluded dimension is not reIndexed\n      final List<String> dimensions = clientInfoResourceTestClient.getDimensions(\n          reindexDataSource,\n          \"2013-08-31T00:00:00.000Z/2013-09-10T00:00:00.000Z\"\n      );\n      Assert.assertFalse(\"dimensions : \" + dimensions, dimensions.contains(\"robot\"));\n    }\n    catch (Exception e) {\n      LOG.error(e, \"Error while testing\");\n      throw new RuntimeException(e);\n    }\n  }\n\n  private void submitTaskAndWait(String indexTaskFilePath, String dataSourceName) throws IOException\n  {\n    final String taskID = indexer.submitTask(getTaskAsString(indexTaskFilePath));\n    LOG.info(\"TaskID for loading index task %s\", taskID);\n    indexer.waitUntilTaskCompletes(taskID);\n\n    RetryUtil.retryUntilTrue(\n        () -> coordinator.areSegmentsLoaded(dataSourceName), \"Segment Load\"\n    );\n  }\n}", "class_id": 0, "repo": "jsun98/druid", "file": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractITBatchIndexTest.java", "last_update_at": "2018-08-31T06:43:27+00:00", "question_id": "f417c149d062210a7bf1d526402038faa1ed3c60", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AbstractITBatchIndexTest extends AbstractIndexerTest\n{\n  private static final Logger LOG = new Logger(AbstractITBatchIndexTest.class);\n  @Inject\n  IntegrationTestingConfig config;\n  @Inject\n  ClientInfoResourceTestClient clientInfoResourceTestClient;\n  void doIndexTestTest(\n      String dataSource,\n      String indexTaskFilePath,\n      String queryFilePath\n  ) throws IOException\n  {\n    submitTaskAndWait(indexTaskFilePath, dataSource);\n    try {\n      queryHelper.testQueriesFromFile(queryFilePath, 2);\n    }\n    catch (Exception e) {\n      LOG.error(e, \"Error while testing\");\n      throw new RuntimeException(e);\n    }\n  }\n  void doReindexTest(\n      String reindexDataSource,\n      String reindexTaskFilePath,\n      String queryFilePath\n  ) throws IOException\n  {\n    submitTaskAndWait(reindexTaskFilePath, reindexDataSource);\n    try {\n      queryHelper.testQueriesFromFile(queryFilePath, 2);\n      // verify excluded dimension is not reIndexed\n      final List<String> dimensions = clientInfoResourceTestClient.getDimensions(\n          reindexDataSource,\n          \"2013-08-31T00:00:00.000Z/2013-09-10T00:00:00.000Z\"\n      );\n      Assert.assertFalse(\"dimensions : \" + dimensions, dimensions.contains(\"robot\"));\n    }\n    catch (Exception e) {\n      LOG.error(e, \"Error while testing\");\n      throw new RuntimeException(e);\n    }\n  }\n  private void submitTaskAndWait(String indexTaskFilePath, String dataSourceName) throws IOException\n  {\n    final String taskID = indexer.submitTask(getTaskAsString(indexTaskFilePath));\n    LOG.info(\"TaskID for loading index task %s\", taskID);\n    indexer.waitUntilTaskCompletes(taskID);\n    RetryUtil.retryUntilTrue(\n        () -> coordinator.areSegmentsLoaded(dataSourceName), \"Segment Load\"\n    );\n  }\n"]], "pred": {"ppl": 2.0614922046661377, "ppl_lower": 2.9194047451019287, "ppl/lowercase_ppl": -1.4809720431491507, "ppl/zlib": 0.0011078561895382164, "Min_5.0% Prob": 6.759729458735539, "Min_10.0% Prob": 4.834018882715477, "Min_20.0% Prob": 3.185478740143326, "Min_30.0% Prob": 2.3143438335508106, "Min_40.0% Prob": 1.7905763518152662, "Min_50.0% Prob": 1.4413941332212326, "Min_60.0% Prob": 1.2059188567072852}}
{"hexsha": "f84b0fddb689c4ed9f34a76410ae530df36cc563", "ext": "java", "lang": "Java", "content": "public class SetupThread extends Thread {\n\n  private static final Logger logger = LogManager.getLogger(SetupThread.class.getName());\n\n  private List<PropertyChangeListener> listener = new ArrayList<PropertyChangeListener>();\n\n  /** The config. */\n  public JsonObject config = new JsonObject();\n\n  /**\n   * Method to update the listeners about any property changes. This is used by the UI to inform user what the status of\n   * the setup.\n   *\n   * @param object\n   * @param config\n   */\n  private void notifyListeners(Object object, JsonObject config) {\n    for (PropertyChangeListener configUpdate : listener) {\n      configUpdate.propertyChange(new PropertyChangeEvent(this, \"configSetup\", config, config)); //$NON-NLS-1$\n    }\n  }\n\n  /**\n   * This method is used to update the JSON Config Object that will be sent back to the UI.\n   *\n   * @param config\n   * @param setupStep The step at which the setup is\n   * @param setupState The state of the setup(accepts ready/not_ready)\n   * @param setupPhase The current phase of the setup(this can be that the services is being setup or if any other\n   *        phase of the application is being setup)\n   * @param setupMessage The message that you want to be shown in the UI.\n   */\n  private void updateConfigObject(String setupStep, String setupState, String setupPhase, String setupMessage) {\n    config.addProperty(Constants.SETUP_STEP, setupStep); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_STATE, setupState); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_PHASE, setupPhase); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_MESSAGE, setupMessage); // $NON-NLS-1$\n    notifyListeners(this, config);\n  }\n\n  /**\n   * Method to add a listener.\n   *\n   * @param newListener PropertyChangeListener\n   */\n  public void addChangeListener(PropertyChangeListener newListener) {\n    listener.add(newListener);\n  }\n\n  /*\n   * (non-Javadoc)\n   *\n   * @see java.lang.Thread#run()\n   */\n  @Override\n  public void run() {\n\n    String status = \"\";\n\n    try {\n      updateConfigObject(\"1\", Constants.NOT_READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.GETTING_CREDENTIALS\"));\n\n      // test discovery credentials\n\n      String userName = System.getenv(\"DISCOVERY_USERNAME\");\n      String password = System.getenv(\"DISCOVERY_PASSWORD\");\n      String collectionId = System.getenv(\"DISCOVERY_COLLECTION_ID\");\n      String environmentId = System.getenv(\"DISCOVERY_ENVIRONMENT_ID\");\n\n      if ((userName == null) || (password == null) || (collectionId == null) || (environmentId == null)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.DISC_INVALID_CREDS\"));\n      }\n      if ((userName.length() == 0) || (password.length() == 0) || (collectionId.length() == 0)\n          || (environmentId.length() == 0)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.DISC_INVALID_CREDS\"));\n      }\n\n      status = \"Discovery \";\n\n      Discovery discovery = new Discovery(Constants.DISCOVERY_VERSION);\n      discovery.setEndPoint(Constants.DISCOVERY_URL);\n      discovery.setUsernameAndPassword(userName, password);\n\n      QueryRequest.Builder queryBuilder = new QueryRequest.Builder(environmentId, collectionId);\n      queryBuilder.query(\"searchText:car tire pressure\");\n      discovery.query(queryBuilder.build()).execute();\n\n      // test conversation credentials\n\n      updateConfigObject(\"2\", Constants.NOT_READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.GETTING_CREDENTIALS\"));\n\n      userName = System.getenv(\"CONVERSATION_USERNAME\");\n      password = System.getenv(\"CONVERSATION_PASSWORD\");\n      String workspaceId = System.getenv(\"WORKSPACE_ID\");\n\n      if ((userName == null) || (password == null) || (workspaceId == null)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.CONV_INVALID_CREDS\"));\n      }\n      if ((userName.length() == 0) || (password.length() == 0) || (workspaceId.length() == 0)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.CONV_INVALID_CREDS\"));\n      }\n\n      status = \"Conversation \";\n\n      ConversationService service = new ConversationService(Constants.CONVERSATION_VERSION);\n      service.setUsernameAndPassword(userName, password);\n      MessageRequest newMessage = new MessageRequest.Builder().inputText(\"hi\").context(null).build();\n      service.message(workspaceId, newMessage).execute();\n\n      updateConfigObject(\"3\", Constants.READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.EMPTY\"));\n\n      logger.info(Messages.getString(\"SetupThread.SETUP_COMPLETE\"));\n    } catch (Exception e) {\n      logger.error(Messages.getString(\"SetupThread.ERROR_COLLECTION_INIT\") + e.getMessage());\n      if (e instanceof UnauthorizedException) {\n        updateConfigObject(\"0\", Constants.NOT_READY, Messages.getString(\"SetupThread.ERROR\"), status + e.getMessage());\n      } else {\n        updateConfigObject(\"0\", Constants.NOT_READY, Messages.getString(\"SetupThread.ERROR\"),\n            e.getMessage() + \" \" + Messages.getString(\"SetupThread.CHECK_LOGS\"));\n      }\n    }\n  }\n}", "class_id": 0, "repo": "irpk/simple-toolchain-20171018112401694", "file": "src/main/java/com/ibm/watson/apis/conversation_with_discovery/listener/SetupThread.java", "last_update_at": "2018-03-27T11:57:30+00:00", "question_id": "f84b0fddb689c4ed9f34a76410ae530df36cc563", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SetupThread extends Thread {\n  private static final Logger logger = LogManager.getLogger(SetupThread.class.getName());\n  private List<PropertyChangeListener> listener = new ArrayList<PropertyChangeListener>();\n  /** The config. */\n  public JsonObject config = new JsonObject();\n  /**\n   * Method to update the listeners about any property changes. This is used by the UI to inform user what the status of\n   * the setup.\n   *\n   * @param object\n   * @param config\n   */\n  private void notifyListeners(Object object, JsonObject config) {\n    for (PropertyChangeListener configUpdate : listener) {\n      configUpdate.propertyChange(new PropertyChangeEvent(this, \"configSetup\", config, config)); //$NON-NLS-1$\n    }\n  }\n  /**\n   * This method is used to update the JSON Config Object that will be sent back to the UI.\n   *\n   * @param config\n   * @param setupStep The step at which the setup is\n   * @param setupState The state of the setup(accepts ready/not_ready)\n   * @param setupPhase The current phase of the setup(this can be that the services is being setup or if any other\n   *        phase of the application is being setup)\n   * @param setupMessage The message that you want to be shown in the UI.\n   */\n  private void updateConfigObject(String setupStep, String setupState, String setupPhase, String setupMessage) {\n    config.addProperty(Constants.SETUP_STEP, setupStep); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_STATE, setupState); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_PHASE, setupPhase); // $NON-NLS-1$\n    config.addProperty(Constants.SETUP_MESSAGE, setupMessage); // $NON-NLS-1$\n    notifyListeners(this, config);\n  }\n  /**\n   * Method to add a listener.\n   *\n   * @param newListener PropertyChangeListener\n   */\n  public void addChangeListener(PropertyChangeListener newListener) {\n    listener.add(newListener);\n  }\n  /*\n   * (non-Javadoc)\n   *\n   * @see java.lang.Thread#run()\n   */\n  @Override\n  public void run() {\n    String status = \"\";\n    try {\n      updateConfigObject(\"1\", Constants.NOT_READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.GETTING_CREDENTIALS\"));\n      // test discovery credentials\n      String userName = System.getenv(\"DISCOVERY_USERNAME\");\n      String password = System.getenv(\"DISCOVERY_PASSWORD\");\n      String collectionId = System.getenv(\"DISCOVERY_COLLECTION_ID\");\n      String environmentId = System.getenv(\"DISCOVERY_ENVIRONMENT_ID\");\n      if ((userName == null) || (password == null) || (collectionId == null) || (environmentId == null)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.DISC_INVALID_CREDS\"));\n      }\n      if ((userName.length() == 0) || (password.length() == 0) || (collectionId.length() == 0)\n          || (environmentId.length() == 0)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.DISC_INVALID_CREDS\"));\n      }\n      status = \"Discovery \";\n      Discovery discovery = new Discovery(Constants.DISCOVERY_VERSION);\n      discovery.setEndPoint(Constants.DISCOVERY_URL);\n      discovery.setUsernameAndPassword(userName, password);\n      QueryRequest.Builder queryBuilder = new QueryRequest.Builder(environmentId, collectionId);\n      queryBuilder.query(\"searchText:car tire pressure\");\n      discovery.query(queryBuilder.build()).execute();\n      // test conversation credentials\n      updateConfigObject(\"2\", Constants.NOT_READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.GETTING_CREDENTIALS\"));\n      userName = System.getenv(\"CONVERSATION_USERNAME\");\n      password = System.getenv(\"CONVERSATION_PASSWORD\");\n      String workspaceId = System.getenv(\"WORKSPACE_ID\");\n      if ((userName == null) || (password == null) || (workspaceId == null)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.CONV_INVALID_CREDS\"));\n      }\n      if ((userName.length() == 0) || (password.length() == 0) || (workspaceId.length() == 0)) {\n        throw new IllegalArgumentException(Messages.getString(\"SetupThread.CONV_INVALID_CREDS\"));\n      }\n      status = \"Conversation \";\n      ConversationService service = new ConversationService(Constants.CONVERSATION_VERSION);\n      service.setUsernameAndPassword(userName, password);\n      MessageRequest newMessage = new MessageRequest.Builder().inputText(\"hi\").context(null).build();\n      service.message(workspaceId, newMessage).execute();\n      updateConfigObject(\"3\", Constants.READY, Messages.getString(\"SetupThread.EMPTY\"),\n          Messages.getString(\"SetupThread.EMPTY\"));\n      logger.info(Messages.getString(\"SetupThread.SETUP_COMPLETE\"));\n    } catch (Exception e) {\n      logger.error(Messages.getString(\"SetupThread.ERROR_COLLECTION_INIT\") + e.getMessage());\n      if (e instanceof UnauthorizedException) {\n        updateConfigObject(\"0\", Constants.NOT_READY, Messages.getString(\"SetupThread.ERROR\"), status + e.getMessage());\n      } else {\n        updateConfigObject(\"0\", Constants.NOT_READY, Messages.getString(\"SetupThread.ERROR\"),\n            e.getMessage() + \" \" + Messages.getString(\"SetupThread.CHECK_LOGS\"));\n      }\n    }\n  }\n"]], "pred": {"ppl": 2.063518762588501, "ppl_lower": 2.326029062271118, "ppl/lowercase_ppl": -1.1653061741277642, "ppl/zlib": 0.00048069851544341955, "Min_5.0% Prob": 6.3213918723312075, "Min_10.0% Prob": 4.8598100017098815, "Min_20.0% Prob": 3.261380878441474, "Min_30.0% Prob": 2.3443965047987456, "Min_40.0% Prob": 1.7974566746238974, "Min_50.0% Prob": 1.4468521780740842, "Min_60.0% Prob": 1.208047964872996}}
{"hexsha": "6223017e14845bf3bba283627af015ff2c4ab3a4", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"StringConcatenationInLoop\")\npublic class L0068 {\n\n//    private final int maxWidth = 16;\n//    private final String[] words = new String[] {\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"};\n\n    private final int maxWidth = 16;\n    private final String[] words = new String[] {\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"};\n\n//    private final int maxWidth = 20;\n//    private final String[] words = new String[] {\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"};\n\n    public void run() {\n        List<String> result = fullJustify(words, maxWidth);\n        for(String s: result) {\n            System.out.println(\"\\\"\" + s + \"\\\"\");\n        }\n    }\n\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList<>();\n        List<String> crtLine = new ArrayList<>();\n        int crtLL = 0;\n        for(int i = 0; i < words.length; i ++) {\n            int candLL = crtLL + words[i].length() + (crtLL == 0 ? 0 : 1);\n            if (candLL <= maxWidth) {\n                crtLine.add(words[i]);\n                crtLL = candLL;\n                if (i == words.length - 1) {\n                    result.add(commit(crtLine, crtLL, true));\n                }\n            }\n            else {\n                // we know that crtLine.length <= maxWidth from\n                // the previous iteration\n                result.add(commit(crtLine, crtLL, false));\n                crtLL = 0;\n                crtLine = new ArrayList<>();\n                i--;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * We get a list of words for which the total length + inter-word spacing\n     * is <= maxWidth\n     **/\n    private String commit(List<String> crtLine, int lengthInclInterWordSpacing,\n                          boolean finalLine) {\n        int extraPadding = maxWidth - lengthInclInterWordSpacing;\n        String s = \"\";\n        if (finalLine || crtLine.size() == 1) {\n            for(int i = 0; i < crtLine.size(); i ++) {\n                s += (i > 0 ? \" \": \"\") + crtLine.get(i);\n            }\n            for(int i = 0; i < extraPadding; i ++) {\n                s += \" \";\n            }\n            return s;\n        }\n        int eppg = extraPadding / (crtLine.size() - 1);\n        // extra spaces to distribute to left gaps (may be 0)\n        int eslg = extraPadding - eppg * (crtLine.size() - 1);\n        for(int i = 0; i < crtLine.size(); i ++) {\n            s +=\n                    (i == 0 ? \"\": \" \" + spaces(eppg) + (eslg-- > 0 ? \" \" : \"\")) +\n                            crtLine.get(i);\n        }\n        return s;\n    }\n\n    private String spaces(int count) {\n        String s = \"\";\n        for(int i = 0; i < count; i ++) {\n            s += \" \";\n        }\n        return s;\n    }\n\n}", "class_id": 0, "repo": "NovaOrdis/playground", "file": "leetcode/src/main/java/playground/leetcode/L0068.java", "last_update_at": "2018-03-14T19:57:11+00:00", "question_id": "6223017e14845bf3bba283627af015ff2c4ab3a4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"StringConcatenationInLoop\")\npublic class L0068 {\n//    private final int maxWidth = 16;\n//    private final String[] words = new String[] {\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"};\n    private final int maxWidth = 16;\n    private final String[] words = new String[] {\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"};\n//    private final int maxWidth = 20;\n//    private final String[] words = new String[] {\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"};\n    public void run() {\n        List<String> result = fullJustify(words, maxWidth);\n        for(String s: result) {\n            System.out.println(\"\\\"\" + s + \"\\\"\");\n        }\n    }\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList<>();\n        List<String> crtLine = new ArrayList<>();\n        int crtLL = 0;\n        for(int i = 0; i < words.length; i ++) {\n            int candLL = crtLL + words[i].length() + (crtLL == 0 ? 0 : 1);\n            if (candLL <= maxWidth) {\n                crtLine.add(words[i]);\n                crtLL = candLL;\n                if (i == words.length - 1) {\n                    result.add(commit(crtLine, crtLL, true));\n                }\n            }\n            else {\n                // we know that crtLine.length <= maxWidth from\n                // the previous iteration\n                result.add(commit(crtLine, crtLL, false));\n                crtLL = 0;\n                crtLine = new ArrayList<>();\n                i--;\n            }\n        }\n        return result;\n    }\n    /**\n     * We get a list of words for which the total length + inter-word spacing\n     * is <= maxWidth\n     **/\n    private String commit(List<String> crtLine, int lengthInclInterWordSpacing,\n                          boolean finalLine) {\n        int extraPadding = maxWidth - lengthInclInterWordSpacing;\n        String s = \"\";\n        if (finalLine || crtLine.size() == 1) {\n            for(int i = 0; i < crtLine.size(); i ++) {\n                s += (i > 0 ? \" \": \"\") + crtLine.get(i);\n            }\n            for(int i = 0; i < extraPadding; i ++) {\n                s += \" \";\n            }\n            return s;\n        }\n        int eppg = extraPadding / (crtLine.size() - 1);\n        // extra spaces to distribute to left gaps (may be 0)\n        int eslg = extraPadding - eppg * (crtLine.size() - 1);\n        for(int i = 0; i < crtLine.size(); i ++) {\n            s +=\n                    (i == 0 ? \"\": \" \" + spaces(eppg) + (eslg-- > 0 ? \" \" : \"\")) +\n                            crtLine.get(i);\n        }\n        return s;\n    }\n    private String spaces(int count) {\n        String s = \"\";\n        for(int i = 0; i < count; i ++) {\n            s += \" \";\n        }\n        return s;\n    }\n"]], "pred": {"ppl": 1.7785661220550537, "ppl_lower": 1.920018196105957, "ppl/lowercase_ppl": -1.132904094092816, "ppl/zlib": 0.0006198143059929478, "Min_5.0% Prob": 5.696012106808749, "Min_10.0% Prob": 4.195019646976771, "Min_20.0% Prob": 2.694471989930009, "Min_30.0% Prob": 1.882497296626888, "Min_40.0% Prob": 1.4283603239471518, "Min_50.0% Prob": 1.1496553079723077, "Min_60.0% Prob": 0.9587123385193502}}
{"hexsha": "9be7d4f43cbba04ab5ae5fbe41b5e00f9bd8602a", "ext": "java", "lang": "Java", "content": "public class CustoController implements Initializable {\n\n    @FXML\n    private AnchorPane apPrincipal;\n    private Date dtInclusao;\n    @FXML\n    private TextField tfCustoPlanejado;\n    @FXML\n    private TextField tfCustoRealizado;\n    private Custo custo;\n    private Projeto projeto;\n    private Stage stage;\n    private GerenciadorDeJanela gerenciadorDeJanela;\n    Map<String,Object> params = new HashMap<>();\n    /**\n     * Initializes the controller class.\n     */\n    \n    @Override\n    public void initialize(URL url, ResourceBundle rb) {\n        apPrincipal.sceneProperty().addListener((ObservableValue<? extends Scene> observable, Scene oldValue, Scene newValue) -> {\n            params = (Map) apPrincipal.getUserData();\n            gerenciadorDeJanela = (GerenciadorDeJanela) params.get(\"gerenciador\");\n        });\n    }\n\n    public void teste(){\n        params = (Map) apPrincipal.getUserData();\n        gerenciadorDeJanela = (GerenciadorDeJanela) params.get(\"gerenciador\");\n        dtInclusao = (Date) params.get(\"dtInclusao\");\n        custo = (Custo) params.get(\"custo\");\n        projeto = (Projeto) params.get(\"projeto\");\n        stage = (Stage) params.get(\"modalStage\");\n        if(null != custo.getCustoTecnicoPlanejado()){\n            tfCustoPlanejado.setText(String.valueOf(custo.getCustoTecnicoPlanejado()));\n        }else{\n            tfCustoPlanejado.setText(\"0.0\");\n        }\n        \n        if(null != custo.getCustoTecnicoRealizado()){\n            tfCustoRealizado.setText(String.valueOf(custo.getCustoTecnicoRealizado()));\n        }else{\n            tfCustoRealizado.setText(\"0.0\");\n        }\n    }\n    \n    @FXML\n    private void salvarCusto() {\n        custo.setDtInclusao(dtInclusao);\n        custo.setProjeto(projeto);\n        if(StringUtil.isEmpty(tfCustoPlanejado.getText())){\n            custo.setCustoTecnicoPlanejado(0.0);\n        }else{\n            String auxPlanejado = tfCustoPlanejado.getText();\n            auxPlanejado.replaceAll(\"[,]*[.]*\", \"\");\n            custo.setCustoTecnicoPlanejado(DoubleConverter.stringToDouble(auxPlanejado));\n        }\n        \n        if(StringUtil.isEmpty(tfCustoRealizado.getText())){\n            custo.setCustoTecnicoRealizado(0.0);\n        }else{\n            String auxRealizado = tfCustoRealizado.getText();\n            auxRealizado.replaceAll(\"[,]*[.]*\", \"\");\n            custo.setCustoTecnicoRealizado(DoubleConverter.stringToDouble(auxRealizado));\n        }\n        if(null == custo.getId()){\n            CustoDAO.getInstance().salvar(custo);\n            new Alert(Alert.AlertType.INFORMATION, \"Custo cadastro com sucesso.\").show();\n            stage.close();\n        }else{\n            CustoDAO.getInstance().editar(custo);\n            new Alert(Alert.AlertType.INFORMATION, \"Custo atualizado com sucesso.\").show();\n            stage.close();\n        }\n        params.put(\"CustoAux\", custo); \n    }\n}", "class_id": 0, "repo": "lucasbiel7/ProductionManager", "file": "src/main/java/br/com/stefanini/control/CustoController.java", "last_update_at": "2018-02-20T18:14:53+00:00", "question_id": "9be7d4f43cbba04ab5ae5fbe41b5e00f9bd8602a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CustoController implements Initializable {\n    @FXML\n    private AnchorPane apPrincipal;\n    private Date dtInclusao;\n    @FXML\n    private TextField tfCustoPlanejado;\n    @FXML\n    private TextField tfCustoRealizado;\n    private Custo custo;\n    private Projeto projeto;\n    private Stage stage;\n    private GerenciadorDeJanela gerenciadorDeJanela;\n    Map<String,Object> params = new HashMap<>();\n    /**\n     * Initializes the controller class.\n     */\n    @Override\n    public void initialize(URL url, ResourceBundle rb) {\n        apPrincipal.sceneProperty().addListener((ObservableValue<? extends Scene> observable, Scene oldValue, Scene newValue) -> {\n            params = (Map) apPrincipal.getUserData();\n            gerenciadorDeJanela = (GerenciadorDeJanela) params.get(\"gerenciador\");\n        });\n    }\n    public void teste(){\n        params = (Map) apPrincipal.getUserData();\n        gerenciadorDeJanela = (GerenciadorDeJanela) params.get(\"gerenciador\");\n        dtInclusao = (Date) params.get(\"dtInclusao\");\n        custo = (Custo) params.get(\"custo\");\n        projeto = (Projeto) params.get(\"projeto\");\n        stage = (Stage) params.get(\"modalStage\");\n        if(null != custo.getCustoTecnicoPlanejado()){\n            tfCustoPlanejado.setText(String.valueOf(custo.getCustoTecnicoPlanejado()));\n        }else{\n            tfCustoPlanejado.setText(\"0.0\");\n        }\n        if(null != custo.getCustoTecnicoRealizado()){\n            tfCustoRealizado.setText(String.valueOf(custo.getCustoTecnicoRealizado()));\n        }else{\n            tfCustoRealizado.setText(\"0.0\");\n        }\n    }\n    @FXML\n    private void salvarCusto() {\n        custo.setDtInclusao(dtInclusao);\n        custo.setProjeto(projeto);\n        if(StringUtil.isEmpty(tfCustoPlanejado.getText())){\n            custo.setCustoTecnicoPlanejado(0.0);\n        }else{\n            String auxPlanejado = tfCustoPlanejado.getText();\n            auxPlanejado.replaceAll(\"[,]*[.]*\", \"\");\n            custo.setCustoTecnicoPlanejado(DoubleConverter.stringToDouble(auxPlanejado));\n        }\n        if(StringUtil.isEmpty(tfCustoRealizado.getText())){\n            custo.setCustoTecnicoRealizado(0.0);\n        }else{\n            String auxRealizado = tfCustoRealizado.getText();\n            auxRealizado.replaceAll(\"[,]*[.]*\", \"\");\n            custo.setCustoTecnicoRealizado(DoubleConverter.stringToDouble(auxRealizado));\n        }\n        if(null == custo.getId()){\n            CustoDAO.getInstance().salvar(custo);\n            new Alert(Alert.AlertType.INFORMATION, \"Custo cadastro com sucesso.\").show();\n            stage.close();\n        }else{\n            CustoDAO.getInstance().editar(custo);\n            new Alert(Alert.AlertType.INFORMATION, \"Custo atualizado com sucesso.\").show();\n            stage.close();\n        }\n        params.put(\"CustoAux\", custo); \n    }\n"]], "pred": {"ppl": 1.5747674703598022, "ppl_lower": 1.8143727779388428, "ppl/lowercase_ppl": -1.311891279190088, "ppl/zlib": 0.0005386804549362532, "Min_5.0% Prob": 5.2970411724514435, "Min_10.0% Prob": 3.773001782099406, "Min_20.0% Prob": 2.193182282437936, "Min_30.0% Prob": 1.4991497241837137, "Min_40.0% Prob": 1.1337046950093332, "Min_50.0% Prob": 0.9080910591457952, "Min_60.0% Prob": 0.756838109002702}}
{"hexsha": "bfa21c6287378aad25b269bc6fd85bd158537822", "ext": "java", "lang": "Java", "content": "@RestController\npublic class OrderController {\n\n\t@Autowired\n\tprivate OrderRepository orders;\n\n\t@Autowired\n\tprivate OrdersSource orderSource;\n\n\t@Value(\"${originator}\")\n\tprivate String originator;\n\n\t@RequestMapping(value = \"/orders\", method = RequestMethod.GET, produces = { \"application/json\" })\n\t@ResponseStatus(HttpStatus.OK)\n\tpublic Iterable<Order> getOrder() {\n\n\t\tIterable<Order> orderList = orders.findAll();\n\n\t\treturn orderList;\n\t}\n\n\t@RequestMapping(method = RequestMethod.POST)\n\tpublic ResponseEntity<Order> add(@RequestBody Order input) {\n\n\t\torders.save(input);\n\n\t\t// place order on Kinesis Stream\n\t\torderSource.sendOrder(new Event(input, \"ORDER\", originator));\n\n\t\treturn new ResponseEntity<Order>(input, HttpStatus.OK);\n\t}\n\n}", "class_id": 0, "repo": "ccshih/spring-cloud-stream-samples", "file": "kinesis-samples/kinesis-produce-consume/src/main/java/demo/controller/OrderController.java", "last_update_at": "2018-11-23T11:56:53+00:00", "question_id": "bfa21c6287378aad25b269bc6fd85bd158537822", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestController\npublic class OrderController {\n\t@Autowired\n\tprivate OrderRepository orders;\n\t@Autowired\n\tprivate OrdersSource orderSource;\n\t@Value(\"${originator}\")\n\tprivate String originator;\n\t@RequestMapping(value = \"/orders\", method = RequestMethod.GET, produces = { \"application/json\" })\n\t@ResponseStatus(HttpStatus.OK)\n\tpublic Iterable<Order> getOrder() {\n\t\tIterable<Order> orderList = orders.findAll();\n\t\treturn orderList;\n\t}\n\t@RequestMapping(method = RequestMethod.POST)\n\tpublic ResponseEntity<Order> add(@RequestBody Order input) {\n\t\torders.save(input);\n\t\t// place order on Kinesis Stream\n\t\torderSource.sendOrder(new Event(input, \"ORDER\", originator));\n\t\treturn new ResponseEntity<Order>(input, HttpStatus.OK);\n\t}\n"]], "pred": {"ppl": 2.3253142833709717, "ppl_lower": 2.795919179916382, "ppl/lowercase_ppl": -1.2184091673376523, "ppl/zlib": 0.0022993329851426275, "Min_5.0% Prob": 7.144936734979803, "Min_10.0% Prob": 5.405845978043296, "Min_20.0% Prob": 3.6762304729885527, "Min_30.0% Prob": 2.6914129016153954, "Min_40.0% Prob": 2.0831519055825014, "Min_50.0% Prob": 1.6833315857016204, "Min_60.0% Prob": 1.4074035141426717}}
{"hexsha": "3e01af8ee1e25334cbecf840bab9b7929ef585ed", "ext": "java", "lang": "Java", "content": "final class cZ\n  implements View.OnClickListener\n{\n  cZ(SettingWidget paramSettingWidget)\n  {\n  }\n\n  public final void onClick(View paramView)\n  {\n    SettingWidget.d(this.a).setSelected(false);\n    SettingWidget.e(this.a).setSelected(false);\n    SettingWidget.f(this.a).setSelected(true);\n    SettingWidget.b(this.a).a(3);\n    SettingWidget.g(this.a).a();\n  }\n}", "class_id": 0, "repo": "clilystudio/NetBook", "file": "allsrc/com/ushaqi/zhuishushenqi/reader/cZ.java", "last_update_at": "2018-02-04T12:23:55+00:00", "question_id": "3e01af8ee1e25334cbecf840bab9b7929ef585ed", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["final class cZ\n  implements View.OnClickListener\n{\n  cZ(SettingWidget paramSettingWidget)\n  {\n  }\n  public final void onClick(View paramView)\n  {\n    SettingWidget.d(this.a).setSelected(false);\n    SettingWidget.e(this.a).setSelected(false);\n    SettingWidget.f(this.a).setSelected(true);\n    SettingWidget.b(this.a).a(3);\n    SettingWidget.g(this.a).a();\n  }\n"]], "pred": {"ppl": 2.872035264968872, "ppl_lower": 3.7023820877075195, "ppl/lowercase_ppl": -1.2407113288114708, "ppl/zlib": 0.006206005470585153, "Min_5.0% Prob": 8.137518882751465, "Min_10.0% Prob": 6.794027209281921, "Min_20.0% Prob": 4.629420847892761, "Min_30.0% Prob": 3.3993621565200187, "Min_40.0% Prob": 2.6061331227421762, "Min_50.0% Prob": 2.120757372328831, "Min_60.0% Prob": 1.7576044901708763}}
{"hexsha": "93bb1fc99291496fee9c267997d2a5d2a61bf52a", "ext": "java", "lang": "Java", "content": "public class ConfigHandler {\r\n\t\r\n\tpublic static boolean enable_limestone_gen ;\r\n\tpublic static boolean enable_marblestone_gen;\r\n\t\r\n\tpublic static boolean enable_demonite_gen;\r\n\tpublic static boolean enable_feliron_ore_gen;\r\n\t\r\n\tpublic static int limestone_gen_chance;\r\n\tpublic static int marblestone_gen_chance;\r\n\tpublic static int demonite_gen_chance;\r\n\tpublic static int feliron_ore_gen_chance;\r\n\t\r\n\t\r\n\tpublic static Configuration config;\r\n\t\r\n\tpublic static void init(File file) {\r\n\t\t\r\n\t\tconfig = new Configuration(file);\r\n\t\tsyncConfig();\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void syncConfig() {\r\n\t\t\r\n\t\tString category = \"ORE & STONE GEN\";\r\n\t\tconfig.addCustomCategoryComment(category, \"Ore & stone generators\");\r\n\t\tenable_limestone_gen = config.getBoolean(\"Enable Limestone gen?\", category, true, \"true for generating limestone in the world\");\r\n\t\tenable_marblestone_gen = config.getBoolean(\"Enable Marblestone gen\", category, true, \"true for generating marblestone in the world\");\r\n\t\t\r\n\t\tenable_demonite_gen = config.getBoolean(\"Enable Demonite gen?\", category, true, \"true for generating demonite in the nether\");\r\n\t\tenable_feliron_ore_gen = config.getBoolean(\"Enable Feliron Ore gen?\", category, true, \"true for generating felrion ore in the nether\");\r\n\t\t\r\n\t\t\r\n\t\tcategory = \"ORE GEN SETTINGS\";\r\n\t\tconfig.addCustomCategoryComment(category, \"Ore & stone generating chance settings\");\r\n\t\tlimestone_gen_chance = config.getInt(\"Limestone generation chance\", category, 25, 1, 50, \"increase for more limestone generation\");\r\n\t\tmarblestone_gen_chance = config.getInt(\"Marblestone generation chance\", category, 25, 1, 50, \"increase for more marblestone generation\");\r\n\t\t\r\n\t\tdemonite_gen_chance = config.getInt(\"Demonite generation chance\", category, 25, 1, 50, \"increase for more demonite generation\");\r\n\t\tfeliron_ore_gen_chance = config.getInt(\"Feliron Ore generation chance\", category, 25, 1, 50, \"increase for more feliron ore generation\");\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "winnetrie83/timsexpansionmod", "file": "main/java/com/winnetrie/timsexpansionmod/util/ConfigHandler.java", "last_update_at": "2018-03-17T15:03:48+00:00", "question_id": "93bb1fc99291496fee9c267997d2a5d2a61bf52a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ConfigHandler {\r\n\t\r\n\tpublic static boolean enable_limestone_gen ;\r\n\tpublic static boolean enable_marblestone_gen;\r\n\t\r\n\tpublic static boolean enable_demonite_gen;\r\n\tpublic static boolean enable_feliron_ore_gen;\r\n\t\r\n\tpublic static int limestone_gen_chance;\r\n\tpublic static int marblestone_gen_chance;\r\n\tpublic static int demonite_gen_chance;\r\n\tpublic static int feliron_ore_gen_chance;\r\n\t\r\n\t\r\n\tpublic static Configuration config;\r\n\t\r\n\tpublic static void init(File file) {\r\n\t\t\r\n\t\tconfig = new Configuration(file);\r\n\t\tsyncConfig();\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void syncConfig() {\r\n\t\t\r\n\t\tString category = \"ORE & STONE GEN\";\r\n\t\tconfig.addCustomCategoryComment(category, \"Ore & stone generators\");\r\n\t\tenable_limestone_gen = config.getBoolean(\"Enable Limestone gen?\", category, true, \"true for generating limestone in the world\");\r\n\t\tenable_marblestone_gen = config.getBoolean(\"Enable Marblestone gen\", category, true, \"true for generating marblestone in the world\");\r\n\t\t\r\n\t\tenable_demonite_gen = config.getBoolean(\"Enable Demonite gen?\", category, true, \"true for generating demonite in the nether\");\r\n\t\tenable_feliron_ore_gen = config.getBoolean(\"Enable Feliron Ore gen?\", category, true, \"true for generating felrion ore in the nether\");\r\n\t\t\r\n\t\t\r\n\t\tcategory = \"ORE GEN SETTINGS\";\r\n\t\tconfig.addCustomCategoryComment(category, \"Ore & stone generating chance settings\");\r\n\t\tlimestone_gen_chance = config.getInt(\"Limestone generation chance\", category, 25, 1, 50, \"increase for more limestone generation\");\r\n\t\tmarblestone_gen_chance = config.getInt(\"Marblestone generation chance\", category, 25, 1, 50, \"increase for more marblestone generation\");\r\n\t\t\r\n\t\tdemonite_gen_chance = config.getInt(\"Demonite generation chance\", category, 25, 1, 50, \"increase for more demonite generation\");\r\n\t\tfeliron_ore_gen_chance = config.getInt(\"Feliron Ore generation chance\", category, 25, 1, 50, \"increase for more feliron ore generation\");\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n"]], "pred": {"ppl": 1.6531645059585571, "ppl_lower": 1.7502071857452393, "ppl/lowercase_ppl": -1.1134748810149373, "ppl/zlib": 0.000987605763307048, "Min_5.0% Prob": 5.768708474934101, "Min_10.0% Prob": 4.081022558733821, "Min_20.0% Prob": 2.41142899193801, "Min_30.0% Prob": 1.6565927559277043, "Min_40.0% Prob": 1.2519382186947041, "Min_50.0% Prob": 1.0047918814409058, "Min_60.0% Prob": 0.8384995069985356}}
{"hexsha": "1e5133262aa9bb128f3b72d2202e00490c274b3b", "ext": "java", "lang": "Java", "content": "public class NimbusProvider {\n\n  public static void main(String[] args) {\n    String token = null;\n    try {\n      token = new NimbusProvider().create();\n      System.out.println(\"Token: \" + token);\n    } catch (JOSEException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public String create() throws JOSEException {\n\n// Create RSA-signer with the private key\n    JWSSigner signer = new RSASSASigner(Alice.getPrivateKey());\n\n// Prepare JWT with claims set\n    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()\n            .subject(\"alice\")\n            .issueTime(new Date())\n            .issuer(\"http://example.com\")\n            .build();\n\n    String keyId = \"id-0815\";\n    JWSHeader header = new JWSHeader(JWSAlgorithm.RS256, null, null, null, null, null, null, null, null, null, keyId, null, null);\n    SignedJWT signedJWT = new SignedJWT(header, claimsSet);\n\n    signedJWT.sign(signer);\n\n    return signedJWT.serialize();\n  }\n\n}", "class_id": 0, "repo": "nitram509/decentral-authentication-playground", "file": "java/src/main/java/nimbus_jose_jwt/private_public/NimbusProvider.java", "last_update_at": "2018-11-12T03:53:33+00:00", "question_id": "1e5133262aa9bb128f3b72d2202e00490c274b3b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NimbusProvider {\n  public static void main(String[] args) {\n    String token = null;\n    try {\n      token = new NimbusProvider().create();\n      System.out.println(\"Token: \" + token);\n    } catch (JOSEException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  public String create() throws JOSEException {\n// Create RSA-signer with the private key\n    JWSSigner signer = new RSASSASigner(Alice.getPrivateKey());\n// Prepare JWT with claims set\n    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()\n            .subject(\"alice\")\n            .issueTime(new Date())\n            .issuer(\"http://example.com\")\n            .build();\n    String keyId = \"id-0815\";\n    JWSHeader header = new JWSHeader(JWSAlgorithm.RS256, null, null, null, null, null, null, null, null, null, keyId, null, null);\n    SignedJWT signedJWT = new SignedJWT(header, claimsSet);\n    signedJWT.sign(signer);\n    return signedJWT.serialize();\n  }\n"]], "pred": {"ppl": 1.934008002281189, "ppl_lower": 2.6757071018218994, "ppl/lowercase_ppl": -1.4921495415124597, "ppl/zlib": 0.001446479242777883, "Min_5.0% Prob": 5.5834885597229, "Min_10.0% Prob": 4.254124295326971, "Min_20.0% Prob": 2.8617285336217573, "Min_30.0% Prob": 2.105293111775511, "Min_40.0% Prob": 1.6315274864675537, "Min_50.0% Prob": 1.3175227636291136, "Min_60.0% Prob": 1.1013196789389175}}
{"hexsha": "ee3c24d43bc9e3d5e754f9cdab0e10acb7cf17f0", "ext": "java", "lang": "Java", "content": "public class AutoIntake extends Command {\n    private double speed;\n\n    private final int DONE_COUNT_MAX = 50;\n    private int currentDoneCount = 0;\n\n    private Command blinkLimelight = new BlinkLimelight(2);\n    private Command JitterIntake = new JitterIntake(1);\n\n    public AutoIntake(double speed) {\n        this.speed = speed;\n    }\n\n    public AutoIntake(double speed, double timeout) {\n        super(timeout);\n        this.speed = speed;\n        requires(Robot.intake);\n    }\n\n\n    // Called just before this Command runs the first time\n    @Override\n    protected void initialize() {\n        Robot.intake.setRampDown();\n        Robot.intake.setIntakePistonsExtend();\n        Robot.shooter.setCubePistonDown();\n        Robot.shooter.setShooterDown();\n    }\n\n    // Called repeatedly when this Command is scheduled to run\n    @Override\n    protected void execute() {\n        Robot.intake.spinBothIntake(speed);\n        Robot.intake.spinBothTransfer(speed);\n\n    }\n\n    // Make this return true when this Command no longer needs to run execute()\n    @Override\n    protected boolean isFinished() {\n        if (Robot.intake.isBlockHalfWayLoaded()) {\n            currentDoneCount++;\n        } else {\n            currentDoneCount = 0;\n        }\n        if (currentDoneCount > DONE_COUNT_MAX) {\n            currentDoneCount = 0;\n            System.out.println(\"TRUE\");\n            return true;\n        }\n        return isTimedOut();\n\n    }\n\n    // Called once after isFinished returns true\n    @Override\n    protected void end() {\n        blinkLimelight.start();\n//        JitterIntake.start();\n    }\n\n    // Called when another command which requires one or more of the same\n    // subsystems is scheduled to run\n    @Override\n    protected void interrupted() {\n    }\n\n}", "class_id": 0, "repo": "Test2220/PowerUp_2018_Repo", "file": "src/main/java/frc/team2220/robot/commands/mechanisms/intake/AutoIntake.java", "last_update_at": "2018-02-04T02:31:25+00:00", "question_id": "ee3c24d43bc9e3d5e754f9cdab0e10acb7cf17f0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AutoIntake extends Command {\n    private double speed;\n    private final int DONE_COUNT_MAX = 50;\n    private int currentDoneCount = 0;\n    private Command blinkLimelight = new BlinkLimelight(2);\n    private Command JitterIntake = new JitterIntake(1);\n    public AutoIntake(double speed) {\n        this.speed = speed;\n    }\n    public AutoIntake(double speed, double timeout) {\n        super(timeout);\n        this.speed = speed;\n        requires(Robot.intake);\n    }\n    // Called just before this Command runs the first time\n    @Override\n    protected void initialize() {\n        Robot.intake.setRampDown();\n        Robot.intake.setIntakePistonsExtend();\n        Robot.shooter.setCubePistonDown();\n        Robot.shooter.setShooterDown();\n    }\n    // Called repeatedly when this Command is scheduled to run\n    @Override\n    protected void execute() {\n        Robot.intake.spinBothIntake(speed);\n        Robot.intake.spinBothTransfer(speed);\n    }\n    // Make this return true when this Command no longer needs to run execute()\n    @Override\n    protected boolean isFinished() {\n        if (Robot.intake.isBlockHalfWayLoaded()) {\n            currentDoneCount++;\n        } else {\n            currentDoneCount = 0;\n        }\n        if (currentDoneCount > DONE_COUNT_MAX) {\n            currentDoneCount = 0;\n            System.out.println(\"TRUE\");\n            return true;\n        }\n        return isTimedOut();\n    }\n    // Called once after isFinished returns true\n    @Override\n    protected void end() {\n        blinkLimelight.start();\n//        JitterIntake.start();\n    }\n    // Called when another command which requires one or more of the same\n    // subsystems is scheduled to run\n    @Override\n    protected void interrupted() {\n    }\n"]], "pred": {"ppl": 1.9075595140457153, "ppl_lower": 2.4099133014678955, "ppl/lowercase_ppl": -1.3619652431103206, "ppl/zlib": 0.0010138535066149615, "Min_5.0% Prob": 6.234474328848032, "Min_10.0% Prob": 4.701485124918131, "Min_20.0% Prob": 2.964101457251952, "Min_30.0% Prob": 2.1112314274486823, "Min_40.0% Prob": 1.6056688930301999, "Min_50.0% Prob": 1.2893243244419303, "Min_60.0% Prob": 1.0757724609112558}}
{"hexsha": "cf47c0639a563db276542ee2c7637a9940717e82", "ext": "java", "lang": "Java", "content": "@Getter\npublic class MetricSuite {\n\n    private PatternMapper patternMapper;\n    private List<RBMLMapping> rbmlStructuralMappings;\n    private SPS sps;\n    private List<RBMLMapping> rbmlBehavioralMappings;\n    private IPS ips;\n\n    //number of participating classes\n    private int numParticipatingClasses = 0;\n\n    //number of conforming structural roles, and nonconforming structural roles, respectively\n    private int numConformingStructuralRoles = 0;\n    private int numNonConformingStructuralRoles = 0;\n\n    //number of conforming and nonconforming behavioral roles.\n    private int numConformingBehavioralRoles = 0;\n    private int numNonConformingBehavioralRoles = 0;\n\n    private int numConformingRolesTotal = 0;\n    private int numNonConformingRolesTotal = 0;\n\n    //ssize2 metric for pattern instance (sum of fields and methods for all classes in a pattern)\n    private int ssize2 = 0;\n\n    //afferent (incoming) coupling to pattern as a whole.\n    private int afferentCoupling = 0;\n\n    //efferent (outgoing) coupling from pattern to anything not pattern-related\n    private int efferentCoupling = 0;\n\n    //coupling between pattern objects.\n    private int couplingBetweenPatternClasses = 0;\n\n    //pattern integrity, defined as (numConformingStructuralRoles)/(numConformingStructuralRoles + numNonConformingStructuralRoles)\n    private String patternStructuralIntegrity = \"\";\n    private String patternBehavioralIntegrity = \"\";\n    private String patternIntegrity = \"\";\n\n    //pattern instability, defined as (efferentCoupling) / (afferentCoupling + efferentCoupling)\n    private String patternInstability = \"\";\n\n    public MetricSuite(ConformanceResults conformanceResults){\n        this.patternMapper = conformanceResults.getPatternMapper();\n        this.sps = conformanceResults.getSps();\n        this.rbmlStructuralMappings = conformanceResults.getRbmlStructureMappings();\n        this.ips = conformanceResults.getIps();\n        this.rbmlBehavioralMappings = conformanceResults.getRbmlBehaviorMappings();\n        calculate();\n    }\n\n    private void calculate(){\n        calcNumParticipatingClasses();\n        calcNumConformingStructuralRoles();\n        calcNumNonConformingStructuralRoles();\n        //behavioral roles being done in 1 method now\n        calcNumConformingBehavioralRoles();\n        calcNumConformingRolesTotal();\n        calcNumNonConformingRolesTotal();\n        calcSSize2();\n        calcAfferentCoupling();\n        calcEfferentCoupling();\n        calcCouplingPatternClasses();\n        calcPatternStructuralIntegrity();\n        calcPatternBehavioralIntegrity();\n        calcPatternIntegrity();\n        calcPatternInstability();\n    }\n\n    private void calcNumParticipatingClasses(){\n        numParticipatingClasses = patternMapper.getAllParticipatingClasses().size();\n    }\n\n    private void calcNumConformingStructuralRoles(){\n        for (RBMLMapping rbmlMapping : rbmlStructuralMappings){\n            for (Pair<String, UMLClassifier> classifier : patternMapper.getClassifierModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(classifier.getValue())){\n                    //found conforming classifier role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Pair<String, UMLOperation> operation : patternMapper.getOperationModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(operation.getValue())){\n                    //found conforming operation role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Pair<String, UMLAttribute> attribute : patternMapper.getAttributeModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(attribute.getValue())){\n                    //found conforming attribute role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship association : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){\n                if (rbmlMapping.getUmlArtifact().equals(association)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship generalization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.GENERALIZATION)){\n                if (rbmlMapping.getUmlArtifact().equals(generalization)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship dependency : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.DEPENDENCY)){\n                if (rbmlMapping.getUmlArtifact().equals(dependency)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship realization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.REALIZATION)){\n                if (rbmlMapping.getUmlArtifact().equals(realization)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n        }\n    }\n\n    private void calcNumNonConformingStructuralRoles(){\n        for (Role role : sps.getAllRoles()){\n            boolean roleHasBeenMapped = false;\n            for (RBMLMapping rbmlMapping : rbmlStructuralMappings){\n                if (role.equals(rbmlMapping.getRole())){\n                    roleHasBeenMapped = true;\n                }\n            }\n            if (!roleHasBeenMapped){\n                numNonConformingStructuralRoles++;\n            }\n        }\n    }\n\n    private void calcNumConformingBehavioralRoles(){\n        List<InteractionRole> seenAlready = new ArrayList<>();\n        for (InteractionRole interactionRole : ips.getInteractions()){\n            for (RBMLMapping rbmlMapping : rbmlBehavioralMappings){\n                if (interactionRole.equals(rbmlMapping.getRole())){\n                    if (!seenAlready.contains(interactionRole)){\n                        seenAlready.add(interactionRole);\n                    }\n                }\n            }\n        }\n        numConformingBehavioralRoles = seenAlready.size();\n        numNonConformingBehavioralRoles = ips.getInteractions().size() - seenAlready.size();\n    }\n    \n    private void calcNumConformingRolesTotal(){\n        numConformingRolesTotal = numConformingBehavioralRoles + numConformingStructuralRoles;\n\n    }\n\n    private void calcNumNonConformingRolesTotal(){\n        numNonConformingRolesTotal = numNonConformingBehavioralRoles + numNonConformingStructuralRoles;\n    }\n\n    private void calcSSize2(){\n        for (Pair<String, UMLClassifier> umlClassifierPair : patternMapper.getClassifierModelBlocks()){\n            UMLClassifier umlClassifier = umlClassifierPair.getValue();\n            ssize2 += umlClassifier.getAttributes().size();\n            ssize2 += umlClassifier.getOperations().size();\n        }\n    }\n\n    private void calcAfferentCoupling(){\n        //afferent means the value of the pair is a pattern class. (nonpattern_class -> pattern_class)\n        afferentCoupling = patternMapper.getUniqueAfferentClassifiers().size();\n\n    }\n\n    private void calcEfferentCoupling(){\n        //efferent means the key of the pair is a pattern class. (pattern_class -> nonpattern_class)\n        efferentCoupling = patternMapper.getUniqueEfferentClassifiers().size();\n    }\n\n    private void calcCouplingPatternClasses(){\n        for (Relationship classifierPair : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){\n            if (isClassifierInPatternInstance(classifierPair.getFrom()) && isClassifierInPatternInstance(classifierPair.getTo())){\n                couplingBetweenPatternClasses++;\n            }\n        }\n    }\n\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternStructuralIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingStructuralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles);\n        patternStructuralIntegrity = df2.format(unformattedIntegrity);\n    }\n\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternBehavioralIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingBehavioralRoles) / (numConformingBehavioralRoles + numNonConformingBehavioralRoles);\n        patternBehavioralIntegrity = df2.format(unformattedIntegrity);\n    }\n\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingStructuralRoles + (double) numConformingBehavioralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles + numConformingBehavioralRoles + numNonConformingBehavioralRoles);\n        patternIntegrity = df2.format(unformattedIntegrity);\n    }\n\n\n    private void calcPatternInstability(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        if (afferentCoupling + efferentCoupling != 0){\n            double unformattedInstability = ((double)efferentCoupling) / (afferentCoupling + efferentCoupling);\n            patternInstability = df2.format(unformattedInstability);\n        }else{\n            //would get a divide by 0 error here\n            //this happens when a pattern-class only has dependencies on 3rd party libs, and no class depends on this class...\n            //happens a few times with Template method implementations\n            patternInstability = \"0\";\n        }\n\n    }\n\n    private boolean isClassifierInPatternInstance(UMLClassifier tester){\n        for (Pair<String, UMLClassifier> umlClassifierPair: patternMapper.getClassifierModelBlocks()){\n            if (umlClassifierPair.getValue().equals(tester)){\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    public String getSummary(){\n        String delim = \"\\t\";\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(Main.projectID + delim);\n        stringBuilder.append(patternMapper.getPi().getSoftwareVersion().getVersionNum() + delim);\n        stringBuilder.append(patternMapper.getPi().getPatternType() + delim);\n        stringBuilder.append(patternMapper.getPi().getUniqueID() + delim);\n        stringBuilder.append(this.getNumParticipatingClasses() + delim);\n        stringBuilder.append(this.getNumConformingStructuralRoles() + delim);\n        stringBuilder.append(this.getNumNonConformingStructuralRoles() + delim);\n        stringBuilder.append(this.getNumConformingBehavioralRoles() + delim);\n        stringBuilder.append(this.getNumNonConformingBehavioralRoles() + delim);\n        stringBuilder.append(this.getNumConformingRolesTotal() + delim);\n        stringBuilder.append(this.getNumNonConformingRolesTotal() + delim);\n        stringBuilder.append(this.getSsize2() + delim);\n        stringBuilder.append(this.getPatternMapper().getPatternMembers().size() + delim);\n        stringBuilder.append(this.getAfferentCoupling() + delim);\n        stringBuilder.append(this.getEfferentCoupling() + delim);\n        stringBuilder.append(this.getCouplingBetweenPatternClasses() + delim);\n        stringBuilder.append(this.getPatternStructuralIntegrity() + delim);\n        stringBuilder.append(this.getPatternBehavioralIntegrity() + delim);\n        stringBuilder.append(this.getPatternIntegrity() + delim);\n        stringBuilder.append(this.getPatternInstability() + delim);\n        return stringBuilder.toString();\n    }\n\n}", "class_id": 0, "repo": "MSUSEL/msusel-pattern-behavior", "file": "src/main/java/com/derek/MetricSuite.java", "last_update_at": "2018-10-23T15:57:35+00:00", "question_id": "cf47c0639a563db276542ee2c7637a9940717e82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Getter\npublic class MetricSuite {\n    private PatternMapper patternMapper;\n    private List<RBMLMapping> rbmlStructuralMappings;\n    private SPS sps;\n    private List<RBMLMapping> rbmlBehavioralMappings;\n    private IPS ips;\n    //number of participating classes\n    private int numParticipatingClasses = 0;\n    //number of conforming structural roles, and nonconforming structural roles, respectively\n    private int numConformingStructuralRoles = 0;\n    private int numNonConformingStructuralRoles = 0;\n    //number of conforming and nonconforming behavioral roles.\n    private int numConformingBehavioralRoles = 0;\n    private int numNonConformingBehavioralRoles = 0;\n    private int numConformingRolesTotal = 0;\n    private int numNonConformingRolesTotal = 0;\n    //ssize2 metric for pattern instance (sum of fields and methods for all classes in a pattern)\n    private int ssize2 = 0;\n    //afferent (incoming) coupling to pattern as a whole.\n    private int afferentCoupling = 0;\n    //efferent (outgoing) coupling from pattern to anything not pattern-related\n    private int efferentCoupling = 0;\n    //coupling between pattern objects.\n    private int couplingBetweenPatternClasses = 0;\n    //pattern integrity, defined as (numConformingStructuralRoles)/(numConformingStructuralRoles + numNonConformingStructuralRoles)\n    private String patternStructuralIntegrity = \"\";\n    private String patternBehavioralIntegrity = \"\";\n    private String patternIntegrity = \"\";\n    //pattern instability, defined as (efferentCoupling) / (afferentCoupling + efferentCoupling)\n    private String patternInstability = \"\";\n    public MetricSuite(ConformanceResults conformanceResults){\n        this.patternMapper = conformanceResults.getPatternMapper();\n        this.sps = conformanceResults.getSps();\n        this.rbmlStructuralMappings = conformanceResults.getRbmlStructureMappings();\n        this.ips = conformanceResults.getIps();\n        this.rbmlBehavioralMappings = conformanceResults.getRbmlBehaviorMappings();\n        calculate();\n    }\n    private void calculate(){\n        calcNumParticipatingClasses();\n        calcNumConformingStructuralRoles();\n        calcNumNonConformingStructuralRoles();\n        //behavioral roles being done in 1 method now\n        calcNumConformingBehavioralRoles();\n        calcNumConformingRolesTotal();\n        calcNumNonConformingRolesTotal();\n        calcSSize2();\n        calcAfferentCoupling();\n        calcEfferentCoupling();\n        calcCouplingPatternClasses();\n        calcPatternStructuralIntegrity();\n        calcPatternBehavioralIntegrity();\n        calcPatternIntegrity();\n        calcPatternInstability();\n    }\n    private void calcNumParticipatingClasses(){\n        numParticipatingClasses = patternMapper.getAllParticipatingClasses().size();\n    }\n    private void calcNumConformingStructuralRoles(){\n        for (RBMLMapping rbmlMapping : rbmlStructuralMappings){\n            for (Pair<String, UMLClassifier> classifier : patternMapper.getClassifierModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(classifier.getValue())){\n                    //found conforming classifier role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Pair<String, UMLOperation> operation : patternMapper.getOperationModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(operation.getValue())){\n                    //found conforming operation role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Pair<String, UMLAttribute> attribute : patternMapper.getAttributeModelBlocks()){\n                if (rbmlMapping.getUmlArtifact().equals(attribute.getValue())){\n                    //found conforming attribute role\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship association : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){\n                if (rbmlMapping.getUmlArtifact().equals(association)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship generalization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.GENERALIZATION)){\n                if (rbmlMapping.getUmlArtifact().equals(generalization)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship dependency : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.DEPENDENCY)){\n                if (rbmlMapping.getUmlArtifact().equals(dependency)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n            for (Relationship realization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.REALIZATION)){\n                if (rbmlMapping.getUmlArtifact().equals(realization)){\n                    //will be a pair.\n                    numConformingStructuralRoles++;\n                }\n            }\n        }\n    }\n    private void calcNumNonConformingStructuralRoles(){\n        for (Role role : sps.getAllRoles()){\n            boolean roleHasBeenMapped = false;\n            for (RBMLMapping rbmlMapping : rbmlStructuralMappings){\n                if (role.equals(rbmlMapping.getRole())){\n                    roleHasBeenMapped = true;\n                }\n            }\n            if (!roleHasBeenMapped){\n                numNonConformingStructuralRoles++;\n            }\n        }\n    }\n    private void calcNumConformingBehavioralRoles(){\n        List<InteractionRole> seenAlready = new ArrayList<>();\n        for (InteractionRole interactionRole : ips.getInteractions()){\n            for (RBMLMapping rbmlMapping : rbmlBehavioralMappings){\n                if (interactionRole.equals(rbmlMapping.getRole())){\n                    if (!seenAlready.contains(interactionRole)){\n                        seenAlready.add(interactionRole);\n                    }\n                }\n            }\n        }\n        numConformingBehavioralRoles = seenAlready.size();\n        numNonConformingBehavioralRoles = ips.getInteractions().size() - seenAlready.size();\n    }\n    private void calcNumConformingRolesTotal(){\n        numConformingRolesTotal = numConformingBehavioralRoles + numConformingStructuralRoles;\n    }\n    private void calcNumNonConformingRolesTotal(){\n        numNonConformingRolesTotal = numNonConformingBehavioralRoles + numNonConformingStructuralRoles;\n    }\n    private void calcSSize2(){\n        for (Pair<String, UMLClassifier> umlClassifierPair : patternMapper.getClassifierModelBlocks()){\n            UMLClassifier umlClassifier = umlClassifierPair.getValue();\n            ssize2 += umlClassifier.getAttributes().size();\n            ssize2 += umlClassifier.getOperations().size();\n        }\n    }\n    private void calcAfferentCoupling(){\n        //afferent means the value of the pair is a pattern class. (nonpattern_class -> pattern_class)\n        afferentCoupling = patternMapper.getUniqueAfferentClassifiers().size();\n    }\n    private void calcEfferentCoupling(){\n        //efferent means the key of the pair is a pattern class. (pattern_class -> nonpattern_class)\n        efferentCoupling = patternMapper.getUniqueEfferentClassifiers().size();\n    }\n    private void calcCouplingPatternClasses(){\n        for (Relationship classifierPair : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){\n            if (isClassifierInPatternInstance(classifierPair.getFrom()) && isClassifierInPatternInstance(classifierPair.getTo())){\n                couplingBetweenPatternClasses++;\n            }\n        }\n    }\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternStructuralIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingStructuralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles);\n        patternStructuralIntegrity = df2.format(unformattedIntegrity);\n    }\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternBehavioralIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingBehavioralRoles) / (numConformingBehavioralRoles + numNonConformingBehavioralRoles);\n        patternBehavioralIntegrity = df2.format(unformattedIntegrity);\n    }\n    //defined as percentage of conforming pattern roles out of whole.\n    private void calcPatternIntegrity(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        double unformattedIntegrity = ((double) numConformingStructuralRoles + (double) numConformingBehavioralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles + numConformingBehavioralRoles + numNonConformingBehavioralRoles);\n        patternIntegrity = df2.format(unformattedIntegrity);\n    }\n    private void calcPatternInstability(){\n        DecimalFormat df2 = new DecimalFormat(\"#.##\");\n        if (afferentCoupling + efferentCoupling != 0){\n            double unformattedInstability = ((double)efferentCoupling) / (afferentCoupling + efferentCoupling);\n            patternInstability = df2.format(unformattedInstability);\n        }else{\n            //would get a divide by 0 error here\n            //this happens when a pattern-class only has dependencies on 3rd party libs, and no class depends on this class...\n            //happens a few times with Template method implementations\n            patternInstability = \"0\";\n        }\n    }\n    private boolean isClassifierInPatternInstance(UMLClassifier tester){\n        for (Pair<String, UMLClassifier> umlClassifierPair: patternMapper.getClassifierModelBlocks()){\n            if (umlClassifierPair.getValue().equals(tester)){\n                return true;\n            }\n        }\n        return false;\n    }\n    public String getSummary(){\n        String delim = \"\\t\";\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(Main.projectID + delim);\n        stringBuilder.append(patternMapper.getPi().getSoftwareVersion().getVersionNum() + delim);\n        stringBuilder.append(patternMapper.getPi().getPatternType() + delim);\n        stringBuilder.append(patternMapper.getPi().getUniqueID() + delim);\n        stringBuilder.append(this.getNumParticipatingClasses() + delim);\n        stringBuilder.append(this.getNumConformingStructuralRoles() + delim);\n        stringBuilder.append(this.getNumNonConformingStructuralRoles() + delim);\n        stringBuilder.append(this.getNumConformingBehavioralRoles() + delim);\n        stringBuilder.append(this.getNumNonConformingBehavioralRoles() + delim);\n        stringBuilder.append(this.getNumConformingRolesTotal() + delim);\n        stringBuilder.append(this.getNumNonConformingRolesTotal() + delim);\n        stringBuilder.append(this.getSsize2() + delim);\n        stringBuilder.append(this.getPatternMapper().getPatternMembers().size() + delim);\n        stringBuilder.append(this.getAfferentCoupling() + delim);\n        stringBuilder.append(this.getEfferentCoupling() + delim);\n        stringBuilder.append(this.getCouplingBetweenPatternClasses() + delim);\n        stringBuilder.append(this.getPatternStructuralIntegrity() + delim);\n        stringBuilder.append(this.getPatternBehavioralIntegrity() + delim);\n        stringBuilder.append(this.getPatternIntegrity() + delim);\n        stringBuilder.append(this.getPatternInstability() + delim);\n        return stringBuilder.toString();\n    }\n"]], "pred": {"ppl": 2.0464231967926025, "ppl_lower": 2.18597412109375, "ppl/lowercase_ppl": -1.0921221393522778, "ppl/zlib": 0.0003515431944982212, "Min_5.0% Prob": 7.333335680120132, "Min_10.0% Prob": 5.478903716685725, "Min_20.0% Prob": 3.3893554310003915, "Min_30.0% Prob": 2.354899507673348, "Min_40.0% Prob": 1.780814003044498, "Min_50.0% Prob": 1.430620218501399, "Min_60.0% Prob": 1.1940896083292405}}
{"hexsha": "c96f341573c717c518981a462ea0eb6b95407430", "ext": "java", "lang": "Java", "content": "public class BatteryFragment extends RecyclerViewFragment implements\nPopupCardView.DPopupCard.OnDPopupCardListener, SwitchCardView.DSwitchCard.OnDSwitchCardListener, SeekBarCardView.DSeekBarCard.OnDSeekBarCardListener {\n\n    private int bclFreqCount = 0, bclArraylist = 60, bclFreqValue = 0;\n    private List < Integer > Cpufreqs;\n\n    private CardViewItem.DCardView mBatteryLevelCard, mBatteryVoltageCard, mBatteryTemperature, mBatteryChargingCurrentCard, mBatteryChargingTypeCard, mBatteryHealthCard;\n\n    private SwitchCardView.DSwitchCard mForceFastChargeCard, mBatteryLedCard;\n    private SwitchCardView.DSwitchCard mBclCard, mBclHotplugCard, mColdDisablerCard;\n\n    private PopupCardView.DPopupCard mBclMaxFreqCard;\n    private PopupCardView.DPopupCard mBclHotmask;\n    private SeekBarCardView.DSeekBarCard mBclVphLowCard, mBclVphHighCard;\n\n    private SeekBarCardView.DSeekBarCard mBlxCard;\n\n    private SwitchCardView.DSwitchCard mCustomChargeRateEnableCard;\n    private SeekBarCardView.DSeekBarCard mChargingRateCard;\n\n    private SwitchCardView.DSwitchCard mC0StateCard, mC1StateCard, mC2StateCard, mC3StateCard;\n\n    private SwitchCardView.DSwitchCard mDeviceidle, mDeviceidlelight, mDeviceidledeep;\n\n    @Override\n    public void init(Bundle savedInstanceState) {\n        super.init(savedInstanceState);\n\n        if (Battery.hasBatteryLed()) BatteryLedInit();\n        batteryLevelInit();\n        batteryHealthInit();\n        batteryVoltageInit();\n        batteryChargingCurrentInit();\n        batteryTemperatureInit();\n        batteryChargingTypeInit();\n        if (Battery.hasColdDisabler()) bclColdDisablerInit();\n        if (Battery.hasForceFastCharge()) forceFastChargeInit();\n        if (Battery.hasBlx()) blxInit();\n        if (Battery.hasChargeRate()) chargerateInit();\n\n        if (Battery.hasBcl()) bclInit();\n        if (Battery.hasBclFreq()) bclMaxFreqInit();\n        if (Battery.hasBclHotMask()) bclHotmask();\n        if (Battery.hasBclVphLow()) BclVphLowInit();\n        if (Battery.hasBclVphHigh()) BclVphHighInit();\n        if (Battery.hasBclHotplug()) bclHotplugInit();\n\n        DeviceidleInit();\n        cstatesInit();\n        Update();\n    }\n\n    @Override\n    public void postInit(Bundle savedInstanceState) {\n        super.postInit(savedInstanceState);\n        if (getCount() < 4) showApplyOnBoot(false);\n    }\n\n    private void batteryLevelInit() {\n        mBatteryLevelCard = new CardViewItem.DCardView();\n        mBatteryLevelCard.setTitle(getString(R.string.battery_level));\n\n        addView(mBatteryLevelCard);\n    }\n\n    private void BatteryLedInit() {\n        mBatteryLedCard = new SwitchCardView.DSwitchCard();\n        mBatteryLedCard.setTitle(getString(R.string.battery_led));\n        mBatteryLedCard.setDescription(getString(R.string.battery_led_summary));\n        mBatteryLedCard.setChecked(Battery.getBatteryLed());\n        mBatteryLedCard.setOnDSwitchCardListener(this);\n\n        addView(mBatteryLedCard);\n    }\n\n    private void batteryVoltageInit() {\n        mBatteryVoltageCard = new CardViewItem.DCardView();\n        mBatteryVoltageCard.setTitle(getString(R.string.battery_voltage));\n\n        addView(mBatteryVoltageCard);\n    }\n\n    private void batteryTemperatureInit() {\n        mBatteryTemperature = new CardViewItem.DCardView();\n        mBatteryTemperature.setTitle(getString(R.string.battery_temperature));\n\n        addView(mBatteryTemperature);\n    }\n\n    private void batteryChargingCurrentInit() {\n        mBatteryChargingCurrentCard = new CardViewItem.DCardView();\n        mBatteryChargingCurrentCard.setTitle(getString(R.string.battery_charging_current));\n\n        addView(mBatteryChargingCurrentCard);\n    }\n\n    private void batteryChargingTypeInit() {\n        mBatteryChargingTypeCard = new CardViewItem.DCardView();\n        mBatteryChargingTypeCard.setTitle(getString(R.string.battery_charging_mode));\n\n        addView(mBatteryChargingTypeCard);\n    }\n\n    private void batteryHealthInit() {\n        mBatteryHealthCard = new CardViewItem.DCardView();\n        mBatteryHealthCard.setTitle(getString(R.string.battery_health));\n\n        addView(mBatteryHealthCard);\n    }\n\n    private void forceFastChargeInit() {\n        mForceFastChargeCard = new SwitchCardView.DSwitchCard();\n        mForceFastChargeCard.setTitle(getString(R.string.usb_fast_charge));\n        mForceFastChargeCard.setDescription(getString(R.string.usb_fast_charge_summary));\n        mForceFastChargeCard.setChecked(Battery.isForceFastChargeActive());\n        mForceFastChargeCard.setOnDSwitchCardListener(this);\n\n        addView(mForceFastChargeCard);\n    }\n\n    private void blxInit() {\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 101; i++) list.add(String.valueOf(i));\n\n        mBlxCard = new SeekBarCardView.DSeekBarCard(list);\n        mBlxCard.setTitle(getString(R.string.blx));\n        mBlxCard.setDescription(getString(R.string.blx_summary));\n        mBlxCard.setProgress(Battery.getCurBlx());\n        mBlxCard.setOnDSeekBarCardListener(this);\n\n        addView(mBlxCard);\n    }\n\n    private void chargerateInit() {\n\n        if (Battery.hasCustomChargeRateEnable()) {\n            mCustomChargeRateEnableCard = new SwitchCardView.DSwitchCard();\n            mCustomChargeRateEnableCard.setDescription(getString(R.string.custom_charge_rate));\n            mCustomChargeRateEnableCard.setChecked(Battery.isCustomChargeRateActive());\n            mCustomChargeRateEnableCard.setOnDSwitchCardListener(this);\n\n            addView(mCustomChargeRateEnableCard);\n        }\n\n        if (Battery.hasChargingRate()) {\n            List < String > list = new ArrayList < > ();\n            for (int i = 10; i < 151; i++) list.add((i * 10) + getString(R.string.ma));\n\n            mChargingRateCard = new SeekBarCardView.DSeekBarCard(list);\n            mChargingRateCard.setTitle(getString(R.string.charge_rate));\n            mChargingRateCard.setDescription(getString(R.string.charge_rate_summary));\n            mChargingRateCard.setProgress((Battery.getChargingRate() / 10) - 10);\n            mChargingRateCard.setOnDSeekBarCardListener(this);\n\n            addView(mChargingRateCard);\n        }\n    }\n\n    private void bclInit() {\n        DDivider mBclDivider = new DDivider();\n        mBclDivider.setText(getString(R.string.bcl));\n        addView(mBclDivider);\n\n        mBclCard = new SwitchCardView.DSwitchCard();\n        mBclCard.setTitle(getString(R.string.bcl));\n        mBclCard.setDescription(getString(R.string.bcl_summary));\n        mBclCard.setChecked(Battery.isBclActive());\n        mBclCard.setOnDSwitchCardListener(this);\n\n        addView(mBclCard);\n    }\n\n    private void bclMaxFreqInit() {\n        bclFreqCount = 0;\n        List < String > freqs = new ArrayList < > ();\n        Cpufreqs = CPU.getFreqs();\n        for (int freq: Cpufreqs) {\n            if (freq >= Battery.getBclLimitFreq()) {\n                bclFreqCount++;\n                freqs.add(freq / 1000 + getString(R.string.mhz));\n            }\n        }\n\n        // replace top freq with a disable\n        freqs.set(freqs.size() - 1, getString(R.string.disabled));\n\n        mBclMaxFreqCard = new PopupCardView.DPopupCard(freqs);\n        mBclMaxFreqCard.setTitle(getString(R.string.bcl_max_freq));\n        mBclMaxFreqCard.setDescription(getString(R.string.bcl_max_freq_summary));\n\n        bclFreqValue = Battery.getBclFreq();\n        if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));\n        else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));\n\n        mBclMaxFreqCard.setOnDPopupCardListener(this);\n\n        addView(mBclMaxFreqCard);\n    }\n\n    private void bclHotmask() {\n        mBclHotmask = new PopupCardView.DPopupCard(new ArrayList < > (\n            Arrays.asList(getResources().getStringArray(R.array.bcl_hot_plug))));\n        mBclHotmask.setTitle(getString(R.string.bcl_cores));\n        mBclHotmask.setDescription(getString(R.string.bcl_cores_summary));\n        mBclHotmask.setItem(Battery.getBclHotMask());\n        mBclHotmask.setOnDPopupCardListener(this);\n\n        addView(mBclHotmask);\n    }\n\n    private void BclVphLowInit() {\n        int position = 0;\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 30; i++) {\n            position = ((i + bclArraylist) * 50);\n            list.add(String.valueOf(position + getString(R.string.mv)));\n        }\n\n        mBclVphLowCard = new SeekBarCardView.DSeekBarCard(list);\n        mBclVphLowCard.setTitle(getString(R.string.bcl_voltage_low));\n        mBclVphLowCard.setDescription(getString(R.string.bcl_voltage_low_summary));\n        mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);\n        mBclVphLowCard.setOnDSeekBarCardListener(this);\n\n        addView(mBclVphLowCard);\n    }\n\n    private void BclVphHighInit() {\n        int position = 0;\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 30; i++) {\n            position = ((i + bclArraylist) * 50);\n            list.add(String.valueOf(position + getString(R.string.mv)));\n        }\n\n        mBclVphHighCard = new SeekBarCardView.DSeekBarCard(list);\n        mBclVphHighCard.setTitle(getString(R.string.bcl_voltage_high));\n        mBclVphHighCard.setDescription(getString(R.string.bcl_voltage_high_summary));\n        mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);\n        mBclVphHighCard.setOnDSeekBarCardListener(this);\n\n        addView(mBclVphHighCard);\n    }\n\n    private void bclHotplugInit() {\n        mBclHotplugCard = new SwitchCardView.DSwitchCard();\n        mBclHotplugCard.setTitle(getString(R.string.bcl_hotplug));\n        mBclHotplugCard.setDescription(getString(R.string.bcl_hotplug_summary));\n        mBclHotplugCard.setChecked(Battery.isBclHotplugActive());\n        mBclHotplugCard.setOnDSwitchCardListener(this);\n\n        addView(mBclHotplugCard);\n    }\n\n    private void bclColdDisablerInit() {\n        mColdDisablerCard = new SwitchCardView.DSwitchCard();\n        mColdDisablerCard.setTitle(getString(R.string.battery_health_cold_disabler));\n        mColdDisablerCard.setDescription(getString(R.string.battery_health_cold_disabler_summary));\n        mColdDisablerCard.setChecked(Battery.isBclHotplugActive());\n        mColdDisablerCard.setOnDSwitchCardListener(this);\n\n        addView(mColdDisablerCard);\n    }\n\n    private void DeviceidleInit() {\n        List < DAdapter.DView > views = new ArrayList < > ();\n\n        if (Battery.hasDeviceidle()) {\n            mDeviceidle = new SwitchCardView.DSwitchCard();\n            mDeviceidle.setTitle(getString(R.string.deviceidle_doze));\n            mDeviceidle.setDescription(getString(R.string.deviceidle_doze_summary));\n            mDeviceidle.setChecked(Battery.isDeviceidleActive());\n            mDeviceidle.setOnDSwitchCardListener(this);\n\n            views.add(mDeviceidle);\n        }\n\n        if (Battery.hasDeviceidlelight()) {\n            mDeviceidlelight = new SwitchCardView.DSwitchCard();\n            mDeviceidlelight.setTitle(getString(R.string.deviceidle_doze_light));\n            mDeviceidlelight.setDescription(getString(R.string.deviceidle_doze_light_summary));\n            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());\n            mDeviceidlelight.setOnDSwitchCardListener(this);\n\n            views.add(mDeviceidlelight);\n        }\n\n        if (Battery.hasDeviceidledeep()) {\n            mDeviceidledeep = new SwitchCardView.DSwitchCard();\n            mDeviceidledeep.setTitle(getString(R.string.deviceidle_doze_deep));\n            mDeviceidledeep.setDescription(getString(R.string.deviceidle_doze_deep_summary));\n            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());\n            mDeviceidledeep.setOnDSwitchCardListener(this);\n\n            views.add(mDeviceidledeep);\n        }\n\n        if (views.size() > 0) {\n            DDivider mDeviceidleCard = new DDivider();\n            mDeviceidleCard.setText(getString(R.string.deviceidle));\n            mDeviceidleCard.setDescription(getString(R.string.deviceidle_summary));\n            addView(mDeviceidleCard);\n\n            addAllViews(views);\n        }\n    }\n\n    private void cstatesInit() {\n        List < DAdapter.DView > views = new ArrayList < > ();\n\n        if (Battery.hasC0State()) {\n            mC0StateCard = new SwitchCardView.DSwitchCard();\n            mC0StateCard.setTitle(getString(R.string.c0state));\n            mC0StateCard.setDescription(getString(R.string.c0state_summary));\n            mC0StateCard.setChecked(Battery.isC0StateActive());\n            mC0StateCard.setOnDSwitchCardListener(this);\n\n            views.add(mC0StateCard);\n        }\n\n        if (Battery.hasC1State()) {\n            mC1StateCard = new SwitchCardView.DSwitchCard();\n            mC1StateCard.setTitle(getString(R.string.c1state));\n            mC1StateCard.setDescription(getString(R.string.c1state_summary));\n            mC1StateCard.setChecked(Battery.isC1StateActive());\n            mC1StateCard.setOnDSwitchCardListener(this);\n\n            views.add(mC1StateCard);\n        }\n\n        if (Battery.hasC2State()) {\n            mC2StateCard = new SwitchCardView.DSwitchCard();\n            mC2StateCard.setTitle(getString(R.string.c2state));\n            mC2StateCard.setDescription(getString(R.string.c2state_summary));\n            mC2StateCard.setChecked(Battery.isC2StateActive());\n            mC2StateCard.setOnDSwitchCardListener(this);\n\n            views.add(mC2StateCard);\n        }\n\n        if (Battery.hasC3State()) {\n            mC3StateCard = new SwitchCardView.DSwitchCard();\n            mC3StateCard.setTitle(getString(R.string.c3state));\n            mC3StateCard.setDescription(getString(R.string.c3state_summary));\n            mC3StateCard.setChecked(Battery.isC3StateActive());\n            mC3StateCard.setOnDSwitchCardListener(this);\n\n            views.add(mC3StateCard);\n        }\n\n        if (views.size() > 0) {\n            DDivider mCstatesCard = new DDivider();\n            mCstatesCard.setText(getString(R.string.cstates));\n            addView(mCstatesCard);\n\n            addAllViews(views);\n        }\n    }\n\n    @Override\n    public void onItemSelected(PopupCardView.DPopupCard dPopupCard, int position) {\n        if (dPopupCard == mBclMaxFreqCard)\n            Battery.setBclFreq(Cpufreqs.get((Cpufreqs.size() - bclFreqCount) + position), getActivity());\n        if (dPopupCard == mBclHotmask)\n            Battery.setBclHotMask(position, getActivity());\n    }\n\n    @Override\n    public boolean onRefresh() {\n        Update();\n        return true;\n    }\n\n    public void Update() {\n        if (mBclMaxFreqCard != null) {\n            bclFreqValue = Battery.getBclFreq();\n            if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));\n            else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));\n        }\n        if (mBclHotmask != null) mBclHotmask.setItem(Battery.getBclHotMask());\n        if (mBatteryLevelCard != null) mBatteryLevelCard.setDescription(Battery.getBatteryLevel() + getString(R.string.percent));\n        if (mBatteryChargingCurrentCard != null) {\n            double amperage = (double) Battery.getChargingCurrent() / 1000;\n            if (amperage < 0) mBatteryChargingCurrentCard.setDescription(amperage + getString(R.string.ma));\n            else mBatteryChargingCurrentCard.setDescription(\"+\" + amperage + getString(R.string.ma));\n        }\n        if (mBatteryVoltageCard != null) {\n            double voltage_now = (double) Battery.getBatteryVoltageNow() / 1000;\n            mBatteryVoltageCard.setDescription(voltage_now + getString(R.string.mv));\n        }\n        if (mBatteryTemperature != null) {\n            double celsius = (double) Battery.getBatteryTemp() / 10;\n            mBatteryTemperature.setDescription(Utils.formatCelsius(celsius) + \" \" + Utils.celsiusToFahrenheit(celsius));\n        }\n        if (mBatteryChargingTypeCard != null) {\n            if (Battery.getChargingType().equals(\"None\"))\n                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_none));\n            else if (Battery.getChargingType().equals(\"Weak\"))\n                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_weak));\n            else mBatteryChargingTypeCard.setDescription(Battery.getChargingType());\n        }\n        if (mBatteryLedCard != null)\n            mBatteryLedCard.setChecked(Battery.getBatteryLed());\n        if (mBatteryHealthCard != null)\n            mBatteryHealthCard.setDescription(Battery.getHealth());\n        if (mBclCard != null)\n            mBclCard.setChecked(Battery.isBclActive());\n        if (mBclHotplugCard != null)\n            mBclHotplugCard.setChecked(Battery.isBclHotplugActive());\n        if (mColdDisablerCard != null)\n            mColdDisablerCard.setChecked(Battery.isColdDisablerActive());\n        if (mBclVphHighCard != null)\n            mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);\n        if (mBclVphLowCard != null)\n            mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);\n\n        if (mDeviceidle != null)\n            mDeviceidle.setChecked(Battery.isDeviceidleActive());\n        if (mDeviceidlelight != null)\n            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());\n        if (mDeviceidledeep != null)\n            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());\n    }\n\n    @Override\n    public void onChecked(SwitchCardView.DSwitchCard dSwitchCard, boolean checked) {\n        if (dSwitchCard == mForceFastChargeCard) Battery.activateForceFastCharge(checked, getActivity());\n        else if (dSwitchCard == mCustomChargeRateEnableCard) Battery.activateCustomChargeRate(checked, getActivity());\n        else if (dSwitchCard == mC0StateCard) Battery.activateC0State(checked, getActivity());\n        else if (dSwitchCard == mC1StateCard) Battery.activateC1State(checked, getActivity());\n        else if (dSwitchCard == mC2StateCard) Battery.activateC2State(checked, getActivity());\n        else if (dSwitchCard == mC3StateCard) Battery.activateC3State(checked, getActivity());\n        else if (dSwitchCard == mBatteryLedCard) Battery.setBatteryLed(checked, getActivity());\n        else if (dSwitchCard == mBclCard) Battery.activateBcl(checked, getActivity());\n        else if (dSwitchCard == mBclHotplugCard) Battery.activateBclHotplug(checked, getActivity());\n        else if (dSwitchCard == mColdDisablerCard) Battery.activateColdDisabler(checked, getActivity());\n        else if (dSwitchCard == mDeviceidle) Battery.activateDeviceidle(checked, getActivity());\n        else if (dSwitchCard == mDeviceidlelight) Battery.activateDeviceidlelight(checked, getActivity());\n        else if (dSwitchCard == mDeviceidledeep) Battery.activateDeviceidledeep(checked, getActivity());\n    }\n\n    @Override\n    public void onChanged(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {}\n\n    @Override\n    public void onStop(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {\n        if (dSeekBarCard == mBlxCard)\n            Battery.setBlx(position, getActivity());\n        else if (dSeekBarCard == mChargingRateCard)\n            Battery.setChargingRate((position * 10) + 100, getActivity());\n        else if (dSeekBarCard == mBclVphLowCard)\n            Battery.setBclVphLow((position + bclArraylist) * 50000, getActivity());\n        else if (dSeekBarCard == mBclVphHighCard)\n            Battery.setBclVphHigh((position + bclArraylist) * 50000, getActivity());\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}", "class_id": 0, "repo": "ShivashishY/KA27", "file": "app/src/main/java/com/grarak/kerneladiutor/fragments/kernel/BatteryFragment.java", "last_update_at": "2018-05-21T22:52:10+00:00", "question_id": "c96f341573c717c518981a462ea0eb6b95407430", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BatteryFragment extends RecyclerViewFragment implements\nPopupCardView.DPopupCard.OnDPopupCardListener, SwitchCardView.DSwitchCard.OnDSwitchCardListener, SeekBarCardView.DSeekBarCard.OnDSeekBarCardListener {\n    private int bclFreqCount = 0, bclArraylist = 60, bclFreqValue = 0;\n    private List < Integer > Cpufreqs;\n    private CardViewItem.DCardView mBatteryLevelCard, mBatteryVoltageCard, mBatteryTemperature, mBatteryChargingCurrentCard, mBatteryChargingTypeCard, mBatteryHealthCard;\n    private SwitchCardView.DSwitchCard mForceFastChargeCard, mBatteryLedCard;\n    private SwitchCardView.DSwitchCard mBclCard, mBclHotplugCard, mColdDisablerCard;\n    private PopupCardView.DPopupCard mBclMaxFreqCard;\n    private PopupCardView.DPopupCard mBclHotmask;\n    private SeekBarCardView.DSeekBarCard mBclVphLowCard, mBclVphHighCard;\n    private SeekBarCardView.DSeekBarCard mBlxCard;\n    private SwitchCardView.DSwitchCard mCustomChargeRateEnableCard;\n    private SeekBarCardView.DSeekBarCard mChargingRateCard;\n    private SwitchCardView.DSwitchCard mC0StateCard, mC1StateCard, mC2StateCard, mC3StateCard;\n    private SwitchCardView.DSwitchCard mDeviceidle, mDeviceidlelight, mDeviceidledeep;\n    @Override\n    public void init(Bundle savedInstanceState) {\n        super.init(savedInstanceState);\n        if (Battery.hasBatteryLed()) BatteryLedInit();\n        batteryLevelInit();\n        batteryHealthInit();\n        batteryVoltageInit();\n        batteryChargingCurrentInit();\n        batteryTemperatureInit();\n        batteryChargingTypeInit();\n        if (Battery.hasColdDisabler()) bclColdDisablerInit();\n        if (Battery.hasForceFastCharge()) forceFastChargeInit();\n        if (Battery.hasBlx()) blxInit();\n        if (Battery.hasChargeRate()) chargerateInit();\n        if (Battery.hasBcl()) bclInit();\n        if (Battery.hasBclFreq()) bclMaxFreqInit();\n        if (Battery.hasBclHotMask()) bclHotmask();\n        if (Battery.hasBclVphLow()) BclVphLowInit();\n        if (Battery.hasBclVphHigh()) BclVphHighInit();\n        if (Battery.hasBclHotplug()) bclHotplugInit();\n        DeviceidleInit();\n        cstatesInit();\n        Update();\n    }\n    @Override\n    public void postInit(Bundle savedInstanceState) {\n        super.postInit(savedInstanceState);\n        if (getCount() < 4) showApplyOnBoot(false);\n    }\n    private void batteryLevelInit() {\n        mBatteryLevelCard = new CardViewItem.DCardView();\n        mBatteryLevelCard.setTitle(getString(R.string.battery_level));\n        addView(mBatteryLevelCard);\n    }\n    private void BatteryLedInit() {\n        mBatteryLedCard = new SwitchCardView.DSwitchCard();\n        mBatteryLedCard.setTitle(getString(R.string.battery_led));\n        mBatteryLedCard.setDescription(getString(R.string.battery_led_summary));\n        mBatteryLedCard.setChecked(Battery.getBatteryLed());\n        mBatteryLedCard.setOnDSwitchCardListener(this);\n        addView(mBatteryLedCard);\n    }\n    private void batteryVoltageInit() {\n        mBatteryVoltageCard = new CardViewItem.DCardView();\n        mBatteryVoltageCard.setTitle(getString(R.string.battery_voltage));\n        addView(mBatteryVoltageCard);\n    }\n    private void batteryTemperatureInit() {\n        mBatteryTemperature = new CardViewItem.DCardView();\n        mBatteryTemperature.setTitle(getString(R.string.battery_temperature));\n        addView(mBatteryTemperature);\n    }\n    private void batteryChargingCurrentInit() {\n        mBatteryChargingCurrentCard = new CardViewItem.DCardView();\n        mBatteryChargingCurrentCard.setTitle(getString(R.string.battery_charging_current));\n        addView(mBatteryChargingCurrentCard);\n    }\n    private void batteryChargingTypeInit() {\n        mBatteryChargingTypeCard = new CardViewItem.DCardView();\n        mBatteryChargingTypeCard.setTitle(getString(R.string.battery_charging_mode));\n        addView(mBatteryChargingTypeCard);\n    }\n    private void batteryHealthInit() {\n        mBatteryHealthCard = new CardViewItem.DCardView();\n        mBatteryHealthCard.setTitle(getString(R.string.battery_health));\n        addView(mBatteryHealthCard);\n    }\n    private void forceFastChargeInit() {\n        mForceFastChargeCard = new SwitchCardView.DSwitchCard();\n        mForceFastChargeCard.setTitle(getString(R.string.usb_fast_charge));\n        mForceFastChargeCard.setDescription(getString(R.string.usb_fast_charge_summary));\n        mForceFastChargeCard.setChecked(Battery.isForceFastChargeActive());\n        mForceFastChargeCard.setOnDSwitchCardListener(this);\n        addView(mForceFastChargeCard);\n    }\n    private void blxInit() {\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 101; i++) list.add(String.valueOf(i));\n        mBlxCard = new SeekBarCardView.DSeekBarCard(list);\n        mBlxCard.setTitle(getString(R.string.blx));\n        mBlxCard.setDescription(getString(R.string.blx_summary));\n        mBlxCard.setProgress(Battery.getCurBlx());\n        mBlxCard.setOnDSeekBarCardListener(this);\n        addView(mBlxCard);\n    }\n    private void chargerateInit() {\n        if (Battery.hasCustomChargeRateEnable()) {\n            mCustomChargeRateEnableCard = new SwitchCardView.DSwitchCard();\n            mCustomChargeRateEnableCard.setDescription(getString(R.string.custom_charge_rate));\n            mCustomChargeRateEnableCard.setChecked(Battery.isCustomChargeRateActive());\n            mCustomChargeRateEnableCard.setOnDSwitchCardListener(this);\n            addView(mCustomChargeRateEnableCard);\n        }\n        if (Battery.hasChargingRate()) {\n            List < String > list = new ArrayList < > ();\n            for (int i = 10; i < 151; i++) list.add((i * 10) + getString(R.string.ma));\n            mChargingRateCard = new SeekBarCardView.DSeekBarCard(list);\n            mChargingRateCard.setTitle(getString(R.string.charge_rate));\n            mChargingRateCard.setDescription(getString(R.string.charge_rate_summary));\n            mChargingRateCard.setProgress((Battery.getChargingRate() / 10) - 10);\n            mChargingRateCard.setOnDSeekBarCardListener(this);\n            addView(mChargingRateCard);\n        }\n    }\n    private void bclInit() {\n        DDivider mBclDivider = new DDivider();\n        mBclDivider.setText(getString(R.string.bcl));\n        addView(mBclDivider);\n        mBclCard = new SwitchCardView.DSwitchCard();\n        mBclCard.setTitle(getString(R.string.bcl));\n        mBclCard.setDescription(getString(R.string.bcl_summary));\n        mBclCard.setChecked(Battery.isBclActive());\n        mBclCard.setOnDSwitchCardListener(this);\n        addView(mBclCard);\n    }\n    private void bclMaxFreqInit() {\n        bclFreqCount = 0;\n        List < String > freqs = new ArrayList < > ();\n        Cpufreqs = CPU.getFreqs();\n        for (int freq: Cpufreqs) {\n            if (freq >= Battery.getBclLimitFreq()) {\n                bclFreqCount++;\n                freqs.add(freq / 1000 + getString(R.string.mhz));\n            }\n        }\n        // replace top freq with a disable\n        freqs.set(freqs.size() - 1, getString(R.string.disabled));\n        mBclMaxFreqCard = new PopupCardView.DPopupCard(freqs);\n        mBclMaxFreqCard.setTitle(getString(R.string.bcl_max_freq));\n        mBclMaxFreqCard.setDescription(getString(R.string.bcl_max_freq_summary));\n        bclFreqValue = Battery.getBclFreq();\n        if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));\n        else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));\n        mBclMaxFreqCard.setOnDPopupCardListener(this);\n        addView(mBclMaxFreqCard);\n    }\n    private void bclHotmask() {\n        mBclHotmask = new PopupCardView.DPopupCard(new ArrayList < > (\n            Arrays.asList(getResources().getStringArray(R.array.bcl_hot_plug))));\n        mBclHotmask.setTitle(getString(R.string.bcl_cores));\n        mBclHotmask.setDescription(getString(R.string.bcl_cores_summary));\n        mBclHotmask.setItem(Battery.getBclHotMask());\n        mBclHotmask.setOnDPopupCardListener(this);\n        addView(mBclHotmask);\n    }\n    private void BclVphLowInit() {\n        int position = 0;\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 30; i++) {\n            position = ((i + bclArraylist) * 50);\n            list.add(String.valueOf(position + getString(R.string.mv)));\n        }\n        mBclVphLowCard = new SeekBarCardView.DSeekBarCard(list);\n        mBclVphLowCard.setTitle(getString(R.string.bcl_voltage_low));\n        mBclVphLowCard.setDescription(getString(R.string.bcl_voltage_low_summary));\n        mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);\n        mBclVphLowCard.setOnDSeekBarCardListener(this);\n        addView(mBclVphLowCard);\n    }\n    private void BclVphHighInit() {\n        int position = 0;\n        List < String > list = new ArrayList < > ();\n        for (int i = 0; i < 30; i++) {\n            position = ((i + bclArraylist) * 50);\n            list.add(String.valueOf(position + getString(R.string.mv)));\n        }\n        mBclVphHighCard = new SeekBarCardView.DSeekBarCard(list);\n        mBclVphHighCard.setTitle(getString(R.string.bcl_voltage_high));\n        mBclVphHighCard.setDescription(getString(R.string.bcl_voltage_high_summary));\n        mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);\n        mBclVphHighCard.setOnDSeekBarCardListener(this);\n        addView(mBclVphHighCard);\n    }\n    private void bclHotplugInit() {\n        mBclHotplugCard = new SwitchCardView.DSwitchCard();\n        mBclHotplugCard.setTitle(getString(R.string.bcl_hotplug));\n        mBclHotplugCard.setDescription(getString(R.string.bcl_hotplug_summary));\n        mBclHotplugCard.setChecked(Battery.isBclHotplugActive());\n        mBclHotplugCard.setOnDSwitchCardListener(this);\n        addView(mBclHotplugCard);\n    }\n    private void bclColdDisablerInit() {\n        mColdDisablerCard = new SwitchCardView.DSwitchCard();\n        mColdDisablerCard.setTitle(getString(R.string.battery_health_cold_disabler));\n        mColdDisablerCard.setDescription(getString(R.string.battery_health_cold_disabler_summary));\n        mColdDisablerCard.setChecked(Battery.isBclHotplugActive());\n        mColdDisablerCard.setOnDSwitchCardListener(this);\n        addView(mColdDisablerCard);\n    }\n    private void DeviceidleInit() {\n        List < DAdapter.DView > views = new ArrayList < > ();\n        if (Battery.hasDeviceidle()) {\n            mDeviceidle = new SwitchCardView.DSwitchCard();\n            mDeviceidle.setTitle(getString(R.string.deviceidle_doze));\n            mDeviceidle.setDescription(getString(R.string.deviceidle_doze_summary));\n            mDeviceidle.setChecked(Battery.isDeviceidleActive());\n            mDeviceidle.setOnDSwitchCardListener(this);\n            views.add(mDeviceidle);\n        }\n        if (Battery.hasDeviceidlelight()) {\n            mDeviceidlelight = new SwitchCardView.DSwitchCard();\n            mDeviceidlelight.setTitle(getString(R.string.deviceidle_doze_light));\n            mDeviceidlelight.setDescription(getString(R.string.deviceidle_doze_light_summary));\n            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());\n            mDeviceidlelight.setOnDSwitchCardListener(this);\n            views.add(mDeviceidlelight);\n        }\n        if (Battery.hasDeviceidledeep()) {\n            mDeviceidledeep = new SwitchCardView.DSwitchCard();\n            mDeviceidledeep.setTitle(getString(R.string.deviceidle_doze_deep));\n            mDeviceidledeep.setDescription(getString(R.string.deviceidle_doze_deep_summary));\n            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());\n            mDeviceidledeep.setOnDSwitchCardListener(this);\n            views.add(mDeviceidledeep);\n        }\n        if (views.size() > 0) {\n            DDivider mDeviceidleCard = new DDivider();\n            mDeviceidleCard.setText(getString(R.string.deviceidle));\n            mDeviceidleCard.setDescription(getString(R.string.deviceidle_summary));\n            addView(mDeviceidleCard);\n            addAllViews(views);\n        }\n    }\n    private void cstatesInit() {\n        List < DAdapter.DView > views = new ArrayList < > ();\n        if (Battery.hasC0State()) {\n            mC0StateCard = new SwitchCardView.DSwitchCard();\n            mC0StateCard.setTitle(getString(R.string.c0state));\n            mC0StateCard.setDescription(getString(R.string.c0state_summary));\n            mC0StateCard.setChecked(Battery.isC0StateActive());\n            mC0StateCard.setOnDSwitchCardListener(this);\n            views.add(mC0StateCard);\n        }\n        if (Battery.hasC1State()) {\n            mC1StateCard = new SwitchCardView.DSwitchCard();\n            mC1StateCard.setTitle(getString(R.string.c1state));\n            mC1StateCard.setDescription(getString(R.string.c1state_summary));\n            mC1StateCard.setChecked(Battery.isC1StateActive());\n            mC1StateCard.setOnDSwitchCardListener(this);\n            views.add(mC1StateCard);\n        }\n        if (Battery.hasC2State()) {\n            mC2StateCard = new SwitchCardView.DSwitchCard();\n            mC2StateCard.setTitle(getString(R.string.c2state));\n            mC2StateCard.setDescription(getString(R.string.c2state_summary));\n            mC2StateCard.setChecked(Battery.isC2StateActive());\n            mC2StateCard.setOnDSwitchCardListener(this);\n            views.add(mC2StateCard);\n        }\n        if (Battery.hasC3State()) {\n            mC3StateCard = new SwitchCardView.DSwitchCard();\n            mC3StateCard.setTitle(getString(R.string.c3state));\n            mC3StateCard.setDescription(getString(R.string.c3state_summary));\n            mC3StateCard.setChecked(Battery.isC3StateActive());\n            mC3StateCard.setOnDSwitchCardListener(this);\n            views.add(mC3StateCard);\n        }\n        if (views.size() > 0) {\n            DDivider mCstatesCard = new DDivider();\n            mCstatesCard.setText(getString(R.string.cstates));\n            addView(mCstatesCard);\n            addAllViews(views);\n        }\n    }\n    @Override\n    public void onItemSelected(PopupCardView.DPopupCard dPopupCard, int position) {\n        if (dPopupCard == mBclMaxFreqCard)\n            Battery.setBclFreq(Cpufreqs.get((Cpufreqs.size() - bclFreqCount) + position), getActivity());\n        if (dPopupCard == mBclHotmask)\n            Battery.setBclHotMask(position, getActivity());\n    }\n    @Override\n    public boolean onRefresh() {\n        Update();\n        return true;\n    }\n    public void Update() {\n        if (mBclMaxFreqCard != null) {\n            bclFreqValue = Battery.getBclFreq();\n            if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));\n            else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));\n        }\n        if (mBclHotmask != null) mBclHotmask.setItem(Battery.getBclHotMask());\n        if (mBatteryLevelCard != null) mBatteryLevelCard.setDescription(Battery.getBatteryLevel() + getString(R.string.percent));\n        if (mBatteryChargingCurrentCard != null) {\n            double amperage = (double) Battery.getChargingCurrent() / 1000;\n            if (amperage < 0) mBatteryChargingCurrentCard.setDescription(amperage + getString(R.string.ma));\n            else mBatteryChargingCurrentCard.setDescription(\"+\" + amperage + getString(R.string.ma));\n        }\n        if (mBatteryVoltageCard != null) {\n            double voltage_now = (double) Battery.getBatteryVoltageNow() / 1000;\n            mBatteryVoltageCard.setDescription(voltage_now + getString(R.string.mv));\n        }\n        if (mBatteryTemperature != null) {\n            double celsius = (double) Battery.getBatteryTemp() / 10;\n            mBatteryTemperature.setDescription(Utils.formatCelsius(celsius) + \" \" + Utils.celsiusToFahrenheit(celsius));\n        }\n        if (mBatteryChargingTypeCard != null) {\n            if (Battery.getChargingType().equals(\"None\"))\n                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_none));\n            else if (Battery.getChargingType().equals(\"Weak\"))\n                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_weak));\n            else mBatteryChargingTypeCard.setDescription(Battery.getChargingType());\n        }\n        if (mBatteryLedCard != null)\n            mBatteryLedCard.setChecked(Battery.getBatteryLed());\n        if (mBatteryHealthCard != null)\n            mBatteryHealthCard.setDescription(Battery.getHealth());\n        if (mBclCard != null)\n            mBclCard.setChecked(Battery.isBclActive());\n        if (mBclHotplugCard != null)\n            mBclHotplugCard.setChecked(Battery.isBclHotplugActive());\n        if (mColdDisablerCard != null)\n            mColdDisablerCard.setChecked(Battery.isColdDisablerActive());\n        if (mBclVphHighCard != null)\n            mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);\n        if (mBclVphLowCard != null)\n            mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);\n        if (mDeviceidle != null)\n            mDeviceidle.setChecked(Battery.isDeviceidleActive());\n        if (mDeviceidlelight != null)\n            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());\n        if (mDeviceidledeep != null)\n            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());\n    }\n    @Override\n    public void onChecked(SwitchCardView.DSwitchCard dSwitchCard, boolean checked) {\n        if (dSwitchCard == mForceFastChargeCard) Battery.activateForceFastCharge(checked, getActivity());\n        else if (dSwitchCard == mCustomChargeRateEnableCard) Battery.activateCustomChargeRate(checked, getActivity());\n        else if (dSwitchCard == mC0StateCard) Battery.activateC0State(checked, getActivity());\n        else if (dSwitchCard == mC1StateCard) Battery.activateC1State(checked, getActivity());\n        else if (dSwitchCard == mC2StateCard) Battery.activateC2State(checked, getActivity());\n        else if (dSwitchCard == mC3StateCard) Battery.activateC3State(checked, getActivity());\n        else if (dSwitchCard == mBatteryLedCard) Battery.setBatteryLed(checked, getActivity());\n        else if (dSwitchCard == mBclCard) Battery.activateBcl(checked, getActivity());\n        else if (dSwitchCard == mBclHotplugCard) Battery.activateBclHotplug(checked, getActivity());\n        else if (dSwitchCard == mColdDisablerCard) Battery.activateColdDisabler(checked, getActivity());\n        else if (dSwitchCard == mDeviceidle) Battery.activateDeviceidle(checked, getActivity());\n        else if (dSwitchCard == mDeviceidlelight) Battery.activateDeviceidlelight(checked, getActivity());\n        else if (dSwitchCard == mDeviceidledeep) Battery.activateDeviceidledeep(checked, getActivity());\n    }\n    @Override\n    public void onChanged(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {}\n    @Override\n    public void onStop(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {\n        if (dSeekBarCard == mBlxCard)\n            Battery.setBlx(position, getActivity());\n        else if (dSeekBarCard == mChargingRateCard)\n            Battery.setChargingRate((position * 10) + 100, getActivity());\n        else if (dSeekBarCard == mBclVphLowCard)\n            Battery.setBclVphLow((position + bclArraylist) * 50000, getActivity());\n        else if (dSeekBarCard == mBclVphHighCard)\n            Battery.setBclVphHigh((position + bclArraylist) * 50000, getActivity());\n    }\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n"]], "pred": {"ppl": 1.8868142366409302, "ppl_lower": 2.1236703395843506, "ppl/lowercase_ppl": -1.1862623448657483, "ppl/zlib": 0.0002072094705577724, "Min_5.0% Prob": 6.565733105528588, "Min_10.0% Prob": 4.789455850919087, "Min_20.0% Prob": 2.9790365944306054, "Min_30.0% Prob": 2.086529094847589, "Min_40.0% Prob": 1.580006069014154, "Min_50.0% Prob": 1.268858809018628, "Min_60.0% Prob": 1.0590403109240432}}
{"hexsha": "7b092243a77187c440d212b8ee516d672822d3e2", "ext": "java", "lang": "Java", "content": "public class NumberPicker extends LinearLayout implements Button.OnClickListener,\n        Button.OnLongClickListener {\n\n    protected int mInputSize = 20;\n    protected final Button mNumbers[] = new Button[10];\n    protected int mInput[] = new int[mInputSize];\n    protected int mInputPointer = -1;\n    protected Button mLeft, mRight;\n    protected ImageButton mDelete;\n    protected NumberView mEnteredNumber;\n    protected final Context mContext;\n\n    private int mSign;\n    private String mLabelText = \"\";\n    private Button mSetButton;\n    private static final int CLICKED_DECIMAL = 10;\n\n    public static final int SIGN_POSITIVE = 0;\n    public static final int SIGN_NEGATIVE = 1;\n\n    private final Typeface mTypefaceMono;\n\n    private ColorStateList mTextColor;\n    private int mDividerColor;\n    private int mDeleteDrawableSrcResId;\n    private int mTheme = -1;\n\n    private BigDecimal mMinNumber = null;\n    private BigDecimal mMaxNumber = null;\n\n    /**\n     * Instantiates a NumberPicker object\n     *\n     * @param context the Context required for creation\n     */\n    public NumberPicker(Context context) {\n        this(context, null);\n    }\n\n    /**\n     * Instantiates a NumberPicker object\n     *\n     * @param context the Context required for creation\n     * @param attrs   additional attributes that define custom colors, selectors, and backgrounds.\n     */\n    public NumberPicker(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mContext = context;\n        LayoutInflater layoutInflater =\n                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n        layoutInflater.inflate(getLayoutId(), this);\n\n        // Init defaults\n        mTextColor = getResources().getColorStateList(R.color.dialog_text_color_holo);\n        mDeleteDrawableSrcResId = R.drawable.ic_backspace_normal_dark;\n        mDividerColor = getResources().getColor(R.color.default_divider_color);\n\n        mTypefaceMono = Typeface.createFromAsset(context.getAssets(), \"fonts/Recursive_Monospace-Regular.ttf\");\n    }\n\n    protected int getLayoutId() {\n        return R.layout.number_picker_view;\n    }\n\n    /**\n     * Change the theme of the Picker\n     *\n     * @param themeResId the resource ID of the new style\n     */\n    public void setTheme(int themeResId) {\n        mTheme = themeResId;\n        if (mTheme != -1) {\n            TypedArray a = getContext().obtainStyledAttributes(themeResId, R.styleable.BetterPickersDialogFragment);\n\n            mTextColor = a.getColorStateList(R.styleable.BetterPickersDialogFragment_bpTextColor);\n            mDividerColor = a.getColor(R.styleable.BetterPickersDialogFragment_bpDividerColor, mDividerColor);\n            mDeleteDrawableSrcResId = a.getResourceId(R.styleable.BetterPickersDialogFragment_bpDeleteIcon, mDeleteDrawableSrcResId);\n        }\n\n        restyleViews();\n    }\n\n    private void restyleViews() {\n        for (Button number : mNumbers) {\n            if (number != null) {\n                number.setTextColor(mTextColor);\n                number.setTypeface(mTypefaceMono);\n            }\n        }\n        if (mLeft != null) {\n            mLeft.setTextColor(mTextColor);\n            mLeft.setTypeface(mTypefaceMono);\n        }\n        if (mRight != null) {\n            mRight.setTextColor(mTextColor);\n            mRight.setTypeface(mTypefaceMono);\n        }\n        if (mDelete != null) {\n            mDelete.setImageDrawable(getResources().getDrawable(mDeleteDrawableSrcResId));\n        }\n        if (mEnteredNumber != null) {\n            mEnteredNumber.setTheme(mTheme);\n        }\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        for (int i = 0; i < mInput.length; i++) {\n            mInput[i] = -1;\n        }\n\n        View numberPickerView = findViewById(R.id.numberPickerView);\n        mEnteredNumber = (NumberView) findViewById(R.id.number_text);\n        mDelete = (ImageButton) findViewById(R.id.delete);\n        mDelete.setOnClickListener(this);\n        mDelete.setOnLongClickListener(this);\n\n        mNumbers[1] = numberPickerView.findViewById(R.id.key_1);\n        mNumbers[2] = numberPickerView.findViewById(R.id.key_2);\n        mNumbers[3] = numberPickerView.findViewById(R.id.key_3);\n\n        mNumbers[4] = numberPickerView.findViewById(R.id.key_4);\n        mNumbers[5] = numberPickerView.findViewById(R.id.key_5);\n        mNumbers[6] = numberPickerView.findViewById(R.id.key_6);\n\n        mNumbers[7] = numberPickerView.findViewById(R.id.key_7);\n        mNumbers[8] = numberPickerView.findViewById(R.id.key_8);\n        mNumbers[9] = numberPickerView.findViewById(R.id.key_9);\n\n        mLeft = numberPickerView.findViewById(R.id.key_left);\n        mNumbers[0] = numberPickerView.findViewById(R.id.key_0);\n        mRight = numberPickerView.findViewById(R.id.key_right);\n        setLeftRightEnabled();\n\n        for (int i = 0; i < 10; i++) {\n            mNumbers[i].setOnClickListener(this);\n            mNumbers[i].setText(String.format(\"%d\", i));\n            mNumbers[i].setTag(R.id.numbers_key, new Integer(i));\n        }\n        updateNumber();\n\n        Resources res = mContext.getResources();\n        mLeft.setText(res.getString(R.string.number_picker_plus_minus));\n        mRight.setText(res.getString(R.string.number_picker_seperator));\n        mLeft.setOnClickListener(this);\n        mRight.setOnClickListener(this);\n        mSign = SIGN_POSITIVE;\n\n        restyleViews();\n        updateKeypad();\n    }\n\n    /**\n     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the plus/minus indicator\n     *\n     * @param visiblity an int using Android's View.* convention\n     */\n    public void setPlusMinusVisibility(int visiblity) {\n        if (mLeft != null) {\n            mLeft.setVisibility(visiblity);\n        }\n    }\n\n    /**\n     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the decimal indicator\n     *\n     * @param visiblity an int using Android's View.* convention\n     */\n    public void setDecimalVisibility(int visiblity) {\n        if (mRight != null) {\n            mRight.setVisibility(visiblity);\n        }\n    }\n\n    /**\n     * Set a minimum required number\n     *\n     * @param min the minimum required number\n     */\n    public void setMin(BigDecimal min) {\n        mMinNumber = min;\n    }\n\n    /**\n     * Set a maximum required number\n     *\n     * @param max the maximum required number\n     */\n    public void setMax(BigDecimal max) {\n        mMaxNumber = max;\n    }\n\n    /**\n     * Update the 0 button to determine whether it is able to be clicked.\n     */\n    public void updateZeroButton() {\n        boolean enabled = mInputPointer >= 0;\n        if (mNumbers[0] != null) {\n            mNumbers[0].setEnabled(enabled);\n            mNumbers[0].setAlpha(enabled? (float) 1: (float) 0.3);\n        }\n    }\n\n    /**\n     * Update the delete button to determine whether it is able to be clicked.\n     */\n    public void updateDeleteButton() {\n        boolean enabled = mInputPointer != -1;\n        if (mDelete != null) {\n            mDelete.setEnabled(enabled);\n            mDelete.setAlpha(enabled? (float) 1: (float) 0.3);\n        }\n    }\n\n    @Override\n    public void onClick(View v) {\n        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);\n        doOnClick(v);\n        updateDeleteButton();\n    }\n\n    protected void doOnClick(View v) {\n        Integer val = (Integer) v.getTag(R.id.numbers_key);\n        if (val != null) {\n            // A number was pressed\n            addClickedNumber(val);\n        } else if (v == mDelete) {\n            if (mInputPointer >= 0) {\n                for (int i = 0; i < mInputPointer; i++) {\n                    mInput[i] = mInput[i + 1];\n                }\n                mInput[mInputPointer] = 0;\n                mInputPointer--;\n            }\n        } else if (v == mLeft) {\n            onLeftClicked();\n        } else if (v == mRight) {\n            onRightClicked();\n        }\n        updateKeypad();\n    }\n\n    @Override\n    public boolean onLongClick(View v) {\n        v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);\n        if (v == mDelete) {\n            mDelete.setPressed(false);\n            reset();\n            updateKeypad();\n            return true;\n        }\n        return false;\n    }\n\n    private void updateKeypad() {\n        // Update state of keypad\n        updateLeftRightButtons();\n        // Update the number\n        updateNumber();\n        // enable/disable the \"set\" key\n        enableSetButton();\n        // Update the backspace button\n        updateDeleteButton();\n        // Update the zero button\n        updateZeroButton();\n    }\n\n    /**\n     * Set the text displayed in the small label\n     *\n     * @param labelText the String to set as the label\n     */\n    public void setLabelText(String labelText) {\n        mLabelText = labelText;\n    }\n\n    /**\n     * Reset all inputs.\n     */\n    public void reset() {\n        for (int i = 0; i < mInputSize; i++) {\n            mInput[i] = -1;\n        }\n        mInputPointer = -1;\n        updateNumber();\n    }\n\n    public void enableKeypad(boolean enable) {\n        for (int i = 0; i < 10; i++) {\n            mNumbers[i].setEnabled(enable);\n        }\n        mLeft.setEnabled(enable);\n    }\n\n    // Update the number displayed in the picker:\n    protected void updateNumber() {\n        String numberString = getEnteredNumberString();\n        numberString = numberString.replaceAll(\"\\\\-\", \"\");\n        String[] split = numberString.split(\"\\\\.\");\n        if (split.length >= 2) {\n            if (split[0].equals(\"\")) {\n                mEnteredNumber.setNumber(\"0\", split[1], containsDecimal(),\n                        mSign == SIGN_NEGATIVE);\n            } else {\n                mEnteredNumber.setNumber(split[0], split[1], containsDecimal(),\n                        mSign == SIGN_NEGATIVE);\n            }\n        } else if (split.length == 1) {\n            if (split[0].equals(String.valueOf(Integer.MAX_VALUE))) {\n                split[0] = \"\u221e\";\n            }\n            mEnteredNumber.setNumber(split[0], \"\", containsDecimal(),\n                    mSign == SIGN_NEGATIVE);\n        } else if (numberString.equals(\".\")) {\n            mEnteredNumber.setNumber(\"0\", \"\", true, mSign == SIGN_NEGATIVE);\n        }\n    }\n\n    protected void setLeftRightEnabled() {\n        mLeft.setEnabled(false);\n        mRight.setEnabled(canAddDecimal());\n        if (!canAddDecimal()) {\n            mRight.setContentDescription(null);\n        }\n    }\n\n    private void addClickedNumber(int val) {\n        if (mInputPointer < mInputSize - 1) {\n            // For 0 we need to check if we have a value of zero or not\n            for (int i = mInputPointer; i >= 0; i--) {\n                mInput[i + 1] = mInput[i];\n            }\n            mInputPointer++;\n            mInput[0] = val;\n        }\n    }\n\n    /**\n     * Clicking on the bottom left button will toggle the sign.\n     */\n    private void onLeftClicked() {\n        if (mSign == SIGN_POSITIVE) {\n            mSign = SIGN_NEGATIVE;\n        } else {\n            mSign = SIGN_POSITIVE;\n        }\n    }\n\n    /**\n     * Clicking on the bottom right button will add a decimal point.\n     */\n    private void onRightClicked() {\n        if (canAddDecimal()) {\n            addClickedNumber(CLICKED_DECIMAL);\n        }\n    }\n\n    private boolean containsDecimal() {\n        boolean containsDecimal = false;\n        for (int i : mInput) {\n            if (i == 10) {\n                containsDecimal = true;\n            }\n        }\n        return containsDecimal;\n    }\n\n    /**\n     * Checks if the user allowed to click on the right button.\n     *\n     * @return true or false if the user is able to add a decimal or not\n     */\n    private boolean canAddDecimal() {\n        return !containsDecimal();\n    }\n\n    private String getEnteredNumberString() {\n        String value = \"\";\n        for (int i = mInputPointer; i >= 0; i--) {\n            if (mInput[i] == -1) {\n                // Don't add\n            } else if (mInput[i] == CLICKED_DECIMAL) {\n                value += \".\";\n            } else {\n                value += mInput[i];\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Returns the number inputted by the user\n     *\n     * @return a double representing the entered number\n     */\n    public BigDecimal getEnteredNumber() {\n        String value = \"0\";\n        for (int i = mInputPointer; i >= 0; i--) {\n            if (mInput[i] == -1) {\n                break;\n            } else if (mInput[i] == CLICKED_DECIMAL) {\n                value += \".\";\n            } else {\n                value += mInput[i];\n            }\n        }\n        if (mSign == SIGN_NEGATIVE) {\n            value = \"-\" + value;\n        }\n\n        return new BigDecimal(value);\n    }\n\n    private void updateLeftRightButtons() {\n        mRight.setEnabled(canAddDecimal());\n    }\n\n    /**\n     * Enable/disable the \"Set\" button\n     */\n    private void enableSetButton() {\n        if (mSetButton == null) {\n            return;\n        }\n\n        boolean enabled = true;\n\n        // Nothing entered - disable, or = 0\n        if (mInputPointer == -1 || mInputPointer < 0) {\n            enabled = false;\n        }\n\n        mSetButton.setEnabled(enabled);\n        mSetButton.setAlpha(enabled? (float) 1: (float) 0.4);\n    }\n\n    /**\n     * Expose the set button to allow communication with the parent Fragment.\n     *\n     * @param b the parent Fragment's \"Set\" button\n     */\n    public void setSetButton(Button b) {\n        mSetButton = b;\n        enableSetButton();\n    }\n\n    /**\n     * Returns the number as currently inputted by the user\n     *\n     * @return an String representation of the number with no decimal\n     */\n    public BigInteger getNumber() {\n        BigDecimal bigDecimal = getEnteredNumber().setScale(0, BigDecimal.ROUND_FLOOR);\n        return bigDecimal.toBigIntegerExact();\n    }\n\n    /**\n     * Returns the decimal following the number\n     *\n     * @return a double representation of the decimal value\n     */\n    public double getDecimal() {\n        return getEnteredNumber().remainder(BigDecimal.ONE).doubleValue();\n    }\n\n    /**\n     * Returns whether the number is positive or negative\n     *\n     * @return true or false whether the number is positive or negative\n     */\n    public boolean getIsNegative() {\n        return mSign == SIGN_NEGATIVE;\n    }\n\n    public void setNumber(Integer integerPart, Double decimalPart, Integer mCurrentSign) {\n        if (mCurrentSign != null) {\n            mSign = mCurrentSign;\n        } else {\n            mSign = SIGN_POSITIVE;\n        }\n\n        if (decimalPart != null) {\n            String decimalString = doubleToString(decimalPart);\n            // remove \"0.\" from the string\n            readAndRightDigits(TextUtils.substring(decimalString, 2, decimalString.length()));\n            mInputPointer++;\n            mInput[mInputPointer] = CLICKED_DECIMAL;\n        }\n\n        if (integerPart != null) {\n            readAndRightDigits(String.valueOf(integerPart));\n        }\n        updateKeypad();\n    }\n\n    private void readAndRightDigits(String digitsToRead) {\n        for (int i = digitsToRead.length() - 1; i >= 0; i--) {\n            mInputPointer++;\n            mInput[mInputPointer] = digitsToRead.charAt(i) - '0';\n        }\n    }\n\n    /**\n     * Method used to format double and avoid scientific notation x.xE-x (ex: 4.0E-4)\n     *\n     * @param value double value to format\n     * @return string representation of double value\n     */\n    private String doubleToString(double value) {\n        // Use decimal format to avoid\n        DecimalFormat format = new DecimalFormat(\"0.0\");\n        format.setMaximumFractionDigits(Integer.MAX_VALUE);\n        return format.format(value);\n    }\n}", "class_id": 0, "repo": "guglielmilo/notification_timer", "file": "src/main/java/com/codetroopers/betterpickers/numberpicker/NumberPicker.java", "last_update_at": "2018-07-07T01:36:17+00:00", "question_id": "7b092243a77187c440d212b8ee516d672822d3e2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NumberPicker extends LinearLayout implements Button.OnClickListener,\n        Button.OnLongClickListener {\n    protected int mInputSize = 20;\n    protected final Button mNumbers[] = new Button[10];\n    protected int mInput[] = new int[mInputSize];\n    protected int mInputPointer = -1;\n    protected Button mLeft, mRight;\n    protected ImageButton mDelete;\n    protected NumberView mEnteredNumber;\n    protected final Context mContext;\n    private int mSign;\n    private String mLabelText = \"\";\n    private Button mSetButton;\n    private static final int CLICKED_DECIMAL = 10;\n    public static final int SIGN_POSITIVE = 0;\n    public static final int SIGN_NEGATIVE = 1;\n    private final Typeface mTypefaceMono;\n    private ColorStateList mTextColor;\n    private int mDividerColor;\n    private int mDeleteDrawableSrcResId;\n    private int mTheme = -1;\n    private BigDecimal mMinNumber = null;\n    private BigDecimal mMaxNumber = null;\n    /**\n     * Instantiates a NumberPicker object\n     *\n     * @param context the Context required for creation\n     */\n    public NumberPicker(Context context) {\n        this(context, null);\n    }\n    /**\n     * Instantiates a NumberPicker object\n     *\n     * @param context the Context required for creation\n     * @param attrs   additional attributes that define custom colors, selectors, and backgrounds.\n     */\n    public NumberPicker(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mContext = context;\n        LayoutInflater layoutInflater =\n                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n        layoutInflater.inflate(getLayoutId(), this);\n        // Init defaults\n        mTextColor = getResources().getColorStateList(R.color.dialog_text_color_holo);\n        mDeleteDrawableSrcResId = R.drawable.ic_backspace_normal_dark;\n        mDividerColor = getResources().getColor(R.color.default_divider_color);\n        mTypefaceMono = Typeface.createFromAsset(context.getAssets(), \"fonts/Recursive_Monospace-Regular.ttf\");\n    }\n    protected int getLayoutId() {\n        return R.layout.number_picker_view;\n    }\n    /**\n     * Change the theme of the Picker\n     *\n     * @param themeResId the resource ID of the new style\n     */\n    public void setTheme(int themeResId) {\n        mTheme = themeResId;\n        if (mTheme != -1) {\n            TypedArray a = getContext().obtainStyledAttributes(themeResId, R.styleable.BetterPickersDialogFragment);\n            mTextColor = a.getColorStateList(R.styleable.BetterPickersDialogFragment_bpTextColor);\n            mDividerColor = a.getColor(R.styleable.BetterPickersDialogFragment_bpDividerColor, mDividerColor);\n            mDeleteDrawableSrcResId = a.getResourceId(R.styleable.BetterPickersDialogFragment_bpDeleteIcon, mDeleteDrawableSrcResId);\n        }\n        restyleViews();\n    }\n    private void restyleViews() {\n        for (Button number : mNumbers) {\n            if (number != null) {\n                number.setTextColor(mTextColor);\n                number.setTypeface(mTypefaceMono);\n            }\n        }\n        if (mLeft != null) {\n            mLeft.setTextColor(mTextColor);\n            mLeft.setTypeface(mTypefaceMono);\n        }\n        if (mRight != null) {\n            mRight.setTextColor(mTextColor);\n            mRight.setTypeface(mTypefaceMono);\n        }\n        if (mDelete != null) {\n            mDelete.setImageDrawable(getResources().getDrawable(mDeleteDrawableSrcResId));\n        }\n        if (mEnteredNumber != null) {\n            mEnteredNumber.setTheme(mTheme);\n        }\n    }\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n        for (int i = 0; i < mInput.length; i++) {\n            mInput[i] = -1;\n        }\n        View numberPickerView = findViewById(R.id.numberPickerView);\n        mEnteredNumber = (NumberView) findViewById(R.id.number_text);\n        mDelete = (ImageButton) findViewById(R.id.delete);\n        mDelete.setOnClickListener(this);\n        mDelete.setOnLongClickListener(this);\n        mNumbers[1] = numberPickerView.findViewById(R.id.key_1);\n        mNumbers[2] = numberPickerView.findViewById(R.id.key_2);\n        mNumbers[3] = numberPickerView.findViewById(R.id.key_3);\n        mNumbers[4] = numberPickerView.findViewById(R.id.key_4);\n        mNumbers[5] = numberPickerView.findViewById(R.id.key_5);\n        mNumbers[6] = numberPickerView.findViewById(R.id.key_6);\n        mNumbers[7] = numberPickerView.findViewById(R.id.key_7);\n        mNumbers[8] = numberPickerView.findViewById(R.id.key_8);\n        mNumbers[9] = numberPickerView.findViewById(R.id.key_9);\n        mLeft = numberPickerView.findViewById(R.id.key_left);\n        mNumbers[0] = numberPickerView.findViewById(R.id.key_0);\n        mRight = numberPickerView.findViewById(R.id.key_right);\n        setLeftRightEnabled();\n        for (int i = 0; i < 10; i++) {\n            mNumbers[i].setOnClickListener(this);\n            mNumbers[i].setText(String.format(\"%d\", i));\n            mNumbers[i].setTag(R.id.numbers_key, new Integer(i));\n        }\n        updateNumber();\n        Resources res = mContext.getResources();\n        mLeft.setText(res.getString(R.string.number_picker_plus_minus));\n        mRight.setText(res.getString(R.string.number_picker_seperator));\n        mLeft.setOnClickListener(this);\n        mRight.setOnClickListener(this);\n        mSign = SIGN_POSITIVE;\n        restyleViews();\n        updateKeypad();\n    }\n    /**\n     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the plus/minus indicator\n     *\n     * @param visiblity an int using Android's View.* convention\n     */\n    public void setPlusMinusVisibility(int visiblity) {\n        if (mLeft != null) {\n            mLeft.setVisibility(visiblity);\n        }\n    }\n    /**\n     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the decimal indicator\n     *\n     * @param visiblity an int using Android's View.* convention\n     */\n    public void setDecimalVisibility(int visiblity) {\n        if (mRight != null) {\n            mRight.setVisibility(visiblity);\n        }\n    }\n    /**\n     * Set a minimum required number\n     *\n     * @param min the minimum required number\n     */\n    public void setMin(BigDecimal min) {\n        mMinNumber = min;\n    }\n    /**\n     * Set a maximum required number\n     *\n     * @param max the maximum required number\n     */\n    public void setMax(BigDecimal max) {\n        mMaxNumber = max;\n    }\n    /**\n     * Update the 0 button to determine whether it is able to be clicked.\n     */\n    public void updateZeroButton() {\n        boolean enabled = mInputPointer >= 0;\n        if (mNumbers[0] != null) {\n            mNumbers[0].setEnabled(enabled);\n            mNumbers[0].setAlpha(enabled? (float) 1: (float) 0.3);\n        }\n    }\n    /**\n     * Update the delete button to determine whether it is able to be clicked.\n     */\n    public void updateDeleteButton() {\n        boolean enabled = mInputPointer != -1;\n        if (mDelete != null) {\n            mDelete.setEnabled(enabled);\n            mDelete.setAlpha(enabled? (float) 1: (float) 0.3);\n        }\n    }\n    @Override\n    public void onClick(View v) {\n        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);\n        doOnClick(v);\n        updateDeleteButton();\n    }\n    protected void doOnClick(View v) {\n        Integer val = (Integer) v.getTag(R.id.numbers_key);\n        if (val != null) {\n            // A number was pressed\n            addClickedNumber(val);\n        } else if (v == mDelete) {\n            if (mInputPointer >= 0) {\n                for (int i = 0; i < mInputPointer; i++) {\n                    mInput[i] = mInput[i + 1];\n                }\n                mInput[mInputPointer] = 0;\n                mInputPointer--;\n            }\n        } else if (v == mLeft) {\n            onLeftClicked();\n        } else if (v == mRight) {\n            onRightClicked();\n        }\n        updateKeypad();\n    }\n    @Override\n    public boolean onLongClick(View v) {\n        v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);\n        if (v == mDelete) {\n            mDelete.setPressed(false);\n            reset();\n            updateKeypad();\n            return true;\n        }\n        return false;\n    }\n    private void updateKeypad() {\n        // Update state of keypad\n        updateLeftRightButtons();\n        // Update the number\n        updateNumber();\n        // enable/disable the \"set\" key\n        enableSetButton();\n        // Update the backspace button\n        updateDeleteButton();\n        // Update the zero button\n        updateZeroButton();\n    }\n    /**\n     * Set the text displayed in the small label\n     *\n     * @param labelText the String to set as the label\n     */\n    public void setLabelText(String labelText) {\n        mLabelText = labelText;\n    }\n    /**\n     * Reset all inputs.\n     */\n    public void reset() {\n        for (int i = 0; i < mInputSize; i++) {\n            mInput[i] = -1;\n        }\n        mInputPointer = -1;\n        updateNumber();\n    }\n    public void enableKeypad(boolean enable) {\n        for (int i = 0; i < 10; i++) {\n            mNumbers[i].setEnabled(enable);\n        }\n        mLeft.setEnabled(enable);\n    }\n    // Update the number displayed in the picker:\n    protected void updateNumber() {\n        String numberString = getEnteredNumberString();\n        numberString = numberString.replaceAll(\"\\\\-\", \"\");\n        String[] split = numberString.split(\"\\\\.\");\n        if (split.length >= 2) {\n            if (split[0].equals(\"\")) {\n                mEnteredNumber.setNumber(\"0\", split[1], containsDecimal(),\n                        mSign == SIGN_NEGATIVE);\n            } else {\n                mEnteredNumber.setNumber(split[0], split[1], containsDecimal(),\n                        mSign == SIGN_NEGATIVE);\n            }\n        } else if (split.length == 1) {\n            if (split[0].equals(String.valueOf(Integer.MAX_VALUE))) {\n                split[0] = \"\u221e\";\n            }\n            mEnteredNumber.setNumber(split[0], \"\", containsDecimal(),\n                    mSign == SIGN_NEGATIVE);\n        } else if (numberString.equals(\".\")) {\n            mEnteredNumber.setNumber(\"0\", \"\", true, mSign == SIGN_NEGATIVE);\n        }\n    }\n    protected void setLeftRightEnabled() {\n        mLeft.setEnabled(false);\n        mRight.setEnabled(canAddDecimal());\n        if (!canAddDecimal()) {\n            mRight.setContentDescription(null);\n        }\n    }\n    private void addClickedNumber(int val) {\n        if (mInputPointer < mInputSize - 1) {\n            // For 0 we need to check if we have a value of zero or not\n            for (int i = mInputPointer; i >= 0; i--) {\n                mInput[i + 1] = mInput[i];\n            }\n            mInputPointer++;\n            mInput[0] = val;\n        }\n    }\n    /**\n     * Clicking on the bottom left button will toggle the sign.\n     */\n    private void onLeftClicked() {\n        if (mSign == SIGN_POSITIVE) {\n            mSign = SIGN_NEGATIVE;\n        } else {\n            mSign = SIGN_POSITIVE;\n        }\n    }\n    /**\n     * Clicking on the bottom right button will add a decimal point.\n     */\n    private void onRightClicked() {\n        if (canAddDecimal()) {\n            addClickedNumber(CLICKED_DECIMAL);\n        }\n    }\n    private boolean containsDecimal() {\n        boolean containsDecimal = false;\n        for (int i : mInput) {\n            if (i == 10) {\n                containsDecimal = true;\n            }\n        }\n        return containsDecimal;\n    }\n    /**\n     * Checks if the user allowed to click on the right button.\n     *\n     * @return true or false if the user is able to add a decimal or not\n     */\n    private boolean canAddDecimal() {\n        return !containsDecimal();\n    }\n    private String getEnteredNumberString() {\n        String value = \"\";\n        for (int i = mInputPointer; i >= 0; i--) {\n            if (mInput[i] == -1) {\n                // Don't add\n            } else if (mInput[i] == CLICKED_DECIMAL) {\n                value += \".\";\n            } else {\n                value += mInput[i];\n            }\n        }\n        return value;\n    }\n    /**\n     * Returns the number inputted by the user\n     *\n     * @return a double representing the entered number\n     */\n    public BigDecimal getEnteredNumber() {\n        String value = \"0\";\n        for (int i = mInputPointer; i >= 0; i--) {\n            if (mInput[i] == -1) {\n                break;\n            } else if (mInput[i] == CLICKED_DECIMAL) {\n                value += \".\";\n            } else {\n                value += mInput[i];\n            }\n        }\n        if (mSign == SIGN_NEGATIVE) {\n            value = \"-\" + value;\n        }\n        return new BigDecimal(value);\n    }\n    private void updateLeftRightButtons() {\n        mRight.setEnabled(canAddDecimal());\n    }\n    /**\n     * Enable/disable the \"Set\" button\n     */\n    private void enableSetButton() {\n        if (mSetButton == null) {\n            return;\n        }\n        boolean enabled = true;\n        // Nothing entered - disable, or = 0\n        if (mInputPointer == -1 || mInputPointer < 0) {\n            enabled = false;\n        }\n        mSetButton.setEnabled(enabled);\n        mSetButton.setAlpha(enabled? (float) 1: (float) 0.4);\n    }\n    /**\n     * Expose the set button to allow communication with the parent Fragment.\n     *\n     * @param b the parent Fragment's \"Set\" button\n     */\n    public void setSetButton(Button b) {\n        mSetButton = b;\n        enableSetButton();\n    }\n    /**\n     * Returns the number as currently inputted by the user\n     *\n     * @return an String representation of the number with no decimal\n     */\n    public BigInteger getNumber() {\n        BigDecimal bigDecimal = getEnteredNumber().setScale(0, BigDecimal.ROUND_FLOOR);\n        return bigDecimal.toBigIntegerExact();\n    }\n    /**\n     * Returns the decimal following the number\n     *\n     * @return a double representation of the decimal value\n     */\n    public double getDecimal() {\n        return getEnteredNumber().remainder(BigDecimal.ONE).doubleValue();\n    }\n    /**\n     * Returns whether the number is positive or negative\n     *\n     * @return true or false whether the number is positive or negative\n     */\n    public boolean getIsNegative() {\n        return mSign == SIGN_NEGATIVE;\n    }\n    public void setNumber(Integer integerPart, Double decimalPart, Integer mCurrentSign) {\n        if (mCurrentSign != null) {\n            mSign = mCurrentSign;\n        } else {\n            mSign = SIGN_POSITIVE;\n        }\n        if (decimalPart != null) {\n            String decimalString = doubleToString(decimalPart);\n            // remove \"0.\" from the string\n            readAndRightDigits(TextUtils.substring(decimalString, 2, decimalString.length()));\n            mInputPointer++;\n            mInput[mInputPointer] = CLICKED_DECIMAL;\n        }\n        if (integerPart != null) {\n            readAndRightDigits(String.valueOf(integerPart));\n        }\n        updateKeypad();\n    }\n    private void readAndRightDigits(String digitsToRead) {\n        for (int i = digitsToRead.length() - 1; i >= 0; i--) {\n            mInputPointer++;\n            mInput[mInputPointer] = digitsToRead.charAt(i) - '0';\n        }\n    }\n    /**\n     * Method used to format double and avoid scientific notation x.xE-x (ex: 4.0E-4)\n     *\n     * @param value double value to format\n     * @return string representation of double value\n     */\n    private String doubleToString(double value) {\n        // Use decimal format to avoid\n        DecimalFormat format = new DecimalFormat(\"0.0\");\n        format.setMaximumFractionDigits(Integer.MAX_VALUE);\n        return format.format(value);\n    }\n"]], "pred": {"ppl": 1.8158166408538818, "ppl_lower": 2.073793888092041, "ppl/lowercase_ppl": -1.2226933060359593, "ppl/zlib": 0.0001578135731186835, "Min_5.0% Prob": 6.023074589523614, "Min_10.0% Prob": 4.369709007880267, "Min_20.0% Prob": 2.767689368011905, "Min_30.0% Prob": 1.9551371760130707, "Min_40.0% Prob": 1.4846699644964014, "Min_50.0% Prob": 1.1926359470911805, "Min_60.0% Prob": 0.995183354016123}}
{"hexsha": "92c8dfdbe78fe366baed58c95037a1c963e22e47", "ext": "java", "lang": "Java", "content": "public final class FindOccurrencesEngine {\n\n\tpublic static FindOccurrencesEngine create(IOccurrencesFinder finder) {\n\t\treturn new FindOccurrencesEngine(finder);\n\t}\n\n\tprivate IOccurrencesFinder fFinder;\n\n\tprivate FindOccurrencesEngine(IOccurrencesFinder finder) {\n\t\tif (finder == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfFinder = finder;\n\t}\n\n\tprivate String run(Program astRoot, int offset, int length) {\n\t\tString message = fFinder.initialize(astRoot, offset, length);\n\t\tif (message != null)\n\t\t\treturn message;\n\n\t\tperformNewSearch(fFinder, astRoot.getSourceModule());\n\t\treturn null;\n\t}\n\n\tpublic String run(ISourceModule input, int offset, int length)\n\t\t\tthrows ModelException, IOException {\n\t\tif (input.getSourceRange() == null) {\n\t\t\treturn \"SearchMessages.FindOccurrencesEngine_noSource_text\"; //$NON-NLS-1$\n\t\t}\n\n\t\tfinal Program root = SharedASTProvider.getAST(input,\n\t\t\t\tSharedASTProvider.WAIT_YES, null);\n\t\tif (root == null) {\n\t\t\treturn \"SearchMessages.FindOccurrencesEngine_cannotParse_text\"; //$NON-NLS-1$\n\t\t}\n\t\treturn run(root, offset, length);\n\t}\n\n\tprivate void performNewSearch(IOccurrencesFinder finder,\n\t\t\tISourceModule element) {\n\t\tNewSearchUI.runQueryInBackground(new OccurrencesSearchQuery(finder,\n\t\t\t\telement));\n\t}\n}", "class_id": 0, "repo": "NisalaNiroshana/developer-studio", "file": "jaggery/org.eclipse.php.ui/src/org/eclipse/php/internal/ui/search/FindOccurrencesEngine.java", "last_update_at": "2018-10-26T12:52:03+00:00", "question_id": "92c8dfdbe78fe366baed58c95037a1c963e22e47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class FindOccurrencesEngine {\n\tpublic static FindOccurrencesEngine create(IOccurrencesFinder finder) {\n\t\treturn new FindOccurrencesEngine(finder);\n\t}\n\tprivate IOccurrencesFinder fFinder;\n\tprivate FindOccurrencesEngine(IOccurrencesFinder finder) {\n\t\tif (finder == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfFinder = finder;\n\t}\n\tprivate String run(Program astRoot, int offset, int length) {\n\t\tString message = fFinder.initialize(astRoot, offset, length);\n\t\tif (message != null)\n\t\t\treturn message;\n\t\tperformNewSearch(fFinder, astRoot.getSourceModule());\n\t\treturn null;\n\t}\n\tpublic String run(ISourceModule input, int offset, int length)\n\t\t\tthrows ModelException, IOException {\n\t\tif (input.getSourceRange() == null) {\n\t\t\treturn \"SearchMessages.FindOccurrencesEngine_noSource_text\"; //$NON-NLS-1$\n\t\t}\n\t\tfinal Program root = SharedASTProvider.getAST(input,\n\t\t\t\tSharedASTProvider.WAIT_YES, null);\n\t\tif (root == null) {\n\t\t\treturn \"SearchMessages.FindOccurrencesEngine_cannotParse_text\"; //$NON-NLS-1$\n\t\t}\n\t\treturn run(root, offset, length);\n\t}\n\tprivate void performNewSearch(IOccurrencesFinder finder,\n\t\t\tISourceModule element) {\n\t\tNewSearchUI.runQueryInBackground(new OccurrencesSearchQuery(finder,\n\t\t\t\telement));\n\t}\n"]], "pred": {"ppl": 2.020578622817993, "ppl_lower": 2.9295215606689453, "ppl/lowercase_ppl": -1.5280973780216782, "ppl/zlib": 0.0014238540836733241, "Min_5.0% Prob": 6.887044747670491, "Min_10.0% Prob": 4.996164499327194, "Min_20.0% Prob": 3.190263263707937, "Min_30.0% Prob": 2.284830473652182, "Min_40.0% Prob": 1.7448512886672518, "Min_50.0% Prob": 1.4038025296877983, "Min_60.0% Prob": 1.171702099538069}}
{"hexsha": "731e371e5ca6687559f264f32bd28fd8e61b2fd8", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"ConstantConditions\")\npublic final class EmailUtils {\n\n\t/**\n\t * Remove emails que possuem o mesmo t\u00edtulo e conteudo, ou seja,\n\t * s\u00e3o iguais perante o equals.\n\t *\n\t * @param emailList - cabe\u00e7a da lista de emails\n\t * @return lista de emails sem duplicacoes\n\t */\n\tpublic static SingleLinkedList<Email> cleanDuplicatedEmails(SingleLinkedList<Email> emailList) {\n\t\tLinkedNode<Email> head = emailList.getHead();\n\t\tif (emailList == null || emailList.isEmpty()) {\n\t\t\treturn emailList;\n\t\t}\n\n\t\tLinkedNode<Email> auxNode = head;\n\t\tfor (; auxNode != null; auxNode = auxNode.getNext()) {\n\t\t\tif (auxNode.getNext() == null) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tLinkedNode<Email> next = auxNode.getNext();\n\t\t\t\tLinkedNode<Email> prevNode = auxNode;\n\t\t\t\tfor (; next != null; next = next.getNext()) {\n\t\t\t\t\tif (isDuplicatedEmail(auxNode.getValue(), next.getValue())) {\n\t\t\t\t\t\tif (next.getNext() != null) {\n\t\t\t\t\t\t\tprevNode.setNext(next.getNext());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprevNode.setNext(null); // Final da lista\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevNode = next; // atualiza prev somente para nao iguais\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\temailList.updateSize();\n\n\t\treturn emailList;\n\t}\n\n\t/**\n\t * Encontra o n\u00f3 que tem a mesma referencia que o n\u00f3 de outra lista tem.\n\t *\n\t * @param firstList  - primeira lista\n\t * @param secondList - a lista que sera verificado elemento a elemento se possue mesma ref que da primeira lista.\n\t * @return primeiro n\u00f3 que ambas listas possuem mesma referencia\n\t */\n\tpublic static LinkedNode<Email> findIntersectionBetween(SingleLinkedList<Email> firstList, SingleLinkedList<Email> secondList) {\n\t\tLinkedNode<Email> head = firstList.getHead();\n\t\tLinkedNode<Email> secondHead = secondList.getHead();\n\t\tfor (; head != null && secondHead != null; head = head.getNext(), secondHead = secondList.getHead()) {\n\t\t\tfor (; secondHead != null; secondHead = secondHead.getNext()) {\n\t\t\t\tif (head.getNext() == secondHead.getNext()) {\n\t\t\t\t\treturn head.getNext();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static boolean isDuplicatedEmail(Email actual, Email compare) {\n\t\treturn actual.equals(compare);\n\t}\n}", "class_id": 0, "repo": "alexferreiradev/cesar_android", "file": "cesar_app/app/src/main/java/com/arfapps/cesar_app/util/EmailUtils.java", "last_update_at": "2018-08-17T09:10:07+00:00", "question_id": "731e371e5ca6687559f264f32bd28fd8e61b2fd8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"ConstantConditions\")\npublic final class EmailUtils {\n\t/**\n\t * Remove emails que possuem o mesmo t\u00edtulo e conteudo, ou seja,\n\t * s\u00e3o iguais perante o equals.\n\t *\n\t * @param emailList - cabe\u00e7a da lista de emails\n\t * @return lista de emails sem duplicacoes\n\t */\n\tpublic static SingleLinkedList<Email> cleanDuplicatedEmails(SingleLinkedList<Email> emailList) {\n\t\tLinkedNode<Email> head = emailList.getHead();\n\t\tif (emailList == null || emailList.isEmpty()) {\n\t\t\treturn emailList;\n\t\t}\n\t\tLinkedNode<Email> auxNode = head;\n\t\tfor (; auxNode != null; auxNode = auxNode.getNext()) {\n\t\t\tif (auxNode.getNext() == null) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tLinkedNode<Email> next = auxNode.getNext();\n\t\t\t\tLinkedNode<Email> prevNode = auxNode;\n\t\t\t\tfor (; next != null; next = next.getNext()) {\n\t\t\t\t\tif (isDuplicatedEmail(auxNode.getValue(), next.getValue())) {\n\t\t\t\t\t\tif (next.getNext() != null) {\n\t\t\t\t\t\t\tprevNode.setNext(next.getNext());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprevNode.setNext(null); // Final da lista\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevNode = next; // atualiza prev somente para nao iguais\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\temailList.updateSize();\n\t\treturn emailList;\n\t}\n\t/**\n\t * Encontra o n\u00f3 que tem a mesma referencia que o n\u00f3 de outra lista tem.\n\t *\n\t * @param firstList  - primeira lista\n\t * @param secondList - a lista que sera verificado elemento a elemento se possue mesma ref que da primeira lista.\n\t * @return primeiro n\u00f3 que ambas listas possuem mesma referencia\n\t */\n\tpublic static LinkedNode<Email> findIntersectionBetween(SingleLinkedList<Email> firstList, SingleLinkedList<Email> secondList) {\n\t\tLinkedNode<Email> head = firstList.getHead();\n\t\tLinkedNode<Email> secondHead = secondList.getHead();\n\t\tfor (; head != null && secondHead != null; head = head.getNext(), secondHead = secondList.getHead()) {\n\t\t\tfor (; secondHead != null; secondHead = secondHead.getNext()) {\n\t\t\t\tif (head.getNext() == secondHead.getNext()) {\n\t\t\t\t\treturn head.getNext();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static boolean isDuplicatedEmail(Email actual, Email compare) {\n\t\treturn actual.equals(compare);\n\t}\n"]], "pred": {"ppl": 1.9791418313980103, "ppl_lower": 2.0998966693878174, "ppl/lowercase_ppl": -1.0867555109499836, "ppl/zlib": 0.0008935383930204846, "Min_5.0% Prob": 6.671003140901265, "Min_10.0% Prob": 4.922106182420409, "Min_20.0% Prob": 3.178770035892338, "Min_30.0% Prob": 2.240520388339505, "Min_40.0% Prob": 1.698902810396307, "Min_50.0% Prob": 1.3650854613265224, "Min_60.0% Prob": 1.1392979923651814}}
{"hexsha": "9486a1f28603d9667ed026c3ca86f2c57691eabb", "ext": "java", "lang": "Java", "content": "public class TestObservationFilter {\n\tprivate HDF5Dataset ds;\n\tprivate static TestData td;\n\tprivate ObservationFilter filter;\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws IOException {\n\t\ttd = new TestData();\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() {\n\t\ttd.dispose();\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t\tds = new HDF5Dataset(td.getPath());\n\t\tfilter = new ObservationFilter(ds, \"http://fake/\");\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t\tds.dispose();\n\t}\n\n\tprivate void checkObservation(Observation obs)\n\t\t\tthrows CloneNotSupportedException {\n\t\t// observation -> URL -> meta is just a fast way of getting an\n\t\t// observationMeta\n\t\tString obsURL = URLScheme.observationURL(obs);\n\t\tObservationMeta meta = URLScheme.parseObservationURL(obsURL);\n\t\tObservation shouldMatch = ObservationFilter.retrieveFromMeta(meta, ds, \"http://fake/\");\n\t\tassertNotNull(shouldMatch);\n\t\tassertTrue(obs.equals(shouldMatch));\n\n\t\t// Try retrieving some junk, just because we can\n\t\tObservationMeta brokenCellMeta = meta.clone();\n\t\tbrokenCellMeta.cell = brokenCellMeta.cell + \"AKSJD\";\n\t\tassertNull(ObservationFilter.retrieveFromMeta(brokenCellMeta, ds, \"http://fake/\"));\n\n\t\tObservationMeta brokenLevelMeta = meta.clone();\n\t\tbrokenLevelMeta.levelPixel = -1;\n\t\tassertNull(ObservationFilter.retrieveFromMeta(brokenLevelMeta, ds, \"http://fake/\"));\n\t}\n\n\t@Test\n\tpublic void testGetFromMeta() throws CloneNotSupportedException {\n\t\tCell cell = ds.dggsCell(\"R7852\");\n\t\tZonedDateTime timestamp = ZonedDateTime.parse(\"2013-05-27T23:58:20Z\");\n\t\tProduct product = new Product(ds, \"LS8_OLI_TIRS_NBAR\");\n\t\tcheckObservation(cell.pixelObservation(product, timestamp, 4));\n\t\tcheckObservation(cell.tileObservation(product, timestamp, 3));\n\t}\n\n\tprivate void checkTypeFilterCount(int expected, Resource val) {\n\t\tfilter = new ObservationFilter(ds, \"http://fake/\");\n\t\tObservationProperty typeFilter = PropertyIndex\n\t\t\t\t.getProperty(RDF.type.getURI()).get();\n\t\ttypeFilter.applyToFilter(filter, val.asNode());\n\t\tassertEquals(expected, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByType() {\n\t\t// First, count the number of observations (no filtering)\n\t\tassertEquals(84, filter.execute().count());\n\t\tcheckTypeFilterCount(0, LED.time);\n\t\tcheckTypeFilterCount(84, QB.Observation);\n\t\tcheckTypeFilterCount(42, LED.Pixel);\n\t\tcheckTypeFilterCount(42, LED.GridSquare);\n\t}\n\n\t@Test\n\tpublic void testIncompatibleType() {\n\t\tfilter.constrainToPixel().constrainToPixel();\n\t\tassertEquals(84 / 2, filter.execute().count());\n\t\tfilter.constrainToTile();\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testIncompatibleLevel() {\n\t\tfilter.constrainLevel(3).constrainLevel(3);\n\t\tassertEquals(14, filter.execute().count());\n\t\tfilter.constrainLevel(5);\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testIncompatibleBand() {\n\t\t// double-specification of bands is fine iff it's the same band\n\t\tfilter.constrainBandNum(3).constrainBandNum(3);\n\t\tassertEquals(84 / 7, filter.execute().count());\n\t\tfilter.constrainBandNum(4);\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testIncompatibleCellID() {\n\t\tfilter.constrainCellID(\"R78\").constrainCellID(\"R78\")\n\t\t\t\t.constrainCellID(\"R91\");\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testConstrainLocation() {\n\t\tfilter.constrainLatMin(-35.45).constrainLatMax(-35)\n\t\t\t\t.constrainLonMin(148.8).constrainLonMax(149.3)\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));\n\t\tList<String> cellIDs = filter.execute()\n\t\t\t\t.map(obs -> obs.getCell().getDGGSIdent())\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, cellIDs.size());\n\t\tassertEquals(\"R78523\", cellIDs.get(0));\n\t}\n\n\t@Test\n\tpublic void testNonexistentProperty() {\n\t\tfilter.constrainProperty(\"http://example.com/doesntExist\",\n\t\t\t\tcreateLiteralNode(42));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testConstrainNaively() {\n\t\t// there are some thing that we can't really constrain by in an efficent\n\t\t// way\n\t\tfilter.constrainNaively(PropertyIndex.getProperty(LED.etmBand).get(),\n\t\t\t\tcreateLiteralNode(3));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\t// there are 84 observations total in the test set, and 7 bands, so we\n\t\t// should get back 1/7th of the observations\n\t\tassertEquals(84 / 7, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(3, obs.getBand());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testIndirectNaiveConstraint() {\n\t\t// we can only really filter values naively, since we don't have an\n\t\t// inverted index for them\n\t\tfilter.constrainProperty(LED.value.getURI(),\n\t\t\t\tcreateLiteralNode(new Double(931.0)));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertTrue(obs instanceof PixelObservation);\n\t\t\tassertEquals(931.0, ((PixelObservation) obs).getPixel(), 0.001);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testFilterByDGGSSquare() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(14, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(\"R7852\", obs.getCell().getDGGSIdent());\n\t\t}\n\n\t\t// compatible constrain doesn't change anything\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"));\n\t\tassertEquals(14, filter.execute().count());\n\n\t\t// incompatible constraint breaks everything\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R785\"));\n\t\tassertEquals(0, filter.execute().count());\n\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByNonExistentSquare() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R8192\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByBand() {\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(12, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(3, obs.getBand());\n\t\t}\n\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));\n\t\tassertEquals(12, filter.execute().count());\n\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(4));\n\t\tassertEquals(0, filter.execute().count());\n\n\t\tfilter.constrainProperty(LED.etmBand.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByNonexistentBand() {\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(17));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByLevel() {\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(5));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(14, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(5, obs.getCellLevel());\n\t\t}\n\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(5));\n\t\tassertEquals(14, filter.execute().count());\n\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(6));\n\t\tassertEquals(0, filter.execute().count());\n\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testFilterByNonexistentLevel() {\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(21));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testComposeFilters() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"))\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(5))\n\t\t\t\t.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\t\t\tcreateLiteralNode(5))\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.Pixel.asNode());\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, allObs.size());\n\t\tObservation firstObs = allObs.get(0);\n\t\tassertEquals(5, firstObs.getBand());\n\t\tassertEquals(\"R7852\", firstObs.getCell().getDGGSIdent());\n\t\tassertEquals(5, firstObs.getCellLevel());\n\t}\n\n\t@Test\n\tpublic void testIrrelevantLatLonBoxProperty() {\n\t\t// Shouldn't do anything\n\t\tfilter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-80.0));\n\t\tassertEquals(84, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testInvalidLatLonBoxProperty() {\n\t\tfilter.constrainProperty(BoxRight.getURI(),\n\t\t\t\tcreateLiteralNode(\"clearly not a number\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\n\t@Test\n\tpublic void testMeaningfulLatLonBoxProperty() {\n\t\tfilter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-35.45))\n\t\t\t\t.constrainProperty(BoxTop.getURI(), createLiteralNode(-35))\n\t\t\t\t.constrainProperty(BoxLeft.getURI(), createLiteralNode(148.8))\n\t\t\t\t.constrainProperty(BoxRight.getURI(), createLiteralNode(149.3))\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));\n\t\tList<Observation> out = filter.execute().collect(Collectors.toList());\n\t\tassertEquals(1, out.size());\n\t\tassertEquals(\"R78523\", out.get(0).getCell().getDGGSIdent());\n\n\t}\n}", "class_id": 0, "repo": "ANU-Linked-Earth-Data/middleware", "file": "dynamic-store/src/test/java/anuled/dynamicstore/rdfmapper/TestObservationFilter.java", "last_update_at": "2018-05-25T14:03:31+00:00", "question_id": "9486a1f28603d9667ed026c3ca86f2c57691eabb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestObservationFilter {\n\tprivate HDF5Dataset ds;\n\tprivate static TestData td;\n\tprivate ObservationFilter filter;\n\t@BeforeClass\n\tpublic static void setUpClass() throws IOException {\n\t\ttd = new TestData();\n\t}\n\t@AfterClass\n\tpublic static void tearDownClass() {\n\t\ttd.dispose();\n\t}\n\t@Before\n\tpublic void setUp() {\n\t\tds = new HDF5Dataset(td.getPath());\n\t\tfilter = new ObservationFilter(ds, \"http://fake/\");\n\t}\n\t@After\n\tpublic void tearDown() {\n\t\tds.dispose();\n\t}\n\tprivate void checkObservation(Observation obs)\n\t\t\tthrows CloneNotSupportedException {\n\t\t// observation -> URL -> meta is just a fast way of getting an\n\t\t// observationMeta\n\t\tString obsURL = URLScheme.observationURL(obs);\n\t\tObservationMeta meta = URLScheme.parseObservationURL(obsURL);\n\t\tObservation shouldMatch = ObservationFilter.retrieveFromMeta(meta, ds, \"http://fake/\");\n\t\tassertNotNull(shouldMatch);\n\t\tassertTrue(obs.equals(shouldMatch));\n\t\t// Try retrieving some junk, just because we can\n\t\tObservationMeta brokenCellMeta = meta.clone();\n\t\tbrokenCellMeta.cell = brokenCellMeta.cell + \"AKSJD\";\n\t\tassertNull(ObservationFilter.retrieveFromMeta(brokenCellMeta, ds, \"http://fake/\"));\n\t\tObservationMeta brokenLevelMeta = meta.clone();\n\t\tbrokenLevelMeta.levelPixel = -1;\n\t\tassertNull(ObservationFilter.retrieveFromMeta(brokenLevelMeta, ds, \"http://fake/\"));\n\t}\n\t@Test\n\tpublic void testGetFromMeta() throws CloneNotSupportedException {\n\t\tCell cell = ds.dggsCell(\"R7852\");\n\t\tZonedDateTime timestamp = ZonedDateTime.parse(\"2013-05-27T23:58:20Z\");\n\t\tProduct product = new Product(ds, \"LS8_OLI_TIRS_NBAR\");\n\t\tcheckObservation(cell.pixelObservation(product, timestamp, 4));\n\t\tcheckObservation(cell.tileObservation(product, timestamp, 3));\n\t}\n\tprivate void checkTypeFilterCount(int expected, Resource val) {\n\t\tfilter = new ObservationFilter(ds, \"http://fake/\");\n\t\tObservationProperty typeFilter = PropertyIndex\n\t\t\t\t.getProperty(RDF.type.getURI()).get();\n\t\ttypeFilter.applyToFilter(filter, val.asNode());\n\t\tassertEquals(expected, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByType() {\n\t\t// First, count the number of observations (no filtering)\n\t\tassertEquals(84, filter.execute().count());\n\t\tcheckTypeFilterCount(0, LED.time);\n\t\tcheckTypeFilterCount(84, QB.Observation);\n\t\tcheckTypeFilterCount(42, LED.Pixel);\n\t\tcheckTypeFilterCount(42, LED.GridSquare);\n\t}\n\t@Test\n\tpublic void testIncompatibleType() {\n\t\tfilter.constrainToPixel().constrainToPixel();\n\t\tassertEquals(84 / 2, filter.execute().count());\n\t\tfilter.constrainToTile();\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testIncompatibleLevel() {\n\t\tfilter.constrainLevel(3).constrainLevel(3);\n\t\tassertEquals(14, filter.execute().count());\n\t\tfilter.constrainLevel(5);\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testIncompatibleBand() {\n\t\t// double-specification of bands is fine iff it's the same band\n\t\tfilter.constrainBandNum(3).constrainBandNum(3);\n\t\tassertEquals(84 / 7, filter.execute().count());\n\t\tfilter.constrainBandNum(4);\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testIncompatibleCellID() {\n\t\tfilter.constrainCellID(\"R78\").constrainCellID(\"R78\")\n\t\t\t\t.constrainCellID(\"R91\");\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testConstrainLocation() {\n\t\tfilter.constrainLatMin(-35.45).constrainLatMax(-35)\n\t\t\t\t.constrainLonMin(148.8).constrainLonMax(149.3)\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));\n\t\tList<String> cellIDs = filter.execute()\n\t\t\t\t.map(obs -> obs.getCell().getDGGSIdent())\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, cellIDs.size());\n\t\tassertEquals(\"R78523\", cellIDs.get(0));\n\t}\n\t@Test\n\tpublic void testNonexistentProperty() {\n\t\tfilter.constrainProperty(\"http://example.com/doesntExist\",\n\t\t\t\tcreateLiteralNode(42));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testConstrainNaively() {\n\t\t// there are some thing that we can't really constrain by in an efficent\n\t\t// way\n\t\tfilter.constrainNaively(PropertyIndex.getProperty(LED.etmBand).get(),\n\t\t\t\tcreateLiteralNode(3));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\t// there are 84 observations total in the test set, and 7 bands, so we\n\t\t// should get back 1/7th of the observations\n\t\tassertEquals(84 / 7, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(3, obs.getBand());\n\t\t}\n\t}\n\t@Test\n\tpublic void testIndirectNaiveConstraint() {\n\t\t// we can only really filter values naively, since we don't have an\n\t\t// inverted index for them\n\t\tfilter.constrainProperty(LED.value.getURI(),\n\t\t\t\tcreateLiteralNode(new Double(931.0)));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertTrue(obs instanceof PixelObservation);\n\t\t\tassertEquals(931.0, ((PixelObservation) obs).getPixel(), 0.001);\n\t\t}\n\t}\n\t@Test\n\tpublic void testFilterByDGGSSquare() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(14, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(\"R7852\", obs.getCell().getDGGSIdent());\n\t\t}\n\t\t// compatible constrain doesn't change anything\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"));\n\t\tassertEquals(14, filter.execute().count());\n\t\t// incompatible constraint breaks everything\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R785\"));\n\t\tassertEquals(0, filter.execute().count());\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByNonExistentSquare() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R8192\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByBand() {\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(12, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(3, obs.getBand());\n\t\t}\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));\n\t\tassertEquals(12, filter.execute().count());\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(4));\n\t\tassertEquals(0, filter.execute().count());\n\t\tfilter.constrainProperty(LED.etmBand.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByNonexistentBand() {\n\t\tfilter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(17));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByLevel() {\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(5));\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(14, allObs.size());\n\t\tfor (Observation obs : allObs) {\n\t\t\tassertEquals(5, obs.getCellLevel());\n\t\t}\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(5));\n\t\tassertEquals(14, filter.execute().count());\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(6));\n\t\tassertEquals(0, filter.execute().count());\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateURINode(\"http://not-a-literal/\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testFilterByNonexistentLevel() {\n\t\tfilter.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\tcreateLiteralNode(21));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testComposeFilters() {\n\t\tfilter.constrainProperty(LED.dggsCell.getURI(),\n\t\t\t\tcreateLiteralNode(\"R7852\"))\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(5))\n\t\t\t\t.constrainProperty(LED.dggsLevelSquare.getURI(),\n\t\t\t\t\t\tcreateLiteralNode(5))\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.Pixel.asNode());\n\t\tList<Observation> allObs = filter.execute()\n\t\t\t\t.collect(Collectors.toList());\n\t\tassertEquals(1, allObs.size());\n\t\tObservation firstObs = allObs.get(0);\n\t\tassertEquals(5, firstObs.getBand());\n\t\tassertEquals(\"R7852\", firstObs.getCell().getDGGSIdent());\n\t\tassertEquals(5, firstObs.getCellLevel());\n\t}\n\t@Test\n\tpublic void testIrrelevantLatLonBoxProperty() {\n\t\t// Shouldn't do anything\n\t\tfilter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-80.0));\n\t\tassertEquals(84, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testInvalidLatLonBoxProperty() {\n\t\tfilter.constrainProperty(BoxRight.getURI(),\n\t\t\t\tcreateLiteralNode(\"clearly not a number\"));\n\t\tassertEquals(0, filter.execute().count());\n\t}\n\t@Test\n\tpublic void testMeaningfulLatLonBoxProperty() {\n\t\tfilter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-35.45))\n\t\t\t\t.constrainProperty(BoxTop.getURI(), createLiteralNode(-35))\n\t\t\t\t.constrainProperty(BoxLeft.getURI(), createLiteralNode(148.8))\n\t\t\t\t.constrainProperty(BoxRight.getURI(), createLiteralNode(149.3))\n\t\t\t\t.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())\n\t\t\t\t.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));\n\t\tList<Observation> out = filter.execute().collect(Collectors.toList());\n\t\tassertEquals(1, out.size());\n\t\tassertEquals(\"R78523\", out.get(0).getCell().getDGGSIdent());\n\t}\n"]], "pred": {"ppl": 2.7231101989746094, "ppl_lower": 2.9934442043304443, "ppl/lowercase_ppl": -1.0944822736588615, "ppl/zlib": 0.0005034043630984704, "Min_5.0% Prob": 8.077272471259622, "Min_10.0% Prob": 6.204501339033539, "Min_20.0% Prob": 4.276919001457738, "Min_30.0% Prob": 3.206033289627312, "Min_40.0% Prob": 2.47872015145268, "Min_50.0% Prob": 1.9988075269936583, "Min_60.0% Prob": 1.6702608361165685}}
{"hexsha": "a2d196adf032d898ad48dcfdb93c63bcb959f615", "ext": "java", "lang": "Java", "content": "public class RealmITCase extends AbstractITCase {\n\n    private static Optional<RealmTO> getRealm(final String fullPath) {\n        return realmService.list(fullPath).stream().filter(realm -> fullPath.equals(realm.getFullPath())).findFirst();\n    }\n\n    @Test\n    public void search() {\n        PagedResult<RealmTO> match = realmService.search(new RealmQuery.Builder().keyword(\"*o*\").build());\n        assertTrue(match.getResult().stream().allMatch(realm -> realm.getName().contains(\"o\")));\n    }\n\n    @Test\n    public void list() {\n        List<RealmTO> realms = realmService.list(SyncopeConstants.ROOT_REALM);\n        assertNotNull(realms);\n        assertFalse(realms.isEmpty());\n        realms.forEach(Assertions::assertNotNull);\n\n        try {\n            realmService.list(\"a name\");\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.InvalidPath, e.getType());\n        }\n    }\n\n    @Test\n    public void createUpdate() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"last\");\n\n        // 1. create\n        Response response = realmService.create(\"/even/two\", realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertNotNull(actual.getKey());\n        assertEquals(\"last\", actual.getName());\n        assertEquals(\"/even/two/last\", actual.getFullPath());\n        assertEquals(actual.getParent(), getRealm(\"/even/two\").get().getKey());\n        assertNull(realm.getAccountPolicy());\n        assertNull(realm.getPasswordPolicy());\n\n        // 2. update setting policies\n        actual.setAccountPolicy(\"06e2ed52-6966-44aa-a177-a0ca7434201f\");\n        actual.setPasswordPolicy(\"986d1236-3ac5-4a19-810c-5ab21d79cba1\");\n        actual.setAuthPolicy(\"b912a0d4-a890-416f-9ab8-84ab077eb028\");\n        actual.setAccessPolicy(\"419935c7-deb3-40b3-8a9a-683037e523a2\");\n        actual.setAttrReleasePolicy(\"319935c7-deb3-40b3-8a9a-683037e523a2\");\n        realmService.update(actual);\n\n        actual = getRealm(actual.getFullPath()).get();\n        assertNotNull(actual.getAccountPolicy());\n        assertNotNull(actual.getPasswordPolicy());\n        assertNotNull(actual.getAuthPolicy());\n        assertNotNull(actual.getAccessPolicy());\n        assertNotNull(actual.getAttrReleasePolicy());\n\n        // 3. update changing parent\n        actual.setParent(getRealm(\"/odd\").get().getKey());\n        realmService.update(actual);\n\n        actual = getRealm(\"/odd/last\").get();\n        assertNotNull(actual);\n        assertEquals(\"/odd/last\", actual.getFullPath());\n\n        assertEquals(1, realmService.list(SyncopeConstants.ROOT_REALM).stream().\n                filter(object -> realm.getName().equals(object.getName())).count());\n\n        // 4. create under invalid path\n        try {\n            realmService.create(\"a name\", realm);\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.InvalidPath, e.getType());\n        }\n\n        // 5. attempt to create duplicate\n        try {\n            realmService.create(\"/odd\", realm);\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.EntityExists, e.getType());\n        }\n    }\n\n    @Test\n    public void createWithTilde() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"73~1~19534\");\n\n        Response response = realmService.create(\"/even/two\", realm);\n        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n\n        List<RealmTO> realms = realmService.list(\"/even/two/73~1~19534\");\n        assertEquals(1, realms.size());\n        assertEquals(realm.getName(), realms.get(0).getName());\n    }\n\n    @Test\n    public void deletingAccountPolicy() {\n        // 1. create account policy\n        DefaultAccountRuleConf ruleConf = new DefaultAccountRuleConf();\n        ruleConf.setMinLength(3);\n        ruleConf.setMaxLength(8);\n\n        ImplementationTO rule = new ImplementationTO();\n        rule.setKey(\"DefaultAccountRuleConf\" + UUID.randomUUID().toString());\n        rule.setEngine(ImplementationEngine.JAVA);\n        rule.setType(IdRepoImplementationType.ACCOUNT_RULE);\n        rule.setBody(POJOHelper.serialize(ruleConf));\n        Response response = implementationService.create(rule);\n        rule.setKey(response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n\n        AccountPolicyTO policy = new AccountPolicyTO();\n        policy.setDescription(\"deletingAccountPolicy\");\n        policy.getRules().add(rule.getKey());\n\n        policy = createPolicy(PolicyType.ACCOUNT, policy);\n        assertNotNull(policy);\n\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withPolicy\");\n\n        response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n\n        String existingAccountPolicy = realm.getAccountPolicy();\n\n        realm.setAccountPolicy(policy.getKey());\n        realmService.update(realm);\n\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAccountPolicy());\n\n        // 3. remove policy\n        policyService.delete(PolicyType.ACCOUNT, policy.getKey());\n\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAccountPolicy, actual.getAccountPolicy());\n    }\n\n    @Test\n    public void deletingAuthPolicy() {\n        // 1. create authentication policy\n        DefaultAuthPolicyConf ruleConf = new DefaultAuthPolicyConf();\n        ruleConf.getAuthModules().addAll(List.of(\"LdapAuthentication1\"));\n\n        AuthPolicyTO policy = new AuthPolicyTO();\n        policy.setDescription(\"Test Authentication policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.AUTH, policy);\n        assertNotNull(policy);\n\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAuthPolicy\");\n\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n\n        String existingAuthPolicy = realm.getAuthPolicy();\n\n        realm.setAuthPolicy(policy.getKey());\n        realmService.update(realm);\n\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAuthPolicy());\n\n        // 3. remove policy\n        policyService.delete(PolicyType.AUTH, policy.getKey());\n\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAuthPolicy, actual.getAuthPolicy());\n    }\n\n    @Test\n    public void deletingAccessPolicy() {\n        // 1. create access policy\n        DefaultAccessPolicyConf ruleConf = new DefaultAccessPolicyConf();\n        ruleConf.setEnabled(true);\n        ruleConf.addRequiredAttr(\"cn\", Set.of(\"admin\", \"Admin\", \"TheAdmin\"));\n\n        AccessPolicyTO policy = new AccessPolicyTO();\n        policy.setDescription(\"Test Access policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.ACCESS, policy);\n        assertNotNull(policy);\n\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAccessPolicy\");\n\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n\n        String existingAccessPolicy = realm.getAccessPolicy();\n\n        realm.setAccessPolicy(policy.getKey());\n        realmService.update(realm);\n\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAccessPolicy());\n\n        // 3. remove policy\n        policyService.delete(PolicyType.ACCESS, policy.getKey());\n\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAccessPolicy, actual.getAccessPolicy());\n    }\n\n    @Test\n    public void deletingAttributeReleasePolicy() {\n        // 1. create attribute release policy\n        AllowedAttrReleasePolicyConf ruleConf = new AllowedAttrReleasePolicyConf();\n        ruleConf.getAllowedAttrs().addAll(List.of(\"cn\", \"givenName\"));\n\n        AllowedAttrReleasePolicyConf.ConsentPolicy consentPolicy1 = ruleConf.new ConsentPolicy();\n        consentPolicy1.getIncludeOnlyAttrs().addAll(Set.of(\"cn\"));\n        ruleConf.setConsentPolicy(consentPolicy1);\n\n        AttrReleasePolicyTO policy = new AttrReleasePolicyTO();\n        policy.setDescription(\"Test Attribute Release policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.ATTR_RELEASE, policy);\n        assertNotNull(policy);\n\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAttrReleasePolicy\");\n\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n\n        String existingAttrReleasePolicy = realm.getAttrReleasePolicy();\n\n        realm.setAttrReleasePolicy(policy.getKey());\n        realmService.update(realm);\n\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAttrReleasePolicy());\n\n        // 3. remove policy\n        policyService.delete(PolicyType.ATTR_RELEASE, policy.getKey());\n\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAttrReleasePolicy, actual.getAttrReleasePolicy());\n    }\n\n    @Test\n    public void delete() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"deletable3\");\n\n        Response response = realmService.create(\"/even/two\", realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n\n        realmService.delete(actual.getFullPath());\n\n        try {\n            realmService.list(actual.getFullPath());\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.NotFound, e.getType());\n        }\n    }\n\n    @Test\n    public void deleteNonEmpty() {\n        try {\n            realmService.delete(\"/even/two\");\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.AssociatedAnys, e.getType());\n            assertEquals(3, e.getElements().size());\n        }\n    }\n\n    @Test\n    public void propagate() {\n        // 1. create realm and add the LDAP resource\n        RealmTO realm = new RealmTO();\n        realm.setName(\"test\");\n        realm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n        RealmTO childRealm = new RealmTO();\n        childRealm.setName(\"child\");\n        childRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n        RealmTO descendantRealm = new RealmTO();\n        descendantRealm.setName(\"test\");\n        descendantRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n\n        // 2. check propagation\n        ProvisioningResult<RealmTO> result = realmService.create(\"/\", realm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(result);\n        assertEquals(1, result.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, result.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, result.getPropagationStatuses().get(0).getStatus());\n\n        ProvisioningResult<RealmTO> resultChild = realmService.create(\"/test\", childRealm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(resultChild);\n        assertEquals(1, resultChild.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultChild.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, resultChild.getPropagationStatuses().get(0).getStatus());\n\n        ProvisioningResult<RealmTO> resultDescendant = realmService.create(\"/test/child\", descendantRealm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(resultDescendant);\n        assertEquals(1, resultDescendant.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultDescendant.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, resultDescendant.getPropagationStatuses().get(0).getStatus());\n\n        // 3. check on LDAP\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,o=isp\"));\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=child,ou=test,o=isp\"));\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,ou=child,ou=test,o=isp\"));\n\n        // 4. remove realms\n        realmService.delete(\"/test/child/test\");\n        realmService.delete(\"/test/child\");\n        realmService.delete(\"/test\");\n\n        // 5. check on LDAP: both realms should be deleted\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,ou=child,ou=test,o=isp\"));\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=child,ou=test,o=isp\"));\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,o=isp\"));\n    }\n\n    @Test\n    public void issueSYNCOPE1472() {\n        // 1. assign twice resource-ldap-orgunit to /odd\n        RealmTO realmTO = realmService.list(\"/odd\").get(0);\n        realmTO.getResources().clear();\n        realmTO.getResources().add(\"resource-ldap-orgunit\");\n        realmTO.getResources().add(\"resource-ldap-orgunit\");\n        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {\n        }).getEntity();\n\n        // 2. remove resource-ldap-orgunit resource\n        realmTO.getResources().remove(\"resource-ldap-orgunit\");\n\n        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {\n        }).getEntity();\n\n        assertFalse(realmTO.getResources().contains(\"resource-ldap-orgunit\"), \"Should not contain removed resources\");\n    }\n}", "class_id": 0, "repo": "FabianoVeglianti/syncope", "file": "fit/core-reference/src/test/java/org/apache/syncope/fit/core/RealmITCase.java", "last_update_at": "2018-05-10T07:34:47+00:00", "question_id": "a2d196adf032d898ad48dcfdb93c63bcb959f615", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class RealmITCase extends AbstractITCase {\n    private static Optional<RealmTO> getRealm(final String fullPath) {\n        return realmService.list(fullPath).stream().filter(realm -> fullPath.equals(realm.getFullPath())).findFirst();\n    }\n    @Test\n    public void search() {\n        PagedResult<RealmTO> match = realmService.search(new RealmQuery.Builder().keyword(\"*o*\").build());\n        assertTrue(match.getResult().stream().allMatch(realm -> realm.getName().contains(\"o\")));\n    }\n    @Test\n    public void list() {\n        List<RealmTO> realms = realmService.list(SyncopeConstants.ROOT_REALM);\n        assertNotNull(realms);\n        assertFalse(realms.isEmpty());\n        realms.forEach(Assertions::assertNotNull);\n        try {\n            realmService.list(\"a name\");\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.InvalidPath, e.getType());\n        }\n    }\n    @Test\n    public void createUpdate() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"last\");\n        // 1. create\n        Response response = realmService.create(\"/even/two\", realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertNotNull(actual.getKey());\n        assertEquals(\"last\", actual.getName());\n        assertEquals(\"/even/two/last\", actual.getFullPath());\n        assertEquals(actual.getParent(), getRealm(\"/even/two\").get().getKey());\n        assertNull(realm.getAccountPolicy());\n        assertNull(realm.getPasswordPolicy());\n        // 2. update setting policies\n        actual.setAccountPolicy(\"06e2ed52-6966-44aa-a177-a0ca7434201f\");\n        actual.setPasswordPolicy(\"986d1236-3ac5-4a19-810c-5ab21d79cba1\");\n        actual.setAuthPolicy(\"b912a0d4-a890-416f-9ab8-84ab077eb028\");\n        actual.setAccessPolicy(\"419935c7-deb3-40b3-8a9a-683037e523a2\");\n        actual.setAttrReleasePolicy(\"319935c7-deb3-40b3-8a9a-683037e523a2\");\n        realmService.update(actual);\n        actual = getRealm(actual.getFullPath()).get();\n        assertNotNull(actual.getAccountPolicy());\n        assertNotNull(actual.getPasswordPolicy());\n        assertNotNull(actual.getAuthPolicy());\n        assertNotNull(actual.getAccessPolicy());\n        assertNotNull(actual.getAttrReleasePolicy());\n        // 3. update changing parent\n        actual.setParent(getRealm(\"/odd\").get().getKey());\n        realmService.update(actual);\n        actual = getRealm(\"/odd/last\").get();\n        assertNotNull(actual);\n        assertEquals(\"/odd/last\", actual.getFullPath());\n        assertEquals(1, realmService.list(SyncopeConstants.ROOT_REALM).stream().\n                filter(object -> realm.getName().equals(object.getName())).count());\n        // 4. create under invalid path\n        try {\n            realmService.create(\"a name\", realm);\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.InvalidPath, e.getType());\n        }\n        // 5. attempt to create duplicate\n        try {\n            realmService.create(\"/odd\", realm);\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.EntityExists, e.getType());\n        }\n    }\n    @Test\n    public void createWithTilde() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"73~1~19534\");\n        Response response = realmService.create(\"/even/two\", realm);\n        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n        List<RealmTO> realms = realmService.list(\"/even/two/73~1~19534\");\n        assertEquals(1, realms.size());\n        assertEquals(realm.getName(), realms.get(0).getName());\n    }\n    @Test\n    public void deletingAccountPolicy() {\n        // 1. create account policy\n        DefaultAccountRuleConf ruleConf = new DefaultAccountRuleConf();\n        ruleConf.setMinLength(3);\n        ruleConf.setMaxLength(8);\n        ImplementationTO rule = new ImplementationTO();\n        rule.setKey(\"DefaultAccountRuleConf\" + UUID.randomUUID().toString());\n        rule.setEngine(ImplementationEngine.JAVA);\n        rule.setType(IdRepoImplementationType.ACCOUNT_RULE);\n        rule.setBody(POJOHelper.serialize(ruleConf));\n        Response response = implementationService.create(rule);\n        rule.setKey(response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n        AccountPolicyTO policy = new AccountPolicyTO();\n        policy.setDescription(\"deletingAccountPolicy\");\n        policy.getRules().add(rule.getKey());\n        policy = createPolicy(PolicyType.ACCOUNT, policy);\n        assertNotNull(policy);\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withPolicy\");\n        response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n        String existingAccountPolicy = realm.getAccountPolicy();\n        realm.setAccountPolicy(policy.getKey());\n        realmService.update(realm);\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAccountPolicy());\n        // 3. remove policy\n        policyService.delete(PolicyType.ACCOUNT, policy.getKey());\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAccountPolicy, actual.getAccountPolicy());\n    }\n    @Test\n    public void deletingAuthPolicy() {\n        // 1. create authentication policy\n        DefaultAuthPolicyConf ruleConf = new DefaultAuthPolicyConf();\n        ruleConf.getAuthModules().addAll(List.of(\"LdapAuthentication1\"));\n        AuthPolicyTO policy = new AuthPolicyTO();\n        policy.setDescription(\"Test Authentication policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.AUTH, policy);\n        assertNotNull(policy);\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAuthPolicy\");\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n        String existingAuthPolicy = realm.getAuthPolicy();\n        realm.setAuthPolicy(policy.getKey());\n        realmService.update(realm);\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAuthPolicy());\n        // 3. remove policy\n        policyService.delete(PolicyType.AUTH, policy.getKey());\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAuthPolicy, actual.getAuthPolicy());\n    }\n    @Test\n    public void deletingAccessPolicy() {\n        // 1. create access policy\n        DefaultAccessPolicyConf ruleConf = new DefaultAccessPolicyConf();\n        ruleConf.setEnabled(true);\n        ruleConf.addRequiredAttr(\"cn\", Set.of(\"admin\", \"Admin\", \"TheAdmin\"));\n        AccessPolicyTO policy = new AccessPolicyTO();\n        policy.setDescription(\"Test Access policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.ACCESS, policy);\n        assertNotNull(policy);\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAccessPolicy\");\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n        String existingAccessPolicy = realm.getAccessPolicy();\n        realm.setAccessPolicy(policy.getKey());\n        realmService.update(realm);\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAccessPolicy());\n        // 3. remove policy\n        policyService.delete(PolicyType.ACCESS, policy.getKey());\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAccessPolicy, actual.getAccessPolicy());\n    }\n    @Test\n    public void deletingAttributeReleasePolicy() {\n        // 1. create attribute release policy\n        AllowedAttrReleasePolicyConf ruleConf = new AllowedAttrReleasePolicyConf();\n        ruleConf.getAllowedAttrs().addAll(List.of(\"cn\", \"givenName\"));\n        AllowedAttrReleasePolicyConf.ConsentPolicy consentPolicy1 = ruleConf.new ConsentPolicy();\n        consentPolicy1.getIncludeOnlyAttrs().addAll(Set.of(\"cn\"));\n        ruleConf.setConsentPolicy(consentPolicy1);\n        AttrReleasePolicyTO policy = new AttrReleasePolicyTO();\n        policy.setDescription(\"Test Attribute Release policy\");\n        policy.setConf(ruleConf);\n        policy = createPolicy(PolicyType.ATTR_RELEASE, policy);\n        assertNotNull(policy);\n        // 2. create realm with policy assigned\n        RealmTO realm = new RealmTO();\n        realm.setName(\"withAttrReleasePolicy\");\n        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        realm = actuals[0];\n        String existingAttrReleasePolicy = realm.getAttrReleasePolicy();\n        realm.setAttrReleasePolicy(policy.getKey());\n        realmService.update(realm);\n        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        assertEquals(policy.getKey(), actual.getAttrReleasePolicy());\n        // 3. remove policy\n        policyService.delete(PolicyType.ATTR_RELEASE, policy.getKey());\n        // 4. verify\n        actual = getRealm(actual.getFullPath()).get();\n        assertEquals(existingAttrReleasePolicy, actual.getAttrReleasePolicy());\n    }\n    @Test\n    public void delete() {\n        RealmTO realm = new RealmTO();\n        realm.setName(\"deletable3\");\n        Response response = realmService.create(\"/even/two\", realm);\n        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);\n        assertNotNull(actuals);\n        assertTrue(actuals.length > 0);\n        RealmTO actual = actuals[0];\n        realmService.delete(actual.getFullPath());\n        try {\n            realmService.list(actual.getFullPath());\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.NotFound, e.getType());\n        }\n    }\n    @Test\n    public void deleteNonEmpty() {\n        try {\n            realmService.delete(\"/even/two\");\n            fail(\"This should not happen\");\n        } catch (SyncopeClientException e) {\n            assertEquals(ClientExceptionType.AssociatedAnys, e.getType());\n            assertEquals(3, e.getElements().size());\n        }\n    }\n    @Test\n    public void propagate() {\n        // 1. create realm and add the LDAP resource\n        RealmTO realm = new RealmTO();\n        realm.setName(\"test\");\n        realm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n        RealmTO childRealm = new RealmTO();\n        childRealm.setName(\"child\");\n        childRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n        RealmTO descendantRealm = new RealmTO();\n        descendantRealm.setName(\"test\");\n        descendantRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);\n        // 2. check propagation\n        ProvisioningResult<RealmTO> result = realmService.create(\"/\", realm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(result);\n        assertEquals(1, result.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, result.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, result.getPropagationStatuses().get(0).getStatus());\n        ProvisioningResult<RealmTO> resultChild = realmService.create(\"/test\", childRealm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(resultChild);\n        assertEquals(1, resultChild.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultChild.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, resultChild.getPropagationStatuses().get(0).getStatus());\n        ProvisioningResult<RealmTO> resultDescendant = realmService.create(\"/test/child\", descendantRealm).readEntity(\n                new GenericType<ProvisioningResult<RealmTO>>() {\n        });\n        assertNotNull(resultDescendant);\n        assertEquals(1, resultDescendant.getPropagationStatuses().size());\n        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultDescendant.getPropagationStatuses().get(0).getResource());\n        assertEquals(ExecStatus.SUCCESS, resultDescendant.getPropagationStatuses().get(0).getStatus());\n        // 3. check on LDAP\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,o=isp\"));\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=child,ou=test,o=isp\"));\n        assertNotNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,ou=child,ou=test,o=isp\"));\n        // 4. remove realms\n        realmService.delete(\"/test/child/test\");\n        realmService.delete(\"/test/child\");\n        realmService.delete(\"/test\");\n        // 5. check on LDAP: both realms should be deleted\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,ou=child,ou=test,o=isp\"));\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=child,ou=test,o=isp\"));\n        assertNull(\n                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"ou=test,o=isp\"));\n    }\n    @Test\n    public void issueSYNCOPE1472() {\n        // 1. assign twice resource-ldap-orgunit to /odd\n        RealmTO realmTO = realmService.list(\"/odd\").get(0);\n        realmTO.getResources().clear();\n        realmTO.getResources().add(\"resource-ldap-orgunit\");\n        realmTO.getResources().add(\"resource-ldap-orgunit\");\n        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {\n        }).getEntity();\n        // 2. remove resource-ldap-orgunit resource\n        realmTO.getResources().remove(\"resource-ldap-orgunit\");\n        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {\n        }).getEntity();\n        assertFalse(realmTO.getResources().contains(\"resource-ldap-orgunit\"), \"Should not contain removed resources\");\n    }\n"]], "pred": {"ppl": 2.1014084815979004, "ppl_lower": 2.572707414627075, "ppl/lowercase_ppl": -1.2724870123446113, "ppl/zlib": 0.00027514183972944, "Min_5.0% Prob": 5.75927890515795, "Min_10.0% Prob": 4.406559757157868, "Min_20.0% Prob": 3.2787452129756702, "Min_30.0% Prob": 2.4119847278579387, "Min_40.0% Prob": 1.844706180425757, "Min_50.0% Prob": 1.4840754521883106, "Min_60.0% Prob": 1.2387051657746206}}
{"hexsha": "9174c8af9d3e4ea0796e381c89cbedfd2e523460", "ext": "java", "lang": "Java", "content": "public class StatusBarController {\n\n    @FXML\n    private Label info;\n    @FXML\n    private Label host;\n    @FXML\n    private ProgressBar loadDataStatus;\n    @FXML\n    private Label loadDataLabel;\n\n    public StatusBarController() {\n\n    }\n\n    @FXML\n    public void initialize() {\n        host.setText(\"Host: \" + Resources.HOST_NAME);\n        info.setText(\"Program version: \" + Resources.PROGRAM_VERSION);\n        loadDataStatus.visibleProperty().bind(Context.getIsLoadDataProperty());\n        loadDataLabel.visibleProperty().bind(Context.getIsLoadDataProperty());\n    }\n\n}", "class_id": 0, "repo": "DYefremov/H2dbAdmin", "file": "src/main/java/by/post/control/ui/StatusBarController.java", "last_update_at": "2018-06-02T03:55:11+00:00", "question_id": "9174c8af9d3e4ea0796e381c89cbedfd2e523460", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StatusBarController {\n    @FXML\n    private Label info;\n    @FXML\n    private Label host;\n    @FXML\n    private ProgressBar loadDataStatus;\n    @FXML\n    private Label loadDataLabel;\n    public StatusBarController() {\n    }\n    @FXML\n    public void initialize() {\n        host.setText(\"Host: \" + Resources.HOST_NAME);\n        info.setText(\"Program version: \" + Resources.PROGRAM_VERSION);\n        loadDataStatus.visibleProperty().bind(Context.getIsLoadDataProperty());\n        loadDataLabel.visibleProperty().bind(Context.getIsLoadDataProperty());\n    }\n"]], "pred": {"ppl": 2.5381391048431396, "ppl_lower": 2.9968106746673584, "ppl/lowercase_ppl": -1.178346443900097, "ppl/zlib": 0.003596259369239733, "Min_5.0% Prob": 7.245138704776764, "Min_10.0% Prob": 5.695072069764137, "Min_20.0% Prob": 3.833564344793558, "Min_30.0% Prob": 2.8988729156553745, "Min_40.0% Prob": 2.278701489325613, "Min_50.0% Prob": 1.8600150203332304, "Min_60.0% Prob": 1.55962106269241}}
{"hexsha": "dad71efdee9071062b43597211c7bb33b7520245", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"deprecation\")\npublic class BlockAsymmetricalMachination extends BlockBaseFacing {\n\n\tprivate static final ImmutableMap<EnumFacing, AxisAlignedBB> BB_MAP = FacingAlignedBB.create(\n\t\t\tnew Vector3(2, 6.5, 2),\n\t\t\tnew Vector3(14, 15.5, 14),\n\t\t\tEnumFacing.UP\n\t).build();\n\n\tpublic BlockAsymmetricalMachination() {\n\t\tsuper(LibNames.ASYMMETRICAL_MACHINATION, IPMMaterial.MONOLITH);\n\t\tsetDefaultState(getDefaultState().withProperty(BlockDirectional.FACING, EnumFacing.UP));\n\t\tsetHarvestLevel(Tool.PICK, ToolLevel.STONE);\n\t\tsetHardness(1F);\n\t}\n\n\t@Override\n\tpublic void randomDisplayTick(IBlockState state, World world, BlockPos pos, Random rand) {\n\t\tEnumFacing facing = state.getValue(BlockDirectional.FACING).getOpposite();\n\t\tBlockPos.MutableBlockPos posOffset = new BlockPos.MutableBlockPos(pos);\n\t\tfloat distance = 0;\n\t\twhile(distance++ < Constants.REACH) {\n\t\t\tIBlockState found = world.getBlockState(posOffset.move(facing));\n\t\t\tif(found.getBlock() == ModBlocks.SYMMETRICAL_MACHINATION && found.getValue(BlockDirectional.FACING) == facing) {\n\t\t\t\tVector3 offset = new Vector3.WrappedVec3i(facing.getDirectionVec()).asImmutable();\n\t\t\t\tVector3 from = new Vector3.WrappedVec3i(pos).asImmutable().add(0.5D).offset(offset, -0.19);\n\t\t\t\tIPM.getProxy().spawnBeam(world, from, offset, distance + 0.41F, 36, 0.75F, 0xFF0303, Light.GLOW, GlowTexture.GLOW.getTexture());\n\t\t\t\tbreak;\n\t\t\t} else if(found.getBlock() == ModBlocks.ASYMMETRICAL_MACHINATION) break;\n\t\t}\n\t}\n\n\t@Override\n\tpublic AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {\n\t\tEnumFacing facing = state.getValue(BlockDirectional.FACING);\n\t\treturn BB_MAP.getOrDefault(facing, FULL_BLOCK_AABB);\n\t}\n\n\t@Override\n\tpublic boolean hasTileEntity(IBlockState state) {\n\t\treturn true;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic TileEntity createTileEntity(World world, IBlockState state) {\n\t\treturn new TileAsymmetricalMachination();\n\t}\n\n\t@Override\n\t@SideOnly(Side.CLIENT)\n\tpublic void registerModel() {\n\t\tDummyModelRegistry.register(this, new ModelRendered()\n\t\t\t\t.setParticle(ResourceLibrary.ASYMMETRICAL_MACHINATION)\n\t\t);\n\t\tModelHelper.registerModel(this, 0);\n\t}\n\n\tpublic static class Constants {\n\t\tpublic static int REACH = 15;\n\t}\n}", "class_id": 0, "repo": "ArekkuusuJerii/Solar", "file": "src/main/java/arekkuusu/implom/common/block/BlockAsymmetricalMachination.java", "last_update_at": "2018-05-06T06:04:11+00:00", "question_id": "dad71efdee9071062b43597211c7bb33b7520245", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"deprecation\")\npublic class BlockAsymmetricalMachination extends BlockBaseFacing {\n\tprivate static final ImmutableMap<EnumFacing, AxisAlignedBB> BB_MAP = FacingAlignedBB.create(\n\t\t\tnew Vector3(2, 6.5, 2),\n\t\t\tnew Vector3(14, 15.5, 14),\n\t\t\tEnumFacing.UP\n\t).build();\n\tpublic BlockAsymmetricalMachination() {\n\t\tsuper(LibNames.ASYMMETRICAL_MACHINATION, IPMMaterial.MONOLITH);\n\t\tsetDefaultState(getDefaultState().withProperty(BlockDirectional.FACING, EnumFacing.UP));\n\t\tsetHarvestLevel(Tool.PICK, ToolLevel.STONE);\n\t\tsetHardness(1F);\n\t}\n\t@Override\n\tpublic void randomDisplayTick(IBlockState state, World world, BlockPos pos, Random rand) {\n\t\tEnumFacing facing = state.getValue(BlockDirectional.FACING).getOpposite();\n\t\tBlockPos.MutableBlockPos posOffset = new BlockPos.MutableBlockPos(pos);\n\t\tfloat distance = 0;\n\t\twhile(distance++ < Constants.REACH) {\n\t\t\tIBlockState found = world.getBlockState(posOffset.move(facing));\n\t\t\tif(found.getBlock() == ModBlocks.SYMMETRICAL_MACHINATION && found.getValue(BlockDirectional.FACING) == facing) {\n\t\t\t\tVector3 offset = new Vector3.WrappedVec3i(facing.getDirectionVec()).asImmutable();\n\t\t\t\tVector3 from = new Vector3.WrappedVec3i(pos).asImmutable().add(0.5D).offset(offset, -0.19);\n\t\t\t\tIPM.getProxy().spawnBeam(world, from, offset, distance + 0.41F, 36, 0.75F, 0xFF0303, Light.GLOW, GlowTexture.GLOW.getTexture());\n\t\t\t\tbreak;\n\t\t\t} else if(found.getBlock() == ModBlocks.ASYMMETRICAL_MACHINATION) break;\n\t\t}\n\t}\n\t@Override\n\tpublic AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {\n\t\tEnumFacing facing = state.getValue(BlockDirectional.FACING);\n\t\treturn BB_MAP.getOrDefault(facing, FULL_BLOCK_AABB);\n\t}\n\t@Override\n\tpublic boolean hasTileEntity(IBlockState state) {\n\t\treturn true;\n\t}\n\t@Nullable\n\t@Override\n\tpublic TileEntity createTileEntity(World world, IBlockState state) {\n\t\treturn new TileAsymmetricalMachination();\n\t}\n\t@Override\n\t@SideOnly(Side.CLIENT)\n\tpublic void registerModel() {\n\t\tDummyModelRegistry.register(this, new ModelRendered()\n\t\t\t\t.setParticle(ResourceLibrary.ASYMMETRICAL_MACHINATION)\n\t\t);\n\t\tModelHelper.registerModel(this, 0);\n\t}\n\tpublic static class Constants {\n\t\tpublic static int REACH = 15;\n\t}\n"]], "pred": {"ppl": 2.016939163208008, "ppl_lower": 2.9538915157318115, "ppl/lowercase_ppl": -1.5438321589742843, "ppl/zlib": 0.0007180973352081432, "Min_5.0% Prob": 6.368305898848034, "Min_10.0% Prob": 4.845799426237742, "Min_20.0% Prob": 3.1889317984411703, "Min_30.0% Prob": 2.2743419570716346, "Min_40.0% Prob": 1.7436933640973054, "Min_50.0% Prob": 1.402068035914299, "Min_60.0% Prob": 1.1696077657009023}}
{"hexsha": "ff00f630cdc6e31f050192d22a59609aefab169b", "ext": "java", "lang": "Java", "content": "public class ParseFormat extends Procedure1\n{\n  public static final ParseFormat parseFormat = new ParseFormat(false);\n\n  boolean emacsStyle = true;\n  public static final int PARAM_UNSPECIFIED = LispFormat.PARAM_UNSPECIFIED;\n  public static final int PARAM_FROM_LIST = LispFormat.PARAM_FROM_LIST;\n\n  public ParseFormat (boolean emacsStyle)\n  {\n    this.emacsStyle = emacsStyle;\n  }\n\n  public static final int SEEN_MINUS = 1;\n  public static final int SEEN_PLUS  = 2;\n  public static final int SEEN_SPACE = 4;\n  public static final int SEEN_ZERO  = 8;\n  public static final int SEEN_HASH = 16;\n\n  public ReportFormat parseFormat(InPort fmt)\n    throws java.text.ParseException, java.io.IOException\n  {\n    return parseFormat(fmt, emacsStyle ? '?' : '~');\n  }\n\n  public static ReportFormat parseFormat(InPort fmt, char magic)\n    throws java.text.ParseException, java.io.IOException\n  {\n    StringBuffer fbuf = new StringBuffer(100);\n    int position = 0;\n    ArrayList<Format> formats = new ArrayList<Format>();\n    Format format;\n    for (;;)\n      {\n\tint ch = fmt.read();\n\tif (ch >= 0)\n\t  {\n\t    if (ch != magic)\n\t      {\n\t\t// FIXME - quote special characters!\n\t\tfbuf.append((char) ch);\n\t\tcontinue;\n\t      }\n\t    ch = fmt.read();\n\t    if (ch == magic)\n\t      {\n\t\tfbuf.append((char) ch);\n\t\tcontinue;\n\t      }\n\t  }\n\tint len = fbuf.length();\n\n        // Note we create a LiteralFormat even when fbuf is empty.\n        // This is to make sure there are string-valued separators between\n        // specifiers (as well as before and after).  Otherwise\n        // ($sprintf$ \"%s%s\" 3 4) would return \"3 4\" rather than \"34\".\n        if (len == 0)\n            format = LiteralFormat.separator;\n        else\n          {\n            char[] text = new char[len];\n            fbuf.getChars(0, len, text, 0);\n            fbuf.setLength(0);\n            format = new LiteralFormat(text);\n          }\n        formats.add(format);\n\n\tif (ch < 0)\n\t  break;\n\tint digit;\n\tif (ch == '$')\n\t  {\n\t    ch = fmt.read();\n\t    position = Character.digit((char) ch, 10);\n\t    if (position < 0)\n\t      throw new ParseException(\"missing number (position) after '%$'\",\n\t\t\t\t       -1);\n\t    for (;;)\n\t      {\n\t\tch = fmt.read();\n\t\tdigit = Character.digit((char) ch, 10);\n\t\tif (digit < 0)\n\t\t  break;\n\t\tposition = 10 * position + digit;\n\t      }\n\t    position--;  /* Convert to zero-origin index. */\n\t  }\n\n\tint flags = 0;\n\tfor (;; ch = fmt.read())\n\t  {\n\t    switch ((char) ch)\n\t      {\n\t      case '-':  flags |= SEEN_MINUS;  continue;\n\t      case '+':  flags |= SEEN_PLUS;   continue;\n\t      case ' ':  flags |= SEEN_SPACE;  continue;\n\t      case '0':  flags |= SEEN_ZERO;   continue;\n\t      case '#':  flags |= SEEN_HASH;   continue;\n\t      }\n\t    break;\n\t  }\n\n\tint width;\n        if (ch == '*')\n          {\n            width = PARAM_FROM_LIST;\n            ch = fmt.read();\n          }\n\telse if ((digit = Character.digit((char) ch, 10)) >= 0)\n\t  {\n\t    width = digit;\n\t    for (;;)\n\t      {\n\t\tch = fmt.read();\n\t\tdigit = Character.digit((char) ch, 10);\n\t\tif (digit < 0)\n\t\t  break;\n\t\twidth = 10 * width + digit;\n\t      }\n\t  }\n        else\n          width = PARAM_UNSPECIFIED;\n\n\tint precision = PARAM_UNSPECIFIED;\n\tif (ch == '.')\n\t  {\n            ch = fmt.read();\n\t    if (ch == '*')\n              {\n                precision = PARAM_FROM_LIST;\n                ch = fmt.read();\n              }\n\t    else if ((digit = Character.digit((char) ch, 10)) >= 0)\n\t      {\n                precision = digit;\n                for (;;)\n                  {\n                    ch = fmt.read();\n                    digit = Character.digit((char) ch, 10);\n                    if (digit < 0)\n                        break;\n                    precision = 10 * precision + digit;\n                  }\n              }\n          }\n\n        char padChar\n            = (flags & (SEEN_ZERO+SEEN_MINUS)) == SEEN_ZERO ? '0' : ' ';\n\tswitch (ch)\n\t  {\n\t  case 's':\n\t  case 'S':\n\t    format = new ObjectFormat(ch == 'S', precision);\n\t    break;\n\n\t  case 'x':\n\t  case 'X':\n\t  case 'i':\n\t  case 'd':\n\t  case 'o':\n\t    int base;\n            int fflags = 0;\n\t    if (ch == 'd' || ch == 'i')\n              base = 10;\n\t    else if (ch == 'o')\n              base = 8;\n\t    else\n              { /* if (ch == 'x' || ch == 'X') */\n                base = 16;\n                if (ch == 'X') fflags = IntegerFormat.UPPERCASE;\n              }\n            boolean seenColon = false;\n            boolean seenAt = false;\n            if ((flags & SEEN_HASH) != 0)\n              fflags |= IntegerFormat.SHOW_BASE;\n            if ((flags & SEEN_PLUS) != 0)\n              fflags |= IntegerFormat.SHOW_PLUS;\n            if ((flags & SEEN_MINUS) != 0)\n              fflags |= IntegerFormat.PAD_RIGHT;\n            if ((flags & SEEN_SPACE) != 0)\n              fflags |= IntegerFormat.SHOW_SPACE;\n\t    if (precision != PARAM_UNSPECIFIED)\n\t      {\n\t\tflags &= ~ SEEN_ZERO;\n\t\tfflags |= IntegerFormat.MIN_DIGITS;\n\t\tformat = IntegerFormat.getInstance(base, precision,\n\t\t\t\t\t\t   '0', PARAM_UNSPECIFIED,\n\t\t\t\t\t\t   PARAM_UNSPECIFIED, fflags);\n\t      }\n\t    else\n\t      format = IntegerFormat.getInstance(base, width,\n\t\t\t\t\t\t padChar, PARAM_UNSPECIFIED,\n\t\t\t\t\t\t PARAM_UNSPECIFIED, fflags);\n            break;\n\t  case 'f':\n\t  case 'e':\n\t  case 'E':\n\t  case 'g':\n\t  case 'G':\n              LispRealFormat dfmt = new LispRealFormat();\n              dfmt.op = (char) ch;\n              dfmt.style = 'P';\n              dfmt.arg1 = width;\n              if (precision == PARAM_UNSPECIFIED)\n                  precision = 6;\n              dfmt.arg2 = precision;\n              dfmt.showPlus = (flags & SEEN_PLUS) != 0;\n              if (ch == 'e' || ch == 'E' || ch == 'g' || ch == 'G') {\n                  dfmt.arg3 = 2;\n                  dfmt.arg4 = 1; // intDigits\n                  dfmt.arg5 = '\\0'; // overflowChar\n                  dfmt.arg6  = padChar;\n                  // set exponentChar\n                  dfmt.arg7 = ch == 'E' || ch == 'G' ? 'E' : 'e';\n              }\n              else {\n                  dfmt.arg3 = '\\0'; // overflowChar\n                  dfmt.arg5 = padChar;\n              }\n              dfmt.internalPad = true;\n              format = dfmt.resolve(null, 0);\n\t    break;\n\t  default:\n\t    throw new ParseException (\"unknown format character '\"+ch+\"'\", -1);\n\t  }\n\tif (width > 0)\n\t  {\n\t    padChar = (flags & SEEN_ZERO) != 0 ? '0' : ' ';\n\t    int where;\n\t    if ((flags & SEEN_MINUS) != 0)\n\t      where = 100;\n\t    else if (padChar == '0')\n\t      where = -1;\n\t    else\n\t      where = 0;\n\t    format = new gnu.text.PadFormat(format, width, padChar, where);\n\t  }\n\t// FIXME handle re-positioning\n\t//fbuf.append('{');\n        // fbuf.append(position);\n\t//fbuf.append('}');\n\tformats.add(format);\n\tposition++;\n      }\n    int fcount = formats.size();\n    if (fcount == 1)\n      {\n\tObject f = formats.get(0);\n\tif (f instanceof ReportFormat)\n\t  return (ReportFormat) f;\n      }\n    return new CompoundFormat(formats.toArray(new Format[fcount]));\n  }\n\n  public Object apply1 (Object arg)\n  {\n    return asFormat(arg, emacsStyle ? '?' : '~');\n  }\n\n  public static ReportFormat asFormat (Object arg, char style)\n  {\n    try\n      {\n\tif (arg instanceof ReportFormat)\n\t  return (ReportFormat) arg;\n\tif (style == '~')\n\t  return new LispFormat(arg.toString());\n\telse\n\t  {\n\t    InPort iport;\n\t    if (arg instanceof FString)\n              iport = ((FString) arg).openReader();\n\t    else \n\t      iport = new CharArrayInPort(arg.toString()); \n\t    try\n\t      {\n\t\treturn parseFormat(iport, style);\n\t      }\n\t    finally\n\t      {\n\t\tiport.close();\n\t      }\n\t  }\n      }\n    catch (java.io.IOException ex)\n      {\n\tthrow new RuntimeException(\"Error parsing format (\"+ex+\")\");\n      }\n    catch (ParseException ex)\n      {\n\tthrow new RuntimeException(\"Invalid format (\"+ex+\")\");\n      }\n    catch (IndexOutOfBoundsException ex)\n      {\n\tthrow new RuntimeException(\"End while parsing format\");\n      }\n  }\n}", "class_id": 0, "repo": "hellcoderz/kawa", "file": "gnu/kawa/functions/ParseFormat.java", "last_update_at": "2018-03-04T05:49:04+00:00", "question_id": "ff00f630cdc6e31f050192d22a59609aefab169b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ParseFormat extends Procedure1\n{\n  public static final ParseFormat parseFormat = new ParseFormat(false);\n  boolean emacsStyle = true;\n  public static final int PARAM_UNSPECIFIED = LispFormat.PARAM_UNSPECIFIED;\n  public static final int PARAM_FROM_LIST = LispFormat.PARAM_FROM_LIST;\n  public ParseFormat (boolean emacsStyle)\n  {\n    this.emacsStyle = emacsStyle;\n  }\n  public static final int SEEN_MINUS = 1;\n  public static final int SEEN_PLUS  = 2;\n  public static final int SEEN_SPACE = 4;\n  public static final int SEEN_ZERO  = 8;\n  public static final int SEEN_HASH = 16;\n  public ReportFormat parseFormat(InPort fmt)\n    throws java.text.ParseException, java.io.IOException\n  {\n    return parseFormat(fmt, emacsStyle ? '?' : '~');\n  }\n  public static ReportFormat parseFormat(InPort fmt, char magic)\n    throws java.text.ParseException, java.io.IOException\n  {\n    StringBuffer fbuf = new StringBuffer(100);\n    int position = 0;\n    ArrayList<Format> formats = new ArrayList<Format>();\n    Format format;\n    for (;;)\n      {\n\tint ch = fmt.read();\n\tif (ch >= 0)\n\t  {\n\t    if (ch != magic)\n\t      {\n\t\t// FIXME - quote special characters!\n\t\tfbuf.append((char) ch);\n\t\tcontinue;\n\t      }\n\t    ch = fmt.read();\n\t    if (ch == magic)\n\t      {\n\t\tfbuf.append((char) ch);\n\t\tcontinue;\n\t      }\n\t  }\n\tint len = fbuf.length();\n        // Note we create a LiteralFormat even when fbuf is empty.\n        // This is to make sure there are string-valued separators between\n        // specifiers (as well as before and after).  Otherwise\n        // ($sprintf$ \"%s%s\" 3 4) would return \"3 4\" rather than \"34\".\n        if (len == 0)\n            format = LiteralFormat.separator;\n        else\n          {\n            char[] text = new char[len];\n            fbuf.getChars(0, len, text, 0);\n            fbuf.setLength(0);\n            format = new LiteralFormat(text);\n          }\n        formats.add(format);\n\tif (ch < 0)\n\t  break;\n\tint digit;\n\tif (ch == '$')\n\t  {\n\t    ch = fmt.read();\n\t    position = Character.digit((char) ch, 10);\n\t    if (position < 0)\n\t      throw new ParseException(\"missing number (position) after '%$'\",\n\t\t\t\t       -1);\n\t    for (;;)\n\t      {\n\t\tch = fmt.read();\n\t\tdigit = Character.digit((char) ch, 10);\n\t\tif (digit < 0)\n\t\t  break;\n\t\tposition = 10 * position + digit;\n\t      }\n\t    position--;  /* Convert to zero-origin index. */\n\t  }\n\tint flags = 0;\n\tfor (;; ch = fmt.read())\n\t  {\n\t    switch ((char) ch)\n\t      {\n\t      case '-':  flags |= SEEN_MINUS;  continue;\n\t      case '+':  flags |= SEEN_PLUS;   continue;\n\t      case ' ':  flags |= SEEN_SPACE;  continue;\n\t      case '0':  flags |= SEEN_ZERO;   continue;\n\t      case '#':  flags |= SEEN_HASH;   continue;\n\t      }\n\t    break;\n\t  }\n\tint width;\n        if (ch == '*')\n          {\n            width = PARAM_FROM_LIST;\n            ch = fmt.read();\n          }\n\telse if ((digit = Character.digit((char) ch, 10)) >= 0)\n\t  {\n\t    width = digit;\n\t    for (;;)\n\t      {\n\t\tch = fmt.read();\n\t\tdigit = Character.digit((char) ch, 10);\n\t\tif (digit < 0)\n\t\t  break;\n\t\twidth = 10 * width + digit;\n\t      }\n\t  }\n        else\n          width = PARAM_UNSPECIFIED;\n\tint precision = PARAM_UNSPECIFIED;\n\tif (ch == '.')\n\t  {\n            ch = fmt.read();\n\t    if (ch == '*')\n              {\n                precision = PARAM_FROM_LIST;\n                ch = fmt.read();\n              }\n\t    else if ((digit = Character.digit((char) ch, 10)) >= 0)\n\t      {\n                precision = digit;\n                for (;;)\n                  {\n                    ch = fmt.read();\n                    digit = Character.digit((char) ch, 10);\n                    if (digit < 0)\n                        break;\n                    precision = 10 * precision + digit;\n                  }\n              }\n          }\n        char padChar\n            = (flags & (SEEN_ZERO+SEEN_MINUS)) == SEEN_ZERO ? '0' : ' ';\n\tswitch (ch)\n\t  {\n\t  case 's':\n\t  case 'S':\n\t    format = new ObjectFormat(ch == 'S', precision);\n\t    break;\n\t  case 'x':\n\t  case 'X':\n\t  case 'i':\n\t  case 'd':\n\t  case 'o':\n\t    int base;\n            int fflags = 0;\n\t    if (ch == 'd' || ch == 'i')\n              base = 10;\n\t    else if (ch == 'o')\n              base = 8;\n\t    else\n              { /* if (ch == 'x' || ch == 'X') */\n                base = 16;\n                if (ch == 'X') fflags = IntegerFormat.UPPERCASE;\n              }\n            boolean seenColon = false;\n            boolean seenAt = false;\n            if ((flags & SEEN_HASH) != 0)\n              fflags |= IntegerFormat.SHOW_BASE;\n            if ((flags & SEEN_PLUS) != 0)\n              fflags |= IntegerFormat.SHOW_PLUS;\n            if ((flags & SEEN_MINUS) != 0)\n              fflags |= IntegerFormat.PAD_RIGHT;\n            if ((flags & SEEN_SPACE) != 0)\n              fflags |= IntegerFormat.SHOW_SPACE;\n\t    if (precision != PARAM_UNSPECIFIED)\n\t      {\n\t\tflags &= ~ SEEN_ZERO;\n\t\tfflags |= IntegerFormat.MIN_DIGITS;\n\t\tformat = IntegerFormat.getInstance(base, precision,\n\t\t\t\t\t\t   '0', PARAM_UNSPECIFIED,\n\t\t\t\t\t\t   PARAM_UNSPECIFIED, fflags);\n\t      }\n\t    else\n\t      format = IntegerFormat.getInstance(base, width,\n\t\t\t\t\t\t padChar, PARAM_UNSPECIFIED,\n\t\t\t\t\t\t PARAM_UNSPECIFIED, fflags);\n            break;\n\t  case 'f':\n\t  case 'e':\n\t  case 'E':\n\t  case 'g':\n\t  case 'G':\n              LispRealFormat dfmt = new LispRealFormat();\n              dfmt.op = (char) ch;\n              dfmt.style = 'P';\n              dfmt.arg1 = width;\n              if (precision == PARAM_UNSPECIFIED)\n                  precision = 6;\n              dfmt.arg2 = precision;\n              dfmt.showPlus = (flags & SEEN_PLUS) != 0;\n              if (ch == 'e' || ch == 'E' || ch == 'g' || ch == 'G') {\n                  dfmt.arg3 = 2;\n                  dfmt.arg4 = 1; // intDigits\n                  dfmt.arg5 = '\\0'; // overflowChar\n                  dfmt.arg6  = padChar;\n                  // set exponentChar\n                  dfmt.arg7 = ch == 'E' || ch == 'G' ? 'E' : 'e';\n              }\n              else {\n                  dfmt.arg3 = '\\0'; // overflowChar\n                  dfmt.arg5 = padChar;\n              }\n              dfmt.internalPad = true;\n              format = dfmt.resolve(null, 0);\n\t    break;\n\t  default:\n\t    throw new ParseException (\"unknown format character '\"+ch+\"'\", -1);\n\t  }\n\tif (width > 0)\n\t  {\n\t    padChar = (flags & SEEN_ZERO) != 0 ? '0' : ' ';\n\t    int where;\n\t    if ((flags & SEEN_MINUS) != 0)\n\t      where = 100;\n\t    else if (padChar == '0')\n\t      where = -1;\n\t    else\n\t      where = 0;\n\t    format = new gnu.text.PadFormat(format, width, padChar, where);\n\t  }\n\t// FIXME handle re-positioning\n\t//fbuf.append('{');\n        // fbuf.append(position);\n\t//fbuf.append('}');\n\tformats.add(format);\n\tposition++;\n      }\n    int fcount = formats.size();\n    if (fcount == 1)\n      {\n\tObject f = formats.get(0);\n\tif (f instanceof ReportFormat)\n\t  return (ReportFormat) f;\n      }\n    return new CompoundFormat(formats.toArray(new Format[fcount]));\n  }\n  public Object apply1 (Object arg)\n  {\n    return asFormat(arg, emacsStyle ? '?' : '~');\n  }\n  public static ReportFormat asFormat (Object arg, char style)\n  {\n    try\n      {\n\tif (arg instanceof ReportFormat)\n\t  return (ReportFormat) arg;\n\tif (style == '~')\n\t  return new LispFormat(arg.toString());\n\telse\n\t  {\n\t    InPort iport;\n\t    if (arg instanceof FString)\n              iport = ((FString) arg).openReader();\n\t    else \n\t      iport = new CharArrayInPort(arg.toString()); \n\t    try\n\t      {\n\t\treturn parseFormat(iport, style);\n\t      }\n\t    finally\n\t      {\n\t\tiport.close();\n\t      }\n\t  }\n      }\n    catch (java.io.IOException ex)\n      {\n\tthrow new RuntimeException(\"Error parsing format (\"+ex+\")\");\n      }\n    catch (ParseException ex)\n      {\n\tthrow new RuntimeException(\"Invalid format (\"+ex+\")\");\n      }\n    catch (IndexOutOfBoundsException ex)\n      {\n\tthrow new RuntimeException(\"End while parsing format\");\n      }\n  }\n"]], "pred": {"ppl": 1.9784948825836182, "ppl_lower": 2.1873066425323486, "ppl/lowercase_ppl": -1.1470455756398232, "ppl/zlib": 0.00030366550748855763, "Min_5.0% Prob": 6.153132214265711, "Min_10.0% Prob": 4.658568354213939, "Min_20.0% Prob": 3.110041281756233, "Min_30.0% Prob": 2.2186287156994045, "Min_40.0% Prob": 1.6922752615656422, "Min_50.0% Prob": 1.362053082548738, "Min_60.0% Prob": 1.137633553392377}}
{"hexsha": "62deea51006c906050fa5eaf0b3179ecb18c3682", "ext": "java", "lang": "Java", "content": "public class MetadataCriterion implements Criterion {\n\n    private String key;\n\n    private String value;\n\n    /**\n     * Creates a MetadataCriterion with the key attribute set to {@code key}, the value attribute to {@code value}.\n     *\n     * @param key the metadata key\n     * @param value the metadata value\n     */\n    public MetadataCriterion(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public List<Enrollment> fetch(AllEnrollments allEnrollments) {\n        return allEnrollments.findByMetadataProperty(key, value);\n    }\n\n    @Override\n    public List<Enrollment> filter(List<Enrollment> enrollments) {\n        List<Enrollment> filteredEnrollments = new ArrayList<Enrollment>();\n        for (Enrollment enrollment : enrollments) {\n            if (enrollment.getMetadata() != null && value.equals(enrollment.getMetadata().get(key))) {\n                filteredEnrollments.add(enrollment);\n            }\n        }\n        return filteredEnrollments;\n    }\n\n\n}", "class_id": 0, "repo": "piopawel/modules", "file": "schedule-tracking/src/main/java/org/motechproject/scheduletracking/domain/search/MetadataCriterion.java", "last_update_at": "2018-07-14T20:38:19+00:00", "question_id": "62deea51006c906050fa5eaf0b3179ecb18c3682", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MetadataCriterion implements Criterion {\n    private String key;\n    private String value;\n    /**\n     * Creates a MetadataCriterion with the key attribute set to {@code key}, the value attribute to {@code value}.\n     *\n     * @param key the metadata key\n     * @param value the metadata value\n     */\n    public MetadataCriterion(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n    @Override\n    public List<Enrollment> fetch(AllEnrollments allEnrollments) {\n        return allEnrollments.findByMetadataProperty(key, value);\n    }\n    @Override\n    public List<Enrollment> filter(List<Enrollment> enrollments) {\n        List<Enrollment> filteredEnrollments = new ArrayList<Enrollment>();\n        for (Enrollment enrollment : enrollments) {\n            if (enrollment.getMetadata() != null && value.equals(enrollment.getMetadata().get(key))) {\n                filteredEnrollments.add(enrollment);\n            }\n        }\n        return filteredEnrollments;\n    }\n"]], "pred": {"ppl": 1.647229552268982, "ppl_lower": 2.1110334396362305, "ppl/lowercase_ppl": -1.4970654537591286, "ppl/zlib": 0.0013599313827840293, "Min_5.0% Prob": 5.793065752301898, "Min_10.0% Prob": 3.9879832678827745, "Min_20.0% Prob": 2.35558548364146, "Min_30.0% Prob": 1.6403086932226159, "Min_40.0% Prob": 1.2450616807227248, "Min_50.0% Prob": 0.9996744257237377, "Min_60.0% Prob": 0.8340965382348018}}
{"hexsha": "05a56089dd1acc0703a839d688437da96a0423c8", "ext": "java", "lang": "Java", "content": "public class TramiteDto implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String codTramite;\n\n    private String nomRemitente;\n\n    private String nomDestinatario;\n\n    private String desComentario;\n\n    private String desAsunto;\n\n    private String codEstado;\n\n    private String nomEstado;\n    \n    private Date fecRegistro;\n\n    private String numDocumento;\n\n    private List<TramiteDocumentoDto> documentosAdjuntos;\n\n    private DocumentoAdjuntoDto documentoAdjunto;\n\n    public TramiteDto() {\n\n        documentosAdjuntos = new ArrayList<>();\n        documentoAdjunto=new DocumentoAdjuntoDto();\n    }\n\n    public TramiteDto(String codTramite, String nomRemitente, String nomDestinatario, String desComentario, String desAsunto, String codEstado, Date fecRegistro, List<TramiteDocumentoDto> documentosAdjuntos,String nomEstado) {\n        this.codTramite = codTramite;\n        this.nomRemitente = nomRemitente;\n        this.nomDestinatario = nomDestinatario;\n        this.desComentario = desComentario;\n        this.desAsunto = desAsunto;\n        this.codEstado = codEstado;\n        this.fecRegistro = fecRegistro;\n        this.documentosAdjuntos = documentosAdjuntos;\n        this.nomEstado=nomEstado;\n    }\n    \n    \n    \n    \n\n    public String getCodTramite() {\n        return codTramite;\n    }\n\n    public void setCodTramite(String codTramite) {\n        this.codTramite = codTramite;\n    }\n\n    public String getNomRemitente() {\n        return nomRemitente;\n    }\n\n    public void setNomRemitente(String nomRemitente) {\n        this.nomRemitente = nomRemitente;\n    }\n\n    public String getNomDestinatario() {\n        return nomDestinatario;\n    }\n\n    public void setNomDestinatario(String nomDestinatario) {\n        this.nomDestinatario = nomDestinatario;\n    }\n\n    public String getDesComentario() {\n        return desComentario;\n    }\n\n    public void setDesComentario(String desComentario) {\n        this.desComentario = desComentario;\n    }\n\n    public String getDesAsunto() {\n        return desAsunto;\n    }\n\n    public void setDesAsunto(String desAsunto) {\n        this.desAsunto = desAsunto;\n    }\n\n    public String getCodEstado() {\n        return codEstado;\n    }\n\n    public void setCodEstado(String codEstado) {\n        this.codEstado = codEstado;\n    }\n\n    public Date getFecRegistro() {\n        return fecRegistro;\n    }\n\n    public void setFecRegistro(Date fecRegistro) {\n        this.fecRegistro = fecRegistro;\n    }\n\n    public String getNumDocumento() {\n        return numDocumento;\n    }\n\n    public void setNumDocumento(String numDocumento) {\n        this.numDocumento = numDocumento;\n    }\n\n  \n    public List<TramiteDocumentoDto> getDocumentosAdjuntos() {\n        return documentosAdjuntos;\n    }\n\n    public void setDocumentosAdjuntos(List<TramiteDocumentoDto> documentosAdjuntos) {\n        this.documentosAdjuntos = documentosAdjuntos;\n    }\n\n    public DocumentoAdjuntoDto getDocumentoAdjunto() {\n        return documentoAdjunto;\n    }\n\n    public void setDocumentoAdjunto(DocumentoAdjuntoDto documentoAdjunto) {\n        this.documentoAdjunto = documentoAdjunto;\n    }\n\n    public String getNomEstado() {\n        return nomEstado;\n    }\n\n    public void setNomEstado(String nomEstado) {\n        this.nomEstado = nomEstado;\n    }\n    \n    \n    \n    \n\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 53 * hash + Objects.hashCode(this.codTramite);\n        hash = 53 * hash + Objects.hashCode(this.nomRemitente);\n        hash = 53 * hash + Objects.hashCode(this.nomDestinatario);\n        hash = 53 * hash + Objects.hashCode(this.desComentario);\n        hash = 53 * hash + Objects.hashCode(this.desAsunto);\n        hash = 53 * hash + Objects.hashCode(this.codEstado);\n        hash = 53 * hash + Objects.hashCode(this.fecRegistro);\n        hash = 53 * hash + Objects.hashCode(this.numDocumento);\n        return hash;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final TramiteDto other = (TramiteDto) obj;\n        if (!Objects.equals(this.codTramite, other.codTramite)) {\n            return false;\n        }\n        if (!Objects.equals(this.nomRemitente, other.nomRemitente)) {\n            return false;\n        }\n        if (!Objects.equals(this.nomDestinatario, other.nomDestinatario)) {\n            return false;\n        }\n        if (!Objects.equals(this.desComentario, other.desComentario)) {\n            return false;\n        }\n        if (!Objects.equals(this.desAsunto, other.desAsunto)) {\n            return false;\n        }\n        if (!Objects.equals(this.codEstado, other.codEstado)) {\n            return false;\n        }\n        if (!Objects.equals(this.numDocumento, other.numDocumento)) {\n            return false;\n        }\n        if (!Objects.equals(this.fecRegistro, other.fecRegistro)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"TramiteDto{\" + \"codTramite=\" + codTramite + \", nomRemitente=\" + nomRemitente + \", nomDestinatario=\" + nomDestinatario + \", desComentario=\" + desComentario + \", desAsunto=\" + desAsunto + \", codEstado=\" + codEstado + \", fecRegistro=\" + fecRegistro + \", numDocumento=\" + numDocumento + '}';\n    }\n\n}", "class_id": 0, "repo": "christian1607/Sistradoc_V2", "file": "src/main/java/com/celmam/dto/TramiteDto.java", "last_update_at": "2018-06-22T17:37:12+00:00", "question_id": "05a56089dd1acc0703a839d688437da96a0423c8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TramiteDto implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String codTramite;\n    private String nomRemitente;\n    private String nomDestinatario;\n    private String desComentario;\n    private String desAsunto;\n    private String codEstado;\n    private String nomEstado;\n    private Date fecRegistro;\n    private String numDocumento;\n    private List<TramiteDocumentoDto> documentosAdjuntos;\n    private DocumentoAdjuntoDto documentoAdjunto;\n    public TramiteDto() {\n        documentosAdjuntos = new ArrayList<>();\n        documentoAdjunto=new DocumentoAdjuntoDto();\n    }\n    public TramiteDto(String codTramite, String nomRemitente, String nomDestinatario, String desComentario, String desAsunto, String codEstado, Date fecRegistro, List<TramiteDocumentoDto> documentosAdjuntos,String nomEstado) {\n        this.codTramite = codTramite;\n        this.nomRemitente = nomRemitente;\n        this.nomDestinatario = nomDestinatario;\n        this.desComentario = desComentario;\n        this.desAsunto = desAsunto;\n        this.codEstado = codEstado;\n        this.fecRegistro = fecRegistro;\n        this.documentosAdjuntos = documentosAdjuntos;\n        this.nomEstado=nomEstado;\n    }\n    public String getCodTramite() {\n        return codTramite;\n    }\n    public void setCodTramite(String codTramite) {\n        this.codTramite = codTramite;\n    }\n    public String getNomRemitente() {\n        return nomRemitente;\n    }\n    public void setNomRemitente(String nomRemitente) {\n        this.nomRemitente = nomRemitente;\n    }\n    public String getNomDestinatario() {\n        return nomDestinatario;\n    }\n    public void setNomDestinatario(String nomDestinatario) {\n        this.nomDestinatario = nomDestinatario;\n    }\n    public String getDesComentario() {\n        return desComentario;\n    }\n    public void setDesComentario(String desComentario) {\n        this.desComentario = desComentario;\n    }\n    public String getDesAsunto() {\n        return desAsunto;\n    }\n    public void setDesAsunto(String desAsunto) {\n        this.desAsunto = desAsunto;\n    }\n    public String getCodEstado() {\n        return codEstado;\n    }\n    public void setCodEstado(String codEstado) {\n        this.codEstado = codEstado;\n    }\n    public Date getFecRegistro() {\n        return fecRegistro;\n    }\n    public void setFecRegistro(Date fecRegistro) {\n        this.fecRegistro = fecRegistro;\n    }\n    public String getNumDocumento() {\n        return numDocumento;\n    }\n    public void setNumDocumento(String numDocumento) {\n        this.numDocumento = numDocumento;\n    }\n    public List<TramiteDocumentoDto> getDocumentosAdjuntos() {\n        return documentosAdjuntos;\n    }\n    public void setDocumentosAdjuntos(List<TramiteDocumentoDto> documentosAdjuntos) {\n        this.documentosAdjuntos = documentosAdjuntos;\n    }\n    public DocumentoAdjuntoDto getDocumentoAdjunto() {\n        return documentoAdjunto;\n    }\n    public void setDocumentoAdjunto(DocumentoAdjuntoDto documentoAdjunto) {\n        this.documentoAdjunto = documentoAdjunto;\n    }\n    public String getNomEstado() {\n        return nomEstado;\n    }\n    public void setNomEstado(String nomEstado) {\n        this.nomEstado = nomEstado;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 53 * hash + Objects.hashCode(this.codTramite);\n        hash = 53 * hash + Objects.hashCode(this.nomRemitente);\n        hash = 53 * hash + Objects.hashCode(this.nomDestinatario);\n        hash = 53 * hash + Objects.hashCode(this.desComentario);\n        hash = 53 * hash + Objects.hashCode(this.desAsunto);\n        hash = 53 * hash + Objects.hashCode(this.codEstado);\n        hash = 53 * hash + Objects.hashCode(this.fecRegistro);\n        hash = 53 * hash + Objects.hashCode(this.numDocumento);\n        return hash;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final TramiteDto other = (TramiteDto) obj;\n        if (!Objects.equals(this.codTramite, other.codTramite)) {\n            return false;\n        }\n        if (!Objects.equals(this.nomRemitente, other.nomRemitente)) {\n            return false;\n        }\n        if (!Objects.equals(this.nomDestinatario, other.nomDestinatario)) {\n            return false;\n        }\n        if (!Objects.equals(this.desComentario, other.desComentario)) {\n            return false;\n        }\n        if (!Objects.equals(this.desAsunto, other.desAsunto)) {\n            return false;\n        }\n        if (!Objects.equals(this.codEstado, other.codEstado)) {\n            return false;\n        }\n        if (!Objects.equals(this.numDocumento, other.numDocumento)) {\n            return false;\n        }\n        if (!Objects.equals(this.fecRegistro, other.fecRegistro)) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    public String toString() {\n        return \"TramiteDto{\" + \"codTramite=\" + codTramite + \", nomRemitente=\" + nomRemitente + \", nomDestinatario=\" + nomDestinatario + \", desComentario=\" + desComentario + \", desAsunto=\" + desAsunto + \", codEstado=\" + codEstado + \", fecRegistro=\" + fecRegistro + \", numDocumento=\" + numDocumento + '}';\n    }\n"]], "pred": {"ppl": 1.1914820671081543, "ppl_lower": 1.2695024013519287, "ppl/lowercase_ppl": -1.3620307252974324, "ppl/zlib": 0.0001762554997563745, "Min_5.0% Prob": 2.8967937207689474, "Min_10.0% Prob": 1.6825765596300948, "Min_20.0% Prob": 0.8725580845356864, "Min_30.0% Prob": 0.5847468712181462, "Min_40.0% Prob": 0.43797208998730286, "Min_50.0% Prob": 0.35067504303941754, "Min_60.0% Prob": 0.29236034300527913}}
{"hexsha": "ebf256c4e30dc2018b7d137838b24c4533c10cdf", "ext": "java", "lang": "Java", "content": "public class ThreeLineAvatarWithTextView extends BaseView {\n\n    public ThreeLineAvatarWithTextView(Context context) {\n        super(context);\n    }\n\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n    }\n\n    @Override\n    protected int getLayoutResourceId() {\n        return R.layout.three_line_avatar_with_text_view;\n    }\n\n    @Override\n    protected int[] getStyleAttributeIds() {\n        return R.styleable.ThreeLineAvatarWithTextView;\n    }\n\n    @Override\n    protected void useStyleAttributes(TypedArray attrs) {\n        String titleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForTitle);\n        int titleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForTitle, -1);\n        float titleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForTitle, -1);\n        int titleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForTitle, Typeface.NORMAL);\n        int titleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForTitle, 0);\n        String titleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForTitle);\n        String subtitleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForSubtitle);\n        int subtitleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForSubtitle, -1);\n        float subtitleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForSubtitle, -1);\n        int subtitleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForSubtitle, Typeface.NORMAL);\n        int subtitleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForSubtitle, 0);\n        String subtitleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForSubtitle);\n        Drawable avatarSrc = attrs.getDrawable(R.styleable.ThreeLineAvatarWithTextView_avatarSrc);\n        attrs.recycle();\n\n        prepareTextViewWithAttrValues(mViewTitle, titleText, titleTextColor, titleTextSize, titleTextStyle, titleTypeface, titleFontFamily);\n        prepareTextViewWithAttrValues(mViewSubtitle, subtitleText, subtitleTextColor, subtitleTextSize, subtitleTextStyle, subtitleTypeface, subtitleFontFamily);\n        prepareAvatarViewWithAttrValues(avatarSrc);\n    }\n\n    @Override\n    protected void prepareChildViews() {\n        mViewSubtitle.setMaxLines(2);\n    }\n\n    @Override\n    protected int getMinimumHeightInList() {\n        return getContext().getResources().getDimensionPixelSize(R.dimen.threeLineListItemHeight);\n    }\n\n    @Override\n    public TextView getTitleView() {\n        return super.getTitleView();\n    }\n\n    @Override\n    public TextView getSubtitleView() {\n        return super.getSubtitleView();\n    }\n\n    @Override\n    public AvatarImageView getAvatarImageView() {\n        return super.getAvatarImageView();\n    }\n\n}", "class_id": 0, "repo": "asadmshah/materiallistitem", "file": "materiallistitem/src/main/java/com/asadmshah/materiallistitem/ThreeLineAvatarWithTextView.java", "last_update_at": "2018-07-13T12:32:12+00:00", "question_id": "ebf256c4e30dc2018b7d137838b24c4533c10cdf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ThreeLineAvatarWithTextView extends BaseView {\n    public ThreeLineAvatarWithTextView(Context context) {\n        super(context);\n    }\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n    }\n    @Override\n    protected int getLayoutResourceId() {\n        return R.layout.three_line_avatar_with_text_view;\n    }\n    @Override\n    protected int[] getStyleAttributeIds() {\n        return R.styleable.ThreeLineAvatarWithTextView;\n    }\n    @Override\n    protected void useStyleAttributes(TypedArray attrs) {\n        String titleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForTitle);\n        int titleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForTitle, -1);\n        float titleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForTitle, -1);\n        int titleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForTitle, Typeface.NORMAL);\n        int titleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForTitle, 0);\n        String titleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForTitle);\n        String subtitleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForSubtitle);\n        int subtitleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForSubtitle, -1);\n        float subtitleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForSubtitle, -1);\n        int subtitleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForSubtitle, Typeface.NORMAL);\n        int subtitleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForSubtitle, 0);\n        String subtitleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForSubtitle);\n        Drawable avatarSrc = attrs.getDrawable(R.styleable.ThreeLineAvatarWithTextView_avatarSrc);\n        attrs.recycle();\n        prepareTextViewWithAttrValues(mViewTitle, titleText, titleTextColor, titleTextSize, titleTextStyle, titleTypeface, titleFontFamily);\n        prepareTextViewWithAttrValues(mViewSubtitle, subtitleText, subtitleTextColor, subtitleTextSize, subtitleTextStyle, subtitleTypeface, subtitleFontFamily);\n        prepareAvatarViewWithAttrValues(avatarSrc);\n    }\n    @Override\n    protected void prepareChildViews() {\n        mViewSubtitle.setMaxLines(2);\n    }\n    @Override\n    protected int getMinimumHeightInList() {\n        return getContext().getResources().getDimensionPixelSize(R.dimen.threeLineListItemHeight);\n    }\n    @Override\n    public TextView getTitleView() {\n        return super.getTitleView();\n    }\n    @Override\n    public TextView getSubtitleView() {\n        return super.getSubtitleView();\n    }\n    @Override\n    public AvatarImageView getAvatarImageView() {\n        return super.getAvatarImageView();\n    }\n"]], "pred": {"ppl": 1.3409423828125, "ppl_lower": 1.4937090873718262, "ppl/lowercase_ppl": -1.3677565518070096, "ppl/zlib": 0.00041910376791345937, "Min_5.0% Prob": 4.120233650008838, "Min_10.0% Prob": 2.6615074694771126, "Min_20.0% Prob": 1.4479684298185957, "Min_30.0% Prob": 0.9753182887570145, "Min_40.0% Prob": 0.7328984121073123, "Min_50.0% Prob": 0.5865977273098212, "Min_60.0% Prob": 0.4889102446164274}}
{"hexsha": "a2ca575501639c8c26ae2c4ef665ad8675ab6df4", "ext": "java", "lang": "Java", "content": "public class FormDataFileTableGenerator extends HttpServlet {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\t\tresponse.setContentType(\"text/html\");\r\n\t\t\r\n\t\tServletContext context = request.getServletContext();\r\n\t\tfinal String INPUT_FILE_PATH =  context.getRealPath(\"/\") + \"output.txt\";\r\n\t\t\r\n\t\tStringBuilder pageHTML = new StringBuilder(\r\n\t\t\t\"<!DOCTYPE html>\" +\r\n\t\t\t\"<html>\"+\r\n\t\t\t\"<body>\" +\r\n\t\t\t\t\"<table border='1'>\"\r\n\t\t);\r\n\t\t\r\n\t\t// Read from input file & add to page HTML\r\n\t\tBufferedReader bufferedReader = new BufferedReader(new FileReader(INPUT_FILE_PATH));\r\n\t\tString line = \"\";\r\n\t\twhile ((line = bufferedReader.readLine()) != null) {\r\n\t\t\tpageHTML.append(\r\n\t\t\t\t\t\"<tr><td>\" + line + \"</td></td>\"\t\r\n\t\t\t);\r\n\t\t}\r\n\t\tbufferedReader.close();\r\n\t\t\r\n\t\tpageHTML.append(\r\n\t\t\t\t\"</table>\" +\r\n\t\t\t\"</body>\" +\r\n\t\t\t\"</html>\");\r\n\t\t\r\n\t\tPrintWriter output = response.getWriter();\r\n\t\toutput.print(pageHTML);\r\n\t}\r\n\r\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\t\t// TODO Auto-generated method stub\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "dvt32/cpp-journey", "file": "Java/Uni-Ruse/Internet-Technologies/course_work_1/src/main/java/servlets/FormDataFileTableGenerator.java", "last_update_at": "2018-05-24T11:30:05+00:00", "question_id": "a2ca575501639c8c26ae2c4ef665ad8675ab6df4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FormDataFileTableGenerator extends HttpServlet {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\t\tresponse.setContentType(\"text/html\");\r\n\t\t\r\n\t\tServletContext context = request.getServletContext();\r\n\t\tfinal String INPUT_FILE_PATH =  context.getRealPath(\"/\") + \"output.txt\";\r\n\t\t\r\n\t\tStringBuilder pageHTML = new StringBuilder(\r\n\t\t\t\"<!DOCTYPE html>\" +\r\n\t\t\t\"<html>\"+\r\n\t\t\t\"<body>\" +\r\n\t\t\t\t\"<table border='1'>\"\r\n\t\t);\r\n\t\t\r\n\t\t// Read from input file & add to page HTML\r\n\t\tBufferedReader bufferedReader = new BufferedReader(new FileReader(INPUT_FILE_PATH));\r\n\t\tString line = \"\";\r\n\t\twhile ((line = bufferedReader.readLine()) != null) {\r\n\t\t\tpageHTML.append(\r\n\t\t\t\t\t\"<tr><td>\" + line + \"</td></td>\"\t\r\n\t\t\t);\r\n\t\t}\r\n\t\tbufferedReader.close();\r\n\t\t\r\n\t\tpageHTML.append(\r\n\t\t\t\t\"</table>\" +\r\n\t\t\t\"</body>\" +\r\n\t\t\t\"</html>\");\r\n\t\t\r\n\t\tPrintWriter output = response.getWriter();\r\n\t\toutput.print(pageHTML);\r\n\t}\r\n\r\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n\t\t// TODO Auto-generated method stub\r\n\t}\r\n\r\n"]], "pred": {"ppl": 1.853031039237976, "ppl_lower": 2.1229403018951416, "ppl/lowercase_ppl": -1.2204512984311668, "ppl/zlib": 0.0011054170214443348, "Min_5.0% Prob": 6.097730875015259, "Min_10.0% Prob": 4.457343256473541, "Min_20.0% Prob": 2.8421086139149137, "Min_30.0% Prob": 2.0052959530568515, "Min_40.0% Prob": 1.5294531001452287, "Min_50.0% Prob": 1.2300491854731066, "Min_60.0% Prob": 1.03048979398054}}
{"hexsha": "58ae8f016e5126730810de741270916b2d72845d", "ext": "java", "lang": "Java", "content": "public class Matches implements FileEvents {\r\n    private enum MatchType {\r\n        Practice,\r\n        Qualification,\r\n        Semifinal,\r\n        Final;\r\n        \r\n        public static MatchType parse(int number) {\r\n            switch (number) {\r\n                case 0:\r\n                    return Practice;\r\n                case 1:\r\n                    return Qualification;\r\n                case 2:\r\n                    return Semifinal;\r\n                case 3:\r\n                    return Final;\r\n            }\r\n            return Qualification;\r\n        }\r\n    }\r\n    \r\n    private final File file;\r\n    \r\n    private final JSONArray matchArray;\r\n    \r\n    public Matches(File _file) {\r\n        file = _file;\r\n        matchArray = new JSONArray();\r\n        if(file.exists()) {\r\n            parseFile();\r\n        }\r\n        \r\n        try {\r\n            App.app.dirWatcher.registerFile(this);\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(Matches.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n    \r\n    public JSONArray getMatchList() {\r\n        return matchArray;\r\n    }\r\n    \r\n    public final void parseFile() {\r\n        String row;\r\n        int i = 0;\r\n        try {\r\n            FileReader fileReader = new FileReader(file);\r\n            BufferedReader bufferedReader = new BufferedReader(fileReader);\r\n            \r\n            while((row = bufferedReader.readLine()) != null) {\r\n                parseRow(i, row);\r\n                i++;\r\n            }\r\n            \r\n            bufferedReader.close();\r\n            \r\n            App.app.log(\"Match List\", matchArray.toJSONString());\r\n            \r\n        } catch (FileNotFoundException ex) {\r\n            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n    \r\n    private void parseRow(int i, String row) {\r\n        int c = 0;\r\n        String cols[] = row.split(\"\\\\|\",-1);\r\n        int division = Integer.parseInt(cols[c++]);\r\n        MatchType matchType = MatchType.parse(Integer.parseInt(cols[c++]));\r\n        int number = Integer.parseInt(cols[c++]);\r\n        int matchStartTimeCnt = Integer.parseInt(cols[c++]);\r\n        \r\n        long matchStartTime = 0;\r\n        \r\n        for(int k = 0; k<matchStartTimeCnt; k++) {\r\n            matchStartTime = Long.parseLong(cols[c++]);\r\n        }\r\n        \r\n        \r\n        c++;// dummy = cols[4]\r\n        \r\n        int[] red_team = new int[3];        \r\n        red_team[0] = Integer.parseInt(cols[c++]);\r\n        red_team[1] = Integer.parseInt(cols[c++]);\r\n        red_team[2] = Integer.parseInt(cols[c++]);\r\n        int[] blue_team = new int[3];\r\n        blue_team[0] = Integer.parseInt(cols[c++]);\r\n        blue_team[1] = Integer.parseInt(cols[c++]);\r\n        blue_team[2] = Integer.parseInt(cols[c++]);\r\n        c++;// int red1_state = cols[11] - 0: normal, 1: noshow, 2: DQed\r\n        c++;// int red2_state = cols[12] //\r\n        c++;// int red3_state = cols[13] //\r\n        c++;// bool red1_yellow_card = cols[14]\r\n        c++;// bool red2_yellow_card = cols[15]\r\n        c++;// bool red3_yellow_card = cols[16]\r\n        c++;// int blue1_state = cols[17]\r\n        c++;// int blue2_state = cols[18]\r\n        c++;// int blue3_state = cols[19]\r\n        c++;// int blue1_yellow = cols[20]\r\n        c++;// int blue2_yellow = cols[21]\r\n        c++;// int blue3_yellow = cols[22]\r\n        boolean[] red_surrogate = new boolean[3];\r\n        red_surrogate[0] = \"1\".equals(cols[c++]);\r\n        red_surrogate[1] = \"1\".equals(cols[c++]);\r\n        red_surrogate[2] = \"1\".equals(cols[c++]);\r\n        boolean[] blue_surrogate = new boolean[3];\r\n        blue_surrogate[0] = \"1\".equals(cols[c++]);\r\n        blue_surrogate[1] = \"1\".equals(cols[c++]);\r\n        blue_surrogate[2] = \"1\".equals(cols[c++]);\r\n        boolean saved = \"1\".equals(cols[c++]);\r\n        \r\n        int red_autoJewlesRemaining = Integer.parseInt(cols[c++]);\r\n        int red_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);\r\n        int red_autoCryptoboxKeys = Integer.parseInt(cols[c++]);\r\n        int red_autoRobotParked = Integer.parseInt(cols[c++]);\r\n        int red_teleGlyphsScored = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedRows = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedColumns = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedCyphers = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone1 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone2 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone3 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsUpright = Integer.parseInt(cols[c++]);\r\n        int red_endgRobotsBalanced = Integer.parseInt(cols[c++]);\r\n        int red_minorPenalties = Integer.parseInt(cols[c++]);\r\n        int red_majorPenalties = Integer.parseInt(cols[c++]);\r\n        int red_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);\r\n        int red_majorPenalitesAwarded = Integer.parseInt(cols[c++]);\r\n        \r\n        int blue_autoJewlesRemaining = Integer.parseInt(cols[c++]);\r\n        int blue_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);\r\n        int blue_autoCryptoboxKeys = Integer.parseInt(cols[c++]);\r\n        int blue_autoRobotParked = Integer.parseInt(cols[c++]);\r\n        int blue_teleGlyphsScored = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedRows = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedColumns = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedCyphers = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone1 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone2 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone3 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsUpright = Integer.parseInt(cols[c++]);\r\n        int blue_endgRobotsBalanced = Integer.parseInt(cols[c++]);\r\n        int blue_minorPenalties = Integer.parseInt(cols[c++]);\r\n        int blue_majorPenalties = Integer.parseInt(cols[c++]);\r\n        int blue_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);\r\n        int blue_majorPenalitesAwarded = Integer.parseInt(cols[c++]);\r\n        \r\n        \r\n        int red_autoBonus = 0;\r\n        int red_auto = 30 * red_autoJewlesRemaining + 15 * red_autoGlyphsInCryptobox +\r\n                30 * red_autoCryptoboxKeys + 10 * red_autoRobotParked;\r\n        int red_endGame = 10 * red_endgRelicsInZone1 + 20 * red_endgRelicsInZone2 +\r\n                40 * red_endgRelicsInZone3 + 15 * red_endgRelicsUpright +\r\n                20 * red_endgRobotsBalanced;\r\n        int red_teleop = 2 * red_teleGlyphsScored + 10 * red_teleCompletedRows +\r\n                20 * red_teleCompletedColumns + 30 * red_teleCompletedCyphers;\r\n        int blue_penalties = 10 * red_minorPenalties + 40 * red_majorPenalties;\r\n        \r\n        \r\n        int blue_autoBonus = 0;\r\n        int blue_auto = 30 * blue_autoJewlesRemaining + 15 * blue_autoGlyphsInCryptobox +\r\n                30 * blue_autoCryptoboxKeys + 10 * blue_autoRobotParked;\r\n        int blue_endGame = 10 * blue_endgRelicsInZone1 + 20 * blue_endgRelicsInZone2 +\r\n                40 * blue_endgRelicsInZone3 + 15 * blue_endgRelicsUpright +\r\n                20 * blue_endgRobotsBalanced;\r\n        int blue_teleop = 2 * blue_teleGlyphsScored + 10 * blue_teleCompletedRows +\r\n                20 * blue_teleCompletedColumns + 30 * blue_teleCompletedCyphers;\r\n        int red_penalties = 10 * blue_minorPenalties + 40 * blue_majorPenalties;\r\n        \r\n        JSONObject match = new JSONObject();\r\n        JSONObject red = new JSONObject();\r\n        JSONObject blue = new JSONObject();\r\n        \r\n        JSONArray red_teams = new JSONArray();\r\n        int j;\r\n        for(j=0;j<3;j++) {\r\n            JSONObject t = new JSONObject();\r\n            if(red_team[j] != 0) { \r\n                t.put(\"number\", red_team[j]);\r\n                t.put(\"surrogate\", red_surrogate[j]);\r\n                red_teams.add(t);\r\n            }\r\n        }\r\n        red.put(\"teams\", red_teams);\r\n        \r\n        \r\n        JSONArray blue_teams = new JSONArray();\r\n        for(j=0;j<3;j++) {\r\n            JSONObject t = new JSONObject();\r\n            if(blue_team[j] != 0) { \r\n                t.put(\"number\", blue_team[j]);\r\n                t.put(\"surrogate\", blue_surrogate[j]);\r\n                blue_teams.add(t);\r\n            }\r\n        }\r\n        blue.put(\"teams\", blue_teams);\r\n\r\n        \r\n        \r\n        \r\n        \r\n        if(saved) {\r\n            red.put(\"auto_bonus\", red_autoBonus);\r\n            red.put(\"auto\", red_auto);\r\n            red.put(\"teleop\", red_teleop);\r\n            red.put(\"endg\", red_endGame);\r\n            red.put(\"penalties\", red_penalties);\r\n            \r\n            blue.put(\"auto_bonus\", blue_autoBonus);\r\n            blue.put(\"auto\", blue_auto);\r\n            blue.put(\"teleop\", blue_teleop);\r\n            blue.put(\"endg\", blue_endGame);\r\n            blue.put(\"penalties\", blue_penalties);\r\n        }\r\n        \r\n        match.put(\"start\", matchStartTime);\r\n        \r\n        match.put(\"number\", number);\r\n        match.put(\"division\", division);\r\n        match.put(\"type\", matchType.toString());\r\n        match.put(\"red\", red);\r\n        match.put(\"blue\", blue);\r\n        \r\n        if(i < matchArray.size())\r\n            matchArray.set(i, match);\r\n        else\r\n            matchArray.add(i, match);\r\n        App.app.log(\"Parsed Match\", match.toJSONString());\r\n    }\r\n\r\n    @Override\r\n    public void onFileCreate() {\r\n        parseFile();\r\n    }\r\n\r\n    @Override\r\n    public void onFileDelete() {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void onFileModify() {\r\n        parseFile();\r\n    }\r\n    \r\n    @Override\r\n    public File getFile() {\r\n        return file;\r\n    }\r\n}", "class_id": 0, "repo": "FTC-Iowa/scorewatcher", "file": "src/main/java/org/firstinspiresiowa/scorewatcher/Matches.java", "last_update_at": "2018-04-09T17:29:33+00:00", "question_id": "58ae8f016e5126730810de741270916b2d72845d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Matches implements FileEvents {\r\n    private enum MatchType {\r\n        Practice,\r\n        Qualification,\r\n        Semifinal,\r\n        Final;\r\n        \r\n        public static MatchType parse(int number) {\r\n            switch (number) {\r\n                case 0:\r\n                    return Practice;\r\n                case 1:\r\n                    return Qualification;\r\n                case 2:\r\n                    return Semifinal;\r\n                case 3:\r\n                    return Final;\r\n            }\r\n            return Qualification;\r\n        }\r\n    }\r\n    \r\n    private final File file;\r\n    \r\n    private final JSONArray matchArray;\r\n    \r\n    public Matches(File _file) {\r\n        file = _file;\r\n        matchArray = new JSONArray();\r\n        if(file.exists()) {\r\n            parseFile();\r\n        }\r\n        \r\n        try {\r\n            App.app.dirWatcher.registerFile(this);\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(Matches.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n    \r\n    public JSONArray getMatchList() {\r\n        return matchArray;\r\n    }\r\n    \r\n    public final void parseFile() {\r\n        String row;\r\n        int i = 0;\r\n        try {\r\n            FileReader fileReader = new FileReader(file);\r\n            BufferedReader bufferedReader = new BufferedReader(fileReader);\r\n            \r\n            while((row = bufferedReader.readLine()) != null) {\r\n                parseRow(i, row);\r\n                i++;\r\n            }\r\n            \r\n            bufferedReader.close();\r\n            \r\n            App.app.log(\"Match List\", matchArray.toJSONString());\r\n            \r\n        } catch (FileNotFoundException ex) {\r\n            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n    \r\n    private void parseRow(int i, String row) {\r\n        int c = 0;\r\n        String cols[] = row.split(\"\\\\|\",-1);\r\n        int division = Integer.parseInt(cols[c++]);\r\n        MatchType matchType = MatchType.parse(Integer.parseInt(cols[c++]));\r\n        int number = Integer.parseInt(cols[c++]);\r\n        int matchStartTimeCnt = Integer.parseInt(cols[c++]);\r\n        \r\n        long matchStartTime = 0;\r\n        \r\n        for(int k = 0; k<matchStartTimeCnt; k++) {\r\n            matchStartTime = Long.parseLong(cols[c++]);\r\n        }\r\n        \r\n        \r\n        c++;// dummy = cols[4]\r\n        \r\n        int[] red_team = new int[3];        \r\n        red_team[0] = Integer.parseInt(cols[c++]);\r\n        red_team[1] = Integer.parseInt(cols[c++]);\r\n        red_team[2] = Integer.parseInt(cols[c++]);\r\n        int[] blue_team = new int[3];\r\n        blue_team[0] = Integer.parseInt(cols[c++]);\r\n        blue_team[1] = Integer.parseInt(cols[c++]);\r\n        blue_team[2] = Integer.parseInt(cols[c++]);\r\n        c++;// int red1_state = cols[11] - 0: normal, 1: noshow, 2: DQed\r\n        c++;// int red2_state = cols[12] //\r\n        c++;// int red3_state = cols[13] //\r\n        c++;// bool red1_yellow_card = cols[14]\r\n        c++;// bool red2_yellow_card = cols[15]\r\n        c++;// bool red3_yellow_card = cols[16]\r\n        c++;// int blue1_state = cols[17]\r\n        c++;// int blue2_state = cols[18]\r\n        c++;// int blue3_state = cols[19]\r\n        c++;// int blue1_yellow = cols[20]\r\n        c++;// int blue2_yellow = cols[21]\r\n        c++;// int blue3_yellow = cols[22]\r\n        boolean[] red_surrogate = new boolean[3];\r\n        red_surrogate[0] = \"1\".equals(cols[c++]);\r\n        red_surrogate[1] = \"1\".equals(cols[c++]);\r\n        red_surrogate[2] = \"1\".equals(cols[c++]);\r\n        boolean[] blue_surrogate = new boolean[3];\r\n        blue_surrogate[0] = \"1\".equals(cols[c++]);\r\n        blue_surrogate[1] = \"1\".equals(cols[c++]);\r\n        blue_surrogate[2] = \"1\".equals(cols[c++]);\r\n        boolean saved = \"1\".equals(cols[c++]);\r\n        \r\n        int red_autoJewlesRemaining = Integer.parseInt(cols[c++]);\r\n        int red_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);\r\n        int red_autoCryptoboxKeys = Integer.parseInt(cols[c++]);\r\n        int red_autoRobotParked = Integer.parseInt(cols[c++]);\r\n        int red_teleGlyphsScored = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedRows = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedColumns = Integer.parseInt(cols[c++]);\r\n        int red_teleCompletedCyphers = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone1 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone2 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsInZone3 = Integer.parseInt(cols[c++]);\r\n        int red_endgRelicsUpright = Integer.parseInt(cols[c++]);\r\n        int red_endgRobotsBalanced = Integer.parseInt(cols[c++]);\r\n        int red_minorPenalties = Integer.parseInt(cols[c++]);\r\n        int red_majorPenalties = Integer.parseInt(cols[c++]);\r\n        int red_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);\r\n        int red_majorPenalitesAwarded = Integer.parseInt(cols[c++]);\r\n        \r\n        int blue_autoJewlesRemaining = Integer.parseInt(cols[c++]);\r\n        int blue_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);\r\n        int blue_autoCryptoboxKeys = Integer.parseInt(cols[c++]);\r\n        int blue_autoRobotParked = Integer.parseInt(cols[c++]);\r\n        int blue_teleGlyphsScored = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedRows = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedColumns = Integer.parseInt(cols[c++]);\r\n        int blue_teleCompletedCyphers = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone1 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone2 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsInZone3 = Integer.parseInt(cols[c++]);\r\n        int blue_endgRelicsUpright = Integer.parseInt(cols[c++]);\r\n        int blue_endgRobotsBalanced = Integer.parseInt(cols[c++]);\r\n        int blue_minorPenalties = Integer.parseInt(cols[c++]);\r\n        int blue_majorPenalties = Integer.parseInt(cols[c++]);\r\n        int blue_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);\r\n        int blue_majorPenalitesAwarded = Integer.parseInt(cols[c++]);\r\n        \r\n        \r\n        int red_autoBonus = 0;\r\n        int red_auto = 30 * red_autoJewlesRemaining + 15 * red_autoGlyphsInCryptobox +\r\n                30 * red_autoCryptoboxKeys + 10 * red_autoRobotParked;\r\n        int red_endGame = 10 * red_endgRelicsInZone1 + 20 * red_endgRelicsInZone2 +\r\n                40 * red_endgRelicsInZone3 + 15 * red_endgRelicsUpright +\r\n                20 * red_endgRobotsBalanced;\r\n        int red_teleop = 2 * red_teleGlyphsScored + 10 * red_teleCompletedRows +\r\n                20 * red_teleCompletedColumns + 30 * red_teleCompletedCyphers;\r\n        int blue_penalties = 10 * red_minorPenalties + 40 * red_majorPenalties;\r\n        \r\n        \r\n        int blue_autoBonus = 0;\r\n        int blue_auto = 30 * blue_autoJewlesRemaining + 15 * blue_autoGlyphsInCryptobox +\r\n                30 * blue_autoCryptoboxKeys + 10 * blue_autoRobotParked;\r\n        int blue_endGame = 10 * blue_endgRelicsInZone1 + 20 * blue_endgRelicsInZone2 +\r\n                40 * blue_endgRelicsInZone3 + 15 * blue_endgRelicsUpright +\r\n                20 * blue_endgRobotsBalanced;\r\n        int blue_teleop = 2 * blue_teleGlyphsScored + 10 * blue_teleCompletedRows +\r\n                20 * blue_teleCompletedColumns + 30 * blue_teleCompletedCyphers;\r\n        int red_penalties = 10 * blue_minorPenalties + 40 * blue_majorPenalties;\r\n        \r\n        JSONObject match = new JSONObject();\r\n        JSONObject red = new JSONObject();\r\n        JSONObject blue = new JSONObject();\r\n        \r\n        JSONArray red_teams = new JSONArray();\r\n        int j;\r\n        for(j=0;j<3;j++) {\r\n            JSONObject t = new JSONObject();\r\n            if(red_team[j] != 0) { \r\n                t.put(\"number\", red_team[j]);\r\n                t.put(\"surrogate\", red_surrogate[j]);\r\n                red_teams.add(t);\r\n            }\r\n        }\r\n        red.put(\"teams\", red_teams);\r\n        \r\n        \r\n        JSONArray blue_teams = new JSONArray();\r\n        for(j=0;j<3;j++) {\r\n            JSONObject t = new JSONObject();\r\n            if(blue_team[j] != 0) { \r\n                t.put(\"number\", blue_team[j]);\r\n                t.put(\"surrogate\", blue_surrogate[j]);\r\n                blue_teams.add(t);\r\n            }\r\n        }\r\n        blue.put(\"teams\", blue_teams);\r\n\r\n        \r\n        \r\n        \r\n        \r\n        if(saved) {\r\n            red.put(\"auto_bonus\", red_autoBonus);\r\n            red.put(\"auto\", red_auto);\r\n            red.put(\"teleop\", red_teleop);\r\n            red.put(\"endg\", red_endGame);\r\n            red.put(\"penalties\", red_penalties);\r\n            \r\n            blue.put(\"auto_bonus\", blue_autoBonus);\r\n            blue.put(\"auto\", blue_auto);\r\n            blue.put(\"teleop\", blue_teleop);\r\n            blue.put(\"endg\", blue_endGame);\r\n            blue.put(\"penalties\", blue_penalties);\r\n        }\r\n        \r\n        match.put(\"start\", matchStartTime);\r\n        \r\n        match.put(\"number\", number);\r\n        match.put(\"division\", division);\r\n        match.put(\"type\", matchType.toString());\r\n        match.put(\"red\", red);\r\n        match.put(\"blue\", blue);\r\n        \r\n        if(i < matchArray.size())\r\n            matchArray.set(i, match);\r\n        else\r\n            matchArray.add(i, match);\r\n        App.app.log(\"Parsed Match\", match.toJSONString());\r\n    }\r\n\r\n    @Override\r\n    public void onFileCreate() {\r\n        parseFile();\r\n    }\r\n\r\n    @Override\r\n    public void onFileDelete() {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void onFileModify() {\r\n        parseFile();\r\n    }\r\n    \r\n    @Override\r\n    public File getFile() {\r\n        return file;\r\n    }\r\n"]], "pred": {"ppl": 1.7777281999588013, "ppl_lower": 1.9188308715820312, "ppl/lowercase_ppl": -1.1327568384596864, "ppl/zlib": 0.00030505633986825203, "Min_5.0% Prob": 6.356194463430667, "Min_10.0% Prob": 4.576650412643657, "Min_20.0% Prob": 2.773977131528013, "Min_30.0% Prob": 1.9055585873136722, "Min_40.0% Prob": 1.4349703125355078, "Min_50.0% Prob": 1.1507400628252213, "Min_60.0% Prob": 0.959902102511291}}
{"hexsha": "8d5d2aa1c5437270ff72fac18474b7e3bc416c04", "ext": "java", "lang": "Java", "content": "public class LevelChangesScriptEvent extends ScriptEvent {\r\n\r\n    // <--[event]\r\n    // @Since 0.3.0\r\n    // @Events\r\n    // level changes\r\n    //\r\n    // @Updated 2017/10/16\r\n    //\r\n    // @Cancellable true\r\n    //\r\n    // @Group Player\r\n    //\r\n    // @Triggers when a player's level changes.\r\n    //\r\n    // @Warning This event does not trigger in Sponge during last testing.\r\n    //\r\n    // @Switch world (WorldTag) checks the world.\r\n    // @Switch cuboid (CuboidTag) checks the cuboid area.\r\n    // @Switch weather (TextTag) checks the weather.\r\n    //\r\n    // @Context\r\n    // player (PlayerTag) returns the player that changed level.\r\n    // old_level (IntegerTag) returns the old level value.\r\n    // new_level (IntegerTag) returns the new level value.\r\n    //\r\n    // @Determinations\r\n    // level (IntegerTag) sets the new level value.\r\n    // -->\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"LevelChanges\";\r\n    }\r\n\r\n    @Override\r\n    public boolean couldMatch(ScriptEventData data) {\r\n        return data.eventPath.startsWith(\"level changes\");\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(ScriptEventData data) {\r\n        return D2SpongeEventHelper.checkWorld(player.getOnline(this::error).getLocation().getExtent(), data, this::error)\r\n                && D2SpongeEventHelper.checkCuboid((new LocationTag(player.getOnline(this::error)\r\n                .getLocation())).getInternal(), data, this::error)\r\n                && D2SpongeEventHelper.checkWeather(Utilities.getIdWithoutDefaultPrefix(\r\n                player.getOnline(this::error).getLocation().getExtent().getWeather().getId()), data, this::error);\r\n    }\r\n\r\n    public PlayerTag player;\r\n\r\n    public IntegerTag old_level;\r\n\r\n    public IntegerTag new_level;\r\n\r\n    public ChangeLevelEvent.TargetPlayer internal;\r\n\r\n    @Override\r\n    public HashMap<String, AbstractTagObject> getDefinitions(ScriptEventData data) {\r\n        HashMap<String, AbstractTagObject> defs = super.getDefinitions(data);\r\n        defs.put(\"player\", player);\r\n        defs.put(\"old_level\", old_level);\r\n        defs.put(\"new_level\", new_level);\r\n        return defs;\r\n    }\r\n\r\n    @Override\r\n    public void enable() {\r\n        Sponge.getEventManager().registerListeners(Denizen2Sponge.instance, this);\r\n    }\r\n\r\n    @Override\r\n    public void disable() {\r\n        Sponge.getEventManager().unregisterListeners(this);\r\n    }\r\n\r\n    @Listener\r\n    public void onLevelChanges(ChangeLevelEvent.TargetPlayer evt, @Root Player player) {\r\n        LevelChangesScriptEvent event = (LevelChangesScriptEvent) clone();\r\n        event.internal = evt;\r\n        event.player = new PlayerTag(player);\r\n        event.old_level = new IntegerTag(evt.getOriginalLevel());\r\n        event.new_level = new IntegerTag(evt.getLevel());\r\n        event.cancelled = evt.isCancelled();\r\n        event.run();\r\n        evt.setCancelled(event.cancelled);\r\n    }\r\n\r\n    @Override\r\n    public void applyDetermination(boolean errors, String determination, AbstractTagObject value) {\r\n        if (determination.equals(\"level\")) {\r\n            IntegerTag it = IntegerTag.getFor(this::error, value);\r\n            new_level = it;\r\n            internal.setLevel((int) it.getInternal());\r\n        }\r\n        else {\r\n            super.applyDetermination(errors, determination, value);\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "DenizenScript/Denizen2Sponge", "file": "src/main/java/com/denizenscript/denizen2sponge/events/player/LevelChangesScriptEvent.java", "last_update_at": "2018-02-25T06:10:33+00:00", "question_id": "8d5d2aa1c5437270ff72fac18474b7e3bc416c04", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LevelChangesScriptEvent extends ScriptEvent {\r\n\r\n    // <--[event]\r\n    // @Since 0.3.0\r\n    // @Events\r\n    // level changes\r\n    //\r\n    // @Updated 2017/10/16\r\n    //\r\n    // @Cancellable true\r\n    //\r\n    // @Group Player\r\n    //\r\n    // @Triggers when a player's level changes.\r\n    //\r\n    // @Warning This event does not trigger in Sponge during last testing.\r\n    //\r\n    // @Switch world (WorldTag) checks the world.\r\n    // @Switch cuboid (CuboidTag) checks the cuboid area.\r\n    // @Switch weather (TextTag) checks the weather.\r\n    //\r\n    // @Context\r\n    // player (PlayerTag) returns the player that changed level.\r\n    // old_level (IntegerTag) returns the old level value.\r\n    // new_level (IntegerTag) returns the new level value.\r\n    //\r\n    // @Determinations\r\n    // level (IntegerTag) sets the new level value.\r\n    // -->\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"LevelChanges\";\r\n    }\r\n\r\n    @Override\r\n    public boolean couldMatch(ScriptEventData data) {\r\n        return data.eventPath.startsWith(\"level changes\");\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(ScriptEventData data) {\r\n        return D2SpongeEventHelper.checkWorld(player.getOnline(this::error).getLocation().getExtent(), data, this::error)\r\n                && D2SpongeEventHelper.checkCuboid((new LocationTag(player.getOnline(this::error)\r\n                .getLocation())).getInternal(), data, this::error)\r\n                && D2SpongeEventHelper.checkWeather(Utilities.getIdWithoutDefaultPrefix(\r\n                player.getOnline(this::error).getLocation().getExtent().getWeather().getId()), data, this::error);\r\n    }\r\n\r\n    public PlayerTag player;\r\n\r\n    public IntegerTag old_level;\r\n\r\n    public IntegerTag new_level;\r\n\r\n    public ChangeLevelEvent.TargetPlayer internal;\r\n\r\n    @Override\r\n    public HashMap<String, AbstractTagObject> getDefinitions(ScriptEventData data) {\r\n        HashMap<String, AbstractTagObject> defs = super.getDefinitions(data);\r\n        defs.put(\"player\", player);\r\n        defs.put(\"old_level\", old_level);\r\n        defs.put(\"new_level\", new_level);\r\n        return defs;\r\n    }\r\n\r\n    @Override\r\n    public void enable() {\r\n        Sponge.getEventManager().registerListeners(Denizen2Sponge.instance, this);\r\n    }\r\n\r\n    @Override\r\n    public void disable() {\r\n        Sponge.getEventManager().unregisterListeners(this);\r\n    }\r\n\r\n    @Listener\r\n    public void onLevelChanges(ChangeLevelEvent.TargetPlayer evt, @Root Player player) {\r\n        LevelChangesScriptEvent event = (LevelChangesScriptEvent) clone();\r\n        event.internal = evt;\r\n        event.player = new PlayerTag(player);\r\n        event.old_level = new IntegerTag(evt.getOriginalLevel());\r\n        event.new_level = new IntegerTag(evt.getLevel());\r\n        event.cancelled = evt.isCancelled();\r\n        event.run();\r\n        evt.setCancelled(event.cancelled);\r\n    }\r\n\r\n    @Override\r\n    public void applyDetermination(boolean errors, String determination, AbstractTagObject value) {\r\n        if (determination.equals(\"level\")) {\r\n            IntegerTag it = IntegerTag.getFor(this::error, value);\r\n            new_level = it;\r\n            internal.setLevel((int) it.getInternal());\r\n        }\r\n        else {\r\n            super.applyDetermination(errors, determination, value);\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 1.4122921228408813, "ppl_lower": 1.9514353275299072, "ppl/lowercase_ppl": -1.9366687340630593, "ppl/zlib": 0.00033581128748810113, "Min_5.0% Prob": 4.894299924373627, "Min_10.0% Prob": 3.0874170562655654, "Min_20.0% Prob": 1.6920207843184472, "Min_30.0% Prob": 1.1480142230882424, "Min_40.0% Prob": 0.8628909758220499, "Min_50.0% Prob": 0.6902289566143557, "Min_60.0% Prob": 0.575904902264836}}
{"hexsha": "3dd4af0cd04698dd15fea21bad6838cd7919ec9c", "ext": "java", "lang": "Java", "content": "public final class XACMLUtils {\n\n  /** XACML rule for combining policies */\n  public static final String RULE_COMBINING_ALG = \"urn:oasis:names:tc:xacml:1.0:rule-combining-algorithm:permit-overrides\";\n  /** XACML urn for actions */\n  public static final String ACTION_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:action:action-id\";\n  /** XACML urn for resources */\n  public static final String RESOURCE_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:resource:resource-id\";\n  /** XACML urn for subject */\n  public static final String SUBJECT_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:subject:subject-id\";\n  /** XACML urn for roles */\n  public static final String SUBJECT_ROLE_IDENTIFIER = \"urn:oasis:names:tc:xacml:2.0:subject:role\";\n  /** XACML urn for string equality */\n  public static final String XACML_STRING_EQUAL = \"urn:oasis:names:tc:xacml:1.0:function:string-equal\";\n  /** XACML urn for string equality */\n  public static final String XACML_STRING_IS_IN = \"urn:oasis:names:tc:xacml:1.0:function:string-is-in\";\n  /** W3C String data type */\n  public static final String W3C_STRING = \"http://www.w3.org/2001/XMLSchema#string\";\n  /** The policy assertion issuer */\n  public static final String ISSUER = \"matterhorn\";\n  /** The JAXB Context to use for marshaling XACML security policy documents */\n  protected static JAXBContext jBossXacmlJaxbContext;\n  /** The logging facility */\n  private static final Logger logger = LoggerFactory.getLogger(XACMLUtils.class);\n\n  /** Static initializer for the single JAXB context */\n  static {\n    try {\n      XACMLUtils.jBossXacmlJaxbContext = JAXBContext.newInstance(\"org.jboss.security.xacml.core.model.policy\",\n              PolicyType.class.getClassLoader());\n    } catch (JAXBException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Private constructor to disable clients from instantiating this class.\n   */\n  private XACMLUtils() {\n  }\n\n  /**\n   * Parses a XACML into an {@link AccessControlList}.\n   * <p>\n   * Only rules which follow the structure of those created by {@link #getXacml(MediaPackage, AccessControlList)} may be\n   * successfully parsed. All other rules are ignored.\n   * \n   * @param xacml\n   *          the XACML to parse\n   * @return the ACL, never {@code null}\n   * @throws XACMLParsingException\n   *           if parsing fails\n   */\n  public static AccessControlList parseXacml(InputStream xacml) throws XACMLParsingException {\n\n    try {\n      @SuppressWarnings(\"unchecked\")\n      final AccessControlList acl = new AccessControlList();\n      final List<AccessControlEntry> entries = acl.getEntries();\n      final PolicyType policy = ((JAXBElement<PolicyType>) XACMLUtils.jBossXacmlJaxbContext.createUnmarshaller().unmarshal(XmlSafeParser.parse(xacml))).getValue();\n      for (Object object : policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition()) {\n\n        if (!(object instanceof RuleType)) {\n          throw new XACMLParsingException(\"Object \" + object + \" of policy \" + policy + \" is not of type RuleType\");\n        }\n        RuleType rule = (RuleType) object;\n        if (rule.getTarget() == null) {\n          if (rule.getRuleId().equals(\"DenyRule\")) {\n            logger.trace(\"Skipping global deny rule\");\n            continue;\n          }\n          throw new XACMLParsingException(\"Empty rule \" + rule + \" in policy \" + policy);\n        }\n\n        String role = null;\n        String actionForAce = null;\n        try {\n          ActionType action = rule.getTarget().getActions().getAction().get(0);\n          actionForAce = (String) action.getActionMatch().get(0).getAttributeValue().getContent().get(0);\n\n          @SuppressWarnings(\"unchecked\") JAXBElement<ApplyType> apply = (JAXBElement<ApplyType>) rule.getCondition().getExpression();\n          for (JAXBElement<?> element : apply.getValue().getExpression()) {\n            if (element.getValue() instanceof AttributeValueType) {\n              role = (String) ((AttributeValueType) element.getValue()).getContent().get(0);\n              break;\n            }\n          }\n        } catch (Exception e) {\n          throw new XACMLParsingException(\"Rule \" + rule + \" of policy \" + policy + \" could not be parsed\", e);\n        }\n        if (role == null) {\n          throw new XACMLParsingException(\"Unable to find role in rule \" + rule + \" of policy \" + policy);\n        }\n        AccessControlEntry ace = new AccessControlEntry(role, actionForAce, rule.getEffect().equals(EffectType.PERMIT));\n        entries.add(ace);\n      }\n      return acl;\n    } catch (Exception e) {\n      if (e instanceof XACMLParsingException) {\n        throw (XACMLParsingException) e;\n      }\n      throw new XACMLParsingException(\"XACML could not be parsed\", e);\n    }\n  }\n\n  /**\n   * Builds an xml string containing the xacml for the mediapackage.\n   *\n   * @param mediapackage\n   *          the mediapackage\n   * @param accessControlList\n   *          the tuples of roles to actions\n   * @return\n   * @throws JAXBException\n   */\n  public static String getXacml(MediaPackage mediapackage, AccessControlList accessControlList) throws JAXBException {\n    ObjectFactory jbossXacmlObjectFactory = new ObjectFactory();\n    PolicyType policy = new PolicyType();\n    policy.setPolicyId(mediapackage.getIdentifier().toString());\n    policy.setVersion(\"2.0\");\n    policy.setRuleCombiningAlgId(XACMLUtils.RULE_COMBINING_ALG);\n\n    // TODO: Add target/resources to rule\n    TargetType policyTarget = new TargetType();\n    ResourcesType resources = new ResourcesType();\n    ResourceType resource = new ResourceType();\n    ResourceMatchType resourceMatch = new ResourceMatchType();\n    resourceMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);\n    AttributeValueType resourceAttributeValue = new AttributeValueType();\n    resourceAttributeValue.setDataType(XACMLUtils.W3C_STRING);\n    resourceAttributeValue.getContent().add(mediapackage.getIdentifier().toString());\n    AttributeDesignatorType resourceDesignator = new AttributeDesignatorType();\n    resourceDesignator.setAttributeId(XACMLUtils.RESOURCE_IDENTIFIER);\n    resourceDesignator.setDataType(XACMLUtils.W3C_STRING);\n\n    // now go back up the tree\n    resourceMatch.setResourceAttributeDesignator(resourceDesignator);\n    resourceMatch.setAttributeValue(resourceAttributeValue);\n    resource.getResourceMatch().add(resourceMatch);\n    resources.getResource().add(resource);\n    policyTarget.setResources(resources);\n    policy.setTarget(policyTarget);\n\n    // Loop over roleActions and add a rule for each\n    for (AccessControlEntry ace : accessControlList.getEntries()) {\n      boolean allow = ace.isAllow();\n\n      RuleType rule = new RuleType();\n      rule.setRuleId(ace.getRole() + \"_\" + ace.getAction() + (allow ? \"_Permit\" : \"_Deny\"));\n      if (allow) {\n        rule.setEffect(EffectType.PERMIT);\n      } else {\n        rule.setEffect(EffectType.DENY);\n      }\n\n      TargetType target = new TargetType();\n      ActionsType actions = new ActionsType();\n      ActionType action = new ActionType();\n      ActionMatchType actionMatch = new ActionMatchType();\n      actionMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);\n      AttributeValueType attributeValue = new AttributeValueType();\n      attributeValue.setDataType(XACMLUtils.W3C_STRING);\n      attributeValue.getContent().add(ace.getAction());\n      AttributeDesignatorType designator = new AttributeDesignatorType();\n      designator.setAttributeId(XACMLUtils.ACTION_IDENTIFIER);\n      designator.setDataType(XACMLUtils.W3C_STRING);\n\n      // now go back up the tree\n      actionMatch.setActionAttributeDesignator(designator);\n      actionMatch.setAttributeValue(attributeValue);\n      action.getActionMatch().add(actionMatch);\n      actions.getAction().add(action);\n      target.setActions(actions);\n      rule.setTarget(target);\n\n      ConditionType condition = new ConditionType();\n      ApplyType apply = new ApplyType();\n      apply.setFunctionId(XACMLUtils.XACML_STRING_IS_IN);\n\n      AttributeValueType conditionAttributeValue = new AttributeValueType();\n      conditionAttributeValue.setDataType(XACMLUtils.W3C_STRING);\n      conditionAttributeValue.getContent().add(ace.getRole());\n\n      SubjectAttributeDesignatorType subjectDesignator = new SubjectAttributeDesignatorType();\n      subjectDesignator.setDataType(XACMLUtils.W3C_STRING);\n      subjectDesignator.setAttributeId(XACMLUtils.SUBJECT_ROLE_IDENTIFIER);\n      apply.getExpression().add(jbossXacmlObjectFactory.createAttributeValue(conditionAttributeValue));\n      apply.getExpression().add(jbossXacmlObjectFactory.createSubjectAttributeDesignator(subjectDesignator));\n\n      condition.setExpression(jbossXacmlObjectFactory.createApply(apply));\n      rule.setCondition(condition);\n      policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(rule);\n    }\n\n    // Add the global deny rule\n    RuleType deny = new RuleType();\n    deny.setEffect(EffectType.DENY);\n    deny.setRuleId(\"DenyRule\");\n    policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(deny);\n\n    // serialize to xml\n    StringWriter writer = new StringWriter();\n    XACMLUtils.jBossXacmlJaxbContext.createMarshaller().marshal(jbossXacmlObjectFactory.createPolicy(policy), writer);\n    return writer.getBuffer().toString();\n  }\n\n}", "class_id": 0, "repo": "MaximilianKorn/opencast", "file": "modules/authorization-xacml/src/main/java/org/opencastproject/authorization/xacml/XACMLUtils.java", "last_update_at": "2018-06-18T20:53:20+00:00", "question_id": "3dd4af0cd04698dd15fea21bad6838cd7919ec9c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class XACMLUtils {\n  /** XACML rule for combining policies */\n  public static final String RULE_COMBINING_ALG = \"urn:oasis:names:tc:xacml:1.0:rule-combining-algorithm:permit-overrides\";\n  /** XACML urn for actions */\n  public static final String ACTION_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:action:action-id\";\n  /** XACML urn for resources */\n  public static final String RESOURCE_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:resource:resource-id\";\n  /** XACML urn for subject */\n  public static final String SUBJECT_IDENTIFIER = \"urn:oasis:names:tc:xacml:1.0:subject:subject-id\";\n  /** XACML urn for roles */\n  public static final String SUBJECT_ROLE_IDENTIFIER = \"urn:oasis:names:tc:xacml:2.0:subject:role\";\n  /** XACML urn for string equality */\n  public static final String XACML_STRING_EQUAL = \"urn:oasis:names:tc:xacml:1.0:function:string-equal\";\n  /** XACML urn for string equality */\n  public static final String XACML_STRING_IS_IN = \"urn:oasis:names:tc:xacml:1.0:function:string-is-in\";\n  /** W3C String data type */\n  public static final String W3C_STRING = \"http://www.w3.org/2001/XMLSchema#string\";\n  /** The policy assertion issuer */\n  public static final String ISSUER = \"matterhorn\";\n  /** The JAXB Context to use for marshaling XACML security policy documents */\n  protected static JAXBContext jBossXacmlJaxbContext;\n  /** The logging facility */\n  private static final Logger logger = LoggerFactory.getLogger(XACMLUtils.class);\n  /** Static initializer for the single JAXB context */\n  static {\n    try {\n      XACMLUtils.jBossXacmlJaxbContext = JAXBContext.newInstance(\"org.jboss.security.xacml.core.model.policy\",\n              PolicyType.class.getClassLoader());\n    } catch (JAXBException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Private constructor to disable clients from instantiating this class.\n   */\n  private XACMLUtils() {\n  }\n  /**\n   * Parses a XACML into an {@link AccessControlList}.\n   * <p>\n   * Only rules which follow the structure of those created by {@link #getXacml(MediaPackage, AccessControlList)} may be\n   * successfully parsed. All other rules are ignored.\n   * \n   * @param xacml\n   *          the XACML to parse\n   * @return the ACL, never {@code null}\n   * @throws XACMLParsingException\n   *           if parsing fails\n   */\n  public static AccessControlList parseXacml(InputStream xacml) throws XACMLParsingException {\n    try {\n      @SuppressWarnings(\"unchecked\")\n      final AccessControlList acl = new AccessControlList();\n      final List<AccessControlEntry> entries = acl.getEntries();\n      final PolicyType policy = ((JAXBElement<PolicyType>) XACMLUtils.jBossXacmlJaxbContext.createUnmarshaller().unmarshal(XmlSafeParser.parse(xacml))).getValue();\n      for (Object object : policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition()) {\n        if (!(object instanceof RuleType)) {\n          throw new XACMLParsingException(\"Object \" + object + \" of policy \" + policy + \" is not of type RuleType\");\n        }\n        RuleType rule = (RuleType) object;\n        if (rule.getTarget() == null) {\n          if (rule.getRuleId().equals(\"DenyRule\")) {\n            logger.trace(\"Skipping global deny rule\");\n            continue;\n          }\n          throw new XACMLParsingException(\"Empty rule \" + rule + \" in policy \" + policy);\n        }\n        String role = null;\n        String actionForAce = null;\n        try {\n          ActionType action = rule.getTarget().getActions().getAction().get(0);\n          actionForAce = (String) action.getActionMatch().get(0).getAttributeValue().getContent().get(0);\n          @SuppressWarnings(\"unchecked\") JAXBElement<ApplyType> apply = (JAXBElement<ApplyType>) rule.getCondition().getExpression();\n          for (JAXBElement<?> element : apply.getValue().getExpression()) {\n            if (element.getValue() instanceof AttributeValueType) {\n              role = (String) ((AttributeValueType) element.getValue()).getContent().get(0);\n              break;\n            }\n          }\n        } catch (Exception e) {\n          throw new XACMLParsingException(\"Rule \" + rule + \" of policy \" + policy + \" could not be parsed\", e);\n        }\n        if (role == null) {\n          throw new XACMLParsingException(\"Unable to find role in rule \" + rule + \" of policy \" + policy);\n        }\n        AccessControlEntry ace = new AccessControlEntry(role, actionForAce, rule.getEffect().equals(EffectType.PERMIT));\n        entries.add(ace);\n      }\n      return acl;\n    } catch (Exception e) {\n      if (e instanceof XACMLParsingException) {\n        throw (XACMLParsingException) e;\n      }\n      throw new XACMLParsingException(\"XACML could not be parsed\", e);\n    }\n  }\n  /**\n   * Builds an xml string containing the xacml for the mediapackage.\n   *\n   * @param mediapackage\n   *          the mediapackage\n   * @param accessControlList\n   *          the tuples of roles to actions\n   * @return\n   * @throws JAXBException\n   */\n  public static String getXacml(MediaPackage mediapackage, AccessControlList accessControlList) throws JAXBException {\n    ObjectFactory jbossXacmlObjectFactory = new ObjectFactory();\n    PolicyType policy = new PolicyType();\n    policy.setPolicyId(mediapackage.getIdentifier().toString());\n    policy.setVersion(\"2.0\");\n    policy.setRuleCombiningAlgId(XACMLUtils.RULE_COMBINING_ALG);\n    // TODO: Add target/resources to rule\n    TargetType policyTarget = new TargetType();\n    ResourcesType resources = new ResourcesType();\n    ResourceType resource = new ResourceType();\n    ResourceMatchType resourceMatch = new ResourceMatchType();\n    resourceMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);\n    AttributeValueType resourceAttributeValue = new AttributeValueType();\n    resourceAttributeValue.setDataType(XACMLUtils.W3C_STRING);\n    resourceAttributeValue.getContent().add(mediapackage.getIdentifier().toString());\n    AttributeDesignatorType resourceDesignator = new AttributeDesignatorType();\n    resourceDesignator.setAttributeId(XACMLUtils.RESOURCE_IDENTIFIER);\n    resourceDesignator.setDataType(XACMLUtils.W3C_STRING);\n    // now go back up the tree\n    resourceMatch.setResourceAttributeDesignator(resourceDesignator);\n    resourceMatch.setAttributeValue(resourceAttributeValue);\n    resource.getResourceMatch().add(resourceMatch);\n    resources.getResource().add(resource);\n    policyTarget.setResources(resources);\n    policy.setTarget(policyTarget);\n    // Loop over roleActions and add a rule for each\n    for (AccessControlEntry ace : accessControlList.getEntries()) {\n      boolean allow = ace.isAllow();\n      RuleType rule = new RuleType();\n      rule.setRuleId(ace.getRole() + \"_\" + ace.getAction() + (allow ? \"_Permit\" : \"_Deny\"));\n      if (allow) {\n        rule.setEffect(EffectType.PERMIT);\n      } else {\n        rule.setEffect(EffectType.DENY);\n      }\n      TargetType target = new TargetType();\n      ActionsType actions = new ActionsType();\n      ActionType action = new ActionType();\n      ActionMatchType actionMatch = new ActionMatchType();\n      actionMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);\n      AttributeValueType attributeValue = new AttributeValueType();\n      attributeValue.setDataType(XACMLUtils.W3C_STRING);\n      attributeValue.getContent().add(ace.getAction());\n      AttributeDesignatorType designator = new AttributeDesignatorType();\n      designator.setAttributeId(XACMLUtils.ACTION_IDENTIFIER);\n      designator.setDataType(XACMLUtils.W3C_STRING);\n      // now go back up the tree\n      actionMatch.setActionAttributeDesignator(designator);\n      actionMatch.setAttributeValue(attributeValue);\n      action.getActionMatch().add(actionMatch);\n      actions.getAction().add(action);\n      target.setActions(actions);\n      rule.setTarget(target);\n      ConditionType condition = new ConditionType();\n      ApplyType apply = new ApplyType();\n      apply.setFunctionId(XACMLUtils.XACML_STRING_IS_IN);\n      AttributeValueType conditionAttributeValue = new AttributeValueType();\n      conditionAttributeValue.setDataType(XACMLUtils.W3C_STRING);\n      conditionAttributeValue.getContent().add(ace.getRole());\n      SubjectAttributeDesignatorType subjectDesignator = new SubjectAttributeDesignatorType();\n      subjectDesignator.setDataType(XACMLUtils.W3C_STRING);\n      subjectDesignator.setAttributeId(XACMLUtils.SUBJECT_ROLE_IDENTIFIER);\n      apply.getExpression().add(jbossXacmlObjectFactory.createAttributeValue(conditionAttributeValue));\n      apply.getExpression().add(jbossXacmlObjectFactory.createSubjectAttributeDesignator(subjectDesignator));\n      condition.setExpression(jbossXacmlObjectFactory.createApply(apply));\n      rule.setCondition(condition);\n      policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(rule);\n    }\n    // Add the global deny rule\n    RuleType deny = new RuleType();\n    deny.setEffect(EffectType.DENY);\n    deny.setRuleId(\"DenyRule\");\n    policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(deny);\n    // serialize to xml\n    StringWriter writer = new StringWriter();\n    XACMLUtils.jBossXacmlJaxbContext.createMarshaller().marshal(jbossXacmlObjectFactory.createPolicy(policy), writer);\n    return writer.getBuffer().toString();\n  }\n"]], "pred": {"ppl": 1.8469295501708984, "ppl_lower": 2.0973074436187744, "ppl/lowercase_ppl": -1.2072122347977565, "ppl/zlib": 0.00024317263481874176, "Min_5.0% Prob": 6.296965879552505, "Min_10.0% Prob": 4.591212361466651, "Min_20.0% Prob": 2.8660851004076937, "Min_30.0% Prob": 2.0177658112123122, "Min_40.0% Prob": 1.5282842136719117, "Min_50.0% Prob": 1.2268195957849404, "Min_60.0% Prob": 1.0235210146555953}}
{"hexsha": "13d87cfac99c3a1ad318aa7f974abb2c4f7c17d2", "ext": "java", "lang": "Java", "content": "public class LoginActionTest {\n    @Test\n    public void it_allows_users_to_input_their_credentials()\n    {\n        action.inputLoginCredentials();\n\n        verify(responder).respondToInputLoginCredentials();\n    }\n\n    @Test\n    public void it_provides_feedback_when_the_credentials_are_invalid()\n    {\n        action.attemptLogin(null, null);\n\n        verify(responder).respondToInvalidLoginInput(input);\n        assertThat(input.messages().size(), is(greaterThan(0)));\n    }\n\n    @Test\n    public void it_provides_feedback_when_the_authentication_fails()\n    {\n        when(users.identifiedBy(\"luis\")).thenReturn(null);\n\n        action.attemptLogin(\"not_luis\", \"password does not really matter\");\n\n        verify(responder).respondToInvalidLoginAttemptWith(any(Credentials.class));\n    }\n\n    @Test\n    public void it_provides_feedback_if_authentication_succeeds()\n    {\n        Password password = Password.fromPlainText(\"password!\");\n        User registeredUser = User.registeredWith(1, \"luis\", password.toString());\n        when(users.identifiedBy(\"luis\")).thenReturn(registeredUser);\n\n        action.attemptLogin(\"luis\", \"password!\");\n\n        verify(responder).respondToASuccessfulAuthenticationOf(registeredUser);\n    }\n\n    @Before\n    public void configureAction() {\n        responder = mock(LoginResponder.class);\n        input = new LoginInput();\n        users = mock(Users.class);\n        action = new LoginAction(responder, input, new AuthenticateUser(users));\n    }\n\n    private LoginAction action;\n    private LoginResponder responder;\n    private LoginInput input;\n    private Users users;\n}", "class_id": 0, "repo": "zgulde/movies", "file": "src/test/java/com/codeup/auth/application/authentication/LoginActionTest.java", "last_update_at": "2018-02-20T22:06:37+00:00", "question_id": "13d87cfac99c3a1ad318aa7f974abb2c4f7c17d2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoginActionTest {\n    @Test\n    public void it_allows_users_to_input_their_credentials()\n    {\n        action.inputLoginCredentials();\n        verify(responder).respondToInputLoginCredentials();\n    }\n    @Test\n    public void it_provides_feedback_when_the_credentials_are_invalid()\n    {\n        action.attemptLogin(null, null);\n        verify(responder).respondToInvalidLoginInput(input);\n        assertThat(input.messages().size(), is(greaterThan(0)));\n    }\n    @Test\n    public void it_provides_feedback_when_the_authentication_fails()\n    {\n        when(users.identifiedBy(\"luis\")).thenReturn(null);\n        action.attemptLogin(\"not_luis\", \"password does not really matter\");\n        verify(responder).respondToInvalidLoginAttemptWith(any(Credentials.class));\n    }\n    @Test\n    public void it_provides_feedback_if_authentication_succeeds()\n    {\n        Password password = Password.fromPlainText(\"password!\");\n        User registeredUser = User.registeredWith(1, \"luis\", password.toString());\n        when(users.identifiedBy(\"luis\")).thenReturn(registeredUser);\n        action.attemptLogin(\"luis\", \"password!\");\n        verify(responder).respondToASuccessfulAuthenticationOf(registeredUser);\n    }\n    @Before\n    public void configureAction() {\n        responder = mock(LoginResponder.class);\n        input = new LoginInput();\n        users = mock(Users.class);\n        action = new LoginAction(responder, input, new AuthenticateUser(users));\n    }\n    private LoginAction action;\n    private LoginResponder responder;\n    private LoginInput input;\n    private Users users;\n"]], "pred": {"ppl": 2.321986436843872, "ppl_lower": 2.5198004245758057, "ppl/lowercase_ppl": -1.0970494105665538, "ppl/zlib": 0.0015428993445167221, "Min_5.0% Prob": 7.425943022188933, "Min_10.0% Prob": 5.786959331968556, "Min_20.0% Prob": 3.753715888313625, "Min_30.0% Prob": 2.7232740843209666, "Min_40.0% Prob": 2.0878063815281442, "Min_50.0% Prob": 1.6799733326972828, "Min_60.0% Prob": 1.4027973458953742}}
{"hexsha": "14b3dffa562fe19a1449d51905880eab860b5039", "ext": "java", "lang": "Java", "content": "public class BittrexAdaptersTest {\n\n  @Test\n  public void testAdaptOrders() {\n    BittrexLevel ask1 = new BittrexLevel(new BigDecimal(\"10\"), new BigDecimal(\"1\"));\n    BittrexLevel ask2 = new BittrexLevel(new BigDecimal(\"11\"), new BigDecimal(\"2\"));\n    BittrexLevel ask3 = new BittrexLevel(new BigDecimal(\"12\"), new BigDecimal(\"3\"));\n\n    BittrexLevel bid1 = new BittrexLevel(new BigDecimal(\"9\"), new BigDecimal(\"4\"));\n    BittrexLevel bid2 = new BittrexLevel(new BigDecimal(\"8\"), new BigDecimal(\"5\"));\n    BittrexLevel bid3 = new BittrexLevel(new BigDecimal(\"7\"), new BigDecimal(\"6\"));\n\n    BittrexLevel[] asks = {ask1, ask2, ask3};\n    BittrexLevel[] bids = {bid1, bid2, bid3};\n    CurrencyPair currencyPair = CurrencyPair.ETH_BTC;\n    Order.OrderType askType = Order.OrderType.ASK;\n    Order.OrderType bidType = Order.OrderType.BID;\n    int depth = 2;\n\n    List<LimitOrder> expectedAsks =\n        Arrays.asList(\n            new LimitOrder(askType, ask1.getAmount(), currencyPair, null, null, ask1.getPrice()),\n            new LimitOrder(askType, ask2.getAmount(), currencyPair, null, null, ask2.getPrice()));\n\n    List<LimitOrder> expectedBids =\n        Arrays.asList(\n            new LimitOrder(bidType, bid1.getAmount(), currencyPair, null, null, bid1.getPrice()),\n            new LimitOrder(bidType, bid2.getAmount(), currencyPair, null, null, bid2.getPrice()));\n\n    List<LimitOrder> adaptedAsks = BittrexAdapters.adaptOrders(asks, currencyPair, askType, depth);\n    List<LimitOrder> adaptedBids = BittrexAdapters.adaptOrders(bids, currencyPair, bidType, depth);\n\n    Assert.assertEquals(expectedAsks, adaptedAsks);\n    Assert.assertEquals(expectedBids, adaptedBids);\n  }\n\n  @Test\n  public void testAdaptOrderStatus() {\n    BittrexOrder orderPartiallyFilled =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"5\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderFilled =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderNew =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"0\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderClosed =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"0\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            Date.from(Instant.now()),\n            null);\n    BittrexOrder orderUnknown =\n        new BittrexOrder(\n            null, null, null, null, null, null, null, null, null, null, null, null, null, null,\n            null, null, null);\n    Assert.assertEquals(\n        Order.OrderStatus.PARTIALLY_FILLED, BittrexAdapters.adaptOrderStatus(orderPartiallyFilled));\n    Assert.assertEquals(Order.OrderStatus.FILLED, BittrexAdapters.adaptOrderStatus(orderFilled));\n    Assert.assertEquals(Order.OrderStatus.NEW, BittrexAdapters.adaptOrderStatus(orderNew));\n    Assert.assertEquals(Order.OrderStatus.UNKNOWN, BittrexAdapters.adaptOrderStatus(orderUnknown));\n    Assert.assertEquals(Order.OrderStatus.CLOSED, BittrexAdapters.adaptOrderStatus(orderClosed));\n  }\n\n  @Test\n  public void testAdaptTrades() {\n    CurrencyPair pair = CurrencyPair.ETH_BTC;\n\n    BittrexTrade trade1 = new BittrexTrade();\n    trade1.setExecutedAt(new Date());\n    trade1.setId(\"123\");\n    trade1.setQuantity(new BigDecimal(\"1\"));\n    trade1.setRate(new BigDecimal(\"2\"));\n    trade1.setTakerSide(BittrexConstants.BUY);\n\n    BittrexTrade trade2 = new BittrexTrade();\n    trade2.setExecutedAt(new Date());\n    trade2.setId(\"456\");\n    trade2.setQuantity(new BigDecimal(\"3\"));\n    trade2.setRate(new BigDecimal(\"4\"));\n    trade2.setTakerSide(BittrexConstants.SELL);\n\n    Trade adaptedTrade1 = BittrexAdapters.adaptTrade(trade1, pair);\n    Trade adaptedTrade2 = BittrexAdapters.adaptTrade(trade2, pair);\n\n    List<BittrexTrade> bittrexTradesList = Arrays.asList(trade1, trade2);\n    List<Trade> tradesList = Arrays.asList(adaptedTrade1, adaptedTrade2);\n\n    Trades adaptedTrades = BittrexAdapters.adaptTrades(bittrexTradesList, pair);\n    Trades trades =\n        new Trades(\n            tradesList,\n            Math.max(Long.parseLong(trade1.getId()), Long.parseLong(trade2.getId())),\n            Trades.TradeSortType.SortByTimestamp);\n    Assert.assertEquals(trades.getNextPageCursor(), adaptedTrades.getNextPageCursor());\n    Assert.assertEquals(trades.getTrades(), adaptedTrades.getTrades());\n    Assert.assertEquals(trades.getTradeSortType(), adaptedTrades.getTradeSortType());\n  }\n\n  @Test\n  public void testAdaptUserTrades() {\n    CurrencyPair pair = CurrencyPair.ETH_BTC;\n\n    BittrexOrder order1 = new BittrexOrder();\n    order1.setType(BittrexConstants.LIMIT);\n    order1.setMarketSymbol(\"ETH-BTC\");\n    order1.setClosedAt(new Date());\n    order1.setId(\"123\");\n    order1.setQuantity(new BigDecimal(\"1\"));\n    order1.setFillQuantity(new BigDecimal(\"1\"));\n    order1.setLimit(new BigDecimal(\"2\"));\n    order1.setDirection(BittrexConstants.BUY);\n    order1.setCommission(new BigDecimal(\"2\"));\n\n    BittrexOrder order2 = new BittrexOrder();\n    order2.setType(BittrexConstants.MARKET);\n    order2.setMarketSymbol(\"ETH-BTC\");\n    order2.setClosedAt(new Date());\n    order2.setId(\"456\");\n    order2.setQuantity(new BigDecimal(\"3\"));\n    order2.setFillQuantity(new BigDecimal(\"1\"));\n    order2.setLimit(new BigDecimal(\"4\"));\n    order2.setDirection(BittrexConstants.SELL);\n    order2.setCommission(new BigDecimal(\"4\"));\n\n    List<UserTrade> tradesList = BittrexAdapters.adaptUserTrades(Arrays.asList(order1, order2));\n\n    Assert.assertEquals(2, tradesList.size());\n\n    UserTrade trade1 = tradesList.get(0);\n    Assert.assertEquals(Order.OrderType.BID, trade1.getType());\n    Assert.assertEquals(order1.getFillQuantity(), trade1.getOriginalAmount());\n    Assert.assertEquals(pair, trade1.getInstrument());\n    Assert.assertEquals(order1.getLimit(), trade1.getPrice());\n    Assert.assertEquals(order1.getClosedAt(), trade1.getTimestamp());\n    Assert.assertEquals(order1.getId(), trade1.getId());\n    Assert.assertEquals(order1.getCommission(), trade1.getFeeAmount());\n    Assert.assertEquals(pair.counter, trade1.getFeeCurrency());\n\n    UserTrade trade2 = tradesList.get(1);\n    Assert.assertEquals(Order.OrderType.ASK, trade2.getType());\n    Assert.assertEquals(order2.getFillQuantity(), trade2.getOriginalAmount());\n    Assert.assertEquals(pair, trade2.getInstrument());\n    Assert.assertEquals(order2.getLimit(), trade2.getPrice());\n    Assert.assertEquals(order2.getClosedAt(), trade2.getTimestamp());\n    Assert.assertEquals(order2.getId(), trade2.getId());\n    Assert.assertEquals(order2.getCommission(), trade2.getFeeAmount());\n    Assert.assertEquals(pair.counter, trade2.getFeeCurrency());\n  }\n}", "class_id": 0, "repo": "grmkris/XChange", "file": "xchange-bittrex/src/test/java/org/knowm/xchange/bittrex/BittrexAdaptersTest.java", "last_update_at": "2018-04-05T17:08:44+00:00", "question_id": "14b3dffa562fe19a1449d51905880eab860b5039", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BittrexAdaptersTest {\n  @Test\n  public void testAdaptOrders() {\n    BittrexLevel ask1 = new BittrexLevel(new BigDecimal(\"10\"), new BigDecimal(\"1\"));\n    BittrexLevel ask2 = new BittrexLevel(new BigDecimal(\"11\"), new BigDecimal(\"2\"));\n    BittrexLevel ask3 = new BittrexLevel(new BigDecimal(\"12\"), new BigDecimal(\"3\"));\n    BittrexLevel bid1 = new BittrexLevel(new BigDecimal(\"9\"), new BigDecimal(\"4\"));\n    BittrexLevel bid2 = new BittrexLevel(new BigDecimal(\"8\"), new BigDecimal(\"5\"));\n    BittrexLevel bid3 = new BittrexLevel(new BigDecimal(\"7\"), new BigDecimal(\"6\"));\n    BittrexLevel[] asks = {ask1, ask2, ask3};\n    BittrexLevel[] bids = {bid1, bid2, bid3};\n    CurrencyPair currencyPair = CurrencyPair.ETH_BTC;\n    Order.OrderType askType = Order.OrderType.ASK;\n    Order.OrderType bidType = Order.OrderType.BID;\n    int depth = 2;\n    List<LimitOrder> expectedAsks =\n        Arrays.asList(\n            new LimitOrder(askType, ask1.getAmount(), currencyPair, null, null, ask1.getPrice()),\n            new LimitOrder(askType, ask2.getAmount(), currencyPair, null, null, ask2.getPrice()));\n    List<LimitOrder> expectedBids =\n        Arrays.asList(\n            new LimitOrder(bidType, bid1.getAmount(), currencyPair, null, null, bid1.getPrice()),\n            new LimitOrder(bidType, bid2.getAmount(), currencyPair, null, null, bid2.getPrice()));\n    List<LimitOrder> adaptedAsks = BittrexAdapters.adaptOrders(asks, currencyPair, askType, depth);\n    List<LimitOrder> adaptedBids = BittrexAdapters.adaptOrders(bids, currencyPair, bidType, depth);\n    Assert.assertEquals(expectedAsks, adaptedAsks);\n    Assert.assertEquals(expectedBids, adaptedBids);\n  }\n  @Test\n  public void testAdaptOrderStatus() {\n    BittrexOrder orderPartiallyFilled =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"5\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderFilled =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderNew =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"0\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    BittrexOrder orderClosed =\n        new BittrexOrder(\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"10\"),\n            null,\n            null,\n            null,\n            null,\n            new BigDecimal(\"0\"),\n            null,\n            null,\n            null,\n            null,\n            null,\n            Date.from(Instant.now()),\n            null);\n    BittrexOrder orderUnknown =\n        new BittrexOrder(\n            null, null, null, null, null, null, null, null, null, null, null, null, null, null,\n            null, null, null);\n    Assert.assertEquals(\n        Order.OrderStatus.PARTIALLY_FILLED, BittrexAdapters.adaptOrderStatus(orderPartiallyFilled));\n    Assert.assertEquals(Order.OrderStatus.FILLED, BittrexAdapters.adaptOrderStatus(orderFilled));\n    Assert.assertEquals(Order.OrderStatus.NEW, BittrexAdapters.adaptOrderStatus(orderNew));\n    Assert.assertEquals(Order.OrderStatus.UNKNOWN, BittrexAdapters.adaptOrderStatus(orderUnknown));\n    Assert.assertEquals(Order.OrderStatus.CLOSED, BittrexAdapters.adaptOrderStatus(orderClosed));\n  }\n  @Test\n  public void testAdaptTrades() {\n    CurrencyPair pair = CurrencyPair.ETH_BTC;\n    BittrexTrade trade1 = new BittrexTrade();\n    trade1.setExecutedAt(new Date());\n    trade1.setId(\"123\");\n    trade1.setQuantity(new BigDecimal(\"1\"));\n    trade1.setRate(new BigDecimal(\"2\"));\n    trade1.setTakerSide(BittrexConstants.BUY);\n    BittrexTrade trade2 = new BittrexTrade();\n    trade2.setExecutedAt(new Date());\n    trade2.setId(\"456\");\n    trade2.setQuantity(new BigDecimal(\"3\"));\n    trade2.setRate(new BigDecimal(\"4\"));\n    trade2.setTakerSide(BittrexConstants.SELL);\n    Trade adaptedTrade1 = BittrexAdapters.adaptTrade(trade1, pair);\n    Trade adaptedTrade2 = BittrexAdapters.adaptTrade(trade2, pair);\n    List<BittrexTrade> bittrexTradesList = Arrays.asList(trade1, trade2);\n    List<Trade> tradesList = Arrays.asList(adaptedTrade1, adaptedTrade2);\n    Trades adaptedTrades = BittrexAdapters.adaptTrades(bittrexTradesList, pair);\n    Trades trades =\n        new Trades(\n            tradesList,\n            Math.max(Long.parseLong(trade1.getId()), Long.parseLong(trade2.getId())),\n            Trades.TradeSortType.SortByTimestamp);\n    Assert.assertEquals(trades.getNextPageCursor(), adaptedTrades.getNextPageCursor());\n    Assert.assertEquals(trades.getTrades(), adaptedTrades.getTrades());\n    Assert.assertEquals(trades.getTradeSortType(), adaptedTrades.getTradeSortType());\n  }\n  @Test\n  public void testAdaptUserTrades() {\n    CurrencyPair pair = CurrencyPair.ETH_BTC;\n    BittrexOrder order1 = new BittrexOrder();\n    order1.setType(BittrexConstants.LIMIT);\n    order1.setMarketSymbol(\"ETH-BTC\");\n    order1.setClosedAt(new Date());\n    order1.setId(\"123\");\n    order1.setQuantity(new BigDecimal(\"1\"));\n    order1.setFillQuantity(new BigDecimal(\"1\"));\n    order1.setLimit(new BigDecimal(\"2\"));\n    order1.setDirection(BittrexConstants.BUY);\n    order1.setCommission(new BigDecimal(\"2\"));\n    BittrexOrder order2 = new BittrexOrder();\n    order2.setType(BittrexConstants.MARKET);\n    order2.setMarketSymbol(\"ETH-BTC\");\n    order2.setClosedAt(new Date());\n    order2.setId(\"456\");\n    order2.setQuantity(new BigDecimal(\"3\"));\n    order2.setFillQuantity(new BigDecimal(\"1\"));\n    order2.setLimit(new BigDecimal(\"4\"));\n    order2.setDirection(BittrexConstants.SELL);\n    order2.setCommission(new BigDecimal(\"4\"));\n    List<UserTrade> tradesList = BittrexAdapters.adaptUserTrades(Arrays.asList(order1, order2));\n    Assert.assertEquals(2, tradesList.size());\n    UserTrade trade1 = tradesList.get(0);\n    Assert.assertEquals(Order.OrderType.BID, trade1.getType());\n    Assert.assertEquals(order1.getFillQuantity(), trade1.getOriginalAmount());\n    Assert.assertEquals(pair, trade1.getInstrument());\n    Assert.assertEquals(order1.getLimit(), trade1.getPrice());\n    Assert.assertEquals(order1.getClosedAt(), trade1.getTimestamp());\n    Assert.assertEquals(order1.getId(), trade1.getId());\n    Assert.assertEquals(order1.getCommission(), trade1.getFeeAmount());\n    Assert.assertEquals(pair.counter, trade1.getFeeCurrency());\n    UserTrade trade2 = tradesList.get(1);\n    Assert.assertEquals(Order.OrderType.ASK, trade2.getType());\n    Assert.assertEquals(order2.getFillQuantity(), trade2.getOriginalAmount());\n    Assert.assertEquals(pair, trade2.getInstrument());\n    Assert.assertEquals(order2.getLimit(), trade2.getPrice());\n    Assert.assertEquals(order2.getClosedAt(), trade2.getTimestamp());\n    Assert.assertEquals(order2.getId(), trade2.getId());\n    Assert.assertEquals(order2.getCommission(), trade2.getFeeAmount());\n    Assert.assertEquals(pair.counter, trade2.getFeeCurrency());\n  }\n"]], "pred": {"ppl": 1.2336982488632202, "ppl_lower": 1.3465430736541748, "ppl/lowercase_ppl": -1.4167497021637248, "ppl/zlib": 0.00015946572868309153, "Min_5.0% Prob": 3.2913725329380408, "Min_10.0% Prob": 1.966437740653169, "Min_20.0% Prob": 1.0424339832628475, "Min_30.0% Prob": 0.7005567386901627, "Min_40.0% Prob": 0.5250003847238337, "Min_50.0% Prob": 0.4203762519742301, "Min_60.0% Prob": 0.3504664299293977}}
{"hexsha": "f55a0802399e5abd77e82354deb402c84a1b0d53", "ext": "java", "lang": "Java", "content": "@Configuration\n@AutoConfigureBefore(StarterErrorHandlingAutoConfiguration.class)\n@ConditionalOnProperty(prefix = \"neostarter.mvc.restErrorHandling\", value = \"enabled\", havingValue = \"true\", matchIfMissing = true)\n@Import(ExceptionHandlersRegistryAutoConfiguration.RestExceptionHandlerRegistryRegistrar.class)\npublic class ExceptionHandlersRegistryAutoConfiguration {\n\n    static class RestExceptionHandlerRegistryRegistrar implements ImportBeanDefinitionRegistrar {\n\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n            beanDefinition.setBeanClass(RestExceptionHandlerRegistry.class);\n            beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            beanDefinition.getConstructorArgumentValues()\n                    .addGenericArgumentValue(Sets.newHashSet());\n            beanDefinition.setSynthetic(true);\n            registry.registerBeanDefinition(RestExceptionHandlerRegistry.BEAN_NAME, beanDefinition);\n        }\n    }\n}", "class_id": 0, "repo": "neoteric-eu/neo-starters", "file": "neo-starter/src/main/java/eu/neoteric/starter/mvc/errorhandling/ExceptionHandlersRegistryAutoConfiguration.java", "last_update_at": "2018-08-22T15:46:10+00:00", "question_id": "f55a0802399e5abd77e82354deb402c84a1b0d53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\n@AutoConfigureBefore(StarterErrorHandlingAutoConfiguration.class)\n@ConditionalOnProperty(prefix = \"neostarter.mvc.restErrorHandling\", value = \"enabled\", havingValue = \"true\", matchIfMissing = true)\n@Import(ExceptionHandlersRegistryAutoConfiguration.RestExceptionHandlerRegistryRegistrar.class)\npublic class ExceptionHandlersRegistryAutoConfiguration {\n    static class RestExceptionHandlerRegistryRegistrar implements ImportBeanDefinitionRegistrar {\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n            beanDefinition.setBeanClass(RestExceptionHandlerRegistry.class);\n            beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            beanDefinition.getConstructorArgumentValues()\n                    .addGenericArgumentValue(Sets.newHashSet());\n            beanDefinition.setSynthetic(true);\n            registry.registerBeanDefinition(RestExceptionHandlerRegistry.BEAN_NAME, beanDefinition);\n        }\n    }\n"]], "pred": {"ppl": 1.9316167831420898, "ppl_lower": 3.291229248046875, "ppl/lowercase_ppl": -1.8094445240433543, "ppl/zlib": 0.0014962667356930876, "Min_5.0% Prob": 6.624830842018127, "Min_10.0% Prob": 4.80147352218628, "Min_20.0% Prob": 3.0380804281608733, "Min_30.0% Prob": 2.1594834710030177, "Min_40.0% Prob": 1.639353988509552, "Min_50.0% Prob": 1.314249198367179, "Min_60.0% Prob": 1.1010070403922179}}
{"hexsha": "7057aadca3164ef8094550db3fa34a8f5570fd57", "ext": "java", "lang": "Java", "content": "public class CompareTwoBstLInkedListMap {\n    private static double testMap(Map<String, Integer> map, String filename) {\n\n        long startTime = System.nanoTime();\n\n        System.out.println(filename);\n        ArrayList<String> words = new ArrayList<>();\n        if (FileOperation.readFile(filename, words)) {\n            System.out.println(\"Total words: \" + words.size());\n\n            for (String word : words) {\n                if (map.contains(word))\n                    map.set(word, map.get(word) + 1);\n                else\n                    map.add(word, 1);\n            }\n\n            System.out.println(\"Total different words: \" + map.getSize());\n            System.out.println(\"Frequency of PRIDE: \" + map.get(\"pride\"));\n            System.out.println(\"Frequency of PREJUDICE: \" + map.get(\"prejudice\"));\n        }\n\n        long endTime = System.nanoTime();\n\n        return (endTime - startTime) / 1e9;\n    }\n\n    public static void main(String[] args) {\n\n        String filename = \"pride-and-prejudice.txt\";\n\n        BSTMap<String, Integer> bstMap = new BSTMap<>();\n        double time1 = testMap(bstMap, filename);\n        System.out.println(\"BST Map: \" + time1 + \" s\");\n\n        System.out.println();\n\n        LinkedListMap<String, Integer> linkedListMap = new LinkedListMap<>();\n        double time2 = testMap(linkedListMap, filename);\n        System.out.println(\"Linked List Map: \" + time2 + \" s\");\n\n    }\n}", "class_id": 0, "repo": "mtianyan/Play-with-Data-Structures-mtianyan", "file": "07-Set-and-Map/src/cn/mtianyan/CompareTwoBstLInkedListMap.java", "last_update_at": "2018-08-21T14:46:36+00:00", "question_id": "7057aadca3164ef8094550db3fa34a8f5570fd57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CompareTwoBstLInkedListMap {\n    private static double testMap(Map<String, Integer> map, String filename) {\n        long startTime = System.nanoTime();\n        System.out.println(filename);\n        ArrayList<String> words = new ArrayList<>();\n        if (FileOperation.readFile(filename, words)) {\n            System.out.println(\"Total words: \" + words.size());\n            for (String word : words) {\n                if (map.contains(word))\n                    map.set(word, map.get(word) + 1);\n                else\n                    map.add(word, 1);\n            }\n            System.out.println(\"Total different words: \" + map.getSize());\n            System.out.println(\"Frequency of PRIDE: \" + map.get(\"pride\"));\n            System.out.println(\"Frequency of PREJUDICE: \" + map.get(\"prejudice\"));\n        }\n        long endTime = System.nanoTime();\n        return (endTime - startTime) / 1e9;\n    }\n    public static void main(String[] args) {\n        String filename = \"pride-and-prejudice.txt\";\n        BSTMap<String, Integer> bstMap = new BSTMap<>();\n        double time1 = testMap(bstMap, filename);\n        System.out.println(\"BST Map: \" + time1 + \" s\");\n        System.out.println();\n        LinkedListMap<String, Integer> linkedListMap = new LinkedListMap<>();\n        double time2 = testMap(linkedListMap, filename);\n        System.out.println(\"Linked List Map: \" + time2 + \" s\");\n    }\n"]], "pred": {"ppl": 1.387843132019043, "ppl_lower": 1.7527097463607788, "ppl/lowercase_ppl": -1.7121634823444687, "ppl/zlib": 0.0006451788157880561, "Min_5.0% Prob": 4.963428395135062, "Min_10.0% Prob": 3.0046417188076746, "Min_20.0% Prob": 1.6134095374672186, "Min_30.0% Prob": 1.0899191952443548, "Min_40.0% Prob": 0.8198562141541126, "Min_50.0% Prob": 0.6565544900972219, "Min_60.0% Prob": 0.5473771056697134}}
{"hexsha": "a25db5dd385cb7c8acd32a8240174ff2723c39ce", "ext": "java", "lang": "Java", "content": "public class ACO extends MetaHeuristic{\n    private final CountIteration loop = CountIteration.obj;\n    \n    private Stop stop;\n    private Problem problem;\n    private oTrailPheromone trails[];\n    \n    private final Factory fStop;\n    private final Factory fProblem;\n    \n    private int Nants;  //number of ants\n    private double convergence; //convergence rate\n\n    public ACO(Factory fStop, Factory fProblem) {\n        this.fStop = fStop;\n        this.fProblem = fProblem;\n    }\n    \n    @Override\n    public String name() {\n        return \"Ant Colony Optimization\";\n    }\n    @Override\n    public void services(LinkerApproaches link) throws Exception {\n        link.add(loop);\n        stop                = link.get(fStop, stop);\n        problem             = link.get(fProblem, problem);\n        trails              = link.needs(oTrailPheromone.class, new oTrailPheromone[1]);\n    }\n    @Override\n    public void parameters(LinkerParameters link) throws Exception {\n        super.parameters(link); //To change body of generated methods, choose Tools | Templates.\n        Nants = link.Int(\"N-ants\", 100, 1, 1000000);\n        convergence = link.Dbl(\"convergence\", 0.5, 1e-3, 1.0);\n    }\n    @Override\n    public void execute() throws Exception {\n        //Initialize trails pheromone of each ant colony\n        for(oTrailPheromone tr : trails){\n            tr.initialize(problem);\n        }\n        //Alocate memory for each ant in all colonies\n        Solution ants[][] = new Solution[trails.length][Nants];\n        for(int t=0; t<trails.length; t++){\n            for(int k=0; k<Nants; k++){\n                ants[t][k] = problem.build_sol();\n            }\n        }\n        Solution best[] = new Solution[trails.length];  //best solution on colony\n        Solution migr[] = new Solution[trails.length];  //migrate solution\n        int trails_life[] = new int[trails.length];\n        int max_life = 1;\n        do{\n            //------------------- build ants ---------------------\n            \n            for(int t=0; t<trails.length; t++){ //for each colony or pheromone trail (t)\n                double prob = 1;\n                for(int k=0; k<Nants; k++){\n                    // if is not the best and is not the migrate solution then rebuild the ant\n                    if(ants[t][k] != best[t] && ants[t][k] != migr[t]){ \n                        //prob = Math.max(prob,trails[t].build(problem, ants[t][k]));\n                        prob *= trails[t].build(problem, ants[t][k]);\n                        problem.evaluate(ants[t][k]);\n                    }\n                }\n//                if(trails_life[t]>max_life){\n//                    max_life = trails_life[t];\n//                    //System.out.println(\"max-life = \"+max_life);\n//                }\n                //System.out.printf(\"%d : %8d : %g\\n\",t, trails_life[t], prob);\n                if(prob>convergence){\n                    //System.out.printf(\"RESTART trail = %d : life = %8d : max = %8d: prob = %g\\n\",t, trails_life[t], max_life, prob);\n                    \n                    trails_life[t] = 0;\n                    //System.out.println(\"--------------[RESTART trail = \"+trails[t]+\" ]-------------\");\n                    trails[t].initialize(problem);\n                    t--;    //repeat the build process\n                }else{\n                    trails_life[t]++;\n                }\n            }\n            //------------------ find bests ----------------------\n            for(int t=0; t<trails.length; t++){\n                int b = Solution.minIndex(ants[t]);\n                best[t] = ants[t][b];\n            }\n            //------------------ migrations ----------------------\n            if(trails.length>1){    //if we have more than one colony\n                for(int t=0; t<trails.length; t++){\n                    int s = (t+1)%trails.length;\n                    int w = Solution.maxIndex(ants[s]);\n                    ants[s][w].copy(problem, best[t]);   //copy the best ant from t on worst ant from t+1\n                    migr[s] = ants[s][w];\n                }\n            }\n                \n            //------------------ update trails -------------------\n            for(int t=0; t<trails.length; t++){\n                trails[t].evaporate(problem);\n                for(int k=0; k<Nants; k++){\n                    trails[t].deposit(problem, ants[t][k], 1.0);\n                }\n                trails[t].deposit(problem, best[t], trails_life[t]);\n            }\n            \n            loop.iteration();\n        }while(!stop.end());\n    }\n    @Override\n    public void results(LinkerResults win) throws Exception {\n        win.writeLong(\"iterations\", loop.value());\n    }\n}", "class_id": 0, "repo": "valdemar-abrao-devesse/ProOF", "file": "ProOFJava/src/ProOF/apl/advanced1/method/ACO.java", "last_update_at": "2018-06-29T16:41:41+00:00", "question_id": "a25db5dd385cb7c8acd32a8240174ff2723c39ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ACO extends MetaHeuristic{\n    private final CountIteration loop = CountIteration.obj;\n    private Stop stop;\n    private Problem problem;\n    private oTrailPheromone trails[];\n    private final Factory fStop;\n    private final Factory fProblem;\n    private int Nants;  //number of ants\n    private double convergence; //convergence rate\n    public ACO(Factory fStop, Factory fProblem) {\n        this.fStop = fStop;\n        this.fProblem = fProblem;\n    }\n    @Override\n    public String name() {\n        return \"Ant Colony Optimization\";\n    }\n    @Override\n    public void services(LinkerApproaches link) throws Exception {\n        link.add(loop);\n        stop                = link.get(fStop, stop);\n        problem             = link.get(fProblem, problem);\n        trails              = link.needs(oTrailPheromone.class, new oTrailPheromone[1]);\n    }\n    @Override\n    public void parameters(LinkerParameters link) throws Exception {\n        super.parameters(link); //To change body of generated methods, choose Tools | Templates.\n        Nants = link.Int(\"N-ants\", 100, 1, 1000000);\n        convergence = link.Dbl(\"convergence\", 0.5, 1e-3, 1.0);\n    }\n    @Override\n    public void execute() throws Exception {\n        //Initialize trails pheromone of each ant colony\n        for(oTrailPheromone tr : trails){\n            tr.initialize(problem);\n        }\n        //Alocate memory for each ant in all colonies\n        Solution ants[][] = new Solution[trails.length][Nants];\n        for(int t=0; t<trails.length; t++){\n            for(int k=0; k<Nants; k++){\n                ants[t][k] = problem.build_sol();\n            }\n        }\n        Solution best[] = new Solution[trails.length];  //best solution on colony\n        Solution migr[] = new Solution[trails.length];  //migrate solution\n        int trails_life[] = new int[trails.length];\n        int max_life = 1;\n        do{\n            //------------------- build ants ---------------------\n            for(int t=0; t<trails.length; t++){ //for each colony or pheromone trail (t)\n                double prob = 1;\n                for(int k=0; k<Nants; k++){\n                    // if is not the best and is not the migrate solution then rebuild the ant\n                    if(ants[t][k] != best[t] && ants[t][k] != migr[t]){ \n                        //prob = Math.max(prob,trails[t].build(problem, ants[t][k]));\n                        prob *= trails[t].build(problem, ants[t][k]);\n                        problem.evaluate(ants[t][k]);\n                    }\n                }\n//                if(trails_life[t]>max_life){\n//                    max_life = trails_life[t];\n//                    //System.out.println(\"max-life = \"+max_life);\n//                }\n                //System.out.printf(\"%d : %8d : %g\\n\",t, trails_life[t], prob);\n                if(prob>convergence){\n                    //System.out.printf(\"RESTART trail = %d : life = %8d : max = %8d: prob = %g\\n\",t, trails_life[t], max_life, prob);\n                    trails_life[t] = 0;\n                    //System.out.println(\"--------------[RESTART trail = \"+trails[t]+\" ]-------------\");\n                    trails[t].initialize(problem);\n                    t--;    //repeat the build process\n                }else{\n                    trails_life[t]++;\n                }\n            }\n            //------------------ find bests ----------------------\n            for(int t=0; t<trails.length; t++){\n                int b = Solution.minIndex(ants[t]);\n                best[t] = ants[t][b];\n            }\n            //------------------ migrations ----------------------\n            if(trails.length>1){    //if we have more than one colony\n                for(int t=0; t<trails.length; t++){\n                    int s = (t+1)%trails.length;\n                    int w = Solution.maxIndex(ants[s]);\n                    ants[s][w].copy(problem, best[t]);   //copy the best ant from t on worst ant from t+1\n                    migr[s] = ants[s][w];\n                }\n            }\n            //------------------ update trails -------------------\n            for(int t=0; t<trails.length; t++){\n                trails[t].evaporate(problem);\n                for(int k=0; k<Nants; k++){\n                    trails[t].deposit(problem, ants[t][k], 1.0);\n                }\n                trails[t].deposit(problem, best[t], trails_life[t]);\n            }\n            loop.iteration();\n        }while(!stop.end());\n    }\n    @Override\n    public void results(LinkerResults win) throws Exception {\n        win.writeLong(\"iterations\", loop.value());\n    }\n"]], "pred": {"ppl": 2.5528512001037598, "ppl_lower": 2.7459590435028076, "ppl/lowercase_ppl": -1.0778048396097573, "ppl/zlib": 0.0006876088424285133, "Min_5.0% Prob": 7.14377259273155, "Min_10.0% Prob": 5.57960283055025, "Min_20.0% Prob": 3.9117978711922965, "Min_30.0% Prob": 2.936536758553748, "Min_40.0% Prob": 2.2916033382739296, "Min_50.0% Prob": 1.8615785777393852, "Min_60.0% Prob": 1.5599174708626302}}
{"hexsha": "0fd5f10a9f8a363119112181aea92b8d58291412", "ext": "java", "lang": "Java", "content": "@javax.annotation.Generated(value = \"io.swagger.codegen.languages.SpringCodegen\", date = \"2017-08-22T11:29:03.578Z\")\r\n\r\npublic class InlineResponse2001   {\r\n  @JsonProperty(\"slotId\")\r\n  private Long slotId = null;\r\n\r\n  @JsonProperty(\"startTime\")\r\n  private String startTime = null;\r\n\r\n  @JsonProperty(\"endTime\")\r\n  private String endTime = null;\r\n\r\n  @JsonProperty(\"doctorId\")\r\n  private Integer doctorId = null;\r\n\r\n  public InlineResponse2001 slotId(Long slotId) {\r\n    this.slotId = slotId;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get slotId\r\n   * @return slotId\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public Long getSlotId() {\r\n    return slotId;\r\n  }\r\n\r\n  public void setSlotId(Long slotId) {\r\n    this.slotId = slotId;\r\n  }\r\n\r\n  public InlineResponse2001 startTime(String startTime) {\r\n    this.startTime = startTime;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get startTime\r\n   * @return startTime\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public String getStartTime() {\r\n    return startTime;\r\n  }\r\n\r\n  public void setStartTime(String startTime) {\r\n    this.startTime = startTime;\r\n  }\r\n\r\n  public InlineResponse2001 endTime(String endTime) {\r\n    this.endTime = endTime;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get endTime\r\n   * @return endTime\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public String getEndTime() {\r\n    return endTime;\r\n  }\r\n\r\n  public void setEndTime(String endTime) {\r\n    this.endTime = endTime;\r\n  }\r\n\r\n  public InlineResponse2001 doctorId(Integer doctorId) {\r\n    this.doctorId = doctorId;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get doctorId\r\n   * @return doctorId\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public Integer getDoctorId() {\r\n    return doctorId;\r\n  }\r\n\r\n  public void setDoctorId(Integer doctorId) {\r\n    this.doctorId = doctorId;\r\n  }\r\n\r\n\r\n  @Override\r\n  public boolean equals(java.lang.Object o) {\r\n    if (this == o) {\r\n      return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n      return false;\r\n    }\r\n    InlineResponse2001 inlineResponse2001 = (InlineResponse2001) o;\r\n    return Objects.equals(this.slotId, inlineResponse2001.slotId) &&\r\n        Objects.equals(this.startTime, inlineResponse2001.startTime) &&\r\n        Objects.equals(this.endTime, inlineResponse2001.endTime) &&\r\n        Objects.equals(this.doctorId, inlineResponse2001.doctorId);\r\n  }\r\n\r\n  @Override\r\n  public int hashCode() {\r\n    return Objects.hash(slotId, startTime, endTime, doctorId);\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"class InlineResponse2001 {\\n\");\r\n    \r\n    sb.append(\"    slotId: \").append(toIndentedString(slotId)).append(\"\\n\");\r\n    sb.append(\"    startTime: \").append(toIndentedString(startTime)).append(\"\\n\");\r\n    sb.append(\"    endTime: \").append(toIndentedString(endTime)).append(\"\\n\");\r\n    sb.append(\"    doctorId: \").append(toIndentedString(doctorId)).append(\"\\n\");\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n  }\r\n\r\n  /**\r\n   * Convert the given object to string with each line indented by 4 spaces\r\n   * (except the first line).\r\n   */\r\n  private String toIndentedString(java.lang.Object o) {\r\n    if (o == null) {\r\n      return \"null\";\r\n    }\r\n    return o.toString().replace(\"\\n\", \"\\n    \");\r\n  }\r\n}", "class_id": 0, "repo": "XoriantOpenSource/swagger-blog-examples", "file": "swagger-blog-2/spring-server/src/main/java/io/swagger/model/InlineResponse2001.java", "last_update_at": "2018-03-08T15:56:29+00:00", "question_id": "0fd5f10a9f8a363119112181aea92b8d58291412", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@javax.annotation.Generated(value = \"io.swagger.codegen.languages.SpringCodegen\", date = \"2017-08-22T11:29:03.578Z\")\r\n\r\npublic class InlineResponse2001   {\r\n  @JsonProperty(\"slotId\")\r\n  private Long slotId = null;\r\n\r\n  @JsonProperty(\"startTime\")\r\n  private String startTime = null;\r\n\r\n  @JsonProperty(\"endTime\")\r\n  private String endTime = null;\r\n\r\n  @JsonProperty(\"doctorId\")\r\n  private Integer doctorId = null;\r\n\r\n  public InlineResponse2001 slotId(Long slotId) {\r\n    this.slotId = slotId;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get slotId\r\n   * @return slotId\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public Long getSlotId() {\r\n    return slotId;\r\n  }\r\n\r\n  public void setSlotId(Long slotId) {\r\n    this.slotId = slotId;\r\n  }\r\n\r\n  public InlineResponse2001 startTime(String startTime) {\r\n    this.startTime = startTime;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get startTime\r\n   * @return startTime\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public String getStartTime() {\r\n    return startTime;\r\n  }\r\n\r\n  public void setStartTime(String startTime) {\r\n    this.startTime = startTime;\r\n  }\r\n\r\n  public InlineResponse2001 endTime(String endTime) {\r\n    this.endTime = endTime;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get endTime\r\n   * @return endTime\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public String getEndTime() {\r\n    return endTime;\r\n  }\r\n\r\n  public void setEndTime(String endTime) {\r\n    this.endTime = endTime;\r\n  }\r\n\r\n  public InlineResponse2001 doctorId(Integer doctorId) {\r\n    this.doctorId = doctorId;\r\n    return this;\r\n  }\r\n\r\n   /**\r\n   * Get doctorId\r\n   * @return doctorId\r\n  **/\r\n  @ApiModelProperty(value = \"\")\r\n\r\n\r\n  public Integer getDoctorId() {\r\n    return doctorId;\r\n  }\r\n\r\n  public void setDoctorId(Integer doctorId) {\r\n    this.doctorId = doctorId;\r\n  }\r\n\r\n\r\n  @Override\r\n  public boolean equals(java.lang.Object o) {\r\n    if (this == o) {\r\n      return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n      return false;\r\n    }\r\n    InlineResponse2001 inlineResponse2001 = (InlineResponse2001) o;\r\n    return Objects.equals(this.slotId, inlineResponse2001.slotId) &&\r\n        Objects.equals(this.startTime, inlineResponse2001.startTime) &&\r\n        Objects.equals(this.endTime, inlineResponse2001.endTime) &&\r\n        Objects.equals(this.doctorId, inlineResponse2001.doctorId);\r\n  }\r\n\r\n  @Override\r\n  public int hashCode() {\r\n    return Objects.hash(slotId, startTime, endTime, doctorId);\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"class InlineResponse2001 {\\n\");\r\n    \r\n    sb.append(\"    slotId: \").append(toIndentedString(slotId)).append(\"\\n\");\r\n    sb.append(\"    startTime: \").append(toIndentedString(startTime)).append(\"\\n\");\r\n    sb.append(\"    endTime: \").append(toIndentedString(endTime)).append(\"\\n\");\r\n    sb.append(\"    doctorId: \").append(toIndentedString(doctorId)).append(\"\\n\");\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n  }\r\n\r\n  /**\r\n   * Convert the given object to string with each line indented by 4 spaces\r\n   * (except the first line).\r\n   */\r\n  private String toIndentedString(java.lang.Object o) {\r\n    if (o == null) {\r\n      return \"null\";\r\n    }\r\n    return o.toString().replace(\"\\n\", \"\\n    \");\r\n  }\r\n"]], "pred": {"ppl": 1.157132625579834, "ppl_lower": 1.347083330154419, "ppl/lowercase_ppl": -2.0414650390325053, "ppl/zlib": 0.00017436687036139398, "Min_5.0% Prob": 2.832557875736087, "Min_10.0% Prob": 1.461723911667279, "Min_20.0% Prob": 0.7317736010391301, "Min_30.0% Prob": 0.48789849345154473, "Min_40.0% Prob": 0.36503736264923714, "Min_50.0% Prob": 0.29217467622276794, "Min_60.0% Prob": 0.24355890938826572}}
{"hexsha": "5b99103db174570ebeeb82d08a8a8fa6fe00b76b", "ext": "java", "lang": "Java", "content": "public class SchedulerUtilities {\n\n\tprivate SchedulerUtilities() {\n\t}\n\n\tprivate static SchedulerUtilities singleton;\n\tprivate WorkloadService ws;\n\tString agentName = \"_CLOUD\";\n\n\tstatic public SchedulerUtilities getSingleton() {\n\t\tif (singleton == null) {\n\t\t\tsingleton = new SchedulerUtilities();\n\t\t}\n\t\treturn singleton;\n\t}\n\n\tpublic WorkloadService getWorkloadService() {\n\t\t\n\t\tAuthenticationServlet.configureSSL();\n\t\t\n\t\tif (ws != null)\n\t\t\treturn ws;\n\n\t\tboolean configExists = false;\n\t\tString url = null;\n\n\t\ttry {\n\t\t\tString ws_url = System.getenv(\"NA_WS_URL\");\n\t\t\tif ((ws_url != null) && (!ws_url.equalsIgnoreCase(\"\"))) {\n\t\t\t\turl = ws_url;\n\t\t\t\tconfigExists = true;\n\t\t\t} else {\n\t\t\t\tString VCAP_SERVICES = System.getenv(\"VCAP_SERVICES\");\n\n\t\t\t\tif (VCAP_SERVICES != null) {\n\t\t\t\t\tObject jsonObject = JSON.parse(VCAP_SERVICES);\n\t\t\t\t\tJSONObject json = (JSONObject) jsonObject;\n\t\t\t\t\tString key = null;\n\t\t\t\t\tJSONArray list = null;\n\t\t\t\t\tjava.util.Set<String> keys = json.keySet();\n\t\t\t\t\tfor (String eachkey : keys) {\n\t\t\t\t\t\tif (eachkey.contains(\"WorkloadScheduler\")) {\n\t\t\t\t\t\t\tkey = eachkey;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (key == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlist = (JSONArray) json.get(key);\n\t\t\t\t\tJSONObject jsonService = (JSONObject) list.get(0);\n\t\t\t\t\tJSONObject credentials = (JSONObject) jsonService\n\t\t\t\t\t\t\t.get(\"credentials\");\n\n\t\t\t\t\turl = (String) credentials.get(\"url\");\n\t\t\t\t\tconfigExists = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (configExists) {\n\t\t\t\tint index = url.indexOf(\"tenantId=\") + 9;\n\t\t\t\tString prefix = url.substring(index, index + 2);\n\t\t\t\tagentName = prefix + agentName;\n\t\t\t\ttry {\n\t\t\t\t\tWorkloadService.disableCertificateValidation();\n\t\t\t\t\tws = new WorkloadService(url);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn ws;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String turnOn() {\n\t\tif (ws == null) return null;\n\t\tSchedulerData data = getData();\n\t\tif (data == null) return null;\n\t\t\n\t\tif (data.isOn()) return \"Already on\";\n\t\t\n\t\tWAProcess process = new WAProcess(\"BluemixInfo\", \"BluemixInfo\");\n\t\tRESTAction action = new RESTAction(\n\t\t\t\t\"http://www.bluemix.info/api/readfeedsscheduler\",\n\t\t\t\t\"application/json\", \"text/html\", RestfulStep.GET_METHOD,\n\t\t\t\t\"file.text\");\n\t\tRESTAuthenticationData auth = RESTAuthenticationData.fromUserPwd(\n\t\t\t\tdata.getUserName(), data.getPassword());\n\n\t\tRESTInput input = RESTInput.fromText(\"\");\n\t\tStep step = new RestfulStep(agentName, action, auth, input);\n\t\tprocess.addStep(step);\n\n\t\ttry {\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(0, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(1, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(2, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(3, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(4, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(5, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(6, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(7, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(8, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(9, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(10, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(11, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(12, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(13, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(14, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(15, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(16, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(17, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(18, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(19, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(20, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(21, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(22, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(23, 0));\n\n\t\t\tTask task = ws.createAndEnableTask(process);\n\t\t\tif (task != null) {\n\t\t\t\tlong processId = task.getId();\n\t\t\t\tdata.setProcessId(processId);\n\t\t\t\tdata.setLastChanged(new Date());\n\t\t\t\tdata.setOn(true);\n\t\t\t\t\n\t\t\t\tws.runTask(processId);\n\n\t\t\t\ttry {\n\t\t\t\t\tCouchDbConnector db;\n\t\t\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\t\t\tdb.update(data);\n\t\t\t\t\t\n\t\t\t\t\treturn \"Scheduler turned on\";\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\t\t\n\t\treturn null;\n\t}\n\n\tpublic String turnOff() {\n\t\tif (ws == null) return null;\n\t\tSchedulerData data = getData();\n\t\tif (data == null) return null;\n\t\t\n\t\tif (data.isOn() == false) return \"Already off\";\n\t\t\n\t\ttry {\n\t\t\tws.deleteTask(data.getProcessId());\n\t\t\t\n\t\t\tdata.setLastChanged(new Date());\n\t\t\tdata.setOn(false);\n\t\t\t\n\t\t\tCouchDbConnector db;\n\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\tdb.update(data);\n\t\t\t\n\t\t\treturn \"Scheduler turned off\";\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\t\n\t}\n\n\tpublic SchedulerData getData() {\n\t\tSchedulerData out = null;\n\t\tCouchDbConnector db;\n\t\ttry {\n\t\t\tList<SchedulerData> list = new ArrayList<SchedulerData>();\n\n\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\n\t\t\tViewQuery viewQuery = new ViewQuery().dbPath(db.path())\n\t\t\t\t\t.designDocId(\"_design/views\").viewName(\"allSchedulerData\")\n\t\t\t\t\t.includeDocs(true).cacheOk(false);\n\t\t\tlist = db.queryView(viewQuery, SchedulerData.class);\n\t\t\tif (list != null) {\n\t\t\t\tif (list.size() > 0) {\n\t\t\t\t\tout = list.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tif (out == null) {\n\t\t\ttry {\n\t\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\t\tUUID id = UUID.randomUUID();\n\t\t\t\tUUID userName = UUID.randomUUID();\n\t\t\t\tUUID password = UUID.randomUUID();\n\n\t\t\t\tSchedulerData data = new SchedulerData(id.toString(),\n\t\t\t\t\t\tuserName.toString(), password.toString(), null, 0, false);\n\n\t\t\t\tdb.create(data.getId(), data);\n\n\t\t\t\tout = db.get(SchedulerData.class, data.getId());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tWorkloadService w = SchedulerUtilities.getSingleton()\n\t\t\t\t.getWorkloadService();\n\t\tSchedulerUtilities.getSingleton().turnOn();\n\n\t}\t\n}", "class_id": 0, "repo": "arthurghulian/IBM-Bluemix-news-aggregator", "file": "src/main/java/net/bluemix/newsaggregator/feeds/SchedulerUtilities.java", "last_update_at": "2018-01-20T00:39:50+00:00", "question_id": "5b99103db174570ebeeb82d08a8a8fa6fe00b76b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SchedulerUtilities {\n\tprivate SchedulerUtilities() {\n\t}\n\tprivate static SchedulerUtilities singleton;\n\tprivate WorkloadService ws;\n\tString agentName = \"_CLOUD\";\n\tstatic public SchedulerUtilities getSingleton() {\n\t\tif (singleton == null) {\n\t\t\tsingleton = new SchedulerUtilities();\n\t\t}\n\t\treturn singleton;\n\t}\n\tpublic WorkloadService getWorkloadService() {\n\t\t\n\t\tAuthenticationServlet.configureSSL();\n\t\t\n\t\tif (ws != null)\n\t\t\treturn ws;\n\t\tboolean configExists = false;\n\t\tString url = null;\n\t\ttry {\n\t\t\tString ws_url = System.getenv(\"NA_WS_URL\");\n\t\t\tif ((ws_url != null) && (!ws_url.equalsIgnoreCase(\"\"))) {\n\t\t\t\turl = ws_url;\n\t\t\t\tconfigExists = true;\n\t\t\t} else {\n\t\t\t\tString VCAP_SERVICES = System.getenv(\"VCAP_SERVICES\");\n\t\t\t\tif (VCAP_SERVICES != null) {\n\t\t\t\t\tObject jsonObject = JSON.parse(VCAP_SERVICES);\n\t\t\t\t\tJSONObject json = (JSONObject) jsonObject;\n\t\t\t\t\tString key = null;\n\t\t\t\t\tJSONArray list = null;\n\t\t\t\t\tjava.util.Set<String> keys = json.keySet();\n\t\t\t\t\tfor (String eachkey : keys) {\n\t\t\t\t\t\tif (eachkey.contains(\"WorkloadScheduler\")) {\n\t\t\t\t\t\t\tkey = eachkey;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (key == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlist = (JSONArray) json.get(key);\n\t\t\t\t\tJSONObject jsonService = (JSONObject) list.get(0);\n\t\t\t\t\tJSONObject credentials = (JSONObject) jsonService\n\t\t\t\t\t\t\t.get(\"credentials\");\n\t\t\t\t\turl = (String) credentials.get(\"url\");\n\t\t\t\t\tconfigExists = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (configExists) {\n\t\t\t\tint index = url.indexOf(\"tenantId=\") + 9;\n\t\t\t\tString prefix = url.substring(index, index + 2);\n\t\t\t\tagentName = prefix + agentName;\n\t\t\t\ttry {\n\t\t\t\t\tWorkloadService.disableCertificateValidation();\n\t\t\t\t\tws = new WorkloadService(url);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn ws;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic String turnOn() {\n\t\tif (ws == null) return null;\n\t\tSchedulerData data = getData();\n\t\tif (data == null) return null;\n\t\t\n\t\tif (data.isOn()) return \"Already on\";\n\t\t\n\t\tWAProcess process = new WAProcess(\"BluemixInfo\", \"BluemixInfo\");\n\t\tRESTAction action = new RESTAction(\n\t\t\t\t\"http://www.bluemix.info/api/readfeedsscheduler\",\n\t\t\t\t\"application/json\", \"text/html\", RestfulStep.GET_METHOD,\n\t\t\t\t\"file.text\");\n\t\tRESTAuthenticationData auth = RESTAuthenticationData.fromUserPwd(\n\t\t\t\tdata.getUserName(), data.getPassword());\n\t\tRESTInput input = RESTInput.fromText(\"\");\n\t\tStep step = new RestfulStep(agentName, action, auth, input);\n\t\tprocess.addStep(step);\n\t\ttry {\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(0, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(1, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(2, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(3, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(4, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(5, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(6, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(7, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(8, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(9, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(10, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(11, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(12, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(13, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(14, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(15, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(16, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(17, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(18, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(19, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(20, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(21, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(22, 0));\n\t\t\tprocess.addTrigger(TriggerFactory.everyDayAt(23, 0));\n\t\t\tTask task = ws.createAndEnableTask(process);\n\t\t\tif (task != null) {\n\t\t\t\tlong processId = task.getId();\n\t\t\t\tdata.setProcessId(processId);\n\t\t\t\tdata.setLastChanged(new Date());\n\t\t\t\tdata.setOn(true);\n\t\t\t\t\n\t\t\t\tws.runTask(processId);\n\t\t\t\ttry {\n\t\t\t\t\tCouchDbConnector db;\n\t\t\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\t\t\tdb.update(data);\n\t\t\t\t\t\n\t\t\t\t\treturn \"Scheduler turned on\";\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\t\t\n\t\treturn null;\n\t}\n\tpublic String turnOff() {\n\t\tif (ws == null) return null;\n\t\tSchedulerData data = getData();\n\t\tif (data == null) return null;\n\t\t\n\t\tif (data.isOn() == false) return \"Already off\";\n\t\t\n\t\ttry {\n\t\t\tws.deleteTask(data.getProcessId());\n\t\t\t\n\t\t\tdata.setLastChanged(new Date());\n\t\t\tdata.setOn(false);\n\t\t\t\n\t\t\tCouchDbConnector db;\n\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\tdb.update(data);\n\t\t\t\n\t\t\treturn \"Scheduler turned off\";\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\t\n\t}\n\tpublic SchedulerData getData() {\n\t\tSchedulerData out = null;\n\t\tCouchDbConnector db;\n\t\ttry {\n\t\t\tList<SchedulerData> list = new ArrayList<SchedulerData>();\n\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\tViewQuery viewQuery = new ViewQuery().dbPath(db.path())\n\t\t\t\t\t.designDocId(\"_design/views\").viewName(\"allSchedulerData\")\n\t\t\t\t\t.includeDocs(true).cacheOk(false);\n\t\t\tlist = db.queryView(viewQuery, SchedulerData.class);\n\t\t\tif (list != null) {\n\t\t\t\tif (list.size() > 0) {\n\t\t\t\t\tout = list.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (out == null) {\n\t\t\ttry {\n\t\t\t\tdb = DatabaseUtilities.getSingleton().getDB();\n\t\t\t\tUUID id = UUID.randomUUID();\n\t\t\t\tUUID userName = UUID.randomUUID();\n\t\t\t\tUUID password = UUID.randomUUID();\n\t\t\t\tSchedulerData data = new SchedulerData(id.toString(),\n\t\t\t\t\t\tuserName.toString(), password.toString(), null, 0, false);\n\t\t\t\tdb.create(data.getId(), data);\n\t\t\t\tout = db.get(SchedulerData.class, data.getId());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\tpublic static void main(String[] args) {\n\t\tWorkloadService w = SchedulerUtilities.getSingleton()\n\t\t\t\t.getWorkloadService();\n\t\tSchedulerUtilities.getSingleton().turnOn();\n\t}\t\n"]], "pred": {"ppl": 2.125525712966919, "ppl_lower": 2.3944168090820312, "ppl/lowercase_ppl": -1.157980774139895, "ppl/zlib": 0.00044146321201219026, "Min_5.0% Prob": 7.300696915271235, "Min_10.0% Prob": 5.335152310483596, "Min_20.0% Prob": 3.4436657904994252, "Min_30.0% Prob": 2.459079252056826, "Min_40.0% Prob": 1.8732676721908936, "Min_50.0% Prob": 1.5065976382358959, "Min_60.0% Prob": 1.2576239054367784}}
{"hexsha": "5f2115ca2ee2d1e94cc24707fbfa74bba83ee907", "ext": "java", "lang": "Java", "content": "public class MatrixIterator implements Iterator<Integer> {\n\n    public int[][] values;\n    private int lineArray;\n    private int columnArray;\n\n    public MatrixIterator(int[][] values) {\n        this.values = values;\n    }\n\n    @Override\n    public boolean hasNext() {\n\n        return this.lineArray < values.length;\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int result = values[lineArray][columnArray++];\n        if (columnArray == values[lineArray].length) {\n            lineArray++;\n            columnArray = 0;\n        }\n\n        return result;\n    }\n}", "class_id": 0, "repo": "kou85/Java-A-to-Z", "file": "Junior/Chapter_001_Collections_Pro/src/main/java/ua/ikonovalov/MatrixIterator.java", "last_update_at": "2018-11-27T15:44:54+00:00", "question_id": "5f2115ca2ee2d1e94cc24707fbfa74bba83ee907", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MatrixIterator implements Iterator<Integer> {\n    public int[][] values;\n    private int lineArray;\n    private int columnArray;\n    public MatrixIterator(int[][] values) {\n        this.values = values;\n    }\n    @Override\n    public boolean hasNext() {\n        return this.lineArray < values.length;\n    }\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int result = values[lineArray][columnArray++];\n        if (columnArray == values[lineArray].length) {\n            lineArray++;\n            columnArray = 0;\n        }\n        return result;\n    }\n"]], "pred": {"ppl": 1.6060322523117065, "ppl_lower": 1.9297620058059692, "ppl/lowercase_ppl": -1.3875958049362365, "ppl/zlib": 0.0017290755390831792, "Min_5.0% Prob": 6.043109208345413, "Min_10.0% Prob": 3.789884756593143, "Min_20.0% Prob": 2.220756110123226, "Min_30.0% Prob": 1.558209092141344, "Min_40.0% Prob": 1.1763126146580491, "Min_50.0% Prob": 0.9427751393523067, "Min_60.0% Prob": 0.7928175925321522}}
{"hexsha": "b281c919eb731b05a1526f642671132892b4d110", "ext": "java", "lang": "Java", "content": "public class BackpointerUtil {\n  private BackpointerUtil() {\n  }\n\n  public static boolean isBackpointerReference(PsiExpression expression, Condition<PsiField> value) {\n    if (expression instanceof PsiParenthesizedExpression) {\n      final PsiExpression contents = ((PsiParenthesizedExpression)expression).getExpression();\n      return isBackpointerReference(contents, value);\n    }\n    if (!(expression instanceof PsiReferenceExpression)) {\n      return false;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)expression;\n    final PsiElement qualifier = reference.getQualifier();\n    if (qualifier != null && !(qualifier instanceof PsiThisExpression)) {\n      return false;\n    }\n    final PsiElement referent = reference.resolve();\n    return referent instanceof PsiField && value.value((PsiField)referent);\n  }\n}", "class_id": 0, "repo": "fduminy/intellij-community", "file": "java/java-impl/src/com/intellij/refactoring/extractclass/BackpointerUtil.java", "last_update_at": "2018-12-29T09:53:42+00:00", "question_id": "b281c919eb731b05a1526f642671132892b4d110", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BackpointerUtil {\n  private BackpointerUtil() {\n  }\n  public static boolean isBackpointerReference(PsiExpression expression, Condition<PsiField> value) {\n    if (expression instanceof PsiParenthesizedExpression) {\n      final PsiExpression contents = ((PsiParenthesizedExpression)expression).getExpression();\n      return isBackpointerReference(contents, value);\n    }\n    if (!(expression instanceof PsiReferenceExpression)) {\n      return false;\n    }\n    final PsiReferenceExpression reference = (PsiReferenceExpression)expression;\n    final PsiElement qualifier = reference.getQualifier();\n    if (qualifier != null && !(qualifier instanceof PsiThisExpression)) {\n      return false;\n    }\n    final PsiElement referent = reference.resolve();\n    return referent instanceof PsiField && value.value((PsiField)referent);\n  }\n"]], "pred": {"ppl": 1.7740744352340698, "ppl_lower": 2.62888240814209, "ppl/lowercase_ppl": -1.686018644353756, "ppl/zlib": 0.0018027636540538848, "Min_5.0% Prob": 6.58600172996521, "Min_10.0% Prob": 4.497221691267831, "Min_20.0% Prob": 2.710517195718629, "Min_30.0% Prob": 1.8801611311851987, "Min_40.0% Prob": 1.4258048510888504, "Min_50.0% Prob": 1.144967452729387, "Min_60.0% Prob": 0.9550344453355859}}
{"hexsha": "865b5199ce355f47e8ff094868c884548a839a3c", "ext": "java", "lang": "Java", "content": "public class AssignmentStatement extends Statement implements OutputWriter,\n                                                              Optimize\n{\n\t//~ Instance fields --------------------------------------------------------\n\n\t// data members\n\n\t/*\n\t * An LvalExpression which is the LHS of the assignment.\n\t */\n\tprivate LvalExpression lhs;\n\n\t/*\n\t * An OperationExpression which is the RHS of the assignment expression.\n\t */\n\tprivate OperationExpression rhs;\n\n\t/*\n\t * The line number of this assignment statement in the output circuit.\n\t * This number may vary form one transformation to another.\n\t */\n\tprivate int outputLine = -1;\n\n\t//~ Constructors -----------------------------------------------------------\n\n\t/**\n\t * Constructs a new AssignmentStatement from a given lhs and rhs.\n\t * @param lhs An LvalExpression which is the LHS of the assignment.\n\t * @param rhs An OperationExpression which is the RHS of the assignment\n\t * expression.\n\t */\n\tpublic AssignmentStatement(LvalExpression lhs, OperationExpression rhs) {\n\t\tthis.lhs     = lhs;\n\t\tthis.rhs     = rhs;\n\t\tthis.lhs.setAssigningStatement(this);\n\t}\n\n\t//~ Methods ----------------------------------------------------------------\n\n\t/**\n\t * Transforms this multibit AssignmentStatement into singlebit Statements\n\t * and returns a BlockStatement containing the result.\n\t * @param obj not used (null).\n\t * @return BlockStatement containing singlebit Statements\n\t *                 of this AssignmentStatement.\n\t */\n\tpublic BlockStatement multi2SingleBit(Object obj) {\n\t\treturn ((Multi2SingleBit) rhs).multi2SingleBit(this);\n\t}\n\n\t/**\n\t * Returns a string representation of this AssignmentStatement.\n\t * @return a string representation of this AssignmentStatement.\n\t */\n\tpublic String toString() {\n\t\treturn lhs.toString() + '=' + rhs.toString() + \"\\n\";\n\t}\n\n\t/**\n\t * Returns this AssignmentStatement's rhs.\n\t * @return this AssignmentStatement's rhs.\n\t */\n\tpublic OperationExpression getRHS() {\n\t\treturn rhs;\n\t}\n\n\t/**\n\t * Returns this AssignmentStatement's lhs.\n\t * @return this AssignmentStatement's lhs.\n\t */\n\tpublic LvalExpression getLHS() {\n\t\treturn lhs;\n\t}\n\n\t/**\n\t * Prints this AssignmentStatement into the circuit.\n\t * @param circuit the circuit output file.\n\t */\n\tpublic void toCircuit(PrintWriter circuit) {\n\t\toutputLine = Program.getLineNumber();\n\n\t\tcircuit.print(outputLine + \" \" + ((lhs.isOutput()) ? \"output \" : \"\"));\n\t\t((OutputWriter) rhs).toCircuit(circuit);\n\t\tcircuit.println(((lhs.isOutput()) ? (\"\\t//\" + lhs.getName()) : \"\"));\n\t}\n\n\t/**\n\t * Returns an int that represents the line number of this\n\t * assignmnet statement in the output circuit.\n\t * @return an int that represents the line number of this\n\t * assignmnet statement in the output circuit.\n\t */\n\tpublic int getOutputLine() {\n\t\treturn outputLine;\n\t}\n\n\t/**\n\t * Sets the output line of this assignment statement.\n\t * @param line the line number in the output.\n\t */\n\tpublic void setOutputLine(int line) {\n\t\toutputLine = line;\n\t}\n\n\t/**\n\t * Optimizes this AssignmentStatement (Phase I): <br>\n\t *\n\t * Peephole optimization: local simplifications of code, e.g.\n\t * (x and true --&gt; x), (x or not x --&gt; true), etc. <br>\n\t * Duplicate code removal: a hash table of all values computed in the\n\t * circuit is kept. If some value is computed twice, then one of the\n\t * duplicates is removed and replaced with direct access to the other\n\t * wire.<br>\n\t * For more information see documation files.\n\t *\n\t */\n\tpublic void optimizePhaseI() {\n\t\t// the statement have to have an output line inorder to be able to sort \n\t\t// input pins and refer to the output gate.\n\t\t// NOTE that this assignment of outputLine may not be the final one \n\t\t//  (refer to the optimization phase II and circuit writing).\n\t\t// \n\t\toutputLine = Program.getLineNumber();\n\n\t\tboolean statementChanged = true;\n\n\t\tdo {\n\t\t\t// tracks if there where changes is this AssignmentStatment\n\t\t\tif (rhs.hasUnaryInput()) // if (this has unary exp as input)\n\t\t\t {\n\t\t\t\trhs.combineUnaryInput();\n\t\t\t} else if (rhs.hasSharedInput()) {\n\t\t\t\trhs = rhs.combineSharedInput();\n\t\t\t}\n\t\t\t// NOTE:\n\t\t\t// the following two trasformations can reduce the rhs's arity.\n\t\t\telse if (((OperationExpression) rhs).hasConstantInput())\n\t\t\t//if (this has constant input)\n\t\t\t {\n\t\t\t\t//combine the input into the gate;\n\t\t\t\trhs = rhs.combineConstInput();\n\t\t\t} else if (rhs.hasEqualInputs()) {\n\t\t\t\t//combine equal inputs into one.\n\t\t\t\trhs = rhs.combineEqualInputs();\n\t\t\t} else {\n\t\t\t\tstatementChanged = false;\n\t\t\t}\n\t\t} while (statementChanged); //while (there are changes \n\t\t                            //in this AssignmentStatmenet);\n\n\t\tif (rhs.isComplexIDOrNeg()) {\n\t\t\trhs = rhs.simplify();\n\t\t}\n\n\t\tif (rhs.isConstant()) { // if the optimized \n\t\t\t                    // gate returns a constant result\n\t\t\trhs = rhs.getConstantOutput();\n\t\t}\n\n\t\trhs.sortInputs();\n\n\t\tif (Optimizer.containsGateNegGate(rhs)) {\n\t\t\trhs = Optimizer.getReference(rhs);\n\t\t} else {\n\t\t\tOptimizer.addGate(rhs, lhs);\n\t\t}\n\t}\n\n\t/**\n\t * Second phase of the optimization: Dead code elimination.\n\t * This statement adds to the new function-body, only if\n\t * it is relevant the computation of the output\n\t * pins of the circuit ( acording to a list of the needed statements that\n\t * was assembled in earlier stage ).\n\t * @param newBody the new function-body.\n\t */\n\tpublic void optimizePhaseII(Vector newBody) {\n\t\tif (Optimizer.isUsed(this)) {\n\t\t\tnewBody.add(this);\n\t\t}\n\t}\n\n\t/**\n\t * Adds this AssignmentStatement to the list of statements that are\n\t * needed to compute the output pins of the output circuit, if this\n\t * AssigmentStatement IS indeed needed. The list is stored in\n\t * Optimizer data structure.\n\t */\n\tpublic void buildUsedStatementsHash() {\n\t\tif (lhs.isOutput()) {\n\t\t\tOptimizer.putUsedStatement(this);\n\t\t}\n\n\t\tif (Optimizer.isUsed(this)) {\n\t\t\tVector v = rhs.getLvalExpressionInputs();\n\n\t\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\t\tStatement as =\n\t\t\t\t\t((LvalExpression) (v.elementAt(i))).getAssigningStatement();\n\t\t\t\tOptimizer.putUsedStatement(as);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Unique vars transformations.\n\t */\n\tpublic Statement uniqueVars() {\n\t\trhs.changeReference(Function.getVars());\n\n\t\t// get the last referance existing\n\t\tlhs = Function.getVar(lhs);\n\n\t\tif (lhs.getAssigningStatement() != this) {\n\t\t\tFunction.addVar(lhs); //.getName(), lhs.getType(), lhs.isOutput());\n\n\t\t\t// get the new ref to lhs\n\t\t\tlhs = Function.getVar(lhs);\n\n\t\t\tlhs.setAssigningStatement(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns true iff rhs if an UnaryOpExpression.\n\t * @return true iff rhs if an UnaryOpExpression.\n\t */\n\tpublic boolean hasUnaryOperator() {\n\t\treturn rhs instanceof UnaryOpExpression;\n\t}\n\n\t/**\n\t * Returns a replica this statement.\n\t * @return a replica this statement.\n\t */\n\tpublic Statement duplicate() {\n\t\treturn new AssignmentStatement(lhs /*.duplicate() no need*/,\n\t\t                               (OperationExpression) rhs.duplicate());\n\t}\n}", "class_id": 0, "repo": "gianpyc/MobileFairPlay", "file": "InterestCastApp/src/SFE/Compiler/AssignmentStatement.java", "last_update_at": "2018-09-19T14:53:20+00:00", "question_id": "865b5199ce355f47e8ff094868c884548a839a3c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AssignmentStatement extends Statement implements OutputWriter,\n                                                              Optimize\n{\n\t//~ Instance fields --------------------------------------------------------\n\t// data members\n\t/*\n\t * An LvalExpression which is the LHS of the assignment.\n\t */\n\tprivate LvalExpression lhs;\n\t/*\n\t * An OperationExpression which is the RHS of the assignment expression.\n\t */\n\tprivate OperationExpression rhs;\n\t/*\n\t * The line number of this assignment statement in the output circuit.\n\t * This number may vary form one transformation to another.\n\t */\n\tprivate int outputLine = -1;\n\t//~ Constructors -----------------------------------------------------------\n\t/**\n\t * Constructs a new AssignmentStatement from a given lhs and rhs.\n\t * @param lhs An LvalExpression which is the LHS of the assignment.\n\t * @param rhs An OperationExpression which is the RHS of the assignment\n\t * expression.\n\t */\n\tpublic AssignmentStatement(LvalExpression lhs, OperationExpression rhs) {\n\t\tthis.lhs     = lhs;\n\t\tthis.rhs     = rhs;\n\t\tthis.lhs.setAssigningStatement(this);\n\t}\n\t//~ Methods ----------------------------------------------------------------\n\t/**\n\t * Transforms this multibit AssignmentStatement into singlebit Statements\n\t * and returns a BlockStatement containing the result.\n\t * @param obj not used (null).\n\t * @return BlockStatement containing singlebit Statements\n\t *                 of this AssignmentStatement.\n\t */\n\tpublic BlockStatement multi2SingleBit(Object obj) {\n\t\treturn ((Multi2SingleBit) rhs).multi2SingleBit(this);\n\t}\n\t/**\n\t * Returns a string representation of this AssignmentStatement.\n\t * @return a string representation of this AssignmentStatement.\n\t */\n\tpublic String toString() {\n\t\treturn lhs.toString() + '=' + rhs.toString() + \"\\n\";\n\t}\n\t/**\n\t * Returns this AssignmentStatement's rhs.\n\t * @return this AssignmentStatement's rhs.\n\t */\n\tpublic OperationExpression getRHS() {\n\t\treturn rhs;\n\t}\n\t/**\n\t * Returns this AssignmentStatement's lhs.\n\t * @return this AssignmentStatement's lhs.\n\t */\n\tpublic LvalExpression getLHS() {\n\t\treturn lhs;\n\t}\n\t/**\n\t * Prints this AssignmentStatement into the circuit.\n\t * @param circuit the circuit output file.\n\t */\n\tpublic void toCircuit(PrintWriter circuit) {\n\t\toutputLine = Program.getLineNumber();\n\t\tcircuit.print(outputLine + \" \" + ((lhs.isOutput()) ? \"output \" : \"\"));\n\t\t((OutputWriter) rhs).toCircuit(circuit);\n\t\tcircuit.println(((lhs.isOutput()) ? (\"\\t//\" + lhs.getName()) : \"\"));\n\t}\n\t/**\n\t * Returns an int that represents the line number of this\n\t * assignmnet statement in the output circuit.\n\t * @return an int that represents the line number of this\n\t * assignmnet statement in the output circuit.\n\t */\n\tpublic int getOutputLine() {\n\t\treturn outputLine;\n\t}\n\t/**\n\t * Sets the output line of this assignment statement.\n\t * @param line the line number in the output.\n\t */\n\tpublic void setOutputLine(int line) {\n\t\toutputLine = line;\n\t}\n\t/**\n\t * Optimizes this AssignmentStatement (Phase I): <br>\n\t *\n\t * Peephole optimization: local simplifications of code, e.g.\n\t * (x and true --&gt; x), (x or not x --&gt; true), etc. <br>\n\t * Duplicate code removal: a hash table of all values computed in the\n\t * circuit is kept. If some value is computed twice, then one of the\n\t * duplicates is removed and replaced with direct access to the other\n\t * wire.<br>\n\t * For more information see documation files.\n\t *\n\t */\n\tpublic void optimizePhaseI() {\n\t\t// the statement have to have an output line inorder to be able to sort \n\t\t// input pins and refer to the output gate.\n\t\t// NOTE that this assignment of outputLine may not be the final one \n\t\t//  (refer to the optimization phase II and circuit writing).\n\t\t// \n\t\toutputLine = Program.getLineNumber();\n\t\tboolean statementChanged = true;\n\t\tdo {\n\t\t\t// tracks if there where changes is this AssignmentStatment\n\t\t\tif (rhs.hasUnaryInput()) // if (this has unary exp as input)\n\t\t\t {\n\t\t\t\trhs.combineUnaryInput();\n\t\t\t} else if (rhs.hasSharedInput()) {\n\t\t\t\trhs = rhs.combineSharedInput();\n\t\t\t}\n\t\t\t// NOTE:\n\t\t\t// the following two trasformations can reduce the rhs's arity.\n\t\t\telse if (((OperationExpression) rhs).hasConstantInput())\n\t\t\t//if (this has constant input)\n\t\t\t {\n\t\t\t\t//combine the input into the gate;\n\t\t\t\trhs = rhs.combineConstInput();\n\t\t\t} else if (rhs.hasEqualInputs()) {\n\t\t\t\t//combine equal inputs into one.\n\t\t\t\trhs = rhs.combineEqualInputs();\n\t\t\t} else {\n\t\t\t\tstatementChanged = false;\n\t\t\t}\n\t\t} while (statementChanged); //while (there are changes \n\t\t                            //in this AssignmentStatmenet);\n\t\tif (rhs.isComplexIDOrNeg()) {\n\t\t\trhs = rhs.simplify();\n\t\t}\n\t\tif (rhs.isConstant()) { // if the optimized \n\t\t\t                    // gate returns a constant result\n\t\t\trhs = rhs.getConstantOutput();\n\t\t}\n\t\trhs.sortInputs();\n\t\tif (Optimizer.containsGateNegGate(rhs)) {\n\t\t\trhs = Optimizer.getReference(rhs);\n\t\t} else {\n\t\t\tOptimizer.addGate(rhs, lhs);\n\t\t}\n\t}\n\t/**\n\t * Second phase of the optimization: Dead code elimination.\n\t * This statement adds to the new function-body, only if\n\t * it is relevant the computation of the output\n\t * pins of the circuit ( acording to a list of the needed statements that\n\t * was assembled in earlier stage ).\n\t * @param newBody the new function-body.\n\t */\n\tpublic void optimizePhaseII(Vector newBody) {\n\t\tif (Optimizer.isUsed(this)) {\n\t\t\tnewBody.add(this);\n\t\t}\n\t}\n\t/**\n\t * Adds this AssignmentStatement to the list of statements that are\n\t * needed to compute the output pins of the output circuit, if this\n\t * AssigmentStatement IS indeed needed. The list is stored in\n\t * Optimizer data structure.\n\t */\n\tpublic void buildUsedStatementsHash() {\n\t\tif (lhs.isOutput()) {\n\t\t\tOptimizer.putUsedStatement(this);\n\t\t}\n\t\tif (Optimizer.isUsed(this)) {\n\t\t\tVector v = rhs.getLvalExpressionInputs();\n\t\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\t\tStatement as =\n\t\t\t\t\t((LvalExpression) (v.elementAt(i))).getAssigningStatement();\n\t\t\t\tOptimizer.putUsedStatement(as);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Unique vars transformations.\n\t */\n\tpublic Statement uniqueVars() {\n\t\trhs.changeReference(Function.getVars());\n\t\t// get the last referance existing\n\t\tlhs = Function.getVar(lhs);\n\t\tif (lhs.getAssigningStatement() != this) {\n\t\t\tFunction.addVar(lhs); //.getName(), lhs.getType(), lhs.isOutput());\n\t\t\t// get the new ref to lhs\n\t\t\tlhs = Function.getVar(lhs);\n\t\t\tlhs.setAssigningStatement(this);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Returns true iff rhs if an UnaryOpExpression.\n\t * @return true iff rhs if an UnaryOpExpression.\n\t */\n\tpublic boolean hasUnaryOperator() {\n\t\treturn rhs instanceof UnaryOpExpression;\n\t}\n\t/**\n\t * Returns a replica this statement.\n\t * @return a replica this statement.\n\t */\n\tpublic Statement duplicate() {\n\t\treturn new AssignmentStatement(lhs /*.duplicate() no need*/,\n\t\t                               (OperationExpression) rhs.duplicate());\n\t}\n"]], "pred": {"ppl": 2.540888547897339, "ppl_lower": 2.752286911010742, "ppl/lowercase_ppl": -1.0857020289026567, "ppl/zlib": 0.0004394504438566538, "Min_5.0% Prob": 7.546268537932751, "Min_10.0% Prob": 5.897142700120514, "Min_20.0% Prob": 4.0396775872099635, "Min_30.0% Prob": 2.973082871803271, "Min_40.0% Prob": 2.299538507328931, "Min_50.0% Prob": 1.8586825327820158, "Min_60.0% Prob": 1.5539289009050872}}
{"hexsha": "a6fba4ccef37c7f2c5a66c2f83f6382098182572", "ext": "java", "lang": "Java", "content": "public class LocalDateTimeField extends CustomField<LocalDateTime> {\n\n    private final DateField legacyDateField = new DateField();\n\n    @Override\n    protected void setInternalValue(LocalDateTime newValue) {\n        super.setInternalValue(newValue);\n        if (newValue == null) {\n            legacyDateField.setValue(null);\n        } else {\n            Instant instant = newValue.atZone(ZoneId.systemDefault()).toInstant();\n            legacyDateField.setValue(Date.from(instant));\n        }\n    }\n    \n     /**\n     * Sets the resolution for UI.\n     * \n     * The default resolution is {@link Resolution#SECOND}.\n     * \n     * @param resolution\n     *            the resolution to set.\n     */\n    public void setResolution(Resolution resolution) {\n        legacyDateField.setResolution(resolution);\n    }\n\n    @Override\n    protected Component initContent() {\n        legacyDateField.addValueChangeListener(e -> {\n            Date value = legacyDateField.getValue();\n            if (value == null) {\n                setValue(null);\n            } else {\n                setValue(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()));\n            }\n        });\n        legacyDateField.setImmediate(true);\n        legacyDateField.setResolution(Resolution.SECOND);\n        return legacyDateField;\n    }\n\n    @Override\n    public Class<? extends LocalDateTime> getType() {\n        return LocalDateTime.class;\n    }\n\n}", "class_id": 0, "repo": "mstahv/date8field", "file": "date8field/src/main/java/org/vaadin/addon/date8field/LocalDateTimeField.java", "last_update_at": "2018-09-17T10:05:04+00:00", "question_id": "a6fba4ccef37c7f2c5a66c2f83f6382098182572", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocalDateTimeField extends CustomField<LocalDateTime> {\n    private final DateField legacyDateField = new DateField();\n    @Override\n    protected void setInternalValue(LocalDateTime newValue) {\n        super.setInternalValue(newValue);\n        if (newValue == null) {\n            legacyDateField.setValue(null);\n        } else {\n            Instant instant = newValue.atZone(ZoneId.systemDefault()).toInstant();\n            legacyDateField.setValue(Date.from(instant));\n        }\n    }\n     /**\n     * Sets the resolution for UI.\n     * \n     * The default resolution is {@link Resolution#SECOND}.\n     * \n     * @param resolution\n     *            the resolution to set.\n     */\n    public void setResolution(Resolution resolution) {\n        legacyDateField.setResolution(resolution);\n    }\n    @Override\n    protected Component initContent() {\n        legacyDateField.addValueChangeListener(e -> {\n            Date value = legacyDateField.getValue();\n            if (value == null) {\n                setValue(null);\n            } else {\n                setValue(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()));\n            }\n        });\n        legacyDateField.setImmediate(true);\n        legacyDateField.setResolution(Resolution.SECOND);\n        return legacyDateField;\n    }\n    @Override\n    public Class<? extends LocalDateTime> getType() {\n        return LocalDateTime.class;\n    }\n"]], "pred": {"ppl": 1.7009470462799072, "ppl_lower": 2.0070438385009766, "ppl/lowercase_ppl": -1.3115255018234844, "ppl/zlib": 0.0010796446788503013, "Min_5.0% Prob": 5.989101370175679, "Min_10.0% Prob": 4.0418645530133634, "Min_20.0% Prob": 2.4998570112763225, "Min_30.0% Prob": 1.7366810987836547, "Min_40.0% Prob": 1.3250187470158874, "Min_50.0% Prob": 1.0599757510979466, "Min_60.0% Prob": 0.886126086922429}}
{"hexsha": "eea2fe90e591f7fd2932edfcc7457e1e1e602b06", "ext": "java", "lang": "Java", "content": "public abstract class BaseObjectEnabler implements LwM2mObjectEnabler {\n\n    final int id;\n    private NotifySender notifySender;\n    private ObjectModel objectModel;\n\n    public BaseObjectEnabler(int id, ObjectModel objectModel) {\n        this.id = id;\n        this.objectModel = objectModel;\n    }\n\n    @Override\n    public synchronized int getId() {\n        return id;\n    }\n\n    @Override\n    public synchronized ObjectModel getObjectModel() {\n        return objectModel;\n    }\n\n    @Override\n    public synchronized CreateResponse create(ServerIdentity identity, CreateRequest request) {\n        if (!identity.isSystem()) {\n            // we can not create new instance on single object\n            if (objectModel != null && !objectModel.multiple) {\n                return CreateResponse.methodNotAllowed();\n            }\n\n            if (id == LwM2mId.SECURITY) {\n                return CreateResponse.notFound();\n            }\n        }\n\n        // TODO we could do a validation of request.getObjectInstance() by comparing with resourceSpec information.\n\n        return doCreate(request);\n    }\n\n    protected CreateResponse doCreate(CreateRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return CreateResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized ReadResponse read(ServerIdentity identity, ReadRequest request) {\n        LwM2mPath path = request.getPath();\n\n        // read is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer()) {\n            return ReadResponse.methodNotAllowed();\n        }\n\n        if (!identity.isSystem()) {\n            // read the security object is forbidden\n            if (id == LwM2mId.SECURITY) {\n                return ReadResponse.notFound();\n            }\n\n            // check if the resource is readable.\n            if (path.isResource()) {\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isReadable()) {\n                    return ReadResponse.methodNotAllowed();\n                }\n            }\n        }\n\n        return doRead(identity, request);\n\n        // TODO we could do a validation of response.getContent by comparing with the spec.\n    }\n\n    protected ReadResponse doRead(ServerIdentity identity, ReadRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return ReadResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized WriteResponse write(ServerIdentity identity, WriteRequest request) {\n        LwM2mPath path = request.getPath();\n\n        // write is not supported for bootstrap, use bootstrap write\n        if (identity.isLwm2mBootstrapServer()) {\n            return WriteResponse.methodNotAllowed();\n        }\n\n        // write the security object is forbidden\n        if (LwM2mId.SECURITY == id && !identity.isSystem()) {\n            return WriteResponse.notFound();\n        }\n\n        if (path.isResource()) {\n            // resource write:\n            // check if the resource is writable\n            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isWritable()) {\n                    return WriteResponse.methodNotAllowed();\n                }\n            }\n        } else if (path.isObjectInstance()) {\n            // instance write:\n            // check if all resources are writable\n            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM\n                ObjectModel model = getObjectModel();\n                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {\n                    ResourceModel resourceModel = model.resources.get(writeResourceId);\n                    if (null != resourceModel && !resourceModel.operations.isWritable()) {\n                        return WriteResponse.methodNotAllowed();\n                    }\n                }\n            }\n\n            if (request.isReplaceRequest()) {\n                // REPLACE\n                // check, if all mandatory writable resources are provided\n                // Collect all mandatory writable resource IDs from the model\n                Set<Integer> mandatoryResources = new HashSet<>();\n                for (ResourceModel resourceModel : getObjectModel().resources.values()) {\n                    if (resourceModel.mandatory && (LwM2mId.SECURITY == id || resourceModel.operations.isWritable()))\n                        mandatoryResources.add(resourceModel.id);\n                }\n                // Afterwards remove the provided resource IDs from that set\n                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {\n                    mandatoryResources.remove(writeResourceId);\n                }\n                if (!mandatoryResources.isEmpty()) {\n                    return WriteResponse.badRequest(\"mandatory writable resources missing!\");\n                }\n            }\n        }\n\n        // TODO we could do a validation of request.getNode() by comparing with resourceSpec information\n\n        return doWrite(identity, request);\n    }\n\n    protected WriteResponse doWrite(ServerIdentity identity, WriteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return WriteResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized BootstrapWriteResponse write(ServerIdentity identity, BootstrapWriteRequest request) {\n\n        // We should not get a bootstrapWriteRequest from a LWM2M server\n        if (!identity.isLwm2mBootstrapServer()) {\n            return BootstrapWriteResponse.internalServerError(\"bootstrap write request from LWM2M server\");\n        }\n\n        return doWrite(identity, request);\n    }\n\n    protected BootstrapWriteResponse doWrite(ServerIdentity identity, BootstrapWriteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return BootstrapWriteResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized DeleteResponse delete(ServerIdentity identity, DeleteRequest request) {\n        if (!identity.isLwm2mBootstrapServer() && !identity.isSystem()) {\n\n            // delete the security object is forbidden\n            if (id == LwM2mId.SECURITY) {\n                return DeleteResponse.notFound();\n            }\n\n            // a resource can not be deleted\n            LwM2mPath path = request.getPath();\n            if (path.isResource()) {\n                return DeleteResponse.methodNotAllowed();\n            }\n\n            // we can not delete instance on single object\n            if (objectModel != null && !objectModel.multiple) {\n                return DeleteResponse.methodNotAllowed();\n            }\n        }\n\n        return doDelete(request);\n    }\n\n    protected DeleteResponse doDelete(DeleteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return DeleteResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized ExecuteResponse execute(ServerIdentity identity, ExecuteRequest request) {\n        LwM2mPath path = request.getPath();\n\n        // execute is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer()) {\n            return ExecuteResponse.methodNotAllowed();\n        }\n\n        // execute on security object is forbidden\n        if (id == LwM2mId.SECURITY) {\n            return ExecuteResponse.notFound();\n        }\n\n        // only resource could be executed\n        if (!path.isResource()) {\n            return ExecuteResponse.badRequest(null);\n        }\n\n        // check if the resource is writable\n        ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n        if (resourceModel != null && !resourceModel.operations.isExecutable()) {\n            return ExecuteResponse.methodNotAllowed();\n        }\n\n        return doExecute(request);\n    }\n\n    protected ExecuteResponse doExecute(ExecuteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return ExecuteResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized WriteAttributesResponse writeAttributes(ServerIdentity identity,\n            WriteAttributesRequest request) {\n        // TODO should be implemented here to be available for all object enabler\n        // This should be a not implemented error, but this is not defined in the spec.\n        return WriteAttributesResponse.internalServerError(\"not implemented\");\n    }\n\n    @Override\n    public synchronized DiscoverResponse discover(ServerIdentity identity, DiscoverRequest request) {\n\n        if (identity.isLwm2mBootstrapServer()) {\n            // discover is not supported for bootstrap\n            return DiscoverResponse.methodNotAllowed();\n        }\n\n        if (id == LwM2mId.SECURITY) {\n            return DiscoverResponse.notFound();\n        }\n\n        LwM2mPath path = request.getPath();\n        if (path.isObject()) {\n\n            // Manage discover on object\n            Link[] ObjectLinks = LinkFormatHelper.getObjectDescription(getObjectModel(), null);\n            return DiscoverResponse.success(ObjectLinks);\n\n        } else if (path.isObjectInstance()) {\n\n            // Manage discover on instance\n            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))\n                return DiscoverResponse.notFound();\n\n            Link instanceLink = LinkFormatHelper.getInstanceDescription(getObjectModel(),\n                    path.getObjectInstanceId(), null);\n            return DiscoverResponse.success(new Link[] { instanceLink });\n\n        } else if (path.isResource()) {\n            // Manage discover on resource\n            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))\n                return DiscoverResponse.notFound();\n\n            ResourceModel resourceModel = getObjectModel().resources.get(path.getResourceId());\n            if (resourceModel == null)\n                return DiscoverResponse.notFound();\n\n            Link resourceLink = LinkFormatHelper.getResourceDescription(getObjectModel().id,\n                    path.getObjectInstanceId(), resourceModel, null);\n            return DiscoverResponse.success(new Link[] { resourceLink });\n        }\n        return DiscoverResponse.badRequest(null);\n    }\n\n    @Override\n    public synchronized ObserveResponse observe(ServerIdentity identity, ObserveRequest request) {\n        LwM2mPath path = request.getPath();\n\n        // observe is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer())\n            return ObserveResponse.methodNotAllowed();\n\n        if (!identity.isSystem()) {\n            // observe or read of the security object is forbidden\n            if (id == LwM2mId.SECURITY)\n                return ObserveResponse.notFound();\n\n            // check if the resource is readable.\n            if (path.isResource()) {\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isReadable())\n                    return ObserveResponse.methodNotAllowed();\n            }\n        }\n        return doObserve(identity, request);\n    }\n\n    protected ObserveResponse doObserve(ServerIdentity identity, ObserveRequest request) {\n        ReadResponse readResponse = this.read(identity, new ReadRequest(request.getPath().toString()));\n        return new ObserveResponse(readResponse.getCode(), readResponse.getContent(), null, null,\n                   readResponse.getErrorMessage());\n    }\n\n    @Override\n    public void setNotifySender(NotifySender sender) {\n        notifySender = sender;\n    }\n\n    public NotifySender getNotifySender() {\n        return notifySender;\n    }\n}", "class_id": 0, "repo": "rkimsb2/leshan", "file": "leshan-client-core/src/main/java/org/eclipse/leshan/client/resource/BaseObjectEnabler.java", "last_update_at": "2018-08-29T13:11:50+00:00", "question_id": "eea2fe90e591f7fd2932edfcc7457e1e1e602b06", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class BaseObjectEnabler implements LwM2mObjectEnabler {\n    final int id;\n    private NotifySender notifySender;\n    private ObjectModel objectModel;\n    public BaseObjectEnabler(int id, ObjectModel objectModel) {\n        this.id = id;\n        this.objectModel = objectModel;\n    }\n    @Override\n    public synchronized int getId() {\n        return id;\n    }\n    @Override\n    public synchronized ObjectModel getObjectModel() {\n        return objectModel;\n    }\n    @Override\n    public synchronized CreateResponse create(ServerIdentity identity, CreateRequest request) {\n        if (!identity.isSystem()) {\n            // we can not create new instance on single object\n            if (objectModel != null && !objectModel.multiple) {\n                return CreateResponse.methodNotAllowed();\n            }\n            if (id == LwM2mId.SECURITY) {\n                return CreateResponse.notFound();\n            }\n        }\n        // TODO we could do a validation of request.getObjectInstance() by comparing with resourceSpec information.\n        return doCreate(request);\n    }\n    protected CreateResponse doCreate(CreateRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return CreateResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized ReadResponse read(ServerIdentity identity, ReadRequest request) {\n        LwM2mPath path = request.getPath();\n        // read is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer()) {\n            return ReadResponse.methodNotAllowed();\n        }\n        if (!identity.isSystem()) {\n            // read the security object is forbidden\n            if (id == LwM2mId.SECURITY) {\n                return ReadResponse.notFound();\n            }\n            // check if the resource is readable.\n            if (path.isResource()) {\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isReadable()) {\n                    return ReadResponse.methodNotAllowed();\n                }\n            }\n        }\n        return doRead(identity, request);\n        // TODO we could do a validation of response.getContent by comparing with the spec.\n    }\n    protected ReadResponse doRead(ServerIdentity identity, ReadRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return ReadResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized WriteResponse write(ServerIdentity identity, WriteRequest request) {\n        LwM2mPath path = request.getPath();\n        // write is not supported for bootstrap, use bootstrap write\n        if (identity.isLwm2mBootstrapServer()) {\n            return WriteResponse.methodNotAllowed();\n        }\n        // write the security object is forbidden\n        if (LwM2mId.SECURITY == id && !identity.isSystem()) {\n            return WriteResponse.notFound();\n        }\n        if (path.isResource()) {\n            // resource write:\n            // check if the resource is writable\n            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isWritable()) {\n                    return WriteResponse.methodNotAllowed();\n                }\n            }\n        } else if (path.isObjectInstance()) {\n            // instance write:\n            // check if all resources are writable\n            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM\n                ObjectModel model = getObjectModel();\n                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {\n                    ResourceModel resourceModel = model.resources.get(writeResourceId);\n                    if (null != resourceModel && !resourceModel.operations.isWritable()) {\n                        return WriteResponse.methodNotAllowed();\n                    }\n                }\n            }\n            if (request.isReplaceRequest()) {\n                // REPLACE\n                // check, if all mandatory writable resources are provided\n                // Collect all mandatory writable resource IDs from the model\n                Set<Integer> mandatoryResources = new HashSet<>();\n                for (ResourceModel resourceModel : getObjectModel().resources.values()) {\n                    if (resourceModel.mandatory && (LwM2mId.SECURITY == id || resourceModel.operations.isWritable()))\n                        mandatoryResources.add(resourceModel.id);\n                }\n                // Afterwards remove the provided resource IDs from that set\n                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {\n                    mandatoryResources.remove(writeResourceId);\n                }\n                if (!mandatoryResources.isEmpty()) {\n                    return WriteResponse.badRequest(\"mandatory writable resources missing!\");\n                }\n            }\n        }\n        // TODO we could do a validation of request.getNode() by comparing with resourceSpec information\n        return doWrite(identity, request);\n    }\n    protected WriteResponse doWrite(ServerIdentity identity, WriteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return WriteResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized BootstrapWriteResponse write(ServerIdentity identity, BootstrapWriteRequest request) {\n        // We should not get a bootstrapWriteRequest from a LWM2M server\n        if (!identity.isLwm2mBootstrapServer()) {\n            return BootstrapWriteResponse.internalServerError(\"bootstrap write request from LWM2M server\");\n        }\n        return doWrite(identity, request);\n    }\n    protected BootstrapWriteResponse doWrite(ServerIdentity identity, BootstrapWriteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return BootstrapWriteResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized DeleteResponse delete(ServerIdentity identity, DeleteRequest request) {\n        if (!identity.isLwm2mBootstrapServer() && !identity.isSystem()) {\n            // delete the security object is forbidden\n            if (id == LwM2mId.SECURITY) {\n                return DeleteResponse.notFound();\n            }\n            // a resource can not be deleted\n            LwM2mPath path = request.getPath();\n            if (path.isResource()) {\n                return DeleteResponse.methodNotAllowed();\n            }\n            // we can not delete instance on single object\n            if (objectModel != null && !objectModel.multiple) {\n                return DeleteResponse.methodNotAllowed();\n            }\n        }\n        return doDelete(request);\n    }\n    protected DeleteResponse doDelete(DeleteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return DeleteResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized ExecuteResponse execute(ServerIdentity identity, ExecuteRequest request) {\n        LwM2mPath path = request.getPath();\n        // execute is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer()) {\n            return ExecuteResponse.methodNotAllowed();\n        }\n        // execute on security object is forbidden\n        if (id == LwM2mId.SECURITY) {\n            return ExecuteResponse.notFound();\n        }\n        // only resource could be executed\n        if (!path.isResource()) {\n            return ExecuteResponse.badRequest(null);\n        }\n        // check if the resource is writable\n        ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n        if (resourceModel != null && !resourceModel.operations.isExecutable()) {\n            return ExecuteResponse.methodNotAllowed();\n        }\n        return doExecute(request);\n    }\n    protected ExecuteResponse doExecute(ExecuteRequest request) {\n        // This should be a not implemented error, but this is not defined in the spec.\n        return ExecuteResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized WriteAttributesResponse writeAttributes(ServerIdentity identity,\n            WriteAttributesRequest request) {\n        // TODO should be implemented here to be available for all object enabler\n        // This should be a not implemented error, but this is not defined in the spec.\n        return WriteAttributesResponse.internalServerError(\"not implemented\");\n    }\n    @Override\n    public synchronized DiscoverResponse discover(ServerIdentity identity, DiscoverRequest request) {\n        if (identity.isLwm2mBootstrapServer()) {\n            // discover is not supported for bootstrap\n            return DiscoverResponse.methodNotAllowed();\n        }\n        if (id == LwM2mId.SECURITY) {\n            return DiscoverResponse.notFound();\n        }\n        LwM2mPath path = request.getPath();\n        if (path.isObject()) {\n            // Manage discover on object\n            Link[] ObjectLinks = LinkFormatHelper.getObjectDescription(getObjectModel(), null);\n            return DiscoverResponse.success(ObjectLinks);\n        } else if (path.isObjectInstance()) {\n            // Manage discover on instance\n            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))\n                return DiscoverResponse.notFound();\n            Link instanceLink = LinkFormatHelper.getInstanceDescription(getObjectModel(),\n                    path.getObjectInstanceId(), null);\n            return DiscoverResponse.success(new Link[] { instanceLink });\n        } else if (path.isResource()) {\n            // Manage discover on resource\n            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))\n                return DiscoverResponse.notFound();\n            ResourceModel resourceModel = getObjectModel().resources.get(path.getResourceId());\n            if (resourceModel == null)\n                return DiscoverResponse.notFound();\n            Link resourceLink = LinkFormatHelper.getResourceDescription(getObjectModel().id,\n                    path.getObjectInstanceId(), resourceModel, null);\n            return DiscoverResponse.success(new Link[] { resourceLink });\n        }\n        return DiscoverResponse.badRequest(null);\n    }\n    @Override\n    public synchronized ObserveResponse observe(ServerIdentity identity, ObserveRequest request) {\n        LwM2mPath path = request.getPath();\n        // observe is not supported for bootstrap\n        if (identity.isLwm2mBootstrapServer())\n            return ObserveResponse.methodNotAllowed();\n        if (!identity.isSystem()) {\n            // observe or read of the security object is forbidden\n            if (id == LwM2mId.SECURITY)\n                return ObserveResponse.notFound();\n            // check if the resource is readable.\n            if (path.isResource()) {\n                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());\n                if (resourceModel != null && !resourceModel.operations.isReadable())\n                    return ObserveResponse.methodNotAllowed();\n            }\n        }\n        return doObserve(identity, request);\n    }\n    protected ObserveResponse doObserve(ServerIdentity identity, ObserveRequest request) {\n        ReadResponse readResponse = this.read(identity, new ReadRequest(request.getPath().toString()));\n        return new ObserveResponse(readResponse.getCode(), readResponse.getContent(), null, null,\n                   readResponse.getErrorMessage());\n    }\n    @Override\n    public void setNotifySender(NotifySender sender) {\n        notifySender = sender;\n    }\n    public NotifySender getNotifySender() {\n        return notifySender;\n    }\n"]], "pred": {"ppl": 1.7774770259857178, "ppl_lower": 2.058119535446167, "ppl/lowercase_ppl": -1.2548662142431386, "ppl/zlib": 0.00028334726980747875, "Min_5.0% Prob": 5.745201653125239, "Min_10.0% Prob": 4.212265076590519, "Min_20.0% Prob": 2.678559982601334, "Min_30.0% Prob": 1.8904124867974543, "Min_40.0% Prob": 1.4324115851033288, "Min_50.0% Prob": 1.149898384238453, "Min_60.0% Prob": 0.9594700151578133}}
{"hexsha": "b3055d7d81d5f283a7a5236ae5c7ecae299b4935", "ext": "java", "lang": "Java", "content": "public class PongGameView extends GameView {\n\n\tpublic static final float HALF_PI = (float) (Math.PI * 0.5f);\n\n\tprotected static final int MIN_MOVEMENT = 2;\n\n\tprivate Racket leftRacket;\n\tprivate Racket rightRacket;\n\tprivate Racket activeRacket;\n\tprivate Ball ball;\n\tprivate int leftPoints;\n\tprivate int rightPoints;\n\n\tprivate int pixelSize = 10;\n\tprivate Vector2d dimens;\n\tprivate Vector2d dimensHalf;\n\n\tprivate final Paint paint = new Paint();\n\tprivate Paint textPaint = new Paint();\n\n\tprivate Random random = new Random();\n\n\tpublic PongGameView(Context context) {\n\t\tsuper(context);\n\n\t\tVector2d racketSize = new Vector2d(pixelSize, 4 * pixelSize);\n\t\tfloat ballRadius = pixelSize;\n\t\tleftRacket = new Racket(racketSize);\n\t\trightRacket = new Racket(racketSize);\n\t\tactiveRacket = leftRacket;\n\n\t\tball = new Ball(ballRadius);\n\n\t\ttextPaint = new Paint();\n\t\ttextPaint.setColor(Color.WHITE);\n\t\ttextPaint.setTextAlign(Align.CENTER);\n\t\ttextPaint.setTextSize(64);\n\t\ttextPaint.setAntiAlias(true);\n\n\t\tpaint.setColor(Color.WHITE);\n\t\tpaint.setAntiAlias(true);\n\n\t\tsetOnTouchListener(new OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\n\t\t\t\tswitch (event.getActionMasked()) {\n\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_POINTER_DOWN: {\n\t\t\t\t\tint pointerIndex = event.getActionIndex();\n\n\t\t\t\t\tfloat x = event.getX(pointerIndex);\n\t\t\t\t\tfloat y = event.getY(pointerIndex);\n\n\t\t\t\t\tRacket racket = (x < getWidth() * 0.5f) ? leftRacket\n\t\t\t\t\t\t: rightRacket;\n\t\t\t\t\tracket.setCenterY(y - dimensHalf.y);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tcase MotionEvent.ACTION_POINTER_UP: {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\tfor (int idx = 0; idx < event.getPointerCount(); idx++) {\n\t\t\t\t\t\tfloat x = event.getX(idx);\n\t\t\t\t\t\tfloat y = event.getY(idx);\n\t\t\t\t\t\tRacket racket = (x < getWidth() * 0.5f) ? leftRacket\n\t\t\t\t\t\t\t: rightRacket;\n\n\t\t\t\t\t\tVector2d center = racket.getCenter();\n\t\t\t\t\t\tif (Math.abs(center.x + dimensHalf.x - x) > MIN_MOVEMENT\n\t\t\t\t\t\t\t|| Math.abs(center.y + dimensHalf.y - y) > MIN_MOVEMENT) {\n\t\t\t\t\t\t\tracket.setCenterY(y - dimensHalf.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tLog.i(LOG_TAG, \"unhandled action\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tprotected void onUpdate() {\n\t\tfloat dt = getTimeDelta();\n\t\tball.update(dt);\n\t\tactiveRacket = (ball.getVelocity().x > 0) ? rightRacket : leftRacket;\n\t\t//leftRacket.update(dt);\n\t\t//rightRacket.update(dt);\n\t}\n\n\t@Override\n\tprotected void onRender(Canvas canvas) {\n\t\tcanvas.drawColor(Color.BLACK);\n\n\t\tcanvas.save();\n\n\t\tcanvas.translate(dimensHalf.x, dimensHalf.y);\n\n\t\t// stroke(0.25f);\n\t\t// fill(0.5f);\n\n\t\tdrawPoints(canvas);\n\t\tdrawNet(canvas);\n\n\t\t// fill(0.25f);\n\t\t// noStroke();\n\n\t\tdrawBall(canvas);\n\t\tdrawRackets(canvas);\n\n\t\tcanvas.restore();\n\t}\n\n\t@Override\n\tpublic void surfaceCreated(SurfaceHolder holder) {\n\t\tdimens = new Vector2d(getWidth(), getHeight());\n\t\tdimensHalf = new Vector2d(0.5f * dimens.x, 0.5f * dimens.y);\n\n\t\tleftRacket.setCenter(new Vector2d(-dimensHalf.x * 0.8f, 0));\n\t\trightRacket.setCenter(new Vector2d(dimensHalf.x * 0.8f, 0));\n\n\t\tball.resetRandomly();\n\n\t\tsuper.surfaceCreated(holder);\n\t}\n\n\tvoid drawNet(Canvas canvas) {\n\t\tcanvas.drawLine(0, -dimensHalf.y, 0, dimensHalf.y, paint);\n\t}\n\n\tvoid drawPoints(Canvas canvas) {\n\t\tfloat quarterWidth = dimens.x * 0.25f;\n\t\tfloat quarterHeight = dimens.y * 0.25f;\n\t\tcanvas.drawText(String.valueOf(leftPoints),\n\t\t\t-quarterWidth,\n\t\t\t-quarterHeight,\n\t\t\ttextPaint);\n\t\tcanvas.drawText(String.valueOf(rightPoints),\n\t\t\tquarterWidth,\n\t\t\t-quarterHeight,\n\t\t\ttextPaint);\n\t}\n\n\tvoid drawBall(Canvas canvas) {\n\t\t// fill(0.75f);\n\t\tball.draw(canvas);\n\t}\n\n\tvoid drawRackets(Canvas canvas) {\n\t\tleftRacket.draw(canvas);\n\t\trightRacket.draw(canvas);\n\t}\n\n\tprivate class Racket {\n\t\tprivate static final float SPEED = 1000f;\n\t\tprivate Vector2d center = new Vector2d(0, 0);\n\t\tprivate Vector2d size;\n\n\t\tpublic Racket(Vector2d size) {\n\t\t\tthis.size = size;\n\t\t}\n\n\t\tpublic Vector2d getCenter() {\n\t\t\treturn center;\n\t\t}\n\n\t\tpublic void setCenter(Vector2d center) {\n\t\t\tthis.center = center;\n\t\t}\n\n\t\tpublic void setCenterY(float y) {\n\t\t\tcenter.y = y;\n\t\t}\n\n\t\t// public void update(float dt) {\n\t\t// if (keyPressed && (key == CODED) && activeRacket == this) {\n\t\t// float dy = 0;\n\t\t// if (keyCode == UP) {\n\t\t// dy = -SPEED * dt;\n\t\t// } else if (keyCode == DOWN) {\n\t\t// dy = SPEED * dt;\n\t\t// }\n\t\t// center.y += dy;\n\t\t// center.y = constrain(center.y,\n\t\t// size.y - dimensHalf.y,\n\t\t// dimensHalf.y - size.y);\n\t\t// }\n\t\t// }\n\t\t\n\t\t\n\n\t\tpublic boolean intersects(Rectangle otherRect) {\n\t\t\tRectangle thisRect = Rectangle.fromCentered(center, size);\n\t\t\treturn thisRect.intersects(otherRect);\n\t\t}\n\n\t\tpublic void draw(Canvas canvas) {\n\t\t\t// fill((activeRacket == this) ? 0.75f : 0.5f);\n\n\t\t\tfloat left = center.x - size.x;\n\t\t\tfloat top = center.y - size.y;\n\t\t\tfloat right = center.x + size.x;\n\t\t\tfloat bottom = center.y + size.y;\n\n\t\t\tcanvas.drawRect(left, top, right, bottom, paint);\n\t\t}\n\t}\n\n\tprivate class Ball {\n\t\tVector2d center;\n\t\tVector2d velocity;\n\t\tfloat radius;\n\n\t\tstatic final float SPEED = 500f;\n\n\t\tpublic Ball(float radius) {\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tpublic void update(float dt) {\n\t\t\tfloat dx = dt * velocity.x;\n\t\t\tfloat dy = dt * velocity.y;\n\t\t\tfloat margin = radius - Math.abs(velocity.x);\n\n\t\t\tif (center.x - margin < -dimensHalf.x) {\n\t\t\t\tresetRandomly();\n\t\t\t} else if (center.x + margin > dimensHalf.x) {\n\t\t\t\tresetRandomly();\n\t\t\t}\n\n\t\t\tif (Math.abs(center.y + dy) + radius > dimensHalf.y) {\n\t\t\t\tdy *= -1;\n\t\t\t\tvelocity.y *= -1;\n\t\t\t} else if (activeRacketIntersects(new Vector2d(center.x + dx,\n\t\t\t\tcenter.y + dy))) {\n\t\t\t\tdx *= -1;\n\t\t\t\tvelocity.x *= -1;\n\t\t\t}\n\n\t\t\tif (center.x + dx - radius < -dimensHalf.x\n\t\t\t\t&& center.x - radius >= -dimensHalf.x) {\n\t\t\t\trightPoints++;\n\t\t\t} else if (center.x + dx + radius > dimensHalf.x\n\t\t\t\t&& center.x + radius <= dimensHalf.x) {\n\t\t\t\tleftPoints++;\n\t\t\t}\n\n\t\t\tcenter.x += dx;\n\t\t\tcenter.y += dy;\n\t\t}\n\n\t\tprivate boolean activeRacketIntersects(Vector2d center) {\n\t\t\tRectangle rect = Rectangle.fromCentered(center, new Vector2d(\n\t\t\t\tradius, radius));\n\t\t\treturn activeRacket.intersects(rect);\n\t\t}\n\n\t\tpublic Vector2d getVelocity() {\n\t\t\treturn velocity;\n\t\t}\n\n\t\tpublic void resetRandomly() {\n\t\t\tcenter = new Vector2d(0, (random.nextFloat() * dimens.y)\n\t\t\t\t- dimensHalf.y);\n\n\t\t\tfloat angle = ((int) random.nextInt(4) + 0.5f) * HALF_PI;\n\t\t\tvelocity = new Vector2d(SPEED * (float) Math.cos(angle), SPEED\n\t\t\t\t* (float) Math.sin(angle));\n\t\t}\n\n\t\tpublic void draw(Canvas canvas) {\n\t\t\tfloat left = center.x - radius;\n\t\t\tfloat top = center.y - radius;\n\t\t\tfloat right = center.x + radius;\n\t\t\tfloat bottom = center.y + radius;\n\t\t\tcanvas.drawRect(left, top, right, bottom, paint);\n\t\t}\n\t}\n\n\tprivate static class Rectangle {\n\t\tprivate Vector2d corner;\n\t\tprivate Vector2d size;\n\n\t\tpublic Rectangle(Vector2d corner, Vector2d size) {\n\t\t\tthis.corner = corner;\n\t\t\tthis.size = size;\n\t\t}\n\n\t\tpublic static Rectangle fromCentered(Vector2d center, Vector2d radius) {\n\t\t\treturn new Rectangle(new Vector2d(center.x - radius.x, center.y\n\t\t\t\t- radius.y), new Vector2d(2 * radius.x, 2 * radius.y));\n\t\t}\n\n\t\tpublic boolean intersects(Rectangle other) {\n\t\t\treturn (this.corner.x + this.size.x >= other.corner.x)\n\t\t\t\t&& (other.corner.x + other.size.x >= this.corner.x)\n\t\t\t\t&& (this.corner.y + this.size.y >= other.corner.y)\n\t\t\t\t&& (other.corner.y + other.size.y >= this.corner.y);\n\t\t}\n\t}\n\n\tprivate static class Vector2d {\n\t\tpublic float x;\n\t\tpublic float y;\n\n\t\tpublic Vector2d(float x, float y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}", "class_id": 0, "repo": "bzamecnik/pong-android", "file": "PongAndroid/src/me/zamecnik/android/pong/PongGameView.java", "last_update_at": "2018-06-28T10:42:42+00:00", "question_id": "b3055d7d81d5f283a7a5236ae5c7ecae299b4935", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PongGameView extends GameView {\n\tpublic static final float HALF_PI = (float) (Math.PI * 0.5f);\n\tprotected static final int MIN_MOVEMENT = 2;\n\tprivate Racket leftRacket;\n\tprivate Racket rightRacket;\n\tprivate Racket activeRacket;\n\tprivate Ball ball;\n\tprivate int leftPoints;\n\tprivate int rightPoints;\n\tprivate int pixelSize = 10;\n\tprivate Vector2d dimens;\n\tprivate Vector2d dimensHalf;\n\tprivate final Paint paint = new Paint();\n\tprivate Paint textPaint = new Paint();\n\tprivate Random random = new Random();\n\tpublic PongGameView(Context context) {\n\t\tsuper(context);\n\t\tVector2d racketSize = new Vector2d(pixelSize, 4 * pixelSize);\n\t\tfloat ballRadius = pixelSize;\n\t\tleftRacket = new Racket(racketSize);\n\t\trightRacket = new Racket(racketSize);\n\t\tactiveRacket = leftRacket;\n\t\tball = new Ball(ballRadius);\n\t\ttextPaint = new Paint();\n\t\ttextPaint.setColor(Color.WHITE);\n\t\ttextPaint.setTextAlign(Align.CENTER);\n\t\ttextPaint.setTextSize(64);\n\t\ttextPaint.setAntiAlias(true);\n\t\tpaint.setColor(Color.WHITE);\n\t\tpaint.setAntiAlias(true);\n\t\tsetOnTouchListener(new OnTouchListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tswitch (event.getActionMasked()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tcase MotionEvent.ACTION_POINTER_DOWN: {\n\t\t\t\t\tint pointerIndex = event.getActionIndex();\n\t\t\t\t\tfloat x = event.getX(pointerIndex);\n\t\t\t\t\tfloat y = event.getY(pointerIndex);\n\t\t\t\t\tRacket racket = (x < getWidth() * 0.5f) ? leftRacket\n\t\t\t\t\t\t: rightRacket;\n\t\t\t\t\tracket.setCenterY(y - dimensHalf.y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tcase MotionEvent.ACTION_POINTER_UP: {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\tfor (int idx = 0; idx < event.getPointerCount(); idx++) {\n\t\t\t\t\t\tfloat x = event.getX(idx);\n\t\t\t\t\t\tfloat y = event.getY(idx);\n\t\t\t\t\t\tRacket racket = (x < getWidth() * 0.5f) ? leftRacket\n\t\t\t\t\t\t\t: rightRacket;\n\t\t\t\t\t\tVector2d center = racket.getCenter();\n\t\t\t\t\t\tif (Math.abs(center.x + dimensHalf.x - x) > MIN_MOVEMENT\n\t\t\t\t\t\t\t|| Math.abs(center.y + dimensHalf.y - y) > MIN_MOVEMENT) {\n\t\t\t\t\t\t\tracket.setCenterY(y - dimensHalf.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tLog.i(LOG_TAG, \"unhandled action\");\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\t@Override\n\tprotected void onUpdate() {\n\t\tfloat dt = getTimeDelta();\n\t\tball.update(dt);\n\t\tactiveRacket = (ball.getVelocity().x > 0) ? rightRacket : leftRacket;\n\t\t//leftRacket.update(dt);\n\t\t//rightRacket.update(dt);\n\t}\n\t@Override\n\tprotected void onRender(Canvas canvas) {\n\t\tcanvas.drawColor(Color.BLACK);\n\t\tcanvas.save();\n\t\tcanvas.translate(dimensHalf.x, dimensHalf.y);\n\t\t// stroke(0.25f);\n\t\t// fill(0.5f);\n\t\tdrawPoints(canvas);\n\t\tdrawNet(canvas);\n\t\t// fill(0.25f);\n\t\t// noStroke();\n\t\tdrawBall(canvas);\n\t\tdrawRackets(canvas);\n\t\tcanvas.restore();\n\t}\n\t@Override\n\tpublic void surfaceCreated(SurfaceHolder holder) {\n\t\tdimens = new Vector2d(getWidth(), getHeight());\n\t\tdimensHalf = new Vector2d(0.5f * dimens.x, 0.5f * dimens.y);\n\t\tleftRacket.setCenter(new Vector2d(-dimensHalf.x * 0.8f, 0));\n\t\trightRacket.setCenter(new Vector2d(dimensHalf.x * 0.8f, 0));\n\t\tball.resetRandomly();\n\t\tsuper.surfaceCreated(holder);\n\t}\n\tvoid drawNet(Canvas canvas) {\n\t\tcanvas.drawLine(0, -dimensHalf.y, 0, dimensHalf.y, paint);\n\t}\n\tvoid drawPoints(Canvas canvas) {\n\t\tfloat quarterWidth = dimens.x * 0.25f;\n\t\tfloat quarterHeight = dimens.y * 0.25f;\n\t\tcanvas.drawText(String.valueOf(leftPoints),\n\t\t\t-quarterWidth,\n\t\t\t-quarterHeight,\n\t\t\ttextPaint);\n\t\tcanvas.drawText(String.valueOf(rightPoints),\n\t\t\tquarterWidth,\n\t\t\t-quarterHeight,\n\t\t\ttextPaint);\n\t}\n\tvoid drawBall(Canvas canvas) {\n\t\t// fill(0.75f);\n\t\tball.draw(canvas);\n\t}\n\tvoid drawRackets(Canvas canvas) {\n\t\tleftRacket.draw(canvas);\n\t\trightRacket.draw(canvas);\n\t}\n\tprivate class Racket {\n\t\tprivate static final float SPEED = 1000f;\n\t\tprivate Vector2d center = new Vector2d(0, 0);\n\t\tprivate Vector2d size;\n\t\tpublic Racket(Vector2d size) {\n\t\t\tthis.size = size;\n\t\t}\n\t\tpublic Vector2d getCenter() {\n\t\t\treturn center;\n\t\t}\n\t\tpublic void setCenter(Vector2d center) {\n\t\t\tthis.center = center;\n\t\t}\n\t\tpublic void setCenterY(float y) {\n\t\t\tcenter.y = y;\n\t\t}\n\t\t// public void update(float dt) {\n\t\t// if (keyPressed && (key == CODED) && activeRacket == this) {\n\t\t// float dy = 0;\n\t\t// if (keyCode == UP) {\n\t\t// dy = -SPEED * dt;\n\t\t// } else if (keyCode == DOWN) {\n\t\t// dy = SPEED * dt;\n\t\t// }\n\t\t// center.y += dy;\n\t\t// center.y = constrain(center.y,\n\t\t// size.y - dimensHalf.y,\n\t\t// dimensHalf.y - size.y);\n\t\t// }\n\t\t// }\n\t\t\n\t\t\n\t\tpublic boolean intersects(Rectangle otherRect) {\n\t\t\tRectangle thisRect = Rectangle.fromCentered(center, size);\n\t\t\treturn thisRect.intersects(otherRect);\n\t\t}\n\t\tpublic void draw(Canvas canvas) {\n\t\t\t// fill((activeRacket == this) ? 0.75f : 0.5f);\n\t\t\tfloat left = center.x - size.x;\n\t\t\tfloat top = center.y - size.y;\n\t\t\tfloat right = center.x + size.x;\n\t\t\tfloat bottom = center.y + size.y;\n\t\t\tcanvas.drawRect(left, top, right, bottom, paint);\n\t\t}\n\t}\n\tprivate class Ball {\n\t\tVector2d center;\n\t\tVector2d velocity;\n\t\tfloat radius;\n\t\tstatic final float SPEED = 500f;\n\t\tpublic Ball(float radius) {\n\t\t\tthis.radius = radius;\n\t\t}\n\t\tpublic void update(float dt) {\n\t\t\tfloat dx = dt * velocity.x;\n\t\t\tfloat dy = dt * velocity.y;\n\t\t\tfloat margin = radius - Math.abs(velocity.x);\n\t\t\tif (center.x - margin < -dimensHalf.x) {\n\t\t\t\tresetRandomly();\n\t\t\t} else if (center.x + margin > dimensHalf.x) {\n\t\t\t\tresetRandomly();\n\t\t\t}\n\t\t\tif (Math.abs(center.y + dy) + radius > dimensHalf.y) {\n\t\t\t\tdy *= -1;\n\t\t\t\tvelocity.y *= -1;\n\t\t\t} else if (activeRacketIntersects(new Vector2d(center.x + dx,\n\t\t\t\tcenter.y + dy))) {\n\t\t\t\tdx *= -1;\n\t\t\t\tvelocity.x *= -1;\n\t\t\t}\n\t\t\tif (center.x + dx - radius < -dimensHalf.x\n\t\t\t\t&& center.x - radius >= -dimensHalf.x) {\n\t\t\t\trightPoints++;\n\t\t\t} else if (center.x + dx + radius > dimensHalf.x\n\t\t\t\t&& center.x + radius <= dimensHalf.x) {\n\t\t\t\tleftPoints++;\n\t\t\t}\n\t\t\tcenter.x += dx;\n\t\t\tcenter.y += dy;\n\t\t}\n\t\tprivate boolean activeRacketIntersects(Vector2d center) {\n\t\t\tRectangle rect = Rectangle.fromCentered(center, new Vector2d(\n\t\t\t\tradius, radius));\n\t\t\treturn activeRacket.intersects(rect);\n\t\t}\n\t\tpublic Vector2d getVelocity() {\n\t\t\treturn velocity;\n\t\t}\n\t\tpublic void resetRandomly() {\n\t\t\tcenter = new Vector2d(0, (random.nextFloat() * dimens.y)\n\t\t\t\t- dimensHalf.y);\n\t\t\tfloat angle = ((int) random.nextInt(4) + 0.5f) * HALF_PI;\n\t\t\tvelocity = new Vector2d(SPEED * (float) Math.cos(angle), SPEED\n\t\t\t\t* (float) Math.sin(angle));\n\t\t}\n\t\tpublic void draw(Canvas canvas) {\n\t\t\tfloat left = center.x - radius;\n\t\t\tfloat top = center.y - radius;\n\t\t\tfloat right = center.x + radius;\n\t\t\tfloat bottom = center.y + radius;\n\t\t\tcanvas.drawRect(left, top, right, bottom, paint);\n\t\t}\n\t}\n\tprivate static class Rectangle {\n\t\tprivate Vector2d corner;\n\t\tprivate Vector2d size;\n\t\tpublic Rectangle(Vector2d corner, Vector2d size) {\n\t\t\tthis.corner = corner;\n\t\t\tthis.size = size;\n\t\t}\n\t\tpublic static Rectangle fromCentered(Vector2d center, Vector2d radius) {\n\t\t\treturn new Rectangle(new Vector2d(center.x - radius.x, center.y\n\t\t\t\t- radius.y), new Vector2d(2 * radius.x, 2 * radius.y));\n\t\t}\n\t\tpublic boolean intersects(Rectangle other) {\n\t\t\treturn (this.corner.x + this.size.x >= other.corner.x)\n\t\t\t\t&& (other.corner.x + other.size.x >= this.corner.x)\n\t\t\t\t&& (this.corner.y + this.size.y >= other.corner.y)\n\t\t\t\t&& (other.corner.y + other.size.y >= this.corner.y);\n\t\t}\n\t}\n\tprivate static class Vector2d {\n\t\tpublic float x;\n\t\tpublic float y;\n\t\tpublic Vector2d(float x, float y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.5192776918411255, "ppl_lower": 1.6614335775375366, "ppl/lowercase_ppl": -1.2138649499135206, "ppl/zlib": 0.0001947997294725108, "Min_5.0% Prob": 4.291199913211897, "Min_10.0% Prob": 3.15096634275773, "Min_20.0% Prob": 1.9828303986612488, "Min_30.0% Prob": 1.3824507652787992, "Min_40.0% Prob": 1.0434187549783467, "Min_50.0% Prob": 0.8367600603933116, "Min_60.0% Prob": 0.6978613922981505}}
{"hexsha": "4e9c713604e93b2fc61261346cc9243f49640c84", "ext": "java", "lang": "Java", "content": "public class NameGenerator {\n\tprivate static final char[] consos = \"bcdfghjklmnprstvwxyz\".toCharArray();\n\tprivate static final char[] vowels = \"aeiou\".toCharArray();\n\tprivate static final Random r = new Random();\n\t\n\tprivate NameGenerator() {}\n\t\n\tpublic static String getName() {\n\t\tStringBuilder name = new StringBuilder();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tname.append(consos[r.nextInt(consos.length)]);\n\t\t\tname.append(vowels[r.nextInt(vowels.length)]);\n\t\t}\n\t\treturn name.toString();\n\t}\n}", "class_id": 0, "repo": "jpverkamp/wombat-ide", "file": "ide/src/wombat/util/NameGenerator.java", "last_update_at": "2018-05-26T02:59:41+00:00", "question_id": "4e9c713604e93b2fc61261346cc9243f49640c84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NameGenerator {\n\tprivate static final char[] consos = \"bcdfghjklmnprstvwxyz\".toCharArray();\n\tprivate static final char[] vowels = \"aeiou\".toCharArray();\n\tprivate static final Random r = new Random();\n\t\n\tprivate NameGenerator() {}\n\t\n\tpublic static String getName() {\n\t\tStringBuilder name = new StringBuilder();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tname.append(consos[r.nextInt(consos.length)]);\n\t\t\tname.append(vowels[r.nextInt(vowels.length)]);\n\t\t}\n\t\treturn name.toString();\n\t}\n"]], "pred": {"ppl": 1.626703143119812, "ppl_lower": 1.9234293699264526, "ppl/lowercase_ppl": -1.344368562099902, "ppl/zlib": 0.0018713667499792139, "Min_5.0% Prob": 6.077922165393829, "Min_10.0% Prob": 3.750052711542915, "Min_20.0% Prob": 2.2142134513173786, "Min_30.0% Prob": 1.5819785764011054, "Min_40.0% Prob": 1.200321975616472, "Min_50.0% Prob": 0.9738047525457952, "Min_60.0% Prob": 0.8093552011774764}}
{"hexsha": "cb133cf02168fd625662a591a3141d4ce60e1059", "ext": "java", "lang": "Java", "content": "public class SolrSearchSinkTest extends HydratorTestBase {\n  @ClassRule\n  public static final TestConfiguration CONFIG = new TestConfiguration(\"explore.enabled\", false);\n  private static final Schema inputSchema = Schema.recordOf(\n    \"input-record\",\n    Schema.Field.of(\"id\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"office address\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"pincode\", Schema.of(Schema.Type.INT)));\n\n  private static final String VERSION = \"3.2.0\";\n  private static final ArtifactVersion CURRENT_VERSION = new ArtifactVersion(VERSION);\n  private static final ArtifactId BATCH_APP_ARTIFACT_ID = NamespaceId.DEFAULT.artifact(\"data-pipeline\", VERSION);\n  private static final ArtifactSummary ETLBATCH_ARTIFACT =\n    new ArtifactSummary(BATCH_APP_ARTIFACT_ID.getArtifact(), BATCH_APP_ARTIFACT_ID.getVersion());\n  private static final ArtifactRange BATCH_ARTIFACT_RANGE = new ArtifactRange(NamespaceId.DEFAULT.getNamespace(),\n                                                                              \"data-pipeline\",\n                                                                              CURRENT_VERSION, true,\n                                                                              CURRENT_VERSION, true);\n\n\n  @ClassRule\n  public static TemporaryFolder temporaryFolder = new TemporaryFolder();\n  private SolrClient client;\n\n  @BeforeClass\n  public static void setupTest() throws Exception {\n    setupBatchArtifacts(BATCH_APP_ARTIFACT_ID, DataPipelineApp.class);\n\n    Set<ArtifactRange> parents = ImmutableSet.of(BATCH_ARTIFACT_RANGE);\n\n    // add Solr search plugins\n    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"solrsearch-plugins\", \"1.0.0\"), parents,\n                      SolrSearchSink.class, SolrSearchSinkConfig.class);\n  }\n\n  @Ignore\n  public void testBatchSolrSearchSink() throws Exception {\n    client = new HttpSolrClient(\"http://localhost:8983/solr/collection1\");\n    String inputDatasetName = \"solr-batch-input-source\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n\n    QueryResponse queryResponse = client.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n\n    Assert.assertEquals(2, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480002, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    client.shutdown();\n  }\n\n  @Ignore\n  public void testSolrCloudModeSink() throws Exception {\n    CloudSolrClient cloudClient = new CloudSolrClient(\"localhost:2181\");\n    cloudClient.setDefaultCollection(\"collection1\");\n\n    String inputDatasetName = \"solrcloud-batch-input-source\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"SolrCloudSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SOLR_CLOUD_MODE)\n      .put(\"solrHost\", \"localhost:2181\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrCloudSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n\n    QueryResponse queryResponse = cloudClient.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n\n    Assert.assertEquals(2, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480002, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    cloudClient.deleteByQuery(\"*:*\");\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n  @Ignore\n  public void testSolrSinkWithNullValues() throws Exception {\n    Schema nullInputSchema = Schema.recordOf(\n      \"input-record\",\n      Schema.Field.of(\"id\", Schema.nullableOf(Schema.of(Schema.Type.STRING))),\n      Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"office address\", Schema.nullableOf(Schema.of(Schema.Type.STRING))),\n      Schema.Field.of(\"pincode\", Schema.nullableOf(Schema.of(Schema.Type.INT))));\n\n    client = new HttpSolrClient(\"http://localhost:8983/solr/collection1\");\n    String inputDatasetName = \"input-source-with-null\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"100\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", null).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"3\").set(\"firstname\", \"Johnny\").set(\"lastname\", \"Wagh\").set\n        (\"office address\", \"\").set(\"pincode\", 480003).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"\").set(\"firstname\", \"Michael\").set(\"lastname\", \"Hussey\").set\n        (\"office address\", \"WE Lake Side\").set(\"pincode\", 480004).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", null).set(\"firstname\", \"Michael\").set(\"lastname\", \"Clarke\")\n        .set(\"office address\", \"WE Lake Side\").set(\"pincode\", 480005).build());\n    MockSource.writeInput(inputManager, input);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n\n    QueryResponse queryResponse = client.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n\n    Assert.assertEquals(4, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else if (document.get(\"id\").equals(\"2\")) {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n      } else if (document.get(\"id\").equals(\"3\")) {\n        Assert.assertEquals(\"Johnny\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Wagh\", document.get(\"lastname\"));\n        Assert.assertEquals(\"\", document.get(\"address\"));\n        Assert.assertEquals(480003, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"Michael\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Hussey\", document.get(\"lastname\"));\n        Assert.assertEquals(\"WE Lake Side\", document.get(\"address\"));\n        Assert.assertEquals(480004, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    client.shutdown();\n  }\n\n  @Test\n  public void testSolrConnectionWithWrongHost() throws Exception {\n    String inputDatasetName = \"input-source-with-wrong-host\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8984\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSinkWrongHost\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);\n  }\n\n  @Test\n  public void testSolrConnectionWithWrongCollection() throws Exception {\n    String inputDatasetName = \"input-source-with-wrong-collection\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"wrong_collection\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidSingleNodeSolrUrl() {\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983,localhost:8984\", \"collection1\", \"id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testWrongKeyFieldName() {\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983\", \"collection1\", \"wrong_id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidInputDataType() {\n    Schema inputSchema = Schema.recordOf(\n      \"input-record\",\n      Schema.Field.of(\"id\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"office address\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"pincode\", Schema.nullableOf(Schema.of(Schema.Type.BYTES))));\n\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983\", \"collection1\", \"id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n}", "class_id": 0, "repo": "prafullkotecha/hydrator-plugins", "file": "solrsearch-plugins/src/test/java/io/cdap/plugin/SolrSearchSinkTest.java", "last_update_at": "2018-02-28T10:06:21+00:00", "question_id": "cb133cf02168fd625662a591a3141d4ce60e1059", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SolrSearchSinkTest extends HydratorTestBase {\n  @ClassRule\n  public static final TestConfiguration CONFIG = new TestConfiguration(\"explore.enabled\", false);\n  private static final Schema inputSchema = Schema.recordOf(\n    \"input-record\",\n    Schema.Field.of(\"id\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"office address\", Schema.of(Schema.Type.STRING)),\n    Schema.Field.of(\"pincode\", Schema.of(Schema.Type.INT)));\n  private static final String VERSION = \"3.2.0\";\n  private static final ArtifactVersion CURRENT_VERSION = new ArtifactVersion(VERSION);\n  private static final ArtifactId BATCH_APP_ARTIFACT_ID = NamespaceId.DEFAULT.artifact(\"data-pipeline\", VERSION);\n  private static final ArtifactSummary ETLBATCH_ARTIFACT =\n    new ArtifactSummary(BATCH_APP_ARTIFACT_ID.getArtifact(), BATCH_APP_ARTIFACT_ID.getVersion());\n  private static final ArtifactRange BATCH_ARTIFACT_RANGE = new ArtifactRange(NamespaceId.DEFAULT.getNamespace(),\n                                                                              \"data-pipeline\",\n                                                                              CURRENT_VERSION, true,\n                                                                              CURRENT_VERSION, true);\n  @ClassRule\n  public static TemporaryFolder temporaryFolder = new TemporaryFolder();\n  private SolrClient client;\n  @BeforeClass\n  public static void setupTest() throws Exception {\n    setupBatchArtifacts(BATCH_APP_ARTIFACT_ID, DataPipelineApp.class);\n    Set<ArtifactRange> parents = ImmutableSet.of(BATCH_ARTIFACT_RANGE);\n    // add Solr search plugins\n    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"solrsearch-plugins\", \"1.0.0\"), parents,\n                      SolrSearchSink.class, SolrSearchSinkConfig.class);\n  }\n  @Ignore\n  public void testBatchSolrSearchSink() throws Exception {\n    client = new HttpSolrClient(\"http://localhost:8983/solr/collection1\");\n    String inputDatasetName = \"solr-batch-input-source\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n    QueryResponse queryResponse = client.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n    Assert.assertEquals(2, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480002, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    client.shutdown();\n  }\n  @Ignore\n  public void testSolrCloudModeSink() throws Exception {\n    CloudSolrClient cloudClient = new CloudSolrClient(\"localhost:2181\");\n    cloudClient.setDefaultCollection(\"collection1\");\n    String inputDatasetName = \"solrcloud-batch-input-source\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"SolrCloudSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SOLR_CLOUD_MODE)\n      .put(\"solrHost\", \"localhost:2181\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrCloudSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n    QueryResponse queryResponse = cloudClient.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n    Assert.assertEquals(2, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480002, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    cloudClient.deleteByQuery(\"*:*\");\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n  @Ignore\n  public void testSolrSinkWithNullValues() throws Exception {\n    Schema nullInputSchema = Schema.recordOf(\n      \"input-record\",\n      Schema.Field.of(\"id\", Schema.nullableOf(Schema.of(Schema.Type.STRING))),\n      Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"office address\", Schema.nullableOf(Schema.of(Schema.Type.STRING))),\n      Schema.Field.of(\"pincode\", Schema.nullableOf(Schema.of(Schema.Type.INT))));\n    client = new HttpSolrClient(\"http://localhost:8983/solr/collection1\");\n    String inputDatasetName = \"input-source-with-null\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"100\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", null).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"3\").set(\"firstname\", \"Johnny\").set(\"lastname\", \"Wagh\").set\n        (\"office address\", \"\").set(\"pincode\", 480003).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", \"\").set(\"firstname\", \"Michael\").set(\"lastname\", \"Hussey\").set\n        (\"office address\", \"WE Lake Side\").set(\"pincode\", 480004).build(),\n      StructuredRecord.builder(nullInputSchema).set(\"id\", null).set(\"firstname\", \"Michael\").set(\"lastname\", \"Clarke\")\n        .set(\"office address\", \"WE Lake Side\").set(\"pincode\", 480005).build());\n    MockSource.writeInput(inputManager, input);\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);\n    QueryResponse queryResponse = client.query(new SolrQuery(\"*:*\"));\n    SolrDocumentList resultList = queryResponse.getResults();\n    Assert.assertEquals(4, resultList.size());\n    for (SolrDocument document : resultList) {\n      if (document.get(\"id\").equals(\"1\")) {\n        Assert.assertEquals(\"Brett\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Lee\", document.get(\"lastname\"));\n        Assert.assertEquals(\"NE lake side\", document.get(\"address\"));\n        Assert.assertEquals(480001, document.get(\"pincode\"));\n      } else if (document.get(\"id\").equals(\"2\")) {\n        Assert.assertEquals(\"John\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Ray\", document.get(\"lastname\"));\n        Assert.assertEquals(\"SE lake side\", document.get(\"address\"));\n      } else if (document.get(\"id\").equals(\"3\")) {\n        Assert.assertEquals(\"Johnny\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Wagh\", document.get(\"lastname\"));\n        Assert.assertEquals(\"\", document.get(\"address\"));\n        Assert.assertEquals(480003, document.get(\"pincode\"));\n      } else {\n        Assert.assertEquals(\"Michael\", document.get(\"firstname\"));\n        Assert.assertEquals(\"Hussey\", document.get(\"lastname\"));\n        Assert.assertEquals(\"WE Lake Side\", document.get(\"address\"));\n        Assert.assertEquals(480004, document.get(\"pincode\"));\n      }\n    }\n    // Clean the indexes\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    client.shutdown();\n  }\n  @Test\n  public void testSolrConnectionWithWrongHost() throws Exception {\n    String inputDatasetName = \"input-source-with-wrong-host\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8984\")\n      .put(\"collectionName\", \"collection1\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSinkWrongHost\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);\n  }\n  @Test\n  public void testSolrConnectionWithWrongCollection() throws Exception {\n    String inputDatasetName = \"input-source-with-wrong-collection\";\n    ETLStage source = new ETLStage(\"source\", MockSource.getPlugin(inputDatasetName));\n    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()\n      .put(Constants.Reference.REFERENCE_NAME, \"BatchSolrSink\")\n      .put(\"solrMode\", SolrSearchSinkConfig.SINGLE_NODE_MODE)\n      .put(\"solrHost\", \"localhost:8983\")\n      .put(\"collectionName\", \"wrong_collection\")\n      .put(\"keyField\", \"id\")\n      .put(\"batchSize\", \"1000\")\n      .put(\"outputFieldMappings\", \"office address:address\")\n      .build();\n    ETLStage sink = new ETLStage(\"SolrSink\", new ETLPlugin(\"SolrSearch\", BatchSink.PLUGIN_TYPE, sinkConfigproperties,\n                                                           null));\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(source)\n      .addStage(sink)\n      .addConnection(source.getName(), sink.getName())\n      .build();\n    ApplicationId appId = NamespaceId.DEFAULT.app(\"testBatchSolrSink\");\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    DataSetManager<Table> inputManager = getDataset(inputDatasetName);\n    List<StructuredRecord> input = ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"id\", \"1\").set(\"firstname\", \"Brett\").set(\"lastname\", \"Lee\").set\n        (\"office address\", \"NE lake side\").set(\"pincode\", 480001).build(),\n      StructuredRecord.builder(inputSchema).set(\"id\", \"2\").set(\"firstname\", \"John\").set(\"lastname\", \"Ray\").set\n        (\"office address\", \"SE lake side\").set(\"pincode\", 480002).build()\n    );\n    MockSource.writeInput(inputManager, input);\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidSingleNodeSolrUrl() {\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983,localhost:8984\", \"collection1\", \"id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testWrongKeyFieldName() {\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983\", \"collection1\", \"wrong_id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n  @Test(expected = IllegalArgumentException.class)\n  public void testInvalidInputDataType() {\n    Schema inputSchema = Schema.recordOf(\n      \"input-record\",\n      Schema.Field.of(\"id\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"firstname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"lastname\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"office address\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"pincode\", Schema.nullableOf(Schema.of(Schema.Type.BYTES))));\n    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig\n      (\"SolrSink\", SolrSearchSinkConfig.SINGLE_NODE_MODE, \"localhost:8983\", \"collection1\", \"id\",\n       \"office address:address\", \"1000\");\n    SolrSearchSink sinkObject = new SolrSearchSink(config);\n    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);\n    sinkObject.configurePipeline(configurer);\n  }\n"]], "pred": {"ppl": 1.593100905418396, "ppl_lower": 2.63451886177063, "ppl/lowercase_ppl": -2.0801744462524434, "ppl/zlib": 0.00020282333272386905, "Min_5.0% Prob": 5.230797655442181, "Min_10.0% Prob": 3.6748594349505854, "Min_20.0% Prob": 2.2177673579723227, "Min_30.0% Prob": 1.5361170175369658, "Min_40.0% Prob": 1.1606917649115867, "Min_50.0% Prob": 0.9313956348912575, "Min_60.0% Prob": 0.7769495936212788}}
{"hexsha": "cfcf3e66836f58db4b0e1571534047ea29d7fccd", "ext": "java", "lang": "Java", "content": "public class SftpFileProgressMonitor implements SftpProgressMonitor {\n\n\n    public long max; // the final count (i.e. length of file to transfer).\n    public String destinationFileName;\n\n\n    private long count; // the number of bytes transferred so far\n    private int direction; // either SftpOverWriteByteChannel.PUT or get\n    private String stringBeingTransferred;\n\n\n    public void init(int i, String src, String destinationFileName, long max) {\n        this.direction = i;\n        this.stringBeingTransferred = src;\n        this.destinationFileName = destinationFileName;\n        this.max = max;\n    }\n\n\n    // Called periodically as more data is transfered.\n    public boolean count(long count) {\n\n        this.count = count;\n        // true if the transfer should go on, false if the transfer should be cancelled.\n        return true;\n    }\n\n    // called when the transfer ended, either because all the data was transferred,\n    // or because the transfer was cancelled.\n    public void end() {\n\n    }\n\n    public long getCount() {\n        return count;\n    }\n\n\n}", "class_id": 0, "repo": "gerardnico/niofs-sftp", "file": "src/main/java/net/bytle/niofs/sftp/SftpFileProgressMonitor.java", "last_update_at": "2018-11-28T10:12:17+00:00", "question_id": "cfcf3e66836f58db4b0e1571534047ea29d7fccd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SftpFileProgressMonitor implements SftpProgressMonitor {\n    public long max; // the final count (i.e. length of file to transfer).\n    public String destinationFileName;\n    private long count; // the number of bytes transferred so far\n    private int direction; // either SftpOverWriteByteChannel.PUT or get\n    private String stringBeingTransferred;\n    public void init(int i, String src, String destinationFileName, long max) {\n        this.direction = i;\n        this.stringBeingTransferred = src;\n        this.destinationFileName = destinationFileName;\n        this.max = max;\n    }\n    // Called periodically as more data is transfered.\n    public boolean count(long count) {\n        this.count = count;\n        // true if the transfer should go on, false if the transfer should be cancelled.\n        return true;\n    }\n    // called when the transfer ended, either because all the data was transferred,\n    // or because the transfer was cancelled.\n    public void end() {\n    }\n    public long getCount() {\n        return count;\n    }\n"]], "pred": {"ppl": 3.2026147842407227, "ppl_lower": 3.4779231548309326, "ppl/lowercase_ppl": -1.0708505332043274, "ppl/zlib": 0.00261565751959561, "Min_5.0% Prob": 7.801963549393874, "Min_10.0% Prob": 6.037439125555533, "Min_20.0% Prob": 4.454551774805243, "Min_30.0% Prob": 3.464209152431023, "Min_40.0% Prob": 2.754829689047553, "Min_50.0% Prob": 2.2747545369725297, "Min_60.0% Prob": 1.93144382130016}}
{"hexsha": "69714de209eac7d35849ab31462dada94a0867a1", "ext": "java", "lang": "Java", "content": "public final class MatcherItrator extends AbstractSpliterator<CharSequence>{\n\tprivate final Matcher matcher;\n\n\tpublic MatcherItrator(Matcher m){\n\t\tsuper(m.regionEnd() - m.regionStart(), ORDERED|NONNULL);\n\t\tmatcher = m;\n\t}\n\t@Override\n\tpublic boolean tryAdvance(Consumer<? super CharSequence> c){\n\t\tif (!matcher.find()) return false;\n\t\tc.accept(matcher.group());\n\t\treturn true;\n\t}\n}", "class_id": 0, "repo": "yipuran/yipuran-core", "file": "src/main/java/org/yipuran/regex/MatcherItrator.java", "last_update_at": "2018-07-31T12:42:53+00:00", "question_id": "69714de209eac7d35849ab31462dada94a0867a1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class MatcherItrator extends AbstractSpliterator<CharSequence>{\n\tprivate final Matcher matcher;\n\tpublic MatcherItrator(Matcher m){\n\t\tsuper(m.regionEnd() - m.regionStart(), ORDERED|NONNULL);\n\t\tmatcher = m;\n\t}\n\t@Override\n\tpublic boolean tryAdvance(Consumer<? super CharSequence> c){\n\t\tif (!matcher.find()) return false;\n\t\tc.accept(matcher.group());\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 2.123720169067383, "ppl_lower": 2.890575647354126, "ppl/lowercase_ppl": -1.4093187298026735, "ppl/zlib": 0.0030369731756324935, "Min_5.0% Prob": 7.04937203725179, "Min_10.0% Prob": 5.33862069936899, "Min_20.0% Prob": 3.4472763996857863, "Min_30.0% Prob": 2.4800037191464352, "Min_40.0% Prob": 1.8962187611569579, "Min_50.0% Prob": 1.5015491821492712, "Min_60.0% Prob": 1.2566873923392048}}
{"hexsha": "363a1695ab14700775449ce4db08e09ece6ff906", "ext": "java", "lang": "Java", "content": "public class CurrencyFormat {\n\n    public static String rupiah(Float nominal)\n    {\n        DecimalFormat kursIndonesia = (DecimalFormat) DecimalFormat.getCurrencyInstance();\n        DecimalFormatSymbols formatRp = new DecimalFormatSymbols();\n\n        formatRp.setCurrencySymbol(\"Rp\");\n        formatRp.setMonetaryDecimalSeparator(',');\n        formatRp.setGroupingSeparator('.');\n\n        kursIndonesia.setDecimalFormatSymbols(formatRp);\n        return kursIndonesia.format(nominal);\n    }\n\n}", "class_id": 0, "repo": "messirichard/skripsilaundry", "file": "notation-laundryanku-android/app/src/main/java/id/placeholderlabs/laundry/util/CurrencyFormat.java", "last_update_at": "2018-09-07T15:52:52+00:00", "question_id": "363a1695ab14700775449ce4db08e09ece6ff906", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CurrencyFormat {\n    public static String rupiah(Float nominal)\n    {\n        DecimalFormat kursIndonesia = (DecimalFormat) DecimalFormat.getCurrencyInstance();\n        DecimalFormatSymbols formatRp = new DecimalFormatSymbols();\n        formatRp.setCurrencySymbol(\"Rp\");\n        formatRp.setMonetaryDecimalSeparator(',');\n        formatRp.setGroupingSeparator('.');\n        kursIndonesia.setDecimalFormatSymbols(formatRp);\n        return kursIndonesia.format(nominal);\n    }\n"]], "pred": {"ppl": 1.6745457649230957, "ppl_lower": 2.949681520462036, "ppl/lowercase_ppl": -2.0981749773224005, "ppl/zlib": 0.00228115904150069, "Min_5.0% Prob": 5.826522895268032, "Min_10.0% Prob": 4.07003561088017, "Min_20.0% Prob": 2.4505620105513213, "Min_30.0% Prob": 1.7019560748541898, "Min_40.0% Prob": 1.3024487123856772, "Min_50.0% Prob": 1.0374141711205855, "Min_60.0% Prob": 0.8610797304612458}}
{"hexsha": "6dfd7ed680985674c7a28d61ba08a9ffd7895c65", "ext": "java", "lang": "Java", "content": "public class Guess1 {\n   public static void main(String[] args) {\n   final int SECRET_NUMBER = 535;\n   int guess;\n   Scanner kb = new Scanner(System.in);\n   \n   // initialize the border condition variable\n   System.out.print(\"Guess the secret number: \");\n   guess = kb.nextInt();\n   \n   while (guess != SECRET_NUMBER)  {\n      \n      System.out.print(\"Guess again: \");\n      guess = kb.nextInt();\n   \n   }\n   \n   System.out.println(\"You got it!\");\n        \n   } // main()\n}", "class_id": 0, "repo": "campbe13/JavaSourceSamples360", "file": "fromslides/S08-loops-while/while1Intro/Guess1.java", "last_update_at": "2018-01-05T19:18:40+00:00", "question_id": "6dfd7ed680985674c7a28d61ba08a9ffd7895c65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Guess1 {\n   public static void main(String[] args) {\n   final int SECRET_NUMBER = 535;\n   int guess;\n   Scanner kb = new Scanner(System.in);\n   // initialize the border condition variable\n   System.out.print(\"Guess the secret number: \");\n   guess = kb.nextInt();\n   while (guess != SECRET_NUMBER)  {\n      System.out.print(\"Guess again: \");\n      guess = kb.nextInt();\n   }\n   System.out.println(\"You got it!\");\n   } // main()\n"]], "pred": {"ppl": 2.76397705078125, "ppl_lower": 3.5015809535980225, "ppl/lowercase_ppl": -1.2326652938290812, "ppl/zlib": 0.003807755067302676, "Min_5.0% Prob": 7.591419560568673, "Min_10.0% Prob": 5.913956610361735, "Min_20.0% Prob": 4.132881714451697, "Min_30.0% Prob": 3.108582855539119, "Min_40.0% Prob": 2.4748257461094085, "Min_50.0% Prob": 2.0133399027280316, "Min_60.0% Prob": 1.6868398990085784}}
{"hexsha": "a9b20e9e02b314bf0df27b7338ac21581e2ca8c5", "ext": "java", "lang": "Java", "content": "public class OnePassSignatureVerificationWithPartialLengthLiteralDataRegressionTest {\n\n    /**\n     * Signed and Encrypted Message created with PGPainless 0.2.9.\n     * PGPainless versions 0.2.10 - 0.2.18 fail to decrypt this message, due to it failing to parse the signatures trailing\n     * the literal data. The cause for this was not draining the literal data first before trying to parse the sigs.\n     * This is likely caused by the literal data using a partial length encoding scheme, so the PGPObjectFactory did not yet\n     * reach the signatures packets.\n     *\n     * As a fix, PGPainless now only tries to parse signatures from after the literal data packet, once the literal data\n     * stream gets closed.\n     */\n    public static final String MSG = \"-----BEGIN PGP MESSAGE-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"\\n\" +\n            \"aEY0RHRHcWVYOENCUGRzU0FRZEFVTjJrSkZNb2lJUHhCUEFSWkZodnJxU2FGd090\\n\" +\n            \"c3llR2pkU1l4bS9UdFJRd01JK09PUGJYVjlnUEM3VEZFemlKWmRmL0ZxcUVaQTNV\\n\" +\n            \"ZkhIeEo3Y0hnWlhQWWw1Q29LMU5aSW9NRC9udk1iT1poRjREYmtNdFV2TkpWL3dT\\n\" +\n            \"QVFkQW00b01SQXVVbTdYL1BZUTc3T3Q2ZUxwTWs2VDk3TmhHMzB6RFFDSUMvV1l3\\n\" +\n            \"TTUvZkR4dW1uVW5ucXNwVFVJSmhRMmVYM0I2R2NtVE5ZdXVmSUNIbGZKMU9UQk05\\n\" +\n            \"MklNMkVGWHU1M2x3TVBLYTB1a0IzRWltbmJRNUpCNTBpT2NUeDZCcDJQREJZK0VN\\n\" +\n            \"K29IdDVlUzFzOWxlZjJUNHdCY0w1ejFLU3hQTkRpODh6Skp6dTZ1b3BxMXFwdWVI\\n\" +\n            \"UDFtemYzN0NTY3lJTHpJK0lwRXVUbWwvODdyK294TWVQR3NvR3NwblBuUWFXa0xY\\n\" +\n            \"dzdGVHpnWUJ5SGxyS3gzTGJIT040bDFVbC90dnhMbFBwNE5aRmJQcjQwWlYxb0o4\\n\" +\n            \"eE9JczRTaXpZSTNDUGRXQmlNVXJiaDJRMEFBTkg4aWNyMjhDeUZneDFSenpGdFRZ\\n\" +\n            \"MzVjeE5HSXRRZzRoR3BNUmVOWDdWNHpWOFRsUkFJSEVtaFRCTHpGZXR4eWJCbFJh\\n\" +\n            \"c3l0SUN0eWVydnZiNTQ3V2htK2tDWUxRQUcyOUlwZXUxOWo2MnV1dHJjWm10YWJn\\n\" +\n            \"LzEyTG5HSEczRkxoMGxHTmNOZnd3OXN6VC9zV0RXM2swQ3RCdVpsSmFUVXFLYlY2\\n\" +\n            \"QkRsTjZMWXFvYi9ad01wcDE4WGVuTk5tU2ZsL2JpcHZ0UE1hMk5NdGVuWXV2SGVO\\n\" +\n            \"R2hZK3Q0MFE3NE5OYmJRV1dsVXFqakFYZ3NOaUhsTjhDV2Z3UG82Ykx1OW9PaEFL\\n\" +\n            \"eTgvbFlNL1dlL2hlUFFpVGpqUUVaM3J2OHVDVGdCekFuc2tqazd0bUVOdTdnclJz\\n\" +\n            \"WjBSdzlYelRwTzJlTCtHRmV3VlhOMzNWUzFHVnR5QTMyVFRCd1ZDcStaNEtCMXRX\\n\" +\n            \"MVFIRUlDekc2UldsMkR5djBmZENpc2FoQU5SLzBmQXRrZm0wU3k1R1htWm5pWU9L\\n\" +\n            \"MkhiN2NZeHEzREs1MHowWTN4WkdiemE4L2VUMzlPTG1jMG5DdWQ5cktHaUkya0Er\\n\" +\n            \"a0NDQzF5UUlrek9zZDZlU1pFR1FncFV5UHlxdDRNQUhYeDcxUkFuR0NiWW9OVkRY\\n\" +\n            \"aUQwZ0d0M2lZRHFJV1N0TGErek1xbkJWN085Z3lSZFFVN2lXR25CeW9QNnlXc1Nk\\n\" +\n            \"aVBRSW5RR3RVSFZabU0wQnBwUk45ZUo0QlVJd2RvY0lIRldjZ0xNQjNiYlBDWHVF\\n\" +\n            \"bGl6N1ZPSHBFVWVYVmNWNWl6Z3NVUEJOSVVOZWxHcElrSk5Xa0lSSndMSFVnUlR0\\n\" +\n            \"SEh1ZFMyNnJZeURoU0tGcjdiM01HdWwyVU9GdTFlM0FzK24yVkJjcGN0ZHFtTGxG\\n\" +\n            \"THU3ZGxHMGJ0dHJQVWhaYyt4NjlFenUraTRtamRoZzZyVC9ydnYvRTJmRTRUVlpN\\n\" +\n            \"MGExbk5CUG40UT09\\n\" +\n            \"=mKyE\\n\" +\n            \"-----END PGP MESSAGE-----\";\n\n    public static final String KEY = \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"Comment: 23A2 3010 2038 66BC B390  8598 BB0C CFD4 57D4 DE77\\n\" +\n            \"Comment: xmpp:one@exampletwo.org\\n\" +\n            \"\\n\" +\n            \"lFgEYXQMCRYJKwYBBAHaRw8BAQdA1NhQdMUKkiwSI92ETqlY2lrAt4EbehgzpWMs\\n\" +\n            \"sm1Ke34AAP4sx3S3r0qoNpGyi3o7zfet60xIIkw9qKNdnYQyvouFhRFftBd4bXBw\\n\" +\n            \"Om9uZUBleGFtcGxldHdvLm9yZ4h4BBMWCgAgBQJhdAwJAhsBBRYCAwEABRUKCQgL\\n\" +\n            \"BAsJCAcCHgECGQEACgkQuwzP1FfU3ncAWQD/dUR7rbOpV8H4CTIpDJXiDuWi1vkC\\n\" +\n            \"Rmm5jFQsJlrIzZEA/0aZSEXH3Gj5OdQGy9qKrvqGkq7idjrTkh3gYiWRB+EOnF0E\\n\" +\n            \"YXQMCRIKKwYBBAGXVQEFAQEHQCobua4HJAsmfCB9TFjBSRfP1FEIEht4MMl4rHN4\\n\" +\n            \"eWc0AwEIBwAA/0Tmh56XX8bVDof1VVCdapcCC+LAA3wSH5SfP+EVaIJoD8WIdQQY\\n\" +\n            \"FgoAHQUCYXQMCQIbDAUWAgMBAAUVCgkICwQLCQgHAh4BAAoJELsMz9RX1N533dQB\\n\" +\n            \"ANRojORnaZw224DRVhONAuQazhKZz3e13MhyTFi91BhmAP9chFgUkvpiorQ6I65D\\n\" +\n            \"iCM315VHIvorrIElhKDtYu65CZxYBGF0DAkWCSsGAQQB2kcPAQEHQB3vy1KMKzDG\\n\" +\n            \"/yooOsvfNXtdFh8ROWWth2CZAh1rt3fdAAD+KVMkDED4xf7h1/aAunFAmdZ+xGTo\\n\" +\n            \"uPbTr8vWQMrVUFAUi4jVBBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcC\\n\" +\n            \"HgFfIAQZFgoABgUCYXQMCQAKCRDFaY6lJy4mR/FEAP9dHZi975eqlSdRa5pEn1xz\\n\" +\n            \"TLBfz2mAfWLQEr2kWLLVRAD+JBsyldKsUF8q1m/D/ty0lUUSGslgOhTcEoXxx3yC\\n\" +\n            \"1wwACgkQuwzP1FfU3neefwEA82brBIEKARYD/zHwNEPGLZweZHLPV5Iu9dmBw3l9\\n\" +\n            \"tmoA/RlQYaAKD86S1ZcfPIbjDIZkL9sjFh5tK0+mSl8rv4UH\\n\" +\n            \"=/1RX\\n\" +\n            \"-----END PGP PRIVATE KEY BLOCK-----\";\n\n    public static final String CERT = \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"Comment: FC0A 2CB3 F757 8B26 442C  7091 A7BA 7031 BD1E 0D5F\\n\" +\n            \"Comment: xmpp:one@exampleone.org\\n\" +\n            \"\\n\" +\n            \"mDMEYXQMCRYJKwYBBAHaRw8BAQdA01hwFPFYUpsGGUpf21BUlwoL9tVVAnR3sS+J\\n\" +\n            \"UZSUlka0F3htcHA6b25lQGV4YW1wbGVvbmUub3JniHgEExYKACAFAmF0DAkCGwEF\\n\" +\n            \"FgIDAQAFFQoJCAsECwkIBwIeAQIZAQAKCRCnunAxvR4NX+f7AQCjzT+r25dDlUpp\\n\" +\n            \"tocSQtgEmWZabwB41ykD/XfyBtM0RAD/ba4yYv+f/4mX7u3XpJxkrKFs/bHwyWsR\\n\" +\n            \"VapeUGxhKwa4OARhdAwJEgorBgEEAZdVAQUBAQdAlbrJ+h8CygRFZBsx+Rsm4Kp+\\n\" +\n            \"VCB7yUR2IxOrmiGqUlsDAQgHiHUEGBYKAB0FAmF0DAkCGwwFFgIDAQAFFQoJCAsE\\n\" +\n            \"CwkIBwIeAQAKCRCnunAxvR4NX3bmAP4mTtMWgKl7RkAB/pSLMJ4bbTMSMUJCH/jS\\n\" +\n            \"qz/PNtmVrgD+JLrWg2+hNPAA8zJx8LH73G4YzZMSQ0CBd9nmWRZr3w+4MwRhdAwJ\\n\" +\n            \"FgkrBgEEAdpHDwEBB0BrLuiD0Xb6/N66IehUl77qh/Q0vDa8ack6TcOIwxZsHIjV\\n\" +\n            \"BBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcCHgFfIAQZFgoABgUCYXQM\\n\" +\n            \"CQAKCRD97UDyQowaGe1MAPwJeSe2vkEcMIk711lBbAsambR7D72XVyc0F8maniUy\\n\" +\n            \"LwD8Dbgx8O0bCcd7fcXztfyZe8OtGKQk19fSLd+xp5VThwkACgkQp7pwMb0eDV8y\\n\" +\n            \"aQEA+g10lq+1gkaLBXZbc/mUJ4odIjYBk0JdGgU8oTAZd58A/2UT9C5G9ht/lMhK\\n\" +\n            \"hISFnP6CXwvy6L1XA9bjXQJ0unMF\\n\" +\n            \"=OyZq\\n\" +\n            \"-----END PGP PUBLIC KEY BLOCK-----\";\n\n    @Test\n    public void testDecryptAndVerify_0_2_9_message() throws IOException, PGPException {\n        PGPSecretKeyRing secretKeys = PGPainless.readKeyRing().secretKeyRing(KEY);\n        PGPPublicKeyRing cert = PGPainless.readKeyRing().publicKeyRing(CERT);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        ByteArrayOutputStream dearmored = new ByteArrayOutputStream();\n        ArmoredInputStream armorIn = new ArmoredInputStream(new ByteArrayInputStream(MSG.getBytes(StandardCharsets.UTF_8)));\n        Streams.pipeAll(armorIn, dearmored);\n        armorIn.close();\n\n        ByteArrayInputStream in = new ByteArrayInputStream(dearmored.toByteArray());\n\n        DecryptionStream decryptionStream = PGPainless.decryptAndOrVerify()\n                .onInputStream(in)\n                .withOptions(new ConsumerOptions()\n                        .addVerificationCert(cert)\n                        .addDecryptionKey(secretKeys));\n\n        Streams.pipeAll(decryptionStream, out);\n        decryptionStream.close();\n        decryptionStream.getResult();\n    }\n}", "class_id": 0, "repo": "ferenc-hechler/pgpainless", "file": "pgpainless-core/src/test/java/investigations/OnePassSignatureVerificationWithPartialLengthLiteralDataRegressionTest.java", "last_update_at": "2018-06-17T18:36:36+00:00", "question_id": "a9b20e9e02b314bf0df27b7338ac21581e2ca8c5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class OnePassSignatureVerificationWithPartialLengthLiteralDataRegressionTest {\n    /**\n     * Signed and Encrypted Message created with PGPainless 0.2.9.\n     * PGPainless versions 0.2.10 - 0.2.18 fail to decrypt this message, due to it failing to parse the signatures trailing\n     * the literal data. The cause for this was not draining the literal data first before trying to parse the sigs.\n     * This is likely caused by the literal data using a partial length encoding scheme, so the PGPObjectFactory did not yet\n     * reach the signatures packets.\n     *\n     * As a fix, PGPainless now only tries to parse signatures from after the literal data packet, once the literal data\n     * stream gets closed.\n     */\n    public static final String MSG = \"-----BEGIN PGP MESSAGE-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"\\n\" +\n            \"aEY0RHRHcWVYOENCUGRzU0FRZEFVTjJrSkZNb2lJUHhCUEFSWkZodnJxU2FGd090\\n\" +\n            \"c3llR2pkU1l4bS9UdFJRd01JK09PUGJYVjlnUEM3VEZFemlKWmRmL0ZxcUVaQTNV\\n\" +\n            \"ZkhIeEo3Y0hnWlhQWWw1Q29LMU5aSW9NRC9udk1iT1poRjREYmtNdFV2TkpWL3dT\\n\" +\n            \"QVFkQW00b01SQXVVbTdYL1BZUTc3T3Q2ZUxwTWs2VDk3TmhHMzB6RFFDSUMvV1l3\\n\" +\n            \"TTUvZkR4dW1uVW5ucXNwVFVJSmhRMmVYM0I2R2NtVE5ZdXVmSUNIbGZKMU9UQk05\\n\" +\n            \"MklNMkVGWHU1M2x3TVBLYTB1a0IzRWltbmJRNUpCNTBpT2NUeDZCcDJQREJZK0VN\\n\" +\n            \"K29IdDVlUzFzOWxlZjJUNHdCY0w1ejFLU3hQTkRpODh6Skp6dTZ1b3BxMXFwdWVI\\n\" +\n            \"UDFtemYzN0NTY3lJTHpJK0lwRXVUbWwvODdyK294TWVQR3NvR3NwblBuUWFXa0xY\\n\" +\n            \"dzdGVHpnWUJ5SGxyS3gzTGJIT040bDFVbC90dnhMbFBwNE5aRmJQcjQwWlYxb0o4\\n\" +\n            \"eE9JczRTaXpZSTNDUGRXQmlNVXJiaDJRMEFBTkg4aWNyMjhDeUZneDFSenpGdFRZ\\n\" +\n            \"MzVjeE5HSXRRZzRoR3BNUmVOWDdWNHpWOFRsUkFJSEVtaFRCTHpGZXR4eWJCbFJh\\n\" +\n            \"c3l0SUN0eWVydnZiNTQ3V2htK2tDWUxRQUcyOUlwZXUxOWo2MnV1dHJjWm10YWJn\\n\" +\n            \"LzEyTG5HSEczRkxoMGxHTmNOZnd3OXN6VC9zV0RXM2swQ3RCdVpsSmFUVXFLYlY2\\n\" +\n            \"QkRsTjZMWXFvYi9ad01wcDE4WGVuTk5tU2ZsL2JpcHZ0UE1hMk5NdGVuWXV2SGVO\\n\" +\n            \"R2hZK3Q0MFE3NE5OYmJRV1dsVXFqakFYZ3NOaUhsTjhDV2Z3UG82Ykx1OW9PaEFL\\n\" +\n            \"eTgvbFlNL1dlL2hlUFFpVGpqUUVaM3J2OHVDVGdCekFuc2tqazd0bUVOdTdnclJz\\n\" +\n            \"WjBSdzlYelRwTzJlTCtHRmV3VlhOMzNWUzFHVnR5QTMyVFRCd1ZDcStaNEtCMXRX\\n\" +\n            \"MVFIRUlDekc2UldsMkR5djBmZENpc2FoQU5SLzBmQXRrZm0wU3k1R1htWm5pWU9L\\n\" +\n            \"MkhiN2NZeHEzREs1MHowWTN4WkdiemE4L2VUMzlPTG1jMG5DdWQ5cktHaUkya0Er\\n\" +\n            \"a0NDQzF5UUlrek9zZDZlU1pFR1FncFV5UHlxdDRNQUhYeDcxUkFuR0NiWW9OVkRY\\n\" +\n            \"aUQwZ0d0M2lZRHFJV1N0TGErek1xbkJWN085Z3lSZFFVN2lXR25CeW9QNnlXc1Nk\\n\" +\n            \"aVBRSW5RR3RVSFZabU0wQnBwUk45ZUo0QlVJd2RvY0lIRldjZ0xNQjNiYlBDWHVF\\n\" +\n            \"bGl6N1ZPSHBFVWVYVmNWNWl6Z3NVUEJOSVVOZWxHcElrSk5Xa0lSSndMSFVnUlR0\\n\" +\n            \"SEh1ZFMyNnJZeURoU0tGcjdiM01HdWwyVU9GdTFlM0FzK24yVkJjcGN0ZHFtTGxG\\n\" +\n            \"THU3ZGxHMGJ0dHJQVWhaYyt4NjlFenUraTRtamRoZzZyVC9ydnYvRTJmRTRUVlpN\\n\" +\n            \"MGExbk5CUG40UT09\\n\" +\n            \"=mKyE\\n\" +\n            \"-----END PGP MESSAGE-----\";\n    public static final String KEY = \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"Comment: 23A2 3010 2038 66BC B390  8598 BB0C CFD4 57D4 DE77\\n\" +\n            \"Comment: xmpp:one@exampletwo.org\\n\" +\n            \"\\n\" +\n            \"lFgEYXQMCRYJKwYBBAHaRw8BAQdA1NhQdMUKkiwSI92ETqlY2lrAt4EbehgzpWMs\\n\" +\n            \"sm1Ke34AAP4sx3S3r0qoNpGyi3o7zfet60xIIkw9qKNdnYQyvouFhRFftBd4bXBw\\n\" +\n            \"Om9uZUBleGFtcGxldHdvLm9yZ4h4BBMWCgAgBQJhdAwJAhsBBRYCAwEABRUKCQgL\\n\" +\n            \"BAsJCAcCHgECGQEACgkQuwzP1FfU3ncAWQD/dUR7rbOpV8H4CTIpDJXiDuWi1vkC\\n\" +\n            \"Rmm5jFQsJlrIzZEA/0aZSEXH3Gj5OdQGy9qKrvqGkq7idjrTkh3gYiWRB+EOnF0E\\n\" +\n            \"YXQMCRIKKwYBBAGXVQEFAQEHQCobua4HJAsmfCB9TFjBSRfP1FEIEht4MMl4rHN4\\n\" +\n            \"eWc0AwEIBwAA/0Tmh56XX8bVDof1VVCdapcCC+LAA3wSH5SfP+EVaIJoD8WIdQQY\\n\" +\n            \"FgoAHQUCYXQMCQIbDAUWAgMBAAUVCgkICwQLCQgHAh4BAAoJELsMz9RX1N533dQB\\n\" +\n            \"ANRojORnaZw224DRVhONAuQazhKZz3e13MhyTFi91BhmAP9chFgUkvpiorQ6I65D\\n\" +\n            \"iCM315VHIvorrIElhKDtYu65CZxYBGF0DAkWCSsGAQQB2kcPAQEHQB3vy1KMKzDG\\n\" +\n            \"/yooOsvfNXtdFh8ROWWth2CZAh1rt3fdAAD+KVMkDED4xf7h1/aAunFAmdZ+xGTo\\n\" +\n            \"uPbTr8vWQMrVUFAUi4jVBBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcC\\n\" +\n            \"HgFfIAQZFgoABgUCYXQMCQAKCRDFaY6lJy4mR/FEAP9dHZi975eqlSdRa5pEn1xz\\n\" +\n            \"TLBfz2mAfWLQEr2kWLLVRAD+JBsyldKsUF8q1m/D/ty0lUUSGslgOhTcEoXxx3yC\\n\" +\n            \"1wwACgkQuwzP1FfU3neefwEA82brBIEKARYD/zHwNEPGLZweZHLPV5Iu9dmBw3l9\\n\" +\n            \"tmoA/RlQYaAKD86S1ZcfPIbjDIZkL9sjFh5tK0+mSl8rv4UH\\n\" +\n            \"=/1RX\\n\" +\n            \"-----END PGP PRIVATE KEY BLOCK-----\";\n    public static final String CERT = \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n\" +\n            \"Version: PGPainless\\n\" +\n            \"Comment: FC0A 2CB3 F757 8B26 442C  7091 A7BA 7031 BD1E 0D5F\\n\" +\n            \"Comment: xmpp:one@exampleone.org\\n\" +\n            \"\\n\" +\n            \"mDMEYXQMCRYJKwYBBAHaRw8BAQdA01hwFPFYUpsGGUpf21BUlwoL9tVVAnR3sS+J\\n\" +\n            \"UZSUlka0F3htcHA6b25lQGV4YW1wbGVvbmUub3JniHgEExYKACAFAmF0DAkCGwEF\\n\" +\n            \"FgIDAQAFFQoJCAsECwkIBwIeAQIZAQAKCRCnunAxvR4NX+f7AQCjzT+r25dDlUpp\\n\" +\n            \"tocSQtgEmWZabwB41ykD/XfyBtM0RAD/ba4yYv+f/4mX7u3XpJxkrKFs/bHwyWsR\\n\" +\n            \"VapeUGxhKwa4OARhdAwJEgorBgEEAZdVAQUBAQdAlbrJ+h8CygRFZBsx+Rsm4Kp+\\n\" +\n            \"VCB7yUR2IxOrmiGqUlsDAQgHiHUEGBYKAB0FAmF0DAkCGwwFFgIDAQAFFQoJCAsE\\n\" +\n            \"CwkIBwIeAQAKCRCnunAxvR4NX3bmAP4mTtMWgKl7RkAB/pSLMJ4bbTMSMUJCH/jS\\n\" +\n            \"qz/PNtmVrgD+JLrWg2+hNPAA8zJx8LH73G4YzZMSQ0CBd9nmWRZr3w+4MwRhdAwJ\\n\" +\n            \"FgkrBgEEAdpHDwEBB0BrLuiD0Xb6/N66IehUl77qh/Q0vDa8ack6TcOIwxZsHIjV\\n\" +\n            \"BBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcCHgFfIAQZFgoABgUCYXQM\\n\" +\n            \"CQAKCRD97UDyQowaGe1MAPwJeSe2vkEcMIk711lBbAsambR7D72XVyc0F8maniUy\\n\" +\n            \"LwD8Dbgx8O0bCcd7fcXztfyZe8OtGKQk19fSLd+xp5VThwkACgkQp7pwMb0eDV8y\\n\" +\n            \"aQEA+g10lq+1gkaLBXZbc/mUJ4odIjYBk0JdGgU8oTAZd58A/2UT9C5G9ht/lMhK\\n\" +\n            \"hISFnP6CXwvy6L1XA9bjXQJ0unMF\\n\" +\n            \"=OyZq\\n\" +\n            \"-----END PGP PUBLIC KEY BLOCK-----\";\n    @Test\n    public void testDecryptAndVerify_0_2_9_message() throws IOException, PGPException {\n        PGPSecretKeyRing secretKeys = PGPainless.readKeyRing().secretKeyRing(KEY);\n        PGPPublicKeyRing cert = PGPainless.readKeyRing().publicKeyRing(CERT);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ByteArrayOutputStream dearmored = new ByteArrayOutputStream();\n        ArmoredInputStream armorIn = new ArmoredInputStream(new ByteArrayInputStream(MSG.getBytes(StandardCharsets.UTF_8)));\n        Streams.pipeAll(armorIn, dearmored);\n        armorIn.close();\n        ByteArrayInputStream in = new ByteArrayInputStream(dearmored.toByteArray());\n        DecryptionStream decryptionStream = PGPainless.decryptAndOrVerify()\n                .onInputStream(in)\n                .withOptions(new ConsumerOptions()\n                        .addVerificationCert(cert)\n                        .addDecryptionKey(secretKeys));\n        Streams.pipeAll(decryptionStream, out);\n        decryptionStream.close();\n        decryptionStream.getResult();\n    }\n"]], "pred": {"ppl": 21.050886154174805, "ppl_lower": 50.5604362487793, "ppl/lowercase_ppl": -1.2875757176946698, "ppl/zlib": 0.0008264015885076793, "Min_5.0% Prob": 7.965905638302074, "Min_10.0% Prob": 7.2801797296486646, "Min_20.0% Prob": 6.304628161823048, "Min_30.0% Prob": 5.58720239237243, "Min_40.0% Prob": 5.06378952564995, "Min_50.0% Prob": 4.666296327650664, "Min_60.0% Prob": 4.360138105140424}}
{"hexsha": "773e2fdc0bf822ea85331efeb42dbc220779c486", "ext": "java", "lang": "Java", "content": "public class LinkImpl extends ElementImpl implements Link {\r\n\t//private java.util.Date date= new java.util.Date();\r\n    /**\r\n     * Creates a Element for a given WebElement.\r\n     *\r\n     * @param element element to wrap up\r\n     */\r\n    public LinkImpl(WebElement element) {\r\n        super(element);\r\n    }\r\n    \r\n    @Override\r\n    public void jsClick(WebDriver driver) {\r\n    \tJavascriptExecutor executor = (JavascriptExecutor)driver;\r\n    \ttry{\r\n    \t    executor.executeScript(\"arguments[0].click();\", element);\r\n    \t}catch(RuntimeException rte){\r\n    \t    TestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\", true);\r\n    \t    throw rte;\r\n    \t}\r\n    \tTestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\");\r\n        \r\n    }\r\n    \r\n    @Override\r\n    public void click() {    \t\r\n        try{\r\n            getWrappedElement().click();\r\n        }catch(RuntimeException rte){\r\n            TestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\", true);\r\n            throw rte;\r\n        }\r\n    \tTestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\");\r\n    \t\r\n    }\r\n}", "class_id": 0, "repo": "waitsavery/Selenium-Toyota-POC", "file": "src/main/java/com/orasi/core/interfaces/impl/LinkImpl.java", "last_update_at": "2018-08-17T19:02:25+00:00", "question_id": "773e2fdc0bf822ea85331efeb42dbc220779c486", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LinkImpl extends ElementImpl implements Link {\r\n\t//private java.util.Date date= new java.util.Date();\r\n    /**\r\n     * Creates a Element for a given WebElement.\r\n     *\r\n     * @param element element to wrap up\r\n     */\r\n    public LinkImpl(WebElement element) {\r\n        super(element);\r\n    }\r\n    \r\n    @Override\r\n    public void jsClick(WebDriver driver) {\r\n    \tJavascriptExecutor executor = (JavascriptExecutor)driver;\r\n    \ttry{\r\n    \t    executor.executeScript(\"arguments[0].click();\", element);\r\n    \t}catch(RuntimeException rte){\r\n    \t    TestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\", true);\r\n    \t    throw rte;\r\n    \t}\r\n    \tTestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\");\r\n        \r\n    }\r\n    \r\n    @Override\r\n    public void click() {    \t\r\n        try{\r\n            getWrappedElement().click();\r\n        }catch(RuntimeException rte){\r\n            TestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\", true);\r\n            throw rte;\r\n        }\r\n    \tTestReporter.interfaceLog(\" Click Link [ <b>@FindBy: \" + getElementLocatorInfo()  + \" </b> ]\");\r\n    \t\r\n    }\r\n"]], "pred": {"ppl": 2.0326004028320312, "ppl_lower": 2.442955493927002, "ppl/lowercase_ppl": -1.2592534565720455, "ppl/zlib": 0.001630611402085287, "Min_5.0% Prob": 6.350364183124743, "Min_10.0% Prob": 4.9835030656111865, "Min_20.0% Prob": 3.2672445240773653, "Min_30.0% Prob": 2.315323625478828, "Min_40.0% Prob": 1.7678947889883267, "Min_50.0% Prob": 1.4153842640679857, "Min_60.0% Prob": 1.1825601490068058}}
{"hexsha": "56ac7189dbc7efdaf48ea200097259ddff2f760d", "ext": "java", "lang": "Java", "content": "public\nclass GeneAnnotator extends GazetteerAnnotator {\n  /** The URI of this Annotator (namespace and ID are defined dynamically). */\n  @SuppressWarnings(\"hiding\")\n  public static final String URI = GeneAnnotator.class.getName();\n  public static final String PARAM_TAXA_ANNOTATOR_URI = \"TaxaAnnotatorUri\";\n  @ConfigurationParameter(name = PARAM_TAXA_ANNOTATOR_URI,\n                          description = \"The annotator URI that made the taxon ID annotations.\")\n  private String taxaAnnotatorUri;\n  public static final String PARAM_TAXA_NAMESPACE = \"TaxaNamespace\";\n  @ConfigurationParameter(name = PARAM_TAXA_NAMESPACE,\n                          description = \"The NS in which the taxon ID annotations were made.\")\n  private String taxaNamespace;\n  /** A mapping of taxonmic IDs to another. */\n  public static final String MODEL_KEY_TAX_ID_MAPPING_RESOURCE = \"TaxIdMappingResource\";\n  @ExternalResource(key = MODEL_KEY_TAX_ID_MAPPING_RESOURCE, mandatory = false)\n  LineBasedStringMapResource<String> taxIdMapping;\n  /** The name of the property used to set the taxon ID of the matched gene name. */\n  public static final String TAX_ID_PROPERTY = \"taxon\";\n  private int counter = 0;\n\n  public static\n  class Builder extends GazetteerAnnotator.Builder {\n    Builder(String entityNamespace, ExternalResourceDescription geneGazetteerResourceDescription) {\n      super(GeneAnnotator.class, entityNamespace, geneGazetteerResourceDescription);\n    }\n\n    /** Set the annotator URI of taxa annotations to use for filtering annotations. */\n    public\n    Builder setTaxaAnnotatorUri(String uri) {\n      setOptionalParameter(PARAM_TAXA_ANNOTATOR_URI, uri);\n      return this;\n    }\n\n    /** Set the namespace of taxa annotations to use for filtering annotations. */\n    public\n    Builder setTaxaNamespace(String ns) {\n      setOptionalParameter(PARAM_TAXA_NAMESPACE, ns);\n      return this;\n    }\n\n    /**\n     * Supply a {@link LineBasedStringMapResource} that maps taxonomic IDs to another.\n     * <p/>\n     * If set, all Tax IDs with a matching key in this resource will instead be annotated with the\n     * mapped target Tax ID.\n     */\n    public\n    Builder setTaxIdMappingResource(ExternalResourceDescription desc) {\n      setOptionalParameter(MODEL_KEY_TAX_ID_MAPPING_RESOURCE, desc);\n      return this;\n    }\n  }\n\n  /**\n   * Create a new gazetteer configuration builder with a pre-configured gazetteer resource.\n   *\n   * @param entityNamespace to use for the {@link SemanticAnnotation SemanticAnnotations} of the\n   *                        entity DB IDs\n   * @param geneGazetteerResourceDescription\n   *                        a pre-configured {@link GnamedGazetteerResource} description.\n   */\n  public static\n  Builder configure(String entityNamespace,\n                    ExternalResourceDescription geneGazetteerResourceDescription) {\n    return new Builder(entityNamespace, geneGazetteerResourceDescription);\n  }\n\n  @Override\n  public\n  void initialize(UimaContext ctx) throws ResourceInitializationException {\n    super.initialize(ctx);\n    if (taxIdMapping != null && taxIdMapping.size() > 0) logger.log(\n        Level.CONFIG, \"{0} TaxID mappings provided to {1} Gazetteer\", new Object[] {\n        taxIdMapping.size(), entityNamespace\n    }\n    );\n    counter = 0;\n  }\n\n  @Override\n  public\n  void process(JCas jcas) throws AnalysisEngineProcessException {\n    List<SemanticAnnotation> buffer = new LinkedList<SemanticAnnotation>();\n    Set<String> annotatedTaxa = getAnnotatedTaxa(jcas);\n    if (textNamespace == null && textIdentifier == null) {\n      String docText = jcas.getDocumentText();\n      Map<Offset, List<String>> matches = gazetteer.match(docText);\n      for (Offset offset : matches.keySet()) {\n        String match = docText.substring(offset.start(), offset.end());\n        if (filter.process(match))\n          taxonFilter(jcas, buffer, match, offset, matches.get(offset), annotatedTaxa);\n      }\n    } else {\n      FSMatchConstraint cons = TextAnnotation.makeConstraint(\n          jcas, null, textNamespace, textIdentifier\n      );\n      FSIterator<Annotation> it = TextAnnotation.getIterator(jcas);\n      it = jcas.createFilteredIterator(it, cons);\n      while (it.hasNext()) {\n        // findEntities -> annotateEntities\n        Annotation ann = it.next();\n        String text = ann.getCoveredText();\n        Map<Offset, List<String>> matches = gazetteer.match(text);\n        int annBegin = ann.getBegin();\n        for (Offset offset : matches.keySet()) {\n          String match = text.substring(offset.start(), offset.end());\n          if (filter.process(match)) taxonFilter(\n              jcas, buffer, match, new Offset(\n              annBegin + offset.start(), annBegin + offset.end()\n          ), matches.get(offset), annotatedTaxa\n          );\n        }\n      }\n    }\n    for (SemanticAnnotation ann : buffer)\n      ann.addToIndexes();\n    logger.log(\n        Level.FINE, \"tagged {0} potential {1} genes\", new Object[] {buffer.size(), entityNamespace}\n    );\n    counter += buffer.size();\n  }\n\n  @Override\n  public\n  void destroy() {\n    super.destroy();\n    logger.log(\n        Level.CONFIG, \"made {0} [potential] {1} gene annoations\",\n        new Object[] {counter, entityNamespace}\n    );\n  }\n\n  /** Annotate the match if the taxon matches or if there is no taxon filter in use. */\n  private\n  void taxonFilter(JCas jcas, List<SemanticAnnotation> buffer, String match, Offset offset,\n                   List<String> ids, Set<String> annotatedTaxa) {\n    for (String id : ids) {\n      if (annotatedTaxa == null || annotatedTaxa.contains(getTaxId(id))) {\n        SemanticAnnotation ann = makeAnnotation(jcas, match, id, offset);\n        if (ann != null) buffer.add(ann);\n      } else {\n        logger.log(Level.FINER, \"taxon-filtered match ''{0}'' for {1}\", new String[] {match, id});\n      }\n    }\n  }\n\n  /** Expands the parent method, adding a taxon ID property to the annotation. */\n  @Override\n  protected\n  SemanticAnnotation annotate(String id, JCas jcas, Offset offset, double confidence, String name) {\n    SemanticAnnotation entity = super.annotate(id, jcas, offset, confidence, name);\n    entity.setAnnotator(URI); // update with static URI\n    Property taxId = new Property(jcas);\n    taxId.setName(TAX_ID_PROPERTY);\n    taxId.setValue(getTaxId(id));\n    entity.addProperty(jcas, taxId);\n    return entity;\n  }\n\n  /** Get all annotated taxa on this SOFA. */\n  private\n  Set<String> getAnnotatedTaxa(JCas jcas) {\n    Set<String> annotatedTaxa = null;\n    if (taxaAnnotatorUri != null || taxaNamespace != null) {\n      annotatedTaxa = new HashSet<String>();\n      FSIterator<Annotation> iter = jcas.createFilteredIterator(\n          SemanticAnnotation.getIterator(jcas),\n          SemanticAnnotation.makeConstraint(jcas, taxaAnnotatorUri, taxaNamespace)\n      );\n      while (iter.hasNext()) annotatedTaxa.add(((SemanticAnnotation) iter.next()).getIdentifier());\n      for (String taxId : annotatedTaxa)\n        logger.log(Level.FINER, \"(taxon-filtering) detected taxId={0}\", taxId);\n      if (annotatedTaxa.size() == 0) annotatedTaxa = null;\n    }\n    return annotatedTaxa;\n  }\n\n  /** Fetches the taxon from the {@link GnamedGazetteerResource gnamed gazetteer}. */\n  private\n  String getTaxId(String id) {\n    String tid = ((GnamedGazetteerResource) gazetteer).getTaxId(id);\n    if (taxIdMapping != null && taxIdMapping.containsKey(tid)) tid = taxIdMapping.get(tid);\n    return tid;\n  }\n}", "class_id": 0, "repo": "fnl/txtfnnl", "file": "txtfnnl-uima/src/main/java/txtfnnl/uima/analysis_component/GeneAnnotator.java", "last_update_at": "2018-03-04T22:25:41+00:00", "question_id": "56ac7189dbc7efdaf48ea200097259ddff2f760d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public\nclass GeneAnnotator extends GazetteerAnnotator {\n  /** The URI of this Annotator (namespace and ID are defined dynamically). */\n  @SuppressWarnings(\"hiding\")\n  public static final String URI = GeneAnnotator.class.getName();\n  public static final String PARAM_TAXA_ANNOTATOR_URI = \"TaxaAnnotatorUri\";\n  @ConfigurationParameter(name = PARAM_TAXA_ANNOTATOR_URI,\n                          description = \"The annotator URI that made the taxon ID annotations.\")\n  private String taxaAnnotatorUri;\n  public static final String PARAM_TAXA_NAMESPACE = \"TaxaNamespace\";\n  @ConfigurationParameter(name = PARAM_TAXA_NAMESPACE,\n                          description = \"The NS in which the taxon ID annotations were made.\")\n  private String taxaNamespace;\n  /** A mapping of taxonmic IDs to another. */\n  public static final String MODEL_KEY_TAX_ID_MAPPING_RESOURCE = \"TaxIdMappingResource\";\n  @ExternalResource(key = MODEL_KEY_TAX_ID_MAPPING_RESOURCE, mandatory = false)\n  LineBasedStringMapResource<String> taxIdMapping;\n  /** The name of the property used to set the taxon ID of the matched gene name. */\n  public static final String TAX_ID_PROPERTY = \"taxon\";\n  private int counter = 0;\n  public static\n  class Builder extends GazetteerAnnotator.Builder {\n    Builder(String entityNamespace, ExternalResourceDescription geneGazetteerResourceDescription) {\n      super(GeneAnnotator.class, entityNamespace, geneGazetteerResourceDescription);\n    }\n    /** Set the annotator URI of taxa annotations to use for filtering annotations. */\n    public\n    Builder setTaxaAnnotatorUri(String uri) {\n      setOptionalParameter(PARAM_TAXA_ANNOTATOR_URI, uri);\n      return this;\n    }\n    /** Set the namespace of taxa annotations to use for filtering annotations. */\n    public\n    Builder setTaxaNamespace(String ns) {\n      setOptionalParameter(PARAM_TAXA_NAMESPACE, ns);\n      return this;\n    }\n    /**\n     * Supply a {@link LineBasedStringMapResource} that maps taxonomic IDs to another.\n     * <p/>\n     * If set, all Tax IDs with a matching key in this resource will instead be annotated with the\n     * mapped target Tax ID.\n     */\n    public\n    Builder setTaxIdMappingResource(ExternalResourceDescription desc) {\n      setOptionalParameter(MODEL_KEY_TAX_ID_MAPPING_RESOURCE, desc);\n      return this;\n    }\n  }\n  /**\n   * Create a new gazetteer configuration builder with a pre-configured gazetteer resource.\n   *\n   * @param entityNamespace to use for the {@link SemanticAnnotation SemanticAnnotations} of the\n   *                        entity DB IDs\n   * @param geneGazetteerResourceDescription\n   *                        a pre-configured {@link GnamedGazetteerResource} description.\n   */\n  public static\n  Builder configure(String entityNamespace,\n                    ExternalResourceDescription geneGazetteerResourceDescription) {\n    return new Builder(entityNamespace, geneGazetteerResourceDescription);\n  }\n  @Override\n  public\n  void initialize(UimaContext ctx) throws ResourceInitializationException {\n    super.initialize(ctx);\n    if (taxIdMapping != null && taxIdMapping.size() > 0) logger.log(\n        Level.CONFIG, \"{0} TaxID mappings provided to {1} Gazetteer\", new Object[] {\n        taxIdMapping.size(), entityNamespace\n    }\n    );\n    counter = 0;\n  }\n  @Override\n  public\n  void process(JCas jcas) throws AnalysisEngineProcessException {\n    List<SemanticAnnotation> buffer = new LinkedList<SemanticAnnotation>();\n    Set<String> annotatedTaxa = getAnnotatedTaxa(jcas);\n    if (textNamespace == null && textIdentifier == null) {\n      String docText = jcas.getDocumentText();\n      Map<Offset, List<String>> matches = gazetteer.match(docText);\n      for (Offset offset : matches.keySet()) {\n        String match = docText.substring(offset.start(), offset.end());\n        if (filter.process(match))\n          taxonFilter(jcas, buffer, match, offset, matches.get(offset), annotatedTaxa);\n      }\n    } else {\n      FSMatchConstraint cons = TextAnnotation.makeConstraint(\n          jcas, null, textNamespace, textIdentifier\n      );\n      FSIterator<Annotation> it = TextAnnotation.getIterator(jcas);\n      it = jcas.createFilteredIterator(it, cons);\n      while (it.hasNext()) {\n        // findEntities -> annotateEntities\n        Annotation ann = it.next();\n        String text = ann.getCoveredText();\n        Map<Offset, List<String>> matches = gazetteer.match(text);\n        int annBegin = ann.getBegin();\n        for (Offset offset : matches.keySet()) {\n          String match = text.substring(offset.start(), offset.end());\n          if (filter.process(match)) taxonFilter(\n              jcas, buffer, match, new Offset(\n              annBegin + offset.start(), annBegin + offset.end()\n          ), matches.get(offset), annotatedTaxa\n          );\n        }\n      }\n    }\n    for (SemanticAnnotation ann : buffer)\n      ann.addToIndexes();\n    logger.log(\n        Level.FINE, \"tagged {0} potential {1} genes\", new Object[] {buffer.size(), entityNamespace}\n    );\n    counter += buffer.size();\n  }\n  @Override\n  public\n  void destroy() {\n    super.destroy();\n    logger.log(\n        Level.CONFIG, \"made {0} [potential] {1} gene annoations\",\n        new Object[] {counter, entityNamespace}\n    );\n  }\n  /** Annotate the match if the taxon matches or if there is no taxon filter in use. */\n  private\n  void taxonFilter(JCas jcas, List<SemanticAnnotation> buffer, String match, Offset offset,\n                   List<String> ids, Set<String> annotatedTaxa) {\n    for (String id : ids) {\n      if (annotatedTaxa == null || annotatedTaxa.contains(getTaxId(id))) {\n        SemanticAnnotation ann = makeAnnotation(jcas, match, id, offset);\n        if (ann != null) buffer.add(ann);\n      } else {\n        logger.log(Level.FINER, \"taxon-filtered match ''{0}'' for {1}\", new String[] {match, id});\n      }\n    }\n  }\n  /** Expands the parent method, adding a taxon ID property to the annotation. */\n  @Override\n  protected\n  SemanticAnnotation annotate(String id, JCas jcas, Offset offset, double confidence, String name) {\n    SemanticAnnotation entity = super.annotate(id, jcas, offset, confidence, name);\n    entity.setAnnotator(URI); // update with static URI\n    Property taxId = new Property(jcas);\n    taxId.setName(TAX_ID_PROPERTY);\n    taxId.setValue(getTaxId(id));\n    entity.addProperty(jcas, taxId);\n    return entity;\n  }\n  /** Get all annotated taxa on this SOFA. */\n  private\n  Set<String> getAnnotatedTaxa(JCas jcas) {\n    Set<String> annotatedTaxa = null;\n    if (taxaAnnotatorUri != null || taxaNamespace != null) {\n      annotatedTaxa = new HashSet<String>();\n      FSIterator<Annotation> iter = jcas.createFilteredIterator(\n          SemanticAnnotation.getIterator(jcas),\n          SemanticAnnotation.makeConstraint(jcas, taxaAnnotatorUri, taxaNamespace)\n      );\n      while (iter.hasNext()) annotatedTaxa.add(((SemanticAnnotation) iter.next()).getIdentifier());\n      for (String taxId : annotatedTaxa)\n        logger.log(Level.FINER, \"(taxon-filtering) detected taxId={0}\", taxId);\n      if (annotatedTaxa.size() == 0) annotatedTaxa = null;\n    }\n    return annotatedTaxa;\n  }\n  /** Fetches the taxon from the {@link GnamedGazetteerResource gnamed gazetteer}. */\n  private\n  String getTaxId(String id) {\n    String tid = ((GnamedGazetteerResource) gazetteer).getTaxId(id);\n    if (taxIdMapping != null && taxIdMapping.containsKey(tid)) tid = taxIdMapping.get(tid);\n    return tid;\n  }\n"]], "pred": {"ppl": 2.378631830215454, "ppl_lower": 2.8322982788085938, "ppl/lowercase_ppl": -1.2014517073297686, "ppl/zlib": 0.00038753374827070236, "Min_5.0% Prob": 7.191057925130806, "Min_10.0% Prob": 5.429401996088963, "Min_20.0% Prob": 3.7676902027691113, "Min_30.0% Prob": 2.7724209886555577, "Min_40.0% Prob": 2.140496756562685, "Min_50.0% Prob": 1.7285959860364635, "Min_60.0% Prob": 1.4446849208841706}}
{"hexsha": "cc27e0847caec1d4df99cb48dac2ffd0fc604f04", "ext": "java", "lang": "Java", "content": "class Zone {\n    // zone name (e.g., \"America/Los_Angeles\")\n    private String name;\n\n    // zone records\n    private List<ZoneRec> list;\n\n    // target zone names for this compilation\n    private static Set<String> targetZones;\n\n    /**\n     * Constructs a Zone with the specified zone name.\n     * @param name the zone name\n     */\n    Zone(String name) {\n        this.name = name;\n        list = new ArrayList<ZoneRec>();\n    }\n\n    /**\n     * Reads time zone names to be generated, called \"target zone\n     * name\", from the specified text file and creats an internal hash\n     * table to keep those names. It's assumed that one text line\n     * contains a zone name or comments if it starts with\n     * '#'. Comments can't follow a zone name in a single line.\n     * @param fileName the text file name\n     */\n    static void readZoneNames(String fileName) {\n        if (fileName == null) {\n            return;\n        }\n        BufferedReader in = null;\n        try {\n            FileReader fr = new FileReader(fileName);\n            in = new BufferedReader(fr);\n        } catch (FileNotFoundException e) {\n            Main.panic(\"can't open file: \" + fileName);\n        }\n        targetZones = new HashSet<String>();\n        String line;\n\n        try {\n            while ((line = in.readLine()) != null) {\n                line = line.trim();\n                if (line.length() == 0 || line.charAt(0) == '#') {\n                    continue;\n                }\n                if (!targetZones.add(line)) {\n                    Main.warning(\"duplicated target zone name: \" + line);\n                }\n            }\n            in.close();\n        } catch (IOException e) {\n            Main.panic(\"IO error: \"+e.getMessage());\n        }\n    }\n\n    /**\n     * Determines whether the specified zone is one of the target zones.\n     * If no target zones are specified, this method always returns\n     * true for any zone name.\n     * @param zoneName the zone name\n     * @return true if the specified name is a target zone.\n     */\n    static boolean isTargetZone(String zoneName) {\n        if (targetZones == null) {\n            return true;\n        }\n        return targetZones.contains(zoneName);\n    }\n\n    /**\n     * Forces to add \"MET\" to the target zone table. This is because\n     * there is a conflict between Java zone name \"WET\" and Olson zone\n     * name.\n     */\n    static void addMET() {\n        if (targetZones != null) {\n            targetZones.add(\"MET\");\n        }\n    }\n\n    /**\n     * @return the zone name\n     */\n    String getName() {\n        return name;\n    }\n\n    /**\n     * Adds the specified zone record to the zone record list.\n     */\n    void add(ZoneRec rec) {\n        list.add(rec);\n    }\n\n    /**\n     * @param index the index at which the zone record in the list is returned.\n     * @return the zone record specified by the index.\n     */\n    ZoneRec get(int index) {\n        return list.get(index);\n    }\n\n    /**\n     * @return the size of the zone record list\n     */\n    int size() {\n        return list.size();\n    }\n\n    /**\n     * Resolves the reference to a rule in each zone record.\n     * @param zi the Zoneinfo object with which the rule reference is\n     * resolved.\n     */\n    void resolve(Zoneinfo zi) {\n        for (int i = 0; i < list.size(); i++) {\n            ZoneRec rec = list.get(i);\n            rec.resolve(zi);\n        }\n    }\n}", "class_id": 0, "repo": "iootclab/openjdk", "file": "openjdk11/test/jdk/sun/util/calendar/zi/Zone.java", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "cc27e0847caec1d4df99cb48dac2ffd0fc604f04", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class Zone {\n    // zone name (e.g., \"America/Los_Angeles\")\n    private String name;\n    // zone records\n    private List<ZoneRec> list;\n    // target zone names for this compilation\n    private static Set<String> targetZones;\n    /**\n     * Constructs a Zone with the specified zone name.\n     * @param name the zone name\n     */\n    Zone(String name) {\n        this.name = name;\n        list = new ArrayList<ZoneRec>();\n    }\n    /**\n     * Reads time zone names to be generated, called \"target zone\n     * name\", from the specified text file and creats an internal hash\n     * table to keep those names. It's assumed that one text line\n     * contains a zone name or comments if it starts with\n     * '#'. Comments can't follow a zone name in a single line.\n     * @param fileName the text file name\n     */\n    static void readZoneNames(String fileName) {\n        if (fileName == null) {\n            return;\n        }\n        BufferedReader in = null;\n        try {\n            FileReader fr = new FileReader(fileName);\n            in = new BufferedReader(fr);\n        } catch (FileNotFoundException e) {\n            Main.panic(\"can't open file: \" + fileName);\n        }\n        targetZones = new HashSet<String>();\n        String line;\n        try {\n            while ((line = in.readLine()) != null) {\n                line = line.trim();\n                if (line.length() == 0 || line.charAt(0) == '#') {\n                    continue;\n                }\n                if (!targetZones.add(line)) {\n                    Main.warning(\"duplicated target zone name: \" + line);\n                }\n            }\n            in.close();\n        } catch (IOException e) {\n            Main.panic(\"IO error: \"+e.getMessage());\n        }\n    }\n    /**\n     * Determines whether the specified zone is one of the target zones.\n     * If no target zones are specified, this method always returns\n     * true for any zone name.\n     * @param zoneName the zone name\n     * @return true if the specified name is a target zone.\n     */\n    static boolean isTargetZone(String zoneName) {\n        if (targetZones == null) {\n            return true;\n        }\n        return targetZones.contains(zoneName);\n    }\n    /**\n     * Forces to add \"MET\" to the target zone table. This is because\n     * there is a conflict between Java zone name \"WET\" and Olson zone\n     * name.\n     */\n    static void addMET() {\n        if (targetZones != null) {\n            targetZones.add(\"MET\");\n        }\n    }\n    /**\n     * @return the zone name\n     */\n    String getName() {\n        return name;\n    }\n    /**\n     * Adds the specified zone record to the zone record list.\n     */\n    void add(ZoneRec rec) {\n        list.add(rec);\n    }\n    /**\n     * @param index the index at which the zone record in the list is returned.\n     * @return the zone record specified by the index.\n     */\n    ZoneRec get(int index) {\n        return list.get(index);\n    }\n    /**\n     * @return the size of the zone record list\n     */\n    int size() {\n        return list.size();\n    }\n    /**\n     * Resolves the reference to a rule in each zone record.\n     * @param zi the Zoneinfo object with which the rule reference is\n     * resolved.\n     */\n    void resolve(Zoneinfo zi) {\n        for (int i = 0; i < list.size(); i++) {\n            ZoneRec rec = list.get(i);\n            rec.resolve(zi);\n        }\n    }\n"]], "pred": {"ppl": 2.0846033096313477, "ppl_lower": 2.2709953784942627, "ppl/lowercase_ppl": -1.1165833754207641, "ppl/zlib": 0.0006338037773766829, "Min_5.0% Prob": 6.339001097577683, "Min_10.0% Prob": 4.896607330504884, "Min_20.0% Prob": 3.2498367790212024, "Min_30.0% Prob": 2.350326747230604, "Min_40.0% Prob": 1.8141476761232664, "Min_50.0% Prob": 1.4632423422438032, "Min_60.0% Prob": 1.2228152438625033}}
{"hexsha": "3c3e8e4cb2309f805aa52932310fcbae62e0aa87", "ext": "java", "lang": "Java", "content": "public class ICURegion {\n\n\tprivate Region icuRegion;\n\tprivate Locale countryLocale;\n\tprivate static final List<Class> REGION_DATATYPES = Arrays\n\t\t\t.asList(new Class[] { ICURegion.class });\n\n\tpublic ICURegion(Region icuRegion) {\n\t\tif (icuRegion == null) {\n\t\t\tthrow new IllegalArgumentException(\"icuRegion required.\");\n\t\t}\n\t\tthis.icuRegion = icuRegion;\n\t\tthis.countryLocale = new Locale(\"\", icuRegion.toString());\n\t}\n\n\tpublic RegionType getRegionType() {\n\t\treturn icuRegion.getType();\n\t}\n\n\tpublic String getRegionCode() {\n\t\t// returns region id!\n\t\treturn icuRegion.toString();\n\t}\n\n\tpublic int getNumericCode() {\n\t\treturn icuRegion.getNumericCode();\n\t}\n\n\tpublic Collection<String> getTimezoneIds() {\n\t\tString[] timezones = TimeZone.getAvailableIDs(getRegionCode());\n\t\treturn Arrays.asList(timezones);\n\t}\n\n\tpublic String getDisplayName(Locale locale) {\n\t\tString name = this.countryLocale.getDisplayCountry(locale);\n\t\tif (name == null) {\n\t\t\tname = this.getRegionCode();\n\t\t}\n\t\treturn name;\n\t}\n\n\tpublic Region getIcuRegion() {\n\t\treturn this.icuRegion;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tString name = getDisplayName(Locale.getDefault());\n\t\tif (name == null) {\n\t\t\tname = \"IcuRegion\";\n\t\t}\n\t\treturn name + \" [code: \" + icuRegion.toString() + \", type: \"\n\t\t\t\t+ getRegionType().name() + \"]\";\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result\n\t\t\t\t+ ((icuRegion == null) ? 0 : icuRegion.hashCode());\n\t\treturn result;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tICURegion other = (ICURegion) obj;\n\t\tif (icuRegion == null) {\n\t\t\tif (other.icuRegion != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!icuRegion.equals(other.icuRegion)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see javax.money.ext.Region#getLocale()\n\t */\n\tpublic Locale getLocale() {\n\t\treturn this.countryLocale;\n\t}\n\n\n}", "class_id": 0, "repo": "McPringle/javamoney-shelter", "file": "retired/regions/src/main/java/org/javamoney/regions/internal/ICURegion.java", "last_update_at": "2018-11-04T22:38:15+00:00", "question_id": "3c3e8e4cb2309f805aa52932310fcbae62e0aa87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ICURegion {\n\tprivate Region icuRegion;\n\tprivate Locale countryLocale;\n\tprivate static final List<Class> REGION_DATATYPES = Arrays\n\t\t\t.asList(new Class[] { ICURegion.class });\n\tpublic ICURegion(Region icuRegion) {\n\t\tif (icuRegion == null) {\n\t\t\tthrow new IllegalArgumentException(\"icuRegion required.\");\n\t\t}\n\t\tthis.icuRegion = icuRegion;\n\t\tthis.countryLocale = new Locale(\"\", icuRegion.toString());\n\t}\n\tpublic RegionType getRegionType() {\n\t\treturn icuRegion.getType();\n\t}\n\tpublic String getRegionCode() {\n\t\t// returns region id!\n\t\treturn icuRegion.toString();\n\t}\n\tpublic int getNumericCode() {\n\t\treturn icuRegion.getNumericCode();\n\t}\n\tpublic Collection<String> getTimezoneIds() {\n\t\tString[] timezones = TimeZone.getAvailableIDs(getRegionCode());\n\t\treturn Arrays.asList(timezones);\n\t}\n\tpublic String getDisplayName(Locale locale) {\n\t\tString name = this.countryLocale.getDisplayCountry(locale);\n\t\tif (name == null) {\n\t\t\tname = this.getRegionCode();\n\t\t}\n\t\treturn name;\n\t}\n\tpublic Region getIcuRegion() {\n\t\treturn this.icuRegion;\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tString name = getDisplayName(Locale.getDefault());\n\t\tif (name == null) {\n\t\t\tname = \"IcuRegion\";\n\t\t}\n\t\treturn name + \" [code: \" + icuRegion.toString() + \", type: \"\n\t\t\t\t+ getRegionType().name() + \"]\";\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result\n\t\t\t\t+ ((icuRegion == null) ? 0 : icuRegion.hashCode());\n\t\treturn result;\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tICURegion other = (ICURegion) obj;\n\t\tif (icuRegion == null) {\n\t\t\tif (other.icuRegion != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!icuRegion.equals(other.icuRegion)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see javax.money.ext.Region#getLocale()\n\t */\n\tpublic Locale getLocale() {\n\t\treturn this.countryLocale;\n\t}\n"]], "pred": {"ppl": 1.431272268295288, "ppl_lower": 1.626340389251709, "ppl/lowercase_ppl": -1.356334361726766, "ppl/zlib": 0.00046932427596026285, "Min_5.0% Prob": 4.754166009691026, "Min_10.0% Prob": 3.1484553224510616, "Min_20.0% Prob": 1.7636223789304495, "Min_30.0% Prob": 1.1906868850674341, "Min_40.0% Prob": 0.8954624013186225, "Min_50.0% Prob": 0.7169208182989516, "Min_60.0% Prob": 0.5975519338713774}}
{"hexsha": "fdc8935095563e93449d1736b136b62f0d4ef8aa", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"UnusedParameters\")\npublic class LandlordCommandExecutor implements CommandExecutor {\n\n    private HashMap<String, LandlordCommand> registeredCommands;\n\n    private Help helpCommand;\n\n    public LandlordCommandExecutor(Landlord plugin) {\n        this.registeredCommands = new HashMap<>();\n\n        this.helpCommand = new Help(plugin, this);\n\n        // note order of registration will affect how they show up in the help menu\n        this.register(helpCommand);             // register the help command (already instantiated)\n\n        this.register(new Claim(plugin));       // register the claim command\n        this.register(new Unclaim(plugin));     // register the unclaim command\n        this.register(new AddFriend(plugin));   // register the addfriend command\n        this.register(new Unfriend(plugin));    // register the unfriend command\n        this.register(new Friends(plugin));     // register the friends command\n        this.register(new FriendAll(plugin));   // register the friendall command\n        this.register(new UnfriendAll(plugin)); // register the unfriendall command\n        this.register(new ShowMap(plugin));     // register the map command\n        this.register(new Manage(plugin));      // register the manage command\n        this.register(new LandList(plugin));    // register the list command\n        this.register(new Info(plugin));        // register the info command\n        this.register(new ListPlayer(plugin));  // register the listplayer command\n        this.register(new ClearWorld(plugin));  // register the clearworld command\n        this.register(new Reload(plugin));      // register the reload command\n\n    }\n\n\n    /**\n     * Main command handler\n     *\n     * @param sender who sent the command\n     * @param label  exact command (or alias) run\n     * @param args   given with command\n     * @return boolean\n     */\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n        if (cmd.getName().equalsIgnoreCase(\"landlord\")) { // If the player typed /land then do the following...\n            // Check if the attempted command is registered\n            if (args.length == 0 || !registeredCommands.containsKey(args[0].toLowerCase())) {\n                // if there is no command, or it's not registered, show the help text as the command given is unknown\n                return helpCommand.execute(sender, new String[]{}, label);\n            } else {\n                // if it is, execute it with the given args\n                return registeredCommands.get(args[0].toLowerCase()).execute(sender, args, label);\n            }\n\n        } //If this has happened the function should return true.\n        // If this hasn't happened the value of false will be returned.\n        return false;\n    }\n\n\n    /**\n     * Register a new command\n     *\n     * @param cmd LandlordCommand to register\n     * @return boolean of success - should fail if a requested label (name, alias) is not available\n     */\n    public boolean register(LandlordCommand cmd) {\n        String[] commandTriggers = cmd.getTriggers();\n\n        // if there are no aliases then fail, command would be impossible to trigger.\n        if (commandTriggers.length <= 0) {\n\n            return false;\n        }\n\n        // iterate the command aliases\n        for (String trigger : commandTriggers) {\n\n            // Check if the command is taken\n            if (registeredCommands.containsKey(trigger.toLowerCase())) {\n                System.out.println(\"Failed to register command with alias '\" + trigger + \"', already taken!\");\n                continue;   // Command name is taken already\n            }\n\n            // register an entry for this command trigger\n            registeredCommands.put(trigger.toLowerCase(), cmd);\n        }\n\n        helpCommand.addCommand(cmd);    // add the command to the help list\n\n        return true;\n    }\n\n}", "class_id": 0, "repo": "fiskenslakt/Landlord", "file": "src/com/jcdesimp/landlord/LandlordCommandExecutor.java", "last_update_at": "2018-06-10T23:21:12+00:00", "question_id": "fdc8935095563e93449d1736b136b62f0d4ef8aa", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"UnusedParameters\")\npublic class LandlordCommandExecutor implements CommandExecutor {\n    private HashMap<String, LandlordCommand> registeredCommands;\n    private Help helpCommand;\n    public LandlordCommandExecutor(Landlord plugin) {\n        this.registeredCommands = new HashMap<>();\n        this.helpCommand = new Help(plugin, this);\n        // note order of registration will affect how they show up in the help menu\n        this.register(helpCommand);             // register the help command (already instantiated)\n        this.register(new Claim(plugin));       // register the claim command\n        this.register(new Unclaim(plugin));     // register the unclaim command\n        this.register(new AddFriend(plugin));   // register the addfriend command\n        this.register(new Unfriend(plugin));    // register the unfriend command\n        this.register(new Friends(plugin));     // register the friends command\n        this.register(new FriendAll(plugin));   // register the friendall command\n        this.register(new UnfriendAll(plugin)); // register the unfriendall command\n        this.register(new ShowMap(plugin));     // register the map command\n        this.register(new Manage(plugin));      // register the manage command\n        this.register(new LandList(plugin));    // register the list command\n        this.register(new Info(plugin));        // register the info command\n        this.register(new ListPlayer(plugin));  // register the listplayer command\n        this.register(new ClearWorld(plugin));  // register the clearworld command\n        this.register(new Reload(plugin));      // register the reload command\n    }\n    /**\n     * Main command handler\n     *\n     * @param sender who sent the command\n     * @param label  exact command (or alias) run\n     * @param args   given with command\n     * @return boolean\n     */\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n        if (cmd.getName().equalsIgnoreCase(\"landlord\")) { // If the player typed /land then do the following...\n            // Check if the attempted command is registered\n            if (args.length == 0 || !registeredCommands.containsKey(args[0].toLowerCase())) {\n                // if there is no command, or it's not registered, show the help text as the command given is unknown\n                return helpCommand.execute(sender, new String[]{}, label);\n            } else {\n                // if it is, execute it with the given args\n                return registeredCommands.get(args[0].toLowerCase()).execute(sender, args, label);\n            }\n        } //If this has happened the function should return true.\n        // If this hasn't happened the value of false will be returned.\n        return false;\n    }\n    /**\n     * Register a new command\n     *\n     * @param cmd LandlordCommand to register\n     * @return boolean of success - should fail if a requested label (name, alias) is not available\n     */\n    public boolean register(LandlordCommand cmd) {\n        String[] commandTriggers = cmd.getTriggers();\n        // if there are no aliases then fail, command would be impossible to trigger.\n        if (commandTriggers.length <= 0) {\n            return false;\n        }\n        // iterate the command aliases\n        for (String trigger : commandTriggers) {\n            // Check if the command is taken\n            if (registeredCommands.containsKey(trigger.toLowerCase())) {\n                System.out.println(\"Failed to register command with alias '\" + trigger + \"', already taken!\");\n                continue;   // Command name is taken already\n            }\n            // register an entry for this command trigger\n            registeredCommands.put(trigger.toLowerCase(), cmd);\n        }\n        helpCommand.addCommand(cmd);    // add the command to the help list\n        return true;\n    }\n"]], "pred": {"ppl": 2.4650187492370605, "ppl_lower": 2.6438093185424805, "ppl/lowercase_ppl": -1.0776118739695733, "ppl/zlib": 0.0007413306603509366, "Min_5.0% Prob": 7.261535634385779, "Min_10.0% Prob": 5.6072045351329605, "Min_20.0% Prob": 3.868947189732602, "Min_30.0% Prob": 2.8850475092728933, "Min_40.0% Prob": 2.2276875931681612, "Min_50.0% Prob": 1.8004614867958701, "Min_60.0% Prob": 1.5044577304720748}}
{"hexsha": "6eb6673bcc56080af10b538418c371bfeb5b0414", "ext": "java", "lang": "Java", "content": "public final class PersistedOutputRDD implements OutputRDD, PersistResultGraphAware {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PersistedOutputRDD.class);\n\n    @Override\n    public void writeGraphRDD(final Configuration configuration, final JavaPairRDD<Object, VertexWritable> graphRDD) {\n        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))\n            LOGGER.warn(\"The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set \" + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + \" to true\");\n        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))\n            throw new IllegalArgumentException(\"There is no provided \" + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + \" to write the persisted RDD to\");\n        SparkContextStorage.open(configuration).rm(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));  // this might be bad cause it unpersists the job RDD\n        // determine which storage level to persist the RDD as with MEMORY_ONLY being the default cache()\n        final StorageLevel storageLevel = StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, \"MEMORY_ONLY\"));\n        if (!configuration.getBoolean(Constants.GREMLIN_HADOOP_GRAPH_WRITER_HAS_EDGES, true))\n            graphRDD.mapValues(vertex -> {\n                vertex.get().dropEdges(Direction.BOTH);\n                return vertex;\n            }).setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)\n                    // call action to eager store rdd\n                    .count();\n        else\n            graphRDD.setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)\n                    // call action to eager store rdd\n                    .count();\n        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD\n    }\n\n    @Override\n    public <K, V> Iterator<KeyValue<K, V>> writeMemoryRDD(final Configuration configuration, final String memoryKey, final JavaPairRDD<K, V> memoryRDD) {\n        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))\n            LOGGER.warn(\"The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set \" + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + \" to true\");\n        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))\n            throw new IllegalArgumentException(\"There is no provided \" + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + \" to write the persisted RDD to\");\n        final String memoryRDDName = Constants.getMemoryLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION), memoryKey);\n        Spark.removeRDD(memoryRDDName);\n        memoryRDD.setName(memoryRDDName).persist(StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, \"MEMORY_ONLY\")))\n                // call action to eager store rdd\n                .count();\n        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD\n        return IteratorUtils.map(memoryRDD.collect().iterator(), tuple -> new KeyValue<>(tuple._1(), tuple._2()));\n    }\n\n    @Override\n    public boolean supportsResultGraphPersistCombination(final GraphComputer.ResultGraph resultGraph, final GraphComputer.Persist persist) {\n        return persist.equals(GraphComputer.Persist.NOTHING) || resultGraph.equals(GraphComputer.ResultGraph.NEW);\n    }\n}", "class_id": 0, "repo": "joestrouth1/tinkerpop", "file": "spark-gremlin/src/main/java/org/apache/tinkerpop/gremlin/spark/structure/io/PersistedOutputRDD.java", "last_update_at": "2018-11-26T11:54:21+00:00", "question_id": "6eb6673bcc56080af10b538418c371bfeb5b0414", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class PersistedOutputRDD implements OutputRDD, PersistResultGraphAware {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PersistedOutputRDD.class);\n    @Override\n    public void writeGraphRDD(final Configuration configuration, final JavaPairRDD<Object, VertexWritable> graphRDD) {\n        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))\n            LOGGER.warn(\"The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set \" + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + \" to true\");\n        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))\n            throw new IllegalArgumentException(\"There is no provided \" + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + \" to write the persisted RDD to\");\n        SparkContextStorage.open(configuration).rm(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));  // this might be bad cause it unpersists the job RDD\n        // determine which storage level to persist the RDD as with MEMORY_ONLY being the default cache()\n        final StorageLevel storageLevel = StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, \"MEMORY_ONLY\"));\n        if (!configuration.getBoolean(Constants.GREMLIN_HADOOP_GRAPH_WRITER_HAS_EDGES, true))\n            graphRDD.mapValues(vertex -> {\n                vertex.get().dropEdges(Direction.BOTH);\n                return vertex;\n            }).setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)\n                    // call action to eager store rdd\n                    .count();\n        else\n            graphRDD.setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)\n                    // call action to eager store rdd\n                    .count();\n        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD\n    }\n    @Override\n    public <K, V> Iterator<KeyValue<K, V>> writeMemoryRDD(final Configuration configuration, final String memoryKey, final JavaPairRDD<K, V> memoryRDD) {\n        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))\n            LOGGER.warn(\"The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set \" + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + \" to true\");\n        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))\n            throw new IllegalArgumentException(\"There is no provided \" + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + \" to write the persisted RDD to\");\n        final String memoryRDDName = Constants.getMemoryLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION), memoryKey);\n        Spark.removeRDD(memoryRDDName);\n        memoryRDD.setName(memoryRDDName).persist(StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, \"MEMORY_ONLY\")))\n                // call action to eager store rdd\n                .count();\n        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD\n        return IteratorUtils.map(memoryRDD.collect().iterator(), tuple -> new KeyValue<>(tuple._1(), tuple._2()));\n    }\n    @Override\n    public boolean supportsResultGraphPersistCombination(final GraphComputer.ResultGraph resultGraph, final GraphComputer.Persist persist) {\n        return persist.equals(GraphComputer.Persist.NOTHING) || resultGraph.equals(GraphComputer.ResultGraph.NEW);\n    }\n"]], "pred": {"ppl": 1.965025782585144, "ppl_lower": 2.451388120651245, "ppl/lowercase_ppl": -1.3273831547592558, "ppl/zlib": 0.000640896931825063, "Min_5.0% Prob": 6.705346490822587, "Min_10.0% Prob": 5.001727143923442, "Min_20.0% Prob": 3.174844903688805, "Min_30.0% Prob": 2.23030101366682, "Min_40.0% Prob": 1.6848314876843489, "Min_50.0% Prob": 1.351414788761331, "Min_60.0% Prob": 1.1271130742689786}}
{"hexsha": "41288d5daa6adf697bd717473b3209a71253605b", "ext": "java", "lang": "Java", "content": "public class MathUtils {\n\t\n\tprivate MathUtils () {} ;\n\t\n\t\n\tpublic static List<Pair<Float, Float> > cubicBezier (int npoints, float x0, float y0, float c1x, float c1y, float c2x, float c2y, float x, float y)\n\t{\n\t\tList<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;\n\t\tfor (int i = 0 ; i < npoints ; ++i)\n\t\t{\n\t\t\tfloat t = (i+1) * 1f / (float)(npoints) ;\n\t\t\tfloat xf = cubicBezier (t, x0, c1x, c2x, x) ;\n\t\t\tfloat yf = cubicBezier (t, y0, c1y, c2y, y) ;\n\t\t\tret.add(Pair.newPair(xf, yf)) ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\t\n\tprivate static float cubicBezier (float t, float f0, float f1, float f2, float f)\n\t{\n\t\treturn (float) (Math.pow((1 - t), 3) * f0 + 3 * Math.pow((1 - t), 2) * t * f1 + 3 * (1 - t) * Math.pow(t, 2) * f2 + Math.pow(t, 3) * f) ;\n\t}\n\t\n\t\n\tpublic static List<Pair<Float, Float> > quadraticBezier (int npoints, float x0, float y0, float cpx, float cpy, float x, float y)\n\t{\n\t\tList<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;\n\t\tfor (int i = 0 ; i < npoints ; ++i)\n\t\t{\n\t\t\tfloat t = (i+1) * 1f / (float)(npoints) ;\n\t\t\tfloat xf = quadraticBezier (t, x0, cpx, x) ;\n\t\t\tfloat yf = quadraticBezier (t, y0, cpy, y) ;\n\t\t\tret.add(Pair.newPair(xf, yf)) ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\n\tprivate static float quadraticBezier (float t, float f0, float f1, float f)\n\t{\n\t\treturn (float) (Math.pow((1 - t), 2) * f0 + 2 * (1 - t) * t * f1 + Math.pow(t, 2) * f) ;\n\t}\n\t\n\t\n\tpublic static float distancePointToLineSegment (Pair<Float, Float> s1, Pair<Float, Float> s2, Pair<Float, Float> p)\n\t{\n\t\tfloat distSqS1S2 = distanceSquared (s1, s2) ;\n\t\tif (Math.abs(distSqS1S2) < Float.MIN_NORMAL)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s1, p)) ;\n\t\tfloat dotS1PS2P = (p.getFirst() - s1.getFirst()) * (s2.getFirst() - s1.getFirst()) \n\t\t\t\t+ (p.getSecond() - s1.getSecond()) * (s2.getSecond() - s1.getSecond())  ;\n\t\tfloat vecS1PProj = dotS1PS2P / distSqS1S2 ;\n\t\tif (vecS1PProj < 0)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s1, p)) ;\n\t\tif (vecS1PProj > 1)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s2, p)) ;\n\t\tfloat xinter = s1.getFirst() + vecS1PProj * (s2.getFirst() - s1.getFirst()) ;\n\t\tfloat yinter = s1.getSecond() + vecS1PProj * (s2.getSecond() - s1.getSecond()) ;\n\t\treturn (float) Math.sqrt(distanceSquared (Pair.newPair(xinter, yinter), p)) ;\n\t}\n\t\n\t\n\tpublic static float distanceSquared (Pair<Float, Float> p1, Pair<Float, Float> p2)\n\t{\n\t\treturn (float) (Math.pow((p1.getFirst() - p2.getFirst()), 2) + Math.pow((p1.getSecond() - p2.getSecond()), 2)) ;\n\t}\n\t\n\t\n\tpublic static boolean arePointsEqual (Pair<Float, Float> p1, Pair<Float, Float> p2)\n\t{\n\t\tif (p1 == null && p2 == null)\n\t\t\treturn true ;\n\t\tif (p1 == null || p2 == null)\n\t\t\treturn false ;\n\t\tfinal float epsilon = Float.MIN_NORMAL ;\n\t\treturn Math.abs(p1.getFirst() - p2.getFirst()) <= epsilon \n\t\t\t\t&& Math.abs(p1.getSecond() - p2.getSecond()) <= epsilon ;\n\t}\n\t\n\t\n\tpublic static Integer getNearestPointIndexInList (Pair<Float, Float> p, List<Pair<Float, Float> > list, float threshold)\n\t{\n\t\tif (list == null || p == null)\n\t\t\tthrow new NullPointerException () ;\n\t\tif (list.isEmpty())\n\t\t\treturn null ;\n\t\tfloat distance2 = Float.MAX_VALUE ;\n\t\tfloat threshold2 = threshold * threshold ;\n\t\tInteger ret = null ;\n\t\tint currIndex = 0 ;\n\t\tfor (Pair<Float, Float> pt : list)\n\t\t{\n\t\t\tfloat dist2 = distanceSquared (p, pt) ;\n\t\t\tif (dist2 <= threshold2) {\n\t\t\t\tif (dist2 < distance2) {\n\t\t\t\t\tdistance2 = dist2 ;\n\t\t\t\t\tret = Integer.valueOf(currIndex) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++currIndex ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\t\n\tpublic static float getAngleBetweenVectors (Pair<Float, Float> v1, Pair<Float, Float> v2)\n\t{\n\t\tfloat vxref = v1.getFirst() ;\n\t\tfloat vyref = v1.getSecond() ;\n\n\t\tfloat vx = v2.getFirst() ;\n\t\tfloat vy = v2.getSecond() ;\n\t\t\n\t\tfinal float epsilon = Float.MIN_NORMAL ;\n\t\tif (Math.abs(vxref) < epsilon && Math.abs(vyref) < epsilon \n\t\t\t\t|| Math.abs(vx) < epsilon && Math.abs(vy) < epsilon) {\n\t\t\tthrow new IllegalArgumentException (\"The magnitude of the vectors cannot be zero\") ;\n\t\t}\n\t\tdouble nref = (float) Math.sqrt(vxref * vxref + vyref * vyref) ;\n\t\tdouble n = (float) Math.sqrt(vx * vx + vy * vy) ;\n\t\tdouble dotP = vxref * vx + vyref * vy ;\n\t\t\n\t\tdouble cos = dotP / (nref * n) ;\n\t\tif (Math.abs(cos) > 1d) {\n\t\t\tcos = Math.signum (cos) * 1d ;\n\t\t}\n\t\tdouble alpha = Math.acos(cos) ;\n\t\treturn (float) Math.abs(alpha) ;\t\n\t}\n}", "class_id": 0, "repo": "roikku/hitsujun", "file": "core/src/main/java/com/hitsujun/core/util/MathUtils.java", "last_update_at": "2018-12-28T16:52:32+00:00", "question_id": "41288d5daa6adf697bd717473b3209a71253605b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MathUtils {\n\t\n\tprivate MathUtils () {} ;\n\t\n\t\n\tpublic static List<Pair<Float, Float> > cubicBezier (int npoints, float x0, float y0, float c1x, float c1y, float c2x, float c2y, float x, float y)\n\t{\n\t\tList<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;\n\t\tfor (int i = 0 ; i < npoints ; ++i)\n\t\t{\n\t\t\tfloat t = (i+1) * 1f / (float)(npoints) ;\n\t\t\tfloat xf = cubicBezier (t, x0, c1x, c2x, x) ;\n\t\t\tfloat yf = cubicBezier (t, y0, c1y, c2y, y) ;\n\t\t\tret.add(Pair.newPair(xf, yf)) ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\t\n\tprivate static float cubicBezier (float t, float f0, float f1, float f2, float f)\n\t{\n\t\treturn (float) (Math.pow((1 - t), 3) * f0 + 3 * Math.pow((1 - t), 2) * t * f1 + 3 * (1 - t) * Math.pow(t, 2) * f2 + Math.pow(t, 3) * f) ;\n\t}\n\t\n\t\n\tpublic static List<Pair<Float, Float> > quadraticBezier (int npoints, float x0, float y0, float cpx, float cpy, float x, float y)\n\t{\n\t\tList<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;\n\t\tfor (int i = 0 ; i < npoints ; ++i)\n\t\t{\n\t\t\tfloat t = (i+1) * 1f / (float)(npoints) ;\n\t\t\tfloat xf = quadraticBezier (t, x0, cpx, x) ;\n\t\t\tfloat yf = quadraticBezier (t, y0, cpy, y) ;\n\t\t\tret.add(Pair.newPair(xf, yf)) ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\tprivate static float quadraticBezier (float t, float f0, float f1, float f)\n\t{\n\t\treturn (float) (Math.pow((1 - t), 2) * f0 + 2 * (1 - t) * t * f1 + Math.pow(t, 2) * f) ;\n\t}\n\t\n\t\n\tpublic static float distancePointToLineSegment (Pair<Float, Float> s1, Pair<Float, Float> s2, Pair<Float, Float> p)\n\t{\n\t\tfloat distSqS1S2 = distanceSquared (s1, s2) ;\n\t\tif (Math.abs(distSqS1S2) < Float.MIN_NORMAL)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s1, p)) ;\n\t\tfloat dotS1PS2P = (p.getFirst() - s1.getFirst()) * (s2.getFirst() - s1.getFirst()) \n\t\t\t\t+ (p.getSecond() - s1.getSecond()) * (s2.getSecond() - s1.getSecond())  ;\n\t\tfloat vecS1PProj = dotS1PS2P / distSqS1S2 ;\n\t\tif (vecS1PProj < 0)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s1, p)) ;\n\t\tif (vecS1PProj > 1)\n\t\t\treturn (float) Math.sqrt(distanceSquared (s2, p)) ;\n\t\tfloat xinter = s1.getFirst() + vecS1PProj * (s2.getFirst() - s1.getFirst()) ;\n\t\tfloat yinter = s1.getSecond() + vecS1PProj * (s2.getSecond() - s1.getSecond()) ;\n\t\treturn (float) Math.sqrt(distanceSquared (Pair.newPair(xinter, yinter), p)) ;\n\t}\n\t\n\t\n\tpublic static float distanceSquared (Pair<Float, Float> p1, Pair<Float, Float> p2)\n\t{\n\t\treturn (float) (Math.pow((p1.getFirst() - p2.getFirst()), 2) + Math.pow((p1.getSecond() - p2.getSecond()), 2)) ;\n\t}\n\t\n\t\n\tpublic static boolean arePointsEqual (Pair<Float, Float> p1, Pair<Float, Float> p2)\n\t{\n\t\tif (p1 == null && p2 == null)\n\t\t\treturn true ;\n\t\tif (p1 == null || p2 == null)\n\t\t\treturn false ;\n\t\tfinal float epsilon = Float.MIN_NORMAL ;\n\t\treturn Math.abs(p1.getFirst() - p2.getFirst()) <= epsilon \n\t\t\t\t&& Math.abs(p1.getSecond() - p2.getSecond()) <= epsilon ;\n\t}\n\t\n\t\n\tpublic static Integer getNearestPointIndexInList (Pair<Float, Float> p, List<Pair<Float, Float> > list, float threshold)\n\t{\n\t\tif (list == null || p == null)\n\t\t\tthrow new NullPointerException () ;\n\t\tif (list.isEmpty())\n\t\t\treturn null ;\n\t\tfloat distance2 = Float.MAX_VALUE ;\n\t\tfloat threshold2 = threshold * threshold ;\n\t\tInteger ret = null ;\n\t\tint currIndex = 0 ;\n\t\tfor (Pair<Float, Float> pt : list)\n\t\t{\n\t\t\tfloat dist2 = distanceSquared (p, pt) ;\n\t\t\tif (dist2 <= threshold2) {\n\t\t\t\tif (dist2 < distance2) {\n\t\t\t\t\tdistance2 = dist2 ;\n\t\t\t\t\tret = Integer.valueOf(currIndex) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++currIndex ;\n\t\t}\n\t\treturn ret ;\n\t}\n\t\n\t\n\tpublic static float getAngleBetweenVectors (Pair<Float, Float> v1, Pair<Float, Float> v2)\n\t{\n\t\tfloat vxref = v1.getFirst() ;\n\t\tfloat vyref = v1.getSecond() ;\n\t\tfloat vx = v2.getFirst() ;\n\t\tfloat vy = v2.getSecond() ;\n\t\t\n\t\tfinal float epsilon = Float.MIN_NORMAL ;\n\t\tif (Math.abs(vxref) < epsilon && Math.abs(vyref) < epsilon \n\t\t\t\t|| Math.abs(vx) < epsilon && Math.abs(vy) < epsilon) {\n\t\t\tthrow new IllegalArgumentException (\"The magnitude of the vectors cannot be zero\") ;\n\t\t}\n\t\tdouble nref = (float) Math.sqrt(vxref * vxref + vyref * vyref) ;\n\t\tdouble n = (float) Math.sqrt(vx * vx + vy * vy) ;\n\t\tdouble dotP = vxref * vx + vyref * vy ;\n\t\t\n\t\tdouble cos = dotP / (nref * n) ;\n\t\tif (Math.abs(cos) > 1d) {\n\t\t\tcos = Math.signum (cos) * 1d ;\n\t\t}\n\t\tdouble alpha = Math.acos(cos) ;\n\t\treturn (float) Math.abs(alpha) ;\t\n\t}\n"]], "pred": {"ppl": 1.3681684732437134, "ppl_lower": 1.4402518272399902, "ppl/lowercase_ppl": -1.1637940733492214, "ppl/zlib": 0.00026122747047798903, "Min_5.0% Prob": 4.310089938780841, "Min_10.0% Prob": 2.7774945561792337, "Min_20.0% Prob": 1.5319648068033012, "Min_30.0% Prob": 1.0383153867426944, "Min_40.0% Prob": 0.7811688895731217, "Min_50.0% Prob": 0.6265709203423717, "Min_60.0% Prob": 0.5227924034352297}}
{"hexsha": "2a56e6c382aefd0652c476baa9969d716d68fafe", "ext": "java", "lang": "Java", "content": "public class ChargeHelperActivity extends BaseActivity\n{\n  public void onCreate(Bundle paramBundle)\n  {\n    super.onCreate(paramBundle);\n    setContentView(2130903091);\n    b(2131034362);\n  }\n}", "class_id": 0, "repo": "clilystudio/NetBook", "file": "allsrc/com/ushaqi/zhuishushenqi/ui/user/ChargeHelperActivity.java", "last_update_at": "2018-02-04T12:23:55+00:00", "question_id": "2a56e6c382aefd0652c476baa9969d716d68fafe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ChargeHelperActivity extends BaseActivity\n{\n  public void onCreate(Bundle paramBundle)\n  {\n    super.onCreate(paramBundle);\n    setContentView(2130903091);\n    b(2131034362);\n  }\n"]], "pred": {"ppl": 3.1661057472229004, "ppl_lower": 4.371249675750732, "ppl/lowercase_ppl": -1.2798663014654394, "ppl/zlib": 0.00794829215029416, "Min_5.0% Prob": 7.513176282246907, "Min_10.0% Prob": 6.255225817362468, "Min_20.0% Prob": 4.3926813419048605, "Min_30.0% Prob": 3.507817828655243, "Min_40.0% Prob": 2.8151267579308263, "Min_50.0% Prob": 2.2901876976384834, "Min_60.0% Prob": 1.9572838175110518}}
{"hexsha": "b891b11d8b3212c7191392e74938f028378faa0c", "ext": "java", "lang": "Java", "content": "public final class GenListModuleFilter extends AbstractXMLFilter {\n    \n    public static final String PI_PATH2PROJ_TARGET = \"path2project\";\n    public static final String PI_PATH2PROJ_TARGET_URI = \"path2project-uri\";\n//    public static final String PI_WORKDIR_TARGET = \"workdir\";\n    public static final String PI_WORKDIR_TARGET_URI = \"workdir-uri\";\n    \n    /** Inherited attributes and their default values. */\n    private static final Map<String, String> inheritedAtts = new HashMap<String, String>();\n    static {\n        inheritedAtts.put(ATTRIBUTE_NAME_SCOPE, ATTR_SCOPE_VALUE_LOCAL);\n        inheritedAtts.put(ATTRIBUTE_NAME_PROCESSING_ROLE, ATTR_PROCESSING_ROLE_VALUE_NORMAL);\n    }\n    \n    /** Output utilities */\n    private Job job;\n    /** Basedir of the current parsing file */\n    private URI currentDir = null;\n    /** Set of all the non-conref and non-copyto targets refered in current parsing file */\n    private final Set<Reference> nonConrefCopytoTargets;\n    /** Set of sources of those copy-to that were ignored */\n    private final Set<File> ignoredCopytoSourceSet;\n    /** Map of copy-to target to souce */\n    private final Map<File, File> copytoMap;\n    /** chunk nesting level */\n    private int chunkLevel = 0;\n    /** mark topics in reltables */\n    private int relTableLevel = 0;\n    /** chunk to-navigation level */\n    private int chunkToNavLevel = 0;\n    /** Topic group nesting level */\n    private int topicGroupLevel = 0;\n    /** Flag used to mark if current file is still valid after filtering */\n    /** Set of outer dita files */\n    private final Set<File> outDitaFilesSet;\n    /** Absolute system path to file being processed */\n    private URI currentFile = null;\n    /** System path to file being processed, relative to base directory. */\n    private URI currentFileRelative;\n//    private boolean setSystemid = true;\n    /** Stack of inherited attributes. */\n    private final Deque<AttributesImpl> inheritedAttsStack;\n    /** Topics with processing role of \"resource-only\" */\n    private final Set<File> resourceOnlySet;\n    /** Topics with processing role of \"normal\" */\n    private final Set<File> normalProcessingSet;\n//    private final List<ExportAnchor> resultList = new ArrayList<ExportAnchor>();\n//    private ExportAnchor currentExportAnchor;\n//    /** Flag to show whether a file has <exportanchors> tag */\n//    private boolean hasExport = false;\n//    /** For topic/dita files whether a </file> tag should be added */\n//    private boolean shouldAppendEndTag = false;\n//    /** Store the href of topicref tag */\n//    private String topicHref = \"\";\n//    /** Topicmeta set for merge multiple exportanchors into one. Each topicmeta/prolog can define many exportanchors */\n//    private final Set<String> topicMetaSet;\n//    /** Refered topic id */\n//    private String topicId = \"\";\n//    /** Map to store plugin id */\n//    private final Map<String, Set<String>> pluginMap = new HashMap<String, Set<String>>();\n//    /** Transtype */\n//    private String transtype;\n    /** Map to store referenced branches. */\n    private final Map<String, List<String>> validBranches;\n    /** Int to mark referenced nested elements. */\n    private int level;\n    /** Topicref stack */\n    private final Stack<String> topicrefStack;\n    private String path2Project;\n    /** Absolute system path to input file parent directory */\n    private URI inputDir;\n    private URI inputFile;\n    private File tempDir;\n    private final Map<String, Integer> counterMap;\n    /** File info map. */\n    private final Map<String, FileInfo.Builder> fileInfoMap;\n    /** File info for the current document. */\n    private FileInfo.Builder fileInfo;\n    private boolean isRootElement = true;\n    private DitaClass rootClass = null;\n    private boolean isStartDocument = false;\n\n    /**\n     * Constructor.\n     */\n    public GenListModuleFilter() {\n        nonConrefCopytoTargets = new HashSet<Reference>(64);\n        copytoMap = new HashMap<File, File>(16);\n        ignoredCopytoSourceSet = new HashSet<File>(16);\n        outDitaFilesSet = new HashSet<File>(64);\n//        processRoleLevel = 0;\n//        processRoleStack = new Stack<String>();\n        inheritedAttsStack = new ArrayDeque<AttributesImpl>();\n        resourceOnlySet = new HashSet<File>(32);\n        normalProcessingSet = new HashSet<File>(32);\n//        topicMetaSet = new HashSet<String>(INT_16);\n        validBranches = new HashMap<String, List<String>>(32);\n        counterMap = new HashMap<String, Integer>();\n        level = 0;\n        topicrefStack = new Stack<String>();\n        fileInfoMap = new HashMap<String, FileInfo.Builder>();\n    }\n    \n    /**\n     * \n     * Reset the internal variables.\n     */\n    public void reset() {\n        currentDir = null;\n        chunkLevel = 0;\n        relTableLevel = 0;\n        chunkToNavLevel = 0;\n        topicGroupLevel = 0;\n        nonConrefCopytoTargets.clear();\n        copytoMap.clear();\n        ignoredCopytoSourceSet.clear();\n        outDitaFilesSet.clear();\n        level = 0;\n        topicrefStack.clear();\n//        processRoleLevel = 0;\n//        processRoleStack.clear();\n        inheritedAttsStack.clear();\n        currentFileRelative = null;\n        path2Project = null;\n        counterMap.clear();\n        fileInfo = null;\n        fileInfoMap.clear();\n        isRootElement = true;\n        rootClass = null;\n        isStartDocument = false;\n        // Don't clean:\n        // resourceOnlySet\n        // normalProcessingSet\n    }\n\n//    /**\n//     * Set transtype.\n//     * \n//     * @param transtype the transtype to set\n//     */\n//    public void setTranstype(final String transtype) {\n//        this.transtype = transtype;\n//    }\n//\n//    /**\n//     * @return the pluginMap\n//     */\n//    public Map<String, Set<String>> getPluginMap() {\n//        return pluginMap;\n//    }\n//\n//    /**\n//     * Get export anchors.\n//     * \n//     * @return list of export anchors\n//     */\n//    public List<ExportAnchor> getExportAnchors() {\n//        return resultList;\n//    }\n\n    /**\n     * Current document is processing start document.\n     */\n    public void isStartDocument(final boolean isStartDocument) {\n        this.isStartDocument = isStartDocument;\n    }\n    \n    /**\n     * Set output utilities.\n     * \n     * @param job output utils\n     */\n    public void setJob(final Job job) {\n        this.job = job;\n    }\n\n    /**\n     * Get out file set.\n     * \n     * @return out file set\n     */\n    public Set<File> getOutFilesSet() {\n        return outDitaFilesSet;\n    }\n\n    /**\n     * List of files with \"@processing-role=resource-only\".\n     * \n     * @return the resource-only set\n     */\n    public Set<File> getResourceOnlySet() {\n        final Set<File> res = new HashSet<File>(resourceOnlySet);\n        res.removeAll(normalProcessingSet);\n        return res;\n    }\n\n    /**\n     * Get all targets except copy-to.\n     * \n     * @return set of target file path references\n     */\n    public Set<Reference> getNonCopytoResult() {\n        final Set<Reference> nonCopytoSet = new HashSet<Reference>(128);\n\n        nonCopytoSet.addAll(nonConrefCopytoTargets);\n        for (final Builder b: fileInfoMap.values()) {\n            final FileInfo f = b.build();\n            if (f.isConrefTarget) {\n                nonCopytoSet.add(new Reference(f.file.getPath(), f.format));\n            }\n        }\n        for (final File f : copytoMap.values()) {\n            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));\n        }\n        for (final File f : ignoredCopytoSourceSet) {\n            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));\n        }\n//        for (final String filename : subsidiarySet) {\n//            // only activated on /generateout:3 & is out file.\n//            if (isOutFile(filename) && OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.OLDSOLUTION) {\n//                nonCopytoSet.add(new Reference(filename));\n//            }\n//        }\n        // nonCopytoSet.addAll(subsidiarySet);\n        return nonCopytoSet;\n    }\n\n    /**\n     * Get outditafileslist.\n     * \n     * @return Returns the outditafileslist.\n     */\n    public Set<File> getOutDitaFilesSet() {\n        return outDitaFilesSet;\n    }\n\n    /**\n     * Get non-conref and non-copyto targets.\n     * \n     * @return Returns the nonConrefCopytoTargets.\n     */\n    public Set<File> getNonConrefCopytoTargets() {\n        final Set<File> res = new HashSet<File>(nonConrefCopytoTargets.size());\n        for (final Reference r : nonConrefCopytoTargets) {\n            res.add(new File(r.filename));\n        }\n        return res;\n    }\n\n    /**\n     * Returns the ignoredCopytoSourceSet.\n     * \n     * @return Returns the ignoredCopytoSourceSet.\n     */\n    public Set<File> getIgnoredCopytoSourceSet() {\n        return ignoredCopytoSourceSet;\n    }\n\n    /**\n     * Get the copy-to map.\n     * \n     * @return copy-to map\n     */\n    public Map<File, File> getCopytoMap() {\n        return copytoMap;\n    }\n\n    /**\n     * Set the relative directory of current file.\n     * \n     * @param dir dir\n     */\n    public void setCurrentDir(final URI dir) {\n        currentDir = dir;\n    }\n    \n    /**\n     * Set processing input directory absolute path.\n     * \n     * @param inputFile absolute path to base directory\n     */\n    public void setInputDir(final URI inputDir) {\n        this.inputDir = inputDir;\n    }\n\n    \n    /**\n     * Set processing input file absolute path.\n     * \n     * @param inputFile absolute path to root file\n     */\n    public void setInputFile(final URI inputFile) {\n        this.inputFile = inputFile;\n    }\n    \n    /**\n     * Set current file absolute path\n     * \n     * @param currentFile absolute path to current file\n     */\n    public void setCurrentFile(final URI currentFile) {\n        this.currentFile = currentFile;\n    }\n    \n    /**\n     * Set temporary directory\n     * @param tempDir absolute path to temporary directory\n     */\n    public void setTempDir(final File tempDir) {\n        this.tempDir = tempDir;\n    }\n\n    /**\n     * Get file info for the current file.\n     */\n    public List<FileInfo> getFileInfo() {\n        final List<FileInfo> res = new ArrayList<FileInfo>();\n        //res.add(fileInfo.build());\n        for (final Builder b: fileInfoMap.values()) {\n            res.add(b.build());\n        }\n        return res;\n    }\n    \n    // Content handler methods\n    \n    /**\n     * Check if the current file is a ditamap with\n     * \"@processing-role=resource-only\".\n     */\n    @Override\n    public void startDocument() throws SAXException {\n        currentFileRelative = inputDir.relativize(currentFile);\n        path2Project = getPathtoProject(toFile(currentFileRelative), toFile(currentFile.toString()), job.getInputFile().getAbsolutePath());\n        fileInfo = getOrCreateBuilder(currentFileRelative);\n        \n        super.startDocument();\n        outputProcessingInstructions();\n    }\n\n    /**\n     * Generate processing instructions to the beginning of the document.\n     * \n     * <p>The following processing instructions are added before the root element:</p>\n     * <dl>\n     *   <!--dt>{@link #PI_WORKDIR_TARGET}<dt>\n     *   <dd>Absolute system path of the file parent directory. On Windows, a {@code /}\n     *     is added to beginning of the path.</dd-->\n     *   <dt>{@link #PI_WORKDIR_TARGET_URI}<dt>\n     *   <dd>Absolute URI of the file parent directory.</dd>\n     *   <dt>{@link #PI_PATH2PROJ_TARGET}<dt>\n     *   <dd>Relative system path to the output directory, with a trailing directory separator.\n     *     When the source file is in the project root directory, processing instruction has no value.</dd>\n     *   <dt>{@link #PI_PATH2PROJ_TARGET_URI}<dt>\n     *   <dd>Relative URI to the output directory, with a trailing path separator.\n     *     When the source file is in the project root directory, processing instruction has value {@code ./}.</dd>\n     * </dl> \n     */\n    private void outputProcessingInstructions() throws SAXException {\n        final URI workDir = tempDir.toURI().resolve(currentFileRelative).resolve(\".\");\n//        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {\n//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, new File(workDir).getAbsolutePath());\n//        } else {\n//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, UNIX_SEPARATOR + new File(workDir).getAbsolutePath());\n//        }\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n        getContentHandler().processingInstruction(PI_WORKDIR_TARGET_URI, workDir.toString());\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n        if (path2Project != null) {\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, path2Project);\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, toURI(path2Project).toString());\n        } else {\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, \"\");\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, \".\" + UNIX_SEPARATOR);\n        }\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n    }\n    \n    /**\n     * Push inherited attributes to the stack.\n     */\n    private void pushInheritedAttributes(final Attributes atts) {\n        final AttributesImpl res = new AttributesImpl();\n        for (final Entry<String, String> e: inheritedAtts.entrySet()) {\n            final String current = atts.getValue(e.getKey());\n            if (current != null) {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), current);\n            } else if (!inheritedAttsStack.isEmpty()) {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), getInherited(e.getKey()));\n            } else {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), e.getValue());\n            }\n        }\n        inheritedAttsStack.addFirst(res);\n    }\n    /**\n     * Get inherited attribute value.\n     * @param name attribute name\n     * @return attribute value or {@code null} if not available\n     */\n    private String getInherited(final String name) {\n        return inheritedAttsStack.peekFirst().getValue(name);\n    }\n    \n    @Override\n    public void startElement(final String uri, final String localName, final String qName, final Attributes atts)\n            throws SAXException {\n        pushInheritedAttributes(atts);\n        \n        handleProcessingRole(atts);\n        \n        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n\n        handleRootElement(localName, atts);\n\n//        // when meets topic tag\n//        if (TOPIC_TOPIC.matches(classValue)) {\n//            topicId = atts.getValue(ATTRIBUTE_NAME_ID);\n//            // relpace place holder with first topic id\n//            // Get relative file name\n//            for (final ExportAnchor e : resultList) {\n//                if (e.topicids.contains(currentFileRelative + QUESTION)) {\n//                    e.topicids.add(topicId);\n//                    e.topicids.remove(currentFileRelative + QUESTION);\n//                }\n//            }\n//        }\n\n//        // merge multiple exportanchors into one\n//        // Each <topicref> can only have one <topicmeta>.\n//        // Each <topic> can only have one <prolog>\n//        // and <metadata> can have more than one exportanchors\n//        // XXX: This should be moved to a separate filter as it's transtype specific\n//        if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {\n//            if (MAP_MAP.matches(classValue) \n//                    && FileUtils.isDITAMapFile(currentFile.getName()) && inputFile.equals(currentFile)) {\n//                String pluginId = atts.getValue(ATTRIBUTE_NAME_ID);\n//                if (pluginId == null) {\n//                    pluginId = \"org.sample.help.doc\";\n//                }\n//                final Set<String> set = StringUtils.restoreSet(pluginId);\n//                pluginMap.put(\"pluginId\", set);\n//            } else if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {\n//                topicMetaSet.add(qName);\n//            } else if (DELAY_D_EXPORTANCHORS.matches(classValue)) {\n//                hasExport = true;\n//                // If current file is a ditamap file\n//                if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                    // if dita file's extension name is \".xml\"\n//                    String editedHref = \"\";\n//                    if (topicHref.endsWith(FILE_EXTENSION_XML)) {\n//                        // change the extension to \".dita\" for latter compare\n//                        editedHref = topicHref.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);\n//                    } else {\n//                        editedHref = topicHref;\n//                    }\n//                    // editedHref = editedHref.replace(File.separator, \"/\");\n//                    currentExportAnchor = new ExportAnchor(editedHref);\n//                    // if <exportanchors> is defined in topicmeta(topicref), there is only one topic id\n//                    currentExportAnchor.topicids.add(topicId);\n//                    // If current file is topic file\n//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {\n//                    // if dita file's extension name is \".xml\"\n//                    if (currentFileRelative.endsWith(FILE_EXTENSION_XML)) {\n//                        // change the extension to \".dita\" for latter compare\n//                        currentFileRelative = currentFileRelative.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);\n//                    }\n//                    currentFileRelative = FileUtils.separatorsToUnix(currentFileRelative);\n//                    currentExportAnchor = new ExportAnchor(currentFileRelative);\n//                    // if <exportanchors> is defined in metadata(topic), there can be many topic ids\n//                    currentExportAnchor.topicids.add(topicId);\n//                    shouldAppendEndTag = true;\n//                }\n//            } else if (DELAY_D_ANCHORKEY.matches(classValue)) {\n//                // create keyref element in the StringBuffer\n//                // TODO in topic file is no keys\n//                final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);\n//                currentExportAnchor.keys.add(keyref);\n//            } else if (DELAY_D_ANCHORID.matches(classValue)) {\n//                // create keyref element in the StringBuffer\n//                final String id = atts.getValue(ATTRIBUTE_NAME_ID);\n//                // If current file is a ditamap file\n//                // The id can only be element id within a topic\n//                if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                    // id shouldn't be same as topic id in the case of duplicate insert\n//                    if (!topicId.equals(id)) {\n//                        currentExportAnchor.ids.add(id);\n//                    }\n//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {\n//                    // id shouldn't be same as topic id in the case of duplicate insert\n//                    if (!topicId.equals(id)) {\n//                        // topic id found\n//                        currentExportAnchor.ids.add(id);\n//                    }\n//                }\n//            }\n//        }\n\n        if (chunkLevel > 0 || atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {\n            chunkLevel++;\n        }\n        if (relTableLevel > 0 || MAP_RELTABLE.matches(classValue)) {\n            relTableLevel++;\n        }\n\n        if (chunkToNavLevel > 0) {\n            chunkToNavLevel++;\n        } else if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null\n                && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-navigation\")) {\n            chunkToNavLevel++;\n        }\n\n        if (topicGroupLevel > 0 || MAPGROUP_D_TOPICGROUP.matches(classValue)) {\n            topicGroupLevel++;\n        }\n\n        handleTopicRef(localName, atts);\n\n        try {\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_CONREF, currentDir);\n            handleConrefAttr(atts, currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_HREF, currentDir);\n            handleHrefAttr(atts, currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_DATA, atts.getValue(ATTRIBUTE_NAME_CODEBASE) != null ? new URI(atts.getValue(ATTRIBUTE_NAME_CODEBASE)) : currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_COPY_TO, currentDir);\n            handleCopyToAttr(atts, currentDir);\n        } catch (final URISyntaxException e) {\n            logger.error(\"Failed to parse URI: \" + e.getMessage(), e);\n        } catch (DITAOTException e) {\n            logger.error(\"Failed to process link: \" + e.getMessage(), e);\n        }\n        handleConactionAttr(atts);\n        handleKeyrefAttr(atts);\n        \n        super.startElement(uri, localName, qName, atts);\n    }\n\n    private void handleRootElement(final String localName, final Attributes atts) {\n        if (isRootElement) {\n            isRootElement = false;\n            final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n            if (classValue != null) {\n                rootClass = new DitaClass(atts.getValue(ATTRIBUTE_NAME_CLASS));\n            }\n            if (TOPIC_TOPIC.matches(rootClass)) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITA);\n            } else if (ELEMENT_NAME_DITA.equals(localName) && classValue == null) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITA);\n            } else if (MAP_MAP.matches(rootClass)) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITAMAP);\n            }\n            if (SUBJECTSCHEME_SUBJECTSCHEME.matches(rootClass)) {\n                fileInfo.isSubjectScheme(true);\n            }\n        }\n    }\n\n    private void handleTopicRef(final String localName, final Attributes atts) {\n        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n        if (MAP_TOPICREF.matches(classValue) && job.getOnlyTopicInMap() && isStartDocument) {\n            URI hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n            if (hrefValue == null) {\n                hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));\n            }\n            if (hrefValue != null) {\n                if (isExternal(hrefValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                // normalize href value.\n                final File target = toFile(hrefValue);\n                // caculate relative path for href value.\n                String fileName = null;\n                if (target.isAbsolute()) {\n                    fileName = FileUtils.getRelativeUnixPath(inputFile.toString(), hrefValue.toString());\n                }\n                fileName = FileUtils.separatorsToUnix(FileUtils.resolve(currentDir.toString(), hrefValue.toString()).getPath());\n\n                final boolean canParse = parseBranch(atts, hrefValue, fileName);\n                if (canParse) {\n                    topicrefStack.push(localName);\n                }\n            }\n        }\n    }\n\n    private void handleProcessingRole(final Attributes atts) {\n        final String href = atts.getValue(ATTRIBUTE_NAME_HREF);\n        final String scope = inheritedAttsStack.peekFirst().getValue(ATTRIBUTE_NAME_SCOPE);\n        if (href != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {\n            final String processingRole = getInherited(ATTRIBUTE_NAME_PROCESSING_ROLE);\n            final File target = FileUtils.resolve(currentDir.toString(), href);\n            if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {\n                resourceOnlySet.add(target);\n            } else if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processingRole)) {\n                normalProcessingSet.add(target);\n            }\n        }\n    }\n\n//    @Override\n//    public void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException {\n//        getContentHandler().characters(ch, start, length);\n//    }\n    \n    @Override\n    public void endElement(final String uri, final String localName, final String qName) throws SAXException {\n        // processing role\n//        if (processRoleLevel > 0) {\n//            if (processRoleLevel == processRoleStack.size()) {\n//                processRoleStack.pop();\n//            }\n//            processRoleLevel--;\n//        }\n        \n        if (chunkLevel > 0) {\n            chunkLevel--;\n        }\n        if (relTableLevel > 0) {\n            relTableLevel--;\n        }\n        if (chunkToNavLevel > 0) {\n            chunkToNavLevel--;\n        }\n        if (topicGroupLevel > 0) {\n            topicGroupLevel--;\n        }\n//        // <exportanchors> over should write </file> tag\n//\n//        if (topicMetaSet.contains(qName) && hasExport) {\n//            // If current file is a ditamap file\n//            if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                resultList.add(currentExportAnchor);\n//                currentExportAnchor = null;\n//                // If current file is topic file\n//            }\n//            hasExport = false;\n//            topicMetaSet.clear();\n//        }\n\n        if (!topicrefStack.isEmpty() && localName.equals(topicrefStack.peek())) {\n            level--;\n            topicrefStack.pop();\n        }\n\n        inheritedAttsStack.removeFirst();\n        super.endElement(uri, localName, qName);\n    }\n\n    /**\n     * Clean up.\n     */\n    @Override\n    public void endDocument() throws SAXException {\n        // processing role\n//        if (processRoleLevel > 0) {\n//            processRoleLevel--;\n//            processRoleStack.pop();\n//        }\n        \n//        if (FileUtils.isDITATopicFile(currentFile.getName()) && shouldAppendEndTag) {\n//            resultList.add(currentExportAnchor);\n//            currentExportAnchor = null;\n//            // should reset\n//            shouldAppendEndTag = false;\n//        }\n        \n        super.endDocument();\n    }\n    \n    /**\n     * Get file info builder from file info map or create new file info into the map. \n     * \n     * @param file file info path\n     * @return existing or new file info\n     */\n    private Builder getOrCreateBuilder(final String file) {\n        final String f = file.isEmpty() ? currentFileRelative.toString() : file;\n        FileInfo.Builder b = fileInfoMap.get(f);\n        if (b == null) {\n            b = new FileInfo.Builder().file(new File(f));\n            fileInfoMap.put(f, b);\n        }\n        return b;\n    }\n    private Builder getOrCreateBuilder(final URI file) {\n        return getOrCreateBuilder(file.toString());\n    }\n\n    /**\n     * Method for see whether a branch should be parsed.\n     * \n     * @param atts {@link Attributes}\n     * @param hrefValue {@link String}\n     * @param fileName normalized file name(remove '#')\n     * @return boolean\n     */\n    private boolean parseBranch(final Attributes atts, final URI hrefValue, final String fileName) {\n        // current file is primary ditamap file.\n        // parse every branch.\n        if (currentDir == null && isStartDocument) {\n            // add branches into map\n            addReferredBranches(hrefValue, fileName);\n            return true;\n        } else {\n            // current file is a sub-ditamap one.\n            // get branch's id\n            final String id = atts.getValue(ATTRIBUTE_NAME_ID);\n            // this branch is not referenced\n            if (level == 0 && StringUtils.isEmptyString(id)) {\n                // There is occassion that the whole ditamap should be parsed\n                final boolean found = searchBrachesMap(id);\n                if (found) {\n                    // Add this branch into map for parsing.\n                    addReferredBranches(hrefValue, fileName);\n                    // update level\n                    level++;\n                    return true;\n                } else {\n                    return false;\n                }\n                // this brach is a decendent of a referenced one\n            } else if (level != 0) {\n                // Add this branch into map for parsing.\n                addReferredBranches(hrefValue, fileName);\n                // update level\n                level++;\n                return true;\n                // This branch has an id but is a new one\n            } else if (!StringUtils.isEmptyString(id)) {\n                // search branches map.\n                final boolean found = searchBrachesMap(id);\n                // branch is referenced\n                if (found) {\n                    // Add this branch into map for parsing.\n                    addReferredBranches(hrefValue, fileName);\n                    // update level\n                    level++;\n                    return true;\n                } else {\n                    // this branch is not referenced\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Search braches map with branch id and current file name.\n     * \n     * @param id String branch id.\n     * @return boolean true if found and false otherwise.\n     */\n    private boolean searchBrachesMap(final String id) {\n        // seach the map with id & current file name.\n        if (validBranches.containsKey(currentFileRelative.getPath())) {\n            final List<String> branchIdList = validBranches.get(currentFileRelative.getPath());\n            // the branch is referenced.\n            if (branchIdList.contains(id)) {\n\n                return true;\n            } else // the whole map is referenced\n// the branch is not referred\n                return branchIdList.size() == 0;\n        } else {\n            // current file is not refered\n            return false;\n        }\n    }\n\n    /**\n     * Add branches into map.\n     * \n     * @param hrefValue\n     * @param fileName\n     */\n    private void addReferredBranches(final URI hrefValue, final String fileName) {\n        String branchId = null;\n        // href value has branch id.\n        if (hrefValue.getFragment() != null) {\n            branchId = hrefValue.getFragment();\n            // The map contains the file name\n            if (validBranches.containsKey(fileName)) {\n                final List<String> branchIdList = validBranches.get(fileName);\n                branchIdList.add(branchId);\n            } else {\n                final List<String> branchIdList = new ArrayList<String>();\n                branchIdList.add(branchId);\n                validBranches.put(fileName, branchIdList);\n            }\n            // href value has no branch id\n        } else {\n            validBranches.put(fileName, new ArrayList<String>());\n        }\n    }\n\n    /**\n     * Parse the input attributes for needed information.\n     * \n     * @param atts all attributes\n     * @param attrName attributes to process\n     */\n    private void parseLinkAttribute(final Attributes atts, final String attrName, final URI baseDir) {\n        URI attValue = toURI(atts.getValue(attrName));\n        if (attValue == null) {\n            return;\n        }\n        if (isExternal(attValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n            return;\n        }\n\n        // Ignore absolute paths for now\n//        if (new File(attrValue).isAbsolute() && // FIXME: cannot test for absolute here as the value is not a system path yet\n//                !ATTRIBUTE_NAME_DATA.equals(attrName)) {\n//            attrValue = FileUtils.getRelativePath(inputFile.getAbsolutePath(), attrValue);\n//        // for object tag bug:3052156\n//        } else\n        final File file = FileUtils.resolve(baseDir.toString(), attValue.getPath());\n\n        final String attrClass = atts.getValue(ATTRIBUTE_NAME_CLASS);\n        final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n//        if (MAP_TOPICREF.matches(attrClass)) {            \n//            // only transtype = eclipsehelp\n//            if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {\n//                // For only format of the href is dita topic\n//                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n//                    topicHref = FileUtils.separatorsToUnix(file.getPath());\n//                    // attrValue has topicId\n//                    if (linkUri.getFragment() != null) {\n//                        topicId = linkUri.getFragment();\n//                    } else {\n//                        // get the first topicId(vaild href file)\n//                        if (FileUtils.isDITAFile(topicHref)) {\n//                            // topicId =\n//                            // MergeUtils.getInstance().getFirstTopicId(topicHref,\n//                            // (new File(rootFilePath)).getParent(), true);\n//                            // to be unique\n//                            topicId = topicHref + QUESTION;\n//                        }\n//                    }\n//                } else {\n//                    topicHref = \"\";\n//                    topicId = \"\";\n//                }\n//            }\n//        }\n\n        // Collect non-conref and non-copyto targets\n        if (file != null\n                && FileUtils.isValidTarget(file.getPath().toLowerCase())\n                && (atts.getValue(ATTRIBUTE_NAME_COPY_TO) == null\n                        || !FileUtils.isDITATopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase())\n                        || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null\n                            && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-content\")))\n                && !ATTRIBUTE_NAME_CONREF.equals(attrName)\n                && !ATTRIBUTE_NAME_COPY_TO.equals(attrName)\n                && (canResolved() || FileUtils.isSupportedImageFile(file.getPath().toLowerCase()))) {\n            String format = attrFormat;\n            if (format == null) {\n                if (TOPIC_IMAGE.matches(attrClass)) {\n                    format = \"image\";\n                } else {\n                    format = ATTR_FORMAT_VALUE_DITA;\n                }\n            }\n            nonConrefCopytoTargets.add(new Reference(file.getPath(), format));\n        }\n    }\n    \n    private void handleHrefAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {\n        final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n        if (href != null) {\n            final File file = FileUtils.resolve(baseDir.toString(), href.getPath());\n            if (PR_D_CODEREF.matches(atts)) {\n                fileInfo.hasCoderef(true);\n                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                getOrCreateBuilder(file.getPath()).isSubtarget(true).format(\"code\");\n            } else if (TOPIC_IMAGE.matches(atts)) {\n                // noop\n            } else {\n                if (!MAP_TOPICREF.matches(atts)) {\n                    fileInfo.hasLink(true);\n                }\n                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n                    // Collect only href target topic files for index extracting\n                    if (canResolved()) {\n                        final Builder b = getOrCreateBuilder(file.getPath()).format(ATTR_FORMAT_VALUE_DITA);\n                        // Do not read format \n                        b.isTarget(true);\n//                        toOutFile(file.getPath());\n                        if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {\n                            b.isSkipChunk(true);\n                        } else {\n                            b.isNonConrefTarget(true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // TODO: replace with reading from inheritedAttributes\n    private boolean isExternal(final URI href, final String scope) {\n        return ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)\n                || ATTR_SCOPE_VALUE_PEER.equals(scope)\n                || href.toString().contains(COLON_DOUBLE_SLASH)\n                || href.toString().startsWith(SHARP);\n    }\n    \n    private void handleCopyToAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {\n        final URI copyTo = toURI(atts.getValue(ATTRIBUTE_NAME_COPY_TO));\n        if (copyTo != null && !isExternal(copyTo, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n            final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n            if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n                final File file = FileUtils.resolve(baseDir.toString(), copyTo.getPath());\n                final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n                final File value = FileUtils.resolve(toFile(currentDir), toFile(href));\n    \n                if (copytoMap.containsKey(file)) {\n                    if (!value.equals(copytoMap.get(file))) {\n                        logger.warn(MessageUtils.getInstance().getMessage(\"DOTX065W\", href.getPath(), file.getPath()).toString());\n                    }\n                    ignoredCopytoSourceSet.add(toFile(href));\n                } else if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-content\"))) {\n                    copytoMap.put(file, value);\n                }\n    \n                final String pathWithoutID = FileUtils.resolve(currentDir.toString(), toFile(copyTo.getPath()).getPath()).getPath();\n                final Builder b = getOrCreateBuilder(pathWithoutID);\n                if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {\n                    b.isSkipChunk(true);\n                } else {\n                    b.isNonConrefTarget(true);\n                }\n            }\n        }\n    }\n    \n    private void handleConrefAttr(final Attributes atts, final URI baseDir) throws DITAOTException, URISyntaxException {\n        final URI conref = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));\n        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);\n        if (conref != null || conkeyref != null) {\n            fileInfo.hasConref(true);\n        }\n        if (conref != null) {\n            final File file = FileUtils.resolve(baseDir.toString(), conref.getPath());\n            getOrCreateBuilder(file.getPath()).isConrefTarget(true);\n        }\n    }\n    \n    private void handleKeyrefAttr(final Attributes atts) {\n        final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);\n        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);\n        if (keyref != null || conkeyref != null) {\n            fileInfo.hasKeyref(true);\n        }\n    }   \n    \n    /**\n     * Collect the conaction source topic file\n     */\n    private void handleConactionAttr(final Attributes atts) {\n        final String attrValue = atts.getValue(ATTRIBUTE_NAME_CONACTION);\n        if (attrValue != null) {\n            if (attrValue.equals(\"mark\") || attrValue.equals(\"pushreplace\")) {\n                fileInfo.isConrefPush(true);\n            }\n        } \n    }\n\n//    /**\n//     * Convert URI references to file paths.\n//     * \n//     * @param filename file reference\n//     * @return file path\n//     */\n//    private File toFile(final String filename) {\n//        if (filename == null) {\n//            return null;\n//        }\n//        String f = filename;\n//        try {\n//            f = URLDecoder.decode(filename, UTF8);\n//        } catch (final UnsupportedEncodingException e) {\n//            throw new RuntimeException(e);\n//        }\n//        if (processingMode == Mode.LAX) {\n//            f = f.replace(WINDOWS_SEPARATOR, File.separator);\n//        }\n//        f = f.replace(URI_SEPARATOR, File.separator);\n//        return new File(f);\n//    }\n\n    /**\n     * Get multi-level keys list\n     */\n    private List<String> getKeysList(final String key, final Map<String, String> keysRefMap) {\n        final List<String> list = new ArrayList<String>();\n        // Iterate the map to look for multi-level keys\n        for (Entry<String, String> entry : keysRefMap.entrySet()) {\n            // Multi-level key found\n            if (entry.getValue().equals(key)) {\n                // add key into the list\n                final String entryKey = entry.getKey();\n                list.add(entryKey);\n                // still have multi-level keys\n                if (keysRefMap.containsValue(entryKey)) {\n                    // rescuive point\n                    final List<String> tempList = getKeysList(entryKey, keysRefMap);\n                    list.addAll(tempList);\n                }\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Update keysDefMap for multi-level keys\n     */\n    private void checkMultiLevelKeys(final Map<String, KeyDef> keysDefMap, final Map<String, String> keysRefMap) {\n        String key = null;\n        KeyDef value = null;\n        // tempMap storing values to avoid ConcurrentModificationException\n        final Map<String, KeyDef> tempMap = new HashMap<String, KeyDef>();\n        for (Entry<String, KeyDef> entry : keysDefMap.entrySet()) {\n            key = entry.getKey();\n            value = entry.getValue();\n            // there is multi-level keys exist.\n            if (keysRefMap.containsValue(key)) {\n                // get multi-level keys\n                final List<String> keysList = getKeysList(key, keysRefMap);\n                for (final String multikey : keysList) {\n                    // update tempMap\n                    tempMap.put(multikey, value);\n                }\n            }\n        }\n        // update keysDefMap.\n        keysDefMap.putAll(tempMap);\n    }\n\n//    /**\n//     * Check if path walks up in parent directories\n//     * \n//     * @param toCheckPath path to check\n//     * @return {@code true} if path walks up, otherwise {@code false}\n//     */\n//    private boolean isOutFile(final String toCheckPath) {\n//        if (!toCheckPath.startsWith(\"..\")) {\n//            return false;\n//        } else {\n//            return true;\n//        }\n//    }\n\n    /**\n     * Check if current file is a map or if not only topics in main map are processed \n     */\n    private boolean canResolved() {\n        return !job.getOnlyTopicInMap() || rootClass != null && MAP_MAP.matches(rootClass);\n    }\n\n//    /**\n//     * Add file to out files set\n//     * \n//     * @param filename a relative path from the dita input file\n//     */\n//    private void toOutFile(final String filename) throws DITAOTException {\n//        final String[] prop = { FileUtils.normalizeDirectory(inputDir.getAbsolutePath(), filename), FileUtils.normalize(currentFile.getAbsolutePath()) };\n//        if ((OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.NOT_GENERATEOUTTER)\n//                || (OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.GENERATEOUTTER)) {\n//            if (isOutFile(filename)) {\n//                if (outputUtils.getOutterControl() == OutputUtils.OutterControl.FAIL) {\n//                    final MessageBean msgBean = MessageUtils.getInstance().getMessage(\"DOTJ035F\", prop);\n//                    throw new DITAOTException(msgBean, null, msgBean.toString());\n//                } else if (outputUtils.getOutterControl() == OutputUtils.OutterControl.WARN) {\n//                    final String message = MessageUtils.getInstance().getMessage(\"DOTJ036W\", prop).toString();\n//                    logger.logWarn(message);\n//                }\n//                if (canResolved()) {\n//                    outDitaFilesSet.add(filename);\n//                }\n//            }\n//        }\n//    }\n\n    /**\n     * Get path to base directory\n     * \n     * @param filename relative input file path from base directory\n     * @param traceFilename absolute input file\n     * @param inputMap absolute path to start file\n     * @return path to base directory, {@code null} if not available\n     */\n    public String getPathtoProject(final File filename, final File traceFilename, final String inputMap) {\n        String path2Project = null;\n//        if (OutputUtils.getGeneratecopyouter() != OutputUtils.Generate.OLDSOLUTION) {\n//            if (isOutFile(traceFilename)) {\n//                path2Project = getRelativePathFromOut(traceFilename.getAbsolutePath());\n//            } else {\n//                path2Project = FileUtils.getRelativePath(traceFilename.getAbsolutePath(),inputMap);\n//                path2Project = new File(path2Project).getParent();\n//                if (path2Project != null && path2Project.length() > 0) {\n//                    path2Project = path2Project+File.separator;\n//                }\n//            }\n//        } else {\n            final File p = FileUtils.getRelativePath(filename); \n            path2Project = p != null ? p.getPath() : null;\n            if (path2Project != null && !path2Project.endsWith(File.separator)) {\n                path2Project = path2Project + File.separator;\n            }\n//        }\n         return path2Project;\n    }\n    \n//    /**\n//     * Check if path falls outside start document directory\n//     * \n//     * @param filePathName path to test\n//     * @return {@code true} if outside start directory, otherwise {@code false}\n//     */\n//    private boolean isOutFile(final File filePathName) {\n//        final String relativePath = FileUtils.getRelativePath(outputUtils.getInputMapPathName().getAbsolutePath(), filePathName.getPath());\n//        if (relativePath == null || relativePath.length() == 0 || !relativePath.startsWith(\"..\")) {\n//            return false;\n//        }\n//        return true;\n//    }\n    \n//    /**\n//     * Just for the overflowing files.\n//     * @param overflowingFile overflowingFile\n//     * @return relative path to out\n//     */\n//    public String getRelativePathFromOut(final String overflowingFile) {\n//        final File mapPathName = outputUtils.getInputMapPathName();\n//        final File currFilePathName = new File(overflowingFile);\n//        final String relativePath = FileUtils.getRelativePath( mapPathName.toString(),currFilePathName.toString());\n//        final String outputDir = OutputUtils.getOutputDir().getAbsolutePath();\n//        final String outputPathName = outputDir + File.separator + \"index.html\";\n//        final String finalOutFilePathName = FileUtils.resolve(outputDir,relativePath);\n//        final String finalRelativePathName = FileUtils.getRelativePath(finalOutFilePathName,outputPathName.toString());\n//        final String parentDir = new File(finalRelativePathName).getParent();\n//        final StringBuffer finalRelativePath = new StringBuffer(parentDir);\n//        if (finalRelativePath.length() > 0) {\n//            finalRelativePath.append(File.separator);\n//        } else {\n//            finalRelativePath.append(\".\").append(File.separator);\n//        }\n//        return finalRelativePath.toString();\n//    }\n    \n    /**\n     * File reference with path and optional format.\n     */\n    public static class Reference {\n        public final String filename;\n        public final String format;\n\n        public Reference(final String filename, final String format) {\n            this.filename = filename;\n            this.format = format;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((filename == null) ? 0 : filename.hashCode());\n            result = prime * result + ((format == null) ? 0 : format.hashCode());\n            return result;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof Reference)) {\n                return false;\n            }\n            final Reference other = (Reference) obj;\n            if (filename == null) {\n                if (other.filename != null) {\n                    return false;\n                }\n            } else if (!filename.equals(other.filename)) {\n                return false;\n            }\n            if (format == null) {\n                if (other.format != null) {\n                    return false;\n                }\n            } else if (!format.equals(other.format)) {\n                return false;\n            }\n            return true;\n        }\n    }\n\n//    public static class ExportAnchor {\n//        public final String file;\n//        public final Set<String> topicids = new HashSet<String>();\n//        public final Set<String> keys = new HashSet<String>();\n//        public final Set<String> ids = new HashSet<String>();\n//\n//        ExportAnchor(final String file) {\n//            this.file = file;\n//        }\n//    }\n\n}", "class_id": 0, "repo": "dita/dita-clj", "file": "src/java/org/dita/dost/writer/GenListModuleFilter.java", "last_update_at": "2018-10-02T23:18:18+00:00", "question_id": "b891b11d8b3212c7191392e74938f028378faa0c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class GenListModuleFilter extends AbstractXMLFilter {\n    public static final String PI_PATH2PROJ_TARGET = \"path2project\";\n    public static final String PI_PATH2PROJ_TARGET_URI = \"path2project-uri\";\n//    public static final String PI_WORKDIR_TARGET = \"workdir\";\n    public static final String PI_WORKDIR_TARGET_URI = \"workdir-uri\";\n    /** Inherited attributes and their default values. */\n    private static final Map<String, String> inheritedAtts = new HashMap<String, String>();\n    static {\n        inheritedAtts.put(ATTRIBUTE_NAME_SCOPE, ATTR_SCOPE_VALUE_LOCAL);\n        inheritedAtts.put(ATTRIBUTE_NAME_PROCESSING_ROLE, ATTR_PROCESSING_ROLE_VALUE_NORMAL);\n    }\n    /** Output utilities */\n    private Job job;\n    /** Basedir of the current parsing file */\n    private URI currentDir = null;\n    /** Set of all the non-conref and non-copyto targets refered in current parsing file */\n    private final Set<Reference> nonConrefCopytoTargets;\n    /** Set of sources of those copy-to that were ignored */\n    private final Set<File> ignoredCopytoSourceSet;\n    /** Map of copy-to target to souce */\n    private final Map<File, File> copytoMap;\n    /** chunk nesting level */\n    private int chunkLevel = 0;\n    /** mark topics in reltables */\n    private int relTableLevel = 0;\n    /** chunk to-navigation level */\n    private int chunkToNavLevel = 0;\n    /** Topic group nesting level */\n    private int topicGroupLevel = 0;\n    /** Flag used to mark if current file is still valid after filtering */\n    /** Set of outer dita files */\n    private final Set<File> outDitaFilesSet;\n    /** Absolute system path to file being processed */\n    private URI currentFile = null;\n    /** System path to file being processed, relative to base directory. */\n    private URI currentFileRelative;\n//    private boolean setSystemid = true;\n    /** Stack of inherited attributes. */\n    private final Deque<AttributesImpl> inheritedAttsStack;\n    /** Topics with processing role of \"resource-only\" */\n    private final Set<File> resourceOnlySet;\n    /** Topics with processing role of \"normal\" */\n    private final Set<File> normalProcessingSet;\n//    private final List<ExportAnchor> resultList = new ArrayList<ExportAnchor>();\n//    private ExportAnchor currentExportAnchor;\n//    /** Flag to show whether a file has <exportanchors> tag */\n//    private boolean hasExport = false;\n//    /** For topic/dita files whether a </file> tag should be added */\n//    private boolean shouldAppendEndTag = false;\n//    /** Store the href of topicref tag */\n//    private String topicHref = \"\";\n//    /** Topicmeta set for merge multiple exportanchors into one. Each topicmeta/prolog can define many exportanchors */\n//    private final Set<String> topicMetaSet;\n//    /** Refered topic id */\n//    private String topicId = \"\";\n//    /** Map to store plugin id */\n//    private final Map<String, Set<String>> pluginMap = new HashMap<String, Set<String>>();\n//    /** Transtype */\n//    private String transtype;\n    /** Map to store referenced branches. */\n    private final Map<String, List<String>> validBranches;\n    /** Int to mark referenced nested elements. */\n    private int level;\n    /** Topicref stack */\n    private final Stack<String> topicrefStack;\n    private String path2Project;\n    /** Absolute system path to input file parent directory */\n    private URI inputDir;\n    private URI inputFile;\n    private File tempDir;\n    private final Map<String, Integer> counterMap;\n    /** File info map. */\n    private final Map<String, FileInfo.Builder> fileInfoMap;\n    /** File info for the current document. */\n    private FileInfo.Builder fileInfo;\n    private boolean isRootElement = true;\n    private DitaClass rootClass = null;\n    private boolean isStartDocument = false;\n    /**\n     * Constructor.\n     */\n    public GenListModuleFilter() {\n        nonConrefCopytoTargets = new HashSet<Reference>(64);\n        copytoMap = new HashMap<File, File>(16);\n        ignoredCopytoSourceSet = new HashSet<File>(16);\n        outDitaFilesSet = new HashSet<File>(64);\n//        processRoleLevel = 0;\n//        processRoleStack = new Stack<String>();\n        inheritedAttsStack = new ArrayDeque<AttributesImpl>();\n        resourceOnlySet = new HashSet<File>(32);\n        normalProcessingSet = new HashSet<File>(32);\n//        topicMetaSet = new HashSet<String>(INT_16);\n        validBranches = new HashMap<String, List<String>>(32);\n        counterMap = new HashMap<String, Integer>();\n        level = 0;\n        topicrefStack = new Stack<String>();\n        fileInfoMap = new HashMap<String, FileInfo.Builder>();\n    }\n    /**\n     * \n     * Reset the internal variables.\n     */\n    public void reset() {\n        currentDir = null;\n        chunkLevel = 0;\n        relTableLevel = 0;\n        chunkToNavLevel = 0;\n        topicGroupLevel = 0;\n        nonConrefCopytoTargets.clear();\n        copytoMap.clear();\n        ignoredCopytoSourceSet.clear();\n        outDitaFilesSet.clear();\n        level = 0;\n        topicrefStack.clear();\n//        processRoleLevel = 0;\n//        processRoleStack.clear();\n        inheritedAttsStack.clear();\n        currentFileRelative = null;\n        path2Project = null;\n        counterMap.clear();\n        fileInfo = null;\n        fileInfoMap.clear();\n        isRootElement = true;\n        rootClass = null;\n        isStartDocument = false;\n        // Don't clean:\n        // resourceOnlySet\n        // normalProcessingSet\n    }\n//    /**\n//     * Set transtype.\n//     * \n//     * @param transtype the transtype to set\n//     */\n//    public void setTranstype(final String transtype) {\n//        this.transtype = transtype;\n//    }\n//\n//    /**\n//     * @return the pluginMap\n//     */\n//    public Map<String, Set<String>> getPluginMap() {\n//        return pluginMap;\n//    }\n//\n//    /**\n//     * Get export anchors.\n//     * \n//     * @return list of export anchors\n//     */\n//    public List<ExportAnchor> getExportAnchors() {\n//        return resultList;\n//    }\n    /**\n     * Current document is processing start document.\n     */\n    public void isStartDocument(final boolean isStartDocument) {\n        this.isStartDocument = isStartDocument;\n    }\n    /**\n     * Set output utilities.\n     * \n     * @param job output utils\n     */\n    public void setJob(final Job job) {\n        this.job = job;\n    }\n    /**\n     * Get out file set.\n     * \n     * @return out file set\n     */\n    public Set<File> getOutFilesSet() {\n        return outDitaFilesSet;\n    }\n    /**\n     * List of files with \"@processing-role=resource-only\".\n     * \n     * @return the resource-only set\n     */\n    public Set<File> getResourceOnlySet() {\n        final Set<File> res = new HashSet<File>(resourceOnlySet);\n        res.removeAll(normalProcessingSet);\n        return res;\n    }\n    /**\n     * Get all targets except copy-to.\n     * \n     * @return set of target file path references\n     */\n    public Set<Reference> getNonCopytoResult() {\n        final Set<Reference> nonCopytoSet = new HashSet<Reference>(128);\n        nonCopytoSet.addAll(nonConrefCopytoTargets);\n        for (final Builder b: fileInfoMap.values()) {\n            final FileInfo f = b.build();\n            if (f.isConrefTarget) {\n                nonCopytoSet.add(new Reference(f.file.getPath(), f.format));\n            }\n        }\n        for (final File f : copytoMap.values()) {\n            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));\n        }\n        for (final File f : ignoredCopytoSourceSet) {\n            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));\n        }\n//        for (final String filename : subsidiarySet) {\n//            // only activated on /generateout:3 & is out file.\n//            if (isOutFile(filename) && OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.OLDSOLUTION) {\n//                nonCopytoSet.add(new Reference(filename));\n//            }\n//        }\n        // nonCopytoSet.addAll(subsidiarySet);\n        return nonCopytoSet;\n    }\n    /**\n     * Get outditafileslist.\n     * \n     * @return Returns the outditafileslist.\n     */\n    public Set<File> getOutDitaFilesSet() {\n        return outDitaFilesSet;\n    }\n    /**\n     * Get non-conref and non-copyto targets.\n     * \n     * @return Returns the nonConrefCopytoTargets.\n     */\n    public Set<File> getNonConrefCopytoTargets() {\n        final Set<File> res = new HashSet<File>(nonConrefCopytoTargets.size());\n        for (final Reference r : nonConrefCopytoTargets) {\n            res.add(new File(r.filename));\n        }\n        return res;\n    }\n    /**\n     * Returns the ignoredCopytoSourceSet.\n     * \n     * @return Returns the ignoredCopytoSourceSet.\n     */\n    public Set<File> getIgnoredCopytoSourceSet() {\n        return ignoredCopytoSourceSet;\n    }\n    /**\n     * Get the copy-to map.\n     * \n     * @return copy-to map\n     */\n    public Map<File, File> getCopytoMap() {\n        return copytoMap;\n    }\n    /**\n     * Set the relative directory of current file.\n     * \n     * @param dir dir\n     */\n    public void setCurrentDir(final URI dir) {\n        currentDir = dir;\n    }\n    /**\n     * Set processing input directory absolute path.\n     * \n     * @param inputFile absolute path to base directory\n     */\n    public void setInputDir(final URI inputDir) {\n        this.inputDir = inputDir;\n    }\n    /**\n     * Set processing input file absolute path.\n     * \n     * @param inputFile absolute path to root file\n     */\n    public void setInputFile(final URI inputFile) {\n        this.inputFile = inputFile;\n    }\n    /**\n     * Set current file absolute path\n     * \n     * @param currentFile absolute path to current file\n     */\n    public void setCurrentFile(final URI currentFile) {\n        this.currentFile = currentFile;\n    }\n    /**\n     * Set temporary directory\n     * @param tempDir absolute path to temporary directory\n     */\n    public void setTempDir(final File tempDir) {\n        this.tempDir = tempDir;\n    }\n    /**\n     * Get file info for the current file.\n     */\n    public List<FileInfo> getFileInfo() {\n        final List<FileInfo> res = new ArrayList<FileInfo>();\n        //res.add(fileInfo.build());\n        for (final Builder b: fileInfoMap.values()) {\n            res.add(b.build());\n        }\n        return res;\n    }\n    // Content handler methods\n    /**\n     * Check if the current file is a ditamap with\n     * \"@processing-role=resource-only\".\n     */\n    @Override\n    public void startDocument() throws SAXException {\n        currentFileRelative = inputDir.relativize(currentFile);\n        path2Project = getPathtoProject(toFile(currentFileRelative), toFile(currentFile.toString()), job.getInputFile().getAbsolutePath());\n        fileInfo = getOrCreateBuilder(currentFileRelative);\n        super.startDocument();\n        outputProcessingInstructions();\n    }\n    /**\n     * Generate processing instructions to the beginning of the document.\n     * \n     * <p>The following processing instructions are added before the root element:</p>\n     * <dl>\n     *   <!--dt>{@link #PI_WORKDIR_TARGET}<dt>\n     *   <dd>Absolute system path of the file parent directory. On Windows, a {@code /}\n     *     is added to beginning of the path.</dd-->\n     *   <dt>{@link #PI_WORKDIR_TARGET_URI}<dt>\n     *   <dd>Absolute URI of the file parent directory.</dd>\n     *   <dt>{@link #PI_PATH2PROJ_TARGET}<dt>\n     *   <dd>Relative system path to the output directory, with a trailing directory separator.\n     *     When the source file is in the project root directory, processing instruction has no value.</dd>\n     *   <dt>{@link #PI_PATH2PROJ_TARGET_URI}<dt>\n     *   <dd>Relative URI to the output directory, with a trailing path separator.\n     *     When the source file is in the project root directory, processing instruction has value {@code ./}.</dd>\n     * </dl> \n     */\n    private void outputProcessingInstructions() throws SAXException {\n        final URI workDir = tempDir.toURI().resolve(currentFileRelative).resolve(\".\");\n//        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {\n//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, new File(workDir).getAbsolutePath());\n//        } else {\n//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, UNIX_SEPARATOR + new File(workDir).getAbsolutePath());\n//        }\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n        getContentHandler().processingInstruction(PI_WORKDIR_TARGET_URI, workDir.toString());\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n        if (path2Project != null) {\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, path2Project);\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, toURI(path2Project).toString());\n        } else {\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, \"\");\n            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, \".\" + UNIX_SEPARATOR);\n        }\n        getContentHandler().ignorableWhitespace(new char[] { '\\n' }, 0, 1);\n    }\n    /**\n     * Push inherited attributes to the stack.\n     */\n    private void pushInheritedAttributes(final Attributes atts) {\n        final AttributesImpl res = new AttributesImpl();\n        for (final Entry<String, String> e: inheritedAtts.entrySet()) {\n            final String current = atts.getValue(e.getKey());\n            if (current != null) {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), current);\n            } else if (!inheritedAttsStack.isEmpty()) {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), getInherited(e.getKey()));\n            } else {\n                XMLUtils.addOrSetAttribute(res, e.getKey(), e.getValue());\n            }\n        }\n        inheritedAttsStack.addFirst(res);\n    }\n    /**\n     * Get inherited attribute value.\n     * @param name attribute name\n     * @return attribute value or {@code null} if not available\n     */\n    private String getInherited(final String name) {\n        return inheritedAttsStack.peekFirst().getValue(name);\n    }\n    @Override\n    public void startElement(final String uri, final String localName, final String qName, final Attributes atts)\n            throws SAXException {\n        pushInheritedAttributes(atts);\n        handleProcessingRole(atts);\n        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n        handleRootElement(localName, atts);\n//        // when meets topic tag\n//        if (TOPIC_TOPIC.matches(classValue)) {\n//            topicId = atts.getValue(ATTRIBUTE_NAME_ID);\n//            // relpace place holder with first topic id\n//            // Get relative file name\n//            for (final ExportAnchor e : resultList) {\n//                if (e.topicids.contains(currentFileRelative + QUESTION)) {\n//                    e.topicids.add(topicId);\n//                    e.topicids.remove(currentFileRelative + QUESTION);\n//                }\n//            }\n//        }\n//        // merge multiple exportanchors into one\n//        // Each <topicref> can only have one <topicmeta>.\n//        // Each <topic> can only have one <prolog>\n//        // and <metadata> can have more than one exportanchors\n//        // XXX: This should be moved to a separate filter as it's transtype specific\n//        if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {\n//            if (MAP_MAP.matches(classValue) \n//                    && FileUtils.isDITAMapFile(currentFile.getName()) && inputFile.equals(currentFile)) {\n//                String pluginId = atts.getValue(ATTRIBUTE_NAME_ID);\n//                if (pluginId == null) {\n//                    pluginId = \"org.sample.help.doc\";\n//                }\n//                final Set<String> set = StringUtils.restoreSet(pluginId);\n//                pluginMap.put(\"pluginId\", set);\n//            } else if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {\n//                topicMetaSet.add(qName);\n//            } else if (DELAY_D_EXPORTANCHORS.matches(classValue)) {\n//                hasExport = true;\n//                // If current file is a ditamap file\n//                if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                    // if dita file's extension name is \".xml\"\n//                    String editedHref = \"\";\n//                    if (topicHref.endsWith(FILE_EXTENSION_XML)) {\n//                        // change the extension to \".dita\" for latter compare\n//                        editedHref = topicHref.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);\n//                    } else {\n//                        editedHref = topicHref;\n//                    }\n//                    // editedHref = editedHref.replace(File.separator, \"/\");\n//                    currentExportAnchor = new ExportAnchor(editedHref);\n//                    // if <exportanchors> is defined in topicmeta(topicref), there is only one topic id\n//                    currentExportAnchor.topicids.add(topicId);\n//                    // If current file is topic file\n//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {\n//                    // if dita file's extension name is \".xml\"\n//                    if (currentFileRelative.endsWith(FILE_EXTENSION_XML)) {\n//                        // change the extension to \".dita\" for latter compare\n//                        currentFileRelative = currentFileRelative.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);\n//                    }\n//                    currentFileRelative = FileUtils.separatorsToUnix(currentFileRelative);\n//                    currentExportAnchor = new ExportAnchor(currentFileRelative);\n//                    // if <exportanchors> is defined in metadata(topic), there can be many topic ids\n//                    currentExportAnchor.topicids.add(topicId);\n//                    shouldAppendEndTag = true;\n//                }\n//            } else if (DELAY_D_ANCHORKEY.matches(classValue)) {\n//                // create keyref element in the StringBuffer\n//                // TODO in topic file is no keys\n//                final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);\n//                currentExportAnchor.keys.add(keyref);\n//            } else if (DELAY_D_ANCHORID.matches(classValue)) {\n//                // create keyref element in the StringBuffer\n//                final String id = atts.getValue(ATTRIBUTE_NAME_ID);\n//                // If current file is a ditamap file\n//                // The id can only be element id within a topic\n//                if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                    // id shouldn't be same as topic id in the case of duplicate insert\n//                    if (!topicId.equals(id)) {\n//                        currentExportAnchor.ids.add(id);\n//                    }\n//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {\n//                    // id shouldn't be same as topic id in the case of duplicate insert\n//                    if (!topicId.equals(id)) {\n//                        // topic id found\n//                        currentExportAnchor.ids.add(id);\n//                    }\n//                }\n//            }\n//        }\n        if (chunkLevel > 0 || atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {\n            chunkLevel++;\n        }\n        if (relTableLevel > 0 || MAP_RELTABLE.matches(classValue)) {\n            relTableLevel++;\n        }\n        if (chunkToNavLevel > 0) {\n            chunkToNavLevel++;\n        } else if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null\n                && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-navigation\")) {\n            chunkToNavLevel++;\n        }\n        if (topicGroupLevel > 0 || MAPGROUP_D_TOPICGROUP.matches(classValue)) {\n            topicGroupLevel++;\n        }\n        handleTopicRef(localName, atts);\n        try {\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_CONREF, currentDir);\n            handleConrefAttr(atts, currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_HREF, currentDir);\n            handleHrefAttr(atts, currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_DATA, atts.getValue(ATTRIBUTE_NAME_CODEBASE) != null ? new URI(atts.getValue(ATTRIBUTE_NAME_CODEBASE)) : currentDir);\n            parseLinkAttribute(atts, ATTRIBUTE_NAME_COPY_TO, currentDir);\n            handleCopyToAttr(atts, currentDir);\n        } catch (final URISyntaxException e) {\n            logger.error(\"Failed to parse URI: \" + e.getMessage(), e);\n        } catch (DITAOTException e) {\n            logger.error(\"Failed to process link: \" + e.getMessage(), e);\n        }\n        handleConactionAttr(atts);\n        handleKeyrefAttr(atts);\n        super.startElement(uri, localName, qName, atts);\n    }\n    private void handleRootElement(final String localName, final Attributes atts) {\n        if (isRootElement) {\n            isRootElement = false;\n            final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n            if (classValue != null) {\n                rootClass = new DitaClass(atts.getValue(ATTRIBUTE_NAME_CLASS));\n            }\n            if (TOPIC_TOPIC.matches(rootClass)) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITA);\n            } else if (ELEMENT_NAME_DITA.equals(localName) && classValue == null) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITA);\n            } else if (MAP_MAP.matches(rootClass)) {\n                fileInfo.format(ATTR_FORMAT_VALUE_DITAMAP);\n            }\n            if (SUBJECTSCHEME_SUBJECTSCHEME.matches(rootClass)) {\n                fileInfo.isSubjectScheme(true);\n            }\n        }\n    }\n    private void handleTopicRef(final String localName, final Attributes atts) {\n        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);\n        if (MAP_TOPICREF.matches(classValue) && job.getOnlyTopicInMap() && isStartDocument) {\n            URI hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n            if (hrefValue == null) {\n                hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));\n            }\n            if (hrefValue != null) {\n                if (isExternal(hrefValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                // normalize href value.\n                final File target = toFile(hrefValue);\n                // caculate relative path for href value.\n                String fileName = null;\n                if (target.isAbsolute()) {\n                    fileName = FileUtils.getRelativeUnixPath(inputFile.toString(), hrefValue.toString());\n                }\n                fileName = FileUtils.separatorsToUnix(FileUtils.resolve(currentDir.toString(), hrefValue.toString()).getPath());\n                final boolean canParse = parseBranch(atts, hrefValue, fileName);\n                if (canParse) {\n                    topicrefStack.push(localName);\n                }\n            }\n        }\n    }\n    private void handleProcessingRole(final Attributes atts) {\n        final String href = atts.getValue(ATTRIBUTE_NAME_HREF);\n        final String scope = inheritedAttsStack.peekFirst().getValue(ATTRIBUTE_NAME_SCOPE);\n        if (href != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {\n            final String processingRole = getInherited(ATTRIBUTE_NAME_PROCESSING_ROLE);\n            final File target = FileUtils.resolve(currentDir.toString(), href);\n            if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {\n                resourceOnlySet.add(target);\n            } else if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processingRole)) {\n                normalProcessingSet.add(target);\n            }\n        }\n    }\n//    @Override\n//    public void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException {\n//        getContentHandler().characters(ch, start, length);\n//    }\n    @Override\n    public void endElement(final String uri, final String localName, final String qName) throws SAXException {\n        // processing role\n//        if (processRoleLevel > 0) {\n//            if (processRoleLevel == processRoleStack.size()) {\n//                processRoleStack.pop();\n//            }\n//            processRoleLevel--;\n//        }\n        if (chunkLevel > 0) {\n            chunkLevel--;\n        }\n        if (relTableLevel > 0) {\n            relTableLevel--;\n        }\n        if (chunkToNavLevel > 0) {\n            chunkToNavLevel--;\n        }\n        if (topicGroupLevel > 0) {\n            topicGroupLevel--;\n        }\n//        // <exportanchors> over should write </file> tag\n//\n//        if (topicMetaSet.contains(qName) && hasExport) {\n//            // If current file is a ditamap file\n//            if (FileUtils.isDITAMapFile(currentFile.getName())) {\n//                resultList.add(currentExportAnchor);\n//                currentExportAnchor = null;\n//                // If current file is topic file\n//            }\n//            hasExport = false;\n//            topicMetaSet.clear();\n//        }\n        if (!topicrefStack.isEmpty() && localName.equals(topicrefStack.peek())) {\n            level--;\n            topicrefStack.pop();\n        }\n        inheritedAttsStack.removeFirst();\n        super.endElement(uri, localName, qName);\n    }\n    /**\n     * Clean up.\n     */\n    @Override\n    public void endDocument() throws SAXException {\n        // processing role\n//        if (processRoleLevel > 0) {\n//            processRoleLevel--;\n//            processRoleStack.pop();\n//        }\n//        if (FileUtils.isDITATopicFile(currentFile.getName()) && shouldAppendEndTag) {\n//            resultList.add(currentExportAnchor);\n//            currentExportAnchor = null;\n//            // should reset\n//            shouldAppendEndTag = false;\n//        }\n        super.endDocument();\n    }\n    /**\n     * Get file info builder from file info map or create new file info into the map. \n     * \n     * @param file file info path\n     * @return existing or new file info\n     */\n    private Builder getOrCreateBuilder(final String file) {\n        final String f = file.isEmpty() ? currentFileRelative.toString() : file;\n        FileInfo.Builder b = fileInfoMap.get(f);\n        if (b == null) {\n            b = new FileInfo.Builder().file(new File(f));\n            fileInfoMap.put(f, b);\n        }\n        return b;\n    }\n    private Builder getOrCreateBuilder(final URI file) {\n        return getOrCreateBuilder(file.toString());\n    }\n    /**\n     * Method for see whether a branch should be parsed.\n     * \n     * @param atts {@link Attributes}\n     * @param hrefValue {@link String}\n     * @param fileName normalized file name(remove '#')\n     * @return boolean\n     */\n    private boolean parseBranch(final Attributes atts, final URI hrefValue, final String fileName) {\n        // current file is primary ditamap file.\n        // parse every branch.\n        if (currentDir == null && isStartDocument) {\n            // add branches into map\n            addReferredBranches(hrefValue, fileName);\n            return true;\n        } else {\n            // current file is a sub-ditamap one.\n            // get branch's id\n            final String id = atts.getValue(ATTRIBUTE_NAME_ID);\n            // this branch is not referenced\n            if (level == 0 && StringUtils.isEmptyString(id)) {\n                // There is occassion that the whole ditamap should be parsed\n                final boolean found = searchBrachesMap(id);\n                if (found) {\n                    // Add this branch into map for parsing.\n                    addReferredBranches(hrefValue, fileName);\n                    // update level\n                    level++;\n                    return true;\n                } else {\n                    return false;\n                }\n                // this brach is a decendent of a referenced one\n            } else if (level != 0) {\n                // Add this branch into map for parsing.\n                addReferredBranches(hrefValue, fileName);\n                // update level\n                level++;\n                return true;\n                // This branch has an id but is a new one\n            } else if (!StringUtils.isEmptyString(id)) {\n                // search branches map.\n                final boolean found = searchBrachesMap(id);\n                // branch is referenced\n                if (found) {\n                    // Add this branch into map for parsing.\n                    addReferredBranches(hrefValue, fileName);\n                    // update level\n                    level++;\n                    return true;\n                } else {\n                    // this branch is not referenced\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n    /**\n     * Search braches map with branch id and current file name.\n     * \n     * @param id String branch id.\n     * @return boolean true if found and false otherwise.\n     */\n    private boolean searchBrachesMap(final String id) {\n        // seach the map with id & current file name.\n        if (validBranches.containsKey(currentFileRelative.getPath())) {\n            final List<String> branchIdList = validBranches.get(currentFileRelative.getPath());\n            // the branch is referenced.\n            if (branchIdList.contains(id)) {\n                return true;\n            } else // the whole map is referenced\n// the branch is not referred\n                return branchIdList.size() == 0;\n        } else {\n            // current file is not refered\n            return false;\n        }\n    }\n    /**\n     * Add branches into map.\n     * \n     * @param hrefValue\n     * @param fileName\n     */\n    private void addReferredBranches(final URI hrefValue, final String fileName) {\n        String branchId = null;\n        // href value has branch id.\n        if (hrefValue.getFragment() != null) {\n            branchId = hrefValue.getFragment();\n            // The map contains the file name\n            if (validBranches.containsKey(fileName)) {\n                final List<String> branchIdList = validBranches.get(fileName);\n                branchIdList.add(branchId);\n            } else {\n                final List<String> branchIdList = new ArrayList<String>();\n                branchIdList.add(branchId);\n                validBranches.put(fileName, branchIdList);\n            }\n            // href value has no branch id\n        } else {\n            validBranches.put(fileName, new ArrayList<String>());\n        }\n    }\n    /**\n     * Parse the input attributes for needed information.\n     * \n     * @param atts all attributes\n     * @param attrName attributes to process\n     */\n    private void parseLinkAttribute(final Attributes atts, final String attrName, final URI baseDir) {\n        URI attValue = toURI(atts.getValue(attrName));\n        if (attValue == null) {\n            return;\n        }\n        if (isExternal(attValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n            return;\n        }\n        // Ignore absolute paths for now\n//        if (new File(attrValue).isAbsolute() && // FIXME: cannot test for absolute here as the value is not a system path yet\n//                !ATTRIBUTE_NAME_DATA.equals(attrName)) {\n//            attrValue = FileUtils.getRelativePath(inputFile.getAbsolutePath(), attrValue);\n//        // for object tag bug:3052156\n//        } else\n        final File file = FileUtils.resolve(baseDir.toString(), attValue.getPath());\n        final String attrClass = atts.getValue(ATTRIBUTE_NAME_CLASS);\n        final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n//        if (MAP_TOPICREF.matches(attrClass)) {            \n//            // only transtype = eclipsehelp\n//            if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {\n//                // For only format of the href is dita topic\n//                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n//                    topicHref = FileUtils.separatorsToUnix(file.getPath());\n//                    // attrValue has topicId\n//                    if (linkUri.getFragment() != null) {\n//                        topicId = linkUri.getFragment();\n//                    } else {\n//                        // get the first topicId(vaild href file)\n//                        if (FileUtils.isDITAFile(topicHref)) {\n//                            // topicId =\n//                            // MergeUtils.getInstance().getFirstTopicId(topicHref,\n//                            // (new File(rootFilePath)).getParent(), true);\n//                            // to be unique\n//                            topicId = topicHref + QUESTION;\n//                        }\n//                    }\n//                } else {\n//                    topicHref = \"\";\n//                    topicId = \"\";\n//                }\n//            }\n//        }\n        // Collect non-conref and non-copyto targets\n        if (file != null\n                && FileUtils.isValidTarget(file.getPath().toLowerCase())\n                && (atts.getValue(ATTRIBUTE_NAME_COPY_TO) == null\n                        || !FileUtils.isDITATopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase())\n                        || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null\n                            && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-content\")))\n                && !ATTRIBUTE_NAME_CONREF.equals(attrName)\n                && !ATTRIBUTE_NAME_COPY_TO.equals(attrName)\n                && (canResolved() || FileUtils.isSupportedImageFile(file.getPath().toLowerCase()))) {\n            String format = attrFormat;\n            if (format == null) {\n                if (TOPIC_IMAGE.matches(attrClass)) {\n                    format = \"image\";\n                } else {\n                    format = ATTR_FORMAT_VALUE_DITA;\n                }\n            }\n            nonConrefCopytoTargets.add(new Reference(file.getPath(), format));\n        }\n    }\n    private void handleHrefAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {\n        final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n        if (href != null) {\n            final File file = FileUtils.resolve(baseDir.toString(), href.getPath());\n            if (PR_D_CODEREF.matches(atts)) {\n                fileInfo.hasCoderef(true);\n                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                getOrCreateBuilder(file.getPath()).isSubtarget(true).format(\"code\");\n            } else if (TOPIC_IMAGE.matches(atts)) {\n                // noop\n            } else {\n                if (!MAP_TOPICREF.matches(atts)) {\n                    fileInfo.hasLink(true);\n                }\n                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n                    return;\n                }\n                final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n                    // Collect only href target topic files for index extracting\n                    if (canResolved()) {\n                        final Builder b = getOrCreateBuilder(file.getPath()).format(ATTR_FORMAT_VALUE_DITA);\n                        // Do not read format \n                        b.isTarget(true);\n//                        toOutFile(file.getPath());\n                        if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {\n                            b.isSkipChunk(true);\n                        } else {\n                            b.isNonConrefTarget(true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // TODO: replace with reading from inheritedAttributes\n    private boolean isExternal(final URI href, final String scope) {\n        return ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)\n                || ATTR_SCOPE_VALUE_PEER.equals(scope)\n                || href.toString().contains(COLON_DOUBLE_SLASH)\n                || href.toString().startsWith(SHARP);\n    }\n    private void handleCopyToAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {\n        final URI copyTo = toURI(atts.getValue(ATTRIBUTE_NAME_COPY_TO));\n        if (copyTo != null && !isExternal(copyTo, getInherited(ATTRIBUTE_NAME_SCOPE))) {\n            final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);\n            if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {\n                final File file = FileUtils.resolve(baseDir.toString(), copyTo.getPath());\n                final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));\n                final File value = FileUtils.resolve(toFile(currentDir), toFile(href));\n                if (copytoMap.containsKey(file)) {\n                    if (!value.equals(copytoMap.get(file))) {\n                        logger.warn(MessageUtils.getInstance().getMessage(\"DOTX065W\", href.getPath(), file.getPath()).toString());\n                    }\n                    ignoredCopytoSourceSet.add(toFile(href));\n                } else if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(\"to-content\"))) {\n                    copytoMap.put(file, value);\n                }\n                final String pathWithoutID = FileUtils.resolve(currentDir.toString(), toFile(copyTo.getPath()).getPath()).getPath();\n                final Builder b = getOrCreateBuilder(pathWithoutID);\n                if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {\n                    b.isSkipChunk(true);\n                } else {\n                    b.isNonConrefTarget(true);\n                }\n            }\n        }\n    }\n    private void handleConrefAttr(final Attributes atts, final URI baseDir) throws DITAOTException, URISyntaxException {\n        final URI conref = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));\n        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);\n        if (conref != null || conkeyref != null) {\n            fileInfo.hasConref(true);\n        }\n        if (conref != null) {\n            final File file = FileUtils.resolve(baseDir.toString(), conref.getPath());\n            getOrCreateBuilder(file.getPath()).isConrefTarget(true);\n        }\n    }\n    private void handleKeyrefAttr(final Attributes atts) {\n        final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);\n        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);\n        if (keyref != null || conkeyref != null) {\n            fileInfo.hasKeyref(true);\n        }\n    }   \n    /**\n     * Collect the conaction source topic file\n     */\n    private void handleConactionAttr(final Attributes atts) {\n        final String attrValue = atts.getValue(ATTRIBUTE_NAME_CONACTION);\n        if (attrValue != null) {\n            if (attrValue.equals(\"mark\") || attrValue.equals(\"pushreplace\")) {\n                fileInfo.isConrefPush(true);\n            }\n        } \n    }\n//    /**\n//     * Convert URI references to file paths.\n//     * \n//     * @param filename file reference\n//     * @return file path\n//     */\n//    private File toFile(final String filename) {\n//        if (filename == null) {\n//            return null;\n//        }\n//        String f = filename;\n//        try {\n//            f = URLDecoder.decode(filename, UTF8);\n//        } catch (final UnsupportedEncodingException e) {\n//            throw new RuntimeException(e);\n//        }\n//        if (processingMode == Mode.LAX) {\n//            f = f.replace(WINDOWS_SEPARATOR, File.separator);\n//        }\n//        f = f.replace(URI_SEPARATOR, File.separator);\n//        return new File(f);\n//    }\n    /**\n     * Get multi-level keys list\n     */\n    private List<String> getKeysList(final String key, final Map<String, String> keysRefMap) {\n        final List<String> list = new ArrayList<String>();\n        // Iterate the map to look for multi-level keys\n        for (Entry<String, String> entry : keysRefMap.entrySet()) {\n            // Multi-level key found\n            if (entry.getValue().equals(key)) {\n                // add key into the list\n                final String entryKey = entry.getKey();\n                list.add(entryKey);\n                // still have multi-level keys\n                if (keysRefMap.containsValue(entryKey)) {\n                    // rescuive point\n                    final List<String> tempList = getKeysList(entryKey, keysRefMap);\n                    list.addAll(tempList);\n                }\n            }\n        }\n        return list;\n    }\n    /**\n     * Update keysDefMap for multi-level keys\n     */\n    private void checkMultiLevelKeys(final Map<String, KeyDef> keysDefMap, final Map<String, String> keysRefMap) {\n        String key = null;\n        KeyDef value = null;\n        // tempMap storing values to avoid ConcurrentModificationException\n        final Map<String, KeyDef> tempMap = new HashMap<String, KeyDef>();\n        for (Entry<String, KeyDef> entry : keysDefMap.entrySet()) {\n            key = entry.getKey();\n            value = entry.getValue();\n            // there is multi-level keys exist.\n            if (keysRefMap.containsValue(key)) {\n                // get multi-level keys\n                final List<String> keysList = getKeysList(key, keysRefMap);\n                for (final String multikey : keysList) {\n                    // update tempMap\n                    tempMap.put(multikey, value);\n                }\n            }\n        }\n        // update keysDefMap.\n        keysDefMap.putAll(tempMap);\n    }\n//    /**\n//     * Check if path walks up in parent directories\n//     * \n//     * @param toCheckPath path to check\n//     * @return {@code true} if path walks up, otherwise {@code false}\n//     */\n//    private boolean isOutFile(final String toCheckPath) {\n//        if (!toCheckPath.startsWith(\"..\")) {\n//            return false;\n//        } else {\n//            return true;\n//        }\n//    }\n    /**\n     * Check if current file is a map or if not only topics in main map are processed \n     */\n    private boolean canResolved() {\n        return !job.getOnlyTopicInMap() || rootClass != null && MAP_MAP.matches(rootClass);\n    }\n//    /**\n//     * Add file to out files set\n//     * \n//     * @param filename a relative path from the dita input file\n//     */\n//    private void toOutFile(final String filename) throws DITAOTException {\n//        final String[] prop = { FileUtils.normalizeDirectory(inputDir.getAbsolutePath(), filename), FileUtils.normalize(currentFile.getAbsolutePath()) };\n//        if ((OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.NOT_GENERATEOUTTER)\n//                || (OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.GENERATEOUTTER)) {\n//            if (isOutFile(filename)) {\n//                if (outputUtils.getOutterControl() == OutputUtils.OutterControl.FAIL) {\n//                    final MessageBean msgBean = MessageUtils.getInstance().getMessage(\"DOTJ035F\", prop);\n//                    throw new DITAOTException(msgBean, null, msgBean.toString());\n//                } else if (outputUtils.getOutterControl() == OutputUtils.OutterControl.WARN) {\n//                    final String message = MessageUtils.getInstance().getMessage(\"DOTJ036W\", prop).toString();\n//                    logger.logWarn(message);\n//                }\n//                if (canResolved()) {\n//                    outDitaFilesSet.add(filename);\n//                }\n//            }\n//        }\n//    }\n    /**\n     * Get path to base directory\n     * \n     * @param filename relative input file path from base directory\n     * @param traceFilename absolute input file\n     * @param inputMap absolute path to start file\n     * @return path to base directory, {@code null} if not available\n     */\n    public String getPathtoProject(final File filename, final File traceFilename, final String inputMap) {\n        String path2Project = null;\n//        if (OutputUtils.getGeneratecopyouter() != OutputUtils.Generate.OLDSOLUTION) {\n//            if (isOutFile(traceFilename)) {\n//                path2Project = getRelativePathFromOut(traceFilename.getAbsolutePath());\n//            } else {\n//                path2Project = FileUtils.getRelativePath(traceFilename.getAbsolutePath(),inputMap);\n//                path2Project = new File(path2Project).getParent();\n//                if (path2Project != null && path2Project.length() > 0) {\n//                    path2Project = path2Project+File.separator;\n//                }\n//            }\n//        } else {\n            final File p = FileUtils.getRelativePath(filename); \n            path2Project = p != null ? p.getPath() : null;\n            if (path2Project != null && !path2Project.endsWith(File.separator)) {\n                path2Project = path2Project + File.separator;\n            }\n//        }\n         return path2Project;\n    }\n//    /**\n//     * Check if path falls outside start document directory\n//     * \n//     * @param filePathName path to test\n//     * @return {@code true} if outside start directory, otherwise {@code false}\n//     */\n//    private boolean isOutFile(final File filePathName) {\n//        final String relativePath = FileUtils.getRelativePath(outputUtils.getInputMapPathName().getAbsolutePath(), filePathName.getPath());\n//        if (relativePath == null || relativePath.length() == 0 || !relativePath.startsWith(\"..\")) {\n//            return false;\n//        }\n//        return true;\n//    }\n//    /**\n//     * Just for the overflowing files.\n//     * @param overflowingFile overflowingFile\n//     * @return relative path to out\n//     */\n//    public String getRelativePathFromOut(final String overflowingFile) {\n//        final File mapPathName = outputUtils.getInputMapPathName();\n//        final File currFilePathName = new File(overflowingFile);\n//        final String relativePath = FileUtils.getRelativePath( mapPathName.toString(),currFilePathName.toString());\n//        final String outputDir = OutputUtils.getOutputDir().getAbsolutePath();\n//        final String outputPathName = outputDir + File.separator + \"index.html\";\n//        final String finalOutFilePathName = FileUtils.resolve(outputDir,relativePath);\n//        final String finalRelativePathName = FileUtils.getRelativePath(finalOutFilePathName,outputPathName.toString());\n//        final String parentDir = new File(finalRelativePathName).getParent();\n//        final StringBuffer finalRelativePath = new StringBuffer(parentDir);\n//        if (finalRelativePath.length() > 0) {\n//            finalRelativePath.append(File.separator);\n//        } else {\n//            finalRelativePath.append(\".\").append(File.separator);\n//        }\n//        return finalRelativePath.toString();\n//    }\n    /**\n     * File reference with path and optional format.\n     */\n    public static class Reference {\n        public final String filename;\n        public final String format;\n        public Reference(final String filename, final String format) {\n            this.filename = filename;\n            this.format = format;\n        }\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((filename == null) ? 0 : filename.hashCode());\n            result = prime * result + ((format == null) ? 0 : format.hashCode());\n            return result;\n        }\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (!(obj instanceof Reference)) {\n                return false;\n            }\n            final Reference other = (Reference) obj;\n            if (filename == null) {\n                if (other.filename != null) {\n                    return false;\n                }\n            } else if (!filename.equals(other.filename)) {\n                return false;\n            }\n            if (format == null) {\n                if (other.format != null) {\n                    return false;\n                }\n            } else if (!format.equals(other.format)) {\n                return false;\n            }\n            return true;\n        }\n    }\n//    public static class ExportAnchor {\n//        public final String file;\n//        public final Set<String> topicids = new HashSet<String>();\n//        public final Set<String> keys = new HashSet<String>();\n//        public final Set<String> ids = new HashSet<String>();\n//\n//        ExportAnchor(final String file) {\n//            this.file = file;\n//        }\n//    }\n"]], "pred": {"ppl": 3.788243532180786, "ppl_lower": 4.333098411560059, "ppl/lowercase_ppl": -1.1008935673400262, "ppl/zlib": 0.0001318845889390755, "Min_5.0% Prob": 8.272843632043577, "Min_10.0% Prob": 6.715406740412993, "Min_20.0% Prob": 5.048602049257241, "Min_30.0% Prob": 3.9629701337004017, "Min_40.0% Prob": 3.1752240705898163, "Min_50.0% Prob": 2.61681489952623, "Min_60.0% Prob": 2.2084951539194213}}
{"hexsha": "3abe7b52c94ec035e1029d23e697ea01235ace05", "ext": "java", "lang": "Java", "content": "@Data\n@JsonDeserialize(builder = Document.Builder.class)\npublic class Document implements Serializable {\n\n    private static final long serialVersionUID = 7352690975010398089L;\n\n    /**\n     * @return The reference of the document\n     * @serial The reference of the document\n     */\n    private final String reference;\n\n    /**\n     * @return The weight (relevance) of the document\n     * @serial The weight (relevance) of the document\n     */\n    private final double weight;\n\n    /**\n     * @return The stemmed terms from the query which matched the document\n     * @serial The stemmed terms from the query which matched the document\n     */\n    private final Set<String> links;\n\n    /**\n     * @return The index in which the document resides\n     * @serial The index in which the document resides\n     */\n    private final String index;\n\n    /**\n     * @return The title of the document\n     * @serial The title of the document\n     */\n    private final String title;\n\n    /**\n     * @return A summary of the document. If summaries were not requested, this will be the empty string\n     * @serial A summary of the document. If summaries were not requested, this will be the empty string\n     */\n    private final String summary;\n\n    /**\n     * @return The content of the document. If content were not requested, this will be the empty string\n     * @serial The content of the document. If content were not requested, this will be the empty string\n     */\n    private final String content;\n\n    /**\n     * @return A map containing any fields on the document which are not known ahead of time\n     */\n    @Setter(AccessLevel.NONE)\n    private transient Map<String, Serializable> fields;\n\n    /**\n     * @return The section number of the result document\n     * @serial The section number of the result document\n     */\n    private final Integer section;\n\n    /**\n     * @return The type of promotion which triggered this result\n     * @serial The type of promotion which triggered this result\n     */\n    @Setter(AccessLevel.NONE)\n    private PromotionType promotionType;\n\n    private Document(final Builder builder) {\n        reference = builder.reference;\n        weight = builder.weight;\n        links = builder.links;\n        index = builder.index;\n        title = builder.title;\n        summary = builder.summary;\n        fields = builder.fields;\n        content = builder.content;\n        section = builder.section;\n\n        promotionType = builder.promotionType == null ? PromotionType.NONE : builder.promotionType;\n    }\n\n    /**\n     * @param objectOutputStream The output stream\n     * @serialData Writes out the standard fields, then the number of non-standard fields {@code int}, followed by\n     * the non-standard field names alternated with their values\n     */\n    private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {\n        objectOutputStream.defaultWriteObject();\n\n        objectOutputStream.writeInt(fields.size());\n\n        for (final Map.Entry<String, Serializable> entry : fields.entrySet()) {\n            objectOutputStream.writeObject(entry.getKey());\n            objectOutputStream.writeObject(entry.getValue());\n        }\n    }\n\n    private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n        objectInputStream.defaultReadObject();\n        fields = new HashMap<>();\n\n        final int fieldCount = objectInputStream.readInt();\n\n        for (int i = 0; i < fieldCount; i++) {\n            final String fieldName = (String) objectInputStream.readObject();\n            final Serializable value = (Serializable) objectInputStream.readObject();\n            fields.put(fieldName, value);\n        }\n\n        // For backwards compatibility of serialized form\n        if (promotionType == null) {\n            promotionType = PromotionType.NONE;\n        }\n    }\n\n    @Setter\n    @Accessors(chain = true)\n    @JsonPOJOBuilder(withPrefix = \"set\")\n    public static class Builder {\n\n        private String reference;\n        private double weight;\n        private Set<String> links;\n        private String index;\n        private String title;\n        private Integer section;\n\n        @JsonProperty(\"promotion\")\n        private PromotionType promotionType;\n\n        @SuppressWarnings(\"FieldMayBeFinal\")\n        private String content = \"\";\n\n        private final Map<String, Serializable> fields = new HashMap<>();\n\n        @SuppressWarnings(\"FieldMayBeFinal\")\n        private String summary = \"\";\n\n        public Builder setLinks(final Set<String> links) {\n            if (links != null) {\n                this.links = new HashSet<>(links);\n            }\n\n            return this;\n        }\n\n        public Builder addField(final String key, final Serializable value) {\n            fields.put(key, value);\n            return this;\n        }\n\n        // Jackson can't convert to interfaces, so we need this helper method\n        @JsonAnySetter\n        Builder _addField(final String key, final Object value) {\n            // Assume Jackson will give us a Serializable type\n            this.addField(key, (Serializable) value);\n            return this;\n        }\n\n        public Document build() {\n            return new Document(this);\n        }\n\n    }\n\n}", "class_id": 0, "repo": "microfocus-idol/java-hod-client", "file": "src/main/java/com/hp/autonomy/hod/client/api/textindex/query/search/Document.java", "last_update_at": "2018-06-22T17:59:44+00:00", "question_id": "3abe7b52c94ec035e1029d23e697ea01235ace05", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Data\n@JsonDeserialize(builder = Document.Builder.class)\npublic class Document implements Serializable {\n    private static final long serialVersionUID = 7352690975010398089L;\n    /**\n     * @return The reference of the document\n     * @serial The reference of the document\n     */\n    private final String reference;\n    /**\n     * @return The weight (relevance) of the document\n     * @serial The weight (relevance) of the document\n     */\n    private final double weight;\n    /**\n     * @return The stemmed terms from the query which matched the document\n     * @serial The stemmed terms from the query which matched the document\n     */\n    private final Set<String> links;\n    /**\n     * @return The index in which the document resides\n     * @serial The index in which the document resides\n     */\n    private final String index;\n    /**\n     * @return The title of the document\n     * @serial The title of the document\n     */\n    private final String title;\n    /**\n     * @return A summary of the document. If summaries were not requested, this will be the empty string\n     * @serial A summary of the document. If summaries were not requested, this will be the empty string\n     */\n    private final String summary;\n    /**\n     * @return The content of the document. If content were not requested, this will be the empty string\n     * @serial The content of the document. If content were not requested, this will be the empty string\n     */\n    private final String content;\n    /**\n     * @return A map containing any fields on the document which are not known ahead of time\n     */\n    @Setter(AccessLevel.NONE)\n    private transient Map<String, Serializable> fields;\n    /**\n     * @return The section number of the result document\n     * @serial The section number of the result document\n     */\n    private final Integer section;\n    /**\n     * @return The type of promotion which triggered this result\n     * @serial The type of promotion which triggered this result\n     */\n    @Setter(AccessLevel.NONE)\n    private PromotionType promotionType;\n    private Document(final Builder builder) {\n        reference = builder.reference;\n        weight = builder.weight;\n        links = builder.links;\n        index = builder.index;\n        title = builder.title;\n        summary = builder.summary;\n        fields = builder.fields;\n        content = builder.content;\n        section = builder.section;\n        promotionType = builder.promotionType == null ? PromotionType.NONE : builder.promotionType;\n    }\n    /**\n     * @param objectOutputStream The output stream\n     * @serialData Writes out the standard fields, then the number of non-standard fields {@code int}, followed by\n     * the non-standard field names alternated with their values\n     */\n    private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {\n        objectOutputStream.defaultWriteObject();\n        objectOutputStream.writeInt(fields.size());\n        for (final Map.Entry<String, Serializable> entry : fields.entrySet()) {\n            objectOutputStream.writeObject(entry.getKey());\n            objectOutputStream.writeObject(entry.getValue());\n        }\n    }\n    private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n        objectInputStream.defaultReadObject();\n        fields = new HashMap<>();\n        final int fieldCount = objectInputStream.readInt();\n        for (int i = 0; i < fieldCount; i++) {\n            final String fieldName = (String) objectInputStream.readObject();\n            final Serializable value = (Serializable) objectInputStream.readObject();\n            fields.put(fieldName, value);\n        }\n        // For backwards compatibility of serialized form\n        if (promotionType == null) {\n            promotionType = PromotionType.NONE;\n        }\n    }\n    @Setter\n    @Accessors(chain = true)\n    @JsonPOJOBuilder(withPrefix = \"set\")\n    public static class Builder {\n        private String reference;\n        private double weight;\n        private Set<String> links;\n        private String index;\n        private String title;\n        private Integer section;\n        @JsonProperty(\"promotion\")\n        private PromotionType promotionType;\n        @SuppressWarnings(\"FieldMayBeFinal\")\n        private String content = \"\";\n        private final Map<String, Serializable> fields = new HashMap<>();\n        @SuppressWarnings(\"FieldMayBeFinal\")\n        private String summary = \"\";\n        public Builder setLinks(final Set<String> links) {\n            if (links != null) {\n                this.links = new HashSet<>(links);\n            }\n            return this;\n        }\n        public Builder addField(final String key, final Serializable value) {\n            fields.put(key, value);\n            return this;\n        }\n        // Jackson can't convert to interfaces, so we need this helper method\n        @JsonAnySetter\n        Builder _addField(final String key, final Object value) {\n            // Assume Jackson will give us a Serializable type\n            this.addField(key, (Serializable) value);\n            return this;\n        }\n        public Document build() {\n            return new Document(this);\n        }\n    }\n"]], "pred": {"ppl": 1.73673677444458, "ppl_lower": 2.0059711933135986, "ppl/lowercase_ppl": -1.2610839165091383, "ppl/zlib": 0.00038521139947264447, "Min_5.0% Prob": 5.6962084583207675, "Min_10.0% Prob": 4.162291208902995, "Min_20.0% Prob": 2.6190942964133095, "Min_30.0% Prob": 1.8194319064077598, "Min_40.0% Prob": 1.3751378309682996, "Min_50.0% Prob": 1.1035394219858408, "Min_60.0% Prob": 0.9207334675097635}}
{"hexsha": "1243e39f474919a5cd4c43b9d72ec532c1c5600f", "ext": "java", "lang": "Java", "content": "public class PacketDescription extends LocatedPacket<PacketDescription>{\n    private byte[] types;\n    private Object[] values;\n    private NBTTagCompound extraData;\n\n    public PacketDescription(){}\n\n    public PacketDescription(TileBase te){\n        super(te.xCoord, te.yCoord, te.zCoord);\n        values = new Object[te.getDescriptionFields().size()];\n        types = new byte[values.length];\n        for(int i = 0; i < values.length; i++) {\n            values[i] = te.getDescriptionFields().get(i).getValue();\n            types[i] = PacketCUpdateGui.getType(te.getDescriptionFields().get(i));\n        }\n        extraData = new NBTTagCompound();\n        te.writeToPacketNBT(extraData);\n    }\n\n    @Override\n    public void toBytes(ByteBuf buf){\n        super.toBytes(buf);\n        buf.writeInt(values.length);\n        for(int i = 0; i < types.length; i++) {\n            buf.writeByte(types[i]);\n            PacketCUpdateGui.writeField(buf, values[i], types[i]);\n        }\n        ByteBufUtils.writeTag(buf, extraData);\n    }\n\n    @Override\n    public void fromBytes(ByteBuf buf){\n        super.fromBytes(buf);\n        int dataAmount = buf.readInt();\n        types = new byte[dataAmount];\n        values = new Object[dataAmount];\n        for(int i = 0; i < dataAmount; i++) {\n            types[i] = buf.readByte();\n            values[i] = PacketCUpdateGui.readField(buf, types[i]);\n        }\n        extraData = ByteBufUtils.readTag(buf);\n    }\n\n    @Override\n    public void handleClientSide(EntityPlayer player){\n        TileEntity te = getTileEntity(player.worldObj);\n        if(te instanceof TileBase) {\n            List<SyncedField> descFields = ((TileBase)te).getDescriptionFields();\n            if(descFields != null && descFields.size() == types.length) {\n                for(int i = 0; i < descFields.size(); i++) {\n                    descFields.get(i).setValue(values[i]);\n                }\n            }\n            ((TileBase)te).readFromPacketNBT(extraData);\n        }\n    }\n\n    @Override\n    public void handleServerSide(EntityPlayer player){\n\n    }\n\n}", "class_id": 0, "repo": "GTNewHorizons/QmunityLib", "file": "src/main/java/uk/co/qmunity/lib/network/annotation/PacketDescription.java", "last_update_at": "2018-01-02T23:18:21+00:00", "question_id": "1243e39f474919a5cd4c43b9d72ec532c1c5600f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PacketDescription extends LocatedPacket<PacketDescription>{\n    private byte[] types;\n    private Object[] values;\n    private NBTTagCompound extraData;\n    public PacketDescription(){}\n    public PacketDescription(TileBase te){\n        super(te.xCoord, te.yCoord, te.zCoord);\n        values = new Object[te.getDescriptionFields().size()];\n        types = new byte[values.length];\n        for(int i = 0; i < values.length; i++) {\n            values[i] = te.getDescriptionFields().get(i).getValue();\n            types[i] = PacketCUpdateGui.getType(te.getDescriptionFields().get(i));\n        }\n        extraData = new NBTTagCompound();\n        te.writeToPacketNBT(extraData);\n    }\n    @Override\n    public void toBytes(ByteBuf buf){\n        super.toBytes(buf);\n        buf.writeInt(values.length);\n        for(int i = 0; i < types.length; i++) {\n            buf.writeByte(types[i]);\n            PacketCUpdateGui.writeField(buf, values[i], types[i]);\n        }\n        ByteBufUtils.writeTag(buf, extraData);\n    }\n    @Override\n    public void fromBytes(ByteBuf buf){\n        super.fromBytes(buf);\n        int dataAmount = buf.readInt();\n        types = new byte[dataAmount];\n        values = new Object[dataAmount];\n        for(int i = 0; i < dataAmount; i++) {\n            types[i] = buf.readByte();\n            values[i] = PacketCUpdateGui.readField(buf, types[i]);\n        }\n        extraData = ByteBufUtils.readTag(buf);\n    }\n    @Override\n    public void handleClientSide(EntityPlayer player){\n        TileEntity te = getTileEntity(player.worldObj);\n        if(te instanceof TileBase) {\n            List<SyncedField> descFields = ((TileBase)te).getDescriptionFields();\n            if(descFields != null && descFields.size() == types.length) {\n                for(int i = 0; i < descFields.size(); i++) {\n                    descFields.get(i).setValue(values[i]);\n                }\n            }\n            ((TileBase)te).readFromPacketNBT(extraData);\n        }\n    }\n    @Override\n    public void handleServerSide(EntityPlayer player){\n    }\n"]], "pred": {"ppl": 1.5538415908813477, "ppl_lower": 1.8579950332641602, "ppl/lowercase_ppl": -1.4056168877782969, "ppl/zlib": 0.0006897187955865441, "Min_5.0% Prob": 5.642862473764727, "Min_10.0% Prob": 3.5805243253707886, "Min_20.0% Prob": 2.099401832342148, "Min_30.0% Prob": 1.4507884068929768, "Min_40.0% Prob": 1.1009845601692796, "Min_50.0% Prob": 0.8816962861679137, "Min_60.0% Prob": 0.7346030537409342}}
{"hexsha": "b8b7a68566d41f87ddb5ebcfd0dfa98318317a29", "ext": "java", "lang": "Java", "content": "public class EmojiController extends SuperController {\n\n    /**\n     * Construct a controller for emojis.\n     *\n     * @param database the database containing emoji data\n     */\n    public EmojiController(MongoDatabase database) {\n        this.gson = new Gson();\n        this.database = database;\n        this.collection = database.getCollection(\"emojis\");\n    }\n\n    public String addNewEmoji(String userID, int mood, int intensity) {\n\n        Document newEmoji = new Document();\n        newEmoji.append(\"userID\", userID);\n        newEmoji.append(\"mood\", mood);\n        newEmoji.append(\"intensity\", intensity);\n\n        Date now = new Date();\n        newEmoji.append(\"date\", now.toString());\n\n        try {\n            collection.insertOne(newEmoji);\n\n            ObjectId id = newEmoji.getObjectId(\"_id\");\n            System.err.println(\"Successfully added new emoji [_id=\" + id + \", userID=\" + userID + \", mood=\"\n                + mood + \" date=\" + now + ']');\n\n            return JSON.serialize(id);\n        } catch(MongoException me) {\n            me.printStackTrace();\n            return null;\n        }\n    }\n}", "class_id": 0, "repo": "corde171/iteration-4-secure-super-group", "file": "server/src/main/java/umm3601/emoji/EmojiController.java", "last_update_at": "2018-05-04T01:35:45+00:00", "question_id": "b8b7a68566d41f87ddb5ebcfd0dfa98318317a29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EmojiController extends SuperController {\n    /**\n     * Construct a controller for emojis.\n     *\n     * @param database the database containing emoji data\n     */\n    public EmojiController(MongoDatabase database) {\n        this.gson = new Gson();\n        this.database = database;\n        this.collection = database.getCollection(\"emojis\");\n    }\n    public String addNewEmoji(String userID, int mood, int intensity) {\n        Document newEmoji = new Document();\n        newEmoji.append(\"userID\", userID);\n        newEmoji.append(\"mood\", mood);\n        newEmoji.append(\"intensity\", intensity);\n        Date now = new Date();\n        newEmoji.append(\"date\", now.toString());\n        try {\n            collection.insertOne(newEmoji);\n            ObjectId id = newEmoji.getObjectId(\"_id\");\n            System.err.println(\"Successfully added new emoji [_id=\" + id + \", userID=\" + userID + \", mood=\"\n                + mood + \" date=\" + now + ']');\n            return JSON.serialize(id);\n        } catch(MongoException me) {\n            me.printStackTrace();\n            return null;\n        }\n    }\n"]], "pred": {"ppl": 1.9404823780059814, "ppl_lower": 2.48004150390625, "ppl/lowercase_ppl": -1.3700786897702557, "ppl/zlib": 0.0013840012330355409, "Min_5.0% Prob": 5.8258892595767975, "Min_10.0% Prob": 4.438262082636356, "Min_20.0% Prob": 2.9423803485356843, "Min_30.0% Prob": 2.140671820677433, "Min_40.0% Prob": 1.6377883703662799, "Min_50.0% Prob": 1.3250335754343756, "Min_60.0% Prob": 1.1036905120007503}}
{"hexsha": "7c22b8e327301b6e0dc6375b3fb9ff4f845efc50", "ext": "java", "lang": "Java", "content": "@SideOnly(Side.CLIENT)\npublic class ParticleFireflyTail extends Particle {\n\n\tprivate static ResourceLocation texture = new ResourceLocation(Motherlode.MOD_ID, \"entity/firefly\");\n\t\n\tpublic ParticleFireflyTail(World worldIn, double xCoordIn, double yCoordIn, double zCoordIn, double xSpeedIn,\n\t\t\tdouble ySpeedIn, double zSpeedIn) {\n\t\t\n\t\tsuper(worldIn, xCoordIn, yCoordIn, zCoordIn);\n\t\tthis.motionX = xSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);\n\t\tthis.motionY = ySpeedIn - 0.01 * this.rand.nextDouble();\n\t\tthis.motionZ = zSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);\n\t\tthis.particleScale = 0.25F;\n\t\tthis.particleMaxAge = 10;\n\t\t\n\t\tTextureAtlasSprite sprite = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(texture.toString());\n\t\tthis.setParticleTexture(sprite);\n\t}\n\t\n\tpublic static ResourceLocation getTexture() {\n\t\treturn texture;\n\t}\n\t\n\t@Override\n\tpublic void onUpdate() {\n        this.prevPosX = this.posX;\n        this.prevPosY = this.posY;\n        this.prevPosZ = this.posZ;\n        this.particleScale *= 0.9;\n        \n        if (this.particleAge++ >= this.particleMaxAge) {\n            this.setExpired();\n        }\n        \n        this.move(this.motionX, this.motionY, this.motionZ);\n\t}\n\t\n\t@Override\n    public int getBrightnessForRender(float partialTicks) {\n\t\treturn 15728800;\n\t}\n\t\n\t// Use the block+item texture sheet onto which we have stitched our sprite in event handler\n\t@Override\n\tpublic int getFXLayer() {\n\t\treturn 1;\n\t}\n}", "class_id": 0, "repo": "MotherlodeMod/MotherlodeMod", "file": "src/main/java/motherlode/client/particle/ParticleFireflyTail.java", "last_update_at": "2018-07-03T20:54:13+00:00", "question_id": "7c22b8e327301b6e0dc6375b3fb9ff4f845efc50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SideOnly(Side.CLIENT)\npublic class ParticleFireflyTail extends Particle {\n\tprivate static ResourceLocation texture = new ResourceLocation(Motherlode.MOD_ID, \"entity/firefly\");\n\t\n\tpublic ParticleFireflyTail(World worldIn, double xCoordIn, double yCoordIn, double zCoordIn, double xSpeedIn,\n\t\t\tdouble ySpeedIn, double zSpeedIn) {\n\t\t\n\t\tsuper(worldIn, xCoordIn, yCoordIn, zCoordIn);\n\t\tthis.motionX = xSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);\n\t\tthis.motionY = ySpeedIn - 0.01 * this.rand.nextDouble();\n\t\tthis.motionZ = zSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);\n\t\tthis.particleScale = 0.25F;\n\t\tthis.particleMaxAge = 10;\n\t\t\n\t\tTextureAtlasSprite sprite = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(texture.toString());\n\t\tthis.setParticleTexture(sprite);\n\t}\n\t\n\tpublic static ResourceLocation getTexture() {\n\t\treturn texture;\n\t}\n\t\n\t@Override\n\tpublic void onUpdate() {\n        this.prevPosX = this.posX;\n        this.prevPosY = this.posY;\n        this.prevPosZ = this.posZ;\n        this.particleScale *= 0.9;\n        if (this.particleAge++ >= this.particleMaxAge) {\n            this.setExpired();\n        }\n        this.move(this.motionX, this.motionY, this.motionZ);\n\t}\n\t\n\t@Override\n    public int getBrightnessForRender(float partialTicks) {\n\t\treturn 15728800;\n\t}\n\t\n\t// Use the block+item texture sheet onto which we have stitched our sprite in event handler\n\t@Override\n\tpublic int getFXLayer() {\n\t\treturn 1;\n\t}\n"]], "pred": {"ppl": 1.6958796977996826, "ppl_lower": 2.391486644744873, "ppl/lowercase_ppl": -1.6507242621590938, "ppl/zlib": 0.0008533143811837215, "Min_5.0% Prob": 6.175915002822876, "Min_10.0% Prob": 4.1760202094360634, "Min_20.0% Prob": 2.462580012072117, "Min_30.0% Prob": 1.7365028167063474, "Min_40.0% Prob": 1.3142578657545627, "Min_50.0% Prob": 1.0567972817156903, "Min_60.0% Prob": 0.8799511017541284}}
{"hexsha": "c6f564848d36a048ee66efbb3bba56a2b1233f40", "ext": "java", "lang": "Java", "content": "public class MoodLightSaveSettingsEvent extends MessageHandler\n{\n    @Override\n    public void handle() throws Exception\n    {\n        Room room = this.client.getHabbo().getHabboInfo().getCurrentRoom();\n\n        if((room.getGuildId() > 0 && room.guildRightLevel(this.client.getHabbo()) < 2) && !room.hasRights(this.client.getHabbo()))\n            return;\n\n        int id = this.packet.readInt();\n        int backgroundOnly = this.packet.readInt();\n        String color = this.packet.readString();\n        int intensity = this.packet.readInt();\n\n        for(RoomMoodlightData data : room.getMoodlightData().valueCollection())\n        {\n            if(data.getId() == id)\n            {\n                data.setBackgroundOnly(backgroundOnly == 2);\n                data.setColor(color);\n                data.setIntensity(intensity);\n                data.enable();\n\n                for(HabboItem item : room.getRoomSpecialTypes().getItemsOfType(InteractionMoodLight.class))\n                {\n                    item.setExtradata(data.toString());\n                    item.needsUpdate(true);\n                    room.updateItem(item);\n                    Emulator.getThreading().run(item);\n                }\n            }\n            else\n            {\n                data.disable();\n            }\n        }\n\n        room.setNeedsUpdate(true);\n        this.client.sendResponse(new MoodLightDataComposer(room.getMoodlightData()));\n    }\n}", "class_id": 0, "repo": "Jackxun123/ArcturusEmulator", "file": "src/main/java/com/eu/habbo/messages/incoming/rooms/items/MoodLightSaveSettingsEvent.java", "last_update_at": "2018-12-21T00:02:33+00:00", "question_id": "c6f564848d36a048ee66efbb3bba56a2b1233f40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MoodLightSaveSettingsEvent extends MessageHandler\n{\n    @Override\n    public void handle() throws Exception\n    {\n        Room room = this.client.getHabbo().getHabboInfo().getCurrentRoom();\n        if((room.getGuildId() > 0 && room.guildRightLevel(this.client.getHabbo()) < 2) && !room.hasRights(this.client.getHabbo()))\n            return;\n        int id = this.packet.readInt();\n        int backgroundOnly = this.packet.readInt();\n        String color = this.packet.readString();\n        int intensity = this.packet.readInt();\n        for(RoomMoodlightData data : room.getMoodlightData().valueCollection())\n        {\n            if(data.getId() == id)\n            {\n                data.setBackgroundOnly(backgroundOnly == 2);\n                data.setColor(color);\n                data.setIntensity(intensity);\n                data.enable();\n                for(HabboItem item : room.getRoomSpecialTypes().getItemsOfType(InteractionMoodLight.class))\n                {\n                    item.setExtradata(data.toString());\n                    item.needsUpdate(true);\n                    room.updateItem(item);\n                    Emulator.getThreading().run(item);\n                }\n            }\n            else\n            {\n                data.disable();\n            }\n        }\n        room.setNeedsUpdate(true);\n        this.client.sendResponse(new MoodLightDataComposer(room.getMoodlightData()));\n    }\n"]], "pred": {"ppl": 1.9862353801727295, "ppl_lower": 2.70949125289917, "ppl/lowercase_ppl": -1.4524937652294858, "ppl/zlib": 0.0012779163469730148, "Min_5.0% Prob": 7.016666111193206, "Min_10.0% Prob": 5.107364874619704, "Min_20.0% Prob": 3.1771466724480253, "Min_30.0% Prob": 2.2440956257471516, "Min_40.0% Prob": 1.7113250235107336, "Min_50.0% Prob": 1.373147770191482, "Min_60.0% Prob": 1.1449476937786773}}
{"hexsha": "25a07b0e9ef067f335827cb82f7451f3289faefd", "ext": "java", "lang": "Java", "content": "public class CMDLog implements CommandExecutor {\r\n\r\n\t@Override\r\n\tpublic CommandResult execute(CommandSource src, CommandContext args) throws CommandException {\r\n\t\tif (!args.hasAny(\"true|false\")) {\r\n\t\t\tHelp help = Help.get(\"sban log\").get();\r\n\t\t\tthrow new CommandException(Text.builder().onClick(TextActions.executeCallback(help.execute())).append(help.getUsageText()).build(), false);\r\n\t\t}\r\n\t\tboolean value = args.<Boolean>getOne(\"true|false\").get();\r\n\r\n\t\tConfigManager configManager = ConfigManager.get(Main.getPlugin());\r\n\r\n\t\tconfigManager.getConfig().getNode(\"console_log\").setValue(value);\r\n\t\tconfigManager.save();\r\n\r\n\t\tsrc.sendMessage(Text.of(TextColors.GREEN, \"Set ban logging to \", value));\r\n\r\n\t\treturn CommandResult.success();\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "trentech/StackBan", "file": "src/main/java/com/gmail/trentech/stackban/commands/CMDLog.java", "last_update_at": "2018-06-11T07:37:20+00:00", "question_id": "25a07b0e9ef067f335827cb82f7451f3289faefd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CMDLog implements CommandExecutor {\r\n\r\n\t@Override\r\n\tpublic CommandResult execute(CommandSource src, CommandContext args) throws CommandException {\r\n\t\tif (!args.hasAny(\"true|false\")) {\r\n\t\t\tHelp help = Help.get(\"sban log\").get();\r\n\t\t\tthrow new CommandException(Text.builder().onClick(TextActions.executeCallback(help.execute())).append(help.getUsageText()).build(), false);\r\n\t\t}\r\n\t\tboolean value = args.<Boolean>getOne(\"true|false\").get();\r\n\r\n\t\tConfigManager configManager = ConfigManager.get(Main.getPlugin());\r\n\r\n\t\tconfigManager.getConfig().getNode(\"console_log\").setValue(value);\r\n\t\tconfigManager.save();\r\n\r\n\t\tsrc.sendMessage(Text.of(TextColors.GREEN, \"Set ban logging to \", value));\r\n\r\n\t\treturn CommandResult.success();\r\n\t}\r\n\r\n"]], "pred": {"ppl": 2.2967302799224854, "ppl_lower": 3.9020540714263916, "ppl/lowercase_ppl": -1.637432609193469, "ppl/zlib": 0.0020479962907717472, "Min_5.0% Prob": 7.089377576654607, "Min_10.0% Prob": 5.199055267416912, "Min_20.0% Prob": 3.5516118251759075, "Min_30.0% Prob": 2.604767944501794, "Min_40.0% Prob": 2.029850908109675, "Min_50.0% Prob": 1.6506639124906581, "Min_60.0% Prob": 1.3832185780089619}}
{"hexsha": "22c209a7a3105ba778af3755b98c9b9a9afd18bc", "ext": "java", "lang": "Java", "content": "public class Form {\n\n\n    private ModelRenderer mRenderer;\n    private android.view.View mView;\n    private Model mModel;\n    private List<IFormOperation> mOperations;\n    private List<Component> mComponents;\n\n\n    public Form(ModelRenderer renderer){\n\n        mRenderer = renderer;\n\n    }\n\n    public Form setModel(Model model){\n\n        mModel = model;\n\n        return this;\n\n    }\n\n    public Form create(LayoutInflater inflater, ViewGroup container) {\n\n        mView = inflater.inflate( getModel().getOptions().getFormLayoutId() , container, false);\n\n        getComponents().clear();\n\n        return this;\n\n    }\n\n    public Form registerOperation(IFormOperation operation){\n\n        if(getOperations().indexOf(operation)  <= -1) {\n\n            getOperations().add(operation);\n\n        }\n\n        return this;\n\n    }\n\n    public Form registerComponent(Component component){\n\n        if(!getComponents().contains(component)) {\n\n            getComponents().add(component);\n\n        }\n\n        return this;\n\n    }\n\n    public Form initOperations(){\n\n        for (IFormOperation operation:getOperations()) {\n\n            operation.onInit();\n\n        }\n\n        return this;\n\n    }\n\n\n    public ModelRenderer getRenderer(){\n\n        return mRenderer;\n\n    }\n\n    public List<Component> getComponents() {\n\n        if(mComponents == null){\n\n            mComponents = new ArrayList<>();\n\n        }\n\n        return mComponents;\n\n    }\n\n    public Model getModel(){\n\n        return mModel;\n\n    }\n\n    public android.view.View getView() {\n\n        return mView;\n\n    }\n\n    public List<IFormOperation> getOperations(){\n\n        if(mOperations == null){\n\n            mOperations = new ArrayList<>();\n\n        }\n\n        return mOperations;\n\n    }\n\n    public Component getComponent(PropertyInfo property){\n\n        for (Component comp: getComponents()) {\n\n            if(comp.getPropertyInfo().equals(property)) {\n\n                return comp;\n\n            }\n\n        }\n\n        return null;\n\n    }\n\n}", "class_id": 0, "repo": "Rmanaf/Impala", "file": "src/main/java/com/github/rmanaf/impala/forms/Form.java", "last_update_at": "2018-04-27T22:32:22+00:00", "question_id": "22c209a7a3105ba778af3755b98c9b9a9afd18bc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Form {\n    private ModelRenderer mRenderer;\n    private android.view.View mView;\n    private Model mModel;\n    private List<IFormOperation> mOperations;\n    private List<Component> mComponents;\n    public Form(ModelRenderer renderer){\n        mRenderer = renderer;\n    }\n    public Form setModel(Model model){\n        mModel = model;\n        return this;\n    }\n    public Form create(LayoutInflater inflater, ViewGroup container) {\n        mView = inflater.inflate( getModel().getOptions().getFormLayoutId() , container, false);\n        getComponents().clear();\n        return this;\n    }\n    public Form registerOperation(IFormOperation operation){\n        if(getOperations().indexOf(operation)  <= -1) {\n            getOperations().add(operation);\n        }\n        return this;\n    }\n    public Form registerComponent(Component component){\n        if(!getComponents().contains(component)) {\n            getComponents().add(component);\n        }\n        return this;\n    }\n    public Form initOperations(){\n        for (IFormOperation operation:getOperations()) {\n            operation.onInit();\n        }\n        return this;\n    }\n    public ModelRenderer getRenderer(){\n        return mRenderer;\n    }\n    public List<Component> getComponents() {\n        if(mComponents == null){\n            mComponents = new ArrayList<>();\n        }\n        return mComponents;\n    }\n    public Model getModel(){\n        return mModel;\n    }\n    public android.view.View getView() {\n        return mView;\n    }\n    public List<IFormOperation> getOperations(){\n        if(mOperations == null){\n            mOperations = new ArrayList<>();\n        }\n        return mOperations;\n    }\n    public Component getComponent(PropertyInfo property){\n        for (Component comp: getComponents()) {\n            if(comp.getPropertyInfo().equals(property)) {\n                return comp;\n            }\n        }\n        return null;\n    }\n"]], "pred": {"ppl": 1.739768385887146, "ppl_lower": 1.83651602268219, "ppl/lowercase_ppl": -1.0977302451465536, "ppl/zlib": 0.0010216826435557127, "Min_5.0% Prob": 5.9253137199967, "Min_10.0% Prob": 4.163902896421927, "Min_20.0% Prob": 2.5701132613584536, "Min_30.0% Prob": 1.7989966500459649, "Min_40.0% Prob": 1.3719138365460042, "Min_50.0% Prob": 1.1040566588146952, "Min_60.0% Prob": 0.922146931211365}}
{"hexsha": "1dcc93e57dd3ea03203449b76f920367d8a89df2", "ext": "java", "lang": "Java", "content": "public class FocusToggleCukes {\n\n\t\n\t WebDriver d;\n\t WebDriverWait wait;\t\n\tpublic FocusToggleCukes()\n\t{\n\t\td = webdriver.openApp();\n\t\twebdriver.trainerLogin();\n\t    //d.manage().timeouts().implicitlyWait(20,TimeUnit.SECONDS);\n\t\twait= new WebDriverWait(d, 10);\n\t\twait.until(elementToBeClickable(By.xpath(\"//li[@name='focus']\")));\n\t   d.findElement(By.xpath(\"//li[@name='focus']\")).click();\n\t}\n\t\n\t@Given(\"^I \\\"([^\\\"]*)\\\" on the focus toggle$\")\n\tpublic void i_on_the_focus_toggle(String arg1) throws Throwable {\n\t\t d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);\n\t\t wait.until(elementToBeClickable(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")));\n\t\t\td.findElement(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")).click(); \n\t\t\t\n\t\t\tString n = d.findElement(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")).getText();\n\t\t\tif(n.equals(\"keyboard_arrow_down\"))\n\t\t\t{\n\t\t\t\tassertEquals(true,true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassertEquals(false, true);\n\t\t\t}\n\t}\n\n\t@Then(\"^a list of focus \\\"([^\\\"]*)\\\" should not be displayed$\")\n\tpublic void a_list_of_focus_should_not_be_displayed(String arg1) throws Throwable {\n\t\t\n\t\td.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);\n\t\twait.until(elementToBeClickable(By.xpath(\"//*[@id=\\\"focus\\\"]\")));\n\t\tString display = d.findElement(By.xpath(\"//*[@id=\\\"focus\\\"]\")).getCssValue(\"display\");\n\t\t//System.out.println(display);\n\t\tif(display.equals(\"block\"))\n\t\t{\n\t\t\tassertEquals(true, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassertEquals(false, true);\n\t\t}\n\t    //throw new PendingException();\n\t    \n\t\td.close();\n\t    }\n\t}", "class_id": 0, "repo": "Bryanv6/TG_pro", "file": "src/test/java/com/gator/tests/FocusToggleCukes.java", "last_update_at": "2018-05-05T10:36:47+00:00", "question_id": "1dcc93e57dd3ea03203449b76f920367d8a89df2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FocusToggleCukes {\n\t\n\t WebDriver d;\n\t WebDriverWait wait;\t\n\tpublic FocusToggleCukes()\n\t{\n\t\td = webdriver.openApp();\n\t\twebdriver.trainerLogin();\n\t    //d.manage().timeouts().implicitlyWait(20,TimeUnit.SECONDS);\n\t\twait= new WebDriverWait(d, 10);\n\t\twait.until(elementToBeClickable(By.xpath(\"//li[@name='focus']\")));\n\t   d.findElement(By.xpath(\"//li[@name='focus']\")).click();\n\t}\n\t\n\t@Given(\"^I \\\"([^\\\"]*)\\\" on the focus toggle$\")\n\tpublic void i_on_the_focus_toggle(String arg1) throws Throwable {\n\t\t d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);\n\t\t wait.until(elementToBeClickable(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")));\n\t\t\td.findElement(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")).click(); \n\t\t\t\n\t\t\tString n = d.findElement(By.xpath(\"//*[@id=\\\"focusArrow\\\"]\")).getText();\n\t\t\tif(n.equals(\"keyboard_arrow_down\"))\n\t\t\t{\n\t\t\t\tassertEquals(true,true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassertEquals(false, true);\n\t\t\t}\n\t}\n\t@Then(\"^a list of focus \\\"([^\\\"]*)\\\" should not be displayed$\")\n\tpublic void a_list_of_focus_should_not_be_displayed(String arg1) throws Throwable {\n\t\t\n\t\td.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);\n\t\twait.until(elementToBeClickable(By.xpath(\"//*[@id=\\\"focus\\\"]\")));\n\t\tString display = d.findElement(By.xpath(\"//*[@id=\\\"focus\\\"]\")).getCssValue(\"display\");\n\t\t//System.out.println(display);\n\t\tif(display.equals(\"block\"))\n\t\t{\n\t\t\tassertEquals(true, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassertEquals(false, true);\n\t\t}\n\t    //throw new PendingException();\n\t    \n\t\td.close();\n\t    }\n"]], "pred": {"ppl": 1.958565354347229, "ppl_lower": 2.2243950366973877, "ppl/lowercase_ppl": -1.1893341621857265, "ppl/zlib": 0.001114779839402419, "Min_5.0% Prob": 6.699388288682507, "Min_10.0% Prob": 4.95142989197085, "Min_20.0% Prob": 3.0945755065448823, "Min_30.0% Prob": 2.1786405154934494, "Min_40.0% Prob": 1.661102321990315, "Min_50.0% Prob": 1.3378023741105871, "Min_60.0% Prob": 1.118329821780364}}
{"hexsha": "dbd24dbac8536631b57f49df1a29798f80be97ac", "ext": "java", "lang": "Java", "content": "public class Conversation {\n  private final UUID id;\n  private final UUID owner;\n  private final Instant creation;\n  private final String title;\n  private List<UUID> conversationUsers = new ArrayList<>();\n  private boolean isPublic = true;\n  /**\n   * Constructs a new Conversation.\n   *\n   * @param id the ID of this Conversation\n   * @param owner the ID of the User who created this Conversation\n   * @param title the title of this Conversation\n   * @param creation the creation time of this Conversation\n   */\n  public Conversation(UUID id, UUID owner, String title, Instant creation) {\n    this.id = id;\n    this.owner = owner;\n    this.creation = creation;\n    this.title = title;\n    this.conversationUsers.add(owner);\n  }\n\n  /**\n   * Constructs a new Conversation.\n   *\n   * @param id the ID of this Conversation\n   * @param owner the ID of the User who created this Conversation\n   * @param title the title of this Conversation\n   * @param creation the creation time of this Conversation\n   * @param isPublic whether this Conversation is public\n   */\n  public Conversation(UUID id, UUID owner, String title, Instant creation, boolean isPublic) {\n    this.id = id;\n    this.owner = owner;\n    this.creation = creation;\n    this.title = title;\n    this.isPublic = isPublic;\n    this.conversationUsers.add(owner);\n  }\n\n  /** Returns the ID of this Conversation. */\n  public UUID getId() {\n    return id;\n  }\n\n  /** Returns the ID of the User who created this Conversation. */\n  public UUID getOwnerId() {\n    return owner;\n  }\n\n  /** Returns the title of this Conversation. */\n  public String getTitle() {\n    return title;\n  }\n\n  /** Returns the creation time of this Conversation. */\n  public Instant getCreationTime() {\n    return creation;\n  }\n\n  /** Returns the set of users in this Conversation. */\n  public List<UUID> getConversationUsers() {\n    return conversationUsers;\n  }\n\n  /**\n   * Returns the set of users in this Conversation as a list of strings indicating the UUID of each\n   * user. For use in persistentDataStore\n   */\n  public List<String> getUserIdsAsStrings() {\n    List<String> ids = new ArrayList<>();\n    for (UUID user : conversationUsers) {\n      ids.add(user.toString());\n    }\n    return ids;\n  }\n\n  /** Adds a user to a conversation */\n  public void addUser(UUID user) {\n    conversationUsers.add(user);\n    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);\n  }\n\n  /** Removes a user from a conversation */\n  public void removeUser(UUID user) {\n    conversationUsers.remove(user);\n    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);\n  }\n\n  /** Updates the list of users from a list of user Ids */\n  public void setUsers(List<String> users) {\n    List<UUID> newUsers = new ArrayList<>();\n    for (String userId : users) {\n      UUID id = UUID.fromString(userId);\n      newUsers.add(id);\n    }\n    conversationUsers = newUsers;\n  }\n\n  /** Returns true if conversation is public, false, otherwise */\n  public boolean getIsPublic() {\n    return isPublic;\n  }\n\n  /** Sets the privacy status of a conversation */\n  public void setIsPublic(boolean isPublic) {\n    this.isPublic = isPublic;\n  }\n\n  /** Returns true if user has permission to access a conversation, false if otherwise */\n  public boolean hasPermission(UUID user) {\n    if (isPublic) {\n      return true;\n    }\n    return conversationUsers.contains(user);\n  }\n\n  public String getCreationTimeFormatted() {\n    LocalDateTime ldt = LocalDateTime.ofInstant(creation, ZoneId.systemDefault());\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM/dd/yy h:mm:ss a\");\n    return ldt.format(formatter);\n  }\n}", "class_id": 0, "repo": "codeu-2018-team12/codeu-2018-team12", "file": "src/main/java/codeu/model/data/Conversation.java", "last_update_at": "2018-03-20T01:02:09+00:00", "question_id": "dbd24dbac8536631b57f49df1a29798f80be97ac", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Conversation {\n  private final UUID id;\n  private final UUID owner;\n  private final Instant creation;\n  private final String title;\n  private List<UUID> conversationUsers = new ArrayList<>();\n  private boolean isPublic = true;\n  /**\n   * Constructs a new Conversation.\n   *\n   * @param id the ID of this Conversation\n   * @param owner the ID of the User who created this Conversation\n   * @param title the title of this Conversation\n   * @param creation the creation time of this Conversation\n   */\n  public Conversation(UUID id, UUID owner, String title, Instant creation) {\n    this.id = id;\n    this.owner = owner;\n    this.creation = creation;\n    this.title = title;\n    this.conversationUsers.add(owner);\n  }\n  /**\n   * Constructs a new Conversation.\n   *\n   * @param id the ID of this Conversation\n   * @param owner the ID of the User who created this Conversation\n   * @param title the title of this Conversation\n   * @param creation the creation time of this Conversation\n   * @param isPublic whether this Conversation is public\n   */\n  public Conversation(UUID id, UUID owner, String title, Instant creation, boolean isPublic) {\n    this.id = id;\n    this.owner = owner;\n    this.creation = creation;\n    this.title = title;\n    this.isPublic = isPublic;\n    this.conversationUsers.add(owner);\n  }\n  /** Returns the ID of this Conversation. */\n  public UUID getId() {\n    return id;\n  }\n  /** Returns the ID of the User who created this Conversation. */\n  public UUID getOwnerId() {\n    return owner;\n  }\n  /** Returns the title of this Conversation. */\n  public String getTitle() {\n    return title;\n  }\n  /** Returns the creation time of this Conversation. */\n  public Instant getCreationTime() {\n    return creation;\n  }\n  /** Returns the set of users in this Conversation. */\n  public List<UUID> getConversationUsers() {\n    return conversationUsers;\n  }\n  /**\n   * Returns the set of users in this Conversation as a list of strings indicating the UUID of each\n   * user. For use in persistentDataStore\n   */\n  public List<String> getUserIdsAsStrings() {\n    List<String> ids = new ArrayList<>();\n    for (UUID user : conversationUsers) {\n      ids.add(user.toString());\n    }\n    return ids;\n  }\n  /** Adds a user to a conversation */\n  public void addUser(UUID user) {\n    conversationUsers.add(user);\n    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);\n  }\n  /** Removes a user from a conversation */\n  public void removeUser(UUID user) {\n    conversationUsers.remove(user);\n    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);\n  }\n  /** Updates the list of users from a list of user Ids */\n  public void setUsers(List<String> users) {\n    List<UUID> newUsers = new ArrayList<>();\n    for (String userId : users) {\n      UUID id = UUID.fromString(userId);\n      newUsers.add(id);\n    }\n    conversationUsers = newUsers;\n  }\n  /** Returns true if conversation is public, false, otherwise */\n  public boolean getIsPublic() {\n    return isPublic;\n  }\n  /** Sets the privacy status of a conversation */\n  public void setIsPublic(boolean isPublic) {\n    this.isPublic = isPublic;\n  }\n  /** Returns true if user has permission to access a conversation, false if otherwise */\n  public boolean hasPermission(UUID user) {\n    if (isPublic) {\n      return true;\n    }\n    return conversationUsers.contains(user);\n  }\n  public String getCreationTimeFormatted() {\n    LocalDateTime ldt = LocalDateTime.ofInstant(creation, ZoneId.systemDefault());\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM/dd/yy h:mm:ss a\");\n    return ldt.format(formatter);\n  }\n"]], "pred": {"ppl": 1.4355133771896362, "ppl_lower": 1.576831340789795, "ppl/lowercase_ppl": -1.2597204966763937, "ppl/zlib": 0.000393815402365959, "Min_5.0% Prob": 4.392456017288507, "Min_10.0% Prob": 2.980455740994098, "Min_20.0% Prob": 1.7446684153640972, "Min_30.0% Prob": 1.1968208120685386, "Min_40.0% Prob": 0.9013764508533084, "Min_50.0% Prob": 0.722907933868548, "Min_60.0% Prob": 0.6030571780489988}}
{"hexsha": "e1dfd23ecc72161944ba9c049b05834e1fac4040", "ext": "java", "lang": "Java", "content": "@Tag(\"group4\")\npublic class ListIT extends AuthorBaseUITest {\n    private static String searchValue = \"Victor Sullivan\";\n    private static String tag1 = \"ellie\";\n    private static String tag2 = \"joel\";\n    private static String description = \"This is a child page\";\n\n    private String compPath;\n    private String parentPath;\n    private String testPage;\n    private String page1Path;\n    private String page2Path;\n    private String page21Path;\n    private String page22Path;\n    private String page3Path;\n    private String page4Path;\n    private String page5Path;\n    private EditorPage editorPage;\n    private List list;\n    private String tag1Path;\n    private String tag2Path;\n\n    protected String textRT;\n    protected String listRT;\n\n    protected void setComponentResources() {\n        textRT = Commons.RT_TEXT_V1;\n        listRT = Commons.RT_LIST_V1;\n    }\n\n\n    protected void setup() throws ClientException {\n        // add 2 tags\n        tag1Path = Commons.addTag(adminClient, tag1);\n        tag2Path = Commons.addTag(adminClient, tag2);\n        // create a separate parent page\n        parentPath = authorClient.createPage(\"parent_page\", \"parent_page\", rootPage, defaultPageTemplate).getSlingPath();\n        // add page 1\n        page1Path = authorClient.createPage(\"page_1\", \"page_1\", parentPath, defaultPageTemplate).getSlingPath();\n        // set tag on the page\n        String[] tags = new String[]{tag1};\n        Commons.setTagsToPage(authorClient, page1Path, tags, 200);\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:description\", description);\n        Commons.editNodeProperties(authorClient, page1Path + \"/jcr:content\", data);\n        // add page 2\n        page2Path = authorClient.createPage(\"page_2\", \"page_2\", parentPath, defaultPageTemplate).getSlingPath();\n        // add a text component\n        String text1Path = Commons.addComponentWithRetry(authorClient, textRT, page2Path + Commons.relParentCompPath, \"text\");\n        //set some text in the text component\n        data.clear();\n        data.put(\"text\", searchValue);\n        Commons.editNodeProperties(authorClient, text1Path, data);\n        // create subpage for page 2\n        page21Path = authorClient.createPage(\"sub_2_1\", \"sub_2_1\", page2Path, defaultPageTemplate).getSlingPath();\n        // create second sub page for page 2\n        page22Path = authorClient.createPage(\"sub_2_2\", \"sub_2_2\", page2Path, defaultPageTemplate).getSlingPath();\n        // add page 3\n        page3Path = authorClient.createPage(\"page_3\", \"page_3\", parentPath, defaultPageTemplate).getSlingPath();\n        // set 2 tags on the page\n        tags = new String[]{tag1, tag2};\n        Commons.setTagsToPage(authorClient, page3Path, tags, 200);\n        // create page 4\n        page4Path = authorClient.createPage(\"page_4\", \"page_4\", parentPath, defaultPageTemplate).getSlingPath();\n        // create a sub page for page 4\n        String page41Path = authorClient.createPage(\"sub_4_1\", \"sub_4_1\", page4Path, defaultPageTemplate).getSlingPath();\n        // add a text component\n        String text2Path = Commons.addComponentWithRetry(authorClient, textRT, page41Path + Commons.relParentCompPath, \"text\");\n        //set some text in the text component\n        data.clear();\n        data.put(\"text\", searchValue);\n        Commons.editNodeProperties(authorClient, text2Path, data);\n        // create page 5\n        page5Path = authorClient.createPage(\"page_5\", \"page_5\", parentPath, defaultPageTemplate).getSlingPath();\n        // set tag on the page\n        tags = new String[]{tag2};\n        Commons.setTagsToPage(authorClient, page5Path, tags, 200);\n\n        // create the test page containing the list component, store page path in 'testPagePath'\n        testPage = authorClient.createPage(\"testPage\", \"Test Page Title\", rootPage, defaultPageTemplate).getSlingPath();\n\n        // add the component to test page\n        compPath = Commons.addComponentWithRetry(authorClient, listRT, testPage + Commons.relParentCompPath, \"list\");\n\n        // open test page in page editor\n        editorPage = new PageEditorPage(testPage);\n        editorPage.open();\n\n        list = new List();\n    }\n\n    /**\n     * Before Test Case\n     */\n    @BeforeEach\n    public void setupBeforeEach() throws ClientException {\n        setComponentResources();\n        setup();\n    }\n\n    /**\n     * After Test Case\n     */\n    @AfterEach\n    public void cleanupAfterEach() throws ClientException, InterruptedException {\n        authorClient.deletePageWithRetry(parentPath, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);\n        authorClient.deletePageWithRetry(testPage, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);\n        adminClient.deletePath(\"/content/cq:tags/default/\" + tag1Path, HttpStatus.SC_OK);\n        adminClient.deletePath(\"/content/cq:tags/default/\" + tag2Path, HttpStatus.SC_OK);\n    }\n\n    /**\n     * Test: Build a list using direct child pages\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using direct child pages\")\n    public void testCreateListDirectChildren() throws ClientException, TimeoutException, InterruptedException {\n        // create 3 direct sub pages\n        String subpage1Path = authorClient.createPage(\"direct_1\", \"direct_1\", testPage, defaultPageTemplate).getSlingPath();\n        String subpage2Path = authorClient.createPage(\"direct_2\", \"direct_2\", testPage, defaultPageTemplate).getSlingPath();\n        String subpage3Path = authorClient.createPage(\"direct_2\", \"direct_3\", testPage, defaultPageTemplate).getSlingPath();\n\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // default setting is to build list using 'child pages', empty 'parent page' and 'child depth' = 1,\n        // so we only need to save\n        Commons.saveConfigureDialog();\n\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"direct_1\"), \"direct_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"direct_2\"), \"direct_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"direct_3\"), \"direct_3 should be present in list\");\n    }\n\n    /**\n     * Test: Build a list using child pages from a different location\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using child pages from a different location\")\n    public void testCreateListChildren() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // set parent page\n        list.getEditDialog().setParentPage(parentPath);\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n\n    /**\n     * Test: Build a list using child pages and sub child pages\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using child pages and sub child pages\")\n    public void testListSubChildren() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_4_1\"), \"sub_4_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n\n    /**\n     * Test: Build a fixed list\n     */\n    @Test\n    @DisplayName(\"Test: Build a fixed list\")\n    public void testCreateFixedList() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // select Fixed List\n        editDialog.selectFromList(\"static\");\n\n        // add items\n        editDialog.addFixedListOptions(page1Path);\n        editDialog.addFixedListOptions(page21Path);\n        editDialog.addFixedListOptions(page4Path);\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n    }\n\n    /**\n     * Test: Build a list using search\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using search\")\n    public void testCreateListBySearch() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n\n        // set the content path\n        editDialog.selectFromList(\"search\");\n        // set the search query\n        editDialog.enterSearchQuery(searchValue);\n        // set search location\n        editDialog.setSearchLocation(parentPath);\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_4_1\"), \"sub_4_1 should be present in list\");\n    }\n\n    /**\n     * Test: Build a list matching any tags defined\n     */\n    @Test\n    @DisplayName(\"Test: Build a list matching any tags defined\")\n    public void testCreateListAnyTagsMatching() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set the content path\n        editDialog.selectFromList(\"tags\");\n        // set parent page\n        editDialog.setTageSearchRoot(parentPath);\n        // search for 2 tags\n        editDialog.selectInTags(\"default/\" + tag1);\n        editDialog.selectInTags(\"default/\" + tag2);\n\n        // set the content path\n        editDialog.setTagsMatch(\"any\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n\n    /**\n     * Test: Build a list matching all tags defined\n     */\n    @Test\n    @DisplayName(\"Test: Build a list matching all tags defined\")\n    public void testCreateListAllTagsMatching() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set the content path\n        editDialog.selectFromList(\"tags\");\n        // set parent page\n        editDialog.setTageSearchRoot(parentPath);\n        // search for 2 tags\n        editDialog.selectInTags(\"default/\" + tag1);\n        editDialog.selectInTags(\"default/\" + tag2);\n\n        // set the content path\n        editDialog.setTagsMatch(\"all\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n    }\n\n    /**\n     * Test: order list by title\n     */\n    @Test\n    @DisplayName(\"Test: order list by title\")\n    public void testOrderByTitle() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n\n        // set order by title\n        editDialog.setOrderBy(\"title\");\n\n        // set sort order to ascending\n        editDialog.setSortOrder(\"asc\");\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if they are listed in the right order\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInListAtPosition(0, \"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(1, \"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(2, \"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(3, \"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(4, \"page_5\"), \"page_5 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(5, \"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(6, \"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(7, \"sub_4_1\"), \"sub_4_1 should be present in list\");\n    }\n\n    /**\n     * Test: change ordering of a list to descending\n     */\n    @Test\n    @DisplayName(\"Test: change ordering of a list to descending\")\n    public void testChangeOrderingTitle() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n\n        // set order by title\n        editDialog.setOrderBy(\"title\");\n\n        // set sort order to ascending\n        editDialog.setSortOrder(\"desc\");\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // check if they are listed in the right order\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInListAtPosition(0, \"sub_4_1\"), \"sub_4_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(1, \"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(2, \"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(3, \"page_5\"), \"page_5 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(4, \"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(5, \"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(6, \"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(7, \"page_1\"), \"page_1 should be present in list\");\n    }\n\n    /**\n     * Test: set max item\n     */\n    @Test\n    @DisplayName(\"Test: set max item\")\n    public void testSetMaxItems() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // by default there should be 8\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.getListLength() == 8, \"By default there should be 8 items\");\n        Commons.switchToDefaultContext();\n\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // set max Items to 4\n        editDialog.setMaxItems(\"4\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        // now it should only render 4 entries\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.getListLength() == 4, \"After setting max items tp 4 there should be 4 items\");\n        Commons.switchToDefaultContext();\n    }\n\n    /**\n     * Test: order list by last modified date\n     */\n    @Test\n    @DisplayName(\"Test: order list by last modified date\")\n    public void testOrderByLastModifiedDate() throws ClientException, TimeoutException, InterruptedException {\n        // modify page 5\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:title\", \"Modified Page 5\");\n        Commons.editNodeProperties(authorClient, page5Path + \"/jcr:content\", data);\n\n        // modify page 1\n        data.put(\"jcr:title\", \"Modified Page 1\");\n        Commons.editNodeProperties(authorClient, page1Path + \"/jcr:content\", data);\n\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n\n        // set order by modified\n        editDialog.setOrderBy(\"modified\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"asc\");\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        Commons.switchContext(\"ContentFrame\");\n        // page 5 should be at 7th place\n        assertTrue(list.isPagePresentInListAtPosition(6, \"Modified Page 5\"), \"page 5 should be at 7th place\");\n        // page 1 should be at 8th place\n        assertTrue(list.isPagePresentInListAtPosition(7, \"Modified Page 1\"), \"page 1 should be at 7th place\");\n    }\n\n    /**\n     * Test: order list by last modified date\n     */\n    @Test\n    @DisplayName(\"Test: order list by last modified date\")\n    public void testChangeOrderingDate() throws ClientException, TimeoutException, InterruptedException {\n        // modify page 3\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:title\", \"Modified Page 3\");\n        Commons.editNodeProperties(authorClient, page3Path + \"/jcr:content\", data);\n\n        // modify page 2\n        data.put(\"jcr:title\", \"Modified Page 2\");\n        Commons.editNodeProperties(authorClient, page2Path + \"/jcr:content\", data);\n\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n\n        // set order by modified\n        editDialog.setOrderBy(\"modified\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"desc\");\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        Commons.switchContext(\"ContentFrame\");\n        // page 5 should be at 7th place\n        assertTrue(list.isPagePresentInListAtPosition(0, \"Modified Page 2\"), \"page 2 should be at 7th place\");\n        // page 1 should be at 8th place\n        assertTrue(list.isPagePresentInListAtPosition(1, \"Modified Page 3\"), \"page 3 should be at 7th place\");\n    }\n\n    /**\n     * Test: item settings - link items option\n     */\n    @Test\n    @DisplayName(\"Test: item settings - link items option\")\n        public void testLinkItemsForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickLinkItems();\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPageLinkPresent(\"page_1\"),\"Page link should be present\");\n    }\n\n    /**\n     * Test: item settings - show description\n     */\n    @Test\n    @DisplayName(\"Test: item settings - show description\")\n    public void testShowDescriptionForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickShowDescription();\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentWithDescription(\"This is a child page\"),\"Page should be present with description This is a child page\");\n    }\n\n    /**\n     * Test: item settings - show date\n     */\n    @Test\n    @DisplayName(\"Test: item settings - show date\")\n    public void testShowDateForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickShowModificationDate();\n\n        // close the dialog\n        Commons.saveConfigureDialog();\n\n        Commons.switchContext(\"ContentFrame\");\n\n        Date date = new Date(System.currentTimeMillis());\n        SimpleDateFormat sdf;\n        sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n        String text = sdf.format(date);\n        String currentDate = text.substring(0, 10);\n        assertTrue(list.isPagePresentWithDate(currentDate),\"Page should be present with date \" + currentDate);\n    }\n\n}", "class_id": 0, "repo": "leonso/aem-core-wcm-components", "file": "testing/it/e2e-selenium/src/test/java/com/adobe/cq/wcm/core/components/it/seljup/tests/list/v1/ListIT.java", "last_update_at": "2018-10-23T17:12:01+00:00", "question_id": "e1dfd23ecc72161944ba9c049b05834e1fac4040", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Tag(\"group4\")\npublic class ListIT extends AuthorBaseUITest {\n    private static String searchValue = \"Victor Sullivan\";\n    private static String tag1 = \"ellie\";\n    private static String tag2 = \"joel\";\n    private static String description = \"This is a child page\";\n    private String compPath;\n    private String parentPath;\n    private String testPage;\n    private String page1Path;\n    private String page2Path;\n    private String page21Path;\n    private String page22Path;\n    private String page3Path;\n    private String page4Path;\n    private String page5Path;\n    private EditorPage editorPage;\n    private List list;\n    private String tag1Path;\n    private String tag2Path;\n    protected String textRT;\n    protected String listRT;\n    protected void setComponentResources() {\n        textRT = Commons.RT_TEXT_V1;\n        listRT = Commons.RT_LIST_V1;\n    }\n    protected void setup() throws ClientException {\n        // add 2 tags\n        tag1Path = Commons.addTag(adminClient, tag1);\n        tag2Path = Commons.addTag(adminClient, tag2);\n        // create a separate parent page\n        parentPath = authorClient.createPage(\"parent_page\", \"parent_page\", rootPage, defaultPageTemplate).getSlingPath();\n        // add page 1\n        page1Path = authorClient.createPage(\"page_1\", \"page_1\", parentPath, defaultPageTemplate).getSlingPath();\n        // set tag on the page\n        String[] tags = new String[]{tag1};\n        Commons.setTagsToPage(authorClient, page1Path, tags, 200);\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:description\", description);\n        Commons.editNodeProperties(authorClient, page1Path + \"/jcr:content\", data);\n        // add page 2\n        page2Path = authorClient.createPage(\"page_2\", \"page_2\", parentPath, defaultPageTemplate).getSlingPath();\n        // add a text component\n        String text1Path = Commons.addComponentWithRetry(authorClient, textRT, page2Path + Commons.relParentCompPath, \"text\");\n        //set some text in the text component\n        data.clear();\n        data.put(\"text\", searchValue);\n        Commons.editNodeProperties(authorClient, text1Path, data);\n        // create subpage for page 2\n        page21Path = authorClient.createPage(\"sub_2_1\", \"sub_2_1\", page2Path, defaultPageTemplate).getSlingPath();\n        // create second sub page for page 2\n        page22Path = authorClient.createPage(\"sub_2_2\", \"sub_2_2\", page2Path, defaultPageTemplate).getSlingPath();\n        // add page 3\n        page3Path = authorClient.createPage(\"page_3\", \"page_3\", parentPath, defaultPageTemplate).getSlingPath();\n        // set 2 tags on the page\n        tags = new String[]{tag1, tag2};\n        Commons.setTagsToPage(authorClient, page3Path, tags, 200);\n        // create page 4\n        page4Path = authorClient.createPage(\"page_4\", \"page_4\", parentPath, defaultPageTemplate).getSlingPath();\n        // create a sub page for page 4\n        String page41Path = authorClient.createPage(\"sub_4_1\", \"sub_4_1\", page4Path, defaultPageTemplate).getSlingPath();\n        // add a text component\n        String text2Path = Commons.addComponentWithRetry(authorClient, textRT, page41Path + Commons.relParentCompPath, \"text\");\n        //set some text in the text component\n        data.clear();\n        data.put(\"text\", searchValue);\n        Commons.editNodeProperties(authorClient, text2Path, data);\n        // create page 5\n        page5Path = authorClient.createPage(\"page_5\", \"page_5\", parentPath, defaultPageTemplate).getSlingPath();\n        // set tag on the page\n        tags = new String[]{tag2};\n        Commons.setTagsToPage(authorClient, page5Path, tags, 200);\n        // create the test page containing the list component, store page path in 'testPagePath'\n        testPage = authorClient.createPage(\"testPage\", \"Test Page Title\", rootPage, defaultPageTemplate).getSlingPath();\n        // add the component to test page\n        compPath = Commons.addComponentWithRetry(authorClient, listRT, testPage + Commons.relParentCompPath, \"list\");\n        // open test page in page editor\n        editorPage = new PageEditorPage(testPage);\n        editorPage.open();\n        list = new List();\n    }\n    /**\n     * Before Test Case\n     */\n    @BeforeEach\n    public void setupBeforeEach() throws ClientException {\n        setComponentResources();\n        setup();\n    }\n    /**\n     * After Test Case\n     */\n    @AfterEach\n    public void cleanupAfterEach() throws ClientException, InterruptedException {\n        authorClient.deletePageWithRetry(parentPath, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);\n        authorClient.deletePageWithRetry(testPage, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);\n        adminClient.deletePath(\"/content/cq:tags/default/\" + tag1Path, HttpStatus.SC_OK);\n        adminClient.deletePath(\"/content/cq:tags/default/\" + tag2Path, HttpStatus.SC_OK);\n    }\n    /**\n     * Test: Build a list using direct child pages\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using direct child pages\")\n    public void testCreateListDirectChildren() throws ClientException, TimeoutException, InterruptedException {\n        // create 3 direct sub pages\n        String subpage1Path = authorClient.createPage(\"direct_1\", \"direct_1\", testPage, defaultPageTemplate).getSlingPath();\n        String subpage2Path = authorClient.createPage(\"direct_2\", \"direct_2\", testPage, defaultPageTemplate).getSlingPath();\n        String subpage3Path = authorClient.createPage(\"direct_2\", \"direct_3\", testPage, defaultPageTemplate).getSlingPath();\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // default setting is to build list using 'child pages', empty 'parent page' and 'child depth' = 1,\n        // so we only need to save\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"direct_1\"), \"direct_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"direct_2\"), \"direct_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"direct_3\"), \"direct_3 should be present in list\");\n    }\n    /**\n     * Test: Build a list using child pages from a different location\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using child pages from a different location\")\n    public void testCreateListChildren() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // set parent page\n        list.getEditDialog().setParentPage(parentPath);\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n    /**\n     * Test: Build a list using child pages and sub child pages\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using child pages and sub child pages\")\n    public void testListSubChildren() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_4_1\"), \"sub_4_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n    /**\n     * Test: Build a fixed list\n     */\n    @Test\n    @DisplayName(\"Test: Build a fixed list\")\n    public void testCreateFixedList() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // select Fixed List\n        editDialog.selectFromList(\"static\");\n        // add items\n        editDialog.addFixedListOptions(page1Path);\n        editDialog.addFixedListOptions(page21Path);\n        editDialog.addFixedListOptions(page4Path);\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_4\"), \"page_4 should be present in list\");\n    }\n    /**\n     * Test: Build a list using search\n     */\n    @Test\n    @DisplayName(\"Test: Build a list using search\")\n    public void testCreateListBySearch() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set the content path\n        editDialog.selectFromList(\"search\");\n        // set the search query\n        editDialog.enterSearchQuery(searchValue);\n        // set search location\n        editDialog.setSearchLocation(parentPath);\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"sub_4_1\"), \"sub_4_1 should be present in list\");\n    }\n    /**\n     * Test: Build a list matching any tags defined\n     */\n    @Test\n    @DisplayName(\"Test: Build a list matching any tags defined\")\n    public void testCreateListAnyTagsMatching() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set the content path\n        editDialog.selectFromList(\"tags\");\n        // set parent page\n        editDialog.setTageSearchRoot(parentPath);\n        // search for 2 tags\n        editDialog.selectInTags(\"default/\" + tag1);\n        editDialog.selectInTags(\"default/\" + tag2);\n        // set the content path\n        editDialog.setTagsMatch(\"any\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInList(\"page_5\"), \"page_5 should be present in list\");\n    }\n    /**\n     * Test: Build a list matching all tags defined\n     */\n    @Test\n    @DisplayName(\"Test: Build a list matching all tags defined\")\n    public void testCreateListAllTagsMatching() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set the content path\n        editDialog.selectFromList(\"tags\");\n        // set parent page\n        editDialog.setTageSearchRoot(parentPath);\n        // search for 2 tags\n        editDialog.selectInTags(\"default/\" + tag1);\n        editDialog.selectInTags(\"default/\" + tag2);\n        // set the content path\n        editDialog.setTagsMatch(\"all\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if the correct pages are listed\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInList(\"page_3\"), \"page_3 should be present in list\");\n    }\n    /**\n     * Test: order list by title\n     */\n    @Test\n    @DisplayName(\"Test: order list by title\")\n    public void testOrderByTitle() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // set order by title\n        editDialog.setOrderBy(\"title\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"asc\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if they are listed in the right order\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInListAtPosition(0, \"page_1\"), \"page_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(1, \"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(2, \"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(3, \"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(4, \"page_5\"), \"page_5 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(5, \"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(6, \"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(7, \"sub_4_1\"), \"sub_4_1 should be present in list\");\n    }\n    /**\n     * Test: change ordering of a list to descending\n     */\n    @Test\n    @DisplayName(\"Test: change ordering of a list to descending\")\n    public void testChangeOrderingTitle() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // set order by title\n        editDialog.setOrderBy(\"title\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"desc\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // check if they are listed in the right order\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentInListAtPosition(0, \"sub_4_1\"), \"sub_4_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(1, \"sub_2_2\"), \"sub_2_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(2, \"sub_2_1\"), \"sub_2_1 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(3, \"page_5\"), \"page_5 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(4, \"page_4\"), \"page_4 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(5, \"page_3\"), \"page_3 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(6, \"page_2\"), \"page_2 should be present in list\");\n        assertTrue(list.isPagePresentInListAtPosition(7, \"page_1\"), \"page_1 should be present in list\");\n    }\n    /**\n     * Test: set max item\n     */\n    @Test\n    @DisplayName(\"Test: set max item\")\n    public void testSetMaxItems() throws TimeoutException, InterruptedException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // by default there should be 8\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.getListLength() == 8, \"By default there should be 8 items\");\n        Commons.switchToDefaultContext();\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        // set max Items to 4\n        editDialog.setMaxItems(\"4\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        // now it should only render 4 entries\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.getListLength() == 4, \"After setting max items tp 4 there should be 4 items\");\n        Commons.switchToDefaultContext();\n    }\n    /**\n     * Test: order list by last modified date\n     */\n    @Test\n    @DisplayName(\"Test: order list by last modified date\")\n    public void testOrderByLastModifiedDate() throws ClientException, TimeoutException, InterruptedException {\n        // modify page 5\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:title\", \"Modified Page 5\");\n        Commons.editNodeProperties(authorClient, page5Path + \"/jcr:content\", data);\n        // modify page 1\n        data.put(\"jcr:title\", \"Modified Page 1\");\n        Commons.editNodeProperties(authorClient, page1Path + \"/jcr:content\", data);\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // set order by modified\n        editDialog.setOrderBy(\"modified\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"asc\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        // page 5 should be at 7th place\n        assertTrue(list.isPagePresentInListAtPosition(6, \"Modified Page 5\"), \"page 5 should be at 7th place\");\n        // page 1 should be at 8th place\n        assertTrue(list.isPagePresentInListAtPosition(7, \"Modified Page 1\"), \"page 1 should be at 7th place\");\n    }\n    /**\n     * Test: order list by last modified date\n     */\n    @Test\n    @DisplayName(\"Test: order list by last modified date\")\n    public void testChangeOrderingDate() throws ClientException, TimeoutException, InterruptedException {\n        // modify page 3\n        HashMap<String, String> data = new HashMap<String, String>();\n        data.put(\"jcr:title\", \"Modified Page 3\");\n        Commons.editNodeProperties(authorClient, page3Path + \"/jcr:content\", data);\n        // modify page 2\n        data.put(\"jcr:title\", \"Modified Page 2\");\n        Commons.editNodeProperties(authorClient, page2Path + \"/jcr:content\", data);\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        // set depth to 2\n        editDialog.setChildDepth(\"2\");\n        // set order by modified\n        editDialog.setOrderBy(\"modified\");\n        // set sort order to ascending\n        editDialog.setSortOrder(\"desc\");\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        // page 5 should be at 7th place\n        assertTrue(list.isPagePresentInListAtPosition(0, \"Modified Page 2\"), \"page 2 should be at 7th place\");\n        // page 1 should be at 8th place\n        assertTrue(list.isPagePresentInListAtPosition(1, \"Modified Page 3\"), \"page 3 should be at 7th place\");\n    }\n    /**\n     * Test: item settings - link items option\n     */\n    @Test\n    @DisplayName(\"Test: item settings - link items option\")\n        public void testLinkItemsForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickLinkItems();\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPageLinkPresent(\"page_1\"),\"Page link should be present\");\n    }\n    /**\n     * Test: item settings - show description\n     */\n    @Test\n    @DisplayName(\"Test: item settings - show description\")\n    public void testShowDescriptionForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickShowDescription();\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        assertTrue(list.isPagePresentWithDescription(\"This is a child page\"),\"Page should be present with description This is a child page\");\n    }\n    /**\n     * Test: item settings - show date\n     */\n    @Test\n    @DisplayName(\"Test: item settings - show date\")\n    public void testShowDateForList() throws InterruptedException, TimeoutException {\n        // open the configuration dialog\n        Commons.openEditDialog(editorPage, compPath);\n        ListEditDialog editDialog = list.getEditDialog();\n        // set parent page\n        editDialog.setParentPage(parentPath);\n        editDialog.openSettings();\n        editDialog.clickShowModificationDate();\n        // close the dialog\n        Commons.saveConfigureDialog();\n        Commons.switchContext(\"ContentFrame\");\n        Date date = new Date(System.currentTimeMillis());\n        SimpleDateFormat sdf;\n        sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n        String text = sdf.format(date);\n        String currentDate = text.substring(0, 10);\n        assertTrue(list.isPagePresentWithDate(currentDate),\"Page should be present with date \" + currentDate);\n    }\n"]], "pred": {"ppl": 1.8641971349716187, "ppl_lower": 2.1048381328582764, "ppl/lowercase_ppl": -1.1949296057089924, "ppl/zlib": 0.00020977786115737462, "Min_5.0% Prob": 6.4943208974950455, "Min_10.0% Prob": 4.743289019547257, "Min_20.0% Prob": 2.912627177057313, "Min_30.0% Prob": 2.0408187115601466, "Min_40.0% Prob": 1.5482371943504127, "Min_50.0% Prob": 1.2446364431847945, "Min_60.0% Prob": 1.0388612100067525}}
{"hexsha": "c9965fc4b74521dda997c28eaf29be70ec2c3249", "ext": "java", "lang": "Java", "content": "public class ServletOutputStreamWrapper extends ServletOutputStream {\n\n    private static Logger logger = LoggerFactory.getLogger(ServletOutputStreamWrapper.class);\n\n    private ByteArrayOutputStream fBuffer;\n    private boolean writtenTo;\n\n    public ServletOutputStreamWrapper() {\n        fBuffer = new ByteArrayOutputStream();\n        writtenTo = false;\n    }\n\n    /**\n     * Override func, catching the data written to it.\n     */\n    @Override\n    public void write(int aByte) {\n\n        if (aByte > 127) {\n            logger.warn(\"Writing suspicious byte \" + aByte);\n        }\n\n        fBuffer.write(aByte);\n\n        if (!writtenTo) {\n            writtenTo = true;\n        }\n    }\n\n    /**\n     * toString() method returns whatever is written to this stream as a string.\n     */\n    @Override\n    public String toString() {\n        return new String(fBuffer.toByteArray(), Charset.defaultCharset());\n    }\n\n    /**\n     * Function indicates if this outputstream has been written to.\n     *\n     * @return\n     */\n    public boolean isWrittenTo() {\n        return writtenTo;\n    }\n}", "class_id": 0, "repo": "RaimondKempees/dd4t-2-java", "file": "dd4t-example-site/src/main/java/org/dd4t/springmvc/view/model/ServletOutputStreamWrapper.java", "last_update_at": "2018-04-08T09:31:21+00:00", "question_id": "c9965fc4b74521dda997c28eaf29be70ec2c3249", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ServletOutputStreamWrapper extends ServletOutputStream {\n    private static Logger logger = LoggerFactory.getLogger(ServletOutputStreamWrapper.class);\n    private ByteArrayOutputStream fBuffer;\n    private boolean writtenTo;\n    public ServletOutputStreamWrapper() {\n        fBuffer = new ByteArrayOutputStream();\n        writtenTo = false;\n    }\n    /**\n     * Override func, catching the data written to it.\n     */\n    @Override\n    public void write(int aByte) {\n        if (aByte > 127) {\n            logger.warn(\"Writing suspicious byte \" + aByte);\n        }\n        fBuffer.write(aByte);\n        if (!writtenTo) {\n            writtenTo = true;\n        }\n    }\n    /**\n     * toString() method returns whatever is written to this stream as a string.\n     */\n    @Override\n    public String toString() {\n        return new String(fBuffer.toByteArray(), Charset.defaultCharset());\n    }\n    /**\n     * Function indicates if this outputstream has been written to.\n     *\n     * @return\n     */\n    public boolean isWrittenTo() {\n        return writtenTo;\n    }\n"]], "pred": {"ppl": 2.1748063564300537, "ppl_lower": 2.5021605491638184, "ppl/lowercase_ppl": -1.1804708422937715, "ppl/zlib": 0.0017738347695221317, "Min_5.0% Prob": 7.197571379797799, "Min_10.0% Prob": 4.989162091551156, "Min_20.0% Prob": 3.380692389504663, "Min_30.0% Prob": 2.4845192846895636, "Min_40.0% Prob": 1.9300066072108417, "Min_50.0% Prob": 1.5479943953097275, "Min_60.0% Prob": 1.294820021523961}}
{"hexsha": "635ba8819067695663e2ee8f115041f3ded041ae", "ext": "java", "lang": "Java", "content": "public class LuceneBooleanIndex extends BaseLuceneTest {\n\n  @Override\n  protected String getDatabaseName() {\n    return \"booleanTest\";\n  }\n\n  @BeforeClass\n  public void init() {\n    initDB();\n    OSchema schema = databaseDocumentTx.getMetadata().getSchema();\n    OClass v = schema.getClass(\"V\");\n    OClass song = schema.createClass(\"Person\");\n    song.setSuperClass(v);\n    song.createProperty(\"isDeleted\", OType.BOOLEAN);\n\n    databaseDocumentTx.command(new OCommandSQL(\"create index Person.isDeleted on Person (isDeleted) FULLTEXT ENGINE LUCENE\"))\n        .execute();\n\n  }\n\n  @AfterClass\n  public void deInit() {\n    deInitDB();\n  }\n\n  public void insertPerson() {\n\n    for (int i = 0; i < 1000; i++) {\n      ODocument doc = new ODocument(\"Person\");\n      doc.field(\"isDeleted\", i % 2 == 0);\n      databaseDocumentTx.save(doc);\n    }\n\n    List<ODocument> docs = databaseDocumentTx\n        .query(new OSQLSynchQuery<ODocument>(\"select from Person where isDeleted lucene false\"));\n\n    Assert.assertEquals(500, docs.size());\n    Assert.assertEquals(false, docs.get(0).field(\"isDeleted\"));\n    docs = databaseDocumentTx.query(new OSQLSynchQuery<ODocument>(\"select from Person where isDeleted lucene true\"));\n\n    Assert.assertEquals(500, docs.size());\n    Assert.assertEquals(true, docs.get(0).field(\"isDeleted\"));\n  }\n}", "class_id": 0, "repo": "nathanmbrown/orientdb", "file": "lucene/src/test/java/com/orientechnologies/lucene/test/LuceneBooleanIndex.java", "last_update_at": "2018-08-15T12:08:29+00:00", "question_id": "635ba8819067695663e2ee8f115041f3ded041ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LuceneBooleanIndex extends BaseLuceneTest {\n  @Override\n  protected String getDatabaseName() {\n    return \"booleanTest\";\n  }\n  @BeforeClass\n  public void init() {\n    initDB();\n    OSchema schema = databaseDocumentTx.getMetadata().getSchema();\n    OClass v = schema.getClass(\"V\");\n    OClass song = schema.createClass(\"Person\");\n    song.setSuperClass(v);\n    song.createProperty(\"isDeleted\", OType.BOOLEAN);\n    databaseDocumentTx.command(new OCommandSQL(\"create index Person.isDeleted on Person (isDeleted) FULLTEXT ENGINE LUCENE\"))\n        .execute();\n  }\n  @AfterClass\n  public void deInit() {\n    deInitDB();\n  }\n  public void insertPerson() {\n    for (int i = 0; i < 1000; i++) {\n      ODocument doc = new ODocument(\"Person\");\n      doc.field(\"isDeleted\", i % 2 == 0);\n      databaseDocumentTx.save(doc);\n    }\n    List<ODocument> docs = databaseDocumentTx\n        .query(new OSQLSynchQuery<ODocument>(\"select from Person where isDeleted lucene false\"));\n    Assert.assertEquals(500, docs.size());\n    Assert.assertEquals(false, docs.get(0).field(\"isDeleted\"));\n    docs = databaseDocumentTx.query(new OSQLSynchQuery<ODocument>(\"select from Person where isDeleted lucene true\"));\n    Assert.assertEquals(500, docs.size());\n    Assert.assertEquals(true, docs.get(0).field(\"isDeleted\"));\n  }\n"]], "pred": {"ppl": 1.54070246219635, "ppl_lower": 2.4202892780303955, "ppl/lowercase_ppl": -2.0449061292124946, "ppl/zlib": 0.0007844618089050887, "Min_5.0% Prob": 4.9332117807297475, "Min_10.0% Prob": 3.3981713312012807, "Min_20.0% Prob": 2.0591324539745557, "Min_30.0% Prob": 1.4175673309364356, "Min_40.0% Prob": 1.0805090749417157, "Min_50.0% Prob": 0.8654110287687798, "Min_60.0% Prob": 0.7207106280475273}}
{"hexsha": "3fcb9272c622fcada129c1cbcd8a90c413009d5b", "ext": "java", "lang": "Java", "content": "public class ExampleDeviceAccess {\r\n\t/*\r\n\t * Maximum number or RO requests that can be executed simultaneously to each device. Other threads should wait\r\n\t * their turn to request device data.\r\n\t */\r\n\tprivate static final int MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE = 30;\r\n\r\n\t/* Maximum number or requests that can be executed simultaneously by server. */\r\n\tprivate static final int MAX_SIMULTANEOUS_FOR_ALL_DEVICES = 600;\r\n\r\n\tACheckpoint cp = CheckpointBuilder.newInst()\r\n\t\t\t.setName(\"Device access\")\r\n\t\t\t.setMaxPassesPerResource(MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE)\r\n\t\t\t.setReentrant(false)\r\n\t\t\t.setFair(true)\r\n\t\t\t.setGlobalPassesLimit(MAX_SIMULTANEOUS_FOR_ALL_DEVICES)\r\n\t\t\t.build();\r\n\r\n\tpublic String readDeviceData(InetAddress device) {\r\n\t\tString deviceData;\r\n\t\t\r\n\t\ttry (Pass p = cp.getPassUninterruptibly(device)) {\r\n\t\t\t// read device data here \r\n\t\t\t// there are no writing threads for current device and no more then\r\n\t\t\t// MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE threads are reading current device\r\n\t\t\t\r\n\t\t\tdeviceData = \"\";\r\n\t\t}\r\n\t\t\r\n\t\treturn deviceData;\r\n\t}\r\n\r\n\tpublic boolean writeDeviceData(InetAddress device, String deviceData) {\r\n\t\t\r\n\t\ttry (Pass p = cp.getPassRWUninterruptibly(device)) {\r\n\t\t\t// write device data here \r\n\t\t\t// there is no other reading or writing threads for current device \r\n\t\t\t// when current thread received access here \r\n\t\t\t// but there might be other RW threads in this section which access other devices\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}", "class_id": 0, "repo": "Zur13/Checkpoint", "file": "src/test/zur13/checkpoint/test/ExampleDeviceAccess.java", "last_update_at": "2018-04-08T08:43:24+00:00", "question_id": "3fcb9272c622fcada129c1cbcd8a90c413009d5b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ExampleDeviceAccess {\r\n\t/*\r\n\t * Maximum number or RO requests that can be executed simultaneously to each device. Other threads should wait\r\n\t * their turn to request device data.\r\n\t */\r\n\tprivate static final int MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE = 30;\r\n\r\n\t/* Maximum number or requests that can be executed simultaneously by server. */\r\n\tprivate static final int MAX_SIMULTANEOUS_FOR_ALL_DEVICES = 600;\r\n\r\n\tACheckpoint cp = CheckpointBuilder.newInst()\r\n\t\t\t.setName(\"Device access\")\r\n\t\t\t.setMaxPassesPerResource(MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE)\r\n\t\t\t.setReentrant(false)\r\n\t\t\t.setFair(true)\r\n\t\t\t.setGlobalPassesLimit(MAX_SIMULTANEOUS_FOR_ALL_DEVICES)\r\n\t\t\t.build();\r\n\r\n\tpublic String readDeviceData(InetAddress device) {\r\n\t\tString deviceData;\r\n\t\t\r\n\t\ttry (Pass p = cp.getPassUninterruptibly(device)) {\r\n\t\t\t// read device data here \r\n\t\t\t// there are no writing threads for current device and no more then\r\n\t\t\t// MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE threads are reading current device\r\n\t\t\t\r\n\t\t\tdeviceData = \"\";\r\n\t\t}\r\n\t\t\r\n\t\treturn deviceData;\r\n\t}\r\n\r\n\tpublic boolean writeDeviceData(InetAddress device, String deviceData) {\r\n\t\t\r\n\t\ttry (Pass p = cp.getPassRWUninterruptibly(device)) {\r\n\t\t\t// write device data here \r\n\t\t\t// there is no other reading or writing threads for current device \r\n\t\t\t// when current thread received access here \r\n\t\t\t// but there might be other RW threads in this section which access other devices\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n"]], "pred": {"ppl": 3.0048437118530273, "ppl_lower": 3.566166400909424, "ppl/lowercase_ppl": -1.1556641028156944, "ppl/zlib": 0.001774557350432135, "Min_5.0% Prob": 8.31457139968872, "Min_10.0% Prob": 6.475447093739229, "Min_20.0% Prob": 4.661517154936697, "Min_30.0% Prob": 3.5007517263780232, "Min_40.0% Prob": 2.7194607230085954, "Min_50.0% Prob": 2.1907856838661246, "Min_60.0% Prob": 1.8328168928890158}}
{"hexsha": "add96ab720577cacf59b9a069aaabd5e041415b4", "ext": "java", "lang": "Java", "content": "public class UtilsPreferences {\n\n    private static final String TOKEN = \"token\";\n    private static final String USUARIO = \"usuario\";\n    private static final String LOGIN = \"login\";\n    private static final String LOGIN_TIME = \"loginTime\";\n    private static final String CONFIG = \"config\";\n    private static final String COBRADO = \"cobrado\";\n    private static final String MACIMPRESORA = \"macImpresora\";\n\n    private static Calendar cal;\n\n    private static Context mContext;\n\n    private static Calendar getCalendar() {\n        if (cal == null) {\n            cal = new GregorianCalendar();\n        }\n        return cal;\n    }\n\n    public static void setContext(final Context context) {\n        mContext = context;\n    }\n\n    public static void saveToken(final String token) {\n        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        editor.putString(TOKEN, token);\n        editor.commit();\n    }\n\n    public static String loadToken() {\n        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);\n        return settings.getString(TOKEN, \"\");\n    }\n\n    public static void saveLogedUser(Usuario usuario) {\n        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(USUARIO, objectMapper.writeValueAsString(usuario));\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n\n    public static Usuario loadLogedUser() {\n        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return objectMapper.readValue(settings.getString(USUARIO, \"\"), Usuario.class);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void saveLogin(Login.Request request) {\n        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(LOGIN, objectMapper.writeValueAsString(request));\n            editor.putLong(LOGIN_TIME, System.currentTimeMillis());\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n\n    public static Login.Request loadLogin() {\n        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            Login.Request req = objectMapper.readValue(settings.getString(LOGIN, \"\"), Login.Request.class);\n            long lastLoginTime = settings.getLong(LOGIN_TIME, 0);\n            long actualTime = System.currentTimeMillis();\n            if ((actualTime - lastLoginTime) > (1000 * 60 * 60)){ // si ya paso una hora, regresar null\n                return null;\n            }else{\n                return req;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void saveConfigs(Config config) {\n        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(CONFIG, objectMapper.writeValueAsString(config));\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n\n    public static Config loadConfig() {\n        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return objectMapper.readValue(settings.getString(CONFIG, \"\"), Config.class);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * almacena un prestamo como cobrado el dia actual\n     *\n     * @param id identificador del prestamo cobrado\n     */\n    public static void setPrestamoCobradoHoy(int id) {\n        //cobrado.{dia del a\u00f1o}\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n\n        String prestamosCobrados = settings.getString(key, \"\");\n        if (prestamosCobrados == \"\") {\n            prestamosCobrados += String.valueOf(id);\n        } else {\n            prestamosCobrados += \",\" + id;\n        }\n        SharedPreferences.Editor editor = settings.edit();\n        editor.putString(key, prestamosCobrados);\n        editor.commit();\n    }\n\n    /**\n     * consulta si un prestmo fue cobrado ya el dia de hoy o no\n     *\n     * @param id identificador del prestamo\n     * @return true si el prestamo fue cobrado, false si el prestamo fue cobrado\n     */\n    public static boolean prestamoCobradoHoy(Integer id) {\n        //cobrado.{dia del a\u00f1o}\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n        String prestamosCobrados = settings.getString(key, \"\");\n        return prestamosCobrados.contains(String.valueOf(id));\n    }\n\n    /**\n     * consulta los prestmos que fueron cobrados hoy, separados por comas\n     *\n     * @return string con los ids de los prestmaos separados por comas ej: \"1,65,35,15\"\n     */\n    public static String prestmosCobradosHoy() {\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n        return settings.getString(key, \"\");\n    }\n\n\n    /**\n     * Metodo para guardar en preferencias la mac address de la impresora seleccionada para poder\n     * imprimir los tickets.\n     *\n     * @param macAddress\n     */\n    public static void saveMacPrinter(String macAddress) {\n        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        try {\n            editor.putString(MACIMPRESORA, macAddress);\n            editor.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Metodo para consultar la mac address guardada anteriormente para la impresion del ticket.\n     *\n     * @return\n     */\n    public static String loadMacPrinter() {\n        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return settings.getString(MACIMPRESORA, \"\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}", "class_id": 0, "repo": "Cdca12/easymoney", "file": "Movil/app/src/main/java/com/easymoney/utils/UtilsPreferences.java", "last_update_at": "2018-07-16T15:17:48+00:00", "question_id": "add96ab720577cacf59b9a069aaabd5e041415b4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UtilsPreferences {\n    private static final String TOKEN = \"token\";\n    private static final String USUARIO = \"usuario\";\n    private static final String LOGIN = \"login\";\n    private static final String LOGIN_TIME = \"loginTime\";\n    private static final String CONFIG = \"config\";\n    private static final String COBRADO = \"cobrado\";\n    private static final String MACIMPRESORA = \"macImpresora\";\n    private static Calendar cal;\n    private static Context mContext;\n    private static Calendar getCalendar() {\n        if (cal == null) {\n            cal = new GregorianCalendar();\n        }\n        return cal;\n    }\n    public static void setContext(final Context context) {\n        mContext = context;\n    }\n    public static void saveToken(final String token) {\n        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        editor.putString(TOKEN, token);\n        editor.commit();\n    }\n    public static String loadToken() {\n        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);\n        return settings.getString(TOKEN, \"\");\n    }\n    public static void saveLogedUser(Usuario usuario) {\n        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(USUARIO, objectMapper.writeValueAsString(usuario));\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n    public static Usuario loadLogedUser() {\n        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return objectMapper.readValue(settings.getString(USUARIO, \"\"), Usuario.class);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public static void saveLogin(Login.Request request) {\n        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(LOGIN, objectMapper.writeValueAsString(request));\n            editor.putLong(LOGIN_TIME, System.currentTimeMillis());\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n    public static Login.Request loadLogin() {\n        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            Login.Request req = objectMapper.readValue(settings.getString(LOGIN, \"\"), Login.Request.class);\n            long lastLoginTime = settings.getLong(LOGIN_TIME, 0);\n            long actualTime = System.currentTimeMillis();\n            if ((actualTime - lastLoginTime) > (1000 * 60 * 60)){ // si ya paso una hora, regresar null\n                return null;\n            }else{\n                return req;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public static void saveConfigs(Config config) {\n        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            editor.putString(CONFIG, objectMapper.writeValueAsString(config));\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        editor.commit();\n    }\n    public static Config loadConfig() {\n        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return objectMapper.readValue(settings.getString(CONFIG, \"\"), Config.class);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    /**\n     * almacena un prestamo como cobrado el dia actual\n     *\n     * @param id identificador del prestamo cobrado\n     */\n    public static void setPrestamoCobradoHoy(int id) {\n        //cobrado.{dia del a\u00f1o}\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n        String prestamosCobrados = settings.getString(key, \"\");\n        if (prestamosCobrados == \"\") {\n            prestamosCobrados += String.valueOf(id);\n        } else {\n            prestamosCobrados += \",\" + id;\n        }\n        SharedPreferences.Editor editor = settings.edit();\n        editor.putString(key, prestamosCobrados);\n        editor.commit();\n    }\n    /**\n     * consulta si un prestmo fue cobrado ya el dia de hoy o no\n     *\n     * @param id identificador del prestamo\n     * @return true si el prestamo fue cobrado, false si el prestamo fue cobrado\n     */\n    public static boolean prestamoCobradoHoy(Integer id) {\n        //cobrado.{dia del a\u00f1o}\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n        String prestamosCobrados = settings.getString(key, \"\");\n        return prestamosCobrados.contains(String.valueOf(id));\n    }\n    /**\n     * consulta los prestmos que fueron cobrados hoy, separados por comas\n     *\n     * @return string con los ids de los prestmaos separados por comas ej: \"1,65,35,15\"\n     */\n    public static String prestmosCobradosHoy() {\n        String key = COBRADO + \".\" + getCalendar().get(Calendar.DAY_OF_YEAR);\n        SharedPreferences settings = mContext.getSharedPreferences(key, 0);\n        return settings.getString(key, \"\");\n    }\n    /**\n     * Metodo para guardar en preferencias la mac address de la impresora seleccionada para poder\n     * imprimir los tickets.\n     *\n     * @param macAddress\n     */\n    public static void saveMacPrinter(String macAddress) {\n        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        try {\n            editor.putString(MACIMPRESORA, macAddress);\n            editor.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     * Metodo para consultar la mac address guardada anteriormente para la impresion del ticket.\n     *\n     * @return\n     */\n    public static String loadMacPrinter() {\n        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            return settings.getString(MACIMPRESORA, \"\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n"]], "pred": {"ppl": 1.3484233617782593, "ppl_lower": 1.4609416723251343, "ppl/lowercase_ppl": -1.2681014367175967, "ppl/zlib": 0.00021646345386140965, "Min_5.0% Prob": 4.428634814187592, "Min_10.0% Prob": 2.73642275613897, "Min_20.0% Prob": 1.4734056616640265, "Min_30.0% Prob": 0.9939127135291403, "Min_40.0% Prob": 0.7463540146047646, "Min_50.0% Prob": 0.5981051374455538, "Min_60.0% Prob": 0.4987834799722548}}
{"hexsha": "b5a40d6269c865608889f42ae2f5245e048f80b4", "ext": "java", "lang": "Java", "content": "public class TestIdUtils {\n\n    private TestIdUtils() {\n        // hide default constructor for this util class\n    }\n\n    /**\n     * Get issue or test case ID.\n     *\n     * @param iMethod the {@link IMethodInstance} to check for test ID annotations.\n     * @return Optional of either the {@link TestCaseId} or {@link Issue} value.\n     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}\n     *                               are specified inconstantly.\n     */\n    public static Optional<String> getIssueOrTestCaseIdValue(IMethodInstance iMethod) {\n        Method method = iMethod.getMethod().getConstructorOrMethod().getMethod();\n        return getIssueOrTestCaseIdValue(method);\n    }\n\n    /**\n     * Get issue or test case ID for a method.\n     *\n     * @param method the method to check for test ID annotations.\n     * @return Optional of the {@link TestCaseId} or {@link Issue} value.\n     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}\n     *                               are both specified inconstantly.\n     */\n    public static Optional<String> getIssueOrTestCaseIdValue(Method method) {\n        TestCaseId tcIdAnnotation = method.getAnnotation(TestCaseId.class);\n        Issue issueAnnotation = method.getAnnotation(Issue.class);\n\n        if (!isNull(issueAnnotation) && !isNull(tcIdAnnotation)\n                && !issueAnnotation.value().equals(tcIdAnnotation.value())) {\n            throw new IllegalStateException(\n                    \"TestCaseId and Issue annotation are both specified but \"\n                            + \"not equal for method: \" + method.toString());\n        }\n\n        if (!isNull(issueAnnotation)) {\n            return Optional.of(issueAnnotation.value());\n        } else if (!isNull(tcIdAnnotation)) {\n            return Optional.of(tcIdAnnotation.value());\n        } else {\n            return Optional.empty();\n        }\n    }\n}", "class_id": 0, "repo": "haim/frameworkium-core", "file": "src/main/java/com/frameworkium/core/common/reporting/TestIdUtils.java", "last_update_at": "2018-01-27T14:27:14+00:00", "question_id": "b5a40d6269c865608889f42ae2f5245e048f80b4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestIdUtils {\n    private TestIdUtils() {\n        // hide default constructor for this util class\n    }\n    /**\n     * Get issue or test case ID.\n     *\n     * @param iMethod the {@link IMethodInstance} to check for test ID annotations.\n     * @return Optional of either the {@link TestCaseId} or {@link Issue} value.\n     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}\n     *                               are specified inconstantly.\n     */\n    public static Optional<String> getIssueOrTestCaseIdValue(IMethodInstance iMethod) {\n        Method method = iMethod.getMethod().getConstructorOrMethod().getMethod();\n        return getIssueOrTestCaseIdValue(method);\n    }\n    /**\n     * Get issue or test case ID for a method.\n     *\n     * @param method the method to check for test ID annotations.\n     * @return Optional of the {@link TestCaseId} or {@link Issue} value.\n     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}\n     *                               are both specified inconstantly.\n     */\n    public static Optional<String> getIssueOrTestCaseIdValue(Method method) {\n        TestCaseId tcIdAnnotation = method.getAnnotation(TestCaseId.class);\n        Issue issueAnnotation = method.getAnnotation(Issue.class);\n        if (!isNull(issueAnnotation) && !isNull(tcIdAnnotation)\n                && !issueAnnotation.value().equals(tcIdAnnotation.value())) {\n            throw new IllegalStateException(\n                    \"TestCaseId and Issue annotation are both specified but \"\n                            + \"not equal for method: \" + method.toString());\n        }\n        if (!isNull(issueAnnotation)) {\n            return Optional.of(issueAnnotation.value());\n        } else if (!isNull(tcIdAnnotation)) {\n            return Optional.of(tcIdAnnotation.value());\n        } else {\n            return Optional.empty();\n        }\n    }\n"]], "pred": {"ppl": 1.8488765954971313, "ppl_lower": 2.143144369125366, "ppl/lowercase_ppl": -1.240320712434283, "ppl/zlib": 0.0011113529999361245, "Min_5.0% Prob": 6.31292998790741, "Min_10.0% Prob": 4.450056085781175, "Min_20.0% Prob": 2.857382376583255, "Min_30.0% Prob": 2.0094730318809044, "Min_40.0% Prob": 1.5286212559713392, "Min_50.0% Prob": 1.2292673052003493, "Min_60.0% Prob": 1.0258084093220532}}
{"hexsha": "16c909d80137b9bf5fcf8b3c5bebe56eb12d38ce", "ext": "java", "lang": "Java", "content": "public class MaxSubArraySumOneDeletion {\n\n    //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/\n\n    //Read : MaxSumSubArray for easy understanding : https://leetcode.com/submissions/detail/288875284/\n    public static void main( String[] args ) {\n\n        System.out.println(maximumSum(new int[]{1, -2, 0, 3}));\n    }\n\n    /*\n     arr = {1, -2, 0, 3}\n\n     consider two elements in array = {1, -2}, we have two options:\n\n     - We can delete and check : if we delete then we try add curr element with delete sum :\n                                 oneDelete + arr[i] or\n                                 by exclude curr element, by using noDelete sum :\n                                 nodelete\n\n     - We don't delete and check : if we don't delete we can include curr element with prev sum:\n                                   noDelete + arr[i] or\n                                   Just include the curr element : arr[i]\n     */\n    private static int maximumSum( int[] arr ) {\n        int n = arr.length;\n\n        int oneDelete = 0, noDelete = arr[0], max = arr[0];\n\n        //see carefully: we start the loop with 1 : that means by exclusion we can pick 1st element and delete the zero-th\n        for (int i = 1; i < n; i++) {\n\n            oneDelete = Math.max(oneDelete + arr[i], noDelete);\n\n            //https://leetcode.com/submissions/detail/288875284/\n            noDelete = Math.max(noDelete + arr[i], arr[i]); //same as MaximumSubArray DP problem\n\n            max = Math.max(max, Math.max(oneDelete, noDelete)); //just maintaining max of 2 states above\n        }\n\n        return max;\n    }\n}", "class_id": 0, "repo": "prdp89/interview", "file": "src/com/interview/codechef/ccdsap_2/leetcode/dp/newproblems/MaxSubArraySumOneDeletion.java", "last_update_at": "2018-03-29T07:45:26+00:00", "question_id": "16c909d80137b9bf5fcf8b3c5bebe56eb12d38ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MaxSubArraySumOneDeletion {\n    //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/\n    //Read : MaxSumSubArray for easy understanding : https://leetcode.com/submissions/detail/288875284/\n    public static void main( String[] args ) {\n        System.out.println(maximumSum(new int[]{1, -2, 0, 3}));\n    }\n    /*\n     arr = {1, -2, 0, 3}\n     consider two elements in array = {1, -2}, we have two options:\n     - We can delete and check : if we delete then we try add curr element with delete sum :\n                                 oneDelete + arr[i] or\n                                 by exclude curr element, by using noDelete sum :\n                                 nodelete\n     - We don't delete and check : if we don't delete we can include curr element with prev sum:\n                                   noDelete + arr[i] or\n                                   Just include the curr element : arr[i]\n     */\n    private static int maximumSum( int[] arr ) {\n        int n = arr.length;\n        int oneDelete = 0, noDelete = arr[0], max = arr[0];\n        //see carefully: we start the loop with 1 : that means by exclusion we can pick 1st element and delete the zero-th\n        for (int i = 1; i < n; i++) {\n            oneDelete = Math.max(oneDelete + arr[i], noDelete);\n            //https://leetcode.com/submissions/detail/288875284/\n            noDelete = Math.max(noDelete + arr[i], arr[i]); //same as MaximumSubArray DP problem\n            max = Math.max(max, Math.max(oneDelete, noDelete)); //just maintaining max of 2 states above\n        }\n        return max;\n    }\n"]], "pred": {"ppl": 3.7285971641540527, "ppl_lower": 4.048445701599121, "ppl/lowercase_ppl": -1.062537201480661, "ppl/zlib": 0.0019879638482070286, "Min_5.0% Prob": 7.950652003288269, "Min_10.0% Prob": 6.601860425910171, "Min_20.0% Prob": 4.887270037008792, "Min_30.0% Prob": 3.897972664054559, "Min_40.0% Prob": 3.1637271423729096, "Min_50.0% Prob": 2.600628604025257, "Min_60.0% Prob": 2.1868869128833417}}
{"hexsha": "9c94c97914fd129e2a3f06edd182837991cbfa89", "ext": "java", "lang": "Java", "content": "public class ResourceUtilTest extends BaseTest {\n\n\tprivate String CLASS_PATH_FILE_TEST_EXTENSION = \"txt\";\n\tprivate String CLASS_PATH_FILE_TEST = \"CLASS_PATH_FILE_TEST.\" + CLASS_PATH_FILE_TEST_EXTENSION;\n\n\t@Test\n\tpublic void testClassNames() throws ZipException, IOException {\n\t\tfinal String[] classPathClassNames = ResourceUtil.getClasspathClassNames();\n\t\tassertNotNull(classPathClassNames);\n\t\tassertTrue( classPathClassNames.length > 0 );\n\n\t\tfor (final String className : classPathClassNames) {\n\t\t\tSystem.out.println(\"Class found: \" + className);\n\t\t\tassertNotNull(className);\n\t\t}\n\n\t}\n\n\t@Test\n\tpublic void testClasspathFileNames() throws ZipException, IOException {\n\t\tfinal String[] classPathFileNames = ResourceUtil.getClasspathFileNames();\n\t\tassertNotNull(classPathFileNames);\n\t\tassertTrue( classPathFileNames.length > 0 );\n\n\t\tboolean foundTestFile = false;\n\t\tfor (final String fileName : classPathFileNames) {\n\t\t\tSystem.out.println(\"File found: \" + fileName);\n\t\t\tassertNotNull(fileName);\n\t\t\tif (fileName.contains(CLASS_PATH_FILE_TEST)) {\n\t\t\t\tfoundTestFile = true;\n\t\t\t}\n\t\t}\n\t\tassertTrue(foundTestFile);\n\t}\n\n\t@Test\n\tpublic void testClasspathFileNamesByExtension() throws ZipException, IOException {\n\t\tfinal String[] classPathFileNames = ResourceUtil.getClasspathFileNamesWithExtension(CLASS_PATH_FILE_TEST_EXTENSION);\n\t\tassertNotNull(classPathFileNames);\n\t\tassertTrue( classPathFileNames.length > 0 );\n\n\t\tboolean foundTestFile = false;\n\t\tfor (final String fileName : classPathFileNames) {\n\t\t\tSystem.out.println(\"File found: \" + fileName);\n\t\t\tassertNotNull(fileName);\n\t\t\tassertTrue(fileName.endsWith(CLASS_PATH_FILE_TEST_EXTENSION));\n\t\t\tif (fileName.contains(CLASS_PATH_FILE_TEST)) {\n\t\t\t\tfoundTestFile = true;\n\t\t\t}\n\t\t}\n\t\tassertTrue(foundTestFile);\n\t}\n}", "class_id": 0, "repo": "ufoscout/jpattern", "file": "jp-util/src/test/java/com/jpattern/util/ResourceUtilTest.java", "last_update_at": "2018-05-15T09:46:18+00:00", "question_id": "9c94c97914fd129e2a3f06edd182837991cbfa89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ResourceUtilTest extends BaseTest {\n\tprivate String CLASS_PATH_FILE_TEST_EXTENSION = \"txt\";\n\tprivate String CLASS_PATH_FILE_TEST = \"CLASS_PATH_FILE_TEST.\" + CLASS_PATH_FILE_TEST_EXTENSION;\n\t@Test\n\tpublic void testClassNames() throws ZipException, IOException {\n\t\tfinal String[] classPathClassNames = ResourceUtil.getClasspathClassNames();\n\t\tassertNotNull(classPathClassNames);\n\t\tassertTrue( classPathClassNames.length > 0 );\n\t\tfor (final String className : classPathClassNames) {\n\t\t\tSystem.out.println(\"Class found: \" + className);\n\t\t\tassertNotNull(className);\n\t\t}\n\t}\n\t@Test\n\tpublic void testClasspathFileNames() throws ZipException, IOException {\n\t\tfinal String[] classPathFileNames = ResourceUtil.getClasspathFileNames();\n\t\tassertNotNull(classPathFileNames);\n\t\tassertTrue( classPathFileNames.length > 0 );\n\t\tboolean foundTestFile = false;\n\t\tfor (final String fileName : classPathFileNames) {\n\t\t\tSystem.out.println(\"File found: \" + fileName);\n\t\t\tassertNotNull(fileName);\n\t\t\tif (fileName.contains(CLASS_PATH_FILE_TEST)) {\n\t\t\t\tfoundTestFile = true;\n\t\t\t}\n\t\t}\n\t\tassertTrue(foundTestFile);\n\t}\n\t@Test\n\tpublic void testClasspathFileNamesByExtension() throws ZipException, IOException {\n\t\tfinal String[] classPathFileNames = ResourceUtil.getClasspathFileNamesWithExtension(CLASS_PATH_FILE_TEST_EXTENSION);\n\t\tassertNotNull(classPathFileNames);\n\t\tassertTrue( classPathFileNames.length > 0 );\n\t\tboolean foundTestFile = false;\n\t\tfor (final String fileName : classPathFileNames) {\n\t\t\tSystem.out.println(\"File found: \" + fileName);\n\t\t\tassertNotNull(fileName);\n\t\t\tassertTrue(fileName.endsWith(CLASS_PATH_FILE_TEST_EXTENSION));\n\t\t\tif (fileName.contains(CLASS_PATH_FILE_TEST)) {\n\t\t\t\tfoundTestFile = true;\n\t\t\t}\n\t\t}\n\t\tassertTrue(foundTestFile);\n\t}\n"]], "pred": {"ppl": 1.4362342357635498, "ppl_lower": 1.5873825550079346, "ppl/lowercase_ppl": -1.2763953083416473, "ppl/zlib": 0.000824657344307321, "Min_5.0% Prob": 4.686759504778632, "Min_10.0% Prob": 3.058769596034083, "Min_20.0% Prob": 1.7351688653485389, "Min_30.0% Prob": 1.1962829588779382, "Min_40.0% Prob": 0.9016299977397116, "Min_50.0% Prob": 0.7244140155556013, "Min_60.0% Prob": 0.6031934641337452}}
{"hexsha": "fceff7407c9a52eacc1cc268626abc9557ccbc9b", "ext": "java", "lang": "Java", "content": "public class PreviewRunnerModule extends PrivateModule {\n  private final CConfiguration cConf;\n  private final AccessEnforcer accessEnforcer;\n  private final ContextAccessEnforcer contextAccessEnforcer;\n  private final ProgramRuntimeProviderLoader programRuntimeProviderLoader;\n  private final ArtifactRepositoryReaderProvider artifactRepositoryReaderProvider;\n  private final PluginFinderProvider pluginFinderProvider;\n  private final PreferencesFetcherProvider preferencesFetcherProvider;\n  private final MessagingService messagingService;\n\n  @Inject\n  PreviewRunnerModule(CConfiguration cConf,\n                      ArtifactRepositoryReaderProvider readerProvider,\n                      AccessEnforcer accessEnforcer,\n                      ContextAccessEnforcer contextAccessEnforcer,\n                      ProgramRuntimeProviderLoader programRuntimeProviderLoader,\n                      PluginFinderProvider pluginFinderProvider,\n                      PreferencesFetcherProvider preferencesFetcherProvider,\n                      MessagingService messagingService) {\n    this.cConf = cConf;\n    this.artifactRepositoryReaderProvider = readerProvider;\n    this.accessEnforcer = accessEnforcer;\n    this.contextAccessEnforcer = contextAccessEnforcer;\n    this.programRuntimeProviderLoader = programRuntimeProviderLoader;\n    this.pluginFinderProvider = pluginFinderProvider;\n    this.preferencesFetcherProvider = preferencesFetcherProvider;\n    this.messagingService = messagingService;\n  }\n\n  @Override\n  protected void configure() {\n    Boolean artifactLocalizerEnabled = cConf.getBoolean(Constants.Preview.ARTIFACT_LOCALIZER_ENABLED, false);\n\n    if (artifactLocalizerEnabled) {\n      // Use remote implementation to fetch artifact metadata from AppFab.\n      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.\n      bind(ArtifactRepositoryReader.class).to(RemoteArtifactRepositoryReaderWithLocalization.class);\n      bind(ArtifactRepository.class).to(RemoteArtifactRepositoryWithLocalization.class);\n      expose(ArtifactRepository.class);\n      bind(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))\n        .to(RemoteArtifactRepositoryWithLocalization.class)\n        .in(Scopes.SINGLETON);\n      expose(ArtifactRepository.class).annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));\n\n\n      // Use remote implementation to fetch plugin metadata from AppFab.\n      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.\n      bind(PluginFinder.class).to(RemoteWorkerPluginFinder.class);\n      expose(PluginFinder.class);\n\n      // Use remote implementation to fetch preferences from AppFab.\n      bind(PreferencesFetcher.class).to(RemotePreferencesFetcherInternal.class);\n      expose(PreferencesFetcher.class);\n    } else {\n      bind(ArtifactRepositoryReader.class).toProvider(artifactRepositoryReaderProvider);\n      bind(ArtifactRepository.class).to(DefaultArtifactRepository.class);\n      expose(ArtifactRepository.class);\n\n      bind(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))\n        .to(DefaultArtifactRepository.class)\n        .in(Scopes.SINGLETON);\n      expose(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));\n\n      bind(PluginFinder.class).toProvider(pluginFinderProvider);\n      expose(PluginFinder.class);\n\n      bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);\n      expose(PreferencesFetcher.class);\n    }\n\n    bind(MessagingService.class)\n      .annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS))\n      .toInstance(messagingService);\n    expose(MessagingService.class).annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS));\n\n    bind(AccessEnforcer.class).toInstance(accessEnforcer);\n    expose(AccessEnforcer.class);\n    bind(ContextAccessEnforcer.class).toInstance(contextAccessEnforcer);\n    expose(ContextAccessEnforcer.class);\n    // bind explore client to mock.\n    bind(ExploreClient.class).to(MockExploreClient.class);\n    expose(ExploreClient.class);\n    bind(ProgramRuntimeProviderLoader.class).toInstance(programRuntimeProviderLoader);\n    expose(ProgramRuntimeProviderLoader.class);\n    bind(StorageProviderNamespaceAdmin.class).to(LocalStorageProviderNamespaceAdmin.class);\n\n    bind(PipelineFactory.class).to(SynchronousPipelineFactory.class);\n\n    install(\n      new FactoryModuleBuilder()\n        .implement(Configurator.class, InMemoryConfigurator.class)\n        .build(ConfiguratorFactory.class)\n    );\n    // expose this binding so program runner modules can use\n    expose(ConfiguratorFactory.class);\n\n    bind(InMemoryProgramRunDispatcher.class).in(Scopes.SINGLETON);\n    expose(InMemoryProgramRunDispatcher.class);\n\n    install(\n      new FactoryModuleBuilder()\n        .implement(new TypeLiteral<Manager<AppDeploymentInfo, ApplicationWithPrograms>>() { },\n                   new TypeLiteral<PreviewApplicationManager<AppDeploymentInfo, ApplicationWithPrograms>>() { })\n        .build(new TypeLiteral<ManagerFactory<AppDeploymentInfo, ApplicationWithPrograms>>() { })\n    );\n\n    bind(Store.class).to(DefaultStore.class);\n    bind(SecretStore.class).to(DefaultSecretStore.class).in(Scopes.SINGLETON);\n\n    bind(UGIProvider.class).to(DefaultUGIProvider.class);\n    expose(UGIProvider.class);\n\n    bind(WorkflowStateWriter.class).to(BasicWorkflowStateWriter.class);\n    expose(WorkflowStateWriter.class);\n\n    // we don't delete namespaces in preview as we just delete preview directory when its done\n    bind(NamespaceResourceDeleter.class).to(NoopNamespaceResourceDeleter.class).in(Scopes.SINGLETON);\n    bind(NamespaceAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);\n    bind(NamespaceQueryAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);\n    expose(NamespaceAdmin.class);\n    expose(NamespaceQueryAdmin.class);\n\n    bind(MetadataAdmin.class).to(DefaultMetadataAdmin.class);\n    expose(MetadataAdmin.class);\n\n    bindPreviewRunner(binder());\n    expose(PreviewRunner.class);\n\n    bind(Scheduler.class).to(NoOpScheduler.class);\n\n    bind(DataTracerFactory.class).to(DefaultDataTracerFactory.class);\n    expose(DataTracerFactory.class);\n\n    bind(PreviewDataPublisher.class).to(MessagingPreviewDataPublisher.class);\n\n    bind(OwnerStore.class).to(DefaultOwnerStore.class);\n    expose(OwnerStore.class);\n    bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n    expose(OwnerAdmin.class);\n    \n    bind(CapabilityReader.class).to(CapabilityStatusStore.class);\n  }\n\n  /**\n   * Binds an implementation for {@link PreviewRunner}.\n   */\n  protected void bindPreviewRunner(Binder binder) {\n    binder.bind(PreviewRunner.class).to(DefaultPreviewRunner.class).in(Scopes.SINGLETON);\n  }\n}", "class_id": 0, "repo": "caskdata/cdap", "file": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewRunnerModule.java", "last_update_at": "2018-11-29T20:22:23+00:00", "question_id": "fceff7407c9a52eacc1cc268626abc9557ccbc9b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PreviewRunnerModule extends PrivateModule {\n  private final CConfiguration cConf;\n  private final AccessEnforcer accessEnforcer;\n  private final ContextAccessEnforcer contextAccessEnforcer;\n  private final ProgramRuntimeProviderLoader programRuntimeProviderLoader;\n  private final ArtifactRepositoryReaderProvider artifactRepositoryReaderProvider;\n  private final PluginFinderProvider pluginFinderProvider;\n  private final PreferencesFetcherProvider preferencesFetcherProvider;\n  private final MessagingService messagingService;\n  @Inject\n  PreviewRunnerModule(CConfiguration cConf,\n                      ArtifactRepositoryReaderProvider readerProvider,\n                      AccessEnforcer accessEnforcer,\n                      ContextAccessEnforcer contextAccessEnforcer,\n                      ProgramRuntimeProviderLoader programRuntimeProviderLoader,\n                      PluginFinderProvider pluginFinderProvider,\n                      PreferencesFetcherProvider preferencesFetcherProvider,\n                      MessagingService messagingService) {\n    this.cConf = cConf;\n    this.artifactRepositoryReaderProvider = readerProvider;\n    this.accessEnforcer = accessEnforcer;\n    this.contextAccessEnforcer = contextAccessEnforcer;\n    this.programRuntimeProviderLoader = programRuntimeProviderLoader;\n    this.pluginFinderProvider = pluginFinderProvider;\n    this.preferencesFetcherProvider = preferencesFetcherProvider;\n    this.messagingService = messagingService;\n  }\n  @Override\n  protected void configure() {\n    Boolean artifactLocalizerEnabled = cConf.getBoolean(Constants.Preview.ARTIFACT_LOCALIZER_ENABLED, false);\n    if (artifactLocalizerEnabled) {\n      // Use remote implementation to fetch artifact metadata from AppFab.\n      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.\n      bind(ArtifactRepositoryReader.class).to(RemoteArtifactRepositoryReaderWithLocalization.class);\n      bind(ArtifactRepository.class).to(RemoteArtifactRepositoryWithLocalization.class);\n      expose(ArtifactRepository.class);\n      bind(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))\n        .to(RemoteArtifactRepositoryWithLocalization.class)\n        .in(Scopes.SINGLETON);\n      expose(ArtifactRepository.class).annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));\n      // Use remote implementation to fetch plugin metadata from AppFab.\n      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.\n      bind(PluginFinder.class).to(RemoteWorkerPluginFinder.class);\n      expose(PluginFinder.class);\n      // Use remote implementation to fetch preferences from AppFab.\n      bind(PreferencesFetcher.class).to(RemotePreferencesFetcherInternal.class);\n      expose(PreferencesFetcher.class);\n    } else {\n      bind(ArtifactRepositoryReader.class).toProvider(artifactRepositoryReaderProvider);\n      bind(ArtifactRepository.class).to(DefaultArtifactRepository.class);\n      expose(ArtifactRepository.class);\n      bind(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))\n        .to(DefaultArtifactRepository.class)\n        .in(Scopes.SINGLETON);\n      expose(ArtifactRepository.class)\n        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));\n      bind(PluginFinder.class).toProvider(pluginFinderProvider);\n      expose(PluginFinder.class);\n      bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);\n      expose(PreferencesFetcher.class);\n    }\n    bind(MessagingService.class)\n      .annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS))\n      .toInstance(messagingService);\n    expose(MessagingService.class).annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS));\n    bind(AccessEnforcer.class).toInstance(accessEnforcer);\n    expose(AccessEnforcer.class);\n    bind(ContextAccessEnforcer.class).toInstance(contextAccessEnforcer);\n    expose(ContextAccessEnforcer.class);\n    // bind explore client to mock.\n    bind(ExploreClient.class).to(MockExploreClient.class);\n    expose(ExploreClient.class);\n    bind(ProgramRuntimeProviderLoader.class).toInstance(programRuntimeProviderLoader);\n    expose(ProgramRuntimeProviderLoader.class);\n    bind(StorageProviderNamespaceAdmin.class).to(LocalStorageProviderNamespaceAdmin.class);\n    bind(PipelineFactory.class).to(SynchronousPipelineFactory.class);\n    install(\n      new FactoryModuleBuilder()\n        .implement(Configurator.class, InMemoryConfigurator.class)\n        .build(ConfiguratorFactory.class)\n    );\n    // expose this binding so program runner modules can use\n    expose(ConfiguratorFactory.class);\n    bind(InMemoryProgramRunDispatcher.class).in(Scopes.SINGLETON);\n    expose(InMemoryProgramRunDispatcher.class);\n    install(\n      new FactoryModuleBuilder()\n        .implement(new TypeLiteral<Manager<AppDeploymentInfo, ApplicationWithPrograms>>() { },\n                   new TypeLiteral<PreviewApplicationManager<AppDeploymentInfo, ApplicationWithPrograms>>() { })\n        .build(new TypeLiteral<ManagerFactory<AppDeploymentInfo, ApplicationWithPrograms>>() { })\n    );\n    bind(Store.class).to(DefaultStore.class);\n    bind(SecretStore.class).to(DefaultSecretStore.class).in(Scopes.SINGLETON);\n    bind(UGIProvider.class).to(DefaultUGIProvider.class);\n    expose(UGIProvider.class);\n    bind(WorkflowStateWriter.class).to(BasicWorkflowStateWriter.class);\n    expose(WorkflowStateWriter.class);\n    // we don't delete namespaces in preview as we just delete preview directory when its done\n    bind(NamespaceResourceDeleter.class).to(NoopNamespaceResourceDeleter.class).in(Scopes.SINGLETON);\n    bind(NamespaceAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);\n    bind(NamespaceQueryAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);\n    expose(NamespaceAdmin.class);\n    expose(NamespaceQueryAdmin.class);\n    bind(MetadataAdmin.class).to(DefaultMetadataAdmin.class);\n    expose(MetadataAdmin.class);\n    bindPreviewRunner(binder());\n    expose(PreviewRunner.class);\n    bind(Scheduler.class).to(NoOpScheduler.class);\n    bind(DataTracerFactory.class).to(DefaultDataTracerFactory.class);\n    expose(DataTracerFactory.class);\n    bind(PreviewDataPublisher.class).to(MessagingPreviewDataPublisher.class);\n    bind(OwnerStore.class).to(DefaultOwnerStore.class);\n    expose(OwnerStore.class);\n    bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);\n    expose(OwnerAdmin.class);\n    bind(CapabilityReader.class).to(CapabilityStatusStore.class);\n  }\n  /**\n   * Binds an implementation for {@link PreviewRunner}.\n   */\n  protected void bindPreviewRunner(Binder binder) {\n    binder.bind(PreviewRunner.class).to(DefaultPreviewRunner.class).in(Scopes.SINGLETON);\n  }\n"]], "pred": {"ppl": 1.5390301942825317, "ppl_lower": 1.8507944345474243, "ppl/lowercase_ppl": -1.4278358771007404, "ppl/zlib": 0.0002935006630913095, "Min_5.0% Prob": 5.837745152267755, "Min_10.0% Prob": 3.8135348248715495, "Min_20.0% Prob": 2.1296193309712645, "Min_30.0% Prob": 1.436890853532389, "Min_40.0% Prob": 1.0775891456372744, "Min_50.0% Prob": 0.8629903226462967, "Min_60.0% Prob": 0.7194895545293886}}
{"hexsha": "7b6ffec8eaef91ed6bcbe4d02e50f38f3e713e21", "ext": "java", "lang": "Java", "content": "public class AdminServlet extends HttpServlet {\n\n// store classes giving access to users, conversations, and messages\n private UserStore userStore; \n  private ConversationStore conversationStore;\n  private MessageStore messageStore;\n\n @Override\n public void init() throws ServletException {\n   super.init();\n  setConversationStore(ConversationStore.getInstance());\n  setMessageStore(MessageStore.getInstance());\n  setUserStore(UserStore.getInstance());\n }\n\n\n  void setConversationStore(ConversationStore conversationStore) {\n    this.conversationStore = conversationStore;\n  }\n\n  void setMessageStore(MessageStore messageStore) {\n    this.messageStore = messageStore;\n  }\n\n  void setUserStore(UserStore userStore) {\n   this.userStore = userStore;\n }\n\n\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws IOException, ServletException {\n      HashMap<String, Object> stats = new HashMap<String, Object>();\n      stats.putAll(userStore.getUserStats());\n      stats.putAll(conversationStore.getConversationStats());\n      stats.putAll(messageStore.getMessageStats());\n      //UUID mostActiveID = (UUID) stats.get(\"Most Active User: \");\n      //User mostActiveUser = userStore.getUser(mostActiveID);\n      //stats.put(\"Most Active User: \", mostActiveUser.getName());\n      request.setAttribute(\"statistics\", stats);\n      request.getRequestDispatcher(\"/WEB-INF/view/admin.jsp\").forward(request, response);\n  }\n}", "class_id": 0, "repo": "camlloyd2/CodeU-Spring-2018", "file": "src/main/java/codeu/controller/AdminServlet.java", "last_update_at": "2018-05-05T01:27:44+00:00", "question_id": "7b6ffec8eaef91ed6bcbe4d02e50f38f3e713e21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AdminServlet extends HttpServlet {\n// store classes giving access to users, conversations, and messages\n private UserStore userStore; \n  private ConversationStore conversationStore;\n  private MessageStore messageStore;\n @Override\n public void init() throws ServletException {\n   super.init();\n  setConversationStore(ConversationStore.getInstance());\n  setMessageStore(MessageStore.getInstance());\n  setUserStore(UserStore.getInstance());\n }\n  void setConversationStore(ConversationStore conversationStore) {\n    this.conversationStore = conversationStore;\n  }\n  void setMessageStore(MessageStore messageStore) {\n    this.messageStore = messageStore;\n  }\n  void setUserStore(UserStore userStore) {\n   this.userStore = userStore;\n }\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws IOException, ServletException {\n      HashMap<String, Object> stats = new HashMap<String, Object>();\n      stats.putAll(userStore.getUserStats());\n      stats.putAll(conversationStore.getConversationStats());\n      stats.putAll(messageStore.getMessageStats());\n      //UUID mostActiveID = (UUID) stats.get(\"Most Active User: \");\n      //User mostActiveUser = userStore.getUser(mostActiveID);\n      //stats.put(\"Most Active User: \", mostActiveUser.getName());\n      request.setAttribute(\"statistics\", stats);\n      request.getRequestDispatcher(\"/WEB-INF/view/admin.jsp\").forward(request, response);\n  }\n"]], "pred": {"ppl": 1.764721155166626, "ppl_lower": 2.081829309463501, "ppl/lowercase_ppl": -1.2909443959789024, "ppl/zlib": 0.0010777849946165274, "Min_5.0% Prob": 6.860184744784706, "Min_10.0% Prob": 4.670724660922319, "Min_20.0% Prob": 2.716069684960903, "Min_30.0% Prob": 1.8614783143767943, "Min_40.0% Prob": 1.4100394994020462, "Min_50.0% Prob": 1.1326246566592884, "Min_60.0% Prob": 0.9457028628104072}}
{"hexsha": "4d48ccc9b3488684b50100904f204203724d4d62", "ext": "java", "lang": "Java", "content": "public class TopologyBuilder\n{\n\tArrayList<IRichSpout> spouts;\n\tArrayList<IRichBolt> bolts;\n\n\tpublic TopologyBuilder()\n\t{\n\t\tspouts = new ArrayList<IRichSpout>();\n\t\tbolts  = new ArrayList<IRichBolt> ();\n\t}\n\n\tpublic SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint)\n\t{\n\t\tspouts.add(spout);\n\t\treturn new SpoutDeclarer();\n\t}\n\n\tpublic  BoltDeclarer setBolt(String id, IRichBolt bolt, Number parallelism_hint)\n\t{\n\t\tbolts.add(bolt);\n\t\treturn new BoltDeclarer();\n\t}\n\n\tpublic StormTopology createTopology()\n\t{\n\t\tStormTopology ret = new StormTopology();\n\t\tret.WHsetSpoutsAndBolts(spouts, bolts);\n\t\treturn ret;\n\t}\n\n}", "class_id": 0, "repo": "hpcn-uam/wormhole", "file": "src/langApis/Java/org/apache/storm/topology/TopologyBuilder.java", "last_update_at": "2018-11-08T19:02:02+00:00", "question_id": "4d48ccc9b3488684b50100904f204203724d4d62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TopologyBuilder\n{\n\tArrayList<IRichSpout> spouts;\n\tArrayList<IRichBolt> bolts;\n\tpublic TopologyBuilder()\n\t{\n\t\tspouts = new ArrayList<IRichSpout>();\n\t\tbolts  = new ArrayList<IRichBolt> ();\n\t}\n\tpublic SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint)\n\t{\n\t\tspouts.add(spout);\n\t\treturn new SpoutDeclarer();\n\t}\n\tpublic  BoltDeclarer setBolt(String id, IRichBolt bolt, Number parallelism_hint)\n\t{\n\t\tbolts.add(bolt);\n\t\treturn new BoltDeclarer();\n\t}\n\tpublic StormTopology createTopology()\n\t{\n\t\tStormTopology ret = new StormTopology();\n\t\tret.WHsetSpoutsAndBolts(spouts, bolts);\n\t\treturn ret;\n\t}\n"]], "pred": {"ppl": 1.8152461051940918, "ppl_lower": 2.087354898452759, "ppl/lowercase_ppl": -1.2342698418152174, "ppl/zlib": 0.002241432532604823, "Min_5.0% Prob": 8.213539560635885, "Min_10.0% Prob": 5.442730231285095, "Min_20.0% Prob": 2.9193623310327528, "Min_30.0% Prob": 1.9772746402025223, "Min_40.0% Prob": 1.493598687313497, "Min_50.0% Prob": 1.1891814193629202, "Min_60.0% Prob": 0.9937684282179404}}
{"hexsha": "1c0bcc355406afb384b2590e49134412df890d11", "ext": "java", "lang": "Java", "content": "public class ReplicationTest {\n    @Rule\n    public final TestRule   testLog = TestHelper.testLog;\n\n    OSD[]                   osds;\n    OSDConfig[]             configs;\n    OSDServiceClient        client;\n\n    private Capability      cap;\n    private String          fileID;\n    private XLocations      xLoc;\n\n    // needed for dummy classes\n    private int             stripeSize;\n    private ReusableBuffer  data;\n\n    private long            objectNo;\n    private TestEnvironment testEnv;\n\n    @BeforeClass\n    public static void initializeTest() throws Exception {\n        Logging.start(SetupUtils.DEBUG_LEVEL, SetupUtils.DEBUG_CATEGORIES);\n    }\n\n    /**\n     * @throws java.lang.Exception\n     */\n    @Before\n    public void setUp() throws Exception {\n        this.stripeSize = 128 * 1024; // byte\n        this.data = SetupUtils.generateData(stripeSize);\n\n        // startup: DIR\n        testEnv = new TestEnvironment(new TestEnvironment.Services[] { TestEnvironment.Services.DIR_SERVICE,\n                TestEnvironment.Services.TIME_SYNC, TestEnvironment.Services.UUID_RESOLVER,\n                TestEnvironment.Services.OSD_CLIENT });\n        testEnv.start();\n\n        osds = new OSD[12];\n        configs = SetupUtils.createMultipleOSDConfigs(12);\n        for (int i = 0; i < osds.length; i++) {\n            osds[i] = new OSD(configs[i]);\n        }\n\n        client = testEnv.getOSDClient();\n\n        fileID = \"1:1\";\n        objectNo = 0;\n        cap = new Capability(fileID, SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(), 60,\n                System.currentTimeMillis(), \"\", 0, false, SnapConfig.SNAP_CONFIG_SNAPS_DISABLED, 0,\n                configs[0].getCapabilitySecret());\n\n        xLoc = createLocations(4, 3);\n    }\n\n    private XLocations createLocations(int numberOfReplicas, int numberOfStripedOSDs) throws InvalidXLocationsException {\n        assert (numberOfReplicas * numberOfStripedOSDs <= osds.length);\n\n        List<Replica> rlist = new LinkedList();\n        for (int replica = 0; replica < numberOfReplicas; replica++) {\n            List<String> osdset = new LinkedList();\n            int startOSD = replica * numberOfStripedOSDs;\n            for (int stripe = 0; stripe < numberOfStripedOSDs; stripe++) {\n                // add available osds\n                osdset.add(configs[startOSD + stripe].getUUID().toString());\n            }\n\n            Replica r = Replica.newBuilder()\n                    .setStripingPolicy(SetupUtils.getStripingPolicy(osdset.size(), stripeSize / 1024))\n                    .setReplicationFlags(0).addAllOsdUuids(osdset).build();\n            rlist.add(r);\n        }\n        XLocSet locSet = XLocSet.newBuilder().setReadOnlyFileSize(0)\n                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE).setVersion(1).addAllReplicas(rlist)\n                .build();\n        // set the first replica as current replica\n\n        // set the first replica as current replica\n        XLocations locations = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));\n        return locations;\n    }\n\n    private void setReplicated(long filesize, int indexOfFullReplica) throws Exception {\n        // set replication flags\n\n        List<Replica> rlist = new LinkedList();\n\n        for (int i = 0; i < xLoc.getXLocSet().getReplicasCount(); i++) {\n            Replica r = xLoc.getXLocSet().getReplicas(i);\n            if (i == indexOfFullReplica)\n                rlist.add(r\n                        .toBuilder()\n                        .setReplicationFlags(\n                                ReplicationFlags.setReplicaIsComplete(ReplicationFlags\n                                        .setPartialReplica(ReplicationFlags.setRandomStrategy(0)))).build());\n            else\n                rlist.add(r.toBuilder()\n                        .setReplicationFlags(ReplicationFlags.setPartialReplica(ReplicationFlags.setRandomStrategy(0)))\n                        .build());\n        }\n\n        XLocSet locSet = xLoc.getXLocSet().toBuilder().clearReplicas().addAllReplicas(rlist)\n                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY).setReadOnlyFileSize(filesize)\n                .build();\n\n        xLoc = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));\n\n    }\n\n    /**\n     * @throws java.lang.Exception\n     */\n    @After\n    public void tearDown() throws Exception {\n        for (OSD osd : this.osds)\n            osd.shutdown();\n\n        testEnv.shutdown();\n\n        // free buffers\n        BufferPool.free(data);\n    }\n\n    /*\n     * private ObjectData getObjectData(ReusableBuffer data) { return new ObjectData(0, false, 0,\n     * data.createViewBuffer()); }\n     */\n\n    @Test\n    public void testStriped() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // write object to replica 3\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n\n        // change XLoc\n        setReplicated(data.limit(), 2);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // read object from replica 3 (object exists on this OSD) => normal read\n        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData rResp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n\n        // read object from replica 2 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        rResp = r.get();\n        if (data.capacity() > 0) {\n            assertNotNull(r.getData());\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        } else\n            assertNull(r.getData());\n        r.freeBuffers();\n\n        // read object from replica 4 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(3).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        rResp = r.get();\n        if (data.capacity() > 0)\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        else\n            assertNull(r.getData());\n        r.freeBuffers();\n\n        // read part of object from replica 1 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 4);\n        rResp = r.get();\n        int j = stripeSize / 4;\n        byte[] responseData = r.getData().array();\n        byte[] dataBytes = data.array();\n        for (int i = 0; i < responseData.length; i++) {\n            assertEquals(dataBytes[j++], responseData[i]);\n        }\n        r.freeBuffers();\n\n    }\n\n    @Test\n    public void testHoleAndEOF() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // write object 1 to replica 1 => full object\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n\n        // object 2 is a hole\n\n        ReusableBuffer data2 = SetupUtils.generateData(stripeSize / 2);\n        // write half object 3 to replica 1 with offset => half object, HOLE\n        w = client.write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, 0, objdata,\n                data2.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n\n        // write half object 4 to replica 1 => half object, EOF\n        w = client.write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata, data2.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n\n        // change XLoc (filesize)\n        setReplicated(stripeSize * 3 + data2.limit(), 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // read object from replica 2\n        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData rResp = r.get();\n        if (data.capacity() > 0)\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        else\n            assertNull(r.getData());\n        r.freeBuffers();\n\n        // read hole from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize);\n        rResp = r.get();\n        // filled with zeros\n        if (rResp.getZeroPadding() == 0) {\n            for (byte b : r.getData().array()) {\n                assertEquals(0, b);\n            }\n        }\n        r.freeBuffers();\n\n        // check whether a padding object for object 2 has been created on\n        // replica 2\n        RPCResponse<InternalReadLocalResponse> intRLRsp = client.xtreemfs_internal_read_local(\n                xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize, false, new ArrayList());\n        InternalReadLocalResponse intRL = intRLRsp.get();\n        assertEquals(stripeSize, intRL.getData().getZeroPadding());\n\n        // read EOF from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 4).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 4, 0, 0, stripeSize);\n        rResp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n\n        // read hole within an object from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize);\n        rResp = r.get();\n        byte[] responseData = r.getData().array();\n        // correct length\n        assertEquals(stripeSize / 4 + data2.limit(), responseData.length);\n        // first quarter filled with zeros\n        for (int i = 0; i < stripeSize / 4; i++) {\n            assertEquals((byte) 0, responseData[i]);\n        }\n        int j = 0;\n        // then there is the data\n        byte[] data2bytes = data2.array();\n        for (int i = stripeSize / 4; i < (stripeSize / 4) * 3; i++) {\n            assertEquals(data2bytes[j++], responseData[i]);\n        }\n        // last quarter filled with zeros again\n        assertEquals(stripeSize / 4, rResp.getZeroPadding());\n        r.freeBuffers();\n\n        // read EOF within data from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 3).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize);\n        rResp = r.get();\n        assertTrue(Arrays.equals(data2.array(), r.getData().array()));\n        r.freeBuffers();\n\n        // read hole within an object from replica 2 with offset and length\n        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(2).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, data2.limit());\n        rResp = r.get();\n        // correct length and data\n        assertEquals(data2.limit(), r.getData().array().length);\n        assertTrue(Arrays.equals(data2.array(), r.getData().array()));\n        r.freeBuffers();\n\n        // free buffers\n        BufferPool.free(data2);\n    }\n\n    /*\n     * following tests are testing readLocal-RPC\n     */\n    /**\n     * striped case\n     */\n    @Test\n    public void testObjectLocalAvailable() throws Exception {\n        // Default case.\n        helperObjectLocalAvailable();\n    }\n\n    public void helperObjectLocalAvailable() throws Exception {\n        ServiceUUID serverID = xLoc.getOSDsForObject(objectNo).get(0);\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // write data\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> r = client.write(serverID.getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata, this.data.createViewBuffer());\n        OSDWriteResponse resp = r.get();\n        r.freeBuffers();\n\n        // change XLoc\n        setReplicated(this.data.limit(), 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // read data\n        RPCResponse<InternalReadLocalResponse> r2 = client.xtreemfs_internal_read_local(serverID.getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,\n                false, new ArrayList());\n        InternalReadLocalResponse resp2 = r2.get();\n\n        assertTrue(Arrays.equals(data.array(), r2.getData().array()));\n        assertEquals(0, resp2.getObjectSetCount());\n\n        r2.freeBuffers();\n\n        // read only part of data\n        r2 = client.xtreemfs_internal_read_local(serverID.getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 2, true,\n                new ArrayList());\n        resp2 = r2.get();\n\n        int j = stripeSize / 4;\n        byte[] responseData = r2.getData().array();\n        byte[] dataBytes = data.array();\n        assertEquals(stripeSize / 2, responseData.length);\n        for (int i = 0; i < responseData.length; i++) {\n            assertEquals(dataBytes[j++], responseData[i]);\n        }\n        assertEquals(1, resp2.getObjectSetCount());\n\n        // check object list\n        ObjectList objectList = resp2.getObjectSet(0);\n        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()\n                .toByteArray());\n        assertNotNull(list);\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo));\n\n        r2.freeBuffers();\n    }\n\n    /**\n     * striped case\n     */\n    @Test\n    public void testObjectLocalNOTAvailable() throws Exception {\n        helperObjectLocalNOTAvailable();\n    }\n\n    public void helperObjectLocalNOTAvailable() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // read object, before one has been written\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<InternalReadLocalResponse> r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo)\n                .get(0).getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo,\n                0, 0, stripeSize, true, new ArrayList());\n        InternalReadLocalResponse resp = r.get();\n        assertNull(r.getData());\n        assertEquals(1, resp.getObjectSetCount());\n        ObjectSet list = new ObjectSet(resp.getObjectSet(0).getStripeWidth(), resp.getObjectSet(0).getFirst(), resp\n                .getObjectSet(0).getSet().toByteArray());\n        assertEquals(0, list.size());\n        r.freeBuffers();\n\n        // write data\n        RPCResponse<OSDWriteResponse> r2 = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse resp2 = r2.get();\n        r2.freeBuffers();\n        r2 = client\n                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        resp2 = r2.get();\n        r2.freeBuffers();\n\n        // change XLoc\n        setReplicated(data.limit() * 2, 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n\n        // read data\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n\n        // read higher object than has been written (EOF)\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n\n        // read object that has not been written (hole)\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n    }\n\n    @Test\n    public void testObjectLocalAvailableNONStriped() throws Exception {\n        this.xLoc = createLocations(2, 1);\n        // reuse test\n        helperObjectLocalAvailable();\n    }\n\n    @Test\n    public void testObjectLocalNOTAvailableNONStriped() throws Exception {\n        this.xLoc = createLocations(2, 1);\n        // reuse test\n        helperObjectLocalNOTAvailable();\n    }\n\n    @Test\n    public void testGetObjectList() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n\n        // read data\n        RPCResponse<ObjectList> r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0)\n                .getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        ObjectList objectList = r.get();\n        r.freeBuffers();\n        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()\n                .toByteArray());\n        assertEquals(0, list.size());\n\n        // write object to replica 1 : OSD 1\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n\n        // read data\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo));\n\n        // write object to replica 1 : OSD 2\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n\n        // write object to replica 1 : OSD 3\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n\n        // write object to replica 1 : OSD 1\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n\n        // read object list from OSD 1 : OSD 1\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(2, list.size());\n        assertTrue(list.contains(objectNo));\n        assertTrue(list.contains(objectNo + 3));\n\n        // read object list from OSD 1 : OSD 2\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo + 1));\n\n        // read object list from OSD 1 : OSD 3\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo + 2));\n    }\n\n    @Test\n    public void testOutdatedView() throws Exception {\n        xLoc = createLocations(2, 1);\n\n        // Write with view version 2\n        XLocSet xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n\n        // write data\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> r = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse resp = r.get();\n        r.freeBuffers();\n\n        // change XLoc to replicated and set the view to the outdated version 1\n        setReplicated(this.data.limit(), 0);\n        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(1).build();\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n\n        // read data from first replica -> would have to replicate but will fail due to the VIEW error\n        RPCResponse<ObjectData> r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        try {\n            ObjectData resp2 = r2.get();\n            fail();\n        } catch (PBRPCException e) {\n            assertEquals(ErrorType.INVALID_VIEW, e.getErrorType());\n        } catch (IOException e) {\n            fail();\n        } finally {\n            r2.freeBuffers();\n        }\n\n        // update to the view version 2\n        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n\n        // read data from first replica -> has to replicate\n        r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData resp2 = r2.get();\n        if (data.capacity() > 0) {\n            assertNotNull(r2.getData());\n            assertTrue(Arrays.equals(data.array(), r2.getData().array()));\n        } else\n            assertNull(r2.getData());\n        r2.freeBuffers();\n    }\n}", "class_id": 0, "repo": "chrkl/xtreemfs", "file": "java/xtreemfs-servers/src/test/java/org/xtreemfs/test/osd/replication/ReplicationTest.java", "last_update_at": "2018-03-08T17:47:46+00:00", "question_id": "1c0bcc355406afb384b2590e49134412df890d11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ReplicationTest {\n    @Rule\n    public final TestRule   testLog = TestHelper.testLog;\n    OSD[]                   osds;\n    OSDConfig[]             configs;\n    OSDServiceClient        client;\n    private Capability      cap;\n    private String          fileID;\n    private XLocations      xLoc;\n    // needed for dummy classes\n    private int             stripeSize;\n    private ReusableBuffer  data;\n    private long            objectNo;\n    private TestEnvironment testEnv;\n    @BeforeClass\n    public static void initializeTest() throws Exception {\n        Logging.start(SetupUtils.DEBUG_LEVEL, SetupUtils.DEBUG_CATEGORIES);\n    }\n    /**\n     * @throws java.lang.Exception\n     */\n    @Before\n    public void setUp() throws Exception {\n        this.stripeSize = 128 * 1024; // byte\n        this.data = SetupUtils.generateData(stripeSize);\n        // startup: DIR\n        testEnv = new TestEnvironment(new TestEnvironment.Services[] { TestEnvironment.Services.DIR_SERVICE,\n                TestEnvironment.Services.TIME_SYNC, TestEnvironment.Services.UUID_RESOLVER,\n                TestEnvironment.Services.OSD_CLIENT });\n        testEnv.start();\n        osds = new OSD[12];\n        configs = SetupUtils.createMultipleOSDConfigs(12);\n        for (int i = 0; i < osds.length; i++) {\n            osds[i] = new OSD(configs[i]);\n        }\n        client = testEnv.getOSDClient();\n        fileID = \"1:1\";\n        objectNo = 0;\n        cap = new Capability(fileID, SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(), 60,\n                System.currentTimeMillis(), \"\", 0, false, SnapConfig.SNAP_CONFIG_SNAPS_DISABLED, 0,\n                configs[0].getCapabilitySecret());\n        xLoc = createLocations(4, 3);\n    }\n    private XLocations createLocations(int numberOfReplicas, int numberOfStripedOSDs) throws InvalidXLocationsException {\n        assert (numberOfReplicas * numberOfStripedOSDs <= osds.length);\n        List<Replica> rlist = new LinkedList();\n        for (int replica = 0; replica < numberOfReplicas; replica++) {\n            List<String> osdset = new LinkedList();\n            int startOSD = replica * numberOfStripedOSDs;\n            for (int stripe = 0; stripe < numberOfStripedOSDs; stripe++) {\n                // add available osds\n                osdset.add(configs[startOSD + stripe].getUUID().toString());\n            }\n            Replica r = Replica.newBuilder()\n                    .setStripingPolicy(SetupUtils.getStripingPolicy(osdset.size(), stripeSize / 1024))\n                    .setReplicationFlags(0).addAllOsdUuids(osdset).build();\n            rlist.add(r);\n        }\n        XLocSet locSet = XLocSet.newBuilder().setReadOnlyFileSize(0)\n                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE).setVersion(1).addAllReplicas(rlist)\n                .build();\n        // set the first replica as current replica\n        // set the first replica as current replica\n        XLocations locations = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));\n        return locations;\n    }\n    private void setReplicated(long filesize, int indexOfFullReplica) throws Exception {\n        // set replication flags\n        List<Replica> rlist = new LinkedList();\n        for (int i = 0; i < xLoc.getXLocSet().getReplicasCount(); i++) {\n            Replica r = xLoc.getXLocSet().getReplicas(i);\n            if (i == indexOfFullReplica)\n                rlist.add(r\n                        .toBuilder()\n                        .setReplicationFlags(\n                                ReplicationFlags.setReplicaIsComplete(ReplicationFlags\n                                        .setPartialReplica(ReplicationFlags.setRandomStrategy(0)))).build());\n            else\n                rlist.add(r.toBuilder()\n                        .setReplicationFlags(ReplicationFlags.setPartialReplica(ReplicationFlags.setRandomStrategy(0)))\n                        .build());\n        }\n        XLocSet locSet = xLoc.getXLocSet().toBuilder().clearReplicas().addAllReplicas(rlist)\n                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY).setReadOnlyFileSize(filesize)\n                .build();\n        xLoc = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));\n    }\n    /**\n     * @throws java.lang.Exception\n     */\n    @After\n    public void tearDown() throws Exception {\n        for (OSD osd : this.osds)\n            osd.shutdown();\n        testEnv.shutdown();\n        // free buffers\n        BufferPool.free(data);\n    }\n    /*\n     * private ObjectData getObjectData(ReusableBuffer data) { return new ObjectData(0, false, 0,\n     * data.createViewBuffer()); }\n     */\n    @Test\n    public void testStriped() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // write object to replica 3\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n        // change XLoc\n        setReplicated(data.limit(), 2);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // read object from replica 3 (object exists on this OSD) => normal read\n        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData rResp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n        // read object from replica 2 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        rResp = r.get();\n        if (data.capacity() > 0) {\n            assertNotNull(r.getData());\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        } else\n            assertNull(r.getData());\n        r.freeBuffers();\n        // read object from replica 4 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(3).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        rResp = r.get();\n        if (data.capacity() > 0)\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        else\n            assertNull(r.getData());\n        r.freeBuffers();\n        // read part of object from replica 1 (object not exists on this OSD) => replication\n        r = client.read(xLoc.getOSDsForObject(objectNo).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 4);\n        rResp = r.get();\n        int j = stripeSize / 4;\n        byte[] responseData = r.getData().array();\n        byte[] dataBytes = data.array();\n        for (int i = 0; i < responseData.length; i++) {\n            assertEquals(dataBytes[j++], responseData[i]);\n        }\n        r.freeBuffers();\n    }\n    @Test\n    public void testHoleAndEOF() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // write object 1 to replica 1 => full object\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n        // object 2 is a hole\n        ReusableBuffer data2 = SetupUtils.generateData(stripeSize / 2);\n        // write half object 3 to replica 1 with offset => half object, HOLE\n        w = client.write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, 0, objdata,\n                data2.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n        // write half object 4 to replica 1 => half object, EOF\n        w = client.write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata, data2.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n        // change XLoc (filesize)\n        setReplicated(stripeSize * 3 + data2.limit(), 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // read object from replica 2\n        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData rResp = r.get();\n        if (data.capacity() > 0)\n            assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        else\n            assertNull(r.getData());\n        r.freeBuffers();\n        // read hole from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize);\n        rResp = r.get();\n        // filled with zeros\n        if (rResp.getZeroPadding() == 0) {\n            for (byte b : r.getData().array()) {\n                assertEquals(0, b);\n            }\n        }\n        r.freeBuffers();\n        // check whether a padding object for object 2 has been created on\n        // replica 2\n        RPCResponse<InternalReadLocalResponse> intRLRsp = client.xtreemfs_internal_read_local(\n                xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize, false, new ArrayList());\n        InternalReadLocalResponse intRL = intRLRsp.get();\n        assertEquals(stripeSize, intRL.getData().getZeroPadding());\n        // read EOF from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 4).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 4, 0, 0, stripeSize);\n        rResp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n        // read hole within an object from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize);\n        rResp = r.get();\n        byte[] responseData = r.getData().array();\n        // correct length\n        assertEquals(stripeSize / 4 + data2.limit(), responseData.length);\n        // first quarter filled with zeros\n        for (int i = 0; i < stripeSize / 4; i++) {\n            assertEquals((byte) 0, responseData[i]);\n        }\n        int j = 0;\n        // then there is the data\n        byte[] data2bytes = data2.array();\n        for (int i = stripeSize / 4; i < (stripeSize / 4) * 3; i++) {\n            assertEquals(data2bytes[j++], responseData[i]);\n        }\n        // last quarter filled with zeros again\n        assertEquals(stripeSize / 4, rResp.getZeroPadding());\n        r.freeBuffers();\n        // read EOF within data from replica 2\n        r = client.read(xLoc.getOSDsForObject(objectNo + 3).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize);\n        rResp = r.get();\n        assertTrue(Arrays.equals(data2.array(), r.getData().array()));\n        r.freeBuffers();\n        // read hole within an object from replica 2 with offset and length\n        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(2).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, data2.limit());\n        rResp = r.get();\n        // correct length and data\n        assertEquals(data2.limit(), r.getData().array().length);\n        assertTrue(Arrays.equals(data2.array(), r.getData().array()));\n        r.freeBuffers();\n        // free buffers\n        BufferPool.free(data2);\n    }\n    /*\n     * following tests are testing readLocal-RPC\n     */\n    /**\n     * striped case\n     */\n    @Test\n    public void testObjectLocalAvailable() throws Exception {\n        // Default case.\n        helperObjectLocalAvailable();\n    }\n    public void helperObjectLocalAvailable() throws Exception {\n        ServiceUUID serverID = xLoc.getOSDsForObject(objectNo).get(0);\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // write data\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> r = client.write(serverID.getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata, this.data.createViewBuffer());\n        OSDWriteResponse resp = r.get();\n        r.freeBuffers();\n        // change XLoc\n        setReplicated(this.data.limit(), 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // read data\n        RPCResponse<InternalReadLocalResponse> r2 = client.xtreemfs_internal_read_local(serverID.getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,\n                false, new ArrayList());\n        InternalReadLocalResponse resp2 = r2.get();\n        assertTrue(Arrays.equals(data.array(), r2.getData().array()));\n        assertEquals(0, resp2.getObjectSetCount());\n        r2.freeBuffers();\n        // read only part of data\n        r2 = client.xtreemfs_internal_read_local(serverID.getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 2, true,\n                new ArrayList());\n        resp2 = r2.get();\n        int j = stripeSize / 4;\n        byte[] responseData = r2.getData().array();\n        byte[] dataBytes = data.array();\n        assertEquals(stripeSize / 2, responseData.length);\n        for (int i = 0; i < responseData.length; i++) {\n            assertEquals(dataBytes[j++], responseData[i]);\n        }\n        assertEquals(1, resp2.getObjectSetCount());\n        // check object list\n        ObjectList objectList = resp2.getObjectSet(0);\n        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()\n                .toByteArray());\n        assertNotNull(list);\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo));\n        r2.freeBuffers();\n    }\n    /**\n     * striped case\n     */\n    @Test\n    public void testObjectLocalNOTAvailable() throws Exception {\n        helperObjectLocalNOTAvailable();\n    }\n    public void helperObjectLocalNOTAvailable() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // read object, before one has been written\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<InternalReadLocalResponse> r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo)\n                .get(0).getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo,\n                0, 0, stripeSize, true, new ArrayList());\n        InternalReadLocalResponse resp = r.get();\n        assertNull(r.getData());\n        assertEquals(1, resp.getObjectSetCount());\n        ObjectSet list = new ObjectSet(resp.getObjectSet(0).getStripeWidth(), resp.getObjectSet(0).getFirst(), resp\n                .getObjectSet(0).getSet().toByteArray());\n        assertEquals(0, list.size());\n        r.freeBuffers();\n        // write data\n        RPCResponse<OSDWriteResponse> r2 = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse resp2 = r2.get();\n        r2.freeBuffers();\n        r2 = client\n                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        resp2 = r2.get();\n        r2.freeBuffers();\n        // change XLoc\n        setReplicated(data.limit() * 2, 0);\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        // read data\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertTrue(Arrays.equals(data.array(), r.getData().array()));\n        r.freeBuffers();\n        // read higher object than has been written (EOF)\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n        // read object that has not been written (hole)\n        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize,\n                false, new ArrayList());\n        resp = r.get();\n        assertNull(r.getData());\n        r.freeBuffers();\n    }\n    @Test\n    public void testObjectLocalAvailableNONStriped() throws Exception {\n        this.xLoc = createLocations(2, 1);\n        // reuse test\n        helperObjectLocalAvailable();\n    }\n    @Test\n    public void testObjectLocalNOTAvailableNONStriped() throws Exception {\n        this.xLoc = createLocations(2, 1);\n        // reuse test\n        helperObjectLocalNOTAvailable();\n    }\n    @Test\n    public void testGetObjectList() throws Exception {\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        // read data\n        RPCResponse<ObjectList> r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0)\n                .getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        ObjectList objectList = r.get();\n        r.freeBuffers();\n        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()\n                .toByteArray());\n        assertEquals(0, list.size());\n        // write object to replica 1 : OSD 1\n        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse wResp = w.get();\n        w.freeBuffers();\n        // read data\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo));\n        // write object to replica 1 : OSD 2\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n        // write object to replica 1 : OSD 3\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n        // write object to replica 1 : OSD 1\n        w = client\n                .write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,\n                        RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata,\n                        this.data.createViewBuffer());\n        wResp = w.get();\n        w.freeBuffers();\n        // read object list from OSD 1 : OSD 1\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(2, list.size());\n        assertTrue(list.contains(objectNo));\n        assertTrue(list.contains(objectNo + 3));\n        // read object list from OSD 1 : OSD 2\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo + 1));\n        // read object list from OSD 1 : OSD 3\n        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);\n        objectList = r.get();\n        r.freeBuffers();\n        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());\n        assertEquals(1, list.size());\n        assertTrue(list.contains(objectNo + 2));\n    }\n    @Test\n    public void testOutdatedView() throws Exception {\n        xLoc = createLocations(2, 1);\n        // Write with view version 2\n        XLocSet xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();\n        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n        // write data\n        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)\n                .build();\n        RPCResponse<OSDWriteResponse> r = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,\n                this.data.createViewBuffer());\n        OSDWriteResponse resp = r.get();\n        r.freeBuffers();\n        // change XLoc to replicated and set the view to the outdated version 1\n        setReplicated(this.data.limit(), 0);\n        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(1).build();\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n        // read data from first replica -> would have to replicate but will fail due to the VIEW error\n        RPCResponse<ObjectData> r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),\n                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        try {\n            ObjectData resp2 = r2.get();\n            fail();\n        } catch (PBRPCException e) {\n            assertEquals(ErrorType.INVALID_VIEW, e.getErrorType());\n        } catch (IOException e) {\n            fail();\n        } finally {\n            r2.freeBuffers();\n        }\n        // update to the view version 2\n        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();\n        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();\n        // read data from first replica -> has to replicate\n        r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,\n                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);\n        ObjectData resp2 = r2.get();\n        if (data.capacity() > 0) {\n            assertNotNull(r2.getData());\n            assertTrue(Arrays.equals(data.array(), r2.getData().array()));\n        } else\n            assertNull(r2.getData());\n        r2.freeBuffers();\n    }\n"]], "pred": {"ppl": 2.1654915809631348, "ppl_lower": 2.9174256324768066, "ppl/lowercase_ppl": -1.3857570778152202, "ppl/zlib": 0.00020236966837669778, "Min_5.0% Prob": 6.347858083014395, "Min_10.0% Prob": 4.878689354541255, "Min_20.0% Prob": 3.3382587830225625, "Min_30.0% Prob": 2.4566175911356423, "Min_40.0% Prob": 1.9046905230557714, "Min_50.0% Prob": 1.540019120488848, "Min_60.0% Prob": 1.2879206595325547}}
{"hexsha": "595ec0ee9517f3449a3bb94cd4f7947d813b8579", "ext": "java", "lang": "Java", "content": "public class AutoReConnectingSocketManager implements SocketManager\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(AutoReConnectingSocketManager.class);\n\n    /**\n     * The delegate socket manager.\n     */\n    private final SocketManager delegate;\n\n    private InetSocketAddress server;\n\n    private long connectionTimeout;\n\n    public AutoReConnectingSocketManager(SocketManager delegate)\n    {\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void setInterceptor(Interceptor interceptor)\n    {\n        delegate.setInterceptor(interceptor);\n    }\n\n    @Override\n    public void setDefaultMessageTimeout(long time, TimeUnit unit)\n    {\n        delegate.setDefaultMessageTimeout(time, unit);\n    }\n\n    @Override\n    public long getDefaultMessageTimeout(TimeUnit unit)\n    {\n        return delegate.getDefaultMessageTimeout(unit);\n    }\n\n    @Override\n    public void connect(String host, int port, long timeout) throws IOException\n    {\n        connect(new InetSocketAddress(host, port), timeout);\n    }\n\n    @Override\n    public synchronized void connect(InetSocketAddress addr, long timeout) throws IOException\n    {\n        this.server = addr;\n        this.connectionTimeout = timeout;\n\n        delegate.connect(addr, timeout);\n    }\n\n    @Override\n    public boolean isConnected()\n    {\n        connectIfNecessary();\n        return delegate.isConnected();\n    }\n\n    @Override\n    public InetSocketAddress getConnectedAddress()\n    {\n        connectIfNecessary();\n        return delegate.getConnectedAddress();\n    }\n\n    @Override\n    public SocketManager newConnection() throws IOException\n    {\n        connectIfNecessary();\n        return delegate.newConnection();\n    }\n\n    @Override\n    public synchronized void disconnect()\n    {\n        this.server = null;\n        delegate.disconnect();\n    }\n\n    @Override\n    public void send(String message) throws IOException\n    {\n        connectIfNecessary();\n        delegate.send(message);\n    }\n\n    @Override\n    public String sendAndWait(String message) throws IOException\n    {\n        connectIfNecessary();\n        return delegate.sendAndWait(message);\n    }\n\n    @Override\n    public String sendAndWait(String message, long timeout, TimeUnit unit) throws IOException\n    {\n        connectIfNecessary();\n        return delegate.sendAndWait(message, timeout, unit);\n    }\n\n    @Override\n    public ByteChannel redirectChannel()\n    {\n        connectIfNecessary();\n        return delegate.redirectChannel();\n    }\n\n    private synchronized void connectIfNecessary()\n    {\n        if (server == null || delegate.isConnected())\n        {\n            return;\n        }\n\n        try\n        {\n            delegate.connect(server, connectionTimeout);\n        }\n        catch (IOException e)\n        {\n            LOGGER.warn(\"Auto-reconnect failed\", e);\n        }\n    }\n}", "class_id": 0, "repo": "syphr42/libmythtv-java", "file": "api/src/main/java/org/syphr/mythtv/api/backend/AutoReConnectingSocketManager.java", "last_update_at": "2018-10-04T06:40:21+00:00", "question_id": "595ec0ee9517f3449a3bb94cd4f7947d813b8579", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AutoReConnectingSocketManager implements SocketManager\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(AutoReConnectingSocketManager.class);\n    /**\n     * The delegate socket manager.\n     */\n    private final SocketManager delegate;\n    private InetSocketAddress server;\n    private long connectionTimeout;\n    public AutoReConnectingSocketManager(SocketManager delegate)\n    {\n        this.delegate = delegate;\n    }\n    @Override\n    public void setInterceptor(Interceptor interceptor)\n    {\n        delegate.setInterceptor(interceptor);\n    }\n    @Override\n    public void setDefaultMessageTimeout(long time, TimeUnit unit)\n    {\n        delegate.setDefaultMessageTimeout(time, unit);\n    }\n    @Override\n    public long getDefaultMessageTimeout(TimeUnit unit)\n    {\n        return delegate.getDefaultMessageTimeout(unit);\n    }\n    @Override\n    public void connect(String host, int port, long timeout) throws IOException\n    {\n        connect(new InetSocketAddress(host, port), timeout);\n    }\n    @Override\n    public synchronized void connect(InetSocketAddress addr, long timeout) throws IOException\n    {\n        this.server = addr;\n        this.connectionTimeout = timeout;\n        delegate.connect(addr, timeout);\n    }\n    @Override\n    public boolean isConnected()\n    {\n        connectIfNecessary();\n        return delegate.isConnected();\n    }\n    @Override\n    public InetSocketAddress getConnectedAddress()\n    {\n        connectIfNecessary();\n        return delegate.getConnectedAddress();\n    }\n    @Override\n    public SocketManager newConnection() throws IOException\n    {\n        connectIfNecessary();\n        return delegate.newConnection();\n    }\n    @Override\n    public synchronized void disconnect()\n    {\n        this.server = null;\n        delegate.disconnect();\n    }\n    @Override\n    public void send(String message) throws IOException\n    {\n        connectIfNecessary();\n        delegate.send(message);\n    }\n    @Override\n    public String sendAndWait(String message) throws IOException\n    {\n        connectIfNecessary();\n        return delegate.sendAndWait(message);\n    }\n    @Override\n    public String sendAndWait(String message, long timeout, TimeUnit unit) throws IOException\n    {\n        connectIfNecessary();\n        return delegate.sendAndWait(message, timeout, unit);\n    }\n    @Override\n    public ByteChannel redirectChannel()\n    {\n        connectIfNecessary();\n        return delegate.redirectChannel();\n    }\n    private synchronized void connectIfNecessary()\n    {\n        if (server == null || delegate.isConnected())\n        {\n            return;\n        }\n        try\n        {\n            delegate.connect(server, connectionTimeout);\n        }\n        catch (IOException e)\n        {\n            LOGGER.warn(\"Auto-reconnect failed\", e);\n        }\n    }\n"]], "pred": {"ppl": 1.4572843313217163, "ppl_lower": 1.5420114994049072, "ppl/lowercase_ppl": -1.1500713734513481, "ppl/zlib": 0.000561214093360235, "Min_5.0% Prob": 4.8321433663368225, "Min_10.0% Prob": 3.184492504760011, "Min_20.0% Prob": 1.8317550456240064, "Min_30.0% Prob": 1.2485099185713275, "Min_40.0% Prob": 0.9403135435403152, "Min_50.0% Prob": 0.7526342609340734, "Min_60.0% Prob": 0.6286237559803315}}
{"hexsha": "000afbbf1284da3cf10b356e16ba7e060725ab17", "ext": "java", "lang": "Java", "content": "public class DevideTwoIntegers implements Facebook {\n\n    /**\n     * Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\n     * Return the quotient after dividing dividend by divisor.\n     * The integer division should truncate toward zero.\n     * Example 1:\n     * Input: dividend = 10, divisor = 3\n     * Output: 3\n     * Example 2:\n     * Input: dividend = 7, divisor = -3\n     * Output: -2\n     * Note:\n     * Both dividend and divisor will be 32-bit signed integers.\n     * The divisor will never be 0.\n     * Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231,  231 \u2212 1].\n     * For the purpose of this problem, assume that your function returns 231 \u2212 1 when the division result overflows.\n     */\n\n    public int divide(int dividend, int divisor) {\n        //Reduce the problem to positive long integer to make it easier.\n        //Use long to avoid integer overflow cases.\n        int sign = 1;\n        if( (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) )\n            sign = -1;\n        long dd = Math.abs((long) dividend);\n        long ds = Math.abs((long) divisor);\n        //Take care the edge cases.\n        if(ds == 0) return Integer.MAX_VALUE;\n        if(dd == 0 || dd < ds) return 0;\n\n        long lans = helper(dd, ds);\n        int ans = 0;\n        //Handle overflow.\n        if(lans > Integer.MAX_VALUE){\n            ans = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }else {\n            ans = (int) (sign * lans);\n        }\n\n        return ans;\n    }\n\n\n    private long helper(long dd, long ds){\n        // Recursion exit condition\n        if(dd < ds) return 0;\n\n        //  Find the largest multiple so that (divisor * multiple <= dividend),\n        //  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\n        //  Think this as a binary search.\n        long sum = ds;\n        long mul = 1;\n        while (sum + sum <= dd){\n            sum += sum;\n            mul += mul;\n        }\n        //Look for additional value for the multiple from the reminder (dividend - sum) recursively\n        return mul + helper(dd - sum, ds);\n    }\n\n    private long bsHelper(long dd, long ds){\n        if(dd < ds) return 0;\n\n        long pro = ds;\n        while (pro * pro <= dd){\n            pro *= pro;\n        }\n        return pro;\n    }\n\n\n    public void test(){\n        System.out.println(divide(10 , 3));\n        System.out.println(divide(7 , -3));\n    }\n\n}", "class_id": 0, "repo": "bazindes/Algorithms", "file": "src/main/java/com/baz/app/lc/medium/DevideTwoIntegers.java", "last_update_at": "2018-10-14T20:42:04+00:00", "question_id": "000afbbf1284da3cf10b356e16ba7e060725ab17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DevideTwoIntegers implements Facebook {\n    /**\n     * Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\n     * Return the quotient after dividing dividend by divisor.\n     * The integer division should truncate toward zero.\n     * Example 1:\n     * Input: dividend = 10, divisor = 3\n     * Output: 3\n     * Example 2:\n     * Input: dividend = 7, divisor = -3\n     * Output: -2\n     * Note:\n     * Both dividend and divisor will be 32-bit signed integers.\n     * The divisor will never be 0.\n     * Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231,  231 \u2212 1].\n     * For the purpose of this problem, assume that your function returns 231 \u2212 1 when the division result overflows.\n     */\n    public int divide(int dividend, int divisor) {\n        //Reduce the problem to positive long integer to make it easier.\n        //Use long to avoid integer overflow cases.\n        int sign = 1;\n        if( (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) )\n            sign = -1;\n        long dd = Math.abs((long) dividend);\n        long ds = Math.abs((long) divisor);\n        //Take care the edge cases.\n        if(ds == 0) return Integer.MAX_VALUE;\n        if(dd == 0 || dd < ds) return 0;\n        long lans = helper(dd, ds);\n        int ans = 0;\n        //Handle overflow.\n        if(lans > Integer.MAX_VALUE){\n            ans = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }else {\n            ans = (int) (sign * lans);\n        }\n        return ans;\n    }\n    private long helper(long dd, long ds){\n        // Recursion exit condition\n        if(dd < ds) return 0;\n        //  Find the largest multiple so that (divisor * multiple <= dividend),\n        //  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\n        //  Think this as a binary search.\n        long sum = ds;\n        long mul = 1;\n        while (sum + sum <= dd){\n            sum += sum;\n            mul += mul;\n        }\n        //Look for additional value for the multiple from the reminder (dividend - sum) recursively\n        return mul + helper(dd - sum, ds);\n    }\n    private long bsHelper(long dd, long ds){\n        if(dd < ds) return 0;\n        long pro = ds;\n        while (pro * pro <= dd){\n            pro *= pro;\n        }\n        return pro;\n    }\n    public void test(){\n        System.out.println(divide(10 , 3));\n        System.out.println(divide(7 , -3));\n    }\n"]], "pred": {"ppl": 1.9927555322647095, "ppl_lower": 2.1923208236694336, "ppl/lowercase_ppl": -1.1384188632266008, "ppl/zlib": 0.0006655582727008759, "Min_5.0% Prob": 6.70811296764173, "Min_10.0% Prob": 4.906019207719084, "Min_20.0% Prob": 3.1357326011503894, "Min_30.0% Prob": 2.2352649451837006, "Min_40.0% Prob": 1.7079702022087153, "Min_50.0% Prob": 1.374291379138789, "Min_60.0% Prob": 1.1497970259180812}}
{"hexsha": "e65eabca600c7e064574e2b0e94f29d9e12b3731", "ext": "java", "lang": "Java", "content": "public class ImageResourceIdAdapter extends BaseImageAdapter<Integer> {\n\n\n    public ImageResourceIdAdapter() {\n        super(new ArrayList<Integer>());\n    }\n\n    public ImageResourceIdAdapter(List<Integer> objects) {\n        super(objects);\n    }\n\n    @Override\n    public void onBindViewHolder(ImageViewHolder holder, int position) {\n        super.onBindViewHolder(holder, position);\n\n        Integer resId = getItem(position);\n        holder.imageView.setImageResource(resId);\n    }\n\n\n}", "class_id": 0, "repo": "gandulf/DsaTab", "file": "DsaTab/src/main/java/com/dsatab/data/adapter/ImageResourceIdAdapter.java", "last_update_at": "2018-07-05T22:48:57+00:00", "question_id": "e65eabca600c7e064574e2b0e94f29d9e12b3731", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImageResourceIdAdapter extends BaseImageAdapter<Integer> {\n    public ImageResourceIdAdapter() {\n        super(new ArrayList<Integer>());\n    }\n    public ImageResourceIdAdapter(List<Integer> objects) {\n        super(objects);\n    }\n    @Override\n    public void onBindViewHolder(ImageViewHolder holder, int position) {\n        super.onBindViewHolder(holder, position);\n        Integer resId = getItem(position);\n        holder.imageView.setImageResource(resId);\n    }\n"]], "pred": {"ppl": 2.1008245944976807, "ppl_lower": 2.489105463027954, "ppl/lowercase_ppl": -1.2284610322009988, "ppl/zlib": 0.0033139729093908045, "Min_5.0% Prob": 6.323263645172119, "Min_10.0% Prob": 4.828988830248515, "Min_20.0% Prob": 3.3076868438720703, "Min_30.0% Prob": 2.374912843108177, "Min_40.0% Prob": 1.8428283494477178, "Min_50.0% Prob": 1.4876087848679163, "Min_60.0% Prob": 1.2415412629821472}}
{"hexsha": "c11ed96a4d9272e6f51ee973c876138e0f19bd50", "ext": "java", "lang": "Java", "content": "public class User implements Parcelable {\n\n    /**\n     * User details for the login procedure.\n     */\n    private String username;\n    private String oauthToken;\n    private String oauthTokenSecret;\n\n    /**\n     * Default constructor.\n     * \n     * @param oauthToken\n     *            The OAuth token\n     * @param oauthTokenSecret\n     *            The OAuth secret token\n     */\n    public User(String oauthToken, String oauthTokenSecret) {\n        this.oauthToken = oauthToken;\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n\n    /**\n     * Default constructor.\n     * \n     * @param username\n     *            The name of the user\n     * @param oauthToken\n     *            The OAuth token\n     * @param oauthTokenSecret\n     *            The OAuth secret token\n     */\n    public User(String username, String oauthToken, String oauthTokenSecret) {\n        this.username = username;\n        this.oauthToken = oauthToken;\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getOAuthToken() {\n        return oauthToken;\n    }\n\n    public void setOAuthToken(String oauthToken) {\n        this.oauthToken = oauthToken;\n    }\n\n    public String getOauthTokenSecret() {\n        return oauthTokenSecret;\n    }\n\n    public void setOauthTokenSecret(String oauthTokenSecret) {\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n\n    /**\n     * Constructor to create a User from a parcel.\n     * \n     * @param in\n     *            The parcel to read from\n     */\n    private User(Parcel in) {\n        this.username = in.readString();\n        this.oauthToken = in.readString();\n        this.oauthTokenSecret = in.readString();\n    }\n\n    /**\n     * Methods to write and restore a Parcel.\n     */\n    public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {\n\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    /**\n     * Writes the nodes to the given parcel.\n     */\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(username);\n        dest.writeString(oauthToken);\n        dest.writeString(oauthTokenSecret);\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n}", "class_id": 0, "repo": "Data4All/Data4All", "file": "src/main/java/io/github/data4all/model/data/User.java", "last_update_at": "2018-10-23T03:58:16+00:00", "question_id": "c11ed96a4d9272e6f51ee973c876138e0f19bd50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class User implements Parcelable {\n    /**\n     * User details for the login procedure.\n     */\n    private String username;\n    private String oauthToken;\n    private String oauthTokenSecret;\n    /**\n     * Default constructor.\n     * \n     * @param oauthToken\n     *            The OAuth token\n     * @param oauthTokenSecret\n     *            The OAuth secret token\n     */\n    public User(String oauthToken, String oauthTokenSecret) {\n        this.oauthToken = oauthToken;\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n    /**\n     * Default constructor.\n     * \n     * @param username\n     *            The name of the user\n     * @param oauthToken\n     *            The OAuth token\n     * @param oauthTokenSecret\n     *            The OAuth secret token\n     */\n    public User(String username, String oauthToken, String oauthTokenSecret) {\n        this.username = username;\n        this.oauthToken = oauthToken;\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n    public String getUsername() {\n        return username;\n    }\n    public void setUsername(String username) {\n        this.username = username;\n    }\n    public String getOAuthToken() {\n        return oauthToken;\n    }\n    public void setOAuthToken(String oauthToken) {\n        this.oauthToken = oauthToken;\n    }\n    public String getOauthTokenSecret() {\n        return oauthTokenSecret;\n    }\n    public void setOauthTokenSecret(String oauthTokenSecret) {\n        this.oauthTokenSecret = oauthTokenSecret;\n    }\n    /**\n     * Constructor to create a User from a parcel.\n     * \n     * @param in\n     *            The parcel to read from\n     */\n    private User(Parcel in) {\n        this.username = in.readString();\n        this.oauthToken = in.readString();\n        this.oauthTokenSecret = in.readString();\n    }\n    /**\n     * Methods to write and restore a Parcel.\n     */\n    public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n    /**\n     * Writes the nodes to the given parcel.\n     */\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(username);\n        dest.writeString(oauthToken);\n        dest.writeString(oauthTokenSecret);\n    }\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n"]], "pred": {"ppl": 1.3200803995132446, "ppl_lower": 1.3524675369262695, "ppl/lowercase_ppl": -1.0872838596289385, "ppl/zlib": 0.0004628210724426227, "Min_5.0% Prob": 3.946347917829241, "Min_10.0% Prob": 2.485114884376526, "Min_20.0% Prob": 1.3802221274801663, "Min_30.0% Prob": 0.9242138900127598, "Min_40.0% Prob": 0.6950804319985052, "Min_50.0% Prob": 0.5551980770925927, "Min_60.0% Prob": 0.46320027313080686}}
{"hexsha": "7ca72de68880bb70ea88b38f6d3609bd1dc9a09a", "ext": "java", "lang": "Java", "content": "public class Tweet implements Serializable{\n    private String text;\n    private Long id;\n    private String createdAt;\n    private User user;\n\n    public String getText() {\n        return text;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getCreatedAt() {\n        return createdAt;\n    }\n\n    public User getUser() {\n        return user;\n    }\n\n    public static Tweet fromJSON(JSONObject jsonObject) {\n        Tweet tweet = new Tweet();\n        try {\n            tweet.text = jsonObject.getString(\"text\");\n            tweet.createdAt = jsonObject.getString(\"created_at\");\n            tweet.id = jsonObject.getLong(\"id\");\n            tweet.user = User.fromJSON(jsonObject.getJSONObject(\"user\"));\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n\n        return tweet;\n    }\n\n    public static ArrayList<Tweet> fromJSONArray(JSONArray jsonArray) {\n        ArrayList<Tweet> tweets = new ArrayList<>();\n        for(int i=0; i<jsonArray.length(); i++){\n            try {\n                JSONObject tweetJSON = jsonArray.getJSONObject(i);\n                Tweet tweet = Tweet.fromJSON(tweetJSON);\n                if (tweet != null) {\n                    tweets.add(tweet);\n                }\n            } catch (JSONException e) {\n                e.printStackTrace();\n            }\n        }\n        Log.i(\"DEBUG\", tweets.toString());\n        return tweets;\n    }\n\n    public String getRelativeTimeAgo(String rawJsonDate) {\n        String twitterFormat = \"EEE MMM dd HH:mm:ss ZZZZZ yyyy\";\n        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);\n        sf.setLenient(true);\n\n        String relativeDate = \"\";\n        try {\n            long dateMillis = System.currentTimeMillis() - sf.parse(rawJsonDate).getTime();\n            int seconds = (int) (dateMillis/1000);\n            int minutes = seconds/60;\n            int hours = minutes/60;\n            int days = hours /24;\n            int weeks = days /7;\n\n            if ( weeks > 0)\n                return weeks + \" w\";\n            if (days > 0)\n                return days + \" d\";\n            if (hours > 0)\n                return hours + \" h\";\n            if (minutes > 0)\n                return minutes + \" m\";\n            return seconds + \" s\";\n\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n\n        return relativeDate;\n    }\n}", "class_id": 0, "repo": "mancgupta/MySimpleTweets", "file": "app/src/main/java/com/codepath/apps/mysimpletweets/models/Tweet.java", "last_update_at": "2018-01-09T19:26:06+00:00", "question_id": "7ca72de68880bb70ea88b38f6d3609bd1dc9a09a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Tweet implements Serializable{\n    private String text;\n    private Long id;\n    private String createdAt;\n    private User user;\n    public String getText() {\n        return text;\n    }\n    public Long getId() {\n        return id;\n    }\n    public String getCreatedAt() {\n        return createdAt;\n    }\n    public User getUser() {\n        return user;\n    }\n    public static Tweet fromJSON(JSONObject jsonObject) {\n        Tweet tweet = new Tweet();\n        try {\n            tweet.text = jsonObject.getString(\"text\");\n            tweet.createdAt = jsonObject.getString(\"created_at\");\n            tweet.id = jsonObject.getLong(\"id\");\n            tweet.user = User.fromJSON(jsonObject.getJSONObject(\"user\"));\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        return tweet;\n    }\n    public static ArrayList<Tweet> fromJSONArray(JSONArray jsonArray) {\n        ArrayList<Tweet> tweets = new ArrayList<>();\n        for(int i=0; i<jsonArray.length(); i++){\n            try {\n                JSONObject tweetJSON = jsonArray.getJSONObject(i);\n                Tweet tweet = Tweet.fromJSON(tweetJSON);\n                if (tweet != null) {\n                    tweets.add(tweet);\n                }\n            } catch (JSONException e) {\n                e.printStackTrace();\n            }\n        }\n        Log.i(\"DEBUG\", tweets.toString());\n        return tweets;\n    }\n    public String getRelativeTimeAgo(String rawJsonDate) {\n        String twitterFormat = \"EEE MMM dd HH:mm:ss ZZZZZ yyyy\";\n        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);\n        sf.setLenient(true);\n        String relativeDate = \"\";\n        try {\n            long dateMillis = System.currentTimeMillis() - sf.parse(rawJsonDate).getTime();\n            int seconds = (int) (dateMillis/1000);\n            int minutes = seconds/60;\n            int hours = minutes/60;\n            int days = hours /24;\n            int weeks = days /7;\n            if ( weeks > 0)\n                return weeks + \" w\";\n            if (days > 0)\n                return days + \" d\";\n            if (hours > 0)\n                return hours + \" h\";\n            if (minutes > 0)\n                return minutes + \" m\";\n            return seconds + \" s\";\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return relativeDate;\n    }\n"]], "pred": {"ppl": 1.2566487789154053, "ppl_lower": 1.603416085243225, "ppl/lowercase_ppl": -2.06670847549739, "ppl/zlib": 0.00029515307287555285, "Min_5.0% Prob": 3.1145197369835596, "Min_10.0% Prob": 1.9889981123534115, "Min_20.0% Prob": 1.106161292726384, "Min_30.0% Prob": 0.7515726339537651, "Min_40.0% Prob": 0.5677984329045154, "Min_50.0% Prob": 0.45556630707669354, "Min_60.0% Prob": 0.3811176498309942}}
{"hexsha": "b3da66788cb916c8b708fa1d648ce7fc77d342cc", "ext": "java", "lang": "Java", "content": "@RunWith(LienzoMockitoTestRunner.class)\npublic class StunnerWiresConnectorHandlerTest {\n\n    private StunnerWiresConnectorHandler stunnerWiresConnectorHandler;\n\n    @Mock\n    private WiresConnectorView connector;\n\n    @Mock\n    private NodeMouseDoubleClickEvent doubleClickEvent;\n\n    @Before\n    public void setUp() throws Exception {\n        stunnerWiresConnectorHandler = new StunnerWiresConnectorHandler(connector, WiresManager.get(new Layer()));\n    }\n\n    @Test\n    public void onNodeMouseDoubleClick() {\n        stunnerWiresConnectorHandler.onNodeMouseDoubleClick(doubleClickEvent);\n        //test it is not executing any action\n        verify(connector, never()).getLine();\n        verify(connector, never()).getPointHandles();\n    }\n}", "class_id": 0, "repo": "etirelli/kie-wb-common", "file": "kie-wb-common-stunner/kie-wb-common-stunner-client/kie-wb-common-stunner-lienzo/src/test/java/org/kie/workbench/common/stunner/client/lienzo/wires/StunnerWiresConnectorHandlerTest.java", "last_update_at": "2018-03-22T08:14:31+00:00", "question_id": "b3da66788cb916c8b708fa1d648ce7fc77d342cc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(LienzoMockitoTestRunner.class)\npublic class StunnerWiresConnectorHandlerTest {\n    private StunnerWiresConnectorHandler stunnerWiresConnectorHandler;\n    @Mock\n    private WiresConnectorView connector;\n    @Mock\n    private NodeMouseDoubleClickEvent doubleClickEvent;\n    @Before\n    public void setUp() throws Exception {\n        stunnerWiresConnectorHandler = new StunnerWiresConnectorHandler(connector, WiresManager.get(new Layer()));\n    }\n    @Test\n    public void onNodeMouseDoubleClick() {\n        stunnerWiresConnectorHandler.onNodeMouseDoubleClick(doubleClickEvent);\n        //test it is not executing any action\n        verify(connector, never()).getLine();\n        verify(connector, never()).getPointHandles();\n    }\n"]], "pred": {"ppl": 2.164022207260132, "ppl_lower": 3.7664413452148438, "ppl/lowercase_ppl": -1.7178555912525373, "ppl/zlib": 0.0025732287435552533, "Min_5.0% Prob": 6.407646226882934, "Min_10.0% Prob": 5.1367640154702325, "Min_20.0% Prob": 3.468171525569189, "Min_30.0% Prob": 2.5162462279910134, "Min_40.0% Prob": 1.9293298180259408, "Min_50.0% Prob": 1.5496387104991647, "Min_60.0% Prob": 1.292372747662566}}
{"hexsha": "a08922bd46d0ac4b99712e6743d77a3aea9697b1", "ext": "java", "lang": "Java", "content": "public class PassengerStopAssignmentValidator extends AbstractValidator {\n\n\tpublic static final String LOCAL_CONTEXT = NetexStifConstant.PASSENGER_STOP_ASSIGNMENT;\n\t\n\tprotected String getLocalContext()\n\t{\n\t\treturn LOCAL_CONTEXT;\n\t}\n\n\t@Override\n\tpublic void init(Context context) {\n\t\tsuper.init(context);\n\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\n\t\t// -- preset checkpoints to OK if uncheck\n\t\tvalidationReporter.prepareCheckPointReport(context, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1);\n\t}\n\n\tpublic boolean validate(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber)\n\t{\n\t\tboolean result = checkModification(context, NetexStifConstant.PASSENGER_STOP_ASSIGNMENT, stopAssignment, lineNumber, columnNumber);\n\t\treturn check2NeTExSTIFPassengerStopAssignment1(context, stopAssignment, lineNumber, columnNumber) && result;\n\t}\n \t/** \n \t * <b>Titre</b> :[Netex] Contr\u00f4le de l'objet PassengerStopAssignment : compl\u00e9tude\n \t * <p>\n \t * <b>R&eacute;ference Redmine</b> : <a target=\"_blank\" href=\"https://projects.af83.io/issues/2318\">Cartes #2318</a>\n \t * <p>\n \t * <b>Code</b> : 2-NeTExSTIF-PassengerStopAssignment-1\n \t * <p>\n \t * <b>Variables</b> :  n\u00e9ant\n \t * <p>\n \t * <b>Pr\u00e9requis</b> :  n\u00e9ant\n \t * <p>\n \t * <b>Pr\u00e9dicat</b> :  Les attributs ScheduledStopPointRef et QuayRef doivent \u00eatre renseign\u00e9s\n \t * <p>\n \t * <b>Message</b> :  {fichier}-Ligne {ligne}-Colonne {Colonne}, l'attribut {attribut requis} de l'objet PassengerStopAssignment {ObjectId} doit \u00eatre renseign\u00e9 \n \t * <p>\n \t * <b>Criticit\u00e9</b> :  error\n \t * <p>\n \t * \n \t *\n \t * @param context\n \t * @return\n \t */\n \tpublic boolean check2NeTExSTIFPassengerStopAssignment1(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber) {\n \t\tboolean result1 = stopAssignment.getScheduledStopPointRef() != null && !stopAssignment.getScheduledStopPointRef().isEmpty();\n \t\tboolean result2 = stopAssignment.getQuayRef() != null && !stopAssignment.getQuayRef().isEmpty();\n \t\tif (!result1)\n \t\t{\n\t\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\t\t\tString fileName = (String) context.get(Constant.FILE_NAME);\n\t\t\tLineLite line = (LineLite) context.get(Constant.LINE);\n\t\t\tDataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);\n\t\t\tvalidationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, \"ScheduledStopPointRef\");\n\n \t\t}\n \t\tif (!result2)\n \t\t{\n\t\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\t\t\tString fileName = (String) context.get(Constant.FILE_NAME);\n\t\t\tLineLite line = (LineLite) context.get(Constant.LINE);\n\t\t\tDataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);\n\t\t\tvalidationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, \"QuayRef\");\n\n \t\t}\n\n \t\treturn result1 && result2;\n \t}\n \n\n}", "class_id": 0, "repo": "entur/chouette-core-iev", "file": "mobi.chouette.exchange.netex_stif/src/main/java/mobi/chouette/exchange/netex_stif/validator/PassengerStopAssignmentValidator.java", "last_update_at": "2018-05-25T14:53:36+00:00", "question_id": "a08922bd46d0ac4b99712e6743d77a3aea9697b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PassengerStopAssignmentValidator extends AbstractValidator {\n\tpublic static final String LOCAL_CONTEXT = NetexStifConstant.PASSENGER_STOP_ASSIGNMENT;\n\t\n\tprotected String getLocalContext()\n\t{\n\t\treturn LOCAL_CONTEXT;\n\t}\n\t@Override\n\tpublic void init(Context context) {\n\t\tsuper.init(context);\n\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\t\t// -- preset checkpoints to OK if uncheck\n\t\tvalidationReporter.prepareCheckPointReport(context, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1);\n\t}\n\tpublic boolean validate(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber)\n\t{\n\t\tboolean result = checkModification(context, NetexStifConstant.PASSENGER_STOP_ASSIGNMENT, stopAssignment, lineNumber, columnNumber);\n\t\treturn check2NeTExSTIFPassengerStopAssignment1(context, stopAssignment, lineNumber, columnNumber) && result;\n\t}\n \t/** \n \t * <b>Titre</b> :[Netex] Contr\u00f4le de l'objet PassengerStopAssignment : compl\u00e9tude\n \t * <p>\n \t * <b>R&eacute;ference Redmine</b> : <a target=\"_blank\" href=\"https://projects.af83.io/issues/2318\">Cartes #2318</a>\n \t * <p>\n \t * <b>Code</b> : 2-NeTExSTIF-PassengerStopAssignment-1\n \t * <p>\n \t * <b>Variables</b> :  n\u00e9ant\n \t * <p>\n \t * <b>Pr\u00e9requis</b> :  n\u00e9ant\n \t * <p>\n \t * <b>Pr\u00e9dicat</b> :  Les attributs ScheduledStopPointRef et QuayRef doivent \u00eatre renseign\u00e9s\n \t * <p>\n \t * <b>Message</b> :  {fichier}-Ligne {ligne}-Colonne {Colonne}, l'attribut {attribut requis} de l'objet PassengerStopAssignment {ObjectId} doit \u00eatre renseign\u00e9 \n \t * <p>\n \t * <b>Criticit\u00e9</b> :  error\n \t * <p>\n \t * \n \t *\n \t * @param context\n \t * @return\n \t */\n \tpublic boolean check2NeTExSTIFPassengerStopAssignment1(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber) {\n \t\tboolean result1 = stopAssignment.getScheduledStopPointRef() != null && !stopAssignment.getScheduledStopPointRef().isEmpty();\n \t\tboolean result2 = stopAssignment.getQuayRef() != null && !stopAssignment.getQuayRef().isEmpty();\n \t\tif (!result1)\n \t\t{\n\t\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\t\t\tString fileName = (String) context.get(Constant.FILE_NAME);\n\t\t\tLineLite line = (LineLite) context.get(Constant.LINE);\n\t\t\tDataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);\n\t\t\tvalidationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, \"ScheduledStopPointRef\");\n \t\t}\n \t\tif (!result2)\n \t\t{\n\t\t\tValidationReporter validationReporter = ValidationReporter.Factory.getInstance();\n\t\t\tString fileName = (String) context.get(Constant.FILE_NAME);\n\t\t\tLineLite line = (LineLite) context.get(Constant.LINE);\n\t\t\tDataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);\n\t\t\tvalidationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, \"QuayRef\");\n \t\t}\n \t\treturn result1 && result2;\n \t}\n"]], "pred": {"ppl": 1.5742521286010742, "ppl_lower": 2.152596950531006, "ppl/lowercase_ppl": -1.6895289692596007, "ppl/zlib": 0.0004620980860717118, "Min_5.0% Prob": 5.536173946717206, "Min_10.0% Prob": 3.7232583422286836, "Min_20.0% Prob": 2.185424644646107, "Min_30.0% Prob": 1.500110953449716, "Min_40.0% Prob": 1.1310643888281289, "Min_50.0% Prob": 0.9073385486849483, "Min_60.0% Prob": 0.7569934508097047}}
{"hexsha": "7d727698b89db5be38abe39efcac6f6e6a7eef7f", "ext": "java", "lang": "Java", "content": "public class Review implements Parcelable{\n    private String author;\n    private String content;\n    private String reivew_url;\n\n    public Review(String author, String content, String reivew_url) {\n        this.author = author;\n        this.content = content;\n        this.reivew_url = reivew_url;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public String getReivew_url() {\n        return reivew_url;\n    }\n\n    protected Review(Parcel in) {\n        author = in.readString();\n        content = in.readString();\n        reivew_url = in.readString();\n    }\n\n    public static final Creator<Review> CREATOR = new Creator<Review>() {\n        @Override\n        public Review createFromParcel(Parcel in) {\n            return new Review(in);\n        }\n\n        @Override\n        public Review[] newArray(int size) {\n            return new Review[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel parcel, int i) {\n        parcel.writeString(author);\n        parcel.writeString(content);\n        parcel.writeString(reivew_url);\n    }\n}", "class_id": 0, "repo": "emmaunel/Nanodegree-PopularMovie", "file": "app/src/main/java/com/wordpress/ayo218/popularmovie/model/Review.java", "last_update_at": "2018-05-21T00:10:32+00:00", "question_id": "7d727698b89db5be38abe39efcac6f6e6a7eef7f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Review implements Parcelable{\n    private String author;\n    private String content;\n    private String reivew_url;\n    public Review(String author, String content, String reivew_url) {\n        this.author = author;\n        this.content = content;\n        this.reivew_url = reivew_url;\n    }\n    public String getAuthor() {\n        return author;\n    }\n    public String getContent() {\n        return content;\n    }\n    public String getReivew_url() {\n        return reivew_url;\n    }\n    protected Review(Parcel in) {\n        author = in.readString();\n        content = in.readString();\n        reivew_url = in.readString();\n    }\n    public static final Creator<Review> CREATOR = new Creator<Review>() {\n        @Override\n        public Review createFromParcel(Parcel in) {\n            return new Review(in);\n        }\n        @Override\n        public Review[] newArray(int size) {\n            return new Review[size];\n        }\n    };\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n    @Override\n    public void writeToParcel(Parcel parcel, int i) {\n        parcel.writeString(author);\n        parcel.writeString(content);\n        parcel.writeString(reivew_url);\n    }\n"]], "pred": {"ppl": 1.184583067893982, "ppl_lower": 1.3419047594070435, "ppl/lowercase_ppl": -1.736162431532964, "ppl/zlib": 0.0004493126558002526, "Min_5.0% Prob": 3.1796178852810577, "Min_10.0% Prob": 1.6915745935269764, "Min_20.0% Prob": 0.8504572496159186, "Min_30.0% Prob": 0.5660911178973582, "Min_40.0% Prob": 0.4238793160819279, "Min_50.0% Prob": 0.3387175311400118, "Min_60.0% Prob": 0.2833481315827616}}
{"hexsha": "87145ddcc0b5a69c27069c7e3b5ba65821c9fc36", "ext": "java", "lang": "Java", "content": "public class NBTUtil {\n\n    public static final int TAG_END = 0;\n    public static final int TAG_BYTE = 1;\n    public static final int TAG_SHORT = 2;\n    public static final int TAG_INT = 3;\n    public static final int TAG_LONG = 4;\n    public static final int TAG_FLOAT = 5;\n    public static final int TAG_DOUBLE = 6;\n    public static final int TAG_BYTE_A = 7;\n    public static final int TAG_STRING = 8;\n    public static final int TAG_LIST = 9;\n    public static final int TAG_COMP = 10;\n    public static final int TAG_INT_A = 11;\n    public static final String ATTRIBS = \"attribs\";\n\n    private static final Field handle;\n    private static final boolean support;\n\n    static {\n        Field _handle = null;\n        boolean _support = false;\n        try {\n            _handle = CraftItemStack.class.getDeclaredField(\"handle\");\n            _handle.setAccessible(true);\n            _support = true;\n        } catch (Throwable ignored) {\n        }\n        handle = _handle;\n        support = _support;\n    }\n\n    public static void setTag(org.bukkit.inventory.ItemStack stack, NBTTagCompound tag) {\n        try {\n            ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).setTag(tag);\n        } catch (Throwable ignored) {\n        }\n    }\n\n    public static NBTTagCompound getOrCreateTag(ItemStack stack, String path) {\n        try {\n            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();\n            if (tag == null) {\n                tag = new NBTTagCompound();\n                setTag(stack, tag);\n            }\n            if (path != null && !path.isEmpty()) {\n                NBTTagCompound child = tag.getCompound(path);\n                tag.set(path, child);\n                return child;\n            }\n            return tag;\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return new NBTTagCompound();\n        }\n    }\n\n    public static NBTTagCompound getTag(ItemStack stack, String path) {\n        if (!(stack instanceof CraftItemStack)) {\n            stack = CraftItemStack.asCraftCopy(stack);\n        }\n        try {\n            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();\n            if (tag == null) return null;\n            if (path != null && !path.isEmpty()) {\n                NBTTagCompound child = tag.getCompound(path);\n                if (child == null) return null;\n                return child;\n            }\n            return tag;\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return new NBTTagCompound();\n        }\n    }\n\n    public static ItemAttrib getOrCreateAttrib(org.bukkit.inventory.ItemStack stack) {\n        NBTTagCompound tag = getOrCreateTag(stack, \"attrib\");\n        ItemAttrib attrib = new ItemAttrib();\n        attrib.globalId = tag.getInt(\"globalId\");\n        attrib.name = tag.getString(\"name\");\n        attrib.attack = tag.getInt(\"attack\");\n        attrib.critChance = tag.getFloat(\"critChance\");\n        attrib.walkspeed = tag.getFloat(\"walkspeed\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        attrib.dodgeChance = tag.getFloat(\"dodgeChance\");\n        attrib.suckRatio = tag.getFloat(\"suckRatio\");\n        attrib.fireChance = tag.getFloat(\"fireChance\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        return attrib;\n    }\n\n    public static ItemAttrib getAttrib(org.bukkit.inventory.ItemStack stack) {\n        NBTTagCompound tag = getTag(stack, \"attrib\");\n        if (tag == null || !tag.hasKey(\"active\")) return null;\n        ItemAttrib attrib = new ItemAttrib();\n        attrib.globalId = tag.getInt(\"globalId\");\n        attrib.name = tag.getString(\"name\");\n        attrib.attack = tag.getInt(\"attack\");\n        attrib.critChance = tag.getFloat(\"critChance\");\n        attrib.walkspeed = tag.getFloat(\"walkspeed\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        attrib.dodgeChance = tag.getFloat(\"dodgeChance\");\n        attrib.suckRatio = tag.getFloat(\"suckRatio\");\n        attrib.fireChance = tag.getFloat(\"fireChance\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        return attrib;\n    }\n\n    public static void offerAttrib(org.bukkit.inventory.ItemStack stack, ItemAttrib attrib) {\n        NBTTagCompound tag = getOrCreateTag(stack, \"attrib\");\n        tag.setInt(\"globalId\", attrib.globalId);\n        tag.setString(\"name\", attrib.name);\n        tag.setInt(\"attack\", attrib.attack);\n        tag.setFloat(\"critChance\", attrib.critChance);\n        tag.setFloat(\"walkspeed\", attrib.walkspeed);\n        tag.setFloat(\"blockChance\", attrib.blockChance);\n        tag.setFloat(\"dodgeChance\", attrib.dodgeChance);\n        tag.setFloat(\"suckRatio\", attrib.suckRatio);\n        tag.setFloat(\"fireChance\", attrib.fireChance);\n        tag.setFloat(\"blockChance\", attrib.blockChance);\n    }\n}", "class_id": 0, "repo": "Himmelt/ItemAttributes", "file": "src/main/java/org/soraworld/attrib/nbt/NBTUtil.java", "last_update_at": "2018-10-25T08:43:39+00:00", "question_id": "87145ddcc0b5a69c27069c7e3b5ba65821c9fc36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NBTUtil {\n    public static final int TAG_END = 0;\n    public static final int TAG_BYTE = 1;\n    public static final int TAG_SHORT = 2;\n    public static final int TAG_INT = 3;\n    public static final int TAG_LONG = 4;\n    public static final int TAG_FLOAT = 5;\n    public static final int TAG_DOUBLE = 6;\n    public static final int TAG_BYTE_A = 7;\n    public static final int TAG_STRING = 8;\n    public static final int TAG_LIST = 9;\n    public static final int TAG_COMP = 10;\n    public static final int TAG_INT_A = 11;\n    public static final String ATTRIBS = \"attribs\";\n    private static final Field handle;\n    private static final boolean support;\n    static {\n        Field _handle = null;\n        boolean _support = false;\n        try {\n            _handle = CraftItemStack.class.getDeclaredField(\"handle\");\n            _handle.setAccessible(true);\n            _support = true;\n        } catch (Throwable ignored) {\n        }\n        handle = _handle;\n        support = _support;\n    }\n    public static void setTag(org.bukkit.inventory.ItemStack stack, NBTTagCompound tag) {\n        try {\n            ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).setTag(tag);\n        } catch (Throwable ignored) {\n        }\n    }\n    public static NBTTagCompound getOrCreateTag(ItemStack stack, String path) {\n        try {\n            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();\n            if (tag == null) {\n                tag = new NBTTagCompound();\n                setTag(stack, tag);\n            }\n            if (path != null && !path.isEmpty()) {\n                NBTTagCompound child = tag.getCompound(path);\n                tag.set(path, child);\n                return child;\n            }\n            return tag;\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return new NBTTagCompound();\n        }\n    }\n    public static NBTTagCompound getTag(ItemStack stack, String path) {\n        if (!(stack instanceof CraftItemStack)) {\n            stack = CraftItemStack.asCraftCopy(stack);\n        }\n        try {\n            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();\n            if (tag == null) return null;\n            if (path != null && !path.isEmpty()) {\n                NBTTagCompound child = tag.getCompound(path);\n                if (child == null) return null;\n                return child;\n            }\n            return tag;\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return new NBTTagCompound();\n        }\n    }\n    public static ItemAttrib getOrCreateAttrib(org.bukkit.inventory.ItemStack stack) {\n        NBTTagCompound tag = getOrCreateTag(stack, \"attrib\");\n        ItemAttrib attrib = new ItemAttrib();\n        attrib.globalId = tag.getInt(\"globalId\");\n        attrib.name = tag.getString(\"name\");\n        attrib.attack = tag.getInt(\"attack\");\n        attrib.critChance = tag.getFloat(\"critChance\");\n        attrib.walkspeed = tag.getFloat(\"walkspeed\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        attrib.dodgeChance = tag.getFloat(\"dodgeChance\");\n        attrib.suckRatio = tag.getFloat(\"suckRatio\");\n        attrib.fireChance = tag.getFloat(\"fireChance\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        return attrib;\n    }\n    public static ItemAttrib getAttrib(org.bukkit.inventory.ItemStack stack) {\n        NBTTagCompound tag = getTag(stack, \"attrib\");\n        if (tag == null || !tag.hasKey(\"active\")) return null;\n        ItemAttrib attrib = new ItemAttrib();\n        attrib.globalId = tag.getInt(\"globalId\");\n        attrib.name = tag.getString(\"name\");\n        attrib.attack = tag.getInt(\"attack\");\n        attrib.critChance = tag.getFloat(\"critChance\");\n        attrib.walkspeed = tag.getFloat(\"walkspeed\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        attrib.dodgeChance = tag.getFloat(\"dodgeChance\");\n        attrib.suckRatio = tag.getFloat(\"suckRatio\");\n        attrib.fireChance = tag.getFloat(\"fireChance\");\n        attrib.blockChance = tag.getFloat(\"blockChance\");\n        return attrib;\n    }\n    public static void offerAttrib(org.bukkit.inventory.ItemStack stack, ItemAttrib attrib) {\n        NBTTagCompound tag = getOrCreateTag(stack, \"attrib\");\n        tag.setInt(\"globalId\", attrib.globalId);\n        tag.setString(\"name\", attrib.name);\n        tag.setInt(\"attack\", attrib.attack);\n        tag.setFloat(\"critChance\", attrib.critChance);\n        tag.setFloat(\"walkspeed\", attrib.walkspeed);\n        tag.setFloat(\"blockChance\", attrib.blockChance);\n        tag.setFloat(\"dodgeChance\", attrib.dodgeChance);\n        tag.setFloat(\"suckRatio\", attrib.suckRatio);\n        tag.setFloat(\"fireChance\", attrib.fireChance);\n        tag.setFloat(\"blockChance\", attrib.blockChance);\n    }\n"]], "pred": {"ppl": 1.4437354803085327, "ppl_lower": 1.6392393112182617, "ppl/lowercase_ppl": -1.3458245075817452, "ppl/zlib": 0.0003853450559372933, "Min_5.0% Prob": 5.103881055233526, "Min_10.0% Prob": 3.2988970057637084, "Min_20.0% Prob": 1.8039102432701517, "Min_30.0% Prob": 1.2206952456579683, "Min_40.0% Prob": 0.9169348591066496, "Min_50.0% Prob": 0.7347971277553843, "Min_60.0% Prob": 0.6127583412538992}}
{"hexsha": "0ee7fa3e3954616e13ad663536037c8fc0ebbbad", "ext": "java", "lang": "Java", "content": "public class DBRunner implements DocumentService{\n\t//Variables\n\tprivate ObjectContainer db = null;\n\tprivate List<Shingle> docs = new ArrayList<Shingle>();\n\t\n\t//Constructor\n\tpublic DBRunner(){\n\t\t\n\t\t//init(); //Populate the database\n\t\t\n\t\tEmbeddedConfiguration config = Db4oEmbedded.newConfiguration();\n\t\tconfig.common().add(new TransparentActivationSupport());\n\t\tconfig.common().add(new TransparentPersistenceSupport());\n\t\tconfig.common().updateDepth(7);\n\t\t\n\t\t//Use the XTea library to add encryption. The basic Db4O container only has a Caesar cypher \n\t\tconfig.file().storage(new XTeaEncryptionStorage(\"password\", XTEA.ITERATIONS64));\n\t\t\n\t\t//Open a local database. Use Db4o.openServer(config, server, port) for full client / server\n\t\tdb = Db4oEmbedded.openFile(config, \"docs.data\");\n\t\t\n\t\tcompareDoc();\n\t\tsaveDoc();\n\t\t\n\t\t\n\t}\n\t\n\t\n\tprivate void showAllShingles(){\n\t\t//An ObjectSet is a specialised List for storing results\n\t\tObjectSet<Shingle> shingles = db.query(Shingle.class);\n\t\tfor (Shingle shingle  : shingles){\n\t\t\t//out.print(\"[Shingle] \" + shingle.getShingleStr() + \"\\t ***Database ObjID: \" + db.ext().getID(shingle));\n\t\t\t\n\t\t\t\n\t\t\tdb.commit();\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew DBRunner();\n\t}\n\n\t@Override\n\tpublic void compareDoc() {\n\t\t//Jaccard..\n\t\t\n\t}\n\n\t@Override\n\tpublic void saveDoc() {\n\t\tfor (Shingle s: docs){\n\t\t\tdb.store(s); //Adds Shingle to db\n\t\t}\n\t\tdb.commit(); //Commits the tx\n\t\t//db.rollback(); //Rolls back the tx\n\t\t\n\t}\n\t\n\n}", "class_id": 0, "repo": "ianburkeixiv/JEE_DocumentSimilarity_App", "file": "DocumentSimilarityApp/src/ie/gmit/sw/DBRunner.java", "last_update_at": "2018-01-05T20:58:37+00:00", "question_id": "0ee7fa3e3954616e13ad663536037c8fc0ebbbad", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DBRunner implements DocumentService{\n\t//Variables\n\tprivate ObjectContainer db = null;\n\tprivate List<Shingle> docs = new ArrayList<Shingle>();\n\t\n\t//Constructor\n\tpublic DBRunner(){\n\t\t\n\t\t//init(); //Populate the database\n\t\t\n\t\tEmbeddedConfiguration config = Db4oEmbedded.newConfiguration();\n\t\tconfig.common().add(new TransparentActivationSupport());\n\t\tconfig.common().add(new TransparentPersistenceSupport());\n\t\tconfig.common().updateDepth(7);\n\t\t\n\t\t//Use the XTea library to add encryption. The basic Db4O container only has a Caesar cypher \n\t\tconfig.file().storage(new XTeaEncryptionStorage(\"password\", XTEA.ITERATIONS64));\n\t\t\n\t\t//Open a local database. Use Db4o.openServer(config, server, port) for full client / server\n\t\tdb = Db4oEmbedded.openFile(config, \"docs.data\");\n\t\t\n\t\tcompareDoc();\n\t\tsaveDoc();\n\t\t\n\t\t\n\t}\n\t\n\t\n\tprivate void showAllShingles(){\n\t\t//An ObjectSet is a specialised List for storing results\n\t\tObjectSet<Shingle> shingles = db.query(Shingle.class);\n\t\tfor (Shingle shingle  : shingles){\n\t\t\t//out.print(\"[Shingle] \" + shingle.getShingleStr() + \"\\t ***Database ObjID: \" + db.ext().getID(shingle));\n\t\t\t\n\t\t\t\n\t\t\tdb.commit();\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew DBRunner();\n\t}\n\t@Override\n\tpublic void compareDoc() {\n\t\t//Jaccard..\n\t\t\n\t}\n\t@Override\n\tpublic void saveDoc() {\n\t\tfor (Shingle s: docs){\n\t\t\tdb.store(s); //Adds Shingle to db\n\t\t}\n\t\tdb.commit(); //Commits the tx\n\t\t//db.rollback(); //Rolls back the tx\n\t\t\n\t}\n\t\n"]], "pred": {"ppl": 3.356675863265991, "ppl_lower": 4.0743937492370605, "ppl/lowercase_ppl": -1.1600153757764315, "ppl/zlib": 0.0016633944476096114, "Min_5.0% Prob": 8.346176571316189, "Min_10.0% Prob": 6.726824725757946, "Min_20.0% Prob": 4.849845890565352, "Min_30.0% Prob": 3.708560138398951, "Min_40.0% Prob": 2.937614579498768, "Min_50.0% Prob": 2.399646631154147, "Min_60.0% Prob": 2.0131330351260575}}
{"hexsha": "161d7ab3f0828279b18adbb04cf0eee98d9b751d", "ext": "java", "lang": "Java", "content": "public class UtilTest extends TestCase {\n    private VContext ctx;\n    private VContext dummyServerCtx;\n    private Endpoint dummyServerEndpoint;\n\n    @Override\n    protected void setUp() throws Exception {\n        ctx = V.init();\n        ctx = V.init();\n        dummyServerCtx = V23TestUtil.withDummyServer(ctx);\n        dummyServerEndpoint = V23TestUtil.getServerEndpoint(dummyServerCtx);\n        ctx = NamespaceTestUtil.withTestMountServer(ctx);\n    }\n\n    public void testListChildren() throws Exception {\n        Namespace n = V.getNamespace(ctx);\n        sync(n.mount(ctx, \"appblessing,database/userblessing,collection1\", dummyServerEndpoint.name(), Duration.standardDays(1)));\n        sync(n.mount(ctx, \"appblessing,database/userblessing,collection2\", dummyServerEndpoint.name(), Duration.standardDays(1)));\n        assertThat(sync(Util.listChildIds(ctx, \"appblessing,database\"))).containsExactly(new Id(\"userblessing\", \"collection1\"), new Id(\"userblessing\", \"collection2\"));\n    }\n\n    private static class FilterTagTestCase {\n        private Permissions input;\n        private Iterable<Tag> allowed;\n        private Permissions wanted;\n\n        private FilterTagTestCase(Permissions input, Iterable<Tag> allowed, Permissions wanted) {\n            this.input = input;\n            this.allowed = allowed;\n            this.wanted = wanted;\n        }\n    }\n\n    public void testFilterTags() {\n        List<FilterTagTestCase> filterTagTestCases = new ArrayList<>();\n        List<BlessingPattern> aclIn = new ArrayList<>();\n        aclIn.add(new BlessingPattern(\"alice\"));\n        aclIn.add(new BlessingPattern(\"bob\"));\n        aclIn.add(new BlessingPattern(\"carol\"));\n        List<String> aclNotIn = new ArrayList<>();\n        aclNotIn.add(\"alice:enemy\");\n        AccessList acl = new AccessList(aclIn, aclNotIn);\n\n        Map<String, AccessList> mapping = new HashMap<>();\n        mapping.put(Constants.DEBUG.getValue(), acl);\n        mapping.put(Constants.RESOLVE.getValue(), acl);\n        mapping.put(Constants.READ.getValue(), acl);\n        mapping.put(Constants.ADMIN.getValue(), acl);\n\n        Permissions canonicalPerms = new Permissions(mapping);\n\n        Map<String, AccessList> noDebugMapping = new HashMap<>(mapping);\n        noDebugMapping.remove(Constants.DEBUG.getValue());\n        Permissions noDebugPerms = new Permissions(noDebugMapping);\n        Set<Tag> noDebugTags = new HashSet<>();\n        Collections.addAll(noDebugTags, Constants.RESOLVE, Constants.READ, Constants.WRITE,\n                Constants.ADMIN);\n\n        Map<String, AccessList> noResolveReadMapping = new HashMap<>(mapping);\n        noResolveReadMapping.remove(Constants.RESOLVE.getValue());\n        noResolveReadMapping.remove(Constants.READ.getValue());\n        Permissions noResolveReadPerms = new Permissions(noResolveReadMapping);\n        List<Tag> noResolveReadTags = new ArrayList<>();\n        Collections.addAll(noResolveReadTags, Constants.DEBUG, Constants.WRITE, Constants.ADMIN);\n\n        List<Tag> allTags = new ArrayList<>();\n        Collections.addAll(allTags, Constants.DEBUG, Constants.RESOLVE, Constants.READ,\n                Constants.WRITE, Constants.ADMIN);\n\n        filterTagTestCases.add(new FilterTagTestCase(new Permissions(), new ArrayList<Tag>(),\n                new Permissions()));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, new HashSet<Tag>(),\n                new Permissions()));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noDebugTags, noDebugPerms));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noResolveReadTags,\n                noResolveReadPerms));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, allTags, canonicalPerms));\n\n        // Confirm that things match up correctly.\n        for (FilterTagTestCase test : filterTagTestCases) {\n            Permissions actualPerms = Util.filterPermissionsByTags(test.input, test.allowed);\n            assertEquals(actualPerms, test.wanted);\n\n            // Confirm the filtered version is independent from the original.\n            Permissions origPerms = test.input;\n            String adminStr = Constants.ADMIN.getValue();\n            if (actualPerms.get(adminStr) != null) {\n                List<BlessingPattern> actualIn = actualPerms.get(adminStr).getIn();\n                List<BlessingPattern> origIn = origPerms.get(adminStr).getIn();\n\n                // It's possible that the admin access list is the same reference instead of copied.\n                // Confirm equality. Change the admin access list. Then confirm inequality.\n                assertEquals(actualIn, origIn);\n                actualIn.clear();\n                assertFalse(actualIn.equals(origIn));\n            }\n\n        }\n    }\n}", "class_id": 0, "repo": "vanadium-archive/java", "file": "lib/src/test/java/io/v/v23/syncbase/util/UtilTest.java", "last_update_at": "2018-02-22T13:08:39+00:00", "question_id": "161d7ab3f0828279b18adbb04cf0eee98d9b751d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UtilTest extends TestCase {\n    private VContext ctx;\n    private VContext dummyServerCtx;\n    private Endpoint dummyServerEndpoint;\n    @Override\n    protected void setUp() throws Exception {\n        ctx = V.init();\n        ctx = V.init();\n        dummyServerCtx = V23TestUtil.withDummyServer(ctx);\n        dummyServerEndpoint = V23TestUtil.getServerEndpoint(dummyServerCtx);\n        ctx = NamespaceTestUtil.withTestMountServer(ctx);\n    }\n    public void testListChildren() throws Exception {\n        Namespace n = V.getNamespace(ctx);\n        sync(n.mount(ctx, \"appblessing,database/userblessing,collection1\", dummyServerEndpoint.name(), Duration.standardDays(1)));\n        sync(n.mount(ctx, \"appblessing,database/userblessing,collection2\", dummyServerEndpoint.name(), Duration.standardDays(1)));\n        assertThat(sync(Util.listChildIds(ctx, \"appblessing,database\"))).containsExactly(new Id(\"userblessing\", \"collection1\"), new Id(\"userblessing\", \"collection2\"));\n    }\n    private static class FilterTagTestCase {\n        private Permissions input;\n        private Iterable<Tag> allowed;\n        private Permissions wanted;\n        private FilterTagTestCase(Permissions input, Iterable<Tag> allowed, Permissions wanted) {\n            this.input = input;\n            this.allowed = allowed;\n            this.wanted = wanted;\n        }\n    }\n    public void testFilterTags() {\n        List<FilterTagTestCase> filterTagTestCases = new ArrayList<>();\n        List<BlessingPattern> aclIn = new ArrayList<>();\n        aclIn.add(new BlessingPattern(\"alice\"));\n        aclIn.add(new BlessingPattern(\"bob\"));\n        aclIn.add(new BlessingPattern(\"carol\"));\n        List<String> aclNotIn = new ArrayList<>();\n        aclNotIn.add(\"alice:enemy\");\n        AccessList acl = new AccessList(aclIn, aclNotIn);\n        Map<String, AccessList> mapping = new HashMap<>();\n        mapping.put(Constants.DEBUG.getValue(), acl);\n        mapping.put(Constants.RESOLVE.getValue(), acl);\n        mapping.put(Constants.READ.getValue(), acl);\n        mapping.put(Constants.ADMIN.getValue(), acl);\n        Permissions canonicalPerms = new Permissions(mapping);\n        Map<String, AccessList> noDebugMapping = new HashMap<>(mapping);\n        noDebugMapping.remove(Constants.DEBUG.getValue());\n        Permissions noDebugPerms = new Permissions(noDebugMapping);\n        Set<Tag> noDebugTags = new HashSet<>();\n        Collections.addAll(noDebugTags, Constants.RESOLVE, Constants.READ, Constants.WRITE,\n                Constants.ADMIN);\n        Map<String, AccessList> noResolveReadMapping = new HashMap<>(mapping);\n        noResolveReadMapping.remove(Constants.RESOLVE.getValue());\n        noResolveReadMapping.remove(Constants.READ.getValue());\n        Permissions noResolveReadPerms = new Permissions(noResolveReadMapping);\n        List<Tag> noResolveReadTags = new ArrayList<>();\n        Collections.addAll(noResolveReadTags, Constants.DEBUG, Constants.WRITE, Constants.ADMIN);\n        List<Tag> allTags = new ArrayList<>();\n        Collections.addAll(allTags, Constants.DEBUG, Constants.RESOLVE, Constants.READ,\n                Constants.WRITE, Constants.ADMIN);\n        filterTagTestCases.add(new FilterTagTestCase(new Permissions(), new ArrayList<Tag>(),\n                new Permissions()));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, new HashSet<Tag>(),\n                new Permissions()));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noDebugTags, noDebugPerms));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noResolveReadTags,\n                noResolveReadPerms));\n        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, allTags, canonicalPerms));\n        // Confirm that things match up correctly.\n        for (FilterTagTestCase test : filterTagTestCases) {\n            Permissions actualPerms = Util.filterPermissionsByTags(test.input, test.allowed);\n            assertEquals(actualPerms, test.wanted);\n            // Confirm the filtered version is independent from the original.\n            Permissions origPerms = test.input;\n            String adminStr = Constants.ADMIN.getValue();\n            if (actualPerms.get(adminStr) != null) {\n                List<BlessingPattern> actualIn = actualPerms.get(adminStr).getIn();\n                List<BlessingPattern> origIn = origPerms.get(adminStr).getIn();\n                // It's possible that the admin access list is the same reference instead of copied.\n                // Confirm equality. Change the admin access list. Then confirm inequality.\n                assertEquals(actualIn, origIn);\n                actualIn.clear();\n                assertFalse(actualIn.equals(origIn));\n            }\n        }\n    }\n"]], "pred": {"ppl": 1.9302207231521606, "ppl_lower": 2.197053909301758, "ppl/lowercase_ppl": -1.196892038831262, "ppl/zlib": 0.0005386030800206695, "Min_5.0% Prob": 7.036674798703661, "Min_10.0% Prob": 5.1304827835045606, "Min_20.0% Prob": 3.1048249606700504, "Min_30.0% Prob": 2.164351966207713, "Min_40.0% Prob": 1.6378923594441566, "Min_50.0% Prob": 1.3149378889927426, "Min_60.0% Prob": 1.0971178619519977}}
{"hexsha": "57ba7c5affc3bea5b2ee8f3766f262bcedca7d78", "ext": "java", "lang": "Java", "content": "@Component\npublic class SavingsPotentialComputeTask extends BaseTask implements StoppableTasklet {\n\n    /**\n     * Service for accessing savings potential scenario data.\n     */\n    @Autowired\n    private ISavingsPotentialService savingsPotentialService;\n\n    /**\n     * Repository for updating savings potential scenario data.\n     */\n    @Autowired\n    private ISavingsPotentialRepository savingsPotentialRepository;\n\n    /**\n     * Repository for accessing utility data.\n     */\n    @Autowired\n    private IUtilityRepository utilityRepository;\n\n    /**\n     * Repository for accessing user data.\n     */\n    @Autowired\n    private IUserRepository userRepository;\n\n    /**\n     * Service for querying user consumption data.\n     */\n    @Autowired\n    private IDataService dataService;\n\n    @Override\n    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {\n        try {\n            Map<String, String> parameters = getStepParameters(chunkContext.getStepContext());\n\n            // Get scenario\n            if(StringUtils.isBlank(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()))) {\n                return RepeatStatus.FINISHED;\n            }\n\n            UUID scenarioKey = UUID.fromString(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()));\n            SavingScenario scenario = savingsPotentialService.find(scenarioKey);\n\n            // Get utility\n            UtilityInfo utility = utilityRepository.getUtilityByKey(scenario.getUtilityKey());\n\n            // Get scenario results\n            SavingResultStore resultStore = new SavingResultStore();\n            for(SavingsPotentialResultEntity result : savingsPotentialService.getScenarioResults(scenario.getKey())) {\n                resultStore.add(result.getMonth(), result.getSerial(), result.getSavingsVolume() / (double) result.getClusterSize());\n            }\n\n            // Compute date interval\n            DateTimeZone timezone = DateTimeZone.forID(utility.getTimezone());\n\n            DateTime begin = new DateTime(scenario.getParameters().getTime().getStart(), timezone);\n            begin = begin.dayOfMonth().withMinimumValue()\n                         .hourOfDay().setCopy(0).minuteOfHour().setCopy(0).secondOfMinute().setCopy(0).millisOfSecond().setCopy(0);\n\n            DateTime end = new DateTime(scenario.getParameters().getTime().getEnd(), timezone);\n            end = end.dayOfMonth().withMaximumValue()\n                     .hourOfDay().setCopy(23).minuteOfHour().setCopy(59).secondOfMinute().setCopy(59).millisOfSecond().setCopy(999);\n\n            // Compute savings per user\n            double scenarioConsumption = 0;\n            double scenarioSavings = 0;\n\n            Map<String, UUID> serialToUserMap = new HashMap<String, UUID>();\n            Map<UUID, AccountSavings> savingsStore = new HashMap<UUID, AccountSavings>();\n\n            while(begin.isBefore(end)) {\n                int year = begin.getYear();\n                int month = begin.getMonthOfYear();\n\n                Map<String, SavingResult> monthlyResults = resultStore.results.get(month);\n\n                if(monthlyResults == null) {\n                    begin = begin.plusMonths(1);\n                    continue;\n                }\n\n                for (SavingResult consumer : monthlyResults.values()) {\n                    // Resolve user key and cache it\n                    UUID userKey = serialToUserMap.get(consumer.serial);\n                    if(userKey == null) {\n                        AccountEntity account = userRepository.getUserByMeterSerial(consumer.serial);\n                        if(account == null) {\n                            continue;\n                        }\n                        userKey = account.getKey();\n                        serialToUserMap.put(consumer.serial, userKey);\n                    }\n\n                    DataQuery query = DataQueryBuilder.create()\n                                                      .timezone(timezone)\n                                                      .absolute(begin, begin.dayOfMonth().withMaximumValue(), EnumTimeAggregation.MONTH)\n                                                      .user(consumer.serial, userKey)\n                                                      .meter()\n                                                      .userAggregates()\n                                                      .sum()\n                                                      .build();\n                    DataQueryResponse result = dataService.execute(query);\n                    if(result.getMeters().isEmpty()) {\n                        continue;\n                    }\n\n                    for (DataPoint point : result.getMeters().get(0).getPoints()) {\n                        MeterDataPoint meterPoint = (MeterDataPoint) point;\n                        DateTime instant = new DateTime(meterPoint.getTimestamp(), timezone);\n\n                        if ((instant.getYear() == year) && (instant.getMonthOfYear() == month)) {\n                            AccountSavings s = savingsStore.get(userKey);\n                            if (s == null) {\n                                s = new AccountSavings();\n                                s.userKey = userKey;\n                                savingsStore.put(userKey, s);\n                            }\n\n                            s.totalConsumption += meterPoint.getVolume().get(EnumMetric.SUM);\n                            s.totalSavings += consumer.userMonthlyPotential;\n\n                            scenarioConsumption += meterPoint.getVolume().get(EnumMetric.SUM);\n                            scenarioSavings += consumer.userMonthlyPotential;\n\n                            continue;\n                        }\n                    }\n                }\n\n                begin = begin.plusMonths(1);\n            }\n\n            // Update store\n            for (AccountSavings s : savingsStore.values()) {\n                savingsPotentialRepository.updateSavingConsumer(scenarioKey,\n                                                                s.userKey,\n                                                                s.totalConsumption,\n                                                                s.totalSavings,\n                                                                DateTime.now());\n            }\n\n            savingsPotentialRepository.updateSavingScenario(scenarioKey,\n                                                            scenarioConsumption,\n                                                            scenarioSavings,\n                                                            DateTime.now(),\n                                                            savingsStore.size());\n\n        } catch (Throwable t) {\n            throw wrapApplicationException(t, SchedulerErrorCode.SCHEDULER_JOB_STEP_FAILED).set(\"step\", chunkContext.getStepContext().getStepName());\n        }\n\n        return RepeatStatus.FINISHED;\n    }\n\n    @Override\n    public void stop() {\n        // TODO: Add business logic for stopping processing\n    }\n\n    /**\n     * Enumeration of job input parameters.\n     */\n    public static enum EnumInParameter {\n        /**\n         * Savings potential scenario key.\n         */\n        SCENARIO_KEY(\"scenario.key\");\n\n\n        private final String value;\n\n        public String getValue() {\n            return value;\n        }\n\n        private EnumInParameter(String value) {\n            this.value = value;\n        }\n    }\n\n    private static class SavingResultStore {\n\n        public Map<Integer, Map<String, SavingResult>> results = new HashMap<Integer, Map<String, SavingResult>>();\n\n        public void add(int month, String serial, double userMonthlyPotential) {\n            Map<String, SavingResult> monthlySavings = results.get(month);\n            if (monthlySavings == null) {\n                monthlySavings = new HashMap<String, SavingResult>();\n                results.put(month, monthlySavings);\n            }\n            monthlySavings.put(serial, new SavingResult(serial, userMonthlyPotential));\n        }\n    }\n\n    private static class SavingResult {\n\n        public String serial;\n\n        public double userMonthlyPotential;\n\n        public SavingResult(String serial, double userMonthlyPotential) {\n            this.serial = serial;\n            this.userMonthlyPotential = userMonthlyPotential;\n        }\n    }\n\n    private static class AccountSavings {\n\n        public UUID userKey;\n\n        public double totalConsumption = 0;\n\n        public double totalSavings = 0;\n    }\n}", "class_id": 0, "repo": "DAIAD/home-web", "file": "scheduler/src/main/java/eu/daiad/scheduler/job/task/SavingsPotentialComputeTask.java", "last_update_at": "2018-10-02T18:54:47+00:00", "question_id": "57ba7c5affc3bea5b2ee8f3766f262bcedca7d78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class SavingsPotentialComputeTask extends BaseTask implements StoppableTasklet {\n    /**\n     * Service for accessing savings potential scenario data.\n     */\n    @Autowired\n    private ISavingsPotentialService savingsPotentialService;\n    /**\n     * Repository for updating savings potential scenario data.\n     */\n    @Autowired\n    private ISavingsPotentialRepository savingsPotentialRepository;\n    /**\n     * Repository for accessing utility data.\n     */\n    @Autowired\n    private IUtilityRepository utilityRepository;\n    /**\n     * Repository for accessing user data.\n     */\n    @Autowired\n    private IUserRepository userRepository;\n    /**\n     * Service for querying user consumption data.\n     */\n    @Autowired\n    private IDataService dataService;\n    @Override\n    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {\n        try {\n            Map<String, String> parameters = getStepParameters(chunkContext.getStepContext());\n            // Get scenario\n            if(StringUtils.isBlank(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()))) {\n                return RepeatStatus.FINISHED;\n            }\n            UUID scenarioKey = UUID.fromString(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()));\n            SavingScenario scenario = savingsPotentialService.find(scenarioKey);\n            // Get utility\n            UtilityInfo utility = utilityRepository.getUtilityByKey(scenario.getUtilityKey());\n            // Get scenario results\n            SavingResultStore resultStore = new SavingResultStore();\n            for(SavingsPotentialResultEntity result : savingsPotentialService.getScenarioResults(scenario.getKey())) {\n                resultStore.add(result.getMonth(), result.getSerial(), result.getSavingsVolume() / (double) result.getClusterSize());\n            }\n            // Compute date interval\n            DateTimeZone timezone = DateTimeZone.forID(utility.getTimezone());\n            DateTime begin = new DateTime(scenario.getParameters().getTime().getStart(), timezone);\n            begin = begin.dayOfMonth().withMinimumValue()\n                         .hourOfDay().setCopy(0).minuteOfHour().setCopy(0).secondOfMinute().setCopy(0).millisOfSecond().setCopy(0);\n            DateTime end = new DateTime(scenario.getParameters().getTime().getEnd(), timezone);\n            end = end.dayOfMonth().withMaximumValue()\n                     .hourOfDay().setCopy(23).minuteOfHour().setCopy(59).secondOfMinute().setCopy(59).millisOfSecond().setCopy(999);\n            // Compute savings per user\n            double scenarioConsumption = 0;\n            double scenarioSavings = 0;\n            Map<String, UUID> serialToUserMap = new HashMap<String, UUID>();\n            Map<UUID, AccountSavings> savingsStore = new HashMap<UUID, AccountSavings>();\n            while(begin.isBefore(end)) {\n                int year = begin.getYear();\n                int month = begin.getMonthOfYear();\n                Map<String, SavingResult> monthlyResults = resultStore.results.get(month);\n                if(monthlyResults == null) {\n                    begin = begin.plusMonths(1);\n                    continue;\n                }\n                for (SavingResult consumer : monthlyResults.values()) {\n                    // Resolve user key and cache it\n                    UUID userKey = serialToUserMap.get(consumer.serial);\n                    if(userKey == null) {\n                        AccountEntity account = userRepository.getUserByMeterSerial(consumer.serial);\n                        if(account == null) {\n                            continue;\n                        }\n                        userKey = account.getKey();\n                        serialToUserMap.put(consumer.serial, userKey);\n                    }\n                    DataQuery query = DataQueryBuilder.create()\n                                                      .timezone(timezone)\n                                                      .absolute(begin, begin.dayOfMonth().withMaximumValue(), EnumTimeAggregation.MONTH)\n                                                      .user(consumer.serial, userKey)\n                                                      .meter()\n                                                      .userAggregates()\n                                                      .sum()\n                                                      .build();\n                    DataQueryResponse result = dataService.execute(query);\n                    if(result.getMeters().isEmpty()) {\n                        continue;\n                    }\n                    for (DataPoint point : result.getMeters().get(0).getPoints()) {\n                        MeterDataPoint meterPoint = (MeterDataPoint) point;\n                        DateTime instant = new DateTime(meterPoint.getTimestamp(), timezone);\n                        if ((instant.getYear() == year) && (instant.getMonthOfYear() == month)) {\n                            AccountSavings s = savingsStore.get(userKey);\n                            if (s == null) {\n                                s = new AccountSavings();\n                                s.userKey = userKey;\n                                savingsStore.put(userKey, s);\n                            }\n                            s.totalConsumption += meterPoint.getVolume().get(EnumMetric.SUM);\n                            s.totalSavings += consumer.userMonthlyPotential;\n                            scenarioConsumption += meterPoint.getVolume().get(EnumMetric.SUM);\n                            scenarioSavings += consumer.userMonthlyPotential;\n                            continue;\n                        }\n                    }\n                }\n                begin = begin.plusMonths(1);\n            }\n            // Update store\n            for (AccountSavings s : savingsStore.values()) {\n                savingsPotentialRepository.updateSavingConsumer(scenarioKey,\n                                                                s.userKey,\n                                                                s.totalConsumption,\n                                                                s.totalSavings,\n                                                                DateTime.now());\n            }\n            savingsPotentialRepository.updateSavingScenario(scenarioKey,\n                                                            scenarioConsumption,\n                                                            scenarioSavings,\n                                                            DateTime.now(),\n                                                            savingsStore.size());\n        } catch (Throwable t) {\n            throw wrapApplicationException(t, SchedulerErrorCode.SCHEDULER_JOB_STEP_FAILED).set(\"step\", chunkContext.getStepContext().getStepName());\n        }\n        return RepeatStatus.FINISHED;\n    }\n    @Override\n    public void stop() {\n        // TODO: Add business logic for stopping processing\n    }\n    /**\n     * Enumeration of job input parameters.\n     */\n    public static enum EnumInParameter {\n        /**\n         * Savings potential scenario key.\n         */\n        SCENARIO_KEY(\"scenario.key\");\n        private final String value;\n        public String getValue() {\n            return value;\n        }\n        private EnumInParameter(String value) {\n            this.value = value;\n        }\n    }\n    private static class SavingResultStore {\n        public Map<Integer, Map<String, SavingResult>> results = new HashMap<Integer, Map<String, SavingResult>>();\n        public void add(int month, String serial, double userMonthlyPotential) {\n            Map<String, SavingResult> monthlySavings = results.get(month);\n            if (monthlySavings == null) {\n                monthlySavings = new HashMap<String, SavingResult>();\n                results.put(month, monthlySavings);\n            }\n            monthlySavings.put(serial, new SavingResult(serial, userMonthlyPotential));\n        }\n    }\n    private static class SavingResult {\n        public String serial;\n        public double userMonthlyPotential;\n        public SavingResult(String serial, double userMonthlyPotential) {\n            this.serial = serial;\n            this.userMonthlyPotential = userMonthlyPotential;\n        }\n    }\n    private static class AccountSavings {\n        public UUID userKey;\n        public double totalConsumption = 0;\n        public double totalSavings = 0;\n    }\n"]], "pred": {"ppl": 1.9860107898712158, "ppl_lower": 2.4046409130096436, "ppl/lowercase_ppl": -1.2787709956640245, "ppl/zlib": 0.00033849432588781196, "Min_5.0% Prob": 6.679437618629605, "Min_10.0% Prob": 4.931633661775028, "Min_20.0% Prob": 3.167099977240843, "Min_30.0% Prob": 2.2498558685183525, "Min_40.0% Prob": 1.7077230060322797, "Min_50.0% Prob": 1.3714622032797645, "Min_60.0% Prob": 1.1444550917102525}}
{"hexsha": "cdae97cbc5d2b38426ba0868ed3192b9560aceb3", "ext": "java", "lang": "Java", "content": "public class ImageGifLoaderInstance {\n\n    public static final String TAG = ImageGifLoaderInstance.class.getSimpleName();\n\n    private ImageLoader mImageLoader;\n\n    private GifLoader mGifLoader;\n\n    private Map<String, String> headers;\n\n    private static ImageGifLoaderInstance instance;\n\n    private HttpRequestFactory httpRequestFactory;\n\n    private String token;\n\n    public ImageGifLoaderInstance(HttpRequestFactory httpRequestFactory) {\n        this.httpRequestFactory = httpRequestFactory;\n    }\n\n    public static ImageGifLoaderInstance getInstance(HttpRequestFactory httpRequestFactory) {\n\n        if (instance == null)\n            instance = new ImageGifLoaderInstance(httpRequestFactory);\n\n        return instance;\n    }\n\n    public static void destroyInstance() {\n\n        Log.d(TAG, \"destroyInstance: \");\n\n        instance = null;\n    }\n\n    public void setToken(String token) {\n\n        Log.d(TAG, \"setToken: \" + token);\n\n        this.token = token;\n\n        if (mImageLoader != null) {\n\n            Log.d(TAG, \"setToken: create header\");\n\n            createHeader();\n\n            mImageLoader.setHeaders(headers);\n\n            if (mGifLoader != null) {\n                mGifLoader.setHeaders(headers);\n            }\n\n        }\n\n    }\n\n    public ImageLoader getImageLoader(Context context) {\n\n        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();\n        mImageLoader = new ImageLoader(mRequestQueue, ImageLruCache.instance());\n\n        Log.d(TAG, \"getImageLoader: create header\");\n\n        createHeader();\n\n        mImageLoader.setHeaders(headers);\n\n        return mImageLoader;\n\n    }\n\n    private void createHeader() {\n        headers = new ArrayMap<>();\n\n        String token = httpRequestFactory.getTokenForHeaderValue();\n\n        headers.put(Util.KEY_AUTHORIZATION, token);\n        Log.i(TAG, \"FNAS JWT: \" + token);\n    }\n\n    public GifLoader getGifLoader(Context context) {\n\n        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();\n        mGifLoader = new GifLoader(mRequestQueue, GifLruCache.instance());\n\n        Log.d(TAG, \"getGifLoader: create header\");\n\n        createHeader();\n\n        mImageLoader.setHeaders(headers);\n\n        return mGifLoader;\n\n    }\n\n}", "class_id": 0, "repo": "winsuntech/fruitmix.android", "file": "app/src/main/java/com/winsun/fruitmix/http/ImageGifLoaderInstance.java", "last_update_at": "2018-07-11T07:55:41+00:00", "question_id": "cdae97cbc5d2b38426ba0868ed3192b9560aceb3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ImageGifLoaderInstance {\n    public static final String TAG = ImageGifLoaderInstance.class.getSimpleName();\n    private ImageLoader mImageLoader;\n    private GifLoader mGifLoader;\n    private Map<String, String> headers;\n    private static ImageGifLoaderInstance instance;\n    private HttpRequestFactory httpRequestFactory;\n    private String token;\n    public ImageGifLoaderInstance(HttpRequestFactory httpRequestFactory) {\n        this.httpRequestFactory = httpRequestFactory;\n    }\n    public static ImageGifLoaderInstance getInstance(HttpRequestFactory httpRequestFactory) {\n        if (instance == null)\n            instance = new ImageGifLoaderInstance(httpRequestFactory);\n        return instance;\n    }\n    public static void destroyInstance() {\n        Log.d(TAG, \"destroyInstance: \");\n        instance = null;\n    }\n    public void setToken(String token) {\n        Log.d(TAG, \"setToken: \" + token);\n        this.token = token;\n        if (mImageLoader != null) {\n            Log.d(TAG, \"setToken: create header\");\n            createHeader();\n            mImageLoader.setHeaders(headers);\n            if (mGifLoader != null) {\n                mGifLoader.setHeaders(headers);\n            }\n        }\n    }\n    public ImageLoader getImageLoader(Context context) {\n        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();\n        mImageLoader = new ImageLoader(mRequestQueue, ImageLruCache.instance());\n        Log.d(TAG, \"getImageLoader: create header\");\n        createHeader();\n        mImageLoader.setHeaders(headers);\n        return mImageLoader;\n    }\n    private void createHeader() {\n        headers = new ArrayMap<>();\n        String token = httpRequestFactory.getTokenForHeaderValue();\n        headers.put(Util.KEY_AUTHORIZATION, token);\n        Log.i(TAG, \"FNAS JWT: \" + token);\n    }\n    public GifLoader getGifLoader(Context context) {\n        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();\n        mGifLoader = new GifLoader(mRequestQueue, GifLruCache.instance());\n        Log.d(TAG, \"getGifLoader: create header\");\n        createHeader();\n        mImageLoader.setHeaders(headers);\n        return mGifLoader;\n    }\n"]], "pred": {"ppl": 1.759663701057434, "ppl_lower": 1.9643113613128662, "ppl/lowercase_ppl": -1.1946816461033878, "ppl/zlib": 0.0009660217296538689, "Min_5.0% Prob": 5.916333690766366, "Min_10.0% Prob": 4.161993007506093, "Min_20.0% Prob": 2.6009751606372093, "Min_30.0% Prob": 1.8457391387031925, "Min_40.0% Prob": 1.4016308993041275, "Min_50.0% Prob": 1.1285774190445996, "Min_60.0% Prob": 0.9429724298956886}}
{"hexsha": "f90c99c54877be6bdeb238b60c068c41ff7f9894", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class LessVariableOptionsBuilderTest {\n\n    @Spy\n    private LessVariableOptionsBuilder builder;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void append_mapIsNull_throwsException() {\n        builder.append((Map<String, String>) null);\n    }\n\n    @Test\n    public void append_mapIsNotNull_variablesAreAdded() {\n        final Map<String, String> variables = new LinkedHashMap<>();\n        variables.put(\"name1\", \"value1\");\n        variables.put(\"name2\", \"value2\");\n\n        final LessVariableOptionsBuilder result = builder.append(variables);\n\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(\"name1\", \"value1\");\n        verify(builder).append(\"name2\", \"value2\");\n        assertThat(builder.getVariables()).containsExactly(new LessVariableOption(\"name1\", \"value1\"),\n                new LessVariableOption(\"name2\", \"value2\"));\n    }\n\n    @Test\n    public void append_nameIsValue_variableIsAdded() {\n        final LessVariableOptionsBuilder result = builder.append(\"name\", \"value\");\n\n        assertThat(result).isSameAs(builder);\n        assertThat(builder.getVariables()).containsExactly(new LessVariableOption(\"name\", \"value\"));\n\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void append_iterableIsNull_throwsException() {\n        builder.append((Iterable<LessVariableOption>) null);\n    }\n\n    @Test\n    public void append_iterableIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable1 = new LessVariableOption(\"name1\", \"value1\");\n        final LessVariableOption variable2 = new LessVariableOption(\"name2\", \"value2\");\n\n        final LessVariableOptionsBuilder result = builder.append(Arrays.asList(variable1, variable2));\n\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(variable1);\n        verify(builder).append(variable2);\n        assertThat(builder.getVariables()).containsExactly(variable1, variable2);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void append_arrayIsNull_throwsException() {\n        builder.append((LessVariableOption[]) null);\n    }\n\n    @Test\n    public void append_arrayIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable1 = new LessVariableOption(\"name1\", \"value1\");\n        final LessVariableOption variable2 = new LessVariableOption(\"name2\", \"value2\");\n\n        final LessVariableOptionsBuilder result = builder.append(new LessVariableOption[] { variable1, variable2 });\n\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(variable1);\n        verify(builder).append(variable2);\n        assertThat(builder.getVariables()).containsExactly(variable1, variable2);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void append_variableIsNull_throwsException() {\n        builder.append((LessVariableOption) null);\n    }\n\n    @Test\n    public void append_variableIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable = new LessVariableOption(\"name\", \"value\");\n\n        final LessVariableOptionsBuilder result = builder.append(variable);\n\n        assertThat(result).isSameAs(builder);\n        assertThat(builder.getVariables()).containsExactly(variable);\n    }\n\n    @Test\n    public void build() {\n        final Map<String, String> variablesMap = new LinkedHashMap<>();\n        variablesMap.put(\"name1\", \"value1\");\n        variablesMap.put(\"name2\", \"value2\");\n\n        final List<LessVariableOption> variables = builder //\n                .append(variablesMap) //\n                .append(\"name3\", \"value3\") //\n                .append(new LessVariableOption(\"name2\", \"value4\")) //\n                .build();\n\n        assertThat(variables).containsExactly(//\n                new LessVariableOption(\"name1\", \"value1\"), //\n                new LessVariableOption(\"name2\", \"value2\"), //\n                new LessVariableOption(\"name3\", \"value3\"), //\n                new LessVariableOption(\"name2\", \"value4\"));\n    }\n}", "class_id": 0, "repo": "gabrysbiz/lesscss-compiler", "file": "src/test/java/biz/gabrys/lesscss/compiler2/LessVariableOptionsBuilderTest.java", "last_update_at": "2018-07-31T02:26:51+00:00", "question_id": "f90c99c54877be6bdeb238b60c068c41ff7f9894", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class LessVariableOptionsBuilderTest {\n    @Spy\n    private LessVariableOptionsBuilder builder;\n    @Test(expected = IllegalArgumentException.class)\n    public void append_mapIsNull_throwsException() {\n        builder.append((Map<String, String>) null);\n    }\n    @Test\n    public void append_mapIsNotNull_variablesAreAdded() {\n        final Map<String, String> variables = new LinkedHashMap<>();\n        variables.put(\"name1\", \"value1\");\n        variables.put(\"name2\", \"value2\");\n        final LessVariableOptionsBuilder result = builder.append(variables);\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(\"name1\", \"value1\");\n        verify(builder).append(\"name2\", \"value2\");\n        assertThat(builder.getVariables()).containsExactly(new LessVariableOption(\"name1\", \"value1\"),\n                new LessVariableOption(\"name2\", \"value2\"));\n    }\n    @Test\n    public void append_nameIsValue_variableIsAdded() {\n        final LessVariableOptionsBuilder result = builder.append(\"name\", \"value\");\n        assertThat(result).isSameAs(builder);\n        assertThat(builder.getVariables()).containsExactly(new LessVariableOption(\"name\", \"value\"));\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void append_iterableIsNull_throwsException() {\n        builder.append((Iterable<LessVariableOption>) null);\n    }\n    @Test\n    public void append_iterableIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable1 = new LessVariableOption(\"name1\", \"value1\");\n        final LessVariableOption variable2 = new LessVariableOption(\"name2\", \"value2\");\n        final LessVariableOptionsBuilder result = builder.append(Arrays.asList(variable1, variable2));\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(variable1);\n        verify(builder).append(variable2);\n        assertThat(builder.getVariables()).containsExactly(variable1, variable2);\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void append_arrayIsNull_throwsException() {\n        builder.append((LessVariableOption[]) null);\n    }\n    @Test\n    public void append_arrayIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable1 = new LessVariableOption(\"name1\", \"value1\");\n        final LessVariableOption variable2 = new LessVariableOption(\"name2\", \"value2\");\n        final LessVariableOptionsBuilder result = builder.append(new LessVariableOption[] { variable1, variable2 });\n        assertThat(result).isSameAs(builder);\n        verify(builder).append(variable1);\n        verify(builder).append(variable2);\n        assertThat(builder.getVariables()).containsExactly(variable1, variable2);\n    }\n    @Test(expected = IllegalArgumentException.class)\n    public void append_variableIsNull_throwsException() {\n        builder.append((LessVariableOption) null);\n    }\n    @Test\n    public void append_variableIsNotNull_variablesAreAdded() {\n        final LessVariableOption variable = new LessVariableOption(\"name\", \"value\");\n        final LessVariableOptionsBuilder result = builder.append(variable);\n        assertThat(result).isSameAs(builder);\n        assertThat(builder.getVariables()).containsExactly(variable);\n    }\n    @Test\n    public void build() {\n        final Map<String, String> variablesMap = new LinkedHashMap<>();\n        variablesMap.put(\"name1\", \"value1\");\n        variablesMap.put(\"name2\", \"value2\");\n        final List<LessVariableOption> variables = builder //\n                .append(variablesMap) //\n                .append(\"name3\", \"value3\") //\n                .append(new LessVariableOption(\"name2\", \"value4\")) //\n                .build();\n        assertThat(variables).containsExactly(//\n                new LessVariableOption(\"name1\", \"value1\"), //\n                new LessVariableOption(\"name2\", \"value2\"), //\n                new LessVariableOption(\"name3\", \"value3\"), //\n                new LessVariableOption(\"name2\", \"value4\"));\n    }\n"]], "pred": {"ppl": 1.2866512537002563, "ppl_lower": 1.415401816368103, "ppl/lowercase_ppl": -1.3783901004241994, "ppl/zlib": 0.0003901593123025435, "Min_5.0% Prob": 4.008882919947307, "Min_10.0% Prob": 2.3513873336361906, "Min_20.0% Prob": 1.2442576380483075, "Min_30.0% Prob": 0.8387450713183414, "Min_40.0% Prob": 0.6293885583481535, "Min_50.0% Prob": 0.5042664158151625, "Min_60.0% Prob": 0.42053685145333736}}
{"hexsha": "647912a00cb6ddbc55949e312c38e2b982fb7ee6", "ext": "java", "lang": "Java", "content": "@RestControllerAdvice\npublic class BaseExceptionHandler {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    private final ResponseEntityExceptionHandler delegate = new ResponseEntityExceptionHandler() {\n        @Override\n        @NonNull\n        protected ResponseEntity<Object> handleExceptionInternal(\n                @NonNull Exception ex, Object body, HttpHeaders headers, HttpStatus status, @NonNull WebRequest request) {\n            if (ex instanceof MethodArgumentNotValidException) {\n                return handle((MethodArgumentNotValidException) ex, request);\n            }\n            final int statusValue = status.value();\n            if (500 <= statusValue && statusValue < 600) {\n                logger.error(\"internal error caught:\", ex);\n            }\n            if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {\n                request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);\n            }\n            final String requestURI = extractRequestURI(request);\n            final Response<?> error = new Response<>(statusValue, status, ex.getMessage(), requestURI);\n            return new ResponseEntity<>(error, headers, status);\n        }\n    };\n\n    @ExceptionHandler({\n            HttpRequestMethodNotSupportedException.class,\n            HttpMediaTypeNotSupportedException.class,\n            HttpMediaTypeNotAcceptableException.class,\n            MissingPathVariableException.class,\n            MissingServletRequestParameterException.class,\n            ServletRequestBindingException.class,\n            ConversionNotSupportedException.class,\n            TypeMismatchException.class,\n            HttpMessageNotReadableException.class,\n            HttpMessageNotWritableException.class,\n            MethodArgumentNotValidException.class,\n            MissingServletRequestPartException.class,\n            BindException.class,\n            NoHandlerFoundException.class,\n            AsyncRequestTimeoutException.class\n    })\n    public final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {\n        return this.delegate.handleException(ex, request);\n    }\n\n    @ExceptionHandler(value = CodedBizException.class)\n    public ResponseEntity<Response<?>> handle(final CodedBizException ex, WebRequest request) {\n        return codedBizExceptionHandle(ex, request);\n    }\n\n    private ResponseEntity<Response<?>> codedBizExceptionHandle(final CodedBizException ex, WebRequest request) {\n        final Throwable cause = ex.getCause();\n        final String message = ex.getMessage();\n        if (ex.isLogging()) {\n            if (cause != null) {\n                logger.error(\"{}\", message, cause);\n            } else {\n                logger.error(\"{}\", message, ex);\n            }\n        }\n        final String requestURI = extractRequestURI(request);\n        final Response<?> error;\n        final int code = ex.getHttpStatus();\n        final HttpStatus resolve = HttpStatus.resolve(code);\n        final String bizCode = ex.getCode();\n        if (cause != null) {\n            final String causeMessage = cause.getMessage();\n            if (resolve != null) {\n                error = new Response<>(code, resolve.getReasonPhrase(), causeMessage, requestURI, bizCode, message);\n            } else {\n                error = new Response<>(code, \"\", causeMessage, requestURI, bizCode, message);\n            }\n        } else {\n            if (resolve != null) {\n                error = new Response<>(\n                        code, resolve.getReasonPhrase(), message, requestURI, bizCode, message);\n            } else {\n                error = new Response<>(\n                        code, \"\", message, requestURI, bizCode, message);\n            }\n        }\n        return ResponseEntity.status(code).body(error);\n    }\n\n    @ExceptionHandler(value = ConstraintViolationException.class)\n    public ResponseEntity<Response<?>> handle(final ConstraintViolationException ex, WebRequest request) {\n        final HttpStatus status = HttpStatus.BAD_REQUEST;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> descriptor = new Response<>(status.value(), status,\n                ex.getConstraintViolations().stream()\n                        .map(ConstraintViolation::getMessage).reduce((s, s2) -> s + \",\" + s2).orElse(\"\"),\n                requestURI);\n        return ResponseEntity.status(status).body(descriptor);\n    }\n\n    @ExceptionHandler(Throwable.class)\n    public ResponseEntity<Response<?>> handle(final Throwable throwable, WebRequest request) {\n        logger.error(\"unexpected exception caught:\", throwable);\n        final HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> error = new Response<>(status.value(), status, throwable.getMessage(), requestURI);\n        return new ResponseEntity<>(error, status);\n    }\n\n    @ExceptionHandler(HystrixRuntimeException.class)\n    public ResponseEntity<Response<?>> handle(@NonNull final HystrixRuntimeException hystrixEx, WebRequest request) {\n        final CodedBizException de = tryExtractCodedBizException(hystrixEx);\n        if (de != null) {\n            return this.handle(de, request);\n        }\n        return handle((Throwable) hystrixEx, request);\n    }\n\n    @Nullable\n    private CodedBizException tryExtractCodedBizException(@NonNull final HystrixRuntimeException hystrixEx) {\n        Throwable ex = hystrixEx;\n        Throwable cause = ex.getCause();\n        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {\n            ex = cause;\n            cause = cause.getCause();\n        }\n        if (cause instanceof CodedBizException) {\n            return (CodedBizException) cause;\n        }\n        ex = hystrixEx.getFallbackException();\n        cause = ex.getCause();\n        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {\n            ex = cause;\n            cause = cause.getCause();\n        }\n        if (cause instanceof CodedBizException) {\n            return (CodedBizException) cause;\n        }\n        return null;\n    }\n\n    private ResponseEntity<Object> handle(final MethodArgumentNotValidException ex, WebRequest request) {\n        final HttpStatus status = HttpStatus.BAD_REQUEST;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> descriptor = new Response<>(status.value(), status,\n                ex.getBindingResult().getAllErrors().stream()\n                        .map(DefaultMessageSourceResolvable::getDefaultMessage)\n                        .reduce((s, s2) -> s + \",\" + s2).orElse(\"\"),\n                requestURI);\n        return ResponseEntity.status(status).body(descriptor);\n    }\n\n    private String extractRequestURI(WebRequest request) {\n        final String requestURI;\n        if (request instanceof ServletWebRequest) {\n            ServletWebRequest servletWebRequest = (ServletWebRequest) request;\n            requestURI = servletWebRequest.getRequest().getRequestURI();\n        } else {\n            requestURI = \"[can't detect]\";\n        }\n        return requestURI;\n    }\n}", "class_id": 0, "repo": "howardliu-cn/my-gear", "file": "gear-spring-boot/spring-boot-autoconfigure-web-misc/src/main/java/cn/howardliu/gear/spring/boot/web/handler/BaseExceptionHandler.java", "last_update_at": "2018-07-31T11:59:44+00:00", "question_id": "647912a00cb6ddbc55949e312c38e2b982fb7ee6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RestControllerAdvice\npublic class BaseExceptionHandler {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final ResponseEntityExceptionHandler delegate = new ResponseEntityExceptionHandler() {\n        @Override\n        @NonNull\n        protected ResponseEntity<Object> handleExceptionInternal(\n                @NonNull Exception ex, Object body, HttpHeaders headers, HttpStatus status, @NonNull WebRequest request) {\n            if (ex instanceof MethodArgumentNotValidException) {\n                return handle((MethodArgumentNotValidException) ex, request);\n            }\n            final int statusValue = status.value();\n            if (500 <= statusValue && statusValue < 600) {\n                logger.error(\"internal error caught:\", ex);\n            }\n            if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {\n                request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);\n            }\n            final String requestURI = extractRequestURI(request);\n            final Response<?> error = new Response<>(statusValue, status, ex.getMessage(), requestURI);\n            return new ResponseEntity<>(error, headers, status);\n        }\n    };\n    @ExceptionHandler({\n            HttpRequestMethodNotSupportedException.class,\n            HttpMediaTypeNotSupportedException.class,\n            HttpMediaTypeNotAcceptableException.class,\n            MissingPathVariableException.class,\n            MissingServletRequestParameterException.class,\n            ServletRequestBindingException.class,\n            ConversionNotSupportedException.class,\n            TypeMismatchException.class,\n            HttpMessageNotReadableException.class,\n            HttpMessageNotWritableException.class,\n            MethodArgumentNotValidException.class,\n            MissingServletRequestPartException.class,\n            BindException.class,\n            NoHandlerFoundException.class,\n            AsyncRequestTimeoutException.class\n    })\n    public final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {\n        return this.delegate.handleException(ex, request);\n    }\n    @ExceptionHandler(value = CodedBizException.class)\n    public ResponseEntity<Response<?>> handle(final CodedBizException ex, WebRequest request) {\n        return codedBizExceptionHandle(ex, request);\n    }\n    private ResponseEntity<Response<?>> codedBizExceptionHandle(final CodedBizException ex, WebRequest request) {\n        final Throwable cause = ex.getCause();\n        final String message = ex.getMessage();\n        if (ex.isLogging()) {\n            if (cause != null) {\n                logger.error(\"{}\", message, cause);\n            } else {\n                logger.error(\"{}\", message, ex);\n            }\n        }\n        final String requestURI = extractRequestURI(request);\n        final Response<?> error;\n        final int code = ex.getHttpStatus();\n        final HttpStatus resolve = HttpStatus.resolve(code);\n        final String bizCode = ex.getCode();\n        if (cause != null) {\n            final String causeMessage = cause.getMessage();\n            if (resolve != null) {\n                error = new Response<>(code, resolve.getReasonPhrase(), causeMessage, requestURI, bizCode, message);\n            } else {\n                error = new Response<>(code, \"\", causeMessage, requestURI, bizCode, message);\n            }\n        } else {\n            if (resolve != null) {\n                error = new Response<>(\n                        code, resolve.getReasonPhrase(), message, requestURI, bizCode, message);\n            } else {\n                error = new Response<>(\n                        code, \"\", message, requestURI, bizCode, message);\n            }\n        }\n        return ResponseEntity.status(code).body(error);\n    }\n    @ExceptionHandler(value = ConstraintViolationException.class)\n    public ResponseEntity<Response<?>> handle(final ConstraintViolationException ex, WebRequest request) {\n        final HttpStatus status = HttpStatus.BAD_REQUEST;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> descriptor = new Response<>(status.value(), status,\n                ex.getConstraintViolations().stream()\n                        .map(ConstraintViolation::getMessage).reduce((s, s2) -> s + \",\" + s2).orElse(\"\"),\n                requestURI);\n        return ResponseEntity.status(status).body(descriptor);\n    }\n    @ExceptionHandler(Throwable.class)\n    public ResponseEntity<Response<?>> handle(final Throwable throwable, WebRequest request) {\n        logger.error(\"unexpected exception caught:\", throwable);\n        final HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> error = new Response<>(status.value(), status, throwable.getMessage(), requestURI);\n        return new ResponseEntity<>(error, status);\n    }\n    @ExceptionHandler(HystrixRuntimeException.class)\n    public ResponseEntity<Response<?>> handle(@NonNull final HystrixRuntimeException hystrixEx, WebRequest request) {\n        final CodedBizException de = tryExtractCodedBizException(hystrixEx);\n        if (de != null) {\n            return this.handle(de, request);\n        }\n        return handle((Throwable) hystrixEx, request);\n    }\n    @Nullable\n    private CodedBizException tryExtractCodedBizException(@NonNull final HystrixRuntimeException hystrixEx) {\n        Throwable ex = hystrixEx;\n        Throwable cause = ex.getCause();\n        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {\n            ex = cause;\n            cause = cause.getCause();\n        }\n        if (cause instanceof CodedBizException) {\n            return (CodedBizException) cause;\n        }\n        ex = hystrixEx.getFallbackException();\n        cause = ex.getCause();\n        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {\n            ex = cause;\n            cause = cause.getCause();\n        }\n        if (cause instanceof CodedBizException) {\n            return (CodedBizException) cause;\n        }\n        return null;\n    }\n    private ResponseEntity<Object> handle(final MethodArgumentNotValidException ex, WebRequest request) {\n        final HttpStatus status = HttpStatus.BAD_REQUEST;\n        final String requestURI = extractRequestURI(request);\n        final Response<?> descriptor = new Response<>(status.value(), status,\n                ex.getBindingResult().getAllErrors().stream()\n                        .map(DefaultMessageSourceResolvable::getDefaultMessage)\n                        .reduce((s, s2) -> s + \",\" + s2).orElse(\"\"),\n                requestURI);\n        return ResponseEntity.status(status).body(descriptor);\n    }\n    private String extractRequestURI(WebRequest request) {\n        final String requestURI;\n        if (request instanceof ServletWebRequest) {\n            ServletWebRequest servletWebRequest = (ServletWebRequest) request;\n            requestURI = servletWebRequest.getRequest().getRequestURI();\n        } else {\n            requestURI = \"[can't detect]\";\n        }\n        return requestURI;\n    }\n"]], "pred": {"ppl": 1.5497769117355347, "ppl_lower": 2.036383867263794, "ppl/lowercase_ppl": -1.6232772807466633, "ppl/zlib": 0.0002872858968262171, "Min_5.0% Prob": 4.921761723125682, "Min_10.0% Prob": 3.445728457441517, "Min_20.0% Prob": 2.076958483925053, "Min_30.0% Prob": 1.4400292761088196, "Min_40.0% Prob": 1.0895893526762215, "Min_50.0% Prob": 0.8755684221972604, "Min_60.0% Prob": 0.7308035804612827}}
{"hexsha": "1846de475f569d5db8396533a0614c0ff1e52fee", "ext": "java", "lang": "Java", "content": "public class TrackerIdFetcherTest {\n\n    private TrackerIdFetcher trackerIdFetcher;\n    private TrackerIdFetcher nextTrackerIdFetcher;\n    private TrackerIdFetcher nextTrackerIdFetcher1;\n    private Http.Context ctx;\n\n    @Before\n    public void setup() {\n        trackerIdFetcher = mock(TrackerIdFetcher.class);\n        nextTrackerIdFetcher = mock(TrackerIdFetcher.class);\n        ctx = mock(Http.Context.class);\n    }\n\n    @Test\n    public void should_return_a_tracker_id() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(\"123\");\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertEquals(trackerIdFetcher.get(ctx), \"123\");\n    }\n\n    @Test\n    public void should_return_a_tracker_id_from_next() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);\n        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(\"456\");\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertEquals(trackerIdFetcher.get(ctx), \"456\");\n    }\n\n    @Test\n    public void should_return_a_null_from_next() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher1);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);\n        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(null);\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertNull(trackerIdFetcher.get(ctx));\n    }\n\n    @Test\n    public void should_set_the_next_provider() {\n        doCallRealMethod().when(trackerIdFetcher).setNextProvider(nextTrackerIdFetcher);\n        trackerIdFetcher.setNextProvider(nextTrackerIdFetcher);\n        Assert.assertEquals(Whitebox.getInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\"), nextTrackerIdFetcher);\n    }\n\n}", "class_id": 0, "repo": "udaynavin/playframework-log-tracker", "file": "module/src/test/java/io/github/naviud/logtracker/actions/trackerproviders/TrackerIdFetcherTest.java", "last_update_at": "2018-10-11T05:38:40+00:00", "question_id": "1846de475f569d5db8396533a0614c0ff1e52fee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TrackerIdFetcherTest {\n    private TrackerIdFetcher trackerIdFetcher;\n    private TrackerIdFetcher nextTrackerIdFetcher;\n    private TrackerIdFetcher nextTrackerIdFetcher1;\n    private Http.Context ctx;\n    @Before\n    public void setup() {\n        trackerIdFetcher = mock(TrackerIdFetcher.class);\n        nextTrackerIdFetcher = mock(TrackerIdFetcher.class);\n        ctx = mock(Http.Context.class);\n    }\n    @Test\n    public void should_return_a_tracker_id() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(\"123\");\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertEquals(trackerIdFetcher.get(ctx), \"123\");\n    }\n    @Test\n    public void should_return_a_tracker_id_from_next() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);\n        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(\"456\");\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertEquals(trackerIdFetcher.get(ctx), \"456\");\n    }\n    @Test\n    public void should_return_a_null_from_next() {\n        Whitebox.setInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\", nextTrackerIdFetcher1);\n        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);\n        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(null);\n        doCallRealMethod().when(trackerIdFetcher).get(ctx);\n        Assert.assertNull(trackerIdFetcher.get(ctx));\n    }\n    @Test\n    public void should_set_the_next_provider() {\n        doCallRealMethod().when(trackerIdFetcher).setNextProvider(nextTrackerIdFetcher);\n        trackerIdFetcher.setNextProvider(nextTrackerIdFetcher);\n        Assert.assertEquals(Whitebox.getInternalState(trackerIdFetcher, \"nextTrackerIdFetcher\"), nextTrackerIdFetcher);\n    }\n"]], "pred": {"ppl": 1.362766981124878, "ppl_lower": 1.5311648845672607, "ppl/lowercase_ppl": -1.376430255641444, "ppl/zlib": 0.0007956739789437737, "Min_5.0% Prob": 4.259252548217773, "Min_10.0% Prob": 2.716837305215097, "Min_20.0% Prob": 1.5223265746908803, "Min_30.0% Prob": 1.0281107977473287, "Min_40.0% Prob": 0.7732154343412408, "Min_50.0% Prob": 0.6189056335982206, "Min_60.0% Prob": 0.5158275817805695}}
{"hexsha": "922f440422cac05f1d27c4df5769a8a5ccdcdbf0", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"deprecation\")\npublic class DeployContract extends AbstractSampler implements Constants {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tpublic boolean isUseCorrelatedData() {\n\t\treturn getPropertyAsBoolean(\"useCorrelatedData\");\n\t}\n\n\tpublic void setUseCorrelatedData(boolean useCorrelatedData) {\n\t\tsetProperty(\"useCorrelatedData\", useCorrelatedData);\n\t}\n\t\n\tpublic String getBinStr() {\n\t\treturn getPropertyAsString(BINCODE, \"\");\n\t}\n\t\n\tpublic void setBinStr(String binStr) {\n\t\tsetProperty(BINCODE, binStr);\n\t}\n\t\n\tpublic String getGas() {\n\t\treturn getPropertyAsString(\"gas\", \"\");\n\t}\n\t\n\tpublic void setGas(String gas) {\n\t\tsetProperty(\"gas\", gas);\n\t}\n\t\n\tpublic String getFromUser() {\n\t\treturn getPropertyAsString(\"fromUser\", \"\");\n\t}\n\t\n\tpublic void setFromUser(String fromUser) {\n\t\tsetProperty(\"fromUser\", fromUser);\n\t}\n\t\n\t@Override\n\tpublic SampleResult sample(Entry arg0) {\n\t\tSampleResult result = new SampleResult();\n\t\tresult.setSampleLabel(getName());\n\t\ttry {\n\t\t\tString binStr, gas;\n\t\t\tif (isUseCorrelatedData()) {\n\t\t\t\tJMeterVariables vars = JMeterContextService.getContext().getVariables();\n\t\t\t\tbinStr = (vars.get(\"binStr\") == null) ? \"null\" : vars.get(\"binStr\");\n\t\t\t\tgas = (vars.get(\"gas\") == null) ? \"null\" : vars.get(\"gas\");\n\t\t\t} else {\n\t\t\t\tbinStr = getBinStr();\n\t\t\t\tgas= getGas();\n\t\t\t}\n\t\t\tString fromUser = getFromUser();\n\t\t\t\n\t\t\tresult.sampleStart();\n\t        String postData = \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendTransaction\\\",\\\"params\\\":[{\\\"from\\\":\\\"\" \n\t        \t\t+ fromUser + \"\\\",\\\"gas\\\":\\\"\" + gas + \"\\\",\\\"data\\\":\\\"\" + binStr + \"\\\"}],\\\"id\\\":1003}\";\n\t        result.setRequestHeaders(postData);\n\t        String responseMsg = EthTestUtil.invokeAPI(null, postData);\n\t        result.sampleEnd();\n\t        \n\t        Object document = Configuration.defaultConfiguration().jsonProvider().parse(responseMsg);\n\t        try {\n\t        \tJsonPath.read(document, \"$.error\").toString();  // detect possible error first\n\t        \tresult.setResponseCode(\"400\");\n\t\t\t\tresult.setResponseData(responseMsg);\n\t        } catch (com.jayway.jsonpath.PathNotFoundException e) {\n\t        \tString txHash = JsonPath.read(document, \"$.result\").toString();\n\t        \tresult.setResponseCode(\"200\");\n\t\t        result.setSuccessful(true);\n\t\t\t\tresult.setResponseData(responseMsg);\n\t        \tJMeterVariables vars = JMeterContextService.getContext().getVariables();\n\t\t\t\tvars.put(\"txHash\", txHash);\n\t        }\n\t\t} catch(Exception ex) {\n\t\t\tif (result.getEndTime() == 0) result.sampleEnd(); // avoid twice call sampleEnd()\n\t\t\tresult.setResponseCode(\"500\");\n\t\t\tresult.setResponseData(ex.getMessage().getBytes());\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n}", "class_id": 0, "repo": "Nero1930/ethereum-jmeter", "file": "src/main/java/net/xmeter/ethereum/sampler/DeployContract.java", "last_update_at": "2018-11-27T09:48:42+00:00", "question_id": "922f440422cac05f1d27c4df5769a8a5ccdcdbf0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"deprecation\")\npublic class DeployContract extends AbstractSampler implements Constants {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tpublic boolean isUseCorrelatedData() {\n\t\treturn getPropertyAsBoolean(\"useCorrelatedData\");\n\t}\n\tpublic void setUseCorrelatedData(boolean useCorrelatedData) {\n\t\tsetProperty(\"useCorrelatedData\", useCorrelatedData);\n\t}\n\t\n\tpublic String getBinStr() {\n\t\treturn getPropertyAsString(BINCODE, \"\");\n\t}\n\t\n\tpublic void setBinStr(String binStr) {\n\t\tsetProperty(BINCODE, binStr);\n\t}\n\t\n\tpublic String getGas() {\n\t\treturn getPropertyAsString(\"gas\", \"\");\n\t}\n\t\n\tpublic void setGas(String gas) {\n\t\tsetProperty(\"gas\", gas);\n\t}\n\t\n\tpublic String getFromUser() {\n\t\treturn getPropertyAsString(\"fromUser\", \"\");\n\t}\n\t\n\tpublic void setFromUser(String fromUser) {\n\t\tsetProperty(\"fromUser\", fromUser);\n\t}\n\t\n\t@Override\n\tpublic SampleResult sample(Entry arg0) {\n\t\tSampleResult result = new SampleResult();\n\t\tresult.setSampleLabel(getName());\n\t\ttry {\n\t\t\tString binStr, gas;\n\t\t\tif (isUseCorrelatedData()) {\n\t\t\t\tJMeterVariables vars = JMeterContextService.getContext().getVariables();\n\t\t\t\tbinStr = (vars.get(\"binStr\") == null) ? \"null\" : vars.get(\"binStr\");\n\t\t\t\tgas = (vars.get(\"gas\") == null) ? \"null\" : vars.get(\"gas\");\n\t\t\t} else {\n\t\t\t\tbinStr = getBinStr();\n\t\t\t\tgas= getGas();\n\t\t\t}\n\t\t\tString fromUser = getFromUser();\n\t\t\t\n\t\t\tresult.sampleStart();\n\t        String postData = \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_sendTransaction\\\",\\\"params\\\":[{\\\"from\\\":\\\"\" \n\t        \t\t+ fromUser + \"\\\",\\\"gas\\\":\\\"\" + gas + \"\\\",\\\"data\\\":\\\"\" + binStr + \"\\\"}],\\\"id\\\":1003}\";\n\t        result.setRequestHeaders(postData);\n\t        String responseMsg = EthTestUtil.invokeAPI(null, postData);\n\t        result.sampleEnd();\n\t        \n\t        Object document = Configuration.defaultConfiguration().jsonProvider().parse(responseMsg);\n\t        try {\n\t        \tJsonPath.read(document, \"$.error\").toString();  // detect possible error first\n\t        \tresult.setResponseCode(\"400\");\n\t\t\t\tresult.setResponseData(responseMsg);\n\t        } catch (com.jayway.jsonpath.PathNotFoundException e) {\n\t        \tString txHash = JsonPath.read(document, \"$.result\").toString();\n\t        \tresult.setResponseCode(\"200\");\n\t\t        result.setSuccessful(true);\n\t\t\t\tresult.setResponseData(responseMsg);\n\t        \tJMeterVariables vars = JMeterContextService.getContext().getVariables();\n\t\t\t\tvars.put(\"txHash\", txHash);\n\t        }\n\t\t} catch(Exception ex) {\n\t\t\tif (result.getEndTime() == 0) result.sampleEnd(); // avoid twice call sampleEnd()\n\t\t\tresult.setResponseCode(\"500\");\n\t\t\tresult.setResponseData(ex.getMessage().getBytes());\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n"]], "pred": {"ppl": 1.7295910120010376, "ppl_lower": 2.0920374393463135, "ppl/lowercase_ppl": -1.3472507572366985, "ppl/zlib": 0.0005534191629420819, "Min_5.0% Prob": 5.958834319644504, "Min_10.0% Prob": 4.265770577059852, "Min_20.0% Prob": 2.5696459557470037, "Min_30.0% Prob": 1.7887577736179767, "Min_40.0% Prob": 1.3590018427853592, "Min_50.0% Prob": 1.0917637710712407, "Min_60.0% Prob": 0.9128383222614067}}
{"hexsha": "8be5d02da06b0e97cfbdde59e4d9fbb0bbc67d6c", "ext": "java", "lang": "Java", "content": "public class PatternedLogger extends BufferedLogger {\n    private final Map<String, String> info = Maps.newHashMap();\n\n    private static final Pattern PATTERN_APP_ID = Pattern.compile(\"Submitted application (.*?) to ResourceManager\");\n    private static final Pattern PATTERN_APP_URL = Pattern.compile(\"The url to track the job: (.*)\");\n    private static final Pattern PATTERN_JOB_ID = Pattern.compile(\"Running job: (.*)\");\n    private static final Pattern PATTERN_HDFS_BYTES_WRITTEN = Pattern.compile(\"(?:HD|MAPR)FS: Number of bytes written=(\\\\d+)\");\n    private static final Pattern PATTERN_SOURCE_RECORDS_COUNT = Pattern.compile(\"Map input records=(\\\\d+)\");\n    private static final Pattern PATTERN_SOURCE_RECORDS_SIZE = Pattern.compile(\"(?:HD|MAPR)FS Read: (\\\\d+) HDFS Write\");\n\n    // hive\n    private static final Pattern PATTERN_HIVE_APP_ID_URL = Pattern.compile(\"Starting Job = (.*?), Tracking URL = (.*)\");\n    private static final Pattern PATTERN_HIVE_BYTES_WRITTEN = Pattern.compile(\"(?:HD|MAPR)FS Read: (\\\\d+) HDFS Write: (\\\\d+) SUCCESS\");\n\n    private static final Pattern PATTERN_HIVE_APP_ID_URL_2 = Pattern.compile(\"Executing on YARN cluster with App id  (.*?)\");\n\n    // spark\n    private static final Pattern PATTERN_SPARK_APP_ID = Pattern.compile(\"Submitted application (.*?)\");\n    private static final Pattern PATTERN_SPARK_APP_URL = Pattern.compile(\"tracking URL: (.*)\");\n\n\n    public PatternedLogger(Logger wrappedLogger) {\n        super(wrappedLogger);\n    }\n\n    @Override\n    public void log(String message) {\n        super.log(message);\n        Matcher matcher = PATTERN_APP_ID.matcher(message);\n        if (matcher.find()) {\n            String appId = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_ID, appId);\n        }\n\n        matcher = PATTERN_APP_URL.matcher(message);\n        if (matcher.find()) {\n            String appTrackingUrl = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_URL, appTrackingUrl);\n        }\n\n        matcher = PATTERN_JOB_ID.matcher(message);\n        if (matcher.find()) {\n            String mrJobID = matcher.group(1);\n            info.put(ExecutableConstants.MR_JOB_ID, mrJobID);\n        }\n\n        matcher = PATTERN_HDFS_BYTES_WRITTEN.matcher(message);\n        if (matcher.find()) {\n            String hdfsWritten = matcher.group(1);\n            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);\n        }\n\n        matcher = PATTERN_SOURCE_RECORDS_COUNT.matcher(message);\n        if (matcher.find()) {\n            String sourceCount = matcher.group(1);\n            info.put(ExecutableConstants.SOURCE_RECORDS_COUNT, sourceCount);\n        }\n\n        matcher = PATTERN_SOURCE_RECORDS_SIZE.matcher(message);\n        if (matcher.find()) {\n            String sourceSize = matcher.group(1);\n            info.put(ExecutableConstants.SOURCE_RECORDS_SIZE, sourceSize);\n        }\n\n        // hive\n        matcher = PATTERN_HIVE_APP_ID_URL.matcher(message);\n        if (matcher.find()) {\n            String jobId = matcher.group(1);\n            String trackingUrl = matcher.group(2);\n            info.put(ExecutableConstants.MR_JOB_ID, jobId);\n            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);\n        } else {\n            matcher = PATTERN_HIVE_APP_ID_URL_2.matcher(message);\n            if (matcher.find()) {\n                String jobId = matcher.group(1);\n                info.put(ExecutableConstants.YARN_APP_ID, jobId);\n            }\n        }\n\n        matcher = PATTERN_HIVE_BYTES_WRITTEN.matcher(message);\n        if (matcher.find()) {\n            // String hdfsRead = matcher.group(1);\n            String hdfsWritten = matcher.group(2);\n            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);\n        }\n\n        // spark\n        matcher = PATTERN_SPARK_APP_ID.matcher(message);\n        if (matcher.find()) {\n            String app_id = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_ID, app_id);\n        }\n\n        matcher = PATTERN_SPARK_APP_URL.matcher(message);\n        if (matcher.find()) {\n            String trackingUrl = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);\n        }\n    }\n\n    public Map<String, String> getInfo() {\n        return info;\n    }\n\n}", "class_id": 0, "repo": "jamesdong89/kylin-optimize", "file": "core-job/src/main/java/org/apache/kylin/job/common/PatternedLogger.java", "last_update_at": "2018-03-27T02:51:28+00:00", "question_id": "8be5d02da06b0e97cfbdde59e4d9fbb0bbc67d6c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PatternedLogger extends BufferedLogger {\n    private final Map<String, String> info = Maps.newHashMap();\n    private static final Pattern PATTERN_APP_ID = Pattern.compile(\"Submitted application (.*?) to ResourceManager\");\n    private static final Pattern PATTERN_APP_URL = Pattern.compile(\"The url to track the job: (.*)\");\n    private static final Pattern PATTERN_JOB_ID = Pattern.compile(\"Running job: (.*)\");\n    private static final Pattern PATTERN_HDFS_BYTES_WRITTEN = Pattern.compile(\"(?:HD|MAPR)FS: Number of bytes written=(\\\\d+)\");\n    private static final Pattern PATTERN_SOURCE_RECORDS_COUNT = Pattern.compile(\"Map input records=(\\\\d+)\");\n    private static final Pattern PATTERN_SOURCE_RECORDS_SIZE = Pattern.compile(\"(?:HD|MAPR)FS Read: (\\\\d+) HDFS Write\");\n    // hive\n    private static final Pattern PATTERN_HIVE_APP_ID_URL = Pattern.compile(\"Starting Job = (.*?), Tracking URL = (.*)\");\n    private static final Pattern PATTERN_HIVE_BYTES_WRITTEN = Pattern.compile(\"(?:HD|MAPR)FS Read: (\\\\d+) HDFS Write: (\\\\d+) SUCCESS\");\n    private static final Pattern PATTERN_HIVE_APP_ID_URL_2 = Pattern.compile(\"Executing on YARN cluster with App id  (.*?)\");\n    // spark\n    private static final Pattern PATTERN_SPARK_APP_ID = Pattern.compile(\"Submitted application (.*?)\");\n    private static final Pattern PATTERN_SPARK_APP_URL = Pattern.compile(\"tracking URL: (.*)\");\n    public PatternedLogger(Logger wrappedLogger) {\n        super(wrappedLogger);\n    }\n    @Override\n    public void log(String message) {\n        super.log(message);\n        Matcher matcher = PATTERN_APP_ID.matcher(message);\n        if (matcher.find()) {\n            String appId = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_ID, appId);\n        }\n        matcher = PATTERN_APP_URL.matcher(message);\n        if (matcher.find()) {\n            String appTrackingUrl = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_URL, appTrackingUrl);\n        }\n        matcher = PATTERN_JOB_ID.matcher(message);\n        if (matcher.find()) {\n            String mrJobID = matcher.group(1);\n            info.put(ExecutableConstants.MR_JOB_ID, mrJobID);\n        }\n        matcher = PATTERN_HDFS_BYTES_WRITTEN.matcher(message);\n        if (matcher.find()) {\n            String hdfsWritten = matcher.group(1);\n            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);\n        }\n        matcher = PATTERN_SOURCE_RECORDS_COUNT.matcher(message);\n        if (matcher.find()) {\n            String sourceCount = matcher.group(1);\n            info.put(ExecutableConstants.SOURCE_RECORDS_COUNT, sourceCount);\n        }\n        matcher = PATTERN_SOURCE_RECORDS_SIZE.matcher(message);\n        if (matcher.find()) {\n            String sourceSize = matcher.group(1);\n            info.put(ExecutableConstants.SOURCE_RECORDS_SIZE, sourceSize);\n        }\n        // hive\n        matcher = PATTERN_HIVE_APP_ID_URL.matcher(message);\n        if (matcher.find()) {\n            String jobId = matcher.group(1);\n            String trackingUrl = matcher.group(2);\n            info.put(ExecutableConstants.MR_JOB_ID, jobId);\n            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);\n        } else {\n            matcher = PATTERN_HIVE_APP_ID_URL_2.matcher(message);\n            if (matcher.find()) {\n                String jobId = matcher.group(1);\n                info.put(ExecutableConstants.YARN_APP_ID, jobId);\n            }\n        }\n        matcher = PATTERN_HIVE_BYTES_WRITTEN.matcher(message);\n        if (matcher.find()) {\n            // String hdfsRead = matcher.group(1);\n            String hdfsWritten = matcher.group(2);\n            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);\n        }\n        // spark\n        matcher = PATTERN_SPARK_APP_ID.matcher(message);\n        if (matcher.find()) {\n            String app_id = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_ID, app_id);\n        }\n        matcher = PATTERN_SPARK_APP_URL.matcher(message);\n        if (matcher.find()) {\n            String trackingUrl = matcher.group(1);\n            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);\n        }\n    }\n    public Map<String, String> getInfo() {\n        return info;\n    }\n"]], "pred": {"ppl": 1.4762154817581177, "ppl_lower": 1.6682788133621216, "ppl/lowercase_ppl": -1.3140346171420978, "ppl/zlib": 0.0004539413821372433, "Min_5.0% Prob": 5.046638713163488, "Min_10.0% Prob": 3.3760200341542563, "Min_20.0% Prob": 1.9006598837965845, "Min_30.0% Prob": 1.2912177186264517, "Min_40.0% Prob": 0.9715364716792237, "Min_50.0% Prob": 0.7790483314418206, "Min_60.0% Prob": 0.64981897413859}}
{"hexsha": "cf00a3662ca454725f1bb8553f51158c309dfcfb", "ext": "java", "lang": "Java", "content": "public class SetPasswordTest extends AbstractPeopleWithSessionBase {\n\n\t@Override\n\tpublic void testValidSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttestSetPassword(caller, theUser, generateSession(UserData.getData(theUser), caller));\n\t}\n\n\t@Override\n\tpublic void testNoSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, null);\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void testOtherUserSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, generateSessionAlterUser(caller));\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void testOtherApplicationSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, generateSessionAlterApplication(UserData.getData(theUser)));\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\n\tpublic void testSetPassword(APICaller inCaller, User inUser, String inSessionId) throws APIException {\n\t\tfinal Action theAction = new SetPassword();\n\t\tfinal Map<String, Object> theParams = new HashMap<String, Object>();\n\t\tfinal UserData theUserData = UserData.getData(inUser);\n\t\tfinal String userId = theUserData.getApiId(inCaller);\n\n\t\ttheParams.put(ActionParam.MAIN_PARAM_KEY, userId);\n\t\ttheParams.put(\"old_password\", \"12345\");\n\t\ttheParams.put(\"new_password\", \"newPass\");\n\t\tsetSessionParam(theParams, inSessionId);\n\n\t\tfinal ActionParam theActionParam = new ActionParam(inCaller, theParams);\n\t\tfinal Object theResult = theAction.processRequest(theActionParam);\n\n\t\tAssert.assertNull(theResult);\n\t\tAssert.assertTrue(inUser.checkPasswordPlain(\"newPass\"));\n\n\t\ttheParams.put(ActionParam.MAIN_PARAM_KEY, userId);\n\t\ttheParams.put(\"old_password\", \"newPass\");\n\t\ttheParams.put(\"new_password\", \"12345\");\n\t\tsetSessionParam(theParams, inSessionId);\n\n\t\tfinal ActionParam theActionParam2 = new ActionParam(inCaller, theParams);\n\t\tfinal Object theResult2 = theAction.processRequest(theActionParam2);\n\n\t\tAssert.assertNull(theResult2);\n\t\tAssert.assertTrue(inUser.checkPasswordPlain(\"12345\"));\n\t}\n}", "class_id": 0, "repo": "nguillaumin/nabaztag-server", "file": "net.violet.platform/src/test/java/net/violet/platform/api/actions/people/SetPasswordTest.java", "last_update_at": "2018-03-29T08:10:12+00:00", "question_id": "cf00a3662ca454725f1bb8553f51158c309dfcfb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SetPasswordTest extends AbstractPeopleWithSessionBase {\n\t@Override\n\tpublic void testValidSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttestSetPassword(caller, theUser, generateSession(UserData.getData(theUser), caller));\n\t}\n\t@Override\n\tpublic void testNoSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, null);\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\t@Override\n\tpublic void testOtherUserSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, generateSessionAlterUser(caller));\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\t@Override\n\tpublic void testOtherApplicationSession() throws APIException {\n\t\tfinal Date now = new Date();\n\t\tfinal User theUser = getPrivateUser();\n\t\tfinal Application theApplication = new ApplicationMock(42, \"My first application\", theUser, now);\n\t\tfinal ApplicationCredentials cred = new ApplicationCredentialsMock(\"6992873d28d86925325dc52d15d6feec30bb2da5\", \"59e6060a53ab1be5\", theApplication);\n\t\tfinal APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));\n\t\ttry {\n\t\t\ttestSetPassword(caller, theUser, generateSessionAlterApplication(UserData.getData(theUser)));\n\t\t} finally {\n\t\t\tAssert.assertFalse(theUser.checkPasswordPlain(\"newPass\"));\n\t\t}\n\t}\n\tpublic void testSetPassword(APICaller inCaller, User inUser, String inSessionId) throws APIException {\n\t\tfinal Action theAction = new SetPassword();\n\t\tfinal Map<String, Object> theParams = new HashMap<String, Object>();\n\t\tfinal UserData theUserData = UserData.getData(inUser);\n\t\tfinal String userId = theUserData.getApiId(inCaller);\n\t\ttheParams.put(ActionParam.MAIN_PARAM_KEY, userId);\n\t\ttheParams.put(\"old_password\", \"12345\");\n\t\ttheParams.put(\"new_password\", \"newPass\");\n\t\tsetSessionParam(theParams, inSessionId);\n\t\tfinal ActionParam theActionParam = new ActionParam(inCaller, theParams);\n\t\tfinal Object theResult = theAction.processRequest(theActionParam);\n\t\tAssert.assertNull(theResult);\n\t\tAssert.assertTrue(inUser.checkPasswordPlain(\"newPass\"));\n\t\ttheParams.put(ActionParam.MAIN_PARAM_KEY, userId);\n\t\ttheParams.put(\"old_password\", \"newPass\");\n\t\ttheParams.put(\"new_password\", \"12345\");\n\t\tsetSessionParam(theParams, inSessionId);\n\t\tfinal ActionParam theActionParam2 = new ActionParam(inCaller, theParams);\n\t\tfinal Object theResult2 = theAction.processRequest(theActionParam2);\n\t\tAssert.assertNull(theResult2);\n\t\tAssert.assertTrue(inUser.checkPasswordPlain(\"12345\"));\n\t}\n"]], "pred": {"ppl": 1.3774583339691162, "ppl_lower": 1.6597537994384766, "ppl/lowercase_ppl": -1.5821548076552259, "ppl/zlib": 0.00044354572578273686, "Min_5.0% Prob": 4.771378376904656, "Min_10.0% Prob": 2.9734678683327695, "Min_20.0% Prob": 1.5889093349231225, "Min_30.0% Prob": 1.06801464754382, "Min_40.0% Prob": 0.8004482583789505, "Min_50.0% Prob": 0.6409619401964047, "Min_60.0% Prob": 0.5343891874548818}}
{"hexsha": "ebacb0dc70d2b334e3d50dbd866d04dace8af192", "ext": "java", "lang": "Java", "content": "public class FluidTools {\n\n    /**\n     * Make sure the forge bucket is enabled. If needed to this in your mod constructor:\n     * FluidRegistry.enableUniversalBucket();\n     * @param fluidStack\n     * @return\n     */\n    @Nonnull\n    public static ItemStack convertFluidToBucket(@Nonnull FluidStack fluidStack) {\n        //                return FluidContainerRegistry.fillFluidContainer(fluidStack, new ItemStack(Items.BUCKET));\n        IFluidHandlerItem fh = FluidUtil.getFluidHandler(new ItemStack(Items.BUCKET));\n        fh.fill(fluidStack, true);\n        return fh.getContainer();\n    }\n\n    public static FluidStack convertBucketToFluid(@Nonnull ItemStack bucket) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(bucket);\n        if (fluidHandler == null) {\n            return null;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            FluidStack contents = properties.getContents();\n            if (contents != null) {\n                return contents;\n            }\n        }\n\n        return null;\n    }\n\n\n    public static boolean isEmptyContainer(@Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return false;\n        }\n\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (properties.canFill() && properties.getCapacity() > 0) {\n                FluidStack contents = properties.getContents();\n                if (contents == null) {\n                    return true;\n                } else if (contents.amount > 0) {\n                    return false;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean isFilledContainer(@Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return false;\n        }\n\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (!properties.canDrain()) {\n                return false;\n            }\n\n            FluidStack contents = properties.getContents();\n            if (contents == null || contents.amount < properties.getCapacity()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Drain a fluid container and return an empty container\n    @Nonnull\n    public static ItemStack drainContainer(@Nonnull ItemStack container) {\n        ItemStack empty = container.copy();\n        if (1 <= 0) {\n            empty.setCount(0);\n        } else {\n            empty.setCount(1);\n        }\n        IFluidHandlerItem fluidHandler = FluidUtil.getFluidHandler(empty);\n        if (fluidHandler == null) {\n            return ItemStack.EMPTY;\n        }\n        if (fluidHandler.drain(Integer.MAX_VALUE, true) != null){\n            return fluidHandler.getContainer();\n        }\n        return ItemStack.EMPTY;\n    }\n\n    // Fill a container with a fluid and return the filled container\n    @Nonnull\n    public static ItemStack fillContainer(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {\n        IFluidHandlerItem fh = FluidUtil.getFluidHandler(itemStack.copy());\n        int filled = fh.fill(fluidStack, true);\n        if (filled == 0) {\n            return ItemStack.EMPTY;\n        }\n        return fh.getContainer();\n    }\n\n    /**\n     * Get the capacity (in mb) of the given container for the given fluid\n     */\n    public static int getCapacity(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return 0;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (properties.canDrainFluidType(fluidStack)) {\n                return properties.getCapacity();\n            }\n        }\n        return 0;\n    }\n\n}", "class_id": 0, "repo": "mjevans/EFab", "file": "src/main/java/mcjty/efab/tools/FluidTools.java", "last_update_at": "2018-03-16T18:33:05+00:00", "question_id": "ebacb0dc70d2b334e3d50dbd866d04dace8af192", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FluidTools {\n    /**\n     * Make sure the forge bucket is enabled. If needed to this in your mod constructor:\n     * FluidRegistry.enableUniversalBucket();\n     * @param fluidStack\n     * @return\n     */\n    @Nonnull\n    public static ItemStack convertFluidToBucket(@Nonnull FluidStack fluidStack) {\n        //                return FluidContainerRegistry.fillFluidContainer(fluidStack, new ItemStack(Items.BUCKET));\n        IFluidHandlerItem fh = FluidUtil.getFluidHandler(new ItemStack(Items.BUCKET));\n        fh.fill(fluidStack, true);\n        return fh.getContainer();\n    }\n    public static FluidStack convertBucketToFluid(@Nonnull ItemStack bucket) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(bucket);\n        if (fluidHandler == null) {\n            return null;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            FluidStack contents = properties.getContents();\n            if (contents != null) {\n                return contents;\n            }\n        }\n        return null;\n    }\n    public static boolean isEmptyContainer(@Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return false;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (properties.canFill() && properties.getCapacity() > 0) {\n                FluidStack contents = properties.getContents();\n                if (contents == null) {\n                    return true;\n                } else if (contents.amount > 0) {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isFilledContainer(@Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return false;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (!properties.canDrain()) {\n                return false;\n            }\n            FluidStack contents = properties.getContents();\n            if (contents == null || contents.amount < properties.getCapacity()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Drain a fluid container and return an empty container\n    @Nonnull\n    public static ItemStack drainContainer(@Nonnull ItemStack container) {\n        ItemStack empty = container.copy();\n        if (1 <= 0) {\n            empty.setCount(0);\n        } else {\n            empty.setCount(1);\n        }\n        IFluidHandlerItem fluidHandler = FluidUtil.getFluidHandler(empty);\n        if (fluidHandler == null) {\n            return ItemStack.EMPTY;\n        }\n        if (fluidHandler.drain(Integer.MAX_VALUE, true) != null){\n            return fluidHandler.getContainer();\n        }\n        return ItemStack.EMPTY;\n    }\n    // Fill a container with a fluid and return the filled container\n    @Nonnull\n    public static ItemStack fillContainer(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {\n        IFluidHandlerItem fh = FluidUtil.getFluidHandler(itemStack.copy());\n        int filled = fh.fill(fluidStack, true);\n        if (filled == 0) {\n            return ItemStack.EMPTY;\n        }\n        return fh.getContainer();\n    }\n    /**\n     * Get the capacity (in mb) of the given container for the given fluid\n     */\n    public static int getCapacity(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {\n        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);\n        if (fluidHandler == null) {\n            return 0;\n        }\n        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();\n        for (IFluidTankProperties properties : tankProperties) {\n            if (properties.canDrainFluidType(fluidStack)) {\n                return properties.getCapacity();\n            }\n        }\n        return 0;\n    }\n"]], "pred": {"ppl": 1.5017017126083374, "ppl_lower": 1.733316421508789, "ppl/lowercase_ppl": -1.3527742591929302, "ppl/zlib": 0.00046735510362049817, "Min_5.0% Prob": 4.672920568316591, "Min_10.0% Prob": 3.168194064906999, "Min_20.0% Prob": 1.92414888651932, "Min_30.0% Prob": 1.338473670890713, "Min_40.0% Prob": 1.0121156822498387, "Min_50.0% Prob": 0.8127280716900942, "Min_60.0% Prob": 0.6782586564014393}}
{"hexsha": "16f8bbb394f434e3c6164d31cad301c322a2d0df", "ext": "java", "lang": "Java", "content": "@Controller\n@Path(\"{version}/oauth2/client\")\n@ResourceFilters({ APIVersionFilter.class, AuthenticationFilter.class,\n        BlockingFilter.class })\npublic class OAuthClientController {\n\n    @Autowired\n    private OAuth2ClientService clientService;\n    @Autowired\n    private OAuth2ScopeService scopeService;\n    @Autowired\n    private OAuth2ResponseHandler responseHandler;\n\n    /**\n     * Registers a client application. Before starting an OAuth\n     * process, client applications have to be registered first. Only\n     * registered users are allowed to register client applications.\n     * \n     * After registration, the client receives a client_id and a\n     * client_secret, if the client is confidential (capable of\n     * storing the client_secret), that are needed in the\n     * authorization process.\n     * \n     * From RFC 6749:\n     * The authorization server SHOULD document the size of any\n     * identifier it issues.\n     * \n     * @param context\n     * @param clientJson\n     *            a JSON object describing the client\n     * @return client_id and client_secret if the client type is\n     *         confidential\n     * \n     * @see OAuth2ClientJson\n     */\n    @POST\n    @Path(\"register\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientDto registerClient (\n            @Context SecurityContext securityContext,\n            OAuth2ClientJson clientJson) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.REGISTER_CLIENT);\n            return clientService.registerClient(clientJson,\n                    context.getUsername());\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n\n    /**\n     * Deregisters a client requires client owner authentication. \n     * \n     * \n     * @param securityContext\n     * @param clientId\n     *            the client id\n     * @return HTTP Response OK if successful.\n     */\n    @DELETE\n    @Path(\"deregister/{client_id}\")\n    public Response deregisterClient (\n            @Context SecurityContext securityContext,\n            @PathParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.DEREGISTER_CLIENT);\n            clientService.deregisterClient(clientId, context.getUsername());\n            return Response.ok().build();\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n\n    /**\n     * Resets client secret of the given client. This controller\n     * requires client owner and client authentication. Only\n     * confidential clients are issued client secrets.\n     * \n     * @param securityContext\n     * @param clientId\n     * @param clientSecret\n     * @return a new client secret\n     */\n    @POST\n    @Path(\"reset\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientDto resetClientSecret (\n            @Context SecurityContext securityContext,\n            @FormParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.RESET_CLIENT_SECRET);\n            return clientService.resetSecret(clientId, context.getUsername());\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n\n    /**\n     * Facilitates editing client privileges for admin purposes, e.g.\n     * setting a specific client to be a super client.\n     * Only confidential clients are allowed to be super clients.\n     * \n     * When upgrading clients to super clients, existing access tokens\n     * and authorization codes retain their scopes.\n     * \n     * When degrading super clients, all existing tokens and\n     * authorization codes are invalidated.\n     * \n     * @param securityContext\n     * @param clientId\n     *            OAuth2 client id\n     * @param super\n     *            true indicating super client, false otherwise\n     * @return Response status OK, if successful\n     */\n    @POST\n    @Path(\"privilege\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    public Response updateClientPrivilege (\n            @Context SecurityContext securityContext,\n            @FormParam(\"client_id\") String clientId,\n            @FormParam(\"super\") String isSuper) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.ADMIN);\n            clientService.updatePrivilege(context.getUsername(), clientId,\n                    Boolean.valueOf(isSuper));\n            return Response.ok(\"SUCCESS\").build();\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n\n    @GET\n    @Path(\"{client_id}\")\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientInfoDto retrieveClientInfo (\n            @Context SecurityContext securityContext,\n            @PathParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.CLIENT_INFO);\n            return clientService.retrieveClientInfo(context.getUsername(),\n                    clientId);\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n\n    /**\n     * Lists user clients having active refresh tokens (not revoked,\n     * not expired), except super clients.\n     * \n     * This service is not part of the OAuth2 specification. It is\n     * intended to facilitate users revoking any suspicious and\n     * misused access or refresh tokens.\n     * \n     * Only super clients are allowed to use this service. It requires\n     * user and client authentications.\n     * \n     * @param context\n     * @param superClientId\n     *            the client id of the super client\n     * @param superClientSecret\n     *            the client secret of the super client\n     * @return a list of clients having refresh tokens of the\n     *         given user\n     */\n    @POST\n    @Path(\"/list\")\n    @ResourceFilters({ AuthenticationFilter.class, BlockingFilter.class })\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public List<OAuth2UserClientDto> listUserAuthorizedClients (\n            @Context SecurityContext context,\n            @FormParam(\"super_client_id\") String superClientId,\n            @FormParam(\"super_client_secret\") String superClientSecret,\n            @FormParam(\"authorized_only\") boolean authorizedOnly) {\n\n        TokenContext tokenContext = (TokenContext) context.getUserPrincipal();\n        String username = tokenContext.getUsername();\n\n        try {\n            scopeService.verifyScope(tokenContext,\n                    OAuth2Scope.LIST_USER_CLIENT);\n            if(authorizedOnly){\n                return clientService.listUserAuthorizedClients(username,\n                        superClientId, superClientSecret);\n            }\n            else {\n                return clientService.listUserRegisteredClients(username,\n                        superClientId, superClientSecret);                \n            }\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n}", "class_id": 0, "repo": "KorAP/Kustvakt", "file": "full/src/main/java/de/ids_mannheim/korap/web/controller/OAuthClientController.java", "last_update_at": "2018-10-24T13:51:57+00:00", "question_id": "16f8bbb394f434e3c6164d31cad301c322a2d0df", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@Path(\"{version}/oauth2/client\")\n@ResourceFilters({ APIVersionFilter.class, AuthenticationFilter.class,\n        BlockingFilter.class })\npublic class OAuthClientController {\n    @Autowired\n    private OAuth2ClientService clientService;\n    @Autowired\n    private OAuth2ScopeService scopeService;\n    @Autowired\n    private OAuth2ResponseHandler responseHandler;\n    /**\n     * Registers a client application. Before starting an OAuth\n     * process, client applications have to be registered first. Only\n     * registered users are allowed to register client applications.\n     * \n     * After registration, the client receives a client_id and a\n     * client_secret, if the client is confidential (capable of\n     * storing the client_secret), that are needed in the\n     * authorization process.\n     * \n     * From RFC 6749:\n     * The authorization server SHOULD document the size of any\n     * identifier it issues.\n     * \n     * @param context\n     * @param clientJson\n     *            a JSON object describing the client\n     * @return client_id and client_secret if the client type is\n     *         confidential\n     * \n     * @see OAuth2ClientJson\n     */\n    @POST\n    @Path(\"register\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientDto registerClient (\n            @Context SecurityContext securityContext,\n            OAuth2ClientJson clientJson) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.REGISTER_CLIENT);\n            return clientService.registerClient(clientJson,\n                    context.getUsername());\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n    /**\n     * Deregisters a client requires client owner authentication. \n     * \n     * \n     * @param securityContext\n     * @param clientId\n     *            the client id\n     * @return HTTP Response OK if successful.\n     */\n    @DELETE\n    @Path(\"deregister/{client_id}\")\n    public Response deregisterClient (\n            @Context SecurityContext securityContext,\n            @PathParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.DEREGISTER_CLIENT);\n            clientService.deregisterClient(clientId, context.getUsername());\n            return Response.ok().build();\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n    /**\n     * Resets client secret of the given client. This controller\n     * requires client owner and client authentication. Only\n     * confidential clients are issued client secrets.\n     * \n     * @param securityContext\n     * @param clientId\n     * @param clientSecret\n     * @return a new client secret\n     */\n    @POST\n    @Path(\"reset\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientDto resetClientSecret (\n            @Context SecurityContext securityContext,\n            @FormParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.RESET_CLIENT_SECRET);\n            return clientService.resetSecret(clientId, context.getUsername());\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n    /**\n     * Facilitates editing client privileges for admin purposes, e.g.\n     * setting a specific client to be a super client.\n     * Only confidential clients are allowed to be super clients.\n     * \n     * When upgrading clients to super clients, existing access tokens\n     * and authorization codes retain their scopes.\n     * \n     * When degrading super clients, all existing tokens and\n     * authorization codes are invalidated.\n     * \n     * @param securityContext\n     * @param clientId\n     *            OAuth2 client id\n     * @param super\n     *            true indicating super client, false otherwise\n     * @return Response status OK, if successful\n     */\n    @POST\n    @Path(\"privilege\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    public Response updateClientPrivilege (\n            @Context SecurityContext securityContext,\n            @FormParam(\"client_id\") String clientId,\n            @FormParam(\"super\") String isSuper) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.ADMIN);\n            clientService.updatePrivilege(context.getUsername(), clientId,\n                    Boolean.valueOf(isSuper));\n            return Response.ok(\"SUCCESS\").build();\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n    @GET\n    @Path(\"{client_id}\")\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public OAuth2ClientInfoDto retrieveClientInfo (\n            @Context SecurityContext securityContext,\n            @PathParam(\"client_id\") String clientId) {\n        TokenContext context =\n                (TokenContext) securityContext.getUserPrincipal();\n        try {\n            scopeService.verifyScope(context, OAuth2Scope.CLIENT_INFO);\n            return clientService.retrieveClientInfo(context.getUsername(),\n                    clientId);\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n    /**\n     * Lists user clients having active refresh tokens (not revoked,\n     * not expired), except super clients.\n     * \n     * This service is not part of the OAuth2 specification. It is\n     * intended to facilitate users revoking any suspicious and\n     * misused access or refresh tokens.\n     * \n     * Only super clients are allowed to use this service. It requires\n     * user and client authentications.\n     * \n     * @param context\n     * @param superClientId\n     *            the client id of the super client\n     * @param superClientSecret\n     *            the client secret of the super client\n     * @return a list of clients having refresh tokens of the\n     *         given user\n     */\n    @POST\n    @Path(\"/list\")\n    @ResourceFilters({ AuthenticationFilter.class, BlockingFilter.class })\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @Produces(MediaType.APPLICATION_JSON + \";charset=utf-8\")\n    public List<OAuth2UserClientDto> listUserAuthorizedClients (\n            @Context SecurityContext context,\n            @FormParam(\"super_client_id\") String superClientId,\n            @FormParam(\"super_client_secret\") String superClientSecret,\n            @FormParam(\"authorized_only\") boolean authorizedOnly) {\n        TokenContext tokenContext = (TokenContext) context.getUserPrincipal();\n        String username = tokenContext.getUsername();\n        try {\n            scopeService.verifyScope(tokenContext,\n                    OAuth2Scope.LIST_USER_CLIENT);\n            if(authorizedOnly){\n                return clientService.listUserAuthorizedClients(username,\n                        superClientId, superClientSecret);\n            }\n            else {\n                return clientService.listUserRegisteredClients(username,\n                        superClientId, superClientSecret);                \n            }\n        }\n        catch (KustvaktException e) {\n            throw responseHandler.throwit(e);\n        }\n    }\n"]], "pred": {"ppl": 2.04219651222229, "ppl_lower": 2.335519790649414, "ppl/lowercase_ppl": -1.1879602897125119, "ppl/zlib": 0.00040801482873410787, "Min_5.0% Prob": 6.6130346036424825, "Min_10.0% Prob": 4.935530924329571, "Min_20.0% Prob": 3.216674846761367, "Min_30.0% Prob": 2.317760199503182, "Min_40.0% Prob": 1.7724922998537354, "Min_50.0% Prob": 1.4269559529086906, "Min_60.0% Prob": 1.191053219267196}}
{"hexsha": "ed3afa5d2bcb1c4c5b6946c9430be20597e9ff65", "ext": "java", "lang": "Java", "content": "public class BitcoinConf extends HashMap<String, String> {\n\n    public RPCConfig getRPCConfig() {\n        URI uri = null;\n        try {\n            uri = new URI(\"http://\" + get(\"rpcconnect\") + \":\" + get(\"rpcport\"));\n        } catch (URISyntaxException e) {\n            try {\n                uri = new URI(\"http://127.0.0.1:8332\");\n            } catch (URISyntaxException e1) {\n                throw new RuntimeException(\"Error creating RPC URI\", e1);\n            }\n        }\n        // TODO: Determine MainNet, TestNet, or RegTest from contents of .conf file\n        RPCConfig config = new RPCConfig(MainNetParams.get(), uri,\n                get(\"rpcuser\"), get(\"rpcpassword\"));\n        return config;\n    }\n}", "class_id": 0, "repo": "JeremyRand/consensusj", "file": "bitcoinj-rpcclient/src/main/java/com/msgilligan/bitcoinj/rpc/bitcoind/BitcoinConf.java", "last_update_at": "2018-05-24T02:11:13+00:00", "question_id": "ed3afa5d2bcb1c4c5b6946c9430be20597e9ff65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BitcoinConf extends HashMap<String, String> {\n    public RPCConfig getRPCConfig() {\n        URI uri = null;\n        try {\n            uri = new URI(\"http://\" + get(\"rpcconnect\") + \":\" + get(\"rpcport\"));\n        } catch (URISyntaxException e) {\n            try {\n                uri = new URI(\"http://127.0.0.1:8332\");\n            } catch (URISyntaxException e1) {\n                throw new RuntimeException(\"Error creating RPC URI\", e1);\n            }\n        }\n        // TODO: Determine MainNet, TestNet, or RegTest from contents of .conf file\n        RPCConfig config = new RPCConfig(MainNetParams.get(), uri,\n                get(\"rpcuser\"), get(\"rpcpassword\"));\n        return config;\n    }\n"]], "pred": {"ppl": 2.166782855987549, "ppl_lower": 2.5840084552764893, "ppl/lowercase_ppl": -1.2277398291314618, "ppl/zlib": 0.0022219641167703303, "Min_5.0% Prob": 7.95242486000061, "Min_10.0% Prob": 5.781696057319641, "Min_20.0% Prob": 3.5638589292037777, "Min_30.0% Prob": 2.495556369904549, "Min_40.0% Prob": 1.9258113343541214, "Min_50.0% Prob": 1.5465712194303864, "Min_60.0% Prob": 1.2886417509927865}}
{"hexsha": "744edbceebb73ca88ea42d43bb803206af553de6", "ext": "java", "lang": "Java", "content": "@Configuration\npublic class WebApplicationConfig implements WebMvcConfigurer {\n\n    /**\n     * Custom object mapper to make sure that dates and other values serialize\n     * correctly.\n     *\n     * @return A new object mapper.\n     */\n    private ObjectMapper objectMapper() {\n        Jackson2ObjectMapperFactoryBean bean = new Jackson2ObjectMapperFactoryBean();\n        bean.setIndentOutput(true);\n        bean.afterPropertiesSet();\n        ObjectMapper objectMapper = bean.getObject();\n        if (objectMapper != null) {\n            objectMapper.registerModule(new JavaTimeModule());\n            objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // replacement for ISO8601DateFormat which is deprecated\n        }\n        return objectMapper;\n    }\n\n    /**\n     * Set custom JSON converter.\n     *\n     * @return New custom converter with a correct object mapper.\n     */\n    private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {\n        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n        converter.setObjectMapper(objectMapper());\n        return converter;\n    }\n\n    /**\n     * Register the JSON converters.\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(mappingJackson2HttpMessageConverter());\n    }\n\n}", "class_id": 0, "repo": "lime-company/powerauth-webflow", "file": "powerauth-webflow-client/src/main/java/io/getlime/security/powerauth/app/webflow/demo/configuration/WebApplicationConfig.java", "last_update_at": "2018-03-24T16:37:54+00:00", "question_id": "744edbceebb73ca88ea42d43bb803206af553de6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Configuration\npublic class WebApplicationConfig implements WebMvcConfigurer {\n    /**\n     * Custom object mapper to make sure that dates and other values serialize\n     * correctly.\n     *\n     * @return A new object mapper.\n     */\n    private ObjectMapper objectMapper() {\n        Jackson2ObjectMapperFactoryBean bean = new Jackson2ObjectMapperFactoryBean();\n        bean.setIndentOutput(true);\n        bean.afterPropertiesSet();\n        ObjectMapper objectMapper = bean.getObject();\n        if (objectMapper != null) {\n            objectMapper.registerModule(new JavaTimeModule());\n            objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // replacement for ISO8601DateFormat which is deprecated\n        }\n        return objectMapper;\n    }\n    /**\n     * Set custom JSON converter.\n     *\n     * @return New custom converter with a correct object mapper.\n     */\n    private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {\n        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n        converter.setObjectMapper(objectMapper());\n        return converter;\n    }\n    /**\n     * Register the JSON converters.\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(mappingJackson2HttpMessageConverter());\n    }\n"]], "pred": {"ppl": 1.9467542171478271, "ppl_lower": 2.3644697666168213, "ppl/lowercase_ppl": -1.291805720751245, "ppl/zlib": 0.001213412535014464, "Min_5.0% Prob": 6.621211051940918, "Min_10.0% Prob": 4.8938860612757065, "Min_20.0% Prob": 3.158481337568339, "Min_30.0% Prob": 2.2078146372793936, "Min_40.0% Prob": 1.669743733110783, "Min_50.0% Prob": 1.3311696787860396, "Min_60.0% Prob": 1.1111101085757382}}
{"hexsha": "5034c8c4401260d65dcb92364ee41954bc827226", "ext": "java", "lang": "Java", "content": "public class PlanetRadar extends Starship{\r\n\t\r\n\tstatic Texture tex1 = new Texture(\"WIP.png\");\r\n\t\r\n\tpublic PlanetRadar(StarshipArena mygame, double spawnx, double spawny){\r\n\t\tsuper(mygame, spawnx, spawny);\r\n\t}\r\n\t\r\n\tpublic PlanetRadar(StarshipArena mygame, double spawnx, double spawny, double spawnangle){\r\n\t\tsuper(mygame, \"none\", spawnx, spawny, spawnangle);\r\n\t}\r\n\r\n\tpublic PlanetRadar(StarshipArena mygame, String newteam, double spawnx, double spawny, double spawnangle){\r\n\t\tsuper(mygame, newteam, spawnx, spawny, spawnangle);\r\n\t}\r\n\t\r\n\tpublic void shipStats(){\r\n\t\tmax_health = 100;\r\n\t\tscan_range = 10000;\r\n\t\tradar_range = 10000;\r\n\t\t//movement\r\n\t\tacceleration = 0;\r\n\t\tmax_velocity = 0;\r\n\t\tmin_turn_velocity = 0;\r\n\t\tmax_turn_speed = 1;\r\n\t\tcurrent_turn_speed = -max_turn_speed;\r\n\t\t//other\r\n\t\tclickRadius = 45;\r\n\t\txOff = 0;\r\n\t\tyOff = 0;\r\n\t}\r\n\t\r\n\tpublic void setTexture(){\r\n\t\ttex1.bind();\r\n\t}\r\n\t\r\n\tpublic void setTextureCoords(){\r\n\t\ttextureCoords = new double[]{0, 0, 0, 1, 1, 0, 1, 1};\r\n\t}\r\n\t\r\n\tpublic void setIndices(){\r\n\t\tindices = new int[]{0, 1, 2, 2, 1, 3};\r\n\t}\r\n\t\r\n\tpublic Point[] generatePoints(){\r\n\t\tPoint[] points = new Point[]{\r\n\t\t\tnew Point(-32, 32, true),\r\n\t\t\tnew Point(-32, -32, true),\r\n\t\t\tnew Point(32, 32, true),\r\n\t\t\tnew Point(32, -32, true)\r\n\t\t};\r\n\t\treturn points;\r\n\t}\r\n\t\r\n\tpublic Point[] generateHitbox(){\r\n\t\tPoint[] hitbox = new Point[]{\r\n\t\t\tnew Point(-32, 32, true),\r\n\t\t\tnew Point(-32, -32, true),\r\n\t\t\tnew Point(32, 32, true),\r\n\t\t\tnew Point(32, -32, true)\r\n\t\t};\r\n\t\treturn hitbox;\r\n\t}\r\n\t\r\n\t\r\n}", "class_id": 0, "repo": "ShatteredIce/StarshipArena", "file": "StarshipArena/src/entities/PlanetRadar.java", "last_update_at": "2018-01-28T05:28:28+00:00", "question_id": "5034c8c4401260d65dcb92364ee41954bc827226", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PlanetRadar extends Starship{\r\n\t\r\n\tstatic Texture tex1 = new Texture(\"WIP.png\");\r\n\t\r\n\tpublic PlanetRadar(StarshipArena mygame, double spawnx, double spawny){\r\n\t\tsuper(mygame, spawnx, spawny);\r\n\t}\r\n\t\r\n\tpublic PlanetRadar(StarshipArena mygame, double spawnx, double spawny, double spawnangle){\r\n\t\tsuper(mygame, \"none\", spawnx, spawny, spawnangle);\r\n\t}\r\n\r\n\tpublic PlanetRadar(StarshipArena mygame, String newteam, double spawnx, double spawny, double spawnangle){\r\n\t\tsuper(mygame, newteam, spawnx, spawny, spawnangle);\r\n\t}\r\n\t\r\n\tpublic void shipStats(){\r\n\t\tmax_health = 100;\r\n\t\tscan_range = 10000;\r\n\t\tradar_range = 10000;\r\n\t\t//movement\r\n\t\tacceleration = 0;\r\n\t\tmax_velocity = 0;\r\n\t\tmin_turn_velocity = 0;\r\n\t\tmax_turn_speed = 1;\r\n\t\tcurrent_turn_speed = -max_turn_speed;\r\n\t\t//other\r\n\t\tclickRadius = 45;\r\n\t\txOff = 0;\r\n\t\tyOff = 0;\r\n\t}\r\n\t\r\n\tpublic void setTexture(){\r\n\t\ttex1.bind();\r\n\t}\r\n\t\r\n\tpublic void setTextureCoords(){\r\n\t\ttextureCoords = new double[]{0, 0, 0, 1, 1, 0, 1, 1};\r\n\t}\r\n\t\r\n\tpublic void setIndices(){\r\n\t\tindices = new int[]{0, 1, 2, 2, 1, 3};\r\n\t}\r\n\t\r\n\tpublic Point[] generatePoints(){\r\n\t\tPoint[] points = new Point[]{\r\n\t\t\tnew Point(-32, 32, true),\r\n\t\t\tnew Point(-32, -32, true),\r\n\t\t\tnew Point(32, 32, true),\r\n\t\t\tnew Point(32, -32, true)\r\n\t\t};\r\n\t\treturn points;\r\n\t}\r\n\t\r\n\tpublic Point[] generateHitbox(){\r\n\t\tPoint[] hitbox = new Point[]{\r\n\t\t\tnew Point(-32, 32, true),\r\n\t\t\tnew Point(-32, -32, true),\r\n\t\t\tnew Point(32, 32, true),\r\n\t\t\tnew Point(32, -32, true)\r\n\t\t};\r\n\t\treturn hitbox;\r\n\t}\r\n\t\r\n\t\r\n"]], "pred": {"ppl": 1.8579638004302979, "ppl_lower": 1.8869026899337769, "ppl/lowercase_ppl": -1.0249491677002942, "ppl/zlib": 0.0013265121137431436, "Min_5.0% Prob": 6.617965943885572, "Min_10.0% Prob": 4.751730313941614, "Min_20.0% Prob": 2.8880710778412997, "Min_30.0% Prob": 2.0201320897035413, "Min_40.0% Prob": 1.5394502781688948, "Min_50.0% Prob": 1.2376295218304634, "Min_60.0% Prob": 1.0327342241872057}}
{"hexsha": "28f7a961cc08d2ec2738c8c957ece8a3c017d30c", "ext": "java", "lang": "Java", "content": "public abstract class BaseTestsHelper extends IntegrationTestBase\n{\n\n    private final static Logger logger = LoggerFactory.getLogger(BaseTestsHelper.class);\n\n    protected final CorePolicyObjectMapper mapper = new CorePolicyObjectMapper();\n    protected static String INPUT_QUEUENAME = \"Input\";\n    protected static String RESULT_QUEUENAME = \"Results\";\n\n    //number of seconds allowed to wait for result to be delivered to results queue consumer\n    protected static int RESULT_TIMEOUTSECONDS;\n    protected static String RABBIT_HOST = \"localhost\";\n    protected static String RABBIT_USER = \"guest\";\n    protected static String RABBIT_PASS = \"guest\";\n    protected static int RABBIT_PORT = 5672;\n\n    protected static com.rabbitmq.client.Connection rabbitConnection;\n\n    protected final AnnotationConfigApplicationContext testingPropertiesApplicationContext;\n    protected final PolicyWorkerTestingProperties properties;\n\n    EventPoller<QueuePublisher> publisher;\n    DefaultRabbitConsumer consumer;\n    TestQueueConsumerImpl consumerImpl;\n\n    public BaseTestsHelper()\n    {\n\n        testingPropertiesApplicationContext = new AnnotationConfigApplicationContext();\n        testingPropertiesApplicationContext.register(ConversionConfiguration.class);\n        testingPropertiesApplicationContext.register(PropertySourcesPlaceholderConfigurer.class);\n        RootBeanDefinition beanDefinition = new RootBeanDefinition();\n        beanDefinition.setBeanClass(PolicyWorkerTestingProperties.class);\n        testingPropertiesApplicationContext.registerBeanDefinition(\"PolicyWorkerTestingProperties\", beanDefinition);\n        testingPropertiesApplicationContext.refresh();\n\n        properties = testingPropertiesApplicationContext.getBean(PolicyWorkerTestingProperties.class);\n    }\n\n    public static void RabbitConnectionSetup() throws TimeoutException, IOException\n    {\n        rabbitConnection = RabbitHelper.getRabbitConnection(RABBIT_HOST, RABBIT_PORT, RABBIT_USER, RABBIT_PASS);\n    }\n\n    @Before\n    public void SetupRabbitQueues() throws IOException, TimeoutException {\n        if(rabbitConnection==null) {\n            INPUT_QUEUENAME = properties.getInputQueueName();\n            RESULT_QUEUENAME = properties.getResultQueueName();\n            RESULT_TIMEOUTSECONDS = properties.getResultTimeoutSeconds();\n            RABBIT_HOST = properties.getRabbitHost();\n            RABBIT_USER = properties.getRabbitUser();\n            RABBIT_PASS = properties.getRabbitPass();\n            RABBIT_PORT = properties.getRabbitPort();\n            RabbitConnectionSetup();\n\n            // the queues might not exist yet, if not do so now\n            Channel inputChannel = rabbitConnection.createChannel();\n            Channel resultsChannel = rabbitConnection.createChannel();\n\n            RabbitUtil.declareWorkerQueue(inputChannel, INPUT_QUEUENAME, 32);\n            RabbitUtil.declareWorkerQueue(resultsChannel, RESULT_QUEUENAME, 32);\n\n            CloseChannel(inputChannel);\n            CloseChannel(resultsChannel);\n        }\n\n        ClearRabbitQueues();\n    }\n\n    public static void ClearRabbitQueues() throws IOException\n    {\n        //clear input and result queues before each test\n        PurgeQueue(INPUT_QUEUENAME);\n        PurgeQueue(RESULT_QUEUENAME);\n    }\n\n    @AfterClass\n    public static void StaticCleanup() throws IOException\n    {\n        //clear queues after tests ran\n        ClearRabbitQueues();\n        rabbitConnection.close();\n        rabbitConnection = null;\n    }\n\n    public static void PurgeQueue(String queueName) throws IOException\n    {\n        Channel channel = rabbitConnection.createChannel();\n        PurgeQueue(channel, queueName);\n        CloseChannel(channel);\n    }\n\n    public static void PurgeQueue(Channel channel, String queueName) throws IOException\n    {\n        channel.queuePurge(queueName);\n    }\n\n    public static void CloseChannel(Channel channel) throws IOException {\n        try {\n            channel.close();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected void closeRabbitConnections(Channel resultsChannel, ConsumerCreationResult consumerResult)\n    {\n        try {\n            consumer.shutdown();\n            publisher.shutdown();\n            try {\n                resultsChannel.basicCancel(consumerResult.getConsumeId());\n            } catch (IOException ex) {\n                getLogger().warn(\"Failed to cancel results channel: \", ex);\n            }\n            try {\n                resultsChannel.close();\n            } catch (IOException | TimeoutException ex) {\n                getLogger().warn(\"Failed to close results channel: \", ex);\n            }\n        } catch (Exception ex) {\n            // dont let normal shutdown type issues cause a failure in the tests, this can happen in debugging, and we dont\n            // want the shutdown of the queue being the recorded reason for the failure.\n        }\n    }\n\n    protected CollectionSequence SetupCollectionSequence(ClassificationApi classificationApi, Long collectionId,\n                                                         boolean returnCollectionSequenceInstead)\n    {\n        CollectionSequence collectionSequence = new CollectionSequence();\n        collectionSequence.name = getUniqueString(\"ClassifyDocumentApiIT::setup_\");\n        collectionSequence.description = \"Used in ClassifyDocumentApiIT tests.\";\n        collectionSequence.collectionSequenceEntries = new ArrayList<>();\n        CollectionSequenceEntry collectionSequenceEntry = new CollectionSequenceEntry();\n        collectionSequenceEntry.collectionIds = new HashSet<>(Arrays.asList(collectionId));\n        collectionSequenceEntry.stopOnMatch = false;\n        collectionSequenceEntry.order = 400;\n        collectionSequence.collectionSequenceEntries.add(collectionSequenceEntry);\n\n        collectionSequence = classificationApi.create(collectionSequence);\n\n        if (returnCollectionSequenceInstead) {\n            return collectionSequence;\n        }\n\n        throw new RuntimeException(\"This method is not used anymore!!\");\n    }\n\n    protected DocumentCollection SetupCollection(Collection<Long> overridePolicyIds)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        NumberCondition numberCondition = new NumberCondition();\n        numberCondition.name = \"afield condition 1\";\n        numberCondition.field = \"afield\";\n        numberCondition.operator = NumberOperatorType.EQ;\n        numberCondition.value = 1L;\n\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection 1\";\n\n        collection1.policyIds = new HashSet<>();\n        if (overridePolicyIds != null) {\n            collection1.policyIds.addAll(overridePolicyIds);\n        }\n        collection1.condition = numberCondition;\n\n        collection1 = classificationApi.create(collection1);\n\n        return collection1;\n\n    }\n\n    protected CollectionSequence SetupCollectionSequence(DocumentCollection collection)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        return SetupCollectionSequence(classificationApi, collection.id, true);\n    }\n\n    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds)\n    {\n        return SetupCollectionSequenceWithPolicies(defaultPolicyIds, null);\n    }\n\n    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds,\n                                                                     final Collection<Long> overridePolicyIds)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        NumberCondition numberCondition = new NumberCondition();\n        numberCondition.name = \"afield condition 1\";\n        numberCondition.field = \"afield\";\n        numberCondition.operator = NumberOperatorType.EQ;\n        numberCondition.value = 1L;\n\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection 1\";\n\n        collection1.policyIds = new HashSet<>();\n        if (overridePolicyIds == null) {\n            collection1.policyIds.addAll(defaultPolicyIds);\n        } else {\n            collection1.policyIds.addAll(overridePolicyIds);\n        }\n        collection1.condition = numberCondition;\n\n        collection1 = classificationApi.create(collection1);\n\n        return SetupCollectionSequence(classificationApi, collection1.id, true);\n    }\n\n    protected Collection<Long> SetupPoliciesWithNoHandlersAvailable() throws IOException\n    {\n        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);\n        //register new policy type that will have no handlers associated\n        MetadataPolicy metadataPolicy = new MetadataPolicy();\n        metadataPolicy.setFieldActions(new ArrayList<>());\n        FieldAction fieldAction = new FieldAction();\n        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);\n        fieldAction.setFieldName(\"EXTERNAL_TEST\");\n        fieldAction.setFieldValue(\"1\");\n        metadataPolicy.getFieldActions().add(fieldAction);\n\n        PolicyType policyType = createCustomPolicyType(policyApi, getUniqueString(\"NoHandler\"), null);\n\n        Policy policy = new Policy();\n        policy.name = \"Policy\";\n        policy.details = mapper.valueToTree(metadataPolicy);\n        policy.typeId = policyType.id;\n        policy.priority = 100;\n        policy = policyApi.create(policy);\n\n        ArrayList<Long> noHandlers = new ArrayList<>();\n        noHandlers.add(policy.id);\n        return noHandlers;\n    }\n\n    protected PolicyType createCustomPolicyType(PolicyApi policyApi, final String uniqueName, final String uniqueShortName)\n    {\n        PolicyType policyType = new PolicyType();\n        policyType.conflictResolutionMode = ConflictResolutionMode.PRIORITY;\n        policyType.name = uniqueName;\n        policyType.shortName = Strings.isNullOrEmpty(uniqueShortName) ? getUniqueString(\"\") : uniqueShortName;\n        JsonNodeFactory nodeFactory = new JsonNodeFactory(false);\n        policyType.definition = nodeFactory.objectNode();\n        policyType = policyApi.create(policyType);\n        return policyType;\n    }\n\n    public static String getUniqueString(String strPrefix)\n    {\n        return strPrefix + UUID.randomUUID().toString();\n    }\n\n    protected LinkedList<Long> SetupPolicies() throws IOException\n    {\n        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);\n\n        MetadataPolicy metadataPolicy = new MetadataPolicy();\n        metadataPolicy.setFieldActions(new ArrayList<>());\n        FieldAction fieldAction = new FieldAction();\n        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);\n        fieldAction.setFieldName(\"EXTERNAL_TEST\");\n        fieldAction.setFieldValue(\"1\");\n        metadataPolicy.getFieldActions().add(fieldAction);\n\n        PolicyType policyType = policyApi.retrievePolicyTypeByName(\"MetadataPolicy\");\n        Policy policy = new Policy();\n        policy.name = \"Policy\";\n        policy.details = mapper.valueToTree(metadataPolicy);\n        policy.typeId = policyType.id;\n        policy.priority = 100;\n        policy = policyApi.create(policy);\n\n        LinkedList<Long> policyIds = new LinkedList<>();\n        policyIds.add(policy.id);\n\n        return policyIds;\n    }\n\n    protected DocumentCollection getDocumentCollection(long colId) throws Exception\n    {\n        Collection<DocumentCollection> collections = getClassificationApi().retrieveCollections(Arrays.asList(colId), true, false);\n        if (collections.isEmpty()) {\n            throw new Exception(\"Failed to find document collection id: \" + colId);\n        }\n\n        return collections.stream().filter(u -> u.id.equals(colId)).findFirst().get();\n    }\n\n    protected PolicyType createCustomExternalClassificationPolicyType(PolicyApi policyApi, String ptName, String ptShortName,\n                                                                      String ptDesc, String ptJsonDefinition)\n        throws IOException\n    {\n\n        PolicyType policyType = new PolicyType();\n        policyType.name = getUniqueString(ptName);\n        policyType.shortName = ptShortName;\n        policyType.description = ptDesc;\n        policyType.definition = mapper.readTree(ptJsonDefinition);\n\n        return policyApi.create(policyType);\n    }\n\n    protected Policy createCustomExternalClassificationPolicy(PolicyApi policyApi, PolicyType policyType, CollectionSequence colSeq,\n                                                              String polName, Integer polPriority, String queueName) throws IOException\n    {\n\n        String policyDef = \"{\\\"classificationSequenceId\\\":\" + colSeq.id + \",\\\"queueName\\\":\\\"\" + queueName + \"\\\"}\";\n        ObjectMapper mapper = new ObjectMapper();\n        Policy policy = new Policy();\n        policy.name = polName;\n        policy.details = mapper.readTree(policyDef);\n        policy.typeId = policyType.id;\n        policy.priority = polPriority;\n\n        return policyApi.create(policy);\n    }\n\n    protected DocumentCollection getWorkflowDocumentCollection(ClassificationApi classificationApi, Condition anyCondition)\n    {\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection to drive workflow custom policy\";\n        collection1.condition = anyCondition;\n        collection1 = classificationApi.create(collection1);\n        return collection1;\n    }\n\n    protected DocumentCollection addPoliciesToDocumentCollection(ClassificationApi classificationApi, DocumentCollection collection,\n                                                                 Collection<Long> policyIds)\n    {\n        collection.policyIds = new HashSet<>();\n        collection.policyIds.addAll(policyIds);\n        DocumentCollection collection1 = classificationApi.update(collection);\n        return collection1;\n    }\n\n    protected void checkClassifyResult(com.github.cafdataprocessing.worker.policy.shared.ClassifyDocumentResult classifyResult,\n                                       Collection<Long> policyIds, DocumentCollection collection)\n    {\n        //check no incomplete collections returned\n        Collection<Long> incomplete = classifyResult.getIncompleteCollections();\n        Assert.assertEquals(0, incomplete.size());\n\n        //check expected policy was resolved\n        Collection<Long> resolvedPolicies = classifyResult.getResolvedPolicies();\n        Assert.assertArrayEquals(policyIds.toArray(), resolvedPolicies.toArray());\n\n        //check that the collection we expected is the one matched\n        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCollection> matchedCollections = classifyResult.getMatchedCollections();\n        Assert.assertEquals(1, matchedCollections.size());\n        com.github.cafdataprocessing.worker.policy.shared.MatchedCollection matchedCollection = matchedCollections.iterator().next();\n\n        Assert.assertEquals(collection.id, matchedCollection.getId());\n        Assert.assertEquals(collection.name, matchedCollection.getName());\n        //check the condition on the collection\n        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCondition> matchedConditions = matchedCollection.getMatchedConditions();\n        assertTrue(\"Number of matched conditions should be positive \", matchedConditions.size() > 0);\n        com.github.cafdataprocessing.worker.policy.shared.MatchedCondition matchedCondition = matchedConditions.stream().filter(u -> u.getId().equals(\n            collection.condition.id)).findFirst().get();\n        // compare the 2 top root condition matches at least, everything below should be fine\n        // in our present test scenario.\n        Assert.assertEquals(collection.condition.id, matchedCondition.getId());\n        Assert.assertEquals(collection.condition.name, matchedCondition.getName());\n\n        //check the policy on the collection\n        Collection<com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy> matchedPolicies = matchedCollection.getPolicies();\n        Assert.assertEquals(collection.policyIds.size(), matchedPolicies.size());\n        if (!matchedPolicies.isEmpty()) {\n            com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy matchedPolicy = matchedPolicies.iterator().next();\n            Assert.assertEquals(collection.policyIds.iterator().next(), matchedPolicy.getId());\n        }\n    }\n\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_SUCCESS\n     */\n    protected void checkTaskMessageReturned(TaskMessage resultWrapper, String expectedTaskId)\n    {\n        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_SUCCESS);\n    }\n\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_EXCEPTION\n     */\n    protected void checkTaskMessageReturnedException(TaskMessage resultWrapper, String expectedTaskId)\n    {\n        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_EXCEPTION);\n    }\n\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_FAILURE\n     */\n    protected void checkTaskMessageReturnedTaskStatus(TaskMessage resultWrapper, String expectedTaskId, TaskStatus expectedStatus)\n    {\n        //check that this has the task ID we specified when adding to Input Queue\n        Assert.assertEquals(expectedTaskId, resultWrapper.getTaskId());\n        TaskStatus status = resultWrapper.getTaskStatus();\n        //check that task status is x\n        Assert.assertEquals(expectedStatus, status);\n    }\n\n    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(final BlockingQueue<Event<QueuePublisher>> pubEvents,\n                                                                  final ConsumerCreationResult consumerResult,\n                                                                  final TaskMessage classifyMessage, final String taskMessageExpected)\n        throws InterruptedException, CodecException, JsonProcessingException\n    {\n        return publishTaskAndAwaitResultAsTaskMessage(pubEvents, consumerResult.getLatch(), classifyMessage, taskMessageExpected);\n    }\n\n    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(BlockingQueue<Event<QueuePublisher>> pubEvents,\n                                                                  ConsumerCreationResult consumerResult, TaskMessage classifyMessage)\n        throws InterruptedException, CodecException, JsonProcessingException\n    {\n        return publishTaskAndAwaitThisMessagesResponse(pubEvents, consumerResult, classifyMessage, null);\n    }\n\n    /*\n        Utility method to publish a task to input queue and attempt to read the expected taskId back as a response from results queue.\n     */\n    protected TaskMessage publishTaskAndAwaitResultAsTaskMessage(BlockingQueue<Event<QueuePublisher>> pubEvents, CountDownLatch latch,\n                                                                 TaskMessage message, String expectedTaskMessage)\n        throws InterruptedException, JsonProcessingException, CodecException\n    {\n        //add message to input queue\n        //pubEvents.add(new PublishQueueEvent(PublishEventType.PUBLISH, 0L, mapper.writeValueAsBytes(message), INPUT_QUEUENAME));\n        pubEvents.add(new PublisherPublishEvent(mapper.writeValueAsBytes(message)));\n\n        Delivery deliveredResult = null;\n        final String awaitThisMessage = Strings.isNullOrEmpty(expectedTaskMessage) ? message.getTaskId() : expectedTaskMessage;\n\n        //give some time for task to be processed and result consumed (result consumer should update latch on consumption)\n        final boolean timeout = !latch.await(RESULT_TIMEOUTSECONDS, TimeUnit.SECONDS);\n\n        return getResultAsTaskMessage(awaitThisMessage, timeout);\n\n    }\n\n    /**\n     * Utility method to get a specific message from the queue without any waiting.\n     *\n     * @param getThisMessage\n     * @return\n     */\n    protected TaskMessage getResultAsTaskMessage(String getThisMessage)\n    {\n        return getResultAsTaskMessage(getThisMessage, false);\n    }\n\n    /**\n     * Utility method to get a specific message from the queue without any waiting.\n     *\n     * @param awaitThisMessage\n     * @param timeout\n     * @return\n     */\n    private TaskMessage getResultAsTaskMessage(String awaitThisMessage, boolean timeout)\n    {\n        Delivery deliveredResult;\n        deliveredResult = consumerImpl.getDelivery(awaitThisMessage);\n\n        if (timeout && deliveredResult == null) {\n            // timeout happened while waiting on the given message, make final check for delivery then give up.\n            logger.error(\"Timeout happened while waiting for the response to taskId: \" + awaitThisMessage);\n            throw new RuntimeException(\"Timeout happened while waiting for the response to taskId: \" + awaitThisMessage);\n        }\n\n        // check if we haven't got a result, try relatching and waiting again -> we should only return from here with correct response or timeout.\n        if (deliveredResult == null) {\n            // the latch has fired, so the message queue filter has received a message the user was interested in, but they then requested\n            // an item that wasn't in the queue yet.\n            // This can happen if you do something like this: filter by taskId: 123.\n            // Request child 123.2*, but the queue can accept 123 / 123.1 and 123.2, so any arriving will wake this code up.\n            // We can either go back to latching for another message OR I have opted to throw, and fix the tests to filter better to only\n            // the message you want.  So change here would be to use filter: 123.2, and publishAndAwait on the same 123.2 id.\n            logger.warn(\"Failed to locate the message you requested taskId: \" + awaitThisMessage);\n\n            debugCurrentQueueItems();\n\n            throw new RuntimeException(\n                \"Failed to locate the message you requested taskId: \" + awaitThisMessage + \"\\nBut the message queue did receive a valid item matching the filter id.  Please make sure that you aren't allowing more than 1 item in your filter list ( and are latching on count 1) if you want a specific child only:\\n\"\n                + \"Ensure that the queue latch=1, and change the queue filter, or increase the latch to the number of children that the workflow accepts into the queue.\");\n        }\n\n        TaskMessage resultMessage = getTaskMessageFromDelivery(deliveredResult);\n        return resultMessage;\n    }\n\n    private void debugCurrentQueueItems()\n    {\n        logger.warn(\"Message queue currently contains: \" + consumerImpl.getDelivery().size());\n\n        // do we have any items on the queue at all, if so, output what we have?\n        for (Map.Entry<String, Delivery> deliveredItem : consumerImpl.getDelivery().entrySet()) {\n            Delivery tmpDel = deliveredItem.getValue();\n            TaskMessage tm = getTaskMessageFromDelivery(tmpDel);\n            logger.warn(\n                String.format(\"Queue contains other item: {%s} TrackingInfo jobTaskId: {%s}\",\n                              tm.getTaskId(), tm.getTracking() == null ? \"null\" : tm.getTracking().getJobTaskId()));\n        }\n    }\n\n    /**\n     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param workflowId\n     * @param executePolicy\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                        final Long workflowId, final boolean executePolicy)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n\n        TaskMessage classifyMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           workflowId.toString(), executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return classifyMessage;\n    }\n\n    /**\n     * Create policy worker task message to classify and execute on a document, given a set of collection sequence identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param collectionSequenceIds\n     * @param executePolicy\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                        final List<String> collectionSequenceIds, final boolean executePolicy)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n\n        TaskMessage classifyMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           collectionSequenceIds, executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return classifyMessage;\n    }\n\n    /**\n     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param workflowId\n     * @param collectionSequenceIds\n     * @param policyIds\n     * @param executePolicy\n     * @param executeOnly\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                      final Long workflowId, final List<String> collectionSequenceIds,\n                                                      final Collection<Long> policyIds, final boolean executePolicy,\n                                                      final boolean executeOnly)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n\n        if (executeOnly) {\n            final TaskMessage taskMessage = TestTaskMessageHelper.getExecuteTaskMessage(taskId, taskClassifier, document, policyIds,\n                                                                                     getProjectId(), collectionSequenceIds, INPUT_QUEUENAME, trackingInfo);\n            return taskMessage;\n        }\n        \n        final TaskMessage taskMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           workflowId.toString(), executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return taskMessage;\n    }\n\n    protected TrackingInfo createTrackingInfo(String taskId)\n    {\n        TrackingInfo trackingInfo = new TrackingInfo();\n        trackingInfo.setTrackingPipe(properties.getJobTrackingPipe());\n        trackingInfo.setJobTaskId(taskId);\n        // if we need to set this, set to rubbish to never remove the tracking info.\n        trackingInfo.setTrackTo(\"xyz\");\n        return trackingInfo;\n    }\n\n    /*\n        Utility method to create publisher to put messages onto an input channel. Returns the publish queue for messages to added to\n     */\n    protected BlockingQueue<Event<QueuePublisher>> createRabbitPublisher(Channel inputChannel)\n    {\n        BlockingQueue<Event<QueuePublisher>> pubEvents = new LinkedBlockingQueue<>();\n        TestQueuePublisherImpl publisherImpl = new TestQueuePublisherImpl(inputChannel, INPUT_QUEUENAME);\n        this.publisher = new EventPoller<>(2, pubEvents, publisherImpl);\n        new Thread(publisher).start();\n        return pubEvents;\n    }\n\n    protected class ConsumerCreationResult\n    {\n        private CountDownLatch latch;\n        private String consumeId;\n\n        public ConsumerCreationResult(CountDownLatch latch, String consumeId)\n        {\n            this.latch = latch;\n            this.consumeId = consumeId;\n        }\n\n        public CountDownLatch getLatch()\n        {\n            return latch;\n        }\n\n        public String getConsumeId()\n        {\n            return consumeId;\n        }\n    }\n\n    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,\n                                                          final int latchCount, final String taskIdFilter)\n        throws IOException\n    {\n        return createRabbitConsumer(resultsChannel, conEvents, RESULT_QUEUENAME, 1, taskIdFilter);\n    }\n\n    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,\n                                                          String queueName, int latchCount, final String taskIdFilter)\n        throws IOException\n    {\n        CountDownLatch latch = new CountDownLatch(latchCount);\n        RabbitUtil.declareWorkerQueue(resultsChannel, queueName, 32);\n        this.consumerImpl = new TestQueueConsumerImpl(latch, conEvents, resultsChannel, taskIdFilter);\n        this.consumer = new DefaultRabbitConsumer(conEvents, consumerImpl);\n        String consumeId = resultsChannel.basicConsume(queueName, consumer);\n        new Thread(consumer).start();\n        return new ConsumerCreationResult(latch, consumeId);\n    }\n\n    /*\n        Utility class used to publish messages onto a RabbitMQ queue\n     */\n    protected class TestQueuePublisherImpl implements QueuePublisher\n    {\n        private final Channel channel;\n        private final String queueName;\n\n        public TestQueuePublisherImpl(final Channel ch, final String queue)\n        {\n            this.channel = Objects.requireNonNull(ch);\n            this.queueName = Objects.requireNonNull(queue);\n        }\n\n        @Override\n        public void handlePublish(final byte[] data)\n        {\n            try {\n                channel.basicPublish(\"\", queueName, MessageProperties.TEXT_PLAIN, data);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}", "class_id": 0, "repo": "CAFDataProcessing/worker-policy", "file": "worker-policy-testing/src/main/java/com/github/cafdataprocessing/worker/policy/testing/shared/BaseTestsHelper.java", "last_update_at": "2018-02-27T13:53:05+00:00", "question_id": "28f7a961cc08d2ec2738c8c957ece8a3c017d30c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class BaseTestsHelper extends IntegrationTestBase\n{\n    private final static Logger logger = LoggerFactory.getLogger(BaseTestsHelper.class);\n    protected final CorePolicyObjectMapper mapper = new CorePolicyObjectMapper();\n    protected static String INPUT_QUEUENAME = \"Input\";\n    protected static String RESULT_QUEUENAME = \"Results\";\n    //number of seconds allowed to wait for result to be delivered to results queue consumer\n    protected static int RESULT_TIMEOUTSECONDS;\n    protected static String RABBIT_HOST = \"localhost\";\n    protected static String RABBIT_USER = \"guest\";\n    protected static String RABBIT_PASS = \"guest\";\n    protected static int RABBIT_PORT = 5672;\n    protected static com.rabbitmq.client.Connection rabbitConnection;\n    protected final AnnotationConfigApplicationContext testingPropertiesApplicationContext;\n    protected final PolicyWorkerTestingProperties properties;\n    EventPoller<QueuePublisher> publisher;\n    DefaultRabbitConsumer consumer;\n    TestQueueConsumerImpl consumerImpl;\n    public BaseTestsHelper()\n    {\n        testingPropertiesApplicationContext = new AnnotationConfigApplicationContext();\n        testingPropertiesApplicationContext.register(ConversionConfiguration.class);\n        testingPropertiesApplicationContext.register(PropertySourcesPlaceholderConfigurer.class);\n        RootBeanDefinition beanDefinition = new RootBeanDefinition();\n        beanDefinition.setBeanClass(PolicyWorkerTestingProperties.class);\n        testingPropertiesApplicationContext.registerBeanDefinition(\"PolicyWorkerTestingProperties\", beanDefinition);\n        testingPropertiesApplicationContext.refresh();\n        properties = testingPropertiesApplicationContext.getBean(PolicyWorkerTestingProperties.class);\n    }\n    public static void RabbitConnectionSetup() throws TimeoutException, IOException\n    {\n        rabbitConnection = RabbitHelper.getRabbitConnection(RABBIT_HOST, RABBIT_PORT, RABBIT_USER, RABBIT_PASS);\n    }\n    @Before\n    public void SetupRabbitQueues() throws IOException, TimeoutException {\n        if(rabbitConnection==null) {\n            INPUT_QUEUENAME = properties.getInputQueueName();\n            RESULT_QUEUENAME = properties.getResultQueueName();\n            RESULT_TIMEOUTSECONDS = properties.getResultTimeoutSeconds();\n            RABBIT_HOST = properties.getRabbitHost();\n            RABBIT_USER = properties.getRabbitUser();\n            RABBIT_PASS = properties.getRabbitPass();\n            RABBIT_PORT = properties.getRabbitPort();\n            RabbitConnectionSetup();\n            // the queues might not exist yet, if not do so now\n            Channel inputChannel = rabbitConnection.createChannel();\n            Channel resultsChannel = rabbitConnection.createChannel();\n            RabbitUtil.declareWorkerQueue(inputChannel, INPUT_QUEUENAME, 32);\n            RabbitUtil.declareWorkerQueue(resultsChannel, RESULT_QUEUENAME, 32);\n            CloseChannel(inputChannel);\n            CloseChannel(resultsChannel);\n        }\n        ClearRabbitQueues();\n    }\n    public static void ClearRabbitQueues() throws IOException\n    {\n        //clear input and result queues before each test\n        PurgeQueue(INPUT_QUEUENAME);\n        PurgeQueue(RESULT_QUEUENAME);\n    }\n    @AfterClass\n    public static void StaticCleanup() throws IOException\n    {\n        //clear queues after tests ran\n        ClearRabbitQueues();\n        rabbitConnection.close();\n        rabbitConnection = null;\n    }\n    public static void PurgeQueue(String queueName) throws IOException\n    {\n        Channel channel = rabbitConnection.createChannel();\n        PurgeQueue(channel, queueName);\n        CloseChannel(channel);\n    }\n    public static void PurgeQueue(Channel channel, String queueName) throws IOException\n    {\n        channel.queuePurge(queueName);\n    }\n    public static void CloseChannel(Channel channel) throws IOException {\n        try {\n            channel.close();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n    }\n    protected void closeRabbitConnections(Channel resultsChannel, ConsumerCreationResult consumerResult)\n    {\n        try {\n            consumer.shutdown();\n            publisher.shutdown();\n            try {\n                resultsChannel.basicCancel(consumerResult.getConsumeId());\n            } catch (IOException ex) {\n                getLogger().warn(\"Failed to cancel results channel: \", ex);\n            }\n            try {\n                resultsChannel.close();\n            } catch (IOException | TimeoutException ex) {\n                getLogger().warn(\"Failed to close results channel: \", ex);\n            }\n        } catch (Exception ex) {\n            // dont let normal shutdown type issues cause a failure in the tests, this can happen in debugging, and we dont\n            // want the shutdown of the queue being the recorded reason for the failure.\n        }\n    }\n    protected CollectionSequence SetupCollectionSequence(ClassificationApi classificationApi, Long collectionId,\n                                                         boolean returnCollectionSequenceInstead)\n    {\n        CollectionSequence collectionSequence = new CollectionSequence();\n        collectionSequence.name = getUniqueString(\"ClassifyDocumentApiIT::setup_\");\n        collectionSequence.description = \"Used in ClassifyDocumentApiIT tests.\";\n        collectionSequence.collectionSequenceEntries = new ArrayList<>();\n        CollectionSequenceEntry collectionSequenceEntry = new CollectionSequenceEntry();\n        collectionSequenceEntry.collectionIds = new HashSet<>(Arrays.asList(collectionId));\n        collectionSequenceEntry.stopOnMatch = false;\n        collectionSequenceEntry.order = 400;\n        collectionSequence.collectionSequenceEntries.add(collectionSequenceEntry);\n        collectionSequence = classificationApi.create(collectionSequence);\n        if (returnCollectionSequenceInstead) {\n            return collectionSequence;\n        }\n        throw new RuntimeException(\"This method is not used anymore!!\");\n    }\n    protected DocumentCollection SetupCollection(Collection<Long> overridePolicyIds)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        NumberCondition numberCondition = new NumberCondition();\n        numberCondition.name = \"afield condition 1\";\n        numberCondition.field = \"afield\";\n        numberCondition.operator = NumberOperatorType.EQ;\n        numberCondition.value = 1L;\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection 1\";\n        collection1.policyIds = new HashSet<>();\n        if (overridePolicyIds != null) {\n            collection1.policyIds.addAll(overridePolicyIds);\n        }\n        collection1.condition = numberCondition;\n        collection1 = classificationApi.create(collection1);\n        return collection1;\n    }\n    protected CollectionSequence SetupCollectionSequence(DocumentCollection collection)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        return SetupCollectionSequence(classificationApi, collection.id, true);\n    }\n    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds)\n    {\n        return SetupCollectionSequenceWithPolicies(defaultPolicyIds, null);\n    }\n    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds,\n                                                                     final Collection<Long> overridePolicyIds)\n    {\n        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);\n        NumberCondition numberCondition = new NumberCondition();\n        numberCondition.name = \"afield condition 1\";\n        numberCondition.field = \"afield\";\n        numberCondition.operator = NumberOperatorType.EQ;\n        numberCondition.value = 1L;\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection 1\";\n        collection1.policyIds = new HashSet<>();\n        if (overridePolicyIds == null) {\n            collection1.policyIds.addAll(defaultPolicyIds);\n        } else {\n            collection1.policyIds.addAll(overridePolicyIds);\n        }\n        collection1.condition = numberCondition;\n        collection1 = classificationApi.create(collection1);\n        return SetupCollectionSequence(classificationApi, collection1.id, true);\n    }\n    protected Collection<Long> SetupPoliciesWithNoHandlersAvailable() throws IOException\n    {\n        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);\n        //register new policy type that will have no handlers associated\n        MetadataPolicy metadataPolicy = new MetadataPolicy();\n        metadataPolicy.setFieldActions(new ArrayList<>());\n        FieldAction fieldAction = new FieldAction();\n        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);\n        fieldAction.setFieldName(\"EXTERNAL_TEST\");\n        fieldAction.setFieldValue(\"1\");\n        metadataPolicy.getFieldActions().add(fieldAction);\n        PolicyType policyType = createCustomPolicyType(policyApi, getUniqueString(\"NoHandler\"), null);\n        Policy policy = new Policy();\n        policy.name = \"Policy\";\n        policy.details = mapper.valueToTree(metadataPolicy);\n        policy.typeId = policyType.id;\n        policy.priority = 100;\n        policy = policyApi.create(policy);\n        ArrayList<Long> noHandlers = new ArrayList<>();\n        noHandlers.add(policy.id);\n        return noHandlers;\n    }\n    protected PolicyType createCustomPolicyType(PolicyApi policyApi, final String uniqueName, final String uniqueShortName)\n    {\n        PolicyType policyType = new PolicyType();\n        policyType.conflictResolutionMode = ConflictResolutionMode.PRIORITY;\n        policyType.name = uniqueName;\n        policyType.shortName = Strings.isNullOrEmpty(uniqueShortName) ? getUniqueString(\"\") : uniqueShortName;\n        JsonNodeFactory nodeFactory = new JsonNodeFactory(false);\n        policyType.definition = nodeFactory.objectNode();\n        policyType = policyApi.create(policyType);\n        return policyType;\n    }\n    public static String getUniqueString(String strPrefix)\n    {\n        return strPrefix + UUID.randomUUID().toString();\n    }\n    protected LinkedList<Long> SetupPolicies() throws IOException\n    {\n        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);\n        MetadataPolicy metadataPolicy = new MetadataPolicy();\n        metadataPolicy.setFieldActions(new ArrayList<>());\n        FieldAction fieldAction = new FieldAction();\n        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);\n        fieldAction.setFieldName(\"EXTERNAL_TEST\");\n        fieldAction.setFieldValue(\"1\");\n        metadataPolicy.getFieldActions().add(fieldAction);\n        PolicyType policyType = policyApi.retrievePolicyTypeByName(\"MetadataPolicy\");\n        Policy policy = new Policy();\n        policy.name = \"Policy\";\n        policy.details = mapper.valueToTree(metadataPolicy);\n        policy.typeId = policyType.id;\n        policy.priority = 100;\n        policy = policyApi.create(policy);\n        LinkedList<Long> policyIds = new LinkedList<>();\n        policyIds.add(policy.id);\n        return policyIds;\n    }\n    protected DocumentCollection getDocumentCollection(long colId) throws Exception\n    {\n        Collection<DocumentCollection> collections = getClassificationApi().retrieveCollections(Arrays.asList(colId), true, false);\n        if (collections.isEmpty()) {\n            throw new Exception(\"Failed to find document collection id: \" + colId);\n        }\n        return collections.stream().filter(u -> u.id.equals(colId)).findFirst().get();\n    }\n    protected PolicyType createCustomExternalClassificationPolicyType(PolicyApi policyApi, String ptName, String ptShortName,\n                                                                      String ptDesc, String ptJsonDefinition)\n        throws IOException\n    {\n        PolicyType policyType = new PolicyType();\n        policyType.name = getUniqueString(ptName);\n        policyType.shortName = ptShortName;\n        policyType.description = ptDesc;\n        policyType.definition = mapper.readTree(ptJsonDefinition);\n        return policyApi.create(policyType);\n    }\n    protected Policy createCustomExternalClassificationPolicy(PolicyApi policyApi, PolicyType policyType, CollectionSequence colSeq,\n                                                              String polName, Integer polPriority, String queueName) throws IOException\n    {\n        String policyDef = \"{\\\"classificationSequenceId\\\":\" + colSeq.id + \",\\\"queueName\\\":\\\"\" + queueName + \"\\\"}\";\n        ObjectMapper mapper = new ObjectMapper();\n        Policy policy = new Policy();\n        policy.name = polName;\n        policy.details = mapper.readTree(policyDef);\n        policy.typeId = policyType.id;\n        policy.priority = polPriority;\n        return policyApi.create(policy);\n    }\n    protected DocumentCollection getWorkflowDocumentCollection(ClassificationApi classificationApi, Condition anyCondition)\n    {\n        DocumentCollection collection1 = new DocumentCollection();\n        collection1.name = \"Collection to drive workflow custom policy\";\n        collection1.condition = anyCondition;\n        collection1 = classificationApi.create(collection1);\n        return collection1;\n    }\n    protected DocumentCollection addPoliciesToDocumentCollection(ClassificationApi classificationApi, DocumentCollection collection,\n                                                                 Collection<Long> policyIds)\n    {\n        collection.policyIds = new HashSet<>();\n        collection.policyIds.addAll(policyIds);\n        DocumentCollection collection1 = classificationApi.update(collection);\n        return collection1;\n    }\n    protected void checkClassifyResult(com.github.cafdataprocessing.worker.policy.shared.ClassifyDocumentResult classifyResult,\n                                       Collection<Long> policyIds, DocumentCollection collection)\n    {\n        //check no incomplete collections returned\n        Collection<Long> incomplete = classifyResult.getIncompleteCollections();\n        Assert.assertEquals(0, incomplete.size());\n        //check expected policy was resolved\n        Collection<Long> resolvedPolicies = classifyResult.getResolvedPolicies();\n        Assert.assertArrayEquals(policyIds.toArray(), resolvedPolicies.toArray());\n        //check that the collection we expected is the one matched\n        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCollection> matchedCollections = classifyResult.getMatchedCollections();\n        Assert.assertEquals(1, matchedCollections.size());\n        com.github.cafdataprocessing.worker.policy.shared.MatchedCollection matchedCollection = matchedCollections.iterator().next();\n        Assert.assertEquals(collection.id, matchedCollection.getId());\n        Assert.assertEquals(collection.name, matchedCollection.getName());\n        //check the condition on the collection\n        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCondition> matchedConditions = matchedCollection.getMatchedConditions();\n        assertTrue(\"Number of matched conditions should be positive \", matchedConditions.size() > 0);\n        com.github.cafdataprocessing.worker.policy.shared.MatchedCondition matchedCondition = matchedConditions.stream().filter(u -> u.getId().equals(\n            collection.condition.id)).findFirst().get();\n        // compare the 2 top root condition matches at least, everything below should be fine\n        // in our present test scenario.\n        Assert.assertEquals(collection.condition.id, matchedCondition.getId());\n        Assert.assertEquals(collection.condition.name, matchedCondition.getName());\n        //check the policy on the collection\n        Collection<com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy> matchedPolicies = matchedCollection.getPolicies();\n        Assert.assertEquals(collection.policyIds.size(), matchedPolicies.size());\n        if (!matchedPolicies.isEmpty()) {\n            com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy matchedPolicy = matchedPolicies.iterator().next();\n            Assert.assertEquals(collection.policyIds.iterator().next(), matchedPolicy.getId());\n        }\n    }\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_SUCCESS\n     */\n    protected void checkTaskMessageReturned(TaskMessage resultWrapper, String expectedTaskId)\n    {\n        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_SUCCESS);\n    }\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_EXCEPTION\n     */\n    protected void checkTaskMessageReturnedException(TaskMessage resultWrapper, String expectedTaskId)\n    {\n        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_EXCEPTION);\n    }\n    /*\n        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_FAILURE\n     */\n    protected void checkTaskMessageReturnedTaskStatus(TaskMessage resultWrapper, String expectedTaskId, TaskStatus expectedStatus)\n    {\n        //check that this has the task ID we specified when adding to Input Queue\n        Assert.assertEquals(expectedTaskId, resultWrapper.getTaskId());\n        TaskStatus status = resultWrapper.getTaskStatus();\n        //check that task status is x\n        Assert.assertEquals(expectedStatus, status);\n    }\n    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(final BlockingQueue<Event<QueuePublisher>> pubEvents,\n                                                                  final ConsumerCreationResult consumerResult,\n                                                                  final TaskMessage classifyMessage, final String taskMessageExpected)\n        throws InterruptedException, CodecException, JsonProcessingException\n    {\n        return publishTaskAndAwaitResultAsTaskMessage(pubEvents, consumerResult.getLatch(), classifyMessage, taskMessageExpected);\n    }\n    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(BlockingQueue<Event<QueuePublisher>> pubEvents,\n                                                                  ConsumerCreationResult consumerResult, TaskMessage classifyMessage)\n        throws InterruptedException, CodecException, JsonProcessingException\n    {\n        return publishTaskAndAwaitThisMessagesResponse(pubEvents, consumerResult, classifyMessage, null);\n    }\n    /*\n        Utility method to publish a task to input queue and attempt to read the expected taskId back as a response from results queue.\n     */\n    protected TaskMessage publishTaskAndAwaitResultAsTaskMessage(BlockingQueue<Event<QueuePublisher>> pubEvents, CountDownLatch latch,\n                                                                 TaskMessage message, String expectedTaskMessage)\n        throws InterruptedException, JsonProcessingException, CodecException\n    {\n        //add message to input queue\n        //pubEvents.add(new PublishQueueEvent(PublishEventType.PUBLISH, 0L, mapper.writeValueAsBytes(message), INPUT_QUEUENAME));\n        pubEvents.add(new PublisherPublishEvent(mapper.writeValueAsBytes(message)));\n        Delivery deliveredResult = null;\n        final String awaitThisMessage = Strings.isNullOrEmpty(expectedTaskMessage) ? message.getTaskId() : expectedTaskMessage;\n        //give some time for task to be processed and result consumed (result consumer should update latch on consumption)\n        final boolean timeout = !latch.await(RESULT_TIMEOUTSECONDS, TimeUnit.SECONDS);\n        return getResultAsTaskMessage(awaitThisMessage, timeout);\n    }\n    /**\n     * Utility method to get a specific message from the queue without any waiting.\n     *\n     * @param getThisMessage\n     * @return\n     */\n    protected TaskMessage getResultAsTaskMessage(String getThisMessage)\n    {\n        return getResultAsTaskMessage(getThisMessage, false);\n    }\n    /**\n     * Utility method to get a specific message from the queue without any waiting.\n     *\n     * @param awaitThisMessage\n     * @param timeout\n     * @return\n     */\n    private TaskMessage getResultAsTaskMessage(String awaitThisMessage, boolean timeout)\n    {\n        Delivery deliveredResult;\n        deliveredResult = consumerImpl.getDelivery(awaitThisMessage);\n        if (timeout && deliveredResult == null) {\n            // timeout happened while waiting on the given message, make final check for delivery then give up.\n            logger.error(\"Timeout happened while waiting for the response to taskId: \" + awaitThisMessage);\n            throw new RuntimeException(\"Timeout happened while waiting for the response to taskId: \" + awaitThisMessage);\n        }\n        // check if we haven't got a result, try relatching and waiting again -> we should only return from here with correct response or timeout.\n        if (deliveredResult == null) {\n            // the latch has fired, so the message queue filter has received a message the user was interested in, but they then requested\n            // an item that wasn't in the queue yet.\n            // This can happen if you do something like this: filter by taskId: 123.\n            // Request child 123.2*, but the queue can accept 123 / 123.1 and 123.2, so any arriving will wake this code up.\n            // We can either go back to latching for another message OR I have opted to throw, and fix the tests to filter better to only\n            // the message you want.  So change here would be to use filter: 123.2, and publishAndAwait on the same 123.2 id.\n            logger.warn(\"Failed to locate the message you requested taskId: \" + awaitThisMessage);\n            debugCurrentQueueItems();\n            throw new RuntimeException(\n                \"Failed to locate the message you requested taskId: \" + awaitThisMessage + \"\\nBut the message queue did receive a valid item matching the filter id.  Please make sure that you aren't allowing more than 1 item in your filter list ( and are latching on count 1) if you want a specific child only:\\n\"\n                + \"Ensure that the queue latch=1, and change the queue filter, or increase the latch to the number of children that the workflow accepts into the queue.\");\n        }\n        TaskMessage resultMessage = getTaskMessageFromDelivery(deliveredResult);\n        return resultMessage;\n    }\n    private void debugCurrentQueueItems()\n    {\n        logger.warn(\"Message queue currently contains: \" + consumerImpl.getDelivery().size());\n        // do we have any items on the queue at all, if so, output what we have?\n        for (Map.Entry<String, Delivery> deliveredItem : consumerImpl.getDelivery().entrySet()) {\n            Delivery tmpDel = deliveredItem.getValue();\n            TaskMessage tm = getTaskMessageFromDelivery(tmpDel);\n            logger.warn(\n                String.format(\"Queue contains other item: {%s} TrackingInfo jobTaskId: {%s}\",\n                              tm.getTaskId(), tm.getTracking() == null ? \"null\" : tm.getTracking().getJobTaskId()));\n        }\n    }\n    /**\n     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param workflowId\n     * @param executePolicy\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                        final Long workflowId, final boolean executePolicy)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n        TaskMessage classifyMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           workflowId.toString(), executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return classifyMessage;\n    }\n    /**\n     * Create policy worker task message to classify and execute on a document, given a set of collection sequence identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param collectionSequenceIds\n     * @param executePolicy\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                        final List<String> collectionSequenceIds, final boolean executePolicy)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n        TaskMessage classifyMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           collectionSequenceIds, executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return classifyMessage;\n    }\n    /**\n     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.\n     *\n     * @param taskId\n     * @param taskClassifier\n     * @param document\n     * @param workflowId\n     * @param collectionSequenceIds\n     * @param policyIds\n     * @param executePolicy\n     * @param executeOnly\n     * @return\n     * @throws CodecException\n     */\n    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,\n                                                      final Long workflowId, final List<String> collectionSequenceIds,\n                                                      final Collection<Long> policyIds, final boolean executePolicy,\n                                                      final boolean executeOnly)\n        throws CodecException\n    {\n        // create with job tracking by default.\n        TrackingInfo trackingInfo = createTrackingInfo(taskId);\n        if (executeOnly) {\n            final TaskMessage taskMessage = TestTaskMessageHelper.getExecuteTaskMessage(taskId, taskClassifier, document, policyIds,\n                                                                                     getProjectId(), collectionSequenceIds, INPUT_QUEUENAME, trackingInfo);\n            return taskMessage;\n        }\n        final TaskMessage taskMessage\n            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,\n                                                           workflowId.toString(), executePolicy, getProjectId(),\n                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);\n        return taskMessage;\n    }\n    protected TrackingInfo createTrackingInfo(String taskId)\n    {\n        TrackingInfo trackingInfo = new TrackingInfo();\n        trackingInfo.setTrackingPipe(properties.getJobTrackingPipe());\n        trackingInfo.setJobTaskId(taskId);\n        // if we need to set this, set to rubbish to never remove the tracking info.\n        trackingInfo.setTrackTo(\"xyz\");\n        return trackingInfo;\n    }\n    /*\n        Utility method to create publisher to put messages onto an input channel. Returns the publish queue for messages to added to\n     */\n    protected BlockingQueue<Event<QueuePublisher>> createRabbitPublisher(Channel inputChannel)\n    {\n        BlockingQueue<Event<QueuePublisher>> pubEvents = new LinkedBlockingQueue<>();\n        TestQueuePublisherImpl publisherImpl = new TestQueuePublisherImpl(inputChannel, INPUT_QUEUENAME);\n        this.publisher = new EventPoller<>(2, pubEvents, publisherImpl);\n        new Thread(publisher).start();\n        return pubEvents;\n    }\n    protected class ConsumerCreationResult\n    {\n        private CountDownLatch latch;\n        private String consumeId;\n        public ConsumerCreationResult(CountDownLatch latch, String consumeId)\n        {\n            this.latch = latch;\n            this.consumeId = consumeId;\n        }\n        public CountDownLatch getLatch()\n        {\n            return latch;\n        }\n        public String getConsumeId()\n        {\n            return consumeId;\n        }\n    }\n    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,\n                                                          final int latchCount, final String taskIdFilter)\n        throws IOException\n    {\n        return createRabbitConsumer(resultsChannel, conEvents, RESULT_QUEUENAME, 1, taskIdFilter);\n    }\n    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,\n                                                          String queueName, int latchCount, final String taskIdFilter)\n        throws IOException\n    {\n        CountDownLatch latch = new CountDownLatch(latchCount);\n        RabbitUtil.declareWorkerQueue(resultsChannel, queueName, 32);\n        this.consumerImpl = new TestQueueConsumerImpl(latch, conEvents, resultsChannel, taskIdFilter);\n        this.consumer = new DefaultRabbitConsumer(conEvents, consumerImpl);\n        String consumeId = resultsChannel.basicConsume(queueName, consumer);\n        new Thread(consumer).start();\n        return new ConsumerCreationResult(latch, consumeId);\n    }\n    /*\n        Utility class used to publish messages onto a RabbitMQ queue\n     */\n    protected class TestQueuePublisherImpl implements QueuePublisher\n    {\n        private final Channel channel;\n        private final String queueName;\n        public TestQueuePublisherImpl(final Channel ch, final String queue)\n        {\n            this.channel = Objects.requireNonNull(ch);\n            this.queueName = Objects.requireNonNull(queue);\n        }\n        @Override\n        public void handlePublish(final byte[] data)\n        {\n            try {\n                channel.basicPublish(\"\", queueName, MessageProperties.TEXT_PLAIN, data);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.028245210647583, "ppl_lower": 2.2431986331939697, "ppl/lowercase_ppl": -1.1424433678219206, "ppl/zlib": 0.00011298466064350881, "Min_5.0% Prob": 7.01988016390333, "Min_10.0% Prob": 5.033117259249968, "Min_20.0% Prob": 3.2464683111391817, "Min_30.0% Prob": 2.3056702517898255, "Min_40.0% Prob": 1.7561006277325975, "Min_50.0% Prob": 1.4128239985132578, "Min_60.0% Prob": 1.1794967895311412}}
{"hexsha": "bebee3f8b444cdb362eba93d17a3bfd5bee7eb9d", "ext": "java", "lang": "Java", "content": "public class msg_image_trigger_control extends MAVLinkMessage{\n\n\tpublic static final int MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153;\n\tpublic static final int MAVLINK_MSG_LENGTH = 1;\n\tprivate static final long serialVersionUID = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n\t\n\n \t/**\n\t* 0 to disable, 1 to enable\n\t*/\n\tpublic byte enable; \n\n\t/**\n\t * Generates the payload for a mavlink message for a message of this type\n\t * @return\n\t */\n\tpublic MAVLinkPacket pack(){\n\t\tMAVLinkPacket packet = new MAVLinkPacket();\n\t\tpacket.len = MAVLINK_MSG_LENGTH;\n\t\tpacket.sysid = 255;\n\t\tpacket.compid = 190;\n\t\tpacket.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n\t\tpacket.payload.putByte(enable);\n\t\treturn packet;\t\t\n\t}\n\n    /**\n     * Decode a image_trigger_control message into this class fields\n     *\n     * @param payload The message to decode\n     */\n    public void unpack(MAVLinkPayload payload) {\n        payload.resetIndex();\n\t    enable = payload.getByte();    \n    }\n\n     /**\n     * Constructor for a new message, just initializes the msgid\n     */\n    public msg_image_trigger_control(){\n    \tmsgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n    }\n\n    /**\n     * Constructor for a new message, initializes the message with the payload\n     * from a mavlink packet\n     * \n     */\n    public msg_image_trigger_control(MAVLinkPacket mavLinkPacket){\n        this.sysid = mavLinkPacket.sysid;\n        this.compid = mavLinkPacket.compid;\n        this.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n        unpack(mavLinkPacket.payload);\n        //Log.d(\"MAVLink\", \"IMAGE_TRIGGER_CONTROL\");\n        //Log.d(\"MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL\", toString());\n    }\n    \n  \n    /**\n     * Returns a string with the MSG name and data\n     */\n    public String toString(){\n    \treturn \"MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL -\"+\" enable:\"+enable+\"\";\n    }\n}", "class_id": 0, "repo": "chrisphillips/Telemetry-For-DJI", "file": "TelemetryServer/app/src/main/java/com/jeremydyer/mavlink/Messages/pixhawk/msg_image_trigger_control.java", "last_update_at": "2018-02-20T19:26:12+00:00", "question_id": "bebee3f8b444cdb362eba93d17a3bfd5bee7eb9d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class msg_image_trigger_control extends MAVLinkMessage{\n\tpublic static final int MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153;\n\tpublic static final int MAVLINK_MSG_LENGTH = 1;\n\tprivate static final long serialVersionUID = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n\t\n \t/**\n\t* 0 to disable, 1 to enable\n\t*/\n\tpublic byte enable; \n\t/**\n\t * Generates the payload for a mavlink message for a message of this type\n\t * @return\n\t */\n\tpublic MAVLinkPacket pack(){\n\t\tMAVLinkPacket packet = new MAVLinkPacket();\n\t\tpacket.len = MAVLINK_MSG_LENGTH;\n\t\tpacket.sysid = 255;\n\t\tpacket.compid = 190;\n\t\tpacket.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n\t\tpacket.payload.putByte(enable);\n\t\treturn packet;\t\t\n\t}\n    /**\n     * Decode a image_trigger_control message into this class fields\n     *\n     * @param payload The message to decode\n     */\n    public void unpack(MAVLinkPayload payload) {\n        payload.resetIndex();\n\t    enable = payload.getByte();    \n    }\n     /**\n     * Constructor for a new message, just initializes the msgid\n     */\n    public msg_image_trigger_control(){\n    \tmsgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n    }\n    /**\n     * Constructor for a new message, initializes the message with the payload\n     * from a mavlink packet\n     * \n     */\n    public msg_image_trigger_control(MAVLinkPacket mavLinkPacket){\n        this.sysid = mavLinkPacket.sysid;\n        this.compid = mavLinkPacket.compid;\n        this.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;\n        unpack(mavLinkPacket.payload);\n        //Log.d(\"MAVLink\", \"IMAGE_TRIGGER_CONTROL\");\n        //Log.d(\"MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL\", toString());\n    }\n    /**\n     * Returns a string with the MSG name and data\n     */\n    public String toString(){\n    \treturn \"MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL -\"+\" enable:\"+enable+\"\";\n    }\n"]], "pred": {"ppl": 1.1243656873703003, "ppl_lower": 1.6477442979812622, "ppl/lowercase_ppl": -4.2604618400679755, "ppl/zlib": 0.00017600456936022257, "Min_5.0% Prob": 2.314600522771026, "Min_10.0% Prob": 1.1696265826085166, "Min_20.0% Prob": 0.5866932721874579, "Min_30.0% Prob": 0.3912742769141335, "Min_40.0% Prob": 0.2934787355997382, "Min_50.0% Prob": 0.2347864163351426, "Min_60.0% Prob": 0.1956562199587864}}
{"hexsha": "436c36b613e16641918f45949d4eead6da5afc23", "ext": "java", "lang": "Java", "content": "public class SViewOrdersToProcess extends SGridPaneView {\n    \n    private Date mtDateStart;\n    private Date mtDateFinal;\n    private int mnYearId;\n    private int mnBizPartherId;\n    \n    public SViewOrdersToProcess(SGuiClient client, int gridType, int gridSubtype, String title, SGuiParams params) {\n        super(client, SGridConsts.GRID_PANE_VIEW, gridType, gridSubtype, title, params);\n        initComponentsCustom();\n    }\n\n    /*\n     * Private methods\n     */\n\n    private void initComponentsCustom() {\n        setRowButtonsEnabled(false);\n        mtDateStart = null;\n        mnBizPartherId = 0;\n        createGridColumns();\n    }\n\n    private void setParamsView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner ) {\n        mtDateStart = dateStart;\n        mtDateFinal = dateFinal;\n        mnYearId = year;\n        mnBizPartherId = idBizPartner;\n    }\n    \n    private void renderView() {\n        createGridColumns();\n        populateGrid(SGridConsts.REFRESH_MODE_RELOAD);\n    }\n\n    /*\n     * Public methods\n     */\n    \n    public void initView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner) {\n        setParamsView(dateStart, dateFinal, year, idBizPartner);\n        renderView();\n    }\n    \n    \n    /*\n     * Overriden methods\n     */\n    \n    @Override\n    public void prepareSqlQuery() {\n        \n        moPaneSettings = new SGridPaneSettings(2);\n        msSql = \"SELECT id_year \" + SDbConsts.FIELD_ID + \"1, \" +\n                \"id_doc \" + SDbConsts.FIELD_ID + \"2, \" + \n                \"'' AS \" + SDbConsts.FIELD_CODE + \", \" +\n                \"'' AS \" + SDbConsts.FIELD_NAME + \", \" + \n                \"num_ref, dt, f_num, fid_cob, fid_bpb, f_cob_code, bpb, \" +\n                \"SUM(f_qty) AS f_qty, SUM(f_orig_qty) AS f_orig_qty, SUM(f_link_qty) AS f_link_qty, SUM(f_link_orig_qty) AS f_link_orig_qty, COUNT(*) AS f_count, COUNT(f_link_orig_qty >= f_orig_qty) AS f_count_link \" +\n                \"FROM (SELECT de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, d.dt_doc_lapsing_n, d.num_ref, d.b_link, d.ts_link, CONCAT(d.num_ser, IF(length(d.num_ser) = \" + SModSysConsts.FINS_CFD_TAX_NA + \", '', '-'), d.num) \" +\n                \"AS f_num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code AS f_dt_code, dn.code AS f_dn_code, cob.code AS f_cob_code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, de.fid_item, de.fid_unit, \" +\n                \"de.fid_orig_unit, de.surplus_per, de.qty AS f_qty, de.orig_qty AS f_orig_qty, CASE WHEN de.qty = \" + SModSysConsts.FINS_CFD_TAX_NA + \" THEN \" + SModSysConsts.FINS_CFD_TAX_NA + \" ELSE de.stot_cur_r / de.qty END AS f_price_u, \" +\n                \"CASE WHEN de.orig_qty = \" + SModSysConsts.FINS_CFD_TAX_NA + \" THEN \" + SModSysConsts.FINS_CFD_TAX_NA + \" ELSE de.stot_cur_r / de.orig_qty END AS f_orig_price_u, i.item_key, i.item, ig.igen, u.symbol AS f_unit, uo.symbol AS f_orig_unit, \" +\n                \"COALESCE((SELECT SUM(ds.qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety \" +\n                \"AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year AND xde.id_doc = xd.id_doc AND xde.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" \" +\n                \"AND xd.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \"), \" + SModSysConsts.FINS_CFD_TAX_NA + \") AS f_link_qty, COALESCE((SELECT SUM(ds.orig_qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year \" +\n                \"AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year \" +\n                \"AND xde.id_doc = xd.id_doc AND xde.\"\n                + \"b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \"), \" + SModSysConsts.FINS_CFD_TAX_NA + \") AS f_link_orig_qty \" +\n                \"FROM \" + SModConsts.TablesMap.get(SModConsts.TRN_DPS) + \" AS d INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRN_DPS_ETY) + \" AS de ON d.id_year = de.id_year \" +\n                \"AND d.id_doc = de.id_doc AND d.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND de.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND d.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" \" ; \n                if (mnGridMode == SDataConstantsSys.BPSS_CT_BP_CUS) {\n                    msSql += \"AND d.fid_ct_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_cl_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_tp_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" \";\n                }\n                else {\n                    msSql += \"AND d.fid_ct_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" AND d.fid_cl_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_tp_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" \";\n                }                \n                msSql += \" AND d.id_year <= \" + mnYearId + \" AND d.dt >= '\" + SLibUtils.DbmsDateFormatDate.format(mtDateStart) + \"' AND d.dt <= '\" + SLibUtils.DbmsDateFormatDate.format(mtDateFinal) + \"' \" +\n                \"AND d.fid_cob = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" AND d.fid_bp_r = \" + mnBizPartherId + \n                \" INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRNU_TP_DPS) + \" AS dt ON d.fid_ct_dps = dt.id_ct_dps AND d.fid_cl_dps = dt.id_cl_dps AND d.fid_tp_dps = dt.id_tp_dps \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRNU_DPS_NAT) + \" AS dn ON d.fid_dps_nat = dn.id_dps_nat \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + \" AS cob ON d.fid_cob = cob.id_bpb \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + \" AS bb ON d.fid_bpb = bb.id_bpb \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BP) + \" AS b ON d.fid_bp_r = b.id_bp \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BP_CT) + \" AS bc ON d.fid_bp_r = bc.id_bp AND bc.id_ct_bp = \" + SDataConstantsSys.TRNS_ST_DPS_ANNULED + \" \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.CFGU_CUR) + \" AS c ON d.fid_cur = c.id_cur \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.USRU_USR) + \" AS ul ON d.fid_usr_link = ul.id_usr \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_ITEM) + \" AS i ON de.fid_item = i.id_item \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_IGEN) + \" AS ig ON i.fid_igen = ig.id_igen \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + \" AS u ON de.fid_unit = u.id_unit \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + \" AS uo ON de.fid_orig_unit = uo.id_unit GROUP BY de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, \" +\n                \"d.num_ref, d.b_link, d.ts_link, d.num_ser, d.num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code, cob.code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, \" +\n                \"de.fid_item, de.fid_unit, de.fid_orig_unit, de.surplus_per, de.qty, de.orig_qty, de.stot_cur_r, i.item_key, i.item, u.symbol, uo.symbol ) AS T \" +\n                \"GROUP BY id_year, id_doc, dt, dt_doc_delivery_n, num_ref, b_link, ts_link, f_num, fid_cob, fid_bpb, fid_bp_r, fid_usr_link, f_dt_code, f_cob_code, bpb, bp, bp_key, usr \" +\n                \"HAVING (f_link_orig_qty < f_orig_qty AND b_link = 0) OR f_count <> f_count_link ORDER BY f_dt_code, f_num, dt, id_year, id_doc, bp, bp_key, fid_bp_r, bpb, fid_bpb \";\n        }\n\n    @Override\n    public ArrayList<SGridColumnView> createGridColumns() {\n        SGridColumnView column = null;\n        ArrayList<SGridColumnView> gridColumnsViews = new ArrayList<SGridColumnView>();\n       \n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, \"f_num\", \"Folio doc\", STableConstants.WIDTH_DOC_NUM));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DATE, \"dt\", \"Fecha doc\", STableConstants.WIDTH_DATE));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, \"num_ref\", \"Referencia doc.\", STableConstants.WIDTH_DOC_NUM_REF));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_orig_qty\", \"Cantidad\", STableConstants.WIDTH_VALUE));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_link_orig_qty\", \"Cant. procesada\", STableConstants.WIDTH_VALUE));\n        \n        column = new SGridColumnView(SGridConsts.COL_TYPE_DEC_PER_2D, \"\", \"Avance %\", STableConstants.WIDTH_VALUE);\n        column.getRpnArguments().add(new SLibRpnArgument(\"f_link_orig_qty\", SLibRpnArgumentType.OPERAND));\n        column.getRpnArguments().add(new SLibRpnArgument(\"f_orig_qty\", SLibRpnArgumentType.OPERAND ));\n        column.getRpnArguments().add(new SLibRpnArgument(SLibRpnOperator.DIVISION, SLibRpnArgumentType.OPERATOR));\n        \n        gridColumnsViews.add(column);\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_orig_qty\", \"Cant. pendiente\", STableConstants.WIDTH_VALUE));\n        return gridColumnsViews;\n    }\n\n    @Override\n    public void defineSuscriptions() {\n        moSuscriptionsSet.add(mnGridType);\n        moSuscriptionsSet.add(SModConsts.TRNU_TP_DPS);\n        moSuscriptionsSet.add(SModConsts.TRNU_DPS_NAT);\n        moSuscriptionsSet.add(SModConsts.BPSU_BPB);\n        moSuscriptionsSet.add(SModConsts.BPSU_BP);\n        moSuscriptionsSet.add(SModConsts.BPSU_BP_CT);\n        moSuscriptionsSet.add(SModConsts.CFGU_CUR);\n        moSuscriptionsSet.add(SModConsts.USRU_USR);\n        moSuscriptionsSet.add(SModConsts.ITMU_ITEM);\n        moSuscriptionsSet.add(SModConsts.ITMU_IGEN);\n        moSuscriptionsSet.add(SModConsts.ITMU_UNIT);\n    }\n}", "class_id": 0, "repo": "alphalapz/siie", "file": "src/erp/mod/trn/view/qi/SViewOrdersToProcess.java", "last_update_at": "2018-07-19T14:41:16+00:00", "question_id": "436c36b613e16641918f45949d4eead6da5afc23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SViewOrdersToProcess extends SGridPaneView {\n    private Date mtDateStart;\n    private Date mtDateFinal;\n    private int mnYearId;\n    private int mnBizPartherId;\n    public SViewOrdersToProcess(SGuiClient client, int gridType, int gridSubtype, String title, SGuiParams params) {\n        super(client, SGridConsts.GRID_PANE_VIEW, gridType, gridSubtype, title, params);\n        initComponentsCustom();\n    }\n    /*\n     * Private methods\n     */\n    private void initComponentsCustom() {\n        setRowButtonsEnabled(false);\n        mtDateStart = null;\n        mnBizPartherId = 0;\n        createGridColumns();\n    }\n    private void setParamsView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner ) {\n        mtDateStart = dateStart;\n        mtDateFinal = dateFinal;\n        mnYearId = year;\n        mnBizPartherId = idBizPartner;\n    }\n    private void renderView() {\n        createGridColumns();\n        populateGrid(SGridConsts.REFRESH_MODE_RELOAD);\n    }\n    /*\n     * Public methods\n     */\n    public void initView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner) {\n        setParamsView(dateStart, dateFinal, year, idBizPartner);\n        renderView();\n    }\n    /*\n     * Overriden methods\n     */\n    @Override\n    public void prepareSqlQuery() {\n        moPaneSettings = new SGridPaneSettings(2);\n        msSql = \"SELECT id_year \" + SDbConsts.FIELD_ID + \"1, \" +\n                \"id_doc \" + SDbConsts.FIELD_ID + \"2, \" + \n                \"'' AS \" + SDbConsts.FIELD_CODE + \", \" +\n                \"'' AS \" + SDbConsts.FIELD_NAME + \", \" + \n                \"num_ref, dt, f_num, fid_cob, fid_bpb, f_cob_code, bpb, \" +\n                \"SUM(f_qty) AS f_qty, SUM(f_orig_qty) AS f_orig_qty, SUM(f_link_qty) AS f_link_qty, SUM(f_link_orig_qty) AS f_link_orig_qty, COUNT(*) AS f_count, COUNT(f_link_orig_qty >= f_orig_qty) AS f_count_link \" +\n                \"FROM (SELECT de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, d.dt_doc_lapsing_n, d.num_ref, d.b_link, d.ts_link, CONCAT(d.num_ser, IF(length(d.num_ser) = \" + SModSysConsts.FINS_CFD_TAX_NA + \", '', '-'), d.num) \" +\n                \"AS f_num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code AS f_dt_code, dn.code AS f_dn_code, cob.code AS f_cob_code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, de.fid_item, de.fid_unit, \" +\n                \"de.fid_orig_unit, de.surplus_per, de.qty AS f_qty, de.orig_qty AS f_orig_qty, CASE WHEN de.qty = \" + SModSysConsts.FINS_CFD_TAX_NA + \" THEN \" + SModSysConsts.FINS_CFD_TAX_NA + \" ELSE de.stot_cur_r / de.qty END AS f_price_u, \" +\n                \"CASE WHEN de.orig_qty = \" + SModSysConsts.FINS_CFD_TAX_NA + \" THEN \" + SModSysConsts.FINS_CFD_TAX_NA + \" ELSE de.stot_cur_r / de.orig_qty END AS f_orig_price_u, i.item_key, i.item, ig.igen, u.symbol AS f_unit, uo.symbol AS f_orig_unit, \" +\n                \"COALESCE((SELECT SUM(ds.qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety \" +\n                \"AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year AND xde.id_doc = xd.id_doc AND xde.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" \" +\n                \"AND xd.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \"), \" + SModSysConsts.FINS_CFD_TAX_NA + \") AS f_link_qty, COALESCE((SELECT SUM(ds.orig_qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year \" +\n                \"AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year \" +\n                \"AND xde.id_doc = xd.id_doc AND xde.\"\n                + \"b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND xd.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \"), \" + SModSysConsts.FINS_CFD_TAX_NA + \") AS f_link_orig_qty \" +\n                \"FROM \" + SModConsts.TablesMap.get(SModConsts.TRN_DPS) + \" AS d INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRN_DPS_ETY) + \" AS de ON d.id_year = de.id_year \" +\n                \"AND d.id_doc = de.id_doc AND d.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND de.b_del = \" + SModSysConsts.FINS_CFD_TAX_NA + \" AND d.fid_st_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" \" ; \n                if (mnGridMode == SDataConstantsSys.BPSS_CT_BP_CUS) {\n                    msSql += \"AND d.fid_ct_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_cl_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_tp_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" \";\n                }\n                else {\n                    msSql += \"AND d.fid_ct_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" AND d.fid_cl_dps = \" + SDataConstantsSys.TRNS_ST_DPS_EMITED + \" AND d.fid_tp_dps = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" \";\n                }                \n                msSql += \" AND d.id_year <= \" + mnYearId + \" AND d.dt >= '\" + SLibUtils.DbmsDateFormatDate.format(mtDateStart) + \"' AND d.dt <= '\" + SLibUtils.DbmsDateFormatDate.format(mtDateFinal) + \"' \" +\n                \"AND d.fid_cob = \" + SDataConstantsSys.TRNS_ST_DPS_NEW + \" AND d.fid_bp_r = \" + mnBizPartherId + \n                \" INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRNU_TP_DPS) + \" AS dt ON d.fid_ct_dps = dt.id_ct_dps AND d.fid_cl_dps = dt.id_cl_dps AND d.fid_tp_dps = dt.id_tp_dps \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.TRNU_DPS_NAT) + \" AS dn ON d.fid_dps_nat = dn.id_dps_nat \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + \" AS cob ON d.fid_cob = cob.id_bpb \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + \" AS bb ON d.fid_bpb = bb.id_bpb \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BP) + \" AS b ON d.fid_bp_r = b.id_bp \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.BPSU_BP_CT) + \" AS bc ON d.fid_bp_r = bc.id_bp AND bc.id_ct_bp = \" + SDataConstantsSys.TRNS_ST_DPS_ANNULED + \" \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.CFGU_CUR) + \" AS c ON d.fid_cur = c.id_cur \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.USRU_USR) + \" AS ul ON d.fid_usr_link = ul.id_usr \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_ITEM) + \" AS i ON de.fid_item = i.id_item \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_IGEN) + \" AS ig ON i.fid_igen = ig.id_igen \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + \" AS u ON de.fid_unit = u.id_unit \" +\n                \"INNER JOIN \" + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + \" AS uo ON de.fid_orig_unit = uo.id_unit GROUP BY de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, \" +\n                \"d.num_ref, d.b_link, d.ts_link, d.num_ser, d.num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code, cob.code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, \" +\n                \"de.fid_item, de.fid_unit, de.fid_orig_unit, de.surplus_per, de.qty, de.orig_qty, de.stot_cur_r, i.item_key, i.item, u.symbol, uo.symbol ) AS T \" +\n                \"GROUP BY id_year, id_doc, dt, dt_doc_delivery_n, num_ref, b_link, ts_link, f_num, fid_cob, fid_bpb, fid_bp_r, fid_usr_link, f_dt_code, f_cob_code, bpb, bp, bp_key, usr \" +\n                \"HAVING (f_link_orig_qty < f_orig_qty AND b_link = 0) OR f_count <> f_count_link ORDER BY f_dt_code, f_num, dt, id_year, id_doc, bp, bp_key, fid_bp_r, bpb, fid_bpb \";\n        }\n    @Override\n    public ArrayList<SGridColumnView> createGridColumns() {\n        SGridColumnView column = null;\n        ArrayList<SGridColumnView> gridColumnsViews = new ArrayList<SGridColumnView>();\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, \"f_num\", \"Folio doc\", STableConstants.WIDTH_DOC_NUM));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DATE, \"dt\", \"Fecha doc\", STableConstants.WIDTH_DATE));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, \"num_ref\", \"Referencia doc.\", STableConstants.WIDTH_DOC_NUM_REF));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_orig_qty\", \"Cantidad\", STableConstants.WIDTH_VALUE));\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_link_orig_qty\", \"Cant. procesada\", STableConstants.WIDTH_VALUE));\n        column = new SGridColumnView(SGridConsts.COL_TYPE_DEC_PER_2D, \"\", \"Avance %\", STableConstants.WIDTH_VALUE);\n        column.getRpnArguments().add(new SLibRpnArgument(\"f_link_orig_qty\", SLibRpnArgumentType.OPERAND));\n        column.getRpnArguments().add(new SLibRpnArgument(\"f_orig_qty\", SLibRpnArgumentType.OPERAND ));\n        column.getRpnArguments().add(new SLibRpnArgument(SLibRpnOperator.DIVISION, SLibRpnArgumentType.OPERATOR));\n        gridColumnsViews.add(column);\n        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, \"f_orig_qty\", \"Cant. pendiente\", STableConstants.WIDTH_VALUE));\n        return gridColumnsViews;\n    }\n    @Override\n    public void defineSuscriptions() {\n        moSuscriptionsSet.add(mnGridType);\n        moSuscriptionsSet.add(SModConsts.TRNU_TP_DPS);\n        moSuscriptionsSet.add(SModConsts.TRNU_DPS_NAT);\n        moSuscriptionsSet.add(SModConsts.BPSU_BPB);\n        moSuscriptionsSet.add(SModConsts.BPSU_BP);\n        moSuscriptionsSet.add(SModConsts.BPSU_BP_CT);\n        moSuscriptionsSet.add(SModConsts.CFGU_CUR);\n        moSuscriptionsSet.add(SModConsts.USRU_USR);\n        moSuscriptionsSet.add(SModConsts.ITMU_ITEM);\n        moSuscriptionsSet.add(SModConsts.ITMU_IGEN);\n        moSuscriptionsSet.add(SModConsts.ITMU_UNIT);\n    }\n"]], "pred": {"ppl": 1.6806070804595947, "ppl_lower": 2.610778570175171, "ppl/lowercase_ppl": -1.8484813233975053, "ppl/zlib": 0.00023395902909316185, "Min_5.0% Prob": 5.202117620729933, "Min_10.0% Prob": 3.818871555375118, "Min_20.0% Prob": 2.3910674248255934, "Min_30.0% Prob": 1.694724225579134, "Min_40.0% Prob": 1.2877440543840741, "Min_50.0% Prob": 1.0359862879111839, "Min_60.0% Prob": 0.8653165489802863}}
{"hexsha": "be0015e402b07706ce13be7c877fce65664da2fb", "ext": "java", "lang": "Java", "content": "@RunWith(MockitoJUnitRunner.class)\npublic class MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapperTest {\n\n    @Mock\n    private MatchingServiceAdapterConfiguration configuration;\n\n    @Mock\n    private IdGenerator idGenerator;\n\n    @Mock\n    private AssertionLifetimeConfiguration assertionLifetimeConfiguration;\n\n    private static final String ENTITY_ID = \"entityId\";\n    private static final String TEST_ID = \"testId\";\n    private static final String REQUEST_ID = \"requestId\";\n    private static final String ASSERTION_CONSUMER_SERVICE_URL = \"assertionConsumerServiceUrl\";\n    private static final String AUTHN_REQUEST_ISSUER_ID = \"authnRequestIssuerId\";\n    private static final String HASH_PID = \"hashPid\";\n    private MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper mapper;\n\n    @Before\n    public void setup(){\n        DateTimeFreezer.freezeTime();\n        mapper = new MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper(configuration, assertionLifetimeConfiguration, idGenerator);\n        when(assertionLifetimeConfiguration.getAssertionLifetime()).thenReturn(Duration.parse(\"30m\"));\n        when(configuration.getEntityId()).thenReturn(ENTITY_ID);\n        when(idGenerator.getId()).thenReturn(TEST_ID);\n    }\n\n    @After\n    public void after() {\n        DateTimeFreezer.unfreezeTime();\n    }\n\n    @Test\n    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withMatch().build();\n        OutboundResponseFromMatchingService responseFromMatchingService = mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n\n        assertThat(responseFromMatchingService.getStatus()).isEqualTo(MatchingServiceMatch);\n        assertThat(responseFromMatchingService.getInResponseTo()).isEqualTo(REQUEST_ID);\n        assertThat(responseFromMatchingService.getId()).isEqualTo(TEST_ID);\n        assertThat(responseFromMatchingService.getIssuer()).isEqualTo(ENTITY_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion()).isPresent();\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions()).isNotNull();\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getId()).isEqualTo(TEST_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getIssuerId()).isEqualTo(ENTITY_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getInResponseTo()).isEqualTo(REQUEST_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getNotOnOrAfter()).isEqualTo(DateTime.now().plus(assertionLifetimeConfiguration.getAssertionLifetime().toMilliseconds()));\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getRecipient()).isEqualTo(ASSERTION_CONSUMER_SERVICE_URL);\n    }\n\n    @Test\n    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithNoMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withNoMatch().build();\n\n        OutboundResponseFromMatchingService idaResponse = mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n\n        assertThat(idaResponse.getStatus()).isEqualTo(MatchingServiceIdaStatus.NoMatchingServiceMatchFromMatchingService);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void map_shouldThrowExceptionIfNotNoMatchOrMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withBadResponse().build();\n\n        mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n    }\n}", "class_id": 0, "repo": "uk-gov-mirror/alphagov.verify-matching-service-adapter", "file": "src/test/java/uk/gov/ida/matchingserviceadapter/mappers/MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapperTest.java", "last_update_at": "2018-07-17T09:18:02+00:00", "question_id": "be0015e402b07706ce13be7c877fce65664da2fb", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(MockitoJUnitRunner.class)\npublic class MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapperTest {\n    @Mock\n    private MatchingServiceAdapterConfiguration configuration;\n    @Mock\n    private IdGenerator idGenerator;\n    @Mock\n    private AssertionLifetimeConfiguration assertionLifetimeConfiguration;\n    private static final String ENTITY_ID = \"entityId\";\n    private static final String TEST_ID = \"testId\";\n    private static final String REQUEST_ID = \"requestId\";\n    private static final String ASSERTION_CONSUMER_SERVICE_URL = \"assertionConsumerServiceUrl\";\n    private static final String AUTHN_REQUEST_ISSUER_ID = \"authnRequestIssuerId\";\n    private static final String HASH_PID = \"hashPid\";\n    private MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper mapper;\n    @Before\n    public void setup(){\n        DateTimeFreezer.freezeTime();\n        mapper = new MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper(configuration, assertionLifetimeConfiguration, idGenerator);\n        when(assertionLifetimeConfiguration.getAssertionLifetime()).thenReturn(Duration.parse(\"30m\"));\n        when(configuration.getEntityId()).thenReturn(ENTITY_ID);\n        when(idGenerator.getId()).thenReturn(TEST_ID);\n    }\n    @After\n    public void after() {\n        DateTimeFreezer.unfreezeTime();\n    }\n    @Test\n    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withMatch().build();\n        OutboundResponseFromMatchingService responseFromMatchingService = mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n        assertThat(responseFromMatchingService.getStatus()).isEqualTo(MatchingServiceMatch);\n        assertThat(responseFromMatchingService.getInResponseTo()).isEqualTo(REQUEST_ID);\n        assertThat(responseFromMatchingService.getId()).isEqualTo(TEST_ID);\n        assertThat(responseFromMatchingService.getIssuer()).isEqualTo(ENTITY_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion()).isPresent();\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions()).isNotNull();\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getId()).isEqualTo(TEST_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getIssuerId()).isEqualTo(ENTITY_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getInResponseTo()).isEqualTo(REQUEST_ID);\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getNotOnOrAfter()).isEqualTo(DateTime.now().plus(assertionLifetimeConfiguration.getAssertionLifetime().toMilliseconds()));\n        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getRecipient()).isEqualTo(ASSERTION_CONSUMER_SERVICE_URL);\n    }\n    @Test\n    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithNoMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withNoMatch().build();\n        OutboundResponseFromMatchingService idaResponse = mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n        assertThat(idaResponse.getStatus()).isEqualTo(MatchingServiceIdaStatus.NoMatchingServiceMatchFromMatchingService);\n    }\n    @Test(expected = UnsupportedOperationException.class)\n    public void map_shouldThrowExceptionIfNotNoMatchOrMatch() {\n        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withBadResponse().build();\n        mapper.map(\n            response,\n            HASH_PID,\n            REQUEST_ID,\n            ASSERTION_CONSUMER_SERVICE_URL,\n            AuthnContext.LEVEL_2,\n            AUTHN_REQUEST_ISSUER_ID);\n    }\n"]], "pred": {"ppl": 1.5549529790878296, "ppl_lower": 1.9780865907669067, "ppl/lowercase_ppl": -1.545219756340378, "ppl/zlib": 0.0005145050194000897, "Min_5.0% Prob": 5.5832153862597895, "Min_10.0% Prob": 3.8002560945118176, "Min_20.0% Prob": 2.143641092321452, "Min_30.0% Prob": 1.4626938631648527, "Min_40.0% Prob": 1.1006703037554557, "Min_50.0% Prob": 0.8828943743709468, "Min_60.0% Prob": 0.7365409221631577}}
{"hexsha": "30474b1865cc9cb0d1f5a1b650378f81af9e9edf", "ext": "java", "lang": "Java", "content": "public class DownloadStatistics {\n    private final ResourceBundle BUNDLE = ResourceBundle.getBundle(\"languages.UIResources\");\n    private final String TIME_FORMAT = \"%02d:%02d min\";\n    private final String DESCRIPTION_TIME = BUNDLE.getString(\"download.statistics.time\");\n    private final String DESCRIPTION_DOWNLOAD_COUNT = BUNDLE.getString(\"download.statistics.successCounter\");\n    private final String DESCRIPTION_SKIPPED_COUNT = BUNDLE.getString(\"download.statistics.skippedCounter\");\n    private final String DESCRIPTION_FAILED_COUNT = BUNDLE.getString(\"download.statistics.failedCounter\");\n\n    private int downloadCount, skippedCount, failedCount;\n    private String downloadFolderLocation, formattedElapsedTime;\n    private long elapsedTime;\n\n\n    public void incrementDownloadCount() {\n        downloadCount++;\n    }\n\n    public void incrementSkippedCount() {\n        skippedCount++;\n    }\n\n    public void incrementFailedCount() {\n        failedCount++;\n    }\n\n    public int getDownloadCount() {\n        return downloadCount;\n    }\n\n    public int getSkippedCount() {\n        return skippedCount;\n    }\n\n    public int getFailedCount() {\n        return failedCount;\n    }\n\n    public void setDownloadFolderLocation(String location) {\n        downloadFolderLocation = location;\n    }\n\n    public String getDownloadFolderLocation() {\n        return downloadFolderLocation;\n    }\n\n    public void setElapsedTime(long elapsedTime) {\n        this.elapsedTime = elapsedTime;\n        this.formattedElapsedTime = setFormattedElapsedTime(elapsedTime);\n    }\n\n    private String setFormattedElapsedTime(long elapsedTime) {\n        long elapsedMinutes = TimeUnit.MILLISECONDS.toMinutes(elapsedTime);\n        long elapsedSeconds = TimeUnit.MILLISECONDS.toSeconds(elapsedTime);\n        long displayedElapsedSeconds = elapsedSeconds - TimeUnit.MINUTES.toSeconds(elapsedMinutes); //121 seconds - 120 seconds\n        return String.format(TIME_FORMAT, elapsedMinutes, displayedElapsedSeconds);\n    }\n\n    public long getElapsedTime() {\n        return elapsedTime;\n    }\n\n    public String getFormattedElapsedTime() {\n        return formattedElapsedTime;\n    }\n\n    public List<Pair> getDisplayableStats() {\n        List<Pair> stats = new ArrayList<>();\n        Pair<String, String> stat_time = new Pair<>(DESCRIPTION_TIME, getFormattedElapsedTime());\n        Pair<String, Integer> stat_download = new Pair<>(DESCRIPTION_DOWNLOAD_COUNT, getDownloadCount());\n        Pair<String, Integer> stat_skipped = new Pair<>(DESCRIPTION_SKIPPED_COUNT, getSkippedCount());\n        Pair<String, Integer> stat_failed = new Pair<>(DESCRIPTION_FAILED_COUNT, getFailedCount());\n        stats.add(stat_time);\n        stats.add(stat_download);\n        stats.add(stat_skipped);\n        stats.add(stat_failed);\n        return stats;\n    }\n}", "class_id": 0, "repo": "theovier/lernplattform-crawler", "file": "src/main/java/com/lailaps/download/DownloadStatistics.java", "last_update_at": "2018-10-24T13:30:06+00:00", "question_id": "30474b1865cc9cb0d1f5a1b650378f81af9e9edf", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DownloadStatistics {\n    private final ResourceBundle BUNDLE = ResourceBundle.getBundle(\"languages.UIResources\");\n    private final String TIME_FORMAT = \"%02d:%02d min\";\n    private final String DESCRIPTION_TIME = BUNDLE.getString(\"download.statistics.time\");\n    private final String DESCRIPTION_DOWNLOAD_COUNT = BUNDLE.getString(\"download.statistics.successCounter\");\n    private final String DESCRIPTION_SKIPPED_COUNT = BUNDLE.getString(\"download.statistics.skippedCounter\");\n    private final String DESCRIPTION_FAILED_COUNT = BUNDLE.getString(\"download.statistics.failedCounter\");\n    private int downloadCount, skippedCount, failedCount;\n    private String downloadFolderLocation, formattedElapsedTime;\n    private long elapsedTime;\n    public void incrementDownloadCount() {\n        downloadCount++;\n    }\n    public void incrementSkippedCount() {\n        skippedCount++;\n    }\n    public void incrementFailedCount() {\n        failedCount++;\n    }\n    public int getDownloadCount() {\n        return downloadCount;\n    }\n    public int getSkippedCount() {\n        return skippedCount;\n    }\n    public int getFailedCount() {\n        return failedCount;\n    }\n    public void setDownloadFolderLocation(String location) {\n        downloadFolderLocation = location;\n    }\n    public String getDownloadFolderLocation() {\n        return downloadFolderLocation;\n    }\n    public void setElapsedTime(long elapsedTime) {\n        this.elapsedTime = elapsedTime;\n        this.formattedElapsedTime = setFormattedElapsedTime(elapsedTime);\n    }\n    private String setFormattedElapsedTime(long elapsedTime) {\n        long elapsedMinutes = TimeUnit.MILLISECONDS.toMinutes(elapsedTime);\n        long elapsedSeconds = TimeUnit.MILLISECONDS.toSeconds(elapsedTime);\n        long displayedElapsedSeconds = elapsedSeconds - TimeUnit.MINUTES.toSeconds(elapsedMinutes); //121 seconds - 120 seconds\n        return String.format(TIME_FORMAT, elapsedMinutes, displayedElapsedSeconds);\n    }\n    public long getElapsedTime() {\n        return elapsedTime;\n    }\n    public String getFormattedElapsedTime() {\n        return formattedElapsedTime;\n    }\n    public List<Pair> getDisplayableStats() {\n        List<Pair> stats = new ArrayList<>();\n        Pair<String, String> stat_time = new Pair<>(DESCRIPTION_TIME, getFormattedElapsedTime());\n        Pair<String, Integer> stat_download = new Pair<>(DESCRIPTION_DOWNLOAD_COUNT, getDownloadCount());\n        Pair<String, Integer> stat_skipped = new Pair<>(DESCRIPTION_SKIPPED_COUNT, getSkippedCount());\n        Pair<String, Integer> stat_failed = new Pair<>(DESCRIPTION_FAILED_COUNT, getFailedCount());\n        stats.add(stat_time);\n        stats.add(stat_download);\n        stats.add(stat_skipped);\n        stats.add(stat_failed);\n        return stats;\n    }\n"]], "pred": {"ppl": 1.4941613674163818, "ppl_lower": 1.730133056640625, "ppl/lowercase_ppl": -1.3651543147620588, "ppl/zlib": 0.0005671823321988621, "Min_5.0% Prob": 5.319823312759399, "Min_10.0% Prob": 3.496123807132244, "Min_20.0% Prob": 1.9625906988047064, "Min_30.0% Prob": 1.332651940632301, "Min_40.0% Prob": 1.0033727604313754, "Min_50.0% Prob": 0.8036762527097017, "Min_60.0% Prob": 0.669994648521606}}
{"hexsha": "bfa69dbd88c38519fb209a7e4c2ea89fa9662cd1", "ext": "java", "lang": "Java", "content": "public abstract class BasicPHPWizardPage extends WizardPage {\n\n\tprivate IStatus fCurrStatus;\n\n\tprivate boolean fPageVisible;\n\n\tprotected BasicPHPWizardPage(String pageName) {\n\t\tsuper(pageName);\n\t}\n\n\tprotected Button createButton(Composite composite, int style,\n\t\t\tString message, GridData gd) {\n\t\tButton button = new Button(composite, style);\n\t\tbutton.setText(message);\n\t\tbutton.setLayoutData(gd);\n\t\treturn button;\n\t}\n\n\tprotected GridLayout createGridLayout(int columns) {\n\t\treturn new GridLayout(columns, false);\n\n\t}\n\n\tprotected GridData createGridData(int flag, int hspan, int vspan, int indent) {\n\t\tGridData gd = new GridData(flag);\n\t\tgd.horizontalIndent = indent;\n\t\tgd.horizontalSpan = hspan;\n\t\tgd.verticalSpan = vspan;\n\t\treturn gd;\n\t}\n\n\tprotected GridData createGridData(int flag, int hspan, int indent) {\n\t\tGridData gd = new GridData(flag);\n\t\tgd.horizontalIndent = indent;\n\t\tgd.horizontalSpan = hspan;\n\t\treturn gd;\n\t}\n\n\tprotected GridData createGridData(int hspan) {\n\t\tGridData gd = new GridData();\n\t\tgd.horizontalSpan = hspan;\n\t\treturn gd;\n\t}\n\n\tprotected void createSeparator(Composite composite, int horizontalSpan) {\n\t\tLabel line = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);\n\t\tGridData gridData = new GridData(GridData.FILL_HORIZONTAL);\n\t\tif (horizontalSpan > 0)\n\t\t\tgridData.horizontalSpan = horizontalSpan;\n\n\t\tline.setLayoutData(gridData);\n\t}\n\n\tprotected Label createLabel(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tLabel label = new Label(composite, style);\n\t\tlabel.setText(message);\n\t\tlabel.setLayoutData(gd);\n\t\treturn label;\n\t}\n\n\tprotected Text createText(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tText text = new Text(composite, style);\n\t\tif (message != null)\n\t\t\ttext.setText(message);\n\t\ttext.setLayoutData(gd);\n\t\treturn text;\n\t}\n\n\tprotected Combo createCombo(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tCombo combo = new Combo(composite, style);\n\t\tif (message != null)\n\t\t\tcombo.setText(message);\n\t\tcombo.setLayoutData(gd);\n\t\treturn combo;\n\t}\n\n\tprotected void handleFileBrowseButtonPressed(Text text,\n\t\t\tString[] extensions, String title) {\n\t\tFileDialog dialog = new FileDialog(text.getShell());\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null)\n\t\t\ttext.setText(selectedDirectory);\n\t}\n\n\tprotected void handleFileBrowseButtonPressed(Combo text,\n\t\t\tString[] extensions, String title) {\n\t\tFileDialog dialog = new FileDialog(text.getShell());\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null) {\n\t\t\ttext.add(selectedDirectory);\n\t\t\ttext.select(text.indexOf(selectedDirectory));\n\t\t\ttext.notifyListeners(SWT.Modify, new Event());\n\t\t}\n\t}\n\n\tprotected void handleFileBrowseButtonPressed(Combo text,\n\t\t\tString[] extensions, String title, String fileName) {\n\t\tFileDialog dialog = new FileDialog(text.getShell(), SWT.SAVE);\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tdialog.setFileName(fileName);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null) {\n\t\t\ttext.add(selectedDirectory);\n\t\t\ttext.select(text.indexOf(selectedDirectory));\n\t\t\ttext.notifyListeners(SWT.Modify, new Event());\n\t\t}\n\t}\n\n\tprotected String handleFolderBrowseButtonPressed(String dir, String title,\n\t\t\tString message) {\n\t\tDirectoryDialog dialog = new DirectoryDialog(getShell());\n\t\tdialog.setFilterPath(dir);\n\t\tdialog.setText(title);\n\t\tdialog.setMessage(message);\n\t\tString res = dialog.open();\n\t\tif (res != null) {\n\t\t\tFile file = new File(res);\n\t\t\tif (file.isDirectory())\n\t\t\t\treturn res;\n\t\t}\n\t\treturn dir;\n\t}\n\n\t/**\n\t * Updates the status line and the OK button according to the given status\n\t * \n\t * @param status\n\t *            status to apply\n\t */\n\tprotected void updateStatus(IStatus status) {\n\t\tfCurrStatus = status;\n\t\tsetPageComplete(!status.matches(IStatus.ERROR));\n\t\tif (fPageVisible) {\n\t\t\tStatusUtil.applyToStatusLine(this, status);\n\t\t}\n\t}\n\n\t/*\n\t * @see WizardPage#becomesVisible\n\t */\n\tpublic void setVisible(boolean visible) {\n\t\tsuper.setVisible(visible);\n\t\tfPageVisible = visible;\n\t\t// policy: wizards are not allowed to come up with an error message\n\t\tif (visible && fCurrStatus.matches(IStatus.ERROR)) {\n\t\t\tStatusInfo status = new StatusInfo();\n\t\t\tstatus.setError(\"\"); //$NON-NLS-1$\n\t\t\tfCurrStatus = status;\n\t\t}\n\t\tupdateStatus(fCurrStatus);\n\t}\n\n\tpublic ArrayList setComboItems(Combo combo, ArrayList arrItems) {\n\t\tarrItems.clear();\n\t\tarrItems.add(combo.getText()); // must be first\n\t\tString[] items = combo.getItems();\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\tString curr = items[i];\n\t\t\tif (!arrItems.contains(curr)) {\n\t\t\t\tarrItems.add(curr);\n\t\t\t}\n\t\t}\n\t\treturn arrItems;\n\n\t}\n\n\tprotected static class EnableSelectionAdapter extends SelectionAdapter {\n\t\tprivate Control[] fEnable;\n\t\tprivate Control[] fDisable;\n\n\t\tprotected EnableSelectionAdapter(Control[] enable, Control[] disable) {\n\t\t\tsuper();\n\t\t\tfEnable = enable;\n\t\t\tfDisable = disable;\n\t\t}\n\n\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\tfor (int i = 0; i < fEnable.length; i++) {\n\t\t\t\tfEnable[i].setEnabled(true);\n\t\t\t}\n\t\t\tfor (int i = 0; i < fDisable.length; i++) {\n\t\t\t\tfDisable[i].setEnabled(false);\n\t\t\t}\n\t\t\tvalidate();\n\t\t}\n\n\t\t// copied from WizardNewProjectCreationPage\n\t\tpublic void validate() {\n\t\t}\n\n\t} // end class EnableSelectionAdapter\n\n\tprotected static class ToggleSelectionAdapter extends SelectionAdapter {\n\t\tControl[] controls;\n\n\t\tprotected ToggleSelectionAdapter(Control[] controls) {\n\t\t\tthis.controls = controls;\n\t\t}\n\n\t\tpublic void widgetSelected(SelectionEvent e) {\n\n\t\t\tfor (int i = 0; i < controls.length; i++) {\n\t\t\t\tControl control = controls[i];\n\t\t\t\tcontrol.setEnabled(!control.getEnabled());\n\t\t\t}\n\t\t\tvalidate();\n\t\t}\n\n\t\tpublic void validate() {\n\t\t}\n\n\t} // end class ToggleSelection Adapter\n\n}", "class_id": 0, "repo": "NisalaNiroshana/developer-studio", "file": "jaggery/org.eclipse.php.ui/src/org/eclipse/php/internal/ui/wizards/BasicPHPWizardPage.java", "last_update_at": "2018-10-26T12:52:03+00:00", "question_id": "bfa69dbd88c38519fb209a7e4c2ea89fa9662cd1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class BasicPHPWizardPage extends WizardPage {\n\tprivate IStatus fCurrStatus;\n\tprivate boolean fPageVisible;\n\tprotected BasicPHPWizardPage(String pageName) {\n\t\tsuper(pageName);\n\t}\n\tprotected Button createButton(Composite composite, int style,\n\t\t\tString message, GridData gd) {\n\t\tButton button = new Button(composite, style);\n\t\tbutton.setText(message);\n\t\tbutton.setLayoutData(gd);\n\t\treturn button;\n\t}\n\tprotected GridLayout createGridLayout(int columns) {\n\t\treturn new GridLayout(columns, false);\n\t}\n\tprotected GridData createGridData(int flag, int hspan, int vspan, int indent) {\n\t\tGridData gd = new GridData(flag);\n\t\tgd.horizontalIndent = indent;\n\t\tgd.horizontalSpan = hspan;\n\t\tgd.verticalSpan = vspan;\n\t\treturn gd;\n\t}\n\tprotected GridData createGridData(int flag, int hspan, int indent) {\n\t\tGridData gd = new GridData(flag);\n\t\tgd.horizontalIndent = indent;\n\t\tgd.horizontalSpan = hspan;\n\t\treturn gd;\n\t}\n\tprotected GridData createGridData(int hspan) {\n\t\tGridData gd = new GridData();\n\t\tgd.horizontalSpan = hspan;\n\t\treturn gd;\n\t}\n\tprotected void createSeparator(Composite composite, int horizontalSpan) {\n\t\tLabel line = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);\n\t\tGridData gridData = new GridData(GridData.FILL_HORIZONTAL);\n\t\tif (horizontalSpan > 0)\n\t\t\tgridData.horizontalSpan = horizontalSpan;\n\t\tline.setLayoutData(gridData);\n\t}\n\tprotected Label createLabel(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tLabel label = new Label(composite, style);\n\t\tlabel.setText(message);\n\t\tlabel.setLayoutData(gd);\n\t\treturn label;\n\t}\n\tprotected Text createText(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tText text = new Text(composite, style);\n\t\tif (message != null)\n\t\t\ttext.setText(message);\n\t\ttext.setLayoutData(gd);\n\t\treturn text;\n\t}\n\tprotected Combo createCombo(Composite composite, int style, String message,\n\t\t\tGridData gd) {\n\t\tCombo combo = new Combo(composite, style);\n\t\tif (message != null)\n\t\t\tcombo.setText(message);\n\t\tcombo.setLayoutData(gd);\n\t\treturn combo;\n\t}\n\tprotected void handleFileBrowseButtonPressed(Text text,\n\t\t\tString[] extensions, String title) {\n\t\tFileDialog dialog = new FileDialog(text.getShell());\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null)\n\t\t\ttext.setText(selectedDirectory);\n\t}\n\tprotected void handleFileBrowseButtonPressed(Combo text,\n\t\t\tString[] extensions, String title) {\n\t\tFileDialog dialog = new FileDialog(text.getShell());\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null) {\n\t\t\ttext.add(selectedDirectory);\n\t\t\ttext.select(text.indexOf(selectedDirectory));\n\t\t\ttext.notifyListeners(SWT.Modify, new Event());\n\t\t}\n\t}\n\tprotected void handleFileBrowseButtonPressed(Combo text,\n\t\t\tString[] extensions, String title, String fileName) {\n\t\tFileDialog dialog = new FileDialog(text.getShell(), SWT.SAVE);\n\t\tdialog.setText(title);\n\t\tdialog.setFilterExtensions(extensions);\n\t\tdialog.setFileName(fileName);\n\t\tString dirName = text.getText();\n\t\tif (!dirName.equals(\"\")) { //$NON-NLS-1$\n\t\t\tFile path = new File(dirName);\n\t\t\tif (path.exists())\n\t\t\t\tdialog.setFilterPath(dirName);\n\t\t}\n\t\tString selectedDirectory = dialog.open();\n\t\tif (selectedDirectory != null) {\n\t\t\ttext.add(selectedDirectory);\n\t\t\ttext.select(text.indexOf(selectedDirectory));\n\t\t\ttext.notifyListeners(SWT.Modify, new Event());\n\t\t}\n\t}\n\tprotected String handleFolderBrowseButtonPressed(String dir, String title,\n\t\t\tString message) {\n\t\tDirectoryDialog dialog = new DirectoryDialog(getShell());\n\t\tdialog.setFilterPath(dir);\n\t\tdialog.setText(title);\n\t\tdialog.setMessage(message);\n\t\tString res = dialog.open();\n\t\tif (res != null) {\n\t\t\tFile file = new File(res);\n\t\t\tif (file.isDirectory())\n\t\t\t\treturn res;\n\t\t}\n\t\treturn dir;\n\t}\n\t/**\n\t * Updates the status line and the OK button according to the given status\n\t * \n\t * @param status\n\t *            status to apply\n\t */\n\tprotected void updateStatus(IStatus status) {\n\t\tfCurrStatus = status;\n\t\tsetPageComplete(!status.matches(IStatus.ERROR));\n\t\tif (fPageVisible) {\n\t\t\tStatusUtil.applyToStatusLine(this, status);\n\t\t}\n\t}\n\t/*\n\t * @see WizardPage#becomesVisible\n\t */\n\tpublic void setVisible(boolean visible) {\n\t\tsuper.setVisible(visible);\n\t\tfPageVisible = visible;\n\t\t// policy: wizards are not allowed to come up with an error message\n\t\tif (visible && fCurrStatus.matches(IStatus.ERROR)) {\n\t\t\tStatusInfo status = new StatusInfo();\n\t\t\tstatus.setError(\"\"); //$NON-NLS-1$\n\t\t\tfCurrStatus = status;\n\t\t}\n\t\tupdateStatus(fCurrStatus);\n\t}\n\tpublic ArrayList setComboItems(Combo combo, ArrayList arrItems) {\n\t\tarrItems.clear();\n\t\tarrItems.add(combo.getText()); // must be first\n\t\tString[] items = combo.getItems();\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\tString curr = items[i];\n\t\t\tif (!arrItems.contains(curr)) {\n\t\t\t\tarrItems.add(curr);\n\t\t\t}\n\t\t}\n\t\treturn arrItems;\n\t}\n\tprotected static class EnableSelectionAdapter extends SelectionAdapter {\n\t\tprivate Control[] fEnable;\n\t\tprivate Control[] fDisable;\n\t\tprotected EnableSelectionAdapter(Control[] enable, Control[] disable) {\n\t\t\tsuper();\n\t\t\tfEnable = enable;\n\t\t\tfDisable = disable;\n\t\t}\n\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\tfor (int i = 0; i < fEnable.length; i++) {\n\t\t\t\tfEnable[i].setEnabled(true);\n\t\t\t}\n\t\t\tfor (int i = 0; i < fDisable.length; i++) {\n\t\t\t\tfDisable[i].setEnabled(false);\n\t\t\t}\n\t\t\tvalidate();\n\t\t}\n\t\t// copied from WizardNewProjectCreationPage\n\t\tpublic void validate() {\n\t\t}\n\t} // end class EnableSelectionAdapter\n\tprotected static class ToggleSelectionAdapter extends SelectionAdapter {\n\t\tControl[] controls;\n\t\tprotected ToggleSelectionAdapter(Control[] controls) {\n\t\t\tthis.controls = controls;\n\t\t}\n\t\tpublic void widgetSelected(SelectionEvent e) {\n\t\t\tfor (int i = 0; i < controls.length; i++) {\n\t\t\t\tControl control = controls[i];\n\t\t\t\tcontrol.setEnabled(!control.getEnabled());\n\t\t\t}\n\t\t\tvalidate();\n\t\t}\n\t\tpublic void validate() {\n\t\t}\n\t} // end class ToggleSelection Adapter\n"]], "pred": {"ppl": 1.357118844985962, "ppl_lower": 1.5422087907791138, "ppl/lowercase_ppl": -1.418686324047719, "ppl/zlib": 0.0001868812461605981, "Min_5.0% Prob": 4.227734238493676, "Min_10.0% Prob": 2.6678785956373403, "Min_20.0% Prob": 1.4883879717512458, "Min_30.0% Prob": 1.0136031819190952, "Min_40.0% Prob": 0.762211215912312, "Min_50.0% Prob": 0.6109714561981311, "Min_60.0% Prob": 0.5095272536171512}}
{"hexsha": "f485edc9c37cda7badcb95c113e7db59bfa489a6", "ext": "java", "lang": "Java", "content": "public class UsingPanel extends Applet{\n\tMyPanel p1,p2,p3,p4;\n\t@Override\n\tpublic void init() {\n\t\tsetSize(500,500);\n\t\tp1=new MyPanel();\n\t\tp1.setLayout(new GridLayout(1, 4));\n\t\t\n\t\tp2=new MyPanel();\n\t\tp2.setLayout(new GridLayout(4, 1));\n\t\t\n\t\tp3=new MyPanel();\n\t\tp3.setLayout(new GridLayout(4, 1));\n\t\t\n\t\tp4=new MyPanel();\n\t\tp4.setLayout(new GridLayout(1, 4));\n\t\t\n\t\tsetLayout(new BorderLayout());\n\t\tadd(BorderLayout.NORTH,p1);\n\t\tadd(BorderLayout.EAST,p2);\n\t\tadd(BorderLayout.WEST,p3);\n\t\tadd(BorderLayout.SOUTH,p4);\n\t}\n}", "class_id": 0, "repo": "AlphaBAT69/Java-Programs", "file": "Applets_Awt/Panel/UsingPanel.java", "last_update_at": "2018-01-26T12:33:16+00:00", "question_id": "f485edc9c37cda7badcb95c113e7db59bfa489a6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class UsingPanel extends Applet{\n\tMyPanel p1,p2,p3,p4;\n\t@Override\n\tpublic void init() {\n\t\tsetSize(500,500);\n\t\tp1=new MyPanel();\n\t\tp1.setLayout(new GridLayout(1, 4));\n\t\t\n\t\tp2=new MyPanel();\n\t\tp2.setLayout(new GridLayout(4, 1));\n\t\t\n\t\tp3=new MyPanel();\n\t\tp3.setLayout(new GridLayout(4, 1));\n\t\t\n\t\tp4=new MyPanel();\n\t\tp4.setLayout(new GridLayout(1, 4));\n\t\t\n\t\tsetLayout(new BorderLayout());\n\t\tadd(BorderLayout.NORTH,p1);\n\t\tadd(BorderLayout.EAST,p2);\n\t\tadd(BorderLayout.WEST,p3);\n\t\tadd(BorderLayout.SOUTH,p4);\n\t}\n"]], "pred": {"ppl": 1.5559700727462769, "ppl_lower": 1.6900014877319336, "ppl/lowercase_ppl": -1.1869042481979186, "ppl/zlib": 0.001973657107668237, "Min_5.0% Prob": 5.238649845123291, "Min_10.0% Prob": 3.504105438788732, "Min_20.0% Prob": 2.1148679676104565, "Min_30.0% Prob": 1.4636615630086154, "Min_40.0% Prob": 1.1012399356660185, "Min_50.0% Prob": 0.8807788789272308, "Min_60.0% Prob": 0.7384509288002642}}
{"hexsha": "6c84bf0abda2a21e54a9c10a2328fd24ecf0eb35", "ext": "java", "lang": "Java", "content": "@With(Secure.class)\npublic class Admin extends Controller {\n    \n    @Before\n    static void setConnectedUser() {\n        if(Security.isConnected()) {\n            User user = User.findUnique(\"email=?\", Security.connected());\n            renderArgs.put(\"user\", user.getFullname());\n        }\n    }\n \n    public static void index() {\n        List<Post> posts = Post.<Post>find(\"author.email=?\", Security.connected()).findList();\n        render(posts);\n    }\n    \n    public static void form(Long id) {\n        if(id != null) {\n            Post post = Post.findById(id);\n            render(post);\n        }\n        render();\n    }\n    \n    public static void save(Long id, String title, String content, String tags) {\n        Post post;\n        if(id == null) {\n            // Create post\n            User author = User.findUnique(\"email=?\", Security.connected());\n            post = new Post(author, title, content);\n        } else {\n            // Retrieve post\n            post = Post.findById(id);\n            post.setTitle(title);\n            post.setContent(content);\n            post.getTags().clear();\n        }\n        // Set tags list\n        for(String tag : tags.split(\"\\\\s+\")) {\n            if(tag.trim().length() > 0) {\n                post.getTags().add(Tag.findOrCreateByName(tag));\n            }\n        }\n        // Validate\n        validation.valid(post);\n        if(validation.hasErrors()) {\n            render(\"@form\", post);\n        }\n        // Save\n        post.save();\n        index();\n    }\n    \n}", "class_id": 0, "repo": "play1-maven-plugin/play1-maven-test-projects", "file": "external-modules/ebean/ebean-yabe/app/controllers/Admin.java", "last_update_at": "2018-02-06T08:16:44+00:00", "question_id": "6c84bf0abda2a21e54a9c10a2328fd24ecf0eb35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@With(Secure.class)\npublic class Admin extends Controller {\n    @Before\n    static void setConnectedUser() {\n        if(Security.isConnected()) {\n            User user = User.findUnique(\"email=?\", Security.connected());\n            renderArgs.put(\"user\", user.getFullname());\n        }\n    }\n    public static void index() {\n        List<Post> posts = Post.<Post>find(\"author.email=?\", Security.connected()).findList();\n        render(posts);\n    }\n    public static void form(Long id) {\n        if(id != null) {\n            Post post = Post.findById(id);\n            render(post);\n        }\n        render();\n    }\n    public static void save(Long id, String title, String content, String tags) {\n        Post post;\n        if(id == null) {\n            // Create post\n            User author = User.findUnique(\"email=?\", Security.connected());\n            post = new Post(author, title, content);\n        } else {\n            // Retrieve post\n            post = Post.findById(id);\n            post.setTitle(title);\n            post.setContent(content);\n            post.getTags().clear();\n        }\n        // Set tags list\n        for(String tag : tags.split(\"\\\\s+\")) {\n            if(tag.trim().length() > 0) {\n                post.getTags().add(Tag.findOrCreateByName(tag));\n            }\n        }\n        // Validate\n        validation.valid(post);\n        if(validation.hasErrors()) {\n            render(\"@form\", post);\n        }\n        // Save\n        post.save();\n        index();\n    }\n"]], "pred": {"ppl": 1.8302180767059326, "ppl_lower": 2.3339595794677734, "ppl/lowercase_ppl": -1.4022451330549224, "ppl/zlib": 0.001111093984103503, "Min_5.0% Prob": 5.546987056732178, "Min_10.0% Prob": 3.9849634085382735, "Min_20.0% Prob": 2.6386966676939103, "Min_30.0% Prob": 1.9206241679096978, "Min_40.0% Prob": 1.4813917598997552, "Min_50.0% Prob": 1.200889210154613, "Min_60.0% Prob": 1.0059908078835598}}
{"hexsha": "04a80de7558ca38cbf07beb9a98e61050884caee", "ext": "java", "lang": "Java", "content": "public abstract class BaseDatum implements Datum, Cloneable {\n\n\tprivate static final ConcurrentMap<Class<?>, String[]> DATUM_TYPE_CACHE = new ConcurrentHashMap<Class<?>, String[]>();\n\n\tprivate String sourceId = null;\n\tprivate Date created = null;\n\tprivate Date uploaded = null;\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic BaseDatum() {\n\t\tsuper();\n\t\tsetSourceId(\"\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * <p>\n\t * This method returns the result of {@link #createSimpleMap()}.\n\t * </p>\n\t * \n\t * @since 1.2\n\t */\n\t@Override\n\tfinal public Map<String, ?> asSimpleMap() {\n\t\treturn createSimpleMap();\n\t}\n\n\t/**\n\t * Create a map of simple property data out of this object.\n\t * \n\t * <p>\n\t * This method will populate the properties of this class and the\n\t * {@link Datum#DATUM_TYPE_PROPERTY} and {@link Datum#DATUM_TYPES_PROPERTY}\n\t * properties. It will then call {@link #getSampleData()} and add all those\n\t * values to the returned result.\n\t * </p>\n\t * \n\t * @return a map of simple property data\n\t * @since 1.2\n\t */\n\tprotected Map<String, Object> createSimpleMap() {\n\t\tMap<String, Object> map = new LinkedHashMap<String, Object>();\n\t\tif ( created != null ) {\n\t\t\tmap.put(\"created\", created.getTime());\n\t\t}\n\t\tif ( sourceId != null ) {\n\t\t\tmap.put(\"sourceId\", sourceId);\n\t\t}\n\t\tString[] datumTypes = getDatumTypes(getClass());\n\t\tif ( datumTypes != null && datumTypes.length > 0 ) {\n\t\t\tmap.put(DATUM_TYPE_PROPERTY, datumTypes[0]);\n\t\t\tmap.put(DATUM_TYPES_PROPERTY, datumTypes);\n\t\t}\n\t\tif ( uploaded != null ) {\n\t\t\tmap.put(\"uploaded\", uploaded.getTime());\n\t\t}\n\t\tMap<String, ?> sampleData = getSampleData();\n\t\tif ( sampleData != null ) {\n\t\t\tmap.putAll(sampleData);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * Get an array of datum types for a class.\n\t * \n\t * <p>\n\t * This method caches the results for performance.\n\t * </p>\n\t * \n\t * @param clazz\n\t *        the datum class to get the types for\n\t * @return the types\n\t * @since 1.2\n\t */\n\tpublic static String[] getDatumTypes(Class<?> clazz) {\n\t\tString[] result = DATUM_TYPE_CACHE.get(clazz);\n\t\tif ( result != null ) {\n\t\t\treturn result;\n\t\t}\n\t\tSet<Class<?>> interfaces = ClassUtils.getAllNonJavaInterfacesForClassAsSet(clazz);\n\t\tresult = new String[interfaces.size()];\n\t\tint i = 0;\n\t\tfor ( Class<?> intf : interfaces ) {\n\t\t\tresult[i] = intf.getName();\n\t\t\ti++;\n\t\t}\n\t\tDATUM_TYPE_CACHE.putIfAbsent(clazz, result);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Object clone() {\n\t\ttry {\n\t\t\treturn super.clone();\n\t\t} catch ( CloneNotSupportedException e ) {\n\t\t\t// should never get here\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((created == null) ? 0 : created.hashCode());\n\t\tresult = prime * result + ((sourceId == null) ? 0 : sourceId.hashCode());\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare for equality.\n\t * \n\t * <p>\n\t * This method compares the {@code created} and {@code sourceId} values for\n\t * equality.\n\t * </p>\n\t * \n\t * @return <em>true</em> if the objects are equal\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif ( this == obj ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( getClass() != obj.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tBaseDatum other = (BaseDatum) obj;\n\t\tif ( created == null ) {\n\t\t\tif ( other.created != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( !(created.getTime() == other.created.getTime()) ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( sourceId == null ) {\n\t\t\tif ( other.sourceId != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( !sourceId.equals(other.sourceId) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Map<String, ?> getSampleData() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Date getCreated() {\n\t\treturn created;\n\t}\n\n\tpublic void setCreated(Date created) {\n\t\tthis.created = created;\n\t}\n\n\t@Override\n\tpublic String getSourceId() {\n\t\treturn sourceId;\n\t}\n\n\tpublic void setSourceId(String sourceId) {\n\t\tthis.sourceId = sourceId;\n\t}\n\n\t@Override\n\tpublic Date getUploaded() {\n\t\treturn uploaded;\n\t}\n\n\tpublic void setUploaded(Date uploaded) {\n\t\tthis.uploaded = uploaded;\n\t}\n\n}", "class_id": 0, "repo": "eniware-org/org.eniware.edge", "file": "org.eniware.edge/src/org/eniware/edge/domain/BaseDatum.java", "last_update_at": "2018-03-20T17:44:28+00:00", "question_id": "04a80de7558ca38cbf07beb9a98e61050884caee", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class BaseDatum implements Datum, Cloneable {\n\tprivate static final ConcurrentMap<Class<?>, String[]> DATUM_TYPE_CACHE = new ConcurrentHashMap<Class<?>, String[]>();\n\tprivate String sourceId = null;\n\tprivate Date created = null;\n\tprivate Date uploaded = null;\n\t/**\n\t * Default constructor.\n\t */\n\tpublic BaseDatum() {\n\t\tsuper();\n\t\tsetSourceId(\"\");\n\t}\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * <p>\n\t * This method returns the result of {@link #createSimpleMap()}.\n\t * </p>\n\t * \n\t * @since 1.2\n\t */\n\t@Override\n\tfinal public Map<String, ?> asSimpleMap() {\n\t\treturn createSimpleMap();\n\t}\n\t/**\n\t * Create a map of simple property data out of this object.\n\t * \n\t * <p>\n\t * This method will populate the properties of this class and the\n\t * {@link Datum#DATUM_TYPE_PROPERTY} and {@link Datum#DATUM_TYPES_PROPERTY}\n\t * properties. It will then call {@link #getSampleData()} and add all those\n\t * values to the returned result.\n\t * </p>\n\t * \n\t * @return a map of simple property data\n\t * @since 1.2\n\t */\n\tprotected Map<String, Object> createSimpleMap() {\n\t\tMap<String, Object> map = new LinkedHashMap<String, Object>();\n\t\tif ( created != null ) {\n\t\t\tmap.put(\"created\", created.getTime());\n\t\t}\n\t\tif ( sourceId != null ) {\n\t\t\tmap.put(\"sourceId\", sourceId);\n\t\t}\n\t\tString[] datumTypes = getDatumTypes(getClass());\n\t\tif ( datumTypes != null && datumTypes.length > 0 ) {\n\t\t\tmap.put(DATUM_TYPE_PROPERTY, datumTypes[0]);\n\t\t\tmap.put(DATUM_TYPES_PROPERTY, datumTypes);\n\t\t}\n\t\tif ( uploaded != null ) {\n\t\t\tmap.put(\"uploaded\", uploaded.getTime());\n\t\t}\n\t\tMap<String, ?> sampleData = getSampleData();\n\t\tif ( sampleData != null ) {\n\t\t\tmap.putAll(sampleData);\n\t\t}\n\t\treturn map;\n\t}\n\t/**\n\t * Get an array of datum types for a class.\n\t * \n\t * <p>\n\t * This method caches the results for performance.\n\t * </p>\n\t * \n\t * @param clazz\n\t *        the datum class to get the types for\n\t * @return the types\n\t * @since 1.2\n\t */\n\tpublic static String[] getDatumTypes(Class<?> clazz) {\n\t\tString[] result = DATUM_TYPE_CACHE.get(clazz);\n\t\tif ( result != null ) {\n\t\t\treturn result;\n\t\t}\n\t\tSet<Class<?>> interfaces = ClassUtils.getAllNonJavaInterfacesForClassAsSet(clazz);\n\t\tresult = new String[interfaces.size()];\n\t\tint i = 0;\n\t\tfor ( Class<?> intf : interfaces ) {\n\t\t\tresult[i] = intf.getName();\n\t\t\ti++;\n\t\t}\n\t\tDATUM_TYPE_CACHE.putIfAbsent(clazz, result);\n\t\treturn result;\n\t}\n\t@Override\n\tpublic Object clone() {\n\t\ttry {\n\t\t\treturn super.clone();\n\t\t} catch ( CloneNotSupportedException e ) {\n\t\t\t// should never get here\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((created == null) ? 0 : created.hashCode());\n\t\tresult = prime * result + ((sourceId == null) ? 0 : sourceId.hashCode());\n\t\treturn result;\n\t}\n\t/**\n\t * Compare for equality.\n\t * \n\t * <p>\n\t * This method compares the {@code created} and {@code sourceId} values for\n\t * equality.\n\t * </p>\n\t * \n\t * @return <em>true</em> if the objects are equal\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif ( this == obj ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( getClass() != obj.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tBaseDatum other = (BaseDatum) obj;\n\t\tif ( created == null ) {\n\t\t\tif ( other.created != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( !(created.getTime() == other.created.getTime()) ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( sourceId == null ) {\n\t\t\tif ( other.sourceId != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( !sourceId.equals(other.sourceId) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t@Override\n\tpublic Map<String, ?> getSampleData() {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic Date getCreated() {\n\t\treturn created;\n\t}\n\tpublic void setCreated(Date created) {\n\t\tthis.created = created;\n\t}\n\t@Override\n\tpublic String getSourceId() {\n\t\treturn sourceId;\n\t}\n\tpublic void setSourceId(String sourceId) {\n\t\tthis.sourceId = sourceId;\n\t}\n\t@Override\n\tpublic Date getUploaded() {\n\t\treturn uploaded;\n\t}\n\tpublic void setUploaded(Date uploaded) {\n\t\tthis.uploaded = uploaded;\n\t}\n"]], "pred": {"ppl": 1.5672452449798584, "ppl_lower": 1.8593672513961792, "ppl/lowercase_ppl": -1.3803903492686573, "ppl/zlib": 0.00033506298074405363, "Min_5.0% Prob": 4.649369725994036, "Min_10.0% Prob": 3.3904481950928185, "Min_20.0% Prob": 2.1117818037084506, "Min_30.0% Prob": 1.4827943970418833, "Min_40.0% Prob": 1.1206274991149132, "Min_50.0% Prob": 0.898917601456585, "Min_60.0% Prob": 0.7497145122674492}}
{"hexsha": "86eaf9118edd27052c3f5011af1e8658db68c3ae", "ext": "java", "lang": "Java", "content": "public class PcmlStruct {\n\t\n\tprivate PcmlElement[] elements;\n\tprivate String[] shortElementNames;\n\tprivate String[] longElementNames;\n\tprivate String preamble;\n \n\tpublic PcmlStruct(String programName, String structName, PcmlElement[] elements) {\n\t\tif (structName.equals('[' + programName + ']')) {\n\t\t\tpreamble = programName + '.';\n\t\t} else if (elements.length==1 || elements[0].getCount() > 1) {\n\t\t\t// this is a repeating structure\n\t\t\tpreamble = programName + '.';\n\t\t} else {\n\t\t\tpreamble = programName + '.' + structName + '.';\n\t\t}\n\t\tthis.elements = elements;\n\t\tshortElementNames = new String[elements.length];\n\t\tlongElementNames = new String[elements.length];\n\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\tString shortName = elements[x].getName();\n\t\t\tshortElementNames[x] = shortName;\n\t\t\tlongElementNames[x] = preamble + shortName;\n\t\t}\n\t}\n\t\n\tpublic String[] getElementNames() {\n\t\treturn shortElementNames;\n\t}\n\t\n\tpublic String getPreamble() {\n\t\treturn preamble;\n\t}\n\t\n\tpublic PcmlElement getElement(String name) {\n\t\tboolean found = false;\n\t\tPcmlElement result = null;\n\t\tfor (int x=0; x<elements.length && !found; x++) {\n\t\t\tif (name.equalsIgnoreCase(elements[x].getName())) {\n\t\t\t\tresult = elements[x];\n\t\t\t\tfound = true;\n\t\t \t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate void checkElemValues(Object[] elementValues) throws PcmlCallException {\n\t\tif (elementValues.length != elements.length) {\n\t\t\tthrow new PcmlCallException(\n\t\t\t\t\t\"The number of element values do not equal the number of element names; \" +\n\t\t\t\t\t\"Names=\"  + elements.length + \", Values=\" + elementValues.length);\n\t\t}\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, Object[] elementValues) throws PcmlCallException {\n\t\tcheckElemValues(elementValues);\n\t\tString elementName = null;\n\t\tObject elementValue = null;\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\telementName = longElementNames[x];\n\t\t\t\telementValue = elementValues[x];\n\t\t\t\tpcd.setValue(elementName, elementValue);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tString msg = String.format(\n\t\t\t\t\t\"Unable to set ProgramCallDocument element:%s, value:%s\", \n\t\t\t\t\telementName, elementValue);\n\t\t\tthrow new PcmlCallException(msg, e);\n\t\t}\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd) throws PcmlCallException {\n\t\tMap<String, Object> resultMap = new HashMap<String, Object>();\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tObject value = pcd.getValue(longElementNames[x]);\n\t\t\t\tresultMap.put(elements[x].getName(), value);\n\t\t\t}\n\t\t\treturn resultMap;\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument values\", e);\n\t\t}\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, int index, Object[] elementValues) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\tsetDocValues(pcd, indices, elementValues);\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd, int index) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\treturn getDocValues(pcd, indices);\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, int[] indices, Object[] elementValues) throws PcmlCallException {\n\t\tcheckElemValues(elementValues);\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tpcd.setValue(longElementNames[x], indices, elementValues[x]);\n\t\t\t}\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to set ProgramCallDocument values\", e);\n\t\t}\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd, int[] indices) throws PcmlCallException {\n\t\tMap<String, Object> resultMap = new HashMap<String, Object>();\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tObject value = pcd.getValue(longElementNames[x], indices);\n\t\t\t\tresultMap.put(elements[x].getName(), value);\n\t\t\t}\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument values\", e);\n\t\t}\n\t\treturn resultMap;\n\t}\n\t\n\tpublic Object getValue(ProgramCallDocument pcd, String element) throws PcmlCallException {\n\t\tObject result = null;\n\t\ttry {\n\t\t\tresult = pcd.getValue(preamble + element);\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument value\", e);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tpublic Object getValue(ProgramCallDocument pcd, String element, int index) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\treturn getValue(pcd, element, indices);\n\t}\n\n\tprivate Object getValue(ProgramCallDocument pcd, String element, int[] indices) throws PcmlCallException {\n\t\tObject result = null;\n\t\ttry {\n\t\t\tresult = pcd.getValue(preamble + element, indices);\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument value\", e);\n\t\t}\n\t\treturn result;\n\t}\n\n}", "class_id": 0, "repo": "dweibel/pcml-om", "file": "src/main/java/org/pcml_om/map/PcmlStruct.java", "last_update_at": "2018-02-23T07:25:15+00:00", "question_id": "86eaf9118edd27052c3f5011af1e8658db68c3ae", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class PcmlStruct {\n\t\n\tprivate PcmlElement[] elements;\n\tprivate String[] shortElementNames;\n\tprivate String[] longElementNames;\n\tprivate String preamble;\n\tpublic PcmlStruct(String programName, String structName, PcmlElement[] elements) {\n\t\tif (structName.equals('[' + programName + ']')) {\n\t\t\tpreamble = programName + '.';\n\t\t} else if (elements.length==1 || elements[0].getCount() > 1) {\n\t\t\t// this is a repeating structure\n\t\t\tpreamble = programName + '.';\n\t\t} else {\n\t\t\tpreamble = programName + '.' + structName + '.';\n\t\t}\n\t\tthis.elements = elements;\n\t\tshortElementNames = new String[elements.length];\n\t\tlongElementNames = new String[elements.length];\n\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\tString shortName = elements[x].getName();\n\t\t\tshortElementNames[x] = shortName;\n\t\t\tlongElementNames[x] = preamble + shortName;\n\t\t}\n\t}\n\t\n\tpublic String[] getElementNames() {\n\t\treturn shortElementNames;\n\t}\n\t\n\tpublic String getPreamble() {\n\t\treturn preamble;\n\t}\n\t\n\tpublic PcmlElement getElement(String name) {\n\t\tboolean found = false;\n\t\tPcmlElement result = null;\n\t\tfor (int x=0; x<elements.length && !found; x++) {\n\t\t\tif (name.equalsIgnoreCase(elements[x].getName())) {\n\t\t\t\tresult = elements[x];\n\t\t\t\tfound = true;\n\t\t \t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate void checkElemValues(Object[] elementValues) throws PcmlCallException {\n\t\tif (elementValues.length != elements.length) {\n\t\t\tthrow new PcmlCallException(\n\t\t\t\t\t\"The number of element values do not equal the number of element names; \" +\n\t\t\t\t\t\"Names=\"  + elements.length + \", Values=\" + elementValues.length);\n\t\t}\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, Object[] elementValues) throws PcmlCallException {\n\t\tcheckElemValues(elementValues);\n\t\tString elementName = null;\n\t\tObject elementValue = null;\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\telementName = longElementNames[x];\n\t\t\t\telementValue = elementValues[x];\n\t\t\t\tpcd.setValue(elementName, elementValue);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tString msg = String.format(\n\t\t\t\t\t\"Unable to set ProgramCallDocument element:%s, value:%s\", \n\t\t\t\t\telementName, elementValue);\n\t\t\tthrow new PcmlCallException(msg, e);\n\t\t}\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd) throws PcmlCallException {\n\t\tMap<String, Object> resultMap = new HashMap<String, Object>();\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tObject value = pcd.getValue(longElementNames[x]);\n\t\t\t\tresultMap.put(elements[x].getName(), value);\n\t\t\t}\n\t\t\treturn resultMap;\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument values\", e);\n\t\t}\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, int index, Object[] elementValues) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\tsetDocValues(pcd, indices, elementValues);\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd, int index) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\treturn getDocValues(pcd, indices);\n\t}\n\t\n\tpublic void setDocValues(ProgramCallDocument pcd, int[] indices, Object[] elementValues) throws PcmlCallException {\n\t\tcheckElemValues(elementValues);\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tpcd.setValue(longElementNames[x], indices, elementValues[x]);\n\t\t\t}\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to set ProgramCallDocument values\", e);\n\t\t}\n\t}\n\t\n\tpublic Map<String, Object> getDocValues(ProgramCallDocument pcd, int[] indices) throws PcmlCallException {\n\t\tMap<String, Object> resultMap = new HashMap<String, Object>();\n\t\ttry {\n\t\t\tfor (int x=0; x<elements.length; x++) {\n\t\t\t\tObject value = pcd.getValue(longElementNames[x], indices);\n\t\t\t\tresultMap.put(elements[x].getName(), value);\n\t\t\t}\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument values\", e);\n\t\t}\n\t\treturn resultMap;\n\t}\n\t\n\tpublic Object getValue(ProgramCallDocument pcd, String element) throws PcmlCallException {\n\t\tObject result = null;\n\t\ttry {\n\t\t\tresult = pcd.getValue(preamble + element);\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument value\", e);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tpublic Object getValue(ProgramCallDocument pcd, String element, int index) throws PcmlCallException {\n\t\tint[] indices = { index };\n\t\treturn getValue(pcd, element, indices);\n\t}\n\tprivate Object getValue(ProgramCallDocument pcd, String element, int[] indices) throws PcmlCallException {\n\t\tObject result = null;\n\t\ttry {\n\t\t\tresult = pcd.getValue(preamble + element, indices);\n\t\t} catch (PcmlException e) {\n\t\t\tthrow new PcmlCallException(\"Unable to get ProgramCallDocument value\", e);\n\t\t}\n\t\treturn result;\n\t}\n"]], "pred": {"ppl": 1.6934689283370972, "ppl_lower": 1.799477219581604, "ppl/lowercase_ppl": -1.115261121649237, "ppl/zlib": 0.0005453199228840686, "Min_5.0% Prob": 6.097244660059611, "Min_10.0% Prob": 4.1989370245559545, "Min_20.0% Prob": 2.494182637947447, "Min_30.0% Prob": 1.7297143303344842, "Min_40.0% Prob": 1.3089922907463933, "Min_50.0% Prob": 1.051604002468113, "Min_60.0% Prob": 0.8779541240704244}}
{"hexsha": "822fe555017e61c5d3fad515cf03a0e47c935187", "ext": "java", "lang": "Java", "content": "public class Server {\n\n    /*\n        INITIAL CONSTANTS/VARS\n     */\n    private SocketAddress addr;\n    private ServerSocketChannel server;\n    private Selector selector;\n\n    //This handles incoming requests.\n    private RequestHandler requestHandler;\n\n    private final static int bufferSize = 512;\n\n    //Stores users that have been authorized.\n    private static BiMap<User, SelectionKey> clients = HashBiMap.create();\n\n    //The database\n    public Mongo mongo;\n\n\n\n\n    /**\n     * Initializes a non-blocking asynchronous Server object.\n     * Binds a new Socket to a provided address and begins listening on a new thread.\n     * @param port Start the server on this port.\n     * @param ip Start the server on this IP.\n     * @throws IOException\n     */\n    public Server(int port, String ip, Mongo mongo) throws IOException {\n\n        if(selector != null) return;\n        if(server != null) return;\n\n        //Setup & bind on address (ip, port)\n        selector = Selector.open();\n        server = ServerSocketChannel.open();\n        server.configureBlocking(false);\n\n\n        //Begin listening for incoming connections\n        addr = new InetSocketAddress(ip, port);\n        server.socket().bind(addr);\n\n        //Create a new request handler\n        requestHandler = new RequestHandler(mongo);\n\n        //set the db\n        this.mongo = mongo;\n\n        //Set up the selection key\n        server.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"Server has been opened at \" + ip + \":\" + port);\n\n        //Start the server in another thread.\n        run();\n\n    }\n\n    public void run() {\n\n        while (true) {\n            try {\n                selector.select();\n            }\n            //Client has closed connection\n            catch(IOException ex) {\n                ex.printStackTrace();\n                return;\n            }\n\n            //Maintains a request for every channel\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n\n                if(!key.isValid()) {\n                    continue;\n                }\n\n                if (key.isAcceptable()) {\n                    accept(selector);\n\n                } else if (key.isWritable()) {\n                    write(key);\n\n                } else if (key.isReadable()) {\n                    read(key);\n                }\n\n                //Remove the request from the Set\n                iter.remove();\n            }\n        }\n    }\n\n\n    /*\n     * Accepts a new client connection and creates a new socket\n     * for the client. Then, tells the server to read from the client.\n     */\n    private void accept(Selector selector) {\n        try {\n\n            SocketChannel client = server.accept();\n            //Disable blocking on new client channel\n            client.configureBlocking(false);\n            //Tell the server to wait & read from the client\n            SelectionKey key = client.register(selector, SelectionKey.OP_READ);\n            addUser(key);\n\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private void disconnect(SelectionKey key) {\n        User user = clients.inverse().get(key);\n        clients.remove(user);\n        clients.remove(key);\n        key.cancel();\n\n        FetchActiveUsers.broadcastUserList(this, null);\n    }\n\n    private void read(SelectionKey key) {\n        User user = getUser(key);\n        SocketChannel client = user.getChannel();\n\n        try {\n\n            //Read from the socket\n            ByteBuffer buffer = ByteBuffer.allocate(bufferSize);\n            int read = client.read(buffer);\n\n            //If there was anything in the read buffer...\n            if(read > 0) {\n\n                String data = new String(buffer.array(), \"UTF-8\");\n\n                //Prune null values from the string.\n                data = data.replaceAll(\"\\u0000.*,\", \"\");\n\n                System.out.println(data);\n\n                requestHandler.handleRequest(this, user, data);\n                //ResponseHandler.handleResponse(this, user, response);\n\n                //Write to the client if there are any messages to be sent\n                if(user.hasMessages()) {\n                    key.interestOps(SelectionKey.OP_WRITE);\n                }\n            }\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n            disconnect(key);\n        }\n    }\n\n\n    private void write(SelectionKey key) {\n\n        User user = getUser(key);\n        SocketChannel client = user.getChannel();\n\n        try {\n\n            //Get next message in queue belonging to THIS client channel & remove it\n            ArrayList<String> messages = user.getMessages();\n            while(!messages.isEmpty()) {\n                String message = messages.remove(0) + \"\\r\\n\";\n                System.out.println(\"Sending to client: \" + message);\n                client.write(ByteBuffer.wrap(message.getBytes()));\n            }\n\n            key.interestOps(SelectionKey.OP_READ);\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n            disconnect(key);\n        }\n        //For now NullPointerException would be thrown if the server doesn't write back to the client.\n        catch(NullPointerException ex) {\n            ex.printStackTrace();\n            key.interestOps(SelectionKey.OP_READ);\n        }\n    }\n\n    /*\n        UTILS\n        ====\n     */\n    /**\n     * Add a message to the message queue that will be sent next time\n     * the server is writing to the client.\n     * @param key the client that should be sent the message.\n     * @param message the actual message.\n     */\n    public void pushMessage(SelectionKey key, String message) {\n        User user = getUser(key);\n        user.queueMessage(message);\n    }\n\n    /**\n     * Adds a message to the message queue and tells the server to send the queue\n     * to the client, given the username.\n     * @param user the username to send the queue.\n     * @param message the actual message.\n     * @return true if the message was sent, otherwise false (invalid user was provided)\n     */\n    public boolean send(User user, String message) {\n        SelectionKey key = user.getKey();\n        pushMessage(key, message);\n        if(key.isValid()) {\n            key.interestOps(SelectionKey.OP_WRITE);\n            return true;\n        }\n        return false;\n    }\n\n\n    /**\n     * Returns a list of the currently connected users.\n     * @return Set<String>\n     */\n    public Set<User> getClientList() {\n        return clients.keySet();\n    }\n\n    /**\n     * Adds a new client to the connected users list.\n     * @param username the username of the client to add.\n     * @param key the key belonging to the client.\n     */\n    public User addUser(String username, SelectionKey key) {\n        User user = new User(key);\n        user.setUsername(username);\n\n        clients.put(user, key);\n        return user;\n    }\n\n    /**\n     * Adds a new user when the username is unknown\n     * @param key\n     */\n    public User addUser(SelectionKey key) {\n        User user = new User(key);\n        clients.put(user, key);\n        return user;\n    }\n\n    /**\n     * Returns the username of a client, given their key.\n     * @param key the key of the client.\n     * @return the username as a String.\n     */\n    public User getUser(SelectionKey key) {\n        if(clients.inverse().containsKey(key)) {\n            return clients.inverse().get(key);\n        }\n        return addUser(key);\n    }\n\n}", "class_id": 0, "repo": "dy1zan/RawM", "file": "src/main/java/today/doingit/Server/Server.java", "last_update_at": "2018-06-15T23:33:25+00:00", "question_id": "822fe555017e61c5d3fad515cf03a0e47c935187", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Server {\n    /*\n        INITIAL CONSTANTS/VARS\n     */\n    private SocketAddress addr;\n    private ServerSocketChannel server;\n    private Selector selector;\n    //This handles incoming requests.\n    private RequestHandler requestHandler;\n    private final static int bufferSize = 512;\n    //Stores users that have been authorized.\n    private static BiMap<User, SelectionKey> clients = HashBiMap.create();\n    //The database\n    public Mongo mongo;\n    /**\n     * Initializes a non-blocking asynchronous Server object.\n     * Binds a new Socket to a provided address and begins listening on a new thread.\n     * @param port Start the server on this port.\n     * @param ip Start the server on this IP.\n     * @throws IOException\n     */\n    public Server(int port, String ip, Mongo mongo) throws IOException {\n        if(selector != null) return;\n        if(server != null) return;\n        //Setup & bind on address (ip, port)\n        selector = Selector.open();\n        server = ServerSocketChannel.open();\n        server.configureBlocking(false);\n        //Begin listening for incoming connections\n        addr = new InetSocketAddress(ip, port);\n        server.socket().bind(addr);\n        //Create a new request handler\n        requestHandler = new RequestHandler(mongo);\n        //set the db\n        this.mongo = mongo;\n        //Set up the selection key\n        server.register(selector, SelectionKey.OP_ACCEPT);\n        System.out.println(\"Server has been opened at \" + ip + \":\" + port);\n        //Start the server in another thread.\n        run();\n    }\n    public void run() {\n        while (true) {\n            try {\n                selector.select();\n            }\n            //Client has closed connection\n            catch(IOException ex) {\n                ex.printStackTrace();\n                return;\n            }\n            //Maintains a request for every channel\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                if(!key.isValid()) {\n                    continue;\n                }\n                if (key.isAcceptable()) {\n                    accept(selector);\n                } else if (key.isWritable()) {\n                    write(key);\n                } else if (key.isReadable()) {\n                    read(key);\n                }\n                //Remove the request from the Set\n                iter.remove();\n            }\n        }\n    }\n    /*\n     * Accepts a new client connection and creates a new socket\n     * for the client. Then, tells the server to read from the client.\n     */\n    private void accept(Selector selector) {\n        try {\n            SocketChannel client = server.accept();\n            //Disable blocking on new client channel\n            client.configureBlocking(false);\n            //Tell the server to wait & read from the client\n            SelectionKey key = client.register(selector, SelectionKey.OP_READ);\n            addUser(key);\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n    private void disconnect(SelectionKey key) {\n        User user = clients.inverse().get(key);\n        clients.remove(user);\n        clients.remove(key);\n        key.cancel();\n        FetchActiveUsers.broadcastUserList(this, null);\n    }\n    private void read(SelectionKey key) {\n        User user = getUser(key);\n        SocketChannel client = user.getChannel();\n        try {\n            //Read from the socket\n            ByteBuffer buffer = ByteBuffer.allocate(bufferSize);\n            int read = client.read(buffer);\n            //If there was anything in the read buffer...\n            if(read > 0) {\n                String data = new String(buffer.array(), \"UTF-8\");\n                //Prune null values from the string.\n                data = data.replaceAll(\"\\u0000.*,\", \"\");\n                System.out.println(data);\n                requestHandler.handleRequest(this, user, data);\n                //ResponseHandler.handleResponse(this, user, response);\n                //Write to the client if there are any messages to be sent\n                if(user.hasMessages()) {\n                    key.interestOps(SelectionKey.OP_WRITE);\n                }\n            }\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n            disconnect(key);\n        }\n    }\n    private void write(SelectionKey key) {\n        User user = getUser(key);\n        SocketChannel client = user.getChannel();\n        try {\n            //Get next message in queue belonging to THIS client channel & remove it\n            ArrayList<String> messages = user.getMessages();\n            while(!messages.isEmpty()) {\n                String message = messages.remove(0) + \"\\r\\n\";\n                System.out.println(\"Sending to client: \" + message);\n                client.write(ByteBuffer.wrap(message.getBytes()));\n            }\n            key.interestOps(SelectionKey.OP_READ);\n        }\n        catch(IOException ex) {\n            ex.printStackTrace();\n            disconnect(key);\n        }\n        //For now NullPointerException would be thrown if the server doesn't write back to the client.\n        catch(NullPointerException ex) {\n            ex.printStackTrace();\n            key.interestOps(SelectionKey.OP_READ);\n        }\n    }\n    /*\n        UTILS\n        ====\n     */\n    /**\n     * Add a message to the message queue that will be sent next time\n     * the server is writing to the client.\n     * @param key the client that should be sent the message.\n     * @param message the actual message.\n     */\n    public void pushMessage(SelectionKey key, String message) {\n        User user = getUser(key);\n        user.queueMessage(message);\n    }\n    /**\n     * Adds a message to the message queue and tells the server to send the queue\n     * to the client, given the username.\n     * @param user the username to send the queue.\n     * @param message the actual message.\n     * @return true if the message was sent, otherwise false (invalid user was provided)\n     */\n    public boolean send(User user, String message) {\n        SelectionKey key = user.getKey();\n        pushMessage(key, message);\n        if(key.isValid()) {\n            key.interestOps(SelectionKey.OP_WRITE);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns a list of the currently connected users.\n     * @return Set<String>\n     */\n    public Set<User> getClientList() {\n        return clients.keySet();\n    }\n    /**\n     * Adds a new client to the connected users list.\n     * @param username the username of the client to add.\n     * @param key the key belonging to the client.\n     */\n    public User addUser(String username, SelectionKey key) {\n        User user = new User(key);\n        user.setUsername(username);\n        clients.put(user, key);\n        return user;\n    }\n    /**\n     * Adds a new user when the username is unknown\n     * @param key\n     */\n    public User addUser(SelectionKey key) {\n        User user = new User(key);\n        clients.put(user, key);\n        return user;\n    }\n    /**\n     * Returns the username of a client, given their key.\n     * @param key the key of the client.\n     * @return the username as a String.\n     */\n    public User getUser(SelectionKey key) {\n        if(clients.inverse().containsKey(key)) {\n            return clients.inverse().get(key);\n        }\n        return addUser(key);\n    }\n"]], "pred": {"ppl": 2.435549020767212, "ppl_lower": 2.6375670433044434, "ppl/lowercase_ppl": -1.08951606883697, "ppl/zlib": 0.0004102176044520001, "Min_5.0% Prob": 6.467504763135723, "Min_10.0% Prob": 5.037317374173333, "Min_20.0% Prob": 3.5687926043482388, "Min_30.0% Prob": 2.7191793365416186, "Min_40.0% Prob": 2.151380202152327, "Min_50.0% Prob": 1.7627808145172674, "Min_60.0% Prob": 1.4806490384564897}}
{"hexsha": "f93360b466f28639034a273e529e0062c86b52d3", "ext": "java", "lang": "Java", "content": "public final class OAuthHmacSha256Signer implements OAuthSigner {\n\n  /** Client secret */\n  private final String clientSharedSecret;\n\n  /** Token secret */\n  private String tokenSharedSecret;\n\n  public void setTokenSecret(String tokenSecret) {\n    tokenSharedSecret = tokenSecret;\n  }\n\n  public OAuthHmacSha256Signer(String clientSecret) {\n    this.clientSharedSecret = clientSecret;\n  }\n\n  @Override\n  public String getSignatureMethod() {\n    return \"HMAC-SHA256\";\n  }\n\n  @Override\n  public String computeSignature(String signatureBaseString) throws GeneralSecurityException {\n    // compute key\n    StringBuilder keyBuffer = new StringBuilder();\n    if (clientSharedSecret != null) {\n      keyBuffer.append(OAuthParameters.escape(clientSharedSecret));\n    }\n    keyBuffer.append('&');\n    if (tokenSharedSecret != null) {\n      keyBuffer.append(OAuthParameters.escape(tokenSharedSecret));\n    }\n    String key = keyBuffer.toString();\n    // sign\n    SecretKey secretKey = new SecretKeySpec(StringUtils.getBytesUtf8(key), \"HmacSHA256\");\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(secretKey);\n    return BaseEncoding.base64().encode(mac.doFinal(StringUtils.getBytesUtf8(signatureBaseString)));\n  }\n}", "class_id": 0, "repo": "Celebrate-future/google-oauth-java-client-1", "file": "google-oauth-client/src/main/java/com/google/api/client/auth/oauth/OAuthHmacSha256Signer.java", "last_update_at": "2018-09-04T15:29:09+00:00", "question_id": "f93360b466f28639034a273e529e0062c86b52d3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class OAuthHmacSha256Signer implements OAuthSigner {\n  /** Client secret */\n  private final String clientSharedSecret;\n  /** Token secret */\n  private String tokenSharedSecret;\n  public void setTokenSecret(String tokenSecret) {\n    tokenSharedSecret = tokenSecret;\n  }\n  public OAuthHmacSha256Signer(String clientSecret) {\n    this.clientSharedSecret = clientSecret;\n  }\n  @Override\n  public String getSignatureMethod() {\n    return \"HMAC-SHA256\";\n  }\n  @Override\n  public String computeSignature(String signatureBaseString) throws GeneralSecurityException {\n    // compute key\n    StringBuilder keyBuffer = new StringBuilder();\n    if (clientSharedSecret != null) {\n      keyBuffer.append(OAuthParameters.escape(clientSharedSecret));\n    }\n    keyBuffer.append('&');\n    if (tokenSharedSecret != null) {\n      keyBuffer.append(OAuthParameters.escape(tokenSharedSecret));\n    }\n    String key = keyBuffer.toString();\n    // sign\n    SecretKey secretKey = new SecretKeySpec(StringUtils.getBytesUtf8(key), \"HmacSHA256\");\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(secretKey);\n    return BaseEncoding.base64().encode(mac.doFinal(StringUtils.getBytesUtf8(signatureBaseString)));\n  }\n"]], "pred": {"ppl": 1.626469373703003, "ppl_lower": 2.213080883026123, "ppl/lowercase_ppl": -1.6331550249119513, "ppl/zlib": 0.0009987918627990444, "Min_5.0% Prob": 5.3834114635691925, "Min_10.0% Prob": 3.8292127541133336, "Min_20.0% Prob": 2.2983209150777735, "Min_30.0% Prob": 1.5974525323955813, "Min_40.0% Prob": 1.217357222423692, "Min_50.0% Prob": 0.9741073695450937, "Min_60.0% Prob": 0.8110333280888099}}
{"hexsha": "521919bcfc91f1d5730c79e684eff967bf91c337", "ext": "java", "lang": "Java", "content": "public class Actividad {\n\n    private int numero;\n    private String denominacion;\n    private String descripcion;\n    private Date fechaCreacion;\n    private Date fechaInicio;\n    private Date fechaFin;\n    private Date fechaAnulacion;\n    private Date fechaEsperadaDeCierre;\n    private EstadoActividad estado;\n    private String observaciones;\n    private TipoActividad tipoActividad;\n    private ArrayList<Tarea> tareas;\n\n    public Actividad()\n    {\n        this.estado = new EstadoActividad();\n        this.tipoActividad = new TipoActividad();\n        this.tareas = new ArrayList();\n    }\n    /**\n     * @return the descripcion\n     */\n    public String getDescripcion() {\n        return descripcion;\n    }\n\n    /**\n     * @param descripcion the descripcion to set\n     */\n    public void setDescripcion(String descripcion) {\n        this.descripcion = descripcion;\n    }\n\n    /**\n     * @return the fechaCreacion\n     */\n    public Date getFechaCreacion() {\n        return fechaCreacion;\n    }\n\n    /**\n     * @param fechaCreacion the fechaCreacion to set\n     */\n    public void setFechaCreacion(Date fechaCreacion) {\n        this.fechaCreacion = fechaCreacion;\n    }\n\n    /**\n     * @return the fechaInicio\n     */\n    public Date getFechaInicio() {\n        return fechaInicio;\n    }\n\n    /**\n     * @param fechaInicio the fechaInicio to set\n     */\n    public void setFechaInicio(Date fechaInicio) {\n        this.fechaInicio = fechaInicio;\n    }\n\n    /**\n     * @return the fechaFin\n     */\n    public Date getFechaFin() {\n        return fechaFin;\n    }\n\n    /**\n     * @param fechaFin the fechaFin to set\n     */\n    public void setFechaFin(Date fechaFin) {\n        this.fechaFin = fechaFin;\n    }\n\n    /**\n     * @return the observaciones\n     */\n    public String getObservaciones() {\n        return observaciones;\n    }\n\n    /**\n     * @param observaciones the observaciones to set\n     */\n    public void setObservaciones(String observaciones) {\n        this.observaciones = observaciones;\n    }\n\n    /**\n     * @return the tipoActividad\n     */\n    public TipoActividad getTipoActividad() {\n        return tipoActividad;\n    }\n\n    /**\n     * @param tipoActividad the tipoActividad to set\n     */\n    public void setTipoActividad(TipoActividad tipoActividad) {\n        this.tipoActividad = tipoActividad;\n    }\n\n    /**\n     * @return the numero\n     */\n    public int getNumero() {\n        return numero;\n    }\n\n    /**\n     * @param numero the numero to set\n     */\n    public void setNumero(int numero) {\n        this.numero = numero;\n    }\n\n    /**\n     * @return the denominacion\n     */\n    public String getDenominacion() {\n        return denominacion;\n    }\n\n    /**\n     * @param denominacion the denominacion to set\n     */\n    public void setDenominacion(String denominacion) {\n        this.denominacion = denominacion;\n    }\n\n    /**\n     * @return the estado\n     */\n    public EstadoActividad getEstado() {\n        return estado;\n    }\n\n    /**\n     * @param estado the estado to set\n     */\n    public void setEstado(EstadoActividad estado) {\n        this.estado = estado;\n    }\n\n    /**\n     * M\u00e9todo para calcular como est\u00e1n las actividades (icono)\n     */\n    public String getIcon() {\n        String icon = null;\n        int dias = this.diasDeCumplimiento();\n        if (dias < 0) {\n            icon = \"/resources/icons/accept.png\";\n        }\n        if (dias == 0) {\n            icon = \"/resources/icons/error.png\";\n        }\n        if (dias > 0) {\n            icon = \"/resources/icons/exclamation.png\";\n        }\n        return icon;\n    }\n\n     /**\n     * M\u00e9todo para calcular como est\u00e1n las actividades (descripcion)\n     */\n    public String getDescrip() {\n        String descrip = null;\n        int dias = this.diasDeCumplimiento();\n        if (dias < 0) {\n            descrip = \"Actividad dentro de Cumplimiento\";\n        }\n        if (dias == 0) {\n            descrip = \"En d\u00eda de cumplimiento\";\n        }\n        if (dias > 0) {\n            descrip = \"Actividad fuera de cumplimiento\";\n        }\n        return descrip;\n    }\n\n    public int diasDeCumplimiento() {\n        if (this.getFechaInicio() != null && this.getFechaFin() != null) {\n            return UtilFecha.fechasDiferenciaEnDias(this.getFechaEsperadaDeCierre(), this.getFechaFin());\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @return the fechaEsperadaDeCierre\n     */\n    public Date getFechaEsperadaDeCierre() {\n        return fechaEsperadaDeCierre;\n    }\n\n    /**\n     * @param fechaEsperadaDeCierre the fechaEsperadaDeCierre to set\n     */\n    public void setFechaEsperadaDeCierre(Date fechaEsperadaDeCierre) {\n        this.fechaEsperadaDeCierre = fechaEsperadaDeCierre;\n    }\n\n    /**\n     * @return the tareas\n     */\n    public ArrayList<Tarea> getTareas() {\n        return tareas;\n    }\n\n    /**\n     * @param tareas the tareas to set\n     */\n    public void setTareas(ArrayList<Tarea> tareas) {\n        this.tareas = tareas;\n    }\n\n    /**\n     * @return the fechaAnulacion\n     */\n    public Date getFechaAnulacion() {\n        return fechaAnulacion;\n    }\n\n    /**\n     * @param fechaAnulacion the fechaAnulacion to set\n     */\n    public void setFechaAnulacion(Date fechaAnulacion) {\n        this.fechaAnulacion = fechaAnulacion;\n    }\n\n    /**\n     *  Devuelve true si est\u00e1 Finalizada\n     */\n    public boolean isFinalizada() {\n        if (this.getEstado().getNumero()==5)\n            return true;\n        else\n            return false;\n    }\n\n}", "class_id": 0, "repo": "facundofarias/iBee", "file": "Source/iBeeProject/src/java/ibeeproject/model/actividad/Actividad.java", "last_update_at": "2018-10-28T13:59:00+00:00", "question_id": "521919bcfc91f1d5730c79e684eff967bf91c337", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Actividad {\n    private int numero;\n    private String denominacion;\n    private String descripcion;\n    private Date fechaCreacion;\n    private Date fechaInicio;\n    private Date fechaFin;\n    private Date fechaAnulacion;\n    private Date fechaEsperadaDeCierre;\n    private EstadoActividad estado;\n    private String observaciones;\n    private TipoActividad tipoActividad;\n    private ArrayList<Tarea> tareas;\n    public Actividad()\n    {\n        this.estado = new EstadoActividad();\n        this.tipoActividad = new TipoActividad();\n        this.tareas = new ArrayList();\n    }\n    /**\n     * @return the descripcion\n     */\n    public String getDescripcion() {\n        return descripcion;\n    }\n    /**\n     * @param descripcion the descripcion to set\n     */\n    public void setDescripcion(String descripcion) {\n        this.descripcion = descripcion;\n    }\n    /**\n     * @return the fechaCreacion\n     */\n    public Date getFechaCreacion() {\n        return fechaCreacion;\n    }\n    /**\n     * @param fechaCreacion the fechaCreacion to set\n     */\n    public void setFechaCreacion(Date fechaCreacion) {\n        this.fechaCreacion = fechaCreacion;\n    }\n    /**\n     * @return the fechaInicio\n     */\n    public Date getFechaInicio() {\n        return fechaInicio;\n    }\n    /**\n     * @param fechaInicio the fechaInicio to set\n     */\n    public void setFechaInicio(Date fechaInicio) {\n        this.fechaInicio = fechaInicio;\n    }\n    /**\n     * @return the fechaFin\n     */\n    public Date getFechaFin() {\n        return fechaFin;\n    }\n    /**\n     * @param fechaFin the fechaFin to set\n     */\n    public void setFechaFin(Date fechaFin) {\n        this.fechaFin = fechaFin;\n    }\n    /**\n     * @return the observaciones\n     */\n    public String getObservaciones() {\n        return observaciones;\n    }\n    /**\n     * @param observaciones the observaciones to set\n     */\n    public void setObservaciones(String observaciones) {\n        this.observaciones = observaciones;\n    }\n    /**\n     * @return the tipoActividad\n     */\n    public TipoActividad getTipoActividad() {\n        return tipoActividad;\n    }\n    /**\n     * @param tipoActividad the tipoActividad to set\n     */\n    public void setTipoActividad(TipoActividad tipoActividad) {\n        this.tipoActividad = tipoActividad;\n    }\n    /**\n     * @return the numero\n     */\n    public int getNumero() {\n        return numero;\n    }\n    /**\n     * @param numero the numero to set\n     */\n    public void setNumero(int numero) {\n        this.numero = numero;\n    }\n    /**\n     * @return the denominacion\n     */\n    public String getDenominacion() {\n        return denominacion;\n    }\n    /**\n     * @param denominacion the denominacion to set\n     */\n    public void setDenominacion(String denominacion) {\n        this.denominacion = denominacion;\n    }\n    /**\n     * @return the estado\n     */\n    public EstadoActividad getEstado() {\n        return estado;\n    }\n    /**\n     * @param estado the estado to set\n     */\n    public void setEstado(EstadoActividad estado) {\n        this.estado = estado;\n    }\n    /**\n     * M\u00e9todo para calcular como est\u00e1n las actividades (icono)\n     */\n    public String getIcon() {\n        String icon = null;\n        int dias = this.diasDeCumplimiento();\n        if (dias < 0) {\n            icon = \"/resources/icons/accept.png\";\n        }\n        if (dias == 0) {\n            icon = \"/resources/icons/error.png\";\n        }\n        if (dias > 0) {\n            icon = \"/resources/icons/exclamation.png\";\n        }\n        return icon;\n    }\n     /**\n     * M\u00e9todo para calcular como est\u00e1n las actividades (descripcion)\n     */\n    public String getDescrip() {\n        String descrip = null;\n        int dias = this.diasDeCumplimiento();\n        if (dias < 0) {\n            descrip = \"Actividad dentro de Cumplimiento\";\n        }\n        if (dias == 0) {\n            descrip = \"En d\u00eda de cumplimiento\";\n        }\n        if (dias > 0) {\n            descrip = \"Actividad fuera de cumplimiento\";\n        }\n        return descrip;\n    }\n    public int diasDeCumplimiento() {\n        if (this.getFechaInicio() != null && this.getFechaFin() != null) {\n            return UtilFecha.fechasDiferenciaEnDias(this.getFechaEsperadaDeCierre(), this.getFechaFin());\n        } else {\n            return 0;\n        }\n    }\n    /**\n     * @return the fechaEsperadaDeCierre\n     */\n    public Date getFechaEsperadaDeCierre() {\n        return fechaEsperadaDeCierre;\n    }\n    /**\n     * @param fechaEsperadaDeCierre the fechaEsperadaDeCierre to set\n     */\n    public void setFechaEsperadaDeCierre(Date fechaEsperadaDeCierre) {\n        this.fechaEsperadaDeCierre = fechaEsperadaDeCierre;\n    }\n    /**\n     * @return the tareas\n     */\n    public ArrayList<Tarea> getTareas() {\n        return tareas;\n    }\n    /**\n     * @param tareas the tareas to set\n     */\n    public void setTareas(ArrayList<Tarea> tareas) {\n        this.tareas = tareas;\n    }\n    /**\n     * @return the fechaAnulacion\n     */\n    public Date getFechaAnulacion() {\n        return fechaAnulacion;\n    }\n    /**\n     * @param fechaAnulacion the fechaAnulacion to set\n     */\n    public void setFechaAnulacion(Date fechaAnulacion) {\n        this.fechaAnulacion = fechaAnulacion;\n    }\n    /**\n     *  Devuelve true si est\u00e1 Finalizada\n     */\n    public boolean isFinalizada() {\n        if (this.getEstado().getNumero()==5)\n            return true;\n        else\n            return false;\n    }\n"]], "pred": {"ppl": 1.293216347694397, "ppl_lower": 1.3401572704315186, "ppl/lowercase_ppl": -1.1386622762799896, "ppl/zlib": 0.0002446550029137577, "Min_5.0% Prob": 4.177009283327589, "Min_10.0% Prob": 2.4810444759387598, "Min_20.0% Prob": 1.285220108045192, "Min_30.0% Prob": 0.8588889780259551, "Min_40.0% Prob": 0.6429130109146575, "Min_50.0% Prob": 0.5146856351027451, "Min_60.0% Prob": 0.4290822084077659}}
{"hexsha": "c6a08d4506d7ebc848c69ed35ec4d8bff5bec70b", "ext": "java", "lang": "Java", "content": "public class SQLScriptGenerator {\n \n    public static void main(String[] args) throws MappingException, IOException {\n    \t\n    \tString createSQLFile = \"dbscripts/createTables.sql\";\n    \tString dropSQLFile = \"dbscripts/dropTables.sql\";\n    \tString hibernateCfgFile = \"/db/hibernate.cfg.xml\";\n    \t\n    \tfinal EnumSet<TargetType> targetTypes = EnumSet.noneOf( TargetType.class );\n\t\ttargetTypes.add(TargetType.SCRIPT);\n    \t\n\t\tSystem.out.println(\"Initialize Hibernate configuration from \" + hibernateCfgFile );\n\t\t\n    \tConfiguration cfg = new Configuration().configure(hibernateCfgFile);\n    \tMetadata metadata = MetadataHelper.getMetadata(cfg);\n    \t\n    \tSchemaExport export = new SchemaExport();\n\t\texport.setHaltOnError(true);\n\t\texport.setFormat(true);\n\t\texport.setDelimiter(\";\");\n\t\t\n\t\tSystem.out.println(\"Generating create SQL to file \" + createSQLFile );\n\t\tif ( new File(createSQLFile).exists() ) {\n\t\t\tFiles.delete(Paths.get(createSQLFile));\n\t\t}\n\t\texport.setOutputFile(createSQLFile);\n\t\texport.execute(targetTypes, Action.CREATE, metadata);\n\t\t\n\t\tSystem.out.println(\"Generating drop SQL to file \" + dropSQLFile );\n\t\texport.setOutputFile(dropSQLFile);\n\t\tif ( new File(dropSQLFile).exists() ) {\n\t\t\tFiles.delete(Paths.get(dropSQLFile));\n\t\t}\n\t\texport.execute(targetTypes, Action.DROP, metadata);\n\n\t\tSystem.out.println(\"Done!\");\n\t}\n}", "class_id": 0, "repo": "1and1/sia-be", "file": "src/main/java/com/oneandone/relesia/tools/SQLScriptGenerator.java", "last_update_at": "2018-02-25T15:54:08+00:00", "question_id": "c6a08d4506d7ebc848c69ed35ec4d8bff5bec70b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SQLScriptGenerator {\n    public static void main(String[] args) throws MappingException, IOException {\n    \t\n    \tString createSQLFile = \"dbscripts/createTables.sql\";\n    \tString dropSQLFile = \"dbscripts/dropTables.sql\";\n    \tString hibernateCfgFile = \"/db/hibernate.cfg.xml\";\n    \t\n    \tfinal EnumSet<TargetType> targetTypes = EnumSet.noneOf( TargetType.class );\n\t\ttargetTypes.add(TargetType.SCRIPT);\n    \t\n\t\tSystem.out.println(\"Initialize Hibernate configuration from \" + hibernateCfgFile );\n\t\t\n    \tConfiguration cfg = new Configuration().configure(hibernateCfgFile);\n    \tMetadata metadata = MetadataHelper.getMetadata(cfg);\n    \t\n    \tSchemaExport export = new SchemaExport();\n\t\texport.setHaltOnError(true);\n\t\texport.setFormat(true);\n\t\texport.setDelimiter(\";\");\n\t\t\n\t\tSystem.out.println(\"Generating create SQL to file \" + createSQLFile );\n\t\tif ( new File(createSQLFile).exists() ) {\n\t\t\tFiles.delete(Paths.get(createSQLFile));\n\t\t}\n\t\texport.setOutputFile(createSQLFile);\n\t\texport.execute(targetTypes, Action.CREATE, metadata);\n\t\t\n\t\tSystem.out.println(\"Generating drop SQL to file \" + dropSQLFile );\n\t\texport.setOutputFile(dropSQLFile);\n\t\tif ( new File(dropSQLFile).exists() ) {\n\t\t\tFiles.delete(Paths.get(dropSQLFile));\n\t\t}\n\t\texport.execute(targetTypes, Action.DROP, metadata);\n\t\tSystem.out.println(\"Done!\");\n\t}\n"]], "pred": {"ppl": 1.9566364288330078, "ppl_lower": 2.4736480712890625, "ppl/lowercase_ppl": -1.3493112756521157, "ppl/zlib": 0.0012569791971993411, "Min_5.0% Prob": 6.183075178237188, "Min_10.0% Prob": 4.717110883357913, "Min_20.0% Prob": 3.0227638247401214, "Min_30.0% Prob": 2.1631065473075983, "Min_40.0% Prob": 1.659609031841852, "Min_50.0% Prob": 1.3365523700190838, "Min_60.0% Prob": 1.117077648119871}}
{"hexsha": "0fdf7a1862ae973464c4f5efa105e754538dda10", "ext": "java", "lang": "Java", "content": "class EnsnaringBridgeRestrictionEffect extends RestrictionEffect {\n\n    public EnsnaringBridgeRestrictionEffect() {\n        super(Duration.WhileOnBattlefield);\n        this.staticText = \"Creatures with power greater than the number of cards in your hand can't attack\";\n    }\n\n    public EnsnaringBridgeRestrictionEffect(final EnsnaringBridgeRestrictionEffect effect) {\n        super(effect);\n    }\n\n    @Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller == null) {\n            return false;\n        }\n        return controller.getInRange().contains(permanent.getControllerId())\n                && permanent.getPower().getValue() > controller.getHand().size();\n    }\n\n    @Override\n    public boolean canAttack(Game game) {\n        return false;\n    }\n\n    @Override\n    public EnsnaringBridgeRestrictionEffect copy() {\n        return new EnsnaringBridgeRestrictionEffect(this);\n    }\n\n}", "class_id": 0, "repo": "FateRevoked/mage", "file": "Mage.Sets/src/mage/cards/e/EnsnaringBridge.java", "last_update_at": "2018-09-11T23:42:18+00:00", "question_id": "0fdf7a1862ae973464c4f5efa105e754538dda10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class EnsnaringBridgeRestrictionEffect extends RestrictionEffect {\n    public EnsnaringBridgeRestrictionEffect() {\n        super(Duration.WhileOnBattlefield);\n        this.staticText = \"Creatures with power greater than the number of cards in your hand can't attack\";\n    }\n    public EnsnaringBridgeRestrictionEffect(final EnsnaringBridgeRestrictionEffect effect) {\n        super(effect);\n    }\n    @Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller == null) {\n            return false;\n        }\n        return controller.getInRange().contains(permanent.getControllerId())\n                && permanent.getPower().getValue() > controller.getHand().size();\n    }\n    @Override\n    public boolean canAttack(Game game) {\n        return false;\n    }\n    @Override\n    public EnsnaringBridgeRestrictionEffect copy() {\n        return new EnsnaringBridgeRestrictionEffect(this);\n    }\n"]], "pred": {"ppl": 1.6369800567626953, "ppl_lower": 2.4011714458465576, "ppl/lowercase_ppl": -1.777318014485806, "ppl/zlib": 0.0012572783559148793, "Min_5.0% Prob": 6.830572385054368, "Min_10.0% Prob": 4.497332453727722, "Min_20.0% Prob": 2.4522503104131177, "Min_30.0% Prob": 1.6558042281554848, "Min_40.0% Prob": 1.2361581813179414, "Min_50.0% Prob": 0.9855678259606011, "Min_60.0% Prob": 0.8244901587992596}}
{"hexsha": "aeb8f8201b5c96d0363084c676a697b697cf63a9", "ext": "java", "lang": "Java", "content": "public class SpringValueRegistry {\n\n  private final Map<BeanFactory, Multimap<String, SpringValue>> registry = Maps.newConcurrentMap();\n  private final Object LOCK = new Object();\n\n  public void register(BeanFactory beanFactory, String key, SpringValue springValue) {\n    if (!registry.containsKey(beanFactory)) {\n      synchronized (LOCK) {\n        if (!registry.containsKey(beanFactory)) {\n          registry.put(beanFactory, LinkedListMultimap.<String, SpringValue>create());\n        }\n      }\n    }\n\n    registry.get(beanFactory).put(key, springValue);\n  }\n\n  public Collection<SpringValue> get(BeanFactory beanFactory, String key) {\n    Multimap<String, SpringValue> beanFactorySpringValues = registry.get(beanFactory);\n    if (beanFactorySpringValues == null) {\n      return null;\n    }\n    return beanFactorySpringValues.get(key);\n  }\n}", "class_id": 0, "repo": "jieqian/apollo", "file": "apollo-client/src/main/java/com/ctrip/framework/apollo/spring/property/SpringValueRegistry.java", "last_update_at": "2018-12-18T15:34:55+00:00", "question_id": "aeb8f8201b5c96d0363084c676a697b697cf63a9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SpringValueRegistry {\n  private final Map<BeanFactory, Multimap<String, SpringValue>> registry = Maps.newConcurrentMap();\n  private final Object LOCK = new Object();\n  public void register(BeanFactory beanFactory, String key, SpringValue springValue) {\n    if (!registry.containsKey(beanFactory)) {\n      synchronized (LOCK) {\n        if (!registry.containsKey(beanFactory)) {\n          registry.put(beanFactory, LinkedListMultimap.<String, SpringValue>create());\n        }\n      }\n    }\n    registry.get(beanFactory).put(key, springValue);\n  }\n  public Collection<SpringValue> get(BeanFactory beanFactory, String key) {\n    Multimap<String, SpringValue> beanFactorySpringValues = registry.get(beanFactory);\n    if (beanFactorySpringValues == null) {\n      return null;\n    }\n    return beanFactorySpringValues.get(key);\n  }\n"]], "pred": {"ppl": 1.5590673685073853, "ppl_lower": 1.8785576820373535, "ppl/lowercase_ppl": -1.4197739488981986, "ppl/zlib": 0.0013748848352416183, "Min_5.0% Prob": 5.362562136216597, "Min_10.0% Prob": 3.4620726730512534, "Min_20.0% Prob": 2.0908086772846137, "Min_30.0% Prob": 1.4644807752059854, "Min_40.0% Prob": 1.1068535873605667, "Min_50.0% Prob": 0.8871216037189184, "Min_60.0% Prob": 0.7397746372752}}
{"hexsha": "7fc140b301f04866aab66f46ae0706d16d269125", "ext": "java", "lang": "Java", "content": "@Entity(name = \"event\")\npublic class EventEntity {\n    @Id\n    @GeneratedValue(strategy = IDENTITY)\n    private Integer eventId;\n\n    @NotNull\n    @Size(max = 100)\n    private String name;\n\n    @NotNull\n    @Size(max = 100)\n    private String location;\n\n    @NotNull\n    private LocalDate startDate;\n\n    @NotNull\n    private LocalDate endDate;\n\n    @NotNull\n    @Enumerated(EnumType.STRING)\n    private EventStatus eventStatus;\n\n    private boolean current;\n\n    @Column(updatable = false)\n    private Integer createdByUserId;\n\n    @Column(updatable = false)\n    private Instant createdDateTime;\n\n    private Integer updatedByUserId;\n    private Instant updatedDateTime;\n\n    @PrePersist\n    private void prePersist() {\n        createdDateTime = Instant.now();\n        updatedDateTime = Instant.now();\n        createdByUserId = SecurityContext.extractUserId();\n        updatedByUserId = SecurityContext.extractUserId();\n    }\n\n    @PreUpdate\n    private void preUpdate() {\n        updatedDateTime = Instant.now();\n        updatedByUserId = SecurityContext.extractUserId();\n    }\n\n    public Integer getEventId() {\n        return eventId;\n    }\n\n    public void setEventId(Integer eventId) {\n        this.eventId = eventId;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n\n    public void setLocation(String location) {\n        this.location = location;\n    }\n\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n\n    public void setStartDate(LocalDate startDate) {\n        this.startDate = startDate;\n    }\n\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n\n    public void setEndDate(LocalDate endDate) {\n        this.endDate = endDate;\n    }\n\n    public EventStatus getEventStatus() {\n        return eventStatus;\n    }\n\n    public void setEventStatus(EventStatus eventStatus) {\n        this.eventStatus = eventStatus;\n    }\n\n    /**\n     * @return indicate this is the current event, so will be used for the default view or sub-data, such as teams.\n     * The application is responsible for ensuring we have one current event.\n     */\n    public boolean isCurrent() {\n        return current;\n    }\n\n    public void setCurrent(boolean current) {\n        this.current = current;\n    }\n\n    public Integer getCreatedByUserId() {\n        return createdByUserId;\n    }\n\n    public void setCreatedByUserId(Integer createdByUserId) {\n        this.createdByUserId = createdByUserId;\n    }\n\n    public Instant getCreatedDateTime() {\n        return createdDateTime;\n    }\n\n    public void setCreatedDateTime(Instant createdDateTime) {\n        this.createdDateTime = createdDateTime;\n    }\n\n    public Integer getUpdatedByUserId() {\n        return updatedByUserId;\n    }\n\n    public void setUpdatedByUserId(Integer updatedByUserId) {\n        this.updatedByUserId = updatedByUserId;\n    }\n\n    public Instant getUpdatedDateTime() {\n        return updatedDateTime;\n    }\n\n    public void setUpdatedDateTime(Instant updatedDateTime) {\n        this.updatedDateTime = updatedDateTime;\n    }\n\n}", "class_id": 0, "repo": "alfonsobonso/attendantsoffice", "file": "src/main/java/org/attendantsoffice/eventmanager/event/EventEntity.java", "last_update_at": "2018-08-15T17:38:39+00:00", "question_id": "7fc140b301f04866aab66f46ae0706d16d269125", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Entity(name = \"event\")\npublic class EventEntity {\n    @Id\n    @GeneratedValue(strategy = IDENTITY)\n    private Integer eventId;\n    @NotNull\n    @Size(max = 100)\n    private String name;\n    @NotNull\n    @Size(max = 100)\n    private String location;\n    @NotNull\n    private LocalDate startDate;\n    @NotNull\n    private LocalDate endDate;\n    @NotNull\n    @Enumerated(EnumType.STRING)\n    private EventStatus eventStatus;\n    private boolean current;\n    @Column(updatable = false)\n    private Integer createdByUserId;\n    @Column(updatable = false)\n    private Instant createdDateTime;\n    private Integer updatedByUserId;\n    private Instant updatedDateTime;\n    @PrePersist\n    private void prePersist() {\n        createdDateTime = Instant.now();\n        updatedDateTime = Instant.now();\n        createdByUserId = SecurityContext.extractUserId();\n        updatedByUserId = SecurityContext.extractUserId();\n    }\n    @PreUpdate\n    private void preUpdate() {\n        updatedDateTime = Instant.now();\n        updatedByUserId = SecurityContext.extractUserId();\n    }\n    public Integer getEventId() {\n        return eventId;\n    }\n    public void setEventId(Integer eventId) {\n        this.eventId = eventId;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getLocation() {\n        return location;\n    }\n    public void setLocation(String location) {\n        this.location = location;\n    }\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n    public void setStartDate(LocalDate startDate) {\n        this.startDate = startDate;\n    }\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n    public void setEndDate(LocalDate endDate) {\n        this.endDate = endDate;\n    }\n    public EventStatus getEventStatus() {\n        return eventStatus;\n    }\n    public void setEventStatus(EventStatus eventStatus) {\n        this.eventStatus = eventStatus;\n    }\n    /**\n     * @return indicate this is the current event, so will be used for the default view or sub-data, such as teams.\n     * The application is responsible for ensuring we have one current event.\n     */\n    public boolean isCurrent() {\n        return current;\n    }\n    public void setCurrent(boolean current) {\n        this.current = current;\n    }\n    public Integer getCreatedByUserId() {\n        return createdByUserId;\n    }\n    public void setCreatedByUserId(Integer createdByUserId) {\n        this.createdByUserId = createdByUserId;\n    }\n    public Instant getCreatedDateTime() {\n        return createdDateTime;\n    }\n    public void setCreatedDateTime(Instant createdDateTime) {\n        this.createdDateTime = createdDateTime;\n    }\n    public Integer getUpdatedByUserId() {\n        return updatedByUserId;\n    }\n    public void setUpdatedByUserId(Integer updatedByUserId) {\n        this.updatedByUserId = updatedByUserId;\n    }\n    public Instant getUpdatedDateTime() {\n        return updatedDateTime;\n    }\n    public void setUpdatedDateTime(Instant updatedDateTime) {\n        this.updatedDateTime = updatedDateTime;\n    }\n"]], "pred": {"ppl": 1.3729722499847412, "ppl_lower": 1.497298240661621, "ppl/lowercase_ppl": -1.2734714047903695, "ppl/zlib": 0.0004154363241863123, "Min_5.0% Prob": 4.455028756098314, "Min_10.0% Prob": 2.9249606875891097, "Min_20.0% Prob": 1.576539023789797, "Min_30.0% Prob": 1.055655163135519, "Min_40.0% Prob": 0.7922284740274785, "Min_50.0% Prob": 0.6338923717542876, "Min_60.0% Prob": 0.5282768438013632}}
{"hexsha": "ac04333552423583d19e2ad39e3d2497b4036642", "ext": "java", "lang": "Java", "content": "public class LoanerDescription {\n    private final Name itemName;\n    private final Name loanerName;\n    private final Quantity quantity;\n\n    public LoanerDescription(Name itemName, Name loanerName, Quantity quantity) {\n        requireAllNonNull(itemName, loanerName, quantity);\n        this.itemName = itemName;\n        this.loanerName = loanerName;\n        this.quantity = quantity;\n    }\n    public LoanerDescription(LoanerDescription loaner) {\n        itemName = loaner.getItemName();\n        loanerName = loaner.getLoanerName();\n        quantity = loaner.getQuantity();\n    }\n    public Name getItemName() {\n        return itemName;\n    }\n\n    public Quantity getQuantity() {\n        return quantity;\n    }\n    public Name getLoanerName() {\n        return loanerName;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(getLoanerName())\n                .append(\" loanerName: \")\n                .append(getLoanerName())\n                .append(\" itemName: \")\n                .append(getItemName())\n                .append(\" Quantity: \")\n                .append(getQuantity());\n        return builder.toString();\n    }\n}", "class_id": 0, "repo": "ChewKinWhye/JalilEnterprisesCKW", "file": "src/main/java/seedu/address/model/item/LoanerDescription.java", "last_update_at": "2018-11-12T13:39:36+00:00", "question_id": "ac04333552423583d19e2ad39e3d2497b4036642", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoanerDescription {\n    private final Name itemName;\n    private final Name loanerName;\n    private final Quantity quantity;\n    public LoanerDescription(Name itemName, Name loanerName, Quantity quantity) {\n        requireAllNonNull(itemName, loanerName, quantity);\n        this.itemName = itemName;\n        this.loanerName = loanerName;\n        this.quantity = quantity;\n    }\n    public LoanerDescription(LoanerDescription loaner) {\n        itemName = loaner.getItemName();\n        loanerName = loaner.getLoanerName();\n        quantity = loaner.getQuantity();\n    }\n    public Name getItemName() {\n        return itemName;\n    }\n    public Quantity getQuantity() {\n        return quantity;\n    }\n    public Name getLoanerName() {\n        return loanerName;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(getLoanerName())\n                .append(\" loanerName: \")\n                .append(getLoanerName())\n                .append(\" itemName: \")\n                .append(getItemName())\n                .append(\" Quantity: \")\n                .append(getQuantity());\n        return builder.toString();\n    }\n"]], "pred": {"ppl": 1.5231810808181763, "ppl_lower": 1.7639362812042236, "ppl/lowercase_ppl": -1.3487322590021553, "ppl/zlib": 0.001282929769196592, "Min_5.0% Prob": 5.653421700000763, "Min_10.0% Prob": 3.6715162433683872, "Min_20.0% Prob": 2.0802856227383018, "Min_30.0% Prob": 1.4015868488543977, "Min_40.0% Prob": 1.0554977738720481, "Min_50.0% Prob": 0.8405567445555089, "Min_60.0% Prob": 0.7016263868384681}}
{"hexsha": "bd539f36c9f25f31c634e11d50b7b43ef3305bed", "ext": "java", "lang": "Java", "content": "@Component\npublic class DHIS2SyncerListener {\n\t\n\tprivate final ClientService clientService;\n\t\n\t@Autowired\n\tprivate AllDHIS2Marker allDHIS2Marker;\n\t\n\t@Autowired\n\tprivate Dhis2TrackCaptureConnector dhis2TrackCaptureConnector;\n\t\n\t@Autowired\n\tprivate DHIS2TrackerService dhis2TrackerService;\n\t\n\tprivate DHIS2Tracker dhis2Tracker;\n\t\n\t@Autowired\n\tprivate EventService eventService;\n\t\n\t@Autowired\n\tpublic VaccinationTracker vaccinationTracker;\n\t\n\t@Autowired\n\tpublic DHIS2SyncerListener(ClientService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\t\n\tpublic JSONObject pushToDHIS2() {\n\t\tJSONObject response = null;\n\t\ttry {\n\t\t\tLong start = 0l;\n\t\t\tLong eventStart = 0l;\n\t\t\tList<DHIS2Marker> clientSync = allDHIS2Marker.findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER);\n\t\t\tList<DHIS2Marker> eventSync = allDHIS2Marker\n\t\t\t        .findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER_EVENT);\n\t\t\tif (clientSync.size() == 0) {\n\t\t\t\tallDHIS2Marker.add();\n\t\t\t\tstart = 0l;\n\t\t\t} else {\n\t\t\t\tstart = clientSync == null || clientSync.get(0).getValue() == null ? 0 : clientSync.get(0).getValue();\n\t\t\t}\n\t\t\tSystem.err.println(\"start:\" + start);\n\t\t\tList<Client> cl = clientService.findByServerVersion(start);\n\t\t\tif (eventSync.size() == 0) {\n\t\t\t\tallDHIS2Marker.addEventMarker();\n\t\t\t\teventStart = 0l;\n\t\t\t} else {\n\t\t\t\teventStart = eventSync == null || eventSync.get(0).getValue() == null ? 0 : eventSync.get(0).getValue();\n\t\t\t}\n\t\t\tList<Event> events = eventService.findByServerVersion(eventStart);\n\t\t\tfor (Client c : cl) {\n\t\t\t\tSystem.err.println(\"Name:\" + c.fullName());\n\t\t\t\ttry {\n\t\t\t\t\tresponse = processTrackerAndSendToDHIS2(c);\n\t\t\t\t\tallDHIS2Marker.update(c.getServerVersion());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprocessAndSendVaccineTrackerToDHIS2(events);\n\t\t\t\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn response;\n\t}\n\t\n\tprivate JSONObject processAndSendVaccineTrackerToDHIS2(List<Event> events) throws JSONException {\n\t\tvaccinationTracker.getTrackCaptureDataAndSend(events);\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate JSONObject processTrackerAndSendToDHIS2(Client client) throws JSONException {\n\t\t\n\t\tdhis2Tracker = dhis2TrackerService.getTrackerType(client);\n\t\tJSONArray clientData = dhis2Tracker.getTrackCaptureData(client);\n\t\treturn dhis2Tracker.sendTrackCaptureData(clientData);\n\t\t\n\t}\n\t\n\tpublic JSONObject sentTrackCaptureDataToDHIS2(Client client) throws JSONException {\n\t\t\n\t\tJSONObject clientData = new JSONObject();\n\t\tJSONArray clientAttribute = new JSONArray();\n\t\t\n\t\tJSONObject fullName = new JSONObject();\n\t\tfullName.put(\"attribute\", \"pzuh7zrs9Xx\");\n\t\tfullName.put(\"value\", client.fullName());\n\t\tclientAttribute.put(fullName);\n\t\t\n\t\tJSONObject gender = new JSONObject();\n\t\tgender.put(\"attribute\", \"xDvyz0ezL4e\");\n\t\tgender.put(\"value\", client.getGender());\n\t\tclientAttribute.put(gender);\n\t\tif (client.getAttributes().containsKey(\"Father_NRC_Number\")) {\n\t\t\tJSONObject Father_NRC_Number = new JSONObject();\n\t\t\tFather_NRC_Number.put(\"attribute\", \"UpMkVyXSk4b\");\n\t\t\tFather_NRC_Number.put(\"value\", client.getAttributes().get(\"Father_NRC_Number\"));\n\t\t\tclientAttribute.put(Father_NRC_Number);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"Child_Register_Card_Number\")) {\n\t\t\tJSONObject Child_Register_Card_Number = new JSONObject();\n\t\t\tChild_Register_Card_Number.put(\"attribute\", \"P5Ew7lka7GR\");\n\t\t\tChild_Register_Card_Number.put(\"value\", client.getAttributes().get(\"Child_Register_Card_Number\"));\n\t\t\tclientAttribute.put(Child_Register_Card_Number);\n\t\t}\n\t\tif (client.getAttributes().containsKey(\"CHW_Phone_Number\")) {\n\t\t\tJSONObject CHW_Phone_Number = new JSONObject();\n\t\t\tCHW_Phone_Number.put(\"attribute\", \"wCom53wUTKf\");\n\t\t\tCHW_Phone_Number.put(\"value\", client.getAttributes().get(\"CHW_Phone_Number\"));\n\t\t\tclientAttribute.put(CHW_Phone_Number);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"CHW_Name\")) {\n\t\t\tJSONObject CHW_Name = new JSONObject();\n\t\t\tCHW_Name.put(\"attribute\", \"t2C80PnQfJH\");\n\t\t\tCHW_Name.put(\"value\", client.getAttributes().get(\"CHW_Name\"));\n\t\t\tclientAttribute.put(CHW_Name);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"Child_Birth_Certificate\")) {\n\t\t\tJSONObject Child_Birth_Certificate = new JSONObject();\n\t\t\tChild_Birth_Certificate.put(\"attribute\", \"ZDWzVhjlgWK\");\n\t\t\tChild_Birth_Certificate.put(\"value\", client.getAttributes().get(\"Child_Birth_Certificate\"));\n\t\t\tclientAttribute.put(Child_Birth_Certificate);\n\t\t}\n\t\t\n\t\t/////////////////////\n\t\tJSONArray enrollments = new JSONArray();\n\t\tJSONObject enrollmentsObj = new JSONObject();\n\t\tenrollmentsObj.put(\"orgUnit\", \"IDc0HEyjhvL\");\n\t\tenrollmentsObj.put(\"program\", \"OprRhyWVIM6\");\n\t\tenrollmentsObj.put(\"enrollmentDate\", DateUtil.getTodayAsString());\n\t\tenrollmentsObj.put(\"incidentDate\", DateUtil.getTodayAsString());\n\t\tenrollments.put(enrollmentsObj);\n\t\t\n\t\tclientData.put(\"attributes\", clientAttribute);\n\t\tclientData.put(\"trackedEntity\", \"MCPQUTHX1Ze\");\n\t\tclientData.put(\"orgUnit\", \"IDc0HEyjhvL\");\n\t\t\n\t\treturn dhis2TrackCaptureConnector.trackCaptureDataSendToDHIS2(clientData);\n\t}\n}", "class_id": 0, "repo": "fazries/opensrp-server", "file": "opensrp-connector/src/main/java/org/opensrp/connector/dhis2/DHIS2SyncerListener.java", "last_update_at": "2018-11-03T20:01:39+00:00", "question_id": "bd539f36c9f25f31c634e11d50b7b43ef3305bed", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class DHIS2SyncerListener {\n\t\n\tprivate final ClientService clientService;\n\t\n\t@Autowired\n\tprivate AllDHIS2Marker allDHIS2Marker;\n\t\n\t@Autowired\n\tprivate Dhis2TrackCaptureConnector dhis2TrackCaptureConnector;\n\t\n\t@Autowired\n\tprivate DHIS2TrackerService dhis2TrackerService;\n\t\n\tprivate DHIS2Tracker dhis2Tracker;\n\t\n\t@Autowired\n\tprivate EventService eventService;\n\t\n\t@Autowired\n\tpublic VaccinationTracker vaccinationTracker;\n\t\n\t@Autowired\n\tpublic DHIS2SyncerListener(ClientService clientService) {\n\t\tthis.clientService = clientService;\n\t}\n\t\n\tpublic JSONObject pushToDHIS2() {\n\t\tJSONObject response = null;\n\t\ttry {\n\t\t\tLong start = 0l;\n\t\t\tLong eventStart = 0l;\n\t\t\tList<DHIS2Marker> clientSync = allDHIS2Marker.findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER);\n\t\t\tList<DHIS2Marker> eventSync = allDHIS2Marker\n\t\t\t        .findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER_EVENT);\n\t\t\tif (clientSync.size() == 0) {\n\t\t\t\tallDHIS2Marker.add();\n\t\t\t\tstart = 0l;\n\t\t\t} else {\n\t\t\t\tstart = clientSync == null || clientSync.get(0).getValue() == null ? 0 : clientSync.get(0).getValue();\n\t\t\t}\n\t\t\tSystem.err.println(\"start:\" + start);\n\t\t\tList<Client> cl = clientService.findByServerVersion(start);\n\t\t\tif (eventSync.size() == 0) {\n\t\t\t\tallDHIS2Marker.addEventMarker();\n\t\t\t\teventStart = 0l;\n\t\t\t} else {\n\t\t\t\teventStart = eventSync == null || eventSync.get(0).getValue() == null ? 0 : eventSync.get(0).getValue();\n\t\t\t}\n\t\t\tList<Event> events = eventService.findByServerVersion(eventStart);\n\t\t\tfor (Client c : cl) {\n\t\t\t\tSystem.err.println(\"Name:\" + c.fullName());\n\t\t\t\ttry {\n\t\t\t\t\tresponse = processTrackerAndSendToDHIS2(c);\n\t\t\t\t\tallDHIS2Marker.update(c.getServerVersion());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprocessAndSendVaccineTrackerToDHIS2(events);\n\t\t\t\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn response;\n\t}\n\t\n\tprivate JSONObject processAndSendVaccineTrackerToDHIS2(List<Event> events) throws JSONException {\n\t\tvaccinationTracker.getTrackCaptureDataAndSend(events);\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate JSONObject processTrackerAndSendToDHIS2(Client client) throws JSONException {\n\t\t\n\t\tdhis2Tracker = dhis2TrackerService.getTrackerType(client);\n\t\tJSONArray clientData = dhis2Tracker.getTrackCaptureData(client);\n\t\treturn dhis2Tracker.sendTrackCaptureData(clientData);\n\t\t\n\t}\n\t\n\tpublic JSONObject sentTrackCaptureDataToDHIS2(Client client) throws JSONException {\n\t\t\n\t\tJSONObject clientData = new JSONObject();\n\t\tJSONArray clientAttribute = new JSONArray();\n\t\t\n\t\tJSONObject fullName = new JSONObject();\n\t\tfullName.put(\"attribute\", \"pzuh7zrs9Xx\");\n\t\tfullName.put(\"value\", client.fullName());\n\t\tclientAttribute.put(fullName);\n\t\t\n\t\tJSONObject gender = new JSONObject();\n\t\tgender.put(\"attribute\", \"xDvyz0ezL4e\");\n\t\tgender.put(\"value\", client.getGender());\n\t\tclientAttribute.put(gender);\n\t\tif (client.getAttributes().containsKey(\"Father_NRC_Number\")) {\n\t\t\tJSONObject Father_NRC_Number = new JSONObject();\n\t\t\tFather_NRC_Number.put(\"attribute\", \"UpMkVyXSk4b\");\n\t\t\tFather_NRC_Number.put(\"value\", client.getAttributes().get(\"Father_NRC_Number\"));\n\t\t\tclientAttribute.put(Father_NRC_Number);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"Child_Register_Card_Number\")) {\n\t\t\tJSONObject Child_Register_Card_Number = new JSONObject();\n\t\t\tChild_Register_Card_Number.put(\"attribute\", \"P5Ew7lka7GR\");\n\t\t\tChild_Register_Card_Number.put(\"value\", client.getAttributes().get(\"Child_Register_Card_Number\"));\n\t\t\tclientAttribute.put(Child_Register_Card_Number);\n\t\t}\n\t\tif (client.getAttributes().containsKey(\"CHW_Phone_Number\")) {\n\t\t\tJSONObject CHW_Phone_Number = new JSONObject();\n\t\t\tCHW_Phone_Number.put(\"attribute\", \"wCom53wUTKf\");\n\t\t\tCHW_Phone_Number.put(\"value\", client.getAttributes().get(\"CHW_Phone_Number\"));\n\t\t\tclientAttribute.put(CHW_Phone_Number);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"CHW_Name\")) {\n\t\t\tJSONObject CHW_Name = new JSONObject();\n\t\t\tCHW_Name.put(\"attribute\", \"t2C80PnQfJH\");\n\t\t\tCHW_Name.put(\"value\", client.getAttributes().get(\"CHW_Name\"));\n\t\t\tclientAttribute.put(CHW_Name);\n\t\t}\n\t\t\n\t\tif (client.getAttributes().containsKey(\"Child_Birth_Certificate\")) {\n\t\t\tJSONObject Child_Birth_Certificate = new JSONObject();\n\t\t\tChild_Birth_Certificate.put(\"attribute\", \"ZDWzVhjlgWK\");\n\t\t\tChild_Birth_Certificate.put(\"value\", client.getAttributes().get(\"Child_Birth_Certificate\"));\n\t\t\tclientAttribute.put(Child_Birth_Certificate);\n\t\t}\n\t\t\n\t\t/////////////////////\n\t\tJSONArray enrollments = new JSONArray();\n\t\tJSONObject enrollmentsObj = new JSONObject();\n\t\tenrollmentsObj.put(\"orgUnit\", \"IDc0HEyjhvL\");\n\t\tenrollmentsObj.put(\"program\", \"OprRhyWVIM6\");\n\t\tenrollmentsObj.put(\"enrollmentDate\", DateUtil.getTodayAsString());\n\t\tenrollmentsObj.put(\"incidentDate\", DateUtil.getTodayAsString());\n\t\tenrollments.put(enrollmentsObj);\n\t\t\n\t\tclientData.put(\"attributes\", clientAttribute);\n\t\tclientData.put(\"trackedEntity\", \"MCPQUTHX1Ze\");\n\t\tclientData.put(\"orgUnit\", \"IDc0HEyjhvL\");\n\t\t\n\t\treturn dhis2TrackCaptureConnector.trackCaptureDataSendToDHIS2(clientData);\n\t}\n"]], "pred": {"ppl": 1.9395427703857422, "ppl_lower": 2.2054600715637207, "ppl/lowercase_ppl": -1.193951902971424, "ppl/zlib": 0.0005080155367552926, "Min_5.0% Prob": 6.561790139067407, "Min_10.0% Prob": 4.804522727050033, "Min_20.0% Prob": 3.05788208777998, "Min_30.0% Prob": 2.1636243279950294, "Min_40.0% Prob": 1.646624874432906, "Min_50.0% Prob": 1.3234651459439306, "Min_60.0% Prob": 1.1046879478824456}}
{"hexsha": "0d44edcb72c42ca000ce8bd7abf696c6737cac4d", "ext": "java", "lang": "Java", "content": "public class EnvVariableTest extends TestRunner {\n    final String testClasses;\n    final ToolBox tb;\n    final Path javaExePath;\n    final ExecTask task;\n    final PrintStream ostream;\n    final ByteArrayOutputStream baos;\n\n    public EnvVariableTest() {\n        super(System.err);\n        ostream = System.err;\n        baos = new ByteArrayOutputStream();\n        testClasses = System.getProperty(\"test.classes\");\n        tb = new ToolBox();\n        javaExePath = tb.getJDKTool(\"java\");\n        task = new ExecTask(tb, javaExePath);\n    }\n\n    public static void main(String... args) throws Exception {\n        EnvVariableTest t = new EnvVariableTest();\n        t.runTests();\n    }\n\n    @Test\n    public void testDoubleQuote() throws Exception {\n        // white space quoted with double quotes\n        test(\"-version -cp \\\"c:\\\\\\\\java libs\\\\\\\\one.jar\\\" \\n\",\n                \"-version\", \"-cp\", \"c:\\\\\\\\java libs\\\\\\\\one.jar\");\n    }\n\n    @Test\n    public void testSingleQuote() throws Exception {\n        // white space quoted with single quotes\n        test(\"-version -cp \\'c:\\\\\\\\java libs\\\\\\\\one.jar\\' \\n\",\n                \"-version\", \"-cp\", \"c:\\\\\\\\java libs\\\\\\\\one.jar\");\n    }\n\n    @Test\n    public void testEscapeCharacters() throws Exception {\n        // escaped characters\n        test(\"escaped chars testing \\\"\\\\a\\\\b\\\\c\\\\f\\\\n\\\\r\\\\t\\\\v\\\\9\\\\6\\\\23\\\\82\\\\28\\\\377\\\\477\\\\278\\\\287\\\"\",\n                \"escaped\", \"chars\", \"testing\", \"\\\\a\\\\b\\\\c\\\\f\\\\n\\\\r\\\\t\\\\v\\\\9\\\\6\\\\23\\\\82\\\\28\\\\377\\\\477\\\\278\\\\287\");\n    }\n\n    @Test\n    public void testMixedQuotes() throws Exception {\n        // more mixing of quote types\n        test(\"\\\"mix 'single quote' in double\\\" 'mix \\\"double quote\\\" in single' partial\\\"quote me\\\"this\",\n                \"mix 'single quote' in double\", \"mix \\\"double quote\\\" in single\", \"partialquote methis\");\n    }\n\n    @Test\n    public void testWhiteSpaces() throws Exception {\n        // whitespace tests\n        test(\"line one #comment\\n'line #2' #rest are comment\\r\\n#comment on line 3\\fline 4 #comment to eof\",\n                \"line\", \"one\", \"#comment\", \"line #2\", \"#rest\", \"are\", \"comment\", \"#comment\", \"on\", \"line\",\n                \"3\", \"line\", \"4\", \"#comment\", \"to\", \"eof\");\n    }\n\n    @Test\n    public void testMismatchedDoubleQuote() throws Exception {\n        // mismatched quote\n        test(\"This is an \\\"open quote \\n    across line\\n\\t, note for WS.\",\n                \"Exception: JDK_JAVAC_OPTIONS\");\n    }\n\n    @Test\n    public void testMismatchedSingleQuote() throws Exception {\n        // mismatched quote\n        test(\"This is an \\'open quote \\n    across line\\n\\t, note for WS.\",\n                \"Exception: JDK_JAVAC_OPTIONS\");\n    }\n\n    void test(String full, String... expectedArgs) throws Exception {\n        task.envVar(\"JDK_JAVAC_OPTIONS\", full);\n        task.args(\"--add-exports\", \"jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED\",\n                \"-cp\", testClasses, \"EnvVariableTest$Tester\");\n        Task.Result tr = task.run(Task.Expect.SUCCESS);\n        String expected = Tester.arrayToString(expectedArgs);\n        String in = tr.getOutput(Task.OutputKind.STDOUT);\n        System.err.println(\"Matching...\");\n        System.err.println(\"Obtained: \" + in);\n        System.err.println(\"Expected: \" + expected);\n        if (in.contains(expected)) {\n            System.err.println(\"....OK\");\n            return;\n        }\n        throw new Exception(\"Expected strings not found\");\n    }\n\n    /**\n     * A tester class that is invoked to invoke the CommandLine class, and\n     * print the result.\n     */\n    public static class Tester {\n        private static final String[] EMPTY_ARRAY = new String[0];\n        static String arrayToString(String... args) {\n            return String.join(\", \", args);\n        }\n        public static void main(String... args) throws IOException {\n            try {\n                String[] argv = CommandLine.parse(\"JDK_JAVAC_OPTIONS\", EMPTY_ARRAY);\n                System.out.print(arrayToString(argv));\n            } catch (CommandLine.UnmatchedQuote ex) {\n                System.out.print(\"Exception: \" + ex.variableName);\n            }\n        }\n    }\n}", "class_id": 0, "repo": "iootclab/openjdk", "file": "openjdk11/test/langtools/tools/javac/main/EnvVariableTest.java", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "0d44edcb72c42ca000ce8bd7abf696c6737cac4d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EnvVariableTest extends TestRunner {\n    final String testClasses;\n    final ToolBox tb;\n    final Path javaExePath;\n    final ExecTask task;\n    final PrintStream ostream;\n    final ByteArrayOutputStream baos;\n    public EnvVariableTest() {\n        super(System.err);\n        ostream = System.err;\n        baos = new ByteArrayOutputStream();\n        testClasses = System.getProperty(\"test.classes\");\n        tb = new ToolBox();\n        javaExePath = tb.getJDKTool(\"java\");\n        task = new ExecTask(tb, javaExePath);\n    }\n    public static void main(String... args) throws Exception {\n        EnvVariableTest t = new EnvVariableTest();\n        t.runTests();\n    }\n    @Test\n    public void testDoubleQuote() throws Exception {\n        // white space quoted with double quotes\n        test(\"-version -cp \\\"c:\\\\\\\\java libs\\\\\\\\one.jar\\\" \\n\",\n                \"-version\", \"-cp\", \"c:\\\\\\\\java libs\\\\\\\\one.jar\");\n    }\n    @Test\n    public void testSingleQuote() throws Exception {\n        // white space quoted with single quotes\n        test(\"-version -cp \\'c:\\\\\\\\java libs\\\\\\\\one.jar\\' \\n\",\n                \"-version\", \"-cp\", \"c:\\\\\\\\java libs\\\\\\\\one.jar\");\n    }\n    @Test\n    public void testEscapeCharacters() throws Exception {\n        // escaped characters\n        test(\"escaped chars testing \\\"\\\\a\\\\b\\\\c\\\\f\\\\n\\\\r\\\\t\\\\v\\\\9\\\\6\\\\23\\\\82\\\\28\\\\377\\\\477\\\\278\\\\287\\\"\",\n                \"escaped\", \"chars\", \"testing\", \"\\\\a\\\\b\\\\c\\\\f\\\\n\\\\r\\\\t\\\\v\\\\9\\\\6\\\\23\\\\82\\\\28\\\\377\\\\477\\\\278\\\\287\");\n    }\n    @Test\n    public void testMixedQuotes() throws Exception {\n        // more mixing of quote types\n        test(\"\\\"mix 'single quote' in double\\\" 'mix \\\"double quote\\\" in single' partial\\\"quote me\\\"this\",\n                \"mix 'single quote' in double\", \"mix \\\"double quote\\\" in single\", \"partialquote methis\");\n    }\n    @Test\n    public void testWhiteSpaces() throws Exception {\n        // whitespace tests\n        test(\"line one #comment\\n'line #2' #rest are comment\\r\\n#comment on line 3\\fline 4 #comment to eof\",\n                \"line\", \"one\", \"#comment\", \"line #2\", \"#rest\", \"are\", \"comment\", \"#comment\", \"on\", \"line\",\n                \"3\", \"line\", \"4\", \"#comment\", \"to\", \"eof\");\n    }\n    @Test\n    public void testMismatchedDoubleQuote() throws Exception {\n        // mismatched quote\n        test(\"This is an \\\"open quote \\n    across line\\n\\t, note for WS.\",\n                \"Exception: JDK_JAVAC_OPTIONS\");\n    }\n    @Test\n    public void testMismatchedSingleQuote() throws Exception {\n        // mismatched quote\n        test(\"This is an \\'open quote \\n    across line\\n\\t, note for WS.\",\n                \"Exception: JDK_JAVAC_OPTIONS\");\n    }\n    void test(String full, String... expectedArgs) throws Exception {\n        task.envVar(\"JDK_JAVAC_OPTIONS\", full);\n        task.args(\"--add-exports\", \"jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED\",\n                \"-cp\", testClasses, \"EnvVariableTest$Tester\");\n        Task.Result tr = task.run(Task.Expect.SUCCESS);\n        String expected = Tester.arrayToString(expectedArgs);\n        String in = tr.getOutput(Task.OutputKind.STDOUT);\n        System.err.println(\"Matching...\");\n        System.err.println(\"Obtained: \" + in);\n        System.err.println(\"Expected: \" + expected);\n        if (in.contains(expected)) {\n            System.err.println(\"....OK\");\n            return;\n        }\n        throw new Exception(\"Expected strings not found\");\n    }\n    /**\n     * A tester class that is invoked to invoke the CommandLine class, and\n     * print the result.\n     */\n    public static class Tester {\n        private static final String[] EMPTY_ARRAY = new String[0];\n        static String arrayToString(String... args) {\n            return String.join(\", \", args);\n        }\n        public static void main(String... args) throws IOException {\n            try {\n                String[] argv = CommandLine.parse(\"JDK_JAVAC_OPTIONS\", EMPTY_ARRAY);\n                System.out.print(arrayToString(argv));\n            } catch (CommandLine.UnmatchedQuote ex) {\n                System.out.print(\"Exception: \" + ex.variableName);\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.5134427547454834, "ppl_lower": 2.878201961517334, "ppl/lowercase_ppl": -1.1470317879327132, "ppl/zlib": 0.0007067894392445987, "Min_5.0% Prob": 7.544848816067565, "Min_10.0% Prob": 5.788209435986538, "Min_20.0% Prob": 4.047161217413697, "Min_30.0% Prob": 2.9612667359947378, "Min_40.0% Prob": 2.2809321387399963, "Min_50.0% Prob": 1.8386020214313281, "Min_60.0% Prob": 1.5361931954417833}}
{"hexsha": "54c8e57a21a94874674b8a91dd39f7308c562c2c", "ext": "java", "lang": "Java", "content": "public class ProcessTable extends AbstractTableModel {\n\n    // Satisfying the linter\n    private static final long serialVersionUID = 1L;\n\n    // TER stands for tempo execut\u00e1vel restante\n    private final String columns[] = {\"PID\", \"Nome\", \"TER\", \"Prioridade\"};\n    private Vector<Object[]> data = new Vector<>();\n\n    /**\n     *\n     * @param data\n     */\n    public void push(Object data[]) {\n        this.data.add(data);\n        fireTableRowsInserted(this.data.size(), this.data.size()+1);\n    }\n\n    /**\n     *\n     * @param row\n     */\n    public void remove(int row) {\n        data.remove(row);\n        fireTableRowsDeleted(row, row);\n    }\n\n    public void remove(Object data[]) {\n        this.data.remove(data);\n        fireTableRowsDeleted(0, this.data.size());\n    }\n\n    public void update() {\n        fireTableRowsUpdated(0, data.size());\n    }\n\n    /**\n     * @brief Clears the entire table\n     */\n    public void clear() {\n        this.data.clear();\n        fireTableRowsDeleted(0, data.size());\n    }\n\n    /**\n     *\n     * @return\n     */\n    public int getRowCount() {\n        return data.size();\n    }\n\n    /**\n     *\n     * @return\n     */\n    public int getColumnCount() {\n        return columns.length;\n    }\n\n    /**\n     *\n     */\n    @Override\n    public String getColumnName(int i) {\n        return columns[i];\n    }\n\n    /**\n     * @brief Returns the data at row and column indicated on the arguments,\n     * it might return null and the caller should treat that behavior.\n     */\n    public Object getValueAt(int row, int column) {\n        Object r = null;\n\n        try {\n            r = data.get(row)[column];\n        } catch(ArrayIndexOutOfBoundsException ex) {\n            System.out.println(\"Error trying to retrieve an element from the table.\");\n        }\n\n        return r;\n    }\n\n    /**\n     *\n     * @param row\n     * @return\n     */\n    public Object[] getValue(int row) {\n        return data.get(row);\n    }\n}", "class_id": 0, "repo": "rafaelcn/j-scheduler", "file": "src/org/scheduler/view/ProcessTable.java", "last_update_at": "2018-11-15T20:52:18+00:00", "question_id": "54c8e57a21a94874674b8a91dd39f7308c562c2c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProcessTable extends AbstractTableModel {\n    // Satisfying the linter\n    private static final long serialVersionUID = 1L;\n    // TER stands for tempo execut\u00e1vel restante\n    private final String columns[] = {\"PID\", \"Nome\", \"TER\", \"Prioridade\"};\n    private Vector<Object[]> data = new Vector<>();\n    /**\n     *\n     * @param data\n     */\n    public void push(Object data[]) {\n        this.data.add(data);\n        fireTableRowsInserted(this.data.size(), this.data.size()+1);\n    }\n    /**\n     *\n     * @param row\n     */\n    public void remove(int row) {\n        data.remove(row);\n        fireTableRowsDeleted(row, row);\n    }\n    public void remove(Object data[]) {\n        this.data.remove(data);\n        fireTableRowsDeleted(0, this.data.size());\n    }\n    public void update() {\n        fireTableRowsUpdated(0, data.size());\n    }\n    /**\n     * @brief Clears the entire table\n     */\n    public void clear() {\n        this.data.clear();\n        fireTableRowsDeleted(0, data.size());\n    }\n    /**\n     *\n     * @return\n     */\n    public int getRowCount() {\n        return data.size();\n    }\n    /**\n     *\n     * @return\n     */\n    public int getColumnCount() {\n        return columns.length;\n    }\n    /**\n     *\n     */\n    @Override\n    public String getColumnName(int i) {\n        return columns[i];\n    }\n    /**\n     * @brief Returns the data at row and column indicated on the arguments,\n     * it might return null and the caller should treat that behavior.\n     */\n    public Object getValueAt(int row, int column) {\n        Object r = null;\n        try {\n            r = data.get(row)[column];\n        } catch(ArrayIndexOutOfBoundsException ex) {\n            System.out.println(\"Error trying to retrieve an element from the table.\");\n        }\n        return r;\n    }\n    /**\n     *\n     * @param row\n     * @return\n     */\n    public Object[] getValue(int row) {\n        return data.get(row);\n    }\n"]], "pred": {"ppl": 2.015592098236084, "ppl_lower": 2.2231507301330566, "ppl/lowercase_ppl": -1.1398353866262094, "ppl/zlib": 0.0009816708648641898, "Min_5.0% Prob": 6.8201773495509705, "Min_10.0% Prob": 4.875488293581996, "Min_20.0% Prob": 3.140687915785559, "Min_30.0% Prob": 2.2692943016688027, "Min_40.0% Prob": 1.7367616577209832, "Min_50.0% Prob": 1.3993883387560082, "Min_60.0% Prob": 1.1694405383715956}}
{"hexsha": "d915d20b533e26cbb5012ccdc535e6ce5c2894f2", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class ExampleBasic {\n\n  public static void main(String[] arg) {\n    log.info(\"Test modem which only understand AT\");\n\n    //final Basic modem = new Basic(new JsscSerial(\"/dev/tty.usbserial-A1056QHL\", 9600, FLOWCONTROL_NONE, callback));\n    final Basic modem = new Basic(\n        new JsscSerial(\"/dev/tty.usbserial-A1056QHL\", 9600, FLOWCONTROL_XONXOFF_IN | FLOWCONTROL_XONXOFF_OUT,\n            new UnsolicitedCallback()));\n\n    try {\n      modem.init();\n      log.info(\"Is the modem responsive? {}\", modem.isResponsive());\n      // Send a simple AT\n      modem.getSimpleCommand(\"AT\").set();\n      // Send a lot of AT commands\n      for (int i = 0; i < 1000; i++) {\n        modem.getAttention();\n      }\n      modem.close();\n    } catch (final Exception e) {\n      log.error(\"The modem had an error\", e);\n    }\n\n  }\n\n}", "class_id": 0, "repo": "pmoerenhout/at-commander", "file": "at-commander-examples/src/main/java/com/github/pmoerenhout/atcommander/ExampleBasic.java", "last_update_at": "2018-07-12T12:07:41+00:00", "question_id": "d915d20b533e26cbb5012ccdc535e6ce5c2894f2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class ExampleBasic {\n  public static void main(String[] arg) {\n    log.info(\"Test modem which only understand AT\");\n    //final Basic modem = new Basic(new JsscSerial(\"/dev/tty.usbserial-A1056QHL\", 9600, FLOWCONTROL_NONE, callback));\n    final Basic modem = new Basic(\n        new JsscSerial(\"/dev/tty.usbserial-A1056QHL\", 9600, FLOWCONTROL_XONXOFF_IN | FLOWCONTROL_XONXOFF_OUT,\n            new UnsolicitedCallback()));\n    try {\n      modem.init();\n      log.info(\"Is the modem responsive? {}\", modem.isResponsive());\n      // Send a simple AT\n      modem.getSimpleCommand(\"AT\").set();\n      // Send a lot of AT commands\n      for (int i = 0; i < 1000; i++) {\n        modem.getAttention();\n      }\n      modem.close();\n    } catch (final Exception e) {\n      log.error(\"The modem had an error\", e);\n    }\n  }\n"]], "pred": {"ppl": 3.170971155166626, "ppl_lower": 3.942535877227783, "ppl/lowercase_ppl": -1.1887167146268698, "ppl/zlib": 0.0026529606875123155, "Min_5.0% Prob": 8.958985328674316, "Min_10.0% Prob": 6.959332021077474, "Min_20.0% Prob": 4.846135232845942, "Min_30.0% Prob": 3.601172616084417, "Min_40.0% Prob": 2.831386484702428, "Min_50.0% Prob": 2.290403454163611, "Min_60.0% Prob": 1.9207875811551487}}
{"hexsha": "6642f9ef752debb2ee5ffb876a4847d2b1941b52", "ext": "java", "lang": "Java", "content": "public class MethodNodeImpl extends MethodNode {\n\n    public MethodNodeImpl() {\n        super(Opcodes.ASM5);\n        exceptions = new ArrayList();\n        tryCatchBlocks = new ArrayList();\n        localVariables = new ArrayList();\n        attrs = new ArrayList();\n    }\n\n    public static MethodNodeImpl duplicate(MethodNode node) {\n        MethodNodeImpl self = new MethodNodeImpl();\n\n        self.name = node.name;\n        self.desc = node.desc;\n        self.access = node.access;\n        self.annotationDefault = node.annotationDefault;\n        self.attrs = node.attrs;\n        self.exceptions = node.exceptions;\n        self.tryCatchBlocks = node.tryCatchBlocks;\n        self.localVariables = node.localVariables;\n\n        self.instructions = node.instructions;\n\n        self.invisibleAnnotations = node.invisibleAnnotations;\n        self.invisibleParameterAnnotations = node.invisibleParameterAnnotations;\n        self.visibleAnnotations = node.visibleAnnotations;\n        self.visibleParameterAnnotations = node.visibleParameterAnnotations;\n        self.maxLocals = node.maxLocals;\n        self.maxStack = node.maxStack;\n\n        self.localVariables = node.localVariables;\n\n        // HACK\n        // it's needed for copied trait method, else it will generate an error in duplicated usage\n        try {\n            Field field = node.getClass().getDeclaredField(\"visited\");\n            field.setAccessible(true);\n            field.setBoolean(self, true);\n        } catch (NoSuchFieldException e) {\n            throw new CriticalException(e);\n        } catch (IllegalAccessException e) {\n            throw new CriticalException(e);\n        }\n        return self;\n    }\n\n    @Override\n    public void accept(ClassVisitor cv) {\n        super.accept(cv);\n    }\n}", "class_id": 0, "repo": "TsSaltan/jphp", "file": "jphp-core/src/org/develnext/jphp/core/compiler/jvm/node/MethodNodeImpl.java", "last_update_at": "2018-05-02T14:44:25+00:00", "question_id": "6642f9ef752debb2ee5ffb876a4847d2b1941b52", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MethodNodeImpl extends MethodNode {\n    public MethodNodeImpl() {\n        super(Opcodes.ASM5);\n        exceptions = new ArrayList();\n        tryCatchBlocks = new ArrayList();\n        localVariables = new ArrayList();\n        attrs = new ArrayList();\n    }\n    public static MethodNodeImpl duplicate(MethodNode node) {\n        MethodNodeImpl self = new MethodNodeImpl();\n        self.name = node.name;\n        self.desc = node.desc;\n        self.access = node.access;\n        self.annotationDefault = node.annotationDefault;\n        self.attrs = node.attrs;\n        self.exceptions = node.exceptions;\n        self.tryCatchBlocks = node.tryCatchBlocks;\n        self.localVariables = node.localVariables;\n        self.instructions = node.instructions;\n        self.invisibleAnnotations = node.invisibleAnnotations;\n        self.invisibleParameterAnnotations = node.invisibleParameterAnnotations;\n        self.visibleAnnotations = node.visibleAnnotations;\n        self.visibleParameterAnnotations = node.visibleParameterAnnotations;\n        self.maxLocals = node.maxLocals;\n        self.maxStack = node.maxStack;\n        self.localVariables = node.localVariables;\n        // HACK\n        // it's needed for copied trait method, else it will generate an error in duplicated usage\n        try {\n            Field field = node.getClass().getDeclaredField(\"visited\");\n            field.setAccessible(true);\n            field.setBoolean(self, true);\n        } catch (NoSuchFieldException e) {\n            throw new CriticalException(e);\n        } catch (IllegalAccessException e) {\n            throw new CriticalException(e);\n        }\n        return self;\n    }\n    @Override\n    public void accept(ClassVisitor cv) {\n        super.accept(cv);\n    }\n"]], "pred": {"ppl": 1.8183581829071045, "ppl_lower": 2.2188894748687744, "ppl/lowercase_ppl": -1.3329344687599534, "ppl/zlib": 0.0010911204318435658, "Min_5.0% Prob": 6.751018921534221, "Min_10.0% Prob": 4.652673075596492, "Min_20.0% Prob": 2.8432137177636227, "Min_30.0% Prob": 1.978707216007428, "Min_40.0% Prob": 1.4940156110484775, "Min_50.0% Prob": 1.1973271019388145, "Min_60.0% Prob": 0.998353001309119}}
{"hexsha": "299dcbce10a290b725e9afce5cbc2a73b314eee9", "ext": "java", "lang": "Java", "content": "public class BrowseBooksScreen extends List implements CommandListener\r\n{\r\n\tprivate static BookCollection books;\r\n\t\r\n\tpublic static int PAGE_SIZE = 5;\r\n\t\r\n\tprivate Midlet midlet;\r\n\tprivate int currentPage;\r\n\t\r\n\tprivate Command nextPage;\r\n\tprivate Command previousPage;\r\n\t\r\n\tprivate Command select;\r\n\tprivate Command home;\r\n\t\r\n\tpublic static BrowseBooksScreen getScreen (int pageNo, Midlet midlet) \r\n\t{\r\n\t\tBrowseBooksScreen browseScreen = new BrowseBooksScreen (pageNo);\r\n\t\tbrowseScreen.setMidlet (midlet);\r\n\t\t\r\n\t\treturn browseScreen;\r\n\t}\r\n\t\r\n\tprivate void setMidlet(Midlet m) \r\n\t{\r\n\t\tmidlet = m;\r\n\t}\r\n\t\r\n\tpublic BrowseBooksScreen (int page)\r\n\t{\r\n\t\tsuper (\"Collection: Page \" + (page + 1), List.IMPLICIT);\r\n\t\t\r\n\t\tcurrentPage = page;\r\n\t\t\r\n\t\tif (books == null)\r\n\t\t{\r\n\t\t\tbooks = BookCollection.getCollection ();\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = (currentPage * PAGE_SIZE); i < books.size () && i < ((currentPage + 1) * PAGE_SIZE); i++)\r\n\t\t{\r\n\t\t\tBook b = books.getBookAtIndex (i);\r\n\t\t\t\r\n\t\t\tif (b.getValue (\"Title\") != null)\r\n\t\t\t\tthis.append (b.getValue (\"Title\"), null);\r\n\t\t}\r\n\t\t\r\n\t\tif (((currentPage + 1) * PAGE_SIZE) < books.size ())\r\n\t\t{\r\n\t\t\tnextPage = new Command (\"Next\", Command.OK, 1);\r\n\t\t\tthis.addCommand (nextPage);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thome = new Command (\"Home\", Command.OK, 2);\r\n\t\t\tthis.addCommand (home);\r\n\t\t}\r\n\t\t\r\n\t\tif (currentPage > 0)\r\n\t\t{\r\n\t\t\tpreviousPage = new Command (\"Previous\", Command.BACK, 1);\r\n\t\t\tthis.addCommand (previousPage);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thome = new Command (\"Home\", Command.BACK, 2);\r\n\t\t\tthis.addCommand (home);\r\n\t\t}\r\n\t\t\r\n\t\tselect = List.SELECT_COMMAND;\r\n\t\tthis.addCommand (select);\r\n\t\t\r\n\t\tthis.setCommandListener (this);\r\n\t}\r\n\t\r\n\tpublic BrowseBooksScreen (String arg0, int arg1) \r\n\t{\r\n\t\tsuper (arg0, arg1);\r\n\t}\r\n\t\r\n\tpublic void commandAction(Command cmd, Displayable sender) \r\n\t{\r\n\t\tif (cmd == home)\r\n\t\t\tmidlet.setScreen (MainMenuScreen.getScreen (midlet));\r\n\t\telse if (cmd == select)\r\n\t\t\tmidlet.setScreen (BookDisplayScreen.getScreen ((currentPage * PAGE_SIZE) + this.getSelectedIndex(), null, midlet));\r\n\t\telse if (cmd == nextPage)\r\n\t\t\tmidlet.setScreen (BrowseBooksScreen.getScreen (currentPage + 1, midlet));\r\n\t\telse if (cmd ==previousPage)\r\n\t\t{\r\n\t\t\tif (currentPage > 0)\r\n\t\t\t\tmidlet.setScreen (BrowseBooksScreen.getScreen (currentPage - 1, midlet));\r\n\t\t}\r\n\t}\r\n}", "class_id": 0, "repo": "telwertowski/Books-Mac-OS-X", "file": "Export Plugins/J2ME Exporter/Books-J2ME/src/net/aetherial/books/me/BrowseBooksScreen.java", "last_update_at": "2018-04-09T18:45:19+00:00", "question_id": "299dcbce10a290b725e9afce5cbc2a73b314eee9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BrowseBooksScreen extends List implements CommandListener\r\n{\r\n\tprivate static BookCollection books;\r\n\t\r\n\tpublic static int PAGE_SIZE = 5;\r\n\t\r\n\tprivate Midlet midlet;\r\n\tprivate int currentPage;\r\n\t\r\n\tprivate Command nextPage;\r\n\tprivate Command previousPage;\r\n\t\r\n\tprivate Command select;\r\n\tprivate Command home;\r\n\t\r\n\tpublic static BrowseBooksScreen getScreen (int pageNo, Midlet midlet) \r\n\t{\r\n\t\tBrowseBooksScreen browseScreen = new BrowseBooksScreen (pageNo);\r\n\t\tbrowseScreen.setMidlet (midlet);\r\n\t\t\r\n\t\treturn browseScreen;\r\n\t}\r\n\t\r\n\tprivate void setMidlet(Midlet m) \r\n\t{\r\n\t\tmidlet = m;\r\n\t}\r\n\t\r\n\tpublic BrowseBooksScreen (int page)\r\n\t{\r\n\t\tsuper (\"Collection: Page \" + (page + 1), List.IMPLICIT);\r\n\t\t\r\n\t\tcurrentPage = page;\r\n\t\t\r\n\t\tif (books == null)\r\n\t\t{\r\n\t\t\tbooks = BookCollection.getCollection ();\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = (currentPage * PAGE_SIZE); i < books.size () && i < ((currentPage + 1) * PAGE_SIZE); i++)\r\n\t\t{\r\n\t\t\tBook b = books.getBookAtIndex (i);\r\n\t\t\t\r\n\t\t\tif (b.getValue (\"Title\") != null)\r\n\t\t\t\tthis.append (b.getValue (\"Title\"), null);\r\n\t\t}\r\n\t\t\r\n\t\tif (((currentPage + 1) * PAGE_SIZE) < books.size ())\r\n\t\t{\r\n\t\t\tnextPage = new Command (\"Next\", Command.OK, 1);\r\n\t\t\tthis.addCommand (nextPage);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thome = new Command (\"Home\", Command.OK, 2);\r\n\t\t\tthis.addCommand (home);\r\n\t\t}\r\n\t\t\r\n\t\tif (currentPage > 0)\r\n\t\t{\r\n\t\t\tpreviousPage = new Command (\"Previous\", Command.BACK, 1);\r\n\t\t\tthis.addCommand (previousPage);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thome = new Command (\"Home\", Command.BACK, 2);\r\n\t\t\tthis.addCommand (home);\r\n\t\t}\r\n\t\t\r\n\t\tselect = List.SELECT_COMMAND;\r\n\t\tthis.addCommand (select);\r\n\t\t\r\n\t\tthis.setCommandListener (this);\r\n\t}\r\n\t\r\n\tpublic BrowseBooksScreen (String arg0, int arg1) \r\n\t{\r\n\t\tsuper (arg0, arg1);\r\n\t}\r\n\t\r\n\tpublic void commandAction(Command cmd, Displayable sender) \r\n\t{\r\n\t\tif (cmd == home)\r\n\t\t\tmidlet.setScreen (MainMenuScreen.getScreen (midlet));\r\n\t\telse if (cmd == select)\r\n\t\t\tmidlet.setScreen (BookDisplayScreen.getScreen ((currentPage * PAGE_SIZE) + this.getSelectedIndex(), null, midlet));\r\n\t\telse if (cmd == nextPage)\r\n\t\t\tmidlet.setScreen (BrowseBooksScreen.getScreen (currentPage + 1, midlet));\r\n\t\telse if (cmd ==previousPage)\r\n\t\t{\r\n\t\t\tif (currentPage > 0)\r\n\t\t\t\tmidlet.setScreen (BrowseBooksScreen.getScreen (currentPage - 1, midlet));\r\n\t\t}\r\n\t}\r\n"]], "pred": {"ppl": 1.5812052488327026, "ppl_lower": 1.7506572008132935, "ppl/lowercase_ppl": -1.2221883339197885, "ppl/zlib": 0.0006233841795370612, "Min_5.0% Prob": 5.405579214746302, "Min_10.0% Prob": 3.6704813349113037, "Min_20.0% Prob": 2.1894649411185405, "Min_30.0% Prob": 1.5094291730992384, "Min_40.0% Prob": 1.1426467353097196, "Min_50.0% Prob": 0.9152881485635053, "Min_60.0% Prob": 0.7639859641012527}}
{"hexsha": "def6ac634f68c6299a28539e50e3d4d70e42a1a5", "ext": "java", "lang": "Java", "content": "public final class JsonNumberValue extends AbstractJsonValue {\n\tprivate final Number value;\n\n\tpublic JsonNumberValue(Number value) {\n\t\tthis.value = notNull(value, \"value\");\n\t}\n\n\t@Override\n\tpublic Optional<JsonNumberValue> isNumber() {\n\t\treturn Optional.of(this);\n\t}\n\n\tpublic Number numberValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((value == null) ? 0 : value.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tprotected boolean equalsJsonValue(JsonValue rhs) {\n\t\treturn rhs.isNumber()\n\t\t\t\t.filter(this::equalsJsonNumberValue)\n\t\t\t\t.isPresent();\n\t}\n\n\tprivate boolean equalsJsonNumberValue(JsonNumberValue cand) {\n\t\treturn cand.numberValue().equals(numberValue());\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn ToString.of(this)\n\t\t\t\t.with(\"value\", value)\n\t\t\t\t.toString();\n\t}\n}", "class_id": 0, "repo": "nrkno/nrk-shared-java", "file": "nrk-ietf/nrk-ietf-rfc7159-json/src/main/java/no/nrk/ietf/rfc7159/json/JsonNumberValue.java", "last_update_at": "2018-01-31T09:26:13+00:00", "question_id": "def6ac634f68c6299a28539e50e3d4d70e42a1a5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class JsonNumberValue extends AbstractJsonValue {\n\tprivate final Number value;\n\tpublic JsonNumberValue(Number value) {\n\t\tthis.value = notNull(value, \"value\");\n\t}\n\t@Override\n\tpublic Optional<JsonNumberValue> isNumber() {\n\t\treturn Optional.of(this);\n\t}\n\tpublic Number numberValue() {\n\t\treturn value;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((value == null) ? 0 : value.hashCode());\n\t\treturn result;\n\t}\n\t@Override\n\tprotected boolean equalsJsonValue(JsonValue rhs) {\n\t\treturn rhs.isNumber()\n\t\t\t\t.filter(this::equalsJsonNumberValue)\n\t\t\t\t.isPresent();\n\t}\n\tprivate boolean equalsJsonNumberValue(JsonNumberValue cand) {\n\t\treturn cand.numberValue().equals(numberValue());\n\t}\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn ToString.of(this)\n\t\t\t\t.with(\"value\", value)\n\t\t\t\t.toString();\n\t}\n"]], "pred": {"ppl": 1.6282463073730469, "ppl_lower": 1.8816759586334229, "ppl/lowercase_ppl": -1.296734857236985, "ppl/zlib": 0.0012965519962544819, "Min_5.0% Prob": 5.925393536686897, "Min_10.0% Prob": 3.9568055383861065, "Min_20.0% Prob": 2.3184067299589515, "Min_30.0% Prob": 1.6068762446132798, "Min_40.0% Prob": 1.2182173861074261, "Min_50.0% Prob": 0.9766659983200953, "Min_60.0% Prob": 0.8145534392545718}}
{"hexsha": "106ddf86929415f459f4a7be0e605fa317d1984d", "ext": "java", "lang": "Java", "content": "public class CommonUtil {\n\n    private static final Logger log = LoggerFactory.getLogger(CommonUtil.class);\n\n    public static String urlEncode(final String value) {\n        try {\n            return URLEncoder.encode(value, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"could not encode url encode string\");\n        }\n    }\n\n    public static String urlDecode(final String value) {\n        try {\n            return URLDecoder.decode(value, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"could not decode url encode string\");\n        }\n    }\n\n    public static String toHexString(byte[] bytes) {\n        //convert the byte to hex format method 1\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < bytes.length; i++) {\n//            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));\n            sb.append(Integer.toHexString(0xFF & bytes[i]));\n        }\n\n        return sb.toString();\n    }\n\n    public static String getTextSha256sum(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n            md.update(text.getBytes());\n\n            byte byteData[] = md.digest();\n\n            return toHexString(byteData);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"SHA-256 digest algorithm not available!\", e);\n            throw new AppException(e);\n        }\n    }\n\n    public static String getFileSha256sum(String fileName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n            FileInputStream fis = new FileInputStream(fileName);\n\n            byte[] dataBytes = new byte[1024];\n\n            int nread = 0;\n            while ((nread = fis.read(dataBytes)) != -1) {\n                md.update(dataBytes, 0, nread);\n            }\n\n            byte[] sumBytes = md.digest();\n\n            return toHexString(sumBytes);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"SHA-256 digest algorithm not available!\", e);\n            throw new AppException(e);\n        } catch (IOException ioe) {\n            log.error(\"file read failed!\", ioe);\n            throw new AppException(ioe);\n        }\n    }\n}", "class_id": 0, "repo": "sjitech/mijin-java-sample", "file": "src/main/java/io/sjitech/demo/util/CommonUtil.java", "last_update_at": "2018-07-06T07:16:00+00:00", "question_id": "106ddf86929415f459f4a7be0e605fa317d1984d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CommonUtil {\n    private static final Logger log = LoggerFactory.getLogger(CommonUtil.class);\n    public static String urlEncode(final String value) {\n        try {\n            return URLEncoder.encode(value, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"could not encode url encode string\");\n        }\n    }\n    public static String urlDecode(final String value) {\n        try {\n            return URLDecoder.decode(value, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"could not decode url encode string\");\n        }\n    }\n    public static String toHexString(byte[] bytes) {\n        //convert the byte to hex format method 1\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < bytes.length; i++) {\n//            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));\n            sb.append(Integer.toHexString(0xFF & bytes[i]));\n        }\n        return sb.toString();\n    }\n    public static String getTextSha256sum(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(text.getBytes());\n            byte byteData[] = md.digest();\n            return toHexString(byteData);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"SHA-256 digest algorithm not available!\", e);\n            throw new AppException(e);\n        }\n    }\n    public static String getFileSha256sum(String fileName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] dataBytes = new byte[1024];\n            int nread = 0;\n            while ((nread = fis.read(dataBytes)) != -1) {\n                md.update(dataBytes, 0, nread);\n            }\n            byte[] sumBytes = md.digest();\n            return toHexString(sumBytes);\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"SHA-256 digest algorithm not available!\", e);\n            throw new AppException(e);\n        } catch (IOException ioe) {\n            log.error(\"file read failed!\", ioe);\n            throw new AppException(ioe);\n        }\n    }\n"]], "pred": {"ppl": 1.4340858459472656, "ppl_lower": 1.6500054597854614, "ppl/lowercase_ppl": -1.389015958377168, "ppl/zlib": 0.0005035301746688861, "Min_5.0% Prob": 4.625800684094429, "Min_10.0% Prob": 2.996292022558359, "Min_20.0% Prob": 1.7407660636764306, "Min_30.0% Prob": 1.1944592927701962, "Min_40.0% Prob": 0.9015734015892332, "Min_50.0% Prob": 0.7203174660023748, "Min_60.0% Prob": 0.6009704581494002}}
{"hexsha": "43b0fc7502cd650291a0258042359563f09b9b70", "ext": "java", "lang": "Java", "content": "public class ModItems {\n\n    public static UpgradeArmory upgradeArmory;\n    public static UpgradeMagic upgradeMagic;\n    public static UpgradePower upgradePower;\n    public static UpgradeDigital upgradeDigital;\n\n    public static void init() {\n        upgradeArmory = new UpgradeArmory();\n        upgradeMagic = new UpgradeMagic();\n        upgradePower = new UpgradePower();\n        upgradeDigital = new UpgradeDigital();\n    }\n\n    @SideOnly(Side.CLIENT)\n    public static void initModels() {\n        upgradeArmory.initModel();\n        upgradeMagic.initModel();\n        upgradePower.initModel();\n        upgradeDigital.initModel();\n    }\n}", "class_id": 0, "repo": "mjevans/EFab", "file": "src/main/java/mcjty/efab/items/ModItems.java", "last_update_at": "2018-03-16T18:33:05+00:00", "question_id": "43b0fc7502cd650291a0258042359563f09b9b70", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ModItems {\n    public static UpgradeArmory upgradeArmory;\n    public static UpgradeMagic upgradeMagic;\n    public static UpgradePower upgradePower;\n    public static UpgradeDigital upgradeDigital;\n    public static void init() {\n        upgradeArmory = new UpgradeArmory();\n        upgradeMagic = new UpgradeMagic();\n        upgradePower = new UpgradePower();\n        upgradeDigital = new UpgradeDigital();\n    }\n    @SideOnly(Side.CLIENT)\n    public static void initModels() {\n        upgradeArmory.initModel();\n        upgradeMagic.initModel();\n        upgradePower.initModel();\n        upgradeDigital.initModel();\n    }\n"]], "pred": {"ppl": 1.7292543649673462, "ppl_lower": 2.021987199783325, "ppl/lowercase_ppl": -1.285545451122147, "ppl/zlib": 0.002724827426329296, "Min_5.0% Prob": 7.825353741645813, "Min_10.0% Prob": 4.864884734153748, "Min_20.0% Prob": 2.6394379924644125, "Min_30.0% Prob": 1.8418943710169013, "Min_40.0% Prob": 1.3746967058290134, "Min_50.0% Prob": 1.0945771239467907, "Min_60.0% Prob": 0.9180611760644807}}
{"hexsha": "71a65321ec0f63aed23f71b557b8db6af86ff773", "ext": "java", "lang": "Java", "content": "public class Client extends AbstractVerticle {\n\n  // Convenience method so you can run it in your IDE\n  public static void main(String[] args) {\n    Runner.runExample(Client.class);\n  }\n\n  @Override\n  public void start() throws Exception {\n\n    JsonObject config = new JsonObject().put(\"url\", \"jdbc:hsqldb:mem:test?shutdown=true\")\n      .put(\"driver_class\", \"org.hsqldb.jdbcDriver\");\n\n    JDBCClient jdbc = JDBCClient.createShared(vertx, config);\n\n    // Connect to the database\n    jdbc.rxGetConnection().flatMap(conn -> {\n\n      // Now chain some statements using flatmap composition\n      Single<ResultSet> resa = conn.rxUpdate(\"CREATE TABLE test(col VARCHAR(20))\")\n        .flatMap(result -> conn.rxUpdate(\"INSERT INTO test (col) VALUES ('val1')\"))\n        .flatMap(result -> conn.rxUpdate(\"INSERT INTO test (col) VALUES ('val2')\"))\n        .flatMap(result -> conn.rxQuery(\"SELECT * FROM test\"));\n\n      return resa.doAfterTerminate(conn::close);\n\n    }).subscribe(resultSet -> {\n      // Subscribe to the final result\n      System.out.println(\"Results : \" + resultSet.getRows());\n    }, err -> {\n      System.out.println(\"Database problem\");\n      err.printStackTrace();\n    });\n  }\n}", "class_id": 0, "repo": "oshai/vertx-examples", "file": "rxjava-2-examples/src/main/java/io/vertx/example/reactivex/database/jdbc/Client.java", "last_update_at": "2018-07-09T08:05:40+00:00", "question_id": "71a65321ec0f63aed23f71b557b8db6af86ff773", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Client extends AbstractVerticle {\n  // Convenience method so you can run it in your IDE\n  public static void main(String[] args) {\n    Runner.runExample(Client.class);\n  }\n  @Override\n  public void start() throws Exception {\n    JsonObject config = new JsonObject().put(\"url\", \"jdbc:hsqldb:mem:test?shutdown=true\")\n      .put(\"driver_class\", \"org.hsqldb.jdbcDriver\");\n    JDBCClient jdbc = JDBCClient.createShared(vertx, config);\n    // Connect to the database\n    jdbc.rxGetConnection().flatMap(conn -> {\n      // Now chain some statements using flatmap composition\n      Single<ResultSet> resa = conn.rxUpdate(\"CREATE TABLE test(col VARCHAR(20))\")\n        .flatMap(result -> conn.rxUpdate(\"INSERT INTO test (col) VALUES ('val1')\"))\n        .flatMap(result -> conn.rxUpdate(\"INSERT INTO test (col) VALUES ('val2')\"))\n        .flatMap(result -> conn.rxQuery(\"SELECT * FROM test\"));\n      return resa.doAfterTerminate(conn::close);\n    }).subscribe(resultSet -> {\n      // Subscribe to the final result\n      System.out.println(\"Results : \" + resultSet.getRows());\n    }, err -> {\n      System.out.println(\"Database problem\");\n      err.printStackTrace();\n    });\n  }\n"]], "pred": {"ppl": 2.0169379711151123, "ppl_lower": 2.5558054447174072, "ppl/lowercase_ppl": -1.3375049751645782, "ppl/zlib": 0.001115390310743402, "Min_5.0% Prob": 6.74114746205947, "Min_10.0% Prob": 5.068541744777135, "Min_20.0% Prob": 3.226792105606624, "Min_30.0% Prob": 2.285307984408878, "Min_40.0% Prob": 1.7457418593977179, "Min_50.0% Prob": 1.3983901962214573, "Min_60.0% Prob": 1.1691064556080724}}
{"hexsha": "76448458f8711fbbba7fb5cc7a15d3ff53c075e5", "ext": "java", "lang": "Java", "content": "@Slf4j\npublic class PgConnectionSupplier {\n\n    @NonNull\n    @VisibleForTesting\n    protected final org.apache.tomcat.jdbc.pool.DataSource ds;\n\n    public PgConnectionSupplier(DataSource dataSource) {\n        if (org.apache.tomcat.jdbc.pool.DataSource.class.isAssignableFrom(dataSource.getClass())) {\n            this.ds = (org.apache.tomcat.jdbc.pool.DataSource) dataSource;\n        } else {\n            throw new IllegalArgumentException(\"expected \"\n                    + org.apache.tomcat.jdbc.pool.DataSource.class.getName()\n                    + \" , but got \" + dataSource.getClass().getName());\n        }\n    }\n\n    public PgConnection get() throws SQLException {\n        try {\n            return (PgConnection) DriverManager.getDriver(ds.getUrl())\n                    .connect(ds.getUrl(), buildPgConnectionProperties(ds));\n        } catch (SQLException e) {\n            final String msg = \"Cannot acquire Connection from DriverManager: \" + ds.getUrl();\n            log.error(msg, e);\n            throw e;\n        }\n    }\n\n    private void setProperty(Properties dbp, String propertyName, String value) {\n        if (value != null)\n            dbp.setProperty(propertyName, value);\n    }\n\n    @VisibleForTesting\n    Properties buildPgConnectionProperties(org.apache.tomcat.jdbc.pool.DataSource ds) {\n        Properties dbp = new Properties();\n        final PoolConfiguration poolProperties = ds.getPoolProperties();\n        if (poolProperties != null) {\n            setProperty(dbp, \"user\", poolProperties.getUsername());\n            setProperty(dbp, \"password\", poolProperties.getPassword());\n            final String connectionProperties = poolProperties.getConnectionProperties();\n            if (connectionProperties != null) {\n                try {\n                    @SuppressWarnings(\"UnstableApiUsage\")\n                    Map<String, String> singleConnectionProperties = Splitter.on(\";\")\n                            .omitEmptyStrings()\n                            .withKeyValueSeparator(\"=\")\n                            .split(connectionProperties);\n                    setProperty(dbp, \"socketTimeout\", singleConnectionProperties.get(\n                            \"socketTimeout\"));\n                    setProperty(dbp, \"connectTimeout\", singleConnectionProperties.get(\n                            \"connectTimeout\"));\n                    setProperty(dbp, \"loginTimeout\", singleConnectionProperties.get(\n                            \"loginTimeout\"));\n                } catch (IllegalArgumentException e) {\n                    throw new IllegalArgumentException(\"illegal connectionProperties: \"\n                            + connectionProperties);\n                }\n            }\n        }\n        return dbp;\n    }\n}", "class_id": 0, "repo": "uweschaefer/factcast", "file": "factcast-store-pgsql/src/main/java/org/factcast/store/pgsql/internal/listen/PgConnectionSupplier.java", "last_update_at": "2018-03-02T21:44:20+00:00", "question_id": "76448458f8711fbbba7fb5cc7a15d3ff53c075e5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Slf4j\npublic class PgConnectionSupplier {\n    @NonNull\n    @VisibleForTesting\n    protected final org.apache.tomcat.jdbc.pool.DataSource ds;\n    public PgConnectionSupplier(DataSource dataSource) {\n        if (org.apache.tomcat.jdbc.pool.DataSource.class.isAssignableFrom(dataSource.getClass())) {\n            this.ds = (org.apache.tomcat.jdbc.pool.DataSource) dataSource;\n        } else {\n            throw new IllegalArgumentException(\"expected \"\n                    + org.apache.tomcat.jdbc.pool.DataSource.class.getName()\n                    + \" , but got \" + dataSource.getClass().getName());\n        }\n    }\n    public PgConnection get() throws SQLException {\n        try {\n            return (PgConnection) DriverManager.getDriver(ds.getUrl())\n                    .connect(ds.getUrl(), buildPgConnectionProperties(ds));\n        } catch (SQLException e) {\n            final String msg = \"Cannot acquire Connection from DriverManager: \" + ds.getUrl();\n            log.error(msg, e);\n            throw e;\n        }\n    }\n    private void setProperty(Properties dbp, String propertyName, String value) {\n        if (value != null)\n            dbp.setProperty(propertyName, value);\n    }\n    @VisibleForTesting\n    Properties buildPgConnectionProperties(org.apache.tomcat.jdbc.pool.DataSource ds) {\n        Properties dbp = new Properties();\n        final PoolConfiguration poolProperties = ds.getPoolProperties();\n        if (poolProperties != null) {\n            setProperty(dbp, \"user\", poolProperties.getUsername());\n            setProperty(dbp, \"password\", poolProperties.getPassword());\n            final String connectionProperties = poolProperties.getConnectionProperties();\n            if (connectionProperties != null) {\n                try {\n                    @SuppressWarnings(\"UnstableApiUsage\")\n                    Map<String, String> singleConnectionProperties = Splitter.on(\";\")\n                            .omitEmptyStrings()\n                            .withKeyValueSeparator(\"=\")\n                            .split(connectionProperties);\n                    setProperty(dbp, \"socketTimeout\", singleConnectionProperties.get(\n                            \"socketTimeout\"));\n                    setProperty(dbp, \"connectTimeout\", singleConnectionProperties.get(\n                            \"connectTimeout\"));\n                    setProperty(dbp, \"loginTimeout\", singleConnectionProperties.get(\n                            \"loginTimeout\"));\n                } catch (IllegalArgumentException e) {\n                    throw new IllegalArgumentException(\"illegal connectionProperties: \"\n                            + connectionProperties);\n                }\n            }\n        }\n        return dbp;\n    }\n"]], "pred": {"ppl": 1.678116798400879, "ppl_lower": 2.103456735610962, "ppl/lowercase_ppl": -1.4363955409074058, "ppl/zlib": 0.0006671033651343671, "Min_5.0% Prob": 5.7777444794774055, "Min_10.0% Prob": 4.106529159471393, "Min_20.0% Prob": 2.4524420217950214, "Min_30.0% Prob": 1.7036378019172507, "Min_40.0% Prob": 1.290009325470876, "Min_50.0% Prob": 1.034133969705529, "Min_60.0% Prob": 0.8642669574413977}}
{"hexsha": "be7f3ffbfa405aed6884040c4005a3bdff2de4e7", "ext": "java", "lang": "Java", "content": "public class TransparentFetcher implements Fetcher {\n    private boolean convertHttpToPhantomJs;\n    private boolean convertHttpToSelenium;\n\n    private TransparentFetcher() {\n    }\n\n    public static TransparentFetcher getDefault() {\n        return new TransparentFetcher();\n    }\n\n    public static Builder custom() {\n        return new Builder();\n    }\n\n    @Override\n    public Page fetch(Task task) throws FetchException {\n        switch (task.getProtocol()) {\n            case \"http\":\n            case \"https\":\n                if (convertHttpToPhantomJs) {\n                    task.setUrl(\"phantomjs://\".concat(task.getUrl()));\n                } else if (convertHttpToSelenium) {\n                    task.setUrl(\"selenium://\".concat(task.getUrl()));\n                }\n            default:\n                Page page = new Page();\n                task.addVisitCount();\n                page.setTask(task);\n                page.setContent(new byte[0]);\n                page.setContentType(task.getProtocol());\n                return page;\n        }\n    }\n\n    @Override\n    public String[] getAcceptedProtocols() {\n        if (convertHttpToPhantomJs || convertHttpToSelenium) {\n            return new String[]{\"phantomjs\", \"selenium\", \"http\", \"https\"};\n        }\n        return new String[]{\"phantomjs\", \"selenium\"};\n    }\n\n    @Override\n    public String getUserAgent() {\n        return null;\n    }\n\n    public static class Builder {\n        private boolean convertHttpToPhantomJs;\n        private boolean convertHttpToSelenium;\n\n        public Builder convertHttpTaskToPhantomJs() {\n            convertHttpToPhantomJs = true;\n            convertHttpToSelenium = false;\n            return this;\n        }\n\n        public Builder convertHttpTaskToSelenium() {\n            convertHttpToPhantomJs = false;\n            convertHttpToSelenium = true;\n            return this;\n        }\n\n        public TransparentFetcher build() {\n            TransparentFetcher fetcher = new TransparentFetcher();\n            fetcher.convertHttpToPhantomJs = convertHttpToPhantomJs;\n            fetcher.convertHttpToSelenium = convertHttpToSelenium;\n            return fetcher;\n        }\n\n    }\n}", "class_id": 0, "repo": "ZhangJiupeng/Gospy", "file": "src/main/java/cc/gospy/core/fetcher/impl/TransparentFetcher.java", "last_update_at": "2018-06-13T03:27:29+00:00", "question_id": "be7f3ffbfa405aed6884040c4005a3bdff2de4e7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TransparentFetcher implements Fetcher {\n    private boolean convertHttpToPhantomJs;\n    private boolean convertHttpToSelenium;\n    private TransparentFetcher() {\n    }\n    public static TransparentFetcher getDefault() {\n        return new TransparentFetcher();\n    }\n    public static Builder custom() {\n        return new Builder();\n    }\n    @Override\n    public Page fetch(Task task) throws FetchException {\n        switch (task.getProtocol()) {\n            case \"http\":\n            case \"https\":\n                if (convertHttpToPhantomJs) {\n                    task.setUrl(\"phantomjs://\".concat(task.getUrl()));\n                } else if (convertHttpToSelenium) {\n                    task.setUrl(\"selenium://\".concat(task.getUrl()));\n                }\n            default:\n                Page page = new Page();\n                task.addVisitCount();\n                page.setTask(task);\n                page.setContent(new byte[0]);\n                page.setContentType(task.getProtocol());\n                return page;\n        }\n    }\n    @Override\n    public String[] getAcceptedProtocols() {\n        if (convertHttpToPhantomJs || convertHttpToSelenium) {\n            return new String[]{\"phantomjs\", \"selenium\", \"http\", \"https\"};\n        }\n        return new String[]{\"phantomjs\", \"selenium\"};\n    }\n    @Override\n    public String getUserAgent() {\n        return null;\n    }\n    public static class Builder {\n        private boolean convertHttpToPhantomJs;\n        private boolean convertHttpToSelenium;\n        public Builder convertHttpTaskToPhantomJs() {\n            convertHttpToPhantomJs = true;\n            convertHttpToSelenium = false;\n            return this;\n        }\n        public Builder convertHttpTaskToSelenium() {\n            convertHttpToPhantomJs = false;\n            convertHttpToSelenium = true;\n            return this;\n        }\n        public TransparentFetcher build() {\n            TransparentFetcher fetcher = new TransparentFetcher();\n            fetcher.convertHttpToPhantomJs = convertHttpToPhantomJs;\n            fetcher.convertHttpToSelenium = convertHttpToSelenium;\n            return fetcher;\n        }\n    }\n"]], "pred": {"ppl": 1.6870568990707397, "ppl_lower": 1.8044700622558594, "ppl/lowercase_ppl": -1.1286487281590816, "ppl/zlib": 0.0009339027338506645, "Min_5.0% Prob": 6.599892033471002, "Min_10.0% Prob": 4.298795821449973, "Min_20.0% Prob": 2.5155199760740454, "Min_30.0% Prob": 1.7369929304177112, "Min_40.0% Prob": 1.3057347682443747, "Min_50.0% Prob": 1.0471810479884616, "Min_60.0% Prob": 0.873584365723317}}
{"hexsha": "278ee5cb2eef2c2d3b388467e85853492b66d3d1", "ext": "java", "lang": "Java", "content": "public final class StudyConfigurationGenerator extends AbstractTestDataGenerator<StudyConfiguration> {\n\n    public static final AbstractTestDataGenerator<StudyConfiguration> INSTANCE = new StudyConfigurationGenerator();\n\n    private StudyConfigurationGenerator() {\n        super();\n    }\n\n    @Override\n    public void compareFields(StudyConfiguration original, StudyConfiguration retrieved) {\n        assertEquals(original.getStatus(), retrieved.getStatus());\n        assertEquals(original.getVisibility(), retrieved.getVisibility());\n        StudyTestDataGenerator.INSTANCE.compare(original.getStudy(), retrieved.getStudy());\n        assertEquals(original.getClinicalConfigurationCollection().size(), retrieved.getClinicalConfigurationCollection().size());\n        for (int i = 0; i < original.getClinicalConfigurationCollection().size(); i++) {\n            DelimitedTextClinicalSourceConfiguration config1 = (DelimitedTextClinicalSourceConfiguration) original.getClinicalConfigurationCollection().get(i);\n            DelimitedTextClinicalSourceConfiguration config2 = (DelimitedTextClinicalSourceConfiguration) retrieved.getClinicalConfigurationCollection().get(i);\n            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n        assertEquals(original.getGenomicDataSources().size(), retrieved.getGenomicDataSources().size());\n        for (int i = 0; i < original.getGenomicDataSources().size(); i++) {\n            GenomicDataSourceConfiguration config1 = original.getGenomicDataSources().get(i);\n            GenomicDataSourceConfiguration config2 = retrieved.getGenomicDataSources().get(i);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n        assertEquals(original.getImageDataSources().size(), retrieved.getImageDataSources().size());\n        for (int i = 0; i < original.getImageDataSources().size(); i++) {\n            ImageDataSourceConfiguration config1 = original.getImageDataSources().get(i);\n            ImageDataSourceConfiguration config2 = retrieved.getImageDataSources().get(i);\n            ImageDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n    }\n\n    @Override\n    public StudyConfiguration createPersistentObject() {\n        return new StudyConfiguration();\n    }\n\n    @Override\n    public void setValues(StudyConfiguration studyConfiguration, Set<AbstractCaIntegrator2Object> nonCascadedObjects) {\n        studyConfiguration.setStatus(getNewEnumValue(studyConfiguration.getStatus(), Status.values()));\n        studyConfiguration.setVisibility(getNewEnumValue(studyConfiguration.getVisibility(), Visibility.values()));\n        if (studyConfiguration.getStudy() == null) {\n            studyConfiguration.setStudy(StudyTestDataGenerator.INSTANCE.createPersistentObject());\n        }\n        studyConfiguration.getStudy().setStudyConfiguration(studyConfiguration);\n        StudyTestDataGenerator.INSTANCE.setValues(studyConfiguration.getStudy(), nonCascadedObjects);\n        studyConfiguration.getClinicalConfigurationCollection().clear();\n        for (int i = 0; i < 3; i++) {\n            DelimitedTextClinicalSourceConfiguration config = new DelimitedTextClinicalSourceConfiguration(null, studyConfiguration);\n            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        studyConfiguration.getGenomicDataSources().clear();\n        for (int i = 0; i < 3; i++) {\n            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();\n            studyConfiguration.getGenomicDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            config.setDataType(PlatformDataTypeEnum.EXPRESSION);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        for (int i = 0; i < 3; i++) {\n            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();\n            studyConfiguration.getGenomicDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            config.setDataType(PlatformDataTypeEnum.COPY_NUMBER);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        for (int i = 0; i < 3; i++) {\n            ImageDataSourceConfiguration config = new ImageDataSourceConfiguration();\n            studyConfiguration.getImageDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            ImageDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n    }\n\n}", "class_id": 0, "repo": "NCIP/caintegrator", "file": "caintegrator-war/test/src/gov/nih/nci/caintegrator/application/study/StudyConfigurationGenerator.java", "last_update_at": "2018-06-19T16:23:49+00:00", "question_id": "278ee5cb2eef2c2d3b388467e85853492b66d3d1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class StudyConfigurationGenerator extends AbstractTestDataGenerator<StudyConfiguration> {\n    public static final AbstractTestDataGenerator<StudyConfiguration> INSTANCE = new StudyConfigurationGenerator();\n    private StudyConfigurationGenerator() {\n        super();\n    }\n    @Override\n    public void compareFields(StudyConfiguration original, StudyConfiguration retrieved) {\n        assertEquals(original.getStatus(), retrieved.getStatus());\n        assertEquals(original.getVisibility(), retrieved.getVisibility());\n        StudyTestDataGenerator.INSTANCE.compare(original.getStudy(), retrieved.getStudy());\n        assertEquals(original.getClinicalConfigurationCollection().size(), retrieved.getClinicalConfigurationCollection().size());\n        for (int i = 0; i < original.getClinicalConfigurationCollection().size(); i++) {\n            DelimitedTextClinicalSourceConfiguration config1 = (DelimitedTextClinicalSourceConfiguration) original.getClinicalConfigurationCollection().get(i);\n            DelimitedTextClinicalSourceConfiguration config2 = (DelimitedTextClinicalSourceConfiguration) retrieved.getClinicalConfigurationCollection().get(i);\n            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n        assertEquals(original.getGenomicDataSources().size(), retrieved.getGenomicDataSources().size());\n        for (int i = 0; i < original.getGenomicDataSources().size(); i++) {\n            GenomicDataSourceConfiguration config1 = original.getGenomicDataSources().get(i);\n            GenomicDataSourceConfiguration config2 = retrieved.getGenomicDataSources().get(i);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n        assertEquals(original.getImageDataSources().size(), retrieved.getImageDataSources().size());\n        for (int i = 0; i < original.getImageDataSources().size(); i++) {\n            ImageDataSourceConfiguration config1 = original.getImageDataSources().get(i);\n            ImageDataSourceConfiguration config2 = retrieved.getImageDataSources().get(i);\n            ImageDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);\n        }\n    }\n    @Override\n    public StudyConfiguration createPersistentObject() {\n        return new StudyConfiguration();\n    }\n    @Override\n    public void setValues(StudyConfiguration studyConfiguration, Set<AbstractCaIntegrator2Object> nonCascadedObjects) {\n        studyConfiguration.setStatus(getNewEnumValue(studyConfiguration.getStatus(), Status.values()));\n        studyConfiguration.setVisibility(getNewEnumValue(studyConfiguration.getVisibility(), Visibility.values()));\n        if (studyConfiguration.getStudy() == null) {\n            studyConfiguration.setStudy(StudyTestDataGenerator.INSTANCE.createPersistentObject());\n        }\n        studyConfiguration.getStudy().setStudyConfiguration(studyConfiguration);\n        StudyTestDataGenerator.INSTANCE.setValues(studyConfiguration.getStudy(), nonCascadedObjects);\n        studyConfiguration.getClinicalConfigurationCollection().clear();\n        for (int i = 0; i < 3; i++) {\n            DelimitedTextClinicalSourceConfiguration config = new DelimitedTextClinicalSourceConfiguration(null, studyConfiguration);\n            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        studyConfiguration.getGenomicDataSources().clear();\n        for (int i = 0; i < 3; i++) {\n            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();\n            studyConfiguration.getGenomicDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            config.setDataType(PlatformDataTypeEnum.EXPRESSION);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        for (int i = 0; i < 3; i++) {\n            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();\n            studyConfiguration.getGenomicDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            config.setDataType(PlatformDataTypeEnum.COPY_NUMBER);\n            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n        for (int i = 0; i < 3; i++) {\n            ImageDataSourceConfiguration config = new ImageDataSourceConfiguration();\n            studyConfiguration.getImageDataSources().add(config);\n            config.setStudyConfiguration(studyConfiguration);\n            ImageDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);\n        }\n    }\n"]], "pred": {"ppl": 1.4624570608139038, "ppl_lower": 1.5675323009490967, "ppl/lowercase_ppl": -1.1825345588592666, "ppl/zlib": 0.0005021373045780876, "Min_5.0% Prob": 5.295628963732252, "Min_10.0% Prob": 3.4795907472862915, "Min_20.0% Prob": 1.87385757756876, "Min_30.0% Prob": 1.2652483769430736, "Min_40.0% Prob": 0.9495996569925441, "Min_50.0% Prob": 0.7606630570937765, "Min_60.0% Prob": 0.6342557922470365}}
{"hexsha": "9198fc2c9b7d0d2b683f38baf1406c789b3039b1", "ext": "java", "lang": "Java", "content": "@Controller\r\npublic class LoginController {\r\n\t\r\n\t@Autowired\r\n\tprivate AgentInfoValidator agentInfoValidator;\r\n\t\r\n\t@Autowired\r\n\tprivate AgentInfoService agentInfoService;\r\n\t\r\n\t@RequestMapping(value = {\"/\", \"\", \"/login\"})\r\n\tpublic String login(Model model) {\r\n\t\tmodel.addAttribute(\"agent\", new Agent());\r\n\t\treturn \"login\";\r\n\t}\r\n\t\r\n\t@RequestMapping(value = \"/login\", method = RequestMethod.POST)\r\n\tpublic String login(@Validated Agent agent, BindingResult result, Model model,\r\n\t\t\tHttpSession session) {\r\n\r\n\t\tagentInfoValidator.validate(agent, result);\r\n\t\tif (!agentInfoService.verifyAgent(agent) && result.hasErrors()) {\r\n\t\t\treturn \"login\";\r\n\t\t}\r\n\t\tagent=agentInfoService.findById(agent);\r\n\t\tsession.setAttribute(\"agent\", agent);\r\n\t\t\r\n\t\treturn \"redirect:/create\";//\t/\" + agent.getId();\r\n\t}\r\n\r\n}", "class_id": 0, "repo": "Arquisoft/InciManager_i1a", "file": "src/main/java/com/app/controllers/LoginController.java", "last_update_at": "2018-03-12T15:36:03+00:00", "question_id": "9198fc2c9b7d0d2b683f38baf1406c789b3039b1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\r\npublic class LoginController {\r\n\t\r\n\t@Autowired\r\n\tprivate AgentInfoValidator agentInfoValidator;\r\n\t\r\n\t@Autowired\r\n\tprivate AgentInfoService agentInfoService;\r\n\t\r\n\t@RequestMapping(value = {\"/\", \"\", \"/login\"})\r\n\tpublic String login(Model model) {\r\n\t\tmodel.addAttribute(\"agent\", new Agent());\r\n\t\treturn \"login\";\r\n\t}\r\n\t\r\n\t@RequestMapping(value = \"/login\", method = RequestMethod.POST)\r\n\tpublic String login(@Validated Agent agent, BindingResult result, Model model,\r\n\t\t\tHttpSession session) {\r\n\r\n\t\tagentInfoValidator.validate(agent, result);\r\n\t\tif (!agentInfoService.verifyAgent(agent) && result.hasErrors()) {\r\n\t\t\treturn \"login\";\r\n\t\t}\r\n\t\tagent=agentInfoService.findById(agent);\r\n\t\tsession.setAttribute(\"agent\", agent);\r\n\t\t\r\n\t\treturn \"redirect:/create\";//\t/\" + agent.getId();\r\n\t}\r\n\r\n"]], "pred": {"ppl": 2.1276400089263916, "ppl_lower": 2.4044101238250732, "ppl/lowercase_ppl": -1.1619722459996127, "ppl/zlib": 0.0020296058828794495, "Min_5.0% Prob": 6.982037544250488, "Min_10.0% Prob": 5.174069995880127, "Min_20.0% Prob": 3.3408941769599916, "Min_30.0% Prob": 2.3967877240975697, "Min_40.0% Prob": 1.8554509176313878, "Min_50.0% Prob": 1.5021345866024494, "Min_60.0% Prob": 1.2587810846666494}}
{"hexsha": "71359206e8c363e77cd9f23d261e515d46db6c6a", "ext": "java", "lang": "Java", "content": "public class FilterTest {\n\n  @Test\n  public void filterJustCreatedShouldNotBeExpired() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n\n    assertThat(filter.isExpired()).isFalse();\n  }\n\n  @Test\n  public void isExpiredShouldReturnTrueForExpiredFilter() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n    filter.setExpireTime(Instant.now().minusSeconds(1));\n\n    assertThat(filter.isExpired()).isTrue();\n  }\n\n  @Test\n  public void resetExpireDateShouldIncrementExpireDate() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n    filter.setExpireTime(Instant.now().minus(Duration.ofDays(1)));\n    filter.resetExpireTime();\n\n    assertThat(filter.getExpireTime())\n        .isBeforeOrEqualTo(Instant.now().plus(Duration.ofMinutes(10)));\n  }\n}", "class_id": 0, "repo": "mbaxter/pantheon", "file": "ethereum/api/src/test/java/tech/pegasys/pantheon/ethereum/api/jsonrpc/internal/filter/FilterTest.java", "last_update_at": "2018-11-26T16:46:52+00:00", "question_id": "71359206e8c363e77cd9f23d261e515d46db6c6a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class FilterTest {\n  @Test\n  public void filterJustCreatedShouldNotBeExpired() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n    assertThat(filter.isExpired()).isFalse();\n  }\n  @Test\n  public void isExpiredShouldReturnTrueForExpiredFilter() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n    filter.setExpireTime(Instant.now().minusSeconds(1));\n    assertThat(filter.isExpired()).isTrue();\n  }\n  @Test\n  public void resetExpireDateShouldIncrementExpireDate() {\n    final BlockFilter filter = new BlockFilter(\"foo\");\n    filter.setExpireTime(Instant.now().minus(Duration.ofDays(1)));\n    filter.resetExpireTime();\n    assertThat(filter.getExpireTime())\n        .isBeforeOrEqualTo(Instant.now().plus(Duration.ofMinutes(10)));\n  }\n"]], "pred": {"ppl": 2.0010507106781006, "ppl_lower": 2.642364501953125, "ppl/lowercase_ppl": -1.4007680914811915, "ppl/zlib": 0.002400250511931463, "Min_5.0% Prob": 6.767134493047541, "Min_10.0% Prob": 5.047486087550288, "Min_20.0% Prob": 3.138080355968881, "Min_30.0% Prob": 2.247061152969088, "Min_40.0% Prob": 1.7160042934912316, "Min_50.0% Prob": 1.3893358787028198, "Min_60.0% Prob": 1.1549772718947724}}
{"hexsha": "fffc2b06975a35486c445b178e8f8505b695b312", "ext": "java", "lang": "Java", "content": "public class Ball implements Runnable {\n\n    private int x, y;\n    private int diameter;\n    private int rateOfFall;\n    private Color color;\n    private boolean isAlive;\n\n    public Ball(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.diameter = new Random().nextInt(50 - 20 + 1) + 20;\n        this.generateRandomColor();\n        this.setRateOfFall();\n    }\n\n    private void generateRandomColor() {\n        Random random = new Random();\n        float r = random.nextFloat();\n        float g = random.nextFloat();\n        float b = random.nextFloat();\n        this.color = new Color(r, g, b);\n    }\n\n    private void setRateOfFall() {\n        this.rateOfFall = new Random().nextInt(10 - 1 + 1) + 1;\n\n    }\n\n    private int getRateOfFall() {\n        return this.rateOfFall;\n    }\n\n    public int getX() {\n        return this.x;\n    }\n\n    public void setX(final int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return this.y;\n    }\n\n    public void setY(final int y) {\n        this.y = y;\n    }\n\n    public int getDiameter() {\n        return this.diameter;\n    }\n\n    public void setDiameter(int diameter) {\n        this.diameter = diameter;\n    }\n\n    public Color getColor() {\n        return this.color;\n    }\n\n    public void setColor(Color color) {\n        this.color = color;\n    }\n\n\n    @Override\n    public void run() {\n        this.isAlive = true;\n        int end = 398 - getDiameter();\n        for (int i = this.y; i < end; i++) {\n            this.y = i;\n            try {\n                Thread.sleep(this.rateOfFall);\n            } catch (InterruptedException iex) {\n                iex.printStackTrace();\n            }\n        }\n        while (this.color.getRGB() != -1) {\n            this.color = this.color.brighter();\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException iex) {\n                iex.printStackTrace();\n            }\n        }\n        this.isAlive = false;\n    }\n\n    public boolean isAlive() {\n        return this.isAlive;\n    }\n\n    public void setAlive(boolean alive) {\n        isAlive = alive;\n    }\n}", "class_id": 0, "repo": "losil/ad_exercises", "file": "src/main/java/ch/hslu/ad/sw05/ex04/Ball.java", "last_update_at": "2018-04-28T06:42:38+00:00", "question_id": "fffc2b06975a35486c445b178e8f8505b695b312", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Ball implements Runnable {\n    private int x, y;\n    private int diameter;\n    private int rateOfFall;\n    private Color color;\n    private boolean isAlive;\n    public Ball(final int x, final int y) {\n        this.x = x;\n        this.y = y;\n        this.diameter = new Random().nextInt(50 - 20 + 1) + 20;\n        this.generateRandomColor();\n        this.setRateOfFall();\n    }\n    private void generateRandomColor() {\n        Random random = new Random();\n        float r = random.nextFloat();\n        float g = random.nextFloat();\n        float b = random.nextFloat();\n        this.color = new Color(r, g, b);\n    }\n    private void setRateOfFall() {\n        this.rateOfFall = new Random().nextInt(10 - 1 + 1) + 1;\n    }\n    private int getRateOfFall() {\n        return this.rateOfFall;\n    }\n    public int getX() {\n        return this.x;\n    }\n    public void setX(final int x) {\n        this.x = x;\n    }\n    public int getY() {\n        return this.y;\n    }\n    public void setY(final int y) {\n        this.y = y;\n    }\n    public int getDiameter() {\n        return this.diameter;\n    }\n    public void setDiameter(int diameter) {\n        this.diameter = diameter;\n    }\n    public Color getColor() {\n        return this.color;\n    }\n    public void setColor(Color color) {\n        this.color = color;\n    }\n    @Override\n    public void run() {\n        this.isAlive = true;\n        int end = 398 - getDiameter();\n        for (int i = this.y; i < end; i++) {\n            this.y = i;\n            try {\n                Thread.sleep(this.rateOfFall);\n            } catch (InterruptedException iex) {\n                iex.printStackTrace();\n            }\n        }\n        while (this.color.getRGB() != -1) {\n            this.color = this.color.brighter();\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException iex) {\n                iex.printStackTrace();\n            }\n        }\n        this.isAlive = false;\n    }\n    public boolean isAlive() {\n        return this.isAlive;\n    }\n    public void setAlive(boolean alive) {\n        isAlive = alive;\n    }\n"]], "pred": {"ppl": 1.4663466215133667, "ppl_lower": 1.5914188623428345, "ppl/lowercase_ppl": -1.2138388849204436, "ppl/zlib": 0.0006498709946345478, "Min_5.0% Prob": 4.679592782800848, "Min_10.0% Prob": 3.1507826901193874, "Min_20.0% Prob": 1.8354899916631073, "Min_30.0% Prob": 1.2628840817562719, "Min_40.0% Prob": 0.9557027400897117, "Min_50.0% Prob": 0.7644962171847084, "Min_60.0% Prob": 0.6382248623012496}}
{"hexsha": "37f03c2a172bd10071d66a3aa3654b804a7b81dc", "ext": "java", "lang": "Java", "content": "@Component\npublic class UserArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    private SeckillUserService seckillUserService;\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        Class<?> clazz = methodParameter.getParameterType();\n        return clazz == SeckillUser.class;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n//        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);\n//        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);\n//        //\u83b7\u53d6token\n//        String paramToken = request.getParameter(SysConstant.COOKIE_NAME_TOKEN); //\u8bf7\u6c42\u53c2\u6570\u4e0a\u7684token\n//        String cookieToken = CookieUtil.getCookieValue(request, SysConstant.COOKIE_NAME_TOKEN); //cookie\u4e2d\u7684token\n//        if (StringUtils.isEmpty(paramToken) && StringUtils.isEmpty(cookieToken)) {\n//            return null;\n//        }\n//        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;\n//        return seckillUserService.getUserByToken(response, token);\n        return CurrentUserContext.getUser();\n    }\n}", "class_id": 0, "repo": "AnthonyZero/second-kill-action", "file": "src/main/java/com/anthonyzero/seckill/config/UserArgumentResolver.java", "last_update_at": "2018-10-08T01:31:33+00:00", "question_id": "37f03c2a172bd10071d66a3aa3654b804a7b81dc", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Component\npublic class UserArgumentResolver implements HandlerMethodArgumentResolver {\n    @Autowired\n    private SeckillUserService seckillUserService;\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        Class<?> clazz = methodParameter.getParameterType();\n        return clazz == SeckillUser.class;\n    }\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n//        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);\n//        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);\n//        //\u83b7\u53d6token\n//        String paramToken = request.getParameter(SysConstant.COOKIE_NAME_TOKEN); //\u8bf7\u6c42\u53c2\u6570\u4e0a\u7684token\n//        String cookieToken = CookieUtil.getCookieValue(request, SysConstant.COOKIE_NAME_TOKEN); //cookie\u4e2d\u7684token\n//        if (StringUtils.isEmpty(paramToken) && StringUtils.isEmpty(cookieToken)) {\n//            return null;\n//        }\n//        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;\n//        return seckillUserService.getUserByToken(response, token);\n        return CurrentUserContext.getUser();\n    }\n"]], "pred": {"ppl": 1.5920289754867554, "ppl_lower": 2.333028793334961, "ppl/lowercase_ppl": -1.8218288466481445, "ppl/zlib": 0.0008244845530836812, "Min_5.0% Prob": 5.993254016427433, "Min_10.0% Prob": 3.9168501163230225, "Min_20.0% Prob": 2.2134705216569057, "Min_30.0% Prob": 1.529284756630659, "Min_40.0% Prob": 1.1627390974968232, "Min_50.0% Prob": 0.9283953503928861, "Min_60.0% Prob": 0.7754209556741777}}
{"hexsha": "ee6d07bdb8a3eedab88c3bba67dd1536c5f5b84b", "ext": "java", "lang": "Java", "content": "public class AttrDescView_widget_TextView_imeActionId extends AttrDesc<ClassDescViewBased,View,AttrLayoutContext>\r\n{\r\n    public AttrDescView_widget_TextView_imeActionId(ClassDescViewBased parent)\r\n    {\r\n        super(parent,\"imeActionId\");\r\n    }\r\n\r\n    @Override\r\n    public void setAttribute(View view, DOMAttr attr, AttrLayoutContext attrCtx)\r\n    {\r\n        int convertedValue = getInteger(attr.getResourceDesc(),attrCtx.getXMLInflaterContext());\r\n\r\n        TextView textView = (TextView)view;\r\n        textView.setImeActionLabel(textView.getImeActionLabel(),convertedValue);\r\n    }\r\n\r\n    @Override\r\n    public void removeAttribute(View view, AttrLayoutContext attrCtx)\r\n    {\r\n        setAttributeToRemove(view, \"0\",attrCtx);\r\n    }\r\n\r\n}", "class_id": 0, "repo": "jmarranz/itsnat_droid", "file": "itsnatdroid/src/main/java/org/itsnat/droid/impl/xmlinflater/layout/attr/widget/AttrDescView_widget_TextView_imeActionId.java", "last_update_at": "2018-04-19T08:08:18+00:00", "question_id": "ee6d07bdb8a3eedab88c3bba67dd1536c5f5b84b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class AttrDescView_widget_TextView_imeActionId extends AttrDesc<ClassDescViewBased,View,AttrLayoutContext>\r\n{\r\n    public AttrDescView_widget_TextView_imeActionId(ClassDescViewBased parent)\r\n    {\r\n        super(parent,\"imeActionId\");\r\n    }\r\n\r\n    @Override\r\n    public void setAttribute(View view, DOMAttr attr, AttrLayoutContext attrCtx)\r\n    {\r\n        int convertedValue = getInteger(attr.getResourceDesc(),attrCtx.getXMLInflaterContext());\r\n\r\n        TextView textView = (TextView)view;\r\n        textView.setImeActionLabel(textView.getImeActionLabel(),convertedValue);\r\n    }\r\n\r\n    @Override\r\n    public void removeAttribute(View view, AttrLayoutContext attrCtx)\r\n    {\r\n        setAttributeToRemove(view, \"0\",attrCtx);\r\n    }\r\n\r\n"]], "pred": {"ppl": 1.7423967123031616, "ppl_lower": 4.10154914855957, "ppl/lowercase_ppl": -2.5418015188503924, "ppl/zlib": 0.0017739986783272463, "Min_5.0% Prob": 6.481876243244518, "Min_10.0% Prob": 4.510218994183973, "Min_20.0% Prob": 2.6706385869871485, "Min_30.0% Prob": 1.8394570594484156, "Min_40.0% Prob": 1.3945493908091025, "Min_50.0% Prob": 1.1090794225634486, "Min_60.0% Prob": 0.9265299372311989}}
{"hexsha": "766b5bb28758220b4ef7d34efba5875d9eeb6ce3", "ext": "java", "lang": "Java", "content": "public class CodeForces {\n\tpublic static void main (String[] args) throws java.lang.Exception {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int m = scanner.nextInt();\n        String[] words = new String[n]; \n        String[] message = new String[m];\n        int[] cost = new int[n];\n        int x = 0;\n        int[][] groupWordIndices = null;\n\n        for(int i=0; i<n; i++) {\n            words[i] = scanner.next();\n        }\n\n        for(int j=0; j<n; j++) {\n            cost[j] = scanner.nextInt();\n        }\n\n\n        // TODO : Modify \n        for(int z=0; z<k; z++) {\n            x = scanner.nextInt();\n            \n        }\n\n        for(int a=0; a<m; a++) {\n            message[a] = scanner.next();\n        }\n\n        scanner.close();\n\t}\n}", "class_id": 0, "repo": "AbhilashG97/RedWatermelonCake", "file": "CodeForces/Contests/Round #473 (Div. 2)/Mahmoud and Ehab and the message/CodeForces.java", "last_update_at": "2018-10-03T21:09:06+00:00", "question_id": "766b5bb28758220b4ef7d34efba5875d9eeb6ce3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CodeForces {\n\tpublic static void main (String[] args) throws java.lang.Exception {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int m = scanner.nextInt();\n        String[] words = new String[n]; \n        String[] message = new String[m];\n        int[] cost = new int[n];\n        int x = 0;\n        int[][] groupWordIndices = null;\n        for(int i=0; i<n; i++) {\n            words[i] = scanner.next();\n        }\n        for(int j=0; j<n; j++) {\n            cost[j] = scanner.nextInt();\n        }\n        // TODO : Modify \n        for(int z=0; z<k; z++) {\n            x = scanner.nextInt();\n        }\n        for(int a=0; a<m; a++) {\n            message[a] = scanner.next();\n        }\n        scanner.close();\n\t}\n"]], "pred": {"ppl": 2.154292106628418, "ppl_lower": 2.3736016750335693, "ppl/lowercase_ppl": -1.1263206413637827, "ppl/zlib": 0.002376043903368197, "Min_5.0% Prob": 6.515907177558312, "Min_10.0% Prob": 5.1695136847319425, "Min_20.0% Prob": 3.4897036411545495, "Min_30.0% Prob": 2.48179629445076, "Min_40.0% Prob": 1.8886982362378728, "Min_50.0% Prob": 1.5287909839220726, "Min_60.0% Prob": 1.2746038486447298}}
{"hexsha": "ba72a64b2f800c7613d25b00c0f32ec3d04a5603", "ext": "java", "lang": "Java", "content": "@RunWith(Parameterized.class)\npublic class OnnxImportTest extends BaseNd4jTest {\n\n\n    public OnnxImportTest(Nd4jBackend backend) {\n        super(backend);\n    }\n\n\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n\n\n    @After\n    public void tearDown() throws Exception {\n        NativeOpsHolder.getInstance().getDeviceNativeOps().enableDebugMode(false);\n        NativeOpsHolder.getInstance().getDeviceNativeOps().enableVerboseMode(false);\n    }\n\n    @Test\n    public void testOnnxImportEmbedding() throws Exception {\n        /**\n         *\n         */\n        val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource(\"onnx_graphs/embedding_only.onnx\").getInputStream());\n        val embeddingMatrix = importGraph.getVariable(\"2\");\n        assertArrayEquals(new long[] {100,300},embeddingMatrix.getShape());\n       /* val onlyOp = importGraph.getFunctionForVertexId(importGraph.getVariable(\"3\").getVertexId());\n        assertNotNull(onlyOp);\n        assertTrue(onlyOp instanceof Gather);\n*/\n    }\n\n    @Test\n    public void testOnnxImportCnn() throws Exception {\n   /*     val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource(\"onnx_graphs/sm_cnn.onnx\").getFile());\n        assertEquals(20,importGraph.graph().numVertices());\n        val outputTanhOutput = importGraph.getFunctionForVertexId(15);\n        assertNotNull(outputTanhOutput);\n        assertTrue(outputTanhOutput instanceof Tanh);\n\n        val pooling = importGraph.getFunctionForVertexId(16);\n        assertTrue(pooling instanceof MaxPooling2D);\n\n        val poolingCast = (MaxPooling2D) pooling;\n        assertEquals(24,poolingCast.getConfig().getkH());\n        assertEquals(24,poolingCast.getConfig().getkW());*/\n\n    }\n\n\n}", "class_id": 0, "repo": "nutonchain/Deeplearning", "file": "nd4j/nd4j-backends/nd4j-tests/src/test/java/org/nd4j/imports/OnnxImportTest.java", "last_update_at": "2018-11-26T15:30:39+00:00", "question_id": "ba72a64b2f800c7613d25b00c0f32ec3d04a5603", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(Parameterized.class)\npublic class OnnxImportTest extends BaseNd4jTest {\n    public OnnxImportTest(Nd4jBackend backend) {\n        super(backend);\n    }\n    @Override\n    public char ordering() {\n        return 'c';\n    }\n    @After\n    public void tearDown() throws Exception {\n        NativeOpsHolder.getInstance().getDeviceNativeOps().enableDebugMode(false);\n        NativeOpsHolder.getInstance().getDeviceNativeOps().enableVerboseMode(false);\n    }\n    @Test\n    public void testOnnxImportEmbedding() throws Exception {\n        /**\n         *\n         */\n        val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource(\"onnx_graphs/embedding_only.onnx\").getInputStream());\n        val embeddingMatrix = importGraph.getVariable(\"2\");\n        assertArrayEquals(new long[] {100,300},embeddingMatrix.getShape());\n       /* val onlyOp = importGraph.getFunctionForVertexId(importGraph.getVariable(\"3\").getVertexId());\n        assertNotNull(onlyOp);\n        assertTrue(onlyOp instanceof Gather);\n*/\n    }\n    @Test\n    public void testOnnxImportCnn() throws Exception {\n   /*     val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource(\"onnx_graphs/sm_cnn.onnx\").getFile());\n        assertEquals(20,importGraph.graph().numVertices());\n        val outputTanhOutput = importGraph.getFunctionForVertexId(15);\n        assertNotNull(outputTanhOutput);\n        assertTrue(outputTanhOutput instanceof Tanh);\n        val pooling = importGraph.getFunctionForVertexId(16);\n        assertTrue(pooling instanceof MaxPooling2D);\n        val poolingCast = (MaxPooling2D) pooling;\n        assertEquals(24,poolingCast.getConfig().getkH());\n        assertEquals(24,poolingCast.getConfig().getkW());*/\n    }\n"]], "pred": {"ppl": 2.05997633934021, "ppl_lower": 2.9329609870910645, "ppl/lowercase_ppl": -1.4888898324795867, "ppl/zlib": 0.001169408571162376, "Min_5.0% Prob": 6.975647964477539, "Min_10.0% Prob": 5.192120706333833, "Min_20.0% Prob": 3.296272014286004, "Min_30.0% Prob": 2.3362672474090154, "Min_40.0% Prob": 1.7918304991794796, "Min_50.0% Prob": 1.4401890346744182, "Min_60.0% Prob": 1.2047436363698745}}
{"hexsha": "865967dc226c798bbeb8d012ce5b0e506277ef19", "ext": "java", "lang": "Java", "content": "public class DomFileInfo {\n    private int maxColCountInRow;\n    private int minColCountInRow;\n    private int rowCount;\n\n    public boolean isTable(){\n        return maxColCountInRow != 0 && maxColCountInRow == minColCountInRow;\n    }\n\n    public int getColCount(){\n        return minColCountInRow;\n    }\n    public int getRowCount() { return rowCount; }\n\n    public DomFileInfo(){\n        this.maxColCountInRow=0;\n        this.minColCountInRow=Integer.MAX_VALUE;\n        this.rowCount = 0;\n    }\n\n    public void scan(String[] values){\n        maxColCountInRow = Math.max(maxColCountInRow, values.length);\n        minColCountInRow = Math.min(minColCountInRow, values.length);\n        rowCount++;\n    }\n\n    public void scan(DomElement line){\n        scan(line.data);\n    }\n}", "class_id": 0, "repo": "chen0040/java-machine-learning-web-api", "file": "ml-components/sk-dom/src/main/java/com/github/chen0040/sk/dom/basic/DomFileInfo.java", "last_update_at": "2018-12-04T10:01:52+00:00", "question_id": "865967dc226c798bbeb8d012ce5b0e506277ef19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DomFileInfo {\n    private int maxColCountInRow;\n    private int minColCountInRow;\n    private int rowCount;\n    public boolean isTable(){\n        return maxColCountInRow != 0 && maxColCountInRow == minColCountInRow;\n    }\n    public int getColCount(){\n        return minColCountInRow;\n    }\n    public int getRowCount() { return rowCount; }\n    public DomFileInfo(){\n        this.maxColCountInRow=0;\n        this.minColCountInRow=Integer.MAX_VALUE;\n        this.rowCount = 0;\n    }\n    public void scan(String[] values){\n        maxColCountInRow = Math.max(maxColCountInRow, values.length);\n        minColCountInRow = Math.min(minColCountInRow, values.length);\n        rowCount++;\n    }\n    public void scan(DomElement line){\n        scan(line.data);\n    }\n"]], "pred": {"ppl": 2.0142624378204346, "ppl_lower": 2.354585886001587, "ppl/lowercase_ppl": -1.2229362162151656, "ppl/zlib": 0.0025009039020359248, "Min_5.0% Prob": 6.13861608505249, "Min_10.0% Prob": 4.771304939104163, "Min_20.0% Prob": 3.2073916463141745, "Min_30.0% Prob": 2.2766106330173117, "Min_40.0% Prob": 1.743232997232362, "Min_50.0% Prob": 1.402950810002429, "Min_60.0% Prob": 1.169585320652443}}
{"hexsha": "a118177967c8fcc855011eef1276e06e745a43f2", "ext": "java", "lang": "Java", "content": "public class WordCountResource extends ServerResource {\n\n\tprivate static Logger logger = LoggerFactory.getLogger(WordCountResource.class);\n\n\tprivate StreamAnslysisApplication application;\n\n\tprivate String topn = \"\";\n\n\t@Override\n\tpublic void doInit() {\n\t\tapplication = (StreamAnslysisApplication) getApplication();\n\t\ttopn = (String) this.getRequest().getAttributes().get(\"topn\");\n\t\tlogger.info(\"Request Url: \" + URLCodecUtils.decoder(getReference().toString(), \"utf-8\") + \".\");\n\t}\n\n\t@Get(\"json\")\n\tpublic Object retrivalTopNWordCount() {\n\t\tif (topn == null || topn.length() == 0 || !JavaPattern.isAllNum(topn)) {\n\t\t\tlogger.error(\"Params `type` or `datestr` is null.\");\n\t\t\treturn new ErrorResponse.Builder(-1, \"params error!\").build();\n\t\t}\n\t\tList<WordAndCount> wordCounts = application.selectWordCountTopN(Integer.parseInt(topn));\n\t\treturn wordCounts;\n\t}\n\n}", "class_id": 0, "repo": "huge-data/storm-sentiment", "file": "storm-web/src/main/java/zx/soft/storm/web/resource/WordCountResource.java", "last_update_at": "2018-12-28T06:21:01+00:00", "question_id": "a118177967c8fcc855011eef1276e06e745a43f2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WordCountResource extends ServerResource {\n\tprivate static Logger logger = LoggerFactory.getLogger(WordCountResource.class);\n\tprivate StreamAnslysisApplication application;\n\tprivate String topn = \"\";\n\t@Override\n\tpublic void doInit() {\n\t\tapplication = (StreamAnslysisApplication) getApplication();\n\t\ttopn = (String) this.getRequest().getAttributes().get(\"topn\");\n\t\tlogger.info(\"Request Url: \" + URLCodecUtils.decoder(getReference().toString(), \"utf-8\") + \".\");\n\t}\n\t@Get(\"json\")\n\tpublic Object retrivalTopNWordCount() {\n\t\tif (topn == null || topn.length() == 0 || !JavaPattern.isAllNum(topn)) {\n\t\t\tlogger.error(\"Params `type` or `datestr` is null.\");\n\t\t\treturn new ErrorResponse.Builder(-1, \"params error!\").build();\n\t\t}\n\t\tList<WordAndCount> wordCounts = application.selectWordCountTopN(Integer.parseInt(topn));\n\t\treturn wordCounts;\n\t}\n"]], "pred": {"ppl": 3.6853935718536377, "ppl_lower": 4.244629383087158, "ppl/lowercase_ppl": -1.108310059515958, "ppl/zlib": 0.0027752709014843657, "Min_5.0% Prob": 8.562367952786959, "Min_10.0% Prob": 7.262179763228805, "Min_20.0% Prob": 5.1381820635362105, "Min_30.0% Prob": 3.934139422623508, "Min_40.0% Prob": 3.163753944364461, "Min_50.0% Prob": 2.5867248173209205, "Min_60.0% Prob": 2.168672770373972}}
{"hexsha": "3daece8ff6647364edea3069ff398ca62b9589ce", "ext": "java", "lang": "Java", "content": "@JsonInclude(JsonInclude.Include.NON_NULL)\n@Entity\n@Table(name = \"USER_DETAILS\")\npublic class UserDetailsDAO extends AbstractIdentityDAO {\n\n    @Column(name = \"USER_ID\")\n    private String userName;\n\n    @Column(name = \"USER_PASSWORD\")\n    private String password;\n\n    @Column(name = \"USER_FIRST_NAME\")\n    private String userFirstName;\n\n    @Column(name = \"USER_LAST_NAME\")\n    private String userLastName;\n\n    @Column(name = \"USER_LAST_LOGIN\")\n    private Date lastSignInTime;\n\n    @Column(name = \"USER_ADDRESS\")\n    private String userAddress;\n\n    @Column(name = \"USER_CITY\")\n    private String userCity;\n\n    @Column(name = \"USER_PINCODE\")\n    private Integer userPostalCode;\n\n    @Column(name = \"USER_STATE\")\n    private String userState;\n\n    @Column(name = \"USER_COUNTRY\")\n    private String userCountry;\n\n    private UserDetailsDAO() {\n\n    }\n\n    private UserDetailsDAO(Builder builder) {\n        setId(builder.id);\n        setUserName(builder.userName);\n        setPassword(builder.password);\n        setUserFirstName(builder.userFirstName);\n        setUserLastName(builder.userLastName);\n        setLastSignInTime(builder.lastSignInTime);\n        setUserAddress(builder.userAddress);\n        setUserCity(builder.userCity);\n        setUserPostalCode(builder.userPostalCode);\n        setUserState(builder.userState);\n        setUserCountry(builder.userCountry);\n    }\n\n    public static Builder newBuilder() {\n        return new Builder();\n    }\n\n    public static Builder newAddUserBuilder(UserDTO userDTo) {\n        java.sql.Date sqlDate = new java.sql.Date(Calendar.getInstance().getTime().getTime());\n        Builder builder = new Builder();\n        builder.userName = userDTo.getUserName();\n        builder.password = userDTo.getPassword();\n        builder.userFirstName = userDTo.getUserFirstName();\n        builder.userLastName = userDTo.getUserLastName();\n        builder.userAddress = userDTo.getUserAddress();\n        builder.userPostalCode = userDTo.getUserPostalCode();\n        builder.userCity = userDTo.getUserCity();\n        builder.userState = userDTo.getUserState();\n        builder.userCountry = userDTo.getUserCountry();\n        builder.lastSignInTime = sqlDate;\n        return builder;\n    }\n\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getUserFirstName() {\n        return userFirstName;\n    }\n\n    public void setUserFirstName(String userFirstName) {\n        this.userFirstName = userFirstName;\n    }\n\n    public String getUserLastName() {\n        return userLastName;\n    }\n\n    public void setUserLastName(String userLastName) {\n        this.userLastName = userLastName;\n    }\n\n    public Date getLastSignInTime() {\n        return lastSignInTime;\n    }\n\n    public void setLastSignInTime(Date lastSignInTime) {\n        this.lastSignInTime = lastSignInTime;\n    }\n\n    public String getUserAddress() {\n        return userAddress;\n    }\n\n    public void setUserAddress(String userAddress) {\n        this.userAddress = userAddress;\n    }\n\n    public String getUserCity() {\n        return userCity;\n    }\n\n    public void setUserCity(String userCity) {\n        this.userCity = userCity;\n    }\n\n    public Integer getUserPostalCode() {\n        return userPostalCode;\n    }\n\n    public void setUserPostalCode(Integer userPostalCode) {\n        this.userPostalCode = userPostalCode;\n    }\n\n    public String getUserState() {\n        return userState;\n    }\n\n    public void setUserState(String userState) {\n        this.userState = userState;\n    }\n\n    public String getUserCountry() {\n        return userCountry;\n    }\n\n    public void setUserCountry(String userCountry) {\n        this.userCountry = userCountry;\n    }\n\n\n    public static final class Builder {\n        private Integer id;\n        private String userName;\n        private String password;\n        private String userFirstName;\n        private String userLastName;\n        private Date lastSignInTime;\n        private String userAddress;\n        private String userCity;\n        private Integer userPostalCode;\n        private String userState;\n        private String userCountry;\n\n        private Builder() {\n        }\n\n        public Builder withId(Integer id) {\n            this.id = id;\n            return this;\n        }\n\n        public Builder withUserName(String userName) {\n            this.userName = userName;\n            return this;\n        }\n\n        public Builder withPassword(String password) {\n            this.password = password;\n            return this;\n        }\n\n        public Builder withUserFirstName(String userFirstName) {\n            this.userFirstName = userFirstName;\n            return this;\n        }\n\n        public Builder withUserLastName(String userLastName) {\n            this.userLastName = userLastName;\n            return this;\n        }\n\n        public Builder withLastSignInTime(Date lastSignInTime) {\n            this.lastSignInTime = lastSignInTime;\n            return this;\n        }\n\n        public Builder withUserAddress(String userAddress) {\n            this.userAddress = userAddress;\n            return this;\n        }\n\n        public Builder withUserCity(String userCity) {\n            this.userCity = userCity;\n            return this;\n        }\n\n        public Builder withUserPostalCode(Integer userPostalCode) {\n            this.userPostalCode = userPostalCode;\n            return this;\n        }\n\n        public Builder withUserState(String userState) {\n            this.userState = userState;\n            return this;\n        }\n\n        public Builder withUserCountry(String userCountry) {\n            this.userCountry = userCountry;\n            return this;\n        }\n\n        public UserDetailsDAO build() {\n            return new UserDetailsDAO(this);\n        }\n    }\n}", "class_id": 0, "repo": "yogeshbhuse/SpringBoot", "file": "src/main/java/com/yogesh/spring/entity/user/UserDetailsDAO.java", "last_update_at": "2018-06-22T07:03:35+00:00", "question_id": "3daece8ff6647364edea3069ff398ca62b9589ce", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@JsonInclude(JsonInclude.Include.NON_NULL)\n@Entity\n@Table(name = \"USER_DETAILS\")\npublic class UserDetailsDAO extends AbstractIdentityDAO {\n    @Column(name = \"USER_ID\")\n    private String userName;\n    @Column(name = \"USER_PASSWORD\")\n    private String password;\n    @Column(name = \"USER_FIRST_NAME\")\n    private String userFirstName;\n    @Column(name = \"USER_LAST_NAME\")\n    private String userLastName;\n    @Column(name = \"USER_LAST_LOGIN\")\n    private Date lastSignInTime;\n    @Column(name = \"USER_ADDRESS\")\n    private String userAddress;\n    @Column(name = \"USER_CITY\")\n    private String userCity;\n    @Column(name = \"USER_PINCODE\")\n    private Integer userPostalCode;\n    @Column(name = \"USER_STATE\")\n    private String userState;\n    @Column(name = \"USER_COUNTRY\")\n    private String userCountry;\n    private UserDetailsDAO() {\n    }\n    private UserDetailsDAO(Builder builder) {\n        setId(builder.id);\n        setUserName(builder.userName);\n        setPassword(builder.password);\n        setUserFirstName(builder.userFirstName);\n        setUserLastName(builder.userLastName);\n        setLastSignInTime(builder.lastSignInTime);\n        setUserAddress(builder.userAddress);\n        setUserCity(builder.userCity);\n        setUserPostalCode(builder.userPostalCode);\n        setUserState(builder.userState);\n        setUserCountry(builder.userCountry);\n    }\n    public static Builder newBuilder() {\n        return new Builder();\n    }\n    public static Builder newAddUserBuilder(UserDTO userDTo) {\n        java.sql.Date sqlDate = new java.sql.Date(Calendar.getInstance().getTime().getTime());\n        Builder builder = new Builder();\n        builder.userName = userDTo.getUserName();\n        builder.password = userDTo.getPassword();\n        builder.userFirstName = userDTo.getUserFirstName();\n        builder.userLastName = userDTo.getUserLastName();\n        builder.userAddress = userDTo.getUserAddress();\n        builder.userPostalCode = userDTo.getUserPostalCode();\n        builder.userCity = userDTo.getUserCity();\n        builder.userState = userDTo.getUserState();\n        builder.userCountry = userDTo.getUserCountry();\n        builder.lastSignInTime = sqlDate;\n        return builder;\n    }\n    public String getUserName() {\n        return userName;\n    }\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n    public String getPassword() {\n        return password;\n    }\n    public void setPassword(String password) {\n        this.password = password;\n    }\n    public String getUserFirstName() {\n        return userFirstName;\n    }\n    public void setUserFirstName(String userFirstName) {\n        this.userFirstName = userFirstName;\n    }\n    public String getUserLastName() {\n        return userLastName;\n    }\n    public void setUserLastName(String userLastName) {\n        this.userLastName = userLastName;\n    }\n    public Date getLastSignInTime() {\n        return lastSignInTime;\n    }\n    public void setLastSignInTime(Date lastSignInTime) {\n        this.lastSignInTime = lastSignInTime;\n    }\n    public String getUserAddress() {\n        return userAddress;\n    }\n    public void setUserAddress(String userAddress) {\n        this.userAddress = userAddress;\n    }\n    public String getUserCity() {\n        return userCity;\n    }\n    public void setUserCity(String userCity) {\n        this.userCity = userCity;\n    }\n    public Integer getUserPostalCode() {\n        return userPostalCode;\n    }\n    public void setUserPostalCode(Integer userPostalCode) {\n        this.userPostalCode = userPostalCode;\n    }\n    public String getUserState() {\n        return userState;\n    }\n    public void setUserState(String userState) {\n        this.userState = userState;\n    }\n    public String getUserCountry() {\n        return userCountry;\n    }\n    public void setUserCountry(String userCountry) {\n        this.userCountry = userCountry;\n    }\n    public static final class Builder {\n        private Integer id;\n        private String userName;\n        private String password;\n        private String userFirstName;\n        private String userLastName;\n        private Date lastSignInTime;\n        private String userAddress;\n        private String userCity;\n        private Integer userPostalCode;\n        private String userState;\n        private String userCountry;\n        private Builder() {\n        }\n        public Builder withId(Integer id) {\n            this.id = id;\n            return this;\n        }\n        public Builder withUserName(String userName) {\n            this.userName = userName;\n            return this;\n        }\n        public Builder withPassword(String password) {\n            this.password = password;\n            return this;\n        }\n        public Builder withUserFirstName(String userFirstName) {\n            this.userFirstName = userFirstName;\n            return this;\n        }\n        public Builder withUserLastName(String userLastName) {\n            this.userLastName = userLastName;\n            return this;\n        }\n        public Builder withLastSignInTime(Date lastSignInTime) {\n            this.lastSignInTime = lastSignInTime;\n            return this;\n        }\n        public Builder withUserAddress(String userAddress) {\n            this.userAddress = userAddress;\n            return this;\n        }\n        public Builder withUserCity(String userCity) {\n            this.userCity = userCity;\n            return this;\n        }\n        public Builder withUserPostalCode(Integer userPostalCode) {\n            this.userPostalCode = userPostalCode;\n            return this;\n        }\n        public Builder withUserState(String userState) {\n            this.userState = userState;\n            return this;\n        }\n        public Builder withUserCountry(String userCountry) {\n            this.userCountry = userCountry;\n            return this;\n        }\n        public UserDetailsDAO build() {\n            return new UserDetailsDAO(this);\n        }\n    }\n"]], "pred": {"ppl": 1.2451069355010986, "ppl_lower": 1.3630850315093994, "ppl/lowercase_ppl": -1.412957451282162, "ppl/zlib": 0.0002068126586763405, "Min_5.0% Prob": 3.7411839693200353, "Min_10.0% Prob": 2.111075011684614, "Min_20.0% Prob": 1.091345590338403, "Min_30.0% Prob": 0.731344789841815, "Min_40.0% Prob": 0.5479136983844655, "Min_50.0% Prob": 0.4387547407186966, "Min_60.0% Prob": 0.3658090066047937}}
{"hexsha": "f5c355d28bf19d10fc64b0c03d7862632fd13a40", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"unused\")\r\n\r\npublic class ProductoEstadisticaModel extends FocusTraversalPolicy implements TableModel, Serializable,PropertyChangeListener  {\t\r\n\t\tprivate static final long serialVersionUID = 1L;\r\n\t\t\r\n\t\tpublic JInternalFrameBase jInternalFrameBase;\r\n\t\t\r\n\t    private String[] columnNames = {\r\n\t\t\t\t\t\t\t\t\t\tConstantes2.S_SELECCIONAR\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_ID\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDEMPRESA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDSUCURSAL\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDBODEGA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDPRODUCTO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOTIZACION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAPROFORMA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDISPONIBLE\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADRESERVADA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDEMANDA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMAXIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMINIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADFISICA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADORDENCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADPEDIDA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADREQUISICION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAINGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAEGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPRODUCCION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMACOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMADEVOLUCION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAORDENCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPEDIDO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAREQUISICION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALINGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALEGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALPRODUCIDO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALDEVUELTO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOULTIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOTOTAL\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOPRODUCCION\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t   \r\n\t    public List<ProductoEstadistica> productoestadisticas;\r\n\t  \t \r\n\t    //NO SE UTILIZA\r\n\t    public ProductoEstadisticaModel(List<ProductoEstadistica> productoestadisticas,JInternalFrameBase jInternalFrameBase) {\r\n\t    \tthis.productoestadisticas=productoestadisticas;\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t    }\r\n\t    \r\n\t    public ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {\r\n\t    \tthis.productoestadisticas=new ArrayList<ProductoEstadistica>();\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t    }\t    \t    \r\n\t    \r\n\t    @Override\r\n\t    public String getColumnName(int columnIndex) {\r\n\t    \treturn columnNames[columnIndex];\t    \t\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public int getRowCount() {\r\n\t        return this.productoestadisticas.size();\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public int getColumnCount() {\t    \t\r\n\t        return this.columnNames.length;\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public Object getValueAt(int rowIndex, int columnIndex) {\r\n\t        switch (columnIndex) {\r\n\t\t\t\tcase 0: return this.productoestadisticas.get(rowIndex).getIsSelected();\r\n\t            \r\n\t\t\t\tcase 1: return this.productoestadisticas.get(rowIndex).getId();\r\n\t\t\t\tcase 2: return this.productoestadisticas.get(rowIndex).getid_empresa();\r\n\t\t\t\tcase 3: return this.productoestadisticas.get(rowIndex).getid_sucursal();\r\n\t\t\t\tcase 4: return this.productoestadisticas.get(rowIndex).getid_bodega();\r\n\t\t\t\tcase 5: return this.productoestadisticas.get(rowIndex).getid_producto();\r\n\t\t\t\tcase 6: return this.productoestadisticas.get(rowIndex).getprecio_ultima_compra();\r\n\t\t\t\tcase 7: return this.productoestadisticas.get(rowIndex).getprecio_ultima_venta();\r\n\t\t\t\tcase 8: return this.productoestadisticas.get(rowIndex).getprecio_ultima_cotizacion();\r\n\t\t\t\tcase 9: return this.productoestadisticas.get(rowIndex).getprecio_ultima_proforma();\r\n\t\t\t\tcase 10: return this.productoestadisticas.get(rowIndex).getcantidad_disponible();\r\n\t\t\t\tcase 11: return this.productoestadisticas.get(rowIndex).getcantidad_reservada();\r\n\t\t\t\tcase 12: return this.productoestadisticas.get(rowIndex).getcantidad_demanda();\r\n\t\t\t\tcase 13: return this.productoestadisticas.get(rowIndex).getcantidad_maximo();\r\n\t\t\t\tcase 14: return this.productoestadisticas.get(rowIndex).getcantidad_minimo();\r\n\t\t\t\tcase 15: return this.productoestadisticas.get(rowIndex).getcantidad_fisica();\r\n\t\t\t\tcase 16: return this.productoestadisticas.get(rowIndex).getcantidad_orden_compra();\r\n\t\t\t\tcase 17: return this.productoestadisticas.get(rowIndex).getcantidad_pedida();\r\n\t\t\t\tcase 18: return this.productoestadisticas.get(rowIndex).getcantidad_requisicion();\r\n\t\t\t\tcase 19: return this.productoestadisticas.get(rowIndex).getfecha_ultima_ingreso();\r\n\t\t\t\tcase 20: return this.productoestadisticas.get(rowIndex).getfecha_ultima_egreso();\r\n\t\t\t\tcase 21: return this.productoestadisticas.get(rowIndex).getfecha_ultima_produccion();\r\n\t\t\t\tcase 22: return this.productoestadisticas.get(rowIndex).getfecha_ultima_compra();\r\n\t\t\t\tcase 23: return this.productoestadisticas.get(rowIndex).getfecha_ultima_venta();\r\n\t\t\t\tcase 24: return this.productoestadisticas.get(rowIndex).getfecha_ultima_devolucion();\r\n\t\t\t\tcase 25: return this.productoestadisticas.get(rowIndex).getfecha_ultima_orden_compra();\r\n\t\t\t\tcase 26: return this.productoestadisticas.get(rowIndex).getfecha_ultima_pedido();\r\n\t\t\t\tcase 27: return this.productoestadisticas.get(rowIndex).getfecha_ultima_requisicion();\r\n\t\t\t\tcase 28: return this.productoestadisticas.get(rowIndex).gettotal_ingreso();\r\n\t\t\t\tcase 29: return this.productoestadisticas.get(rowIndex).gettotal_egreso();\r\n\t\t\t\tcase 30: return this.productoestadisticas.get(rowIndex).gettotal_compra();\r\n\t\t\t\tcase 31: return this.productoestadisticas.get(rowIndex).gettotal_venta();\r\n\t\t\t\tcase 32: return this.productoestadisticas.get(rowIndex).gettotal_producido();\r\n\t\t\t\tcase 33: return this.productoestadisticas.get(rowIndex).gettotal_devuelto();\r\n\t\t\t\tcase 34: return this.productoestadisticas.get(rowIndex).getcosto_ultimo();\r\n\t\t\t\tcase 35: return this.productoestadisticas.get(rowIndex).getcosto_total();\r\n\t\t\t\tcase 36: return this.productoestadisticas.get(rowIndex).getcosto_produccion();\t            \r\n\t            default: return null;\r\n\t        }\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public Class<?> getColumnClass(int columnIndex) {\r\n\t    \tswitch (columnIndex) {\r\n\t\t\t\tcase 0: return Boolean.class;\r\n\t            \r\n\t\t\t\tcase 1: return Long.class;\r\n\t\t\t\tcase 2: return Long.class;\r\n\t\t\t\tcase 3: return Long.class;\r\n\t\t\t\tcase 4: return Long.class;\r\n\t\t\t\tcase 5: return Long.class;\r\n\t\t\t\tcase 6: return Double.class;\r\n\t\t\t\tcase 7: return Double.class;\r\n\t\t\t\tcase 8: return Double.class;\r\n\t\t\t\tcase 9: return Double.class;\r\n\t\t\t\tcase 10: return Integer.class;\r\n\t\t\t\tcase 11: return Double.class;\r\n\t\t\t\tcase 12: return Double.class;\r\n\t\t\t\tcase 13: return Integer.class;\r\n\t\t\t\tcase 14: return Integer.class;\r\n\t\t\t\tcase 15: return Double.class;\r\n\t\t\t\tcase 16: return Double.class;\r\n\t\t\t\tcase 17: return Double.class;\r\n\t\t\t\tcase 18: return Double.class;\r\n\t\t\t\tcase 19: return Date.class;\r\n\t\t\t\tcase 20: return Date.class;\r\n\t\t\t\tcase 21: return Date.class;\r\n\t\t\t\tcase 22: return Date.class;\r\n\t\t\t\tcase 23: return Date.class;\r\n\t\t\t\tcase 24: return Date.class;\r\n\t\t\t\tcase 25: return Date.class;\r\n\t\t\t\tcase 26: return Date.class;\r\n\t\t\t\tcase 27: return Date.class;\r\n\t\t\t\tcase 28: return Double.class;\r\n\t\t\t\tcase 29: return Double.class;\r\n\t\t\t\tcase 30: return Double.class;\r\n\t\t\t\tcase 31: return Double.class;\r\n\t\t\t\tcase 32: return Double.class;\r\n\t\t\t\tcase 33: return Double.class;\r\n\t\t\t\tcase 34: return Double.class;\r\n\t\t\t\tcase 35: return Double.class;\r\n\t\t\t\tcase 36: return Double.class;\t            \r\n\t            default: return String.class;\r\n\t        }\t    \t\t        \r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public boolean isCellEditable(int rowIndex, int columnIndex) {\r\n\t    \tswitch (columnIndex) {\r\n\t\t\t\tcase 0: return true;\r\n            \t\r\n\t\t\t\tcase 1: return true;\r\n\t\t\t\tcase 2: return true;\r\n\t\t\t\tcase 3: return true;\r\n\t\t\t\tcase 4: return true;\r\n\t\t\t\tcase 5: return true;\r\n\t\t\t\tcase 6: return true;\r\n\t\t\t\tcase 7: return true;\r\n\t\t\t\tcase 8: return true;\r\n\t\t\t\tcase 9: return true;\r\n\t\t\t\tcase 10: return true;\r\n\t\t\t\tcase 11: return true;\r\n\t\t\t\tcase 12: return true;\r\n\t\t\t\tcase 13: return true;\r\n\t\t\t\tcase 14: return true;\r\n\t\t\t\tcase 15: return true;\r\n\t\t\t\tcase 16: return true;\r\n\t\t\t\tcase 17: return true;\r\n\t\t\t\tcase 18: return true;\r\n\t\t\t\tcase 19: return true;\r\n\t\t\t\tcase 20: return true;\r\n\t\t\t\tcase 21: return true;\r\n\t\t\t\tcase 22: return true;\r\n\t\t\t\tcase 23: return true;\r\n\t\t\t\tcase 24: return true;\r\n\t\t\t\tcase 25: return true;\r\n\t\t\t\tcase 26: return true;\r\n\t\t\t\tcase 27: return true;\r\n\t\t\t\tcase 28: return true;\r\n\t\t\t\tcase 29: return true;\r\n\t\t\t\tcase 30: return true;\r\n\t\t\t\tcase 31: return true;\r\n\t\t\t\tcase 32: return true;\r\n\t\t\t\tcase 33: return true;\r\n\t\t\t\tcase 34: return true;\r\n\t\t\t\tcase 35: return true;\r\n\t\t\t\tcase 36: return true;\t            \r\n\t            default: return true;\r\n\t        }\t\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public void setValueAt(Object value, int rowIndex, int columnIndex) {\r\n\t    \tProductoEstadistica productoestadistica = this.productoestadisticas.get(rowIndex);\r\n\t    \tBoolean esCampoValor=false;\r\n\t\t\tString sTipo=\"\";\r\n\t\t\t\r\n\t\t\tProductoEstadisticaBeanSwingJInternalFrame productoestadisticaBeanSwingJInternalFrame=(ProductoEstadisticaBeanSwingJInternalFrame)this.jInternalFrameBase; \r\n\t\t\t\r\n\t        switch (columnIndex) {\r\n\t\t\t\tcase 0: try {productoestadistica.setIsSelected((Boolean) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t            \r\n\t\t\t\tcase 1: try {productoestadistica.setId((Long) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 2: try {productoestadistica.setid_empresa((Long) value);productoestadistica.setempresa_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualEmpresaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 3: try {productoestadistica.setid_sucursal((Long) value);productoestadistica.setsucursal_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualSucursalForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 4: try {productoestadistica.setid_bodega((Long) value);productoestadistica.setbodega_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualBodegaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 5: try {productoestadistica.setid_producto((Long) value);productoestadistica.setproducto_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualProductoForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 6: try {productoestadistica.setprecio_ultima_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 7: try {productoestadistica.setprecio_ultima_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 8: try {productoestadistica.setprecio_ultima_cotizacion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 9: try {productoestadistica.setprecio_ultima_proforma((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 10: try {productoestadistica.setcantidad_disponible((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 11: try {productoestadistica.setcantidad_reservada((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 12: try {productoestadistica.setcantidad_demanda((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 13: try {productoestadistica.setcantidad_maximo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 14: try {productoestadistica.setcantidad_minimo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 15: try {productoestadistica.setcantidad_fisica((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 16: try {productoestadistica.setcantidad_orden_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 17: try {productoestadistica.setcantidad_pedida((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 18: try {productoestadistica.setcantidad_requisicion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 19: try {productoestadistica.setfecha_ultima_ingreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 20: try {productoestadistica.setfecha_ultima_egreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 21: try {productoestadistica.setfecha_ultima_produccion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 22: try {productoestadistica.setfecha_ultima_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 23: try {productoestadistica.setfecha_ultima_venta((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 24: try {productoestadistica.setfecha_ultima_devolucion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 25: try {productoestadistica.setfecha_ultima_orden_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 26: try {productoestadistica.setfecha_ultima_pedido((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 27: try {productoestadistica.setfecha_ultima_requisicion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 28: try {productoestadistica.settotal_ingreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 29: try {productoestadistica.settotal_egreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 30: try {productoestadistica.settotal_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 31: try {productoestadistica.settotal_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 32: try {productoestadistica.settotal_producido((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 33: try {productoestadistica.settotal_devuelto((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 34: try {productoestadistica.setcosto_ultimo((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 35: try {productoestadistica.setcosto_total((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 36: try {productoestadistica.setcosto_produccion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t        }\r\n\t        \r\n\t        fireTableCellUpdated(rowIndex, columnIndex);\r\n\t\t\t\r\n\t\t\tif(esCampoValor) {\r\n\t\t\t\tjInternalFrameBase.procesoActualizarFilaTotales(esCampoValor,sTipo);\r\n\t\t\t}\r\n\t    }\r\n\t\t\r\n\t\t\r\n\t\t//PARTE PARA EL PROPERTYVALORCHANGELISTENER\r\n\t\t//public JInternalFrameBase jInternalFrameBase;\r\n\t\t/*\r\n\t\tpublic ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t\t}\r\n\t\t*/\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic void propertyChange(PropertyChangeEvent evt) {\r\n\t\t\ttry {\r\n\t\t\t\tthis.jInternalFrameBase.procesoActualizarFilaTotales();\r\n\t\t\t\t\t\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\t//PARTE PARA EL PROPERTYVALORCHANGELISTENER FIN\r\n\t\t\r\n\t\t\t\r\n\t\t/*FUNCIONES PARA FOCUS TRAVERSAL POLICY*/\r\n\t\t\r\n\t\tprivate Component componentTab=new JTextField();\r\n\t\tprivate ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame=null;\r\n\t\t\r\n\t\tpublic ProductoEstadisticaModel(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {\r\n\t\t\tthis.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentAfter(Container focusCycleRoot, Component component) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\t\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\t\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentBefore(Container focusCycleRoot, Component component) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();\r\n\t\t\t\t\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {\r\n\t\t\t\t\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\t\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getDefaultComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getFirstComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getLastComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic ProductoEstadisticaDetalleFormJInternalFrame getproductoestadisticaJInternalFrame() {\r\n\t\t\treturn this.productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void setproductoestadisticaJInternalFrame(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {\r\n\t\t\tthis.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentTab() {\r\n\t\t\treturn this.componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void setComponentTab(Component componentTab) {\r\n\t\t\tthis.componentTab=componentTab;\r\n\t\t}\r\n\t\t/*FUNCIONES PARA FOCUS TRAVERSAL POLICY FIN*/\r\n\t\t\r\n\t\t\r\n\t\t/*FUNCIONES PARA AbstractTableModel*/\r\n\t\t/*\r\n\t\tNotas:\r\n\t\t* Si Cambia version se copia variables y metodos que no son sobreescritos en esta clase.(Usa Jdk 8)\r\n\t\t* Se copia del Jdk javax.swing.table.AbstractTableModel\r\n\t\t* Los argumentos usados es de tipo Interface TableModel no de Clase AbstractTableModel\r\n\t\t* Si se cambia y/o actualiza jdj, toca actualizar el c\u00f3digo nuevamente\r\n\t\t*/\r\n\t\t\r\n\t\tprotected EventListenerList listenerList = new EventListenerList();\r\n\r\n\t\tpublic int findColumn(String columnName) {\r\n\t\t\tfor (int i = 0; i < getColumnCount(); i++) {\r\n\t\t\t\tif (columnName.equals(getColumnName(i))) {\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void addTableModelListener(TableModelListener l) {\r\n        \tlistenerList.add(TableModelListener.class, l);\r\n    \t}\r\n\t\t\r\n\t\tpublic void removeTableModelListener(TableModelListener l) {\r\n        \tlistenerList.remove(TableModelListener.class, l);\r\n    \t}\r\n\t\t\r\n\t\tpublic TableModelListener[] getTableModelListeners() {\r\n\t\t\treturn listenerList.getListeners(TableModelListener.class);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableDataChanged() {\r\n\t\t\tfireTableChanged(new TableModelEvent(this));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableStructureChanged() {\r\n        \tfireTableChanged(new TableModelEvent(this, TableModelEvent.HEADER_ROW));\r\n    \t}\r\n\t\t\r\n\t\tpublic void fireTableRowsInserted(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));\r\n\t\t}\r\n\t\r\n\t\tpublic void fireTableRowsUpdated(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableRowsDeleted(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));\r\n\t\t}\r\n\t\r\n\t\tpublic void fireTableCellUpdated(int row, int column) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, row, row, column));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableChanged(TableModelEvent e) {\r\n\t\t\t// Guaranteed to return a non-null array\r\n\t\t\tObject[] listeners = listenerList.getListenerList();\r\n\t\t\t// Process the listeners last to first, notifying\r\n\t\t\t// those that are interested in this event\r\n\t\t\tfor (int i = listeners.length-2; i>=0; i-=2) {\r\n\t\t\t\tif (listeners[i]==TableModelListener.class) {\r\n\t\t\t\t\t((TableModelListener)listeners[i+1]).tableChanged(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic <T extends EventListener> T[] getListeners(Class<T> listenerType) {\r\n\t\t\treturn listenerList.getListeners(listenerType);\r\n\t\t}\r\n\t\t/*FUNCIONES PARA AbstractTableModel FIN*/\r\n}", "class_id": 0, "repo": "jarocho105/pre2", "file": "erp_desktop_all/src_inventario/com/bydan/erp/inventario/presentation/swing/jinternalframes/auxiliar/ProductoEstadisticaModel.java", "last_update_at": "2018-01-05T17:50:03+00:00", "question_id": "f5c355d28bf19d10fc64b0c03d7862632fd13a40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"unused\")\r\n\r\npublic class ProductoEstadisticaModel extends FocusTraversalPolicy implements TableModel, Serializable,PropertyChangeListener  {\t\r\n\t\tprivate static final long serialVersionUID = 1L;\r\n\t\t\r\n\t\tpublic JInternalFrameBase jInternalFrameBase;\r\n\t\t\r\n\t    private String[] columnNames = {\r\n\t\t\t\t\t\t\t\t\t\tConstantes2.S_SELECCIONAR\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_ID\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDEMPRESA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDSUCURSAL\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDBODEGA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_IDPRODUCTO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOTIZACION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAPROFORMA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDISPONIBLE\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADRESERVADA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDEMANDA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMAXIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMINIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADFISICA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADORDENCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADPEDIDA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADREQUISICION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAINGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAEGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPRODUCCION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMACOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMADEVOLUCION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAORDENCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPEDIDO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAREQUISICION\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALINGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALEGRESO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALCOMPRA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALVENTA\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALPRODUCIDO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_TOTALDEVUELTO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOULTIMO\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOTOTAL\r\n\t\t\t\t\t\t\t\t\t\t,ProductoEstadisticaConstantesFunciones.LABEL_COSTOPRODUCCION\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t   \r\n\t    public List<ProductoEstadistica> productoestadisticas;\r\n\t  \t \r\n\t    //NO SE UTILIZA\r\n\t    public ProductoEstadisticaModel(List<ProductoEstadistica> productoestadisticas,JInternalFrameBase jInternalFrameBase) {\r\n\t    \tthis.productoestadisticas=productoestadisticas;\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t    }\r\n\t    \r\n\t    public ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {\r\n\t    \tthis.productoestadisticas=new ArrayList<ProductoEstadistica>();\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t    }\t    \t    \r\n\t    \r\n\t    @Override\r\n\t    public String getColumnName(int columnIndex) {\r\n\t    \treturn columnNames[columnIndex];\t    \t\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public int getRowCount() {\r\n\t        return this.productoestadisticas.size();\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public int getColumnCount() {\t    \t\r\n\t        return this.columnNames.length;\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public Object getValueAt(int rowIndex, int columnIndex) {\r\n\t        switch (columnIndex) {\r\n\t\t\t\tcase 0: return this.productoestadisticas.get(rowIndex).getIsSelected();\r\n\t            \r\n\t\t\t\tcase 1: return this.productoestadisticas.get(rowIndex).getId();\r\n\t\t\t\tcase 2: return this.productoestadisticas.get(rowIndex).getid_empresa();\r\n\t\t\t\tcase 3: return this.productoestadisticas.get(rowIndex).getid_sucursal();\r\n\t\t\t\tcase 4: return this.productoestadisticas.get(rowIndex).getid_bodega();\r\n\t\t\t\tcase 5: return this.productoestadisticas.get(rowIndex).getid_producto();\r\n\t\t\t\tcase 6: return this.productoestadisticas.get(rowIndex).getprecio_ultima_compra();\r\n\t\t\t\tcase 7: return this.productoestadisticas.get(rowIndex).getprecio_ultima_venta();\r\n\t\t\t\tcase 8: return this.productoestadisticas.get(rowIndex).getprecio_ultima_cotizacion();\r\n\t\t\t\tcase 9: return this.productoestadisticas.get(rowIndex).getprecio_ultima_proforma();\r\n\t\t\t\tcase 10: return this.productoestadisticas.get(rowIndex).getcantidad_disponible();\r\n\t\t\t\tcase 11: return this.productoestadisticas.get(rowIndex).getcantidad_reservada();\r\n\t\t\t\tcase 12: return this.productoestadisticas.get(rowIndex).getcantidad_demanda();\r\n\t\t\t\tcase 13: return this.productoestadisticas.get(rowIndex).getcantidad_maximo();\r\n\t\t\t\tcase 14: return this.productoestadisticas.get(rowIndex).getcantidad_minimo();\r\n\t\t\t\tcase 15: return this.productoestadisticas.get(rowIndex).getcantidad_fisica();\r\n\t\t\t\tcase 16: return this.productoestadisticas.get(rowIndex).getcantidad_orden_compra();\r\n\t\t\t\tcase 17: return this.productoestadisticas.get(rowIndex).getcantidad_pedida();\r\n\t\t\t\tcase 18: return this.productoestadisticas.get(rowIndex).getcantidad_requisicion();\r\n\t\t\t\tcase 19: return this.productoestadisticas.get(rowIndex).getfecha_ultima_ingreso();\r\n\t\t\t\tcase 20: return this.productoestadisticas.get(rowIndex).getfecha_ultima_egreso();\r\n\t\t\t\tcase 21: return this.productoestadisticas.get(rowIndex).getfecha_ultima_produccion();\r\n\t\t\t\tcase 22: return this.productoestadisticas.get(rowIndex).getfecha_ultima_compra();\r\n\t\t\t\tcase 23: return this.productoestadisticas.get(rowIndex).getfecha_ultima_venta();\r\n\t\t\t\tcase 24: return this.productoestadisticas.get(rowIndex).getfecha_ultima_devolucion();\r\n\t\t\t\tcase 25: return this.productoestadisticas.get(rowIndex).getfecha_ultima_orden_compra();\r\n\t\t\t\tcase 26: return this.productoestadisticas.get(rowIndex).getfecha_ultima_pedido();\r\n\t\t\t\tcase 27: return this.productoestadisticas.get(rowIndex).getfecha_ultima_requisicion();\r\n\t\t\t\tcase 28: return this.productoestadisticas.get(rowIndex).gettotal_ingreso();\r\n\t\t\t\tcase 29: return this.productoestadisticas.get(rowIndex).gettotal_egreso();\r\n\t\t\t\tcase 30: return this.productoestadisticas.get(rowIndex).gettotal_compra();\r\n\t\t\t\tcase 31: return this.productoestadisticas.get(rowIndex).gettotal_venta();\r\n\t\t\t\tcase 32: return this.productoestadisticas.get(rowIndex).gettotal_producido();\r\n\t\t\t\tcase 33: return this.productoestadisticas.get(rowIndex).gettotal_devuelto();\r\n\t\t\t\tcase 34: return this.productoestadisticas.get(rowIndex).getcosto_ultimo();\r\n\t\t\t\tcase 35: return this.productoestadisticas.get(rowIndex).getcosto_total();\r\n\t\t\t\tcase 36: return this.productoestadisticas.get(rowIndex).getcosto_produccion();\t            \r\n\t            default: return null;\r\n\t        }\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public Class<?> getColumnClass(int columnIndex) {\r\n\t    \tswitch (columnIndex) {\r\n\t\t\t\tcase 0: return Boolean.class;\r\n\t            \r\n\t\t\t\tcase 1: return Long.class;\r\n\t\t\t\tcase 2: return Long.class;\r\n\t\t\t\tcase 3: return Long.class;\r\n\t\t\t\tcase 4: return Long.class;\r\n\t\t\t\tcase 5: return Long.class;\r\n\t\t\t\tcase 6: return Double.class;\r\n\t\t\t\tcase 7: return Double.class;\r\n\t\t\t\tcase 8: return Double.class;\r\n\t\t\t\tcase 9: return Double.class;\r\n\t\t\t\tcase 10: return Integer.class;\r\n\t\t\t\tcase 11: return Double.class;\r\n\t\t\t\tcase 12: return Double.class;\r\n\t\t\t\tcase 13: return Integer.class;\r\n\t\t\t\tcase 14: return Integer.class;\r\n\t\t\t\tcase 15: return Double.class;\r\n\t\t\t\tcase 16: return Double.class;\r\n\t\t\t\tcase 17: return Double.class;\r\n\t\t\t\tcase 18: return Double.class;\r\n\t\t\t\tcase 19: return Date.class;\r\n\t\t\t\tcase 20: return Date.class;\r\n\t\t\t\tcase 21: return Date.class;\r\n\t\t\t\tcase 22: return Date.class;\r\n\t\t\t\tcase 23: return Date.class;\r\n\t\t\t\tcase 24: return Date.class;\r\n\t\t\t\tcase 25: return Date.class;\r\n\t\t\t\tcase 26: return Date.class;\r\n\t\t\t\tcase 27: return Date.class;\r\n\t\t\t\tcase 28: return Double.class;\r\n\t\t\t\tcase 29: return Double.class;\r\n\t\t\t\tcase 30: return Double.class;\r\n\t\t\t\tcase 31: return Double.class;\r\n\t\t\t\tcase 32: return Double.class;\r\n\t\t\t\tcase 33: return Double.class;\r\n\t\t\t\tcase 34: return Double.class;\r\n\t\t\t\tcase 35: return Double.class;\r\n\t\t\t\tcase 36: return Double.class;\t            \r\n\t            default: return String.class;\r\n\t        }\t    \t\t        \r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public boolean isCellEditable(int rowIndex, int columnIndex) {\r\n\t    \tswitch (columnIndex) {\r\n\t\t\t\tcase 0: return true;\r\n            \t\r\n\t\t\t\tcase 1: return true;\r\n\t\t\t\tcase 2: return true;\r\n\t\t\t\tcase 3: return true;\r\n\t\t\t\tcase 4: return true;\r\n\t\t\t\tcase 5: return true;\r\n\t\t\t\tcase 6: return true;\r\n\t\t\t\tcase 7: return true;\r\n\t\t\t\tcase 8: return true;\r\n\t\t\t\tcase 9: return true;\r\n\t\t\t\tcase 10: return true;\r\n\t\t\t\tcase 11: return true;\r\n\t\t\t\tcase 12: return true;\r\n\t\t\t\tcase 13: return true;\r\n\t\t\t\tcase 14: return true;\r\n\t\t\t\tcase 15: return true;\r\n\t\t\t\tcase 16: return true;\r\n\t\t\t\tcase 17: return true;\r\n\t\t\t\tcase 18: return true;\r\n\t\t\t\tcase 19: return true;\r\n\t\t\t\tcase 20: return true;\r\n\t\t\t\tcase 21: return true;\r\n\t\t\t\tcase 22: return true;\r\n\t\t\t\tcase 23: return true;\r\n\t\t\t\tcase 24: return true;\r\n\t\t\t\tcase 25: return true;\r\n\t\t\t\tcase 26: return true;\r\n\t\t\t\tcase 27: return true;\r\n\t\t\t\tcase 28: return true;\r\n\t\t\t\tcase 29: return true;\r\n\t\t\t\tcase 30: return true;\r\n\t\t\t\tcase 31: return true;\r\n\t\t\t\tcase 32: return true;\r\n\t\t\t\tcase 33: return true;\r\n\t\t\t\tcase 34: return true;\r\n\t\t\t\tcase 35: return true;\r\n\t\t\t\tcase 36: return true;\t            \r\n\t            default: return true;\r\n\t        }\t\r\n\t    }\r\n\t \r\n\t    @Override\r\n\t    public void setValueAt(Object value, int rowIndex, int columnIndex) {\r\n\t    \tProductoEstadistica productoestadistica = this.productoestadisticas.get(rowIndex);\r\n\t    \tBoolean esCampoValor=false;\r\n\t\t\tString sTipo=\"\";\r\n\t\t\t\r\n\t\t\tProductoEstadisticaBeanSwingJInternalFrame productoestadisticaBeanSwingJInternalFrame=(ProductoEstadisticaBeanSwingJInternalFrame)this.jInternalFrameBase; \r\n\t\t\t\r\n\t        switch (columnIndex) {\r\n\t\t\t\tcase 0: try {productoestadistica.setIsSelected((Boolean) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t            \r\n\t\t\t\tcase 1: try {productoestadistica.setId((Long) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 2: try {productoestadistica.setid_empresa((Long) value);productoestadistica.setempresa_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualEmpresaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 3: try {productoestadistica.setid_sucursal((Long) value);productoestadistica.setsucursal_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualSucursalForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 4: try {productoestadistica.setid_bodega((Long) value);productoestadistica.setbodega_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualBodegaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 5: try {productoestadistica.setid_producto((Long) value);productoestadistica.setproducto_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualProductoForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 6: try {productoestadistica.setprecio_ultima_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 7: try {productoestadistica.setprecio_ultima_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 8: try {productoestadistica.setprecio_ultima_cotizacion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 9: try {productoestadistica.setprecio_ultima_proforma((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 10: try {productoestadistica.setcantidad_disponible((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 11: try {productoestadistica.setcantidad_reservada((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 12: try {productoestadistica.setcantidad_demanda((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 13: try {productoestadistica.setcantidad_maximo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 14: try {productoestadistica.setcantidad_minimo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 15: try {productoestadistica.setcantidad_fisica((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 16: try {productoestadistica.setcantidad_orden_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 17: try {productoestadistica.setcantidad_pedida((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 18: try {productoestadistica.setcantidad_requisicion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 19: try {productoestadistica.setfecha_ultima_ingreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 20: try {productoestadistica.setfecha_ultima_egreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 21: try {productoestadistica.setfecha_ultima_produccion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 22: try {productoestadistica.setfecha_ultima_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 23: try {productoestadistica.setfecha_ultima_venta((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 24: try {productoestadistica.setfecha_ultima_devolucion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 25: try {productoestadistica.setfecha_ultima_orden_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 26: try {productoestadistica.setfecha_ultima_pedido((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 27: try {productoestadistica.setfecha_ultima_requisicion((Date) value);} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 28: try {productoestadistica.settotal_ingreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 29: try {productoestadistica.settotal_egreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 30: try {productoestadistica.settotal_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 31: try {productoestadistica.settotal_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 32: try {productoestadistica.settotal_producido((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 33: try {productoestadistica.settotal_devuelto((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 34: try {productoestadistica.setcosto_ultimo((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 35: try {productoestadistica.setcosto_total((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t\t\t\tcase 36: try {productoestadistica.setcosto_produccion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;\r\n\t        }\r\n\t        \r\n\t        fireTableCellUpdated(rowIndex, columnIndex);\r\n\t\t\t\r\n\t\t\tif(esCampoValor) {\r\n\t\t\t\tjInternalFrameBase.procesoActualizarFilaTotales(esCampoValor,sTipo);\r\n\t\t\t}\r\n\t    }\r\n\t\t\r\n\t\t\r\n\t\t//PARTE PARA EL PROPERTYVALORCHANGELISTENER\r\n\t\t//public JInternalFrameBase jInternalFrameBase;\r\n\t\t/*\r\n\t\tpublic ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {\r\n\t\t\tthis.jInternalFrameBase=jInternalFrameBase;\r\n\t\t}\r\n\t\t*/\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic void propertyChange(PropertyChangeEvent evt) {\r\n\t\t\ttry {\r\n\t\t\t\tthis.jInternalFrameBase.procesoActualizarFilaTotales();\r\n\t\t\t\t\t\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\t//PARTE PARA EL PROPERTYVALORCHANGELISTENER FIN\r\n\t\t\r\n\t\t\t\r\n\t\t/*FUNCIONES PARA FOCUS TRAVERSAL POLICY*/\r\n\t\t\r\n\t\tprivate Component componentTab=new JTextField();\r\n\t\tprivate ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame=null;\r\n\t\t\r\n\t\tpublic ProductoEstadisticaModel(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {\r\n\t\t\tthis.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentAfter(Container focusCycleRoot, Component component) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\t\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\t\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentBefore(Container focusCycleRoot, Component component) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();\r\n\t\t\t\t\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {\r\n\t\t\t\t\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica)) {\r\n\t\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;\r\n\t\t\t\treturn componentTab;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\r\n\t\tif(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\t\r\n\t\t\treturn componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getDefaultComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getFirstComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getLastComponent(Container focusCycleRoot) {\r\n\t\t\t\r\n\t\t\tcomponentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn componentTab;\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic ProductoEstadisticaDetalleFormJInternalFrame getproductoestadisticaJInternalFrame() {\r\n\t\t\treturn this.productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void setproductoestadisticaJInternalFrame(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {\r\n\t\t\tthis.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;\r\n\t\t}\r\n\t\t\r\n\t\tpublic Component getComponentTab() {\r\n\t\t\treturn this.componentTab;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void setComponentTab(Component componentTab) {\r\n\t\t\tthis.componentTab=componentTab;\r\n\t\t}\r\n\t\t/*FUNCIONES PARA FOCUS TRAVERSAL POLICY FIN*/\r\n\t\t\r\n\t\t\r\n\t\t/*FUNCIONES PARA AbstractTableModel*/\r\n\t\t/*\r\n\t\tNotas:\r\n\t\t* Si Cambia version se copia variables y metodos que no son sobreescritos en esta clase.(Usa Jdk 8)\r\n\t\t* Se copia del Jdk javax.swing.table.AbstractTableModel\r\n\t\t* Los argumentos usados es de tipo Interface TableModel no de Clase AbstractTableModel\r\n\t\t* Si se cambia y/o actualiza jdj, toca actualizar el c\u00f3digo nuevamente\r\n\t\t*/\r\n\t\t\r\n\t\tprotected EventListenerList listenerList = new EventListenerList();\r\n\r\n\t\tpublic int findColumn(String columnName) {\r\n\t\t\tfor (int i = 0; i < getColumnCount(); i++) {\r\n\t\t\t\tif (columnName.equals(getColumnName(i))) {\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void addTableModelListener(TableModelListener l) {\r\n        \tlistenerList.add(TableModelListener.class, l);\r\n    \t}\r\n\t\t\r\n\t\tpublic void removeTableModelListener(TableModelListener l) {\r\n        \tlistenerList.remove(TableModelListener.class, l);\r\n    \t}\r\n\t\t\r\n\t\tpublic TableModelListener[] getTableModelListeners() {\r\n\t\t\treturn listenerList.getListeners(TableModelListener.class);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableDataChanged() {\r\n\t\t\tfireTableChanged(new TableModelEvent(this));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableStructureChanged() {\r\n        \tfireTableChanged(new TableModelEvent(this, TableModelEvent.HEADER_ROW));\r\n    \t}\r\n\t\t\r\n\t\tpublic void fireTableRowsInserted(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));\r\n\t\t}\r\n\t\r\n\t\tpublic void fireTableRowsUpdated(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableRowsDeleted(int firstRow, int lastRow) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\r\n\t\t\t\t\t\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));\r\n\t\t}\r\n\t\r\n\t\tpublic void fireTableCellUpdated(int row, int column) {\r\n\t\t\tfireTableChanged(new TableModelEvent(this, row, row, column));\r\n\t\t}\r\n\t\t\r\n\t\tpublic void fireTableChanged(TableModelEvent e) {\r\n\t\t\t// Guaranteed to return a non-null array\r\n\t\t\tObject[] listeners = listenerList.getListenerList();\r\n\t\t\t// Process the listeners last to first, notifying\r\n\t\t\t// those that are interested in this event\r\n\t\t\tfor (int i = listeners.length-2; i>=0; i-=2) {\r\n\t\t\t\tif (listeners[i]==TableModelListener.class) {\r\n\t\t\t\t\t((TableModelListener)listeners[i+1]).tableChanged(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic <T extends EventListener> T[] getListeners(Class<T> listenerType) {\r\n\t\t\treturn listenerList.getListeners(listenerType);\r\n\t\t}\r\n\t\t/*FUNCIONES PARA AbstractTableModel FIN*/\r\n"]], "pred": {"ppl": 1.2777817249298096, "ppl_lower": 1.5165461301803589, "ppl/lowercase_ppl": -1.698866035998759, "ppl/zlib": 5.938118873636554e-05, "Min_5.0% Prob": 4.093215224789638, "Min_10.0% Prob": 2.3773737450440726, "Min_20.0% Prob": 1.2262581714072867, "Min_30.0% Prob": 0.8192845965909477, "Min_40.0% Prob": 0.6130688212046139, "Min_50.0% Prob": 0.49071801880853483, "Min_60.0% Prob": 0.409072162745945}}
{"hexsha": "2ea814cde3b519bfac60feda1d0c6c581f8f8ffe", "ext": "java", "lang": "Java", "content": "public class MessengerServer {\n\n    private static final Configuration config = CFGService.getInstance().getConfiguration();\n    private static final int PORT             = config.getInt(\"server.port\", 8000);\n    private static final String HOST          = config.getString(\"server.host\", \"localhost\");\n\n    public static final AttributeKey<MTSession> SESSION = AttributeKey.valueOf(\"session\");\n\n    public static void main(String[] args) throws Exception\n    {\n        EventLoopGroup bossGroup   = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .handler(new LoggingHandler(LogLevel.INFO))\n                     .childHandler(new ServerInitializer())\n                     .option(ChannelOption.SO_BACKLOG, 128)\n                     .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            bootstrap.bind(HOST, PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}", "class_id": 0, "repo": "ITON-Solutions/messenger-server", "file": "server/src/main/java/org/iton/messenger/server/MessengerServer.java", "last_update_at": "2018-06-25T00:07:19+00:00", "question_id": "2ea814cde3b519bfac60feda1d0c6c581f8f8ffe", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MessengerServer {\n    private static final Configuration config = CFGService.getInstance().getConfiguration();\n    private static final int PORT             = config.getInt(\"server.port\", 8000);\n    private static final String HOST          = config.getString(\"server.host\", \"localhost\");\n    public static final AttributeKey<MTSession> SESSION = AttributeKey.valueOf(\"session\");\n    public static void main(String[] args) throws Exception\n    {\n        EventLoopGroup bossGroup   = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .handler(new LoggingHandler(LogLevel.INFO))\n                     .childHandler(new ServerInitializer())\n                     .option(ChannelOption.SO_BACKLOG, 128)\n                     .childOption(ChannelOption.SO_KEEPALIVE, true);\n            bootstrap.bind(HOST, PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n"]], "pred": {"ppl": 1.669091820716858, "ppl_lower": 2.1585171222686768, "ppl/lowercase_ppl": -1.5019559250258085, "ppl/zlib": 0.0010025042242171208, "Min_5.0% Prob": 6.500096654891967, "Min_10.0% Prob": 4.14321457570599, "Min_20.0% Prob": 2.4415125832442315, "Min_30.0% Prob": 1.693729367387551, "Min_40.0% Prob": 1.2748482854962349, "Min_50.0% Prob": 1.0255500413656522, "Min_60.0% Prob": 0.8567824859924136}}
{"hexsha": "6d76521cd39de2900907e491052a899a9a4eef79", "ext": "java", "lang": "Java", "content": "public class Font extends AbstractStyle {\r\n// ### E N U M S ###\r\n    /**\r\n     * Default font family as constant\r\n     */\r\n    public static final String DEFAULTFONT = \"Calibri\";\r\n\r\n    /**\r\n     * Enum for the vertical alignment of the text from base line\r\n     */\r\n    public enum VerticalAlignValue {\r\n        // baseline, // Maybe not used in Excel\r\n        /**\r\n         * Text will be rendered as subscript\r\n         */\r\n        subscript(1),\r\n        /**\r\n         * Text will be rendered as superscript\r\n         */\r\n        superscript(2),\r\n        /**\r\n         * Text will be rendered normal\r\n         */\r\n        none(0);\r\n\r\n        private final int value;\r\n\r\n        VerticalAlignValue(int value) {\r\n            this.value = value;\r\n        }\r\n\r\n        public int getValue() {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enum for the font scheme\r\n     */\r\n    public enum SchemeValue {\r\n        /**\r\n         * Font scheme is major\r\n         */\r\n        major(1),\r\n        /**\r\n         * Font scheme is minor (default)\r\n         */\r\n        minor(2),\r\n        /**\r\n         * No Font scheme is used\r\n         */\r\n        none(0);\r\n\r\n        private final int value;\r\n\r\n        SchemeValue(int value) {\r\n            this.value = value;\r\n        }\r\n\r\n        public int getValue() {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    // ### P R I V A T E  F I E L D S ###\r\n    private int size;\r\n    private String name;\r\n    private String family;\r\n    private int colorTheme;\r\n    private String colorValue;\r\n    private SchemeValue scheme;\r\n    private VerticalAlignValue verticalAlign;\r\n    private boolean bold;\r\n    private boolean italic;\r\n    private boolean underline;\r\n    private boolean doubleUnderline;\r\n    private boolean strike;\r\n    private String charset;\r\n\r\n// ### G E T T E R S  &  S E T T E R S ###\r\n\r\n    /**\r\n     * Gets the font size. Valid range is from 8 to 75\r\n     *\r\n     * @return Font size\r\n     */\r\n    public int getSize() {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Sets the Font size. Valid range is from 8 to 75\r\n     *\r\n     * @param size Font size\r\n     */\r\n    public void setSize(int size) {\r\n        if (size < 8) {\r\n            this.size = 8;\r\n        } else if (size > 75) {\r\n            this.size = 72;\r\n        } else {\r\n            this.size = size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the font name (Default is Calibri)\r\n     *\r\n     * @return Font name\r\n     */\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Sets the font name (Default is Calibri)\r\n     *\r\n     * @param name Font name\r\n     */\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Gets the font family (Default is 2)\r\n     *\r\n     * @return Font family\r\n     */\r\n    public String getFamily() {\r\n        return this.family;\r\n    }\r\n\r\n    /**\r\n     * Sets the font family (Default is 2)\r\n     *\r\n     * @param family Font family\r\n     */\r\n    public void setFamily(String family) {\r\n        this.family = family;\r\n    }\r\n\r\n    /**\r\n     * Gets the font color theme (Default is 1)\r\n     *\r\n     * @return Font color theme\r\n     */\r\n    public int getColorTheme() {\r\n        return this.colorTheme;\r\n    }\r\n\r\n    /**\r\n     * Sets the font color theme (Default is 1)\r\n     *\r\n     * @param colorTheme Font color theme\r\n     */\r\n    public void setColorTheme(int colorTheme) {\r\n        this.colorTheme = colorTheme;\r\n    }\r\n\r\n    /**\r\n     * Gets the Font color (default is empty)\r\n     *\r\n     * @return Font color\r\n     */\r\n    public String getColorValue() {\r\n        return this.colorValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the font color (default is empty)\r\n     *\r\n     * @param colorValue Font color\r\n     */\r\n    public void setColorValue(String colorValue) {\r\n        this.colorValue = colorValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the font scheme (Default is minor)\r\n     *\r\n     * @return Font scheme\r\n     */\r\n    public SchemeValue getScheme() {\r\n        return this.scheme;\r\n    }\r\n\r\n    /**\r\n     * Sets the Font scheme (Default is minor)\r\n     *\r\n     * @param scheme Font scheme\r\n     */\r\n    public void setScheme(SchemeValue scheme) {\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    /**\r\n     * Gets the alignment of the font (Default is none)\r\n     *\r\n     * @return Alignment of the font\r\n     */\r\n    public VerticalAlignValue getVerticalAlign() {\r\n        return this.verticalAlign;\r\n    }\r\n\r\n    /**\r\n     * Sets the Alignment of the font (Default is none)\r\n     *\r\n     * @param verticalAlign Alignment of the font\r\n     */\r\n    public void setVerticalAlign(VerticalAlignValue verticalAlign) {\r\n        this.verticalAlign = verticalAlign;\r\n    }\r\n\r\n    /**\r\n     * Gets the bold parameter of the font\r\n     *\r\n     * @return If true, the font is bold\r\n     */\r\n    public boolean isBold() {\r\n        return this.bold;\r\n    }\r\n\r\n    /**\r\n     * Sets the bold parameter of the font\r\n     *\r\n     * @param bold If true, the font is bold\r\n     */\r\n    public void setBold(boolean bold) {\r\n        this.bold = bold;\r\n    }\r\n\r\n    /**\r\n     * Gets the italic parameter of the font\r\n     *\r\n     * @return If true, the font is italic\r\n     */\r\n    public boolean isItalic() {\r\n        return this.italic;\r\n    }\r\n\r\n    /**\r\n     * Sets the italic parameter of the font\r\n     *\r\n     * @param italic If true, the font is italic\r\n     */\r\n    public void setItalic(boolean italic) {\r\n        this.italic = italic;\r\n    }\r\n\r\n    /**\r\n     * Gets the underline parameter of the font\r\n     *\r\n     * @return If true, the font as one underline\r\n     */\r\n    public boolean isUnderline() {\r\n        return this.underline;\r\n    }\r\n\r\n    /**\r\n     * Sets the underline parameter of the font\r\n     *\r\n     * @param underline If true, the font as one underline\r\n     */\r\n    public void setUnderline(boolean underline) {\r\n        this.underline = underline;\r\n    }\r\n\r\n    /**\r\n     * Gets the double-underline parameter of the font\r\n     *\r\n     * @return If true, the font ha a double underline\r\n     */\r\n    public boolean isDoubleUnderline() {\r\n        return this.doubleUnderline;\r\n    }\r\n\r\n    /**\r\n     * Sets the double-underline parameter of the font\r\n     *\r\n     * @param doubleUnderline If true, the font ha a double underline\r\n     */\r\n    public void setDoubleUnderline(boolean doubleUnderline) {\r\n        this.doubleUnderline = doubleUnderline;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the font is struck through\r\n     *\r\n     * @return If true, the font is declared as strike-through\r\n     */\r\n    public boolean isStrike() {\r\n        return this.strike;\r\n    }\r\n\r\n    /**\r\n     * Sets whether the font is struck through\r\n     *\r\n     * @param strike If true, the font is declared as strike-through\r\n     */\r\n    public void setStrike(boolean strike) {\r\n        this.strike = strike;\r\n    }\r\n\r\n    /**\r\n     * Gets the charset of the Font (Default is empty)\r\n     *\r\n     * @return Charset of the Font\r\n     */\r\n    public String getCharset() {\r\n        return this.charset;\r\n    }\r\n\r\n    /**\r\n     * Sets the charset of the Font (Default is empty)\r\n     *\r\n     * @param charset Charset of the Font\r\n     */\r\n    public void setCharset(String charset) {\r\n        this.charset = charset;\r\n    }\r\n\r\n    /**\r\n     * Gets whether this object is the default font\r\n     *\r\n     * @return In true the font is equals the default font\r\n     */\r\n    public boolean isDefaultFont() {\r\n        Font temp = new Font();\r\n        return this.equals(temp);\r\n    }\r\n\r\n// ### C O N S T R U C T O R S ###   \r\n\r\n    /**\r\n     * Default constructor\r\n     */\r\n    public Font() {\r\n        this.size = 11;\r\n        this.name = DEFAULTFONT;\r\n        this.family = \"2\";\r\n        this.colorTheme = 1;\r\n        this.colorValue = \"\";\r\n        this.charset = \"\";\r\n        this.scheme = SchemeValue.minor;\r\n        this.verticalAlign = VerticalAlignValue.none;\r\n    }\r\n\r\n    /**\r\n     * Override toString method\r\n     *\r\n     * @return String of a class instance\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return \"Font:\" + this.hashCode();\r\n    }\r\n\r\n    /**\r\n     * Method to copy the current object to a new one\r\n     *\r\n     * @return Copy of the current object without the internal ID\r\n     */\r\n    @Override\r\n    public Font copy() {\r\n        Font copy = new Font();\r\n        copy.setBold(this.bold);\r\n        copy.setCharset(this.charset);\r\n        copy.setColorTheme(this.colorTheme);\r\n        copy.setColorValue(this.colorValue);\r\n        copy.setVerticalAlign(this.verticalAlign);\r\n        copy.setDoubleUnderline(this.doubleUnderline);\r\n        copy.setFamily(this.family);\r\n        copy.setItalic(this.italic);\r\n        copy.setName(this.name);\r\n        copy.setScheme(this.scheme);\r\n        copy.setSize(this.size);\r\n        copy.setStrike(this.strike);\r\n        copy.setUnderline(this.underline);\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Override method to calculate the hash of this component\r\n     *\r\n     * @return Calculated hash as string\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        int p = 257;\r\n        int r = 1;\r\n        r *= p + (this.bold ? 0 : 1);\r\n        r *= p + (this.italic ? 0 : 1);\r\n        r *= p + (this.underline ? 0 : 1);\r\n        r *= p + (this.doubleUnderline ? 0 : 1);\r\n        r *= p + (this.strike ? 0 : 1);\r\n        r *= p + this.colorTheme;\r\n        r *= p + this.colorValue.hashCode();\r\n        r *= p + this.family.hashCode();\r\n        r *= p + this.name.hashCode();\r\n        r *= p + this.scheme.getValue();\r\n        r *= p + this.verticalAlign.value;\r\n        r *= p + this.charset.hashCode();\r\n        r *= p + this.size;\r\n        return r;\r\n    }\r\n\r\n\r\n}", "class_id": 0, "repo": "rabanti-github/PicoXLSX4j", "file": "src/main/java/ch/rabanti/picoxlsx4j/style/Font.java", "last_update_at": "2018-03-12T04:24:05+00:00", "question_id": "6d76521cd39de2900907e491052a899a9a4eef79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Font extends AbstractStyle {\r\n// ### E N U M S ###\r\n    /**\r\n     * Default font family as constant\r\n     */\r\n    public static final String DEFAULTFONT = \"Calibri\";\r\n\r\n    /**\r\n     * Enum for the vertical alignment of the text from base line\r\n     */\r\n    public enum VerticalAlignValue {\r\n        // baseline, // Maybe not used in Excel\r\n        /**\r\n         * Text will be rendered as subscript\r\n         */\r\n        subscript(1),\r\n        /**\r\n         * Text will be rendered as superscript\r\n         */\r\n        superscript(2),\r\n        /**\r\n         * Text will be rendered normal\r\n         */\r\n        none(0);\r\n\r\n        private final int value;\r\n\r\n        VerticalAlignValue(int value) {\r\n            this.value = value;\r\n        }\r\n\r\n        public int getValue() {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enum for the font scheme\r\n     */\r\n    public enum SchemeValue {\r\n        /**\r\n         * Font scheme is major\r\n         */\r\n        major(1),\r\n        /**\r\n         * Font scheme is minor (default)\r\n         */\r\n        minor(2),\r\n        /**\r\n         * No Font scheme is used\r\n         */\r\n        none(0);\r\n\r\n        private final int value;\r\n\r\n        SchemeValue(int value) {\r\n            this.value = value;\r\n        }\r\n\r\n        public int getValue() {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    // ### P R I V A T E  F I E L D S ###\r\n    private int size;\r\n    private String name;\r\n    private String family;\r\n    private int colorTheme;\r\n    private String colorValue;\r\n    private SchemeValue scheme;\r\n    private VerticalAlignValue verticalAlign;\r\n    private boolean bold;\r\n    private boolean italic;\r\n    private boolean underline;\r\n    private boolean doubleUnderline;\r\n    private boolean strike;\r\n    private String charset;\r\n\r\n// ### G E T T E R S  &  S E T T E R S ###\r\n\r\n    /**\r\n     * Gets the font size. Valid range is from 8 to 75\r\n     *\r\n     * @return Font size\r\n     */\r\n    public int getSize() {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Sets the Font size. Valid range is from 8 to 75\r\n     *\r\n     * @param size Font size\r\n     */\r\n    public void setSize(int size) {\r\n        if (size < 8) {\r\n            this.size = 8;\r\n        } else if (size > 75) {\r\n            this.size = 72;\r\n        } else {\r\n            this.size = size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the font name (Default is Calibri)\r\n     *\r\n     * @return Font name\r\n     */\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Sets the font name (Default is Calibri)\r\n     *\r\n     * @param name Font name\r\n     */\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Gets the font family (Default is 2)\r\n     *\r\n     * @return Font family\r\n     */\r\n    public String getFamily() {\r\n        return this.family;\r\n    }\r\n\r\n    /**\r\n     * Sets the font family (Default is 2)\r\n     *\r\n     * @param family Font family\r\n     */\r\n    public void setFamily(String family) {\r\n        this.family = family;\r\n    }\r\n\r\n    /**\r\n     * Gets the font color theme (Default is 1)\r\n     *\r\n     * @return Font color theme\r\n     */\r\n    public int getColorTheme() {\r\n        return this.colorTheme;\r\n    }\r\n\r\n    /**\r\n     * Sets the font color theme (Default is 1)\r\n     *\r\n     * @param colorTheme Font color theme\r\n     */\r\n    public void setColorTheme(int colorTheme) {\r\n        this.colorTheme = colorTheme;\r\n    }\r\n\r\n    /**\r\n     * Gets the Font color (default is empty)\r\n     *\r\n     * @return Font color\r\n     */\r\n    public String getColorValue() {\r\n        return this.colorValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the font color (default is empty)\r\n     *\r\n     * @param colorValue Font color\r\n     */\r\n    public void setColorValue(String colorValue) {\r\n        this.colorValue = colorValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the font scheme (Default is minor)\r\n     *\r\n     * @return Font scheme\r\n     */\r\n    public SchemeValue getScheme() {\r\n        return this.scheme;\r\n    }\r\n\r\n    /**\r\n     * Sets the Font scheme (Default is minor)\r\n     *\r\n     * @param scheme Font scheme\r\n     */\r\n    public void setScheme(SchemeValue scheme) {\r\n        this.scheme = scheme;\r\n    }\r\n\r\n    /**\r\n     * Gets the alignment of the font (Default is none)\r\n     *\r\n     * @return Alignment of the font\r\n     */\r\n    public VerticalAlignValue getVerticalAlign() {\r\n        return this.verticalAlign;\r\n    }\r\n\r\n    /**\r\n     * Sets the Alignment of the font (Default is none)\r\n     *\r\n     * @param verticalAlign Alignment of the font\r\n     */\r\n    public void setVerticalAlign(VerticalAlignValue verticalAlign) {\r\n        this.verticalAlign = verticalAlign;\r\n    }\r\n\r\n    /**\r\n     * Gets the bold parameter of the font\r\n     *\r\n     * @return If true, the font is bold\r\n     */\r\n    public boolean isBold() {\r\n        return this.bold;\r\n    }\r\n\r\n    /**\r\n     * Sets the bold parameter of the font\r\n     *\r\n     * @param bold If true, the font is bold\r\n     */\r\n    public void setBold(boolean bold) {\r\n        this.bold = bold;\r\n    }\r\n\r\n    /**\r\n     * Gets the italic parameter of the font\r\n     *\r\n     * @return If true, the font is italic\r\n     */\r\n    public boolean isItalic() {\r\n        return this.italic;\r\n    }\r\n\r\n    /**\r\n     * Sets the italic parameter of the font\r\n     *\r\n     * @param italic If true, the font is italic\r\n     */\r\n    public void setItalic(boolean italic) {\r\n        this.italic = italic;\r\n    }\r\n\r\n    /**\r\n     * Gets the underline parameter of the font\r\n     *\r\n     * @return If true, the font as one underline\r\n     */\r\n    public boolean isUnderline() {\r\n        return this.underline;\r\n    }\r\n\r\n    /**\r\n     * Sets the underline parameter of the font\r\n     *\r\n     * @param underline If true, the font as one underline\r\n     */\r\n    public void setUnderline(boolean underline) {\r\n        this.underline = underline;\r\n    }\r\n\r\n    /**\r\n     * Gets the double-underline parameter of the font\r\n     *\r\n     * @return If true, the font ha a double underline\r\n     */\r\n    public boolean isDoubleUnderline() {\r\n        return this.doubleUnderline;\r\n    }\r\n\r\n    /**\r\n     * Sets the double-underline parameter of the font\r\n     *\r\n     * @param doubleUnderline If true, the font ha a double underline\r\n     */\r\n    public void setDoubleUnderline(boolean doubleUnderline) {\r\n        this.doubleUnderline = doubleUnderline;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the font is struck through\r\n     *\r\n     * @return If true, the font is declared as strike-through\r\n     */\r\n    public boolean isStrike() {\r\n        return this.strike;\r\n    }\r\n\r\n    /**\r\n     * Sets whether the font is struck through\r\n     *\r\n     * @param strike If true, the font is declared as strike-through\r\n     */\r\n    public void setStrike(boolean strike) {\r\n        this.strike = strike;\r\n    }\r\n\r\n    /**\r\n     * Gets the charset of the Font (Default is empty)\r\n     *\r\n     * @return Charset of the Font\r\n     */\r\n    public String getCharset() {\r\n        return this.charset;\r\n    }\r\n\r\n    /**\r\n     * Sets the charset of the Font (Default is empty)\r\n     *\r\n     * @param charset Charset of the Font\r\n     */\r\n    public void setCharset(String charset) {\r\n        this.charset = charset;\r\n    }\r\n\r\n    /**\r\n     * Gets whether this object is the default font\r\n     *\r\n     * @return In true the font is equals the default font\r\n     */\r\n    public boolean isDefaultFont() {\r\n        Font temp = new Font();\r\n        return this.equals(temp);\r\n    }\r\n\r\n// ### C O N S T R U C T O R S ###   \r\n\r\n    /**\r\n     * Default constructor\r\n     */\r\n    public Font() {\r\n        this.size = 11;\r\n        this.name = DEFAULTFONT;\r\n        this.family = \"2\";\r\n        this.colorTheme = 1;\r\n        this.colorValue = \"\";\r\n        this.charset = \"\";\r\n        this.scheme = SchemeValue.minor;\r\n        this.verticalAlign = VerticalAlignValue.none;\r\n    }\r\n\r\n    /**\r\n     * Override toString method\r\n     *\r\n     * @return String of a class instance\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return \"Font:\" + this.hashCode();\r\n    }\r\n\r\n    /**\r\n     * Method to copy the current object to a new one\r\n     *\r\n     * @return Copy of the current object without the internal ID\r\n     */\r\n    @Override\r\n    public Font copy() {\r\n        Font copy = new Font();\r\n        copy.setBold(this.bold);\r\n        copy.setCharset(this.charset);\r\n        copy.setColorTheme(this.colorTheme);\r\n        copy.setColorValue(this.colorValue);\r\n        copy.setVerticalAlign(this.verticalAlign);\r\n        copy.setDoubleUnderline(this.doubleUnderline);\r\n        copy.setFamily(this.family);\r\n        copy.setItalic(this.italic);\r\n        copy.setName(this.name);\r\n        copy.setScheme(this.scheme);\r\n        copy.setSize(this.size);\r\n        copy.setStrike(this.strike);\r\n        copy.setUnderline(this.underline);\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Override method to calculate the hash of this component\r\n     *\r\n     * @return Calculated hash as string\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        int p = 257;\r\n        int r = 1;\r\n        r *= p + (this.bold ? 0 : 1);\r\n        r *= p + (this.italic ? 0 : 1);\r\n        r *= p + (this.underline ? 0 : 1);\r\n        r *= p + (this.doubleUnderline ? 0 : 1);\r\n        r *= p + (this.strike ? 0 : 1);\r\n        r *= p + this.colorTheme;\r\n        r *= p + this.colorValue.hashCode();\r\n        r *= p + this.family.hashCode();\r\n        r *= p + this.name.hashCode();\r\n        r *= p + this.scheme.getValue();\r\n        r *= p + this.verticalAlign.value;\r\n        r *= p + this.charset.hashCode();\r\n        r *= p + this.size;\r\n        return r;\r\n    }\r\n\r\n\r\n"]], "pred": {"ppl": 1.4886571168899536, "ppl_lower": 1.5361748933792114, "ppl/lowercase_ppl": -1.0789722521723188, "ppl/zlib": 0.0002133375065644418, "Min_5.0% Prob": 4.99024201374428, "Min_10.0% Prob": 3.34509240879732, "Min_20.0% Prob": 1.9297321243759464, "Min_30.0% Prob": 1.3162752770350066, "Min_40.0% Prob": 0.9920855525671561, "Min_50.0% Prob": 0.7957853020465916, "Min_60.0% Prob": 0.6638191108547036}}
{"hexsha": "12101258c5cd65ef3c38957217a9ccdcffa6476d", "ext": "java", "lang": "Java", "content": "public class ProximityGrid implements Algorithm {\n\n\tprivate Grid m_Grid;\n\n\t/**\n\t * @param args\n\t */\n\tpublic HashMap<String, List<User>> findAkNNs(\n\t\t\tList<User> neighborsList, int K) {\n\t\tHashMap<String, List<User>> neighborsListSet = new HashMap<String, List<User>>();\n\n\t\tfor (int j = 0; j < neighborsList.size(); j++) {\n\t\t\tUser n = (User) neighborsList.get(j);\n\t\t\tList<User> temp = new LinkedList<User>();\n\t\t\t// Get the Cell of the n\n\t\t\tCell c = m_Grid.getCell(n);\n\t\t\n\t\t\t// Get the cell\n\t\t\t// /////////////////////////////////////////////\n\t\t\t// Ulist + Kheap + Boundary List\n\t\t\t// ////////////////////////////////////////////\n\t\t\tList<User> tempList = c.AllToArrayList();\n\t\t\t// System.out.println(\"Grid.findAkNNs() in \"+tempList.size());\n\t\t\tfor (int k = 0; k < tempList.size(); k++) {\n\t\t\t\tUser n_in = tempList.get(k);\n\n\t\t\t\tn_in.setDistance(n.lon, n.lat);\n\n\t\t\t\ttemp.add(n_in);\n\n\t\t\t}\n\t\n\t\t\tCollections.sort(temp);\n\t\t\tneighborsListSet.put(n.key, temp.subList(0, K));\n\n\t\t}\n\n\t\treturn neighborsListSet;\n\t}\n\n\tpublic void buildingStructures(List<User> neighborsList, int K,\n\t\t\tint cellSize) {\n\t\t// Create the grid\n\t\tm_Grid = new Grid(neighborsList.size(), K, cellSize);\n\n\t\tfor (int j = 0; j < neighborsList.size(); j++) {\n\t\t\tUser neighbor = neighborsList.get(j);\n\t\t\tm_Grid.insertCell(neighbor);\n\t\t}\n\t}\n\n\tpublic void buildingStructures(List<User> neighborsList, int K) {\n\t\t// TODO Auto-generated method stub\n\t\tbuildingStructures(neighborsList, K, Grid.LOG_N);\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tint K = 2;\n\t\tint CellSize = Grid.LOG_N;\n\n\t\tif (args.length < 2) {\n\t\t\tSystem.err.println(\"prog <K> <CellSize>\");\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\ttry {\n\t\t\tK = Integer.parseInt(args[0]);\n\t\t\tCellSize = Integer.parseInt(args[1]);\n\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"prog <K> <CellSize>\");\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\tCouchBaseData.setLoggingOff();\n\n\t\tList<User> neighborsList = CouchBaseData.getData();\n\n\t\t// ////////////////////////////////////////////////////////////////////////////\n\t\t// *\n\t\t// * ProximityGrid benchmarking\n\t\t// *\n\t\t// ////////////////////////////////////////////////////////////////////////////\n\n\t\tProximityGrid pgr = new ProximityGrid();\n\t\t;\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tHashMap<String, List<User>> proxg = null;\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tpgr.buildingStructures(neighborsList, K,CellSize);\n\t\tlong endTime = System.currentTimeMillis();\n\t\tlong duration = endTime - startTime;\n\t\tSystem.out.println(\"Building Structures : Time [\" + duration + \"] ms\");\n\n\t\tstartTime = System.currentTimeMillis();\n\t\tproxg = pgr.findAkNNs(neighborsList, K);\n\t\tendTime = System.currentTimeMillis();\n\t\tduration = endTime - startTime;\n\t\tSystem.out.println(\"ProximityGrid Search : Time [\" + duration + \"] ms\");\n\n\t\tSystem.exit(0);\n\t}\n\n}", "class_id": 0, "repo": "dmsl/rayzit", "file": "spitfire/src/spitfire/AKNN_Gather/src/algorithms/ProximityGrid.java", "last_update_at": "2018-04-04T17:34:33+00:00", "question_id": "12101258c5cd65ef3c38957217a9ccdcffa6476d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProximityGrid implements Algorithm {\n\tprivate Grid m_Grid;\n\t/**\n\t * @param args\n\t */\n\tpublic HashMap<String, List<User>> findAkNNs(\n\t\t\tList<User> neighborsList, int K) {\n\t\tHashMap<String, List<User>> neighborsListSet = new HashMap<String, List<User>>();\n\t\tfor (int j = 0; j < neighborsList.size(); j++) {\n\t\t\tUser n = (User) neighborsList.get(j);\n\t\t\tList<User> temp = new LinkedList<User>();\n\t\t\t// Get the Cell of the n\n\t\t\tCell c = m_Grid.getCell(n);\n\t\t\n\t\t\t// Get the cell\n\t\t\t// /////////////////////////////////////////////\n\t\t\t// Ulist + Kheap + Boundary List\n\t\t\t// ////////////////////////////////////////////\n\t\t\tList<User> tempList = c.AllToArrayList();\n\t\t\t// System.out.println(\"Grid.findAkNNs() in \"+tempList.size());\n\t\t\tfor (int k = 0; k < tempList.size(); k++) {\n\t\t\t\tUser n_in = tempList.get(k);\n\t\t\t\tn_in.setDistance(n.lon, n.lat);\n\t\t\t\ttemp.add(n_in);\n\t\t\t}\n\t\n\t\t\tCollections.sort(temp);\n\t\t\tneighborsListSet.put(n.key, temp.subList(0, K));\n\t\t}\n\t\treturn neighborsListSet;\n\t}\n\tpublic void buildingStructures(List<User> neighborsList, int K,\n\t\t\tint cellSize) {\n\t\t// Create the grid\n\t\tm_Grid = new Grid(neighborsList.size(), K, cellSize);\n\t\tfor (int j = 0; j < neighborsList.size(); j++) {\n\t\t\tUser neighbor = neighborsList.get(j);\n\t\t\tm_Grid.insertCell(neighbor);\n\t\t}\n\t}\n\tpublic void buildingStructures(List<User> neighborsList, int K) {\n\t\t// TODO Auto-generated method stub\n\t\tbuildingStructures(neighborsList, K, Grid.LOG_N);\n\t}\n\tpublic static void main(String[] args) {\n\t\tint K = 2;\n\t\tint CellSize = Grid.LOG_N;\n\t\tif (args.length < 2) {\n\t\t\tSystem.err.println(\"prog <K> <CellSize>\");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\ttry {\n\t\t\tK = Integer.parseInt(args[0]);\n\t\t\tCellSize = Integer.parseInt(args[1]);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"prog <K> <CellSize>\");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tCouchBaseData.setLoggingOff();\n\t\tList<User> neighborsList = CouchBaseData.getData();\n\t\t// ////////////////////////////////////////////////////////////////////////////\n\t\t// *\n\t\t// * ProximityGrid benchmarking\n\t\t// *\n\t\t// ////////////////////////////////////////////////////////////////////////////\n\t\tProximityGrid pgr = new ProximityGrid();\n\t\t;\n\t\t@SuppressWarnings(\"unused\")\n\t\tHashMap<String, List<User>> proxg = null;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tpgr.buildingStructures(neighborsList, K,CellSize);\n\t\tlong endTime = System.currentTimeMillis();\n\t\tlong duration = endTime - startTime;\n\t\tSystem.out.println(\"Building Structures : Time [\" + duration + \"] ms\");\n\t\tstartTime = System.currentTimeMillis();\n\t\tproxg = pgr.findAkNNs(neighborsList, K);\n\t\tendTime = System.currentTimeMillis();\n\t\tduration = endTime - startTime;\n\t\tSystem.out.println(\"ProximityGrid Search : Time [\" + duration + \"] ms\");\n\t\tSystem.exit(0);\n\t}\n"]], "pred": {"ppl": 2.1738293170928955, "ppl_lower": 2.243361234664917, "ppl/lowercase_ppl": -1.0405478584391137, "ppl/zlib": 0.000822553257012754, "Min_5.0% Prob": 7.262323370166853, "Min_10.0% Prob": 5.4360618544559856, "Min_20.0% Prob": 3.518722992317349, "Min_30.0% Prob": 2.52091153618557, "Min_40.0% Prob": 1.9232631883149043, "Min_50.0% Prob": 1.5490780141233755, "Min_60.0% Prob": 1.2942222238367889}}
{"hexsha": "09d02d66b1f2c911e613968db7cdf65b9e0504ea", "ext": "java", "lang": "Java", "content": "public class SecurityHeadersResponseFilter implements SecurityResponseFilter {\n\n    @Override\n    public void filter(DiscFilterResponse response, RequestView request) {\n        response.setHeader(\"Cache-control\", \"no-store\");\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    }\n}", "class_id": 0, "repo": "amahussein/vespa", "file": "jdisc-security-filters/src/main/java/com/yahoo/jdisc/http/filter/security/misc/SecurityHeadersResponseFilter.java", "last_update_at": "2018-12-30T05:42:18+00:00", "question_id": "09d02d66b1f2c911e613968db7cdf65b9e0504ea", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SecurityHeadersResponseFilter implements SecurityResponseFilter {\n    @Override\n    public void filter(DiscFilterResponse response, RequestView request) {\n        response.setHeader(\"Cache-control\", \"no-store\");\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\n        response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    }\n"]], "pred": {"ppl": 2.1555793285369873, "ppl_lower": 2.779266119003296, "ppl/lowercase_ppl": -1.3308693971733416, "ppl/zlib": 0.0031349368056121365, "Min_5.0% Prob": 8.210394859313965, "Min_10.0% Prob": 5.891653478145599, "Min_20.0% Prob": 3.552070831259092, "Min_30.0% Prob": 2.51849265396595, "Min_40.0% Prob": 1.932121842013051, "Min_50.0% Prob": 1.5309938038775668, "Min_60.0% Prob": 1.2816907553359458}}
{"hexsha": "71c33504e313b023fee4bf56e1192b96a39ba56d", "ext": "java", "lang": "Java", "content": "public class StringTest {\n    public static void main(String[] args) {\n        String a = \"a\"; //1\u4e2a\u5b57\u8282\n        String b = \"\u4e2d\";//3\n        String c = \"1\";//1\n        String d = \"a\u4e2d1\";//5\n        String e = \"aa11\";//4\n        System.out.println(a.getBytes().length);\n        System.out.println(b.getBytes().length);\n        System.out.println(c.getBytes().length);\n        System.out.println(d.getBytes().length);\n        System.out.println(e.getBytes().length);\n        System.out.println(Charset.defaultCharset()); //UTF-8\n    }\n\n\n    public void test0() {\n        System.out.println(\"abc\" == \"abc\"); //true\n        System.out.println(\"abc\".equals(\"abc\")); //true\n        System.out.println(System.identityHashCode(new String(\"abc\"))); //1555009629\n        System.out.println(System.identityHashCode(new String(\"abc\"))); //41359092\n        System.out.println(System.identityHashCode(new String(\"abc\").intern())); //149928006\n        System.out.println(System.identityHashCode(\"abc\")); //149928006\n    }\n\n\n}", "class_id": 0, "repo": "cqxxxxxxxx/somethingnew", "file": "stn-java8/src/main/java/com/cqx/string/StringTest.java", "last_update_at": "2018-08-22T08:04:47+00:00", "question_id": "71c33504e313b023fee4bf56e1192b96a39ba56d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StringTest {\n    public static void main(String[] args) {\n        String a = \"a\"; //1\u4e2a\u5b57\u8282\n        String b = \"\u4e2d\";//3\n        String c = \"1\";//1\n        String d = \"a\u4e2d1\";//5\n        String e = \"aa11\";//4\n        System.out.println(a.getBytes().length);\n        System.out.println(b.getBytes().length);\n        System.out.println(c.getBytes().length);\n        System.out.println(d.getBytes().length);\n        System.out.println(e.getBytes().length);\n        System.out.println(Charset.defaultCharset()); //UTF-8\n    }\n    public void test0() {\n        System.out.println(\"abc\" == \"abc\"); //true\n        System.out.println(\"abc\".equals(\"abc\")); //true\n        System.out.println(System.identityHashCode(new String(\"abc\"))); //1555009629\n        System.out.println(System.identityHashCode(new String(\"abc\"))); //41359092\n        System.out.println(System.identityHashCode(new String(\"abc\").intern())); //149928006\n        System.out.println(System.identityHashCode(\"abc\")); //149928006\n    }\n"]], "pred": {"ppl": 2.0214040279388428, "ppl_lower": 2.2302727699279785, "ppl/lowercase_ppl": -1.1397167294773969, "ppl/zlib": 0.002113490490403984, "Min_5.0% Prob": 4.97336408495903, "Min_10.0% Prob": 3.8587970950386743, "Min_20.0% Prob": 2.9709483901066567, "Min_30.0% Prob": 2.218975992190956, "Min_40.0% Prob": 1.7305231778256929, "Min_50.0% Prob": 1.401611105804997, "Min_60.0% Prob": 1.1721066234190718}}
{"hexsha": "764c59cdf295b973d8d1a3007f4c9ab9f3ae8134", "ext": "java", "lang": "Java", "content": "public class NodeRegistry {\n\n    private static final TreeMap<String, Node> REPRESENTATIVE_NODES = new TreeMap<>();\n\n    private NodeRegistry() {\n\n    }\n\n    public static Node getRepresentive(Node node) {\n        Node n = REPRESENTATIVE_NODES.get(node.toString());\n        if (n == null) {\n            n = node;\n            REPRESENTATIVE_NODES.put(n.toString(), n);\n        }\n        return n;\n    }\n\n    public static void updateRepresentative(Node oldNode, Node newNode) {\n        REPRESENTATIVE_NODES.remove(oldNode.toString());\n        REPRESENTATIVE_NODES.put(newNode.toString(), newNode);\n    }\n\n}", "class_id": 0, "repo": "flordan/COMPSs-Mobile", "file": "code/runtime/commons/src/main/java/es/bsc/mobile/types/comm/NodeRegistry.java", "last_update_at": "2018-03-05T14:49:53+00:00", "question_id": "764c59cdf295b973d8d1a3007f4c9ab9f3ae8134", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class NodeRegistry {\n    private static final TreeMap<String, Node> REPRESENTATIVE_NODES = new TreeMap<>();\n    private NodeRegistry() {\n    }\n    public static Node getRepresentive(Node node) {\n        Node n = REPRESENTATIVE_NODES.get(node.toString());\n        if (n == null) {\n            n = node;\n            REPRESENTATIVE_NODES.put(n.toString(), n);\n        }\n        return n;\n    }\n    public static void updateRepresentative(Node oldNode, Node newNode) {\n        REPRESENTATIVE_NODES.remove(oldNode.toString());\n        REPRESENTATIVE_NODES.put(newNode.toString(), newNode);\n    }\n"]], "pred": {"ppl": 1.7224403619766235, "ppl_lower": 2.052732229232788, "ppl/lowercase_ppl": -1.3226338369570718, "ppl/zlib": 0.0020833030665169815, "Min_5.0% Prob": 6.846527576446533, "Min_10.0% Prob": 4.439558838543139, "Min_20.0% Prob": 2.572706509859134, "Min_30.0% Prob": 1.792981113038831, "Min_40.0% Prob": 1.355659916006689, "Min_50.0% Prob": 1.0856332478461543, "Min_60.0% Prob": 0.9119862270723018}}
{"hexsha": "290f1b1e289ef853c0757fccf9c2683d1336b132", "ext": "java", "lang": "Java", "content": "public class MainTestCFPGrowth_saveToFile {\r\n\r\n\tpublic static void main(String[] arg) throws FileNotFoundException,\r\n\t\t\tIOException {\r\n\t\tString database = fileToPath(\"contextCFPGrowth.txt\");\r\n\t\tString output = \".//output.txt\";\r\n\t\tString MISfile = fileToPath(\"MIS.txt\");\r\n\r\n\t\t// Applying the CFPGROWTH algorithmMainTestFPGrowth.java\r\n\t\tAlgoCFPGrowth algo = new AlgoCFPGrowth();\r\n\t\talgo.runAlgorithm(database, output, MISfile);\r\n\t\talgo.printStats();\r\n\t}\r\n\r\n\tpublic static String fileToPath(String filename)\r\n\t\t\tthrows UnsupportedEncodingException {\r\n\t\tURL url = MainTestCFPGrowth_saveToFile.class.getResource(filename);\r\n\t\treturn java.net.URLDecoder.decode(url.getPath(), \"UTF-8\");\r\n\t}\r\n}", "class_id": 0, "repo": "matheusmmcs/SPMF-UseSkill", "file": "src/ca/pfv/spmf/test/MainTestCFPGrowth_saveToFile.java", "last_update_at": "2018-08-09T05:06:54+00:00", "question_id": "290f1b1e289ef853c0757fccf9c2683d1336b132", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MainTestCFPGrowth_saveToFile {\r\n\r\n\tpublic static void main(String[] arg) throws FileNotFoundException,\r\n\t\t\tIOException {\r\n\t\tString database = fileToPath(\"contextCFPGrowth.txt\");\r\n\t\tString output = \".//output.txt\";\r\n\t\tString MISfile = fileToPath(\"MIS.txt\");\r\n\r\n\t\t// Applying the CFPGROWTH algorithmMainTestFPGrowth.java\r\n\t\tAlgoCFPGrowth algo = new AlgoCFPGrowth();\r\n\t\talgo.runAlgorithm(database, output, MISfile);\r\n\t\talgo.printStats();\r\n\t}\r\n\r\n\tpublic static String fileToPath(String filename)\r\n\t\t\tthrows UnsupportedEncodingException {\r\n\t\tURL url = MainTestCFPGrowth_saveToFile.class.getResource(filename);\r\n\t\treturn java.net.URLDecoder.decode(url.getPath(), \"UTF-8\");\r\n\t}\r\n"]], "pred": {"ppl": 2.076610803604126, "ppl_lower": 3.4662952423095703, "ppl/lowercase_ppl": -1.7011402544596053, "ppl/zlib": 0.0020075196247755166, "Min_5.0% Prob": 7.813490304079923, "Min_10.0% Prob": 5.741211849710216, "Min_20.0% Prob": 3.507900138264117, "Min_30.0% Prob": 2.4106708760772433, "Min_40.0% Prob": 1.8325887266346204, "Min_50.0% Prob": 1.4605600215996115, "Min_60.0% Prob": 1.2211898303357884}}
{"hexsha": "613915c52c2920581d0460770d1aea3fd9280ee1", "ext": "java", "lang": "Java", "content": "public class LocationListener  implements android.location.LocationListener{\n\n    private LocationManager mLocationManager = null;\n    public static final int LOCATION_INTERVAL = 1000;\n    public static final float LOCATION_DISTANCE = 10f;\n    private Location mLastLocation;\n    private static final String TAG = \"LocationListener\";\n    public static  final String ShareKeyLongitude = \"Longitude\";\n    public static  final String ShareKeyLatitude= \"Latitude\";\n    Context context;\n\n    public LocationListener(String provider, Context context) {\n        Log.e(TAG, \"LocationListener s\" + provider);\n        mLastLocation = new Location(provider);\n        this.context = context;\n    }\n\n    @Override\n    public void onLocationChanged(Location location) {\n        Log.e(TAG, \"onLocationChanged: \" + location);\n        mLastLocation.set(location);\n\n        Log.e(TAG, \"onLocationChanged: \" + location);\n        mLastLocation.set(location);\n        double longitude = location.getLongitude();\n        double latitude = location.getLatitude();\n        Log.e(TAG, \"Longitude: \" + longitude);\n        Log.e(TAG, \"latitude: \" + latitude);\n\n\n    //    Toast.makeText(context,longitude + \"/ \"+ latitude + \" \",Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onStatusChanged(String provider, int status, Bundle extras) {\n        Log.e(TAG, \"onStatusChanged: \" + provider);\n    }\n\n    @Override\n    public void onProviderEnabled(String provider) {\n        Log.e(TAG, \"onProviderEnabled: \" + provider);\n    }\n\n    @Override\n    public void onProviderDisabled(String provider) {\n        Log.e(TAG, \"onProviderDisabled: \" + provider);\n        Toast.makeText(context,\"GPS is de\",Toast.LENGTH_LONG).show();\n\n    }\n}", "class_id": 0, "repo": "gminchev1982/softuni-android", "file": "SharePreferences/app/src/main/java/com/example/gminchev/sharepreferences/old/LocationListener.java", "last_update_at": "2018-03-23T13:00:25+00:00", "question_id": "613915c52c2920581d0460770d1aea3fd9280ee1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LocationListener  implements android.location.LocationListener{\n    private LocationManager mLocationManager = null;\n    public static final int LOCATION_INTERVAL = 1000;\n    public static final float LOCATION_DISTANCE = 10f;\n    private Location mLastLocation;\n    private static final String TAG = \"LocationListener\";\n    public static  final String ShareKeyLongitude = \"Longitude\";\n    public static  final String ShareKeyLatitude= \"Latitude\";\n    Context context;\n    public LocationListener(String provider, Context context) {\n        Log.e(TAG, \"LocationListener s\" + provider);\n        mLastLocation = new Location(provider);\n        this.context = context;\n    }\n    @Override\n    public void onLocationChanged(Location location) {\n        Log.e(TAG, \"onLocationChanged: \" + location);\n        mLastLocation.set(location);\n        Log.e(TAG, \"onLocationChanged: \" + location);\n        mLastLocation.set(location);\n        double longitude = location.getLongitude();\n        double latitude = location.getLatitude();\n        Log.e(TAG, \"Longitude: \" + longitude);\n        Log.e(TAG, \"latitude: \" + latitude);\n    //    Toast.makeText(context,longitude + \"/ \"+ latitude + \" \",Toast.LENGTH_LONG).show();\n    }\n    @Override\n    public void onStatusChanged(String provider, int status, Bundle extras) {\n        Log.e(TAG, \"onStatusChanged: \" + provider);\n    }\n    @Override\n    public void onProviderEnabled(String provider) {\n        Log.e(TAG, \"onProviderEnabled: \" + provider);\n    }\n    @Override\n    public void onProviderDisabled(String provider) {\n        Log.e(TAG, \"onProviderDisabled: \" + provider);\n        Toast.makeText(context,\"GPS is de\",Toast.LENGTH_LONG).show();\n    }\n"]], "pred": {"ppl": 1.7254834175109863, "ppl_lower": 1.9837214946746826, "ppl/lowercase_ppl": -1.2556654732817327, "ppl/zlib": 0.00106336696541562, "Min_5.0% Prob": 5.827996378359587, "Min_10.0% Prob": 4.068610807682606, "Min_20.0% Prob": 2.519032161486776, "Min_30.0% Prob": 1.778014855368154, "Min_40.0% Prob": 1.3557201648101758, "Min_50.0% Prob": 1.089668836678421, "Min_60.0% Prob": 0.9093535436245934}}
{"hexsha": "5997ff230f5fd11630bfc17870488a89906e018d", "ext": "java", "lang": "Java", "content": "public class CutableTextView extends AppCompatTextView {\n\n    private boolean clicked = false;\n    private boolean linesRendered = false;\n    private int totalCountLines;\n    private int linesToCut;\n\n    private static final String PROPERTY_MAX_LINES = \"maxLines\";\n\n    public CutableTextView(Context context) {\n        super(context);\n        init(context , null);\n        linesToCut = 4;\n    }\n\n    public CutableTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context , attrs);\n    }\n\n    public CutableTextView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context , attrs);\n    }\n\n    public void setLinesToCut(int linesToCut){\n        this.linesToCut = linesToCut;\n    }\n\n    @Override\n    public void setText(CharSequence text, BufferType type) {\n        super.setText(text, type);\n        post(() -> {\n            if (getLineCount() > linesToCut && !linesRendered){\n                totalCountLines = getLineCount();\n                linesRendered = true;\n            }\n            if (totalCountLines > linesToCut){\n                setLines(linesToCut);\n            }\n        });\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(event.getAction() == MotionEvent.ACTION_UP) {\n            if (!clicked) {\n                expandAnimation();\n                clicked = true;\n            } else {\n                collapseAnimation();\n                clicked = false;\n            }\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    private void expandAnimation(){\n        startMaxLineAnimationChanger(totalCountLines , 0);\n    }\n\n    private void collapseAnimation(){\n        startMaxLineAnimationChanger(totalCountLines , linesToCut);\n    }\n\n    private void startMaxLineAnimationChanger(int from , int to) {\n        if (totalCountLines > linesToCut){\n            ObjectAnimator objectAnimator = ObjectAnimator.ofInt(this, PROPERTY_MAX_LINES, from , to);\n            if (to == 0){\n                objectAnimator = ObjectAnimator.ofInt(this , PROPERTY_MAX_LINES , from);\n            }\n            if (totalCountLines <= 8){\n                objectAnimator.setDuration(70);\n            }\n            objectAnimator.start();\n        }\n    }\n\n    private void init(Context context , @Nullable AttributeSet attrs) {\n        if (attrs != null){\n            TypedArray a = context.obtainStyledAttributes(attrs , R.styleable.CutableTextView);\n            linesToCut = a.getInt(R.styleable.CutableTextView_ctv_lines_to_cut , 4);\n            a.recycle();\n        }\n        setEllipsize(TextUtils.TruncateAt.END);\n        setClickable(true);\n        setFocusable(true);\n        TypedValue typedValue = new TypedValue();\n        context.getTheme().resolveAttribute(R.attr.selectableItemBackground , typedValue , true);\n        setBackgroundResource(typedValue.resourceId);\n    }\n}", "class_id": 0, "repo": "Devit951/CutableTextView", "file": "cutabletextview/src/main/java/com/david/cutabletextview/CutableTextView.java", "last_update_at": "2018-09-27T04:17:22+00:00", "question_id": "5997ff230f5fd11630bfc17870488a89906e018d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CutableTextView extends AppCompatTextView {\n    private boolean clicked = false;\n    private boolean linesRendered = false;\n    private int totalCountLines;\n    private int linesToCut;\n    private static final String PROPERTY_MAX_LINES = \"maxLines\";\n    public CutableTextView(Context context) {\n        super(context);\n        init(context , null);\n        linesToCut = 4;\n    }\n    public CutableTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context , attrs);\n    }\n    public CutableTextView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context , attrs);\n    }\n    public void setLinesToCut(int linesToCut){\n        this.linesToCut = linesToCut;\n    }\n    @Override\n    public void setText(CharSequence text, BufferType type) {\n        super.setText(text, type);\n        post(() -> {\n            if (getLineCount() > linesToCut && !linesRendered){\n                totalCountLines = getLineCount();\n                linesRendered = true;\n            }\n            if (totalCountLines > linesToCut){\n                setLines(linesToCut);\n            }\n        });\n    }\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(event.getAction() == MotionEvent.ACTION_UP) {\n            if (!clicked) {\n                expandAnimation();\n                clicked = true;\n            } else {\n                collapseAnimation();\n                clicked = false;\n            }\n        }\n        return super.dispatchTouchEvent(event);\n    }\n    private void expandAnimation(){\n        startMaxLineAnimationChanger(totalCountLines , 0);\n    }\n    private void collapseAnimation(){\n        startMaxLineAnimationChanger(totalCountLines , linesToCut);\n    }\n    private void startMaxLineAnimationChanger(int from , int to) {\n        if (totalCountLines > linesToCut){\n            ObjectAnimator objectAnimator = ObjectAnimator.ofInt(this, PROPERTY_MAX_LINES, from , to);\n            if (to == 0){\n                objectAnimator = ObjectAnimator.ofInt(this , PROPERTY_MAX_LINES , from);\n            }\n            if (totalCountLines <= 8){\n                objectAnimator.setDuration(70);\n            }\n            objectAnimator.start();\n        }\n    }\n    private void init(Context context , @Nullable AttributeSet attrs) {\n        if (attrs != null){\n            TypedArray a = context.obtainStyledAttributes(attrs , R.styleable.CutableTextView);\n            linesToCut = a.getInt(R.styleable.CutableTextView_ctv_lines_to_cut , 4);\n            a.recycle();\n        }\n        setEllipsize(TextUtils.TruncateAt.END);\n        setClickable(true);\n        setFocusable(true);\n        TypedValue typedValue = new TypedValue();\n        context.getTheme().resolveAttribute(R.attr.selectableItemBackground , typedValue , true);\n        setBackgroundResource(typedValue.resourceId);\n    }\n"]], "pred": {"ppl": 1.6447376012802124, "ppl_lower": 1.8206441402435303, "ppl/lowercase_ppl": -1.204207017480986, "ppl/zlib": 0.0005616036778715944, "Min_5.0% Prob": 5.681265217065811, "Min_10.0% Prob": 3.832779516408473, "Min_20.0% Prob": 2.3303480602708864, "Min_30.0% Prob": 1.6318194336361356, "Min_40.0% Prob": 1.2385797633754987, "Min_50.0% Prob": 0.9948253165102667, "Min_60.0% Prob": 0.8299935514015364}}
{"hexsha": "2489be4ae5734e9b9f38cc05d9268d79359561d5", "ext": "java", "lang": "Java", "content": "public class LightPsiClassBuilder extends LightPsiClassBase implements OriginInfoAwareElement {\n\n  private final LightModifierList myModifierList = new LightModifierList(getManager());\n  private final LightReferenceListBuilder myImplementsList = new LightReferenceListBuilder(getManager(), IMPLEMENTS_LIST);\n  private final LightReferenceListBuilder myExtendsList = new LightReferenceListBuilder(getManager(), EXTENDS_LIST);\n  private final LightTypeParameterListBuilder myTypeParametersList = new LightTypeParameterListBuilder(getManager(), getLanguage());\n  private final Collection<PsiMethod> myMethods = ContainerUtil.newArrayList();\n  private PsiElement myScope;\n  private PsiClass myContainingClass;\n  private String myOriginInfo;\n\n  public LightPsiClassBuilder(@NotNull PsiElement context, @NotNull String name) {\n    super(context, name);\n  }\n\n  @Nullable\n  @Override\n  public String getOriginInfo() {\n    return myOriginInfo;\n  }\n\n  @NotNull\n  @Override\n  public LightModifierList getModifierList() {\n    return myModifierList;\n  }\n\n  @NotNull\n  @Override\n  public LightReferenceListBuilder getExtendsList() {\n    return myExtendsList;\n  }\n\n  @NotNull\n  @Override\n  public LightReferenceListBuilder getImplementsList() {\n    return myImplementsList;\n  }\n\n  @NotNull\n  @Override\n  public PsiField[] getFields() {\n    // TODO\n    return PsiField.EMPTY_ARRAY;\n  }\n\n  @NotNull\n  @Override\n  public PsiMethod[] getMethods() {\n    return myMethods.toArray(PsiMethod.EMPTY_ARRAY);\n  }\n\n  @NotNull\n  @Override\n  public PsiClass[] getInnerClasses() {\n    // TODO\n    return PsiClass.EMPTY_ARRAY;\n  }\n\n  @NotNull\n  @Override\n  public PsiClassInitializer[] getInitializers() {\n    return PsiClassInitializer.EMPTY_ARRAY;\n  }\n\n  @Override\n  public PsiElement getScope() {\n    return myScope;\n  }\n\n  @Nullable\n  @Override\n  public PsiClass getContainingClass() {\n    return myContainingClass;\n  }\n\n  @NotNull\n  @Override\n  public LightTypeParameterListBuilder getTypeParameterList() {\n    return myTypeParametersList;\n  }\n\n  @Override\n  public boolean isEquivalentTo(PsiElement another) {\n    return PsiClassImplUtil.isClassEquivalentTo(this, another);\n  }\n\n  public LightPsiClassBuilder setOriginInfo(String originInfo) {\n    myOriginInfo = originInfo;\n    return this;\n  }\n\n  public LightPsiClassBuilder setScope(PsiElement scope) {\n    myScope = scope;\n    return this;\n  }\n\n  public LightPsiClassBuilder setContainingClass(PsiClass containingClass) {\n    myContainingClass = containingClass;\n    return this;\n  }\n\n  public LightPsiClassBuilder addMethod(PsiMethod method) {\n    if (method instanceof LightMethodBuilder) {\n      ((LightMethodBuilder)method).setContainingClass(this);\n    }\n    myMethods.add(method);\n    return this;\n  }\n}", "class_id": 0, "repo": "jnthn/intellij-community", "file": "java/java-psi-impl/src/com/intellij/psi/impl/light/LightPsiClassBuilder.java", "last_update_at": "2018-12-29T09:53:42+00:00", "question_id": "2489be4ae5734e9b9f38cc05d9268d79359561d5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LightPsiClassBuilder extends LightPsiClassBase implements OriginInfoAwareElement {\n  private final LightModifierList myModifierList = new LightModifierList(getManager());\n  private final LightReferenceListBuilder myImplementsList = new LightReferenceListBuilder(getManager(), IMPLEMENTS_LIST);\n  private final LightReferenceListBuilder myExtendsList = new LightReferenceListBuilder(getManager(), EXTENDS_LIST);\n  private final LightTypeParameterListBuilder myTypeParametersList = new LightTypeParameterListBuilder(getManager(), getLanguage());\n  private final Collection<PsiMethod> myMethods = ContainerUtil.newArrayList();\n  private PsiElement myScope;\n  private PsiClass myContainingClass;\n  private String myOriginInfo;\n  public LightPsiClassBuilder(@NotNull PsiElement context, @NotNull String name) {\n    super(context, name);\n  }\n  @Nullable\n  @Override\n  public String getOriginInfo() {\n    return myOriginInfo;\n  }\n  @NotNull\n  @Override\n  public LightModifierList getModifierList() {\n    return myModifierList;\n  }\n  @NotNull\n  @Override\n  public LightReferenceListBuilder getExtendsList() {\n    return myExtendsList;\n  }\n  @NotNull\n  @Override\n  public LightReferenceListBuilder getImplementsList() {\n    return myImplementsList;\n  }\n  @NotNull\n  @Override\n  public PsiField[] getFields() {\n    // TODO\n    return PsiField.EMPTY_ARRAY;\n  }\n  @NotNull\n  @Override\n  public PsiMethod[] getMethods() {\n    return myMethods.toArray(PsiMethod.EMPTY_ARRAY);\n  }\n  @NotNull\n  @Override\n  public PsiClass[] getInnerClasses() {\n    // TODO\n    return PsiClass.EMPTY_ARRAY;\n  }\n  @NotNull\n  @Override\n  public PsiClassInitializer[] getInitializers() {\n    return PsiClassInitializer.EMPTY_ARRAY;\n  }\n  @Override\n  public PsiElement getScope() {\n    return myScope;\n  }\n  @Nullable\n  @Override\n  public PsiClass getContainingClass() {\n    return myContainingClass;\n  }\n  @NotNull\n  @Override\n  public LightTypeParameterListBuilder getTypeParameterList() {\n    return myTypeParametersList;\n  }\n  @Override\n  public boolean isEquivalentTo(PsiElement another) {\n    return PsiClassImplUtil.isClassEquivalentTo(this, another);\n  }\n  public LightPsiClassBuilder setOriginInfo(String originInfo) {\n    myOriginInfo = originInfo;\n    return this;\n  }\n  public LightPsiClassBuilder setScope(PsiElement scope) {\n    myScope = scope;\n    return this;\n  }\n  public LightPsiClassBuilder setContainingClass(PsiClass containingClass) {\n    myContainingClass = containingClass;\n    return this;\n  }\n  public LightPsiClassBuilder addMethod(PsiMethod method) {\n    if (method instanceof LightMethodBuilder) {\n      ((LightMethodBuilder)method).setContainingClass(this);\n    }\n    myMethods.add(method);\n    return this;\n  }\n"]], "pred": {"ppl": 1.3226209878921509, "ppl_lower": 1.786417007446289, "ppl/lowercase_ppl": -2.0750359782240366, "ppl/zlib": 0.00039052425250608945, "Min_5.0% Prob": 3.7601447850465775, "Min_10.0% Prob": 2.437707807123661, "Min_20.0% Prob": 1.36590250132617, "Min_30.0% Prob": 0.9289809244276941, "Min_40.0% Prob": 0.6993456853066367, "Min_50.0% Prob": 0.5596895879892388, "Min_60.0% Prob": 0.4663459620628141}}
{"hexsha": "1915bb67e7a930d1384da5fcc3688e1c1bea9fbd", "ext": "java", "lang": "Java", "content": "public class SetDepartmentCommandTest {\n\n    private Model model;\n    private CommandHistory commandHistory = new CommandHistory();\n\n    @Before\n    public void setUp() {\n        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());\n    }\n\n    @Test\n    public void constructor_nullParameters_throwsNullPointerException() {\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(null, null);\n        });\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(INDEX_FIRST_PERSON, null);\n        });\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(null, new Department(\"Junior Management\"));\n        });\n    }\n\n    @Test\n    public void execute_notLoggedIn_throwsCommandException() {\n        Assertions.assertThrows(CommandException.class, () -> {\n            SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                    new Department(\"Junior Management\"));\n            sd.execute(model, commandHistory);\n        }, SessionManager.NOT_LOGGED_IN);\n    }\n\n    @Test\n    public void execute_invalidPersonIndexFilteredList_failure() throws CommandException {\n        showPersonAtIndex(model, INDEX_FIRST_PERSON);\n        Index outOfBoundIndex = INDEX_SECOND_PERSON;\n        // ensures that outOfBoundIndex is still in bounds of address book list\n        assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getPersonList().size());\n\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n\n        SetDepartmentCommand sd = new SetDepartmentCommand(outOfBoundIndex,\n                new Department(\"Junior Management\"));\n\n        assertCommandFailure(sd, model, commandHistory, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);\n    }\n\n    /**\n     * After this test method, Alice's Department remains, whereas Daniel's Department will become Junior Management.\n     */\n    @Test\n    public void execute_setDepartmentOfFourthPerson_success() throws CommandException {\n        SessionManager.getInstance(model).destroy();\n        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());\n\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n\n        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)\n                .withDepartment(\"Junior Management\").build();\n\n        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());\n        expectedModel.updatePerson(TypicalPersons.DANIEL, editedDaniel);\n        expectedModel.commitAddressBook();\n\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FOURTH_PERSON,\n                new Department(\"Junior Management\"));\n        String expectedMessage = String.format(SetDepartmentCommand.MESSAGE_CHANGE_DEPARTMENT_SUCCESS,\n                TypicalPersons.DANIEL.getName(), \"Junior Management\");\n        assertCommandSuccess(sd, model, commandHistory, expectedMessage, expectedModel);\n    }\n\n    @Test\n    public void execute_insufficientPriorityLevel_throwsCommandException() throws CommandException {\n        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)\n                .withPriorityLevel(PriorityLevelEnum.BASIC.getPriorityLevelCode()).build();\n        model.updatePerson(TypicalPersons.DANIEL, editedDaniel);\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.DANIEL.getNric(),\n                TypicalPersons.DANIEL.getPassword());\n        loginCommand.execute(model, commandHistory);\n\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                new Department(\"Junior Management\"));\n\n        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),\n                String.format(PriorityLevel.INSUFFICIENT_PRIORITY_LEVEL, PriorityLevelEnum.ADMINISTRATOR));\n\n    }\n\n    @Test\n    public void execute_editOwnDepartment_throwsCommandException() throws CommandException {\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                new Department(\"Senior Management\"));\n\n        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),\n                SetDepartmentCommand.MESSAGE_CANNOT_EDIT_OWN_DEPARTMENT);\n    }\n\n    /**\n     * Logs out of the application after each test\n     */\n    @After\n    public void tearDown() throws CommandException {\n        try {\n            new LogoutCommand().execute(model, commandHistory);\n        } catch (CommandException ce) {\n            //Ignores the CommandException if user is not logged in in the first place.\n            if (!ce.getMessage().equals(LogoutCommand.NOT_LOGGED_IN)) {\n                throw new CommandException(ce.getMessage());\n            }\n        } finally {\n            SessionManager.getInstance(model).destroy();\n        }\n    }\n}", "class_id": 0, "repo": "speezy37/main", "file": "src/test/java/seedu/address/logic/commands/SetDepartmentCommandTest.java", "last_update_at": "2018-10-30T15:05:15+00:00", "question_id": "1915bb67e7a930d1384da5fcc3688e1c1bea9fbd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SetDepartmentCommandTest {\n    private Model model;\n    private CommandHistory commandHistory = new CommandHistory();\n    @Before\n    public void setUp() {\n        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());\n    }\n    @Test\n    public void constructor_nullParameters_throwsNullPointerException() {\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(null, null);\n        });\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(INDEX_FIRST_PERSON, null);\n        });\n        Assertions.assertThrows(NullPointerException.class, () -> {\n            new SetDepartmentCommand(null, new Department(\"Junior Management\"));\n        });\n    }\n    @Test\n    public void execute_notLoggedIn_throwsCommandException() {\n        Assertions.assertThrows(CommandException.class, () -> {\n            SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                    new Department(\"Junior Management\"));\n            sd.execute(model, commandHistory);\n        }, SessionManager.NOT_LOGGED_IN);\n    }\n    @Test\n    public void execute_invalidPersonIndexFilteredList_failure() throws CommandException {\n        showPersonAtIndex(model, INDEX_FIRST_PERSON);\n        Index outOfBoundIndex = INDEX_SECOND_PERSON;\n        // ensures that outOfBoundIndex is still in bounds of address book list\n        assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getPersonList().size());\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n        SetDepartmentCommand sd = new SetDepartmentCommand(outOfBoundIndex,\n                new Department(\"Junior Management\"));\n        assertCommandFailure(sd, model, commandHistory, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);\n    }\n    /**\n     * After this test method, Alice's Department remains, whereas Daniel's Department will become Junior Management.\n     */\n    @Test\n    public void execute_setDepartmentOfFourthPerson_success() throws CommandException {\n        SessionManager.getInstance(model).destroy();\n        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)\n                .withDepartment(\"Junior Management\").build();\n        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());\n        expectedModel.updatePerson(TypicalPersons.DANIEL, editedDaniel);\n        expectedModel.commitAddressBook();\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FOURTH_PERSON,\n                new Department(\"Junior Management\"));\n        String expectedMessage = String.format(SetDepartmentCommand.MESSAGE_CHANGE_DEPARTMENT_SUCCESS,\n                TypicalPersons.DANIEL.getName(), \"Junior Management\");\n        assertCommandSuccess(sd, model, commandHistory, expectedMessage, expectedModel);\n    }\n    @Test\n    public void execute_insufficientPriorityLevel_throwsCommandException() throws CommandException {\n        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)\n                .withPriorityLevel(PriorityLevelEnum.BASIC.getPriorityLevelCode()).build();\n        model.updatePerson(TypicalPersons.DANIEL, editedDaniel);\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.DANIEL.getNric(),\n                TypicalPersons.DANIEL.getPassword());\n        loginCommand.execute(model, commandHistory);\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                new Department(\"Junior Management\"));\n        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),\n                String.format(PriorityLevel.INSUFFICIENT_PRIORITY_LEVEL, PriorityLevelEnum.ADMINISTRATOR));\n    }\n    @Test\n    public void execute_editOwnDepartment_throwsCommandException() throws CommandException {\n        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),\n                TypicalPersons.ALICE.getPassword());\n        loginCommand.execute(model, commandHistory);\n        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,\n                new Department(\"Senior Management\"));\n        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),\n                SetDepartmentCommand.MESSAGE_CANNOT_EDIT_OWN_DEPARTMENT);\n    }\n    /**\n     * Logs out of the application after each test\n     */\n    @After\n    public void tearDown() throws CommandException {\n        try {\n            new LogoutCommand().execute(model, commandHistory);\n        } catch (CommandException ce) {\n            //Ignores the CommandException if user is not logged in in the first place.\n            if (!ce.getMessage().equals(LogoutCommand.NOT_LOGGED_IN)) {\n                throw new CommandException(ce.getMessage());\n            }\n        } finally {\n            SessionManager.getInstance(model).destroy();\n        }\n    }\n"]], "pred": {"ppl": 1.460752248764038, "ppl_lower": 1.8763514757156372, "ppl/lowercase_ppl": -1.660711508539974, "ppl/zlib": 0.0002995664362922908, "Min_5.0% Prob": 5.214502998426849, "Min_10.0% Prob": 3.3655140096066045, "Min_20.0% Prob": 1.8645439172419263, "Min_30.0% Prob": 1.260487738333253, "Min_40.0% Prob": 0.9462412008332558, "Min_50.0% Prob": 0.758217761943248, "Min_60.0% Prob": 0.6322995330274278}}
{"hexsha": "3ae5046e1ffa6c99f103dd166d9f4d30aea77c7d", "ext": "java", "lang": "Java", "content": "public class JBossASTest {\n\n\tprivate static final String SERVER_HOME = \"/Users/john01/projectZ/torquebox/jboss\";\n\n\t@Test(dataProvider = \"getServerProperties\")\n\tpublic void shouldStartJBossWithProperCommand(ServerProperties properties, String expectedCommand) throws Exception {\n\t    // Given\n\t\tAbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();\n\n\t\t// When\n\t\tString[] command = jboss.startCommand();\n\n\t    // Then\n\t\tassertThat(normalize(command)).isEqualTo(expectedCommand);\n\t}\n\n    @DataProvider\n    public Object[][] getServerProperties() {\n        return new Object[][]{\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5),\n                        SERVER_HOME + \"/bin/run.sh -c default -Djboss.service.binding.set=ports-02\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username(\"scott\").password(\"tiger\").configuration(\"myconf\").portset(0),\n                        SERVER_HOME + \"/bin/run.sh -c myconf\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties(\"-Dmyprop=val\"),\n                        SERVER_HOME + \"/bin/run.sh -c default -Djboss.service.binding.set=ports-02 -Dmyprop=val\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),\n                        SERVER_HOME + \"/bin/standalone.sh\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),\n                        SERVER_HOME + \"/bin/standalone.sh  -Djboss.socket.binding.port-offset=200\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).configuration(\"mystandalone.xml\").portset(0),\n                        SERVER_HOME + \"/bin/standalone.sh -c mystandalone.xml\"\n                },\n        };\n    }\n\n    @Test(dataProvider = \"getServerPropertiesShutdown\")\n\tpublic void shouldShutdownJBossWithProperCommnd(ServerProperties properties, String expectedCommand) throws Exception {\n\t    // Given\n\t     AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();\n\n\t\t// When\n\t\tString[] command = jboss.shutdownCommand();\n\n\t    // Then\n\t\tassertThat(normalize(command)).isEqualTo(expectedCommand);\n\t}\n\n\t@DataProvider\n    public Object[][] getServerPropertiesShutdown() {\n        return new Object[][]{\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5),\n                        SERVER_HOME + \"/bin/shutdown.sh --server=localhost:1299 -S\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username(\"scott\").password(\"tiger\").configuration(\"myconf\").portset(0),\n                        SERVER_HOME + \"/bin/shutdown.sh --server=localhost:1099 -S -u scott -p tiger\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties(\"-Dmyprop=val\"),\n                        SERVER_HOME + \"/bin/shutdown.sh --host=localhost --port=1290 -S\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown --controller=localhost:10199\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0).secured(true).username(\"scott\").password(\"tiger\"),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown --user=scott --password=tiger\"\n                },\n        };\n    }\n\n    private static String normalize(String[] command) {\n\t\treturn Arrays.toString(command).replaceAll(\"[,\\\\[\\\\]]\",\"\").trim();\n\t}\n}", "class_id": 0, "repo": "softwaremill/softwaremill-common", "file": "softwaremill-test/softwaremill-test-ui-web/src/test/java/com/softwaremill/common/test/web/jboss/server/JBossASTest.java", "last_update_at": "2018-12-31T23:19:16+00:00", "question_id": "3ae5046e1ffa6c99f103dd166d9f4d30aea77c7d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JBossASTest {\n\tprivate static final String SERVER_HOME = \"/Users/john01/projectZ/torquebox/jboss\";\n\t@Test(dataProvider = \"getServerProperties\")\n\tpublic void shouldStartJBossWithProperCommand(ServerProperties properties, String expectedCommand) throws Exception {\n\t    // Given\n\t\tAbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();\n\t\t// When\n\t\tString[] command = jboss.startCommand();\n\t    // Then\n\t\tassertThat(normalize(command)).isEqualTo(expectedCommand);\n\t}\n    @DataProvider\n    public Object[][] getServerProperties() {\n        return new Object[][]{\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5),\n                        SERVER_HOME + \"/bin/run.sh -c default -Djboss.service.binding.set=ports-02\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username(\"scott\").password(\"tiger\").configuration(\"myconf\").portset(0),\n                        SERVER_HOME + \"/bin/run.sh -c myconf\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties(\"-Dmyprop=val\"),\n                        SERVER_HOME + \"/bin/run.sh -c default -Djboss.service.binding.set=ports-02 -Dmyprop=val\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),\n                        SERVER_HOME + \"/bin/standalone.sh\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),\n                        SERVER_HOME + \"/bin/standalone.sh  -Djboss.socket.binding.port-offset=200\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).configuration(\"mystandalone.xml\").portset(0),\n                        SERVER_HOME + \"/bin/standalone.sh -c mystandalone.xml\"\n                },\n        };\n    }\n    @Test(dataProvider = \"getServerPropertiesShutdown\")\n\tpublic void shouldShutdownJBossWithProperCommnd(ServerProperties properties, String expectedCommand) throws Exception {\n\t    // Given\n\t     AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();\n\t\t// When\n\t\tString[] command = jboss.shutdownCommand();\n\t    // Then\n\t\tassertThat(normalize(command)).isEqualTo(expectedCommand);\n\t}\n\t@DataProvider\n    public Object[][] getServerPropertiesShutdown() {\n        return new Object[][]{\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5),\n                        SERVER_HOME + \"/bin/shutdown.sh --server=localhost:1299 -S\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username(\"scott\").password(\"tiger\").configuration(\"myconf\").portset(0),\n                        SERVER_HOME + \"/bin/shutdown.sh --server=localhost:1099 -S -u scott -p tiger\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties(\"-Dmyprop=val\"),\n                        SERVER_HOME + \"/bin/shutdown.sh --host=localhost --port=1290 -S\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown --controller=localhost:10199\"\n                },\n                {\n                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0).secured(true).username(\"scott\").password(\"tiger\"),\n                        SERVER_HOME + \"/bin/jboss-cli.sh --connect command=:shutdown --user=scott --password=tiger\"\n                },\n        };\n    }\n    private static String normalize(String[] command) {\n\t\treturn Arrays.toString(command).replaceAll(\"[,\\\\[\\\\]]\",\"\").trim();\n\t}\n"]], "pred": {"ppl": 1.7649027109146118, "ppl_lower": 1.9255281686782837, "ppl/lowercase_ppl": -1.1533276104350723, "ppl/zlib": 0.0006819874760758561, "Min_5.0% Prob": 6.0204870373595, "Min_10.0% Prob": 4.371386796820397, "Min_20.0% Prob": 2.6740843866970025, "Min_30.0% Prob": 1.8710683820391791, "Min_40.0% Prob": 1.415132671981722, "Min_50.0% Prob": 1.1357120065357529, "Min_60.0% Prob": 0.9475623585559507}}
{"hexsha": "51da26424db1ce4133463ca48656f0ba823c718a", "ext": "java", "lang": "Java", "content": "public class JobRebalancer extends TaskRebalancer {\n  private static final Logger LOG = LoggerFactory.getLogger(JobRebalancer.class);\n  private static TaskAssignmentCalculator _fixTaskAssignmentCal =\n      new FixedTargetTaskAssignmentCalculator();\n  private static TaskAssignmentCalculator _genericTaskAssignmentCal =\n      new GenericTaskAssignmentCalculator();\n\n  private static final String PREV_RA_NODE = \"PreviousResourceAssignment\";\n\n  @Override\n  public ResourceAssignment computeBestPossiblePartitionState(ClusterDataCache clusterData,\n      IdealState taskIs, Resource resource, CurrentStateOutput currStateOutput) {\n    final String jobName = resource.getResourceName();\n    LOG.debug(\"Computer Best Partition for job: \" + jobName);\n\n    // Fetch job configuration\n    JobConfig jobCfg = clusterData.getJobConfig(jobName);\n    if (jobCfg == null) {\n      LOG.error(\"Job configuration is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    String workflowResource = jobCfg.getWorkflow();\n\n    // Fetch workflow configuration and context\n    WorkflowConfig workflowCfg = clusterData.getWorkflowConfig(workflowResource);\n    if (workflowCfg == null) {\n      LOG.error(\"Workflow configuration is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    WorkflowContext workflowCtx = clusterData.getWorkflowContext(workflowResource);\n    if (workflowCtx == null) {\n      LOG.error(\"Workflow context is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    TargetState targetState = workflowCfg.getTargetState();\n    if (targetState != TargetState.START && targetState != TargetState.STOP) {\n      LOG.info(\"Target state is \" + targetState.name() + \" for workflow \" + workflowResource\n          + \".Stop scheduling job \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    // Stop current run of the job if workflow or job is already in final state (failed or completed)\n    TaskState workflowState = workflowCtx.getWorkflowState();\n    TaskState jobState = workflowCtx.getJobState(jobName);\n    // The job is already in a final state (completed/failed).\n    if (workflowState == TaskState.FAILED || workflowState == TaskState.COMPLETED ||\n        jobState == TaskState.FAILED || jobState == TaskState.COMPLETED) {\n      LOG.info(String.format(\n          \"Workflow %s or job %s is already failed or completed, workflow state (%s), job state (%s), clean up job IS.\",\n          workflowResource, jobName, workflowState, jobState));\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);\n      _rebalanceScheduler.removeScheduledRebalance(jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    if (!isWorkflowReadyForSchedule(workflowCfg)) {\n      LOG.info(\"Job is not ready to be run since workflow is not ready \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    if (!isJobStarted(jobName, workflowCtx) && !isJobReadyToSchedule(jobName, workflowCfg,\n        workflowCtx, getInCompleteJobCount(workflowCfg, workflowCtx),\n        clusterData.getJobConfigMap())) {\n      LOG.info(\"Job is not ready to run \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n\n    // Fetch any existing context information from the property store.\n    JobContext jobCtx = clusterData.getJobContext(jobName);\n    if (jobCtx == null) {\n      jobCtx = new JobContext(new ZNRecord(TaskUtil.TASK_CONTEXT_KW));\n      jobCtx.setStartTime(System.currentTimeMillis());\n      jobCtx.setName(jobName);\n      workflowCtx.setJobState(jobName, TaskState.IN_PROGRESS);\n    }\n\n    scheduleRebalanceForJobTimeout(jobCfg, jobCtx);\n\n    // Grab the old assignment, or an empty one if it doesn't exist\n    ResourceAssignment prevAssignment = getPrevResourceAssignment(jobName);\n    if (prevAssignment == null) {\n      prevAssignment = new ResourceAssignment(jobName);\n    }\n\n    // Will contain the list of partitions that must be explicitly dropped from the ideal state that\n    // is stored in zk.\n    // Fetch the previous resource assignment from the property store. This is required because of\n    // HELIX-230.\n    Set<String> liveInstances = jobCfg.getInstanceGroupTag() == null\n        ? clusterData.getEnabledLiveInstances()\n        : clusterData.getEnabledLiveInstancesWithTag(jobCfg.getInstanceGroupTag());\n\n    if (liveInstances.isEmpty()) {\n      LOG.error(\"No available instance found for job!\");\n    }\n\n    Set<Integer> partitionsToDrop = new TreeSet<Integer>();\n    ResourceAssignment newAssignment =\n        computeResourceMapping(jobName, workflowCfg, jobCfg, prevAssignment, liveInstances,\n            currStateOutput, workflowCtx, jobCtx, partitionsToDrop, clusterData);\n\n    HelixDataAccessor accessor = _manager.getHelixDataAccessor();\n    PropertyKey propertyKey = accessor.keyBuilder().idealStates(jobName);\n    taskIs = clusterData.getIdealState(jobName);\n    if (!partitionsToDrop.isEmpty() && taskIs != null) {\n      for (Integer pId : partitionsToDrop) {\n        taskIs.getRecord().getMapFields().remove(pName(jobName, pId));\n      }\n      accessor.setProperty(propertyKey, taskIs);\n    }\n\n    // Update Workflow and Job context in data cache and ZK.\n    clusterData.updateJobContext(jobName, jobCtx, _manager.getHelixDataAccessor());\n    clusterData\n        .updateWorkflowContext(workflowResource, workflowCtx, _manager.getHelixDataAccessor());\n\n    setPrevResourceAssignment(jobName, newAssignment);\n\n    LOG.debug(\"Job \" + jobName + \" new assignment \" + Arrays\n        .toString(newAssignment.getMappedPartitions().toArray()));\n    return newAssignment;\n  }\n\n  private Set<String> getExcludedInstances(String currentJobName,\n      WorkflowConfig workflowCfg, ClusterDataCache cache) {\n    Set<String> ret = new HashSet<String>();\n\n    if (!workflowCfg.isAllowOverlapJobAssignment()) {\n      // exclude all instances that has been assigned other jobs' tasks\n      for (String jobName : workflowCfg.getJobDag().getAllNodes()) {\n        if (jobName.equals(currentJobName)) {\n          continue;\n        }\n        JobContext jobContext = cache.getJobContext(jobName);\n        if (jobContext == null) {\n          continue;\n        }\n        for (int pId : jobContext.getPartitionSet()) {\n          TaskPartitionState partitionState = jobContext.getPartitionState(pId);\n          if (partitionState == TaskPartitionState.INIT || partitionState == TaskPartitionState.RUNNING) {\n            ret.add(jobContext.getAssignedParticipant(pId));\n          }\n        }\n      }\n    }\n    return ret;\n  }\n\n  private ResourceAssignment computeResourceMapping(String jobResource,\n      WorkflowConfig workflowConfig, JobConfig jobCfg, ResourceAssignment prevTaskToInstanceStateAssignment,\n      Collection<String> liveInstances, CurrentStateOutput currStateOutput,\n      WorkflowContext workflowCtx, JobContext jobCtx, Set<Integer> partitionsToDropFromIs,\n      ClusterDataCache cache) {\n    TargetState jobTgtState = workflowConfig.getTargetState();\n    TaskState jobState = workflowCtx.getJobState(jobResource);\n\n    if (jobState == TaskState.IN_PROGRESS && isJobTimeout(jobCtx, jobCfg)) {\n      jobState = TaskState.TIMING_OUT;\n      workflowCtx.setJobState(jobResource, TaskState.TIMING_OUT);\n    } else if (jobState != TaskState.TIMING_OUT && jobState != TaskState.FAILING) {\n      // TIMING_OUT/FAILING/ABORTING job can't be stopped, because all tasks are being aborted\n      // Update running status in workflow context\n      if (jobTgtState == TargetState.STOP) {\n        if (checkJobStopped(jobCtx)) {\n          workflowCtx.setJobState(jobResource, TaskState.STOPPED);\n        } else {\n          workflowCtx.setJobState(jobResource, TaskState.STOPPING);\n        }\n        // Workflow has been stopped if all in progress jobs are stopped\n        if (isWorkflowStopped(workflowCtx, workflowConfig)) {\n          workflowCtx.setWorkflowState(TaskState.STOPPED);\n        } else {\n          workflowCtx.setWorkflowState(TaskState.STOPPING);\n        }\n      } else {\n        workflowCtx.setJobState(jobResource, TaskState.IN_PROGRESS);\n        // Workflow is in progress if any task is in progress\n        workflowCtx.setWorkflowState(TaskState.IN_PROGRESS);\n      }\n    }\n\n    // Used to keep track of tasks that have already been assigned to instances.\n    Set<Integer> assignedPartitions = new HashSet<Integer>();\n\n    // Used to keep track of tasks that have failed, but whose failure is acceptable\n    Set<Integer> skippedPartitions = new HashSet<Integer>();\n\n    // Keeps a mapping of (partition) -> (instance, state)\n    Map<Integer, PartitionAssignment> paMap = new TreeMap<Integer, PartitionAssignment>();\n\n    Set<String> excludedInstances = getExcludedInstances(jobResource, workflowConfig, cache);\n\n    // Process all the current assignments of tasks.\n    TaskAssignmentCalculator taskAssignmentCal = getAssignmentCalulator(jobCfg);\n    Set<Integer> allPartitions = taskAssignmentCal\n        .getAllTaskPartitions(jobCfg, jobCtx, workflowConfig, workflowCtx, cache.getIdealStates());\n\n    if (allPartitions == null || allPartitions.isEmpty()) {\n      // Empty target partitions, mark the job as FAILED.\n      String failureMsg = \"Empty task partition mapping for job \" + jobResource + \", marked the job as FAILED!\";\n      LOG.info(failureMsg);\n      jobCtx.setInfo(failureMsg);\n      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n      markAllPartitionsError(jobCtx, TaskPartitionState.ERROR, false);\n      return new ResourceAssignment(jobResource);\n    }\n\n    Map<String, SortedSet<Integer>> prevInstanceToTaskAssignments =\n        getPrevInstanceToTaskAssignments(liveInstances, prevTaskToInstanceStateAssignment, allPartitions);\n    long currentTime = System.currentTimeMillis();\n\n    LOG.debug(\"All partitions: \" + allPartitions + \" taskAssignment: \" + prevInstanceToTaskAssignments\n        + \" excludedInstances: \" + excludedInstances);\n\n    // Iterate through all instances\n    for (String instance : prevInstanceToTaskAssignments.keySet()) {\n      if (excludedInstances.contains(instance)) {\n        continue;\n      }\n\n      Set<Integer> pSet = prevInstanceToTaskAssignments.get(instance);\n      // Used to keep track of partitions that are in one of the final states: COMPLETED, TIMED_OUT,\n      // TASK_ERROR, ERROR.\n      Set<Integer> donePartitions = new TreeSet<Integer>();\n      for (int pId : pSet) {\n        final String pName = pName(jobResource, pId);\n        TaskPartitionState currState =\n            updateJobContextAndGetTaskCurrentState(currStateOutput, jobResource, pId, pName, instance, jobCtx);\n\n        // Check for pending state transitions on this (partition, instance).\n        Message pendingMessage =\n            currStateOutput.getPendingState(jobResource, new Partition(pName), instance);\n        if (pendingMessage != null && !pendingMessage.getToState().equals(currState.name())) {\n          processTaskWithPendingMessage(prevTaskToInstanceStateAssignment, pId, pName, instance,\n              pendingMessage, jobState, currState, paMap, assignedPartitions);\n          continue;\n        }\n\n        // Process any requested state transitions.\n        String requestedStateStr =\n            currStateOutput.getRequestedState(jobResource, new Partition(pName), instance);\n        if (requestedStateStr != null && !requestedStateStr.isEmpty()) {\n          TaskPartitionState requestedState = TaskPartitionState.valueOf(requestedStateStr);\n          if (requestedState.equals(currState)) {\n            LOG.warn(String.format(\n                \"Requested state %s is the same as the current state for instance %s.\",\n                requestedState, instance));\n          }\n\n          paMap.put(pId, new PartitionAssignment(instance, requestedState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\n              \"Instance %s requested a state transition to %s for partition %s.\", instance,\n              requestedState, pName));\n          continue;\n        }\n\n        switch (currState) {\n        case RUNNING: {\n          TaskPartitionState nextState = TaskPartitionState.RUNNING;\n          if (jobState == TaskState.TIMING_OUT) {\n            nextState = TaskPartitionState.TASK_ABORTED;\n          } else if (jobTgtState == TargetState.STOP) {\n            nextState = TaskPartitionState.STOPPED;\n          }\n\n          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n              nextState, instance));\n        }\n          break;\n        case STOPPED: {\n          TaskPartitionState nextState;\n          if (jobTgtState == TargetState.START) {\n            nextState = TaskPartitionState.RUNNING;\n          } else {\n            nextState = TaskPartitionState.STOPPED;\n          }\n\n          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n              nextState, instance));\n        }\n          break;\n        case COMPLETED: {\n          // The task has completed on this partition. Mark as such in the context object.\n          donePartitions.add(pId);\n          LOG.debug(String\n              .format(\n                  \"Task partition %s has completed with state %s. Marking as such in rebalancer context.\",\n                  pName, currState));\n          partitionsToDropFromIs.add(pId);\n          markPartitionCompleted(jobCtx, pId);\n        }\n          break;\n        case TIMED_OUT:\n        case TASK_ERROR:\n        case TASK_ABORTED:\n        case ERROR: {\n          donePartitions.add(pId); // The task may be rescheduled on a different instance.\n          LOG.debug(String.format(\n              \"Task partition %s has error state %s with msg %s. Marking as such in rebalancer context.\", pName,\n              currState, jobCtx.getPartitionInfo(pId)));\n          markPartitionError(jobCtx, pId, currState, true);\n          // The error policy is to fail the task as soon a single partition fails for a specified\n          // maximum number of attempts or task is in ABORTED state.\n          // But notice that if job is TIMED_OUT, aborted task won't be treated as fail and won't cause job fail.\n          // After all tasks are aborted, they will be dropped, because of job timeout.\n          if (jobState != TaskState.TIMED_OUT && jobState != TaskState.TIMING_OUT) {\n            if (jobCtx.getPartitionNumAttempts(pId) >= jobCfg.getMaxAttemptsPerTask()\n                || currState.equals(TaskPartitionState.TASK_ABORTED)\n                || currState.equals(TaskPartitionState.ERROR)) {\n              skippedPartitions.add(pId);\n              partitionsToDropFromIs.add(pId);\n              LOG.debug(\"skippedPartitions:\" + skippedPartitions);\n            } else {\n              // Mark the task to be started at some later time (if enabled)\n              markPartitionDelayed(jobCfg, jobCtx, pId);\n            }\n          }\n        }\n          break;\n        case INIT:\n        case DROPPED: {\n          // currState in [INIT, DROPPED]. Do nothing, the partition is eligible to be reassigned.\n          donePartitions.add(pId);\n          LOG.debug(String.format(\n              \"Task partition %s has state %s. It will be dropped from the current ideal state.\",\n              pName, currState));\n        }\n          break;\n        default:\n          throw new AssertionError(\"Unknown enum symbol: \" + currState);\n        }\n      }\n\n      // Remove the set of task partitions that are completed or in one of the error states.\n      pSet.removeAll(donePartitions);\n    }\n\n    addGiveupPartitions(skippedPartitions, jobCtx, allPartitions, jobCfg);\n\n    if (jobState == TaskState.IN_PROGRESS && skippedPartitions.size() > jobCfg.getFailureThreshold()) {\n      if (isJobFinished(jobCtx, jobResource, currStateOutput)) {\n        failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n        return buildEmptyAssignment(jobResource, currStateOutput);\n      }\n      workflowCtx.setJobState(jobResource, TaskState.FAILING);\n      // Drop all assigned but not given-up tasks\n      for (int pId : jobCtx.getPartitionSet()) {\n        String instance = jobCtx.getAssignedParticipant(pId);\n        if (jobCtx.getPartitionState(pId) != null && !isTaskGivenup(jobCtx, jobCfg, pId)) {\n          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.TASK_ABORTED.name()));\n        }\n        Partition partition = new Partition(pName(jobResource, pId));\n        Message pendingMessage = currStateOutput.getPendingState(jobResource, partition, instance);\n        // While job is failing, if the task is pending on INIT->RUNNING, set it back to INIT,\n        // so that Helix will cancel the transition.\n        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT && pendingMessage != null) {\n          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));\n        }\n      }\n\n      return toResourceAssignment(jobResource, paMap);\n    }\n\n    if (jobState == TaskState.FAILING && isJobFinished(jobCtx, jobResource, currStateOutput)) {\n      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n\n    if (isJobComplete(jobCtx, allPartitions, jobCfg)) {\n      markJobComplete(jobResource, jobCtx, workflowConfig, workflowCtx,\n          cache.getJobConfigMap());\n      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.COMPLETED,\n          jobCtx.getFinishTime() - jobCtx.getStartTime());\n      _rebalanceScheduler.removeScheduledRebalance(jobResource);\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n\n    // If job is being timed out and no task is running (for whatever reason), idealState can be deleted and all tasks\n    // can be dropped(note that Helix doesn't track whether the drop is success or not).\n    if (jobState == TaskState.TIMING_OUT && isJobFinished(jobCtx, jobResource, currStateOutput)) {\n      jobCtx.setFinishTime(System.currentTimeMillis());\n      workflowCtx.setJobState(jobResource, TaskState.TIMED_OUT);\n      // Mark all INIT task to TASK_ABORTED\n      for (int pId : jobCtx.getPartitionSet()) {\n        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT) {\n          jobCtx.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);\n        }\n      }\n      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.TIMED_OUT);\n      _rebalanceScheduler.removeScheduledRebalance(jobResource);\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n\n    // For delayed tasks, trigger a rebalance event for the closest upcoming ready time\n    scheduleForNextTask(jobResource, jobCtx, currentTime);\n\n    // Make additional task assignments if needed.\n    if (jobState != TaskState.TIMING_OUT && jobState != TaskState.TIMED_OUT && jobTgtState == TargetState.START) {\n      // Contains the set of task partitions that must be excluded from consideration when making\n      // any new assignments.\n      // This includes all completed, failed, delayed, and already assigned partitions.\n      Set<Integer> excludeSet = Sets.newTreeSet(assignedPartitions);\n      addCompletedTasks(excludeSet, jobCtx, allPartitions);\n      addGiveupPartitions(excludeSet, jobCtx, allPartitions, jobCfg);\n      excludeSet.addAll(skippedPartitions);\n      excludeSet.addAll(getNonReadyPartitions(jobCtx, currentTime));\n      // Get instance->[partition, ...] mappings for the target resource.\n      Map<String, SortedSet<Integer>> tgtPartitionAssignments = taskAssignmentCal\n          .getTaskAssignment(currStateOutput, prevTaskToInstanceStateAssignment, liveInstances, jobCfg, jobCtx,\n              workflowConfig, workflowCtx, allPartitions, cache.getIdealStates());\n\n      if (!isGenericTaskJob(jobCfg) || jobCfg.isRebalanceRunningTask()) {\n        dropRebalancedRunningTasks(tgtPartitionAssignments, prevInstanceToTaskAssignments, paMap,\n            jobCtx);\n      }\n\n      for (Map.Entry<String, SortedSet<Integer>> entry : prevInstanceToTaskAssignments.entrySet()) {\n        String instance = entry.getKey();\n        if (!tgtPartitionAssignments.containsKey(instance) || excludedInstances\n            .contains(instance)) {\n          continue;\n        }\n        // 1. throttled by job configuration\n        // Contains the set of task partitions currently assigned to the instance.\n        Set<Integer> pSet = entry.getValue();\n        int jobCfgLimitation = jobCfg.getNumConcurrentTasksPerInstance() - pSet.size();\n        // 2. throttled by participant capacity\n        int participantCapacity = cache.getInstanceConfigMap().get(instance).getMaxConcurrentTask();\n        if (participantCapacity == InstanceConfig.MAX_CONCURRENT_TASK_NOT_SET) {\n          participantCapacity = cache.getClusterConfig().getMaxConcurrentTaskPerInstance();\n        }\n        int participantLimitation = participantCapacity - cache.getParticipantActiveTaskCount(instance);\n        // New tasks to be assigned\n        int numToAssign = Math.min(jobCfgLimitation, participantLimitation);\n        LOG.debug(String.format(\n            \"Throttle tasks to be assigned to instance %s using limitation: Job Concurrent Task(%d), \"\n                + \"Participant Max Task(%d). Remaining capacity %d.\", instance, jobCfgLimitation, participantCapacity,\n            numToAssign));\n        if (numToAssign > 0) {\n          Set<Integer> throttledSet = new HashSet<Integer>();\n          List<Integer> nextPartitions =\n              getNextPartitions(tgtPartitionAssignments.get(instance), excludeSet, throttledSet, numToAssign);\n          for (Integer pId : nextPartitions) {\n            String pName = pName(jobResource, pId);\n            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.RUNNING.name()));\n            excludeSet.add(pId);\n            jobCtx.setAssignedParticipant(pId, instance);\n            jobCtx.setPartitionState(pId, TaskPartitionState.INIT);\n            jobCtx.setPartitionStartTime(pId, System.currentTimeMillis());\n            LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n                TaskPartitionState.RUNNING, instance));\n          }\n          cache.setParticipantActiveTaskCount(instance, cache.getParticipantActiveTaskCount(instance) + nextPartitions.size());\n          if (!throttledSet.isEmpty()) {\n            LOG.debug(throttledSet.size() + \"tasks are ready but throttled when assigned to participant.\");\n          }\n        }\n      }\n    }\n\n    return toResourceAssignment(jobResource, paMap);\n  }\n\n  private ResourceAssignment toResourceAssignment(String jobResource, Map<Integer, PartitionAssignment> paMap) {\n    // Construct a ResourceAssignment object from the map of partition assignments.\n    ResourceAssignment ra = new ResourceAssignment(jobResource);\n    for (Map.Entry<Integer, PartitionAssignment> e : paMap.entrySet()) {\n      PartitionAssignment pa = e.getValue();\n      ra.addReplicaMap(new Partition(pName(jobResource, e.getKey())),\n          ImmutableMap.of(pa._instance, pa._state));\n    }\n    return ra;\n  }\n\n  /**\n   * If assignment is different from previous assignment, drop the old running task if it's no\n   * longer assigned to the same instance, but not removing it from excludeSet because the same task\n   * should not be assigned to the new instance right way.\n   */\n  private void dropRebalancedRunningTasks(Map<String, SortedSet<Integer>> newAssignment,\n      Map<String, SortedSet<Integer>> oldAssignment, Map<Integer, PartitionAssignment> paMap,\n      JobContext jobContext) {\n    for (String instance : oldAssignment.keySet()) {\n      for (Integer pId : oldAssignment.get(instance)) {\n        if (jobContext.getPartitionState(pId) == TaskPartitionState.RUNNING\n                && !newAssignment.get(instance).contains(pId)) {\n            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));\n            jobContext.setPartitionState(pId, TaskPartitionState.DROPPED);\n        }\n      }\n    }\n  }\n\n  private TaskPartitionState updateJobContextAndGetTaskCurrentState(CurrentStateOutput currentStateOutput,\n      String jobResource, Integer pId, String pName, String instance, JobContext jobCtx) {\n    String currentStateString = currentStateOutput.getCurrentState(jobResource, new Partition(\n        pName), instance);\n    if (currentStateString == null) {\n      // Task state is either DROPPED or INIT\n      return jobCtx.getPartitionState(pId);\n    }\n    TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n    jobCtx.setPartitionState(pId, currentState);\n    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(\n        pName), instance);\n    if (taskMsg != null) {\n      jobCtx.setPartitionInfo(pId, taskMsg);\n    }\n    return currentState;\n  }\n\n  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId, String pName,\n      String instance, Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n      Map<Integer, PartitionAssignment> paMap, Set<Integer> assignedPartitions) {\n\n    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n    if (stateMap != null) {\n      String prevState = stateMap.get(instance);\n      if (!pendingMessage.getToState().equals(prevState)) {\n        LOG.warn(String.format(\"Task pending to-state is %s while previous assigned state is %s. This should not\"\n            + \"heppen.\", pendingMessage.getToState(), prevState));\n      }\n      if (jobState == TaskState.TIMING_OUT\n          && currState == TaskPartitionState.INIT\n          && prevState.equals(TaskPartitionState.RUNNING.name())) {\n        // While job is timing out, if the task is pending on INIT->RUNNING, set it back to INIT,\n        // so that Helix will cancel the transition.\n        paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));\n        assignedPartitions.add(pId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"Task partition %s has a pending state transition on instance %s INIT->RUNNING. \"\n                  + \"Setting it back to INIT so that Helix can cancel the transition(if enabled).\",\n              pName, instance, prevState));\n        }\n      } else {\n        // Otherwise, Just copy forward\n        // the state assignment from the previous ideal state.\n        paMap.put(pId, new PartitionAssignment(instance, prevState));\n        assignedPartitions.add(pId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"Task partition %s has a pending state transition on instance %s. Using the previous ideal state which was %s.\",\n              pName, instance, prevState));\n        }\n      }\n    }\n  }\n\n  private void failJob(String jobName, WorkflowContext workflowContext, JobContext jobContext,\n      WorkflowConfig workflowConfig, Map<String, JobConfig> jobConfigMap) {\n    markJobFailed(jobName, jobContext, workflowConfig, workflowContext, jobConfigMap);\n    // Mark all INIT task to TASK_ABORTED\n    for (int pId : jobContext.getPartitionSet()) {\n      if (jobContext.getPartitionState(pId) == TaskPartitionState.INIT) {\n        jobContext.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);\n      }\n    }\n    _clusterStatusMonitor.updateJobCounters(jobConfigMap.get(jobName), TaskState.FAILED);\n    _rebalanceScheduler.removeScheduledRebalance(jobName);\n    TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);\n  }\n\n  private boolean isJobTimeout(JobContext jobContext, JobConfig jobConfig) {\n    long jobTimeoutTime = computeJobTimeoutTime(jobContext, jobConfig);\n    return jobTimeoutTime != jobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime <= System\n        .currentTimeMillis();\n  }\n\n  private boolean isJobFinished(JobContext jobContext, String jobResource,\n      CurrentStateOutput currentStateOutput) {\n    for (int pId : jobContext.getPartitionSet()) {\n      TaskPartitionState state = jobContext.getPartitionState(pId);\n      Partition partition = new Partition(pName(jobResource, pId));\n      String instance = jobContext.getAssignedParticipant(pId);\n      Message pendingMessage = currentStateOutput.getPendingState(jobResource, partition, instance);\n      // If state is INIT but is pending INIT->RUNNING, it's not yet safe to say the job finished\n      if (state == TaskPartitionState.RUNNING\n          || (state == TaskPartitionState.INIT && pendingMessage != null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Return jobConfig.DEFAULT_TIMEOUT_NEVER if job should never timeout.\n  // job start time can't be -1 before calling this method.\n  private long computeJobTimeoutTime(JobContext jobContext, JobConfig jobConfig) {\n    return (jobConfig.getTimeout() == JobConfig.DEFAULT_TIMEOUT_NEVER\n        || jobConfig.getTimeout() > Long.MAX_VALUE - jobContext.getStartTime()) // check long overflow\n        ? jobConfig.DEFAULT_TIMEOUT_NEVER\n        : jobContext.getStartTime() + jobConfig.getTimeout();\n  }\n\n  private void markJobComplete(String jobName, JobContext jobContext, WorkflowConfig workflowConfig,\n      WorkflowContext workflowContext, Map<String, JobConfig> jobConfigMap) {\n    long currentTime = System.currentTimeMillis();\n    workflowContext.setJobState(jobName, TaskState.COMPLETED);\n    jobContext.setFinishTime(currentTime);\n    if (isWorkflowFinished(workflowContext, workflowConfig, jobConfigMap)) {\n      workflowContext.setFinishTime(currentTime);\n    }\n    scheduleJobCleanUp(jobConfigMap.get(jobName), workflowConfig, currentTime);\n  }\n\n  private void scheduleForNextTask(String job, JobContext jobCtx, long now) {\n    // Figure out the earliest schedulable time in the future of a non-complete job\n    boolean shouldSchedule = false;\n    long earliestTime = Long.MAX_VALUE;\n    for (int p : jobCtx.getPartitionSet()) {\n      long retryTime = jobCtx.getNextRetryTime(p);\n      TaskPartitionState state = jobCtx.getPartitionState(p);\n      state = (state != null) ? state : TaskPartitionState.INIT;\n      Set<TaskPartitionState> errorStates =\n          Sets.newHashSet(TaskPartitionState.ERROR, TaskPartitionState.TASK_ERROR,\n              TaskPartitionState.TIMED_OUT);\n      if (errorStates.contains(state) && retryTime > now && retryTime < earliestTime) {\n        earliestTime = retryTime;\n        shouldSchedule = true;\n      }\n    }\n\n    // If any was found, then schedule it\n    if (shouldSchedule) {\n      long scheduledTime = _rebalanceScheduler.getRebalanceTime(job);\n      if (scheduledTime == -1 || earliestTime < scheduledTime) {\n        _rebalanceScheduler.scheduleRebalance(_manager, job, earliestTime);\n      }\n    }\n  }\n\n  // Set job timeout rebalance, if the time is earlier than the current scheduled rebalance time\n  // This needs to run for every rebalance because the scheduled rebalance could be removed in other places.\n  private void scheduleRebalanceForJobTimeout(JobConfig jobCfg, JobContext jobCtx) {\n    long jobTimeoutTime = computeJobTimeoutTime(jobCtx, jobCfg);\n    if (jobTimeoutTime != JobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime > System.currentTimeMillis()) {\n      long nextRebalanceTime = _rebalanceScheduler.getRebalanceTime(jobCfg.getJobId());\n      if (nextRebalanceTime == JobConfig.DEFAULT_TIMEOUT_NEVER || jobTimeoutTime < nextRebalanceTime) {\n        _rebalanceScheduler.scheduleRebalance(_manager, jobCfg.getJobId(), jobTimeoutTime);\n      }\n    }\n  }\n\n  /**\n   * Get the last task assignment for a given job\n   *\n   * @param resourceName the name of the job\n   * @return {@link ResourceAssignment} instance, or null if no assignment is available\n   */\n  private ResourceAssignment getPrevResourceAssignment(String resourceName) {\n    ZNRecord r = _manager.getHelixPropertyStore()\n        .get(Joiner.on(\"/\").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),\n            null, AccessOption.PERSISTENT);\n    return r != null ? new ResourceAssignment(r) : null;\n  }\n\n  /**\n   * Set the last task assignment for a given job\n   *\n   * @param resourceName the name of the job\n   * @param ra           {@link ResourceAssignment} containing the task assignment\n   */\n  private void setPrevResourceAssignment(String resourceName,\n      ResourceAssignment ra) {\n    _manager.getHelixPropertyStore()\n        .set(Joiner.on(\"/\").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),\n            ra.getRecord(), AccessOption.PERSISTENT);\n  }\n\n  /**\n   * Checks if the job has completed.\n   * Look at states of all tasks of the job, there're 3 kind: completed, given up, not given up.\n   * The job is completed if all tasks are completed or given up, and the number of given up tasks is within job\n   * failure threshold.\n   */\n  private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions, JobConfig cfg) {\n    int numOfGivenUpTasks = 0;\n    // Iterate through all tasks, if any one indicates the job has not completed, return false.\n    for (Integer pId : allPartitions) {\n      TaskPartitionState state = ctx.getPartitionState(pId);\n      if (state != TaskPartitionState.COMPLETED) {\n        if(!isTaskGivenup(ctx, cfg, pId)) {\n          return false;\n        }\n        // If the task is given up, there's still chance the job has completed because of job failure threshold.\n        numOfGivenUpTasks++;\n      }\n    }\n    return numOfGivenUpTasks <= cfg.getFailureThreshold();\n  }\n\n  private static void addCompletedTasks(Set<Integer> set, JobContext ctx,\n      Iterable<Integer> pIds) {\n    for (Integer pId : pIds) {\n      TaskPartitionState state = ctx.getPartitionState(pId);\n      if (state == TaskPartitionState.COMPLETED) {\n        set.add(pId);\n      }\n    }\n  }\n\n  private static boolean isTaskGivenup(JobContext ctx, JobConfig cfg, int pId) {\n    TaskPartitionState state = ctx.getPartitionState(pId);\n    if (state == TaskPartitionState.TASK_ABORTED || state == TaskPartitionState.ERROR) {\n      return true;\n    }\n    if (state == TaskPartitionState.TIMED_OUT || state == TaskPartitionState.TASK_ERROR) {\n      return ctx.getPartitionNumAttempts(pId) >= cfg.getMaxAttemptsPerTask();\n    }\n    return false;\n  }\n\n  // add all partitions that have been tried maxNumberAttempts\n  private static void addGiveupPartitions(Set<Integer> set, JobContext ctx, Iterable<Integer> pIds,\n      JobConfig cfg) {\n    for (Integer pId : pIds) {\n      if (isTaskGivenup(ctx, cfg, pId)) {\n        set.add(pId);\n      }\n    }\n  }\n\n  private static List<Integer> getNextPartitions(SortedSet<Integer> candidatePartitions,\n      Set<Integer> excluded, Set<Integer> throttled, int n) {\n    List<Integer> result = new ArrayList<Integer>();\n    for (Integer pId : candidatePartitions) {\n      if (!excluded.contains(pId)) {\n        if (result.size() < n) {\n          result.add(pId);\n        } else {\n          throttled.add(pId);\n        }\n      }\n    }\n    return result;\n  }\n\n  private static void markPartitionDelayed(JobConfig cfg, JobContext ctx, int p) {\n    long delayInterval = cfg.getTaskRetryDelay();\n    if (delayInterval <= 0) {\n      return;\n    }\n    long nextStartTime = ctx.getPartitionFinishTime(p) + delayInterval;\n    ctx.setNextRetryTime(p, nextStartTime);\n  }\n\n  private static void markPartitionCompleted(JobContext ctx, int pId) {\n    ctx.setPartitionState(pId, TaskPartitionState.COMPLETED);\n    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());\n    ctx.incrementNumAttempts(pId);\n  }\n\n  private static void markPartitionError(JobContext ctx, int pId, TaskPartitionState state,\n      boolean incrementAttempts) {\n    ctx.setPartitionState(pId, state);\n    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());\n    if (incrementAttempts) {\n      ctx.incrementNumAttempts(pId);\n    }\n  }\n\n  private static void markAllPartitionsError(JobContext ctx, TaskPartitionState state,\n      boolean incrementAttempts) {\n    for (int pId : ctx.getPartitionSet()) {\n      markPartitionError(ctx, pId, state, incrementAttempts);\n    }\n  }\n\n  /**\n   * @param liveInstances\n   * @param prevAssignment task partition -> (instance -> state)\n   * @param allTaskPartitions all task partitionIds\n   * @return instance -> partitionIds from previous assignment, if the instance is still live\n   */\n  private static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n      Iterable<String> liveInstances, ResourceAssignment prevAssignment, Set<Integer> allTaskPartitions) {\n    Map<String, SortedSet<Integer>> result = new HashMap<String, SortedSet<Integer>>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    for (Partition partition : prevAssignment.getMappedPartitions()) {\n      int pId = getPartitionId(partition.getPartitionName());\n      if (allTaskPartitions.contains(pId)) {\n        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n        for (String instance : replicaMap.keySet()) {\n          SortedSet<Integer> pList = result.get(instance);\n          if (pList != null) {\n            pList.add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  /* Extracts the partition id from the given partition name. */\n  private static int getPartitionId(String pName) {\n    int index = pName.lastIndexOf(\"_\");\n    if (index == -1) {\n      throw new HelixException(\"Invalid partition name \" + pName);\n    }\n    return Integer.valueOf(pName.substring(index + 1));\n  }\n\n  private static Set<Integer> getNonReadyPartitions(JobContext ctx, long now) {\n    Set<Integer> nonReadyPartitions = Sets.newHashSet();\n    for (int p : ctx.getPartitionSet()) {\n      long toStart = ctx.getNextRetryTime(p);\n      if (now < toStart) {\n        nonReadyPartitions.add(p);\n      }\n    }\n    return nonReadyPartitions;\n  }\n\n  private TaskAssignmentCalculator getAssignmentCalulator(JobConfig jobConfig) {\n    return isGenericTaskJob(jobConfig) ? _genericTaskAssignmentCal : _fixTaskAssignmentCal;\n  }\n\n  private boolean isGenericTaskJob(JobConfig jobConfig) {\n    Map<String, TaskConfig> taskConfigMap = jobConfig.getTaskConfigMap();\n    return taskConfigMap != null && !taskConfigMap.isEmpty();\n  }\n\n  /**\n   * Check whether tasks are not in final states\n   * @param jobContext The job context\n   * @return           False if still tasks not in final state. Otherwise return true\n   */\n  private boolean checkJobStopped(JobContext jobContext) {\n    for (int partition : jobContext.getPartitionSet()) {\n      TaskPartitionState taskState = jobContext.getPartitionState(partition);\n      if (taskState == TaskPartitionState.RUNNING) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Computes the partition name given the resource name and partition id.\n   */\n  private String pName(String resource, int pId) {\n    return resource + \"_\" + pId;\n  }\n\n  /**\n   * An (instance, state) pair.\n   */\n  private static class PartitionAssignment {\n    private final String _instance;\n    private final String _state;\n\n    private PartitionAssignment(String instance, String state) {\n      _instance = instance;\n      _state = state;\n    }\n  }\n}", "class_id": 0, "repo": "turn/helix", "file": "helix-core/src/main/java/org/apache/helix/task/JobRebalancer.java", "last_update_at": "2018-04-02T22:15:49+00:00", "question_id": "51da26424db1ce4133463ca48656f0ba823c718a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JobRebalancer extends TaskRebalancer {\n  private static final Logger LOG = LoggerFactory.getLogger(JobRebalancer.class);\n  private static TaskAssignmentCalculator _fixTaskAssignmentCal =\n      new FixedTargetTaskAssignmentCalculator();\n  private static TaskAssignmentCalculator _genericTaskAssignmentCal =\n      new GenericTaskAssignmentCalculator();\n  private static final String PREV_RA_NODE = \"PreviousResourceAssignment\";\n  @Override\n  public ResourceAssignment computeBestPossiblePartitionState(ClusterDataCache clusterData,\n      IdealState taskIs, Resource resource, CurrentStateOutput currStateOutput) {\n    final String jobName = resource.getResourceName();\n    LOG.debug(\"Computer Best Partition for job: \" + jobName);\n    // Fetch job configuration\n    JobConfig jobCfg = clusterData.getJobConfig(jobName);\n    if (jobCfg == null) {\n      LOG.error(\"Job configuration is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    String workflowResource = jobCfg.getWorkflow();\n    // Fetch workflow configuration and context\n    WorkflowConfig workflowCfg = clusterData.getWorkflowConfig(workflowResource);\n    if (workflowCfg == null) {\n      LOG.error(\"Workflow configuration is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    WorkflowContext workflowCtx = clusterData.getWorkflowContext(workflowResource);\n    if (workflowCtx == null) {\n      LOG.error(\"Workflow context is NULL for \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    TargetState targetState = workflowCfg.getTargetState();\n    if (targetState != TargetState.START && targetState != TargetState.STOP) {\n      LOG.info(\"Target state is \" + targetState.name() + \" for workflow \" + workflowResource\n          + \".Stop scheduling job \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    // Stop current run of the job if workflow or job is already in final state (failed or completed)\n    TaskState workflowState = workflowCtx.getWorkflowState();\n    TaskState jobState = workflowCtx.getJobState(jobName);\n    // The job is already in a final state (completed/failed).\n    if (workflowState == TaskState.FAILED || workflowState == TaskState.COMPLETED ||\n        jobState == TaskState.FAILED || jobState == TaskState.COMPLETED) {\n      LOG.info(String.format(\n          \"Workflow %s or job %s is already failed or completed, workflow state (%s), job state (%s), clean up job IS.\",\n          workflowResource, jobName, workflowState, jobState));\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);\n      _rebalanceScheduler.removeScheduledRebalance(jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    if (!isWorkflowReadyForSchedule(workflowCfg)) {\n      LOG.info(\"Job is not ready to be run since workflow is not ready \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    if (!isJobStarted(jobName, workflowCtx) && !isJobReadyToSchedule(jobName, workflowCfg,\n        workflowCtx, getInCompleteJobCount(workflowCfg, workflowCtx),\n        clusterData.getJobConfigMap())) {\n      LOG.info(\"Job is not ready to run \" + jobName);\n      return buildEmptyAssignment(jobName, currStateOutput);\n    }\n    // Fetch any existing context information from the property store.\n    JobContext jobCtx = clusterData.getJobContext(jobName);\n    if (jobCtx == null) {\n      jobCtx = new JobContext(new ZNRecord(TaskUtil.TASK_CONTEXT_KW));\n      jobCtx.setStartTime(System.currentTimeMillis());\n      jobCtx.setName(jobName);\n      workflowCtx.setJobState(jobName, TaskState.IN_PROGRESS);\n    }\n    scheduleRebalanceForJobTimeout(jobCfg, jobCtx);\n    // Grab the old assignment, or an empty one if it doesn't exist\n    ResourceAssignment prevAssignment = getPrevResourceAssignment(jobName);\n    if (prevAssignment == null) {\n      prevAssignment = new ResourceAssignment(jobName);\n    }\n    // Will contain the list of partitions that must be explicitly dropped from the ideal state that\n    // is stored in zk.\n    // Fetch the previous resource assignment from the property store. This is required because of\n    // HELIX-230.\n    Set<String> liveInstances = jobCfg.getInstanceGroupTag() == null\n        ? clusterData.getEnabledLiveInstances()\n        : clusterData.getEnabledLiveInstancesWithTag(jobCfg.getInstanceGroupTag());\n    if (liveInstances.isEmpty()) {\n      LOG.error(\"No available instance found for job!\");\n    }\n    Set<Integer> partitionsToDrop = new TreeSet<Integer>();\n    ResourceAssignment newAssignment =\n        computeResourceMapping(jobName, workflowCfg, jobCfg, prevAssignment, liveInstances,\n            currStateOutput, workflowCtx, jobCtx, partitionsToDrop, clusterData);\n    HelixDataAccessor accessor = _manager.getHelixDataAccessor();\n    PropertyKey propertyKey = accessor.keyBuilder().idealStates(jobName);\n    taskIs = clusterData.getIdealState(jobName);\n    if (!partitionsToDrop.isEmpty() && taskIs != null) {\n      for (Integer pId : partitionsToDrop) {\n        taskIs.getRecord().getMapFields().remove(pName(jobName, pId));\n      }\n      accessor.setProperty(propertyKey, taskIs);\n    }\n    // Update Workflow and Job context in data cache and ZK.\n    clusterData.updateJobContext(jobName, jobCtx, _manager.getHelixDataAccessor());\n    clusterData\n        .updateWorkflowContext(workflowResource, workflowCtx, _manager.getHelixDataAccessor());\n    setPrevResourceAssignment(jobName, newAssignment);\n    LOG.debug(\"Job \" + jobName + \" new assignment \" + Arrays\n        .toString(newAssignment.getMappedPartitions().toArray()));\n    return newAssignment;\n  }\n  private Set<String> getExcludedInstances(String currentJobName,\n      WorkflowConfig workflowCfg, ClusterDataCache cache) {\n    Set<String> ret = new HashSet<String>();\n    if (!workflowCfg.isAllowOverlapJobAssignment()) {\n      // exclude all instances that has been assigned other jobs' tasks\n      for (String jobName : workflowCfg.getJobDag().getAllNodes()) {\n        if (jobName.equals(currentJobName)) {\n          continue;\n        }\n        JobContext jobContext = cache.getJobContext(jobName);\n        if (jobContext == null) {\n          continue;\n        }\n        for (int pId : jobContext.getPartitionSet()) {\n          TaskPartitionState partitionState = jobContext.getPartitionState(pId);\n          if (partitionState == TaskPartitionState.INIT || partitionState == TaskPartitionState.RUNNING) {\n            ret.add(jobContext.getAssignedParticipant(pId));\n          }\n        }\n      }\n    }\n    return ret;\n  }\n  private ResourceAssignment computeResourceMapping(String jobResource,\n      WorkflowConfig workflowConfig, JobConfig jobCfg, ResourceAssignment prevTaskToInstanceStateAssignment,\n      Collection<String> liveInstances, CurrentStateOutput currStateOutput,\n      WorkflowContext workflowCtx, JobContext jobCtx, Set<Integer> partitionsToDropFromIs,\n      ClusterDataCache cache) {\n    TargetState jobTgtState = workflowConfig.getTargetState();\n    TaskState jobState = workflowCtx.getJobState(jobResource);\n    if (jobState == TaskState.IN_PROGRESS && isJobTimeout(jobCtx, jobCfg)) {\n      jobState = TaskState.TIMING_OUT;\n      workflowCtx.setJobState(jobResource, TaskState.TIMING_OUT);\n    } else if (jobState != TaskState.TIMING_OUT && jobState != TaskState.FAILING) {\n      // TIMING_OUT/FAILING/ABORTING job can't be stopped, because all tasks are being aborted\n      // Update running status in workflow context\n      if (jobTgtState == TargetState.STOP) {\n        if (checkJobStopped(jobCtx)) {\n          workflowCtx.setJobState(jobResource, TaskState.STOPPED);\n        } else {\n          workflowCtx.setJobState(jobResource, TaskState.STOPPING);\n        }\n        // Workflow has been stopped if all in progress jobs are stopped\n        if (isWorkflowStopped(workflowCtx, workflowConfig)) {\n          workflowCtx.setWorkflowState(TaskState.STOPPED);\n        } else {\n          workflowCtx.setWorkflowState(TaskState.STOPPING);\n        }\n      } else {\n        workflowCtx.setJobState(jobResource, TaskState.IN_PROGRESS);\n        // Workflow is in progress if any task is in progress\n        workflowCtx.setWorkflowState(TaskState.IN_PROGRESS);\n      }\n    }\n    // Used to keep track of tasks that have already been assigned to instances.\n    Set<Integer> assignedPartitions = new HashSet<Integer>();\n    // Used to keep track of tasks that have failed, but whose failure is acceptable\n    Set<Integer> skippedPartitions = new HashSet<Integer>();\n    // Keeps a mapping of (partition) -> (instance, state)\n    Map<Integer, PartitionAssignment> paMap = new TreeMap<Integer, PartitionAssignment>();\n    Set<String> excludedInstances = getExcludedInstances(jobResource, workflowConfig, cache);\n    // Process all the current assignments of tasks.\n    TaskAssignmentCalculator taskAssignmentCal = getAssignmentCalulator(jobCfg);\n    Set<Integer> allPartitions = taskAssignmentCal\n        .getAllTaskPartitions(jobCfg, jobCtx, workflowConfig, workflowCtx, cache.getIdealStates());\n    if (allPartitions == null || allPartitions.isEmpty()) {\n      // Empty target partitions, mark the job as FAILED.\n      String failureMsg = \"Empty task partition mapping for job \" + jobResource + \", marked the job as FAILED!\";\n      LOG.info(failureMsg);\n      jobCtx.setInfo(failureMsg);\n      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n      markAllPartitionsError(jobCtx, TaskPartitionState.ERROR, false);\n      return new ResourceAssignment(jobResource);\n    }\n    Map<String, SortedSet<Integer>> prevInstanceToTaskAssignments =\n        getPrevInstanceToTaskAssignments(liveInstances, prevTaskToInstanceStateAssignment, allPartitions);\n    long currentTime = System.currentTimeMillis();\n    LOG.debug(\"All partitions: \" + allPartitions + \" taskAssignment: \" + prevInstanceToTaskAssignments\n        + \" excludedInstances: \" + excludedInstances);\n    // Iterate through all instances\n    for (String instance : prevInstanceToTaskAssignments.keySet()) {\n      if (excludedInstances.contains(instance)) {\n        continue;\n      }\n      Set<Integer> pSet = prevInstanceToTaskAssignments.get(instance);\n      // Used to keep track of partitions that are in one of the final states: COMPLETED, TIMED_OUT,\n      // TASK_ERROR, ERROR.\n      Set<Integer> donePartitions = new TreeSet<Integer>();\n      for (int pId : pSet) {\n        final String pName = pName(jobResource, pId);\n        TaskPartitionState currState =\n            updateJobContextAndGetTaskCurrentState(currStateOutput, jobResource, pId, pName, instance, jobCtx);\n        // Check for pending state transitions on this (partition, instance).\n        Message pendingMessage =\n            currStateOutput.getPendingState(jobResource, new Partition(pName), instance);\n        if (pendingMessage != null && !pendingMessage.getToState().equals(currState.name())) {\n          processTaskWithPendingMessage(prevTaskToInstanceStateAssignment, pId, pName, instance,\n              pendingMessage, jobState, currState, paMap, assignedPartitions);\n          continue;\n        }\n        // Process any requested state transitions.\n        String requestedStateStr =\n            currStateOutput.getRequestedState(jobResource, new Partition(pName), instance);\n        if (requestedStateStr != null && !requestedStateStr.isEmpty()) {\n          TaskPartitionState requestedState = TaskPartitionState.valueOf(requestedStateStr);\n          if (requestedState.equals(currState)) {\n            LOG.warn(String.format(\n                \"Requested state %s is the same as the current state for instance %s.\",\n                requestedState, instance));\n          }\n          paMap.put(pId, new PartitionAssignment(instance, requestedState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\n              \"Instance %s requested a state transition to %s for partition %s.\", instance,\n              requestedState, pName));\n          continue;\n        }\n        switch (currState) {\n        case RUNNING: {\n          TaskPartitionState nextState = TaskPartitionState.RUNNING;\n          if (jobState == TaskState.TIMING_OUT) {\n            nextState = TaskPartitionState.TASK_ABORTED;\n          } else if (jobTgtState == TargetState.STOP) {\n            nextState = TaskPartitionState.STOPPED;\n          }\n          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n              nextState, instance));\n        }\n          break;\n        case STOPPED: {\n          TaskPartitionState nextState;\n          if (jobTgtState == TargetState.START) {\n            nextState = TaskPartitionState.RUNNING;\n          } else {\n            nextState = TaskPartitionState.STOPPED;\n          }\n          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));\n          assignedPartitions.add(pId);\n          LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n              nextState, instance));\n        }\n          break;\n        case COMPLETED: {\n          // The task has completed on this partition. Mark as such in the context object.\n          donePartitions.add(pId);\n          LOG.debug(String\n              .format(\n                  \"Task partition %s has completed with state %s. Marking as such in rebalancer context.\",\n                  pName, currState));\n          partitionsToDropFromIs.add(pId);\n          markPartitionCompleted(jobCtx, pId);\n        }\n          break;\n        case TIMED_OUT:\n        case TASK_ERROR:\n        case TASK_ABORTED:\n        case ERROR: {\n          donePartitions.add(pId); // The task may be rescheduled on a different instance.\n          LOG.debug(String.format(\n              \"Task partition %s has error state %s with msg %s. Marking as such in rebalancer context.\", pName,\n              currState, jobCtx.getPartitionInfo(pId)));\n          markPartitionError(jobCtx, pId, currState, true);\n          // The error policy is to fail the task as soon a single partition fails for a specified\n          // maximum number of attempts or task is in ABORTED state.\n          // But notice that if job is TIMED_OUT, aborted task won't be treated as fail and won't cause job fail.\n          // After all tasks are aborted, they will be dropped, because of job timeout.\n          if (jobState != TaskState.TIMED_OUT && jobState != TaskState.TIMING_OUT) {\n            if (jobCtx.getPartitionNumAttempts(pId) >= jobCfg.getMaxAttemptsPerTask()\n                || currState.equals(TaskPartitionState.TASK_ABORTED)\n                || currState.equals(TaskPartitionState.ERROR)) {\n              skippedPartitions.add(pId);\n              partitionsToDropFromIs.add(pId);\n              LOG.debug(\"skippedPartitions:\" + skippedPartitions);\n            } else {\n              // Mark the task to be started at some later time (if enabled)\n              markPartitionDelayed(jobCfg, jobCtx, pId);\n            }\n          }\n        }\n          break;\n        case INIT:\n        case DROPPED: {\n          // currState in [INIT, DROPPED]. Do nothing, the partition is eligible to be reassigned.\n          donePartitions.add(pId);\n          LOG.debug(String.format(\n              \"Task partition %s has state %s. It will be dropped from the current ideal state.\",\n              pName, currState));\n        }\n          break;\n        default:\n          throw new AssertionError(\"Unknown enum symbol: \" + currState);\n        }\n      }\n      // Remove the set of task partitions that are completed or in one of the error states.\n      pSet.removeAll(donePartitions);\n    }\n    addGiveupPartitions(skippedPartitions, jobCtx, allPartitions, jobCfg);\n    if (jobState == TaskState.IN_PROGRESS && skippedPartitions.size() > jobCfg.getFailureThreshold()) {\n      if (isJobFinished(jobCtx, jobResource, currStateOutput)) {\n        failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n        return buildEmptyAssignment(jobResource, currStateOutput);\n      }\n      workflowCtx.setJobState(jobResource, TaskState.FAILING);\n      // Drop all assigned but not given-up tasks\n      for (int pId : jobCtx.getPartitionSet()) {\n        String instance = jobCtx.getAssignedParticipant(pId);\n        if (jobCtx.getPartitionState(pId) != null && !isTaskGivenup(jobCtx, jobCfg, pId)) {\n          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.TASK_ABORTED.name()));\n        }\n        Partition partition = new Partition(pName(jobResource, pId));\n        Message pendingMessage = currStateOutput.getPendingState(jobResource, partition, instance);\n        // While job is failing, if the task is pending on INIT->RUNNING, set it back to INIT,\n        // so that Helix will cancel the transition.\n        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT && pendingMessage != null) {\n          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));\n        }\n      }\n      return toResourceAssignment(jobResource, paMap);\n    }\n    if (jobState == TaskState.FAILING && isJobFinished(jobCtx, jobResource, currStateOutput)) {\n      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n    if (isJobComplete(jobCtx, allPartitions, jobCfg)) {\n      markJobComplete(jobResource, jobCtx, workflowConfig, workflowCtx,\n          cache.getJobConfigMap());\n      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.COMPLETED,\n          jobCtx.getFinishTime() - jobCtx.getStartTime());\n      _rebalanceScheduler.removeScheduledRebalance(jobResource);\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n    // If job is being timed out and no task is running (for whatever reason), idealState can be deleted and all tasks\n    // can be dropped(note that Helix doesn't track whether the drop is success or not).\n    if (jobState == TaskState.TIMING_OUT && isJobFinished(jobCtx, jobResource, currStateOutput)) {\n      jobCtx.setFinishTime(System.currentTimeMillis());\n      workflowCtx.setJobState(jobResource, TaskState.TIMED_OUT);\n      // Mark all INIT task to TASK_ABORTED\n      for (int pId : jobCtx.getPartitionSet()) {\n        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT) {\n          jobCtx.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);\n        }\n      }\n      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.TIMED_OUT);\n      _rebalanceScheduler.removeScheduledRebalance(jobResource);\n      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);\n      return buildEmptyAssignment(jobResource, currStateOutput);\n    }\n    // For delayed tasks, trigger a rebalance event for the closest upcoming ready time\n    scheduleForNextTask(jobResource, jobCtx, currentTime);\n    // Make additional task assignments if needed.\n    if (jobState != TaskState.TIMING_OUT && jobState != TaskState.TIMED_OUT && jobTgtState == TargetState.START) {\n      // Contains the set of task partitions that must be excluded from consideration when making\n      // any new assignments.\n      // This includes all completed, failed, delayed, and already assigned partitions.\n      Set<Integer> excludeSet = Sets.newTreeSet(assignedPartitions);\n      addCompletedTasks(excludeSet, jobCtx, allPartitions);\n      addGiveupPartitions(excludeSet, jobCtx, allPartitions, jobCfg);\n      excludeSet.addAll(skippedPartitions);\n      excludeSet.addAll(getNonReadyPartitions(jobCtx, currentTime));\n      // Get instance->[partition, ...] mappings for the target resource.\n      Map<String, SortedSet<Integer>> tgtPartitionAssignments = taskAssignmentCal\n          .getTaskAssignment(currStateOutput, prevTaskToInstanceStateAssignment, liveInstances, jobCfg, jobCtx,\n              workflowConfig, workflowCtx, allPartitions, cache.getIdealStates());\n      if (!isGenericTaskJob(jobCfg) || jobCfg.isRebalanceRunningTask()) {\n        dropRebalancedRunningTasks(tgtPartitionAssignments, prevInstanceToTaskAssignments, paMap,\n            jobCtx);\n      }\n      for (Map.Entry<String, SortedSet<Integer>> entry : prevInstanceToTaskAssignments.entrySet()) {\n        String instance = entry.getKey();\n        if (!tgtPartitionAssignments.containsKey(instance) || excludedInstances\n            .contains(instance)) {\n          continue;\n        }\n        // 1. throttled by job configuration\n        // Contains the set of task partitions currently assigned to the instance.\n        Set<Integer> pSet = entry.getValue();\n        int jobCfgLimitation = jobCfg.getNumConcurrentTasksPerInstance() - pSet.size();\n        // 2. throttled by participant capacity\n        int participantCapacity = cache.getInstanceConfigMap().get(instance).getMaxConcurrentTask();\n        if (participantCapacity == InstanceConfig.MAX_CONCURRENT_TASK_NOT_SET) {\n          participantCapacity = cache.getClusterConfig().getMaxConcurrentTaskPerInstance();\n        }\n        int participantLimitation = participantCapacity - cache.getParticipantActiveTaskCount(instance);\n        // New tasks to be assigned\n        int numToAssign = Math.min(jobCfgLimitation, participantLimitation);\n        LOG.debug(String.format(\n            \"Throttle tasks to be assigned to instance %s using limitation: Job Concurrent Task(%d), \"\n                + \"Participant Max Task(%d). Remaining capacity %d.\", instance, jobCfgLimitation, participantCapacity,\n            numToAssign));\n        if (numToAssign > 0) {\n          Set<Integer> throttledSet = new HashSet<Integer>();\n          List<Integer> nextPartitions =\n              getNextPartitions(tgtPartitionAssignments.get(instance), excludeSet, throttledSet, numToAssign);\n          for (Integer pId : nextPartitions) {\n            String pName = pName(jobResource, pId);\n            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.RUNNING.name()));\n            excludeSet.add(pId);\n            jobCtx.setAssignedParticipant(pId, instance);\n            jobCtx.setPartitionState(pId, TaskPartitionState.INIT);\n            jobCtx.setPartitionStartTime(pId, System.currentTimeMillis());\n            LOG.debug(String.format(\"Setting task partition %s state to %s on instance %s.\", pName,\n                TaskPartitionState.RUNNING, instance));\n          }\n          cache.setParticipantActiveTaskCount(instance, cache.getParticipantActiveTaskCount(instance) + nextPartitions.size());\n          if (!throttledSet.isEmpty()) {\n            LOG.debug(throttledSet.size() + \"tasks are ready but throttled when assigned to participant.\");\n          }\n        }\n      }\n    }\n    return toResourceAssignment(jobResource, paMap);\n  }\n  private ResourceAssignment toResourceAssignment(String jobResource, Map<Integer, PartitionAssignment> paMap) {\n    // Construct a ResourceAssignment object from the map of partition assignments.\n    ResourceAssignment ra = new ResourceAssignment(jobResource);\n    for (Map.Entry<Integer, PartitionAssignment> e : paMap.entrySet()) {\n      PartitionAssignment pa = e.getValue();\n      ra.addReplicaMap(new Partition(pName(jobResource, e.getKey())),\n          ImmutableMap.of(pa._instance, pa._state));\n    }\n    return ra;\n  }\n  /**\n   * If assignment is different from previous assignment, drop the old running task if it's no\n   * longer assigned to the same instance, but not removing it from excludeSet because the same task\n   * should not be assigned to the new instance right way.\n   */\n  private void dropRebalancedRunningTasks(Map<String, SortedSet<Integer>> newAssignment,\n      Map<String, SortedSet<Integer>> oldAssignment, Map<Integer, PartitionAssignment> paMap,\n      JobContext jobContext) {\n    for (String instance : oldAssignment.keySet()) {\n      for (Integer pId : oldAssignment.get(instance)) {\n        if (jobContext.getPartitionState(pId) == TaskPartitionState.RUNNING\n                && !newAssignment.get(instance).contains(pId)) {\n            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));\n            jobContext.setPartitionState(pId, TaskPartitionState.DROPPED);\n        }\n      }\n    }\n  }\n  private TaskPartitionState updateJobContextAndGetTaskCurrentState(CurrentStateOutput currentStateOutput,\n      String jobResource, Integer pId, String pName, String instance, JobContext jobCtx) {\n    String currentStateString = currentStateOutput.getCurrentState(jobResource, new Partition(\n        pName), instance);\n    if (currentStateString == null) {\n      // Task state is either DROPPED or INIT\n      return jobCtx.getPartitionState(pId);\n    }\n    TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n    jobCtx.setPartitionState(pId, currentState);\n    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(\n        pName), instance);\n    if (taskMsg != null) {\n      jobCtx.setPartitionInfo(pId, taskMsg);\n    }\n    return currentState;\n  }\n  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId, String pName,\n      String instance, Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n      Map<Integer, PartitionAssignment> paMap, Set<Integer> assignedPartitions) {\n    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n    if (stateMap != null) {\n      String prevState = stateMap.get(instance);\n      if (!pendingMessage.getToState().equals(prevState)) {\n        LOG.warn(String.format(\"Task pending to-state is %s while previous assigned state is %s. This should not\"\n            + \"heppen.\", pendingMessage.getToState(), prevState));\n      }\n      if (jobState == TaskState.TIMING_OUT\n          && currState == TaskPartitionState.INIT\n          && prevState.equals(TaskPartitionState.RUNNING.name())) {\n        // While job is timing out, if the task is pending on INIT->RUNNING, set it back to INIT,\n        // so that Helix will cancel the transition.\n        paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));\n        assignedPartitions.add(pId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"Task partition %s has a pending state transition on instance %s INIT->RUNNING. \"\n                  + \"Setting it back to INIT so that Helix can cancel the transition(if enabled).\",\n              pName, instance, prevState));\n        }\n      } else {\n        // Otherwise, Just copy forward\n        // the state assignment from the previous ideal state.\n        paMap.put(pId, new PartitionAssignment(instance, prevState));\n        assignedPartitions.add(pId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\n              \"Task partition %s has a pending state transition on instance %s. Using the previous ideal state which was %s.\",\n              pName, instance, prevState));\n        }\n      }\n    }\n  }\n  private void failJob(String jobName, WorkflowContext workflowContext, JobContext jobContext,\n      WorkflowConfig workflowConfig, Map<String, JobConfig> jobConfigMap) {\n    markJobFailed(jobName, jobContext, workflowConfig, workflowContext, jobConfigMap);\n    // Mark all INIT task to TASK_ABORTED\n    for (int pId : jobContext.getPartitionSet()) {\n      if (jobContext.getPartitionState(pId) == TaskPartitionState.INIT) {\n        jobContext.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);\n      }\n    }\n    _clusterStatusMonitor.updateJobCounters(jobConfigMap.get(jobName), TaskState.FAILED);\n    _rebalanceScheduler.removeScheduledRebalance(jobName);\n    TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);\n  }\n  private boolean isJobTimeout(JobContext jobContext, JobConfig jobConfig) {\n    long jobTimeoutTime = computeJobTimeoutTime(jobContext, jobConfig);\n    return jobTimeoutTime != jobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime <= System\n        .currentTimeMillis();\n  }\n  private boolean isJobFinished(JobContext jobContext, String jobResource,\n      CurrentStateOutput currentStateOutput) {\n    for (int pId : jobContext.getPartitionSet()) {\n      TaskPartitionState state = jobContext.getPartitionState(pId);\n      Partition partition = new Partition(pName(jobResource, pId));\n      String instance = jobContext.getAssignedParticipant(pId);\n      Message pendingMessage = currentStateOutput.getPendingState(jobResource, partition, instance);\n      // If state is INIT but is pending INIT->RUNNING, it's not yet safe to say the job finished\n      if (state == TaskPartitionState.RUNNING\n          || (state == TaskPartitionState.INIT && pendingMessage != null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Return jobConfig.DEFAULT_TIMEOUT_NEVER if job should never timeout.\n  // job start time can't be -1 before calling this method.\n  private long computeJobTimeoutTime(JobContext jobContext, JobConfig jobConfig) {\n    return (jobConfig.getTimeout() == JobConfig.DEFAULT_TIMEOUT_NEVER\n        || jobConfig.getTimeout() > Long.MAX_VALUE - jobContext.getStartTime()) // check long overflow\n        ? jobConfig.DEFAULT_TIMEOUT_NEVER\n        : jobContext.getStartTime() + jobConfig.getTimeout();\n  }\n  private void markJobComplete(String jobName, JobContext jobContext, WorkflowConfig workflowConfig,\n      WorkflowContext workflowContext, Map<String, JobConfig> jobConfigMap) {\n    long currentTime = System.currentTimeMillis();\n    workflowContext.setJobState(jobName, TaskState.COMPLETED);\n    jobContext.setFinishTime(currentTime);\n    if (isWorkflowFinished(workflowContext, workflowConfig, jobConfigMap)) {\n      workflowContext.setFinishTime(currentTime);\n    }\n    scheduleJobCleanUp(jobConfigMap.get(jobName), workflowConfig, currentTime);\n  }\n  private void scheduleForNextTask(String job, JobContext jobCtx, long now) {\n    // Figure out the earliest schedulable time in the future of a non-complete job\n    boolean shouldSchedule = false;\n    long earliestTime = Long.MAX_VALUE;\n    for (int p : jobCtx.getPartitionSet()) {\n      long retryTime = jobCtx.getNextRetryTime(p);\n      TaskPartitionState state = jobCtx.getPartitionState(p);\n      state = (state != null) ? state : TaskPartitionState.INIT;\n      Set<TaskPartitionState> errorStates =\n          Sets.newHashSet(TaskPartitionState.ERROR, TaskPartitionState.TASK_ERROR,\n              TaskPartitionState.TIMED_OUT);\n      if (errorStates.contains(state) && retryTime > now && retryTime < earliestTime) {\n        earliestTime = retryTime;\n        shouldSchedule = true;\n      }\n    }\n    // If any was found, then schedule it\n    if (shouldSchedule) {\n      long scheduledTime = _rebalanceScheduler.getRebalanceTime(job);\n      if (scheduledTime == -1 || earliestTime < scheduledTime) {\n        _rebalanceScheduler.scheduleRebalance(_manager, job, earliestTime);\n      }\n    }\n  }\n  // Set job timeout rebalance, if the time is earlier than the current scheduled rebalance time\n  // This needs to run for every rebalance because the scheduled rebalance could be removed in other places.\n  private void scheduleRebalanceForJobTimeout(JobConfig jobCfg, JobContext jobCtx) {\n    long jobTimeoutTime = computeJobTimeoutTime(jobCtx, jobCfg);\n    if (jobTimeoutTime != JobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime > System.currentTimeMillis()) {\n      long nextRebalanceTime = _rebalanceScheduler.getRebalanceTime(jobCfg.getJobId());\n      if (nextRebalanceTime == JobConfig.DEFAULT_TIMEOUT_NEVER || jobTimeoutTime < nextRebalanceTime) {\n        _rebalanceScheduler.scheduleRebalance(_manager, jobCfg.getJobId(), jobTimeoutTime);\n      }\n    }\n  }\n  /**\n   * Get the last task assignment for a given job\n   *\n   * @param resourceName the name of the job\n   * @return {@link ResourceAssignment} instance, or null if no assignment is available\n   */\n  private ResourceAssignment getPrevResourceAssignment(String resourceName) {\n    ZNRecord r = _manager.getHelixPropertyStore()\n        .get(Joiner.on(\"/\").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),\n            null, AccessOption.PERSISTENT);\n    return r != null ? new ResourceAssignment(r) : null;\n  }\n  /**\n   * Set the last task assignment for a given job\n   *\n   * @param resourceName the name of the job\n   * @param ra           {@link ResourceAssignment} containing the task assignment\n   */\n  private void setPrevResourceAssignment(String resourceName,\n      ResourceAssignment ra) {\n    _manager.getHelixPropertyStore()\n        .set(Joiner.on(\"/\").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),\n            ra.getRecord(), AccessOption.PERSISTENT);\n  }\n  /**\n   * Checks if the job has completed.\n   * Look at states of all tasks of the job, there're 3 kind: completed, given up, not given up.\n   * The job is completed if all tasks are completed or given up, and the number of given up tasks is within job\n   * failure threshold.\n   */\n  private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions, JobConfig cfg) {\n    int numOfGivenUpTasks = 0;\n    // Iterate through all tasks, if any one indicates the job has not completed, return false.\n    for (Integer pId : allPartitions) {\n      TaskPartitionState state = ctx.getPartitionState(pId);\n      if (state != TaskPartitionState.COMPLETED) {\n        if(!isTaskGivenup(ctx, cfg, pId)) {\n          return false;\n        }\n        // If the task is given up, there's still chance the job has completed because of job failure threshold.\n        numOfGivenUpTasks++;\n      }\n    }\n    return numOfGivenUpTasks <= cfg.getFailureThreshold();\n  }\n  private static void addCompletedTasks(Set<Integer> set, JobContext ctx,\n      Iterable<Integer> pIds) {\n    for (Integer pId : pIds) {\n      TaskPartitionState state = ctx.getPartitionState(pId);\n      if (state == TaskPartitionState.COMPLETED) {\n        set.add(pId);\n      }\n    }\n  }\n  private static boolean isTaskGivenup(JobContext ctx, JobConfig cfg, int pId) {\n    TaskPartitionState state = ctx.getPartitionState(pId);\n    if (state == TaskPartitionState.TASK_ABORTED || state == TaskPartitionState.ERROR) {\n      return true;\n    }\n    if (state == TaskPartitionState.TIMED_OUT || state == TaskPartitionState.TASK_ERROR) {\n      return ctx.getPartitionNumAttempts(pId) >= cfg.getMaxAttemptsPerTask();\n    }\n    return false;\n  }\n  // add all partitions that have been tried maxNumberAttempts\n  private static void addGiveupPartitions(Set<Integer> set, JobContext ctx, Iterable<Integer> pIds,\n      JobConfig cfg) {\n    for (Integer pId : pIds) {\n      if (isTaskGivenup(ctx, cfg, pId)) {\n        set.add(pId);\n      }\n    }\n  }\n  private static List<Integer> getNextPartitions(SortedSet<Integer> candidatePartitions,\n      Set<Integer> excluded, Set<Integer> throttled, int n) {\n    List<Integer> result = new ArrayList<Integer>();\n    for (Integer pId : candidatePartitions) {\n      if (!excluded.contains(pId)) {\n        if (result.size() < n) {\n          result.add(pId);\n        } else {\n          throttled.add(pId);\n        }\n      }\n    }\n    return result;\n  }\n  private static void markPartitionDelayed(JobConfig cfg, JobContext ctx, int p) {\n    long delayInterval = cfg.getTaskRetryDelay();\n    if (delayInterval <= 0) {\n      return;\n    }\n    long nextStartTime = ctx.getPartitionFinishTime(p) + delayInterval;\n    ctx.setNextRetryTime(p, nextStartTime);\n  }\n  private static void markPartitionCompleted(JobContext ctx, int pId) {\n    ctx.setPartitionState(pId, TaskPartitionState.COMPLETED);\n    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());\n    ctx.incrementNumAttempts(pId);\n  }\n  private static void markPartitionError(JobContext ctx, int pId, TaskPartitionState state,\n      boolean incrementAttempts) {\n    ctx.setPartitionState(pId, state);\n    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());\n    if (incrementAttempts) {\n      ctx.incrementNumAttempts(pId);\n    }\n  }\n  private static void markAllPartitionsError(JobContext ctx, TaskPartitionState state,\n      boolean incrementAttempts) {\n    for (int pId : ctx.getPartitionSet()) {\n      markPartitionError(ctx, pId, state, incrementAttempts);\n    }\n  }\n  /**\n   * @param liveInstances\n   * @param prevAssignment task partition -> (instance -> state)\n   * @param allTaskPartitions all task partitionIds\n   * @return instance -> partitionIds from previous assignment, if the instance is still live\n   */\n  private static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n      Iterable<String> liveInstances, ResourceAssignment prevAssignment, Set<Integer> allTaskPartitions) {\n    Map<String, SortedSet<Integer>> result = new HashMap<String, SortedSet<Integer>>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n    for (Partition partition : prevAssignment.getMappedPartitions()) {\n      int pId = getPartitionId(partition.getPartitionName());\n      if (allTaskPartitions.contains(pId)) {\n        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n        for (String instance : replicaMap.keySet()) {\n          SortedSet<Integer> pList = result.get(instance);\n          if (pList != null) {\n            pList.add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n  /* Extracts the partition id from the given partition name. */\n  private static int getPartitionId(String pName) {\n    int index = pName.lastIndexOf(\"_\");\n    if (index == -1) {\n      throw new HelixException(\"Invalid partition name \" + pName);\n    }\n    return Integer.valueOf(pName.substring(index + 1));\n  }\n  private static Set<Integer> getNonReadyPartitions(JobContext ctx, long now) {\n    Set<Integer> nonReadyPartitions = Sets.newHashSet();\n    for (int p : ctx.getPartitionSet()) {\n      long toStart = ctx.getNextRetryTime(p);\n      if (now < toStart) {\n        nonReadyPartitions.add(p);\n      }\n    }\n    return nonReadyPartitions;\n  }\n  private TaskAssignmentCalculator getAssignmentCalulator(JobConfig jobConfig) {\n    return isGenericTaskJob(jobConfig) ? _genericTaskAssignmentCal : _fixTaskAssignmentCal;\n  }\n  private boolean isGenericTaskJob(JobConfig jobConfig) {\n    Map<String, TaskConfig> taskConfigMap = jobConfig.getTaskConfigMap();\n    return taskConfigMap != null && !taskConfigMap.isEmpty();\n  }\n  /**\n   * Check whether tasks are not in final states\n   * @param jobContext The job context\n   * @return           False if still tasks not in final state. Otherwise return true\n   */\n  private boolean checkJobStopped(JobContext jobContext) {\n    for (int partition : jobContext.getPartitionSet()) {\n      TaskPartitionState taskState = jobContext.getPartitionState(partition);\n      if (taskState == TaskPartitionState.RUNNING) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Computes the partition name given the resource name and partition id.\n   */\n  private String pName(String resource, int pId) {\n    return resource + \"_\" + pId;\n  }\n  /**\n   * An (instance, state) pair.\n   */\n  private static class PartitionAssignment {\n    private final String _instance;\n    private final String _state;\n    private PartitionAssignment(String instance, String state) {\n      _instance = instance;\n      _state = state;\n    }\n  }\n"]], "pred": {"ppl": 2.118398427963257, "ppl_lower": 2.815370559692383, "ppl/lowercase_ppl": -1.3789111118219803, "ppl/zlib": 8.587808542197065e-05, "Min_5.0% Prob": 6.434679648455451, "Min_10.0% Prob": 4.864214392269359, "Min_20.0% Prob": 3.254400232843324, "Min_30.0% Prob": 2.389501718524235, "Min_40.0% Prob": 1.8511212300190425, "Min_50.0% Prob": 1.4971685433603545, "Min_60.0% Prob": 1.2514199876829641}}
{"hexsha": "5568d8218206ecb2d0de57706117512a3224fd47", "ext": "java", "lang": "Java", "content": "public class SonarWayProfileTest {\n    private IMocksControl mocksControl;\n    private XMLProfileParser parser;\n    private RuleFinder ruleFinder;\n    private SonarWayProfile profile;\n    private ValidationMessages messages;\n\n    @Before\n    public void setup() {\n        mocksControl = EasyMock.createControl();\n        ruleFinder = mocksControl.createMock(RuleFinder.class);\n        parser = new XMLProfileParser(ruleFinder);\n        messages = ValidationMessages.create();\n\n        profile = new SonarWayProfile(parser);\n    }\n\n    @Test\n    public void testConstructor() {\n        assertNotNull(profile);\n    }\n\n    @Test\n    public void testCreateProfile() {\n//       RulesProfile rulesProfile = profile.createProfile(messages);\n//       assertNotNull(rulesProfile);\n//       assertEquals(\"Sonar Way\", rulesProfile.getName());\n//       assertEquals(\"ruby\", rulesProfile.getLanguage());\n    }\n\n}", "class_id": 0, "repo": "shay6/ruby_sonar_plugin", "file": "src/test/java/com/godaddy/sonar/ruby/core/profiles/SonarWayProfileTest.java", "last_update_at": "2018-03-14T15:20:10+00:00", "question_id": "5568d8218206ecb2d0de57706117512a3224fd47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SonarWayProfileTest {\n    private IMocksControl mocksControl;\n    private XMLProfileParser parser;\n    private RuleFinder ruleFinder;\n    private SonarWayProfile profile;\n    private ValidationMessages messages;\n    @Before\n    public void setup() {\n        mocksControl = EasyMock.createControl();\n        ruleFinder = mocksControl.createMock(RuleFinder.class);\n        parser = new XMLProfileParser(ruleFinder);\n        messages = ValidationMessages.create();\n        profile = new SonarWayProfile(parser);\n    }\n    @Test\n    public void testConstructor() {\n        assertNotNull(profile);\n    }\n    @Test\n    public void testCreateProfile() {\n//       RulesProfile rulesProfile = profile.createProfile(messages);\n//       assertNotNull(rulesProfile);\n//       assertEquals(\"Sonar Way\", rulesProfile.getName());\n//       assertEquals(\"ruby\", rulesProfile.getLanguage());\n    }\n"]], "pred": {"ppl": 2.2717514038085938, "ppl_lower": 3.084418296813965, "ppl/lowercase_ppl": -1.3726910022383136, "ppl/zlib": 0.002427665909865753, "Min_5.0% Prob": 7.848746220270793, "Min_10.0% Prob": 5.863802711168925, "Min_20.0% Prob": 3.5948639872173467, "Min_30.0% Prob": 2.5882499855425625, "Min_40.0% Prob": 2.012451272147397, "Min_50.0% Prob": 1.6326373633307716, "Min_60.0% Prob": 1.3654670759957905}}
{"hexsha": "e067db237b92d515800eff0d3dff3e8754e33d3f", "ext": "java", "lang": "Java", "content": "public final class AuctionableHall extends ClanHall\n{\n\tprotected long _paidUntil;\n\tprivate final int _grade;\n\tprotected boolean _paid;\n\tprivate final int _lease;\n\tprivate final int _chRate = 604800000;\n\t\n\tpublic AuctionableHall(StatsSet set)\n\t{\n\t\tsuper(set);\n\t\t_paidUntil = set.getLong(\"paidUntil\");\n\t\t_grade = set.getInt(\"grade\");\n\t\t_paid = set.getBoolean(\"paid\");\n\t\t_lease = set.getInt(\"lease\");\n\t\t\n\t\tif (getOwnerId() != 0)\n\t\t{\n\t\t\t_isFree = false;\n\t\t\tinitialyzeTask(false);\n\t\t\tloadFunctions();\n\t\t}\n\t}\n\t\n\t/**\n\t * @return if clanHall is paid or not\n\t */\n\tpublic final boolean getPaid()\n\t{\n\t\treturn _paid;\n\t}\n\t\n\t/** Return lease */\n\t@Override\n\tpublic final int getLease()\n\t{\n\t\treturn _lease;\n\t}\n\t\n\t/** Return PaidUntil */\n\t@Override\n\tpublic final long getPaidUntil()\n\t{\n\t\treturn _paidUntil;\n\t}\n\t\n\t/** Return Grade */\n\t@Override\n\tpublic final int getGrade()\n\t{\n\t\treturn _grade;\n\t}\n\t\n\t@Override\n\tpublic final void free()\n\t{\n\t\tsuper.free();\n\t\t_paidUntil = 0;\n\t\t_paid = false;\n\t}\n\t\n\t@Override\n\tpublic final void setOwner(L2Clan clan)\n\t{\n\t\tsuper.setOwner(clan);\n\t\t_paidUntil = System.currentTimeMillis();\n\t\tinitialyzeTask(true);\n\t}\n\t\n\t/**\n\t * Initialize Fee Task\n\t * @param forced\n\t */\n\tprivate final void initialyzeTask(boolean forced)\n\t{\n\t\tlong currentTime = System.currentTimeMillis();\n\t\tif (_paidUntil > currentTime)\n\t\t{\n\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - currentTime);\n\t\t}\n\t\telse if (!_paid && !forced)\n\t\t{\n\t\t\tif ((System.currentTimeMillis() + (3600000 * 24)) <= (_paidUntil + _chRate))\n\t\t\t{\n\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), System.currentTimeMillis() + (3600000 * 24));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - System.currentTimeMillis());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 0);\n\t\t}\n\t}\n\t\n\t/** Fee Task */\n\tprotected class FeeTask implements Runnable\n\t{\n\t\tprivate final Logger _log = Logger.getLogger(FeeTask.class.getName());\n\t\t\n\t\t@Override\n\t\tpublic void run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong _time = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t\tif (isFree())\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (_paidUntil > _time)\n\t\t\t\t{\n\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tL2Clan Clan = ClanTable.getInstance().getClan(getOwnerId());\n\t\t\t\tif (ClanTable.getInstance().getClan(getOwnerId()).getWarehouse().getAdena() >= getLease())\n\t\t\t\t{\n\t\t\t\t\tif (_paidUntil != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (_paidUntil <= _time)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_paidUntil += _chRate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_paidUntil = _time + _chRate;\n\t\t\t\t\t}\n\t\t\t\t\tClanTable.getInstance().getClan(getOwnerId()).getWarehouse().destroyItemByItemId(\"CH_rental_fee\", Inventory.ADENA_ID, getLease(), null, null);\n\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);\n\t\t\t\t\t_paid = true;\n\t\t\t\t\tupdateDb();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_paid = false;\n\t\t\t\t\tif (_time > (_paidUntil + _chRate))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ClanHallManager.getInstance().loaded())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAuctionManager.getInstance().initNPC(getId());\n\t\t\t\t\t\t\tClanHallManager.getInstance().setFree(getId());\n\t\t\t\t\t\t\tClan.broadcastToOnlineMembers(SystemMessage.getSystemMessage(SystemMessageId.THE_CLAN_HALL_FEE_IS_ONE_WEEK_OVERDUE_THEREFORE_THE_CLAN_HALL_OWNERSHIP_HAS_BEEN_REVOKED));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 3000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateDb();\n\t\t\t\t\t\tSystemMessage sm = SystemMessage.getSystemMessage(SystemMessageId.PAYMENT_FOR_YOUR_CLAN_HALL_HAS_NOT_BEEN_MADE_PLEASE_MAKE_PAYMENT_TO_YOUR_CLAN_WAREHOUSE_BY_S1_TOMORROW);\n\t\t\t\t\t\tsm.addInt(getLease());\n\t\t\t\t\t\tClan.broadcastToOnlineMembers(sm);\n\t\t\t\t\t\tif ((_time + (3600000 * 24)) <= (_paidUntil + _chRate))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _time + (3600000 * 24));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - _time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.log(Level.SEVERE, \"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic final void updateDb()\n\t{\n\t\ttry (Connection con = ConnectionFactory.getInstance().getConnection();\n\t\t\tPreparedStatement ps = con.prepareStatement(\"UPDATE clanhall SET ownerId=?, paidUntil=?, paid=? WHERE id=?\"))\n\t\t{\n\t\t\tps.setInt(1, getOwnerId());\n\t\t\tps.setLong(2, getPaidUntil());\n\t\t\tps.setInt(3, (getPaid()) ? 1 : 0);\n\t\t\tps.setInt(4, getId());\n\t\t\tps.execute();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\t_log.log(Level.WARNING, \"Exception: updateOwnerInDB(L2Clan clan): \" + e.getMessage(), e);\n\t\t}\n\t}\n}", "class_id": 0, "repo": "RollingSoftware/L2J_HighFive_Hardcore", "file": "l2j_server/src/main/java/com/l2jserver/gameserver/model/entity/clanhall/AuctionableHall.java", "last_update_at": "2018-06-05T20:47:59+00:00", "question_id": "e067db237b92d515800eff0d3dff3e8754e33d3f", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class AuctionableHall extends ClanHall\n{\n\tprotected long _paidUntil;\n\tprivate final int _grade;\n\tprotected boolean _paid;\n\tprivate final int _lease;\n\tprivate final int _chRate = 604800000;\n\t\n\tpublic AuctionableHall(StatsSet set)\n\t{\n\t\tsuper(set);\n\t\t_paidUntil = set.getLong(\"paidUntil\");\n\t\t_grade = set.getInt(\"grade\");\n\t\t_paid = set.getBoolean(\"paid\");\n\t\t_lease = set.getInt(\"lease\");\n\t\t\n\t\tif (getOwnerId() != 0)\n\t\t{\n\t\t\t_isFree = false;\n\t\t\tinitialyzeTask(false);\n\t\t\tloadFunctions();\n\t\t}\n\t}\n\t\n\t/**\n\t * @return if clanHall is paid or not\n\t */\n\tpublic final boolean getPaid()\n\t{\n\t\treturn _paid;\n\t}\n\t\n\t/** Return lease */\n\t@Override\n\tpublic final int getLease()\n\t{\n\t\treturn _lease;\n\t}\n\t\n\t/** Return PaidUntil */\n\t@Override\n\tpublic final long getPaidUntil()\n\t{\n\t\treturn _paidUntil;\n\t}\n\t\n\t/** Return Grade */\n\t@Override\n\tpublic final int getGrade()\n\t{\n\t\treturn _grade;\n\t}\n\t\n\t@Override\n\tpublic final void free()\n\t{\n\t\tsuper.free();\n\t\t_paidUntil = 0;\n\t\t_paid = false;\n\t}\n\t\n\t@Override\n\tpublic final void setOwner(L2Clan clan)\n\t{\n\t\tsuper.setOwner(clan);\n\t\t_paidUntil = System.currentTimeMillis();\n\t\tinitialyzeTask(true);\n\t}\n\t\n\t/**\n\t * Initialize Fee Task\n\t * @param forced\n\t */\n\tprivate final void initialyzeTask(boolean forced)\n\t{\n\t\tlong currentTime = System.currentTimeMillis();\n\t\tif (_paidUntil > currentTime)\n\t\t{\n\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - currentTime);\n\t\t}\n\t\telse if (!_paid && !forced)\n\t\t{\n\t\t\tif ((System.currentTimeMillis() + (3600000 * 24)) <= (_paidUntil + _chRate))\n\t\t\t{\n\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), System.currentTimeMillis() + (3600000 * 24));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - System.currentTimeMillis());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 0);\n\t\t}\n\t}\n\t\n\t/** Fee Task */\n\tprotected class FeeTask implements Runnable\n\t{\n\t\tprivate final Logger _log = Logger.getLogger(FeeTask.class.getName());\n\t\t\n\t\t@Override\n\t\tpublic void run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong _time = System.currentTimeMillis();\n\t\t\t\t\n\t\t\t\tif (isFree())\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (_paidUntil > _time)\n\t\t\t\t{\n\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tL2Clan Clan = ClanTable.getInstance().getClan(getOwnerId());\n\t\t\t\tif (ClanTable.getInstance().getClan(getOwnerId()).getWarehouse().getAdena() >= getLease())\n\t\t\t\t{\n\t\t\t\t\tif (_paidUntil != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (_paidUntil <= _time)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_paidUntil += _chRate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_paidUntil = _time + _chRate;\n\t\t\t\t\t}\n\t\t\t\t\tClanTable.getInstance().getClan(getOwnerId()).getWarehouse().destroyItemByItemId(\"CH_rental_fee\", Inventory.ADENA_ID, getLease(), null, null);\n\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);\n\t\t\t\t\t_paid = true;\n\t\t\t\t\tupdateDb();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_paid = false;\n\t\t\t\t\tif (_time > (_paidUntil + _chRate))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ClanHallManager.getInstance().loaded())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAuctionManager.getInstance().initNPC(getId());\n\t\t\t\t\t\t\tClanHallManager.getInstance().setFree(getId());\n\t\t\t\t\t\t\tClan.broadcastToOnlineMembers(SystemMessage.getSystemMessage(SystemMessageId.THE_CLAN_HALL_FEE_IS_ONE_WEEK_OVERDUE_THEREFORE_THE_CLAN_HALL_OWNERSHIP_HAS_BEEN_REVOKED));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 3000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateDb();\n\t\t\t\t\t\tSystemMessage sm = SystemMessage.getSystemMessage(SystemMessageId.PAYMENT_FOR_YOUR_CLAN_HALL_HAS_NOT_BEEN_MADE_PLEASE_MAKE_PAYMENT_TO_YOUR_CLAN_WAREHOUSE_BY_S1_TOMORROW);\n\t\t\t\t\t\tsm.addInt(getLease());\n\t\t\t\t\t\tClan.broadcastToOnlineMembers(sm);\n\t\t\t\t\t\tif ((_time + (3600000 * 24)) <= (_paidUntil + _chRate))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _time + (3600000 * 24));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - _time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.log(Level.SEVERE, \"\", e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic final void updateDb()\n\t{\n\t\ttry (Connection con = ConnectionFactory.getInstance().getConnection();\n\t\t\tPreparedStatement ps = con.prepareStatement(\"UPDATE clanhall SET ownerId=?, paidUntil=?, paid=? WHERE id=?\"))\n\t\t{\n\t\t\tps.setInt(1, getOwnerId());\n\t\t\tps.setLong(2, getPaidUntil());\n\t\t\tps.setInt(3, (getPaid()) ? 1 : 0);\n\t\t\tps.setInt(4, getId());\n\t\t\tps.execute();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\t_log.log(Level.WARNING, \"Exception: updateOwnerInDB(L2Clan clan): \" + e.getMessage(), e);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.6118558645248413, "ppl_lower": 1.822602391242981, "ppl/lowercase_ppl": -1.2573998417981438, "ppl/zlib": 0.00032900498002776357, "Min_5.0% Prob": 5.4377102431129005, "Min_10.0% Prob": 3.793417045883104, "Min_20.0% Prob": 2.271733605540266, "Min_30.0% Prob": 1.5795998929762374, "Min_40.0% Prob": 1.191819114492145, "Min_50.0% Prob": 0.955312542678832, "Min_60.0% Prob": 0.7965985167579578}}
{"hexsha": "9840e26fb17e826cc58f4dd6bf250109c9dfaf6b", "ext": "java", "lang": "Java", "content": "public class ActivityFeedServlet extends HttpServlet{\n  /** Store class that gives access to Conversations. */\n  private ConversationStore conversationStore;\n\n  /** Store class that gives access to Messages. */\n  private MessageStore messageStore;\n\n  /** Store class that gives access to Users. */\n  private UserStore userStore;\n\n  @Override\n  public void init() throws ServletException{\n    super.init();\n\n    setMessageStore(MessageStore.getInstance());\n    setUserStore(UserStore.getInstance());\n    setConversationStore(ConversationStore.getInstance());\n  }\n\n  /**\n   * Sets the UserStore used by this servlet. This function provides a common setup method for use\n   * by the test framework or the servlet's init() function.\n   */\n  void setUserStore(UserStore userStore) {\n    this.userStore = userStore;\n  }\n\n  /**\n   * Sets the ConversationStore used by this servlet. This function provides a common setup method\n   * for use by the test framework or the servlet's init() function.\n   */\n  void setConversationStore(ConversationStore conversationStore) {\n    this.conversationStore = conversationStore;\n  }\n\n  /**\n   * Sets the MessageStore used by this servlet. This function provides a common setup method for\n   * use by the test framework or the servlet's init() function.\n   */\n  void setMessageStore(MessageStore messageStore) {\n    this.messageStore = messageStore;\n  }\n\n  public static class DateFormatter {\n\n    static final String FORMAT = \"EEE MMM dd yyyy hh:mm:ss a z\";\n    static final String TIMEZONE = \"PST\";\n\n    /**\n     * Utility function to convert java Date to TimeZone format\n     *\n     * @param date date to be formatted\n     */\n    public static String formatDateToString(Date date) {\n      // null check\n      if (date == null) return null;\n      // create SimpleDateFormat object with input format\n      SimpleDateFormat sdf = new SimpleDateFormat(FORMAT);\n      // set timezone to SimpleDateFormat\n      sdf.setTimeZone(TimeZone.getTimeZone(TIMEZONE));\n      // return Date in required format with timezone as String\n      return sdf.format(date);\n    }\n  }\n\n\n    /**\n   * Subclass to combine activities together even if they are from different types.\n   */\n  public static class Item implements Comparable<Item>{\n    Instant instant;\n    UUID id;\n\n    public Item(Message m){\n      instant = m.getCreationTime();\n      id = m.getId();\n    }\n\n    public Item(User u){\n      instant = u.getCreationTime();\n      id = u.getId();\n    }\n\n    public Item(Conversation c){\n      instant = c.getCreationTime();\n      id = c.getId();\n    }\n\n    @Override\n    public int compareTo(Item item) {\n      if (instant.compareTo(item.instant)>0) {\n        return -1;\n      } else if (instant.compareTo(item.instant)<0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    public UUID getId() {\n      return id;\n    }\n  }\n\n  /**\n   * This function fires when a user navigates to the activity feed page.\n   * It then forwards to activityfeed.jsp for rendering.\n   */\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException, ServletException {\n\n    PriorityQueue<Item> fringe = new PriorityQueue<>();\n    Map<UUID, Object> ids = new HashMap<>();\n\n    List<Conversation> conversations = conversationStore.getAllConversations();\n    List<User> users = userStore.getUsers();\n    List<Message> messages = messageStore.getMessages();\n\n    for(Conversation c: conversations){\n      fringe.add(new Item(c));\n      ids.put(c.getId(),c);\n    }\n\n    for(User u: users){\n      fringe.add(new Item(u));\n      ids.put(u.getId(),u);\n    }\n\n    for(Message m: messages){\n      fringe.add(new Item(m));\n      ids.put(m.getId(),m);\n    }\n\n    request.setAttribute(\"FeedItems\", fringe);\n    request.setAttribute(\"ids\", ids);\n    request.getRequestDispatcher(\"/WEB-INF/view/activityfeed.jsp\").forward(request, response);\n  }\n}", "class_id": 0, "repo": "Georgeg10499/CodeU-2018", "file": "src/main/java/codeu/controller/ActivityFeedServlet.java", "last_update_at": "2018-05-17T00:13:21+00:00", "question_id": "9840e26fb17e826cc58f4dd6bf250109c9dfaf6b", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ActivityFeedServlet extends HttpServlet{\n  /** Store class that gives access to Conversations. */\n  private ConversationStore conversationStore;\n  /** Store class that gives access to Messages. */\n  private MessageStore messageStore;\n  /** Store class that gives access to Users. */\n  private UserStore userStore;\n  @Override\n  public void init() throws ServletException{\n    super.init();\n    setMessageStore(MessageStore.getInstance());\n    setUserStore(UserStore.getInstance());\n    setConversationStore(ConversationStore.getInstance());\n  }\n  /**\n   * Sets the UserStore used by this servlet. This function provides a common setup method for use\n   * by the test framework or the servlet's init() function.\n   */\n  void setUserStore(UserStore userStore) {\n    this.userStore = userStore;\n  }\n  /**\n   * Sets the ConversationStore used by this servlet. This function provides a common setup method\n   * for use by the test framework or the servlet's init() function.\n   */\n  void setConversationStore(ConversationStore conversationStore) {\n    this.conversationStore = conversationStore;\n  }\n  /**\n   * Sets the MessageStore used by this servlet. This function provides a common setup method for\n   * use by the test framework or the servlet's init() function.\n   */\n  void setMessageStore(MessageStore messageStore) {\n    this.messageStore = messageStore;\n  }\n  public static class DateFormatter {\n    static final String FORMAT = \"EEE MMM dd yyyy hh:mm:ss a z\";\n    static final String TIMEZONE = \"PST\";\n    /**\n     * Utility function to convert java Date to TimeZone format\n     *\n     * @param date date to be formatted\n     */\n    public static String formatDateToString(Date date) {\n      // null check\n      if (date == null) return null;\n      // create SimpleDateFormat object with input format\n      SimpleDateFormat sdf = new SimpleDateFormat(FORMAT);\n      // set timezone to SimpleDateFormat\n      sdf.setTimeZone(TimeZone.getTimeZone(TIMEZONE));\n      // return Date in required format with timezone as String\n      return sdf.format(date);\n    }\n  }\n    /**\n   * Subclass to combine activities together even if they are from different types.\n   */\n  public static class Item implements Comparable<Item>{\n    Instant instant;\n    UUID id;\n    public Item(Message m){\n      instant = m.getCreationTime();\n      id = m.getId();\n    }\n    public Item(User u){\n      instant = u.getCreationTime();\n      id = u.getId();\n    }\n    public Item(Conversation c){\n      instant = c.getCreationTime();\n      id = c.getId();\n    }\n    @Override\n    public int compareTo(Item item) {\n      if (instant.compareTo(item.instant)>0) {\n        return -1;\n      } else if (instant.compareTo(item.instant)<0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    public UUID getId() {\n      return id;\n    }\n  }\n  /**\n   * This function fires when a user navigates to the activity feed page.\n   * It then forwards to activityfeed.jsp for rendering.\n   */\n  @Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException, ServletException {\n    PriorityQueue<Item> fringe = new PriorityQueue<>();\n    Map<UUID, Object> ids = new HashMap<>();\n    List<Conversation> conversations = conversationStore.getAllConversations();\n    List<User> users = userStore.getUsers();\n    List<Message> messages = messageStore.getMessages();\n    for(Conversation c: conversations){\n      fringe.add(new Item(c));\n      ids.put(c.getId(),c);\n    }\n    for(User u: users){\n      fringe.add(new Item(u));\n      ids.put(u.getId(),u);\n    }\n    for(Message m: messages){\n      fringe.add(new Item(m));\n      ids.put(m.getId(),m);\n    }\n    request.setAttribute(\"FeedItems\", fringe);\n    request.setAttribute(\"ids\", ids);\n    request.getRequestDispatcher(\"/WEB-INF/view/activityfeed.jsp\").forward(request, response);\n  }\n"]], "pred": {"ppl": 1.6186392307281494, "ppl_lower": 1.8127367496490479, "ppl/lowercase_ppl": -1.2351645353753833, "ppl/zlib": 0.0003822109644686825, "Min_5.0% Prob": 5.92092731887219, "Min_10.0% Prob": 4.014241687223023, "Min_20.0% Prob": 2.3349602343697176, "Min_30.0% Prob": 1.5968358148790263, "Min_40.0% Prob": 1.201422234830927, "Min_50.0% Prob": 0.9633271331186252, "Min_60.0% Prob": 0.8034439566410352}}
{"hexsha": "126271718cb7d9b24047f28783c27b2bb56be6b6", "ext": "java", "lang": "Java", "content": "public class BlockSolidLayoutBlock extends Block {\n\n    public static final PropertyEnum<EnumDyeColor> COLOR = PropertyEnum.create(\"color\", EnumDyeColor.class);\n\n    public BlockSolidLayoutBlock(){\n        super(Material.GROUND);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(COLOR, EnumDyeColor.GRAY));\n\n        setHardness((float) .04);\n        setResistance(0);\n        setLightOpacity(0);\n\n        setUnlocalizedName(LayoutBlocks.MOD_ID + \".solid_layout_block\");\n        setRegistryName(\"solid_layout_block\");\n    }\n\n    @Override\n    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player){\n        if(player.getHeldItemMainhand().getItem() == ModItems.itemPlacer){\n            ItemStack stack = player.getHeldItemMainhand();\n            NBTTagCompound nbt;\n\n            if (stack.hasTagCompound()){\n                nbt = stack.getTagCompound();\n                if (nbt.hasKey(\"breaks\")){\n                    byte breaks = nbt.getByte(\"breaks\");\n\n                    switch (breaks){\n                        case 0: //normal\n                            break;\n\n                        case 1: //break all connected layoutblocks\n                            if (Config.enableAltBreakMode)\n                                new Thread(new BlockBreakerThread(worldIn, player, pos, stack)).start();\n                            break;\n                    }\n                }\n                else {\n                    nbt.setByte(\"breaks\", (byte) 0);\n                    stack.setTagCompound(nbt);\n                }\n            }\n            else {\n                nbt = new NBTTagCompound();\n                nbt.setByte(\"places\", (byte) 1);\n                nbt.setByte(\"breaks\", (byte) 0);\n                stack.setTagCompound(nbt);\n            }\n        }\n    }\n\n\n\n    @Override\n    @SideOnly(Side.CLIENT)\n    public BlockRenderLayer getBlockLayer() {\n        return BlockRenderLayer.CUTOUT;\n    }\n\n    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {\n        return false;\n    }\n\n\n    public Item createItemBlock(){\n        return new ItemBlock(this).setRegistryName(this.getRegistryName());\n    }\n\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public int quantityDropped(Random random) { return 0; }\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    protected boolean canSilkHarvest(){return false;}\n\n    public void registerItemModel(){\n        LayoutBlocks.proxy.registerItemRenderer(Item.getItemFromBlock(this), 0, \"solid_layout_block\");\n    }\n\n\n\n\n    //<editor-fold desc=\"Coloring stuff\">\n    @Override\n    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing side,\n                                    float hitX, float hitY, float hitZ){\n        ItemStack itemstack = playerIn.getHeldItem(hand);\n\n        if(!itemstack.isEmpty()){\n            if(DyeUtils.isDye(itemstack)){\n                if(DyeUtils.colorFromStack(itemstack) != null){\n                    worldIn.setBlockState(pos, state.withProperty(COLOR, DyeUtils.colorFromStack(itemstack).get()));\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Get the MapColor for this Block and the given BlockState\n     */\n    @SuppressWarnings( \"deprecation\" )\n    public MapColor getMapColor(IBlockState state, IBlockAccess worldIn, BlockPos pos)\n    {\n        return MapColor.getBlockColor((EnumDyeColor)state.getValue(COLOR));\n    }\n\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    @SuppressWarnings( \"deprecation\" )\n    public IBlockState getStateFromMeta(int meta)\n    {\n        return this.getDefaultState().withProperty(COLOR, EnumDyeColor.byMetadata(meta));\n    }\n\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state)\n    {\n        return ((EnumDyeColor)state.getValue(COLOR)).getMetadata();\n    }\n\n    protected BlockStateContainer createBlockState()\n    {\n        return new BlockStateContainer(this, new IProperty[] {COLOR});\n    }\n    //</editor-fold>\n}", "class_id": 0, "repo": "Schoggomilch/LayoutBlocks", "file": "src/main/java/com/schoggomilch/layout_blocks/block/BlockSolidLayoutBlock.java", "last_update_at": "2018-07-13T13:52:35+00:00", "question_id": "126271718cb7d9b24047f28783c27b2bb56be6b6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class BlockSolidLayoutBlock extends Block {\n    public static final PropertyEnum<EnumDyeColor> COLOR = PropertyEnum.create(\"color\", EnumDyeColor.class);\n    public BlockSolidLayoutBlock(){\n        super(Material.GROUND);\n        this.setDefaultState(this.blockState.getBaseState().withProperty(COLOR, EnumDyeColor.GRAY));\n        setHardness((float) .04);\n        setResistance(0);\n        setLightOpacity(0);\n        setUnlocalizedName(LayoutBlocks.MOD_ID + \".solid_layout_block\");\n        setRegistryName(\"solid_layout_block\");\n    }\n    @Override\n    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player){\n        if(player.getHeldItemMainhand().getItem() == ModItems.itemPlacer){\n            ItemStack stack = player.getHeldItemMainhand();\n            NBTTagCompound nbt;\n            if (stack.hasTagCompound()){\n                nbt = stack.getTagCompound();\n                if (nbt.hasKey(\"breaks\")){\n                    byte breaks = nbt.getByte(\"breaks\");\n                    switch (breaks){\n                        case 0: //normal\n                            break;\n                        case 1: //break all connected layoutblocks\n                            if (Config.enableAltBreakMode)\n                                new Thread(new BlockBreakerThread(worldIn, player, pos, stack)).start();\n                            break;\n                    }\n                }\n                else {\n                    nbt.setByte(\"breaks\", (byte) 0);\n                    stack.setTagCompound(nbt);\n                }\n            }\n            else {\n                nbt = new NBTTagCompound();\n                nbt.setByte(\"places\", (byte) 1);\n                nbt.setByte(\"breaks\", (byte) 0);\n                stack.setTagCompound(nbt);\n            }\n        }\n    }\n    @Override\n    @SideOnly(Side.CLIENT)\n    public BlockRenderLayer getBlockLayer() {\n        return BlockRenderLayer.CUTOUT;\n    }\n    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {\n        return false;\n    }\n    public Item createItemBlock(){\n        return new ItemBlock(this).setRegistryName(this.getRegistryName());\n    }\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    public int quantityDropped(Random random) { return 0; }\n    @Override\n    @SuppressWarnings( \"deprecation\" )\n    protected boolean canSilkHarvest(){return false;}\n    public void registerItemModel(){\n        LayoutBlocks.proxy.registerItemRenderer(Item.getItemFromBlock(this), 0, \"solid_layout_block\");\n    }\n    //<editor-fold desc=\"Coloring stuff\">\n    @Override\n    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing side,\n                                    float hitX, float hitY, float hitZ){\n        ItemStack itemstack = playerIn.getHeldItem(hand);\n        if(!itemstack.isEmpty()){\n            if(DyeUtils.isDye(itemstack)){\n                if(DyeUtils.colorFromStack(itemstack) != null){\n                    worldIn.setBlockState(pos, state.withProperty(COLOR, DyeUtils.colorFromStack(itemstack).get()));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get the MapColor for this Block and the given BlockState\n     */\n    @SuppressWarnings( \"deprecation\" )\n    public MapColor getMapColor(IBlockState state, IBlockAccess worldIn, BlockPos pos)\n    {\n        return MapColor.getBlockColor((EnumDyeColor)state.getValue(COLOR));\n    }\n    /**\n     * Convert the given metadata into a BlockState for this Block\n     */\n    @SuppressWarnings( \"deprecation\" )\n    public IBlockState getStateFromMeta(int meta)\n    {\n        return this.getDefaultState().withProperty(COLOR, EnumDyeColor.byMetadata(meta));\n    }\n    /**\n     * Convert the BlockState into the correct metadata value\n     */\n    public int getMetaFromState(IBlockState state)\n    {\n        return ((EnumDyeColor)state.getValue(COLOR)).getMetadata();\n    }\n    protected BlockStateContainer createBlockState()\n    {\n        return new BlockStateContainer(this, new IProperty[] {COLOR});\n    }\n    //</editor-fold>\n"]], "pred": {"ppl": 1.697448968887329, "ppl_lower": 2.1703591346740723, "ppl/lowercase_ppl": -1.4644751833414245, "ppl/zlib": 0.00039021129608236095, "Min_5.0% Prob": 5.233078409643734, "Min_10.0% Prob": 3.9104036443373738, "Min_20.0% Prob": 2.4521425299200357, "Min_30.0% Prob": 1.729962889957272, "Min_40.0% Prob": 1.314922511477415, "Min_50.0% Prob": 1.0572369064818594, "Min_60.0% Prob": 0.8825323442282037}}
{"hexsha": "1127bb6f5e9d7f7dfc2d09c1605febc452887c57", "ext": "java", "lang": "Java", "content": "public class KubernetesResponseComposer implements ResponseComposer {\n\n  @Override\n  public String compose(Collection<String> collection) {\n    List<HasMetadata> items = new ArrayList<>();\n    for (String item : collection) {\n      try (InputStream stream = new ByteArrayInputStream(item.getBytes(StandardCharsets.UTF_8.name()))) {\n        HasMetadata h = Serialization.unmarshal(stream);\n        items.add(h);\n      } catch (Exception e) {\n        throw KubernetesClientException.launderThrowable(e);\n      }\n    }\n    KubernetesList list = new KubernetesListBuilder().withItems(items).build();\n    return Serialization.asJson(list);\n  }\n}", "class_id": 0, "repo": "Vlatombe/kubernetes-client", "file": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesResponseComposer.java", "last_update_at": "2018-04-24T03:34:36+00:00", "question_id": "1127bb6f5e9d7f7dfc2d09c1605febc452887c57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class KubernetesResponseComposer implements ResponseComposer {\n  @Override\n  public String compose(Collection<String> collection) {\n    List<HasMetadata> items = new ArrayList<>();\n    for (String item : collection) {\n      try (InputStream stream = new ByteArrayInputStream(item.getBytes(StandardCharsets.UTF_8.name()))) {\n        HasMetadata h = Serialization.unmarshal(stream);\n        items.add(h);\n      } catch (Exception e) {\n        throw KubernetesClientException.launderThrowable(e);\n      }\n    }\n    KubernetesList list = new KubernetesListBuilder().withItems(items).build();\n    return Serialization.asJson(list);\n  }\n"]], "pred": {"ppl": 1.901202917098999, "ppl_lower": 2.983663320541382, "ppl/lowercase_ppl": -1.7014386094225102, "ppl/zlib": 0.0018841255134977772, "Min_5.0% Prob": 6.209596037864685, "Min_10.0% Prob": 4.552666762295892, "Min_20.0% Prob": 2.955287414438584, "Min_30.0% Prob": 2.104853306038707, "Min_40.0% Prob": 1.6120712815729135, "Min_50.0% Prob": 1.2820238863919364, "Min_60.0% Prob": 1.072030613022558}}
{"hexsha": "aaf02a9921531f8c4ac7d2eb14a1c6c4819a5a17", "ext": "java", "lang": "Java", "content": "public class DOMSwitchStatement implements Handler {\n\n\tfinal SwitchStatement statement;\n\n\tDSubTree tree = new DSubTree();\n\n\tArrayList<List<DASTNode>> bodies = new ArrayList<>();\n\tArrayList<Integer> nodeType = new ArrayList<>();\n\n\tpublic DOMSwitchStatement(SwitchStatement statement) {\n\t\tthis.statement = statement;\n\t}\n\n\tprivate DSubTree BuildTree(DSubTree Sexpr, int itPos) {\n\t\tDSubTree bodyPrev = new DSubTree();\n\t\tDSubTree caseNodes = new DSubTree();\n        DSubTree bodyNext;\n\t\tfor (int it1 = itPos; it1 < bodies.size(); it1++) {\n\t\t\tint typePrev = nodeType.get(it1);\n\t\t\tif (typePrev == 49) { // checks for 'case' statement\n\t\t\t\tbodyNext = BuildTree(Sexpr, it1+1);\n\t\t\t\tDASTNode caseNode = new DBranch(Sexpr.getNodesAsCalls(), bodyPrev.getNodes(), bodyNext.getNodes());\n\t\t\t\tcaseNodes.addNode(caseNode);\n\t\t\t\treturn caseNodes;\n\t\t\t} else {\n\t\t\t\tbodyPrev.addNodes(bodies.get(it1));\n\t\t\t}\n\t\t}\n\n\t\treturn bodyPrev;\n\t}\n\n\t@Override\n\tpublic DSubTree handle() {\n\t\tDSubTree Sexpr = new DOMExpression(statement.getExpression()).handle();\n\t\tboolean branch = Sexpr.isValid();\n\n\t\tfor (Object o : statement.statements()) {\n\t\t\tint type = ((Statement) o).getNodeType();\n\t\t\tnodeType.add(type);\n\t\t\tDSubTree body = new DOMStatement((Statement) o).handle();\n\t\t\tbodies.add(body.getNodes());\n\t\t\tif (type != 49) // excludes 'case' statement\n\t\t\t\tbranch |= body.isValid();\n\t\t}\n\n\t\tif (branch) {\n\t\t\tDSubTree switchNode = BuildTree(Sexpr, 1);\n\t\t\ttree.addNode(switchNode.getNodes().get(0));\n\t\t} else {\n\t\t\t// only one  will add nodes, the rest will add nothing\n\t\t\ttree.addNodes(Sexpr.getNodes());\n\t\t\tfor (Iterator<Object> iter = statement.statements().iterator(); iter.hasNext(); ) {\n\t\t\t\tObject o = iter.next();\n\t\t\t\tDSubTree body = new DOMStatement((Statement) o).handle();\n\t\t\t\ttree.addNodes(body.getNodes());\n\t\t\t}\n\t\t}\n\n\t\treturn tree;\n\t}\n}", "class_id": 0, "repo": "rohan2606/bayou", "file": "src/main/java/edu/rice/cs/caper/bayou/core/dom_driver/DOMSwitchStatement.java", "last_update_at": "2018-02-19T21:48:06+00:00", "question_id": "aaf02a9921531f8c4ac7d2eb14a1c6c4819a5a17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class DOMSwitchStatement implements Handler {\n\tfinal SwitchStatement statement;\n\tDSubTree tree = new DSubTree();\n\tArrayList<List<DASTNode>> bodies = new ArrayList<>();\n\tArrayList<Integer> nodeType = new ArrayList<>();\n\tpublic DOMSwitchStatement(SwitchStatement statement) {\n\t\tthis.statement = statement;\n\t}\n\tprivate DSubTree BuildTree(DSubTree Sexpr, int itPos) {\n\t\tDSubTree bodyPrev = new DSubTree();\n\t\tDSubTree caseNodes = new DSubTree();\n        DSubTree bodyNext;\n\t\tfor (int it1 = itPos; it1 < bodies.size(); it1++) {\n\t\t\tint typePrev = nodeType.get(it1);\n\t\t\tif (typePrev == 49) { // checks for 'case' statement\n\t\t\t\tbodyNext = BuildTree(Sexpr, it1+1);\n\t\t\t\tDASTNode caseNode = new DBranch(Sexpr.getNodesAsCalls(), bodyPrev.getNodes(), bodyNext.getNodes());\n\t\t\t\tcaseNodes.addNode(caseNode);\n\t\t\t\treturn caseNodes;\n\t\t\t} else {\n\t\t\t\tbodyPrev.addNodes(bodies.get(it1));\n\t\t\t}\n\t\t}\n\t\treturn bodyPrev;\n\t}\n\t@Override\n\tpublic DSubTree handle() {\n\t\tDSubTree Sexpr = new DOMExpression(statement.getExpression()).handle();\n\t\tboolean branch = Sexpr.isValid();\n\t\tfor (Object o : statement.statements()) {\n\t\t\tint type = ((Statement) o).getNodeType();\n\t\t\tnodeType.add(type);\n\t\t\tDSubTree body = new DOMStatement((Statement) o).handle();\n\t\t\tbodies.add(body.getNodes());\n\t\t\tif (type != 49) // excludes 'case' statement\n\t\t\t\tbranch |= body.isValid();\n\t\t}\n\t\tif (branch) {\n\t\t\tDSubTree switchNode = BuildTree(Sexpr, 1);\n\t\t\ttree.addNode(switchNode.getNodes().get(0));\n\t\t} else {\n\t\t\t// only one  will add nodes, the rest will add nothing\n\t\t\ttree.addNodes(Sexpr.getNodes());\n\t\t\tfor (Iterator<Object> iter = statement.statements().iterator(); iter.hasNext(); ) {\n\t\t\t\tObject o = iter.next();\n\t\t\t\tDSubTree body = new DOMStatement((Statement) o).handle();\n\t\t\t\ttree.addNodes(body.getNodes());\n\t\t\t}\n\t\t}\n\t\treturn tree;\n\t}\n"]], "pred": {"ppl": 2.3442800045013428, "ppl_lower": 2.545788049697876, "ppl/lowercase_ppl": -1.0967887631832152, "ppl/zlib": 0.0012584613300232904, "Min_5.0% Prob": 7.48928233348962, "Min_10.0% Prob": 5.712525399763193, "Min_20.0% Prob": 3.783432118038633, "Min_30.0% Prob": 2.750648084119778, "Min_40.0% Prob": 2.1102005783468485, "Min_50.0% Prob": 1.6964065037956018, "Min_60.0% Prob": 1.418268589351428}}
{"hexsha": "7d3260ed208653d80c9045f17dc684ec11257666", "ext": "java", "lang": "Java", "content": "public class WhileCommand extends AbstractCommand {\n\n    // <--[command]\n    // @Since 0.3.0\n    // @Name while\n    // @Arguments 'start'/'stop'/'next' [if comparisons]\n    // @Short runs a block of code repeatedly for so long as the comparisons return true.\n    // @Updated 2017/02/19\n    // @Group Queue\n    // @Procedural true\n    // @Minimum 1\n    // @Maximum -1\n    // @Description\n    // Runs a block of code repeatedly for so long as the comparisons return true.\n    // TODO: Explain more!\n    // @Example\n    // # This example runs forever (until it's externally stopped, or the engine shuts down)\n    // # and echoes \"hi\" every half second.\n    // - while start true:\n    //   - echo \"hi\"\n    //   - wait 0.5s\n    // -->\n\n    @Override\n    public String getName() {\n        return \"while\";\n    }\n\n    @Override\n    public String getArguments() {\n        return \"'start'/'stop'/'next' [if comparisons]\";\n    }\n\n    @Override\n    public int getMinimumArguments() {\n        return 1;\n    }\n\n    @Override\n    public int getMaximumArguments() {\n        return -1;\n    }\n\n    @Override\n    public boolean isProcedural() {\n        return true;\n    }\n\n    @Override\n    public boolean allowsBlock() {\n        return true;\n    }\n\n    @Override\n    public void execute(CommandQueue queue, CommandEntry entry) {\n        if (entry.arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n            CommandEntry orig = queue.commandStack.peek().entries[entry.blockStart - 1];\n            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();\n            helper.queue = queue;\n            helper.entry = orig;\n            helper.arguments = new ArrayList<>(orig.arguments);\n            boolean success = IfCommand.tryIf(helper);\n            if (success) {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While continuing...\");\n                }\n                queue.commandStack.peek().goTo(entry.blockStart);\n            }\n            else {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While completed!\");\n                }\n            }\n            return;\n        }\n        String type = entry.getArgumentObject(queue, 0).toString();\n        if (type.equals(\"start\")) {\n            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();\n            helper.queue = queue;\n            helper.entry = entry;\n            helper.arguments = new ArrayList<>(entry.arguments);\n            helper.arguments.remove(0);\n            boolean success = IfCommand.tryIf(helper);\n            if (!success) {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While is false, skipping.\");\n                }\n                queue.commandStack.peek().goTo(entry.blockEnd + 1);\n                return;\n            }\n            if (queue.shouldShowGood()) {\n                queue.outGood(\"While is true, looping...\");\n            }\n        }\n        else if (type.equals(\"stop\")) {\n            CommandStackEntry cse = queue.commandStack.peek();\n            for (int i = cse.getIndex(); i < cse.entries.length; i++) {\n                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n                    if (queue.shouldShowGood()) {\n                        queue.outGood(\"Stopping a while loop.\");\n                    }\n                    cse.goTo(i + 1);\n                    return;\n                }\n            }\n            queue.handleError(entry, \"Cannot stop while: not in one!\");\n        }\n        else if (type.equals(\"next\")) {\n            CommandStackEntry cse = queue.commandStack.peek();\n            for (int i = cse.getIndex(); i < cse.entries.length; i++) {\n                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n                    if (queue.shouldShowGood()) {\n                        queue.outGood(\"Jumping forward in a while loop.\");\n                    }\n                    cse.goTo(i);\n                    return;\n                }\n            }\n            queue.handleError(entry, \"Cannot advance while: not in one!\");\n        }\n    }\n}", "class_id": 0, "repo": "aufdemrand/Denizen2Core", "file": "src/main/java/com/denizenscript/denizen2core/commands/queuecommands/WhileCommand.java", "last_update_at": "2018-11-12T08:37:17+00:00", "question_id": "7d3260ed208653d80c9045f17dc684ec11257666", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class WhileCommand extends AbstractCommand {\n    // <--[command]\n    // @Since 0.3.0\n    // @Name while\n    // @Arguments 'start'/'stop'/'next' [if comparisons]\n    // @Short runs a block of code repeatedly for so long as the comparisons return true.\n    // @Updated 2017/02/19\n    // @Group Queue\n    // @Procedural true\n    // @Minimum 1\n    // @Maximum -1\n    // @Description\n    // Runs a block of code repeatedly for so long as the comparisons return true.\n    // TODO: Explain more!\n    // @Example\n    // # This example runs forever (until it's externally stopped, or the engine shuts down)\n    // # and echoes \"hi\" every half second.\n    // - while start true:\n    //   - echo \"hi\"\n    //   - wait 0.5s\n    // -->\n    @Override\n    public String getName() {\n        return \"while\";\n    }\n    @Override\n    public String getArguments() {\n        return \"'start'/'stop'/'next' [if comparisons]\";\n    }\n    @Override\n    public int getMinimumArguments() {\n        return 1;\n    }\n    @Override\n    public int getMaximumArguments() {\n        return -1;\n    }\n    @Override\n    public boolean isProcedural() {\n        return true;\n    }\n    @Override\n    public boolean allowsBlock() {\n        return true;\n    }\n    @Override\n    public void execute(CommandQueue queue, CommandEntry entry) {\n        if (entry.arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n            CommandEntry orig = queue.commandStack.peek().entries[entry.blockStart - 1];\n            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();\n            helper.queue = queue;\n            helper.entry = orig;\n            helper.arguments = new ArrayList<>(orig.arguments);\n            boolean success = IfCommand.tryIf(helper);\n            if (success) {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While continuing...\");\n                }\n                queue.commandStack.peek().goTo(entry.blockStart);\n            }\n            else {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While completed!\");\n                }\n            }\n            return;\n        }\n        String type = entry.getArgumentObject(queue, 0).toString();\n        if (type.equals(\"start\")) {\n            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();\n            helper.queue = queue;\n            helper.entry = entry;\n            helper.arguments = new ArrayList<>(entry.arguments);\n            helper.arguments.remove(0);\n            boolean success = IfCommand.tryIf(helper);\n            if (!success) {\n                if (queue.shouldShowGood()) {\n                    queue.outGood(\"While is false, skipping.\");\n                }\n                queue.commandStack.peek().goTo(entry.blockEnd + 1);\n                return;\n            }\n            if (queue.shouldShowGood()) {\n                queue.outGood(\"While is true, looping...\");\n            }\n        }\n        else if (type.equals(\"stop\")) {\n            CommandStackEntry cse = queue.commandStack.peek();\n            for (int i = cse.getIndex(); i < cse.entries.length; i++) {\n                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n                    if (queue.shouldShowGood()) {\n                        queue.outGood(\"Stopping a while loop.\");\n                    }\n                    cse.goTo(i + 1);\n                    return;\n                }\n            }\n            queue.handleError(entry, \"Cannot stop while: not in one!\");\n        }\n        else if (type.equals(\"next\")) {\n            CommandStackEntry cse = queue.commandStack.peek();\n            for (int i = cse.getIndex(); i < cse.entries.length; i++) {\n                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals(\"\\0CALLBACK\")) {\n                    if (queue.shouldShowGood()) {\n                        queue.outGood(\"Jumping forward in a while loop.\");\n                    }\n                    cse.goTo(i);\n                    return;\n                }\n            }\n            queue.handleError(entry, \"Cannot advance while: not in one!\");\n        }\n    }\n"]], "pred": {"ppl": 1.6910395622253418, "ppl_lower": 1.9298744201660156, "ppl/lowercase_ppl": -1.2514763708497747, "ppl/zlib": 0.0004942083399811077, "Min_5.0% Prob": 5.610771941203697, "Min_10.0% Prob": 4.025614265133353, "Min_20.0% Prob": 2.486133575585543, "Min_30.0% Prob": 1.7344095671147692, "Min_40.0% Prob": 1.309237204993048, "Min_50.0% Prob": 1.0506008677193694, "Min_60.0% Prob": 0.8764328822785256}}
{"hexsha": "f146e4e2f17a0639275f5c81007d7a73c2cfa651", "ext": "java", "lang": "Java", "content": "public class Scope {\r\n    private final ConcurrentHashMap<String, Symbol> locallyDefined = new ConcurrentHashMap<>();\r\n    private Scope parentScope;\r\n    \r\n    public Optional<Scope> getParentScope() { return Optional.ofNullable(parentScope); }\r\n    \r\n    public Scope createNewChildScope() {\r\n        Scope child = new Scope();\r\n        child.parentScope = this;\r\n        return child;\r\n    }\r\n    \r\n    public Optional<Symbol> getForName(String name) {\r\n        return Optional.ofNullable(locallyDefined.getOrDefault(name,\r\n                getParentScope().map(scope -> scope.getForName(name).orElse(Symbol.getForName(name))).orElse(null)));\r\n    }\r\n    \r\n    public java.util.Set<String> getAllSymbolNames() {\r\n        return Collections.unmodifiableSet(locallyDefined.keySet());\r\n    }\r\n    \r\n    public java.util.Set<Symbol> getAllSymbols() {\r\n        return new HashSet<>(locallyDefined.values());\r\n    }\r\n    \r\n    public Symbol getOrCreate(String name, String representation) {\r\n        return locallyDefined.getOrDefault(name, new Symbol(name, representation, this));\r\n    }\r\n    \r\n    public Optional<Symbol> unbind(String name) {\r\n        return Optional.ofNullable(locallyDefined.remove(name));\r\n    }\r\n    \r\n    public void rebind(Symbol binding) {\r\n        Symbol previous = locallyDefined.put(binding.getName(), binding);\r\n        if (previous == null) {\r\n            Logger.getLogger(Scope.class.getName()).log(Level.WARNING,\r\n                    \"Symbol {} was rebound, but had no previous binding\", binding.getName());\r\n        } else {\r\n            if (!previous.getRepresentation().equals(binding.getRepresentation())) {\r\n                Logger.getLogger(Scope.class.getName()).log(Level.SEVERE,\r\n                        \"Symbol {} rebound with new representation; old = {}, current = {}\",\r\n                        new Object[] { binding.getName(), previous.getRepresentation(), binding.getRepresentation() });\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cacheValue(String name, Numeric value) {\r\n        checkIfAlreadyCached(name);\r\n        Symbol symbol = new Symbol(name, name, this);\r\n        symbol.setConcreteValue(value);\r\n        locallyDefined.put(name, symbol);\r\n    }\r\n\r\n    private void checkIfAlreadyCached(String name) throws IllegalStateException {\r\n        if (locallyDefined.containsKey(name)) {\r\n            throw new IllegalStateException(\"Cache already contains entry for \"\r\n                    + name + \" with value \" + locallyDefined.get(name).getConcreteValue());\r\n        }\r\n    }\r\n    \r\n    public void cacheValue(String name, String representation, Numeric value) {\r\n        checkIfAlreadyCached(name);\r\n        Symbol symbol = new Symbol(name, representation, value, this);\r\n        locallyDefined.put(name, symbol);\r\n    }\r\n    \r\n    /**\r\n     * Cache a {@link Symbol} explicitly. If the symbol has already been\r\n     * associated with a different scope, the operation will fail without\r\n     * throwing an exception.\r\n     * \r\n     * @param symbol the symbol to cache\r\n     * @return true if successful, false otherwise\r\n     */\r\n    public boolean cacheSymbol(Symbol symbol) {\r\n        checkIfAlreadyCached(symbol.getName());\r\n        if (!symbol.getScope().isPresent()) {\r\n            symbol.updateScope(this);\r\n            locallyDefined.put(symbol.getName(), symbol);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    public Optional<? extends Numeric> updateValue(Symbol symbol, Numeric newValue) {\r\n        final String name = symbol.getName();\r\n        if (!locallyDefined.containsKey(name)) {\r\n            Logger.getLogger(Scope.class.getName()).log(Level.INFO,\r\n                    \"Symbol {} is being redefined in this scope from an ancestor scope.\", name);\r\n            if (Symbol.getForName(name) != null &&\r\n                    Symbol.getForName(name).getValueClass()\r\n                            .map(clazz -> clazz.isAnnotationPresent(Constant.class)).orElse(false)) {\r\n                throw new IllegalArgumentException(\"Cannot redefine a constant value in any scope.\");\r\n            }\r\n        }\r\n        \r\n        Symbol old = locallyDefined.getOrDefault(name,\r\n                getParentScope().flatMap((scope) -> scope.getForName(name)).orElse(symbol));\r\n        final Optional<? extends Numeric> oldValue = old.getConcreteValue();\r\n        oldValue.ifPresent(value -> {\r\n            if (value.equals(newValue)) {\r\n                Logger.getLogger(Scope.class.getName()).log(Level.INFO,\r\n                        \"Symbol {} is being updated in this scope, but the value {} appears to be unchanged.\",\r\n                        new Object[] { name, value });\r\n            }\r\n        });\r\n        symbol.setConcreteValue(newValue);\r\n        locallyDefined.put(name, symbol);\r\n        return oldValue;\r\n    }\r\n    \r\n    /**\r\n     * Update the concrete value bound to a symbol. This method returns\r\n     * the previously bound value.  Note that if the symbol was bound in a\r\n     * parent {@link Scope}, this operation will rebind the symbol in the\r\n     * current {@link Scope}, thus masking the binding in the parent scope.\r\n     * \r\n     * @param name the unique name of the symbol to be rebound\r\n     * @param newValue the new value to bind to the named symbol\r\n     * @return the previously bound value of the named symbol\r\n     */\r\n    public Optional<? extends Numeric> updateValue(String name, Numeric newValue) {\r\n        Optional<Symbol> old = getForName(name);\r\n        if (old.isPresent()) {\r\n            Symbol fresh = locallyDefined.containsKey(name) ? old.get() : new Symbol(name, old.get().getRepresentation(), this);\r\n            Optional<? extends Numeric> oldValue = old.get().getConcreteValue();\r\n            fresh.setConcreteValue(newValue);\r\n            locallyDefined.put(name, fresh);\r\n            return oldValue;\r\n        } else {\r\n            throw new IllegalArgumentException(\"Symbol \" + name + \" does not exist!\");\r\n        }\r\n    }\r\n}", "class_id": 0, "repo": "lionmage/tower-of-types", "file": "src/tungsten/types/Scope.java", "last_update_at": "2018-03-25T19:21:22+00:00", "question_id": "f146e4e2f17a0639275f5c81007d7a73c2cfa651", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class Scope {\r\n    private final ConcurrentHashMap<String, Symbol> locallyDefined = new ConcurrentHashMap<>();\r\n    private Scope parentScope;\r\n    \r\n    public Optional<Scope> getParentScope() { return Optional.ofNullable(parentScope); }\r\n    \r\n    public Scope createNewChildScope() {\r\n        Scope child = new Scope();\r\n        child.parentScope = this;\r\n        return child;\r\n    }\r\n    \r\n    public Optional<Symbol> getForName(String name) {\r\n        return Optional.ofNullable(locallyDefined.getOrDefault(name,\r\n                getParentScope().map(scope -> scope.getForName(name).orElse(Symbol.getForName(name))).orElse(null)));\r\n    }\r\n    \r\n    public java.util.Set<String> getAllSymbolNames() {\r\n        return Collections.unmodifiableSet(locallyDefined.keySet());\r\n    }\r\n    \r\n    public java.util.Set<Symbol> getAllSymbols() {\r\n        return new HashSet<>(locallyDefined.values());\r\n    }\r\n    \r\n    public Symbol getOrCreate(String name, String representation) {\r\n        return locallyDefined.getOrDefault(name, new Symbol(name, representation, this));\r\n    }\r\n    \r\n    public Optional<Symbol> unbind(String name) {\r\n        return Optional.ofNullable(locallyDefined.remove(name));\r\n    }\r\n    \r\n    public void rebind(Symbol binding) {\r\n        Symbol previous = locallyDefined.put(binding.getName(), binding);\r\n        if (previous == null) {\r\n            Logger.getLogger(Scope.class.getName()).log(Level.WARNING,\r\n                    \"Symbol {} was rebound, but had no previous binding\", binding.getName());\r\n        } else {\r\n            if (!previous.getRepresentation().equals(binding.getRepresentation())) {\r\n                Logger.getLogger(Scope.class.getName()).log(Level.SEVERE,\r\n                        \"Symbol {} rebound with new representation; old = {}, current = {}\",\r\n                        new Object[] { binding.getName(), previous.getRepresentation(), binding.getRepresentation() });\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cacheValue(String name, Numeric value) {\r\n        checkIfAlreadyCached(name);\r\n        Symbol symbol = new Symbol(name, name, this);\r\n        symbol.setConcreteValue(value);\r\n        locallyDefined.put(name, symbol);\r\n    }\r\n\r\n    private void checkIfAlreadyCached(String name) throws IllegalStateException {\r\n        if (locallyDefined.containsKey(name)) {\r\n            throw new IllegalStateException(\"Cache already contains entry for \"\r\n                    + name + \" with value \" + locallyDefined.get(name).getConcreteValue());\r\n        }\r\n    }\r\n    \r\n    public void cacheValue(String name, String representation, Numeric value) {\r\n        checkIfAlreadyCached(name);\r\n        Symbol symbol = new Symbol(name, representation, value, this);\r\n        locallyDefined.put(name, symbol);\r\n    }\r\n    \r\n    /**\r\n     * Cache a {@link Symbol} explicitly. If the symbol has already been\r\n     * associated with a different scope, the operation will fail without\r\n     * throwing an exception.\r\n     * \r\n     * @param symbol the symbol to cache\r\n     * @return true if successful, false otherwise\r\n     */\r\n    public boolean cacheSymbol(Symbol symbol) {\r\n        checkIfAlreadyCached(symbol.getName());\r\n        if (!symbol.getScope().isPresent()) {\r\n            symbol.updateScope(this);\r\n            locallyDefined.put(symbol.getName(), symbol);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    public Optional<? extends Numeric> updateValue(Symbol symbol, Numeric newValue) {\r\n        final String name = symbol.getName();\r\n        if (!locallyDefined.containsKey(name)) {\r\n            Logger.getLogger(Scope.class.getName()).log(Level.INFO,\r\n                    \"Symbol {} is being redefined in this scope from an ancestor scope.\", name);\r\n            if (Symbol.getForName(name) != null &&\r\n                    Symbol.getForName(name).getValueClass()\r\n                            .map(clazz -> clazz.isAnnotationPresent(Constant.class)).orElse(false)) {\r\n                throw new IllegalArgumentException(\"Cannot redefine a constant value in any scope.\");\r\n            }\r\n        }\r\n        \r\n        Symbol old = locallyDefined.getOrDefault(name,\r\n                getParentScope().flatMap((scope) -> scope.getForName(name)).orElse(symbol));\r\n        final Optional<? extends Numeric> oldValue = old.getConcreteValue();\r\n        oldValue.ifPresent(value -> {\r\n            if (value.equals(newValue)) {\r\n                Logger.getLogger(Scope.class.getName()).log(Level.INFO,\r\n                        \"Symbol {} is being updated in this scope, but the value {} appears to be unchanged.\",\r\n                        new Object[] { name, value });\r\n            }\r\n        });\r\n        symbol.setConcreteValue(newValue);\r\n        locallyDefined.put(name, symbol);\r\n        return oldValue;\r\n    }\r\n    \r\n    /**\r\n     * Update the concrete value bound to a symbol. This method returns\r\n     * the previously bound value.  Note that if the symbol was bound in a\r\n     * parent {@link Scope}, this operation will rebind the symbol in the\r\n     * current {@link Scope}, thus masking the binding in the parent scope.\r\n     * \r\n     * @param name the unique name of the symbol to be rebound\r\n     * @param newValue the new value to bind to the named symbol\r\n     * @return the previously bound value of the named symbol\r\n     */\r\n    public Optional<? extends Numeric> updateValue(String name, Numeric newValue) {\r\n        Optional<Symbol> old = getForName(name);\r\n        if (old.isPresent()) {\r\n            Symbol fresh = locallyDefined.containsKey(name) ? old.get() : new Symbol(name, old.get().getRepresentation(), this);\r\n            Optional<? extends Numeric> oldValue = old.get().getConcreteValue();\r\n            fresh.setConcreteValue(newValue);\r\n            locallyDefined.put(name, fresh);\r\n            return oldValue;\r\n        } else {\r\n            throw new IllegalArgumentException(\"Symbol \" + name + \" does not exist!\");\r\n        }\r\n    }\r\n"]], "pred": {"ppl": 1.8764958381652832, "ppl_lower": 2.1235482692718506, "ppl/lowercase_ppl": -1.196506318451762, "ppl/zlib": 0.0003921533468657903, "Min_5.0% Prob": 6.083508921604531, "Min_10.0% Prob": 4.476325402072832, "Min_20.0% Prob": 2.8563213433120764, "Min_30.0% Prob": 2.0397729325333454, "Min_40.0% Prob": 1.5591912457040877, "Min_50.0% Prob": 1.2562228296455105, "Min_60.0% Prob": 1.0494458360580778}}
{"hexsha": "ab7aedff7c7beb20850e83a0cf43078b04a017fd", "ext": "java", "lang": "Java", "content": "public final class ImmutableMapNonSingletonArrayTest extends ImmutableMapTestCase3<ImmutableMapNonSingletonArray<String, Integer>> {\n\n    @Test\n    public void testNotCopied() {\n        @SuppressWarnings(\"unchecked\")\n        final Entry<String, Integer>[] array = new Entry[2];\n        array[0] = Maps.entry(KEY1, VALUE1);\n        array[1] = Maps.entry(KEY2, VALUE2);\n        final ImmutableMapNonSingletonArray<String, Integer> immutable = ImmutableMapNonSingletonArray.with(array);\n\n        array[1] = Maps.entry(KEY2, 666);\n\n        this.getAndCheck(immutable, KEY1, VALUE1);\n        this.getAndCheck(immutable, KEY2, 666);\n        this.sizeAndCheck(immutable, 2);\n    }\n\n    @Test\n    public void testGetNullValue() {\n        final ImmutableMapNonSingletonArray<String, Integer> map = this.createMap(KEY1, null, KEY2, VALUE2);\n        this.getAndCheck(map, KEY1, null);\n        this.getAndCheck(map, KEY2, VALUE2);\n    }\n\n    @Override\n    ImmutableMapNonSingletonArray<String, Integer> createMap(final String key0,\n                                                             final Integer value0,\n                                                             final String key1,\n                                                             final Integer value1) {\n        //noinspection unchecked\n        return ImmutableMapNonSingletonArray.with(Maps.entry(key0, value0), Maps.entry(key1, value1));\n    }\n\n    @Override\n    public Class<ImmutableMapNonSingletonArray<String, Integer>> type() {\n        return Cast.to(ImmutableMapNonSingletonArray.class);\n    }\n}", "class_id": 0, "repo": "mP1/walkingkooka", "file": "src/test/java/walkingkooka/collect/map/ImmutableMapNonSingletonArrayTest.java", "last_update_at": "2018-08-05T00:29:44+00:00", "question_id": "ab7aedff7c7beb20850e83a0cf43078b04a017fd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public final class ImmutableMapNonSingletonArrayTest extends ImmutableMapTestCase3<ImmutableMapNonSingletonArray<String, Integer>> {\n    @Test\n    public void testNotCopied() {\n        @SuppressWarnings(\"unchecked\")\n        final Entry<String, Integer>[] array = new Entry[2];\n        array[0] = Maps.entry(KEY1, VALUE1);\n        array[1] = Maps.entry(KEY2, VALUE2);\n        final ImmutableMapNonSingletonArray<String, Integer> immutable = ImmutableMapNonSingletonArray.with(array);\n        array[1] = Maps.entry(KEY2, 666);\n        this.getAndCheck(immutable, KEY1, VALUE1);\n        this.getAndCheck(immutable, KEY2, 666);\n        this.sizeAndCheck(immutable, 2);\n    }\n    @Test\n    public void testGetNullValue() {\n        final ImmutableMapNonSingletonArray<String, Integer> map = this.createMap(KEY1, null, KEY2, VALUE2);\n        this.getAndCheck(map, KEY1, null);\n        this.getAndCheck(map, KEY2, VALUE2);\n    }\n    @Override\n    ImmutableMapNonSingletonArray<String, Integer> createMap(final String key0,\n                                                             final Integer value0,\n                                                             final String key1,\n                                                             final Integer value1) {\n        //noinspection unchecked\n        return ImmutableMapNonSingletonArray.with(Maps.entry(key0, value0), Maps.entry(key1, value1));\n    }\n    @Override\n    public Class<ImmutableMapNonSingletonArray<String, Integer>> type() {\n        return Cast.to(ImmutableMapNonSingletonArray.class);\n    }\n"]], "pred": {"ppl": 1.598862648010254, "ppl_lower": 2.0250244140625, "ppl/lowercase_ppl": -1.5035009284821257, "ppl/zlib": 0.0010475279720581424, "Min_5.0% Prob": 5.2953689965334805, "Min_10.0% Prob": 3.6702702787187365, "Min_20.0% Prob": 2.2249680784013535, "Min_30.0% Prob": 1.5480320297457553, "Min_40.0% Prob": 1.1733217046389148, "Min_50.0% Prob": 0.9373186233358672, "Min_60.0% Prob": 0.7824114810888453}}
{"hexsha": "6c693e907d19ddb7b0ecb080ebaa06b3a8584965", "ext": "java", "lang": "Java", "content": "public class LoadingUtils {\n\n    private LoadingUtils() {\n        // This class is not publicly instantiate\n\n    }\n\n    public static ProgressDialog showLoadingDialog(Context context) {\n        ProgressDialog progressDialog = new ProgressDialog(context);\n        progressDialog.show();\n        if (progressDialog.getWindow() != null) {\n            progressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));\n        }\n        progressDialog.setContentView(R.layout.util_progress_dialog);\n        progressDialog.setIndeterminate(true);\n        progressDialog.setCancelable(false);\n        progressDialog.setCanceledOnTouchOutside(false);\n        return progressDialog;\n    }\n}", "class_id": 0, "repo": "divisi-mobile-POROS/SigmaDialog", "file": "sigmadialog/src/main/java/com/arsldev/lutluthfi/sigmadialog/utils/LoadingUtils.java", "last_update_at": "2018-09-05T14:49:58+00:00", "question_id": "6c693e907d19ddb7b0ecb080ebaa06b3a8584965", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LoadingUtils {\n    private LoadingUtils() {\n        // This class is not publicly instantiate\n    }\n    public static ProgressDialog showLoadingDialog(Context context) {\n        ProgressDialog progressDialog = new ProgressDialog(context);\n        progressDialog.show();\n        if (progressDialog.getWindow() != null) {\n            progressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));\n        }\n        progressDialog.setContentView(R.layout.util_progress_dialog);\n        progressDialog.setIndeterminate(true);\n        progressDialog.setCancelable(false);\n        progressDialog.setCanceledOnTouchOutside(false);\n        return progressDialog;\n    }\n"]], "pred": {"ppl": 1.603582739830017, "ppl_lower": 2.2690913677215576, "ppl/lowercase_ppl": -1.7350899664872537, "ppl/zlib": 0.0015637097296015703, "Min_5.0% Prob": 6.8912353515625, "Min_10.0% Prob": 4.053780177060296, "Min_20.0% Prob": 2.294884378419203, "Min_30.0% Prob": 1.5797170019325089, "Min_40.0% Prob": 1.180148631280315, "Min_50.0% Prob": 0.9492818339522061, "Min_60.0% Prob": 0.7930438248282389}}
{"hexsha": "8eecef3ed30cb86d899fb4cd0a625ecb71e591ea", "ext": "java", "lang": "Java", "content": "public class EjercicioInstanciaDTO{\r\n    //--------------------------------------------\r\n    // DATOS BASE\r\n    //--------------------------------------------\r\n    private Double efectividad;\r\n    private Double cumplimiento;\r\n    private Integer duracion;\r\n    private Long id;\r\n    private Integer series;\r\n    private Integer tamanioParticiones;\r\n    private Integer repeticionesPorParticion;\r\n    \r\n    \r\n    //--------------------------------------------\r\n    // CONSTRUCTOR & TOENTITY\r\n    //--------------------------------------------\r\n    public EjercicioInstanciaDTO() {\r\n        //javax\r\n    }\r\n    \r\n    public EjercicioInstanciaDTO(EjercicioInstanciaEntity entity){\r\n        this.id=entity.getId();\r\n        efectividad=entity.getEfectividad();\r\n        cumplimiento=entity.getCumplimiento();\r\n        duracion=entity.getDuracion();\r\n        series=entity.getSeries();\r\n        tamanioParticiones=entity.getTamanioParticiones();\r\n        repeticionesPorParticion=entity.getRepeticionesPorParticion();\r\n    }\r\n    \r\n    public EjercicioInstanciaEntity toEntity(){\r\n        EjercicioInstanciaEntity ent=new EjercicioInstanciaEntity();\r\n        ent.setDuracion(duracion);\r\n        ent.setRepeticionesPorParticion(repeticionesPorParticion);\r\n        ent.setSeries(series);\r\n        ent.setTamanioParticiones(tamanioParticiones);\r\n        ent.setCumplimiento(0.0);\r\n        ent.setEfectividad(0.0);\r\n        return ent;\r\n    }\r\n    //--------------------------------------------\r\n    // GETS & SETS\r\n    //--------------------------------------------\r\n\r\n    public Double getEfectividad() {\r\n        return efectividad;\r\n    }\r\n\r\n    public void setEfectividad(Double efectividad) {\r\n        this.efectividad = efectividad;\r\n    }\r\n\r\n    public Double getCumplimiento() {\r\n        return cumplimiento;\r\n    }\r\n\r\n    public void setCumplimiento(Double cumplimiento) {\r\n        this.cumplimiento = cumplimiento;\r\n    }\r\n\r\n    public Integer getDuracion() {\r\n        return duracion;\r\n    }\r\n\r\n    public void setDuracion(Integer duracion) {\r\n        this.duracion = duracion;\r\n    }\r\n\r\n    public Long getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Long id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public Integer getSeries() {\r\n        return series;\r\n    }\r\n\r\n    public void setSeries(Integer series) {\r\n        this.series = series;\r\n    }\r\n\r\n    public Integer getTamanioParticiones() {\r\n        return tamanioParticiones;\r\n    }\r\n\r\n    public void setTamanioParticiones(Integer tamanioParticiones) {\r\n        this.tamanioParticiones = tamanioParticiones;\r\n    }\r\n\r\n    public Integer getRepeticionesPorParticion() {\r\n        return repeticionesPorParticion;\r\n    }\r\n\r\n    public void setRepeticionesPorParticion(Integer repeticionesPorParticion) {\r\n        this.repeticionesPorParticion = repeticionesPorParticion;\r\n    }\r\n}", "class_id": 0, "repo": "Uniandes-isis2603/s3_gimnasio", "file": "gimnasio-web/src/main/java/co/edu/uniandes/baco/gimnasio/dtos/EjercicioInstanciaDTO.java", "last_update_at": "2018-08-06T16:07:42+00:00", "question_id": "8eecef3ed30cb86d899fb4cd0a625ecb71e591ea", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class EjercicioInstanciaDTO{\r\n    //--------------------------------------------\r\n    // DATOS BASE\r\n    //--------------------------------------------\r\n    private Double efectividad;\r\n    private Double cumplimiento;\r\n    private Integer duracion;\r\n    private Long id;\r\n    private Integer series;\r\n    private Integer tamanioParticiones;\r\n    private Integer repeticionesPorParticion;\r\n    \r\n    \r\n    //--------------------------------------------\r\n    // CONSTRUCTOR & TOENTITY\r\n    //--------------------------------------------\r\n    public EjercicioInstanciaDTO() {\r\n        //javax\r\n    }\r\n    \r\n    public EjercicioInstanciaDTO(EjercicioInstanciaEntity entity){\r\n        this.id=entity.getId();\r\n        efectividad=entity.getEfectividad();\r\n        cumplimiento=entity.getCumplimiento();\r\n        duracion=entity.getDuracion();\r\n        series=entity.getSeries();\r\n        tamanioParticiones=entity.getTamanioParticiones();\r\n        repeticionesPorParticion=entity.getRepeticionesPorParticion();\r\n    }\r\n    \r\n    public EjercicioInstanciaEntity toEntity(){\r\n        EjercicioInstanciaEntity ent=new EjercicioInstanciaEntity();\r\n        ent.setDuracion(duracion);\r\n        ent.setRepeticionesPorParticion(repeticionesPorParticion);\r\n        ent.setSeries(series);\r\n        ent.setTamanioParticiones(tamanioParticiones);\r\n        ent.setCumplimiento(0.0);\r\n        ent.setEfectividad(0.0);\r\n        return ent;\r\n    }\r\n    //--------------------------------------------\r\n    // GETS & SETS\r\n    //--------------------------------------------\r\n\r\n    public Double getEfectividad() {\r\n        return efectividad;\r\n    }\r\n\r\n    public void setEfectividad(Double efectividad) {\r\n        this.efectividad = efectividad;\r\n    }\r\n\r\n    public Double getCumplimiento() {\r\n        return cumplimiento;\r\n    }\r\n\r\n    public void setCumplimiento(Double cumplimiento) {\r\n        this.cumplimiento = cumplimiento;\r\n    }\r\n\r\n    public Integer getDuracion() {\r\n        return duracion;\r\n    }\r\n\r\n    public void setDuracion(Integer duracion) {\r\n        this.duracion = duracion;\r\n    }\r\n\r\n    public Long getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Long id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public Integer getSeries() {\r\n        return series;\r\n    }\r\n\r\n    public void setSeries(Integer series) {\r\n        this.series = series;\r\n    }\r\n\r\n    public Integer getTamanioParticiones() {\r\n        return tamanioParticiones;\r\n    }\r\n\r\n    public void setTamanioParticiones(Integer tamanioParticiones) {\r\n        this.tamanioParticiones = tamanioParticiones;\r\n    }\r\n\r\n    public Integer getRepeticionesPorParticion() {\r\n        return repeticionesPorParticion;\r\n    }\r\n\r\n    public void setRepeticionesPorParticion(Integer repeticionesPorParticion) {\r\n        this.repeticionesPorParticion = repeticionesPorParticion;\r\n    }\r\n"]], "pred": {"ppl": 1.3821544647216797, "ppl_lower": 1.5013450384140015, "ppl/lowercase_ppl": -1.2555834230272434, "ppl/zlib": 0.0005748552186030386, "Min_5.0% Prob": 5.468258416652679, "Min_10.0% Prob": 3.142770081758499, "Min_20.0% Prob": 1.6117780119569207, "Min_30.0% Prob": 1.0800494384707608, "Min_40.0% Prob": 0.8089154930385344, "Min_50.0% Prob": 0.6480241172909234, "Min_60.0% Prob": 0.5393864197478199}}
{"hexsha": "77b83560aa4d4120003c17ff5690b46b85cae23c", "ext": "java", "lang": "Java", "content": "@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)\npublic class InputDeviceState {\n\t// DEVICE_ID_PAD_0 from the cpp code. TODO: allocate these sequentially if we get more controllers.\n\tprivate static int deviceId = 10;\n\t\n\tprivate InputDevice mDevice;\n\tprivate int[] mAxes;\n\t\t\n\tInputDevice getDevice() { return mDevice; }\n\t\n\tpublic InputDeviceState(InputDevice device) {\n\t     mDevice = device;\n\t     int numAxes = 0;\n\t     for (MotionRange range : device.getMotionRanges()) {\n\t          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {\n\t               numAxes += 1;\n\t          }\n\t     }\n\n\t     mAxes\t\t= new int[numAxes];\n\n\t     int i = 0;\n\t     for (MotionRange range : device.getMotionRanges()) {\n\t          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {\n\t               mAxes[i++] = range.getAxis();\n\t          }\n\t     }\n\t}\n\t\n\tpublic static float ProcessAxis(InputDevice.MotionRange range, float axisvalue) {\n\t\tfloat absaxisvalue = Math.abs(axisvalue);\n\t\tfloat deadzone = range.getFlat();\n\t\tif (absaxisvalue <= deadzone) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tfloat normalizedvalue;\n\t\tif (axisvalue < 0.0f) {\n\t\t\tnormalizedvalue = absaxisvalue / range.getMin();\n\t\t} else {\n\t\t\tnormalizedvalue = absaxisvalue / range.getMax();\n\t\t}\n\n\t\treturn normalizedvalue;\n\t}\n\t\n\tprivate static boolean isGameKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn KeyEvent.isGamepadButton(keyCode);\n\t\t}\n\t}\n\t\n\tpublic boolean onKeyDown(KeyEvent event) {\n\t\tint keyCode = event.getKeyCode();\n\t\tif (event.getRepeatCount() == 0) {\n\t\t\tif (isGameKey(keyCode)) {\n\t\t\t\tNativeApp.keyDown(deviceId, keyCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean onKeyUp(KeyEvent event) {\n\t     int keyCode = event.getKeyCode();\n\t     if (isGameKey(keyCode)) {\n\t    \t NativeApp.keyUp(deviceId, keyCode);\n\t         return true;\n\t     }\n\t     return false;\n\t}\n\t\n\tpublic boolean onJoystickMotion(MotionEvent event) {\n\t\tif ((event.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tNativeApp.beginJoystickEvent();\n\t\tfor (int i = 0; i < mAxes.length; i++) {\n\t\t\tint axisId = mAxes[i];\n\t\t\tfloat value = event.getAxisValue(axisId);\n\t\t\t// TODO: Use processAxis or move that to the C++ code\n\t\t\tNativeApp.joystickAxis(deviceId, axisId, value);\n\t\t}\n\t\tNativeApp.endJoystickEvent();\n\n\t\treturn true;\n\t}\n}", "class_id": 0, "repo": "Ced2911/native", "file": "android/src/com/henrikrydgard/libnative/InputDeviceState.java", "last_update_at": "2018-05-02T19:01:30+00:00", "question_id": "77b83560aa4d4120003c17ff5690b46b85cae23c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)\npublic class InputDeviceState {\n\t// DEVICE_ID_PAD_0 from the cpp code. TODO: allocate these sequentially if we get more controllers.\n\tprivate static int deviceId = 10;\n\t\n\tprivate InputDevice mDevice;\n\tprivate int[] mAxes;\n\t\t\n\tInputDevice getDevice() { return mDevice; }\n\t\n\tpublic InputDeviceState(InputDevice device) {\n\t     mDevice = device;\n\t     int numAxes = 0;\n\t     for (MotionRange range : device.getMotionRanges()) {\n\t          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {\n\t               numAxes += 1;\n\t          }\n\t     }\n\t     mAxes\t\t= new int[numAxes];\n\t     int i = 0;\n\t     for (MotionRange range : device.getMotionRanges()) {\n\t          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {\n\t               mAxes[i++] = range.getAxis();\n\t          }\n\t     }\n\t}\n\t\n\tpublic static float ProcessAxis(InputDevice.MotionRange range, float axisvalue) {\n\t\tfloat absaxisvalue = Math.abs(axisvalue);\n\t\tfloat deadzone = range.getFlat();\n\t\tif (absaxisvalue <= deadzone) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tfloat normalizedvalue;\n\t\tif (axisvalue < 0.0f) {\n\t\t\tnormalizedvalue = absaxisvalue / range.getMin();\n\t\t} else {\n\t\t\tnormalizedvalue = absaxisvalue / range.getMax();\n\t\t}\n\t\treturn normalizedvalue;\n\t}\n\t\n\tprivate static boolean isGameKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn KeyEvent.isGamepadButton(keyCode);\n\t\t}\n\t}\n\t\n\tpublic boolean onKeyDown(KeyEvent event) {\n\t\tint keyCode = event.getKeyCode();\n\t\tif (event.getRepeatCount() == 0) {\n\t\t\tif (isGameKey(keyCode)) {\n\t\t\t\tNativeApp.keyDown(deviceId, keyCode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean onKeyUp(KeyEvent event) {\n\t     int keyCode = event.getKeyCode();\n\t     if (isGameKey(keyCode)) {\n\t    \t NativeApp.keyUp(deviceId, keyCode);\n\t         return true;\n\t     }\n\t     return false;\n\t}\n\t\n\tpublic boolean onJoystickMotion(MotionEvent event) {\n\t\tif ((event.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tNativeApp.beginJoystickEvent();\n\t\tfor (int i = 0; i < mAxes.length; i++) {\n\t\t\tint axisId = mAxes[i];\n\t\t\tfloat value = event.getAxisValue(axisId);\n\t\t\t// TODO: Use processAxis or move that to the C++ code\n\t\t\tNativeApp.joystickAxis(deviceId, axisId, value);\n\t\t}\n\t\tNativeApp.endJoystickEvent();\n\t\treturn true;\n\t}\n"]], "pred": {"ppl": 1.6999350786209106, "ppl_lower": 1.9706296920776367, "ppl/lowercase_ppl": -1.2784881998723705, "ppl/zlib": 0.0005961686081869966, "Min_5.0% Prob": 5.587103034059207, "Min_10.0% Prob": 3.982484593987465, "Min_20.0% Prob": 2.4861664292402565, "Min_30.0% Prob": 1.736856600140325, "Min_40.0% Prob": 1.3176566573480766, "Min_50.0% Prob": 1.0586111539509147, "Min_60.0% Prob": 0.8840960319810418}}
{"hexsha": "befbfddbe0438b302a118c5a78782f73798f15c0", "ext": "java", "lang": "Java", "content": "public class TestDatasetConfigManager {\n\n  private Long datasetConfigId1;\n  private Long datasetConfigId2;\n  private static String collection1 = \"my dataset1\";\n  private static String collection2 = \"my dataset2\";\n\n  private DAOTestBase testDAOProvider;\n  private DatasetConfigManager datasetConfigDAO;\n  @BeforeClass\n  void beforeClass() {\n    testDAOProvider = DAOTestBase.getInstance();\n    DAORegistry daoRegistry = DAORegistry.getInstance();\n    datasetConfigDAO = daoRegistry.getDatasetConfigDAO();\n  }\n\n  @AfterClass(alwaysRun = true)\n  void afterClass() {\n    testDAOProvider.cleanup();\n  }\n\n  @Test\n  public void testCreate() {\n\n    DatasetConfigDTO datasetConfig1 = DaoTestUtils.getTestDatasetConfig(collection1);\n    datasetConfig1.setRequiresCompletenessCheck(true);\n    datasetConfigId1 = datasetConfigDAO.save(datasetConfig1);\n    Assert.assertNotNull(datasetConfigId1);\n\n    DatasetConfigDTO datasetConfig2 = DaoTestUtils.getTestDatasetConfig(collection2);\n    datasetConfig2.setActive(false);\n    datasetConfig2.setRequiresCompletenessCheck(true);\n    datasetConfigId2 = datasetConfigDAO.save(datasetConfig2);\n    Assert.assertNotNull(datasetConfigId2);\n\n    List<DatasetConfigDTO> datasetConfigs = datasetConfigDAO.findAll();\n    Assert.assertEquals(datasetConfigs.size(), 2);\n\n    datasetConfigs = datasetConfigDAO.findActive();\n    Assert.assertEquals(datasetConfigs.size(), 1);\n  }\n\n  @Test(dependsOnMethods = {\"testCreate\"})\n  public void testFindByDataset() {\n    DatasetConfigDTO datasetConfigs = datasetConfigDAO.findByDataset(collection1);\n    Assert.assertEquals(datasetConfigs.getDataset(), collection1);\n  }\n\n  @Test(dependsOnMethods = { \"testFindByDataset\" })\n  public void testUpdate() {\n    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId1);\n    Assert.assertNotNull(datasetConfig);\n    Assert.assertFalse(datasetConfig.isRealtime());\n    datasetConfig.setRealtime(true);\n    datasetConfigDAO.update(datasetConfig);\n    datasetConfig = datasetConfigDAO.findById(datasetConfigId1);\n    Assert.assertNotNull(datasetConfig);\n    Assert.assertTrue(datasetConfig.isRealtime());\n  }\n\n  @Test(dependsOnMethods = { \"testUpdate\" })\n  public void testDelete() {\n    datasetConfigDAO.deleteById(datasetConfigId2);\n    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId2);\n    Assert.assertNull(datasetConfig);\n  }\n\n  @Test(dependsOnMethods = {\"testCreate\"})\n  public void testActiveRequiresCompletenessCheck() {\n    Assert.assertEquals(datasetConfigDAO.findActiveRequiresCompletenessCheck().size(), 1);\n  }\n}", "class_id": 0, "repo": "kupl/starlab-benchmarks", "file": "Benchmarks_with_Functional_Bugs/Java/Bears-169/src/thirdeye/thirdeye-pinot/src/test/java/com/linkedin/thirdeye/datalayer/bao/TestDatasetConfigManager.java", "last_update_at": "2018-05-18T22:16:27+00:00", "question_id": "befbfddbe0438b302a118c5a78782f73798f15c0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestDatasetConfigManager {\n  private Long datasetConfigId1;\n  private Long datasetConfigId2;\n  private static String collection1 = \"my dataset1\";\n  private static String collection2 = \"my dataset2\";\n  private DAOTestBase testDAOProvider;\n  private DatasetConfigManager datasetConfigDAO;\n  @BeforeClass\n  void beforeClass() {\n    testDAOProvider = DAOTestBase.getInstance();\n    DAORegistry daoRegistry = DAORegistry.getInstance();\n    datasetConfigDAO = daoRegistry.getDatasetConfigDAO();\n  }\n  @AfterClass(alwaysRun = true)\n  void afterClass() {\n    testDAOProvider.cleanup();\n  }\n  @Test\n  public void testCreate() {\n    DatasetConfigDTO datasetConfig1 = DaoTestUtils.getTestDatasetConfig(collection1);\n    datasetConfig1.setRequiresCompletenessCheck(true);\n    datasetConfigId1 = datasetConfigDAO.save(datasetConfig1);\n    Assert.assertNotNull(datasetConfigId1);\n    DatasetConfigDTO datasetConfig2 = DaoTestUtils.getTestDatasetConfig(collection2);\n    datasetConfig2.setActive(false);\n    datasetConfig2.setRequiresCompletenessCheck(true);\n    datasetConfigId2 = datasetConfigDAO.save(datasetConfig2);\n    Assert.assertNotNull(datasetConfigId2);\n    List<DatasetConfigDTO> datasetConfigs = datasetConfigDAO.findAll();\n    Assert.assertEquals(datasetConfigs.size(), 2);\n    datasetConfigs = datasetConfigDAO.findActive();\n    Assert.assertEquals(datasetConfigs.size(), 1);\n  }\n  @Test(dependsOnMethods = {\"testCreate\"})\n  public void testFindByDataset() {\n    DatasetConfigDTO datasetConfigs = datasetConfigDAO.findByDataset(collection1);\n    Assert.assertEquals(datasetConfigs.getDataset(), collection1);\n  }\n  @Test(dependsOnMethods = { \"testFindByDataset\" })\n  public void testUpdate() {\n    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId1);\n    Assert.assertNotNull(datasetConfig);\n    Assert.assertFalse(datasetConfig.isRealtime());\n    datasetConfig.setRealtime(true);\n    datasetConfigDAO.update(datasetConfig);\n    datasetConfig = datasetConfigDAO.findById(datasetConfigId1);\n    Assert.assertNotNull(datasetConfig);\n    Assert.assertTrue(datasetConfig.isRealtime());\n  }\n  @Test(dependsOnMethods = { \"testUpdate\" })\n  public void testDelete() {\n    datasetConfigDAO.deleteById(datasetConfigId2);\n    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId2);\n    Assert.assertNull(datasetConfig);\n  }\n  @Test(dependsOnMethods = {\"testCreate\"})\n  public void testActiveRequiresCompletenessCheck() {\n    Assert.assertEquals(datasetConfigDAO.findActiveRequiresCompletenessCheck().size(), 1);\n  }\n"]], "pred": {"ppl": 1.4775002002716064, "ppl_lower": 1.7476427555084229, "ppl/lowercase_ppl": -1.4301667386709385, "ppl/zlib": 0.0006409714381703212, "Min_5.0% Prob": 4.977836056759483, "Min_10.0% Prob": 3.1978814416117483, "Min_20.0% Prob": 1.8693585232380898, "Min_30.0% Prob": 1.2869403432303232, "Min_40.0% Prob": 0.9722703738479465, "Min_50.0% Prob": 0.7796182100371407, "Min_60.0% Prob": 0.6514310456898319}}
{"hexsha": "acca4f51ed37e37e4b238bb26a92232f8f5f937d", "ext": "java", "lang": "Java", "content": "public class SignatureCalculator {\n\n    public static String signature(List<String> input) {\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < input.size(); i++) {\n            if (i > 0) {\n                sb.append(\"|\");\n            }\n\n            sb.append(input.get(i));\n        }\n\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(sb.toString().getBytes());\n            byte[] digest = md.digest();\n            return DatatypeConverter.printHexBinary(digest).toLowerCase();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException();\n        }\n    }\n\n}", "class_id": 0, "repo": "KarolStoinski/p24client", "file": "src/main/java/pl/karolstoinski/p24client/util/SignatureCalculator.java", "last_update_at": "2018-07-16T21:29:58+00:00", "question_id": "acca4f51ed37e37e4b238bb26a92232f8f5f937d", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SignatureCalculator {\n    public static String signature(List<String> input) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < input.size(); i++) {\n            if (i > 0) {\n                sb.append(\"|\");\n            }\n            sb.append(input.get(i));\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(sb.toString().getBytes());\n            byte[] digest = md.digest();\n            return DatatypeConverter.printHexBinary(digest).toLowerCase();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException();\n        }\n    }\n"]], "pred": {"ppl": 1.6003005504608154, "ppl_lower": 2.149510145187378, "ppl/lowercase_ppl": -1.6275071942461714, "ppl/zlib": 0.0014035565840097403, "Min_5.0% Prob": 5.140012635125054, "Min_10.0% Prob": 3.427582946088579, "Min_20.0% Prob": 2.150765440530247, "Min_30.0% Prob": 1.5451915600785502, "Min_40.0% Prob": 1.1778547489601705, "Min_50.0% Prob": 0.9376889943134982, "Min_60.0% Prob": 0.7842498041578321}}
{"hexsha": "83345c1805fa18f74e369b316c42d29cce7aea48", "ext": "java", "lang": "Java", "content": "public class LaunchTests {\n\tpublic static void main(String[] args) {\n\t\tList<EARMARKTest> tests = new ArrayList<EARMARKTest>();\n\t\t\n\t\ttests.add(new DocumentCreation());\n\t\ttests.add(new DocumentStructure());\n\t\ttests.add(new ModifyingDocument(DocumentCreation.getDocument()));\n\t\ttests.add(new ModifyingDocument(DocumentStructure.getDocument()));\n\t\ttests.add(new EqualityTest(DocumentStructure.getDocument(), DocumentStructure.getDocument()\n\t\t\t\t, true, true, true));\n\t\ttests.add(new EqualityTest(DocumentCreation.getDocument(), DocumentStructure.getDocument()\n\t\t\t\t, false, false, false));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentDocumentId(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, true, true));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentIds(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, true, true));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentDocumentIdAndStructure(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, false, false));\n\t\ttests.add(new LoadTest());\n\t\ttests.add(new StoreTest(DocumentStructure.getDocument()));\n\t\ttests.add(new FrancescoPoggiTestOne(DocumentCreation.getDocument()));\n\t\t\n\t\tfor (EARMARKTest test : tests) {\n\t\t\tSystem.out.print(\"\\n*** BEGIN: \" + test.getTestName() + \" ***\\n\");\n\t\t\tfor (String result : test.doTest()) {\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t\tSystem.out.print(\"*** END: \" + test.getTestName() + \" ***\\n\");\n\t\t}\n\t}\n}", "class_id": 0, "repo": "essepuntato/EarmarkDataStructure", "file": "src/it/essepuntato/earmark/core/test/LaunchTests.java", "last_update_at": "2018-05-29T20:59:37+00:00", "question_id": "83345c1805fa18f74e369b316c42d29cce7aea48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class LaunchTests {\n\tpublic static void main(String[] args) {\n\t\tList<EARMARKTest> tests = new ArrayList<EARMARKTest>();\n\t\t\n\t\ttests.add(new DocumentCreation());\n\t\ttests.add(new DocumentStructure());\n\t\ttests.add(new ModifyingDocument(DocumentCreation.getDocument()));\n\t\ttests.add(new ModifyingDocument(DocumentStructure.getDocument()));\n\t\ttests.add(new EqualityTest(DocumentStructure.getDocument(), DocumentStructure.getDocument()\n\t\t\t\t, true, true, true));\n\t\ttests.add(new EqualityTest(DocumentCreation.getDocument(), DocumentStructure.getDocument()\n\t\t\t\t, false, false, false));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentDocumentId(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, true, true));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentIds(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, true, true));\n\t\ttests.add(new EqualityTest(\n\t\t\t\tEqualityTest.getDocumentWithDifferentDocumentIdAndStructure(), \n\t\t\t\tDocumentStructure.getDocument()\n\t\t\t\t, false, false, false));\n\t\ttests.add(new LoadTest());\n\t\ttests.add(new StoreTest(DocumentStructure.getDocument()));\n\t\ttests.add(new FrancescoPoggiTestOne(DocumentCreation.getDocument()));\n\t\t\n\t\tfor (EARMARKTest test : tests) {\n\t\t\tSystem.out.print(\"\\n*** BEGIN: \" + test.getTestName() + \" ***\\n\");\n\t\t\tfor (String result : test.doTest()) {\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t\tSystem.out.print(\"*** END: \" + test.getTestName() + \" ***\\n\");\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.9063255786895752, "ppl_lower": 2.1865057945251465, "ppl/lowercase_ppl": -1.2125416812195544, "ppl/zlib": 0.0016089217167700354, "Min_5.0% Prob": 7.188237819671631, "Min_10.0% Prob": 5.087855268927181, "Min_20.0% Prob": 3.062633869402549, "Min_30.0% Prob": 2.1188387900006536, "Min_40.0% Prob": 1.607155383820189, "Min_50.0% Prob": 1.290348076721763, "Min_60.0% Prob": 1.076642522675113}}
{"hexsha": "56a693011aa5ea0e90a6485a9b2175abb674b4ef", "ext": "java", "lang": "Java", "content": "public class MyReducer extends Reducer<Text, Text, Text, Text> {\n    private MultipleOutputs multipleOutputs;\n    private String search;\n\n    @Override\n    public void setup(Context context) {\n        multipleOutputs = new MultipleOutputs(context);\n        /* get search query from configuration */\n        Configuration conf = context.getConfiguration();\n        search = conf.get(\"search\");\n        /* reduce has no named input file! */\n    }\n\n    @Override\n    public void reduce(Text key, Iterable<Text> values, Context context) {\n        int nbrOfMatches = 0;\n        int nbrOfMisses = 0;\n\n        for (Text val : values) {\n           String[] fields = val.toString().split(\" \");\n           nbrOfMatches += Integer.parseInt(fields[0]);\n           nbrOfMisses += Integer.parseInt(fields[1]);\n        }\n        try { \n           // context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n           multipleOutputs.write(\"text\", key, new Text(nbrOfMatches+\" \"+nbrOfMisses), \"counts-\"+search);\n        } catch (Throwable e) {\n           // catch io errors from FileInputStream or readLine()\n           System.out.println(\"Error: \" + e + \" \" + e.getMessage());\n        }\n//        try { \n//           // context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n//           context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n//        } catch (Throwable e) {\n//           // catch io errors from FileInputStream or readLine()\n//           System.out.println(\"Error: \" + e + \" \" + e.getMessage());\n//        }\n    }\n\n    @Override\n    protected void cleanup(Context context) throws IOException, InterruptedException {\n        multipleOutputs.close();\n    }\n}", "class_id": 0, "repo": "twinl/website", "file": "java/search/MyReducer.java", "last_update_at": "2018-10-18T09:57:19+00:00", "question_id": "56a693011aa5ea0e90a6485a9b2175abb674b4ef", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class MyReducer extends Reducer<Text, Text, Text, Text> {\n    private MultipleOutputs multipleOutputs;\n    private String search;\n    @Override\n    public void setup(Context context) {\n        multipleOutputs = new MultipleOutputs(context);\n        /* get search query from configuration */\n        Configuration conf = context.getConfiguration();\n        search = conf.get(\"search\");\n        /* reduce has no named input file! */\n    }\n    @Override\n    public void reduce(Text key, Iterable<Text> values, Context context) {\n        int nbrOfMatches = 0;\n        int nbrOfMisses = 0;\n        for (Text val : values) {\n           String[] fields = val.toString().split(\" \");\n           nbrOfMatches += Integer.parseInt(fields[0]);\n           nbrOfMisses += Integer.parseInt(fields[1]);\n        }\n        try { \n           // context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n           multipleOutputs.write(\"text\", key, new Text(nbrOfMatches+\" \"+nbrOfMisses), \"counts-\"+search);\n        } catch (Throwable e) {\n           // catch io errors from FileInputStream or readLine()\n           System.out.println(\"Error: \" + e + \" \" + e.getMessage());\n        }\n//        try { \n//           // context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n//           context.write(key, new Text(nbrOfMatches+\" \"+nbrOfMisses));\n//        } catch (Throwable e) {\n//           // catch io errors from FileInputStream or readLine()\n//           System.out.println(\"Error: \" + e + \" \" + e.getMessage());\n//        }\n    }\n    @Override\n    protected void cleanup(Context context) throws IOException, InterruptedException {\n        multipleOutputs.close();\n    }\n"]], "pred": {"ppl": 1.9965400695800781, "ppl_lower": 2.2911014556884766, "ppl/lowercase_ppl": -1.199036507682406, "ppl/zlib": 0.0011982941373173772, "Min_5.0% Prob": 6.868288392605989, "Min_10.0% Prob": 5.057353866861222, "Min_20.0% Prob": 3.232656085110725, "Min_30.0% Prob": 2.2696643653490867, "Min_40.0% Prob": 1.717522611792283, "Min_50.0% Prob": 1.382088609047676, "Min_60.0% Prob": 1.1544975384694685}}
{"hexsha": "a7fe7cd880b3d3c55ed05396633860597a9a3b2c", "ext": "java", "lang": "Java", "content": "@SuppressWarnings(\"deprecation\")\npublic class JSONWriterTestCase {\n\n    @Test\n    public void testJSONWriter() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n\n        w.beginObject();\n\n        w.beginField(\"string\").value(\"a string\").endField();\n        w.beginField(\"number\").value(37).endField();\n        w.beginField(\"true\").value(true).endField();\n        w.beginField(\"false\").value(false).endField();\n        w.beginField(\"null\").value().endField();\n\n        w.beginField(\"object\").beginObject();\n        w.beginField(\"nested-array\").beginArray().beginArrayValue().value(1).endArrayValue().endArray().endField();\n        w.endObject().endField();\n\n        w.beginField(\"array\").beginArray();\n        w.beginArrayValue().value(\"item1\").endArrayValue();\n        w.beginArrayValue().value(\"item2\").endArrayValue();\n        w.beginArrayValue().beginObject().beginField(\"nested\").value(\"item3\").endField().endObject().endArrayValue();\n        w.endArray().endField();\n\n        w.endObject();\n\n        assertEquals(\"{\\\"string\\\":\\\"a string\\\",\" +\n                      \"\\\"number\\\":37,\" +\n                      \"\\\"true\\\":true,\" +\n                      \"\\\"false\\\":false,\" +\n                      \"\\\"null\\\":null,\" +\n                      \"\\\"object\\\":{\\\"nested-array\\\":[1]},\" +\n                      \"\\\"array\\\":[\\\"item1\\\",\\\"item2\\\",{\\\"nested\\\":\\\"item3\\\"}]}\",\n                     out.toString());\n    }\n\n    @Test\n    public void testJSONWriterEmptyObject() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginObject();\n        w.endObject();\n\n        assertEquals(\"{}\",out.toString());\n    }\n\n    @Test\n    public void testJSONWriterEmptyArray() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginArray();\n        w.endArray();\n\n        assertEquals(\"[]\",out.toString());\n    }\n\n    @Test\n    public void testJSONWriterStringOnly() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.value(\"Hello, world!\");\n\n        assertEquals(\"\\\"Hello, world!\\\"\",out.toString());\n    }\n\n    @Test\n    public void testJSONWriterNestedArrays() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginArray();\n\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n\n        w.beginArrayValue().beginArray();\n        w.beginArrayValue().value(\"hello\").endArrayValue();\n        w.beginArrayValue().value(\"world\").endArrayValue();\n        w.endArray().endArrayValue();\n\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n\n        w.beginArrayValue().beginArray();\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n        w.endArray().endArrayValue();\n\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n\n        w.endArray();\n\n        assertEquals(\"[[],[\\\"hello\\\",\\\"world\\\"],[],[[]],[]]\",out.toString());\n    }\n\n}", "class_id": 0, "repo": "amahussein/vespa", "file": "vespajlib/src/test/java/com/yahoo/text/JSONWriterTestCase.java", "last_update_at": "2018-12-30T05:42:18+00:00", "question_id": "a7fe7cd880b3d3c55ed05396633860597a9a3b2c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@SuppressWarnings(\"deprecation\")\npublic class JSONWriterTestCase {\n    @Test\n    public void testJSONWriter() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginObject();\n        w.beginField(\"string\").value(\"a string\").endField();\n        w.beginField(\"number\").value(37).endField();\n        w.beginField(\"true\").value(true).endField();\n        w.beginField(\"false\").value(false).endField();\n        w.beginField(\"null\").value().endField();\n        w.beginField(\"object\").beginObject();\n        w.beginField(\"nested-array\").beginArray().beginArrayValue().value(1).endArrayValue().endArray().endField();\n        w.endObject().endField();\n        w.beginField(\"array\").beginArray();\n        w.beginArrayValue().value(\"item1\").endArrayValue();\n        w.beginArrayValue().value(\"item2\").endArrayValue();\n        w.beginArrayValue().beginObject().beginField(\"nested\").value(\"item3\").endField().endObject().endArrayValue();\n        w.endArray().endField();\n        w.endObject();\n        assertEquals(\"{\\\"string\\\":\\\"a string\\\",\" +\n                      \"\\\"number\\\":37,\" +\n                      \"\\\"true\\\":true,\" +\n                      \"\\\"false\\\":false,\" +\n                      \"\\\"null\\\":null,\" +\n                      \"\\\"object\\\":{\\\"nested-array\\\":[1]},\" +\n                      \"\\\"array\\\":[\\\"item1\\\",\\\"item2\\\",{\\\"nested\\\":\\\"item3\\\"}]}\",\n                     out.toString());\n    }\n    @Test\n    public void testJSONWriterEmptyObject() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginObject();\n        w.endObject();\n        assertEquals(\"{}\",out.toString());\n    }\n    @Test\n    public void testJSONWriterEmptyArray() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginArray();\n        w.endArray();\n        assertEquals(\"[]\",out.toString());\n    }\n    @Test\n    public void testJSONWriterStringOnly() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.value(\"Hello, world!\");\n        assertEquals(\"\\\"Hello, world!\\\"\",out.toString());\n    }\n    @Test\n    public void testJSONWriterNestedArrays() throws IOException {\n        OutputStream out = new ByteArrayOutputStream();\n        JSONWriter w = new JSONWriter(out);\n        w.beginArray();\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n        w.beginArrayValue().beginArray();\n        w.beginArrayValue().value(\"hello\").endArrayValue();\n        w.beginArrayValue().value(\"world\").endArrayValue();\n        w.endArray().endArrayValue();\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n        w.beginArrayValue().beginArray();\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n        w.endArray().endArrayValue();\n        w.beginArrayValue().beginArray();\n        w.endArray().endArrayValue();\n        w.endArray();\n        assertEquals(\"[[],[\\\"hello\\\",\\\"world\\\"],[],[[]],[]]\",out.toString());\n    }\n"]], "pred": {"ppl": 1.3458534479141235, "ppl_lower": 1.4039047956466675, "ppl/lowercase_ppl": -1.1421721158125135, "ppl/zlib": 0.0005000477198443121, "Min_5.0% Prob": 3.8754040030545966, "Min_10.0% Prob": 2.56188414836752, "Min_20.0% Prob": 1.4349038457018988, "Min_30.0% Prob": 0.9812224460447015, "Min_40.0% Prob": 0.7404144307985859, "Min_50.0% Prob": 0.5935766060077129, "Min_60.0% Prob": 0.4950300570161204}}
{"hexsha": "73f029d31b58e29fa340cd156f628fde5bcde265", "ext": "java", "lang": "Java", "content": "public class JavaBugDemoApplication {\n\n    public static void main(String[] args) {\n        JavaBug.addPlugin(new RecursiveOutputCatergory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestPropertyCategory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestOutputCatergory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestSimpleOutputCategory(JavaBug.getCore()));\n\n        JavaBug.addRootObject(\"Test\", new TestClass());\n        JavaBug.addRootObject(\"TestWrapped\", BugByteCodeUtil.getBuggedInstance(TestClass.class));\n        JavaBug.addRootObject(\"Recursion\", RecursiveTestClass.getBuggedTestHierarchy());\n        JavaBug.addRootObject(\"JavaBugCore\", JavaBug.getCore());\n        JavaBug.addRootObject(\"Formats\", new BugFormatTest());\n        JavaBug.addRootObject(\"Array\", new String[]{\"Eins\", \"Zwei\", \"Drei\"});\n        JavaBug.addRootObject(\"List\", Arrays.asList(\"One\", \"Two\", \"Three\"));\n        HashMap<String, String> map = new LinkedHashMap<>();\n        map.put(\"One\", \"Eins\");\n        map.put(\"Two\", \"Zwei\");\n        map.put(\"Three\", \"Drei\");\n        JavaBug.addRootObject(\"Map\", map);\n        for (int i = 0; i < 100; i++)\n            JavaBug.addRootObject(\"Integer \" + i, i);\n        JavaBug.start();\n        System.out.println(\"javaBug startet. Open your browser at: \" + JavaBug.getIPAddresses(true));\n\n\n        while (true) {\n            try {\n                Thread.sleep(Long.MAX_VALUE);\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n}", "class_id": 0, "repo": "MaxNagl/droidBug", "file": "demoapplication/src/main/java/de/siebn/javaBug/testApplication/JavaBugDemoApplication.java", "last_update_at": "2018-04-16T18:39:18+00:00", "question_id": "73f029d31b58e29fa340cd156f628fde5bcde265", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class JavaBugDemoApplication {\n    public static void main(String[] args) {\n        JavaBug.addPlugin(new RecursiveOutputCatergory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestPropertyCategory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestOutputCatergory(JavaBug.getCore()));\n        JavaBug.addPlugin(new TestSimpleOutputCategory(JavaBug.getCore()));\n        JavaBug.addRootObject(\"Test\", new TestClass());\n        JavaBug.addRootObject(\"TestWrapped\", BugByteCodeUtil.getBuggedInstance(TestClass.class));\n        JavaBug.addRootObject(\"Recursion\", RecursiveTestClass.getBuggedTestHierarchy());\n        JavaBug.addRootObject(\"JavaBugCore\", JavaBug.getCore());\n        JavaBug.addRootObject(\"Formats\", new BugFormatTest());\n        JavaBug.addRootObject(\"Array\", new String[]{\"Eins\", \"Zwei\", \"Drei\"});\n        JavaBug.addRootObject(\"List\", Arrays.asList(\"One\", \"Two\", \"Three\"));\n        HashMap<String, String> map = new LinkedHashMap<>();\n        map.put(\"One\", \"Eins\");\n        map.put(\"Two\", \"Zwei\");\n        map.put(\"Three\", \"Drei\");\n        JavaBug.addRootObject(\"Map\", map);\n        for (int i = 0; i < 100; i++)\n            JavaBug.addRootObject(\"Integer \" + i, i);\n        JavaBug.start();\n        System.out.println(\"javaBug startet. Open your browser at: \" + JavaBug.getIPAddresses(true));\n        while (true) {\n            try {\n                Thread.sleep(Long.MAX_VALUE);\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n"]], "pred": {"ppl": 2.5066239833831787, "ppl_lower": 2.765516757965088, "ppl/lowercase_ppl": -1.1069613128673583, "ppl/zlib": 0.001652764066983841, "Min_5.0% Prob": 7.403389329495638, "Min_10.0% Prob": 5.9282560602147525, "Min_20.0% Prob": 4.081403804586289, "Min_30.0% Prob": 2.9541459702853614, "Min_40.0% Prob": 2.2710970537935165, "Min_50.0% Prob": 1.830646692137135, "Min_60.0% Prob": 1.5295458628452574}}
{"hexsha": "2ebab7cb01b49557e017b8651d2d407a72730046", "ext": "java", "lang": "Java", "content": "public class House {\n\n    private static final String PHRASE_01 = \"that lay in the house that Jack built.\\n\";\n    private static final String PHRASE_02 = \"that killed the rat \";\n    private static final String PHRASE_03 = \"that worried the cat \";\n    private static final String PHRASE_04 = \"that ate the malt \";\n    private static final String PHRASE_05 = \"that milked the cow with the crumpled horn \";\n    private static final String PHRASE_06 = \"that kissed the maiden all forlorn \";\n    private static final String PHRASE_07 = \"that married the man all tattered and torn \";\n    private static final String PHRASE_08 = \"that woke the priest all shaven and shorn \";\n    private static final String PHRASE_09 = \"that tossed the dog \";\n\n    private static final String SONG =\n            \"This is the house that Jack built.\\n\" + \"This is the malt \" + PHRASE_01 + \"This is the rat \" + PHRASE_04 + PHRASE_01\n                    + \"This is the cat \" + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the dog \" + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + PHRASE_01 + \"This is the cow with the crumpled horn \" + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01\n                    + \"This is the maiden all forlorn \" + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01\n                    + \"This is the man all tattered and torn \" + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + PHRASE_01 + \"This is the priest all shaven and shorn \" + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03\n                    + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the rooster that crowed in the morn \" + PHRASE_08 + PHRASE_07 + PHRASE_06\n                    + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the farmer sowing his corn \"\n                    + \"that kept the rooster that crowed in the morn \" + PHRASE_08 + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09\n                    + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the horse and the hound and the horn \"\n                    + \"that belonged to the farmer sowing his corn \" + \"that kept the rooster that crowed in the morn \" + PHRASE_08\n                    + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + \"that lay in the house that Jack built.\";\n\n    private static final Map<Integer, String> SONG_MAP = new HashMap<>();\n\n    static {\n        String[] array = SONG.split(\"\\n\");\n\n        for (int i = 0; i < array.length; i++) {\n            SONG_MAP.put(i + 1, array[i]);\n        }\n    }\n\n    public String verse(int verseNumber) {\n        return SONG_MAP.get(verseNumber);\n    }\n\n    public String verses(int startVerse, int endVerse) {\n        StringBuilder result = new StringBuilder();\n        for (int i = startVerse; i < endVerse; i++) {\n            result.append(SONG_MAP.get(i))\n                  .append(\"\\n\");\n        }\n        result.append(SONG_MAP.get(endVerse));\n\n        return result.toString();\n    }\n\n    String sing() {\n        return SONG;\n    }\n}", "class_id": 0, "repo": "craneyuan/exercism-solution", "file": "java/house/src/main/java/House.java", "last_update_at": "2018-08-18T14:28:47+00:00", "question_id": "2ebab7cb01b49557e017b8651d2d407a72730046", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class House {\n    private static final String PHRASE_01 = \"that lay in the house that Jack built.\\n\";\n    private static final String PHRASE_02 = \"that killed the rat \";\n    private static final String PHRASE_03 = \"that worried the cat \";\n    private static final String PHRASE_04 = \"that ate the malt \";\n    private static final String PHRASE_05 = \"that milked the cow with the crumpled horn \";\n    private static final String PHRASE_06 = \"that kissed the maiden all forlorn \";\n    private static final String PHRASE_07 = \"that married the man all tattered and torn \";\n    private static final String PHRASE_08 = \"that woke the priest all shaven and shorn \";\n    private static final String PHRASE_09 = \"that tossed the dog \";\n    private static final String SONG =\n            \"This is the house that Jack built.\\n\" + \"This is the malt \" + PHRASE_01 + \"This is the rat \" + PHRASE_04 + PHRASE_01\n                    + \"This is the cat \" + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the dog \" + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + PHRASE_01 + \"This is the cow with the crumpled horn \" + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01\n                    + \"This is the maiden all forlorn \" + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01\n                    + \"This is the man all tattered and torn \" + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + PHRASE_01 + \"This is the priest all shaven and shorn \" + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03\n                    + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the rooster that crowed in the morn \" + PHRASE_08 + PHRASE_07 + PHRASE_06\n                    + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the farmer sowing his corn \"\n                    + \"that kept the rooster that crowed in the morn \" + PHRASE_08 + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09\n                    + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + \"This is the horse and the hound and the horn \"\n                    + \"that belonged to the farmer sowing his corn \" + \"that kept the rooster that crowed in the morn \" + PHRASE_08\n                    + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04\n                    + \"that lay in the house that Jack built.\";\n    private static final Map<Integer, String> SONG_MAP = new HashMap<>();\n    static {\n        String[] array = SONG.split(\"\\n\");\n        for (int i = 0; i < array.length; i++) {\n            SONG_MAP.put(i + 1, array[i]);\n        }\n    }\n    public String verse(int verseNumber) {\n        return SONG_MAP.get(verseNumber);\n    }\n    public String verses(int startVerse, int endVerse) {\n        StringBuilder result = new StringBuilder();\n        for (int i = startVerse; i < endVerse; i++) {\n            result.append(SONG_MAP.get(i))\n                  .append(\"\\n\");\n        }\n        result.append(SONG_MAP.get(endVerse));\n        return result.toString();\n    }\n    String sing() {\n        return SONG;\n    }\n"]], "pred": {"ppl": 1.288496971130371, "ppl_lower": 1.4823976755142212, "ppl/lowercase_ppl": -1.5530472552488344, "ppl/zlib": 0.00036159258261512367, "Min_5.0% Prob": 4.136474326545117, "Min_10.0% Prob": 2.422585058153844, "Min_20.0% Prob": 1.2628477791817312, "Min_30.0% Prob": 0.8462357610750189, "Min_40.0% Prob": 0.6337522442898347, "Min_50.0% Prob": 0.507389975485992, "Min_60.0% Prob": 0.42300103872592704}}
{"hexsha": "e765d1bb5a0173e06bbc2766f0d7a27169bd5a6c", "ext": "java", "lang": "Java", "content": "public class StitchProblem implements IStitchProblem {\n\n    private RecognitionException sourceException = null;\n    private int severity = UNKNOWN;\n\n    public StitchProblem(RecognitionException exception, int severity) {\n        sourceException = exception;\n        this.severity = severity;\n    }\n\n    public RecognitionException getSourceException () {\n        return sourceException;\n    }\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getSeverity()\n     */\n    @Override\n    public int getSeverity () {\n        return severity;\n    }\n\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getMessage()\n     */\n    @Override\n    public String getMessage () {\n        return sourceException.getMessage();\n    }\n\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getLine()\n     */\n    @Override\n    public int getLine () {\n        return sourceException.getLine();\n    }\n\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getColumn()\n     */\n    @Override\n    public int getColumn () {\n        return sourceException.getColumn();\n    }\n\n    @Override\n    public IStitchProblem clone () {\n        return new StitchProblem (sourceException, severity);\n    }\n\n    @Override\n    public boolean equals (Object o) {\n        if (o instanceof StitchProblem) {\n            StitchProblem p = (StitchProblem) o;\n            return getMessage ().equals (p.getMessage ()) && getLine () == p.getLine () && getColumn () == p.getColumn () && severity == p.severity;\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode () {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + getMessage ().hashCode ();\n        result = result * prime + getColumn ();\n        result = result * prime + getLine ();\n        result = result * prime + getSeverity ();\n        return result;\n    }\n/*\n\tpublic int getOffset() {\n\t\t// TODO Calculate offset location\n\t\treturn 1;\n\t}\n\n\tpublic int getLength() {\n\t\t// TODO Calculate length of problem\n\t\treturn 1;\n\t}\n */\t\n}", "class_id": 0, "repo": "cmendesce/rainbow-znn-deployment", "file": "rainbow-stitch/src/main/java/org/sa/rainbow/stitch/error/StitchProblem.java", "last_update_at": "2018-11-08T01:20:18+00:00", "question_id": "e765d1bb5a0173e06bbc2766f0d7a27169bd5a6c", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class StitchProblem implements IStitchProblem {\n    private RecognitionException sourceException = null;\n    private int severity = UNKNOWN;\n    public StitchProblem(RecognitionException exception, int severity) {\n        sourceException = exception;\n        this.severity = severity;\n    }\n    public RecognitionException getSourceException () {\n        return sourceException;\n    }\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getSeverity()\n     */\n    @Override\n    public int getSeverity () {\n        return severity;\n    }\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getMessage()\n     */\n    @Override\n    public String getMessage () {\n        return sourceException.getMessage();\n    }\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getLine()\n     */\n    @Override\n    public int getLine () {\n        return sourceException.getLine();\n    }\n    /* (non-Javadoc)\n     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getColumn()\n     */\n    @Override\n    public int getColumn () {\n        return sourceException.getColumn();\n    }\n    @Override\n    public IStitchProblem clone () {\n        return new StitchProblem (sourceException, severity);\n    }\n    @Override\n    public boolean equals (Object o) {\n        if (o instanceof StitchProblem) {\n            StitchProblem p = (StitchProblem) o;\n            return getMessage ().equals (p.getMessage ()) && getLine () == p.getLine () && getColumn () == p.getColumn () && severity == p.severity;\n        }\n        return false;\n    }\n    @Override\n    public int hashCode () {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + getMessage ().hashCode ();\n        result = result * prime + getColumn ();\n        result = result * prime + getLine ();\n        result = result * prime + getSeverity ();\n        return result;\n    }\n/*\n\tpublic int getOffset() {\n\t\t// TODO Calculate offset location\n\t\treturn 1;\n\t}\n\tpublic int getLength() {\n\t\t// TODO Calculate length of problem\n\t\treturn 1;\n\t}\n */\t\n"]], "pred": {"ppl": 1.5659842491149902, "ppl_lower": 1.736731767654419, "ppl/lowercase_ppl": -1.2307405980772277, "ppl/zlib": 0.0007786710754889311, "Min_5.0% Prob": 5.916543446481228, "Min_10.0% Prob": 3.825410413555801, "Min_20.0% Prob": 2.1723124431446195, "Min_30.0% Prob": 1.487234393755595, "Min_40.0% Prob": 1.1214923392253695, "Min_50.0% Prob": 0.895931578409565, "Min_60.0% Prob": 0.7475260674421277}}
{"hexsha": "baabda339e69ba70e847b4d0fc5cb182a1f1d0cd", "ext": "java", "lang": "Java", "content": "@Autonomous(name = \"Crater - competition\")\n@Disabled\n\npublic class Crater extends LinearOpMode  {\n\nMecanumDrive myMechDrive;\n\nGyroCompetition myGyro;\nMecanumMineralMiner myMineralMiner;\nRevColorDistance myRevColorDistance;\n\nWebcam myWebcam;\nLiftMotor myLiftMotor;\nTeamMarker myTeamMarker;\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\n\n\n    final long sleepTime = 100;\n    final double SPD_DRIVE_MED = .5;\n\n\n    myMechDrive = new MecanumDrive(hardwareMap.dcMotor.get(\"front_left_motor\"), hardwareMap.dcMotor.get(\"front_right_motor\"), hardwareMap.dcMotor.get(\"rear_left_motor\"), hardwareMap.dcMotor.get(\"rear_right_motor\"));\n    myMechDrive.setLinearOp(this);\n\n    myGyro = new GyroCompetition(hardwareMap.get(BNO055IMU.class, \"imu\"));\n    myGyro.setLinearOp(this);\n\n    myMineralMiner = new MecanumMineralMiner();\n    myMineralMiner.setLinearOp(this);\n\n    myLiftMotor = new LiftMotor(hardwareMap.dcMotor.get(\"lift_motor\"));\n    myLiftMotor.setLinearOp(this);\n\n    myTeamMarker = new TeamMarker(hardwareMap.servo.get(\"team_marker_arm\"));\n    myTeamMarker.setLinearOp(this);\n\n    myRevColorDistance = new RevColorDistance(hardwareMap.get(ColorSensor.class, \"rev_sensor_color_distance\"), hardwareMap.get(DistanceSensor.class, \"rev_sensor_color_distance\"));\n    myWebcam = new Webcam();\n\n\n    waitForStart();\n\n    boolean active = true;\n    while (opModeIsActive() && !isStopRequested()) {\n        while (active && !isStopRequested()) {\n            idle();\n            /*\n            Find the correct gold mineral\n             */\n            myMineralMiner.findingMineral();\n            sleep(sleepTime);\n            idle();\n            /*\n            1) drives forward from lander a short distance so doesn't interfere with gyro turn\n            2) angles self with gold mineral based on myMineralMiner.findingMineral\n            3) Drives forward to knock of gold mineral.\n             */\n            myMineralMiner.driveMineral(myGyro, myMechDrive, myLiftMotor);\n            sleep(sleepTime);\n            idle();\n            /*\n            1) BACKS UP TO TAPE\n            2) TURNS TO A) MISS LANDER AND AND B) MISS MINERALS WHEN GOING STRAIGHT\n            3) GOES STRAIGHT TOWARDS WALL\n             */\n            myMineralMiner.craterMineralToWall (myGyro, myMechDrive, myRevColorDistance);\n            sleep(sleepTime);\n\n            idle();\n            /*\n            Will angle robot to be parallel with robot, score in depot, and then go to crater.\n             */\n           myMineralMiner.wallToDepot(myGyro, myMechDrive, myRevColorDistance, myTeamMarker);\n\n            active = false;\n        }\n        idle();\n        requestOpModeStop();\n    }\n}\n}", "class_id": 0, "repo": "10219roverruckus/ftc_app", "file": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robot/competition/oldClasses/Crater.java", "last_update_at": "2018-10-05T23:07:03+00:00", "question_id": "baabda339e69ba70e847b4d0fc5cb182a1f1d0cd", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Autonomous(name = \"Crater - competition\")\n@Disabled\npublic class Crater extends LinearOpMode  {\nMecanumDrive myMechDrive;\nGyroCompetition myGyro;\nMecanumMineralMiner myMineralMiner;\nRevColorDistance myRevColorDistance;\nWebcam myWebcam;\nLiftMotor myLiftMotor;\nTeamMarker myTeamMarker;\n@Override\npublic void runOpMode() throws InterruptedException {\n    final long sleepTime = 100;\n    final double SPD_DRIVE_MED = .5;\n    myMechDrive = new MecanumDrive(hardwareMap.dcMotor.get(\"front_left_motor\"), hardwareMap.dcMotor.get(\"front_right_motor\"), hardwareMap.dcMotor.get(\"rear_left_motor\"), hardwareMap.dcMotor.get(\"rear_right_motor\"));\n    myMechDrive.setLinearOp(this);\n    myGyro = new GyroCompetition(hardwareMap.get(BNO055IMU.class, \"imu\"));\n    myGyro.setLinearOp(this);\n    myMineralMiner = new MecanumMineralMiner();\n    myMineralMiner.setLinearOp(this);\n    myLiftMotor = new LiftMotor(hardwareMap.dcMotor.get(\"lift_motor\"));\n    myLiftMotor.setLinearOp(this);\n    myTeamMarker = new TeamMarker(hardwareMap.servo.get(\"team_marker_arm\"));\n    myTeamMarker.setLinearOp(this);\n    myRevColorDistance = new RevColorDistance(hardwareMap.get(ColorSensor.class, \"rev_sensor_color_distance\"), hardwareMap.get(DistanceSensor.class, \"rev_sensor_color_distance\"));\n    myWebcam = new Webcam();\n    waitForStart();\n    boolean active = true;\n    while (opModeIsActive() && !isStopRequested()) {\n        while (active && !isStopRequested()) {\n            idle();\n            /*\n            Find the correct gold mineral\n             */\n            myMineralMiner.findingMineral();\n            sleep(sleepTime);\n            idle();\n            /*\n            1) drives forward from lander a short distance so doesn't interfere with gyro turn\n            2) angles self with gold mineral based on myMineralMiner.findingMineral\n            3) Drives forward to knock of gold mineral.\n             */\n            myMineralMiner.driveMineral(myGyro, myMechDrive, myLiftMotor);\n            sleep(sleepTime);\n            idle();\n            /*\n            1) BACKS UP TO TAPE\n            2) TURNS TO A) MISS LANDER AND AND B) MISS MINERALS WHEN GOING STRAIGHT\n            3) GOES STRAIGHT TOWARDS WALL\n             */\n            myMineralMiner.craterMineralToWall (myGyro, myMechDrive, myRevColorDistance);\n            sleep(sleepTime);\n            idle();\n            /*\n            Will angle robot to be parallel with robot, score in depot, and then go to crater.\n             */\n           myMineralMiner.wallToDepot(myGyro, myMechDrive, myRevColorDistance, myTeamMarker);\n            active = false;\n        }\n        idle();\n        requestOpModeStop();\n    }\n}\n"]], "pred": {"ppl": 2.2676594257354736, "ppl_lower": 2.7463619709014893, "ppl/lowercase_ppl": -1.233928947101039, "ppl/zlib": 0.0008747309931303182, "Min_5.0% Prob": 7.163600783877903, "Min_10.0% Prob": 5.60693145857917, "Min_20.0% Prob": 3.640417472104341, "Min_30.0% Prob": 2.623226557693937, "Min_40.0% Prob": 2.023970304113446, "Min_50.0% Prob": 1.6325949686394783, "Min_60.0% Prob": 1.3655542583180837}}
{"hexsha": "b30acd33e1c62c5c5c15ee0305d99909dc3acfde", "ext": "java", "lang": "Java", "content": "@ApplicationScoped\npublic class WsValidationErrorConverter {\n\n    public WsViolationError toWsValidationError(ConstraintViolation constraintViolation) {\n        String propertyPath = constraintViolation.getPropertyPath().toString();\n        String messageTemplate = constraintViolation.getMessageTemplate();\n\n        WsViolationError validationError = new WsViolationError(propertyPath, messageTemplate);\n        return validationError;\n    }\n}", "class_id": 0, "repo": "cghislai/authenticator", "file": "authenticator-management/src/main/java/com/charlyghislain/authenticator/management/web/converter/WsValidationErrorConverter.java", "last_update_at": "2018-09-07T14:12:06+00:00", "question_id": "b30acd33e1c62c5c5c15ee0305d99909dc3acfde", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@ApplicationScoped\npublic class WsValidationErrorConverter {\n    public WsViolationError toWsValidationError(ConstraintViolation constraintViolation) {\n        String propertyPath = constraintViolation.getPropertyPath().toString();\n        String messageTemplate = constraintViolation.getMessageTemplate();\n        WsViolationError validationError = new WsViolationError(propertyPath, messageTemplate);\n        return validationError;\n    }\n"]], "pred": {"ppl": 2.386387586593628, "ppl_lower": 4.072692394256592, "ppl/lowercase_ppl": -1.6145497571410505, "ppl/zlib": 0.00460201456336377, "Min_5.0% Prob": 7.826666355133057, "Min_10.0% Prob": 5.6883057117462155, "Min_20.0% Prob": 3.8129943211873374, "Min_30.0% Prob": 2.811007898300886, "Min_40.0% Prob": 2.1925942564294454, "Min_50.0% Prob": 1.74969232968002, "Min_60.0% Prob": 1.45292522359523}}
{"hexsha": "1df3e8d8b4ee39f5094c91c53daa16ddc62b4284", "ext": "java", "lang": "Java", "content": "public abstract class AbstractMessageAction extends AbstractAction {\n\n\t/**\n\t * @param inParam\n\t * @return\n\t * @throws InvalidParameterException\n\t * @throws NoSuchMessageException\n\t * @throws APIException\n\t */\n\tprotected MessageData getRequestedMessage(ActionParam inParam, StatusMessage inStatus) throws InvalidParameterException, NoSuchMessageException {\n\n\t\tfinal String messageId = inParam.getMainParamAsString();\n\n\t\tfinal MessageData message = MessageData.findByAPIId(messageId, inParam.getCaller().getAPIKey(), inStatus);\n\n\t\tif (message == null) {\n\t\t\tthrow new NoSuchMessageException(APIErrorMessage.NO_SUCH_MESSAGE);\n\t\t}\n\n\t\treturn message;\n\t}\n\n}", "class_id": 0, "repo": "nguillaumin/nabaztag-server", "file": "net.violet.platform/src/main/java/net/violet/platform/api/actions/messages/AbstractMessageAction.java", "last_update_at": "2018-03-29T08:10:12+00:00", "question_id": "1df3e8d8b4ee39f5094c91c53daa16ddc62b4284", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public abstract class AbstractMessageAction extends AbstractAction {\n\t/**\n\t * @param inParam\n\t * @return\n\t * @throws InvalidParameterException\n\t * @throws NoSuchMessageException\n\t * @throws APIException\n\t */\n\tprotected MessageData getRequestedMessage(ActionParam inParam, StatusMessage inStatus) throws InvalidParameterException, NoSuchMessageException {\n\t\tfinal String messageId = inParam.getMainParamAsString();\n\t\tfinal MessageData message = MessageData.findByAPIId(messageId, inParam.getCaller().getAPIKey(), inStatus);\n\t\tif (message == null) {\n\t\t\tthrow new NoSuchMessageException(APIErrorMessage.NO_SUCH_MESSAGE);\n\t\t}\n\t\treturn message;\n\t}\n"]], "pred": {"ppl": 2.239386796951294, "ppl_lower": 3.4117400646209717, "ppl/lowercase_ppl": -1.522226844847274, "ppl/zlib": 0.0025512723956619475, "Min_5.0% Prob": 6.700317753685845, "Min_10.0% Prob": 5.10909124424583, "Min_20.0% Prob": 3.3898105307629236, "Min_30.0% Prob": 2.525471740647366, "Min_40.0% Prob": 1.9641904976073798, "Min_50.0% Prob": 1.6063592295007159, "Min_60.0% Prob": 1.350054252649779}}
{"hexsha": "02333fba8ff5a709c3d5a735eb011408f2713320", "ext": "java", "lang": "Java", "content": "public class CachedProviderHandler implements InvocationHandler {\n\n    private Map<String, Object> cached = new HashMap<>();\n    private Object              target;\n\n    public CachedProviderHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Type[] types = method.getParameterTypes();\n        if (method.getName().matches(\"get.+\") && (types.length == 1) && (types[0] == String.class)) {\n            String key   = (String) args[0];\n            Object value = cached.get(key);\n            if (value == null) {\n                value = method.invoke(target, args);\n                cached.put(key, value);\n            }\n            return value;\n        }\n        return method.invoke(target, args);\n    }\n\n}", "class_id": 0, "repo": "firenio/baseio", "file": "firenio-test/src/main/java/test/others/jdkproxy/CachedProviderHandler.java", "last_update_at": "2018-11-29T07:21:10+00:00", "question_id": "02333fba8ff5a709c3d5a735eb011408f2713320", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class CachedProviderHandler implements InvocationHandler {\n    private Map<String, Object> cached = new HashMap<>();\n    private Object              target;\n    public CachedProviderHandler(Object target) {\n        this.target = target;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Type[] types = method.getParameterTypes();\n        if (method.getName().matches(\"get.+\") && (types.length == 1) && (types[0] == String.class)) {\n            String key   = (String) args[0];\n            Object value = cached.get(key);\n            if (value == null) {\n                value = method.invoke(target, args);\n                cached.put(key, value);\n            }\n            return value;\n        }\n        return method.invoke(target, args);\n    }\n"]], "pred": {"ppl": 1.6840704679489136, "ppl_lower": 1.9532761573791504, "ppl/lowercase_ppl": -1.284517206257481, "ppl/zlib": 0.0013936196805347531, "Min_5.0% Prob": 5.86126561164856, "Min_10.0% Prob": 3.960822548185076, "Min_20.0% Prob": 2.4398731532550992, "Min_30.0% Prob": 1.7116896285424157, "Min_40.0% Prob": 1.292911372465246, "Min_50.0% Prob": 1.042846053135845, "Min_60.0% Prob": 0.8726125677211547}}
{"hexsha": "798c46940dc9ae70d6a3ca0e9886c09e3ebd33c7", "ext": "java", "lang": "Java", "content": "public class ProcedureName implements Comparable<ProcedureName> {\n    private final String name;\n\n    private ProcedureName(final String name) {\n        this.name = name;\n    }\n\n    @Override public String toString() {\n        return name;\n    }\n\n    @Override public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (name == null ? 0 : name.hashCode());\n        return result;\n    }\n\n    @Override public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final ProcedureName other = (ProcedureName) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override public int compareTo(final ProcedureName o) {\n        return name.compareTo(o.name);\n    }\n\n    public static List<ProcedureName> asProcedureNames(final String[] names) {\n        return Jc.$(names).map(ProcedureName::procedureName)._$();\n    }\n\n    public static ProcedureName procedureName(final String name) {\n        return new ProcedureName(name);\n    }\n}", "class_id": 0, "repo": "lexicalscope/ape", "file": "src/main/java/com/lexicalscope/bl/procedures/ProcedureName.java", "last_update_at": "2018-12-17T19:11:05+00:00", "question_id": "798c46940dc9ae70d6a3ca0e9886c09e3ebd33c7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProcedureName implements Comparable<ProcedureName> {\n    private final String name;\n    private ProcedureName(final String name) {\n        this.name = name;\n    }\n    @Override public String toString() {\n        return name;\n    }\n    @Override public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + (name == null ? 0 : name.hashCode());\n        return result;\n    }\n    @Override public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final ProcedureName other = (ProcedureName) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        return true;\n    }\n    @Override public int compareTo(final ProcedureName o) {\n        return name.compareTo(o.name);\n    }\n    public static List<ProcedureName> asProcedureNames(final String[] names) {\n        return Jc.$(names).map(ProcedureName::procedureName)._$();\n    }\n    public static ProcedureName procedureName(final String name) {\n        return new ProcedureName(name);\n    }\n"]], "pred": {"ppl": 1.3876920938491821, "ppl_lower": 1.5094083547592163, "ppl/lowercase_ppl": -1.2566085915240728, "ppl/zlib": 0.0007876009689257589, "Min_5.0% Prob": 4.907590680652195, "Min_10.0% Prob": 3.091002546452187, "Min_20.0% Prob": 1.6187448408206304, "Min_30.0% Prob": 1.0945795023414706, "Min_40.0% Prob": 0.8199419181793928, "Min_50.0% Prob": 0.6548665778865007, "Min_60.0% Prob": 0.5473816960731832}}
{"hexsha": "1e6fd2e693b09f6010a67cc46f0cd05ff756afe4", "ext": "java", "lang": "Java", "content": "public class TestRange {\n\n    @Test\n    public void testBasic() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertEquals(5, integerRange.getMin().intValue());\n        Assert.assertEquals(6, integerRange.getMax().intValue());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[5, 6]\", integerRange.toString());\n        Assert.assertEquals(2L, integerRange.size().longValue());\n\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertEquals(null, integerRange.getMin());\n        Assert.assertEquals(27, integerRange.getMax().intValue());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[-inf, 27]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n\n        integerRange = new IntegerRange(8, null);\n        Assert.assertEquals(8, integerRange.getMin().intValue());\n        Assert.assertEquals(null, integerRange.getMax());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[8, +inf]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(null, integerRange.getMin());\n        Assert.assertEquals(null, integerRange.getMax());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[-inf, +inf]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertEquals(5, integerRange.getMin().intValue());\n        Assert.assertEquals(4, integerRange.getMax().intValue());\n        Assert.assertTrue(integerRange.isEmpty());\n        Assert.assertEquals(\"[5, 4]\", integerRange.toString());\n        Assert.assertEquals(0L, integerRange.size().longValue());\n    }\n\n    @Test\n    public void testContains() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertTrue(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n\n        integerRange = new IntegerRange(8, null);\n        Assert.assertTrue(integerRange.contains(15));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertTrue(integerRange.contains(100));\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertTrue(integerRange.contains(0));\n        Assert.assertTrue(integerRange.contains(100));\n\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertFalse(integerRange.contains(5));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n    }\n\n    @Test\n    public void testCompareToValues() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n\n        integerRange = new IntegerRange(8, null);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n    }\n\n    @Test\n    public void testCompareRanges() {\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.EQUALS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.EQUALS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.EQUALS);\n\n        integerRange = new IntegerRange(1, 0);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.ANY_EMPTY);\n    }\n\n\n    @Test\n    public void testIntersection() {\n        IntegerRange emptyRange = new IntegerRange(0, -1);\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -1)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));\n\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));\n\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(0, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 20));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 20));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));\n\n        integerRange = new IntegerRange(1, 0);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), emptyRange);\n    }\n\n    @Test\n    public void testGetPosition() {\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));\n        try {\n            integerRange.getPosition(15L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n\n        integerRange = new IntegerRange(0, -1);\n        try {\n            integerRange.getPosition(5L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(15L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(null, integerRange.getPosition(5L));\n        Assert.assertEquals(null, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));\n        Assert.assertEquals((Integer) 15, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(null, integerRange.getPosition(5L));\n        Assert.assertEquals(null, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n    }\n}", "class_id": 0, "repo": "albertoanguita/util", "file": "src/test/java/org/aanguita/jacuzzi/numeric/range/TestRange.java", "last_update_at": "2018-02-10T15:58:12+00:00", "question_id": "1e6fd2e693b09f6010a67cc46f0cd05ff756afe4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class TestRange {\n    @Test\n    public void testBasic() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertEquals(5, integerRange.getMin().intValue());\n        Assert.assertEquals(6, integerRange.getMax().intValue());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[5, 6]\", integerRange.toString());\n        Assert.assertEquals(2L, integerRange.size().longValue());\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertEquals(null, integerRange.getMin());\n        Assert.assertEquals(27, integerRange.getMax().intValue());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[-inf, 27]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n        integerRange = new IntegerRange(8, null);\n        Assert.assertEquals(8, integerRange.getMin().intValue());\n        Assert.assertEquals(null, integerRange.getMax());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[8, +inf]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(null, integerRange.getMin());\n        Assert.assertEquals(null, integerRange.getMax());\n        Assert.assertFalse(integerRange.isEmpty());\n        Assert.assertEquals(\"[-inf, +inf]\", integerRange.toString());\n        Assert.assertEquals(null, integerRange.size());\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertEquals(5, integerRange.getMin().intValue());\n        Assert.assertEquals(4, integerRange.getMax().intValue());\n        Assert.assertTrue(integerRange.isEmpty());\n        Assert.assertEquals(\"[5, 4]\", integerRange.toString());\n        Assert.assertEquals(0L, integerRange.size().longValue());\n    }\n    @Test\n    public void testContains() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertTrue(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n        integerRange = new IntegerRange(8, null);\n        Assert.assertTrue(integerRange.contains(15));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertTrue(integerRange.contains(100));\n        integerRange = new IntegerRange(null, null);\n        Assert.assertTrue(integerRange.contains(5));\n        Assert.assertTrue(integerRange.contains(0));\n        Assert.assertTrue(integerRange.contains(100));\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertFalse(integerRange.contains(5));\n        Assert.assertFalse(integerRange.contains(0));\n        Assert.assertFalse(integerRange.contains(100));\n    }\n    @Test\n    public void testCompareToValues() {\n        IntegerRange integerRange = new IntegerRange(5, 6);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n        integerRange = new IntegerRange(null, 27);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n        integerRange = new IntegerRange(8, null);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n        integerRange = new IntegerRange(5, 4);\n        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);\n    }\n    @Test\n    public void testCompareRanges() {\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.EQUALS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.LEFT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.RIGHT_OVERLAP);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.EQUALS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.CONTAINS);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.EQUALS);\n        integerRange = new IntegerRange(1, 0);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.ANY_EMPTY);\n        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.ANY_EMPTY);\n    }\n    @Test\n    public void testIntersection() {\n        IntegerRange emptyRange = new IntegerRange(0, -1);\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -1)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(0, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 20));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 20));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));\n        integerRange = new IntegerRange(1, 0);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), emptyRange);\n        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), emptyRange);\n    }\n    @Test\n    public void testGetPosition() {\n        IntegerRange integerRange = new IntegerRange(0, 10);\n        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));\n        try {\n            integerRange.getPosition(15L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n        integerRange = new IntegerRange(0, -1);\n        try {\n            integerRange.getPosition(5L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(15L);\n        } catch (IndexOutOfBoundsException e) {\n            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n        }\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n        integerRange = new IntegerRange(null, 10);\n        Assert.assertEquals(null, integerRange.getPosition(5L));\n        Assert.assertEquals(null, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n        integerRange = new IntegerRange(0, null);\n        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));\n        Assert.assertEquals((Integer) 15, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n        integerRange = new IntegerRange(null, null);\n        Assert.assertEquals(null, integerRange.getPosition(5L));\n        Assert.assertEquals(null, integerRange.getPosition(15L));\n        try {\n            integerRange.getPosition(-5L);\n        } catch (IllegalArgumentException e) {\n            Assert.assertEquals(IllegalArgumentException.class, e.getClass());\n        }\n    }\n"]], "pred": {"ppl": 1.2833822965621948, "ppl_lower": 1.3557958602905273, "ppl/lowercase_ppl": -1.2199993505076838, "ppl/zlib": 0.00018987748254879473, "Min_5.0% Prob": 3.751780760054495, "Min_10.0% Prob": 2.2970091645039763, "Min_20.0% Prob": 1.2324701540135579, "Min_30.0% Prob": 0.8311187674267083, "Min_40.0% Prob": 0.6233677714038413, "Min_50.0% Prob": 0.49931482669640853, "Min_60.0% Prob": 0.4163294125670798}}
{"hexsha": "39a00aab3bb91f9ba6a8aa5a4edbc366e12074c0", "ext": "java", "lang": "Java", "content": "public class setvalue001 {\n\n    public static void main(String argv[]) {\n        System.exit(run(argv, System.out) + 95); // JCK-compatible exit status\n    }\n\n    static int exitCode  = 0;\n    static int exitCode0 = 0;\n    static int exitCode2 = 2;\n\n//\n    static Connector.IntegerArgument intArgument = null;\n    static int i;\n\n    private static void check(int i1, PrintStream out) {\n\n//\n        String sErr2 =  \"ERROR\\n\" +\n                        \"Method tested: \" +\n                        \"jdi.Connector.IntegerArgument.setValue()\\n\" ;\n\n\n            intArgument.setValue(i);\n            intArgument.setValue(i1);\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(int); setValue(int)\\n\" +\n                         \"result: no equality\\n\");\n            }\n\n            intArgument.setValue(i);\n            intArgument.setValue(intArgument.stringValueOf(i1));\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(int); setValue(String)\\n\" +\n                         \"result: no equality\\n\");\n            }\n\n            intArgument.setValue(intArgument.stringValueOf(i));\n            intArgument.setValue(i1);\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(String); setValue(int)\\n\" +\n                         \"result: no equality\\n\");\n            }\n\n            intArgument.setValue(intArgument.stringValueOf(i));\n            intArgument.setValue(intArgument.stringValueOf(i1));\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(String); setValue(String)\\n\" +\n                         \"result: no equality\\n\");\n            }\n    }\n\n    public static int run(String argv[], PrintStream out) {\n\n        VirtualMachineManager vmm = Bootstrap.virtualMachineManager();\n\n        List connectorsList = vmm.allConnectors();\n        Iterator connectorsListIterator = connectorsList.iterator();\n//\n        String sErr1 =  \"WARNING\\n\" +\n                        \"Method tested: \" +\n                        \"jdi.Connector.IntegerArgument.setValue\\n\" ;\n\n        Integer intI = null;\n\n        for ( ; ; ) {\n            try {\n                Connector connector =\n                (Connector) connectorsListIterator.next();\n\n                Map defaultArguments = connector.defaultArguments();\n                Set keyset     = defaultArguments.keySet();\n                int keysetSize = defaultArguments.size();\n                Iterator  keysetIterator = keyset.iterator();\n\n                for ( ; ; ) {\n                    try {\n                        String argName = (String) keysetIterator.next();\n\n                        try {\n//\n                            intArgument = (Connector.IntegerArgument)\n                                       defaultArguments.get(argName);\n                            break ;\n                        } catch ( ClassCastException e) {\n                        }\n                    } catch ( NoSuchElementException e) {\n                        break ;\n                    }\n                }\n                if (intArgument != null) {\n                    break ;\n                }\n            } catch ( NoSuchElementException e) {\n                out.println(sErr1 +\n//\n                    \"no Connector with IntegerArgument found\\n\");\n                return exitCode0;\n            }\n        }\n\n\n        if (intArgument.min() >= 0) {\n            i = -1;\n        } else {\n            i = 1;\n        }\n\n        check(intArgument.min(), out);\n        check(intArgument.max(), out);\n        if (intArgument.min() < intArgument.max()) {\n            check(intArgument.min() + 1, out);\n        }\n        if (intArgument.min() > intI.MIN_VALUE) {\n            check(intArgument.min() - 1, out);\n        }\n        if (intArgument.max() < intI.MAX_VALUE) {\n            check(intArgument.max() + 1, out);\n        }\n\n        if (exitCode != exitCode0) {\n            out.println(\"TEST FAILED\");\n        }\n        return exitCode;\n    }\n}", "class_id": 0, "repo": "iootclab/openjdk", "file": "openjdk11/test/hotspot/jtreg/vmTestbase/nsk/jdi/IntegerArgument/setValue/setvalue001.java", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "39a00aab3bb91f9ba6a8aa5a4edbc366e12074c0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class setvalue001 {\n    public static void main(String argv[]) {\n        System.exit(run(argv, System.out) + 95); // JCK-compatible exit status\n    }\n    static int exitCode  = 0;\n    static int exitCode0 = 0;\n    static int exitCode2 = 2;\n//\n    static Connector.IntegerArgument intArgument = null;\n    static int i;\n    private static void check(int i1, PrintStream out) {\n//\n        String sErr2 =  \"ERROR\\n\" +\n                        \"Method tested: \" +\n                        \"jdi.Connector.IntegerArgument.setValue()\\n\" ;\n            intArgument.setValue(i);\n            intArgument.setValue(i1);\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(int); setValue(int)\\n\" +\n                         \"result: no equality\\n\");\n            }\n            intArgument.setValue(i);\n            intArgument.setValue(intArgument.stringValueOf(i1));\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(int); setValue(String)\\n\" +\n                         \"result: no equality\\n\");\n            }\n            intArgument.setValue(intArgument.stringValueOf(i));\n            intArgument.setValue(i1);\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(String); setValue(int)\\n\" +\n                         \"result: no equality\\n\");\n            }\n            intArgument.setValue(intArgument.stringValueOf(i));\n            intArgument.setValue(intArgument.stringValueOf(i1));\n            if (intArgument.intValue() != i1) {\n                exitCode = exitCode2;\n                out.println(sErr2 +\n                         \"check: setValue(String); setValue(String)\\n\" +\n                         \"result: no equality\\n\");\n            }\n    }\n    public static int run(String argv[], PrintStream out) {\n        VirtualMachineManager vmm = Bootstrap.virtualMachineManager();\n        List connectorsList = vmm.allConnectors();\n        Iterator connectorsListIterator = connectorsList.iterator();\n//\n        String sErr1 =  \"WARNING\\n\" +\n                        \"Method tested: \" +\n                        \"jdi.Connector.IntegerArgument.setValue\\n\" ;\n        Integer intI = null;\n        for ( ; ; ) {\n            try {\n                Connector connector =\n                (Connector) connectorsListIterator.next();\n                Map defaultArguments = connector.defaultArguments();\n                Set keyset     = defaultArguments.keySet();\n                int keysetSize = defaultArguments.size();\n                Iterator  keysetIterator = keyset.iterator();\n                for ( ; ; ) {\n                    try {\n                        String argName = (String) keysetIterator.next();\n                        try {\n//\n                            intArgument = (Connector.IntegerArgument)\n                                       defaultArguments.get(argName);\n                            break ;\n                        } catch ( ClassCastException e) {\n                        }\n                    } catch ( NoSuchElementException e) {\n                        break ;\n                    }\n                }\n                if (intArgument != null) {\n                    break ;\n                }\n            } catch ( NoSuchElementException e) {\n                out.println(sErr1 +\n//\n                    \"no Connector with IntegerArgument found\\n\");\n                return exitCode0;\n            }\n        }\n        if (intArgument.min() >= 0) {\n            i = -1;\n        } else {\n            i = 1;\n        }\n        check(intArgument.min(), out);\n        check(intArgument.max(), out);\n        if (intArgument.min() < intArgument.max()) {\n            check(intArgument.min() + 1, out);\n        }\n        if (intArgument.min() > intI.MIN_VALUE) {\n            check(intArgument.min() - 1, out);\n        }\n        if (intArgument.max() < intI.MAX_VALUE) {\n            check(intArgument.max() + 1, out);\n        }\n        if (exitCode != exitCode0) {\n            out.println(\"TEST FAILED\");\n        }\n        return exitCode;\n    }\n"]], "pred": {"ppl": 1.7787925004959106, "ppl_lower": 2.065742015838623, "ppl/lowercase_ppl": -1.2596730349116205, "ppl/zlib": 0.0006219597879035567, "Min_5.0% Prob": 5.612199376611149, "Min_10.0% Prob": 4.228918257881613, "Min_20.0% Prob": 2.6460156320941213, "Min_30.0% Prob": 1.873266878470876, "Min_40.0% Prob": 1.4276267902921056, "Min_50.0% Prob": 1.1497282374125346, "Min_60.0% Prob": 0.9602354085103261}}
{"hexsha": "a433ab62423bd8da6f23e8dcd35d13f267fb5c75", "ext": "java", "lang": "Java", "content": "public class ProjectComponent\n        extends AbstractComponent<IProjectComponent.Controller, HTMLElement>\n        implements IProjectComponent {\n\n    private HTMLDivElement element;\n\n    private FieldsGrouping fieldsGrouping = FieldsGrouping.create();\n    private TextBox groupIdTextBox;\n    private TextBox artifactIdTextBox;\n    private Select<String> gwtVersionSelect;\n    private Select<WidgetLibrary> widgetSetSelect;\n\n    public ProjectComponent() {\n    }\n\n    @Override\n    public void render() {\n\n        groupIdTextBox = TextBox.create(\"Group ID\")\n                .setPlaceholder(\"com.example\")\n                .value(\"com.example\")\n                .floating()\n                .setRequired(true)\n                .setAutoValidation(true)\n                .setLeftAddon(Icons.ALL.inbox())\n                .groupBy(fieldsGrouping);\n\n        artifactIdTextBox = TextBox.create(\"Artifact ID\")\n                .setPlaceholder(\"MyTestProject\")\n                .value(\"MyTestProject\")\n                .floating()\n                .setRequired(true)\n                .setAutoValidation(true)\n                .setLeftAddon(Icons.ALL.archive())\n                .groupBy(fieldsGrouping);\n\n        gwtVersionSelect = Select.<String>create(\"GWT Version\")\n                .appendChild(SelectOption.create(\"2.8.2\",\n                        \"2.8.2\"))\n                .selectAt(0)\n                .setLeftAddon(Icons.ALL.code())\n                .setRequired(true)\n                .setAutoValidation(true)\n                .groupBy(fieldsGrouping);\n\n        widgetSetSelect = Select.<WidgetLibrary>create(\"Widget Set\")\n                .appendChild(SelectOption.create(WidgetLibrary.DOMINO_UI,\n                        WidgetLibrary.DOMINO_UI.getText()))\n                .appendChild(SelectOption\n                        .create(WidgetLibrary.ELEMENTO,\n                                WidgetLibrary.ELEMENTO.getText()))\n                .appendChild(SelectOption.create(WidgetLibrary.GWT,\n                        WidgetLibrary.GWT.getText()))\n                .appendChild(SelectOption.create(WidgetLibrary.GXT,\n                        WidgetLibrary.GXT.getText()))\n                .selectAt(3)\n                .setLeftAddon(Icons.ALL.dashboard())\n                .setRequired(true)\n                .setAutoValidation(true)\n                .groupBy(fieldsGrouping);\n\n        this.element = div().asElement();\n        this.element.appendChild(Row.create()\n                .appendChild(Column.span6()\n                        .offset3()\n                        .appendChild(BlockHeader.create(\"Project Meta Data\"))\n                        .appendChild(Card.create()\n                                .styler(style -> style.setPaddingTop(\"20px\"))\n                                .appendChild(Row.create()\n                                        .appendChild(Column\n                                                .span6()\n                                                .appendChild(groupIdTextBox))\n                                        .appendChild(Column\n                                                .span6()\n                                                .appendChild(artifactIdTextBox)))\n                                .appendChild(Row.create()\n                                        .appendChild(Column\n                                                .span6()\n                                                .condenced()\n                                                .appendChild(gwtVersionSelect))\n                                        .appendChild(Column\n                                                .span6()\n                                                .condenced()\n                                                .appendChild(widgetSetSelect)))\n                        )\n                )\n                .asElement());\n        initElement(this.element);\n    }\n\n    @Override\n    public void edit(NaluGeneraterParms naluGeneraterParms) {\n        this.groupIdTextBox.setValue(naluGeneraterParms.getGroupId());\n        this.artifactIdTextBox.setValue(naluGeneraterParms.getArtefactId());\n        this.gwtVersionSelect.setValue(naluGeneraterParms.getGwtVersion());\n        this.widgetSetSelect.setValue(naluGeneraterParms.getWidgetLibrary());\n\n    }\n\n    @Override\n    public NaluGeneraterParms flush(NaluGeneraterParms naluGeneraterParms) {\n        naluGeneraterParms.setGroupId(this.groupIdTextBox.getValue());\n        naluGeneraterParms.setArtefactId(this.artifactIdTextBox.getValue());\n        naluGeneraterParms.setGwtVersion(this.gwtVersionSelect.getValue());\n        naluGeneraterParms.setWidgetLibrary(this.widgetSetSelect.getValue());\n        return naluGeneraterParms;\n    }\n}", "class_id": 0, "repo": "fworks/gwt-boot-starter-nalu", "file": "src/main/java/com/github/nalukit/gwtbootstarternalu/client/ui/content/splitter/project/ProjectComponent.java", "last_update_at": "2018-10-27T22:58:21+00:00", "question_id": "a433ab62423bd8da6f23e8dcd35d13f267fb5c75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ProjectComponent\n        extends AbstractComponent<IProjectComponent.Controller, HTMLElement>\n        implements IProjectComponent {\n    private HTMLDivElement element;\n    private FieldsGrouping fieldsGrouping = FieldsGrouping.create();\n    private TextBox groupIdTextBox;\n    private TextBox artifactIdTextBox;\n    private Select<String> gwtVersionSelect;\n    private Select<WidgetLibrary> widgetSetSelect;\n    public ProjectComponent() {\n    }\n    @Override\n    public void render() {\n        groupIdTextBox = TextBox.create(\"Group ID\")\n                .setPlaceholder(\"com.example\")\n                .value(\"com.example\")\n                .floating()\n                .setRequired(true)\n                .setAutoValidation(true)\n                .setLeftAddon(Icons.ALL.inbox())\n                .groupBy(fieldsGrouping);\n        artifactIdTextBox = TextBox.create(\"Artifact ID\")\n                .setPlaceholder(\"MyTestProject\")\n                .value(\"MyTestProject\")\n                .floating()\n                .setRequired(true)\n                .setAutoValidation(true)\n                .setLeftAddon(Icons.ALL.archive())\n                .groupBy(fieldsGrouping);\n        gwtVersionSelect = Select.<String>create(\"GWT Version\")\n                .appendChild(SelectOption.create(\"2.8.2\",\n                        \"2.8.2\"))\n                .selectAt(0)\n                .setLeftAddon(Icons.ALL.code())\n                .setRequired(true)\n                .setAutoValidation(true)\n                .groupBy(fieldsGrouping);\n        widgetSetSelect = Select.<WidgetLibrary>create(\"Widget Set\")\n                .appendChild(SelectOption.create(WidgetLibrary.DOMINO_UI,\n                        WidgetLibrary.DOMINO_UI.getText()))\n                .appendChild(SelectOption\n                        .create(WidgetLibrary.ELEMENTO,\n                                WidgetLibrary.ELEMENTO.getText()))\n                .appendChild(SelectOption.create(WidgetLibrary.GWT,\n                        WidgetLibrary.GWT.getText()))\n                .appendChild(SelectOption.create(WidgetLibrary.GXT,\n                        WidgetLibrary.GXT.getText()))\n                .selectAt(3)\n                .setLeftAddon(Icons.ALL.dashboard())\n                .setRequired(true)\n                .setAutoValidation(true)\n                .groupBy(fieldsGrouping);\n        this.element = div().asElement();\n        this.element.appendChild(Row.create()\n                .appendChild(Column.span6()\n                        .offset3()\n                        .appendChild(BlockHeader.create(\"Project Meta Data\"))\n                        .appendChild(Card.create()\n                                .styler(style -> style.setPaddingTop(\"20px\"))\n                                .appendChild(Row.create()\n                                        .appendChild(Column\n                                                .span6()\n                                                .appendChild(groupIdTextBox))\n                                        .appendChild(Column\n                                                .span6()\n                                                .appendChild(artifactIdTextBox)))\n                                .appendChild(Row.create()\n                                        .appendChild(Column\n                                                .span6()\n                                                .condenced()\n                                                .appendChild(gwtVersionSelect))\n                                        .appendChild(Column\n                                                .span6()\n                                                .condenced()\n                                                .appendChild(widgetSetSelect)))\n                        )\n                )\n                .asElement());\n        initElement(this.element);\n    }\n    @Override\n    public void edit(NaluGeneraterParms naluGeneraterParms) {\n        this.groupIdTextBox.setValue(naluGeneraterParms.getGroupId());\n        this.artifactIdTextBox.setValue(naluGeneraterParms.getArtefactId());\n        this.gwtVersionSelect.setValue(naluGeneraterParms.getGwtVersion());\n        this.widgetSetSelect.setValue(naluGeneraterParms.getWidgetLibrary());\n    }\n    @Override\n    public NaluGeneraterParms flush(NaluGeneraterParms naluGeneraterParms) {\n        naluGeneraterParms.setGroupId(this.groupIdTextBox.getValue());\n        naluGeneraterParms.setArtefactId(this.artifactIdTextBox.getValue());\n        naluGeneraterParms.setGwtVersion(this.gwtVersionSelect.getValue());\n        naluGeneraterParms.setWidgetLibrary(this.widgetSetSelect.getValue());\n        return naluGeneraterParms;\n    }\n"]], "pred": {"ppl": 1.6374882459640503, "ppl_lower": 2.0042805671691895, "ppl/lowercase_ppl": -1.4098471647788762, "ppl/zlib": 0.0005528738906550297, "Min_5.0% Prob": 5.853060787799311, "Min_10.0% Prob": 4.046368048471563, "Min_20.0% Prob": 2.379244793133408, "Min_30.0% Prob": 1.632838449166978, "Min_40.0% Prob": 1.2301193736197569, "Min_50.0% Prob": 0.9863646909641922, "Min_60.0% Prob": 0.8227437651441941}}
{"hexsha": "030929737e204476711efd5a116853803fa01711", "ext": "java", "lang": "Java", "content": "public class HibernateSessionConversationFilter\n        implements Filter {\n\n    private static Log log = LogFactory.getLog(HibernateSessionConversationFilter.class);\n\n    private SessionFactory sf;\n\n    public static final String HIBERNATE_SESSION_KEY = \"hibernateSession\";\n    public static final String END_OF_CONVERSATION_FLAG = \"endOfConversation\";\n\n    public void doFilter(ServletRequest request,\n                         ServletResponse response,\n                         FilterChain chain)\n            throws IOException, ServletException {\n\n        org.hibernate.classic.Session currentSession;\n\n        // Try to get a Hibernate Session from the HttpSession\n        HttpSession httpSession =\n                ((HttpServletRequest) request).getSession();\n        Session disconnectedSession =\n                (Session) httpSession.getAttribute(HIBERNATE_SESSION_KEY);\n\n        try {\n\n            // Start a new conversation or in the middle?\n            if (disconnectedSession == null) {\n                log.debug(\">>> New conversation\");\n                log.debug(\"Opening Session, disabling automatic flushing\");\n                currentSession = sf.openSession();\n                currentSession.setFlushMode(FlushMode.MANUAL);\n            } else {\n                log.debug(\"< Continuing conversation\");\n                currentSession = (org.hibernate.classic.Session) disconnectedSession;\n            }\n\n            log.debug(\"Binding the current Session\");\n            ManagedSessionContext.bind(currentSession);\n\n            log.debug(\"Starting a database transaction\");\n            currentSession.beginTransaction();\n\n            log.debug(\"Processing the event\");\n            chain.doFilter(request, response);\n\n            log.debug(\"Unbinding Session after processing\");\n            currentSession = ManagedSessionContext.unbind(sf);\n\n            // End or continue the long-running conversation?\n            if (request.getAttribute(END_OF_CONVERSATION_FLAG) != null ||\n                request.getParameter(END_OF_CONVERSATION_FLAG) != null) {\n\n                log.debug(\"Flushing Session\");\n                currentSession.flush();\n\n                log.debug(\"Committing the database transaction\");\n                currentSession.getTransaction().commit();\n\n                log.debug(\"Closing the Session\");\n                currentSession.close();\n\n                log.debug(\"Cleaning Session from HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);\n\n                log.debug(\"<<< End of conversation\");\n\n            } else {\n\n                log.debug(\"Committing database transaction\");\n                currentSession.getTransaction().commit();\n\n                log.debug(\"Storing Session in the HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, currentSession);\n\n                log.debug(\"> Returning to user in conversation\");\n            }\n\n        } catch (StaleObjectStateException staleEx) {\n            log.error(\"This interceptor does not implement optimistic concurrency control!\");\n            log.error(\"Your application will not work until you add compensation actions!\");\n            // Rollback, close everything, possibly compensate for any permanent changes\n            // during the conversation, and finally restart business conversation. Maybe\n            // give the user of the application a chance to merge some of his work with\n            // fresh data... what you do here depends on your applications design.\n            throw staleEx;\n        } catch (Throwable ex) {\n            // Rollback only\n            try {\n                if (sf.getCurrentSession().getTransaction().isActive()) {\n                    log.debug(\"Trying to rollback database transaction after exception\");\n                    sf.getCurrentSession().getTransaction().rollback();\n                }\n            } catch (Throwable rbEx) {\n                log.error(\"Could not rollback transaction after exception!\", rbEx);\n            } finally {\n                log.error(\"Cleanup after exception!\");\n\n                // Cleanup\n                log.debug(\"Unbinding Session after exception\");\n                currentSession = ManagedSessionContext.unbind(sf);\n\n                log.debug(\"Closing Session after exception\");\n                currentSession.close();\n\n                log.debug(\"Removing Session from HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);\n\n            }\n\n            // Let others handle it... maybe another interceptor for exceptions?\n            throw new ServletException(ex);\n        }\n\n    }\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        log.debug(\"Initializing filter...\");\n        log.debug(\"Obtaining SessionFactory from HibernateUtil\");\n        sf = HibernateUtil.getSessionFactory();\n    }\n\n    public void destroy() {}\n\n}", "class_id": 0, "repo": "lihongjie/tutorials", "file": "hibernate-lihongjie/CaveatEmptor/src/main/java/org/hibernate/caveatemptor/tutorial4/auction/web/filter/HibernateSessionConversationFilter.java", "last_update_at": "2018-04-01T06:27:14+00:00", "question_id": "030929737e204476711efd5a116853803fa01711", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class HibernateSessionConversationFilter\n        implements Filter {\n    private static Log log = LogFactory.getLog(HibernateSessionConversationFilter.class);\n    private SessionFactory sf;\n    public static final String HIBERNATE_SESSION_KEY = \"hibernateSession\";\n    public static final String END_OF_CONVERSATION_FLAG = \"endOfConversation\";\n    public void doFilter(ServletRequest request,\n                         ServletResponse response,\n                         FilterChain chain)\n            throws IOException, ServletException {\n        org.hibernate.classic.Session currentSession;\n        // Try to get a Hibernate Session from the HttpSession\n        HttpSession httpSession =\n                ((HttpServletRequest) request).getSession();\n        Session disconnectedSession =\n                (Session) httpSession.getAttribute(HIBERNATE_SESSION_KEY);\n        try {\n            // Start a new conversation or in the middle?\n            if (disconnectedSession == null) {\n                log.debug(\">>> New conversation\");\n                log.debug(\"Opening Session, disabling automatic flushing\");\n                currentSession = sf.openSession();\n                currentSession.setFlushMode(FlushMode.MANUAL);\n            } else {\n                log.debug(\"< Continuing conversation\");\n                currentSession = (org.hibernate.classic.Session) disconnectedSession;\n            }\n            log.debug(\"Binding the current Session\");\n            ManagedSessionContext.bind(currentSession);\n            log.debug(\"Starting a database transaction\");\n            currentSession.beginTransaction();\n            log.debug(\"Processing the event\");\n            chain.doFilter(request, response);\n            log.debug(\"Unbinding Session after processing\");\n            currentSession = ManagedSessionContext.unbind(sf);\n            // End or continue the long-running conversation?\n            if (request.getAttribute(END_OF_CONVERSATION_FLAG) != null ||\n                request.getParameter(END_OF_CONVERSATION_FLAG) != null) {\n                log.debug(\"Flushing Session\");\n                currentSession.flush();\n                log.debug(\"Committing the database transaction\");\n                currentSession.getTransaction().commit();\n                log.debug(\"Closing the Session\");\n                currentSession.close();\n                log.debug(\"Cleaning Session from HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);\n                log.debug(\"<<< End of conversation\");\n            } else {\n                log.debug(\"Committing database transaction\");\n                currentSession.getTransaction().commit();\n                log.debug(\"Storing Session in the HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, currentSession);\n                log.debug(\"> Returning to user in conversation\");\n            }\n        } catch (StaleObjectStateException staleEx) {\n            log.error(\"This interceptor does not implement optimistic concurrency control!\");\n            log.error(\"Your application will not work until you add compensation actions!\");\n            // Rollback, close everything, possibly compensate for any permanent changes\n            // during the conversation, and finally restart business conversation. Maybe\n            // give the user of the application a chance to merge some of his work with\n            // fresh data... what you do here depends on your applications design.\n            throw staleEx;\n        } catch (Throwable ex) {\n            // Rollback only\n            try {\n                if (sf.getCurrentSession().getTransaction().isActive()) {\n                    log.debug(\"Trying to rollback database transaction after exception\");\n                    sf.getCurrentSession().getTransaction().rollback();\n                }\n            } catch (Throwable rbEx) {\n                log.error(\"Could not rollback transaction after exception!\", rbEx);\n            } finally {\n                log.error(\"Cleanup after exception!\");\n                // Cleanup\n                log.debug(\"Unbinding Session after exception\");\n                currentSession = ManagedSessionContext.unbind(sf);\n                log.debug(\"Closing Session after exception\");\n                currentSession.close();\n                log.debug(\"Removing Session from HttpSession\");\n                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);\n            }\n            // Let others handle it... maybe another interceptor for exceptions?\n            throw new ServletException(ex);\n        }\n    }\n    public void init(FilterConfig filterConfig) throws ServletException {\n        log.debug(\"Initializing filter...\");\n        log.debug(\"Obtaining SessionFactory from HibernateUtil\");\n        sf = HibernateUtil.getSessionFactory();\n    }\n    public void destroy() {}\n"]], "pred": {"ppl": 2.258333444595337, "ppl_lower": 2.4960813522338867, "ppl/lowercase_ppl": -1.1228720629243876, "ppl/zlib": 0.0005789816114889564, "Min_5.0% Prob": 6.76009381051157, "Min_10.0% Prob": 5.314821329771304, "Min_20.0% Prob": 3.59894383596439, "Min_30.0% Prob": 2.610797101181317, "Min_40.0% Prob": 2.0114946327830294, "Min_50.0% Prob": 1.6257237207632942, "Min_60.0% Prob": 1.358465012009476}}
{"hexsha": "00a232d9fd27d4eaad8be822976f3b8122583428", "ext": "java", "lang": "Java", "content": "public class SocketOptionTests {\n\n    static <T> void checkOption(DatagramChannel dc,\n                                SocketOption<T> name,\n                                T expectedValue)\n        throws IOException\n    {\n        T value = dc.getOption(name);\n        if (!value.equals(expectedValue))\n            throw new RuntimeException(\"value not as expected\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        DatagramChannel dc = DatagramChannel.open();\n\n        // check supported options\n        Set<SocketOption<?>> options = dc.supportedOptions();\n        boolean reuseport = options.contains(SO_REUSEPORT);\n        List<? extends SocketOption<?>> expected;\n        if (reuseport) {\n           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,\n                      SO_REUSEADDR, SO_REUSEPORT, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF,\n                      IP_MULTICAST_TTL, IP_MULTICAST_LOOP);\n        } else {\n           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,\n                      SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL,\n                      IP_MULTICAST_LOOP);\n        }\n        for (SocketOption opt: expected) {\n            if (!options.contains(opt))\n                throw new RuntimeException(opt.name() + \" should be supported\");\n        }\n\n        // check specified defaults\n        checkOption(dc, SO_BROADCAST, false);\n        checkOption(dc, IP_MULTICAST_TTL, 1);           // true on supported platforms\n        checkOption(dc, IP_MULTICAST_LOOP, true);       // true on supported platforms\n\n        // allowed to change when not bound\n        dc.setOption(SO_BROADCAST, true);\n        checkOption(dc, SO_BROADCAST, true);\n        dc.setOption(SO_BROADCAST, false);\n        checkOption(dc, SO_BROADCAST, false);\n        dc.setOption(SO_SNDBUF, 128*1024);       // can't check\n        dc.setOption(SO_RCVBUF, 128*1024);       // can't check\n        int before, after;\n        before = dc.getOption(SO_SNDBUF);\n        after = dc.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);\n        if (after < before)\n            throw new RuntimeException(\"setOption caused SO_SNDBUF to decrease\");\n        before = dc.getOption(SO_RCVBUF);\n        after = dc.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);\n        if (after < before)\n            throw new RuntimeException(\"setOption caused SO_RCVBUF to decrease\");\n        dc.setOption(SO_REUSEADDR, true);\n        checkOption(dc, SO_REUSEADDR, true);\n        dc.setOption(SO_REUSEADDR, false);\n        checkOption(dc, SO_REUSEADDR, false);\n        if (reuseport) {\n            dc.setOption(SO_REUSEPORT, true);\n            checkOption(dc, SO_REUSEPORT, true);\n            dc.setOption(SO_REUSEPORT, false);\n            checkOption(dc, SO_REUSEPORT, false);\n        }\n        // bind socket\n        dc.bind(new InetSocketAddress(0));\n\n        // allow to change when bound\n        dc.setOption(SO_BROADCAST, true);\n        checkOption(dc, SO_BROADCAST, true);\n        dc.setOption(SO_BROADCAST, false);\n        checkOption(dc, SO_BROADCAST, false);\n        dc.setOption(IP_TOS, 0x08);     // can't check\n        dc.setOption(IP_MULTICAST_TTL, 2);\n        checkOption(dc, IP_MULTICAST_TTL, 2);\n        dc.setOption(IP_MULTICAST_LOOP, false);\n        checkOption(dc, IP_MULTICAST_LOOP, false);\n        dc.setOption(IP_MULTICAST_LOOP, true);\n        checkOption(dc, IP_MULTICAST_LOOP, true);\n\n\n        // NullPointerException\n        try {\n            dc.setOption(null, \"value\");\n            throw new RuntimeException(\"NullPointerException not thrown\");\n        } catch (NullPointerException x) {\n        }\n        try {\n            dc.getOption(null);\n            throw new RuntimeException(\"NullPointerException not thrown\");\n        } catch (NullPointerException x) {\n        }\n\n        // ClosedChannelException\n        dc.close();\n        try {\n            dc.setOption(IP_MULTICAST_LOOP, true);\n            throw new RuntimeException(\"ClosedChannelException not thrown\");\n        } catch (ClosedChannelException x) {\n        }\n    }\n}", "class_id": 0, "repo": "iootclab/openjdk", "file": "openjdk11/test/jdk/java/nio/channels/DatagramChannel/SocketOptionTests.java", "last_update_at": "2018-06-23T10:04:56+00:00", "question_id": "00a232d9fd27d4eaad8be822976f3b8122583428", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class SocketOptionTests {\n    static <T> void checkOption(DatagramChannel dc,\n                                SocketOption<T> name,\n                                T expectedValue)\n        throws IOException\n    {\n        T value = dc.getOption(name);\n        if (!value.equals(expectedValue))\n            throw new RuntimeException(\"value not as expected\");\n    }\n    public static void main(String[] args) throws IOException {\n        DatagramChannel dc = DatagramChannel.open();\n        // check supported options\n        Set<SocketOption<?>> options = dc.supportedOptions();\n        boolean reuseport = options.contains(SO_REUSEPORT);\n        List<? extends SocketOption<?>> expected;\n        if (reuseport) {\n           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,\n                      SO_REUSEADDR, SO_REUSEPORT, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF,\n                      IP_MULTICAST_TTL, IP_MULTICAST_LOOP);\n        } else {\n           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,\n                      SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL,\n                      IP_MULTICAST_LOOP);\n        }\n        for (SocketOption opt: expected) {\n            if (!options.contains(opt))\n                throw new RuntimeException(opt.name() + \" should be supported\");\n        }\n        // check specified defaults\n        checkOption(dc, SO_BROADCAST, false);\n        checkOption(dc, IP_MULTICAST_TTL, 1);           // true on supported platforms\n        checkOption(dc, IP_MULTICAST_LOOP, true);       // true on supported platforms\n        // allowed to change when not bound\n        dc.setOption(SO_BROADCAST, true);\n        checkOption(dc, SO_BROADCAST, true);\n        dc.setOption(SO_BROADCAST, false);\n        checkOption(dc, SO_BROADCAST, false);\n        dc.setOption(SO_SNDBUF, 128*1024);       // can't check\n        dc.setOption(SO_RCVBUF, 128*1024);       // can't check\n        int before, after;\n        before = dc.getOption(SO_SNDBUF);\n        after = dc.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);\n        if (after < before)\n            throw new RuntimeException(\"setOption caused SO_SNDBUF to decrease\");\n        before = dc.getOption(SO_RCVBUF);\n        after = dc.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);\n        if (after < before)\n            throw new RuntimeException(\"setOption caused SO_RCVBUF to decrease\");\n        dc.setOption(SO_REUSEADDR, true);\n        checkOption(dc, SO_REUSEADDR, true);\n        dc.setOption(SO_REUSEADDR, false);\n        checkOption(dc, SO_REUSEADDR, false);\n        if (reuseport) {\n            dc.setOption(SO_REUSEPORT, true);\n            checkOption(dc, SO_REUSEPORT, true);\n            dc.setOption(SO_REUSEPORT, false);\n            checkOption(dc, SO_REUSEPORT, false);\n        }\n        // bind socket\n        dc.bind(new InetSocketAddress(0));\n        // allow to change when bound\n        dc.setOption(SO_BROADCAST, true);\n        checkOption(dc, SO_BROADCAST, true);\n        dc.setOption(SO_BROADCAST, false);\n        checkOption(dc, SO_BROADCAST, false);\n        dc.setOption(IP_TOS, 0x08);     // can't check\n        dc.setOption(IP_MULTICAST_TTL, 2);\n        checkOption(dc, IP_MULTICAST_TTL, 2);\n        dc.setOption(IP_MULTICAST_LOOP, false);\n        checkOption(dc, IP_MULTICAST_LOOP, false);\n        dc.setOption(IP_MULTICAST_LOOP, true);\n        checkOption(dc, IP_MULTICAST_LOOP, true);\n        // NullPointerException\n        try {\n            dc.setOption(null, \"value\");\n            throw new RuntimeException(\"NullPointerException not thrown\");\n        } catch (NullPointerException x) {\n        }\n        try {\n            dc.getOption(null);\n            throw new RuntimeException(\"NullPointerException not thrown\");\n        } catch (NullPointerException x) {\n        }\n        // ClosedChannelException\n        dc.close();\n        try {\n            dc.setOption(IP_MULTICAST_LOOP, true);\n            throw new RuntimeException(\"ClosedChannelException not thrown\");\n        } catch (ClosedChannelException x) {\n        }\n    }\n"]], "pred": {"ppl": 1.4810961484909058, "ppl_lower": 1.5959105491638184, "ppl/lowercase_ppl": -1.190084855371755, "ppl/zlib": 0.0004187446210118947, "Min_5.0% Prob": 5.129983691608205, "Min_10.0% Prob": 3.3755151652822306, "Min_20.0% Prob": 1.9157989939638214, "Min_30.0% Prob": 1.306133545448188, "Min_40.0% Prob": 0.9813384587505336, "Min_50.0% Prob": 0.7861290193568832, "Min_60.0% Prob": 0.6554485356540485}}
{"hexsha": "a38a856f22fdfa10638a66be1fb80061baeefb3a", "ext": "java", "lang": "Java", "content": "@RunWith(SpringRunner.class)\n@SpringBootTest\n@ContextConfiguration(locations = \"classpath*:/applicationTest.xml\")\npublic class Test {\n\n    @org.junit.Test\n    public void testKeyCount() {\n        try {\n            BufferedReader bufferedReader = new BufferedReader(new FileReader(\"G:\\\\Intellij\\\\TPCDSkew\\\\lineitem.tbl\"));\n            String line = null;\n            Map<String, Integer> map = new HashMap<>();\n            while ((line = bufferedReader.readLine()) != null) {\n                String[] splits = line.split(\"\\\\|\");\n                String key = splits[2];\n                map.put(key, map.getOrDefault(key, 0) + 1);\n            }\n            int maxCount = Integer.MIN_VALUE;\n            String maxCountKey = null;\n            int minCount = Integer.MAX_VALUE;\n            String minCountKey = null;\n            for (Map.Entry<String, Integer> entry : map.entrySet()) {\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\n                if (entry.getValue() > maxCount) {\n                    maxCount = entry.getValue();\n                    maxCountKey = entry.getKey();\n                }\n                if (entry.getValue() < minCount) {\n                    minCount = entry.getValue();\n                    minCountKey = entry.getKey();\n                }\n            }\n            System.out.println(\"=============================================\");\n            System.out.println(maxCountKey + \": \" + maxCount);\n            System.out.println(minCountKey + \": \" + minCount);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @org.junit.Test\n    public void generateFile() {\n        int MAX = 8000000;\n        Random random = new Random();\n        try {\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(\"E:\\\\TPCH_DATA\\\\KeyWord.txt\"));\n            int i = 0;\n            while (i < MAX) {\n                StringBuilder stringBuilder = new StringBuilder();\n                for (int j = 0; j < 20; j++) {\n                    if (j != 19) {\n                        stringBuilder.append(\"key\" + \"_\" + random.nextInt(MAX) + \" \");\n                    } else {\n                        stringBuilder.append(\"key\" + \"_\" + random.nextInt(MAX));\n                    }\n                }\n                bufferedWriter.write(stringBuilder.toString());\n                bufferedWriter.newLine();\n                i++;\n                if (i % 1000 == 0) {\n                    bufferedWriter.flush();\n                }\n            }\n            bufferedWriter.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "class_id": 0, "repo": "dmy1115143060/graduation-project", "file": "graduation-project-core/src/test/main/java/com/dmy/graduation/core/Test.java", "last_update_at": "2018-10-10T12:49:57+00:00", "question_id": "a38a856f22fdfa10638a66be1fb80061baeefb3a", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@RunWith(SpringRunner.class)\n@SpringBootTest\n@ContextConfiguration(locations = \"classpath*:/applicationTest.xml\")\npublic class Test {\n    @org.junit.Test\n    public void testKeyCount() {\n        try {\n            BufferedReader bufferedReader = new BufferedReader(new FileReader(\"G:\\\\Intellij\\\\TPCDSkew\\\\lineitem.tbl\"));\n            String line = null;\n            Map<String, Integer> map = new HashMap<>();\n            while ((line = bufferedReader.readLine()) != null) {\n                String[] splits = line.split(\"\\\\|\");\n                String key = splits[2];\n                map.put(key, map.getOrDefault(key, 0) + 1);\n            }\n            int maxCount = Integer.MIN_VALUE;\n            String maxCountKey = null;\n            int minCount = Integer.MAX_VALUE;\n            String minCountKey = null;\n            for (Map.Entry<String, Integer> entry : map.entrySet()) {\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\n                if (entry.getValue() > maxCount) {\n                    maxCount = entry.getValue();\n                    maxCountKey = entry.getKey();\n                }\n                if (entry.getValue() < minCount) {\n                    minCount = entry.getValue();\n                    minCountKey = entry.getKey();\n                }\n            }\n            System.out.println(\"=============================================\");\n            System.out.println(maxCountKey + \": \" + maxCount);\n            System.out.println(minCountKey + \": \" + minCount);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    @org.junit.Test\n    public void generateFile() {\n        int MAX = 8000000;\n        Random random = new Random();\n        try {\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(\"E:\\\\TPCH_DATA\\\\KeyWord.txt\"));\n            int i = 0;\n            while (i < MAX) {\n                StringBuilder stringBuilder = new StringBuilder();\n                for (int j = 0; j < 20; j++) {\n                    if (j != 19) {\n                        stringBuilder.append(\"key\" + \"_\" + random.nextInt(MAX) + \" \");\n                    } else {\n                        stringBuilder.append(\"key\" + \"_\" + random.nextInt(MAX));\n                    }\n                }\n                bufferedWriter.write(stringBuilder.toString());\n                bufferedWriter.newLine();\n                i++;\n                if (i % 1000 == 0) {\n                    bufferedWriter.flush();\n                }\n            }\n            bufferedWriter.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n"]], "pred": {"ppl": 1.611388087272644, "ppl_lower": 1.8181533813476562, "ppl/lowercase_ppl": -1.2530421414437116, "ppl/zlib": 0.0005875566176756147, "Min_5.0% Prob": 5.586297427906709, "Min_10.0% Prob": 3.97113434882725, "Min_20.0% Prob": 2.285458254988176, "Min_30.0% Prob": 1.5733917529990034, "Min_40.0% Prob": 1.1877581487226225, "Min_50.0% Prob": 0.954235593716162, "Min_60.0% Prob": 0.7948091378619038}}
{"hexsha": "824135b9f6a04e10e994a5ef11d8d24cfa8c6860", "ext": "java", "lang": "Java", "content": "public class ItemDetailFragment extends Fragment {\n    /**\n     * The fragment argument representing the item ID that this fragment\n     * represents.\n     */\n    public static final String ARG_ITEM_ID = \"item_id\";\n\n    /**\n     * The dummy content this fragment is presenting.\n     */\n    private DummyContent.DummyItem mItem;\n\n    /**\n     * Mandatory empty constructor for the fragment manager to instantiate the\n     * fragment (e.g. upon screen orientation changes).\n     */\n    public ItemDetailFragment() {\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (getArguments().containsKey(ARG_ITEM_ID)) {\n            // Load the dummy content specified by the fragment\n            // arguments. In a real-world scenario, use a Loader\n            // to load content from a content provider.\n            mItem = DummyContent.ITEM_MAP.get(getArguments().getString(ARG_ITEM_ID));\n\n            Activity activity = this.getActivity();\n            CollapsingToolbarLayout appBarLayout = (CollapsingToolbarLayout) activity.findViewById(R.id.toolbar_layout);\n            if (appBarLayout != null) {\n                appBarLayout.setTitle(mItem.content);\n            }\n        }\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_item_detail, container, false);\n\n        // Show the dummy content as text in a TextView.\n        if (mItem != null) {\n            String rf= readFile((Environment.getExternalStorageDirectory().getPath() + \"/downloadhtml/\"  + mItem.content));\n            ((TextView) rootView.findViewById(R.id.item_detail)).setText(Html.fromHtml(rf));\n\n        }\n\n        return rootView;\n    }\n    public static String readFile(String path){\n        String res=\"\";\n        try{\n            FileInputStream fin = new FileInputStream(path);\n\n            int length = fin.available();\n\n            byte [] buffer = new byte[length];\n            fin.read(buffer);\n\n            res = EncodingUtils.getString(buffer, \"UTF-8\");\n\n            fin.close();\n        }\n\n        catch(Exception e){\n            e.printStackTrace();\n        }\n\n        return res;\n    }\n}", "class_id": 0, "repo": "maozhuren/WHU_OpenSource_Project", "file": "BaseVersion/src/article2/ItemDetailFragment.java", "last_update_at": "2018-12-25T02:42:37+00:00", "question_id": "824135b9f6a04e10e994a5ef11d8d24cfa8c6860", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public class ItemDetailFragment extends Fragment {\n    /**\n     * The fragment argument representing the item ID that this fragment\n     * represents.\n     */\n    public static final String ARG_ITEM_ID = \"item_id\";\n    /**\n     * The dummy content this fragment is presenting.\n     */\n    private DummyContent.DummyItem mItem;\n    /**\n     * Mandatory empty constructor for the fragment manager to instantiate the\n     * fragment (e.g. upon screen orientation changes).\n     */\n    public ItemDetailFragment() {\n    }\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (getArguments().containsKey(ARG_ITEM_ID)) {\n            // Load the dummy content specified by the fragment\n            // arguments. In a real-world scenario, use a Loader\n            // to load content from a content provider.\n            mItem = DummyContent.ITEM_MAP.get(getArguments().getString(ARG_ITEM_ID));\n            Activity activity = this.getActivity();\n            CollapsingToolbarLayout appBarLayout = (CollapsingToolbarLayout) activity.findViewById(R.id.toolbar_layout);\n            if (appBarLayout != null) {\n                appBarLayout.setTitle(mItem.content);\n            }\n        }\n    }\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_item_detail, container, false);\n        // Show the dummy content as text in a TextView.\n        if (mItem != null) {\n            String rf= readFile((Environment.getExternalStorageDirectory().getPath() + \"/downloadhtml/\"  + mItem.content));\n            ((TextView) rootView.findViewById(R.id.item_detail)).setText(Html.fromHtml(rf));\n        }\n        return rootView;\n    }\n    public static String readFile(String path){\n        String res=\"\";\n        try{\n            FileInputStream fin = new FileInputStream(path);\n            int length = fin.available();\n            byte [] buffer = new byte[length];\n            fin.read(buffer);\n            res = EncodingUtils.getString(buffer, \"UTF-8\");\n            fin.close();\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n        return res;\n    }\n"]], "pred": {"ppl": 1.3018128871917725, "ppl_lower": 1.694070816040039, "ppl/lowercase_ppl": -1.99855456853229, "ppl/zlib": 0.0002848356605016914, "Min_5.0% Prob": 4.095639664551308, "Min_10.0% Prob": 2.4627137821296166, "Min_20.0% Prob": 1.3084111823421767, "Min_30.0% Prob": 0.8766434804419987, "Min_40.0% Prob": 0.6607606616388593, "Min_50.0% Prob": 0.5281642526201427, "Min_60.0% Prob": 0.4397747512092048}}
{"hexsha": "3878019c50fb9aafad81e397489e5136cdb3ec05", "ext": "java", "lang": "Java", "content": "@Controller\n@Slf4j\npublic class IndexController extends AbstractController {\n\t@Autowired\n\tprivate ArticleService articleService;\n\t@Autowired\n\tprivate PeriodicalService periodicalService;\n\t@RequestMapping(value={\"/index\",\"/\",\"\"},method = RequestMethod.GET)\n\tpublic ModelAndView welcome(HttpServletRequest request, HttpServletResponse response,\n\t\t\t\t\t\t\t\tModelMap model) {\n\t\tarticlesTop10(request,model);\n\t\tdocsTop10(request,model);\n\t\tsuper.success(model);\n\t\treturn new ModelAndView(\"index\");\n\t}\n\tpublic void articlesTop10(HttpServletRequest request,ModelMap model){\n\t\tfinal Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);\n\t\tfilters.add(new SearchFilter(\"isPub\", SearchFilter.Operator.EQ,Boolean.TRUE));\n\t\tSpecification<Article> spec= DynamicSpecifications.bySearchFilter(filters, Article.class);\n\t\tPageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,10, \"pushTime\",CommonConst.Page.ORDER_DESC,Article.class);\n\t\tPage<Article> pag = this.articleService.findAll(spec, pageRequest);\n\t\tif(pag!=null&&pag.hasContent()){\n\t\t\tList<ArticleVO> vos = Lists.newArrayList();\n\t\t\tfor(Article po:pag.getContent()){\n\t\t\t\tvos.add(new ArticleVO(po));\n\t\t\t}\n\t\t\tPage<ArticleVO> docVos  =new PageImpl<ArticleVO>(vos,pageRequest,pag.getTotalElements());\n\t\t\tmodel.put(\"articles\",docVos);\n\t\t}\n\t}\n\n\tpublic void docsTop10(HttpServletRequest request,ModelMap model){\n\t\tfinal Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);\n\t\tfilters.add(new SearchFilter(\"isPub\", SearchFilter.Operator.EQ,Boolean.TRUE));\n\t\tSpecification<Periodical> spec= DynamicSpecifications.bySearchFilter(filters, Periodical.class);\n\t\tPageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,5, \"pushTime\",CommonConst.Page.ORDER_DESC,Periodical.class);\n\t\tPage<Periodical> pag = this.periodicalService.findAll(spec, pageRequest);\n\t\tif(pag!=null&&pag.hasContent()){\n\t\t\tList<PeriodicalVO> vos = Lists.newArrayList();\n\t\t\tfor(Periodical po:pag.getContent()){\n\t\t\t\tvos.add(new PeriodicalVO(po));\n\t\t\t}\n\t\t\tPage<PeriodicalVO> docVos  =new PageImpl<PeriodicalVO>(vos,pageRequest,pag.getTotalElements());\n\t\t\tmodel.put(\"docs\",docVos);\n\t\t}\n\t}\n\n}", "class_id": 0, "repo": "LKG/lore", "file": "lore-web/src/main/java/im/heart/front/web/IndexController.java", "last_update_at": "2018-12-16T16:08:35+00:00", "question_id": "3878019c50fb9aafad81e397489e5136cdb3ec05", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Controller\n@Slf4j\npublic class IndexController extends AbstractController {\n\t@Autowired\n\tprivate ArticleService articleService;\n\t@Autowired\n\tprivate PeriodicalService periodicalService;\n\t@RequestMapping(value={\"/index\",\"/\",\"\"},method = RequestMethod.GET)\n\tpublic ModelAndView welcome(HttpServletRequest request, HttpServletResponse response,\n\t\t\t\t\t\t\t\tModelMap model) {\n\t\tarticlesTop10(request,model);\n\t\tdocsTop10(request,model);\n\t\tsuper.success(model);\n\t\treturn new ModelAndView(\"index\");\n\t}\n\tpublic void articlesTop10(HttpServletRequest request,ModelMap model){\n\t\tfinal Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);\n\t\tfilters.add(new SearchFilter(\"isPub\", SearchFilter.Operator.EQ,Boolean.TRUE));\n\t\tSpecification<Article> spec= DynamicSpecifications.bySearchFilter(filters, Article.class);\n\t\tPageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,10, \"pushTime\",CommonConst.Page.ORDER_DESC,Article.class);\n\t\tPage<Article> pag = this.articleService.findAll(spec, pageRequest);\n\t\tif(pag!=null&&pag.hasContent()){\n\t\t\tList<ArticleVO> vos = Lists.newArrayList();\n\t\t\tfor(Article po:pag.getContent()){\n\t\t\t\tvos.add(new ArticleVO(po));\n\t\t\t}\n\t\t\tPage<ArticleVO> docVos  =new PageImpl<ArticleVO>(vos,pageRequest,pag.getTotalElements());\n\t\t\tmodel.put(\"articles\",docVos);\n\t\t}\n\t}\n\tpublic void docsTop10(HttpServletRequest request,ModelMap model){\n\t\tfinal Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);\n\t\tfilters.add(new SearchFilter(\"isPub\", SearchFilter.Operator.EQ,Boolean.TRUE));\n\t\tSpecification<Periodical> spec= DynamicSpecifications.bySearchFilter(filters, Periodical.class);\n\t\tPageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,5, \"pushTime\",CommonConst.Page.ORDER_DESC,Periodical.class);\n\t\tPage<Periodical> pag = this.periodicalService.findAll(spec, pageRequest);\n\t\tif(pag!=null&&pag.hasContent()){\n\t\t\tList<PeriodicalVO> vos = Lists.newArrayList();\n\t\t\tfor(Periodical po:pag.getContent()){\n\t\t\t\tvos.add(new PeriodicalVO(po));\n\t\t\t}\n\t\t\tPage<PeriodicalVO> docVos  =new PageImpl<PeriodicalVO>(vos,pageRequest,pag.getTotalElements());\n\t\t\tmodel.put(\"docs\",docVos);\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.6564257144927979, "ppl_lower": 2.098357677459717, "ppl/lowercase_ppl": -1.4686162978570803, "ppl/zlib": 0.0007367329881668584, "Min_5.0% Prob": 6.40911717414856, "Min_10.0% Prob": 4.328119587898255, "Min_20.0% Prob": 2.4584881376924246, "Min_30.0% Prob": 1.6700311640172072, "Min_40.0% Prob": 1.2614560900454193, "Min_50.0% Prob": 1.0096010171884813, "Min_60.0% Prob": 0.8411705404990089}}
