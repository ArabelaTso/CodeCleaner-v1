{"hexsha": "ebdb49a6cffa0ebfe8908bf7815a1da35edab563", "ext": "c", "lang": "C", "content": "char* intToCharString(int num) {\n    char* str = malloc(sizeof(char) * 3);\n    // sprintf(str, \"%d\", num);\n    // convert 123 to string [buf]\n    itoa(num, str, 10);\n    return str;\n}", "item_id": 0, "repo": "liudonghua123/gtk-game-24", "file": "game.c", "last_update_at": "2019-06-05T10:53:11+00:00", "question_id": "ebdb49a6cffa0ebfe8908bf7815a1da35edab563_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* intToCharString(int num) {\n    char* str = malloc(sizeof(char) * 3);\n    // sprintf(str, \"%d\", num);\n    // convert 123 to string [buf]\n    itoa(num, str, 10);\n    return str;\n"]], "pred": {"ppl": 3.895979166030884, "ppl_lower": 4.160628318786621, "ppl/lowercase_ppl": -1.0483262638945212, "ppl/zlib": 0.009314692042725914, "Min_5.0% Prob": 9.000089963277182, "Min_10.0% Prob": 7.256430285317557, "Min_20.0% Prob": 5.405673469815936, "Min_30.0% Prob": 4.1392060575031095, "Min_40.0% Prob": 3.227093225923078, "Min_50.0% Prob": 2.693358672161897, "Min_60.0% Prob": 2.283743313578672}}
{"hexsha": "556c859d997160ae76cfb1aa82987689e08a029d", "ext": "h", "lang": "C", "content": "void\nHourlyWorker::NewWeek()\n{\n    float hours;\n\n    hours = 44; // ( float(rand()) / float(RAND_MAX) ) * 80.0;\n\n    SetThisWeekHours(hours);\n}", "item_id": 1, "repo": "nettrino/IntFlow", "file": "projects/test-suite/MultiSource/Benchmarks/Prolangs-C++/employ/hourly.h", "last_update_at": "2019-07-20T14:46:20+00:00", "question_id": "556c859d997160ae76cfb1aa82987689e08a029d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nHourlyWorker::NewWeek()\n{\n    float hours;\n    hours = 44; // ( float(rand()) / float(RAND_MAX) ) * 80.0;\n    SetThisWeekHours(hours);\n"]], "pred": {"ppl": 7.613793849945068, "ppl_lower": 13.256771087646484, "ppl/lowercase_ppl": -1.2731809654504076, "ppl/zlib": 0.016776542003816387, "Min_5.0% Prob": 7.814611752827962, "Min_10.0% Prob": 7.472844044367473, "Min_20.0% Prob": 6.697625080744426, "Min_30.0% Prob": 5.464742170439826, "Min_40.0% Prob": 4.614768172303836, "Min_50.0% Prob": 3.855077653161941, "Min_60.0% Prob": 3.3413197623716817}}
{"hexsha": "45f71467c52c44cc66ec47b84bc6c32ffcb7d2ba", "ext": "c", "lang": "C", "content": "double v_rasqal_sparql_xml_start( float parameter_1)\r\n{\r\n\tint int_1 = 1;\r\n\tint int_2 = 1;\r\n\tchar char_1 = 1;\r\n\tchar char_2 = 1;\r\n\tlong long_1 = 1;\r\n\tdouble double_1 = 1;\r\n\tint_2 = int_1 * int_1;\r\n\tchar_2 = char_1 + char_1;\r\n\tlong_1 = long_1 * long_1;\r\n\tint_2 = int_2 * int_2;\r\n\treturn double_1;\r\n}", "item_id": 333, "repo": "Vul4Vendetta/Vul_Tech", "file": "experiments/node9/c_source/rasqal_5_30_node9.c", "last_update_at": "2019-10-28T05:24:15+00:00", "question_id": "45f71467c52c44cc66ec47b84bc6c32ffcb7d2ba_333", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double v_rasqal_sparql_xml_start( float parameter_1)\r\n{\r\n\tint int_1 = 1;\r\n\tint int_2 = 1;\r\n\tchar char_1 = 1;\r\n\tchar char_2 = 1;\r\n\tlong long_1 = 1;\r\n\tdouble double_1 = 1;\r\n\tint_2 = int_1 * int_1;\r\n\tchar_2 = char_1 + char_1;\r\n\tlong_1 = long_1 * long_1;\r\n\tint_2 = int_2 * int_2;\r\n\treturn double_1;\r\n"]], "pred": {"ppl": 2.1662395000457764, "ppl_lower": 2.1662395000457764, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00518787057027574, "Min_5.0% Prob": 9.919939654214042, "Min_10.0% Prob": 6.592928613935198, "Min_20.0% Prob": 3.784176826477051, "Min_30.0% Prob": 2.5773961389945312, "Min_40.0% Prob": 1.9589833367118161, "Min_50.0% Prob": 1.55656879637202, "Min_60.0% Prob": 1.291247642035666}}
{"hexsha": "c4f710d0265e20da931bb3a353e1a0839d1d5804", "ext": "c", "lang": "C", "content": "int\nVX_COLBYUCD (handle_t *parent, XCHAR *name, XCHAR *alt)\n{\n    char *_name = spp2c (name, spplen (name));\n    char *_alt = spp2c (alt, spplen (alt));\n\n    int col = vot_colByUCD (*parent, _name, _alt);\n\n    free ((char *) _name);\n    free ((char *) _alt);\n\n    return ( col );\n}", "item_id": 3, "repo": "olebole/voclient", "file": "libvotable/votParse_spp.c", "last_update_at": "2019-12-02T16:48:42+00:00", "question_id": "c4f710d0265e20da931bb3a353e1a0839d1d5804_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nVX_COLBYUCD (handle_t *parent, XCHAR *name, XCHAR *alt)\n{\n    char *_name = spp2c (name, spplen (name));\n    char *_alt = spp2c (alt, spplen (alt));\n    int col = vot_colByUCD (*parent, _name, _alt);\n    free ((char *) _name);\n    free ((char *) _alt);\n    return ( col );\n"]], "pred": {"ppl": 4.824894905090332, "ppl_lower": 5.195820331573486, "ppl/lowercase_ppl": -1.047061943479973, "ppl/zlib": 0.00942388594745691, "Min_5.0% Prob": 8.505481338500976, "Min_10.0% Prob": 7.794289979067716, "Min_20.0% Prob": 6.252901388251263, "Min_30.0% Prob": 4.768188755852836, "Min_40.0% Prob": 3.8425788399965866, "Min_50.0% Prob": 3.1344813355084122, "Min_60.0% Prob": 2.6228430490408625}}
{"hexsha": "9e993387986126111779b28c2f0d3633cb69d591", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI xmlwriter_WriteCData(IXmlWriter *iface, LPCWSTR data)\n{\n    xmlwriter *This = impl_from_IXmlWriter(iface);\n    int len;\n\n    TRACE(\"%p %s\\n\", This, debugstr_w(data));\n\n    switch (This->state)\n    {\n    case XmlWriterState_Initial:\n        return E_UNEXPECTED;\n    case XmlWriterState_ElemStarted:\n        writer_close_starttag(This);\n        break;\n    case XmlWriterState_Ready:\n    case XmlWriterState_DocClosed:\n        This->state = XmlWriterState_DocClosed;\n        return WR_E_INVALIDACTION;\n    default:\n        ;\n    }\n\n    len = data ? strlenW(data) : 0;\n\n    write_node_indent(This);\n    if (!len)\n        write_cdata_section(This->output, NULL, 0);\n    else {\n        static const WCHAR cdatacloseW[] = {']',']','>',0};\n        while (len) {\n            const WCHAR *str = strstrW(data, cdatacloseW);\n            if (str) {\n                str += 2;\n                write_cdata_section(This->output, data, str - data);\n                len -= str - data;\n                data = str;\n            }\n            else {\n                write_cdata_section(This->output, data, len);\n                break;\n            }\n        }\n    }\n\n    return S_OK;\n}", "item_id": 24, "repo": "ntxy/wine", "file": "dlls/xmllite/writer.c", "last_update_at": "2019-06-30T16:15:46+00:00", "question_id": "9e993387986126111779b28c2f0d3633cb69d591_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI xmlwriter_WriteCData(IXmlWriter *iface, LPCWSTR data)\n{\n    xmlwriter *This = impl_from_IXmlWriter(iface);\n    int len;\n    TRACE(\"%p %s\\n\", This, debugstr_w(data));\n    switch (This->state)\n    {\n    case XmlWriterState_Initial:\n        return E_UNEXPECTED;\n    case XmlWriterState_ElemStarted:\n        writer_close_starttag(This);\n        break;\n    case XmlWriterState_Ready:\n    case XmlWriterState_DocClosed:\n        This->state = XmlWriterState_DocClosed;\n        return WR_E_INVALIDACTION;\n    default:\n        ;\n    }\n    len = data ? strlenW(data) : 0;\n    write_node_indent(This);\n    if (!len)\n        write_cdata_section(This->output, NULL, 0);\n    else {\n        static const WCHAR cdatacloseW[] = {']',']','>',0};\n        while (len) {\n            const WCHAR *str = strstrW(data, cdatacloseW);\n            if (str) {\n                str += 2;\n                write_cdata_section(This->output, data, str - data);\n                len -= str - data;\n                data = str;\n            }\n            else {\n                write_cdata_section(This->output, data, len);\n                break;\n            }\n        }\n    }\n    return S_OK;\n"]], "pred": {"ppl": 1.8163135051727295, "ppl_lower": 2.831509828567505, "ppl/lowercase_ppl": -1.7439587064107807, "ppl/zlib": 0.0011864988077264476, "Min_5.0% Prob": 5.613180223264192, "Min_10.0% Prob": 4.228330016136169, "Min_20.0% Prob": 2.6996295390191016, "Min_30.0% Prob": 1.9486423312321952, "Min_40.0% Prob": 1.4830743954940275, "Min_50.0% Prob": 1.1947630300079861, "Min_60.0% Prob": 0.9942215112001671}}
{"hexsha": "babde3776eae777d104d8f4ca2b7cf6f236a36fe", "ext": "c", "lang": "C", "content": "void test_ioexp_led_input(void)\n{\n    /* Test a couple of different arbitrary input values */\n    uint8_t input_val = 0xff;\n\n    SX1509_regs[0x11] = 0xF2;\n    TEST_ASSERT_EQUAL(\n        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_A, &input_val));\n    TEST_ASSERT_EQUAL_HEX8(0xF2, input_val);\n\n    SX1509_regs[0x10] = 0x04;\n    TEST_ASSERT_EQUAL(\n        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_B, &input_val));\n    TEST_ASSERT_EQUAL_HEX8(0x04, input_val);\n}", "item_id": 0, "repo": "fabiojna02/OpenCellular", "file": "firmware/ec/test/suites/Test_sx1509.c", "last_update_at": "2019-11-04T07:11:25+00:00", "question_id": "babde3776eae777d104d8f4ca2b7cf6f236a36fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_ioexp_led_input(void)\n{\n    /* Test a couple of different arbitrary input values */\n    uint8_t input_val = 0xff;\n    SX1509_regs[0x11] = 0xF2;\n    TEST_ASSERT_EQUAL(\n        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_A, &input_val));\n    TEST_ASSERT_EQUAL_HEX8(0xF2, input_val);\n    SX1509_regs[0x10] = 0x04;\n    TEST_ASSERT_EQUAL(\n        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_B, &input_val));\n    TEST_ASSERT_EQUAL_HEX8(0x04, input_val);\n"]], "pred": {"ppl": 2.284801959991455, "ppl_lower": 2.7770135402679443, "ppl/lowercase_ppl": -1.236114738841888, "ppl/zlib": 0.003531108337616058, "Min_5.0% Prob": 7.205446322758992, "Min_10.0% Prob": 5.668901939392089, "Min_20.0% Prob": 3.789742041826248, "Min_30.0% Prob": 2.7226440807183585, "Min_40.0% Prob": 2.060253931965568, "Min_50.0% Prob": 1.6576037851738787, "Min_60.0% Prob": 1.3842110557833205}}
{"hexsha": "dc4f3fcd52d5e56f78c83d694d2dd59ac93c44ab", "ext": "c", "lang": "C", "content": "int update_condition(object me, int duration)\n{\n  if (me->is_ghost()) return 1;\n        if( !living(me) || query_temp(\"noliving\", me) )\n        {\n                message(\"vision\", me->name()+\"\u5598\u7740\u7c97\u6c23\uff0c\u4e2d\u638c\u8655\u9ed1\u7d72\u5982\u58a8\u3002\\n\", environment(me), me);\n        }\n        else\n        {\n                tell_object(me, HIB\"\u4f60\u53ea\u89ba\u6e3e\u8eab\u51b0\u51b7\u523a\u9aa8\uff0c\u751a\u70ba\u96e3\u53d7\uff01\\n\" NOR );\n                message(\"vision\", HIB+me->name()+\"\u7a81\u7136\u9762\u8272\u9435\u9752\uff0c\u5168\u8eab\u4e0a\u4e0b\u9ed1\u7d72\u96b1\u7d04\u53ef\u8fa8\uff0c\u770b\u4f86\u662f\u4e2d\u4e86\u9ed1\u7802\u638c\u5f8c\u638c\u6bd2\u767c\u4f5c\u4e86\u3002\\n\"NOR, environment(me), me);\n        }\n        me->receive_damage(\"qi\", 25,\"\u9ed1\u7802\u638c\u6bd2\u767c\u4f5c\");\n        me->receive_wound(\"jing\", 20,\"\u9ed1\u7802\u638c\u6bd2\u767c\u4f5c\");\n        if( query(\"eff_jing\", me)<0 || query(\"eff_qi\", me)<0)return 0;\n        me->apply_condition(\"black_poison\", duration - 1);\n        if( duration < 1 ) return 0;\n        return CND_CONTINUE;\n}", "item_id": 0, "repo": "cantona/NT6", "file": "nitan/kungfu/condition/black_poison.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "dc4f3fcd52d5e56f78c83d694d2dd59ac93c44ab_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int update_condition(object me, int duration)\n{\n  if (me->is_ghost()) return 1;\n        if( !living(me) || query_temp(\"noliving\", me) )\n        {\n                message(\"vision\", me->name()+\"\u5598\u7740\u7c97\u6c23\uff0c\u4e2d\u638c\u8655\u9ed1\u7d72\u5982\u58a8\u3002\\n\", environment(me), me);\n        }\n        else\n        {\n                tell_object(me, HIB\"\u4f60\u53ea\u89ba\u6e3e\u8eab\u51b0\u51b7\u523a\u9aa8\uff0c\u751a\u70ba\u96e3\u53d7\uff01\\n\" NOR );\n                message(\"vision\", HIB+me->name()+\"\u7a81\u7136\u9762\u8272\u9435\u9752\uff0c\u5168\u8eab\u4e0a\u4e0b\u9ed1\u7d72\u96b1\u7d04\u53ef\u8fa8\uff0c\u770b\u4f86\u662f\u4e2d\u4e86\u9ed1\u7802\u638c\u5f8c\u638c\u6bd2\u767c\u4f5c\u4e86\u3002\\n\"NOR, environment(me), me);\n        }\n        me->receive_damage(\"qi\", 25,\"\u9ed1\u7802\u638c\u6bd2\u767c\u4f5c\");\n        me->receive_wound(\"jing\", 20,\"\u9ed1\u7802\u638c\u6bd2\u767c\u4f5c\");\n        if( query(\"eff_jing\", me)<0 || query(\"eff_qi\", me)<0)return 0;\n        me->apply_condition(\"black_poison\", duration - 1);\n        if( duration < 1 ) return 0;\n        return CND_CONTINUE;\n"]], "pred": {"ppl": 2.994676113128662, "ppl_lower": 3.4288554191589355, "ppl/lowercase_ppl": -1.12343724585066, "ppl/zlib": 0.0020773410666507486, "Min_5.0% Prob": 6.825759059504459, "Min_10.0% Prob": 5.389220494490403, "Min_20.0% Prob": 4.0975390868850905, "Min_30.0% Prob": 3.265767505613424, "Min_40.0% Prob": 2.625305275373821, "Min_50.0% Prob": 2.158592993412355, "Min_60.0% Prob": 1.822997388897566}}
{"hexsha": "1676c296612ecbc19bdefcacfc35b010bf1542b7", "ext": "c", "lang": "C", "content": "NTSTATUS dcerpc_decode_trustAuthInOut_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)\n{\n\tstruct dcerpc_decode_trustAuthInOut_r_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct dcerpc_decode_trustAuthInOut_r_state);\n\tNTSTATUS status;\n\n\tif (tevent_req_is_nterror(req, &status)) {\n\t\ttevent_req_received(req);\n\t\treturn status;\n\t}\n\n\ttalloc_steal(mem_ctx, state->out_mem_ctx);\n\n\ttevent_req_received(req);\n\treturn NT_STATUS_OK;\n}", "item_id": 90, "repo": "zaion520/ATtomato", "file": "release/src-rt-6.x.4708/router/samba3/source3/librpc/gen_ndr/ndr_drsblobs_c.c", "last_update_at": "2019-02-15T03:30:28+00:00", "question_id": "1676c296612ecbc19bdefcacfc35b010bf1542b7_90", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NTSTATUS dcerpc_decode_trustAuthInOut_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)\n{\n\tstruct dcerpc_decode_trustAuthInOut_r_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct dcerpc_decode_trustAuthInOut_r_state);\n\tNTSTATUS status;\n\tif (tevent_req_is_nterror(req, &status)) {\n\t\ttevent_req_received(req);\n\t\treturn status;\n\t}\n\ttalloc_steal(mem_ctx, state->out_mem_ctx);\n\ttevent_req_received(req);\n\treturn NT_STATUS_OK;\n"]], "pred": {"ppl": 1.8164451122283936, "ppl_lower": 2.137139081954956, "ppl/lowercase_ppl": -1.2723936665008002, "ppl/zlib": 0.002652806026658707, "Min_5.0% Prob": 6.859358946482341, "Min_10.0% Prob": 4.91591551429347, "Min_20.0% Prob": 2.914460826861231, "Min_30.0% Prob": 1.980614493878787, "Min_40.0% Prob": 1.490779203105424, "Min_50.0% Prob": 1.1934169558416072, "Min_60.0% Prob": 0.9947378217761421}}
{"hexsha": "9af7f15e29011807e50843116b8acac09484c18e", "ext": "c", "lang": "C", "content": "METHODDEF(void)\nh2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t\tJSAMPARRAY input_data, JSAMPARRAY output_data)\n{\n  int inrow, outrow;\n  JDIMENSION colctr;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;\n  INT32 membersum, neighsum, memberscale, neighscale;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n\t\t    cinfo->image_width, output_cols * 2);\n\n  /* We don't bother to form the individual \"smoothed\" input pixel values;\n   * we can directly compute the output which is the average of the four\n   * smoothed values.  Each of the four member pixels contributes a fraction\n   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three\n   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final\n   * output.  The four corner-adjacent neighbor pixels contribute a fraction\n   * SF to just one smoothed pixel, or SF/4 to the final output; while the\n   * eight edge-adjacent neighbors contribute SF to each of two smoothed\n   * pixels, or SF/2 overall.  In order to use integer arithmetic, these\n   * factors are scaled by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n\n  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */\n  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow+1];\n    above_ptr = input_data[inrow-1];\n    below_ptr = input_data[inrow+2];\n\n    /* Special case for first column: pretend column -1 is same as column 0 */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +\n\t       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +\n\t\tGETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n    inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      /* sum of pixels directly mapped to this output element */\n      membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\t  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n      /* sum of edge-neighbor pixels */\n      neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t\t GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t\t GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +\n\t\t GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);\n      /* The edge-neighbors count twice as much as corner-neighbors */\n      neighsum += neighsum;\n      /* Add in the corner-neighbors */\n      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +\n\t\t  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);\n      /* form final output scaled up by 2^16 */\n      membersum = membersum * memberscale + neighsum * neighscale;\n      /* round, descale and output it */\n      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n      inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n    }\n\n    /* Special case for last column */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +\n\t       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +\n\t\tGETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);\n\n    inrow += 2;\n  }\n}", "item_id": 6, "repo": "miahmie/krkrz", "file": "src/core/external/jpeg-6bx/jcsample.c", "last_update_at": "2019-08-15T04:47:11+00:00", "question_id": "9af7f15e29011807e50843116b8acac09484c18e_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["METHODDEF(void)\nh2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t\tJSAMPARRAY input_data, JSAMPARRAY output_data)\n{\n  int inrow, outrow;\n  JDIMENSION colctr;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;\n  INT32 membersum, neighsum, memberscale, neighscale;\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n\t\t    cinfo->image_width, output_cols * 2);\n  /* We don't bother to form the individual \"smoothed\" input pixel values;\n   * we can directly compute the output which is the average of the four\n   * smoothed values.  Each of the four member pixels contributes a fraction\n   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three\n   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final\n   * output.  The four corner-adjacent neighbor pixels contribute a fraction\n   * SF to just one smoothed pixel, or SF/4 to the final output; while the\n   * eight edge-adjacent neighbors contribute SF to each of two smoothed\n   * pixels, or SF/2 overall.  In order to use integer arithmetic, these\n   * factors are scaled by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */\n  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow+1];\n    above_ptr = input_data[inrow-1];\n    below_ptr = input_data[inrow+2];\n    /* Special case for first column: pretend column -1 is same as column 0 */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +\n\t       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +\n\t\tGETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n    inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      /* sum of pixels directly mapped to this output element */\n      membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\t  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n      /* sum of edge-neighbor pixels */\n      neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t\t GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t\t GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +\n\t\t GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);\n      /* The edge-neighbors count twice as much as corner-neighbors */\n      neighsum += neighsum;\n      /* Add in the corner-neighbors */\n      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +\n\t\t  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);\n      /* form final output scaled up by 2^16 */\n      membersum = membersum * memberscale + neighsum * neighscale;\n      /* round, descale and output it */\n      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n      inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n    }\n    /* Special case for last column */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +\n\t       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +\n\t\tGETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);\n    inrow += 2;\n  }\n"]], "pred": {"ppl": 1.4650969505310059, "ppl_lower": 1.8305141925811768, "ppl/lowercase_ppl": -1.583040065992093, "ppl/zlib": 0.0002904345384914359, "Min_5.0% Prob": 4.302417633580227, "Min_10.0% Prob": 2.96323366726146, "Min_20.0% Prob": 1.7952385740537269, "Min_30.0% Prob": 1.2527904895931676, "Min_40.0% Prob": 0.9499924027549973, "Min_50.0% Prob": 0.7634316298932041, "Min_60.0% Prob": 0.637142543307981}}
{"hexsha": "cf74a9b7f92d9a6c1e681da5e38982d8f08fb104", "ext": "c", "lang": "C", "content": "ZEND_API int zend_parse_method_parameters_ex(int flags, int num_args TSRMLS_DC, zval *this_ptr, char *type_spec, ...) /* {{{ */\n{\n\tva_list va;\n\tint retval;\n\tchar *p = type_spec;\n\tzval **object;\n\tzend_class_entry *ce;\n\tint quiet = flags & ZEND_PARSE_PARAMS_QUIET;\n\n\tif (!this_ptr) {\n\t\tRETURN_IF_ZERO_ARGS(num_args, p, quiet);\n\n\t\tva_start(va, type_spec);\n\t\tretval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);\n\t\tva_end(va);\n\t} else {\n\t\tp++;\n\t\tRETURN_IF_ZERO_ARGS(num_args-1, p, quiet);\n\n\t\tva_start(va, type_spec);\n\n\t\tobject = va_arg(va, zval **);\n\t\tce = va_arg(va, zend_class_entry *);\n\t\t*object = this_ptr;\n\n\t\tif (ce && !instanceof_function(Z_OBJCE_P(this_ptr), ce TSRMLS_CC)) {\n\t\t\tif (!quiet) {\n\t\t\t\tzend_error(E_CORE_ERROR, \"%s::%s() must be derived from %s::%s\",\n\t\t\t\t\tce->name, get_active_function_name(TSRMLS_C), Z_OBJCE_P(this_ptr)->name, get_active_function_name(TSRMLS_C));\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tretval = zend_parse_va_args(num_args, p, &va, flags TSRMLS_CC);\n\t\tva_end(va);\n\t}\n\treturn retval;\n}", "item_id": 13, "repo": "5up3rc/php-5.3.3", "file": "Zend/zend_API.c", "last_update_at": "2019-04-29T12:45:50+00:00", "question_id": "cf74a9b7f92d9a6c1e681da5e38982d8f08fb104_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ZEND_API int zend_parse_method_parameters_ex(int flags, int num_args TSRMLS_DC, zval *this_ptr, char *type_spec, ...) /* {{{ */\n{\n\tva_list va;\n\tint retval;\n\tchar *p = type_spec;\n\tzval **object;\n\tzend_class_entry *ce;\n\tint quiet = flags & ZEND_PARSE_PARAMS_QUIET;\n\tif (!this_ptr) {\n\t\tRETURN_IF_ZERO_ARGS(num_args, p, quiet);\n\t\tva_start(va, type_spec);\n\t\tretval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);\n\t\tva_end(va);\n\t} else {\n\t\tp++;\n\t\tRETURN_IF_ZERO_ARGS(num_args-1, p, quiet);\n\t\tva_start(va, type_spec);\n\t\tobject = va_arg(va, zval **);\n\t\tce = va_arg(va, zend_class_entry *);\n\t\t*object = this_ptr;\n\t\tif (ce && !instanceof_function(Z_OBJCE_P(this_ptr), ce TSRMLS_CC)) {\n\t\t\tif (!quiet) {\n\t\t\t\tzend_error(E_CORE_ERROR, \"%s::%s() must be derived from %s::%s\",\n\t\t\t\t\tce->name, get_active_function_name(TSRMLS_C), Z_OBJCE_P(this_ptr)->name, get_active_function_name(TSRMLS_C));\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t\tretval = zend_parse_va_args(num_args, p, &va, flags TSRMLS_CC);\n\t\tva_end(va);\n\t}\n\treturn retval;\n"]], "pred": {"ppl": 1.4341084957122803, "ppl_lower": 1.8860653638839722, "ppl/lowercase_ppl": -1.759823763583482, "ppl/zlib": 0.0007388184401801603, "Min_5.0% Prob": 4.179279470443726, "Min_10.0% Prob": 2.8222594332695006, "Min_20.0% Prob": 1.7410860075056553, "Min_30.0% Prob": 1.19651826142023, "Min_40.0% Prob": 0.9015673148026689, "Min_50.0% Prob": 0.722120564376004, "Min_60.0% Prob": 0.6020149216705856}}
{"hexsha": "379cb489f75b65e12996b48b6d93bc6b3f40a561", "ext": "c", "lang": "C", "content": "static void aha1740_getconfig(unsigned int base, unsigned int *irq_level,\n\t\t\t      unsigned int *irq_type,\n\t\t\t      unsigned int *translation)\n{\n\tstatic int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };\n\n\t*irq_level = intab[inb(INTDEF(base)) & 0x7];\n\t*irq_type  = (inb(INTDEF(base)) & 0x8) >> 3;\n\t*translation = inb(RESV1(base)) & 0x1;\n\toutb(inb(INTDEF(base)) | 0x10, INTDEF(base));\n}", "item_id": 7, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/drivers/scsi/aha1740.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "379cb489f75b65e12996b48b6d93bc6b3f40a561_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void aha1740_getconfig(unsigned int base, unsigned int *irq_level,\n\t\t\t      unsigned int *irq_type,\n\t\t\t      unsigned int *translation)\n{\n\tstatic int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };\n\t*irq_level = intab[inb(INTDEF(base)) & 0x7];\n\t*irq_type  = (inb(INTDEF(base)) & 0x8) >> 3;\n\t*translation = inb(RESV1(base)) & 0x1;\n\toutb(inb(INTDEF(base)) | 0x10, INTDEF(base));\n"]], "pred": {"ppl": 2.753007650375366, "ppl_lower": 2.82015061378479, "ppl/lowercase_ppl": -1.0237942433417633, "ppl/zlib": 0.0047102046747894664, "Min_5.0% Prob": 6.877696408165826, "Min_10.0% Prob": 5.611961502777903, "Min_20.0% Prob": 4.008093931173024, "Min_30.0% Prob": 3.074601481881058, "Min_40.0% Prob": 2.442540952249577, "Min_50.0% Prob": 1.991505263353649, "Min_60.0% Prob": 1.6753765881192266}}
{"hexsha": "62bb98288f8eaf361ad4c30dda716b6283da079c", "ext": "h", "lang": "C", "content": "namespace UIHelper{\n\nvoid setRowItems(int row, const QString & name, const QString & classname, const QString & bind, const QString & value, const QString & tip1, const QString & tip2, TableWidget *table);\nvoid setBinding(int index, int row, int column, const QString & variableName, const QString & path, hkVariableType type, bool isProperty, TableWidget *table, HkDynamicObject *bsData);\nvoid loadBinding(int row, int column, hkbVariableBindingSet *varBind, const QString &path, TableWidget *table, HkxObject *bsData);\nvoid setGenerator(int index, const QString &name, DataIconManager *dynobj, hkbGenerator *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);\nvoid setModifier(int index, const QString &name, DataIconManager *dynobj, hkbModifier *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);\n\n}", "item_id": 4, "repo": "Zartar/Skyrim-Behavior-Editor-", "file": "src/ui/genericdatawidgets.h", "last_update_at": "2019-04-01T23:28:39+00:00", "question_id": "62bb98288f8eaf361ad4c30dda716b6283da079c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace UIHelper{\nvoid setRowItems(int row, const QString & name, const QString & classname, const QString & bind, const QString & value, const QString & tip1, const QString & tip2, TableWidget *table);\nvoid setBinding(int index, int row, int column, const QString & variableName, const QString & path, hkVariableType type, bool isProperty, TableWidget *table, HkDynamicObject *bsData);\nvoid loadBinding(int row, int column, hkbVariableBindingSet *varBind, const QString &path, TableWidget *table, HkxObject *bsData);\nvoid setGenerator(int index, const QString &name, DataIconManager *dynobj, hkbGenerator *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);\nvoid setModifier(int index, const QString &name, DataIconManager *dynobj, hkbModifier *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);\n"]], "pred": {"ppl": 4.638666152954102, "ppl_lower": 5.020537376403809, "ppl/lowercase_ppl": -1.0515567860305655, "ppl/zlib": 0.004692436874238047, "Min_5.0% Prob": 10.198224851063319, "Min_10.0% Prob": 8.214863351413182, "Min_20.0% Prob": 6.0177010255200525, "Min_30.0% Prob": 4.627059992621927, "Min_40.0% Prob": 3.6987721888364944, "Min_50.0% Prob": 3.0316635051243743, "Min_60.0% Prob": 2.5548971822156625}}
{"hexsha": "f4ecd080224d2aa212b2b449e56260852753ac4d", "ext": "c", "lang": "C", "content": "static slist_t*\n_splice_after_r(slist_t* self, slist_ref_t pos,\n    slist_t* other, slist_ref_t first, slist_ref_t last)\n{\n  assert(self);\n  assert(other);\n\n  if(pos == first || first == last || pos == NULL ||\n      first == NULL || first->next == NULL)\n    return self;\n\n  if( pos->next != NULL ){\n    slist_ref_t b_last = first;\n    while( b_last->next != NULL )  b_last = b_last ->next;\n    __link_nodes(b_last, pos->next);\n  }\n  __link_nodes(pos, first->next);\n  __link_nodes(first, last);\n  return self;\n}", "item_id": 23, "repo": "justmao945/lab", "file": "yacl/src/slist.c", "last_update_at": "2019-09-10T19:01:37+00:00", "question_id": "f4ecd080224d2aa212b2b449e56260852753ac4d_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static slist_t*\n_splice_after_r(slist_t* self, slist_ref_t pos,\n    slist_t* other, slist_ref_t first, slist_ref_t last)\n{\n  assert(self);\n  assert(other);\n  if(pos == first || first == last || pos == NULL ||\n      first == NULL || first->next == NULL)\n    return self;\n  if( pos->next != NULL ){\n    slist_ref_t b_last = first;\n    while( b_last->next != NULL )  b_last = b_last ->next;\n    __link_nodes(b_last, pos->next);\n  }\n  __link_nodes(pos, first->next);\n  __link_nodes(first, last);\n  return self;\n"]], "pred": {"ppl": 3.011676549911499, "ppl_lower": 3.075023889541626, "ppl/lowercase_ppl": -1.0188805545302264, "ppl/zlib": 0.004921861236712758, "Min_5.0% Prob": 6.784907245635987, "Min_10.0% Prob": 5.763267874717712, "Min_20.0% Prob": 4.171304529905319, "Min_30.0% Prob": 3.241205496589343, "Min_40.0% Prob": 2.599969907104969, "Min_50.0% Prob": 2.156680606305599, "Min_60.0% Prob": 1.8251324803257982}}
{"hexsha": "1f0b48be66012af9fff9fdbaa12b403030758b02", "ext": "c", "lang": "C", "content": "JNICALL Java_org_lwjgl_util_yoga_Yoga_nYGNodeStyleGetOverflow(JNIEnv *__env, jclass clazz, jlong nodeAddress) {\n    YGNodeRef const node = (YGNodeRef const)(intptr_t)nodeAddress;\n    UNUSED_PARAMS(__env, clazz)\n    return (jint)YGNodeStyleGetOverflow(node);\n}", "item_id": 54, "repo": "patrickSpaceSurfer/lwjgl3", "file": "modules/lwjgl/yoga/src/generated/c/org_lwjgl_util_yoga_Yoga.c", "last_update_at": "2019-12-19T22:57:15+00:00", "question_id": "1f0b48be66012af9fff9fdbaa12b403030758b02_54", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_org_lwjgl_util_yoga_Yoga_nYGNodeStyleGetOverflow(JNIEnv *__env, jclass clazz, jlong nodeAddress) {\n    YGNodeRef const node = (YGNodeRef const)(intptr_t)nodeAddress;\n    UNUSED_PARAMS(__env, clazz)\n    return (jint)YGNodeStyleGetOverflow(node);\n"]], "pred": {"ppl": 1.6968990564346313, "ppl_lower": 6.196129322052002, "ppl/lowercase_ppl": -3.449160680862513, "ppl/zlib": 0.0028583918969949116, "Min_5.0% Prob": 5.703297138214111, "Min_10.0% Prob": 4.227542114257813, "Min_20.0% Prob": 2.702688076347113, "Min_30.0% Prob": 1.765749771808905, "Min_40.0% Prob": 1.3390869194778001, "Min_50.0% Prob": 1.0570108360395982, "Min_60.0% Prob": 0.8868751346956067}}
{"hexsha": "77951134434f3c4af357f2346a826eaf0e731d40", "ext": "c", "lang": "C", "content": "int add_watcher_by_pid(JobList* jobs, int pid, int fd){\n  JobNode *node = jobs->first;\n  while (node != NULL){\n    if (node->pid == pid){\n      WatcherList *lst = &(node->watcher_list);\n      return add_watcher(lst, fd);\n    }\n    node = node->next;\n  }\n  return 1;\n}", "item_id": 10, "repo": "gagandeepbhangal/job_server_and_client", "file": "jobprotocol.c", "last_update_at": "2019-09-09T21:04:57+00:00", "question_id": "77951134434f3c4af357f2346a826eaf0e731d40_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int add_watcher_by_pid(JobList* jobs, int pid, int fd){\n  JobNode *node = jobs->first;\n  while (node != NULL){\n    if (node->pid == pid){\n      WatcherList *lst = &(node->watcher_list);\n      return add_watcher(lst, fd);\n    }\n    node = node->next;\n  }\n  return 1;\n"]], "pred": {"ppl": 3.213531494140625, "ppl_lower": 3.542371988296509, "ppl/lowercase_ppl": -1.0834577117858348, "ppl/zlib": 0.006787037711360217, "Min_5.0% Prob": 7.967265892028808, "Min_10.0% Prob": 6.333176136016846, "Min_20.0% Prob": 4.552680265903473, "Min_30.0% Prob": 3.576896886030833, "Min_40.0% Prob": 2.8180167413339383, "Min_50.0% Prob": 2.3184170056791866, "Min_60.0% Prob": 1.9576046973711154}}
{"hexsha": "b10baacb51c990a47baf396fc606b4f922273a0e", "ext": "c", "lang": "C", "content": "int mwifiex_set_mgmt_ies(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_beacon_data *info)\n{\n\tint ret;\n\n\tret = mwifiex_uap_parse_tail_ies(priv, info);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn mwifiex_set_mgmt_beacon_data_ies(priv, info);\n}", "item_id": 7, "repo": "silentghoul-spec/Fuzzing-ext4", "file": "lkl/drivers/net/wireless/marvell/mwifiex/ie.c", "last_update_at": "2019-12-01T08:07:48+00:00", "question_id": "b10baacb51c990a47baf396fc606b4f922273a0e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mwifiex_set_mgmt_ies(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_beacon_data *info)\n{\n\tint ret;\n\tret = mwifiex_uap_parse_tail_ies(priv, info);\n\tif (ret)\n\t\treturn ret;\n\treturn mwifiex_set_mgmt_beacon_data_ies(priv, info);\n"]], "pred": {"ppl": 2.4422414302825928, "ppl_lower": 2.4422414302825928, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0061158646342547906, "Min_5.0% Prob": 8.29707384109497, "Min_10.0% Prob": 6.36336840282787, "Min_20.0% Prob": 3.962005280930063, "Min_30.0% Prob": 2.9135638764675926, "Min_40.0% Prob": 2.2165675560093443, "Min_50.0% Prob": 1.7989627201306193, "Min_60.0% Prob": 1.4877559223070578}}
{"hexsha": "4a83d91e1f8642bfa81c35c5a94c9bc5068fea61", "ext": "c", "lang": "C", "content": "int heap_realloc(Heap *heap, va_t va, size_t size)\n{\n    if (heap->var_pool[va].occupied == false)\n        return pvm_reporterror(HEAP_H, __FUNCTION__, \"Target unallocated\");\n\n    PrimitiveData * tmp;\n\n    heap->totalblocks -= heap->var_pool[va].framesize; // Minus previous size\n    heap->totalblocks += heap->var_pool[va].framesize = size; // New size\n\n    tmp = realloc(heap->var_pool[va].block, size);\n    if (tmp == NULL)\n        return pvm_reporterror(HEAP_H, __FUNCTION__, \"Allocation Failed\");\n\n    heap->var_pool[va].block = tmp;\n    return 0;\n}", "item_id": 4, "repo": "redrossa/pinevm", "file": "src/heap.c", "last_update_at": "2019-11-27T03:40:05+00:00", "question_id": "4a83d91e1f8642bfa81c35c5a94c9bc5068fea61_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int heap_realloc(Heap *heap, va_t va, size_t size)\n{\n    if (heap->var_pool[va].occupied == false)\n        return pvm_reporterror(HEAP_H, __FUNCTION__, \"Target unallocated\");\n    PrimitiveData * tmp;\n    heap->totalblocks -= heap->var_pool[va].framesize; // Minus previous size\n    heap->totalblocks += heap->var_pool[va].framesize = size; // New size\n    tmp = realloc(heap->var_pool[va].block, size);\n    if (tmp == NULL)\n        return pvm_reporterror(HEAP_H, __FUNCTION__, \"Allocation Failed\");\n    heap->var_pool[va].block = tmp;\n    return 0;\n"]], "pred": {"ppl": 3.7290282249450684, "ppl_lower": 4.016744136810303, "ppl/lowercase_ppl": -1.0564708578915802, "ppl/zlib": 0.004768650979009686, "Min_5.0% Prob": 9.321289539337158, "Min_10.0% Prob": 7.669373273849487, "Min_20.0% Prob": 5.613428103923797, "Min_30.0% Prob": 4.137807539105415, "Min_40.0% Prob": 3.2023991614948084, "Min_50.0% Prob": 2.617746538750016, "Min_60.0% Prob": 2.2013416811823845}}
{"hexsha": "e6959c708e1cfd2b03e3b7013a34bbe15b334338", "ext": "c", "lang": "C", "content": "int main() {\n\tfloat nota1, nota2, nota3, nota4;\n\tfloat media;\n\n\tscanf(\"%f %f %f %f\", &nota1, &nota2, &nota3, &nota4);\n\tmedia = (nota1*2) + (nota2*3) + (nota3*4) + nota4;\n\tmedia /= 10;\n\tprintf(\"Media: %.1f\\n\", media);\n\n\tif (media >= 7.0f) {\n\t\t\n\t\tprintf(\"Aluno aprovado.\\n\");\n\n\t} else if (media >= 5.0f) {\n\t\t\n\t\tprintf(\"Aluno em exame.\\n\");\n\t\tscanf(\"%f\",&nota1);\n\t\tprintf(\"Nota do exame: %.1f\\n\", nota1);\n\t\tmedia = (media + nota1) / 2;\n\n\t\tif (media >= 5.0)\n\t\t\tprintf(\"Aluno aprovado.\\n\");\n\t\telse\n\t\t\tprintf(\"Aluno reprovado.\\n\");\n\n\t\tprintf(\"Media final: %.1f\\n\", media);\n\t} else {\n\t\tprintf(\"Aluno reprovado.\\n\");\t\t\n\t}\n\n\treturn 0;\n}", "item_id": 0, "repo": "marcosmapl/uri-solutions", "file": "01-beginner/1040.c", "last_update_at": "2019-12-24T02:11:50+00:00", "question_id": "e6959c708e1cfd2b03e3b7013a34bbe15b334338_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main() {\n\tfloat nota1, nota2, nota3, nota4;\n\tfloat media;\n\tscanf(\"%f %f %f %f\", &nota1, &nota2, &nota3, &nota4);\n\tmedia = (nota1*2) + (nota2*3) + (nota3*4) + nota4;\n\tmedia /= 10;\n\tprintf(\"Media: %.1f\\n\", media);\n\tif (media >= 7.0f) {\n\t\t\n\t\tprintf(\"Aluno aprovado.\\n\");\n\t} else if (media >= 5.0f) {\n\t\t\n\t\tprintf(\"Aluno em exame.\\n\");\n\t\tscanf(\"%f\",&nota1);\n\t\tprintf(\"Nota do exame: %.1f\\n\", nota1);\n\t\tmedia = (media + nota1) / 2;\n\t\tif (media >= 5.0)\n\t\t\tprintf(\"Aluno aprovado.\\n\");\n\t\telse\n\t\t\tprintf(\"Aluno reprovado.\\n\");\n\t\tprintf(\"Media final: %.1f\\n\", media);\n\t} else {\n\t\tprintf(\"Aluno reprovado.\\n\");\t\t\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 1.467447280883789, "ppl_lower": 1.5055745840072632, "ppl/lowercase_ppl": -1.0668803982260142, "ppl/zlib": 0.001389580969690102, "Min_5.0% Prob": 4.867048904299736, "Min_10.0% Prob": 3.0488505978137255, "Min_20.0% Prob": 1.7832034965977073, "Min_30.0% Prob": 1.2545583479416866, "Min_40.0% Prob": 0.9481484325992506, "Min_50.0% Prob": 0.764634660589769, "Min_60.0% Prob": 0.6401577786653462}}
{"hexsha": "49f64a430c90a2d7d1bd0239529719c4ac0a5e4b", "ext": "c", "lang": "C", "content": "double image_influence(double *potential,\n\t\t       struct image_Landscape_param *image_paras,\n\t\t       miColor *color)\n{\n  double value;\n\n  value = 0;\n\n  if ((image_paras->on) && (image_paras->influence))\n    {\n      if (image_paras->alpha)\n\tvalue += (2.0 * color->a - 1.0);\n\n      if (image_paras->red)\n\tvalue += (2.0 * color->r - 1.0);\n\n      if (image_paras->green)\n\tvalue += (2.0 * color->g - 1.0);\n\n      if (image_paras->blue)\n\tvalue += (2.0 * color->b - 1.0);\n\n      value *= image_paras->influence;\n\n      *potential += image_paras->influence;\n\n      return value;\n    }\n\n  else\n    return 0;\n}", "item_id": 0, "repo": "qarl/lumetools", "file": "Landscape/Landscape.c", "last_update_at": "2019-11-22T15:11:36+00:00", "question_id": "49f64a430c90a2d7d1bd0239529719c4ac0a5e4b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double image_influence(double *potential,\n\t\t       struct image_Landscape_param *image_paras,\n\t\t       miColor *color)\n{\n  double value;\n  value = 0;\n  if ((image_paras->on) && (image_paras->influence))\n    {\n      if (image_paras->alpha)\n\tvalue += (2.0 * color->a - 1.0);\n      if (image_paras->red)\n\tvalue += (2.0 * color->r - 1.0);\n      if (image_paras->green)\n\tvalue += (2.0 * color->g - 1.0);\n      if (image_paras->blue)\n\tvalue += (2.0 * color->b - 1.0);\n      value *= image_paras->influence;\n      *potential += image_paras->influence;\n      return value;\n    }\n  else\n    return 0;\n"]], "pred": {"ppl": 2.4988114833831787, "ppl_lower": 2.455275774002075, "ppl/lowercase_ppl": -0.9808082182462676, "ppl/zlib": 0.003947479362870078, "Min_5.0% Prob": 8.226664781570435, "Min_10.0% Prob": 5.964464101791382, "Min_20.0% Prob": 4.0133065462112425, "Min_30.0% Prob": 2.951832544406255, "Min_40.0% Prob": 2.2804181285947562, "Min_50.0% Prob": 1.8348881490528584, "Min_60.0% Prob": 1.5316346882283687}}
{"hexsha": "7f02ee14a5846a231d874b383f21fb789128f123", "ext": "c", "lang": "C", "content": "void initdnsserver(void)\n{\n\tPyObject *m;\n\tPyObject *dep_samba_dcerpc_base;\n\n\tdep_samba_dcerpc_base = PyImport_ImportModule(\"samba.dcerpc.base\");\n\tif (dep_samba_dcerpc_base == NULL)\n\t\treturn;\n\n\tClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, \"ClientConnection\");\n\tif (ClientConnection_Type == NULL)\n\t\treturn;\n\n\tdnsserver_InterfaceType.tp_base = ClientConnection_Type;\n\n\tif (PyType_Ready(&dnsserver_InterfaceType) < 0)\n\t\treturn;\n\tif (!PyInterface_AddNdrRpcMethods(&dnsserver_InterfaceType, py_ndr_dnsserver_methods))\n\t\treturn;\n\n#ifdef PY_DNSSERVER_PATCH\n\tPY_DNSSERVER_PATCH(&dnsserver_InterfaceType);\n#endif\n\n\tm = Py_InitModule3(\"dnsserver\", dnsserver_methods, \"dnsserver DCE/RPC\");\n\tif (m == NULL)\n\t\treturn;\n\n\tPy_INCREF((PyObject *)(void *)&dnsserver_InterfaceType);\n\tPyModule_AddObject(m, \"dnsserver\", (PyObject *)(void *)&dnsserver_InterfaceType);\n#ifdef PY_MOD_DNSSERVER_PATCH\n\tPY_MOD_DNSSERVER_PATCH(m);\n#endif\n\n}", "item_id": 2, "repo": "zaion520/ATtomato", "file": "release/src-rt-6.x.4708/router/samba3/source3/librpc/gen_ndr/py_dnsserver.c", "last_update_at": "2019-02-15T01:21:02+00:00", "question_id": "7f02ee14a5846a231d874b383f21fb789128f123_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void initdnsserver(void)\n{\n\tPyObject *m;\n\tPyObject *dep_samba_dcerpc_base;\n\tdep_samba_dcerpc_base = PyImport_ImportModule(\"samba.dcerpc.base\");\n\tif (dep_samba_dcerpc_base == NULL)\n\t\treturn;\n\tClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, \"ClientConnection\");\n\tif (ClientConnection_Type == NULL)\n\t\treturn;\n\tdnsserver_InterfaceType.tp_base = ClientConnection_Type;\n\tif (PyType_Ready(&dnsserver_InterfaceType) < 0)\n\t\treturn;\n\tif (!PyInterface_AddNdrRpcMethods(&dnsserver_InterfaceType, py_ndr_dnsserver_methods))\n\t\treturn;\n#ifdef PY_DNSSERVER_PATCH\n\tPY_DNSSERVER_PATCH(&dnsserver_InterfaceType);\n#endif\n\tm = Py_InitModule3(\"dnsserver\", dnsserver_methods, \"dnsserver DCE/RPC\");\n\tif (m == NULL)\n\t\treturn;\n\tPy_INCREF((PyObject *)(void *)&dnsserver_InterfaceType);\n\tPyModule_AddObject(m, \"dnsserver\", (PyObject *)(void *)&dnsserver_InterfaceType);\n#ifdef PY_MOD_DNSSERVER_PATCH\n\tPY_MOD_DNSSERVER_PATCH(m);\n#endif\n"]], "pred": {"ppl": 2.4827771186828613, "ppl_lower": 2.664879322052002, "ppl/lowercase_ppl": -1.077834580061879, "ppl/zlib": 0.0024057612158265153, "Min_5.0% Prob": 9.06842703568308, "Min_10.0% Prob": 6.750422251530183, "Min_20.0% Prob": 4.2549906097925625, "Min_30.0% Prob": 2.979715605194752, "Min_40.0% Prob": 2.264624610591011, "Min_50.0% Prob": 1.819941131121073, "Min_60.0% Prob": 1.5185783905948265}}
{"hexsha": "a3a0958995a6278853e5bfad37034414115c8d1d", "ext": "c", "lang": "C", "content": "static npy_intp\ngallop_left_ubyte(const npy_ubyte *arr, const npy_intp size, const npy_ubyte key)\n{\n    npy_intp last_ofs, ofs, l, m, r;\n\n    if (UBYTE_LT(arr[size - 1], key)) {\n        return size;\n    }\n\n    last_ofs = 0;\n    ofs = 1;\n\n    for (;;) {\n        if (size <= ofs || ofs < 0) {\n            ofs = size;\n            break;\n        }\n\n        if (UBYTE_LT(arr[size - ofs - 1], key)) {\n            break;\n        } else {\n            last_ofs = ofs;\n            ofs = (ofs << 1) + 1;\n        }\n    }\n\n    /* now that arr[size-ofs-1] < key <= arr[size-last_ofs-1] */\n    l = size - ofs - 1;\n    r = size - last_ofs - 1;\n\n    while (l + 1 < r) {\n        m = l + ((r - l) >> 1);\n\n        if (UBYTE_LT(arr[m], key)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n\n    /* now that arr[r-1] < key <= arr[r] */\n    return r;\n}", "item_id": 45, "repo": "jochenater/catboost", "file": "contrib/python/numpy/py3/numpy/core/src/npysort/timsort.c", "last_update_at": "2019-03-18T13:30:19+00:00", "question_id": "a3a0958995a6278853e5bfad37034414115c8d1d_45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static npy_intp\ngallop_left_ubyte(const npy_ubyte *arr, const npy_intp size, const npy_ubyte key)\n{\n    npy_intp last_ofs, ofs, l, m, r;\n    if (UBYTE_LT(arr[size - 1], key)) {\n        return size;\n    }\n    last_ofs = 0;\n    ofs = 1;\n    for (;;) {\n        if (size <= ofs || ofs < 0) {\n            ofs = size;\n            break;\n        }\n        if (UBYTE_LT(arr[size - ofs - 1], key)) {\n            break;\n        } else {\n            last_ofs = ofs;\n            ofs = (ofs << 1) + 1;\n        }\n    }\n    /* now that arr[size-ofs-1] < key <= arr[size-last_ofs-1] */\n    l = size - ofs - 1;\n    r = size - last_ofs - 1;\n    while (l + 1 < r) {\n        m = l + ((r - l) >> 1);\n        if (UBYTE_LT(arr[m], key)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    /* now that arr[r-1] < key <= arr[r] */\n    return r;\n"]], "pred": {"ppl": 1.859006404876709, "ppl_lower": 1.866381287574768, "ppl/lowercase_ppl": -1.0063854717542176, "ppl/zlib": 0.0018961533763541397, "Min_5.0% Prob": 6.456657237476772, "Min_10.0% Prob": 4.667625771628486, "Min_20.0% Prob": 2.8636498810493785, "Min_30.0% Prob": 2.0392772119253055, "Min_40.0% Prob": 1.5429849885659266, "Min_50.0% Prob": 1.2366272428994134, "Min_60.0% Prob": 1.035198422316802}}
{"hexsha": "cbf45589f1f66fa5629e814a706f49abbb169e9c", "ext": "h", "lang": "C", "content": "void doAWheelPID(SetPointInfo *p)\n{\n  long Perror = 0;\n  long output = 0;\n  int input   = 0;\n\n  p->Encoder = readEncoder(A_WHEEL);\n  input  = p->Encoder - p->PrevEnc;\n  Perror = p->TargetTicksPerFrame - input;\n\n  /*\n    Avoid derivative kick and allow tuning changes,\n    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/\n    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/\n  */\n  output = (AWheel_Kp * Perror - AWheel_Kd * (input - p->PrevInput) + p->ITerm) / AWheel_Ko;\n  p->PrevEnc = p->Encoder;  //save current encoder value to preEncoder\n\n  output += p->output;\n  // Accumulate Integral error *or* Limit output.\n  // Stop accumulating when output saturates\n  if (output >= MAX_PWM)\n  {\n    output = MAX_PWM;\n  }\n  else if (output <= -MAX_PWM)\n  {\n    output = -MAX_PWM;\n  }\n  else\n  {\n    /*\n      allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/\n    */\n    p->ITerm += AWheel_Ki * Perror;\n  }\n\n  p->output    = output;  //save current pid output for next pid\n  p->PrevInput = input;\n}", "item_id": 1, "repo": "darwinbeing/YoYoRobot", "file": "arduinoCode/mobileBaseArduinoCode/omniWheel_controller.h", "last_update_at": "2019-12-06T08:28:19+00:00", "question_id": "cbf45589f1f66fa5629e814a706f49abbb169e9c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void doAWheelPID(SetPointInfo *p)\n{\n  long Perror = 0;\n  long output = 0;\n  int input   = 0;\n  p->Encoder = readEncoder(A_WHEEL);\n  input  = p->Encoder - p->PrevEnc;\n  Perror = p->TargetTicksPerFrame - input;\n  /*\n    Avoid derivative kick and allow tuning changes,\n    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/\n    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/\n  */\n  output = (AWheel_Kp * Perror - AWheel_Kd * (input - p->PrevInput) + p->ITerm) / AWheel_Ko;\n  p->PrevEnc = p->Encoder;  //save current encoder value to preEncoder\n  output += p->output;\n  // Accumulate Integral error *or* Limit output.\n  // Stop accumulating when output saturates\n  if (output >= MAX_PWM)\n  {\n    output = MAX_PWM;\n  }\n  else if (output <= -MAX_PWM)\n  {\n    output = -MAX_PWM;\n  }\n  else\n  {\n    /*\n      allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/\n    */\n    p->ITerm += AWheel_Ki * Perror;\n  }\n  p->output    = output;  //save current pid output for next pid\n  p->PrevInput = input;\n"]], "pred": {"ppl": 2.922693967819214, "ppl_lower": 2.9829869270324707, "ppl/lowercase_ppl": -1.0190389093373695, "ppl/zlib": 0.002153626069624379, "Min_5.0% Prob": 8.09483273824056, "Min_10.0% Prob": 6.471224804313815, "Min_20.0% Prob": 4.540415181189167, "Min_30.0% Prob": 3.3815555580619243, "Min_40.0% Prob": 2.643048227897712, "Min_50.0% Prob": 2.1364848029856778, "Min_60.0% Prob": 1.785840276571713}}
{"hexsha": "52dd05ac3bf782f97010df86c93b90482d7ba029", "ext": "c", "lang": "C", "content": "uint32_t nb_tessellator2D_delete_internal_input_segments(nb_tessellator2D_t *const restrict mesh)\n{\n\tuint32_t removed = 0;\n\tfor (uint32_t i = 0; i < mesh->N_input_sgm; i++) {\n\t\tmsh_edge_t* restrict sgm = mesh->input_sgm[i];\n\t\tif (NULL != sgm) {\n\t\t\tif (NULL != sgm->t1 && NULL != sgm->t2) {\n\t\t\t\tmesh->input_sgm[i] = NULL;      \n\t\t\t\twhile (NULL != sgm) {\n\t\t\t\t\tmsh_edge_t* prev_sgm = sgm;\n\t\t\t\t\tsgm = medge_subsgm_next(sgm);\n\t\t\t\t\tmedge_destroy_subsgm_attribute(prev_sgm);\n\t\t\t\t\tremoved += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn removed;\n}", "item_id": 16, "repo": "vecn/nbots", "file": "sources/nb/geometric_bot/mesh/modules2D/area_analizer.c", "last_update_at": "2019-09-19T02:02:14+00:00", "question_id": "52dd05ac3bf782f97010df86c93b90482d7ba029_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t nb_tessellator2D_delete_internal_input_segments(nb_tessellator2D_t *const restrict mesh)\n{\n\tuint32_t removed = 0;\n\tfor (uint32_t i = 0; i < mesh->N_input_sgm; i++) {\n\t\tmsh_edge_t* restrict sgm = mesh->input_sgm[i];\n\t\tif (NULL != sgm) {\n\t\t\tif (NULL != sgm->t1 && NULL != sgm->t2) {\n\t\t\t\tmesh->input_sgm[i] = NULL;      \n\t\t\t\twhile (NULL != sgm) {\n\t\t\t\t\tmsh_edge_t* prev_sgm = sgm;\n\t\t\t\t\tsgm = medge_subsgm_next(sgm);\n\t\t\t\t\tmedge_destroy_subsgm_attribute(prev_sgm);\n\t\t\t\t\tremoved += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn removed;\n"]], "pred": {"ppl": 2.549968957901001, "ppl_lower": 2.6062779426574707, "ppl/lowercase_ppl": -1.023333384454116, "ppl/zlib": 0.0034669673545336377, "Min_5.0% Prob": 9.16555037865272, "Min_10.0% Prob": 6.822015055903682, "Min_20.0% Prob": 4.290936496041038, "Min_30.0% Prob": 3.044725371412484, "Min_40.0% Prob": 2.331821823594245, "Min_50.0% Prob": 1.8710917115643404, "Min_60.0% Prob": 1.560133517136326}}
{"hexsha": "288d170629d01cb26e375a7d80be0198ff4862f6", "ext": "c", "lang": "C", "content": "static int alltoall_handler(boot_t *boot) {\n  printf(\"Entering alltoall_handler at %d\\n\", HPX_LOCALITY_ID);\n  const int NLOC = HPX_LOCALITIES;\n  int src[NLOC][2];\n  int dst[NLOC][2];\n\n  int base = here->rank * here->ranks;\n  for (int i = 0; i < NLOC; ++i) {\n    src[i][0] = base + i;\n    src[i][1] = here->rank;\n    dst[i][0] = here->rank;\n    dst[i][1] = here->rank;\n  }\n\n  boot_barrier(boot);\n  static tatas_lock_t lock = SYNC_TATAS_LOCK_INIT;\n  sync_tatas_acquire(&lock);\n  {\n    printf(\"src@%d { \", here->rank);\n    for (int i = 0; i < NLOC; ++i) {\n      printf(\"{%d,%d} \", src[i][0], src[i][1]);\n    }\n    printf(\"}\\n\");\n    fflush(stdout);\n  }\n  sync_tatas_release(&lock);\n\n  boot_barrier(boot);\n  int e = boot_alltoall(boot, dst, src, 1*sizeof(int), 2*sizeof(int));\n  if (e) {\n    FAIL(dst, \"boot_alltoall returned failure code\\n\");\n  }\n\n  sync_tatas_acquire(&lock);\n  {\n    printf(\"dst@%d { \", here->rank);\n    for (int i = 0; i < NLOC; ++i) {\n      printf(\"{%d,%d} \", dst[i][0], dst[i][1]);\n    }\n    printf(\"}\\n\");\n    fflush(stdout);\n  }\n  sync_tatas_release(&lock);\n  boot_barrier(boot);\n\n  for (int i = 0; i < NLOC; ++i) {\n    if (dst[i][0] != i * NLOC + here->rank) {\n      FAIL(dst, \"%d:dst[%d][0]=%d, expected %d\\n\", here->rank, i, dst[i][0], i * NLOC + here->rank);\n    }\n    if (dst[i][1] != here->rank) {\n      FAIL(dst, \"%d:dst[%d][1]=%d, expected %d\\n\", here->rank, i, dst[i][1], here->rank);\n    }\n  }\n\n  return 0;\n}", "item_id": 0, "repo": "dkogler/hpx5-measurement-tests", "file": "tests/unit/libhpx_boot.c", "last_update_at": "2019-11-05T21:12:04+00:00", "question_id": "288d170629d01cb26e375a7d80be0198ff4862f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int alltoall_handler(boot_t *boot) {\n  printf(\"Entering alltoall_handler at %d\\n\", HPX_LOCALITY_ID);\n  const int NLOC = HPX_LOCALITIES;\n  int src[NLOC][2];\n  int dst[NLOC][2];\n  int base = here->rank * here->ranks;\n  for (int i = 0; i < NLOC; ++i) {\n    src[i][0] = base + i;\n    src[i][1] = here->rank;\n    dst[i][0] = here->rank;\n    dst[i][1] = here->rank;\n  }\n  boot_barrier(boot);\n  static tatas_lock_t lock = SYNC_TATAS_LOCK_INIT;\n  sync_tatas_acquire(&lock);\n  {\n    printf(\"src@%d { \", here->rank);\n    for (int i = 0; i < NLOC; ++i) {\n      printf(\"{%d,%d} \", src[i][0], src[i][1]);\n    }\n    printf(\"}\\n\");\n    fflush(stdout);\n  }\n  sync_tatas_release(&lock);\n  boot_barrier(boot);\n  int e = boot_alltoall(boot, dst, src, 1*sizeof(int), 2*sizeof(int));\n  if (e) {\n    FAIL(dst, \"boot_alltoall returned failure code\\n\");\n  }\n  sync_tatas_acquire(&lock);\n  {\n    printf(\"dst@%d { \", here->rank);\n    for (int i = 0; i < NLOC; ++i) {\n      printf(\"{%d,%d} \", dst[i][0], dst[i][1]);\n    }\n    printf(\"}\\n\");\n    fflush(stdout);\n  }\n  sync_tatas_release(&lock);\n  boot_barrier(boot);\n  for (int i = 0; i < NLOC; ++i) {\n    if (dst[i][0] != i * NLOC + here->rank) {\n      FAIL(dst, \"%d:dst[%d][0]=%d, expected %d\\n\", here->rank, i, dst[i][0], i * NLOC + here->rank);\n    }\n    if (dst[i][1] != here->rank) {\n      FAIL(dst, \"%d:dst[%d][1]=%d, expected %d\\n\", here->rank, i, dst[i][1], here->rank);\n    }\n  }\n  return 0;\n"]], "pred": {"ppl": 1.752422571182251, "ppl_lower": 1.877018690109253, "ppl/lowercase_ppl": -1.1224343336390932, "ppl/zlib": 0.0011197587964648214, "Min_5.0% Prob": 6.513465493917465, "Min_10.0% Prob": 4.571298848837614, "Min_20.0% Prob": 2.6773246263348778, "Min_30.0% Prob": 1.8593271703608913, "Min_40.0% Prob": 1.4010432765191032, "Min_50.0% Prob": 1.121066083609712, "Min_60.0% Prob": 0.9361549029710344}}
{"hexsha": "bd30014fc20e124985265e70130a5c61c3250db0", "ext": "h", "lang": "C", "content": "static inline void hri_eic_write_EVCTRL_EXTINTEO7_bit(const void *const hw, bool value)\n{\n\tuint32_t tmp;\n\tEIC_CRITICAL_SECTION_ENTER();\n\ttmp = ((Eic *)hw)->EVCTRL.reg;\n\ttmp &= ~EIC_EVCTRL_EXTINTEO7;\n\ttmp |= value << EIC_EVCTRL_EXTINTEO7_Pos;\n\t((Eic *)hw)->EVCTRL.reg = tmp;\n\tEIC_CRITICAL_SECTION_LEAVE();\n}", "item_id": 69, "repo": "arrow-acs/acn-embedded", "file": "SAMW25-ECC608A-ACT2018/SAMW25Demo/hri/hri_eic_d21.h", "last_update_at": "2019-08-20T18:29:03+00:00", "question_id": "bd30014fc20e124985265e70130a5c61c3250db0_69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_eic_write_EVCTRL_EXTINTEO7_bit(const void *const hw, bool value)\n{\n\tuint32_t tmp;\n\tEIC_CRITICAL_SECTION_ENTER();\n\ttmp = ((Eic *)hw)->EVCTRL.reg;\n\ttmp &= ~EIC_EVCTRL_EXTINTEO7;\n\ttmp |= value << EIC_EVCTRL_EXTINTEO7_Pos;\n\t((Eic *)hw)->EVCTRL.reg = tmp;\n\tEIC_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.251840591430664, "ppl_lower": 2.6004297733306885, "ppl/lowercase_ppl": -4.254733557368887, "ppl/zlib": 0.001157808976459694, "Min_5.0% Prob": 4.08689272403717, "Min_10.0% Prob": 2.244317373633385, "Min_20.0% Prob": 1.1302053128524372, "Min_30.0% Prob": 0.753673953436535, "Min_40.0% Prob": 0.5652738742164123, "Min_50.0% Prob": 0.45222331296771395, "Min_60.0% Prob": 0.3768535369893698}}
{"hexsha": "bdc19d54efd53cc0d7d231bd776f856f437aef63", "ext": "c", "lang": "C", "content": "void gfx_triangle( int x1, int y1, int x2, int y2, int x3, int y3 )\n{\n\tgfx_line(x1,y1,x2,y2);\n\tgfx_line(x2,y2,x3,y3);\n\tgfx_line(x3,y3,x1,y1);\n}", "item_id": 8, "repo": "ejavier48/M4_Sherman", "file": "ejemplo/X11_juego_minimo/gfxModified.c", "last_update_at": "2019-05-28T02:10:09+00:00", "question_id": "bdc19d54efd53cc0d7d231bd776f856f437aef63_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gfx_triangle( int x1, int y1, int x2, int y2, int x3, int y3 )\n{\n\tgfx_line(x1,y1,x2,y2);\n\tgfx_line(x2,y2,x3,y3);\n\tgfx_line(x3,y3,x1,y1);\n"]], "pred": {"ppl": 1.6883102655410767, "ppl_lower": 1.6883102655410767, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0058192020653729535, "Min_5.0% Prob": 7.013771414756775, "Min_10.0% Prob": 4.382998095618354, "Min_20.0% Prob": 2.5917180611027613, "Min_30.0% Prob": 1.7530955639150407, "Min_40.0% Prob": 1.3205251677944843, "Min_50.0% Prob": 1.0580422445096904, "Min_60.0% Prob": 0.8821336471117791}}
{"hexsha": "3d125b7fccfa256d5fc0acdd2ee71f38b7d6de89", "ext": "c", "lang": "C", "content": "void OvsSendControlPacketWithAutoSplit(OPENVPN_CHANNEL *c, UCHAR opcode, UCHAR *data, UINT data_size)\r\n{\r\n\tBUF *b;\r\n\t// Validate arguments\r\n\tif (c == NULL || (data_size != 0 && data == NULL))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tb = NewBuf();\r\n\tWriteBuf(b, data, data_size);\r\n\tSeekBuf(b, 0, 0);\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tUCHAR tmp[OPENVPN_CONTROL_PACKET_MAX_DATASIZE];\r\n\t\tUINT size = ReadBuf(b, tmp, sizeof(tmp));\r\n\r\n\t\tif (size == 0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tOvsSendControlPacket(c, opcode, tmp, size);\r\n\t\t//Debug(\" *** CNT SEND %u\\n\", size);\r\n\t}\r\n\r\n\tFreeBuf(b);\r\n}", "item_id": 18, "repo": "mba811/SoftEtherVPN", "file": "src/Cedar/Interop_OpenVPN.c", "last_update_at": "2019-05-07T15:09:30+00:00", "question_id": "3d125b7fccfa256d5fc0acdd2ee71f38b7d6de89_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void OvsSendControlPacketWithAutoSplit(OPENVPN_CHANNEL *c, UCHAR opcode, UCHAR *data, UINT data_size)\r\n{\r\n\tBUF *b;\r\n\t// Validate arguments\r\n\tif (c == NULL || (data_size != 0 && data == NULL))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tb = NewBuf();\r\n\tWriteBuf(b, data, data_size);\r\n\tSeekBuf(b, 0, 0);\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tUCHAR tmp[OPENVPN_CONTROL_PACKET_MAX_DATASIZE];\r\n\t\tUINT size = ReadBuf(b, tmp, sizeof(tmp));\r\n\r\n\t\tif (size == 0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tOvsSendControlPacket(c, opcode, tmp, size);\r\n\t\t//Debug(\" *** CNT SEND %u\\n\", size);\r\n\t}\r\n\r\n\tFreeBuf(b);\r\n"]], "pred": {"ppl": 2.2344889640808105, "ppl_lower": 3.656952381134033, "ppl/lowercase_ppl": -1.612698852747071, "ppl/zlib": 0.0023237356950948826, "Min_5.0% Prob": 7.74390957905696, "Min_10.0% Prob": 5.9965687073194065, "Min_20.0% Prob": 3.7864232510328293, "Min_30.0% Prob": 2.6682293877387657, "Min_40.0% Prob": 2.00582414042382, "Min_50.0% Prob": 1.612408261184531, "Min_60.0% Prob": 1.346452766071388}}
{"hexsha": "4d39fcc91a8189fc399a1624fd3984591d20e86f", "ext": "c", "lang": "C", "content": "int\nenc_clone_create(struct if_clone *ifc, int unit)\n{\n\tstruct enc_softc\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifnet\t\t**new;\n\tsize_t\t\t\t newlen;\n\tint\t\t\t error;\n\n\tif (unit > ENC_MAX_UNITS)\n\t\treturn (EINVAL);\n\n\tif ((sc = malloc(sizeof(struct enc_softc),\n\t    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)\n\t\treturn (ENOBUFS);\n\n\tsc->sc_unit = unit;\n\n\tifp = &sc->sc_if;\n\tifp->if_softc = sc;\n\tifp->if_type = IFT_ENC;\n\tifp->if_start = enc_start;\n\tifp->if_output = enc_output;\n\tifp->if_ioctl = enc_ioctl;\n\tifp->if_hdrlen = ENC_HDRLEN;\n\n\tsnprintf(ifp->if_xname, sizeof(ifp->if_xname), \"%s%d\",\n\t    ifc->ifc_name, unit);\n\n\tif_attach(ifp);\n\tif (unit == 0)\n\t\tif_addgroup(ifp, ifc->ifc_name);\n\t/*\n\t * enc(4) does not have a link-layer address but rtrequest()\n\t * wants an ifa for every route entry.  So let's setup a fake\n\t * and empty ifa of type AF_LINK for this purpose.\n\t */\n\tif_alloc_sadl(ifp);\n\tsc->sc_ifa.ifa_ifp = ifp;\n\tsc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);\n\tsc->sc_ifa.ifa_netmask = NULL;\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_ENC, ENC_HDRLEN);\n#endif\n\n\tif ((error = enc_setif(ifp, 0)) != 0) {\n\t\tif_detach(ifp);\n\t\tfree(sc, M_DEVBUF, 0);\n\t\treturn (error);\n\t}\n\n\tif (unit == 0 || unit > enc_max_unit) {\n\t\tif ((new = mallocarray(unit + 1, sizeof(struct ifnet *),\n\t\t    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)\n\t\t\treturn (ENOBUFS);\n\t\tnewlen = sizeof(struct ifnet *) * (unit + 1);\n\n\t\tif (enc_allifps != NULL) {\n\t\t\tmemcpy(new, enc_allifps,\n\t\t\t    sizeof(struct ifnet *) * (enc_max_unit + 1));\n\t\t\tfree(enc_allifps, M_DEVBUF, 0);\n\t\t}\n\t\tenc_allifps = new;\n\t\tenc_max_unit = unit;\n\t}\n\tenc_allifps[unit] = ifp;\n\n\treturn (0);\n}", "item_id": 1, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/net/if_enc.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "4d39fcc91a8189fc399a1624fd3984591d20e86f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nenc_clone_create(struct if_clone *ifc, int unit)\n{\n\tstruct enc_softc\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifnet\t\t**new;\n\tsize_t\t\t\t newlen;\n\tint\t\t\t error;\n\tif (unit > ENC_MAX_UNITS)\n\t\treturn (EINVAL);\n\tif ((sc = malloc(sizeof(struct enc_softc),\n\t    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)\n\t\treturn (ENOBUFS);\n\tsc->sc_unit = unit;\n\tifp = &sc->sc_if;\n\tifp->if_softc = sc;\n\tifp->if_type = IFT_ENC;\n\tifp->if_start = enc_start;\n\tifp->if_output = enc_output;\n\tifp->if_ioctl = enc_ioctl;\n\tifp->if_hdrlen = ENC_HDRLEN;\n\tsnprintf(ifp->if_xname, sizeof(ifp->if_xname), \"%s%d\",\n\t    ifc->ifc_name, unit);\n\tif_attach(ifp);\n\tif (unit == 0)\n\t\tif_addgroup(ifp, ifc->ifc_name);\n\t/*\n\t * enc(4) does not have a link-layer address but rtrequest()\n\t * wants an ifa for every route entry.  So let's setup a fake\n\t * and empty ifa of type AF_LINK for this purpose.\n\t */\n\tif_alloc_sadl(ifp);\n\tsc->sc_ifa.ifa_ifp = ifp;\n\tsc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);\n\tsc->sc_ifa.ifa_netmask = NULL;\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_ENC, ENC_HDRLEN);\n#endif\n\tif ((error = enc_setif(ifp, 0)) != 0) {\n\t\tif_detach(ifp);\n\t\tfree(sc, M_DEVBUF, 0);\n\t\treturn (error);\n\t}\n\tif (unit == 0 || unit > enc_max_unit) {\n\t\tif ((new = mallocarray(unit + 1, sizeof(struct ifnet *),\n\t\t    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)\n\t\t\treturn (ENOBUFS);\n\t\tnewlen = sizeof(struct ifnet *) * (unit + 1);\n\t\tif (enc_allifps != NULL) {\n\t\t\tmemcpy(new, enc_allifps,\n\t\t\t    sizeof(struct ifnet *) * (enc_max_unit + 1));\n\t\t\tfree(enc_allifps, M_DEVBUF, 0);\n\t\t}\n\t\tenc_allifps = new;\n\t\tenc_max_unit = unit;\n\t}\n\tenc_allifps[unit] = ifp;\n\treturn (0);\n"]], "pred": {"ppl": 1.7630892992019653, "ppl_lower": 2.1079061031341553, "ppl/lowercase_ppl": -1.3150022097919996, "ppl/zlib": 0.0007510828529503779, "Min_5.0% Prob": 5.488031834363937, "Min_10.0% Prob": 3.9917310282588003, "Min_20.0% Prob": 2.6043663408607243, "Min_30.0% Prob": 1.8524799002955357, "Min_40.0% Prob": 1.4094361766731813, "Min_50.0% Prob": 1.1333202593251506, "Min_60.0% Prob": 0.9460995087512379}}
{"hexsha": "37d2e19c5d7d5f4e1e8d3f79b1b7f346b5bfc130", "ext": "c", "lang": "C", "content": "void print_byte_sh(short s) {\n    int i;\n    unsigned char *p;\n    p = (unsigned char*)&s;\n    for (i=0; i<sizeof(short); i++) {\n        printf(\"%02x\", *p);\n        p++;\n    }\n    printf(\"\\n\");\n}", "item_id": 1, "repo": "wkentaro-archive/lecture2014s-utmech-soft2", "file": "08_140609/test-byteorder.c", "last_update_at": "2019-03-11T12:16:48+00:00", "question_id": "37d2e19c5d7d5f4e1e8d3f79b1b7f346b5bfc130_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_byte_sh(short s) {\n    int i;\n    unsigned char *p;\n    p = (unsigned char*)&s;\n    for (i=0; i<sizeof(short); i++) {\n        printf(\"%02x\", *p);\n        p++;\n    }\n    printf(\"\\n\");\n"]], "pred": {"ppl": 2.93204927444458, "ppl_lower": 2.93204927444458, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00785183642064432, "Min_5.0% Prob": 9.305706977844238, "Min_10.0% Prob": 7.044839893068586, "Min_20.0% Prob": 4.348381662368775, "Min_30.0% Prob": 3.1989707065665205, "Min_40.0% Prob": 2.571325780948003, "Min_50.0% Prob": 2.1048970551867234, "Min_60.0% Prob": 1.7763719949061456}}
{"hexsha": "d5d0fa98867aa7f61eed68d2a867cb18648f7bb9", "ext": "h", "lang": "C", "content": "class DevToolsBridgeClientBrowserTest : public WebUIBrowserTest {\n public:\n  DevToolsBridgeClientBrowserTest();\n  ~DevToolsBridgeClientBrowserTest() override;\n\n  // InProcessBrowserTest overrides.\n  void SetUpOnMainThread() override;\n  void TearDownOnMainThread() override;\n  content::WebUIMessageHandler* GetMockMessageHandler() override;\n\n private:\n  class DevToolsBridgeClientMock;\n  class GCDApiFlowMock;\n  class MessageHandler;\n\n  scoped_ptr<FakeSigninManagerForTesting> fake_signin_manager_;\n  scoped_ptr<ProfileOAuth2TokenService> fake_token_service_;\n  base::WeakPtr<DevToolsBridgeClientMock> client_mock_;\n  scoped_ptr<MessageHandler> handler_;\n  std::map<int, GCDApiFlowMock*> flows_;\n  int last_flow_id_;\n}", "item_id": 0, "repo": "kjthegod/chromium", "file": "chrome/browser/devtools/device/webrtc/devtools_bridge_client_browsertest.h", "last_update_at": "2019-11-28T10:46:52+00:00", "question_id": "d5d0fa98867aa7f61eed68d2a867cb18648f7bb9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class DevToolsBridgeClientBrowserTest : public WebUIBrowserTest {\n public:\n  DevToolsBridgeClientBrowserTest();\n  ~DevToolsBridgeClientBrowserTest() override;\n  // InProcessBrowserTest overrides.\n  void SetUpOnMainThread() override;\n  void TearDownOnMainThread() override;\n  content::WebUIMessageHandler* GetMockMessageHandler() override;\n private:\n  class DevToolsBridgeClientMock;\n  class GCDApiFlowMock;\n  class MessageHandler;\n  scoped_ptr<FakeSigninManagerForTesting> fake_signin_manager_;\n  scoped_ptr<ProfileOAuth2TokenService> fake_token_service_;\n  base::WeakPtr<DevToolsBridgeClientMock> client_mock_;\n  scoped_ptr<MessageHandler> handler_;\n  std::map<int, GCDApiFlowMock*> flows_;\n  int last_flow_id_;\n"]], "pred": {"ppl": 2.2812395095825195, "ppl_lower": 4.196688175201416, "ppl/lowercase_ppl": -1.7391327097107698, "ppl/zlib": 0.0025143870115820785, "Min_5.0% Prob": 6.663146279074929, "Min_10.0% Prob": 5.187179955569181, "Min_20.0% Prob": 3.616113069382581, "Min_30.0% Prob": 2.6709499196572737, "Min_40.0% Prob": 2.0513122507025687, "Min_50.0% Prob": 1.65458989841444, "Min_60.0% Prob": 1.3823374730632885}}
{"hexsha": "141a8b65ee598b6655e46524c3a51c2024f1ee9f", "ext": "c", "lang": "C", "content": "list* objectFileGetUnused(objectFile* src)\n{\n\tlist* res = newList();\n\t\n\tlistStart(src->sects);\n\twhile (listNext(src->sects))\n\t{\n\t\tchar* name = (char*) listGet(src->sects);\n\t\tgraph* curr = (graph*) hashmapGet(sectionMap, name);\n\t\t\n\t\tif (!graphGetColorNode(curr))\n\t\t\tlistAdd(res, graphGetNameNode(curr));\n\t}\n\t\n\treturn res;\n}", "item_id": 5, "repo": "probonopd/deadstrip", "file": "src/objectFile.c", "last_update_at": "2019-12-10T16:52:02+00:00", "question_id": "141a8b65ee598b6655e46524c3a51c2024f1ee9f_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["list* objectFileGetUnused(objectFile* src)\n{\n\tlist* res = newList();\n\t\n\tlistStart(src->sects);\n\twhile (listNext(src->sects))\n\t{\n\t\tchar* name = (char*) listGet(src->sects);\n\t\tgraph* curr = (graph*) hashmapGet(sectionMap, name);\n\t\t\n\t\tif (!graphGetColorNode(curr))\n\t\t\tlistAdd(res, graphGetNameNode(curr));\n\t}\n\t\n\treturn res;\n"]], "pred": {"ppl": 4.281299591064453, "ppl_lower": 4.435925483703613, "ppl/lowercase_ppl": -1.0243971145362119, "ppl/zlib": 0.007128708854292338, "Min_5.0% Prob": 10.063735008239746, "Min_10.0% Prob": 8.389109244713417, "Min_20.0% Prob": 5.89936886383937, "Min_30.0% Prob": 4.491515709803655, "Min_40.0% Prob": 3.5624024340739617, "Min_50.0% Prob": 2.899880170592895, "Min_60.0% Prob": 2.4336354208107176}}
{"hexsha": "82931df32875feec44e737581c4ab1a57193f39b", "ext": "c", "lang": "C", "content": "__API__ int tos_chr_fifo_pop_stream(k_chr_fifo_t *chr_fifo, uint8_t *buffer, size_t size)\n{\n    TOS_CPU_CPSR_ALLOC();\n    int i = 0;\n    uint8_t data;\n\n    TOS_PTR_SANITY_CHECK_RC(chr_fifo, 0);\n    TOS_OBJ_VERIFY_RC(chr_fifo, KNL_OBJ_TYPE_CHAR_FIFO, 0);\n\n    TOS_CPU_INT_DISABLE();\n\n    while (i < size) {\n        if (tos_ring_q_dequeue(&chr_fifo->ring_q, &data, K_NULL) != K_ERR_NONE) {\n            TOS_CPU_INT_ENABLE();\n            return i;\n        }\n        buffer[i++] = data;\n    }\n\n    TOS_CPU_INT_ENABLE();\n    return i;\n}", "item_id": 7, "repo": "githytera/TencentOS-tiny", "file": "kernel/core/tos_char_fifo.c", "last_update_at": "2019-11-19T01:30:02+00:00", "question_id": "82931df32875feec44e737581c4ab1a57193f39b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__API__ int tos_chr_fifo_pop_stream(k_chr_fifo_t *chr_fifo, uint8_t *buffer, size_t size)\n{\n    TOS_CPU_CPSR_ALLOC();\n    int i = 0;\n    uint8_t data;\n    TOS_PTR_SANITY_CHECK_RC(chr_fifo, 0);\n    TOS_OBJ_VERIFY_RC(chr_fifo, KNL_OBJ_TYPE_CHAR_FIFO, 0);\n    TOS_CPU_INT_DISABLE();\n    while (i < size) {\n        if (tos_ring_q_dequeue(&chr_fifo->ring_q, &data, K_NULL) != K_ERR_NONE) {\n            TOS_CPU_INT_ENABLE();\n            return i;\n        }\n        buffer[i++] = data;\n    }\n    TOS_CPU_INT_ENABLE();\n    return i;\n"]], "pred": {"ppl": 1.8030434846878052, "ppl_lower": 2.550438165664673, "ppl/lowercase_ppl": -1.5883005852249024, "ppl/zlib": 0.0020118636924697374, "Min_5.0% Prob": 6.586387713750203, "Min_10.0% Prob": 4.579918179512024, "Min_20.0% Prob": 2.7303258287906647, "Min_30.0% Prob": 1.9315931590398152, "Min_40.0% Prob": 1.463704982422071, "Min_50.0% Prob": 1.1806518653821614, "Min_60.0% Prob": 0.9870102618611264}}
{"hexsha": "22128d928e028100b70449ebf5787f50148970eb", "ext": "c", "lang": "C", "content": "static void post_drive_status(const struct drive_status *stat)\n{\n\tif (!shm)\n\t\treturn;\n\n\tstruct timespec now;\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\tlimiter_tag = stat->velocityLimiterTag;\n\n\tpthread_mutex_lock(&shm->stat_lock);\n\tshm->stat_time = now;\n\tshm->stat = *stat;\n\tpthread_cond_signal(&shm->stat_cond);\n\tpthread_mutex_unlock(&shm->stat_lock);\n}", "item_id": 2, "repo": "vml39/rosbeam-test", "file": "rosbeam/src/texclient-inject.c", "last_update_at": "2019-02-08T05:11:48+00:00", "question_id": "22128d928e028100b70449ebf5787f50148970eb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void post_drive_status(const struct drive_status *stat)\n{\n\tif (!shm)\n\t\treturn;\n\tstruct timespec now;\n\tclock_gettime(CLOCK_MONOTONIC, &now);\n\tlimiter_tag = stat->velocityLimiterTag;\n\tpthread_mutex_lock(&shm->stat_lock);\n\tshm->stat_time = now;\n\tshm->stat = *stat;\n\tpthread_cond_signal(&shm->stat_cond);\n\tpthread_mutex_unlock(&shm->stat_lock);\n"]], "pred": {"ppl": 2.8214058876037598, "ppl_lower": 3.286773681640625, "ppl/lowercase_ppl": -1.1471904561807578, "ppl/zlib": 0.004757960102857136, "Min_5.0% Prob": 9.464706829616002, "Min_10.0% Prob": 7.041676776749747, "Min_20.0% Prob": 4.500250339508057, "Min_30.0% Prob": 3.318616412406744, "Min_40.0% Prob": 2.5701535040962287, "Min_50.0% Prob": 2.069113107985013, "Min_60.0% Prob": 1.7395539614639577}}
{"hexsha": "82d533fd827037098d78ec478ad72bc07bcf3654", "ext": "c", "lang": "C", "content": "int ReadEEProm(unsigned char Line, USHORT Add)\n{\n  ULONG SendID ;\n  ULONG RecID ;\n  char SendLen ;\n  char SendData[8] ;\n  char RecLen ;\n  char RecData[8] ;\n  int i,j ;\n  \n  SendID = BuildCANId(0,0,0,1,Line,Add,0) ;\n  \n  for (i=0;i<512;i++) {\n    /* Request senden */\n    if (i%32==0) {\n      printf (\".\") ;\n      fflush(stdout);\n    } ;\n    SendLen = 4 ;\n    SendData[0] = READ_VAR ;\n    SendData[1] = (unsigned char)(i&0xFF) ;\n    SendData[2] = (unsigned char)(i>>8) ;\n    SendCANMessage (SendID,SendLen,SendData) ;\n    /* Daten empfangen */\n    for (j=0;j<10;j++) {\n      ReceiveCANMessage (&RecID,&RecLen,RecData) ;\n      if ((MatchAddress(RecID,0,1))&&(MatchSrcAddress(RecID,Line,Add))&&(RecData[0]==READ_VAR|SUCCESS)) break ;\n    } ;\n    if (j>=10) { \n      printf (\"Did not receive answer from %d %d\\n\",Line,Add) ;\n      return (-1);\n    } ;\n    FileBuffer[i] = RecData[3] ;\n  }\n  FileSize = 512 ;\n  return (0) ;\n}", "item_id": 14, "repo": "maveric00/HomeCANtrol", "file": "src/Server/MakeChecksum.c", "last_update_at": "2019-04-08T21:30:49+00:00", "question_id": "82d533fd827037098d78ec478ad72bc07bcf3654_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ReadEEProm(unsigned char Line, USHORT Add)\n{\n  ULONG SendID ;\n  ULONG RecID ;\n  char SendLen ;\n  char SendData[8] ;\n  char RecLen ;\n  char RecData[8] ;\n  int i,j ;\n  SendID = BuildCANId(0,0,0,1,Line,Add,0) ;\n  for (i=0;i<512;i++) {\n    /* Request senden */\n    if (i%32==0) {\n      printf (\".\") ;\n      fflush(stdout);\n    } ;\n    SendLen = 4 ;\n    SendData[0] = READ_VAR ;\n    SendData[1] = (unsigned char)(i&0xFF) ;\n    SendData[2] = (unsigned char)(i>>8) ;\n    SendCANMessage (SendID,SendLen,SendData) ;\n    /* Daten empfangen */\n    for (j=0;j<10;j++) {\n      ReceiveCANMessage (&RecID,&RecLen,RecData) ;\n      if ((MatchAddress(RecID,0,1))&&(MatchSrcAddress(RecID,Line,Add))&&(RecData[0]==READ_VAR|SUCCESS)) break ;\n    } ;\n    if (j>=10) { \n      printf (\"Did not receive answer from %d %d\\n\",Line,Add) ;\n      return (-1);\n    } ;\n    FileBuffer[i] = RecData[3] ;\n  }\n  FileSize = 512 ;\n  return (0) ;\n"]], "pred": {"ppl": 3.140899181365967, "ppl_lower": 3.350400686264038, "ppl/lowercase_ppl": -1.05641791999857, "ppl/zlib": 0.002445532312859635, "Min_5.0% Prob": 8.436764692005358, "Min_10.0% Prob": 6.6017674543918705, "Min_20.0% Prob": 4.6112613557260245, "Min_30.0% Prob": 3.46896502951614, "Min_40.0% Prob": 2.737109039002245, "Min_50.0% Prob": 2.2390003273235495, "Min_60.0% Prob": 1.8948259939040457}}
{"hexsha": "f429cbe01b0e9a3c60177a077af85c7307667ca7", "ext": "h", "lang": "C", "content": "MI_CALL R_IndicationC1_Set_id(\n    R_IndicationC1* self,\n    MI_Uint32 x)\n{\n    ((MI_Uint32Field*)&self->id)->value = x;\n    ((MI_Uint32Field*)&self->id)->exists = 1;\n    return MI_RESULT_OK;\n}", "item_id": 5, "repo": "Beguiled/omi", "file": "Unix/samples/Providers/Test_Indication/R_IndicationC1.h", "last_update_at": "2019-05-05T11:09:37+00:00", "question_id": "f429cbe01b0e9a3c60177a077af85c7307667ca7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MI_CALL R_IndicationC1_Set_id(\n    R_IndicationC1* self,\n    MI_Uint32 x)\n{\n    ((MI_Uint32Field*)&self->id)->value = x;\n    ((MI_Uint32Field*)&self->id)->exists = 1;\n    return MI_RESULT_OK;\n"]], "pred": {"ppl": 2.5872416496276855, "ppl_lower": 4.964967727661133, "ppl/lowercase_ppl": -1.6856929978657997, "ppl/zlib": 0.007201456879182353, "Min_5.0% Prob": 7.8291343450546265, "Min_10.0% Prob": 6.258223242229885, "Min_20.0% Prob": 4.268302089289615, "Min_30.0% Prob": 3.1844637202365056, "Min_40.0% Prob": 2.389871461022841, "Min_50.0% Prob": 1.8995855768832068, "Min_60.0% Prob": 1.6005965444716836}}
{"hexsha": "23dcb887f14a0cd6c6f819458d1247afd4ba1639", "ext": "c", "lang": "C", "content": "static void\nSTV_InitObj(struct sess *sp, struct object *o, unsigned wsl, unsigned lhttp,\n    unsigned nhttp)\n{\n\n\tmemset(o, 0, sizeof *o);\n\to->magic = OBJECT_MAGIC;\n\n\tassert(PAOK(wsl));\n\tassert(PAOK(lhttp));\n\n\to->http = HTTP_create(o + 1, nhttp);\n\tWS_Init(o->ws_o, \"obj\", (char *)(o + 1) + lhttp, wsl);\n\tWS_Assert(o->ws_o);\n\n\thttp_Setup(o->http, o->ws_o);\n\to->http->magic = HTTP_MAGIC;\n\to->grace = NAN;\n\to->entered = NAN;\n\tVTAILQ_INIT(&o->store);\n\tsp->wrk->stats.n_object++;\n}", "item_id": 2, "repo": "smallvil/Cache-Terminator", "file": "bin/varnishd/stevedore.c", "last_update_at": "2019-10-14T14:19:09+00:00", "question_id": "23dcb887f14a0cd6c6f819458d1247afd4ba1639_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nSTV_InitObj(struct sess *sp, struct object *o, unsigned wsl, unsigned lhttp,\n    unsigned nhttp)\n{\n\tmemset(o, 0, sizeof *o);\n\to->magic = OBJECT_MAGIC;\n\tassert(PAOK(wsl));\n\tassert(PAOK(lhttp));\n\to->http = HTTP_create(o + 1, nhttp);\n\tWS_Init(o->ws_o, \"obj\", (char *)(o + 1) + lhttp, wsl);\n\tWS_Assert(o->ws_o);\n\thttp_Setup(o->http, o->ws_o);\n\to->http->magic = HTTP_MAGIC;\n\to->grace = NAN;\n\to->entered = NAN;\n\tVTAILQ_INIT(&o->store);\n\tsp->wrk->stats.n_object++;\n"]], "pred": {"ppl": 2.9585909843444824, "ppl_lower": 3.99765944480896, "ppl/lowercase_ppl": -1.2774889552047075, "ppl/zlib": 0.0036645714060828108, "Min_5.0% Prob": 7.847841392863881, "Min_10.0% Prob": 6.22314698045904, "Min_20.0% Prob": 4.470277722676595, "Min_30.0% Prob": 3.3667578907573925, "Min_40.0% Prob": 2.6456535962911754, "Min_50.0% Prob": 2.1506129761406205, "Min_60.0% Prob": 1.8137490076889449}}
{"hexsha": "cc1859d7d2c560080a181593e8db8fbd5be89b94", "ext": "c", "lang": "C", "content": "void\ndb_set_ddb_regs(int type, mips_reg_t *tfp)\n{\n\tstruct frame *f = (struct frame *)&ddb_regs;\n\t\n\t/* Should switch to kdb`s own stack here. */\n\n\tif (type & T_USER)\n\t\t*f = *(struct frame *)curproc->p_md.md_regs;\n\telse {\n\t\t/* Synthetic full scale register context when trap happens */\n\t\tf->f_regs[AST] = tfp[0];\n\t\tf->f_regs[V0] = tfp[1];\n\t\tf->f_regs[V1] = tfp[2];\n\t\tf->f_regs[A0] = tfp[3];\n\t\tf->f_regs[A1] = tfp[4];\n\t\tf->f_regs[A2] = tfp[5];\n\t\tf->f_regs[A3] = tfp[6];\n\t\tf->f_regs[T0] = tfp[7];\n\t\tf->f_regs[T1] = tfp[8];\n\t\tf->f_regs[T2] = tfp[9];\n\t\tf->f_regs[T3] = tfp[10];\n\t\tf->f_regs[T4] = tfp[11];\n\t\tf->f_regs[T5] = tfp[12];\n\t\tf->f_regs[T6] = tfp[13];\n\t\tf->f_regs[T7] = tfp[14];\n\t\tf->f_regs[T8] = tfp[15];\n\t\tf->f_regs[T9] = tfp[16];\n\t\tf->f_regs[RA] = tfp[17];\n\t\tf->f_regs[SR] = tfp[18];\n\t\tf->f_regs[MULLO] = tfp[19];\n\t\tf->f_regs[MULHI] = tfp[20];\n\t\tf->f_regs[PC] = tfp[21];\n\t\tf->f_regs[S0] = kdbaux[0];\n\t\tf->f_regs[S1] = kdbaux[1];\n\t\tf->f_regs[S2] = kdbaux[2];\n\t\tf->f_regs[S3] = kdbaux[3];\n\t\tf->f_regs[S4] = kdbaux[4];\n\t\tf->f_regs[S5] = kdbaux[5];\n\t\tf->f_regs[S6] = kdbaux[6];\n\t\tf->f_regs[S7] = kdbaux[7];\n\t\tf->f_regs[SP] = kdbaux[8];\n\t\tf->f_regs[S8] = kdbaux[9];\n\t\tf->f_regs[GP] = kdbaux[10];\n\t}\n}", "item_id": 1, "repo": "shisa/kame-shisa", "file": "netbsd/sys/arch/mips/mips/db_interface.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "cc1859d7d2c560080a181593e8db8fbd5be89b94_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ndb_set_ddb_regs(int type, mips_reg_t *tfp)\n{\n\tstruct frame *f = (struct frame *)&ddb_regs;\n\t\n\t/* Should switch to kdb`s own stack here. */\n\tif (type & T_USER)\n\t\t*f = *(struct frame *)curproc->p_md.md_regs;\n\telse {\n\t\t/* Synthetic full scale register context when trap happens */\n\t\tf->f_regs[AST] = tfp[0];\n\t\tf->f_regs[V0] = tfp[1];\n\t\tf->f_regs[V1] = tfp[2];\n\t\tf->f_regs[A0] = tfp[3];\n\t\tf->f_regs[A1] = tfp[4];\n\t\tf->f_regs[A2] = tfp[5];\n\t\tf->f_regs[A3] = tfp[6];\n\t\tf->f_regs[T0] = tfp[7];\n\t\tf->f_regs[T1] = tfp[8];\n\t\tf->f_regs[T2] = tfp[9];\n\t\tf->f_regs[T3] = tfp[10];\n\t\tf->f_regs[T4] = tfp[11];\n\t\tf->f_regs[T5] = tfp[12];\n\t\tf->f_regs[T6] = tfp[13];\n\t\tf->f_regs[T7] = tfp[14];\n\t\tf->f_regs[T8] = tfp[15];\n\t\tf->f_regs[T9] = tfp[16];\n\t\tf->f_regs[RA] = tfp[17];\n\t\tf->f_regs[SR] = tfp[18];\n\t\tf->f_regs[MULLO] = tfp[19];\n\t\tf->f_regs[MULHI] = tfp[20];\n\t\tf->f_regs[PC] = tfp[21];\n\t\tf->f_regs[S0] = kdbaux[0];\n\t\tf->f_regs[S1] = kdbaux[1];\n\t\tf->f_regs[S2] = kdbaux[2];\n\t\tf->f_regs[S3] = kdbaux[3];\n\t\tf->f_regs[S4] = kdbaux[4];\n\t\tf->f_regs[S5] = kdbaux[5];\n\t\tf->f_regs[S6] = kdbaux[6];\n\t\tf->f_regs[S7] = kdbaux[7];\n\t\tf->f_regs[SP] = kdbaux[8];\n\t\tf->f_regs[S8] = kdbaux[9];\n\t\tf->f_regs[GP] = kdbaux[10];\n\t}\n"]], "pred": {"ppl": 1.5350178480148315, "ppl_lower": 1.5642198324203491, "ppl/lowercase_ppl": -1.0439751094400407, "ppl/zlib": 0.0010555221880364258, "Min_5.0% Prob": 6.099135725121749, "Min_10.0% Prob": 4.014687356195952, "Min_20.0% Prob": 2.1353890174890267, "Min_30.0% Prob": 1.4267671379179734, "Min_40.0% Prob": 1.0735579101289654, "Min_50.0% Prob": 0.8580116424062131, "Min_60.0% Prob": 0.7144897357929554}}
{"hexsha": "cb59a0bc1c36f41af05b98160f0953108a306291", "ext": "c", "lang": "C", "content": "intgo _wrap_airspy_close_spywrap_c67b9816208bfcb4(struct airspy_device *_swig_go_0) {\n  struct airspy_device *arg1 = (struct airspy_device *) 0 ;\n  int result;\n  intgo _swig_go_result;\n  \n  arg1 = *(struct airspy_device **)&_swig_go_0; \n  \n  result = (int)airspy_close(arg1);\n  _swig_go_result = result; \n  return _swig_go_result;\n}", "item_id": 58, "repo": "racerxdl/spy2go", "file": "spywrap/spywrap_wrap.c", "last_update_at": "2019-03-19T01:28:49+00:00", "question_id": "cb59a0bc1c36f41af05b98160f0953108a306291_58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["intgo _wrap_airspy_close_spywrap_c67b9816208bfcb4(struct airspy_device *_swig_go_0) {\n  struct airspy_device *arg1 = (struct airspy_device *) 0 ;\n  int result;\n  intgo _swig_go_result;\n  arg1 = *(struct airspy_device **)&_swig_go_0; \n  result = (int)airspy_close(arg1);\n  _swig_go_result = result; \n  return _swig_go_result;\n"]], "pred": {"ppl": 3.722722291946411, "ppl_lower": 3.722722291946411, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007966395148855271, "Min_5.0% Prob": 9.81454576764788, "Min_10.0% Prob": 7.56565424601237, "Min_20.0% Prob": 5.330829089687716, "Min_30.0% Prob": 4.199088459429533, "Min_40.0% Prob": 3.252603973111799, "Min_50.0% Prob": 2.616398459348159, "Min_60.0% Prob": 2.2023372680189146}}
{"hexsha": "0248175301b3662c026aefc3ba7a66bf004ec545", "ext": "c", "lang": "C", "content": "void\nvtc_log(struct vtclog *vl, unsigned lvl, const char *fmt, ...)\n{\n\n\tCHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);\n\tAZ(pthread_mutex_lock(&vl->mtx));\n\tassert(lvl < NLEAD);\n\tvsb_clear(vl->vsb);\n\tvsb_printf(vl->vsb, \"%s %-4s \", lead[lvl], vl->id);\n\tva_list ap;\n\tva_start(ap, fmt);\n\t(void)vsb_vprintf(vl->vsb, fmt, ap);\n\tva_end(ap);\n\tvsb_putc(vl->vsb, '\\n');\n\tvsb_finish(vl->vsb);\n\tAZ(vsb_overflowed(vl->vsb));\n\n\tvtc_log_emit(vl, lvl);\n\n\tvsb_clear(vl->vsb);\n\tAZ(pthread_mutex_unlock(&vl->mtx));\n\tif (lvl == 0) {\n\t\tvtc_error = 1;\n\t\tif (pthread_self() != vtc_thread)\n\t\t\tpthread_exit(NULL);\n\t}\n}", "item_id": 5, "repo": "smallvil/Cache-Terminator", "file": "bin/varnishtest/vtc_log.c", "last_update_at": "2019-10-14T14:19:09+00:00", "question_id": "0248175301b3662c026aefc3ba7a66bf004ec545_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nvtc_log(struct vtclog *vl, unsigned lvl, const char *fmt, ...)\n{\n\tCHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);\n\tAZ(pthread_mutex_lock(&vl->mtx));\n\tassert(lvl < NLEAD);\n\tvsb_clear(vl->vsb);\n\tvsb_printf(vl->vsb, \"%s %-4s \", lead[lvl], vl->id);\n\tva_list ap;\n\tva_start(ap, fmt);\n\t(void)vsb_vprintf(vl->vsb, fmt, ap);\n\tva_end(ap);\n\tvsb_putc(vl->vsb, '\\n');\n\tvsb_finish(vl->vsb);\n\tAZ(vsb_overflowed(vl->vsb));\n\tvtc_log_emit(vl, lvl);\n\tvsb_clear(vl->vsb);\n\tAZ(pthread_mutex_unlock(&vl->mtx));\n\tif (lvl == 0) {\n\t\tvtc_error = 1;\n\t\tif (pthread_self() != vtc_thread)\n\t\t\tpthread_exit(NULL);\n\t}\n"]], "pred": {"ppl": 2.167741537094116, "ppl_lower": 2.788893461227417, "ppl/lowercase_ppl": -1.3256606618882552, "ppl/zlib": 0.002223235227767105, "Min_5.0% Prob": 6.874649747212728, "Min_10.0% Prob": 5.148461707433065, "Min_20.0% Prob": 3.522904900253796, "Min_30.0% Prob": 2.5322655564093073, "Min_40.0% Prob": 1.9255415417435693, "Min_50.0% Prob": 1.5447631471173524, "Min_60.0% Prob": 1.294399813323727}}
{"hexsha": "796733335da986d21206f5eb101e10d413b1db99", "ext": "h", "lang": "C", "content": "namespace sco {\n\ntemplate<typename F>\ninline auto start_impl(const F& f, std::false_type&&) {\n    auto ch = std::make_shared<channel<decltype(f())>>();\n    routine::func_t func = [f, ch](){\n        auto r = f();\n        ch->send(r);\n    };\n    global_queue::inst()->push_routine(func);\n    return ch;\n}", "item_id": 0, "repo": "rickone/async", "file": "src/sco.h", "last_update_at": "2019-01-27T15:31:33+00:00", "question_id": "796733335da986d21206f5eb101e10d413b1db99_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace sco {\ntemplate<typename F>\ninline auto start_impl(const F& f, std::false_type&&) {\n    auto ch = std::make_shared<channel<decltype(f())>>();\n    routine::func_t func = [f, ch](){\n        auto r = f();\n        ch->send(r);\n    };\n    global_queue::inst()->push_routine(func);\n    return ch;\n"]], "pred": {"ppl": 5.024666786193848, "ppl_lower": 5.398532867431641, "ppl/lowercase_ppl": -1.044456083591046, "ppl/zlib": 0.007798836427735507, "Min_5.0% Prob": 9.733819580078125, "Min_10.0% Prob": 8.242364311218262, "Min_20.0% Prob": 5.7801887307848245, "Min_30.0% Prob": 4.6081732319247335, "Min_40.0% Prob": 3.781972195420946, "Min_50.0% Prob": 3.1314341150364786, "Min_60.0% Prob": 2.682257467319095}}
{"hexsha": "c8e3a31875ce057b7270ef653aca542cf61eca2d", "ext": "c", "lang": "C", "content": "JNICALL\nJava_com_intel_realsense_librealsense_FrameQueue_nPollForFrame(JNIEnv *env, jclass type,\n                                                               jlong handle) {\n    rs2_frame *output_frame = NULL;\n    rs2_error *e = NULL;\n    int rv = rs2_poll_for_frame((rs2_frame_queue *) handle, &output_frame, &e);\n    handle_error(env, e);\n    return (jlong) (rv ? output_frame : 0);\n}", "item_id": 1, "repo": "RitwikSaikia/librealsense", "file": "src/android/jni/frame_queue.c", "last_update_at": "2019-02-25T19:49:53+00:00", "question_id": "c8e3a31875ce057b7270ef653aca542cf61eca2d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_com_intel_realsense_librealsense_FrameQueue_nPollForFrame(JNIEnv *env, jclass type,\n                                                               jlong handle) {\n    rs2_frame *output_frame = NULL;\n    rs2_error *e = NULL;\n    int rv = rs2_poll_for_frame((rs2_frame_queue *) handle, &output_frame, &e);\n    handle_error(env, e);\n    return (jlong) (rv ? output_frame : 0);\n"]], "pred": {"ppl": 2.1705524921417236, "ppl_lower": 3.374634265899658, "ppl/lowercase_ppl": -1.5694394981178703, "ppl/zlib": 0.0037438731392256236, "Min_5.0% Prob": 6.406997362772624, "Min_10.0% Prob": 5.171637590114887, "Min_20.0% Prob": 3.4450356938220836, "Min_30.0% Prob": 2.494349706918001, "Min_40.0% Prob": 1.9150759610864851, "Min_50.0% Prob": 1.5413641203742694, "Min_60.0% Prob": 1.2986840263790922}}
{"hexsha": "969b126149b710c2a239ced0b77a191970eab637", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv) {\n  // initialise the Webots API\n  wb_robot_init();\n\n  // internal variables\n  int i;\n  int avoid_obstacle_counter = 0;\n\n  // initialise distance sensors\n  WbDeviceTag ds[2];\n  char ds_names[2][10] = {\"ds_left\", \"ds_right\"};\n  for (i = 0; i < 2; i++) {\n    ds[i] = wb_robot_get_device(ds_names[i]);\n    wb_distance_sensor_enable(ds[i], TIME_STEP);\n  }\n\n  // initialise motors\n  WbDeviceTag wheels[4];\n  char wheels_names[4][8] = {\"wheel1\", \"wheel2\", \"wheel3\", \"wheel4\"};\n  for (i = 0; i < 4; i++) {\n    wheels[i] = wb_robot_get_device(wheels_names[i]);\n    wb_motor_set_position(wheels[i], INFINITY);\n  }\n\n  // feedback loop\n  while (wb_robot_step(TIME_STEP) != -1) {\n    // init speeds\n    double left_speed = 1.0;\n    double right_speed = 1.0;\n\n    if (avoid_obstacle_counter > 0) {\n      avoid_obstacle_counter--;\n      left_speed = 1.0;\n      right_speed = -1.0;\n    } else {\n      // read sensors outputs\n      double ds_values[2];\n      for (i = 0; i < 2; i++)\n        ds_values[i] = wb_distance_sensor_get_value(ds[i]);\n\n      // increase counter in case of obstacle\n      if (ds_values[0] < 950.0 || ds_values[1] < 950.0)\n        avoid_obstacle_counter = 100;\n    }\n\n    // write actuators inputs\n    wb_motor_set_velocity(wheels[0], left_speed);\n    wb_motor_set_velocity(wheels[1], right_speed);\n    wb_motor_set_velocity(wheels[2], left_speed);\n    wb_motor_set_velocity(wheels[3], right_speed);\n  }\n\n  // cleanup the Webots API\n  wb_robot_cleanup();\n  return 0;  // EXIT_SUCCESS\n}", "item_id": 0, "repo": "yjf18340/webots", "file": "projects/samples/tutorials/controllers/4_wheels_collision_avoidance/4_wheels_collision_avoidance.c", "last_update_at": "2019-11-13T08:12:02+00:00", "question_id": "969b126149b710c2a239ced0b77a191970eab637_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv) {\n  // initialise the Webots API\n  wb_robot_init();\n  // internal variables\n  int i;\n  int avoid_obstacle_counter = 0;\n  // initialise distance sensors\n  WbDeviceTag ds[2];\n  char ds_names[2][10] = {\"ds_left\", \"ds_right\"};\n  for (i = 0; i < 2; i++) {\n    ds[i] = wb_robot_get_device(ds_names[i]);\n    wb_distance_sensor_enable(ds[i], TIME_STEP);\n  }\n  // initialise motors\n  WbDeviceTag wheels[4];\n  char wheels_names[4][8] = {\"wheel1\", \"wheel2\", \"wheel3\", \"wheel4\"};\n  for (i = 0; i < 4; i++) {\n    wheels[i] = wb_robot_get_device(wheels_names[i]);\n    wb_motor_set_position(wheels[i], INFINITY);\n  }\n  // feedback loop\n  while (wb_robot_step(TIME_STEP) != -1) {\n    // init speeds\n    double left_speed = 1.0;\n    double right_speed = 1.0;\n    if (avoid_obstacle_counter > 0) {\n      avoid_obstacle_counter--;\n      left_speed = 1.0;\n      right_speed = -1.0;\n    } else {\n      // read sensors outputs\n      double ds_values[2];\n      for (i = 0; i < 2; i++)\n        ds_values[i] = wb_distance_sensor_get_value(ds[i]);\n      // increase counter in case of obstacle\n      if (ds_values[0] < 950.0 || ds_values[1] < 950.0)\n        avoid_obstacle_counter = 100;\n    }\n    // write actuators inputs\n    wb_motor_set_velocity(wheels[0], left_speed);\n    wb_motor_set_velocity(wheels[1], right_speed);\n    wb_motor_set_velocity(wheels[2], left_speed);\n    wb_motor_set_velocity(wheels[3], right_speed);\n  }\n  // cleanup the Webots API\n  wb_robot_cleanup();\n  return 0;  // EXIT_SUCCESS\n"]], "pred": {"ppl": 1.4668165445327759, "ppl_lower": 1.605475902557373, "ppl/lowercase_ppl": -1.2357794320014464, "ppl/zlib": 0.0006311275724699911, "Min_5.0% Prob": 5.153977103531361, "Min_10.0% Prob": 3.258483450229351, "Min_20.0% Prob": 1.857273142528898, "Min_30.0% Prob": 1.2679298734339663, "Min_40.0% Prob": 0.9588009284787904, "Min_50.0% Prob": 0.7669672662748603, "Min_60.0% Prob": 0.6387219116276988}}
{"hexsha": "803277d15c6727a1e6fe7a613dd3598d51c56c5d", "ext": "c", "lang": "C", "content": "int MPI_Type_create_subarray(int ndims, int *array_of_sizes, \n                             int *array_of_subsizes, int *array_of_starts,\n                             int order, MPI_Datatype oldtype, \n                             MPI_Datatype *newtype)\n{\n    MPI_Aint extent, disps[3], size, size_with_aint;\n    int i, blklens[3];\n    MPI_Datatype tmp1, tmp2, types[3];\n    MPI_Offset size_with_offset;\n\n    if (ndims <= 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Invalid ndims argument\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_sizes <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_sizes is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_subsizes <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_subsizes is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_starts <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_starts is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n\n    for (i=0; i<ndims; i++) {\n        if (array_of_sizes[i] <= 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_sizes\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_subsizes[i] <= 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_subsizes\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_starts[i] < 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_starts\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_subsizes[i] > array_of_sizes[i]) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Error! array_of_subsizes[%d] > array_of_sizes[%d]\\n\", i, i);\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_starts[i] > (array_of_sizes[i] - array_of_subsizes[i])) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Error! array_of_starts[%d] > (array_of_sizes[%d] - array_of_subsizes[%d])\\n\", i, i, i);\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n    }\n\n    /* order argument checked below */\n\n    if (oldtype == MPI_DATATYPE_NULL) {\n        FPRINTF(stderr, \"MPI_Type_create_subarray: oldtype is an invalid datatype\\n\");\n        MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n\n    MPI_Type_extent(oldtype, &extent);\n\n/* check if MPI_Aint is large enough for size of global array. \n   if not, complain. */\n\n    size_with_aint = extent;\n    for (i=0; i<ndims; i++) size_with_aint *= array_of_sizes[i];\n    size_with_offset = extent;\n    for (i=0; i<ndims; i++) size_with_offset *= array_of_sizes[i];\n    if (size_with_aint != size_with_offset) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Can't use an array of this size unless the MPI implementation defines a 64-bit MPI_Aint\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n\n    if (order == MPI_ORDER_FORTRAN) {\n      /* dimension 0 changes fastest */\n\tif (ndims == 1)\n\t    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);\n\telse {\n\t    MPI_Type_vector(array_of_subsizes[1], array_of_subsizes[0],\n\t\t\t    array_of_sizes[0], oldtype, &tmp1);\n\t    \n\t    size = array_of_sizes[0]*extent;\n\t    for (i=2; i<ndims; i++) {\n\t\tsize *= array_of_sizes[i-1];\n\t\tMPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);\n\t\tMPI_Type_free(&tmp1);\n\t\ttmp1 = tmp2;\n\t    }\n\t}\n\t\n\t/* add displacement and UB */\n\t\n\tdisps[1] = array_of_starts[0];\n\tsize = 1;\n\tfor (i=1; i<ndims; i++) {\n\t    size *= array_of_sizes[i-1];\n\t    disps[1] += size*array_of_starts[i];\n\t}  \n        /* rest done below for both Fortran and C order */\n    }\n\n    else if (order == MPI_ORDER_C) {\n\t/* dimension ndims-1 changes fastest */\n\tif (ndims == 1)\n\t    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);\n\telse {\n\t    MPI_Type_vector(array_of_subsizes[ndims-2],\n\t\t\t    array_of_subsizes[ndims-1],\n\t\t\t    array_of_sizes[ndims-1], oldtype, &tmp1);\n\t    \n\t    size = array_of_sizes[ndims-1]*extent;\n\t    for (i=ndims-3; i>=0; i--) {\n\t\tsize *= array_of_sizes[i+1];\n\t\tMPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);\n\t\tMPI_Type_free(&tmp1);\n\t\ttmp1 = tmp2;\n\t    }\n\t}\n\t\n\t/* add displacement and UB */\n\t\n\tdisps[1] = array_of_starts[ndims-1];\n\tsize = 1;\n\tfor (i=ndims-2; i>=0; i--) {\n\t    size *= array_of_sizes[i+1];\n\t    disps[1] += size*array_of_starts[i];\n\t}\n    }\n    else {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Invalid order argument\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    \n    disps[1] *= extent;\n    \n    disps[2] = extent;\n    for (i=0; i<ndims; i++) disps[2] *= array_of_sizes[i];\n    \n    disps[0] = 0;\n    blklens[0] = blklens[1] = blklens[2] = 1;\n    types[0] = MPI_LB;\n    types[1] = tmp1;\n    types[2] = MPI_UB;\n    \n    MPI_Type_struct(3, blklens, disps, types, newtype);\n\n    MPI_Type_free(&tmp1);\n\n    return MPI_SUCCESS;\n}", "item_id": 0, "repo": "scottkwarren/config-db", "file": "NAMD_2.12_Source/charm-6.7.1/src/libs/ck-libs/ampi/romio/mpi2-other/array/subarray.c", "last_update_at": "2019-01-17T20:07:23+00:00", "question_id": "803277d15c6727a1e6fe7a613dd3598d51c56c5d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int MPI_Type_create_subarray(int ndims, int *array_of_sizes, \n                             int *array_of_subsizes, int *array_of_starts,\n                             int order, MPI_Datatype oldtype, \n                             MPI_Datatype *newtype)\n{\n    MPI_Aint extent, disps[3], size, size_with_aint;\n    int i, blklens[3];\n    MPI_Datatype tmp1, tmp2, types[3];\n    MPI_Offset size_with_offset;\n    if (ndims <= 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Invalid ndims argument\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_sizes <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_sizes is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_subsizes <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_subsizes is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (array_of_starts <= (int *) 0) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: array_of_starts is an invalid address\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    for (i=0; i<ndims; i++) {\n        if (array_of_sizes[i] <= 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_sizes\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_subsizes[i] <= 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_subsizes\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_starts[i] < 0) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Invalid value in array_of_starts\\n\");\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_subsizes[i] > array_of_sizes[i]) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Error! array_of_subsizes[%d] > array_of_sizes[%d]\\n\", i, i);\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n        if (array_of_starts[i] > (array_of_sizes[i] - array_of_subsizes[i])) {\n            FPRINTF(stderr, \"MPI_Type_create_subarray: Error! array_of_starts[%d] > (array_of_sizes[%d] - array_of_subsizes[%d])\\n\", i, i, i);\n            MPI_Abort(MPI_COMM_WORLD, 1);\n        }\n    }\n    /* order argument checked below */\n    if (oldtype == MPI_DATATYPE_NULL) {\n        FPRINTF(stderr, \"MPI_Type_create_subarray: oldtype is an invalid datatype\\n\");\n        MPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    MPI_Type_extent(oldtype, &extent);\n/* check if MPI_Aint is large enough for size of global array. \n   if not, complain. */\n    size_with_aint = extent;\n    for (i=0; i<ndims; i++) size_with_aint *= array_of_sizes[i];\n    size_with_offset = extent;\n    for (i=0; i<ndims; i++) size_with_offset *= array_of_sizes[i];\n    if (size_with_aint != size_with_offset) {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Can't use an array of this size unless the MPI implementation defines a 64-bit MPI_Aint\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    if (order == MPI_ORDER_FORTRAN) {\n      /* dimension 0 changes fastest */\n\tif (ndims == 1)\n\t    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);\n\telse {\n\t    MPI_Type_vector(array_of_subsizes[1], array_of_subsizes[0],\n\t\t\t    array_of_sizes[0], oldtype, &tmp1);\n\t    \n\t    size = array_of_sizes[0]*extent;\n\t    for (i=2; i<ndims; i++) {\n\t\tsize *= array_of_sizes[i-1];\n\t\tMPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);\n\t\tMPI_Type_free(&tmp1);\n\t\ttmp1 = tmp2;\n\t    }\n\t}\n\t\n\t/* add displacement and UB */\n\t\n\tdisps[1] = array_of_starts[0];\n\tsize = 1;\n\tfor (i=1; i<ndims; i++) {\n\t    size *= array_of_sizes[i-1];\n\t    disps[1] += size*array_of_starts[i];\n\t}  \n        /* rest done below for both Fortran and C order */\n    }\n    else if (order == MPI_ORDER_C) {\n\t/* dimension ndims-1 changes fastest */\n\tif (ndims == 1)\n\t    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);\n\telse {\n\t    MPI_Type_vector(array_of_subsizes[ndims-2],\n\t\t\t    array_of_subsizes[ndims-1],\n\t\t\t    array_of_sizes[ndims-1], oldtype, &tmp1);\n\t    \n\t    size = array_of_sizes[ndims-1]*extent;\n\t    for (i=ndims-3; i>=0; i--) {\n\t\tsize *= array_of_sizes[i+1];\n\t\tMPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);\n\t\tMPI_Type_free(&tmp1);\n\t\ttmp1 = tmp2;\n\t    }\n\t}\n\t\n\t/* add displacement and UB */\n\t\n\tdisps[1] = array_of_starts[ndims-1];\n\tsize = 1;\n\tfor (i=ndims-2; i>=0; i--) {\n\t    size *= array_of_sizes[i+1];\n\t    disps[1] += size*array_of_starts[i];\n\t}\n    }\n    else {\n\tFPRINTF(stderr, \"MPI_Type_create_subarray: Invalid order argument\\n\");\n\tMPI_Abort(MPI_COMM_WORLD, 1);\n    }\n    disps[1] *= extent;\n    disps[2] = extent;\n    for (i=0; i<ndims; i++) disps[2] *= array_of_sizes[i];\n    disps[0] = 0;\n    blklens[0] = blklens[1] = blklens[2] = 1;\n    types[0] = MPI_LB;\n    types[1] = tmp1;\n    types[2] = MPI_UB;\n    MPI_Type_struct(3, blklens, disps, types, newtype);\n    MPI_Type_free(&tmp1);\n    return MPI_SUCCESS;\n"]], "pred": {"ppl": 1.2866358757019043, "ppl_lower": 1.3773106336593628, "ppl/lowercase_ppl": -1.2702121074379835, "ppl/zlib": 0.0002236299589358073, "Min_5.0% Prob": 3.537995139757792, "Min_10.0% Prob": 2.2710492342126134, "Min_20.0% Prob": 1.2446475244108952, "Min_30.0% Prob": 0.8393881524839968, "Min_40.0% Prob": 0.6296462217860452, "Min_50.0% Prob": 0.5043575539389887, "Min_60.0% Prob": 0.42055272015727385}}
{"hexsha": "0cc24b4d4cbea9ef763acae849f45fd8b82a0aa4", "ext": "c", "lang": "C", "content": "void setGraphicsLcdTextPosition(uint8_t x, uint8_t page)\r\n{\r\n    txtIndex = (page << 7) + x;\r\n    setGraphicsLcdPage(page);\r\n    setGraphicsLcdColumn(x);\r\n}", "item_id": 9, "repo": "nihit30/Acoustic-local-positioning-system", "file": "just_for_reference.txt2.c", "last_update_at": "2019-06-04T02:32:27+00:00", "question_id": "0cc24b4d4cbea9ef763acae849f45fd8b82a0aa4_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void setGraphicsLcdTextPosition(uint8_t x, uint8_t page)\r\n{\r\n    txtIndex = (page << 7) + x;\r\n    setGraphicsLcdPage(page);\r\n    setGraphicsLcdColumn(x);\r\n"]], "pred": {"ppl": 7.340814590454102, "ppl_lower": 7.671521186828613, "ppl/lowercase_ppl": -1.0221049502762878, "ppl/zlib": 0.017641148814995934, "Min_5.0% Prob": 10.55978775024414, "Min_10.0% Prob": 9.248293781280518, "Min_20.0% Prob": 7.283806302330711, "Min_30.0% Prob": 5.807695613187902, "Min_40.0% Prob": 4.673076049141262, "Min_50.0% Prob": 3.8728999146099747, "Min_60.0% Prob": 3.3597895590698017}}
{"hexsha": "a9042f4faabb01e14c77bf3c8c1fe2728d1c4b44", "ext": "c", "lang": "C", "content": "static device_t\nagp_find_display(void)\n{\n\tdevclass_t pci = devclass_find(\"pci\");\n\tdevice_t bus, dev = 0;\n\tdevice_t *kids;\n\tint busnum, numkids, i;\n\n\tfor (busnum = 0; busnum < devclass_get_maxunit(pci); busnum++) {\n\t\tbus = devclass_get_device(pci, busnum);\n\t\tif (!bus)\n\t\t\tcontinue;\n\t\tdevice_get_children(bus, &kids, &numkids);\n\t\tfor (i = 0; i < numkids; i++) {\n\t\t\tdev = kids[i];\n\t\t\tif (pci_get_class(dev) == PCIC_DISPLAY\n\t\t\t    && pci_get_subclass(dev) == PCIS_DISPLAY_VGA)\n\t\t\t\tif (agp_find_caps(dev)) {\n\t\t\t\t\tfree(kids, M_TEMP);\n\t\t\t\t\treturn dev;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\tfree(kids, M_TEMP);\n\t}\n\n\treturn 0;\n}", "item_id": 1, "repo": "shisa/kame-shisa", "file": "freebsd5/sys/pci/agp.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "a9042f4faabb01e14c77bf3c8c1fe2728d1c4b44_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static device_t\nagp_find_display(void)\n{\n\tdevclass_t pci = devclass_find(\"pci\");\n\tdevice_t bus, dev = 0;\n\tdevice_t *kids;\n\tint busnum, numkids, i;\n\tfor (busnum = 0; busnum < devclass_get_maxunit(pci); busnum++) {\n\t\tbus = devclass_get_device(pci, busnum);\n\t\tif (!bus)\n\t\t\tcontinue;\n\t\tdevice_get_children(bus, &kids, &numkids);\n\t\tfor (i = 0; i < numkids; i++) {\n\t\t\tdev = kids[i];\n\t\t\tif (pci_get_class(dev) == PCIC_DISPLAY\n\t\t\t    && pci_get_subclass(dev) == PCIS_DISPLAY_VGA)\n\t\t\t\tif (agp_find_caps(dev)) {\n\t\t\t\t\tfree(kids, M_TEMP);\n\t\t\t\t\treturn dev;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\tfree(kids, M_TEMP);\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 1.5319164991378784, "ppl_lower": 1.7268396615982056, "ppl/lowercase_ppl": -1.280815693053249, "ppl/zlib": 0.0013412564948232226, "Min_5.0% Prob": 5.408148590723673, "Min_10.0% Prob": 3.615892398357391, "Min_20.0% Prob": 2.071902949301923, "Min_30.0% Prob": 1.4166174065321684, "Min_40.0% Prob": 1.0678261771449835, "Min_50.0% Prob": 0.8547210413146183, "Min_60.0% Prob": 0.7121250498133737}}
{"hexsha": "7fadc564b7275dee9bfb054b3051db4a87ae3993", "ext": "c", "lang": "C", "content": "ssize_t\nread_pos(int fd, fs_off_t _pos, void *data,  size_t nbytes)\n{\n    off_t  pos = (off_t)_pos;\n    size_t ret;\n    \n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        perror(\"read lseek\");\n        return EINVAL;\n    }\n    \n    ret = read(fd, data, nbytes);\n\n    if (ret != nbytes) {\n        printf(\"read_pos: wanted %d, got %d\\n\", nbytes, ret);\n        return -1;\n    }\n\n    return ret;\n}", "item_id": 0, "repo": "axeld/haiku", "file": "src/tests/add-ons/kernel/file_systems/userlandfs/r5/src/server/sysdep.c", "last_update_at": "2019-01-25T10:51:55+00:00", "question_id": "7fadc564b7275dee9bfb054b3051db4a87ae3993_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t\nread_pos(int fd, fs_off_t _pos, void *data,  size_t nbytes)\n{\n    off_t  pos = (off_t)_pos;\n    size_t ret;\n    if (lseek(fd, pos, SEEK_SET) < 0) {\n        perror(\"read lseek\");\n        return EINVAL;\n    }\n    ret = read(fd, data, nbytes);\n    if (ret != nbytes) {\n        printf(\"read_pos: wanted %d, got %d\\n\", nbytes, ret);\n        return -1;\n    }\n    return ret;\n"]], "pred": {"ppl": 2.373539447784424, "ppl_lower": 2.6479833126068115, "ppl/lowercase_ppl": -1.12658294815953, "ppl/zlib": 0.0038588494596493938, "Min_5.0% Prob": 7.405301749706268, "Min_10.0% Prob": 5.520806267857552, "Min_20.0% Prob": 3.726546034668431, "Min_30.0% Prob": 2.730232869386673, "Min_40.0% Prob": 2.1456400174083132, "Min_50.0% Prob": 1.7282647674072937, "Min_60.0% Prob": 1.4396744302846491}}
{"hexsha": "af727fd160b612d22a4b7034bbfff3981cbde824", "ext": "c", "lang": "C", "content": "STREAM* fastpath_input_pdu_init(rdpFastPath* fastpath, BYTE eventFlags, BYTE eventCode)\n{\n\trdpRdp *rdp;\n\tSTREAM* s;\n\n\trdp = fastpath->rdp;\n\n\ts = transport_send_stream_init(rdp->transport, 256);\n\tstream_seek(s, 3); /* fpInputHeader, length1 and length2 */\n\tif (rdp->do_crypt) {\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\tstream_seek(s, fastpath_get_sec_bytes(rdp));\n\tstream_write_BYTE(s, eventFlags | (eventCode << 5)); /* eventHeader (1 byte) */\n\treturn s;\n}", "item_id": 19, "repo": "Osirium/FreeRDP", "file": "libfreerdp/core/fastpath.c", "last_update_at": "2019-06-28T09:06:21+00:00", "question_id": "af727fd160b612d22a4b7034bbfff3981cbde824_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["STREAM* fastpath_input_pdu_init(rdpFastPath* fastpath, BYTE eventFlags, BYTE eventCode)\n{\n\trdpRdp *rdp;\n\tSTREAM* s;\n\trdp = fastpath->rdp;\n\ts = transport_send_stream_init(rdp->transport, 256);\n\tstream_seek(s, 3); /* fpInputHeader, length1 and length2 */\n\tif (rdp->do_crypt) {\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\tstream_seek(s, fastpath_get_sec_bytes(rdp));\n\tstream_write_BYTE(s, eventFlags | (eventCode << 5)); /* eventHeader (1 byte) */\n\treturn s;\n"]], "pred": {"ppl": 2.447227716445923, "ppl_lower": 3.2434561252593994, "ppl/lowercase_ppl": -1.3147458394949318, "ppl/zlib": 0.0028501778330230518, "Min_5.0% Prob": 6.855411052703857, "Min_10.0% Prob": 5.444414933522542, "Min_20.0% Prob": 3.865401034553846, "Min_30.0% Prob": 2.8551760162744255, "Min_40.0% Prob": 2.218689165233324, "Min_50.0% Prob": 1.7815548699072077, "Min_60.0% Prob": 1.4919062518739494}}
{"hexsha": "e8fadba2a92f6d8b97145ccaaaeda3cec7b9689b", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv)\n{\n\tblk_t\tblocks;\n\tint\tretval;\n\t\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage: %s device\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tretval = ext2fs_get_device_size(argv[1], 1024, &blocks);\n\tif (retval) {\n\t\tcom_err(argv[0], retval,\n\t\t\t\"while calling ext2fs_get_device_size\");\n\t\texit(1);\n\t}\n\tprintf(\"Device %s has %d 1k blocks.\\n\", argv[1], blocks);\n\texit(0);\n}", "item_id": 2, "repo": "impedimentToProgress/UCI-BlueChip", "file": "snapgear_linux/user/e2fsprogs/lib/ext2fs/getsize.c", "last_update_at": "2019-12-05T02:31:23+00:00", "question_id": "e8fadba2a92f6d8b97145ccaaaeda3cec7b9689b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv)\n{\n\tblk_t\tblocks;\n\tint\tretval;\n\t\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage: %s device\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tretval = ext2fs_get_device_size(argv[1], 1024, &blocks);\n\tif (retval) {\n\t\tcom_err(argv[0], retval,\n\t\t\t\"while calling ext2fs_get_device_size\");\n\t\texit(1);\n\t}\n\tprintf(\"Device %s has %d 1k blocks.\\n\", argv[1], blocks);\n\texit(0);\n"]], "pred": {"ppl": 1.8209840059280396, "ppl_lower": 1.8506826162338257, "ppl/lowercase_ppl": -1.0269905830980022, "ppl/zlib": 0.002550540500345386, "Min_5.0% Prob": 5.481382131576538, "Min_10.0% Prob": 3.8726748161845737, "Min_20.0% Prob": 2.5651592563938452, "Min_30.0% Prob": 1.895075485110283, "Min_40.0% Prob": 1.4846458857929385, "Min_50.0% Prob": 1.1975309238719043, "Min_60.0% Prob": 0.9985768360950585}}
{"hexsha": "b1236d76a3981d2d88b526cd96ca009b21fdb171", "ext": "c", "lang": "C", "content": "static void\nsparc64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n{\n  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n\n  tdep->gregset = regset_alloc (gdbarch, sparc64obsd_supply_gregset, NULL);\n  tdep->sizeof_gregset = 288;\n\n  tdep->fpregset = regset_alloc (gdbarch, sparc64obsd_supply_fpregset, NULL);\n  tdep->sizeof_fpregset = 272;\n\n  frame_unwind_append_sniffer (gdbarch, sparc64obsd_sigtramp_frame_sniffer);\n  frame_unwind_append_sniffer (gdbarch, sparc64obsd_trapframe_sniffer);\n\n  sparc64_init_abi (info, gdbarch);\n\n  /* OpenBSD/sparc64 has SVR4-style shared libraries...  */\n  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);\n  set_solib_svr4_fetch_link_map_offsets\n    (gdbarch, svr4_lp64_fetch_link_map_offsets);\n  set_gdbarch_skip_solib_resolver (gdbarch, obsd_skip_solib_resolver);\n}", "item_id": 6, "repo": "ArrogantWombatics/openbsd-src", "file": "gnu/usr.bin/binutils/gdb/sparc64obsd-tdep.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "b1236d76a3981d2d88b526cd96ca009b21fdb171_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsparc64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n{\n  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n  tdep->gregset = regset_alloc (gdbarch, sparc64obsd_supply_gregset, NULL);\n  tdep->sizeof_gregset = 288;\n  tdep->fpregset = regset_alloc (gdbarch, sparc64obsd_supply_fpregset, NULL);\n  tdep->sizeof_fpregset = 272;\n  frame_unwind_append_sniffer (gdbarch, sparc64obsd_sigtramp_frame_sniffer);\n  frame_unwind_append_sniffer (gdbarch, sparc64obsd_trapframe_sniffer);\n  sparc64_init_abi (info, gdbarch);\n  /* OpenBSD/sparc64 has SVR4-style shared libraries...  */\n  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);\n  set_solib_svr4_fetch_link_map_offsets\n    (gdbarch, svr4_lp64_fetch_link_map_offsets);\n  set_gdbarch_skip_solib_resolver (gdbarch, obsd_skip_solib_resolver);\n"]], "pred": {"ppl": 1.3537265062332153, "ppl_lower": 1.433088779449463, "ppl/lowercase_ppl": -1.188109082792109, "ppl/zlib": 0.0008778584481143044, "Min_5.0% Prob": 4.501436895794338, "Min_10.0% Prob": 2.759133256770469, "Min_20.0% Prob": 1.4934113509953022, "Min_30.0% Prob": 1.008631210421791, "Min_40.0% Prob": 0.7584790816637561, "Min_50.0% Prob": 0.6072203879178552, "Min_60.0% Prob": 0.5061048176500769}}
{"hexsha": "f0107fc6aa1f8cfe99c144a85e3ecc156e12dff9", "ext": "c", "lang": "C", "content": "SEC_BOOL SecMutex_TryLock(pthread_mutex_t *mutex)\n{\n    int ret;\n\n    SEC_TRACE(SEC_TRACE_MUTEX, \"TRYLOCK %p\", mutex);\n    ret = pthread_mutex_trylock(mutex);\n\n#ifdef SEC_USE_ROBUST_MUTEX\n    if (ret == EOWNERDEAD) {\n        SEC_LOG_ERROR(\"Dead mutex owner detected.  Attempting to recover.\");\n\n        ret = pthread_mutex_consistent(mutex);\n        if (0 != ret)\n        {\n            SEC_LOG_ERROR(\"pthread_mutex_consistent failed with error code %d\", ret);\n            goto done;\n        }\n\n        SEC_LOG_ERROR(\"mutex recovered.\");\n    }\n#endif\n\n    if (ret == 0) {\n        SEC_TRACE(SEC_TRACE_MUTEX, \"LOCKED %p\", mutex);\n    }\n\n#ifdef SEC_USE_ROBUST_MUTEX\ndone:\n#endif\n    return ret == 0;\n}", "item_id": 2, "repo": "DalavanCloud/rdkcryptoapi", "file": "src/sec_security_mutex.c", "last_update_at": "2019-02-02T05:30:52+00:00", "question_id": "f0107fc6aa1f8cfe99c144a85e3ecc156e12dff9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SEC_BOOL SecMutex_TryLock(pthread_mutex_t *mutex)\n{\n    int ret;\n    SEC_TRACE(SEC_TRACE_MUTEX, \"TRYLOCK %p\", mutex);\n    ret = pthread_mutex_trylock(mutex);\n#ifdef SEC_USE_ROBUST_MUTEX\n    if (ret == EOWNERDEAD) {\n        SEC_LOG_ERROR(\"Dead mutex owner detected.  Attempting to recover.\");\n        ret = pthread_mutex_consistent(mutex);\n        if (0 != ret)\n        {\n            SEC_LOG_ERROR(\"pthread_mutex_consistent failed with error code %d\", ret);\n            goto done;\n        }\n        SEC_LOG_ERROR(\"mutex recovered.\");\n    }\n#endif\n    if (ret == 0) {\n        SEC_TRACE(SEC_TRACE_MUTEX, \"LOCKED %p\", mutex);\n    }\n#ifdef SEC_USE_ROBUST_MUTEX\ndone:\n#endif\n    return ret == 0;\n"]], "pred": {"ppl": 1.988022804260254, "ppl_lower": 2.30798077583313, "ppl/lowercase_ppl": -1.217178907284346, "ppl/zlib": 0.0020949407900135776, "Min_5.0% Prob": 6.6458359105246405, "Min_10.0% Prob": 4.712249342884336, "Min_20.0% Prob": 2.9598776530801203, "Min_30.0% Prob": 2.1791532292085534, "Min_40.0% Prob": 1.691333676770068, "Min_50.0% Prob": 1.3732220235110169, "Min_60.0% Prob": 1.1437092118335572}}
{"hexsha": "057566832808670f43ce331d00c004e8c64d3bb3", "ext": "c", "lang": "C", "content": "static bool api_frsapi_GetDsPollingIntervalW(struct pipes_struct *p)\n{\n\tconst struct ndr_interface_call *call;\n\tstruct ndr_pull *pull;\n\tstruct ndr_push *push;\n\tenum ndr_err_code ndr_err;\n\tstruct frsapi_GetDsPollingIntervalW *r;\n\n\tcall = &ndr_table_frsapi.calls[NDR_FRSAPI_GETDSPOLLINGINTERVALW];\n\n\tr = talloc(talloc_tos(), struct frsapi_GetDsPollingIntervalW);\n\tif (r == NULL) {\n\t\treturn false;\n\t}\n\n\tpull = ndr_pull_init_blob(&p->in_data.data, r);\n\tif (pull == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tpull->flags |= LIBNDR_FLAG_REF_ALLOC;\n\tif (p->endian) {\n\t\tpull->flags |= LIBNDR_FLAG_BIGENDIAN;\n\t}\n\tndr_err = call->ndr_pull(pull, NDR_IN, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_IN, r);\n\t}\n\n\tZERO_STRUCT(r->out);\n\tr->out.CurrentInterval = talloc_zero(r, uint32_t);\n\tif (r->out.CurrentInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tr->out.DsPollingLongInterval = talloc_zero(r, uint32_t);\n\tif (r->out.DsPollingLongInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tr->out.DsPollingShortInterval = talloc_zero(r, uint32_t);\n\tif (r->out.DsPollingShortInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tr->out.result = _frsapi_GetDsPollingIntervalW(p, r);\n\n\tif (p->fault_state) {\n\t\ttalloc_free(r);\n\t\t/* Return true here, srv_pipe_hnd.c will take care */\n\t\treturn true;\n\t}\n\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_OUT | NDR_SET_VALUES, r);\n\t}\n\n\tpush = ndr_push_init_ctx(r);\n\tif (push == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\t/*\n\t * carry over the pointer count to the reply in case we are\n\t * using full pointer. See NDR specification for full pointers\n\t */\n\tpush->ptr_count = pull->ptr_count;\n\n\tndr_err = call->ndr_push(push, NDR_OUT, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\n\tp->out_data.rdata = ndr_push_blob(push);\n\ttalloc_steal(p->mem_ctx, p->out_data.rdata.data);\n\n\ttalloc_free(r);\n\n\treturn true;\n}", "item_id": 5, "repo": "zaion520/ATtomato", "file": "release/src-rt-6.x.4708/router/samba3/source3/librpc/gen_ndr/srv_frsapi.c", "last_update_at": "2019-02-15T01:21:02+00:00", "question_id": "057566832808670f43ce331d00c004e8c64d3bb3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool api_frsapi_GetDsPollingIntervalW(struct pipes_struct *p)\n{\n\tconst struct ndr_interface_call *call;\n\tstruct ndr_pull *pull;\n\tstruct ndr_push *push;\n\tenum ndr_err_code ndr_err;\n\tstruct frsapi_GetDsPollingIntervalW *r;\n\tcall = &ndr_table_frsapi.calls[NDR_FRSAPI_GETDSPOLLINGINTERVALW];\n\tr = talloc(talloc_tos(), struct frsapi_GetDsPollingIntervalW);\n\tif (r == NULL) {\n\t\treturn false;\n\t}\n\tpull = ndr_pull_init_blob(&p->in_data.data, r);\n\tif (pull == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tpull->flags |= LIBNDR_FLAG_REF_ALLOC;\n\tif (p->endian) {\n\t\tpull->flags |= LIBNDR_FLAG_BIGENDIAN;\n\t}\n\tndr_err = call->ndr_pull(pull, NDR_IN, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_IN, r);\n\t}\n\tZERO_STRUCT(r->out);\n\tr->out.CurrentInterval = talloc_zero(r, uint32_t);\n\tif (r->out.CurrentInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tr->out.DsPollingLongInterval = talloc_zero(r, uint32_t);\n\tif (r->out.DsPollingLongInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tr->out.DsPollingShortInterval = talloc_zero(r, uint32_t);\n\tif (r->out.DsPollingShortInterval == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tr->out.result = _frsapi_GetDsPollingIntervalW(p, r);\n\tif (p->fault_state) {\n\t\ttalloc_free(r);\n\t\t/* Return true here, srv_pipe_hnd.c will take care */\n\t\treturn true;\n\t}\n\tif (DEBUGLEVEL >= 10) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_OUT | NDR_SET_VALUES, r);\n\t}\n\tpush = ndr_push_init_ctx(r);\n\tif (push == NULL) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\t/*\n\t * carry over the pointer count to the reply in case we are\n\t * using full pointer. See NDR specification for full pointers\n\t */\n\tpush->ptr_count = pull->ptr_count;\n\tndr_err = call->ndr_push(push, NDR_OUT, r);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\ttalloc_free(r);\n\t\treturn false;\n\t}\n\tp->out_data.rdata = ndr_push_blob(push);\n\ttalloc_steal(p->mem_ctx, p->out_data.rdata.data);\n\ttalloc_free(r);\n\treturn true;\n"]], "pred": {"ppl": 1.7400697469711304, "ppl_lower": 1.9642927646636963, "ppl/lowercase_ppl": -1.2188148654829167, "ppl/zlib": 0.0007567284110508796, "Min_5.0% Prob": 6.977729452417252, "Min_10.0% Prob": 4.788678688752023, "Min_20.0% Prob": 2.72279469130551, "Min_30.0% Prob": 1.8410434622629075, "Min_40.0% Prob": 1.386482065467954, "Min_50.0% Prob": 1.1087185222098788, "Min_60.0% Prob": 0.9234509374288223}}
{"hexsha": "19556a6476a41e613535f6e16fb48f0169b72b69", "ext": "c", "lang": "C", "content": "int RecordPage(LinkedList *data, string title, string record(void *, uint8_t)) { \n  LinkedListNode *p, *re[100];//\u76ee\u6807\u8282\u70b9\uff0c\u5206\u9875\u6570\u7ec4\n  int num = 0, count = 1, j = 0, y = 0;//\u5e8f\u53f7\uff0c\u8ba1\u6570\u5668\uff0c\u9875\u7801\uff0c\u9009\u4e2d\u884c\n  bool printed = false;\n  char a, b;//\u8bfb\u53d6\u6309\u952eascii\u7801\n  int end;//\u6700\u7ec8\u8bb0\u5f55\u6761\u6570+1\n  p = data->top;\n  re[0] = data->top;\n  PrintString(title);\n  while (1) {\n    if ((count - 1) % hangshu == 0 && count != 1 || p == data->rear->next) {\n      end = count;\n      if (p == data->rear->next && (count - 1) % hangshu != 0) {\n        count = (count + hangshu - 1) / hangshu * hangshu + 1;//\u8fdb\u4f4d\u53d6\u6574+1\uff1a\u598239->41\n      }\n\n      if (!printed) {\n        gotoxy(0, 11);\n        PrintLITERAL(\"  \u4fee\u6539\u8bb0\u5f55: Enter  \u8fd4\u56de\u4e0a\u4e00\u7ea7: Backspace  \u5de6\u7ffb\u9875: \u2190  \u53f3\u7ffb\u9875: \u2192\\n\");\n        printed = true;\n      }\n\n      a = _getch();\n      if (a < 0) {\n        b = _getch();\n        if (b == 75 && count > 1 + hangshu) {//\u5de6\u7ffb\u9875\n          count -= hangshu;\n          if (j > 0) j--;\n          p = re[j];\n          UI_Clear();\n          PrintString(title);\n          printed = false;\n        }\n        else if (b == 77 && p != data->rear->next) {//\u53f3\u7ffb\u9875\n          j++;\n          re[j] = p;\n          UI_Clear();\n          PrintString(title);\n          printed = false;\n        }\n        else//\u9501\u5b9a\u5176\u4ed6\u6309\u952e\n          continue;\n      }\n      if (a == 8) {\n        UI_Clear();\n        return -1;\n      }//Backspace\n      if (a == 13)break;//\u56de\u8f66\u9000\u51fa\n    }\n    num++;\n    PrintLITERAL(\"[ ]\");\n    PrintString(record(p->data, num));\n    p = p->next;\n    count++;\n  }\n  gotoxy(0, 11);\n  PrintLITERAL(\"  \u5411\u4e0a\u79fb\u52a8: \u2191  \u5411\u4e0b\u79fb\u52a8: \u2193                                                     \");\n  int count0 = end;//\u62f7\u8d1d\uff08\u771f\u5b9e\u8bb0\u5f55\u884c\u6570+1\uff09\n  if ((count0 - 1) % hangshu == 0) {\n    y = OptionBar(2, 2 + hangshu - 1);\n  }\n  else {\n    if (count0 > hangshu) {\n      count0 = count0 - (count0 / hangshu * hangshu) - 1;//\u8bb0\u5f55\u672b\u9875\u884c\u6570\uff1a\u5982\u8bb0\u5f5538\u6761\uff0c\u672b\u98758\u884c\n    }\n    y = OptionBar(2, 2 + count0 - 1);\n  }\n  return j * hangshu + y;\n}", "item_id": 6, "repo": "Yesterday17/ProgramDesignHomework", "file": "ProgramDesignHomework/ui/ui.c", "last_update_at": "2019-04-23T14:09:22+00:00", "question_id": "19556a6476a41e613535f6e16fb48f0169b72b69_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int RecordPage(LinkedList *data, string title, string record(void *, uint8_t)) { \n  LinkedListNode *p, *re[100];//\u76ee\u6807\u8282\u70b9\uff0c\u5206\u9875\u6570\u7ec4\n  int num = 0, count = 1, j = 0, y = 0;//\u5e8f\u53f7\uff0c\u8ba1\u6570\u5668\uff0c\u9875\u7801\uff0c\u9009\u4e2d\u884c\n  bool printed = false;\n  char a, b;//\u8bfb\u53d6\u6309\u952eascii\u7801\n  int end;//\u6700\u7ec8\u8bb0\u5f55\u6761\u6570+1\n  p = data->top;\n  re[0] = data->top;\n  PrintString(title);\n  while (1) {\n    if ((count - 1) % hangshu == 0 && count != 1 || p == data->rear->next) {\n      end = count;\n      if (p == data->rear->next && (count - 1) % hangshu != 0) {\n        count = (count + hangshu - 1) / hangshu * hangshu + 1;//\u8fdb\u4f4d\u53d6\u6574+1\uff1a\u598239->41\n      }\n      if (!printed) {\n        gotoxy(0, 11);\n        PrintLITERAL(\"  \u4fee\u6539\u8bb0\u5f55: Enter  \u8fd4\u56de\u4e0a\u4e00\u7ea7: Backspace  \u5de6\u7ffb\u9875: \u2190  \u53f3\u7ffb\u9875: \u2192\\n\");\n        printed = true;\n      }\n      a = _getch();\n      if (a < 0) {\n        b = _getch();\n        if (b == 75 && count > 1 + hangshu) {//\u5de6\u7ffb\u9875\n          count -= hangshu;\n          if (j > 0) j--;\n          p = re[j];\n          UI_Clear();\n          PrintString(title);\n          printed = false;\n        }\n        else if (b == 77 && p != data->rear->next) {//\u53f3\u7ffb\u9875\n          j++;\n          re[j] = p;\n          UI_Clear();\n          PrintString(title);\n          printed = false;\n        }\n        else//\u9501\u5b9a\u5176\u4ed6\u6309\u952e\n          continue;\n      }\n      if (a == 8) {\n        UI_Clear();\n        return -1;\n      }//Backspace\n      if (a == 13)break;//\u56de\u8f66\u9000\u51fa\n    }\n    num++;\n    PrintLITERAL(\"[ ]\");\n    PrintString(record(p->data, num));\n    p = p->next;\n    count++;\n  }\n  gotoxy(0, 11);\n  PrintLITERAL(\"  \u5411\u4e0a\u79fb\u52a8: \u2191  \u5411\u4e0b\u79fb\u52a8: \u2193                                                     \");\n  int count0 = end;//\u62f7\u8d1d\uff08\u771f\u5b9e\u8bb0\u5f55\u884c\u6570+1\uff09\n  if ((count0 - 1) % hangshu == 0) {\n    y = OptionBar(2, 2 + hangshu - 1);\n  }\n  else {\n    if (count0 > hangshu) {\n      count0 = count0 - (count0 / hangshu * hangshu) - 1;//\u8bb0\u5f55\u672b\u9875\u884c\u6570\uff1a\u5982\u8bb0\u5f5538\u6761\uff0c\u672b\u98758\u884c\n    }\n    y = OptionBar(2, 2 + count0 - 1);\n  }\n  return j * hangshu + y;\n"]], "pred": {"ppl": 3.2998223304748535, "ppl_lower": 3.2703633308410645, "ppl/lowercase_ppl": -0.9924886721381401, "ppl/zlib": 0.001276864842537974, "Min_5.0% Prob": 8.111802868726777, "Min_10.0% Prob": 6.347720585673688, "Min_20.0% Prob": 4.600912165499019, "Min_30.0% Prob": 3.567624245506834, "Min_40.0% Prob": 2.8513505584268426, "Min_50.0% Prob": 2.3430459854284162, "Min_60.0% Prob": 1.9784416103089948}}
{"hexsha": "d9794c4664cdbf804d2d4421f93172abb61ac15d", "ext": "c", "lang": "C", "content": "static int luacef_CommandLine_Copy(lua_State *L)\r\n{\r\n\tluacef_CommandLine *p = luacef_toudata(L, 1);\r\n\r\n\tluacef_CommandLine *cpy = p->copy(p);\r\n\r\n\tluacef_pushudata(L, cpy, __CefCommandLine);\r\n\treturn 1;\r\n}", "item_id": 2, "repo": "exect3r/luacef", "file": "src/api/command_line.c", "last_update_at": "2019-10-20T04:12:55+00:00", "question_id": "d9794c4664cdbf804d2d4421f93172abb61ac15d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int luacef_CommandLine_Copy(lua_State *L)\r\n{\r\n\tluacef_CommandLine *p = luacef_toudata(L, 1);\r\n\r\n\tluacef_CommandLine *cpy = p->copy(p);\r\n\r\n\tluacef_pushudata(L, cpy, __CefCommandLine);\r\n\treturn 1;\r\n"]], "pred": {"ppl": 2.9363057613372803, "ppl_lower": 4.151059627532959, "ppl/lowercase_ppl": -1.3214136041804405, "ppl/zlib": 0.008222536240264906, "Min_5.0% Prob": 9.255571126937866, "Min_10.0% Prob": 6.916710482703315, "Min_20.0% Prob": 4.830548220210606, "Min_30.0% Prob": 3.548006565482528, "Min_40.0% Prob": 2.682435727602727, "Min_50.0% Prob": 2.1738110941065396, "Min_60.0% Prob": 1.8204440842213279}}
{"hexsha": "314d250524b5691759b14f7e7b3aa3ab5a940c5f", "ext": "c", "lang": "C", "content": "X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\r\n\t{\r\n\tX509_NAME_ENTRY *ret;\r\n\tint i,n,set_prev,set_next;\r\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\r\n\r\n\tif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\r\n\t    || loc < 0)\r\n\t\treturn(NULL);\r\n\tsk=name->entries;\r\n\tret=sk_X509_NAME_ENTRY_delete(sk,loc);\r\n\tn=sk_X509_NAME_ENTRY_num(sk);\r\n\tname->modified=1;\r\n\tif (loc == n) return(ret);\r\n\r\n\t/* else we need to fixup the set field */\r\n\tif (loc != 0)\r\n\t\tset_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;\r\n\telse\r\n\t\tset_prev=ret->set-1;\r\n\tset_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;\r\n\r\n\t/* set_prev is the previous set\r\n\t * set is the current set\r\n\t * set_next is the following\r\n\t * prev  1 1\t1 1\t1 1\t1 1\r\n\t * set   1\t1\t2\t2\r\n\t * next  1 1\t2 2\t2 2\t3 2\r\n\t * so basically only if prev and next differ by 2, then\r\n\t * re-number down by 1 */\r\n\tif (set_prev+1 < set_next)\r\n\t\tfor (i=loc; i<n; i++)\r\n\t\t\tsk_X509_NAME_ENTRY_value(sk,i)->set--;\r\n\treturn(ret);\r\n\t}", "item_id": 4, "repo": "jiangzhu1212/oooii", "file": "Ouroboros/External/OpenSSL/openssl-1.0.0e/crypto/x509/x509name.c", "last_update_at": "2019-10-10T12:58:41+00:00", "question_id": "314d250524b5691759b14f7e7b3aa3ab5a940c5f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\r\n\t{\r\n\tX509_NAME_ENTRY *ret;\r\n\tint i,n,set_prev,set_next;\r\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\r\n\r\n\tif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\r\n\t    || loc < 0)\r\n\t\treturn(NULL);\r\n\tsk=name->entries;\r\n\tret=sk_X509_NAME_ENTRY_delete(sk,loc);\r\n\tn=sk_X509_NAME_ENTRY_num(sk);\r\n\tname->modified=1;\r\n\tif (loc == n) return(ret);\r\n\r\n\t/* else we need to fixup the set field */\r\n\tif (loc != 0)\r\n\t\tset_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;\r\n\telse\r\n\t\tset_prev=ret->set-1;\r\n\tset_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;\r\n\r\n\t/* set_prev is the previous set\r\n\t * set is the current set\r\n\t * set_next is the following\r\n\t * prev  1 1\t1 1\t1 1\t1 1\r\n\t * set   1\t1\t2\t2\r\n\t * next  1 1\t2 2\t2 2\t3 2\r\n\t * so basically only if prev and next differ by 2, then\r\n\t * re-number down by 1 */\r\n\tif (set_prev+1 < set_next)\r\n\t\tfor (i=loc; i<n; i++)\r\n\t\t\tsk_X509_NAME_ENTRY_value(sk,i)->set--;\r\n\treturn(ret);\r\n"]], "pred": {"ppl": 2.24898099899292, "ppl_lower": 2.4263601303100586, "ppl/lowercase_ppl": -1.0936670631378456, "ppl/zlib": 0.0017657455866982544, "Min_5.0% Prob": 6.59597519169683, "Min_10.0% Prob": 5.099414460202481, "Min_20.0% Prob": 3.5168952716024298, "Min_30.0% Prob": 2.5972831697313934, "Min_40.0% Prob": 2.008449836005091, "Min_50.0% Prob": 1.620053272974915, "Min_60.0% Prob": 1.3520071541806131}}
{"hexsha": "5ca10e75df169c4d015e2cbb646c6343cd75149d", "ext": "h", "lang": "C", "content": "static inline void hri_tcc_clear_PATT_PGE6_bit(const void *const hw)\n{\n\tTCC_CRITICAL_SECTION_ENTER();\n\thri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_MASK);\n\t((Tcc *)hw)->PATT.reg &= ~TCC_PATT_PGE6;\n\tTCC_CRITICAL_SECTION_LEAVE();\n}", "item_id": 859, "repo": "jinlongliu/AliOS-Things", "file": "platform/mcu/atsamd5x_e5x/Drivers/hri/hri_tcc_e54.h", "last_update_at": "2019-09-25T07:17:27+00:00", "question_id": "5ca10e75df169c4d015e2cbb646c6343cd75149d_859", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_tcc_clear_PATT_PGE6_bit(const void *const hw)\n{\n\tTCC_CRITICAL_SECTION_ENTER();\n\thri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_MASK);\n\t((Tcc *)hw)->PATT.reg &= ~TCC_PATT_PGE6;\n\tTCC_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.4782973527908325, "ppl_lower": 4.321905136108398, "ppl/lowercase_ppl": -3.7445128000215053, "ppl/zlib": 0.002246499932250358, "Min_5.0% Prob": 5.282298851013183, "Min_10.0% Prob": 3.6309135502034966, "Min_20.0% Prob": 2.008241651660722, "Min_30.0% Prob": 1.328262421688331, "Min_40.0% Prob": 0.989626507528691, "Min_50.0% Prob": 0.7883872928828399, "Min_60.0% Prob": 0.6551502555290861}}
{"hexsha": "b18b4bf16db1cfd73b04ed75ba7b2ebf8f24cdf1", "ext": "h", "lang": "C", "content": "class MaOpenSslConfig : public MaSslConfig {\n  public:\n\tSSL_CTX\t\t\t*context;\n\tRSA\t\t\t\t*rsaKey512;\n\tRSA\t\t\t\t*rsaKey1024;\n\tDH\t\t\t\t*dhKey512;\n\tDH\t\t\t\t*dhKey1024;\n\n  public:\n\t\t\t\t\tMaOpenSslConfig(MaHost *host);\n\t\t\t\t\t~MaOpenSslConfig();\n\n\tMprSocket \t\t*newSocket();\n\tSSL_CTX\t\t\t*getContext();\n\tint\t\t\t\tstart();\n\tvoid\t\t\tstop();\n}", "item_id": 2, "repo": "linbc/appweb2-win", "file": "http/modules/openSsl/openSslModule.h", "last_update_at": "2019-12-11T02:29:49+00:00", "question_id": "b18b4bf16db1cfd73b04ed75ba7b2ebf8f24cdf1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class MaOpenSslConfig : public MaSslConfig {\n  public:\n\tSSL_CTX\t\t\t*context;\n\tRSA\t\t\t\t*rsaKey512;\n\tRSA\t\t\t\t*rsaKey1024;\n\tDH\t\t\t\t*dhKey512;\n\tDH\t\t\t\t*dhKey1024;\n  public:\n\t\t\t\t\tMaOpenSslConfig(MaHost *host);\n\t\t\t\t\t~MaOpenSslConfig();\n\tMprSocket \t\t*newSocket();\n\tSSL_CTX\t\t\t*getContext();\n\tint\t\t\t\tstart();\n\tvoid\t\t\tstop();\n"]], "pred": {"ppl": 2.655975818634033, "ppl_lower": 3.3634159564971924, "ppl/lowercase_ppl": -1.241750667858794, "ppl/zlib": 0.005308761560558611, "Min_5.0% Prob": 8.542072713375092, "Min_10.0% Prob": 6.463176376679364, "Min_20.0% Prob": 4.382979280808392, "Min_30.0% Prob": 3.166516062675738, "Min_40.0% Prob": 2.4160452785267346, "Min_50.0% Prob": 1.9566378180197506, "Min_60.0% Prob": 1.6387937798354666}}
{"hexsha": "c836c718b3bd006619ec6c0aa38ee849157a3c66", "ext": "c", "lang": "C", "content": "void * auth_simple_init_data() {\n    auth_simple_global_data *global = (auth_simple_global_data*)malloc(sizeof(auth_simple_global_data));\n    rand_bytes(global->local_client_id, 8);\n    rand_bytes((uint8_t*)&global->connection_id, 4);\n    global->connection_id &= 0xFFFFFF;\n    return global;\n}", "item_id": 1, "repo": "networkextension/obfsplugin", "file": "c/auth.c", "last_update_at": "2019-01-06T05:30:53+00:00", "question_id": "c836c718b3bd006619ec6c0aa38ee849157a3c66_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void * auth_simple_init_data() {\n    auth_simple_global_data *global = (auth_simple_global_data*)malloc(sizeof(auth_simple_global_data));\n    rand_bytes(global->local_client_id, 8);\n    rand_bytes((uint8_t*)&global->connection_id, 4);\n    global->connection_id &= 0xFFFFFF;\n    return global;\n"]], "pred": {"ppl": 3.713945150375366, "ppl_lower": 3.725639581680298, "ppl/lowercase_ppl": -1.0023960484004508, "ppl/zlib": 0.008304396800498751, "Min_5.0% Prob": 9.148420238494873, "Min_10.0% Prob": 7.091952133178711, "Min_20.0% Prob": 5.134643489122391, "Min_30.0% Prob": 3.998951756954193, "Min_40.0% Prob": 3.162353642103149, "Min_50.0% Prob": 2.6135163777599146, "Min_60.0% Prob": 2.2039113386732634}}
{"hexsha": "c5d9e9ac3fffa8b9aa43f6807169bcdbcd970e11", "ext": "c", "lang": "C", "content": "int\nSetCharTableEsc (unsigned char *table, const char * map, char * escapes)\n/* [HGM] moved here from winboard.c because of its general usefulness */\n/*       Basically a safe strcpy that uses the last character as King */\n{\n    int result = FALSE; int NrPieces;\n    unsigned char partner[EmptySquare];\n\n    if( map != NULL && (NrPieces=ptclen(map, escapes)) <= (int) EmptySquare\n                    && NrPieces >= 12 && !(NrPieces&1)) {\n        int i, ii, offs, j = 0; /* [HGM] Accept even length from 12 to 88 */\n\n        for( i=0; i<(int) EmptySquare; i++ ) table[i] = '.';\n        for( i=offs=0; i<NrPieces/2-1; i++ ) {\n            char *p, c=0;\n            if(map[j] == '/') offs = WhitePBishop - i, j++;\n            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];\n            table[i+offs] = map[j++];\n            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);\n            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;\n            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;\n        }\n        table[(int) WhiteKing]  = map[j++];\n        for( ii=offs=0; ii<NrPieces/2-1; ii++ ) {\n            char *p, c=0;\n            if(map[j] == '/') offs = WhitePBishop - ii, j++;\n            i = WHITE_TO_BLACK ii;\n            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];\n            table[i+offs] = map[j++];\n            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);\n            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;\n            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;\n        }\n        table[(int) BlackKing]  = map[j++];\n\n\n        if(*escapes) { // set up promotion pairing\n            for( i=0; i<(int) EmptySquare; i++ ) promoPartner[i] = (i%BlackPawn < 11 ? i + 11 : i%BlackPawn < 22 ? i - 11 : i); // default\n            // pieceToChar entirely filled, so we can look up specified partners\n            for(i=0; i<EmptySquare; i++) { // adjust promotion pairing\n                int c = table[i];\n                if(c == '^' || c == '-') { // has specified partner\n                    int p;\n                    for(p=0; p<EmptySquare; p++) if(table[p] == partner[i]) break;\n                    if(c == '^') table[i] = '+';\n                    if(p < EmptySquare) {\n                        if(promoPartner[promoPartner[p]] == p) promoPartner[promoPartner[p]] = promoPartner[p]; // divorce old partners\n                        if(promoPartner[promoPartner[i]] == i) promoPartner[promoPartner[i]] = promoPartner[i];\n                        promoPartner[p] = i, promoPartner[i] = p; // and marry this couple\n                    }\n                } else if(c == '*') {\n                    table[i] = partner[i];\n                    promoPartner[i] = (i < BlackPawn ? WhiteTokin : BlackTokin); // promotes to Tokin\n                }\n            }\n        }\n\n        result = TRUE;\n    }\n\n    return result;\n}", "item_id": 74, "repo": "aLahdekorpi/chessAi", "file": "xboard-4.9.0/backend.c", "last_update_at": "2019-11-11T09:54:10+00:00", "question_id": "c5d9e9ac3fffa8b9aa43f6807169bcdbcd970e11_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nSetCharTableEsc (unsigned char *table, const char * map, char * escapes)\n/* [HGM] moved here from winboard.c because of its general usefulness */\n/*       Basically a safe strcpy that uses the last character as King */\n{\n    int result = FALSE; int NrPieces;\n    unsigned char partner[EmptySquare];\n    if( map != NULL && (NrPieces=ptclen(map, escapes)) <= (int) EmptySquare\n                    && NrPieces >= 12 && !(NrPieces&1)) {\n        int i, ii, offs, j = 0; /* [HGM] Accept even length from 12 to 88 */\n        for( i=0; i<(int) EmptySquare; i++ ) table[i] = '.';\n        for( i=offs=0; i<NrPieces/2-1; i++ ) {\n            char *p, c=0;\n            if(map[j] == '/') offs = WhitePBishop - i, j++;\n            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];\n            table[i+offs] = map[j++];\n            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);\n            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;\n            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;\n        }\n        table[(int) WhiteKing]  = map[j++];\n        for( ii=offs=0; ii<NrPieces/2-1; ii++ ) {\n            char *p, c=0;\n            if(map[j] == '/') offs = WhitePBishop - ii, j++;\n            i = WHITE_TO_BLACK ii;\n            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];\n            table[i+offs] = map[j++];\n            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);\n            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;\n            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;\n        }\n        table[(int) BlackKing]  = map[j++];\n        if(*escapes) { // set up promotion pairing\n            for( i=0; i<(int) EmptySquare; i++ ) promoPartner[i] = (i%BlackPawn < 11 ? i + 11 : i%BlackPawn < 22 ? i - 11 : i); // default\n            // pieceToChar entirely filled, so we can look up specified partners\n            for(i=0; i<EmptySquare; i++) { // adjust promotion pairing\n                int c = table[i];\n                if(c == '^' || c == '-') { // has specified partner\n                    int p;\n                    for(p=0; p<EmptySquare; p++) if(table[p] == partner[i]) break;\n                    if(c == '^') table[i] = '+';\n                    if(p < EmptySquare) {\n                        if(promoPartner[promoPartner[p]] == p) promoPartner[promoPartner[p]] = promoPartner[p]; // divorce old partners\n                        if(promoPartner[promoPartner[i]] == i) promoPartner[promoPartner[i]] = promoPartner[i];\n                        promoPartner[p] = i, promoPartner[i] = p; // and marry this couple\n                    }\n                } else if(c == '*') {\n                    table[i] = partner[i];\n                    promoPartner[i] = (i < BlackPawn ? WhiteTokin : BlackTokin); // promotes to Tokin\n                }\n            }\n        }\n        result = TRUE;\n    }\n    return result;\n"]], "pred": {"ppl": 2.95158052444458, "ppl_lower": 3.0740511417388916, "ppl/lowercase_ppl": -1.0375625533585298, "ppl/zlib": 0.0011441234649850465, "Min_5.0% Prob": 8.222996038549086, "Min_10.0% Prob": 6.251618852802351, "Min_20.0% Prob": 4.420418712438321, "Min_30.0% Prob": 3.367343004427704, "Min_40.0% Prob": 2.641856097140347, "Min_50.0% Prob": 2.149657659874154, "Min_60.0% Prob": 1.80258090754585}}
{"hexsha": "31570b9a6e9aa72cca60d1953c14e47938547ebe", "ext": "c", "lang": "C", "content": "static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)\n{\n\tstruct tcmsg *tcm = NLMSG_DATA(n);\n\tstruct rtattr **tca = arg;\n\tstruct net_device *dev;\n\tstruct Qdisc *q = NULL;\n\tstruct Qdisc_class_ops *cops;\n\tunsigned long cl = 0;\n\tunsigned long new_cl;\n\tu32 pid = tcm->tcm_parent;\n\tu32 clid = tcm->tcm_handle;\n\tu32 qid = TC_H_MAJ(clid);\n\tint err;\n\n\tif ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)\n\t\treturn -ENODEV;\n\n\t/*\n\t   parent == TC_H_UNSPEC - unspecified parent.\n\t   parent == TC_H_ROOT   - class is root, which has no parent.\n\t   parent == X:0\t - parent is root class.\n\t   parent == X:Y\t - parent is a node in hierarchy.\n\t   parent == 0:Y\t - parent is X:Y, where X:0 is qdisc.\n\n\t   handle == 0:0\t - generate handle from kernel pool.\n\t   handle == 0:Y\t - class is X:Y, where X:0 is qdisc.\n\t   handle == X:Y\t - clear.\n\t   handle == X:0\t - root class.\n\t */\n\n\t/* Step 1. Determine qdisc handle X:0 */\n\n\tif (pid != TC_H_ROOT) {\n\t\tu32 qid1 = TC_H_MAJ(pid);\n\n\t\tif (qid && qid1) {\n\t\t\t/* If both majors are known, they must be identical. */\n\t\t\tif (qid != qid1)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (qid1) {\n\t\t\tqid = qid1;\n\t\t} else if (qid == 0)\n\t\t\tqid = dev->qdisc_sleeping->handle;\n\n\t\t/* Now qid is genuine qdisc handle consistent\n\t\t   both with parent and child.\n\n\t\t   TC_H_MAJ(pid) still may be unspecified, complete it now.\n\t\t */\n\t\tif (pid)\n\t\t\tpid = TC_H_MAKE(qid, pid);\n\t} else {\n\t\tif (qid == 0)\n\t\t\tqid = dev->qdisc_sleeping->handle;\n\t}\n\n\t/* OK. Locate qdisc */\n\tif ((q = qdisc_lookup(dev, qid)) == NULL) \n\t\treturn -ENOENT;\n\n\t/* An check that it supports classes */\n\tcops = q->ops->cl_ops;\n\tif (cops == NULL)\n\t\treturn -EINVAL;\n\n\t/* Now try to get class */\n\tif (clid == 0) {\n\t\tif (pid == TC_H_ROOT)\n\t\t\tclid = qid;\n\t} else\n\t\tclid = TC_H_MAKE(qid, clid);\n\n\tif (clid)\n\t\tcl = cops->get(q, clid);\n\n\tif (cl == 0) {\n\t\terr = -ENOENT;\n\t\tif (n->nlmsg_type != RTM_NEWTCLASS || !(n->nlmsg_flags&NLM_F_CREATE))\n\t\t\tgoto out;\n\t} else {\n\t\tswitch (n->nlmsg_type) {\n\t\tcase RTM_NEWTCLASS:\t\n\t\t\terr = -EEXIST;\n\t\t\tif (n->nlmsg_flags&NLM_F_EXCL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase RTM_DELTCLASS:\n\t\t\terr = cops->delete(q, cl);\n\t\t\tif (err == 0)\n\t\t\t\ttclass_notify(skb, n, q, cl, RTM_DELTCLASS);\n\t\t\tgoto out;\n\t\tcase RTM_GETTCLASS:\n\t\t\terr = tclass_notify(skb, n, q, cl, RTM_NEWTCLASS);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnew_cl = cl;\n\terr = cops->change(q, clid, pid, tca, &new_cl);\n\tif (err == 0)\n\t\ttclass_notify(skb, n, q, new_cl, RTM_NEWTCLASS);\n\nout:\n\tif (cl)\n\t\tcops->put(q, cl);\n\n\treturn err;\n}", "item_id": 18, "repo": "ut-osa/syncchar", "file": "linux-2.6.16-unmod/net/sched/sch_api.c", "last_update_at": "2019-05-14T16:36:45+00:00", "question_id": "31570b9a6e9aa72cca60d1953c14e47938547ebe_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)\n{\n\tstruct tcmsg *tcm = NLMSG_DATA(n);\n\tstruct rtattr **tca = arg;\n\tstruct net_device *dev;\n\tstruct Qdisc *q = NULL;\n\tstruct Qdisc_class_ops *cops;\n\tunsigned long cl = 0;\n\tunsigned long new_cl;\n\tu32 pid = tcm->tcm_parent;\n\tu32 clid = tcm->tcm_handle;\n\tu32 qid = TC_H_MAJ(clid);\n\tint err;\n\tif ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)\n\t\treturn -ENODEV;\n\t/*\n\t   parent == TC_H_UNSPEC - unspecified parent.\n\t   parent == TC_H_ROOT   - class is root, which has no parent.\n\t   parent == X:0\t - parent is root class.\n\t   parent == X:Y\t - parent is a node in hierarchy.\n\t   parent == 0:Y\t - parent is X:Y, where X:0 is qdisc.\n\t   handle == 0:0\t - generate handle from kernel pool.\n\t   handle == 0:Y\t - class is X:Y, where X:0 is qdisc.\n\t   handle == X:Y\t - clear.\n\t   handle == X:0\t - root class.\n\t */\n\t/* Step 1. Determine qdisc handle X:0 */\n\tif (pid != TC_H_ROOT) {\n\t\tu32 qid1 = TC_H_MAJ(pid);\n\t\tif (qid && qid1) {\n\t\t\t/* If both majors are known, they must be identical. */\n\t\t\tif (qid != qid1)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (qid1) {\n\t\t\tqid = qid1;\n\t\t} else if (qid == 0)\n\t\t\tqid = dev->qdisc_sleeping->handle;\n\t\t/* Now qid is genuine qdisc handle consistent\n\t\t   both with parent and child.\n\t\t   TC_H_MAJ(pid) still may be unspecified, complete it now.\n\t\t */\n\t\tif (pid)\n\t\t\tpid = TC_H_MAKE(qid, pid);\n\t} else {\n\t\tif (qid == 0)\n\t\t\tqid = dev->qdisc_sleeping->handle;\n\t}\n\t/* OK. Locate qdisc */\n\tif ((q = qdisc_lookup(dev, qid)) == NULL) \n\t\treturn -ENOENT;\n\t/* An check that it supports classes */\n\tcops = q->ops->cl_ops;\n\tif (cops == NULL)\n\t\treturn -EINVAL;\n\t/* Now try to get class */\n\tif (clid == 0) {\n\t\tif (pid == TC_H_ROOT)\n\t\t\tclid = qid;\n\t} else\n\t\tclid = TC_H_MAKE(qid, clid);\n\tif (clid)\n\t\tcl = cops->get(q, clid);\n\tif (cl == 0) {\n\t\terr = -ENOENT;\n\t\tif (n->nlmsg_type != RTM_NEWTCLASS || !(n->nlmsg_flags&NLM_F_CREATE))\n\t\t\tgoto out;\n\t} else {\n\t\tswitch (n->nlmsg_type) {\n\t\tcase RTM_NEWTCLASS:\t\n\t\t\terr = -EEXIST;\n\t\t\tif (n->nlmsg_flags&NLM_F_EXCL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase RTM_DELTCLASS:\n\t\t\terr = cops->delete(q, cl);\n\t\t\tif (err == 0)\n\t\t\t\ttclass_notify(skb, n, q, cl, RTM_DELTCLASS);\n\t\t\tgoto out;\n\t\tcase RTM_GETTCLASS:\n\t\t\terr = tclass_notify(skb, n, q, cl, RTM_NEWTCLASS);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnew_cl = cl;\n\terr = cops->change(q, clid, pid, tca, &new_cl);\n\tif (err == 0)\n\t\ttclass_notify(skb, n, q, new_cl, RTM_NEWTCLASS);\nout:\n\tif (cl)\n\t\tcops->put(q, cl);\n\treturn err;\n"]], "pred": {"ppl": 1.9398819208145142, "ppl_lower": 2.235720634460449, "ppl/lowercase_ppl": -1.2142026801275752, "ppl/zlib": 0.0006286784683712757, "Min_5.0% Prob": 5.894835266412473, "Min_10.0% Prob": 4.4140490807738955, "Min_20.0% Prob": 2.91159679200135, "Min_30.0% Prob": 2.1067580400533927, "Min_40.0% Prob": 1.6291658196662049, "Min_50.0% Prob": 1.319749650219182, "Min_60.0% Prob": 1.1044229877957707}}
{"hexsha": "0aeb8a62bff4532737de9b9d265112bbf4e5fc6a", "ext": "c", "lang": "C", "content": "void spi_init(void)\n{\n  SPI_PORT(DIR) |= (MOSI_PIN + SCK_PIN + W_PIN + CS_PIN);\n  SPI_PORT(DIR) &= ~(MISO_PIN);\n  SPI_PORT(REN) &= ~(MISO_PIN);\n  \n  TSL_HIGH;\n  CS_HIGH;\n  SCK_LOW;\n}", "item_id": 0, "repo": "cradle08/nb_wvds", "file": "dev/m25pe/spi.c", "last_update_at": "2019-11-20T11:09:14+00:00", "question_id": "0aeb8a62bff4532737de9b9d265112bbf4e5fc6a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void spi_init(void)\n{\n  SPI_PORT(DIR) |= (MOSI_PIN + SCK_PIN + W_PIN + CS_PIN);\n  SPI_PORT(DIR) &= ~(MISO_PIN);\n  SPI_PORT(REN) &= ~(MISO_PIN);\n  TSL_HIGH;\n  CS_HIGH;\n  SCK_LOW;\n"]], "pred": {"ppl": 3.433527708053589, "ppl_lower": 4.8863983154296875, "ppl/lowercase_ppl": -1.2860494830531126, "ppl/zlib": 0.010916709902311146, "Min_5.0% Prob": 8.348558521270752, "Min_10.0% Prob": 6.618366198106245, "Min_20.0% Prob": 4.785104112191633, "Min_30.0% Prob": 3.6827659715305674, "Min_40.0% Prob": 2.940145679495551, "Min_50.0% Prob": 2.4199781772765245, "Min_60.0% Prob": 2.044462888924913}}
{"hexsha": "9dc9330bcf19f23e13c7d9db0e4b416fc2aa28e1", "ext": "c", "lang": "C", "content": "static void\nng_rewind(struct irs_ng *this, const char *netgroup) {\n\tUNUSED(this);\n\tUNUSED(netgroup);\n\t/* NOOP */\n}", "item_id": 3, "repo": "TrustedBSD/sebsd", "file": "contrib/bind9/lib/bind/irs/nul_ng.c", "last_update_at": "2019-10-09T17:34:14+00:00", "question_id": "9dc9330bcf19f23e13c7d9db0e4b416fc2aa28e1_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nng_rewind(struct irs_ng *this, const char *netgroup) {\n\tUNUSED(this);\n\tUNUSED(netgroup);\n\t/* NOOP */\n"]], "pred": {"ppl": 4.77136754989624, "ppl_lower": 6.141895294189453, "ppl/lowercase_ppl": -1.1615865136709425, "ppl/zlib": 0.015025316941362119, "Min_5.0% Prob": 11.572722911834717, "Min_10.0% Prob": 9.27151644229889, "Min_20.0% Prob": 6.571252902348836, "Min_30.0% Prob": 4.825206748076847, "Min_40.0% Prob": 3.8004246730553475, "Min_50.0% Prob": 3.0866885309418044, "Min_60.0% Prob": 2.6662157686161145}}
{"hexsha": "32565320a2cd42784023fb271c6d7cbfeb520307", "ext": "c", "lang": "C", "content": "static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)\r\n{ \r\n  USBD_AUDIO_HandleTypeDef   *haudio;\r\n  haudio = pdev->pClassData;\r\n  \r\n  if (req->wLength)\r\n  {\r\n    /* Prepare the reception of the buffer over EP0 */\r\n    USBD_CtlPrepareRx (pdev,\r\n                       haudio->control.data,                                  \r\n                       req->wLength);    \r\n    \r\n    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */\r\n    haudio->control.len = req->wLength;          /* Set the request data length */\r\n    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */\r\n  }\r\n}", "item_id": 7, "repo": "lurch/micropython", "file": "stmhal/usbdev/class/AUDIO/Src/usbd_audio.c", "last_update_at": "2019-04-17T03:56:42+00:00", "question_id": "32565320a2cd42784023fb271c6d7cbfeb520307_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)\r\n{ \r\n  USBD_AUDIO_HandleTypeDef   *haudio;\r\n  haudio = pdev->pClassData;\r\n  \r\n  if (req->wLength)\r\n  {\r\n    /* Prepare the reception of the buffer over EP0 */\r\n    USBD_CtlPrepareRx (pdev,\r\n                       haudio->control.data,                                  \r\n                       req->wLength);    \r\n    \r\n    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */\r\n    haudio->control.len = req->wLength;          /* Set the request data length */\r\n    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */\r\n  }\r\n"]], "pred": {"ppl": 1.976603627204895, "ppl_lower": 3.672714948654175, "ppl/lowercase_ppl": -1.9092592906205696, "ppl/zlib": 0.0021631112127970223, "Min_5.0% Prob": 5.479092662984675, "Min_10.0% Prob": 4.328630003062162, "Min_20.0% Prob": 3.012972883202813, "Min_30.0% Prob": 2.2262564694339577, "Min_40.0% Prob": 1.691755973639783, "Min_50.0% Prob": 1.3662061785255466, "Min_60.0% Prob": 1.1419796522433652}}
{"hexsha": "59ec57f9ba4301d864a9205b70ac8bc77ffbe637", "ext": "c", "lang": "C", "content": "struct sunxi_drm_gem_obj *sunxi_drm_gem_init(struct drm_device *dev,\r\n\t\t\t\t\t\t      unsigned long size)\r\n{\r\n\tstruct sunxi_drm_gem_obj *sunxi_gem_obj;\r\n\tstruct drm_gem_object *obj;\r\n\tint ret;\r\n\r\n\tsunxi_gem_obj = kzalloc(sizeof(*sunxi_gem_obj), GFP_KERNEL);\r\n\tif (!sunxi_gem_obj) {\r\n\t\tDRM_ERROR(\"failed to allocate sunxi gem object\\n\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tsunxi_gem_obj->size = size;\r\n\tobj = &sunxi_gem_obj->base;\r\n\r\n\tret = drm_gem_object_init(dev, obj, size);\r\n\tif (ret < 0) {\r\n\t\tDRM_ERROR(\"failed to initialize gem object\\n\");\r\n\t\tkfree(sunxi_gem_obj);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tDRM_DEBUG_KMS(\"created file object = 0x%x\\n\", (unsigned int)obj->filp);\r\n\r\n\treturn sunxi_gem_obj;\r\n}", "item_id": 8, "repo": "troyane/r6p2", "file": "libwayland_for_mali/h3/sunxi/sunxi_gem.c", "last_update_at": "2019-09-10T17:21:33+00:00", "question_id": "59ec57f9ba4301d864a9205b70ac8bc77ffbe637_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct sunxi_drm_gem_obj *sunxi_drm_gem_init(struct drm_device *dev,\r\n\t\t\t\t\t\t      unsigned long size)\r\n{\r\n\tstruct sunxi_drm_gem_obj *sunxi_gem_obj;\r\n\tstruct drm_gem_object *obj;\r\n\tint ret;\r\n\r\n\tsunxi_gem_obj = kzalloc(sizeof(*sunxi_gem_obj), GFP_KERNEL);\r\n\tif (!sunxi_gem_obj) {\r\n\t\tDRM_ERROR(\"failed to allocate sunxi gem object\\n\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tsunxi_gem_obj->size = size;\r\n\tobj = &sunxi_gem_obj->base;\r\n\r\n\tret = drm_gem_object_init(dev, obj, size);\r\n\tif (ret < 0) {\r\n\t\tDRM_ERROR(\"failed to initialize gem object\\n\");\r\n\t\tkfree(sunxi_gem_obj);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tDRM_DEBUG_KMS(\"created file object = 0x%x\\n\", (unsigned int)obj->filp);\r\n\r\n\treturn sunxi_gem_obj;\r\n"]], "pred": {"ppl": 1.483615756034851, "ppl_lower": 1.7330185174942017, "ppl/lowercase_ppl": -1.3938897988824197, "ppl/zlib": 0.0012366212749643712, "Min_5.0% Prob": 4.931768298149109, "Min_10.0% Prob": 3.2108258625556685, "Min_20.0% Prob": 1.8623609204413527, "Min_30.0% Prob": 1.3048123106021772, "Min_40.0% Prob": 0.9854917266895458, "Min_50.0% Prob": 0.7880942534680504, "Min_60.0% Prob": 0.6595073222869344}}
{"hexsha": "ac47a33f24310d56297a1e3a0715997d4d0ea8bf", "ext": "c", "lang": "C", "content": "S_LOCAL void window_residuals(SRelp *self, SArrayInt *residual,\n\t\t\t\t\t\t\t  STrackFloat *coefs, uint frame_number, s_erc *error)\n{\n\tfloat prev_pm;\n\tfloat first_pos;\n\tuint32 j = 0;\n\tfloat current_pm = 0.0;\n\tfloat period = 0.0;\n\tuint32 pm_num_frames = coefs->data->row_count;\n\tsint32 centre_sample = 0;\n\tsint32 first_sample;\n\tsint32 last_sample;\n\n\n\tS_CLR_ERR(error);\n\n\t/*\n\t * estimate first period as pitchmark time itself (i.e. assume a previous\n\t * pitchmark at 0.0 time, waveform sample 0)\n\t */\n\tprev_pm = 0.0;\n\n\n\tif (self->symmetric == TRUE)\n\t{\n\t\tif (pm_num_frames < 1)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Attempted to window around less than 1 pitchmark\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (j = 0; j < pm_num_frames; j++, frame_number++ )\n\t\t{\n\t\t\tcurrent_pm = coefs->time[j];\n\t\t\tperiod = current_pm - prev_pm;\n\t\t\tcentre_sample = (sint32)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\tlast_sample  = (2 * centre_sample) - first_sample;\n\n\t\t\tself->residuals[frame_number] = S_NEW(SArrayInt, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Failed to create new 'SArrayInt' object\"))\n\t\t\t\treturn;\n\n\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t -1, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\treturn;\n\n\t\t\tprev_pm = current_pm;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (self->pmIndx == NULL)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Required pitchmark indices is NULL\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (pm_num_frames < 1)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Attempting to window around less than 1 pitchmark\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat next_pm;\n\t\t\tfloat last_pos;\n\n\t\t\tfor (j = 0; j < pm_num_frames - 1; j++, frame_number++)\n\t\t\t{\n\t\t\t\tcurrent_pm = coefs->time[j];\n\t\t\t\tperiod = current_pm - prev_pm;\n\t\t\t\tcentre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\t\tnext_pm = coefs->time[j + 1];\n\t\t\t\tlast_pos = next_pm + ((next_pm - current_pm) * (self->window_factor - 1.0));\n\t\t\t\tlast_sample = (int)(last_pos * (float)self->sample_rate + 0.5);\n\n\t\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t\t centre_sample, error);\n\t\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\t\treturn;\n\n\t\t\t\tself->pmIndx->i[frame_number] = centre_sample - first_sample;\n\t\t\t\tprev_pm = current_pm;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * last frame window size is set according to coefs->time[end] and the number\n\t\t\t * of samples in the waveform (it is presumed the waveform begins at the\n\t\t\t * preceeding pitchmark and ends at the pitchmark following the current\n\t\t\t * unit...)\n\t\t\t */\n\t\t\tcurrent_pm = coefs->time[j];\n\t\t\tcentre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\tlast_sample = residual->count - 1;\n\n\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t -1, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\treturn;\n\n\n\t\t\tself->pmIndx->i[frame_number] = centre_sample - first_sample;\n\t\t\tframe_number++;\n\t\t}\n\t}\n}", "item_id": 0, "repo": "Oghma/speect", "file": "plugins/acoustic/wave_generation/relp/src/window.c", "last_update_at": "2019-04-24T14:45:55+00:00", "question_id": "ac47a33f24310d56297a1e3a0715997d4d0ea8bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["S_LOCAL void window_residuals(SRelp *self, SArrayInt *residual,\n\t\t\t\t\t\t\t  STrackFloat *coefs, uint frame_number, s_erc *error)\n{\n\tfloat prev_pm;\n\tfloat first_pos;\n\tuint32 j = 0;\n\tfloat current_pm = 0.0;\n\tfloat period = 0.0;\n\tuint32 pm_num_frames = coefs->data->row_count;\n\tsint32 centre_sample = 0;\n\tsint32 first_sample;\n\tsint32 last_sample;\n\tS_CLR_ERR(error);\n\t/*\n\t * estimate first period as pitchmark time itself (i.e. assume a previous\n\t * pitchmark at 0.0 time, waveform sample 0)\n\t */\n\tprev_pm = 0.0;\n\tif (self->symmetric == TRUE)\n\t{\n\t\tif (pm_num_frames < 1)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Attempted to window around less than 1 pitchmark\");\n\t\t\treturn;\n\t\t}\n\t\tfor (j = 0; j < pm_num_frames; j++, frame_number++ )\n\t\t{\n\t\t\tcurrent_pm = coefs->time[j];\n\t\t\tperiod = current_pm - prev_pm;\n\t\t\tcentre_sample = (sint32)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\tlast_sample  = (2 * centre_sample) - first_sample;\n\t\t\tself->residuals[frame_number] = S_NEW(SArrayInt, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Failed to create new 'SArrayInt' object\"))\n\t\t\t\treturn;\n\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t -1, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\treturn;\n\t\t\tprev_pm = current_pm;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (self->pmIndx == NULL)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Required pitchmark indices is NULL\");\n\t\t\treturn;\n\t\t}\n\t\tif (pm_num_frames < 1)\n\t\t{\n\t\t\tS_CTX_ERR(error, S_FAILURE,\n\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t  \"Attempting to window around less than 1 pitchmark\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat next_pm;\n\t\t\tfloat last_pos;\n\t\t\tfor (j = 0; j < pm_num_frames - 1; j++, frame_number++)\n\t\t\t{\n\t\t\t\tcurrent_pm = coefs->time[j];\n\t\t\t\tperiod = current_pm - prev_pm;\n\t\t\t\tcentre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\t\tnext_pm = coefs->time[j + 1];\n\t\t\t\tlast_pos = next_pm + ((next_pm - current_pm) * (self->window_factor - 1.0));\n\t\t\t\tlast_sample = (int)(last_pos * (float)self->sample_rate + 0.5);\n\t\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t\t centre_sample, error);\n\t\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\t\treturn;\n\t\t\t\tself->pmIndx->i[frame_number] = centre_sample - first_sample;\n\t\t\t\tprev_pm = current_pm;\n\t\t\t}\n\t\t\t/*\n\t\t\t * last frame window size is set according to coefs->time[end] and the number\n\t\t\t * of samples in the waveform (it is presumed the waveform begins at the\n\t\t\t * preceeding pitchmark and ends at the pitchmark following the current\n\t\t\t * unit...)\n\t\t\t */\n\t\t\tcurrent_pm = coefs->time[j];\n\t\t\tcentre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);\n\t\t\tfirst_pos = prev_pm - (period * (self->window_factor - 1.0));\n\t\t\tfirst_sample = (int)(first_pos * (float)self->sample_rate + 0.5);\n\t\t\tlast_sample = residual->count - 1;\n\t\t\twindow_this_residual(self->residuals[frame_number], residual,\n\t\t\t\t\t\t\t\t first_sample, last_sample, self->window,\n\t\t\t\t\t\t\t\t -1, error);\n\t\t\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t\t\t  \"window_residuals\",\n\t\t\t\t\t\t  \"Call to \\\"window_this_residual\\\" failed\"))\n\t\t\t\treturn;\n\t\t\tself->pmIndx->i[frame_number] = centre_sample - first_sample;\n\t\t\tframe_number++;\n\t\t}\n\t}\n"]], "pred": {"ppl": 1.9870868921279907, "ppl_lower": 2.202575922012329, "ppl/lowercase_ppl": -1.1499379646496952, "ppl/zlib": 0.0006873570499745292, "Min_5.0% Prob": 6.85791628968482, "Min_10.0% Prob": 5.134365186971777, "Min_20.0% Prob": 3.2376972895626928, "Min_30.0% Prob": 2.2614045201076403, "Min_40.0% Prob": 1.7113238439637903, "Min_50.0% Prob": 1.3733630641299772, "Min_60.0% Prob": 1.1457150920854842}}
{"hexsha": "c83d81cdafe427bbab9834da9ba5e565a4df326d", "ext": "c", "lang": "C", "content": "char *\nnextstr (char **pbuf, FILE *fp)\n{\n\tchar\t*p, *nxtchr();\n\tstatic\tchar\ttbuf[SZ_LINE];\n\tchar\tquote;\n\tint\tcnt;\n\n\tp = *pbuf;\n\n\t/* Skip white space. */\n\twhile ( *p == ' '  ||  *p == '\\t'  ||  *p =='\\n')\n\t    p = nxtchr(p, fp);\n\n\t/* Reached end?\t*/\n\tif (*p == '\\0') {\n\t    *pbuf = p;\n\t    return (NULL);\n\t}\n\n\tquote = '\\0';\n\tcnt = 0;\n\n\t/* Quoted string. */\n\tif (*p == '\\''  ||  *p == '\"') {\n\t    quote = *p;\n\t    p = nxtchr (p, fp);\n\n\t    while (*p != quote) {\n\n\t\tif (p == '\\0'  ||  cnt >= SZ_LINE)\n\t\t    return ( (char *) ERR);\n\n\t\telse {\n\t\t    tbuf[cnt++] = *p;\n\t\t    p = nxtchr(p, fp);\n\t\t}\n\t    }\n\t    /* Skip quote. */\n\t    p = nxtchr (p, fp);\n\n\t} else {\n\t    /* Unquoted string. */\n\t    while (*p != ' '   &&  *p != '\\t'   &&  *p != '\\n'  &&\n\t      *p != '\\0'  &&  *p != ',') {\n\n\t\tif (cnt >= SZ_LINE)\n\t\t    return ( (char *) ERR );\n\n\t\ttbuf[cnt++] = *p;\n\t\tp = nxtchr (p, fp);\n\t    }\n\t}\n\ttbuf[cnt] = '\\0';\n\n\t/* Skip any white-space following. */\n\twhile (*p == ' '  ||  *p == '\\t'  ||  *p == '\\n')\n\t    p = nxtchr(p, fp);\n\n\tif (*p != ','   &&  *p != '\\0')\n\t    return ( (char *) ERR);\n\n\t/* Skip delimiter. */\n\tif (*p == ',')\n\t   p = nxtchr(p, fp);\n\n\t*pbuf = p;\n\tif (cnt == 0) {\n\t    /* Return a quoted null string, otherwise the field was skipped. */\n\t    if (quote != '\\0')\n\t\treturn (tbuf);\n\t    else\n\t\treturn (undefval);\n\t} else\n\t    return (tbuf);\n}", "item_id": 3, "repo": "ysBach/irafdocgen", "file": "iraf.v2161/pkg/ecl/modes.c", "last_update_at": "2019-12-02T16:48:42+00:00", "question_id": "c83d81cdafe427bbab9834da9ba5e565a4df326d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *\nnextstr (char **pbuf, FILE *fp)\n{\n\tchar\t*p, *nxtchr();\n\tstatic\tchar\ttbuf[SZ_LINE];\n\tchar\tquote;\n\tint\tcnt;\n\tp = *pbuf;\n\t/* Skip white space. */\n\twhile ( *p == ' '  ||  *p == '\\t'  ||  *p =='\\n')\n\t    p = nxtchr(p, fp);\n\t/* Reached end?\t*/\n\tif (*p == '\\0') {\n\t    *pbuf = p;\n\t    return (NULL);\n\t}\n\tquote = '\\0';\n\tcnt = 0;\n\t/* Quoted string. */\n\tif (*p == '\\''  ||  *p == '\"') {\n\t    quote = *p;\n\t    p = nxtchr (p, fp);\n\t    while (*p != quote) {\n\t\tif (p == '\\0'  ||  cnt >= SZ_LINE)\n\t\t    return ( (char *) ERR);\n\t\telse {\n\t\t    tbuf[cnt++] = *p;\n\t\t    p = nxtchr(p, fp);\n\t\t}\n\t    }\n\t    /* Skip quote. */\n\t    p = nxtchr (p, fp);\n\t} else {\n\t    /* Unquoted string. */\n\t    while (*p != ' '   &&  *p != '\\t'   &&  *p != '\\n'  &&\n\t      *p != '\\0'  &&  *p != ',') {\n\t\tif (cnt >= SZ_LINE)\n\t\t    return ( (char *) ERR );\n\t\ttbuf[cnt++] = *p;\n\t\tp = nxtchr (p, fp);\n\t    }\n\t}\n\ttbuf[cnt] = '\\0';\n\t/* Skip any white-space following. */\n\twhile (*p == ' '  ||  *p == '\\t'  ||  *p == '\\n')\n\t    p = nxtchr(p, fp);\n\tif (*p != ','   &&  *p != '\\0')\n\t    return ( (char *) ERR);\n\t/* Skip delimiter. */\n\tif (*p == ',')\n\t   p = nxtchr(p, fp);\n\t*pbuf = p;\n\tif (cnt == 0) {\n\t    /* Return a quoted null string, otherwise the field was skipped. */\n\t    if (quote != '\\0')\n\t\treturn (tbuf);\n\t    else\n\t\treturn (undefval);\n\t} else\n\t    return (tbuf);\n"]], "pred": {"ppl": 1.907913088798523, "ppl_lower": 2.0010664463043213, "ppl/lowercase_ppl": -1.0737917973433861, "ppl/zlib": 0.001247123592749901, "Min_5.0% Prob": 5.960399568080902, "Min_10.0% Prob": 4.506617762492254, "Min_20.0% Prob": 2.8554567121542416, "Min_30.0% Prob": 2.061590317256597, "Min_40.0% Prob": 1.591506504321692, "Min_50.0% Prob": 1.28266532021925, "Min_60.0% Prob": 1.074434774618938}}
{"hexsha": "2f21f3fba3e2d961d06efd82af2dc80f2fdbc1f5", "ext": "c", "lang": "C", "content": "struct topic *topic_new(const char *name) {\n    struct topic *t = sol_malloc(sizeof(*t));\n    topic_init(t, name);\n    return t;\n}", "item_id": 0, "repo": "zlxqur/sol", "file": "src/core.c", "last_update_at": "2019-12-09T10:41:27+00:00", "question_id": "2f21f3fba3e2d961d06efd82af2dc80f2fdbc1f5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct topic *topic_new(const char *name) {\n    struct topic *t = sol_malloc(sizeof(*t));\n    topic_init(t, name);\n    return t;\n"]], "pred": {"ppl": 3.6471755504608154, "ppl_lower": 3.6471755504608154, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01244185621392515, "Min_5.0% Prob": 10.66903829574585, "Min_10.0% Prob": 9.224540948867798, "Min_20.0% Prob": 5.364772955576579, "Min_30.0% Prob": 4.1092833280563354, "Min_40.0% Prob": 3.1487403180864124, "Min_50.0% Prob": 2.6159530864520506, "Min_60.0% Prob": 2.148425403430506}}
{"hexsha": "cff9b445f2f101cf0533131ecaf7b57b8382f4bc", "ext": "c", "lang": "C", "content": "int\nxheart_intr_establish(int (*func)(void *), void *arg, int intrbit,\n    int level, const char *name, struct intrhand *ihstore)\n{\n\tstruct intrhand *ih;\n\tint s;\n\tu_long cpuid = cpu_number();\n\n#ifdef DIAGNOSTIC\n\tif (intrbit < 0 || intrbit >= HEART_NINTS)\n\t\treturn EINVAL;\n#endif\n\n\t/*\n\t * HEART interrupts are not supposed to be shared - the interrupt\n\t * mask is large enough for all widgets.\n\t */\n\tif (xheart_intrhand[intrbit] != NULL)\n\t\treturn EEXIST;\n\n\tif (ihstore == NULL) {\n\t\tih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);\n\t\tif (ih == NULL)\n\t\t\treturn ENOMEM;\n\t\tih->ih_flags = IH_ALLOCATED;\n\t} else {\n\t\tih = ihstore;\n\t\tih->ih_flags = 0;\n\t}\n\n\tih->ih_next = NULL;\n\tih->ih_fun = func;\n\tih->ih_arg = arg;\n\tih->ih_level = level;\n\tih->ih_irq = intrbit;\n\tif (name != NULL)\n\t\tevcount_attach(&ih->ih_count, name, &ih->ih_level);\n\n\ts = splhigh();\n\n\txheart_intrhand[intrbit] = ih;\n\n\txheart_intem[cpuid] |= 1UL << intrbit;\n\txheart_intr_makemasks();\n\n\tsplx(s);\t/* causes hw mask update */\n\n\treturn 0;\n}", "item_id": 7, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/arch/sgi/xbow/xheart.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "cff9b445f2f101cf0533131ecaf7b57b8382f4bc_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nxheart_intr_establish(int (*func)(void *), void *arg, int intrbit,\n    int level, const char *name, struct intrhand *ihstore)\n{\n\tstruct intrhand *ih;\n\tint s;\n\tu_long cpuid = cpu_number();\n#ifdef DIAGNOSTIC\n\tif (intrbit < 0 || intrbit >= HEART_NINTS)\n\t\treturn EINVAL;\n#endif\n\t/*\n\t * HEART interrupts are not supposed to be shared - the interrupt\n\t * mask is large enough for all widgets.\n\t */\n\tif (xheart_intrhand[intrbit] != NULL)\n\t\treturn EEXIST;\n\tif (ihstore == NULL) {\n\t\tih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);\n\t\tif (ih == NULL)\n\t\t\treturn ENOMEM;\n\t\tih->ih_flags = IH_ALLOCATED;\n\t} else {\n\t\tih = ihstore;\n\t\tih->ih_flags = 0;\n\t}\n\tih->ih_next = NULL;\n\tih->ih_fun = func;\n\tih->ih_arg = arg;\n\tih->ih_level = level;\n\tih->ih_irq = intrbit;\n\tif (name != NULL)\n\t\tevcount_attach(&ih->ih_count, name, &ih->ih_level);\n\ts = splhigh();\n\txheart_intrhand[intrbit] = ih;\n\txheart_intem[cpuid] |= 1UL << intrbit;\n\txheart_intr_makemasks();\n\tsplx(s);\t/* causes hw mask update */\n\treturn 0;\n"]], "pred": {"ppl": 2.157942056655884, "ppl_lower": 2.6182427406311035, "ppl/lowercase_ppl": -1.2513776326647983, "ppl/zlib": 0.0014010109580903953, "Min_5.0% Prob": 7.328811818903143, "Min_10.0% Prob": 5.270955259149725, "Min_20.0% Prob": 3.424046156758612, "Min_30.0% Prob": 2.4710956985751786, "Min_40.0% Prob": 1.9045725135048004, "Min_50.0% Prob": 1.5315598744511334, "Min_60.0% Prob": 1.2811788818851675}}
{"hexsha": "9a3ec11223e8ac07eb335974f0a375d4c58640ed", "ext": "c", "lang": "C", "content": "HRESULT WINAPI IDirectMusicBandTrack_IDirectMusicTrack_AddNotificationType (LPDIRECTMUSICTRACK8 iface, REFGUID rguidNotificationType) {\n\tICOM_THIS_MULTI(IDirectMusicBandTrack, TrackVtbl, iface);\n\tFIXME(\"(%p, %s): stub\\n\", This, debugstr_dmguid(rguidNotificationType));\n\treturn S_OK;\n}", "item_id": 10, "repo": "roytam1/wine-win31look", "file": "dlls/dmband/bandtrack.c", "last_update_at": "2019-10-23T04:07:16+00:00", "question_id": "9a3ec11223e8ac07eb335974f0a375d4c58640ed_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["HRESULT WINAPI IDirectMusicBandTrack_IDirectMusicTrack_AddNotificationType (LPDIRECTMUSICTRACK8 iface, REFGUID rguidNotificationType) {\n\tICOM_THIS_MULTI(IDirectMusicBandTrack, TrackVtbl, iface);\n\tFIXME(\"(%p, %s): stub\\n\", This, debugstr_dmguid(rguidNotificationType));\n\treturn S_OK;\n"]], "pred": {"ppl": 1.4441956281661987, "ppl_lower": 6.7056498527526855, "ppl/lowercase_ppl": -5.1773566822216015, "ppl/zlib": 0.0018017279797250124, "Min_5.0% Prob": 4.945942544937134, "Min_10.0% Prob": 3.4365371574055064, "Min_20.0% Prob": 1.8312699049711227, "Min_30.0% Prob": 1.2314952767143648, "Min_40.0% Prob": 0.9259871418418532, "Min_50.0% Prob": 0.7414819426961582, "Min_60.0% Prob": 0.6180778464865094}}
{"hexsha": "cf82a789934b2885f87f9a8bd2027d908347b40a", "ext": "c", "lang": "C", "content": "static int rp_encode_process_query_response(unsigned int mask,\n        const rp_thread_ref *ref,\n        const rp_thread_info *info,\n        char *out,\n        size_t out_size)\n{\n    size_t len;\n    unsigned int tag;\n    int i;\n\n    assert(ref != NULL);\n    assert(info != NULL);\n    assert(out != NULL);\n    assert(out_size > 0);\n\n    /* In all cases we will have at least mask and reference thread */\n    if (out_size <= 26)\n        return 0;\n\n    /* Encode header */\n    *out++ = 'q';\n    *out++ = 'Q';\n    out_size -= 2;\n\n    /* Encode mask */\n    sprintf(out, \"%08x\", mask);\n    out += 8;\n    out_size -= 8;\n\n    /* Encode reference thread */\n    sprintf(out, \"%016\"PRIu64\"x\", ref->val);\n\n    out += 16;\n    out_size -= 16;\n\n    for (i = 0, tag = 0;  i < 32;  i++, tag <<= 1)\n    {\n        if ((mask & tag) == 0)\n            continue;\n\n        if (out_size <= 10)\n        {\n            /* We have no place to put even tag and length */\n            return 0;\n        }\n\n        /* Encode tag */\n        sprintf(out, \"%08x\", tag);\n        out += 8;\n        out_size -= 8;\n\n        switch (tag)\n        {\n            case RP_BIT_PROCQMASK_THREADID:\n                if (out_size <= 18)\n                    return 0;\n\n                /* Encode length - it is 16 */\n                rp_encode_byte(16, out);\n                out += 2;\n                out_size -= 2;\n\n                /* Encode value */\n                sprintf(out, \"%016\"PRIu64\"x\", info->thread_id.val);\n\n                out += 16;\n                out_size -= 16;\n                break;\n            case RP_BIT_PROCQMASK_EXISTS:\n                /* One nibble is enough */\n                if (out_size <= 3)\n                    return 0;\n\n                /* Encode Length */\n                rp_encode_byte(1, out);\n                out += 2;\n                out_size -= 2;\n\n                /* Encode value */\n                *out++    = (info->exists) ? '1' : '0';\n                out_size-- ;\n                *out      = 0;\n                break;\n            case RP_BIT_PROCQMASK_DISPLAY:\n                /* Encode length */\n                len = strlen(info->display);\n                assert(len <= 255);\n\n                if (out_size <= (len + 2))\n                    return 0;\n\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n\n                /* Encode value */\n                strcpy(out, info->display);\n                out      += len;\n                out_size -= len;\n                break;\n            case RP_BIT_PROCQMASK_THREADNAME:\n                /* Encode length */\n                len = strlen(info->thread_name);\n                assert(len <= 255);\n\n                if (out_size <= (len + 2))\n                    return 0;\n\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n\n                /* Encode value */\n                strcpy(out, info->thread_name);\n                out      += len;\n                out_size -= len;\n                break;\n            case RP_BIT_PROCQMASK_MOREDISPLAY:\n                /* Encode length */\n                len = strlen(info->more_display);\n                assert(len <= 255);\n\n                if (out_size <= (len + 2))\n                    return 0;\n\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n\n                /* Encode value */\n                strcpy(out, info->more_display);\n                out += len;\n                out_size -= len;\n                break;\n            default:\n                /* Unexpected tag value */\n                assert(0);\n                return 0;\n        }\n    }\n\n    return 1;\n}", "item_id": 30, "repo": "avrsimulator/gdbproxy", "file": "gdbproxy.c", "last_update_at": "2019-03-12T18:46:00+00:00", "question_id": "cf82a789934b2885f87f9a8bd2027d908347b40a_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int rp_encode_process_query_response(unsigned int mask,\n        const rp_thread_ref *ref,\n        const rp_thread_info *info,\n        char *out,\n        size_t out_size)\n{\n    size_t len;\n    unsigned int tag;\n    int i;\n    assert(ref != NULL);\n    assert(info != NULL);\n    assert(out != NULL);\n    assert(out_size > 0);\n    /* In all cases we will have at least mask and reference thread */\n    if (out_size <= 26)\n        return 0;\n    /* Encode header */\n    *out++ = 'q';\n    *out++ = 'Q';\n    out_size -= 2;\n    /* Encode mask */\n    sprintf(out, \"%08x\", mask);\n    out += 8;\n    out_size -= 8;\n    /* Encode reference thread */\n    sprintf(out, \"%016\"PRIu64\"x\", ref->val);\n    out += 16;\n    out_size -= 16;\n    for (i = 0, tag = 0;  i < 32;  i++, tag <<= 1)\n    {\n        if ((mask & tag) == 0)\n            continue;\n        if (out_size <= 10)\n        {\n            /* We have no place to put even tag and length */\n            return 0;\n        }\n        /* Encode tag */\n        sprintf(out, \"%08x\", tag);\n        out += 8;\n        out_size -= 8;\n        switch (tag)\n        {\n            case RP_BIT_PROCQMASK_THREADID:\n                if (out_size <= 18)\n                    return 0;\n                /* Encode length - it is 16 */\n                rp_encode_byte(16, out);\n                out += 2;\n                out_size -= 2;\n                /* Encode value */\n                sprintf(out, \"%016\"PRIu64\"x\", info->thread_id.val);\n                out += 16;\n                out_size -= 16;\n                break;\n            case RP_BIT_PROCQMASK_EXISTS:\n                /* One nibble is enough */\n                if (out_size <= 3)\n                    return 0;\n                /* Encode Length */\n                rp_encode_byte(1, out);\n                out += 2;\n                out_size -= 2;\n                /* Encode value */\n                *out++    = (info->exists) ? '1' : '0';\n                out_size-- ;\n                *out      = 0;\n                break;\n            case RP_BIT_PROCQMASK_DISPLAY:\n                /* Encode length */\n                len = strlen(info->display);\n                assert(len <= 255);\n                if (out_size <= (len + 2))\n                    return 0;\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n                /* Encode value */\n                strcpy(out, info->display);\n                out      += len;\n                out_size -= len;\n                break;\n            case RP_BIT_PROCQMASK_THREADNAME:\n                /* Encode length */\n                len = strlen(info->thread_name);\n                assert(len <= 255);\n                if (out_size <= (len + 2))\n                    return 0;\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n                /* Encode value */\n                strcpy(out, info->thread_name);\n                out      += len;\n                out_size -= len;\n                break;\n            case RP_BIT_PROCQMASK_MOREDISPLAY:\n                /* Encode length */\n                len = strlen(info->more_display);\n                assert(len <= 255);\n                if (out_size <= (len + 2))\n                    return 0;\n                rp_encode_byte(len, out);\n                out += 2;\n                out_size -= 2;\n                /* Encode value */\n                strcpy(out, info->more_display);\n                out += len;\n                out_size -= len;\n                break;\n            default:\n                /* Unexpected tag value */\n                assert(0);\n                return 0;\n        }\n    }\n    return 1;\n"]], "pred": {"ppl": 1.7890139818191528, "ppl_lower": 1.8062959909439087, "ppl/lowercase_ppl": -1.0165279344916145, "ppl/zlib": 0.0006932832180385706, "Min_5.0% Prob": 6.182997951320574, "Min_10.0% Prob": 4.376958288398444, "Min_20.0% Prob": 2.715280081127204, "Min_30.0% Prob": 1.9055022586112709, "Min_40.0% Prob": 1.4463980593479495, "Min_50.0% Prob": 1.1624332414812422, "Min_60.0% Prob": 0.9701552681103014}}
{"hexsha": "332fdd0f185a36d560111b1220358f5823fa09b8", "ext": "h", "lang": "C", "content": "Node Pop()\n\t{\n\t\tstd::unique_lock lock(mutex);\n\t\tif (queue.empty())\n\t\t\tcondition_variable.wait(lock,[this] {return !queue.empty(); });\n\t\tauto temp = std::move(queue.front());\n\t\tqueue.pop_front();\n\t\treturn temp;\n\t}", "item_id": 0, "repo": "yonghenghuanmie/Component", "file": "ProducerConsumerQueue/ProducerConsumerQueue.h", "last_update_at": "2019-05-13T05:25:02+00:00", "question_id": "332fdd0f185a36d560111b1220358f5823fa09b8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Node Pop()\n\t{\n\t\tstd::unique_lock lock(mutex);\n\t\tif (queue.empty())\n\t\t\tcondition_variable.wait(lock,[this] {return !queue.empty(); });\n\t\tauto temp = std::move(queue.front());\n\t\tqueue.pop_front();\n\t\treturn temp;\n"]], "pred": {"ppl": 2.5604918003082275, "ppl_lower": 2.4704108238220215, "ppl/lowercase_ppl": -0.9619071345768189, "ppl/zlib": 0.005988530888765645, "Min_5.0% Prob": 9.411739826202393, "Min_10.0% Prob": 6.357453465461731, "Min_20.0% Prob": 4.0024973675608635, "Min_30.0% Prob": 3.0049404203891754, "Min_40.0% Prob": 2.3511159121990204, "Min_50.0% Prob": 1.8644620194667723, "Min_60.0% Prob": 1.5670444720557757}}
{"hexsha": "e7a20c0771bbd7b3014d634488c98259fe27a836", "ext": "c", "lang": "C", "content": "SOAP_FMAC4 soap_out__turb1__GetMagneticHessianResponse(struct soap *soap, const char *tag, int id, const struct _turb1__GetMagneticHessianResponse *a, const char *type)\n{\n\t(void)soap; (void)tag; (void)id; (void)type;\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__turb1__GetMagneticHessianResponse), type))\n\t\treturn soap->error;\n\tif (a->GetMagneticHessianResult)\n\t\tsoap_element_result(soap, \"turb1:GetMagneticHessianResult\");\n\tif (soap_out_PointerToturb1__ArrayOfVelocityHessian(soap, \"turb1:GetMagneticHessianResult\", -1, &a->GetMagneticHessianResult, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n}", "item_id": 471, "repo": "KTHVisualization/percMPI", "file": "fetchIso/soapC.c", "last_update_at": "2019-08-17T11:48:19+00:00", "question_id": "e7a20c0771bbd7b3014d634488c98259fe27a836_471", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SOAP_FMAC4 soap_out__turb1__GetMagneticHessianResponse(struct soap *soap, const char *tag, int id, const struct _turb1__GetMagneticHessianResponse *a, const char *type)\n{\n\t(void)soap; (void)tag; (void)id; (void)type;\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__turb1__GetMagneticHessianResponse), type))\n\t\treturn soap->error;\n\tif (a->GetMagneticHessianResult)\n\t\tsoap_element_result(soap, \"turb1:GetMagneticHessianResult\");\n\tif (soap_out_PointerToturb1__ArrayOfVelocityHessian(soap, \"turb1:GetMagneticHessianResult\", -1, &a->GetMagneticHessianResult, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n"]], "pred": {"ppl": 1.3337681293487549, "ppl_lower": 2.0721702575683594, "ppl/lowercase_ppl": -2.5297776361630113, "ppl/zlib": 0.0009931314355354232, "Min_5.0% Prob": 4.800702975346492, "Min_10.0% Prob": 2.836858231287736, "Min_20.0% Prob": 1.4483542202148014, "Min_30.0% Prob": 0.9670216570181461, "Min_40.0% Prob": 0.725495624688707, "Min_50.0% Prob": 0.576003341897529, "Min_60.0% Prob": 0.4806220079041103}}
{"hexsha": "f5e283d94ac8f9119b9c6a8af734385844207e91", "ext": "h", "lang": "C", "content": "static inline bool x86_feature_test(struct cpuid_bit bit)\r\n{\r\n    if(bit.word > 3 || bit.bit > 31) return false;\r\n\r\n    const struct cpuid_leaf* leaf = x86_cpuid_leaf(bit.leaf);\r\n    if(!leaf) return false;\r\n    switch(bit.word)\r\n    {\r\n        case 0: return ((1u << bit.bit) & leaf -> a) != 0;\r\n        case 1: return ((1u << bit.bit) & leaf -> b) != 0;\r\n        case 2: return ((1u << bit.bit) & leaf -> c) != 0;\r\n        case 3: return ((1u << bit.bit) & leaf -> d) != 0;\r\n        default: return false;\r\n    }\r\n}", "item_id": 1, "repo": "TheCool1Kevin/LiquiDOS", "file": "include/arch/x86/cpu.h", "last_update_at": "2019-09-17T12:49:49+00:00", "question_id": "f5e283d94ac8f9119b9c6a8af734385844207e91_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline bool x86_feature_test(struct cpuid_bit bit)\r\n{\r\n    if(bit.word > 3 || bit.bit > 31) return false;\r\n\r\n    const struct cpuid_leaf* leaf = x86_cpuid_leaf(bit.leaf);\r\n    if(!leaf) return false;\r\n    switch(bit.word)\r\n    {\r\n        case 0: return ((1u << bit.bit) & leaf -> a) != 0;\r\n        case 1: return ((1u << bit.bit) & leaf -> b) != 0;\r\n        case 2: return ((1u << bit.bit) & leaf -> c) != 0;\r\n        case 3: return ((1u << bit.bit) & leaf -> d) != 0;\r\n        default: return false;\r\n    }\r\n"]], "pred": {"ppl": 2.011460781097412, "ppl_lower": 2.011460781097412, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0032057853893396803, "Min_5.0% Prob": 6.358406967586941, "Min_10.0% Prob": 4.758788648404573, "Min_20.0% Prob": 3.190350339962886, "Min_30.0% Prob": 2.309900893733419, "Min_40.0% Prob": 1.7481990340046394, "Min_50.0% Prob": 1.3964704827652599, "Min_60.0% Prob": 1.1704854556900632}}
{"hexsha": "cfa13b41f8e45e5401e221ba41f3b5a9aecbdca4", "ext": "c", "lang": "C", "content": "static void \nselect_point(const limb idx, unsigned int size, const felem pre_comp[ /* size */ ][3],\n    felem out[3])\n{\n\tunsigned i, j;\n\tlimb *outlimbs = &out[0][0];\n\tmemset(outlimbs, 0, 3 * sizeof(felem));\n\n\tfor (i = 0; i < size; i++) {\n\t\tconst limb *inlimbs = &pre_comp[i][0][0];\n\t\tlimb mask = i ^ idx;\n\t\tmask |= mask >> 4;\n\t\tmask |= mask >> 2;\n\t\tmask |= mask >> 1;\n\t\tmask &= 1;\n\t\tmask--;\n\t\tfor (j = 0; j < NLIMBS * 3; j++)\n\t\t\toutlimbs[j] |= inlimbs[j] & mask;\n\t}\n}", "item_id": 24, "repo": "ArrogantWombatics/openbsd-src", "file": "lib/libssl/src/crypto/ec/ecp_nistp521.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "cfa13b41f8e45e5401e221ba41f3b5a9aecbdca4_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void \nselect_point(const limb idx, unsigned int size, const felem pre_comp[ /* size */ ][3],\n    felem out[3])\n{\n\tunsigned i, j;\n\tlimb *outlimbs = &out[0][0];\n\tmemset(outlimbs, 0, 3 * sizeof(felem));\n\tfor (i = 0; i < size; i++) {\n\t\tconst limb *inlimbs = &pre_comp[i][0][0];\n\t\tlimb mask = i ^ idx;\n\t\tmask |= mask >> 4;\n\t\tmask |= mask >> 2;\n\t\tmask |= mask >> 1;\n\t\tmask &= 1;\n\t\tmask--;\n\t\tfor (j = 0; j < NLIMBS * 3; j++)\n\t\t\toutlimbs[j] |= inlimbs[j] & mask;\n\t}\n"]], "pred": {"ppl": 2.620389938354492, "ppl_lower": 2.694010019302368, "ppl/lowercase_ppl": -1.0287625801459606, "ppl/zlib": 0.0036215155568861614, "Min_5.0% Prob": 7.988702730699019, "Min_10.0% Prob": 6.211304491216486, "Min_20.0% Prob": 4.157014118300544, "Min_30.0% Prob": 3.0408699889393414, "Min_40.0% Prob": 2.373314992739604, "Min_50.0% Prob": 1.9244240329257751, "Min_60.0% Prob": 1.6069750245388625}}
{"hexsha": "3055e07590dfce27df1a4f2023212eece937e7e7", "ext": "c", "lang": "C", "content": "void printBucket(pkBucket* bucket){\n\tfprintf(stderr, \"------------------------------------------------------------\\n\");\n\tfprintf(stderr, \"local_depth(%\"PRIu32\"), current_subBuckets(%\"PRIu32\")\\n\", bucket->local_depth, bucket->current_subBuckets);\n\tuint64_t i;\n\tuint32_t j;\n\tfor (i = 0 ; i < bucket->current_subBuckets ; i++) { //\n\t\tKey key = bucket->key_buckets[i]->key;\n\t\tuint64_t current_entries = bucket->key_buckets[i]->current_entries;\n\t\tfprintf(stderr, \"\\tSubBucket(%zd): key: %zd, current_entries: %zd\\n\", i, key, current_entries);\n\t\tfor (j = 0 ; j < current_entries ; j++) {\n\t\t\tuint64_t tid = bucket->key_buckets[i]->transaction_range[j].transaction_id;\n\t\t\tuint64_t rec_offset = bucket->key_buckets[i]->transaction_range[j].rec_offset;\n\t\t\tfprintf(stderr, \"\\t\\ttid: %zd, offset :%zd\\n\", tid, rec_offset);\n\t\t}\n\t}\n\tfprintf(stderr, \"------------------------------------------------------------\\n\");\n}", "item_id": 10, "repo": "thanosgn/sigmod-2015", "file": "src/PKeyHash.c", "last_update_at": "2019-05-28T20:58:46+00:00", "question_id": "3055e07590dfce27df1a4f2023212eece937e7e7_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void printBucket(pkBucket* bucket){\n\tfprintf(stderr, \"------------------------------------------------------------\\n\");\n\tfprintf(stderr, \"local_depth(%\"PRIu32\"), current_subBuckets(%\"PRIu32\")\\n\", bucket->local_depth, bucket->current_subBuckets);\n\tuint64_t i;\n\tuint32_t j;\n\tfor (i = 0 ; i < bucket->current_subBuckets ; i++) { //\n\t\tKey key = bucket->key_buckets[i]->key;\n\t\tuint64_t current_entries = bucket->key_buckets[i]->current_entries;\n\t\tfprintf(stderr, \"\\tSubBucket(%zd): key: %zd, current_entries: %zd\\n\", i, key, current_entries);\n\t\tfor (j = 0 ; j < current_entries ; j++) {\n\t\t\tuint64_t tid = bucket->key_buckets[i]->transaction_range[j].transaction_id;\n\t\t\tuint64_t rec_offset = bucket->key_buckets[i]->transaction_range[j].rec_offset;\n\t\t\tfprintf(stderr, \"\\t\\ttid: %zd, offset :%zd\\n\", tid, rec_offset);\n\t\t}\n\t}\n\tfprintf(stderr, \"------------------------------------------------------------\\n\");\n"]], "pred": {"ppl": 2.4442930221557617, "ppl_lower": 2.5890583992004395, "ppl/lowercase_ppl": -1.0643781223863316, "ppl/zlib": 0.002775639529880938, "Min_5.0% Prob": 7.88908436719109, "Min_10.0% Prob": 6.0654727501027725, "Min_20.0% Prob": 4.030775084215052, "Min_30.0% Prob": 2.891363619881518, "Min_40.0% Prob": 2.213852182030678, "Min_50.0% Prob": 1.7844653333592064, "Min_60.0% Prob": 1.4912991367883104}}
{"hexsha": "c8273645b2c24f29f02b4752da474284e112221d", "ext": "c", "lang": "C", "content": "void ports_init(Ports *ports)\n{\n    ports->ctl = 0xff;\n    ports->TRA = TRI_HIGHZ;\n    ports->THA = TRI_HIGHZ;\n    ports->TRB = TRI_HIGHZ;\n    ports->THB = TRI_HIGHZ;\n}", "item_id": 0, "repo": "Noah1989/micro-21", "file": "software/collapseos/emul/z80/sms_ports.c", "last_update_at": "2019-05-17T14:43:17+00:00", "question_id": "c8273645b2c24f29f02b4752da474284e112221d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ports_init(Ports *ports)\n{\n    ports->ctl = 0xff;\n    ports->TRA = TRI_HIGHZ;\n    ports->THA = TRI_HIGHZ;\n    ports->TRB = TRI_HIGHZ;\n    ports->THB = TRI_HIGHZ;\n"]], "pred": {"ppl": 3.620497941970825, "ppl_lower": 5.003140449523926, "ppl/lowercase_ppl": -1.2514000677864834, "ppl/zlib": 0.016082644617609297, "Min_5.0% Prob": 9.532398700714111, "Min_10.0% Prob": 7.901286780834198, "Min_20.0% Prob": 5.5773948851753685, "Min_30.0% Prob": 4.151600558757782, "Min_40.0% Prob": 3.177964568576392, "Min_50.0% Prob": 2.5938021379212537, "Min_60.0% Prob": 2.143218714944726}}
{"hexsha": "2b4cf099e5f2192244be97af7e5ee00f527448d5", "ext": "c", "lang": "C", "content": "int main(void)\n{\n    int status;\n    pid_t pid;\n\n    if((pid = vfork()) > 0) // vfork = chd\ub97c \uc0dd\uc131\ud558\uace0 parent\ub294 \ube14\ub85d\uc2dc\ud0a8\ub2e4.\n                            //\uc77c\ubc18\uc801\uc778 fork\ub294 \uba54\ubaa8\ub9ac \uc804\uccb4\ub97c \uc2f9\ub2e4 \ubcf5\uc0ac\ud55c\ub2e4. \uadf8\ub807\uac8c \uc9c4\ud589\ud55c\ub2e4\uba74 \ud398\uc774\uc9d5\uc744 \uc4f8\ub370\uc5c6\uc774 \ub9ce\uc774\ud574\uc11c\n                        // \uc6a9\ub7c9\uc744 \ub0ad\ube44\ud55c\ub2e4.\n                     // VFORK\ub294 task_struct\ub9cc \uc0dd\uc131\ud558\uace0 \ubcf5\uc0ac\uc791\uc5c5\uc740 \ud558\uc9c0\uc54a\ub294\ub2e4.\n                     // exec\ub294 \uac00\uc0c1\uba54\ubaa8\ub9ac\uc758 \ub808\uc774\uc544\uc6c3\ub9cc\uc7a1\ub294\ub2e4.\n\n\n    {\n        waitpid(-1, &status, WNOHANG);\n        printf(\"ls -al test Success\\n\");\n    }\n\n    else if(!pid)\n    {\n        execlp(\"ls\", \"ls\", \"-a\", \"-l\", 0);\n    }\n\n    return 0;\n}", "item_id": 0, "repo": "daeroro/IntegrationProject", "file": "F458/dsp/ccs_backup1/kyunghwan/exec2.c", "last_update_at": "2019-04-29T02:45:44+00:00", "question_id": "2b4cf099e5f2192244be97af7e5ee00f527448d5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void)\n{\n    int status;\n    pid_t pid;\n    if((pid = vfork()) > 0) // vfork = chd\ub97c \uc0dd\uc131\ud558\uace0 parent\ub294 \ube14\ub85d\uc2dc\ud0a8\ub2e4.\n                            //\uc77c\ubc18\uc801\uc778 fork\ub294 \uba54\ubaa8\ub9ac \uc804\uccb4\ub97c \uc2f9\ub2e4 \ubcf5\uc0ac\ud55c\ub2e4. \uadf8\ub807\uac8c \uc9c4\ud589\ud55c\ub2e4\uba74 \ud398\uc774\uc9d5\uc744 \uc4f8\ub370\uc5c6\uc774 \ub9ce\uc774\ud574\uc11c\n                        // \uc6a9\ub7c9\uc744 \ub0ad\ube44\ud55c\ub2e4.\n                     // VFORK\ub294 task_struct\ub9cc \uc0dd\uc131\ud558\uace0 \ubcf5\uc0ac\uc791\uc5c5\uc740 \ud558\uc9c0\uc54a\ub294\ub2e4.\n                     // exec\ub294 \uac00\uc0c1\uba54\ubaa8\ub9ac\uc758 \ub808\uc774\uc544\uc6c3\ub9cc\uc7a1\ub294\ub2e4.\n    {\n        waitpid(-1, &status, WNOHANG);\n        printf(\"ls -al test Success\\n\");\n    }\n    else if(!pid)\n    {\n        execlp(\"ls\", \"ls\", \"-a\", \"-l\", 0);\n    }\n    return 0;\n"]], "pred": {"ppl": 3.8248138427734375, "ppl_lower": 3.763279914855957, "ppl/lowercase_ppl": -0.9879099633611748, "ppl/zlib": 0.0029811328834181833, "Min_5.0% Prob": 8.474661350250244, "Min_10.0% Prob": 6.63947783747027, "Min_20.0% Prob": 4.8707159103885775, "Min_30.0% Prob": 3.8465022528043358, "Min_40.0% Prob": 3.1403914118005383, "Min_50.0% Prob": 2.606073741729443, "Min_60.0% Prob": 2.2150798683019883}}
{"hexsha": "b48634e4e333214f2dc5941348a151a45796761c", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[])\n{\n    int i, err_no, rule_no, rc = 0;\n    int wait_count = DEFAULT_WAIT_COUNT, skip_flag;\n    char *kdblevel = NULL, *eeh_env = NULL, *ptr = NULL;\n    struct ruleinfo *current_ruleptr;\n    char msg[MAX_TEXT_MSG], script_path[64], cmd_str[128];\n    struct thread_context *current_tctx;\n    char file_name[128];\n\n    struct sigaction sigvector, sigdata;\n    static sigset_t  sigmask;\n\n    /****************************************/\n    /**     Register Signal handlers        */\n    /****************************************/\n    sigemptyset((&sigvector.sa_mask)); /* empty the mask */\n    sigvector.sa_flags = 0;\n    sigvector.sa_handler = (void (*)(int)) SIGTERM_hdl;\n    sigaction(SIGTERM, &sigvector, (struct sigaction *) NULL); /* set signal handler for SIGTERM */\n\n\n    sigprocmask(0, NULL, &sigmask); /* get current signal mask     */\n    sigdata.sa_flags = SA_RESTART; /* restart on signal calls     */\n    sigdata.sa_mask = sigmask;  /* set the signal mask */\n\n    sigdata.sa_handler = (void(*)(int))sig_function;\n    sigaction(SIGUSR1, &sigdata, NULL); /* call when recv sig 30 */\n\n    sigdata.sa_handler = (void(*)(int))int_sig_function;\n    sigaction(SIGINT, &sigdata, NULL); /* set signal handler for SIGINT */\n\n    /*********************************************/\n    /** Initialize thread attributes and mutex  **/\n    /*********************************************/\n    pthread_attr_init(&thread_attrs_detached);\n    pthread_attr_setdetachstate(&thread_attrs_detached, PTHREAD_CREATE_DETACHED);\n\n    pthread_mutex_init(&thread_create_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&cache_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&fencepost_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&stats_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&dump_mutex, DEFAULT_MUTEX_ATTR_PTR);\n#ifndef __HTX_LINUX__\n    pthread_mutex_init(&log_mutex, DEFAULT_MUTEX_ATTR_PTR);\n#endif\n\n    pthread_cond_init(&create_thread_cond_var, DEFAULT_COND_ATTR_PTR);\n    pthread_cond_init(&do_oper_cond_var, DEFAULT_COND_ATTR_PTR);\n    pthread_cond_init(&threads_finished_cond_var, DEFAULT_COND_ATTR_PTR);\n\n    bzero(&dev_info, sizeof(dev_info));\n    dev_info.cont_on_misc = UNINITIALIZED;\n\n    /************************************************/\n    /*******   Read command line arguments    *******/\n    /************************************************/\n    memset(&data, 0, sizeof(struct htx_data));\n    strcpy(data.HE_name, argv[0]);\n    strcpy(data.sdev_id, argv[1]);\n    strcpy(dev_info.dev_name, argv[1]);\n    strcpy(data.run_type, argv[2]);\n    strcpy(dev_info.rules_file_name, argv[3]);\n\n    hxfupdate(START, &data);\n    sprintf(msg, \"%s %s %s %s \\n\", data.HE_name, data.sdev_id, data.run_type, dev_info.rules_file_name);\n    user_msg(&data, 0, 0, INFO, msg);\n\n    /* globla_htx_d will be used by stats thread. So, this need to be updated\n     * from data.\n     */\n     memcpy(&global_htx_d, &data, sizeof(struct htx_data));\n\n    /*************************************************************************/\n    /* Sanity check:                                                         */\n    /* Before we open the device, check to see if it is a member of a volume */\n    /* group which is currently defined in the ODM.  This check prevents     */\n    /* accidentally clobbering a disk which was added to a volume group      */\n    /* after logging on as htx.                                              */\n    /* If check_disk returns < 0, then the device is OK to exercise.         */\n    /*************************************************************************/\n\n    ptr = getenv(\"HTXSCRIPTS\");\n    if (ptr != NULL) {\n\t\tstrcpy(script_path, ptr);\n    } else {\n        sprintf(msg, \"HTX env. is not set. Hence exiting.\\nPlease setup the env. and re-run the test\");\n        user_msg(&data, 0, 0, INFO, msg);\n        exit(1);\n    }\n\n#ifndef __HTX_LINUX__\n    if ( (rc = check_disk(data.sdev_id, msg, sizeof(msg))) == 0) {\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(126);\n    } else if (rc > 0 ) {\n        sprintf(msg, \"ODM or LVM error in check_disk, rc = %d\\n%s\", rc, msg);\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(1);\n    }\n#else\n    sprintf(cmd_str, \"%scheck_disk %s\", script_path, data.sdev_id);\n    rc = system(cmd_str);\n    if (WIFEXITED(rc)) {\n        if (WEXITSTATUS(rc) == 1) {\n            sprintf(msg, \"Disk either has partitions OR is used by the system. So, can not run exerciser on it. Hence exiting.\");\n            user_msg(&data, 0, 0, INFO, msg);\n            exit(1);\n        }\n    } else {\n        sprintf(msg, \"command did not completed properly. Hence exiting.\");\n        user_msg(&data, 0, 0, INFO, msg);\n        exit(1);\n    }\n#endif\n\n    /****************************************************/\n    /****** Get hostname for machine running code *******/\n    /****************************************************/\n    rc = gethostname(dev_info.hostname, 16);\n    if ( rc != 0 ) {\n        sprintf(msg, \"Unable to get hostname for this run!, errno = %d \\n\", errno);\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n\n    /*****************************************************/\n    /******* Get HTXKDBLEVEL and EEH env. variable *******/\n    /*****************************************************/\n    dev_info.crash_on_miscom = 1;\n    kdblevel = getenv(\"HTXKDBLEVEL\");\n    if (kdblevel != NULL) {\n        if (!(atoi(kdblevel))) {\n            dev_info.crash_on_miscom = 0;\n        }\n    }\n    eeh_env = getenv(\"HTXEEH\");\n    if (eeh_env != NULL) {\n        if (atoi(eeh_env)) {\n            ptr = getenv(\"HTXEEHRETRIES\");\n            if (ptr != NULL) {\n                eeh_retries = atoi(getenv(\"HTXEEHRETRIES\"));\n\t\t\t}\n        } else if((strcmp(data.run_type, \"REG\") == 0) && data.p_shm_HE->cont_on_err) {\n            /* If User specifies COE in mdt file, then need to make sure all\n             * read/write call are successfull. If we see ocassional error, retry.\n             */\n            eeh_retries = DEFAULT_EEH_RETRIES;\n        }\n    }\n\n    /* Create mmaped dump file */\n    sprintf (file_name, \"%s/IO_details_dump.log\", data.htx_exer_log_dir);\n    mmap_fd = open (file_name, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n    if (mmap_fd == -1) {\n        sprintf(msg, \"Could not open the dump file. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    if (lseek (mmap_fd, MMAP_FILE_SIZE, SEEK_SET) == -1) {\n        perror(\"lseek\");\n    }\n    rc = write(mmap_fd, \"\", 1);\n    close(mmap_fd);\n\n    mmap_fd = open (file_name, O_RDWR);\n    if (mmap_fd == -1) {\n        sprintf(msg, \"Could not open the dump file. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    /* Do the mmap of the file */\n    mmap_ptr = (char *) mmap( NULL, MMAP_FILE_SIZE, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, mmap_fd, 0);\n    if (mmap_ptr == (void *) -1) {\n        sprintf(msg, \"mmap failed. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    close(mmap_fd);\n\n    if (strcmp(data.run_type, \"REG\") == 0){\n        /* time_driven_htx read the time_interval_for_run from the shm header */\n        time_interval_for_run = get_exec_time_value_from_shm_hdr(&data);\n        sprintf(msg,\"debug_msg6 from FPU, exec_time = %d \\n\",time_interval_for_run);\n        hxfmsg (&data, 0, INFO, msg);\n    }\n\n    /****************************************************************************/\n\t/*   For CAPI flash, Device given as input is of format /dev/rhdisk[0-1]*.N */\n    /*   on AIX and sd[a-z][a-z]*.N on Linux. Actual device would be            */\n    /*   /dev/rhdisk[0-1] OR /dev/sd[a-z][a-z, 0-1]* and our invocation count   */\n    /*   would be N. Extract device name from argv[1]                           */\n\t/****************************************************************************/\n\n#ifdef __CAPI_FLASH__\n\tchar file[128] = \"/tmp/test_lun_mode\";\n    FILE * fp ;\n\tuint32_t num_instance = 0;\n\tchar buf[128];\n\n    char device[MAX_STR_SZ], intance[MAX_STR_SZ], input_dev[MAX_STR_SZ], temp[MAX_STR_SZ];\n    int str_len, indx=0;\n    strcpy(input_dev, basename(data.sdev_id));\n    str_len = strlen(input_dev);\n\n\trc = cblk_init(NULL, 0);\n\tif (rc != 0) {\n       sprintf(msg, \"cblk_init returned error. rc: %d.\", rc);\n       user_msg(&data, 0, 0, HARD, msg);\n       exit(1);\n    }\n\n    for(i = 0; i <= str_len; i++ ) {\n        temp[indx]=input_dev[i];\n        if(input_dev[i] == '.' ) {\n            strncpy(device, temp, indx);\n            device[indx] = '\\0';\n            indx = 0;\n            memset(temp, 0, MAX_STR_SZ);\n        } else  if (input_dev[i] == '\\0') {\n            strcpy(intance, temp);\n        } else {\n            indx++;\n        }\n    }\n\n\tif(device[0] == 'r') {\n    \tstrncpy(dev_info.diskname, &device[1], MAX_STR_SZ);\n\t} else {\n\t\tstrncpy(dev_info.diskname, &device[0], MAX_STR_SZ);\n\t}\n\tsprintf(capi_device,\"/dev/%s\",&device[0]);\n    printf(\"input_dev=%s, device=%s, intance=%s, capi_device=%s \\n\", input_dev, device, intance, capi_device);\n    fflush(stdout);\n\n\trc = access(file, F_OK);\n    if(rc == -1 ) {\n    #ifdef __HTX_LINUX__\n        /* In case of Linux, if file does not exist, we run in VLUN mode.\n         * Hence, setting the params for VLUN mode.\n         */\n        lun_type = CBLK_OPN_VIRT_LUN;\n        dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;\n        dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n    #else\n        /* In case of AIX, if file does not exist, means we are testing in Legacy mode.\n         * hxestorage should run on this device instead of hxesurelock. Hence, exiting.\n         */\n\t\tsprintf(msg, \"File: %s, doesnot exists!! this exerciser should not have been envoked. \\n\", file);\n\t\tuser_msg(&data, 0, 0, HARD, msg);\n\t\treturn(rc);\n    #endif\n\t} else {\n        /************************************************/\n\t    /* Get content of file : \"/tmp/test_lun_mode\"   */\n\t    /************************************************/\n\t    sprintf(cmd_str, \"cat %s\", file);\n        fp = popen(cmd_str, \"r\");\n        if (fp == NULL) {\n            sprintf(msg, \"popen failed while reading file=%s with errno=%d. Setting Virtual LUN mode. \\n\", file, errno);\n            user_msg(&data, 0, 0, INFO, msg);\n\t    \tnum_instance = 2;\n        } else {\n            if (fgets(buf, 128, fp) == NULL) {\n                sprintf(msg, \"fgets failed while reading from file = %s, errno=%d. Setting Virtual LUN mode. \\n \\n\", file, errno);\n                user_msg(&data, 0, 0, INFO, msg);\n                pclose(fp);\n\t    \t\tnum_instance = 2;\n            } else {\n                pclose(fp);\n                num_instance = atoi(buf);\n            }\n        }\n\n\t    if(num_instance == 1) {\n\t    \t/***********************************************************/\n            /* File exists with value=1, we are testing PLUNs. We can  */\n            /* query IOCINFO on PLUNs for total blocks and block size. */\n            /***********************************************************/\n            lun_type            = CBLK_OPN_PHY_LUN;\n        #ifndef __HTX_LINUX__\n            rc = get_disk_info(&data, capi_device);\n            if ( rc != 0) {\n                exit(1);\n            }\n            /****************************************************/\n            /* For PLUN chunk_size is same as num blocks on disk*/\n            /****************************************************/\n            chunk_size = dev_info.maxblk + 1;\n        #else\n            chunk_id_t chunk_id = NULL_CHUNK_ID;\n        #ifdef __HTX_LINUX__\n            chunk_attrs_t attr;\n        #endif\n\n            chunk_id = cblk_open(capi_device, MAX_THREADS, O_RDWR, 0, 0);\n            if(chunk_id == NULL_CHUNK_ID) {\n                sprintf(msg, \"main : Cannot get a valid chunk_id, capi_device = %s, errno = %d \\n\", capi_device, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n\t        }\n            rc = cblk_get_lun_size(chunk_id, (unsigned long *)&dev_info.maxblk, 0);\n            if(rc ) {\n                sprintf(msg, \"cblk_get_size failed with rc = %d, errno = %d \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                return(1);\n            }\n        #ifdef __HTX_LINUX__\n            rc = cblk_get_attrs (chunk_id, &attr, 0);\n            if (rc) {\n                sprintf(msg, \"cblk_get_attrs failed with rc = %d, errno = %x \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n            }\n\n            if (attr.flags1 & CFLSH_ATTR_UNMAP) {\n                discard_enabled = 1;\n            }\n        #endif\n            rc = cblk_close(chunk_id, CBLK_SCRUB_DATA_FLG);\n            if(rc) {\n                sprintf(msg, \"cblk_close failed with rc = %d, errno = %x \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n            }\n            chunk_id = NULL_CHUNK_ID;\n            /****************************************************/\n            /* For PLUN chunk_size is same as num blocks on disk*/\n            /****************************************************/\n            chunk_size = dev_info.maxblk;\n            dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n        #endif\n\t    } else {\n            if (num_instance == 0) {\n            #ifdef __HTX_LINUX__\n                 /* in case of LInux, If value in file is 0, means we are testing VLUN */\n                dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;\n                dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n                lun_type = CBLK_OPN_VIRT_LUN;\n            #else\n                /* In case of AIX, value 0 means, we need to run in LEGACY mode. So error out */\n                sprintf(msg, \"File: %s, exists but value = %d, this exerciser should not have been envoked. \\n\", file, num_instance);\n                user_msg(&data, 0, 0, HARD, msg);\n                return(rc);\n            #endif\n            } else {\n                /********************************************************/\n\t            /* File exists with value > 1, we are testing VLUNS.    */\n\t    \t    /* VLUNs have capability to dynamically change size.    */\n\t    \t    /* So user request for it through chunk_size rules parm.*/\n\t    \t    /********************************************************/\n\t \t        dev_info.maxblk \t= (unsigned long long)VLUN_TOTALBLOCKS;\n\t            dev_info.blksize \t= (unsigned int)VLUN_BLKSIZE;\n\t\t        lun_type \t\t\t= CBLK_OPN_VIRT_LUN;\n\t        }\n        }\n    }\n#else\n    /***************************************************/\n    /****   Get disk info using IOCINFO ioctl.      ****/\n    /****   This will update maxblk and blksize.    ****/\n    /***************************************************/\n    rc = get_disk_info(&data, data.sdev_id);\n    if ( rc != 0) {\n        exit(1);\n    }\n#endif\n\n    /***************************************************/\n    /********           Read rule file          ********/\n    /***************************************************/\n    rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);\n    if (rc != 0) {\n        sprintf(msg, \"Check HTXERR log for a listing of errors with rule file reading!\\n\");\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(1);\n    }\n    segment_table_init();\n\n    /* time_driven_htx */\n    /* if we provide a value for time_interval_for_run along with cmdline as arg then only we need to populate these variables */\n    if (time_interval_for_run > 0){\n        /* provide total no. of stanzas present */\n        total_no_of_stanzas_present = num_rules_defined;\n        if (total_BWRC_threads > 0) {\n            if (rule_list[1].oper[0][0] == 'S' || rule_list[1].oper[0][0] == 's') {\n                time_interval_for_run -= (rule_list[1].sleep / 1000000);\n            }\n            time_interval_for_stanza_switch_tmp = time_interval_for_run / (total_no_of_stanzas_present - 2);\n        } else {\n            time_interval_for_stanza_switch_tmp = time_interval_for_run/total_no_of_stanzas_present;\n        }\n        /* provide the reference to exit_flag */\n        time_diff_struct.exit_flag = &exit_flag;\n    }\n\n    /* if run_on_misc is set to YES and misc_run_cmd is null. {Populate the default script to run*/\n    if (run_on_misc == 'Y' && strcmp(misc_run_cmd, \"\") == 0) {\n        sprintf(misc_run_cmd, \"%s/storage_miscom_pre_kdb_script\", script_path);\n    }\n\n    time_mark = time(0); /* set time mark for comparison */\n    if (enable_state_table == YES) {\n        rc = initialize_state_table(&data, data.sdev_id);\n        if (rc == -1) {\n\t\t\texit(1);\n\t    }\n    }\n\n#ifdef __HTX_LINUX__\n    /* Check if write cahce is enabled if sync_cache is set to yes in any\n     * of the rule. This will set dev_info.write_cache to 1 if enabled,\n     * otherwise 0.\n     */\n    dev_info.write_cache = 0;\n    if (sync_cache_flag == 1) {\n        dev_info.write_cache = check_write_cache (&data);\n        /* Create a separate thread to issue CACHE_SYNC ioctl at regular interval */\n        if (dev_info.write_cache == 1 && randomize_sync_cache == 1) {\n            rc = pthread_create(&sync_cache_th, &thread_attrs_detached, (void *(*)(void *))sync_cache_thread, (void *)(&data));\n            if (rc != 0) {\n                sprintf(msg, \"pthread_create failed for sync_cache threas. errno. set is: %d\\n\", rc);\n                user_msg(&data, rc, 0, HARD, msg);\n                exit(1);\n\t\t    }\n        } else if (dev_info.write_cache == 0) {\n            sprintf(msg, \"Write cache is is not enabled. Will not run sync_cache thread.\");\n            user_msg(&data, 0, 0, INFO, msg);\n        }\n        sprintf(msg, \"write cache is : %d\\n\", dev_info.write_cache);\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n#endif\n\n    /*****************************************************************/\n    /* Allocate memory for BWRC threads. Since lifetime of BWRC      */\n    /* threads can span across multiple stanzas. So, we pre-allocate */\n    /* memory for all BWRC threads defined in various stanzas in the */\n    /* rulefile. Information of BWRC threads of various stanzas once */\n    /* updated here will be maintained till end of the exerciser.    */\n    /*****************************************************************/\n    if (total_BWRC_threads != 0) {\n        BWRC_threads_mem = (struct thread_context *) malloc(total_BWRC_threads * sizeof(struct thread_context));\n        if (BWRC_threads_mem == NULL) {\n            err_no = errno;\n            sprintf(msg, \"malloc failed(with errno: %d) while allocating memory for BWRC thread context.\\n\", errno);\n            user_msg(&data, err_no, 0, HARD, msg);\n            exit(1);\n        }\n        initialize_threads(BWRC_threads_mem, total_BWRC_threads);\n        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {\n            current_ruleptr = &rule_list[rule_no];\n            if (current_ruleptr->num_BWRC_threads == 0) {\n                continue;\n            } else {\n                populate_BWRC_thread_context(&data, current_ruleptr, BWRC_threads_mem);\n            }\n        }\n    }\n\n    /*********************************************************************/\n    /****** run hang_monitor thread to keep a check of any HUNG IO  ******/\n    /*********************************************************************/\n    rc = pthread_create(&(hang_monitor_thread), &thread_attrs_detached, (void *(*)(void *))hang_monitor, (void *)(&data));\n    if (rc != 0) {\n        sprintf(msg, \"pthread_create failed for hang_monitor thread. errno set is: %d\\n\", rc);\n        user_msg(&data, rc, 0, HARD, msg);\n        /* Free BWRC memory also if allocated */\n        if (BWRC_threads_mem != NULL) {\n            free (BWRC_threads_mem);\n            BWRC_threads_mem = NULL;\n        }\n        exit(1);\n    }\n\n    /*******************************************************/\n    /******     Create stats updation thread         *******/\n    /*******************************************************/\n    rc = pthread_create(&stats_update_th, &thread_attrs_detached, (void *(*)(void *))stats_update_thread, NULL);\n    if (rc != 0) {\n        sprintf(msg, \"pthread_create failed for stats update thread. errno set is: %d\\n\", rc);\n        user_msg(&data, rc, 0, HARD, msg);\n        /* Free BWRC memory also if allocated */\n        if (BWRC_threads_mem != NULL) {\n            free (BWRC_threads_mem);\n            BWRC_threads_mem = NULL;\n        }\n        exit(1);\n    }\n\n    /******************************************************/\n    /*******    Start processing of stanza          *******/\n    /******************************************************/\n    read_rules_file_count = 1;\n    do {\n        current_ruleptr = &rule_list[0];\n        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {\n            /* DPRINT(\"%s:%d - Running stanza: %d\\n\", __FUNCTION__, __LINE__, rule_no + 1); */\n            data.test_id = rule_no + 1;\n            HTX_STATS_UPDATE (UPDATE , &data);\n\n            skip_flag = 0;\n            /******************************************************************/\n            /***    Check rule parameter to see if need to skip this stanza ***/\n            /******************************************************************/\n            if ( current_ruleptr->repeat_pos > 0 ) {\n                if ((read_rules_file_count == 1)                                ||\n                    ((read_rules_file_count % current_ruleptr->repeat_pos) !=0) ||\n                    ((current_ruleptr->repeat_pos == 1)                         &&\n                    (!(read_rules_file_count & 1)))\n                )  {\n                    skip_flag = 1;\n                }\n            } else if ( current_ruleptr->repeat_neg > 0 ) {\n                if (((read_rules_file_count != 1)                                   &&\n                    ((read_rules_file_count % current_ruleptr->repeat_neg) != 0))   ||\n                    ((current_ruleptr->repeat_neg == 1)                             &&\n                    (!(read_rules_file_count & 1))                                  &&\n                    (read_rules_file_count != 1))) {\n                    skip_flag = 1;\n                }\n            }\n\n            /****************************************************/\n            /**  If not skipping the stanza, run the testcase  **/\n            /****************************************************/\n            if (skip_flag != 1) {\n                if (current_ruleptr->oper[0][0] == 'S' || current_ruleptr->oper[0][0] == 's') {\n                    usleep(current_ruleptr->sleep);\n                } else if (strcasecmp(current_ruleptr->oper[0], \"XCMD\") == 0) {\n                    rc = run_cmd(&data, current_ruleptr->cmd_list);\n                } else {\n                    /************************************************************************/\n                    /****           Allocate memory for non BWRC threads context        *****/\n                    /************************************************************************/\n                    num_non_BWRC_threads = current_ruleptr->num_threads - current_ruleptr->num_BWRC_threads;\n                    if (num_non_BWRC_threads) {\n                        non_BWRC_threads_mem = (struct thread_context *) malloc (num_non_BWRC_threads * sizeof(struct thread_context));\n                        if (non_BWRC_threads_mem == NULL) {\n                            err_no = errno;\n                            sprintf(msg, \"malloc failed(with errno: %d) while allocating memory for thread context.\\n\", errno);\n                            user_msg(&data, err_no, 0, HARD, msg);\n                            /* Free BWRC memory also if allocated */\n                            if (BWRC_threads_mem != NULL) {\n                                free (BWRC_threads_mem);\n                                BWRC_threads_mem = NULL;\n                            }\n                            exit(1);\n                        }\n                        initialize_threads(non_BWRC_threads_mem, num_non_BWRC_threads);\n\n                        /**********************************************/\n                        /* Populate thread context for all non BWRC   */\n                        /* threads defined in current stanza.         */\n                        /**********************************************/\n                        rc = populate_thread_context(&data, current_ruleptr, BWRC_threads_mem, non_BWRC_threads_mem);\n                    }\n\n                    /**************************************************************/\n                    /*** Spawn threads to execute testcase. First, BWRC threads ***/\n                    /*** will be created for current stanza, if defined any.    ***/\n                    /*** After that, non BWRC threads will be created.          ***/\n                    /**************************************************************/\n                    rc = pthread_mutex_lock(&thread_create_mutex);\n                    if (rc) {\n                        sprintf(msg, \"Mutex lock failed in MAIN, rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(1);\n                    }\n                    for (i = 0; i < current_ruleptr->num_BWRC_threads; i++) {\n                        current_tctx = &(BWRC_threads_mem[current_ruleptr->BWRC_th_mem_index + i]);\n\n                        /* Need to check if current BWRC thread status is 'F' (i.e. Finished), then only\n                         * need to create the thread. Otherwise, skip it.\n                         */\n                        if (lba_fencepost[current_tctx->fencepost_index].status == 'F') {\n                            rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,\n                                            (void *(*)(void *)) execute_thread_context, (void *) current_tctx);\n                            if (rc) {\n                                sprintf(msg, \"rc %d, errno %d from main(): pthread_create for BWRC threads no: %d\",\n                                        rc, errno, i);\n                                user_msg(&data, rc, 0, HARD, msg);\n                                exit(rc);\n                            }\n                            rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);\n                            if (rc) {\n                                sprintf(msg, \"Cond wait failed in MAIN for BWRC thread, rc = %d\\n\", rc);\n                                user_msg(&data, rc, 0, HARD, msg);\n                                exit(rc);\n                            }\n                            BWRC_threads_running++;\n                        } else {\n                            continue;\n                        }\n                    }\n                    for (i=0; i < num_non_BWRC_threads; i++) {\n                        current_tctx = &(non_BWRC_threads_mem[i]);\n                        current_tctx->th_num = i;\n                        rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,\n                                    (void *(*)(void *)) execute_thread_context, (void *) current_tctx);\n                        if (rc) {\n                            sprintf(msg, \"rc %d, errno %d from main(): pthread_create\", rc,errno);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                        rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);\n                        if (rc) {\n                            sprintf(msg, \"Cond wait failed in MAIN, rc = %d\\n\", rc);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                        non_BWRC_threads_running++;\n                    }\n\n                    /**********************************************************************/\n                    /******      Send broadcast to all threads to start executing   *******/\n                    /**********************************************************************/\n                    rc = pthread_cond_broadcast(&do_oper_cond_var);\n                    if ( rc ) {\n                        sprintf(msg,\"pthread_cond_broadcast failed for do_oper_cond_var. rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(1);\n                    }\n\n                    /*************************************************************/\n                    /****   wait for threads to finish if non BWRC stanza   ******/\n                    /*************************************************************/\n                    if (current_ruleptr->is_only_BWRC_stanza == 'N') {\n                        rc = pthread_cond_wait(&threads_finished_cond_var, &thread_create_mutex);\n                        if (rc) {\n                            sprintf(msg, \"Cond wait failed in MAIN for threads_finished condition variable.rc = %d\\n\", rc);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                    }\n                    rc = pthread_mutex_unlock(&thread_create_mutex);\n                    if (rc) {\n                        sprintf(msg, \"Mutex unlock failed in MAIN, rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(rc);\n                    }\n\n                    /***********************************************************/\n                    /********       Clean up thread context memory      ********/\n                    /***********************************************************/\n                    if (non_BWRC_threads_mem != NULL) {\n                        free(non_BWRC_threads_mem);\n                        non_BWRC_threads_mem = NULL;\n                    }\n                }\n            } else {\n                sprintf(msg, \"Rule %s Has Been SKIPPED......\\n\", current_ruleptr->rule_id);\n                user_msg(&data, 0, 0, INFO, msg);\n            }\n            current_ruleptr++;\n\n            if (exit_flag == 1 || int_signal_flag == 'Y' || signal_flag == 'Y') {\n                break;\n            }\n            /* DPRINT(\"%s:%d - Completed stanza: %d\\n\", __FUNCTION__, __LINE__, rule_no + 1); */\n\n            /* time_driven_htx switches stanza with the given interval by setting time_out_flag as 0 */\n            if (time_interval_for_run > 0) {\n                rc = pthread_mutex_lock(&mutex_for_time_driven_exec);\n                if (rc) {\n                    sprintf(msg, \"Mutex lock failed in MAIN for time_driven_exec, rc = %d\\n\", rc);\n                    user_msg(&data, rc, 0, HARD, msg);\n\t\t\t    }\n\t\t\t    (time_diff_struct.time_out_flag) = 0;\n                rc = pthread_mutex_unlock(&mutex_for_time_driven_exec);\n                if (rc) {\n                    sprintf(msg, \"Mutex unlock failed in MAIN for time_driven_exec, rc = %d\\n\", rc);\n                    user_msg(&data, rc, 0, HARD, msg);\n\t\t\t    }\n\t\t    }\n        } /* End rule_no < num_rules_defined for loop */\n\n        if (signal_flag == 'Y') {\n\t\t\t/*************************************************************************/\n            /* Below code looks to see if it has received a signal 30 from the user. */\n            /* This is to see if the user has made a change to the rules file. The   */\n            /* program will reread the rules file and start processing again.        */\n            /*************************************************************************/\n            total_BWRC_threads = 0;\n            free_BWRC_th_mem_index = 0;\n            num_rules_defined = 0;\n            signal_flag = 'N';\n            rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);\n            if ( rc != 0 ) {\n                sprintf(msg, \"Check the HTXERR log for error information on rule file reading.\\n\");\n                user_msg(&data, 0, 0, HARD, msg);\n                return (-1);\n            }\n        }\n        sprintf(msg, \"Pass #%d, rule file %s completed.\\nCollision count = %d.\", read_rules_file_count,\n                dev_info.rules_file_name, collisions);\n        user_msg(&data, 0, 0, INFO, msg);\n        HTX_STATS_UPDATE (FINISH, &data);\n        read_rules_file_count++;\n    } while ((strcmp(data.run_type, \"REG\") == 0) && (exit_flag == 0) && (int_signal_flag == 'N'));\n\n    /****************************************************/\n    /** Set the exit flag and wait for any BWRC thread **/\n    /** if  running                                    **/\n    /****************************************************/\n    exit_flag = 1;\n#ifdef __CAPI_FLASH__\n    /* Wait for the thread (i.e. the thread for which open_flag was set) to close the LUN. */\n    while (shared_lun_id != NULL_CHUNK_ID) {\n        sleep(5);\n    }\n#endif\n    while (BWRC_threads_running != 0 && wait_count > 0) {\n        sleep(5);\n        wait_count--;\n    }\n\n    /********************************************/\n    /*****      Cleanup threads memory      *****/\n    /********************************************/\n\n    if (BWRC_threads_running != 0) {\n        sprintf(msg, \"Going to cleanup memory. Since some BWRC threads are still running, ignore if any core is generated.\");\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n    cleanup_threads_mem();\n    munmap(mmap_ptr, MMAP_FILE_SIZE);\n\n    /* If enable_state_table flag is YES, SYNC the state table (i.e. update metadata on disk) */\n    if (enable_state_table == YES) {\n        rc = sync_state_table(&data, data.sdev_id);\n        if (rc) {\n\t\t\tsprintf(msg, \"Failed to update state table.\\n\");\n            user_msg(&data, 0, 0, INFO, msg);\n        }\n    }\n\n    pthread_attr_destroy(&thread_attrs_detached);\n    return rc;\n}", "item_id": 0, "repo": "narasimhan-v/HTX", "file": "bin/hxestorage/hxestorage.c", "last_update_at": "2019-07-23T01:31:45+00:00", "question_id": "b48634e4e333214f2dc5941348a151a45796761c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[])\n{\n    int i, err_no, rule_no, rc = 0;\n    int wait_count = DEFAULT_WAIT_COUNT, skip_flag;\n    char *kdblevel = NULL, *eeh_env = NULL, *ptr = NULL;\n    struct ruleinfo *current_ruleptr;\n    char msg[MAX_TEXT_MSG], script_path[64], cmd_str[128];\n    struct thread_context *current_tctx;\n    char file_name[128];\n    struct sigaction sigvector, sigdata;\n    static sigset_t  sigmask;\n    /****************************************/\n    /**     Register Signal handlers        */\n    /****************************************/\n    sigemptyset((&sigvector.sa_mask)); /* empty the mask */\n    sigvector.sa_flags = 0;\n    sigvector.sa_handler = (void (*)(int)) SIGTERM_hdl;\n    sigaction(SIGTERM, &sigvector, (struct sigaction *) NULL); /* set signal handler for SIGTERM */\n    sigprocmask(0, NULL, &sigmask); /* get current signal mask     */\n    sigdata.sa_flags = SA_RESTART; /* restart on signal calls     */\n    sigdata.sa_mask = sigmask;  /* set the signal mask */\n    sigdata.sa_handler = (void(*)(int))sig_function;\n    sigaction(SIGUSR1, &sigdata, NULL); /* call when recv sig 30 */\n    sigdata.sa_handler = (void(*)(int))int_sig_function;\n    sigaction(SIGINT, &sigdata, NULL); /* set signal handler for SIGINT */\n    /*********************************************/\n    /** Initialize thread attributes and mutex  **/\n    /*********************************************/\n    pthread_attr_init(&thread_attrs_detached);\n    pthread_attr_setdetachstate(&thread_attrs_detached, PTHREAD_CREATE_DETACHED);\n    pthread_mutex_init(&thread_create_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&cache_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&fencepost_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&stats_mutex, DEFAULT_MUTEX_ATTR_PTR);\n    pthread_mutex_init(&dump_mutex, DEFAULT_MUTEX_ATTR_PTR);\n#ifndef __HTX_LINUX__\n    pthread_mutex_init(&log_mutex, DEFAULT_MUTEX_ATTR_PTR);\n#endif\n    pthread_cond_init(&create_thread_cond_var, DEFAULT_COND_ATTR_PTR);\n    pthread_cond_init(&do_oper_cond_var, DEFAULT_COND_ATTR_PTR);\n    pthread_cond_init(&threads_finished_cond_var, DEFAULT_COND_ATTR_PTR);\n    bzero(&dev_info, sizeof(dev_info));\n    dev_info.cont_on_misc = UNINITIALIZED;\n    /************************************************/\n    /*******   Read command line arguments    *******/\n    /************************************************/\n    memset(&data, 0, sizeof(struct htx_data));\n    strcpy(data.HE_name, argv[0]);\n    strcpy(data.sdev_id, argv[1]);\n    strcpy(dev_info.dev_name, argv[1]);\n    strcpy(data.run_type, argv[2]);\n    strcpy(dev_info.rules_file_name, argv[3]);\n    hxfupdate(START, &data);\n    sprintf(msg, \"%s %s %s %s \\n\", data.HE_name, data.sdev_id, data.run_type, dev_info.rules_file_name);\n    user_msg(&data, 0, 0, INFO, msg);\n    /* globla_htx_d will be used by stats thread. So, this need to be updated\n     * from data.\n     */\n     memcpy(&global_htx_d, &data, sizeof(struct htx_data));\n    /*************************************************************************/\n    /* Sanity check:                                                         */\n    /* Before we open the device, check to see if it is a member of a volume */\n    /* group which is currently defined in the ODM.  This check prevents     */\n    /* accidentally clobbering a disk which was added to a volume group      */\n    /* after logging on as htx.                                              */\n    /* If check_disk returns < 0, then the device is OK to exercise.         */\n    /*************************************************************************/\n    ptr = getenv(\"HTXSCRIPTS\");\n    if (ptr != NULL) {\n\t\tstrcpy(script_path, ptr);\n    } else {\n        sprintf(msg, \"HTX env. is not set. Hence exiting.\\nPlease setup the env. and re-run the test\");\n        user_msg(&data, 0, 0, INFO, msg);\n        exit(1);\n    }\n#ifndef __HTX_LINUX__\n    if ( (rc = check_disk(data.sdev_id, msg, sizeof(msg))) == 0) {\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(126);\n    } else if (rc > 0 ) {\n        sprintf(msg, \"ODM or LVM error in check_disk, rc = %d\\n%s\", rc, msg);\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(1);\n    }\n#else\n    sprintf(cmd_str, \"%scheck_disk %s\", script_path, data.sdev_id);\n    rc = system(cmd_str);\n    if (WIFEXITED(rc)) {\n        if (WEXITSTATUS(rc) == 1) {\n            sprintf(msg, \"Disk either has partitions OR is used by the system. So, can not run exerciser on it. Hence exiting.\");\n            user_msg(&data, 0, 0, INFO, msg);\n            exit(1);\n        }\n    } else {\n        sprintf(msg, \"command did not completed properly. Hence exiting.\");\n        user_msg(&data, 0, 0, INFO, msg);\n        exit(1);\n    }\n#endif\n    /****************************************************/\n    /****** Get hostname for machine running code *******/\n    /****************************************************/\n    rc = gethostname(dev_info.hostname, 16);\n    if ( rc != 0 ) {\n        sprintf(msg, \"Unable to get hostname for this run!, errno = %d \\n\", errno);\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n    /*****************************************************/\n    /******* Get HTXKDBLEVEL and EEH env. variable *******/\n    /*****************************************************/\n    dev_info.crash_on_miscom = 1;\n    kdblevel = getenv(\"HTXKDBLEVEL\");\n    if (kdblevel != NULL) {\n        if (!(atoi(kdblevel))) {\n            dev_info.crash_on_miscom = 0;\n        }\n    }\n    eeh_env = getenv(\"HTXEEH\");\n    if (eeh_env != NULL) {\n        if (atoi(eeh_env)) {\n            ptr = getenv(\"HTXEEHRETRIES\");\n            if (ptr != NULL) {\n                eeh_retries = atoi(getenv(\"HTXEEHRETRIES\"));\n\t\t\t}\n        } else if((strcmp(data.run_type, \"REG\") == 0) && data.p_shm_HE->cont_on_err) {\n            /* If User specifies COE in mdt file, then need to make sure all\n             * read/write call are successfull. If we see ocassional error, retry.\n             */\n            eeh_retries = DEFAULT_EEH_RETRIES;\n        }\n    }\n    /* Create mmaped dump file */\n    sprintf (file_name, \"%s/IO_details_dump.log\", data.htx_exer_log_dir);\n    mmap_fd = open (file_name, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n    if (mmap_fd == -1) {\n        sprintf(msg, \"Could not open the dump file. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    if (lseek (mmap_fd, MMAP_FILE_SIZE, SEEK_SET) == -1) {\n        perror(\"lseek\");\n    }\n    rc = write(mmap_fd, \"\", 1);\n    close(mmap_fd);\n    mmap_fd = open (file_name, O_RDWR);\n    if (mmap_fd == -1) {\n        sprintf(msg, \"Could not open the dump file. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    /* Do the mmap of the file */\n    mmap_ptr = (char *) mmap( NULL, MMAP_FILE_SIZE, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, mmap_fd, 0);\n    if (mmap_ptr == (void *) -1) {\n        sprintf(msg, \"mmap failed. errno: %d\\n\", errno);\n        user_msg(&data, 0, 0, HARD, msg);\n    }\n    close(mmap_fd);\n    if (strcmp(data.run_type, \"REG\") == 0){\n        /* time_driven_htx read the time_interval_for_run from the shm header */\n        time_interval_for_run = get_exec_time_value_from_shm_hdr(&data);\n        sprintf(msg,\"debug_msg6 from FPU, exec_time = %d \\n\",time_interval_for_run);\n        hxfmsg (&data, 0, INFO, msg);\n    }\n    /****************************************************************************/\n\t/*   For CAPI flash, Device given as input is of format /dev/rhdisk[0-1]*.N */\n    /*   on AIX and sd[a-z][a-z]*.N on Linux. Actual device would be            */\n    /*   /dev/rhdisk[0-1] OR /dev/sd[a-z][a-z, 0-1]* and our invocation count   */\n    /*   would be N. Extract device name from argv[1]                           */\n\t/****************************************************************************/\n#ifdef __CAPI_FLASH__\n\tchar file[128] = \"/tmp/test_lun_mode\";\n    FILE * fp ;\n\tuint32_t num_instance = 0;\n\tchar buf[128];\n    char device[MAX_STR_SZ], intance[MAX_STR_SZ], input_dev[MAX_STR_SZ], temp[MAX_STR_SZ];\n    int str_len, indx=0;\n    strcpy(input_dev, basename(data.sdev_id));\n    str_len = strlen(input_dev);\n\trc = cblk_init(NULL, 0);\n\tif (rc != 0) {\n       sprintf(msg, \"cblk_init returned error. rc: %d.\", rc);\n       user_msg(&data, 0, 0, HARD, msg);\n       exit(1);\n    }\n    for(i = 0; i <= str_len; i++ ) {\n        temp[indx]=input_dev[i];\n        if(input_dev[i] == '.' ) {\n            strncpy(device, temp, indx);\n            device[indx] = '\\0';\n            indx = 0;\n            memset(temp, 0, MAX_STR_SZ);\n        } else  if (input_dev[i] == '\\0') {\n            strcpy(intance, temp);\n        } else {\n            indx++;\n        }\n    }\n\tif(device[0] == 'r') {\n    \tstrncpy(dev_info.diskname, &device[1], MAX_STR_SZ);\n\t} else {\n\t\tstrncpy(dev_info.diskname, &device[0], MAX_STR_SZ);\n\t}\n\tsprintf(capi_device,\"/dev/%s\",&device[0]);\n    printf(\"input_dev=%s, device=%s, intance=%s, capi_device=%s \\n\", input_dev, device, intance, capi_device);\n    fflush(stdout);\n\trc = access(file, F_OK);\n    if(rc == -1 ) {\n    #ifdef __HTX_LINUX__\n        /* In case of Linux, if file does not exist, we run in VLUN mode.\n         * Hence, setting the params for VLUN mode.\n         */\n        lun_type = CBLK_OPN_VIRT_LUN;\n        dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;\n        dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n    #else\n        /* In case of AIX, if file does not exist, means we are testing in Legacy mode.\n         * hxestorage should run on this device instead of hxesurelock. Hence, exiting.\n         */\n\t\tsprintf(msg, \"File: %s, doesnot exists!! this exerciser should not have been envoked. \\n\", file);\n\t\tuser_msg(&data, 0, 0, HARD, msg);\n\t\treturn(rc);\n    #endif\n\t} else {\n        /************************************************/\n\t    /* Get content of file : \"/tmp/test_lun_mode\"   */\n\t    /************************************************/\n\t    sprintf(cmd_str, \"cat %s\", file);\n        fp = popen(cmd_str, \"r\");\n        if (fp == NULL) {\n            sprintf(msg, \"popen failed while reading file=%s with errno=%d. Setting Virtual LUN mode. \\n\", file, errno);\n            user_msg(&data, 0, 0, INFO, msg);\n\t    \tnum_instance = 2;\n        } else {\n            if (fgets(buf, 128, fp) == NULL) {\n                sprintf(msg, \"fgets failed while reading from file = %s, errno=%d. Setting Virtual LUN mode. \\n \\n\", file, errno);\n                user_msg(&data, 0, 0, INFO, msg);\n                pclose(fp);\n\t    \t\tnum_instance = 2;\n            } else {\n                pclose(fp);\n                num_instance = atoi(buf);\n            }\n        }\n\t    if(num_instance == 1) {\n\t    \t/***********************************************************/\n            /* File exists with value=1, we are testing PLUNs. We can  */\n            /* query IOCINFO on PLUNs for total blocks and block size. */\n            /***********************************************************/\n            lun_type            = CBLK_OPN_PHY_LUN;\n        #ifndef __HTX_LINUX__\n            rc = get_disk_info(&data, capi_device);\n            if ( rc != 0) {\n                exit(1);\n            }\n            /****************************************************/\n            /* For PLUN chunk_size is same as num blocks on disk*/\n            /****************************************************/\n            chunk_size = dev_info.maxblk + 1;\n        #else\n            chunk_id_t chunk_id = NULL_CHUNK_ID;\n        #ifdef __HTX_LINUX__\n            chunk_attrs_t attr;\n        #endif\n            chunk_id = cblk_open(capi_device, MAX_THREADS, O_RDWR, 0, 0);\n            if(chunk_id == NULL_CHUNK_ID) {\n                sprintf(msg, \"main : Cannot get a valid chunk_id, capi_device = %s, errno = %d \\n\", capi_device, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n\t        }\n            rc = cblk_get_lun_size(chunk_id, (unsigned long *)&dev_info.maxblk, 0);\n            if(rc ) {\n                sprintf(msg, \"cblk_get_size failed with rc = %d, errno = %d \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                return(1);\n            }\n        #ifdef __HTX_LINUX__\n            rc = cblk_get_attrs (chunk_id, &attr, 0);\n            if (rc) {\n                sprintf(msg, \"cblk_get_attrs failed with rc = %d, errno = %x \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n            }\n            if (attr.flags1 & CFLSH_ATTR_UNMAP) {\n                discard_enabled = 1;\n            }\n        #endif\n            rc = cblk_close(chunk_id, CBLK_SCRUB_DATA_FLG);\n            if(rc) {\n                sprintf(msg, \"cblk_close failed with rc = %d, errno = %x \\n\", rc, errno);\n                user_msg(&data, errno, 0, HARD, msg);\n                exit(1);\n            }\n            chunk_id = NULL_CHUNK_ID;\n            /****************************************************/\n            /* For PLUN chunk_size is same as num blocks on disk*/\n            /****************************************************/\n            chunk_size = dev_info.maxblk;\n            dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n        #endif\n\t    } else {\n            if (num_instance == 0) {\n            #ifdef __HTX_LINUX__\n                 /* in case of LInux, If value in file is 0, means we are testing VLUN */\n                dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;\n                dev_info.blksize = (unsigned int)VLUN_BLKSIZE;\n                lun_type = CBLK_OPN_VIRT_LUN;\n            #else\n                /* In case of AIX, value 0 means, we need to run in LEGACY mode. So error out */\n                sprintf(msg, \"File: %s, exists but value = %d, this exerciser should not have been envoked. \\n\", file, num_instance);\n                user_msg(&data, 0, 0, HARD, msg);\n                return(rc);\n            #endif\n            } else {\n                /********************************************************/\n\t            /* File exists with value > 1, we are testing VLUNS.    */\n\t    \t    /* VLUNs have capability to dynamically change size.    */\n\t    \t    /* So user request for it through chunk_size rules parm.*/\n\t    \t    /********************************************************/\n\t \t        dev_info.maxblk \t= (unsigned long long)VLUN_TOTALBLOCKS;\n\t            dev_info.blksize \t= (unsigned int)VLUN_BLKSIZE;\n\t\t        lun_type \t\t\t= CBLK_OPN_VIRT_LUN;\n\t        }\n        }\n    }\n#else\n    /***************************************************/\n    /****   Get disk info using IOCINFO ioctl.      ****/\n    /****   This will update maxblk and blksize.    ****/\n    /***************************************************/\n    rc = get_disk_info(&data, data.sdev_id);\n    if ( rc != 0) {\n        exit(1);\n    }\n#endif\n    /***************************************************/\n    /********           Read rule file          ********/\n    /***************************************************/\n    rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);\n    if (rc != 0) {\n        sprintf(msg, \"Check HTXERR log for a listing of errors with rule file reading!\\n\");\n        user_msg(&data, 0, 0, HARD, msg);\n        exit(1);\n    }\n    segment_table_init();\n    /* time_driven_htx */\n    /* if we provide a value for time_interval_for_run along with cmdline as arg then only we need to populate these variables */\n    if (time_interval_for_run > 0){\n        /* provide total no. of stanzas present */\n        total_no_of_stanzas_present = num_rules_defined;\n        if (total_BWRC_threads > 0) {\n            if (rule_list[1].oper[0][0] == 'S' || rule_list[1].oper[0][0] == 's') {\n                time_interval_for_run -= (rule_list[1].sleep / 1000000);\n            }\n            time_interval_for_stanza_switch_tmp = time_interval_for_run / (total_no_of_stanzas_present - 2);\n        } else {\n            time_interval_for_stanza_switch_tmp = time_interval_for_run/total_no_of_stanzas_present;\n        }\n        /* provide the reference to exit_flag */\n        time_diff_struct.exit_flag = &exit_flag;\n    }\n    /* if run_on_misc is set to YES and misc_run_cmd is null. {Populate the default script to run*/\n    if (run_on_misc == 'Y' && strcmp(misc_run_cmd, \"\") == 0) {\n        sprintf(misc_run_cmd, \"%s/storage_miscom_pre_kdb_script\", script_path);\n    }\n    time_mark = time(0); /* set time mark for comparison */\n    if (enable_state_table == YES) {\n        rc = initialize_state_table(&data, data.sdev_id);\n        if (rc == -1) {\n\t\t\texit(1);\n\t    }\n    }\n#ifdef __HTX_LINUX__\n    /* Check if write cahce is enabled if sync_cache is set to yes in any\n     * of the rule. This will set dev_info.write_cache to 1 if enabled,\n     * otherwise 0.\n     */\n    dev_info.write_cache = 0;\n    if (sync_cache_flag == 1) {\n        dev_info.write_cache = check_write_cache (&data);\n        /* Create a separate thread to issue CACHE_SYNC ioctl at regular interval */\n        if (dev_info.write_cache == 1 && randomize_sync_cache == 1) {\n            rc = pthread_create(&sync_cache_th, &thread_attrs_detached, (void *(*)(void *))sync_cache_thread, (void *)(&data));\n            if (rc != 0) {\n                sprintf(msg, \"pthread_create failed for sync_cache threas. errno. set is: %d\\n\", rc);\n                user_msg(&data, rc, 0, HARD, msg);\n                exit(1);\n\t\t    }\n        } else if (dev_info.write_cache == 0) {\n            sprintf(msg, \"Write cache is is not enabled. Will not run sync_cache thread.\");\n            user_msg(&data, 0, 0, INFO, msg);\n        }\n        sprintf(msg, \"write cache is : %d\\n\", dev_info.write_cache);\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n#endif\n    /*****************************************************************/\n    /* Allocate memory for BWRC threads. Since lifetime of BWRC      */\n    /* threads can span across multiple stanzas. So, we pre-allocate */\n    /* memory for all BWRC threads defined in various stanzas in the */\n    /* rulefile. Information of BWRC threads of various stanzas once */\n    /* updated here will be maintained till end of the exerciser.    */\n    /*****************************************************************/\n    if (total_BWRC_threads != 0) {\n        BWRC_threads_mem = (struct thread_context *) malloc(total_BWRC_threads * sizeof(struct thread_context));\n        if (BWRC_threads_mem == NULL) {\n            err_no = errno;\n            sprintf(msg, \"malloc failed(with errno: %d) while allocating memory for BWRC thread context.\\n\", errno);\n            user_msg(&data, err_no, 0, HARD, msg);\n            exit(1);\n        }\n        initialize_threads(BWRC_threads_mem, total_BWRC_threads);\n        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {\n            current_ruleptr = &rule_list[rule_no];\n            if (current_ruleptr->num_BWRC_threads == 0) {\n                continue;\n            } else {\n                populate_BWRC_thread_context(&data, current_ruleptr, BWRC_threads_mem);\n            }\n        }\n    }\n    /*********************************************************************/\n    /****** run hang_monitor thread to keep a check of any HUNG IO  ******/\n    /*********************************************************************/\n    rc = pthread_create(&(hang_monitor_thread), &thread_attrs_detached, (void *(*)(void *))hang_monitor, (void *)(&data));\n    if (rc != 0) {\n        sprintf(msg, \"pthread_create failed for hang_monitor thread. errno set is: %d\\n\", rc);\n        user_msg(&data, rc, 0, HARD, msg);\n        /* Free BWRC memory also if allocated */\n        if (BWRC_threads_mem != NULL) {\n            free (BWRC_threads_mem);\n            BWRC_threads_mem = NULL;\n        }\n        exit(1);\n    }\n    /*******************************************************/\n    /******     Create stats updation thread         *******/\n    /*******************************************************/\n    rc = pthread_create(&stats_update_th, &thread_attrs_detached, (void *(*)(void *))stats_update_thread, NULL);\n    if (rc != 0) {\n        sprintf(msg, \"pthread_create failed for stats update thread. errno set is: %d\\n\", rc);\n        user_msg(&data, rc, 0, HARD, msg);\n        /* Free BWRC memory also if allocated */\n        if (BWRC_threads_mem != NULL) {\n            free (BWRC_threads_mem);\n            BWRC_threads_mem = NULL;\n        }\n        exit(1);\n    }\n    /******************************************************/\n    /*******    Start processing of stanza          *******/\n    /******************************************************/\n    read_rules_file_count = 1;\n    do {\n        current_ruleptr = &rule_list[0];\n        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {\n            /* DPRINT(\"%s:%d - Running stanza: %d\\n\", __FUNCTION__, __LINE__, rule_no + 1); */\n            data.test_id = rule_no + 1;\n            HTX_STATS_UPDATE (UPDATE , &data);\n            skip_flag = 0;\n            /******************************************************************/\n            /***    Check rule parameter to see if need to skip this stanza ***/\n            /******************************************************************/\n            if ( current_ruleptr->repeat_pos > 0 ) {\n                if ((read_rules_file_count == 1)                                ||\n                    ((read_rules_file_count % current_ruleptr->repeat_pos) !=0) ||\n                    ((current_ruleptr->repeat_pos == 1)                         &&\n                    (!(read_rules_file_count & 1)))\n                )  {\n                    skip_flag = 1;\n                }\n            } else if ( current_ruleptr->repeat_neg > 0 ) {\n                if (((read_rules_file_count != 1)                                   &&\n                    ((read_rules_file_count % current_ruleptr->repeat_neg) != 0))   ||\n                    ((current_ruleptr->repeat_neg == 1)                             &&\n                    (!(read_rules_file_count & 1))                                  &&\n                    (read_rules_file_count != 1))) {\n                    skip_flag = 1;\n                }\n            }\n            /****************************************************/\n            /**  If not skipping the stanza, run the testcase  **/\n            /****************************************************/\n            if (skip_flag != 1) {\n                if (current_ruleptr->oper[0][0] == 'S' || current_ruleptr->oper[0][0] == 's') {\n                    usleep(current_ruleptr->sleep);\n                } else if (strcasecmp(current_ruleptr->oper[0], \"XCMD\") == 0) {\n                    rc = run_cmd(&data, current_ruleptr->cmd_list);\n                } else {\n                    /************************************************************************/\n                    /****           Allocate memory for non BWRC threads context        *****/\n                    /************************************************************************/\n                    num_non_BWRC_threads = current_ruleptr->num_threads - current_ruleptr->num_BWRC_threads;\n                    if (num_non_BWRC_threads) {\n                        non_BWRC_threads_mem = (struct thread_context *) malloc (num_non_BWRC_threads * sizeof(struct thread_context));\n                        if (non_BWRC_threads_mem == NULL) {\n                            err_no = errno;\n                            sprintf(msg, \"malloc failed(with errno: %d) while allocating memory for thread context.\\n\", errno);\n                            user_msg(&data, err_no, 0, HARD, msg);\n                            /* Free BWRC memory also if allocated */\n                            if (BWRC_threads_mem != NULL) {\n                                free (BWRC_threads_mem);\n                                BWRC_threads_mem = NULL;\n                            }\n                            exit(1);\n                        }\n                        initialize_threads(non_BWRC_threads_mem, num_non_BWRC_threads);\n                        /**********************************************/\n                        /* Populate thread context for all non BWRC   */\n                        /* threads defined in current stanza.         */\n                        /**********************************************/\n                        rc = populate_thread_context(&data, current_ruleptr, BWRC_threads_mem, non_BWRC_threads_mem);\n                    }\n                    /**************************************************************/\n                    /*** Spawn threads to execute testcase. First, BWRC threads ***/\n                    /*** will be created for current stanza, if defined any.    ***/\n                    /*** After that, non BWRC threads will be created.          ***/\n                    /**************************************************************/\n                    rc = pthread_mutex_lock(&thread_create_mutex);\n                    if (rc) {\n                        sprintf(msg, \"Mutex lock failed in MAIN, rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(1);\n                    }\n                    for (i = 0; i < current_ruleptr->num_BWRC_threads; i++) {\n                        current_tctx = &(BWRC_threads_mem[current_ruleptr->BWRC_th_mem_index + i]);\n                        /* Need to check if current BWRC thread status is 'F' (i.e. Finished), then only\n                         * need to create the thread. Otherwise, skip it.\n                         */\n                        if (lba_fencepost[current_tctx->fencepost_index].status == 'F') {\n                            rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,\n                                            (void *(*)(void *)) execute_thread_context, (void *) current_tctx);\n                            if (rc) {\n                                sprintf(msg, \"rc %d, errno %d from main(): pthread_create for BWRC threads no: %d\",\n                                        rc, errno, i);\n                                user_msg(&data, rc, 0, HARD, msg);\n                                exit(rc);\n                            }\n                            rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);\n                            if (rc) {\n                                sprintf(msg, \"Cond wait failed in MAIN for BWRC thread, rc = %d\\n\", rc);\n                                user_msg(&data, rc, 0, HARD, msg);\n                                exit(rc);\n                            }\n                            BWRC_threads_running++;\n                        } else {\n                            continue;\n                        }\n                    }\n                    for (i=0; i < num_non_BWRC_threads; i++) {\n                        current_tctx = &(non_BWRC_threads_mem[i]);\n                        current_tctx->th_num = i;\n                        rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,\n                                    (void *(*)(void *)) execute_thread_context, (void *) current_tctx);\n                        if (rc) {\n                            sprintf(msg, \"rc %d, errno %d from main(): pthread_create\", rc,errno);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                        rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);\n                        if (rc) {\n                            sprintf(msg, \"Cond wait failed in MAIN, rc = %d\\n\", rc);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                        non_BWRC_threads_running++;\n                    }\n                    /**********************************************************************/\n                    /******      Send broadcast to all threads to start executing   *******/\n                    /**********************************************************************/\n                    rc = pthread_cond_broadcast(&do_oper_cond_var);\n                    if ( rc ) {\n                        sprintf(msg,\"pthread_cond_broadcast failed for do_oper_cond_var. rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(1);\n                    }\n                    /*************************************************************/\n                    /****   wait for threads to finish if non BWRC stanza   ******/\n                    /*************************************************************/\n                    if (current_ruleptr->is_only_BWRC_stanza == 'N') {\n                        rc = pthread_cond_wait(&threads_finished_cond_var, &thread_create_mutex);\n                        if (rc) {\n                            sprintf(msg, \"Cond wait failed in MAIN for threads_finished condition variable.rc = %d\\n\", rc);\n                            user_msg(&data, rc, 0, HARD, msg);\n                            exit(rc);\n                        }\n                    }\n                    rc = pthread_mutex_unlock(&thread_create_mutex);\n                    if (rc) {\n                        sprintf(msg, \"Mutex unlock failed in MAIN, rc = %d\\n\", rc);\n                        user_msg(&data, rc, 0, HARD, msg);\n                        exit(rc);\n                    }\n                    /***********************************************************/\n                    /********       Clean up thread context memory      ********/\n                    /***********************************************************/\n                    if (non_BWRC_threads_mem != NULL) {\n                        free(non_BWRC_threads_mem);\n                        non_BWRC_threads_mem = NULL;\n                    }\n                }\n            } else {\n                sprintf(msg, \"Rule %s Has Been SKIPPED......\\n\", current_ruleptr->rule_id);\n                user_msg(&data, 0, 0, INFO, msg);\n            }\n            current_ruleptr++;\n            if (exit_flag == 1 || int_signal_flag == 'Y' || signal_flag == 'Y') {\n                break;\n            }\n            /* DPRINT(\"%s:%d - Completed stanza: %d\\n\", __FUNCTION__, __LINE__, rule_no + 1); */\n            /* time_driven_htx switches stanza with the given interval by setting time_out_flag as 0 */\n            if (time_interval_for_run > 0) {\n                rc = pthread_mutex_lock(&mutex_for_time_driven_exec);\n                if (rc) {\n                    sprintf(msg, \"Mutex lock failed in MAIN for time_driven_exec, rc = %d\\n\", rc);\n                    user_msg(&data, rc, 0, HARD, msg);\n\t\t\t    }\n\t\t\t    (time_diff_struct.time_out_flag) = 0;\n                rc = pthread_mutex_unlock(&mutex_for_time_driven_exec);\n                if (rc) {\n                    sprintf(msg, \"Mutex unlock failed in MAIN for time_driven_exec, rc = %d\\n\", rc);\n                    user_msg(&data, rc, 0, HARD, msg);\n\t\t\t    }\n\t\t    }\n        } /* End rule_no < num_rules_defined for loop */\n        if (signal_flag == 'Y') {\n\t\t\t/*************************************************************************/\n            /* Below code looks to see if it has received a signal 30 from the user. */\n            /* This is to see if the user has made a change to the rules file. The   */\n            /* program will reread the rules file and start processing again.        */\n            /*************************************************************************/\n            total_BWRC_threads = 0;\n            free_BWRC_th_mem_index = 0;\n            num_rules_defined = 0;\n            signal_flag = 'N';\n            rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);\n            if ( rc != 0 ) {\n                sprintf(msg, \"Check the HTXERR log for error information on rule file reading.\\n\");\n                user_msg(&data, 0, 0, HARD, msg);\n                return (-1);\n            }\n        }\n        sprintf(msg, \"Pass #%d, rule file %s completed.\\nCollision count = %d.\", read_rules_file_count,\n                dev_info.rules_file_name, collisions);\n        user_msg(&data, 0, 0, INFO, msg);\n        HTX_STATS_UPDATE (FINISH, &data);\n        read_rules_file_count++;\n    } while ((strcmp(data.run_type, \"REG\") == 0) && (exit_flag == 0) && (int_signal_flag == 'N'));\n    /****************************************************/\n    /** Set the exit flag and wait for any BWRC thread **/\n    /** if  running                                    **/\n    /****************************************************/\n    exit_flag = 1;\n#ifdef __CAPI_FLASH__\n    /* Wait for the thread (i.e. the thread for which open_flag was set) to close the LUN. */\n    while (shared_lun_id != NULL_CHUNK_ID) {\n        sleep(5);\n    }\n#endif\n    while (BWRC_threads_running != 0 && wait_count > 0) {\n        sleep(5);\n        wait_count--;\n    }\n    /********************************************/\n    /*****      Cleanup threads memory      *****/\n    /********************************************/\n    if (BWRC_threads_running != 0) {\n        sprintf(msg, \"Going to cleanup memory. Since some BWRC threads are still running, ignore if any core is generated.\");\n        user_msg(&data, 0, 0, INFO, msg);\n    }\n    cleanup_threads_mem();\n    munmap(mmap_ptr, MMAP_FILE_SIZE);\n    /* If enable_state_table flag is YES, SYNC the state table (i.e. update metadata on disk) */\n    if (enable_state_table == YES) {\n        rc = sync_state_table(&data, data.sdev_id);\n        if (rc) {\n\t\t\tsprintf(msg, \"Failed to update state table.\\n\");\n            user_msg(&data, 0, 0, INFO, msg);\n        }\n    }\n    pthread_attr_destroy(&thread_attrs_detached);\n    return rc;\n"]], "pred": {"ppl": 2.570172071456909, "ppl_lower": 2.9596681594848633, "ppl/lowercase_ppl": -1.1494791965133206, "ppl/zlib": 0.00012453467685225614, "Min_5.0% Prob": 7.383486102609074, "Min_10.0% Prob": 5.884718506943946, "Min_20.0% Prob": 4.07546985558435, "Min_30.0% Prob": 3.004473088808309, "Min_40.0% Prob": 2.3212960176989617, "Min_50.0% Prob": 1.8791079067583187, "Min_60.0% Prob": 1.5728796605282078}}
{"hexsha": "d02a1300d8fb957d58f96a0df4fc3f5b3404aab1", "ext": "c", "lang": "C", "content": "void histogram_imager_load_image_file(HistogramImager *self, const gchar *filename) {\n  /* Try to open the given PNG file and load parameters from it */\n  const gchar *params;\n  GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n  params = gdk_pixbuf_get_option(pixbuf, \"tEXt::de_jong_params\");\n  if (params)\n    parameter_holder_load_string(PARAMETER_HOLDER(self), params);\n  else\n    printf(\"No parameters chunk found\\n\");\n  gdk_pixbuf_unref(pixbuf);\n}", "item_id": 7, "repo": "AlexRogalskiy/DevArtifacts", "file": "master/de-jong-explorer-0.5/de-jong-explorer-0.5/src/histogram-imager.c", "last_update_at": "2019-03-27T09:48:12+00:00", "question_id": "d02a1300d8fb957d58f96a0df4fc3f5b3404aab1_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void histogram_imager_load_image_file(HistogramImager *self, const gchar *filename) {\n  /* Try to open the given PNG file and load parameters from it */\n  const gchar *params;\n  GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n  params = gdk_pixbuf_get_option(pixbuf, \"tEXt::de_jong_params\");\n  if (params)\n    parameter_holder_load_string(PARAMETER_HOLDER(self), params);\n  else\n    printf(\"No parameters chunk found\\n\");\n  gdk_pixbuf_unref(pixbuf);\n"]], "pred": {"ppl": 3.906106948852539, "ppl_lower": 4.889042377471924, "ppl/lowercase_ppl": -1.164732807084686, "ppl/zlib": 0.004780846360485109, "Min_5.0% Prob": 9.529279112815857, "Min_10.0% Prob": 7.6693732037263755, "Min_20.0% Prob": 5.513160207692315, "Min_30.0% Prob": 4.176940123240153, "Min_40.0% Prob": 3.286694206621336, "Min_50.0% Prob": 2.701626097220321, "Min_60.0% Prob": 2.2789785357788928}}
{"hexsha": "33177571d03d16ea93eaf58ac9719c2e84824e55", "ext": "c", "lang": "C", "content": "int proxyfs_remount(mount_handle_t* in_mount_handle)\n{\n    // Get context and set the method\n    jsonrpc_context_t* ctx = jsonrpc_open(in_mount_handle->rpc_handle, \"RpcMountByVolumeName\");\n\n    // Set the params based on what was passed in\n    jsonrpc_set_req_param_str(   ctx, ptable[VOL_NAME],      in_mount_handle->volume_name);\n    jsonrpc_set_req_param_int(   ctx, ptable[MOUNT_OPTS],    in_mount_handle->mount_options);\n    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_USER_ID],  in_mount_handle->auth_user_id);\n    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_GROUP_ID], in_mount_handle->auth_group_id);\n\n    // Call RPC\n    int rsp_status = jsonrpc_exec_request_blocking(ctx);\n    if (rsp_status == 0) {\n        // Success; Set the return values (assuming .mount_id_as_str decodes)\n        in_mount_handle->mount_id_as_str    = strdup(jsonrpc_get_resp_str(ctx, ptable[MOUNT_ID]));\n        in_mount_handle->root_dir_inode_num = jsonrpc_get_resp_uint64(ctx, ptable[ROOT_DIR_INODE_NUM]);\n\n        rsp_status = proxyfs_decode_mount_id(in_mount_handle);\n        if (rsp_status != 0) {\n            handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);\n        }\n    } else {\n        handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);\n    }\n\n    // Clean up jsonrpc context and return\n    jsonrpc_close(ctx);\n    return rsp_status;\n}", "item_id": 22, "repo": "NVIDIA/proxyfs-jrpc-client", "file": "proxyfs_api.c", "last_update_at": "2019-11-04T19:38:45+00:00", "question_id": "33177571d03d16ea93eaf58ac9719c2e84824e55_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int proxyfs_remount(mount_handle_t* in_mount_handle)\n{\n    // Get context and set the method\n    jsonrpc_context_t* ctx = jsonrpc_open(in_mount_handle->rpc_handle, \"RpcMountByVolumeName\");\n    // Set the params based on what was passed in\n    jsonrpc_set_req_param_str(   ctx, ptable[VOL_NAME],      in_mount_handle->volume_name);\n    jsonrpc_set_req_param_int(   ctx, ptable[MOUNT_OPTS],    in_mount_handle->mount_options);\n    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_USER_ID],  in_mount_handle->auth_user_id);\n    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_GROUP_ID], in_mount_handle->auth_group_id);\n    // Call RPC\n    int rsp_status = jsonrpc_exec_request_blocking(ctx);\n    if (rsp_status == 0) {\n        // Success; Set the return values (assuming .mount_id_as_str decodes)\n        in_mount_handle->mount_id_as_str    = strdup(jsonrpc_get_resp_str(ctx, ptable[MOUNT_ID]));\n        in_mount_handle->root_dir_inode_num = jsonrpc_get_resp_uint64(ctx, ptable[ROOT_DIR_INODE_NUM]);\n        rsp_status = proxyfs_decode_mount_id(in_mount_handle);\n        if (rsp_status != 0) {\n            handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);\n        }\n    } else {\n        handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);\n    }\n    // Clean up jsonrpc context and return\n    jsonrpc_close(ctx);\n    return rsp_status;\n"]], "pred": {"ppl": 2.481435537338257, "ppl_lower": 2.63197922706604, "ppl/lowercase_ppl": -1.0648068543840972, "ppl/zlib": 0.0016645370666872707, "Min_5.0% Prob": 8.065596466064454, "Min_10.0% Prob": 6.0855468628453275, "Min_20.0% Prob": 4.037626749160243, "Min_30.0% Prob": 2.9520981302058775, "Min_40.0% Prob": 2.254654139134942, "Min_50.0% Prob": 1.8167066190653713, "Min_60.0% Prob": 1.517684442761691}}
{"hexsha": "69e269675d6766ae4fe4f41cb547caedf2a43141", "ext": "c", "lang": "C", "content": "static void itc_systemio_gpio_get_edge_mode_n_after_close(void)\n{\n\tint ret;\n\tg_gpio_h = NULL;\n\tiotbus_gpio_edge_e set_edge = IOTBUS_GPIO_EDGE_NONE;\n\tiotbus_gpio_edge_e get_edge;\n\n\tg_gpio_h = iotbus_gpio_open(GPIO_PIN);\n\tTC_ASSERT_NEQ(\"iotbus_gpio_open\", g_gpio_h, NULL);\n\n\tret = iotbus_gpio_set_edge_mode(g_gpio_h, set_edge);\n\tTC_ASSERT_EQ_CLEANUP(\"iotbus_gpio_set_edge_mode\", ret, 0, iotbus_gpio_close(g_gpio_h));\n\n\tret = iotbus_gpio_close(g_gpio_h);\n\tTC_ASSERT_EQ(\"iotbus_gpio_close\", ret, 0);\n\n\tret = iotbus_gpio_get_edge_mode(g_gpio_h, &get_edge);\n\tTC_ASSERT_LT(\"iotbus_gpio_get_edge_mode\", ret, 0);\n\n\tTC_SUCCESS_RESULT();\n}", "item_id": 29, "repo": "Taejun-Kwon/TizenRT", "file": "apps/examples/testcase/ta_tc/systemio/itc/itc_gpio.c", "last_update_at": "2019-01-27T14:51:05+00:00", "question_id": "69e269675d6766ae4fe4f41cb547caedf2a43141_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void itc_systemio_gpio_get_edge_mode_n_after_close(void)\n{\n\tint ret;\n\tg_gpio_h = NULL;\n\tiotbus_gpio_edge_e set_edge = IOTBUS_GPIO_EDGE_NONE;\n\tiotbus_gpio_edge_e get_edge;\n\tg_gpio_h = iotbus_gpio_open(GPIO_PIN);\n\tTC_ASSERT_NEQ(\"iotbus_gpio_open\", g_gpio_h, NULL);\n\tret = iotbus_gpio_set_edge_mode(g_gpio_h, set_edge);\n\tTC_ASSERT_EQ_CLEANUP(\"iotbus_gpio_set_edge_mode\", ret, 0, iotbus_gpio_close(g_gpio_h));\n\tret = iotbus_gpio_close(g_gpio_h);\n\tTC_ASSERT_EQ(\"iotbus_gpio_close\", ret, 0);\n\tret = iotbus_gpio_get_edge_mode(g_gpio_h, &get_edge);\n\tTC_ASSERT_LT(\"iotbus_gpio_get_edge_mode\", ret, 0);\n\tTC_SUCCESS_RESULT();\n"]], "pred": {"ppl": 1.5908066034317017, "ppl_lower": 1.8522608280181885, "ppl/lowercase_ppl": -1.327773109354607, "ppl/zlib": 0.0017719129212058098, "Min_5.0% Prob": 6.509862571954727, "Min_10.0% Prob": 4.20510483533144, "Min_20.0% Prob": 2.3017749630487883, "Min_30.0% Prob": 1.552454621264977, "Min_40.0% Prob": 1.1648812379389433, "Min_50.0% Prob": 0.9310289603606912, "Min_60.0% Prob": 0.7752216950222628}}
{"hexsha": "6c2eedd7fa27b9f27318868be83200fa5632e18b", "ext": "c", "lang": "C", "content": "void donotification(char *msg, int length) {\n  unsigned char ec = *(unsigned char *)(msg + 0);\n  unsigned char esc = *(unsigned char *)(msg + 1);\n  fprintf(stderr, \"BGP Notification: error code = %d, error subcode = %d\\n\", ec, esc);\n}", "item_id": 13, "repo": "hdb3/kakapo", "file": "core/session.c", "last_update_at": "2019-03-29T16:02:05+00:00", "question_id": "6c2eedd7fa27b9f27318868be83200fa5632e18b_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void donotification(char *msg, int length) {\n  unsigned char ec = *(unsigned char *)(msg + 0);\n  unsigned char esc = *(unsigned char *)(msg + 1);\n  fprintf(stderr, \"BGP Notification: error code = %d, error subcode = %d\\n\", ec, esc);\n"]], "pred": {"ppl": 4.654880523681641, "ppl_lower": 4.714130401611328, "ppl/lowercase_ppl": -1.0082242597006537, "ppl/zlib": 0.010533672905245496, "Min_5.0% Prob": 9.599700212478638, "Min_10.0% Prob": 7.8343625664711, "Min_20.0% Prob": 5.909465491771698, "Min_30.0% Prob": 4.497103174527486, "Min_40.0% Prob": 3.636265631765127, "Min_50.0% Prob": 3.016901331394911, "Min_60.0% Prob": 2.573465616752704}}
{"hexsha": "855b99ce87c0ca0245f2043bba86c355dc76de5b", "ext": "c", "lang": "C", "content": "void test_decline_timeout(void **state)\n{\n    (void)state;\n\n    kaa_log_collector_t *log_collector = NULL;\n    kaa_error_t error_code = kaa_log_collector_create(&log_collector, status, channel_manager, logger);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    kaa_user_log_record_t *test_log_record = kaa_test_log_record_create();\n    test_log_record->data = kaa_string_copy_create(TEST_LOG_BUFFER);\n    size_t test_log_record_size = test_log_record->get_size(test_log_record);\n\n    mock_strategy_context_t strategy;\n    memset(&strategy, 0, sizeof(mock_strategy_context_t));\n    strategy.timeout = TEST_TIMEOUT;\n    strategy.decision = NOOP;\n    strategy.max_parallel_uploads = UINT32_MAX;\n\n    mock_storage_context_t *storage = create_mock_storage();\n    ASSERT_NOT_NULL(storage);\n\n    kaa_log_bucket_constraints_t constraints = {\n        .max_bucket_size = 2 * test_log_record_size,\n        .max_bucket_log_count = UINT32_MAX,\n    };\n\n    error_code = kaa_logging_init(log_collector, storage, &strategy, &constraints);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    size_t request_buffer_size = 256;\n    uint8_t request_buffer[request_buffer_size];\n    kaa_platform_message_writer_t *writer = NULL;\n    error_code = kaa_platform_message_writer_create(&writer, request_buffer, request_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    error_code = kaa_logging_request_serialize(log_collector, writer);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    sleep(TEST_TIMEOUT + 1);\n\n    uint16_t bucket_id = *((uint16_t *)(request_buffer + KAA_EXTENSION_HEADER_SIZE));\n    bucket_id = KAA_NTOHS(bucket_id);\n\n    uint32_t response_count = 1;\n    size_t response_buffer_size = sizeof(uint32_t) + sizeof(uint32_t) * response_count;\n    uint8_t response_buffer[response_buffer_size];\n\n    uint8_t *response = response_buffer;\n    *((uint32_t *)response) = KAA_HTONL(response_count);\n    response += sizeof(uint32_t);\n\n    /* First response */\n    *((uint16_t *)response) = KAA_HTONS(bucket_id);\n    response += sizeof(uint16_t);\n    *((uint8_t *)response) = 0x0; // SUCCESS\n    response += sizeof(uint8_t);\n    *((uint8_t *)response) = 0;\n    response += sizeof(uint8_t);\n\n    kaa_platform_message_reader_t *reader = NULL;\n    error_code = kaa_platform_message_reader_create(&reader, response_buffer, response_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    ASSERT_NOT_NULL(reader);\n\n    error_code = kaa_logging_handle_server_sync(log_collector, reader, 0, response_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    ASSERT_TRUE(storage->on_remove_by_id_count);\n\n    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n\n    ASSERT_FALSE(strategy.on_timeout_count);\n\n    test_log_record->destroy(test_log_record);\n    kaa_platform_message_writer_destroy(writer);\n    kaa_platform_message_reader_destroy(reader);\n    kaa_log_collector_destroy(log_collector);\n}", "item_id": 19, "repo": "Donny3000/auto-gardern-kaa", "file": "flowerbed-ep/kaa/src/extensions/logging/test/test_kaa_log.c", "last_update_at": "2019-08-30T06:21:04+00:00", "question_id": "855b99ce87c0ca0245f2043bba86c355dc76de5b_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_decline_timeout(void **state)\n{\n    (void)state;\n    kaa_log_collector_t *log_collector = NULL;\n    kaa_error_t error_code = kaa_log_collector_create(&log_collector, status, channel_manager, logger);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    kaa_user_log_record_t *test_log_record = kaa_test_log_record_create();\n    test_log_record->data = kaa_string_copy_create(TEST_LOG_BUFFER);\n    size_t test_log_record_size = test_log_record->get_size(test_log_record);\n    mock_strategy_context_t strategy;\n    memset(&strategy, 0, sizeof(mock_strategy_context_t));\n    strategy.timeout = TEST_TIMEOUT;\n    strategy.decision = NOOP;\n    strategy.max_parallel_uploads = UINT32_MAX;\n    mock_storage_context_t *storage = create_mock_storage();\n    ASSERT_NOT_NULL(storage);\n    kaa_log_bucket_constraints_t constraints = {\n        .max_bucket_size = 2 * test_log_record_size,\n        .max_bucket_log_count = UINT32_MAX,\n    };\n    error_code = kaa_logging_init(log_collector, storage, &strategy, &constraints);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    size_t request_buffer_size = 256;\n    uint8_t request_buffer[request_buffer_size];\n    kaa_platform_message_writer_t *writer = NULL;\n    error_code = kaa_platform_message_writer_create(&writer, request_buffer, request_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    error_code = kaa_logging_request_serialize(log_collector, writer);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    sleep(TEST_TIMEOUT + 1);\n    uint16_t bucket_id = *((uint16_t *)(request_buffer + KAA_EXTENSION_HEADER_SIZE));\n    bucket_id = KAA_NTOHS(bucket_id);\n    uint32_t response_count = 1;\n    size_t response_buffer_size = sizeof(uint32_t) + sizeof(uint32_t) * response_count;\n    uint8_t response_buffer[response_buffer_size];\n    uint8_t *response = response_buffer;\n    *((uint32_t *)response) = KAA_HTONL(response_count);\n    response += sizeof(uint32_t);\n    /* First response */\n    *((uint16_t *)response) = KAA_HTONS(bucket_id);\n    response += sizeof(uint16_t);\n    *((uint8_t *)response) = 0x0; // SUCCESS\n    response += sizeof(uint8_t);\n    *((uint8_t *)response) = 0;\n    response += sizeof(uint8_t);\n    kaa_platform_message_reader_t *reader = NULL;\n    error_code = kaa_platform_message_reader_create(&reader, response_buffer, response_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    ASSERT_NOT_NULL(reader);\n    error_code = kaa_logging_handle_server_sync(log_collector, reader, 0, response_buffer_size);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    ASSERT_TRUE(storage->on_remove_by_id_count);\n    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);\n    ASSERT_EQUAL(error_code, KAA_ERR_NONE);\n    ASSERT_FALSE(strategy.on_timeout_count);\n    test_log_record->destroy(test_log_record);\n    kaa_platform_message_writer_destroy(writer);\n    kaa_platform_message_reader_destroy(reader);\n    kaa_log_collector_destroy(log_collector);\n"]], "pred": {"ppl": 1.6074893474578857, "ppl_lower": 1.7597442865371704, "ppl/lowercase_ppl": -1.1906467220657408, "ppl/zlib": 0.0005412469217011065, "Min_5.0% Prob": 4.885228512333889, "Min_10.0% Prob": 3.577839109243131, "Min_20.0% Prob": 2.216127221198643, "Min_30.0% Prob": 1.5604922738583649, "Min_40.0% Prob": 1.1821489976741792, "Min_50.0% Prob": 0.9491611488168938, "Min_60.0% Prob": 0.7919373398595057}}
{"hexsha": "a27cd784ab01ffb5fea45300fe9957933503af15", "ext": "c", "lang": "C", "content": "JNICALL Java_org_lwjgl_system_JNI_callPPPP__JJ_3IJ(JNIEnv *__env, jclass clazz, jlong param0, jlong param1, jintArray param2, jlong __functionAddress) {\n    UNUSED_PARAMS(__env, clazz)\n    void *paramArray2 = param2 == NULL ? NULL : (*__env)->GetIntArrayElements(__env, param2, NULL);\n    jlong __result = (jlong)((intptr_t (APIENTRY *) (intptr_t, intptr_t, intptr_t))(intptr_t)__functionAddress)((intptr_t)param0, (intptr_t)param1, (intptr_t)paramArray2);\n    if (param2 != NULL) { (*__env)->ReleaseIntArrayElements(__env, param2, paramArray2, 0); }\n    return __result;\n}", "item_id": 188, "repo": "Mu-L/lwjgl3", "file": "modules/lwjgl/core/src/generated/c/org_lwjgl_system_JNI.c", "last_update_at": "2019-12-25T05:04:54+00:00", "question_id": "a27cd784ab01ffb5fea45300fe9957933503af15_188", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL Java_org_lwjgl_system_JNI_callPPPP__JJ_3IJ(JNIEnv *__env, jclass clazz, jlong param0, jlong param1, jintArray param2, jlong __functionAddress) {\n    UNUSED_PARAMS(__env, clazz)\n    void *paramArray2 = param2 == NULL ? NULL : (*__env)->GetIntArrayElements(__env, param2, NULL);\n    jlong __result = (jlong)((intptr_t (APIENTRY *) (intptr_t, intptr_t, intptr_t))(intptr_t)__functionAddress)((intptr_t)param0, (intptr_t)param1, (intptr_t)paramArray2);\n    if (param2 != NULL) { (*__env)->ReleaseIntArrayElements(__env, param2, paramArray2, 0); }\n    return __result;\n"]], "pred": {"ppl": 2.173191785812378, "ppl_lower": 4.27570915222168, "ppl/lowercase_ppl": -1.871883110474562, "ppl/zlib": 0.0026046877715503966, "Min_5.0% Prob": 6.528379223563454, "Min_10.0% Prob": 5.34245100888339, "Min_20.0% Prob": 3.570620732837253, "Min_30.0% Prob": 2.5647296618614623, "Min_40.0% Prob": 1.93535049032006, "Min_50.0% Prob": 1.5580967244043546, "Min_60.0% Prob": 1.2933648808255653}}
{"hexsha": "2d76f86d1254b861af7d45410586ecf3bb82a365", "ext": "c", "lang": "C", "content": "void playSample(uint8_t chNum, uint8_t insNum, uint8_t smpNum, uint8_t note, uint16_t midiVibDepth, uint16_t midiPitch)\n{\n\tif (instr[insNum] == NULL)\n\t\treturn;\n\n\t// for sampling playback line in Smp. Ed.\n\tlastChInstr[chNum].instrNum = 255;\n\tlastChInstr[chNum].smpNum = 255;\n\teditor.curPlayInstr = 255;\n\teditor.curPlaySmp = 255;\n\n\tassert(chNum < MAX_CHANNELS && insNum <= MAX_INST && smpNum < MAX_SMP_PER_INST && note <= NOTE_OFF);\n\tchannel_t *ch = &channel[chNum];\n\n\tmemcpy(&instr[130]->smp[0], &instr[insNum]->smp[smpNum], sizeof (sample_t));\n\n\tuint8_t vol = instr[insNum]->smp[smpNum].volume;\n\t\n\tlockAudio();\n\n\tch->instrNum = 130;\n\tch->noteData = (ch->instrNum << 8) | note;\n\tch->efx = 0;\n\n\tstartTone(note, 0, 0, ch);\n\n\tif (note != NOTE_OFF)\n\t{\n\t\tretrigVolume(ch);\n\t\tretrigEnvelopeVibrato(ch);\n\n\t\tch->realVol = vol;\n\t\tch->outVol = vol;\n\t\tch->oldVol = vol;\n\t}\n\n\tch->midiVibDepth = midiVibDepth;\n\tch->midiPitch = midiPitch;\n\n\tupdateChannel(ch);\n\n\tunlockAudio();\n\n\twhile (ch->status & IS_Trigger); // wait for sample to latch in mixer\n\n\t// for sampling playback line in Smp. Ed.\n\teditor.curPlayInstr = editor.curInstr;\n\teditor.curPlaySmp = editor.curSmp;\n}", "item_id": 77, "repo": "OPNA2608/ft2-clone", "file": "src/ft2_replayer.c", "last_update_at": "2019-12-02T11:42:39+00:00", "question_id": "2d76f86d1254b861af7d45410586ecf3bb82a365_77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void playSample(uint8_t chNum, uint8_t insNum, uint8_t smpNum, uint8_t note, uint16_t midiVibDepth, uint16_t midiPitch)\n{\n\tif (instr[insNum] == NULL)\n\t\treturn;\n\t// for sampling playback line in Smp. Ed.\n\tlastChInstr[chNum].instrNum = 255;\n\tlastChInstr[chNum].smpNum = 255;\n\teditor.curPlayInstr = 255;\n\teditor.curPlaySmp = 255;\n\tassert(chNum < MAX_CHANNELS && insNum <= MAX_INST && smpNum < MAX_SMP_PER_INST && note <= NOTE_OFF);\n\tchannel_t *ch = &channel[chNum];\n\tmemcpy(&instr[130]->smp[0], &instr[insNum]->smp[smpNum], sizeof (sample_t));\n\tuint8_t vol = instr[insNum]->smp[smpNum].volume;\n\t\n\tlockAudio();\n\tch->instrNum = 130;\n\tch->noteData = (ch->instrNum << 8) | note;\n\tch->efx = 0;\n\tstartTone(note, 0, 0, ch);\n\tif (note != NOTE_OFF)\n\t{\n\t\tretrigVolume(ch);\n\t\tretrigEnvelopeVibrato(ch);\n\t\tch->realVol = vol;\n\t\tch->outVol = vol;\n\t\tch->oldVol = vol;\n\t}\n\tch->midiVibDepth = midiVibDepth;\n\tch->midiPitch = midiPitch;\n\tupdateChannel(ch);\n\tunlockAudio();\n\twhile (ch->status & IS_Trigger); // wait for sample to latch in mixer\n\t// for sampling playback line in Smp. Ed.\n\teditor.curPlayInstr = editor.curInstr;\n\teditor.curPlaySmp = editor.curSmp;\n"]], "pred": {"ppl": 2.958955764770508, "ppl_lower": 3.5609958171844482, "ppl/lowercase_ppl": -1.170720489901735, "ppl/zlib": 0.0019832475757249977, "Min_5.0% Prob": 8.282387751799364, "Min_10.0% Prob": 6.51154761944177, "Min_20.0% Prob": 4.480491359278841, "Min_30.0% Prob": 3.355874849190502, "Min_40.0% Prob": 2.6308772265911102, "Min_50.0% Prob": 2.1501674593279234, "Min_60.0% Prob": 1.8069922635828066}}
{"hexsha": "d76f5378066d01d133baead66e76e740bdf15776", "ext": "c", "lang": "C", "content": "static\nCMR_ERROR updateHashtable(\n  CMR* cmr,                         /**< \\ref CMR environment. */\n  DenseBinaryMatrix* dense,         /**< Matrix. */\n  ElementData* majorData,           /**< Major index data. */\n  size_t* processedMajors,          /**< Array of processed major indices. */\n  size_t numProcessedMajors,        /**< Number of processed major indices. */\n  CMR_LISTHASHTABLE* majorHashtable /**< Major index hashtable. */\n)\n{\n  assert(cmr);\n  assert(dense);\n  assert(majorData);\n  assert(processedMajors);\n  assert(majorHashtable);\n\n  CMRdbgMsg(8, \"Updating row/column hashtable.\\n\");\n\n  /* Add missing hashtable entries. */\n  for (size_t i = 0; i < numProcessedMajors; i++)\n  {\n    size_t major = processedMajors[i];\n    if (majorData[major].hashEntry == SIZE_MAX)\n    {\n      CMR_CALL( CMRlisthashtableInsert(cmr, majorHashtable, majorData[major].hashValue, major,\n        &majorData[major].hashEntry) );\n    }\n  }\n\n  return CMR_OKAY;\n}", "item_id": 3, "repo": "discopt/cmr", "file": "src/cmr/regular_nested_minor_sequence.c", "last_update_at": "2019-06-26T11:56:31+00:00", "question_id": "d76f5378066d01d133baead66e76e740bdf15776_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nCMR_ERROR updateHashtable(\n  CMR* cmr,                         /**< \\ref CMR environment. */\n  DenseBinaryMatrix* dense,         /**< Matrix. */\n  ElementData* majorData,           /**< Major index data. */\n  size_t* processedMajors,          /**< Array of processed major indices. */\n  size_t numProcessedMajors,        /**< Number of processed major indices. */\n  CMR_LISTHASHTABLE* majorHashtable /**< Major index hashtable. */\n)\n{\n  assert(cmr);\n  assert(dense);\n  assert(majorData);\n  assert(processedMajors);\n  assert(majorHashtable);\n  CMRdbgMsg(8, \"Updating row/column hashtable.\\n\");\n  /* Add missing hashtable entries. */\n  for (size_t i = 0; i < numProcessedMajors; i++)\n  {\n    size_t major = processedMajors[i];\n    if (majorData[major].hashEntry == SIZE_MAX)\n    {\n      CMR_CALL( CMRlisthashtableInsert(cmr, majorHashtable, majorData[major].hashValue, major,\n        &majorData[major].hashEntry) );\n    }\n  }\n  return CMR_OKAY;\n"]], "pred": {"ppl": 2.1498968601226807, "ppl_lower": 3.014096975326538, "ppl/lowercase_ppl": -1.441431454026717, "ppl/zlib": 0.001796760255758014, "Min_5.0% Prob": 7.1132972240448, "Min_10.0% Prob": 5.425555164163763, "Min_20.0% Prob": 3.480533281058976, "Min_30.0% Prob": 2.4952808356646337, "Min_40.0% Prob": 1.9021424866820638, "Min_50.0% Prob": 1.532544613501663, "Min_60.0% Prob": 1.2801164659184765}}
{"hexsha": "9acb263511e009facaffe836fa87a52cc6f866db", "ext": "c", "lang": "C", "content": "static int r_perfective_gerund(struct SN_env * z) { /* backwardmode */\n    int among_var;\n    z->ket = z->c; /* [, line 74 */\n    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((25166336 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; /* substring, line 74 */\n    among_var = find_among_b(z, a_0, 9);\n    if (!(among_var)) return 0;\n    z->bra = z->c; /* ], line 74 */\n    switch (among_var) { /* among, line 74 */\n        case 1:\n            {   int m1 = z->l - z->c; (void)m1; /* or, line 78 */\n                if (z->c <= z->lb || z->p[z->c - 1] != 0xC1) goto lab1; /* literal, line 78 */\n                z->c--;\n                goto lab0;\n            lab1:\n                z->c = z->l - m1;\n                if (z->c <= z->lb || z->p[z->c - 1] != 0xD1) return 0; /* literal, line 78 */\n                z->c--;\n            }\n        lab0:\n            {   int ret = slice_del(z); /* delete, line 78 */\n                if (ret < 0) return ret;\n            }\n            break;\n        case 2:\n            {   int ret = slice_del(z); /* delete, line 85 */\n                if (ret < 0) return ret;\n            }\n            break;\n    }\n    return 1;\n}", "item_id": 2, "repo": "QwantResearch/qtokenizer", "file": "externals/snowball/src_c/stem_KOI8_R_russian.c", "last_update_at": "2019-04-08T18:53:15+00:00", "question_id": "9acb263511e009facaffe836fa87a52cc6f866db_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int r_perfective_gerund(struct SN_env * z) { /* backwardmode */\n    int among_var;\n    z->ket = z->c; /* [, line 74 */\n    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((25166336 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; /* substring, line 74 */\n    among_var = find_among_b(z, a_0, 9);\n    if (!(among_var)) return 0;\n    z->bra = z->c; /* ], line 74 */\n    switch (among_var) { /* among, line 74 */\n        case 1:\n            {   int m1 = z->l - z->c; (void)m1; /* or, line 78 */\n                if (z->c <= z->lb || z->p[z->c - 1] != 0xC1) goto lab1; /* literal, line 78 */\n                z->c--;\n                goto lab0;\n            lab1:\n                z->c = z->l - m1;\n                if (z->c <= z->lb || z->p[z->c - 1] != 0xD1) return 0; /* literal, line 78 */\n                z->c--;\n            }\n        lab0:\n            {   int ret = slice_del(z); /* delete, line 78 */\n                if (ret < 0) return ret;\n            }\n            break;\n        case 2:\n            {   int ret = slice_del(z); /* delete, line 85 */\n                if (ret < 0) return ret;\n            }\n            break;\n    }\n    return 1;\n"]], "pred": {"ppl": 1.3987407684326172, "ppl_lower": 1.4734954833984375, "ppl/lowercase_ppl": -1.1551530465690172, "ppl/zlib": 0.0008495503310196864, "Min_5.0% Prob": 4.397485567175823, "Min_10.0% Prob": 3.0186755890431614, "Min_20.0% Prob": 1.666899516125736, "Min_30.0% Prob": 1.11956298898946, "Min_40.0% Prob": 0.8404744274828219, "Min_50.0% Prob": 0.6725517936064811, "Min_60.0% Prob": 0.5604899184897965}}
{"hexsha": "a00be21688dd01a5ad8ddcfe80930cfa4d79bf57", "ext": "c", "lang": "C", "content": "int handle_fwPath0(netsnmp_mib_handler *handler,\n\n\t\t\t\t\t\t  netsnmp_handler_registration *reginfo,\n                          netsnmp_agent_request_info   *reqinfo,\n                          netsnmp_request_info         *requests)\n\n{\n    /* We are never called for a GETNEXT if it's registered as a\n       \"instance\", as it's \"magically\" handled for us.  */\n\n    /* a instance handler also only hands us one request at a time, so\n       we don't need to loop over a list of requests; we'll only get one. */\n\n\t\t\tFILE *in;\n\t\t\textern FILE *popen();\n\t\t\tchar fwPath0[512];\n\t\t\tchar contextName[32];\n\t\t\tchar command[512];\n\n\t\t\tif (reqinfo->asp->orig_pdu->contextNameLen > 31) {\n\t\t\t    \t\t         printf(\"ERROR: too long contextName\");\n\t\t\t    \t\t         exit(1);\n\n\t\t\t}\n\n\t\t\tmemset(contextName, 0, 32);\n\t\t\tmemcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);\n\t\t\tmemset(command, 0, 512);\n\t\t\tsnprintf(command, 512, \"ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath0\", contextName);\n\n\t\t\tif(!(in = popen(command, \"r\"))){\n\n\t\t\texit(1);\n\t\t\t   }\n\n\t\t\twhile(fgets(fwPath0, sizeof(fwPath0), in)!=NULL){\n\t\t\t       printf(\"%s\", fwPath0);\n\t\t\t}\n\t\t\tpclose(in);\n\n\tswitch(reqinfo->mode) {\n\n        case MODE_GET:\n//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,\n            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,\n\t\t\t\t    (u_char *) &fwPath0,\n\t\t\t            sizeof( fwPath0 ) );\n            break;\n\n\n        default:\n            /* we should never get here, so this is a really bad error */\n            snmp_log(LOG_ERR, \"unknown mode (%d) in handle_fwPath0\\n\", reqinfo->mode );\n            return SNMP_ERR_GENERR;\n    }\n\n    return SNMP_ERR_NOERROR;\n}", "item_id": 216, "repo": "marcieloliveira/snmp-gateway-ccn", "file": "snmp-agent/ccnMIB.c", "last_update_at": "2019-08-10T20:00:48+00:00", "question_id": "a00be21688dd01a5ad8ddcfe80930cfa4d79bf57_216", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int handle_fwPath0(netsnmp_mib_handler *handler,\n\t\t\t\t\t\t  netsnmp_handler_registration *reginfo,\n                          netsnmp_agent_request_info   *reqinfo,\n                          netsnmp_request_info         *requests)\n{\n    /* We are never called for a GETNEXT if it's registered as a\n       \"instance\", as it's \"magically\" handled for us.  */\n    /* a instance handler also only hands us one request at a time, so\n       we don't need to loop over a list of requests; we'll only get one. */\n\t\t\tFILE *in;\n\t\t\textern FILE *popen();\n\t\t\tchar fwPath0[512];\n\t\t\tchar contextName[32];\n\t\t\tchar command[512];\n\t\t\tif (reqinfo->asp->orig_pdu->contextNameLen > 31) {\n\t\t\t    \t\t         printf(\"ERROR: too long contextName\");\n\t\t\t    \t\t         exit(1);\n\t\t\t}\n\t\t\tmemset(contextName, 0, 32);\n\t\t\tmemcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);\n\t\t\tmemset(command, 0, 512);\n\t\t\tsnprintf(command, 512, \"ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath0\", contextName);\n\t\t\tif(!(in = popen(command, \"r\"))){\n\t\t\texit(1);\n\t\t\t   }\n\t\t\twhile(fgets(fwPath0, sizeof(fwPath0), in)!=NULL){\n\t\t\t       printf(\"%s\", fwPath0);\n\t\t\t}\n\t\t\tpclose(in);\n\tswitch(reqinfo->mode) {\n        case MODE_GET:\n//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,\n            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,\n\t\t\t\t    (u_char *) &fwPath0,\n\t\t\t            sizeof( fwPath0 ) );\n            break;\n        default:\n            /* we should never get here, so this is a really bad error */\n            snmp_log(LOG_ERR, \"unknown mode (%d) in handle_fwPath0\\n\", reqinfo->mode );\n            return SNMP_ERR_GENERR;\n    }\n    return SNMP_ERR_NOERROR;\n"]], "pred": {"ppl": 2.042227029800415, "ppl_lower": 2.518864154815674, "ppl/lowercase_ppl": -1.2937747345754043, "ppl/zlib": 0.000901566784949694, "Min_5.0% Prob": 7.866720950964726, "Min_10.0% Prob": 5.489786299792203, "Min_20.0% Prob": 3.329885106785853, "Min_30.0% Prob": 2.3349366445637227, "Min_40.0% Prob": 1.7724951091677623, "Min_50.0% Prob": 1.4263805030082095, "Min_60.0% Prob": 1.189105492309296}}
{"hexsha": "eac64358d5b743672d9c4a2b4a095ff8d51370fa", "ext": "c", "lang": "C", "content": "static int i2ctool_dump(FAR struct i2ctool_s *i2ctool, int fd,\n                        uint8_t regaddr, FAR uint8_t *buf, int nbytes)\n{\n  struct i2c_msg_s msg[2];\n  int ret;\n\n  /* Set up data structures */\n\n  if (i2ctool->hasregindx)\n    {\n      msg[0].frequency = i2ctool->freq;\n      msg[0].addr      = i2ctool->addr;\n      msg[0].flags     = I2C_M_NOSTOP;\n      msg[0].buffer    = &regaddr;\n      msg[0].length    = 1;\n\n      msg[1].frequency = i2ctool->freq;\n      msg[1].addr      = i2ctool->addr;\n      msg[1].flags     = I2C_M_READ;\n\n      msg[1].buffer = buf;\n      msg[1].length = nbytes;\n\n      if (i2ctool->start)\n        {\n          ret = i2cdev_transfer(fd, &msg[0], 1);\n          if (ret == OK)\n            {\n              ret = i2cdev_transfer(fd, &msg[1], 1);\n            }\n        }\n      else\n        {\n          ret = i2cdev_transfer(fd, msg, 2);\n        }\n    }\n  else\n    {\n      /* no register index \"-r\" has been specified so\n       * we do a pure read (no write of index)\n       */\n\n      msg[0].frequency = i2ctool->freq;\n      msg[0].addr      = i2ctool->addr;\n      msg[0].flags     = I2C_M_READ;\n\n      msg[0].buffer = buf;\n      msg[0].length = nbytes;\n\n      ret = i2cdev_transfer(fd, msg, 1);\n    }\n\n  return ret;\n}", "item_id": 0, "repo": "anchao/incubator-nuttx-apps", "file": "system/i2c/i2c_dump.c", "last_update_at": "2019-10-29T07:39:45+00:00", "question_id": "eac64358d5b743672d9c4a2b4a095ff8d51370fa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int i2ctool_dump(FAR struct i2ctool_s *i2ctool, int fd,\n                        uint8_t regaddr, FAR uint8_t *buf, int nbytes)\n{\n  struct i2c_msg_s msg[2];\n  int ret;\n  /* Set up data structures */\n  if (i2ctool->hasregindx)\n    {\n      msg[0].frequency = i2ctool->freq;\n      msg[0].addr      = i2ctool->addr;\n      msg[0].flags     = I2C_M_NOSTOP;\n      msg[0].buffer    = &regaddr;\n      msg[0].length    = 1;\n      msg[1].frequency = i2ctool->freq;\n      msg[1].addr      = i2ctool->addr;\n      msg[1].flags     = I2C_M_READ;\n      msg[1].buffer = buf;\n      msg[1].length = nbytes;\n      if (i2ctool->start)\n        {\n          ret = i2cdev_transfer(fd, &msg[0], 1);\n          if (ret == OK)\n            {\n              ret = i2cdev_transfer(fd, &msg[1], 1);\n            }\n        }\n      else\n        {\n          ret = i2cdev_transfer(fd, msg, 2);\n        }\n    }\n  else\n    {\n      /* no register index \"-r\" has been specified so\n       * we do a pure read (no write of index)\n       */\n      msg[0].frequency = i2ctool->freq;\n      msg[0].addr      = i2ctool->addr;\n      msg[0].flags     = I2C_M_READ;\n      msg[0].buffer = buf;\n      msg[0].length = nbytes;\n      ret = i2cdev_transfer(fd, msg, 1);\n    }\n  return ret;\n"]], "pred": {"ppl": 1.614612340927124, "ppl_lower": 1.73720121383667, "ppl/lowercase_ppl": -1.1527472541614867, "ppl/zlib": 0.0010938239527022774, "Min_5.0% Prob": 6.006701489289601, "Min_10.0% Prob": 4.062607521913489, "Min_20.0% Prob": 2.3396658813110505, "Min_30.0% Prob": 1.5969182991145834, "Min_40.0% Prob": 1.1978294505935274, "Min_50.0% Prob": 0.9575084920938788, "Min_60.0% Prob": 0.7999198124336349}}
{"hexsha": "bf1574e84e13ae3c65c733690732db91eec21954", "ext": "c", "lang": "C", "content": "int v4l2_subdev_get_frame_interval(struct media_entity *entity,\n\t\t\t\t   struct v4l2_fract *interval)\n{\n\tstruct v4l2_subdev_frame_interval ival;\n\tint ret;\n\n\tret = v4l2_subdev_open(entity);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(&ival, 0, sizeof(ival));\n\n\tret = ioctl(entity->fd, VIDIOC_SUBDEV_G_FRAME_INTERVAL, &ival);\n\tif (ret < 0)\n\t\treturn -errno;\n\n\t*interval = ival.interval;\n\treturn 0;\n}", "item_id": 5, "repo": "NovasomIndustries/Utils-2019.01", "file": "rock/external/gstreamer-rockchip-extra/gst/rkv4l2/ext/v4l2subdev.c", "last_update_at": "2019-06-14T07:17:22+00:00", "question_id": "bf1574e84e13ae3c65c733690732db91eec21954_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int v4l2_subdev_get_frame_interval(struct media_entity *entity,\n\t\t\t\t   struct v4l2_fract *interval)\n{\n\tstruct v4l2_subdev_frame_interval ival;\n\tint ret;\n\tret = v4l2_subdev_open(entity);\n\tif (ret < 0)\n\t\treturn ret;\n\tmemset(&ival, 0, sizeof(ival));\n\tret = ioctl(entity->fd, VIDIOC_SUBDEV_G_FRAME_INTERVAL, &ival);\n\tif (ret < 0)\n\t\treturn -errno;\n\t*interval = ival.interval;\n\treturn 0;\n"]], "pred": {"ppl": 1.780996561050415, "ppl_lower": 1.9631422758102417, "ppl/lowercase_ppl": -1.1687073124545053, "ppl/zlib": 0.0024560556314735834, "Min_5.0% Prob": 6.90634149312973, "Min_10.0% Prob": 4.778448834138758, "Min_20.0% Prob": 2.7581514392580306, "Min_30.0% Prob": 1.9084462630298902, "Min_40.0% Prob": 1.4475165232491325, "Min_50.0% Prob": 1.1593183933474709, "Min_60.0% Prob": 0.9651643826743744}}
{"hexsha": "c40a90d02be4a2f1802ceb5064e298a6fb0e0ee3", "ext": "c", "lang": "C", "content": "static void\nget_rw_operations(float      rw_ratio,\n                  int        id,\n                  uint64_t * ops)\n{\n    int i, nr_read = 0, nr_write = 0, start_idx;\n    float idx, write_inc;\n\n    *ops = 0;\n\n    nr_write = (int)(64. * (1. - rw_ratio));\n    write_inc = (float)(64. / nr_write);\n\n    /* seed with local instance's id */\n    srand(VB_BASE_SEED + id);\n    start_idx = rand() % 64;\n\n    for (i = 0; i < nr_write; i++) {\n        idx = (start_idx + (int)(i * write_inc)) % 64;\n        *ops |= (1ULL << (int)idx);\n    }\n}", "item_id": 0, "repo": "TomPlano/varbench", "file": "src/kernels/cache-coherence.c", "last_update_at": "2019-03-14T18:59:50+00:00", "question_id": "c40a90d02be4a2f1802ceb5064e298a6fb0e0ee3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nget_rw_operations(float      rw_ratio,\n                  int        id,\n                  uint64_t * ops)\n{\n    int i, nr_read = 0, nr_write = 0, start_idx;\n    float idx, write_inc;\n    *ops = 0;\n    nr_write = (int)(64. * (1. - rw_ratio));\n    write_inc = (float)(64. / nr_write);\n    /* seed with local instance's id */\n    srand(VB_BASE_SEED + id);\n    start_idx = rand() % 64;\n    for (i = 0; i < nr_write; i++) {\n        idx = (start_idx + (int)(i * write_inc)) % 64;\n        *ops |= (1ULL << (int)idx);\n    }\n"]], "pred": {"ppl": 3.2852702140808105, "ppl_lower": 3.34224271774292, "ppl/lowercase_ppl": -1.0144547180183936, "ppl/zlib": 0.004309597483708966, "Min_5.0% Prob": 8.687244415283203, "Min_10.0% Prob": 7.038995851169933, "Min_20.0% Prob": 4.752772829749367, "Min_30.0% Prob": 3.626702800844655, "Min_40.0% Prob": 2.8753299303352833, "Min_50.0% Prob": 2.3434686070089943, "Min_60.0% Prob": 1.9767796675065405}}
{"hexsha": "16c292bda69912c2d8516b46bcb05fc9b750065d", "ext": "c", "lang": "C", "content": "Node Node_new(NodeFn f, void* arg) {\n  Node node = mem_malloc(sizeof(struct NodeSt));\n  node->run = f;\n  node->arg = arg;\n  return node;\n}", "item_id": 0, "repo": "mori0091/cparsec2", "file": "src/codegen.c", "last_update_at": "2019-07-08T02:20:44+00:00", "question_id": "16c292bda69912c2d8516b46bcb05fc9b750065d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Node Node_new(NodeFn f, void* arg) {\n  Node node = mem_malloc(sizeof(struct NodeSt));\n  node->run = f;\n  node->arg = arg;\n  return node;\n"]], "pred": {"ppl": 5.302894115447998, "ppl_lower": 7.011745452880859, "ppl/lowercase_ppl": -1.1674410168912355, "ppl/zlib": 0.014763298504781594, "Min_5.0% Prob": 11.10561752319336, "Min_10.0% Prob": 9.001354026794434, "Min_20.0% Prob": 6.876486730575562, "Min_30.0% Prob": 5.201910829544067, "Min_40.0% Prob": 4.143431788682937, "Min_50.0% Prob": 3.2845574571536136, "Min_60.0% Prob": 2.7838238131615425}}
{"hexsha": "36e6694d5ea4aca25df136abb8f93fe79b469770", "ext": "h", "lang": "C", "content": "class JSON {\n    public:\n        JSON();\n        void jsonToDocument(string json);\n\n        string serializeNewPlay();\n        string serializeNextIteration();\n        string serializeGraphic();\n        string serializereorder();\n\n        int getRequest();\n        List<string> getObstacles();\n        List<string> getRoute();\n        List<string> getTowers();\n        string obs1();\n        string rute();\n        int getId();\n        int getAge();\n        float getSurvivalProb();\n        int getExpectedGen();\n        int getEmocionalIntelligent();\n        int getUperStrenght();\n        int getLowerStrenght();\n        int getResistance();\n        int getPhysicalCondition();\n        int getTime();\n        int getIteration();\n\n        List<int> getGraphicResistance();\n        List<int> getGraphicUperStrenght();\n        List<int> getGraphicLowerStrenght();\n        List<int> getGraphicEmotionalInt();\n        List<int> getGraphicPhysicalCond();\n        List<int> getGraphicAge();\n        List<float> getGraphicSurvivalProb();\n        List<int> getGraphicExpectedGen();\n        List<int> getGraphicFitness();\n        List<int> getGraphicId();\n}", "item_id": 0, "repo": "tati2327/Gladiators_Project2", "file": "Josue/Interfaz/json.h", "last_update_at": "2019-05-15T06:04:00+00:00", "question_id": "36e6694d5ea4aca25df136abb8f93fe79b469770_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class JSON {\n    public:\n        JSON();\n        void jsonToDocument(string json);\n        string serializeNewPlay();\n        string serializeNextIteration();\n        string serializeGraphic();\n        string serializereorder();\n        int getRequest();\n        List<string> getObstacles();\n        List<string> getRoute();\n        List<string> getTowers();\n        string obs1();\n        string rute();\n        int getId();\n        int getAge();\n        float getSurvivalProb();\n        int getExpectedGen();\n        int getEmocionalIntelligent();\n        int getUperStrenght();\n        int getLowerStrenght();\n        int getResistance();\n        int getPhysicalCondition();\n        int getTime();\n        int getIteration();\n        List<int> getGraphicResistance();\n        List<int> getGraphicUperStrenght();\n        List<int> getGraphicLowerStrenght();\n        List<int> getGraphicEmotionalInt();\n        List<int> getGraphicPhysicalCond();\n        List<int> getGraphicAge();\n        List<float> getGraphicSurvivalProb();\n        List<int> getGraphicExpectedGen();\n        List<int> getGraphicFitness();\n        List<int> getGraphicId();\n"]], "pred": {"ppl": 3.512061595916748, "ppl_lower": 3.9322197437286377, "ppl/lowercase_ppl": -1.0899542933098363, "ppl/zlib": 0.0037723820249841973, "Min_5.0% Prob": 8.60989648103714, "Min_10.0% Prob": 7.2302951365709305, "Min_20.0% Prob": 5.294243577867746, "Min_30.0% Prob": 3.9532518012007487, "Min_40.0% Prob": 3.080527497238891, "Min_50.0% Prob": 2.487065142733447, "Min_60.0% Prob": 2.089889242784264}}
{"hexsha": "e8cfec07614cf63f38dc520ba908a25fc4ddab37", "ext": "h", "lang": "C", "content": "bool ApplyRelocation(uint8_t * base, VpuRelocation * relocation)\n\t{\n\t\tuint32_t * loc = (uint32_t *)(base + relocation->m_fixupOffset);\n\n\t\tif (relocation->m_type == kIMAGE_REL_I386_REL32 || relocation->m_type == kIMAGE_REL_AMD64_REL32)\n\t\t\t*loc = (uint32_t) (relocation->m_referenceOffset - relocation->m_fixupOffset - 4);\n#ifdef _M_IX86\n\t\telse if (relocation.m_type == kIMAGE_REL_I386_DIR32)\n\t\t\t*loc = relocation.m_referenceOffset + (uint32_t)base;\n#endif\n\t\telse\n\t\t\treturn false;\n\t\treturn true;\n\t}", "item_id": 1, "repo": "fengjixuchui/graphics-driver-samples", "file": "compute-only-sample/vpucommon/VpuImage.h", "last_update_at": "2019-04-24T14:27:01+00:00", "question_id": "e8cfec07614cf63f38dc520ba908a25fc4ddab37_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool ApplyRelocation(uint8_t * base, VpuRelocation * relocation)\n\t{\n\t\tuint32_t * loc = (uint32_t *)(base + relocation->m_fixupOffset);\n\t\tif (relocation->m_type == kIMAGE_REL_I386_REL32 || relocation->m_type == kIMAGE_REL_AMD64_REL32)\n\t\t\t*loc = (uint32_t) (relocation->m_referenceOffset - relocation->m_fixupOffset - 4);\n#ifdef _M_IX86\n\t\telse if (relocation.m_type == kIMAGE_REL_I386_DIR32)\n\t\t\t*loc = relocation.m_referenceOffset + (uint32_t)base;\n#endif\n\t\telse\n\t\t\treturn false;\n\t\treturn true;\n"]], "pred": {"ppl": 2.4455926418304443, "ppl_lower": 2.884702205657959, "ppl/lowercase_ppl": -1.1846544800612482, "ppl/zlib": 0.0036651126346393488, "Min_5.0% Prob": 9.579069050875576, "Min_10.0% Prob": 6.612081278454173, "Min_20.0% Prob": 4.02994380262163, "Min_30.0% Prob": 2.9024683886499547, "Min_40.0% Prob": 2.2205357362826663, "Min_50.0% Prob": 1.7828605841944176, "Min_60.0% Prob": 1.495482562199511}}
{"hexsha": "8d311837ca8482ecb955ef32ca01157cff00c0f4", "ext": "c", "lang": "C", "content": "char * clear_number(char *str) {\n  int curr_pos = 0;\n  int curr_pos_ans = 0;\n\n  char *answer = malloc(strlen(str) * sizeof(char));\n\n  while(str[curr_pos] != '\\0') {\n    if (isdigit(str[curr_pos])) {\n      answer[curr_pos_ans] = str[curr_pos];\n      curr_pos_ans++;\n    }\n    curr_pos++;\n  }\n  answer[curr_pos_ans] = '\\0';\n  \n  return answer;\n}", "item_id": 5, "repo": "egormkn/Study-courses", "file": "C & C++/C - 2. Phone book/main.c", "last_update_at": "2019-03-27T18:42:12+00:00", "question_id": "8d311837ca8482ecb955ef32ca01157cff00c0f4_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char * clear_number(char *str) {\n  int curr_pos = 0;\n  int curr_pos_ans = 0;\n  char *answer = malloc(strlen(str) * sizeof(char));\n  while(str[curr_pos] != '\\0') {\n    if (isdigit(str[curr_pos])) {\n      answer[curr_pos_ans] = str[curr_pos];\n      curr_pos_ans++;\n    }\n    curr_pos++;\n  }\n  answer[curr_pos_ans] = '\\0';\n  return answer;\n"]], "pred": {"ppl": 1.9609248638153076, "ppl_lower": 1.9609248638153076, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003848092749946542, "Min_5.0% Prob": 7.944593361445835, "Min_10.0% Prob": 5.150239322866712, "Min_20.0% Prob": 3.1067419392721995, "Min_30.0% Prob": 2.197339693350451, "Min_40.0% Prob": 1.682742074398058, "Min_50.0% Prob": 1.3398510021433023, "Min_60.0% Prob": 1.1224690432276796}}
{"hexsha": "afecc77e3127d2cc6643f625b12c27fbf8673e7a", "ext": "c", "lang": "C", "content": "static boolean\nbrw_layout_3d_cube( struct brw_texture *tex )\n{\n   GLuint width  = tex->b.b.width0;\n   GLuint height = tex->b.b.height0;\n   GLuint depth = tex->b.b.depth0;\n   GLuint pack_x_pitch, pack_x_nr;\n   GLuint pack_y_pitch;\n   GLuint level;\n   GLuint align_h = 2;\n   GLuint align_w = 4;\n\n   tex->total_height = 0;\n   brw_tex_alignment_unit(tex->b.b.format, &align_w, &align_h);\n\n   if (tex->compressed) {\n      tex->pitch = align(width, align_w);\n      pack_y_pitch = (height + 3) / 4;\n   } else {\n      tex->pitch = brw_tex_pitch_align(tex, tex->b.b.width0);\n      pack_y_pitch = align(tex->b.b.height0, align_h);\n   }\n\n   pack_x_pitch = width;\n   pack_x_nr = 1;\n\n   for (level = 0 ; level <= tex->b.b.last_level ; level++) {\n      GLuint nr_images = tex->b.b.target == PIPE_TEXTURE_3D ? depth : 6;\n      GLint x = 0;\n      GLint y = 0;\n      GLint q, j;\n\n      brw_tex_set_level_info(tex, level, nr_images,\n\t\t\t\t   0, tex->total_height,\n\t\t\t\t   width, height, depth);\n\n      for (q = 0; q < nr_images;) {\n\t for (j = 0; j < pack_x_nr && q < nr_images; j++, q++) {\n\t    brw_tex_set_image_offset(tex, level, q, x, y, 0);\n\t    x += pack_x_pitch;\n\t }\n\n\t x = 0;\n\t y += pack_y_pitch;\n      }\n\n\n      tex->total_height += y;\n      width  = u_minify(width, 1);\n      height = u_minify(height, 1);\n      depth  = u_minify(depth, 1);\n\n      if (tex->compressed) {\n\t pack_y_pitch = (height + 3) / 4;\n\n\t if (pack_x_pitch > align(width, align_w)) {\n\t    pack_x_pitch = align(width, align_w);\n\t    pack_x_nr <<= 1;\n\t }\n      } else {\n\t if (pack_x_pitch > 4) {\n\t    pack_x_pitch >>= 1;\n\t    pack_x_nr <<= 1;\n\t    assert(pack_x_pitch * pack_x_nr <= tex->pitch);\n\t }\n\n\t if (pack_y_pitch > 2) {\n\t    pack_y_pitch >>= 1;\n\t    pack_y_pitch = align(pack_y_pitch, align_h);\n\t }\n      }\n   }\n\n   /* The 965's sampler lays cachelines out according to how accesses\n    * in the texture surfaces run, so they may be \"vertical\" through\n    * memory.  As a result, the docs say in Surface Padding Requirements:\n    * Sampling Engine Surfaces that two extra rows of padding are required.\n    */\n   if (tex->b.b.target == PIPE_TEXTURE_CUBE)\n      tex->total_height += 2;\n\n   return TRUE;\n}", "item_id": 4, "repo": "ayoubg/gem5-graphics_v1", "file": "Mesa-7.11.2_GPGPU-Sim/src/gallium/drivers/i965/brw_resource_texture_layout.c", "last_update_at": "2019-01-26T10:34:02+00:00", "question_id": "afecc77e3127d2cc6643f625b12c27fbf8673e7a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static boolean\nbrw_layout_3d_cube( struct brw_texture *tex )\n{\n   GLuint width  = tex->b.b.width0;\n   GLuint height = tex->b.b.height0;\n   GLuint depth = tex->b.b.depth0;\n   GLuint pack_x_pitch, pack_x_nr;\n   GLuint pack_y_pitch;\n   GLuint level;\n   GLuint align_h = 2;\n   GLuint align_w = 4;\n   tex->total_height = 0;\n   brw_tex_alignment_unit(tex->b.b.format, &align_w, &align_h);\n   if (tex->compressed) {\n      tex->pitch = align(width, align_w);\n      pack_y_pitch = (height + 3) / 4;\n   } else {\n      tex->pitch = brw_tex_pitch_align(tex, tex->b.b.width0);\n      pack_y_pitch = align(tex->b.b.height0, align_h);\n   }\n   pack_x_pitch = width;\n   pack_x_nr = 1;\n   for (level = 0 ; level <= tex->b.b.last_level ; level++) {\n      GLuint nr_images = tex->b.b.target == PIPE_TEXTURE_3D ? depth : 6;\n      GLint x = 0;\n      GLint y = 0;\n      GLint q, j;\n      brw_tex_set_level_info(tex, level, nr_images,\n\t\t\t\t   0, tex->total_height,\n\t\t\t\t   width, height, depth);\n      for (q = 0; q < nr_images;) {\n\t for (j = 0; j < pack_x_nr && q < nr_images; j++, q++) {\n\t    brw_tex_set_image_offset(tex, level, q, x, y, 0);\n\t    x += pack_x_pitch;\n\t }\n\t x = 0;\n\t y += pack_y_pitch;\n      }\n      tex->total_height += y;\n      width  = u_minify(width, 1);\n      height = u_minify(height, 1);\n      depth  = u_minify(depth, 1);\n      if (tex->compressed) {\n\t pack_y_pitch = (height + 3) / 4;\n\t if (pack_x_pitch > align(width, align_w)) {\n\t    pack_x_pitch = align(width, align_w);\n\t    pack_x_nr <<= 1;\n\t }\n      } else {\n\t if (pack_x_pitch > 4) {\n\t    pack_x_pitch >>= 1;\n\t    pack_x_nr <<= 1;\n\t    assert(pack_x_pitch * pack_x_nr <= tex->pitch);\n\t }\n\t if (pack_y_pitch > 2) {\n\t    pack_y_pitch >>= 1;\n\t    pack_y_pitch = align(pack_y_pitch, align_h);\n\t }\n      }\n   }\n   /* The 965's sampler lays cachelines out according to how accesses\n    * in the texture surfaces run, so they may be \"vertical\" through\n    * memory.  As a result, the docs say in Surface Padding Requirements:\n    * Sampling Engine Surfaces that two extra rows of padding are required.\n    */\n   if (tex->b.b.target == PIPE_TEXTURE_CUBE)\n      tex->total_height += 2;\n   return TRUE;\n"]], "pred": {"ppl": 2.251098871231079, "ppl_lower": 2.370070219039917, "ppl/lowercase_ppl": -1.0634704530269194, "ppl/zlib": 0.0009931682793242625, "Min_5.0% Prob": 7.162034978037295, "Min_10.0% Prob": 5.35393427777034, "Min_20.0% Prob": 3.593075875292487, "Min_30.0% Prob": 2.6055152141538804, "Min_40.0% Prob": 2.0039728167057036, "Min_50.0% Prob": 1.615534479906564, "Min_60.0% Prob": 1.352213151492775}}
{"hexsha": "5b57636cc8ea797da3ace146e7bd731a30b2af16", "ext": "c", "lang": "C", "content": "void vithist_utt_reset (vithist_t *vh)\n{\n    int32 b;\n    \n    vithist_lmstate_reset (vh);\n    \n    for (b = VITHIST_ID2BLK(vh->n_entry-1); b >= 0; --b) {\n\tckd_free ((void *) vh->entry[b]);\n\tvh->entry[b] = NULL;\n    }\n    vh->n_entry = 0;\n    \n    vh->bestscore[0] = MAX_NEG_INT32;\n    vh->bestvh[0] = -1;\n}", "item_id": 14, "repo": "rhudson2802/sunflower-simulator", "file": "benchmarks/source/superh/ALPBench/Sphinx3/src/vithist.c", "last_update_at": "2019-07-08T03:42:24+00:00", "question_id": "5b57636cc8ea797da3ace146e7bd731a30b2af16_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vithist_utt_reset (vithist_t *vh)\n{\n    int32 b;\n    vithist_lmstate_reset (vh);\n    for (b = VITHIST_ID2BLK(vh->n_entry-1); b >= 0; --b) {\n\tckd_free ((void *) vh->entry[b]);\n\tvh->entry[b] = NULL;\n    }\n    vh->n_entry = 0;\n    vh->bestscore[0] = MAX_NEG_INT32;\n    vh->bestvh[0] = -1;\n"]], "pred": {"ppl": 3.143303632736206, "ppl_lower": 3.577549695968628, "ppl/lowercase_ppl": -1.1129893142173515, "ppl/zlib": 0.005614089995952214, "Min_5.0% Prob": 8.53245097398758, "Min_10.0% Prob": 7.016738444566727, "Min_20.0% Prob": 4.7576867789030075, "Min_30.0% Prob": 3.5663794428110123, "Min_40.0% Prob": 2.8093277593143284, "Min_50.0% Prob": 2.276203406509012, "Min_60.0% Prob": 1.9041721634954836}}
{"hexsha": "42ade8c7bc75585628862cf8f3de1653a53a1aed", "ext": "c", "lang": "C", "content": "void rl_index_remove(index_t* index, int object_id) {\n\tif(object_id < 0 || object_id >= index->num_elements) return;\n\tindex_cell_t* cell = &index->cells[index->element_cell[object_id]];\n\tint remove_index = index->element_index_in_cell[object_id];\n\tif(remove_index < cell->num_elements - 1) {\n\t\tint moved_object_id = cell->elements[cell->num_elements - 1].object_id;\n\t\tcell->elements[remove_index] = cell->elements[cell->num_elements - 1];\n\t\tindex->element_index_in_cell[moved_object_id] = remove_index;\n\t}\n\tcell->num_elements--;\n}", "item_id": 4, "repo": "benob/pyrogue", "file": "lib/rogue_index.c", "last_update_at": "2019-09-29T20:35:43+00:00", "question_id": "42ade8c7bc75585628862cf8f3de1653a53a1aed_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void rl_index_remove(index_t* index, int object_id) {\n\tif(object_id < 0 || object_id >= index->num_elements) return;\n\tindex_cell_t* cell = &index->cells[index->element_cell[object_id]];\n\tint remove_index = index->element_index_in_cell[object_id];\n\tif(remove_index < cell->num_elements - 1) {\n\t\tint moved_object_id = cell->elements[cell->num_elements - 1].object_id;\n\t\tcell->elements[remove_index] = cell->elements[cell->num_elements - 1];\n\t\tindex->element_index_in_cell[moved_object_id] = remove_index;\n\t}\n\tcell->num_elements--;\n"]], "pred": {"ppl": 2.215406894683838, "ppl_lower": 2.215406894683838, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0038613402245529964, "Min_5.0% Prob": 6.672983540429009, "Min_10.0% Prob": 5.003719907057913, "Min_20.0% Prob": 3.419892207170144, "Min_30.0% Prob": 2.555658879421525, "Min_40.0% Prob": 1.9712890586521052, "Min_50.0% Prob": 1.5909919193146205, "Min_60.0% Prob": 1.3283268099322039}}
{"hexsha": "3206a0692bb9456db2df1dc5b5733dc52c3ac2fe", "ext": "c", "lang": "C", "content": "static int php_snmp_write_exceptions_enabled(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)\n{\n\tzval ztmp;\n\tint ret = SUCCESS;\n\tif (Z_TYPE_P(newval) != IS_LONG) {\n\t\tztmp = *newval;\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_long(&ztmp);\n\t\tnewval = &ztmp;\n\t}\n\n\tsnmp_object->exceptions_enabled = Z_LVAL_P(newval);\t\n\n\tif (newval == &ztmp) {\n\t\tzval_dtor(newval);\n\t}\n\treturn ret;\n}", "item_id": 28, "repo": "maruoze/PHP5.6", "file": "ext/snmp/snmp.c", "last_update_at": "2019-06-19T15:54:46+00:00", "question_id": "3206a0692bb9456db2df1dc5b5733dc52c3ac2fe_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int php_snmp_write_exceptions_enabled(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)\n{\n\tzval ztmp;\n\tint ret = SUCCESS;\n\tif (Z_TYPE_P(newval) != IS_LONG) {\n\t\tztmp = *newval;\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_long(&ztmp);\n\t\tnewval = &ztmp;\n\t}\n\tsnmp_object->exceptions_enabled = Z_LVAL_P(newval);\t\n\tif (newval == &ztmp) {\n\t\tzval_dtor(newval);\n\t}\n\treturn ret;\n"]], "pred": {"ppl": 1.9704405069351196, "ppl_lower": 2.882080316543579, "ppl/lowercase_ppl": -1.5606358208214326, "ppl/zlib": 0.002837895921902624, "Min_5.0% Prob": 7.643231709798177, "Min_10.0% Prob": 5.278432144059075, "Min_20.0% Prob": 3.205679123600324, "Min_30.0% Prob": 2.2535375312522605, "Min_40.0% Prob": 1.7079442871165358, "Min_50.0% Prob": 1.3548284643585538, "Min_60.0% Prob": 1.1319977582940712}}
{"hexsha": "12bdd39a86b99486e4ef8704b5e252b56a533e92", "ext": "h", "lang": "C", "content": "static inline hri_gmac_rpq_reg_t hri_gmac_get_RPQ_reg(const void *const hw, hri_gmac_rpq_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Gmac *)hw)->RPQ.reg;\n\ttmp &= mask;\n\treturn tmp;\n}", "item_id": 188, "repo": "jinlongliu/AliOS-Things", "file": "platform/mcu/atsamd5x_e5x/Drivers/hri/hri_gmac_e54.h", "last_update_at": "2019-09-25T07:17:27+00:00", "question_id": "12bdd39a86b99486e4ef8704b5e252b56a533e92_188", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline hri_gmac_rpq_reg_t hri_gmac_get_RPQ_reg(const void *const hw, hri_gmac_rpq_reg_t mask)\n{\n\tuint32_t tmp;\n\ttmp = ((Gmac *)hw)->RPQ.reg;\n\ttmp &= mask;\n\treturn tmp;\n"]], "pred": {"ppl": 1.4912678003311157, "ppl_lower": 2.0131218433380127, "ppl/lowercase_ppl": -1.7508509668835142, "ppl/zlib": 0.003004711510344682, "Min_5.0% Prob": 6.149994373321533, "Min_10.0% Prob": 4.1658090353012085, "Min_20.0% Prob": 2.0796877275056698, "Min_30.0% Prob": 1.365980317314657, "Min_40.0% Prob": 1.0159351650292852, "Min_50.0% Prob": 0.8082909870916576, "Min_60.0% Prob": 0.6710584742134604}}
{"hexsha": "04feb8ac5934e100a28d48d46f6c106b5450daf4", "ext": "c", "lang": "C", "content": "bool compare_lists(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {\n    struct SinglyLinkedListNode *p1,*p2;\n    p1 = head1;\n    p2 = head2;\n    int ct1=0,ct2=0;\n    while(p1!=NULL){\n        ct1++;\n        p1=p1->next;\n\n    }\n    while(p2!=NULL){\n        ct2++;\n        p2 = p2->next;\n    }\n    if(ct1==ct2){\n        p1=head1;\n        p2=head2;\n        while(p1!=NULL){\n            if(p1->data == p2->data)\n            {\n                p1 = p1->next;\n                p2=p2->next;\n            }\n            else\n                return 0;\n        }\n        if(p1==NULL)\n            return 1;\n    }\n\n    \n        return 0;\n\n\n}", "item_id": 0, "repo": "PreethiPrakashA/hackerrank", "file": "problem-solving/Compare two linked lists.c", "last_update_at": "2019-09-26T09:04:16+00:00", "question_id": "04feb8ac5934e100a28d48d46f6c106b5450daf4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool compare_lists(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {\n    struct SinglyLinkedListNode *p1,*p2;\n    p1 = head1;\n    p2 = head2;\n    int ct1=0,ct2=0;\n    while(p1!=NULL){\n        ct1++;\n        p1=p1->next;\n    }\n    while(p2!=NULL){\n        ct2++;\n        p2 = p2->next;\n    }\n    if(ct1==ct2){\n        p1=head1;\n        p2=head2;\n        while(p1!=NULL){\n            if(p1->data == p2->data)\n            {\n                p1 = p1->next;\n                p2=p2->next;\n            }\n            else\n                return 0;\n        }\n        if(p1==NULL)\n            return 1;\n    }\n        return 0;\n"]], "pred": {"ppl": 1.6998176574707031, "ppl_lower": 1.9258720874786377, "ppl/lowercase_ppl": -1.235349620732547, "ppl/zlib": 0.0021478582388583835, "Min_5.0% Prob": 5.905210018157959, "Min_10.0% Prob": 4.09278504550457, "Min_20.0% Prob": 2.464855326681721, "Min_30.0% Prob": 1.7164650583589398, "Min_40.0% Prob": 1.309743525667323, "Min_50.0% Prob": 1.0542557043654304, "Min_60.0% Prob": 0.8865106131982159}}
{"hexsha": "0c4a4167c182b4a4c19bd262ba972bb093bb98c0", "ext": "c", "lang": "C", "content": "void drawStatusBar(struct abuf *ab) {\n\t//Invert colors (Select Graphic Rendition)\n\tabAppend(ab, \"\\x1b[7m\", 4);\n\tchar status[80], rstatus[80];\n\t\n\tint len = snprintf(status, sizeof(status), \"%s %.20s - %d line%s\", E.modified ? \"(modified)\" : \"\", E.filename ? E.filename : \"[No Name]\", E.numrows, E.numrows == 1 ? \"\" : \"s\");\n\tint rlen = snprintf(rstatus, sizeof(rstatus), \"(%s) %d/%d - %d\", E.syntax ? E.syntax->filetype : \"Plain Text\", E.cy + 1 > E.numrows ? E.cy : E.cy + 1, E.numrows, E.cx + 1);\n\t\n\tif (len > E.screencols) {\n\t\tlen = E.screencols;\n\t}\n\t\n\tabAppend(ab, status, len);\n\t\n\twhile (len < E.screencols) {\n\t\tif (E.screencols - len == rlen) {\n\t\t\tabAppend(ab, rstatus, rlen);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tabAppend(ab, \" \", 1);\n\t\t\tlen++;\n\t\t}\n\t}\n\t//Clear all attributes (Select Graphic Rendition)\n\tabAppend(ab, \"\\x1b[m\", 3);\n\tabAppend(ab, \"\\r\\n\", 2);\n}", "item_id": 4, "repo": "failex234/fedit", "file": "src/terminal.c", "last_update_at": "2019-04-10T08:02:18+00:00", "question_id": "0c4a4167c182b4a4c19bd262ba972bb093bb98c0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void drawStatusBar(struct abuf *ab) {\n\t//Invert colors (Select Graphic Rendition)\n\tabAppend(ab, \"\\x1b[7m\", 4);\n\tchar status[80], rstatus[80];\n\t\n\tint len = snprintf(status, sizeof(status), \"%s %.20s - %d line%s\", E.modified ? \"(modified)\" : \"\", E.filename ? E.filename : \"[No Name]\", E.numrows, E.numrows == 1 ? \"\" : \"s\");\n\tint rlen = snprintf(rstatus, sizeof(rstatus), \"(%s) %d/%d - %d\", E.syntax ? E.syntax->filetype : \"Plain Text\", E.cy + 1 > E.numrows ? E.cy : E.cy + 1, E.numrows, E.cx + 1);\n\t\n\tif (len > E.screencols) {\n\t\tlen = E.screencols;\n\t}\n\t\n\tabAppend(ab, status, len);\n\t\n\twhile (len < E.screencols) {\n\t\tif (E.screencols - len == rlen) {\n\t\t\tabAppend(ab, rstatus, rlen);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tabAppend(ab, \" \", 1);\n\t\t\tlen++;\n\t\t}\n\t}\n\t//Clear all attributes (Select Graphic Rendition)\n\tabAppend(ab, \"\\x1b[m\", 3);\n\tabAppend(ab, \"\\r\\n\", 2);\n"]], "pred": {"ppl": 1.909759759902954, "ppl_lower": 2.1091301441192627, "ppl/lowercase_ppl": -1.1534800848334112, "ppl/zlib": 0.0015187264178216666, "Min_5.0% Prob": 7.642419438613088, "Min_10.0% Prob": 5.366050469247918, "Min_20.0% Prob": 3.101928236061021, "Min_30.0% Prob": 2.141135214778938, "Min_40.0% Prob": 1.6158174095356739, "Min_50.0% Prob": 1.2954951268179635, "Min_60.0% Prob": 1.0805807584414684}}
{"hexsha": "ef2e117259d0ee31c1292af9c844a612aefa40b8", "ext": "c", "lang": "C", "content": "void\n__txn_remlock(env, txn, lock, locker)\n\tENV *env;\n\tDB_TXN *txn;\n\tDB_LOCK *lock;\n\tDB_LOCKER *locker;\n{\n\tTXN_EVENT *e, *next_e;\n\n\tfor (e = TAILQ_FIRST(&txn->events); e != NULL; e = next_e) {\n\t\tnext_e = TAILQ_NEXT(e, links);\n\t\tif ((e->op != TXN_TRADE && e->op != TXN_TRADED) ||\n\t\t    (e->u.t.lock.off != lock->off && e->u.t.locker != locker))\n\t\t\tcontinue;\n\t\tTAILQ_REMOVE(&txn->events, e, links);\n\t\t__os_free(env, e);\n\t}\n\n\treturn;\n}", "item_id": 4, "repo": "natangl/refnet", "file": "db-4.8.30.NC/txn/txn_util.c", "last_update_at": "2019-03-20T06:04:55+00:00", "question_id": "ef2e117259d0ee31c1292af9c844a612aefa40b8_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\n__txn_remlock(env, txn, lock, locker)\n\tENV *env;\n\tDB_TXN *txn;\n\tDB_LOCK *lock;\n\tDB_LOCKER *locker;\n{\n\tTXN_EVENT *e, *next_e;\n\tfor (e = TAILQ_FIRST(&txn->events); e != NULL; e = next_e) {\n\t\tnext_e = TAILQ_NEXT(e, links);\n\t\tif ((e->op != TXN_TRADE && e->op != TXN_TRADED) ||\n\t\t    (e->u.t.lock.off != lock->off && e->u.t.locker != locker))\n\t\t\tcontinue;\n\t\tTAILQ_REMOVE(&txn->events, e, links);\n\t\t__os_free(env, e);\n\t}\n\treturn;\n"]], "pred": {"ppl": 2.2788352966308594, "ppl_lower": 3.2170069217681885, "ppl/lowercase_ppl": -1.4186011799755653, "ppl/zlib": 0.0030170859986621583, "Min_5.0% Prob": 7.835059686140581, "Min_10.0% Prob": 5.678566756455795, "Min_20.0% Prob": 3.741791686286097, "Min_30.0% Prob": 2.683672831326291, "Min_40.0% Prob": 2.0500292923787367, "Min_50.0% Prob": 1.6493849531140017, "Min_60.0% Prob": 1.3773130505629207}}
{"hexsha": "8bf7806f55dbbb31e772af2f59d20027f440e235", "ext": "c", "lang": "C", "content": "int\r\nmain()\r\n{\r\n\tint i;\r\n\tsigset_t set, oset, saveset;\r\n\r\n\tsignal(SIGINT, handler);\r\n\r\n\tsigemptyset(&set);\r\n\tsigaddset(&set, SIGINT);\r\n\r\n\tsigprocmask(SIG_UNBLOCK, &set, &oset);\r\n\r\n\tsigprocmask(SIG_BLOCK, &set, &saveset);\r\n\r\n\twhile (1) {\r\n/*\r\n\t\tsigset_t tmpset;\r\n\t\tsigprocmask(SIG_SETMASK, &saveset, &tmpset);\r\n\t\tpause();\r\n\t\tsigprocmask(SIG_SETMASK, &tmpset, NULL);\r\n\r\n\t\tATOMIC:\r\n*/\r\n\t\tsigsuspend(&saveset);\r\n\t\tfor (i=0;i<5;++i) {\r\n\t\t\twrite(1, \"x\", 1);\r\n\t\t\tsleep(1);\r\n\t\t}\r\n\t\twrite(1, \"\\n\", 1);\r\n\t\tfflush(stdout);\r\n\t}\r\n\r\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\r\n\r\n\treturn 0;\r\n}", "item_id": 0, "repo": "harkhuang/harkcode", "file": "linux/nhf/signal/susp.c", "last_update_at": "2019-04-19T08:14:46+00:00", "question_id": "8bf7806f55dbbb31e772af2f59d20027f440e235_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\r\nmain()\r\n{\r\n\tint i;\r\n\tsigset_t set, oset, saveset;\r\n\r\n\tsignal(SIGINT, handler);\r\n\r\n\tsigemptyset(&set);\r\n\tsigaddset(&set, SIGINT);\r\n\r\n\tsigprocmask(SIG_UNBLOCK, &set, &oset);\r\n\r\n\tsigprocmask(SIG_BLOCK, &set, &saveset);\r\n\r\n\twhile (1) {\r\n/*\r\n\t\tsigset_t tmpset;\r\n\t\tsigprocmask(SIG_SETMASK, &saveset, &tmpset);\r\n\t\tpause();\r\n\t\tsigprocmask(SIG_SETMASK, &tmpset, NULL);\r\n\r\n\t\tATOMIC:\r\n*/\r\n\t\tsigsuspend(&saveset);\r\n\t\tfor (i=0;i<5;++i) {\r\n\t\t\twrite(1, \"x\", 1);\r\n\t\t\tsleep(1);\r\n\t\t}\r\n\t\twrite(1, \"\\n\", 1);\r\n\t\tfflush(stdout);\r\n\t}\r\n\r\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\r\n\r\n\treturn 0;\r\n"]], "pred": {"ppl": 1.844062328338623, "ppl_lower": 2.0306179523468018, "ppl/lowercase_ppl": -1.157473545894888, "ppl/zlib": 0.0020674693418265156, "Min_5.0% Prob": 6.454045629501342, "Min_10.0% Prob": 4.530376251538595, "Min_20.0% Prob": 2.8223495297744625, "Min_30.0% Prob": 2.0039184273599266, "Min_40.0% Prob": 1.5205516442045814, "Min_50.0% Prob": 1.2200406860267998, "Min_60.0% Prob": 1.0226649200655724}}
{"hexsha": "e7456de35114938f97b600c390cf3a714492e28d", "ext": "c", "lang": "C", "content": "static void\nHALF_to_CFLOAT(void *input, void *output, npy_intp n,\n        void *NPY_UNUSED(aip), void *NPY_UNUSED(aop))\n{\n    const npy_half *ip = input;\n    npy_uint32 *op = output;\n\n    while (n--) {\n        *op++ = npy_halfbits_to_floatbits(*ip++);\n#if 1\n        *op++ = 0;\n#endif\n    }\n}", "item_id": 357, "repo": "jochenater/catboost", "file": "contrib/python/numpy/py3/numpy/core/src/multiarray/arraytypes.c", "last_update_at": "2019-03-18T13:30:19+00:00", "question_id": "e7456de35114938f97b600c390cf3a714492e28d_357", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nHALF_to_CFLOAT(void *input, void *output, npy_intp n,\n        void *NPY_UNUSED(aip), void *NPY_UNUSED(aop))\n{\n    const npy_half *ip = input;\n    npy_uint32 *op = output;\n    while (n--) {\n        *op++ = npy_halfbits_to_floatbits(*ip++);\n#if 1\n        *op++ = 0;\n#endif\n    }\n"]], "pred": {"ppl": 2.6039435863494873, "ppl_lower": 2.7268130779266357, "ppl/lowercase_ppl": -1.0481767952186798, "ppl/zlib": 0.0049586894294473705, "Min_5.0% Prob": 7.350164492925008, "Min_10.0% Prob": 5.875370575831487, "Min_20.0% Prob": 4.087303037826832, "Min_30.0% Prob": 3.0496219763389, "Min_40.0% Prob": 2.366179269953416, "Min_50.0% Prob": 1.8930125965765028, "Min_60.0% Prob": 1.5931084272982199}}
{"hexsha": "cf00f7c8cbf050bf1ce1af828df40e380d1310a9", "ext": "c", "lang": "C", "content": "void list_remove(struct list_elem* pelem) {\n    enum intr_status old_status = intr_disable();\n\n    pelem->prev->next = pelem->next;\n    pelem->next->prev = pelem->prev;\n    intr_set_status(old_status);\n}", "item_id": 2, "repo": "Yu2erer/BearOS", "file": "lib/kernel/list.c", "last_update_at": "2019-08-31T09:42:06+00:00", "question_id": "cf00f7c8cbf050bf1ce1af828df40e380d1310a9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void list_remove(struct list_elem* pelem) {\n    enum intr_status old_status = intr_disable();\n    pelem->prev->next = pelem->next;\n    pelem->next->prev = pelem->prev;\n    intr_set_status(old_status);\n"]], "pred": {"ppl": 3.2013447284698486, "ppl_lower": 3.2013447284698486, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009161975977807869, "Min_5.0% Prob": 8.368903160095215, "Min_10.0% Prob": 6.911731379372733, "Min_20.0% Prob": 4.7197624785559515, "Min_30.0% Prob": 3.5908620016915456, "Min_40.0% Prob": 2.879657711301531, "Min_50.0% Prob": 2.3555915103427, "Min_60.0% Prob": 1.9658752074576027}}
{"hexsha": "24f046d254a77c2d95c4febfa35c175cf44161a8", "ext": "c", "lang": "C", "content": "void   pb__unsubscribe_request__free_unpacked\n                     (Pb__UnsubscribeRequest *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &pb__unsubscribe_request__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n}", "item_id": 10, "repo": "igor-sinelnikow/nats.c", "file": "src/stan/protocol.pb-c.c", "last_update_at": "2019-05-10T12:24:34+00:00", "question_id": "24f046d254a77c2d95c4febfa35c175cf44161a8_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void   pb__unsubscribe_request__free_unpacked\n                     (Pb__UnsubscribeRequest *message,\n                      ProtobufCAllocator *allocator)\n{\n  if(!message)\n    return;\n  assert(message->base.descriptor == &pb__unsubscribe_request__descriptor);\n  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);\n"]], "pred": {"ppl": 1.9082918167114258, "ppl_lower": 3.0936996936798096, "ppl/lowercase_ppl": -1.747683104849111, "ppl/zlib": 0.0036303848601150564, "Min_5.0% Prob": 7.4054357528686525, "Min_10.0% Prob": 5.69778790473938, "Min_20.0% Prob": 3.3115660205483435, "Min_30.0% Prob": 2.1640701546303687, "Min_40.0% Prob": 1.6385421888425764, "Min_50.0% Prob": 1.2922983294601391, "Min_60.0% Prob": 1.0839295902349535}}
{"hexsha": "8bc1483f94c5cd85b01f91f0f65028b682d2fd42", "ext": "c", "lang": "C", "content": "void CheckWaterJump (void)\n{\n\tvec3_t\tspot;\n\tint\t\tcont;\n\tvec3_t\tflatforward;\n\n\tif (pmove.waterjumptime)\n\t\treturn;\n\n\t// ZOID, don't hop out if we just jumped in\n\tif (pmove.velocity[2] < -180)\n\t\treturn; // only hop out if we are moving up\n\n\t// see if near an edge\n\tflatforward[0] = forward[0];\n\tflatforward[1] = forward[1];\n\tflatforward[2] = 0;\n\tVectorNormalize (flatforward);\n\n\tVectorMA (pmove.origin, 24, flatforward, spot);\n\tspot[2] += 8;\n\tcont = PM_PointContents (spot);\n\tif (cont != CONTENTS_SOLID)\n\t\treturn;\n\tspot[2] += 24;\n\tcont = PM_PointContents (spot);\n\tif (cont != CONTENTS_EMPTY)\n\t\treturn;\n\t// jump out of water\n\tVectorScale (flatforward, 50, pmove.velocity);\n\tpmove.velocity[2] = 310;\n\tpmove.waterjumptime = 2;\t// safety net\n\tpmove.oldbuttons |= BUTTON_JUMP;\t// don't jump again until released\n}", "item_id": 10, "repo": "chaos4ever/chaos-old", "file": "programs/quake/q1source/QW/client/pmove.c", "last_update_at": "2019-12-10T15:47:15+00:00", "question_id": "8bc1483f94c5cd85b01f91f0f65028b682d2fd42_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CheckWaterJump (void)\n{\n\tvec3_t\tspot;\n\tint\t\tcont;\n\tvec3_t\tflatforward;\n\tif (pmove.waterjumptime)\n\t\treturn;\n\t// ZOID, don't hop out if we just jumped in\n\tif (pmove.velocity[2] < -180)\n\t\treturn; // only hop out if we are moving up\n\t// see if near an edge\n\tflatforward[0] = forward[0];\n\tflatforward[1] = forward[1];\n\tflatforward[2] = 0;\n\tVectorNormalize (flatforward);\n\tVectorMA (pmove.origin, 24, flatforward, spot);\n\tspot[2] += 8;\n\tcont = PM_PointContents (spot);\n\tif (cont != CONTENTS_SOLID)\n\t\treturn;\n\tspot[2] += 24;\n\tcont = PM_PointContents (spot);\n\tif (cont != CONTENTS_EMPTY)\n\t\treturn;\n\t// jump out of water\n\tVectorScale (flatforward, 50, pmove.velocity);\n\tpmove.velocity[2] = 310;\n\tpmove.waterjumptime = 2;\t// safety net\n\tpmove.oldbuttons |= BUTTON_JUMP;\t// don't jump again until released\n"]], "pred": {"ppl": 2.438539505004883, "ppl_lower": 3.0589101314544678, "ppl/lowercase_ppl": -1.2542736915213222, "ppl/zlib": 0.0021427867706054326, "Min_5.0% Prob": 7.513314723968506, "Min_10.0% Prob": 5.463990381785801, "Min_20.0% Prob": 3.746877612386431, "Min_30.0% Prob": 2.7635018059185574, "Min_40.0% Prob": 2.1798650769250734, "Min_50.0% Prob": 1.7682119906371967, "Min_60.0% Prob": 1.483688081583776}}
{"hexsha": "064637f213f29f9973154dac29c19c0f46d1a8e4", "ext": "c", "lang": "C", "content": "void SND_startPlay_2ADPCM(const u8 *sample, const u32 len, const u16 channel, const u8 loop)\r\n{\r\n    vu8 *pb;\r\n    u8 status;\r\n    u16 ch;\r\n    u32 addr;\r\n\r\n    // disable ints when requesting Z80 bus\r\n    SYS_disableInts();\r\n\r\n    // load the appropriate driver if not already done\r\n    Z80_loadDriver(Z80_DRIVER_2ADPCM, TRUE);\r\n\r\n    Z80_requestBus(TRUE);\r\n\r\n    // point to Z80 status\r\n    pb = (u8 *) Z80_DRV_STATUS;\r\n    // get status\r\n    status = *pb;\r\n\r\n    // auto channel ?\r\n    if (channel == SOUND_PCM_CH_AUTO)\r\n    {\r\n        // scan for first free channel\r\n        ch = 0;\r\n\r\n        while ((ch < 2) && (status & (Z80_DRV_STAT_PLAYING << ch))) ch++;\r\n\r\n        // if all channel busy we use the first\r\n        if (ch == 2) ch = 0;\r\n    }\r\n    // we use specified channel\r\n    else ch = channel;\r\n\r\n    // point to Z80 base parameters\r\n    pb = (u8 *) (Z80_DRV_PARAMS + (ch * 4));\r\n\r\n    addr = (u32) sample;\r\n    // sample address (128 bytes aligned)\r\n    pb[0] = addr >> 7;\r\n    pb[1] = addr >> 15;\r\n    // sample length (128 bytes aligned)\r\n    pb[2] = len >> 7;\r\n    pb[3] = len >> 15;\r\n\r\n    // point to Z80 command\r\n    pb = (u8 *) Z80_DRV_COMMAND;\r\n    // play command\r\n    *pb |= (Z80_DRV_COM_PLAY << ch);\r\n\r\n    // point to Z80 status\r\n    pb = (u8 *) Z80_DRV_STATUS;\r\n\r\n    // loop flag in status\r\n    if (loop) pb[1] |= (Z80_DRV_STAT_PLAYING << ch);\r\n    else pb[1] &= ~(Z80_DRV_STAT_PLAYING << ch);\r\n\r\n    Z80_releaseBus();\r\n\r\n    // re-enable ints\r\n    SYS_enableInts();\r\n}", "item_id": 4, "repo": "Megadrive-Vault/SGDK", "file": "src/sound.c", "last_update_at": "2019-09-16T10:24:36+00:00", "question_id": "064637f213f29f9973154dac29c19c0f46d1a8e4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SND_startPlay_2ADPCM(const u8 *sample, const u32 len, const u16 channel, const u8 loop)\r\n{\r\n    vu8 *pb;\r\n    u8 status;\r\n    u16 ch;\r\n    u32 addr;\r\n\r\n    // disable ints when requesting Z80 bus\r\n    SYS_disableInts();\r\n\r\n    // load the appropriate driver if not already done\r\n    Z80_loadDriver(Z80_DRIVER_2ADPCM, TRUE);\r\n\r\n    Z80_requestBus(TRUE);\r\n\r\n    // point to Z80 status\r\n    pb = (u8 *) Z80_DRV_STATUS;\r\n    // get status\r\n    status = *pb;\r\n\r\n    // auto channel ?\r\n    if (channel == SOUND_PCM_CH_AUTO)\r\n    {\r\n        // scan for first free channel\r\n        ch = 0;\r\n\r\n        while ((ch < 2) && (status & (Z80_DRV_STAT_PLAYING << ch))) ch++;\r\n\r\n        // if all channel busy we use the first\r\n        if (ch == 2) ch = 0;\r\n    }\r\n    // we use specified channel\r\n    else ch = channel;\r\n\r\n    // point to Z80 base parameters\r\n    pb = (u8 *) (Z80_DRV_PARAMS + (ch * 4));\r\n\r\n    addr = (u32) sample;\r\n    // sample address (128 bytes aligned)\r\n    pb[0] = addr >> 7;\r\n    pb[1] = addr >> 15;\r\n    // sample length (128 bytes aligned)\r\n    pb[2] = len >> 7;\r\n    pb[3] = len >> 15;\r\n\r\n    // point to Z80 command\r\n    pb = (u8 *) Z80_DRV_COMMAND;\r\n    // play command\r\n    *pb |= (Z80_DRV_COM_PLAY << ch);\r\n\r\n    // point to Z80 status\r\n    pb = (u8 *) Z80_DRV_STATUS;\r\n\r\n    // loop flag in status\r\n    if (loop) pb[1] |= (Z80_DRV_STAT_PLAYING << ch);\r\n    else pb[1] &= ~(Z80_DRV_STAT_PLAYING << ch);\r\n\r\n    Z80_releaseBus();\r\n\r\n    // re-enable ints\r\n    SYS_enableInts();\r\n"]], "pred": {"ppl": 2.369293689727783, "ppl_lower": 2.5242316722869873, "ppl/lowercase_ppl": -1.0734354675378528, "ppl/zlib": 0.0013562765558458925, "Min_5.0% Prob": 6.641778915159164, "Min_10.0% Prob": 5.1390901188696585, "Min_20.0% Prob": 3.6360862684249877, "Min_30.0% Prob": 2.7163430398448987, "Min_40.0% Prob": 2.1253412129879, "Min_50.0% Prob": 1.7196132341584267, "Min_60.0% Prob": 1.4366354578684897}}
{"hexsha": "eaff4be9909a28a47faa7bd433af9e20c0b40c40", "ext": "c", "lang": "C", "content": "void cg_propagator( double **propagator, double **source )\n{\n  double **tmp = alloc_vector();\n  vec_zero(tmp);\n\n  fM_transpose( tmp, source );\n  cg_MdM( propagator, tmp );\n  //fM( tmp, propagator ); //To test cg\n  //vec_dmul_add( tmp, tmp, source, -1 );\n  free_vector(tmp);\n}", "item_id": 7, "repo": "rantahar/Thirring2D", "file": "vec_ops.c", "last_update_at": "2019-07-18T10:21:16+00:00", "question_id": "eaff4be9909a28a47faa7bd433af9e20c0b40c40_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cg_propagator( double **propagator, double **source )\n{\n  double **tmp = alloc_vector();\n  vec_zero(tmp);\n  fM_transpose( tmp, source );\n  cg_MdM( propagator, tmp );\n  //fM( tmp, propagator ); //To test cg\n  //vec_dmul_add( tmp, tmp, source, -1 );\n  free_vector(tmp);\n"]], "pred": {"ppl": 7.388715744018555, "ppl_lower": 7.163626194000244, "ppl/lowercase_ppl": -0.9845308274883211, "ppl/zlib": 0.012269656054666764, "Min_5.0% Prob": 8.347061347961425, "Min_10.0% Prob": 7.3514699068936435, "Min_20.0% Prob": 5.995411103421992, "Min_30.0% Prob": 5.075777667941469, "Min_40.0% Prob": 4.345029161735014, "Min_50.0% Prob": 3.7315904129635205, "Min_60.0% Prob": 3.223707644325314}}
{"hexsha": "486b6eb57add9900d0f9d1cdb21ea13ef0fda5e4", "ext": "c", "lang": "C", "content": "unsigned int v__cb_ctxp_dismissed(short parameter_2)\r\n{\r\n\tunsigned int unsigned_int_1 = 1;\r\n\tunsigned int unsigned_int_2 = 1;\r\n\tint int_1 = 1;\r\n\tshort short_1 = 1;\r\n\tshort short_2 = 1;\r\n\tdouble double_1 = 1;\r\n\tdouble double_2 = 1;\r\n\tdouble double_3 = 1;\r\n\tunsigned_int_2 = unsigned_int_1 * unsigned_int_1;\r\n\tint_1 = int_1 + int_1;\r\n\tshort_1 = short_1 + short_2;\r\n\tdouble_3 = double_1 + double_2;\r\n\treturn unsigned_int_1;\r\n}", "item_id": 79, "repo": "Vul4Vendetta/Vul_Tech", "file": "experiments/node3/c_source/terminology_0_15_node3.c", "last_update_at": "2019-10-28T05:24:15+00:00", "question_id": "486b6eb57add9900d0f9d1cdb21ea13ef0fda5e4_79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned int v__cb_ctxp_dismissed(short parameter_2)\r\n{\r\n\tunsigned int unsigned_int_1 = 1;\r\n\tunsigned int unsigned_int_2 = 1;\r\n\tint int_1 = 1;\r\n\tshort short_1 = 1;\r\n\tshort short_2 = 1;\r\n\tdouble double_1 = 1;\r\n\tdouble double_2 = 1;\r\n\tdouble double_3 = 1;\r\n\tunsigned_int_2 = unsigned_int_1 * unsigned_int_1;\r\n\tint_1 = int_1 + int_1;\r\n\tshort_1 = short_1 + short_2;\r\n\tdouble_3 = double_1 + double_2;\r\n\treturn unsigned_int_1;\r\n"]], "pred": {"ppl": 1.522585153579712, "ppl_lower": 1.522585153579712, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002611240056767095, "Min_5.0% Prob": 6.174843043088913, "Min_10.0% Prob": 3.6871927555869606, "Min_20.0% Prob": 2.114627287217549, "Min_30.0% Prob": 1.4195432902032614, "Min_40.0% Prob": 1.0598905247453319, "Min_50.0% Prob": 0.8455412029985443, "Min_60.0% Prob": 0.7033019614852543}}
{"hexsha": "9ad037cd40f589f3154f0c72f384ae28fc8bf1bf", "ext": "c", "lang": "C", "content": "static long fltoa(long number, char *buf)\n{\n    static char digits[] = \"0123456789\";\n    long sign = number;\n    char* tmp = buf;\n\n    if (sign < 0) number = -number;\n    do *tmp++ = digits[number % 10]; while (number /= 10);\n    if (sign < 0) *tmp++ = '-';\n    freverse(buf, tmp - 1);\n    return tmp - buf;\n}", "item_id": 10, "repo": "parisiale/marionette-collective", "file": "lib/mcollective/vendor/json/ext/json/ext/generator/generator.c", "last_update_at": "2019-11-09T19:50:59+00:00", "question_id": "9ad037cd40f589f3154f0c72f384ae28fc8bf1bf_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static long fltoa(long number, char *buf)\n{\n    static char digits[] = \"0123456789\";\n    long sign = number;\n    char* tmp = buf;\n    if (sign < 0) number = -number;\n    do *tmp++ = digits[number % 10]; while (number /= 10);\n    if (sign < 0) *tmp++ = '-';\n    freverse(buf, tmp - 1);\n    return tmp - buf;\n"]], "pred": {"ppl": 2.451308488845825, "ppl_lower": 2.451308488845825, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0047947698345890905, "Min_5.0% Prob": 8.57225521405538, "Min_10.0% Prob": 6.197349190711975, "Min_20.0% Prob": 4.0128161162137985, "Min_30.0% Prob": 2.870940351808393, "Min_40.0% Prob": 2.230536644251979, "Min_50.0% Prob": 1.7810291879840436, "Min_60.0% Prob": 1.4986864570024852}}
{"hexsha": "53a54ee4023dc62eee6f836b42593bcafd5ddc92", "ext": "c", "lang": "C", "content": "uint8_t base64_decode(const unsigned char *src, size_t len, size_t *out_len, unsigned char *dst)\n{\n    unsigned char dtable[256], *pos, block[4], tmp;\n    size_t i, count, olen;\n    int pad = 0;\n\n    memset(dtable, 0x80, 256);\n    for (i = 0; i < sizeof(base64_table) - 1; i++)\n        dtable[base64_table[i]] = (unsigned char) i;\n    dtable['='] = 0;\n\n    count = 0;\n    for (i = 0; i < len; i++) {\n        if (dtable[src[i]] != 0x80)\n        count++;\n    }\n\n    if (count == 0 || count % 4) // Check padding\n        return 0;\n\n    olen = count / 4 * 3;\n    unsigned char out[olen];\n    pos = out;\n    if (out == NULL)\n        return 0;\n\n    count = 0;\n    for (i = 0; i < len; i++) {\n        tmp = dtable[src[i]];\n        if (tmp == 0x80)\n            continue;\n\n        if (src[i] == '=')\n            pad++;\n        block[count] = tmp;\n        count++;\n        if (count == 4) {\n            *pos++ = (block[0] << 2) | (block[1] >> 4);\n            *pos++ = (block[1] << 4) | (block[2] >> 2);\n            *pos++ = (block[2] << 6) | block[3];\n            count = 0;\n            if (pad) {\n                if (pad == 1)\n                    pos--;\n                else if (pad == 2)\n                    pos -= 2;\n                else /* Invalid padding */\n                    return 0;\n            break;\n            }\n        }\n    }\n\n    *out_len = pos - out;\n    memcpy(dst, out, *out_len+1);\n    return 1;\n}", "item_id": 1, "repo": "eduingles/coap-eap-noob", "file": "base64.c", "last_update_at": "2019-12-02T13:00:24+00:00", "question_id": "53a54ee4023dc62eee6f836b42593bcafd5ddc92_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t base64_decode(const unsigned char *src, size_t len, size_t *out_len, unsigned char *dst)\n{\n    unsigned char dtable[256], *pos, block[4], tmp;\n    size_t i, count, olen;\n    int pad = 0;\n    memset(dtable, 0x80, 256);\n    for (i = 0; i < sizeof(base64_table) - 1; i++)\n        dtable[base64_table[i]] = (unsigned char) i;\n    dtable['='] = 0;\n    count = 0;\n    for (i = 0; i < len; i++) {\n        if (dtable[src[i]] != 0x80)\n        count++;\n    }\n    if (count == 0 || count % 4) // Check padding\n        return 0;\n    olen = count / 4 * 3;\n    unsigned char out[olen];\n    pos = out;\n    if (out == NULL)\n        return 0;\n    count = 0;\n    for (i = 0; i < len; i++) {\n        tmp = dtable[src[i]];\n        if (tmp == 0x80)\n            continue;\n        if (src[i] == '=')\n            pad++;\n        block[count] = tmp;\n        count++;\n        if (count == 4) {\n            *pos++ = (block[0] << 2) | (block[1] >> 4);\n            *pos++ = (block[1] << 4) | (block[2] >> 2);\n            *pos++ = (block[2] << 6) | block[3];\n            count = 0;\n            if (pad) {\n                if (pad == 1)\n                    pos--;\n                else if (pad == 2)\n                    pos -= 2;\n                else /* Invalid padding */\n                    return 0;\n            break;\n            }\n        }\n    }\n    *out_len = pos - out;\n    memcpy(dst, out, *out_len+1);\n    return 1;\n"]], "pred": {"ppl": 1.4176950454711914, "ppl_lower": 1.4345440864562988, "ppl/lowercase_ppl": -1.0338499962290018, "ppl/zlib": 0.0006597964940831983, "Min_5.0% Prob": 5.547285786041846, "Min_10.0% Prob": 3.26521970978323, "Min_20.0% Prob": 1.7339513591516797, "Min_30.0% Prob": 1.1627166916078293, "Min_40.0% Prob": 0.8724517418017481, "Min_50.0% Prob": 0.6977881681698558, "Min_60.0% Prob": 0.5830950359501138}}
{"hexsha": "1ee67b942e59d80360180037d3823ca30b5d6130", "ext": "c", "lang": "C", "content": "static int\n_conversation(int num_msg,\n              const struct pam_message **msg,\n              struct pam_response **rp,\n              void *appdata_ptr)\n{\n   int i = 0;\n\n   Pam_Config *c = appdata_ptr;\n\n   *rp = (struct pam_response *)calloc(num_msg, sizeof(struct pam_response));\n   for (i = 0; i < num_msg; i++) {\n      rp[i]->resp_retcode = 0;\n      switch (msg[i]->msg_style) {\n         case PAM_PROMPT_ECHO_ON:\n            if (!c->user)\n               c->user = _prompt(msg[i]->msg, true);\n            rp[i]->resp = strdup(c->user);\n            break;\n         case PAM_PROMPT_ECHO_OFF:\n            if (c->autologin) {\n               printf(\"Password requested in autologin-mode!\\n\");\n               abort();\n            }\n            if (!c->password)\n               c->password = _prompt(msg[i]->msg, false);\n            rp[i]->resp = strdup(c->password);\n            break;\n         case PAM_TEXT_INFO:\n         case PAM_ERROR_MSG:\n            printf(\"%s\\n\", msg[i]->msg);\n            break;\n         default:\n\n            break;\n      }\n   }\n   return PAM_SUCCESS;\n}", "item_id": 2, "repo": "marcelhollerbach/spawny", "file": "src/selftest/main.c", "last_update_at": "2019-01-26T03:01:07+00:00", "question_id": "1ee67b942e59d80360180037d3823ca30b5d6130_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\n_conversation(int num_msg,\n              const struct pam_message **msg,\n              struct pam_response **rp,\n              void *appdata_ptr)\n{\n   int i = 0;\n   Pam_Config *c = appdata_ptr;\n   *rp = (struct pam_response *)calloc(num_msg, sizeof(struct pam_response));\n   for (i = 0; i < num_msg; i++) {\n      rp[i]->resp_retcode = 0;\n      switch (msg[i]->msg_style) {\n         case PAM_PROMPT_ECHO_ON:\n            if (!c->user)\n               c->user = _prompt(msg[i]->msg, true);\n            rp[i]->resp = strdup(c->user);\n            break;\n         case PAM_PROMPT_ECHO_OFF:\n            if (c->autologin) {\n               printf(\"Password requested in autologin-mode!\\n\");\n               abort();\n            }\n            if (!c->password)\n               c->password = _prompt(msg[i]->msg, false);\n            rp[i]->resp = strdup(c->password);\n            break;\n         case PAM_TEXT_INFO:\n         case PAM_ERROR_MSG:\n            printf(\"%s\\n\", msg[i]->msg);\n            break;\n         default:\n            break;\n      }\n   }\n   return PAM_SUCCESS;\n"]], "pred": {"ppl": 1.879982590675354, "ppl_lower": 2.0378501415252686, "ppl/lowercase_ppl": -1.1277327282072231, "ppl/zlib": 0.0014578811005078848, "Min_5.0% Prob": 6.885612487792969, "Min_10.0% Prob": 4.85555066381182, "Min_20.0% Prob": 3.0104350968145988, "Min_30.0% Prob": 2.081231630851175, "Min_40.0% Prob": 1.5761986822671408, "Min_50.0% Prob": 1.263704290613532, "Min_60.0% Prob": 1.0534740398941171}}
{"hexsha": "a2cf3f76c677ee88c27ec9a88eb65f2f825cc0dc", "ext": "c", "lang": "C", "content": "static int do_if_print(struct interface *ife, void *cookie)\n{\n\tint *opt_a = (int *) cookie;\n\tint res;\n\n\tres = do_if_fetch(ife);\n\tif (res >= 0) {\n\t\tif ((ife->flags & IFF_UP) || *opt_a)\n\t\t\tife_print(ife);\n\t}\n\treturn res;\n}", "item_id": 35, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/progs.gpl/busybox-1.00/libbb/interface.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "a2cf3f76c677ee88c27ec9a88eb65f2f825cc0dc_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int do_if_print(struct interface *ife, void *cookie)\n{\n\tint *opt_a = (int *) cookie;\n\tint res;\n\tres = do_if_fetch(ife);\n\tif (res >= 0) {\n\t\tif ((ife->flags & IFF_UP) || *opt_a)\n\t\t\tife_print(ife);\n\t}\n\treturn res;\n"]], "pred": {"ppl": 3.969681978225708, "ppl_lower": 4.441606044769287, "ppl/lowercase_ppl": -1.0814761655555971, "ppl/zlib": 0.008670981039308473, "Min_5.0% Prob": 8.572715187072754, "Min_10.0% Prob": 7.601054382324219, "Min_20.0% Prob": 5.4770283699035645, "Min_30.0% Prob": 4.179317208131154, "Min_40.0% Prob": 3.3142046585679052, "Min_50.0% Prob": 2.718518661260605, "Min_60.0% Prob": 2.2875845827162267}}
{"hexsha": "8dd031bc69b641cb3c7c7c94759b5f595a5acb1a", "ext": "c", "lang": "C", "content": "static int\nbsd_wireless_event_init(void *priv)\n{\n\tstruct bsd_driver_data *drv = priv;\n\tint s;\n\n\tdrv->wext_sock = -1;\n\n\ts = socket(PF_ROUTE, SOCK_RAW, 0);\n\tif (s < 0) {\n\t\tperror(\"socket(PF_ROUTE,SOCK_RAW)\");\n\t\treturn -1;\n\t}\n\teloop_register_read_sock(s, bsd_wireless_event_receive, drv, NULL);\n\tdrv->wext_sock = s;\n\n\treturn 0;\n}", "item_id": 21, "repo": "cooljeanius/DragonFlyBSD", "file": "usr.sbin/802_11/hostapd/driver_dragonfly.c", "last_update_at": "2019-11-23T09:35:10+00:00", "question_id": "8dd031bc69b641cb3c7c7c94759b5f595a5acb1a_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nbsd_wireless_event_init(void *priv)\n{\n\tstruct bsd_driver_data *drv = priv;\n\tint s;\n\tdrv->wext_sock = -1;\n\ts = socket(PF_ROUTE, SOCK_RAW, 0);\n\tif (s < 0) {\n\t\tperror(\"socket(PF_ROUTE,SOCK_RAW)\");\n\t\treturn -1;\n\t}\n\teloop_register_read_sock(s, bsd_wireless_event_receive, drv, NULL);\n\tdrv->wext_sock = s;\n\treturn 0;\n"]], "pred": {"ppl": 1.852396845817566, "ppl_lower": 2.364553451538086, "ppl/lowercase_ppl": -1.3959717107860659, "ppl/zlib": 0.002802183603947778, "Min_5.0% Prob": 6.1243152022361755, "Min_10.0% Prob": 4.495281100273132, "Min_20.0% Prob": 2.806970838457346, "Min_30.0% Prob": 1.9882295368885508, "Min_40.0% Prob": 1.5418543640237587, "Min_50.0% Prob": 1.230452567656956, "Min_60.0% Prob": 1.0310195200169003}}
{"hexsha": "bd4f83e1ee07cf83d5ac4f119c406f06347e23cc", "ext": "c", "lang": "C", "content": "int \nunlock_file_win(void *pHandle) {\n\tBOOL bSuccess;\n\n\tif (pHandle != INVALID_HANDLE_VALUE) {\n\t\tbSuccess = UnlockFile(\n\t\t\t(HANDLE)pHandle,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0);\n\t\tif (bSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}", "item_id": 4, "repo": "nneesshh/openresty-win32-build", "file": "openresty-win32-build/src/nginx/src/os/win32/lfs.c", "last_update_at": "2019-01-12T03:20:41+00:00", "question_id": "bd4f83e1ee07cf83d5ac4f119c406f06347e23cc_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int \nunlock_file_win(void *pHandle) {\n\tBOOL bSuccess;\n\tif (pHandle != INVALID_HANDLE_VALUE) {\n\t\tbSuccess = UnlockFile(\n\t\t\t(HANDLE)pHandle,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0);\n\t\tif (bSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n"]], "pred": {"ppl": 2.1668918132781982, "ppl_lower": 2.9765756130218506, "ppl/lowercase_ppl": -1.4105551102822946, "ppl/zlib": 0.0050213882899709196, "Min_5.0% Prob": 6.398730278015137, "Min_10.0% Prob": 4.863073088906028, "Min_20.0% Prob": 3.2290314435958862, "Min_30.0% Prob": 2.397422329017094, "Min_40.0% Prob": 1.895754097624028, "Min_50.0% Prob": 1.536901570477728, "Min_60.0% Prob": 1.3005581857370478}}
{"hexsha": "77c93458f825316a89b82a2b34f6d9fa68ee7964", "ext": "c", "lang": "C", "content": "void create()\n{\n        set(\"short\", HIR \"\u3010\u9b3c\u9580\u95dc\u3011\" NOR);\n        set(\"long\", HIR @LONG\n\n                    \u9b3c         \u9580         \u95dc\n\n    \u9019\u88cf\u5c31\u662f\u8457\u540d\u7684\u9670\u9593\u5165\u53e3\u300c\u9b3c\u9580\u95dc\u300d\uff0c\u5728\u4f60\u9762\u524d\u77d7\u7acb\u8457\u4e00\u5ea7\u9ad8\u5927\u7684\n\u9ed1\u8272\u57ce\u6a13\uff0c\u8a31\u591a\u4ea1\u9b42\u6b63\u54ed\u54ed\u557c\u557c\u5730\u5217\u968a\u524d\u9032\uff0c\u56e0\u70ba\u4e00\u9032\u9b3c\u9580\u95dc\u5c31\u7121\u6cd5\u518d\n\u56de\u967d\u9593\u4e86\u3002\n\n\nLONG NOR );\n        set(\"exits\", ([\n                \"north\" : __DIR__\"gateway\",\n        ]) );\n        set(\"objects\", ([\n                __DIR__\"npc/bai\":1,\n                __DIR__\"npc/ghost\":1,\n        ]) );\n\n        set(\"no_fight\", 1);\n        set(\"no_magic\", 1);\n        set(\"no_sleep_room\", 1);\n\n        setup();\n        replace_program(ROOM);\n}", "item_id": 0, "repo": "cantona/NT6", "file": "nitan/d/death/gate.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "77c93458f825316a89b82a2b34f6d9fa68ee7964_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void create()\n{\n        set(\"short\", HIR \"\u3010\u9b3c\u9580\u95dc\u3011\" NOR);\n        set(\"long\", HIR @LONG\n                    \u9b3c         \u9580         \u95dc\n    \u9019\u88cf\u5c31\u662f\u8457\u540d\u7684\u9670\u9593\u5165\u53e3\u300c\u9b3c\u9580\u95dc\u300d\uff0c\u5728\u4f60\u9762\u524d\u77d7\u7acb\u8457\u4e00\u5ea7\u9ad8\u5927\u7684\n\u9ed1\u8272\u57ce\u6a13\uff0c\u8a31\u591a\u4ea1\u9b42\u6b63\u54ed\u54ed\u557c\u557c\u5730\u5217\u968a\u524d\u9032\uff0c\u56e0\u70ba\u4e00\u9032\u9b3c\u9580\u95dc\u5c31\u7121\u6cd5\u518d\n\u56de\u967d\u9593\u4e86\u3002\nLONG NOR );\n        set(\"exits\", ([\n                \"north\" : __DIR__\"gateway\",\n        ]) );\n        set(\"objects\", ([\n                __DIR__\"npc/bai\":1,\n                __DIR__\"npc/ghost\":1,\n        ]) );\n        set(\"no_fight\", 1);\n        set(\"no_magic\", 1);\n        set(\"no_sleep_room\", 1);\n        setup();\n        replace_program(ROOM);\n"]], "pred": {"ppl": 3.2759854793548584, "ppl_lower": 4.660578727722168, "ppl/lowercase_ppl": -1.297080171927429, "ppl/zlib": 0.002838800797965641, "Min_5.0% Prob": 7.519363607679095, "Min_10.0% Prob": 6.0720454454422, "Min_20.0% Prob": 4.596144016299929, "Min_30.0% Prob": 3.5781672455015636, "Min_40.0% Prob": 2.86270559579134, "Min_50.0% Prob": 2.3474122816962857, "Min_60.0% Prob": 1.9728356500688409}}
{"hexsha": "0a3f29fa308f8847bd89f9b4879598e5e829d744", "ext": "c", "lang": "C", "content": "void \ngen_backing_up()\n{\n\tif (reject || num_backing_up == 0)\n\t\treturn;\n\n\tif (fullspd)\n\t\tindent_puts(\"if ( yy_current_state[-1].yy_nxt )\");\n\telse\n\t\tindent_puts(\"if ( yy_accept[yy_current_state] )\");\n\n\tindent_up();\n\tindent_puts(\"{\");\n\tindent_puts(\"YY_G(yy_last_accepting_state) = yy_current_state;\");\n\tindent_puts(\"YY_G(yy_last_accepting_cpos) = yy_cp;\");\n\tindent_puts(\"}\");\n\tindent_down();\n}", "item_id": 3, "repo": "ArrogantWombatics/openbsd-src", "file": "usr.bin/lex/gen.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "0a3f29fa308f8847bd89f9b4879598e5e829d744_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void \ngen_backing_up()\n{\n\tif (reject || num_backing_up == 0)\n\t\treturn;\n\tif (fullspd)\n\t\tindent_puts(\"if ( yy_current_state[-1].yy_nxt )\");\n\telse\n\t\tindent_puts(\"if ( yy_accept[yy_current_state] )\");\n\tindent_up();\n\tindent_puts(\"{\");\n\tindent_puts(\"YY_G(yy_last_accepting_state) = yy_current_state;\");\n\tindent_puts(\"YY_G(yy_last_accepting_cpos) = yy_cp;\");\n\tindent_puts(\"}\");\n\tindent_down();\n"]], "pred": {"ppl": 2.7307870388031006, "ppl_lower": 3.0837514400482178, "ppl/lowercase_ppl": -1.1210016150871467, "ppl/zlib": 0.005259632776180156, "Min_5.0% Prob": 8.927680280473497, "Min_10.0% Prob": 6.939492066701253, "Min_20.0% Prob": 4.492692589759827, "Min_30.0% Prob": 3.189213708855889, "Min_40.0% Prob": 2.480401507999799, "Min_50.0% Prob": 1.994764529735498, "Min_60.0% Prob": 1.6762880071658979}}
{"hexsha": "6ca848b6ed36ed23374562afddbd2c2d216c5484", "ext": "c", "lang": "C", "content": "int uart_open(char* device, int baudrate)\n{\n    int uart_fd;\n    struct termios uart_term;\n\n    uart_fd = open(device, O_RDWR | O_NOCTTY);\n\n    if (uart_fd <= 0)\n        return -1;\n\n    memset(&uart_term, 0, sizeof(uart_term));\n    uart_term.c_cflag = parse_baudrate(baudrate) | CS8 | CLOCAL | CREAD;\n    uart_term.c_iflag = IGNPAR;\n    uart_term.c_oflag = 0;\n\n    /* set noncanonical mode */\n    uart_term.c_lflag = 0;\n    uart_term.c_cc[VTIME] = 30;\n    uart_term.c_cc[VMIN] = 1;\n    tcflush(uart_fd, TCIFLUSH);\n\n    if (tcsetattr(uart_fd, TCSANOW, &uart_term) != 0) {\n        close(uart_fd);\n        return -1;\n    }\n\n    /* Put the fd in non-blocking mode */\n    if (fcntl(uart_fd, F_SETFL, fcntl(uart_fd, F_GETFL) | O_NONBLOCK) < 0) {\n        close(uart_fd);\n        return -1;\n    }\n\n    return uart_fd;\n}", "item_id": 0, "repo": "oubotong/wasm-micro-runtime", "file": "core/iwasm/lib/native/extension/connection/linux/conn_uart.c", "last_update_at": "2019-08-21T02:50:27+00:00", "question_id": "6ca848b6ed36ed23374562afddbd2c2d216c5484_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int uart_open(char* device, int baudrate)\n{\n    int uart_fd;\n    struct termios uart_term;\n    uart_fd = open(device, O_RDWR | O_NOCTTY);\n    if (uart_fd <= 0)\n        return -1;\n    memset(&uart_term, 0, sizeof(uart_term));\n    uart_term.c_cflag = parse_baudrate(baudrate) | CS8 | CLOCAL | CREAD;\n    uart_term.c_iflag = IGNPAR;\n    uart_term.c_oflag = 0;\n    /* set noncanonical mode */\n    uart_term.c_lflag = 0;\n    uart_term.c_cc[VTIME] = 30;\n    uart_term.c_cc[VMIN] = 1;\n    tcflush(uart_fd, TCIFLUSH);\n    if (tcsetattr(uart_fd, TCSANOW, &uart_term) != 0) {\n        close(uart_fd);\n        return -1;\n    }\n    /* Put the fd in non-blocking mode */\n    if (fcntl(uart_fd, F_SETFL, fcntl(uart_fd, F_GETFL) | O_NONBLOCK) < 0) {\n        close(uart_fd);\n        return -1;\n    }\n    return uart_fd;\n"]], "pred": {"ppl": 1.4717035293579102, "ppl_lower": 1.6773037910461426, "ppl/lowercase_ppl": -1.3384059412036444, "ppl/zlib": 0.0010168962982511362, "Min_5.0% Prob": 4.719873365602996, "Min_10.0% Prob": 3.105018725520686, "Min_20.0% Prob": 1.8458426610419625, "Min_30.0% Prob": 1.2768912744757377, "Min_40.0% Prob": 0.9668760986165389, "Min_50.0% Prob": 0.7717757814524803, "Min_60.0% Prob": 0.6443670304755449}}
{"hexsha": "71d832f0b5cd9d95837f4850b56004ffa31ae883", "ext": "c", "lang": "C", "content": "void pinta_test_format(wchar *format_string, wchar *format_argument, wchar *expected)\n{\n    PintaException exception = PINTA_OK;\n    wchar *actual_data;\n    i32 test;\n    struct\n    {\n        PintaReference format;\n        PintaReference arguments;\n        PintaReference item;\n        PintaReference actual;\n    } gc;\n    pinta_assert(format_string != NULL);\n    pinta_assert(format_argument != NULL);\n    pinta_assert(expected != NULL);\n\n    PINTA_GC_ENTER(core, gc);\n\n    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_string, wcslen(format_string), &gc.format));\n    PINTA_CHECK(pinta_lib_array_alloc(core, 1, &gc.arguments));\n    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_argument, wcslen(format_argument), &gc.item));\n    PINTA_CHECK(pinta_lib_array_set_item(core, &gc.arguments, 0, &gc.item));\n\n    PINTA_CHECK(pinta_lib_format(core, NULL, &gc.format, &gc.arguments, 0, &gc.actual));\n    PINTA_CHECK(pinta_lib_string_to_string(core, &gc.actual, &gc.actual));\n\n    actual_data = pinta_string_ref_get_data(&gc.actual);\n    test = wcscmp(expected, actual_data);\n    sput_fail_if(test != 0, pinta_tests_message(L\"failed format (%ls, %ls): expected - %ls, actual - %ls\", format_string, format_argument, expected, actual_data));\n    if (test != 0)\n        test++;\n\nPINTA_EXIT:\n    PINTA_GC_EXIT(core);\n    if (exception != PINTA_OK)\n        sput_fail_if(exception != PINTA_OK, \"No exception\");\n}", "item_id": 1, "repo": "marius-klimantavicius/pinta", "file": "Marius.Pinta/tests/format_tests.c", "last_update_at": "2019-12-05T05:05:02+00:00", "question_id": "71d832f0b5cd9d95837f4850b56004ffa31ae883_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void pinta_test_format(wchar *format_string, wchar *format_argument, wchar *expected)\n{\n    PintaException exception = PINTA_OK;\n    wchar *actual_data;\n    i32 test;\n    struct\n    {\n        PintaReference format;\n        PintaReference arguments;\n        PintaReference item;\n        PintaReference actual;\n    } gc;\n    pinta_assert(format_string != NULL);\n    pinta_assert(format_argument != NULL);\n    pinta_assert(expected != NULL);\n    PINTA_GC_ENTER(core, gc);\n    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_string, wcslen(format_string), &gc.format));\n    PINTA_CHECK(pinta_lib_array_alloc(core, 1, &gc.arguments));\n    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_argument, wcslen(format_argument), &gc.item));\n    PINTA_CHECK(pinta_lib_array_set_item(core, &gc.arguments, 0, &gc.item));\n    PINTA_CHECK(pinta_lib_format(core, NULL, &gc.format, &gc.arguments, 0, &gc.actual));\n    PINTA_CHECK(pinta_lib_string_to_string(core, &gc.actual, &gc.actual));\n    actual_data = pinta_string_ref_get_data(&gc.actual);\n    test = wcscmp(expected, actual_data);\n    sput_fail_if(test != 0, pinta_tests_message(L\"failed format (%ls, %ls): expected - %ls, actual - %ls\", format_string, format_argument, expected, actual_data));\n    if (test != 0)\n        test++;\nPINTA_EXIT:\n    PINTA_GC_EXIT(core);\n    if (exception != PINTA_OK)\n        sput_fail_if(exception != PINTA_OK, \"No exception\");\n"]], "pred": {"ppl": 1.8854550123214722, "ppl_lower": 2.256321430206299, "ppl/lowercase_ppl": -1.2831525563439516, "ppl/zlib": 0.001321185786704235, "Min_5.0% Prob": 6.21125525694627, "Min_10.0% Prob": 4.650318040297582, "Min_20.0% Prob": 2.955506938979739, "Min_30.0% Prob": 2.0753336658206165, "Min_40.0% Prob": 1.5827605970203877, "Min_50.0% Prob": 1.2690206554261507, "Min_60.0% Prob": 1.0572619551757374}}
{"hexsha": "ef12aa5090e0f4ce4dfddf312fc5d8455c5c954d", "ext": "h", "lang": "C", "content": "void set_default_parameters(){\n\t\tPI=3.14159265f;\n\t\tn_planes=700;\n\t\tn_rot=5;\n\t\tn_phi=15;\n\t\ttol_angle_rad=0.79f;\n\t\tsmall_radius_factor=4;\n\t\tn_cubes=4;\n\t\tlower_neighbor_bound_neighbors=10;\n\t\tselection_type= CLUSTER;\n\t}", "item_id": 0, "repo": "ohanlonl/qCMAT", "file": "plugins/core/qHoughNormals/src/normals_Hough/pcl/PCL_normEst.h", "last_update_at": "2019-02-03T12:19:42+00:00", "question_id": "ef12aa5090e0f4ce4dfddf312fc5d8455c5c954d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void set_default_parameters(){\n\t\tPI=3.14159265f;\n\t\tn_planes=700;\n\t\tn_rot=5;\n\t\tn_phi=15;\n\t\ttol_angle_rad=0.79f;\n\t\tsmall_radius_factor=4;\n\t\tn_cubes=4;\n\t\tlower_neighbor_bound_neighbors=10;\n\t\tselection_type= CLUSTER;\n"]], "pred": {"ppl": 6.948514938354492, "ppl_lower": 7.046800136566162, "ppl/lowercase_ppl": -1.0072455357567516, "ppl/zlib": 0.011205363923755566, "Min_5.0% Prob": 9.426132043202719, "Min_10.0% Prob": 8.36768384774526, "Min_20.0% Prob": 6.6634370136260985, "Min_30.0% Prob": 5.399180824692185, "Min_40.0% Prob": 4.467548034191132, "Min_50.0% Prob": 3.7753235688132625, "Min_60.0% Prob": 3.1819175000985465}}
{"hexsha": "3da3f62fa9020c0fd3b637aebc8d5b60876041e4", "ext": "c", "lang": "C", "content": "static inline void\nmprq_buf_replace(struct mlx5_rxq_data *rxq, uint16_t rq_idx)\n{\n\tstruct mlx5_mprq_buf *rep = rxq->mprq_repl;\n\tvolatile struct mlx5_wqe_data_seg *wqe =\n\t\t&((volatile struct mlx5_wqe_mprq *)rxq->wqes)[rq_idx].dseg;\n\tvoid *addr;\n\n\tassert(rep != NULL);\n\t/* Replace MPRQ buf. */\n\t(*rxq->mprq_bufs)[rq_idx] = rep;\n\t/* Replace WQE. */\n\taddr = mlx5_mprq_buf_addr(rep);\n\twqe->addr = rte_cpu_to_be_64((uintptr_t)addr);\n\t/* If there's only one MR, no need to replace LKey in WQE. */\n\tif (unlikely(mlx5_mr_btree_len(&rxq->mr_ctrl.cache_bh) > 1))\n\t\twqe->lkey = mlx5_rx_addr2mr(rxq, (uintptr_t)addr);\n\t/* Stash a mbuf for next replacement. */\n\tif (likely(!rte_mempool_get(rxq->mprq_mp, (void **)&rep)))\n\t\trxq->mprq_repl = rep;\n\telse\n\t\trxq->mprq_repl = NULL;\n}", "item_id": 26, "repo": "klement/trex-core", "file": "src/dpdk/drivers/net/mlx5/mlx5_rxtx.c", "last_update_at": "2019-12-29T01:58:06+00:00", "question_id": "3da3f62fa9020c0fd3b637aebc8d5b60876041e4_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void\nmprq_buf_replace(struct mlx5_rxq_data *rxq, uint16_t rq_idx)\n{\n\tstruct mlx5_mprq_buf *rep = rxq->mprq_repl;\n\tvolatile struct mlx5_wqe_data_seg *wqe =\n\t\t&((volatile struct mlx5_wqe_mprq *)rxq->wqes)[rq_idx].dseg;\n\tvoid *addr;\n\tassert(rep != NULL);\n\t/* Replace MPRQ buf. */\n\t(*rxq->mprq_bufs)[rq_idx] = rep;\n\t/* Replace WQE. */\n\taddr = mlx5_mprq_buf_addr(rep);\n\twqe->addr = rte_cpu_to_be_64((uintptr_t)addr);\n\t/* If there's only one MR, no need to replace LKey in WQE. */\n\tif (unlikely(mlx5_mr_btree_len(&rxq->mr_ctrl.cache_bh) > 1))\n\t\twqe->lkey = mlx5_rx_addr2mr(rxq, (uintptr_t)addr);\n\t/* Stash a mbuf for next replacement. */\n\tif (likely(!rte_mempool_get(rxq->mprq_mp, (void **)&rep)))\n\t\trxq->mprq_repl = rep;\n\telse\n\t\trxq->mprq_repl = NULL;\n"]], "pred": {"ppl": 2.1281392574310303, "ppl_lower": 2.2275078296661377, "ppl/lowercase_ppl": -1.0604243704082839, "ppl/zlib": 0.0017982095472865742, "Min_5.0% Prob": 5.76194399281552, "Min_10.0% Prob": 4.615795777394221, "Min_20.0% Prob": 3.3018934971246963, "Min_30.0% Prob": 2.4255436719992223, "Min_40.0% Prob": 1.8635514584506394, "Min_50.0% Prob": 1.5076401994316553, "Min_60.0% Prob": 1.2614809127128188}}
{"hexsha": "2b01b8817817b7912ac39cbd76e17dbb7242e9af", "ext": "c", "lang": "C", "content": "static void __deepcopy_hostent_from_compat(struct hostent *fat , struct hostent *compat ) \n{ int num_addrs ;\n  int i ;\n  char **p ;\n\n  {\n  fat->h_name = __mkptr_string((char *)compat->h_name);\n  fat->h_aliases = __deepcopy_stringarray_from_compat((char **)compat->h_aliases);\n  p = (char **)compat->h_addr_list;\n  num_addrs = 0;\n  while ((unsigned int )(*p) != (unsigned int )((char *)0)) {\n    p = (char **)__trusted_cast((void *)((unsigned long )p +\n                                                                                                   (unsigned long )(1 *\n                                                                                                                    sizeof((*p)))));\n    num_addrs ++;\n  }\n  num_addrs ++;\n  fat->h_addr_list = (char **)wrapperAlloc((unsigned int )num_addrs * sizeof((*(fat->h_addr_list +\n                                                                                0))));\n  i = 0;\n  while (i < num_addrs) {\n    p = (char **)__trusted_cast((void *)((unsigned long )compat->h_addr_list +\n                                                                                                   (unsigned long )((unsigned int )i *\n                                                                                                                    sizeof((*(compat->h_addr_list))))));\n    (*(fat->h_addr_list + i)) = (char *)__mkptr_size((void *)(*p),\n                                                     (unsigned int )compat->h_length);\n    i ++;\n  }\n  return;\n}\n}", "item_id": 87, "repo": "tracer-x/tracer", "file": "src/interpreter/tests/SLICING/MACRO_TESTS/pfinger/pfinger-mine.c", "last_update_at": "2019-10-08T12:16:55+00:00", "question_id": "2b01b8817817b7912ac39cbd76e17dbb7242e9af_87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void __deepcopy_hostent_from_compat(struct hostent *fat , struct hostent *compat ) \n{ int num_addrs ;\n  int i ;\n  char **p ;\n  {\n  fat->h_name = __mkptr_string((char *)compat->h_name);\n  fat->h_aliases = __deepcopy_stringarray_from_compat((char **)compat->h_aliases);\n  p = (char **)compat->h_addr_list;\n  num_addrs = 0;\n  while ((unsigned int )(*p) != (unsigned int )((char *)0)) {\n    p = (char **)__trusted_cast((void *)((unsigned long )p +\n                                                                                                   (unsigned long )(1 *\n                                                                                                                    sizeof((*p)))));\n    num_addrs ++;\n  }\n  num_addrs ++;\n  fat->h_addr_list = (char **)wrapperAlloc((unsigned int )num_addrs * sizeof((*(fat->h_addr_list +\n                                                                                0))));\n  i = 0;\n  while (i < num_addrs) {\n    p = (char **)__trusted_cast((void *)((unsigned long )compat->h_addr_list +\n                                                                                                   (unsigned long )((unsigned int )i *\n                                                                                                                    sizeof((*(compat->h_addr_list))))));\n    (*(fat->h_addr_list + i)) = (char *)__mkptr_size((void *)(*p),\n                                                     (unsigned int )compat->h_length);\n    i ++;\n  }\n  return;\n}\n"]], "pred": {"ppl": 2.1214382648468018, "ppl_lower": 2.118077278137207, "ppl/lowercase_ppl": -0.9978918167370522, "ppl/zlib": 0.0020272083166334525, "Min_5.0% Prob": 6.987782096862793, "Min_10.0% Prob": 5.024808563837191, "Min_20.0% Prob": 3.326823013584788, "Min_30.0% Prob": 2.426240963080237, "Min_40.0% Prob": 1.8716139762239024, "Min_50.0% Prob": 1.5009398442211646, "Min_60.0% Prob": 1.2546322952839546}}
{"hexsha": "54255194feb90b09a23b5a9043461f03b23abb7f", "ext": "c", "lang": "C", "content": "retval_t SH7x_measure_temperature(uint16_t* temp){\n    retval_t rv;\n    uint8_t aux[2];\n    uint8_t checksum;\n\n    SH7x_start_transmission();\n    rv = SH7x_write_byte(SH7x_CMD_MEASURE_TEMPERATURE);\n    if(RV_SUCCESS != rv){\n        SH7x_hard_reset();\n        return rv;\n    }\n    SH7x_data_as_input();\n    // TODO: Add timeout here. This can hang out if chip never answer \n    while (IsBitSet(sensor_th_data_PIN, sensor_th_data_PIN_NUMBER)){}//wait until sensor has finished the measurement\n\n    SH7x_read_byte(&aux[0], true);\n    SH7x_read_byte(&aux[1], true);\n    SH7x_read_byte(&checksum, false);\n    rv = SH7x_checksum(aux, checksum);\n    if(RV_SUCCESS == rv){\n        *temp = (aux[0]<<8) | aux[1];\n    }\n\n    return rv;\n}", "item_id": 5, "repo": "xcancerberox/SHT7x_AVR", "file": "test_code.c", "last_update_at": "2019-08-20T10:52:35+00:00", "question_id": "54255194feb90b09a23b5a9043461f03b23abb7f_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["retval_t SH7x_measure_temperature(uint16_t* temp){\n    retval_t rv;\n    uint8_t aux[2];\n    uint8_t checksum;\n    SH7x_start_transmission();\n    rv = SH7x_write_byte(SH7x_CMD_MEASURE_TEMPERATURE);\n    if(RV_SUCCESS != rv){\n        SH7x_hard_reset();\n        return rv;\n    }\n    SH7x_data_as_input();\n    // TODO: Add timeout here. This can hang out if chip never answer \n    while (IsBitSet(sensor_th_data_PIN, sensor_th_data_PIN_NUMBER)){}//wait until sensor has finished the measurement\n    SH7x_read_byte(&aux[0], true);\n    SH7x_read_byte(&aux[1], true);\n    SH7x_read_byte(&checksum, false);\n    rv = SH7x_checksum(aux, checksum);\n    if(RV_SUCCESS == rv){\n        *temp = (aux[0]<<8) | aux[1];\n    }\n    return rv;\n"]], "pred": {"ppl": 3.358096122741699, "ppl_lower": 3.626615047454834, "ppl/lowercase_ppl": -1.0635027039875455, "ppl/zlib": 0.003154620268862473, "Min_5.0% Prob": 8.575352225984846, "Min_10.0% Prob": 6.6412439592953385, "Min_20.0% Prob": 4.6813611499333785, "Min_30.0% Prob": 3.630683237247253, "Min_40.0% Prob": 2.909264039592583, "Min_50.0% Prob": 2.393150631813395, "Min_60.0% Prob": 2.0131266873392315}}
{"hexsha": "796c3d77ce18291a13bc00e8da5f5fb41faa34cc", "ext": "c", "lang": "C", "content": "void\npms_proc_elantech_v4(struct pms_softc *sc)\n{\n\tstruct elantech_softc *elantech = sc->elantech;\n\tstruct device *sc_wsmousedev = sc->sc_wsmousedev;\n\tint id, weight, n, x, y, z;\n\tu_int buttons, slots;\n\n\tswitch (sc->packet[3] & 0x1f) {\n\tcase ELANTECH_V4_PKT_STATUS:\n\t\tslots = elantech->mt_slots;\n\t\telantech->mt_slots = sc->packet[1] & 0x1f;\n\t\tslots &= ~elantech->mt_slots;\n\t\tfor (id = 0; slots; id++, slots >>= 1) {\n\t\t\tif (slots & 1)\n\t\t\t\twsmouse_mtstate(sc_wsmousedev, id, 0, 0, 0);\n\t\t}\n\t\tbreak;\n\n\tcase ELANTECH_V4_PKT_HEAD:\n\t\tid = ((sc->packet[3] & 0xe0) >> 5) - 1;\n\t\tif (id > -1 && id < ELANTECH_MAX_FINGERS) {\n\t\t\tx = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];\n\t\t\ty = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];\n\t\t\tz = (sc->packet[1] & 0xf0)\n\t\t\t    | ((sc->packet[4] & 0xf0) >> 4);\n\t\t\twsmouse_mtstate(sc_wsmousedev, id, x, y, z);\n\t\t}\n\t\tbreak;\n\n\tcase ELANTECH_V4_PKT_MOTION:\n\t\tweight = (sc->packet[0] & 0x10) ? ELANTECH_V4_WEIGHT_VALUE : 1;\n\t\tfor (n = 0; n < 6; n += 3) {\n\t\t\tid = ((sc->packet[n] & 0xe0) >> 5) - 1;\n\t\t\tif (id < 0 || id >= ELANTECH_MAX_FINGERS)\n\t\t\t\tcontinue;\n\t\t\tx = weight * (signed char)sc->packet[n + 1];\n\t\t\ty = weight * (signed char)sc->packet[n + 2];\n\t\t\tz = WSMOUSE_DEFAULT_PRESSURE;\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_X, x, id);\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_Y, y, id);\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_PRESSURE, z, id);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unknown packet type 0x%x\\n\", DEVNAME(sc),\n\t\t    sc->packet[3] & 0x1f);\n\t\treturn;\n\t}\n\n\tbuttons = 0;\n\tif (sc->packet[0] & 0x01)\n\t\tbuttons |= WSMOUSE_BUTTON(1);\n\tif (sc->packet[0] & 0x02)\n\t\tbuttons |= WSMOUSE_BUTTON(3);\n\twsmouse_buttons(sc_wsmousedev, buttons);\n\n\twsmouse_input_sync(sc_wsmousedev);\n}", "item_id": 59, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/dev/pckbc/pms.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "796c3d77ce18291a13bc00e8da5f5fb41faa34cc_59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\npms_proc_elantech_v4(struct pms_softc *sc)\n{\n\tstruct elantech_softc *elantech = sc->elantech;\n\tstruct device *sc_wsmousedev = sc->sc_wsmousedev;\n\tint id, weight, n, x, y, z;\n\tu_int buttons, slots;\n\tswitch (sc->packet[3] & 0x1f) {\n\tcase ELANTECH_V4_PKT_STATUS:\n\t\tslots = elantech->mt_slots;\n\t\telantech->mt_slots = sc->packet[1] & 0x1f;\n\t\tslots &= ~elantech->mt_slots;\n\t\tfor (id = 0; slots; id++, slots >>= 1) {\n\t\t\tif (slots & 1)\n\t\t\t\twsmouse_mtstate(sc_wsmousedev, id, 0, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase ELANTECH_V4_PKT_HEAD:\n\t\tid = ((sc->packet[3] & 0xe0) >> 5) - 1;\n\t\tif (id > -1 && id < ELANTECH_MAX_FINGERS) {\n\t\t\tx = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];\n\t\t\ty = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];\n\t\t\tz = (sc->packet[1] & 0xf0)\n\t\t\t    | ((sc->packet[4] & 0xf0) >> 4);\n\t\t\twsmouse_mtstate(sc_wsmousedev, id, x, y, z);\n\t\t}\n\t\tbreak;\n\tcase ELANTECH_V4_PKT_MOTION:\n\t\tweight = (sc->packet[0] & 0x10) ? ELANTECH_V4_WEIGHT_VALUE : 1;\n\t\tfor (n = 0; n < 6; n += 3) {\n\t\t\tid = ((sc->packet[n] & 0xe0) >> 5) - 1;\n\t\t\tif (id < 0 || id >= ELANTECH_MAX_FINGERS)\n\t\t\t\tcontinue;\n\t\t\tx = weight * (signed char)sc->packet[n + 1];\n\t\t\ty = weight * (signed char)sc->packet[n + 2];\n\t\t\tz = WSMOUSE_DEFAULT_PRESSURE;\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_X, x, id);\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_Y, y, id);\n\t\t\twsmouse_set(sc_wsmousedev, WSMOUSE_MT_PRESSURE, z, id);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown packet type 0x%x\\n\", DEVNAME(sc),\n\t\t    sc->packet[3] & 0x1f);\n\t\treturn;\n\t}\n\tbuttons = 0;\n\tif (sc->packet[0] & 0x01)\n\t\tbuttons |= WSMOUSE_BUTTON(1);\n\tif (sc->packet[0] & 0x02)\n\t\tbuttons |= WSMOUSE_BUTTON(3);\n\twsmouse_buttons(sc_wsmousedev, buttons);\n\twsmouse_input_sync(sc_wsmousedev);\n"]], "pred": {"ppl": 1.7298007011413574, "ppl_lower": 1.801378607749939, "ppl/lowercase_ppl": -1.0739883320892663, "ppl/zlib": 0.0007942118843783667, "Min_5.0% Prob": 5.966447323560715, "Min_10.0% Prob": 4.195124354213476, "Min_20.0% Prob": 2.5820354015255966, "Min_30.0% Prob": 1.7969721609260887, "Min_40.0% Prob": 1.3646445034925516, "Min_50.0% Prob": 1.095586573848656, "Min_60.0% Prob": 0.9139185713958997}}
{"hexsha": "79eddc387aa98a040dbabdb3879e516c5f6481d6", "ext": "c", "lang": "C", "content": "void sg_strsubpool__alloc(\n        SG_context* pCtx,\n        SG_uint32 space,\n        sg_strsubpool* pNext,\n        sg_strsubpool** ppNew\n        )\n{\n\tsg_strsubpool* pThis = NULL;\n\n\tSG_ERR_CHECK_RETURN(  SG_alloc1(pCtx, pThis)  );\n\n\tpThis->space = space;\n\n\tSG_ERR_CHECK(  SG_allocN(pCtx, space,pThis->pBytes)  );\n\n\tpThis->pNext = pNext;\n\tpThis->count = 0;\n\n\t*ppNew = pThis;\n\treturn;\n\nfail:\n\tSG_ERR_IGNORE(  sg_strsubpool__free(pCtx, pThis)  );\n}", "item_id": 0, "repo": "avar/veracity", "file": "src/libraries/ut/sg_strpool.c", "last_update_at": "2019-12-28T18:15:09+00:00", "question_id": "79eddc387aa98a040dbabdb3879e516c5f6481d6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void sg_strsubpool__alloc(\n        SG_context* pCtx,\n        SG_uint32 space,\n        sg_strsubpool* pNext,\n        sg_strsubpool** ppNew\n        )\n{\n\tsg_strsubpool* pThis = NULL;\n\tSG_ERR_CHECK_RETURN(  SG_alloc1(pCtx, pThis)  );\n\tpThis->space = space;\n\tSG_ERR_CHECK(  SG_allocN(pCtx, space,pThis->pBytes)  );\n\tpThis->pNext = pNext;\n\tpThis->count = 0;\n\t*ppNew = pThis;\n\treturn;\nfail:\n\tSG_ERR_IGNORE(  sg_strsubpool__free(pCtx, pThis)  );\n"]], "pred": {"ppl": 2.0588181018829346, "ppl_lower": 3.0368008613586426, "ppl/lowercase_ppl": -1.538229143933861, "ppl/zlib": 0.003209475916450817, "Min_5.0% Prob": 7.265260410308838, "Min_10.0% Prob": 5.194621006647746, "Min_20.0% Prob": 3.300381186462584, "Min_30.0% Prob": 2.337599587161094, "Min_40.0% Prob": 1.7986487279043477, "Min_50.0% Prob": 1.4408836634568523, "Min_60.0% Prob": 1.2062670431987499}}
{"hexsha": "a1671a1f7045fb2dbf8b721380b1a8f08c4c5069", "ext": "c", "lang": "C", "content": "void HandleInput()\n{\n    SceCtrlData pad;\n    sceCtrlPeekBufferPositive(&pad, 1);\n\n    uint8_t controls_state = 0;\n    if (pad.Buttons & PSP_CTRL_RIGHT ) controls_state |= 0x01;\n    if (pad.Buttons & PSP_CTRL_LEFT  ) controls_state |= 0x02;\n    if (pad.Buttons & PSP_CTRL_DOWN  ) controls_state |= 0x04;\n    if (pad.Buttons & PSP_CTRL_UP    ) controls_state |= 0x08;\n    if (pad.Buttons & PSP_CTRL_CROSS ) controls_state |= 0x10;\n    if (pad.Buttons & PSP_CTRL_SQUARE) controls_state |= 0x20;\n    if (pad.Buttons & PSP_CTRL_SELECT) controls_state |= 0x40;\n    if (pad.Buttons & PSP_CTRL_START ) controls_state |= 0x80;\n\n    supervision_set_input(controls_state);\n}", "item_id": 1, "repo": "liberodark/potator", "file": "platform/PSP/main.c", "last_update_at": "2019-11-05T01:08:25+00:00", "question_id": "a1671a1f7045fb2dbf8b721380b1a8f08c4c5069_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void HandleInput()\n{\n    SceCtrlData pad;\n    sceCtrlPeekBufferPositive(&pad, 1);\n    uint8_t controls_state = 0;\n    if (pad.Buttons & PSP_CTRL_RIGHT ) controls_state |= 0x01;\n    if (pad.Buttons & PSP_CTRL_LEFT  ) controls_state |= 0x02;\n    if (pad.Buttons & PSP_CTRL_DOWN  ) controls_state |= 0x04;\n    if (pad.Buttons & PSP_CTRL_UP    ) controls_state |= 0x08;\n    if (pad.Buttons & PSP_CTRL_CROSS ) controls_state |= 0x10;\n    if (pad.Buttons & PSP_CTRL_SQUARE) controls_state |= 0x20;\n    if (pad.Buttons & PSP_CTRL_SELECT) controls_state |= 0x40;\n    if (pad.Buttons & PSP_CTRL_START ) controls_state |= 0x80;\n    supervision_set_input(controls_state);\n"]], "pred": {"ppl": 1.5786423683166504, "ppl_lower": 1.9579187631607056, "ppl/lowercase_ppl": -1.4716014895006355, "ppl/zlib": 0.0019183412483354226, "Min_5.0% Prob": 6.65415232522147, "Min_10.0% Prob": 4.172081791121384, "Min_20.0% Prob": 2.2916940990193138, "Min_30.0% Prob": 1.5227513357107951, "Min_40.0% Prob": 1.146770227394011, "Min_50.0% Prob": 0.9130072038783851, "Min_60.0% Prob": 0.762639227756815}}
{"hexsha": "f8de45ca4fd5e1609733bdb3cb7522c564fdf6b0", "ext": "c", "lang": "C", "content": "void *myprocess(void *arg) {\n    printf(\"threadid is 0x%x, working on task %d\\n\", pthread_self(),\n           *(int *)arg);\n    /*\u4f11\u606f\u4e00\u79d2\uff0c\u5ef6\u957f\u4efb\u52a1\u7684\u6267\u884c\u65f6\u95f4*/\n    sleep(1);\n    return NULL;\n}", "item_id": 0, "repo": "aqnotecom/c.library", "file": "apps/thread.threadpool/src/main.c", "last_update_at": "2019-09-27T08:11:17+00:00", "question_id": "f8de45ca4fd5e1609733bdb3cb7522c564fdf6b0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *myprocess(void *arg) {\n    printf(\"threadid is 0x%x, working on task %d\\n\", pthread_self(),\n           *(int *)arg);\n    /*\u4f11\u606f\u4e00\u79d2\uff0c\u5ef6\u957f\u4efb\u52a1\u7684\u6267\u884c\u65f6\u95f4*/\n    sleep(1);\n    return NULL;\n"]], "pred": {"ppl": 3.9120805263519287, "ppl_lower": 4.1767964363098145, "ppl/lowercase_ppl": -1.047999915949426, "ppl/zlib": 0.007333706109712386, "Min_5.0% Prob": 8.480286836624146, "Min_10.0% Prob": 6.9797243475914, "Min_20.0% Prob": 5.040820062160492, "Min_30.0% Prob": 3.9827424734830856, "Min_40.0% Prob": 3.2040581703186035, "Min_50.0% Prob": 2.6874084756141756, "Min_60.0% Prob": 2.291785345089679}}
{"hexsha": "aaf74a0767311735502f9122d15872b54cc32bfe", "ext": "c", "lang": "C", "content": "MagickExport MagickBooleanType SetImageColorspace(Image *image,\n  const ColorspaceType colorspace)\n{\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (colorspace == UndefinedColorspace)\n    {\n      image->colorspace=UndefinedColorspace;\n      return(MagickTrue);\n    }\n  if (image->colorspace == colorspace)\n    return(MagickTrue);\n  if ((colorspace == RGBColorspace) || (colorspace == TransparentColorspace))\n    return(TransformRGBImage(image,image->colorspace));\n  status=MagickTrue;\n  if ((image->colorspace != RGBColorspace) &&\n      (image->colorspace != TransparentColorspace) &&\n      (image->colorspace != GRAYColorspace))\n    status=TransformRGBImage(image,image->colorspace);\n  if (RGBTransformImage(image,colorspace) == MagickFalse)\n    status=MagickFalse;\n  return(status);\n}", "item_id": 3, "repo": "KiiCorp/ImageMagick", "file": "magick/colorspace.c", "last_update_at": "2019-10-12T09:55:12+00:00", "question_id": "aaf74a0767311735502f9122d15872b54cc32bfe_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MagickExport MagickBooleanType SetImageColorspace(Image *image,\n  const ColorspaceType colorspace)\n{\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (colorspace == UndefinedColorspace)\n    {\n      image->colorspace=UndefinedColorspace;\n      return(MagickTrue);\n    }\n  if (image->colorspace == colorspace)\n    return(MagickTrue);\n  if ((colorspace == RGBColorspace) || (colorspace == TransparentColorspace))\n    return(TransformRGBImage(image,image->colorspace));\n  status=MagickTrue;\n  if ((image->colorspace != RGBColorspace) &&\n      (image->colorspace != TransparentColorspace) &&\n      (image->colorspace != GRAYColorspace))\n    status=TransformRGBImage(image,image->colorspace);\n  if (RGBTransformImage(image,colorspace) == MagickFalse)\n    status=MagickFalse;\n  return(status);\n"]], "pred": {"ppl": 1.570756435394287, "ppl_lower": 2.7238712310791016, "ppl/lowercase_ppl": -2.219107286067236, "ppl/zlib": 0.0012543258592016787, "Min_5.0% Prob": 5.447918891906738, "Min_10.0% Prob": 3.5517815868059794, "Min_20.0% Prob": 2.1612264201045037, "Min_30.0% Prob": 1.5037729108499156, "Min_40.0% Prob": 1.128517599660934, "Min_50.0% Prob": 0.9056574131935736, "Min_60.0% Prob": 0.7558061818879108}}
{"hexsha": "1e73e68c0798fa3b523b939f2dc3bd8ab551d6b8", "ext": "c", "lang": "C", "content": "static void port_event(LV2UI_Handle handle, uint32_t port_index,\n                        uint32_t buffer_size, uint32_t format,\n                        const void * buffer) {\n    X11_UI* ui = (X11_UI*)handle;\n    float value = *(float*)buffer;\n    if (port_index == GAIN) {\n        check_value_changed(ui->widget->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == VOWEL) {\n        check_value_changed(ui->win->adj_x, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == NOTE) {\n        check_value_changed(ui->win->adj_y, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == GATE) {\n        adj_changed(ui->win, GATE, value);\n    }  else if (port_index == MIDIVOWEL) {\n        if (ui->ignore_midi_vowel) {\n            ui->ignore_midi_vowel = false;\n            return;\n        }\n        if (ui->midi_vowel != value) {\n            if(value>-0.1 && value<4.1) {\n                check_value_changed(ui->win->adj_x, &value);\n                // prevent event loop between host and plugin\n                ui->block_event = VOWEL;\n                ui->midi_vowel = value;\n            }\n        }\n    } else if (port_index == MIDINOTE) {\n        if (ui->ignore_midi_note) {\n            ui->ignore_midi_note = false;\n            return;\n        }\n        if (ui->midi_note != value) {\n            if(value >-1.0 && value<127.0) {\n                check_value_changed(ui->win->adj_y, &value);\n                // prevent event loop between host and plugin\n                ui->block_event = NOTE;\n                ui->midi_note = value;\n            }\n        }\n    } else if (port_index == MIDIGATE) {\n        if (ui->ignore_midi_gate) {\n            ui->ignore_midi_gate = false;\n            return;\n        }\n        if (ui->midi_gate != value) {\n            if(value>-0.1 && value<1.1) {\n                adj_changed(ui->win, GATE, value);\n                ui->midi_gate = value;\n            }\n        }\n    } else if (port_index == SCALE) {\n        check_value_changed(ui->button->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == SUSTAIN) {\n        check_value_changed(ui->sustain_slider->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == PANIC) {\n        ui->panic = value;\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    }\n}", "item_id": 18, "repo": "brummer10/Xmonk.lv2", "file": "Xmonk/gui/Xmonk_x11ui.c", "last_update_at": "2019-11-10T23:35:46+00:00", "question_id": "1e73e68c0798fa3b523b939f2dc3bd8ab551d6b8_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void port_event(LV2UI_Handle handle, uint32_t port_index,\n                        uint32_t buffer_size, uint32_t format,\n                        const void * buffer) {\n    X11_UI* ui = (X11_UI*)handle;\n    float value = *(float*)buffer;\n    if (port_index == GAIN) {\n        check_value_changed(ui->widget->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == VOWEL) {\n        check_value_changed(ui->win->adj_x, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == NOTE) {\n        check_value_changed(ui->win->adj_y, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == GATE) {\n        adj_changed(ui->win, GATE, value);\n    }  else if (port_index == MIDIVOWEL) {\n        if (ui->ignore_midi_vowel) {\n            ui->ignore_midi_vowel = false;\n            return;\n        }\n        if (ui->midi_vowel != value) {\n            if(value>-0.1 && value<4.1) {\n                check_value_changed(ui->win->adj_x, &value);\n                // prevent event loop between host and plugin\n                ui->block_event = VOWEL;\n                ui->midi_vowel = value;\n            }\n        }\n    } else if (port_index == MIDINOTE) {\n        if (ui->ignore_midi_note) {\n            ui->ignore_midi_note = false;\n            return;\n        }\n        if (ui->midi_note != value) {\n            if(value >-1.0 && value<127.0) {\n                check_value_changed(ui->win->adj_y, &value);\n                // prevent event loop between host and plugin\n                ui->block_event = NOTE;\n                ui->midi_note = value;\n            }\n        }\n    } else if (port_index == MIDIGATE) {\n        if (ui->ignore_midi_gate) {\n            ui->ignore_midi_gate = false;\n            return;\n        }\n        if (ui->midi_gate != value) {\n            if(value>-0.1 && value<1.1) {\n                adj_changed(ui->win, GATE, value);\n                ui->midi_gate = value;\n            }\n        }\n    } else if (port_index == SCALE) {\n        check_value_changed(ui->button->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == SUSTAIN) {\n        check_value_changed(ui->sustain_slider->adj, &value);\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    } else if (port_index == PANIC) {\n        ui->panic = value;\n        // prevent event loop between host and plugin\n        ui->block_event = (int)port_index;\n    }\n"]], "pred": {"ppl": 1.653298258781433, "ppl_lower": 1.728327751159668, "ppl/lowercase_ppl": -1.0882747345784654, "ppl/zlib": 0.0009380079055913863, "Min_5.0% Prob": 5.844471636272612, "Min_10.0% Prob": 4.0422548266018135, "Min_20.0% Prob": 2.4054249173019366, "Min_30.0% Prob": 1.6606029201777297, "Min_40.0% Prob": 1.2558272906432026, "Min_50.0% Prob": 1.0054089560969863, "Min_60.0% Prob": 0.8378677122858408}}
{"hexsha": "88b81c8fec68caeb54430ee1950e9941248d99a1", "ext": "c", "lang": "C", "content": "Item_Set\nnewItem_Set(relevant) Relevant relevant;\n{\n\tItem_Set ts;\n\t\n\tif (fptr) {\n\t\tts = fptr;\n\t\tfptr = 0;\n\t\tmemset(ts->virgin, 0, max_nonterminal * sizeof(struct item));\n\t\tif (ts->closed) {\n\t\t\tzfree(ts->closed);\n\t\t\tts->closed = 0;\n\t\t}\n\t\tts->num = 0;\n\t\tts->op = 0;\n\t} else {\n\t\tts = (Item_Set) zalloc(sizeof(struct item_set));\n\t\tts->virgin = newItemArray();\n\t}\n\tts->relevant = relevant;\n\treturn ts;\n}", "item_id": 2, "repo": "nettrino/IntFlow", "file": "projects/test-suite/MultiSource/Applications/Burg/item.c", "last_update_at": "2019-07-20T14:46:20+00:00", "question_id": "88b81c8fec68caeb54430ee1950e9941248d99a1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Item_Set\nnewItem_Set(relevant) Relevant relevant;\n{\n\tItem_Set ts;\n\t\n\tif (fptr) {\n\t\tts = fptr;\n\t\tfptr = 0;\n\t\tmemset(ts->virgin, 0, max_nonterminal * sizeof(struct item));\n\t\tif (ts->closed) {\n\t\t\tzfree(ts->closed);\n\t\t\tts->closed = 0;\n\t\t}\n\t\tts->num = 0;\n\t\tts->op = 0;\n\t} else {\n\t\tts = (Item_Set) zalloc(sizeof(struct item_set));\n\t\tts->virgin = newItemArray();\n\t}\n\tts->relevant = relevant;\n\treturn ts;\n"]], "pred": {"ppl": 3.491698980331421, "ppl_lower": 3.7619056701660156, "ppl/lowercase_ppl": -1.0596112557414028, "ppl/zlib": 0.005657866206368603, "Min_5.0% Prob": 8.946104155646431, "Min_10.0% Prob": 7.517390304141575, "Min_20.0% Prob": 5.211911359348813, "Min_30.0% Prob": 3.856205032340118, "Min_40.0% Prob": 3.036471912066142, "Min_50.0% Prob": 2.4794963338273637, "Min_60.0% Prob": 2.0802025504871806}}
{"hexsha": "8236759bd6d271082df7875f3e37018ff108c156", "ext": "c", "lang": "C", "content": "LIST_ITEM* \nLQListFindFromHead( \n\tIN LOCKED_QUICK_LIST* const pLQuickList,\n\tIN QLIST_FIND_FUNC pfnFunc OPTIONAL,\n\tIN void* const Context )\n{\n\tLIST_ITEM\t*pListItem;\n\n\tASSERT( pLQuickList );\n\tSpinLockAcquire(&pLQuickList->m_Lock);\n\tpListItem = QListFindFromHead(&pLQuickList->m_List, pfnFunc, Context);\n\tSpinLockRelease(&pLQuickList->m_Lock);\n\n\treturn pListItem;\n}", "item_id": 25, "repo": "dsilakov/opa-fm", "file": "IbAccess/Common/Public/ilist.c", "last_update_at": "2019-05-14T09:56:19+00:00", "question_id": "8236759bd6d271082df7875f3e37018ff108c156_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LIST_ITEM* \nLQListFindFromHead( \n\tIN LOCKED_QUICK_LIST* const pLQuickList,\n\tIN QLIST_FIND_FUNC pfnFunc OPTIONAL,\n\tIN void* const Context )\n{\n\tLIST_ITEM\t*pListItem;\n\tASSERT( pLQuickList );\n\tSpinLockAcquire(&pLQuickList->m_Lock);\n\tpListItem = QListFindFromHead(&pLQuickList->m_List, pfnFunc, Context);\n\tSpinLockRelease(&pLQuickList->m_Lock);\n\treturn pListItem;\n"]], "pred": {"ppl": 3.218398332595825, "ppl_lower": 4.71833610534668, "ppl/lowercase_ppl": -1.3272971925110117, "ppl/zlib": 0.005462073941908833, "Min_5.0% Prob": 7.7883360385894775, "Min_10.0% Prob": 6.5152595937252045, "Min_20.0% Prob": 4.870229408144951, "Min_30.0% Prob": 3.674315116057793, "Min_40.0% Prob": 2.87426895624958, "Min_50.0% Prob": 2.3229888658039273, "Min_60.0% Prob": 1.9445286130843062}}
{"hexsha": "2446b2391d762731620c4ba8d3b73a3110382ff3", "ext": "c", "lang": "C", "content": "float64_t f64_sub( float64_t a, float64_t b )\n{\n    union ui64_f64 uA;\n    uint_fast64_t uiA;\n    bool signA;\n    union ui64_f64 uB;\n    uint_fast64_t uiB;\n    bool signB;\n#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)\n    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );\n#endif\n\n    uA.f = a;\n    uiA = uA.ui;\n    signA = signF64UI( uiA );\n    uB.f = b;\n    uiB = uB.ui;\n    signB = signF64UI( uiB );\n#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)\n    if ( signA == signB ) {\n        return softfloat_subMagsF64( uiA, uiB, signA );\n    } else {\n        return softfloat_addMagsF64( uiA, uiB, signA );\n    }\n#else\n    magsFuncPtr =\n        (signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;\n    return (*magsFuncPtr)( uiA, uiB, signA );\n#endif\n\n}", "item_id": 58, "repo": "Codasip/riscv-compliance", "file": "riscv-ovpsim/source/riscvSoftFloat.c", "last_update_at": "2019-01-01T03:34:26+00:00", "question_id": "2446b2391d762731620c4ba8d3b73a3110382ff3_58", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["float64_t f64_sub( float64_t a, float64_t b )\n{\n    union ui64_f64 uA;\n    uint_fast64_t uiA;\n    bool signA;\n    union ui64_f64 uB;\n    uint_fast64_t uiB;\n    bool signB;\n#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)\n    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );\n#endif\n    uA.f = a;\n    uiA = uA.ui;\n    signA = signF64UI( uiA );\n    uB.f = b;\n    uiB = uB.ui;\n    signB = signF64UI( uiB );\n#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)\n    if ( signA == signB ) {\n        return softfloat_subMagsF64( uiA, uiB, signA );\n    } else {\n        return softfloat_addMagsF64( uiA, uiB, signA );\n    }\n#else\n    magsFuncPtr =\n        (signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;\n    return (*magsFuncPtr)( uiA, uiB, signA );\n#endif\n"]], "pred": {"ppl": 1.2310816049575806, "ppl_lower": 1.575618863105774, "ppl/lowercase_ppl": -2.186931860691621, "ppl/zlib": 0.0006749777162450814, "Min_5.0% Prob": 3.17831418911616, "Min_10.0% Prob": 1.9357082040773497, "Min_20.0% Prob": 1.0327405425099034, "Min_30.0% Prob": 0.6932398406702474, "Min_40.0% Prob": 0.520786337913402, "Min_50.0% Prob": 0.41684295806982036, "Min_60.0% Prob": 0.3474318339838781}}
{"hexsha": "9ab3cb3477d6432ff0ae46a58a57e10a1c0b7787", "ext": "c", "lang": "C", "content": "void get_response(int sock, char *buf)\n{\n\t/* This function gets a response from the\n\t   server in the form of a character string. */\n\n\tint n;\n\n\tn=read(sock,buf,625);\n\n\tif (n<0)\n\t{\n\t\tif (errno==EINTR)\n\t\t\treturn;\n\n\t\tif (errno==ECONNREFUSED)\n\t\t{\n\t\t\tfprintf(stderr, \"Connection refused - server not running\\n\");\n\t\t\texit (1);\n\t\t}\n\t}\n\n\tbuf[n]='\\0';\n}", "item_id": 1, "repo": "abrahamneben/orbcomm_beam_mapping", "file": "daq/predict-2.2.2/clients/earthtrack/old_version/earthtrack.c", "last_update_at": "2019-04-10T02:50:19+00:00", "question_id": "9ab3cb3477d6432ff0ae46a58a57e10a1c0b7787_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void get_response(int sock, char *buf)\n{\n\t/* This function gets a response from the\n\t   server in the form of a character string. */\n\tint n;\n\tn=read(sock,buf,625);\n\tif (n<0)\n\t{\n\t\tif (errno==EINTR)\n\t\t\treturn;\n\t\tif (errno==ECONNREFUSED)\n\t\t{\n\t\t\tfprintf(stderr, \"Connection refused - server not running\\n\");\n\t\t\texit (1);\n\t\t}\n\t}\n\tbuf[n]='\\0';\n"]], "pred": {"ppl": 2.6746561527252197, "ppl_lower": 3.0730366706848145, "ppl/lowercase_ppl": -1.1411287307954054, "ppl/zlib": 0.003919604904575943, "Min_5.0% Prob": 6.535646711077009, "Min_10.0% Prob": 5.175132131576538, "Min_20.0% Prob": 3.5898313791521135, "Min_30.0% Prob": 2.793761354811648, "Min_40.0% Prob": 2.314492582313476, "Min_50.0% Prob": 1.93249539572459, "Min_60.0% Prob": 1.6307465887450157}}
{"hexsha": "382c7db25b9f346680ed2a8d235e5423f0a83160", "ext": "c", "lang": "C", "content": "weather_values    weather_seven_values(n_int px, n_int py)\n{\n    n_byte    ret_val;\n    n_int    val;\n    n_int   map_x = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(px));\n    n_int   map_y = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(py));\n    \n    if(IS_DAWNDUSK(m_land.time))\n    {\n        return WEATHER_SEVEN_DAWN_DUSK;\n    }\n    if(IS_NIGHT(m_land.time))\n    {\n        ret_val = WEATHER_SEVEN_CLEAR_NIGHT;\n    }\n    else\n    {\n        ret_val = WEATHER_SEVEN_SUNNY_DAY;\n    }\n    \n    val = weather_pressure(map_x, map_y);\n    \n    if ( val == -1)\n    {\n        return WEATHER_SEVEN_ERROR; /* Error has already been shown */\n    }\n    \n    if(val > WEATHER_RAIN)\n    {\n        return ret_val+2;\n    }\n    if(val > WEATHER_CLOUD)\n    {\n        return ret_val+1;\n    }\n    \n    return ret_val;\n}", "item_id": 4, "repo": "barbalet/nobleape", "file": "sim/land.c", "last_update_at": "2019-12-04T23:02:30+00:00", "question_id": "382c7db25b9f346680ed2a8d235e5423f0a83160_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["weather_values    weather_seven_values(n_int px, n_int py)\n{\n    n_byte    ret_val;\n    n_int    val;\n    n_int   map_x = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(px));\n    n_int   map_y = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(py));\n    if(IS_DAWNDUSK(m_land.time))\n    {\n        return WEATHER_SEVEN_DAWN_DUSK;\n    }\n    if(IS_NIGHT(m_land.time))\n    {\n        ret_val = WEATHER_SEVEN_CLEAR_NIGHT;\n    }\n    else\n    {\n        ret_val = WEATHER_SEVEN_SUNNY_DAY;\n    }\n    val = weather_pressure(map_x, map_y);\n    if ( val == -1)\n    {\n        return WEATHER_SEVEN_ERROR; /* Error has already been shown */\n    }\n    if(val > WEATHER_RAIN)\n    {\n        return ret_val+2;\n    }\n    if(val > WEATHER_CLOUD)\n    {\n        return ret_val+1;\n    }\n    return ret_val;\n"]], "pred": {"ppl": 2.9925546646118164, "ppl_lower": 3.5952887535095215, "ppl/lowercase_ppl": -1.167404700454621, "ppl/zlib": 0.0033418519069769305, "Min_5.0% Prob": 8.093490263995003, "Min_10.0% Prob": 6.435760838644845, "Min_20.0% Prob": 4.667499867963119, "Min_30.0% Prob": 3.4618584948165396, "Min_40.0% Prob": 2.7030836935643547, "Min_50.0% Prob": 2.1831154553375764, "Min_60.0% Prob": 1.8309460830152313}}
{"hexsha": "9ee58d4ebb6db1406ca3e66f1203b928db0f3ee0", "ext": "c", "lang": "C", "content": "struct texture_list* construct_texture_list() {\n\tstruct texture_list* result = (struct texture_list*)malloc(sizeof(struct texture_list));\n\n\tresult->head = NULL;\n\n\tresult->num_floor_ceils = 0;\n\tresult->num_walls = 0;\n\n\treturn result;\n}", "item_id": 5, "repo": "wynnliam/raycore", "file": "src/map/map_loading/ir/texture_list.c", "last_update_at": "2019-12-21T23:40:19+00:00", "question_id": "9ee58d4ebb6db1406ca3e66f1203b928db0f3ee0_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct texture_list* construct_texture_list() {\n\tstruct texture_list* result = (struct texture_list*)malloc(sizeof(struct texture_list));\n\tresult->head = NULL;\n\tresult->num_floor_ceils = 0;\n\tresult->num_walls = 0;\n\treturn result;\n"]], "pred": {"ppl": 3.0917375087738037, "ppl_lower": 3.337813138961792, "ppl/lowercase_ppl": -1.0678482816059025, "ppl/zlib": 0.008423382339193812, "Min_5.0% Prob": 10.402142524719238, "Min_10.0% Prob": 8.100601136684418, "Min_20.0% Prob": 5.166390471160412, "Min_30.0% Prob": 3.71127837151289, "Min_40.0% Prob": 2.834214137867093, "Min_50.0% Prob": 2.277487369906157, "Min_60.0% Prob": 1.9018229226930998}}
{"hexsha": "48c4ce847634b1716c7c83e612bbda61716c4995", "ext": "c", "lang": "C", "content": "int ExWAD_GetDirEnt(ExWAD_Context *ctx, char *name)\n{\n\tchar tb[256];\n\tExWAD_DirEnt *de;\n\tchar *s, *name1;\n\tint i, j, b, n, n1, fl, pfx;\n\t\n\ti=ExWAD_LookupDirEnt(ctx, name);\n\tif(i>=0)return(i);\n\n#if 1\n\tif(strlen(name)>EXWAD_NAMESZ)\n\t{\n\t\tstrcpy(tb, name);\n\t\ts=tb+strlen(tb);\n//\t\twhile((s>tb) && (*s!='/'))s--;\n\t\twhile(s>tb)\n\t\t{\n\t\t\tif((*s=='/') && s[1])\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t}\n\t\tif((s>tb) && (*s=='/') && s[1])\n\t\t{\n\t\t\ts[1]=0;\n\t\t\tpfx=ExWAD_GetDirEnt(ctx, tb);\n\n\t\t\ts=name+strlen(name);\n//\t\t\twhile((s>name) && (*s!='/'))s--;\n\t\t\twhile(s>tb)\n\t\t\t{\n\t\t\t\tif((*s=='/') && s[1])\n\t\t\t\t\tbreak;\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tname1=s+1;\n\t\t}else\n\t\t{\n\t\t\tpfx=-1;\n\t\t\tname1=name;\n\t\t}\n\t}else\n\t{\n\t\tpfx=-1;\n\t\tname1=name;\n\t}\n#endif\n\n\tb=exwad_getu32(ctx->head->rva_dirents);\n\tn=exwad_getu32(ctx->head->num_dirents);\n\tfor(i=0; i<n; i++)\n\t{\n\t\tde=&(ctx->dir[i]);\n//\t\tfl=exwad_getxu16(de->flags);\n\t\tj=exwad_getu32(de->name);\n\t\tif(!j)\n\t\t{\n\t\t\tif((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))\n\t\t\t{\n//\t\t\t\tde->name[14]=pfx&0xFF;\n//\t\t\t\tde->name[15]=(pfx>>8)&0xFF;\n\t\t\t\tstrcpy(de->name, name1);\n//\t\t\t\texwad_setu16(de->name+14, pfx);\n\t\t\t\texwad_setu32(de->dir, pfx);\n\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);\n\t\t\t}else if(strlen(name)<=EXWAD_NAMESZ)\n\t\t\t{\n\t\t\t\tstrcpy(de->name, name);\n\t\t\t\texwad_setu16(de->flags, 0);\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif((pfx>=0) && (pfx<65536))\n\t\t\t\t{\n\t\t\t\t\tj=ExWAD_GetStringRVA(ctx, name1);\n\t\t\t\t\texwad_setu32(de->name, j);\n//\t\t\t\t\texwad_setu32(de->name+12, pfx);\n\t\t\t\t\texwad_setu32(de->dir, pfx);\n\t\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|\n\t\t\t\t\t\tEXWAD_DIRFL_DIRPFX);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tj=ExWAD_GetStringRVA(ctx, name);\n\t\t\t\t\texwad_setu32(de->name, j);\n\t\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\treturn(i);\n\t\t}\n\t}\n\t\n\tExWAD_CheckExpandDir(ctx, n+EXWAD_CELLSZ);\n\ti=n+1;\n\n\tde=&(ctx->dir[i]);\n\tif((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))\n\t{\n//\t\tde->name[14]=pfx&0xFF;\n//\t\tde->name[15]=(pfx>>8)&0xFF;\n\t\tstrcpy(de->name, name1);\n//\t\texwad_setu16(de->name+14, pfx);\n\t\texwad_setu32(de->dir, pfx);\n\t\texwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);\n\t}else if(strlen(name)<=EXWAD_NAMESZ)\n\t{\n\t\tstrcpy(de->name, name);\n\t\texwad_setu16(de->flags, 0);\n\t}else\n\t{\n\t\tif((pfx>=0) && (pfx<65536))\n\t\t{\n\t\t\tj=ExWAD_GetStringRVA(ctx, name1);\n\t\t\texwad_setu32(de->name, j);\n//\t\t\texwad_setu32(de->name+12, pfx);\n\t\t\texwad_setu32(de->dir, pfx);\n\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|\n\t\t\t\tEXWAD_DIRFL_DIRPFX);\n\t\t}else\n\t\t{\n\t\t\tj=ExWAD_GetStringRVA(ctx, name);\n\t\t\texwad_setu32(de->name, j);\n\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);\n\t\t}\n\t}\n\n\treturn(i);\n}", "item_id": 20, "repo": "cr88192/bgbtech_engine", "file": "bscc/bgbdy/base/dyll_exwad.c", "last_update_at": "2019-07-02T22:53:52+00:00", "question_id": "48c4ce847634b1716c7c83e612bbda61716c4995_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ExWAD_GetDirEnt(ExWAD_Context *ctx, char *name)\n{\n\tchar tb[256];\n\tExWAD_DirEnt *de;\n\tchar *s, *name1;\n\tint i, j, b, n, n1, fl, pfx;\n\t\n\ti=ExWAD_LookupDirEnt(ctx, name);\n\tif(i>=0)return(i);\n#if 1\n\tif(strlen(name)>EXWAD_NAMESZ)\n\t{\n\t\tstrcpy(tb, name);\n\t\ts=tb+strlen(tb);\n//\t\twhile((s>tb) && (*s!='/'))s--;\n\t\twhile(s>tb)\n\t\t{\n\t\t\tif((*s=='/') && s[1])\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t}\n\t\tif((s>tb) && (*s=='/') && s[1])\n\t\t{\n\t\t\ts[1]=0;\n\t\t\tpfx=ExWAD_GetDirEnt(ctx, tb);\n\t\t\ts=name+strlen(name);\n//\t\t\twhile((s>name) && (*s!='/'))s--;\n\t\t\twhile(s>tb)\n\t\t\t{\n\t\t\t\tif((*s=='/') && s[1])\n\t\t\t\t\tbreak;\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tname1=s+1;\n\t\t}else\n\t\t{\n\t\t\tpfx=-1;\n\t\t\tname1=name;\n\t\t}\n\t}else\n\t{\n\t\tpfx=-1;\n\t\tname1=name;\n\t}\n#endif\n\tb=exwad_getu32(ctx->head->rva_dirents);\n\tn=exwad_getu32(ctx->head->num_dirents);\n\tfor(i=0; i<n; i++)\n\t{\n\t\tde=&(ctx->dir[i]);\n//\t\tfl=exwad_getxu16(de->flags);\n\t\tj=exwad_getu32(de->name);\n\t\tif(!j)\n\t\t{\n\t\t\tif((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))\n\t\t\t{\n//\t\t\t\tde->name[14]=pfx&0xFF;\n//\t\t\t\tde->name[15]=(pfx>>8)&0xFF;\n\t\t\t\tstrcpy(de->name, name1);\n//\t\t\t\texwad_setu16(de->name+14, pfx);\n\t\t\t\texwad_setu32(de->dir, pfx);\n\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);\n\t\t\t}else if(strlen(name)<=EXWAD_NAMESZ)\n\t\t\t{\n\t\t\t\tstrcpy(de->name, name);\n\t\t\t\texwad_setu16(de->flags, 0);\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif((pfx>=0) && (pfx<65536))\n\t\t\t\t{\n\t\t\t\t\tj=ExWAD_GetStringRVA(ctx, name1);\n\t\t\t\t\texwad_setu32(de->name, j);\n//\t\t\t\t\texwad_setu32(de->name+12, pfx);\n\t\t\t\t\texwad_setu32(de->dir, pfx);\n\t\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|\n\t\t\t\t\t\tEXWAD_DIRFL_DIRPFX);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tj=ExWAD_GetStringRVA(ctx, name);\n\t\t\t\t\texwad_setu32(de->name, j);\n\t\t\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\treturn(i);\n\t\t}\n\t}\n\t\n\tExWAD_CheckExpandDir(ctx, n+EXWAD_CELLSZ);\n\ti=n+1;\n\tde=&(ctx->dir[i]);\n\tif((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))\n\t{\n//\t\tde->name[14]=pfx&0xFF;\n//\t\tde->name[15]=(pfx>>8)&0xFF;\n\t\tstrcpy(de->name, name1);\n//\t\texwad_setu16(de->name+14, pfx);\n\t\texwad_setu32(de->dir, pfx);\n\t\texwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);\n\t}else if(strlen(name)<=EXWAD_NAMESZ)\n\t{\n\t\tstrcpy(de->name, name);\n\t\texwad_setu16(de->flags, 0);\n\t}else\n\t{\n\t\tif((pfx>=0) && (pfx<65536))\n\t\t{\n\t\t\tj=ExWAD_GetStringRVA(ctx, name1);\n\t\t\texwad_setu32(de->name, j);\n//\t\t\texwad_setu32(de->name+12, pfx);\n\t\t\texwad_setu32(de->dir, pfx);\n\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|\n\t\t\t\tEXWAD_DIRFL_DIRPFX);\n\t\t}else\n\t\t{\n\t\t\tj=ExWAD_GetStringRVA(ctx, name);\n\t\t\texwad_setu32(de->name, j);\n\t\t\texwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);\n\t\t}\n\t}\n\treturn(i);\n"]], "pred": {"ppl": 1.6709465980529785, "ppl_lower": 1.7018028497695923, "ppl/lowercase_ppl": -1.0356413011472938, "ppl/zlib": 0.0006845203880338324, "Min_5.0% Prob": 5.239815796122832, "Min_10.0% Prob": 3.7150724004296696, "Min_20.0% Prob": 2.346945547297889, "Min_30.0% Prob": 1.6750926499078476, "Min_40.0% Prob": 1.2752855660753613, "Min_50.0% Prob": 1.025793575439347, "Min_60.0% Prob": 0.8562633901447829}}
{"hexsha": "fe27fa351d1dac78c11e1993eecf6673b8793223", "ext": "c", "lang": "C", "content": "struct usp_pwm_t *\nusp_pwm_new(struct udev_device *device, const char *name,\n            enum usp_pwm_type_e type)\n{\n  struct usp_pwm_t *pwm = NULL;\n\n  pwm = calloc(sizeof(struct usp_pwm_t), 1);\n  assert(pwm != NULL);\n\n  udev_device_ref(pwm->uspwm_device);\n  pwm->uspwm_device = device;\n  pwm->uspwm_type = type;\n  pwm->uspwm_name = name;\n  usp_ref_init(pwm, usp_pwm_delete);\n\n  return pwm;\n}", "item_id": 0, "repo": "Coderlane/c-pwm-api", "file": "src/pwm_generic.c", "last_update_at": "2019-05-02T22:57:54+00:00", "question_id": "fe27fa351d1dac78c11e1993eecf6673b8793223_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct usp_pwm_t *\nusp_pwm_new(struct udev_device *device, const char *name,\n            enum usp_pwm_type_e type)\n{\n  struct usp_pwm_t *pwm = NULL;\n  pwm = calloc(sizeof(struct usp_pwm_t), 1);\n  assert(pwm != NULL);\n  udev_device_ref(pwm->uspwm_device);\n  pwm->uspwm_device = device;\n  pwm->uspwm_type = type;\n  pwm->uspwm_name = name;\n  usp_ref_init(pwm, usp_pwm_delete);\n  return pwm;\n"]], "pred": {"ppl": 2.204139232635498, "ppl_lower": 2.3029959201812744, "ppl/lowercase_ppl": -1.055512754526605, "ppl/zlib": 0.0039320251840671075, "Min_5.0% Prob": 6.496168565750122, "Min_10.0% Prob": 5.0600498676300045, "Min_20.0% Prob": 3.4239506393671038, "Min_30.0% Prob": 2.5423464263478914, "Min_40.0% Prob": 1.9646693575195968, "Min_50.0% Prob": 1.5843671987019479, "Min_60.0% Prob": 1.3226145492595}}
{"hexsha": "c5ed8c2de859210af8c50709c67dcd35009c5cb6", "ext": "h", "lang": "C", "content": "static inline void hri_i2s_write_CLKCTRL_SLOTSIZE_bf(const void *const hw, uint8_t index, hri_i2s_clkctrl_reg_t data)\n{\n\tuint32_t tmp;\n\tI2S_CRITICAL_SECTION_ENTER();\n\ttmp = ((I2s *)hw)->CLKCTRL[index].reg;\n\ttmp &= ~I2S_CLKCTRL_SLOTSIZE_Msk;\n\ttmp |= I2S_CLKCTRL_SLOTSIZE(data);\n\t((I2s *)hw)->CLKCTRL[index].reg = tmp;\n\tI2S_CRITICAL_SECTION_LEAVE();\n}", "item_id": 82, "repo": "jinlongliu/AliOS-Things", "file": "platform/mcu/atsamd5x_e5x/Drivers/hri/hri_i2s_e54.h", "last_update_at": "2019-09-25T07:17:27+00:00", "question_id": "c5ed8c2de859210af8c50709c67dcd35009c5cb6_82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_i2s_write_CLKCTRL_SLOTSIZE_bf(const void *const hw, uint8_t index, hri_i2s_clkctrl_reg_t data)\n{\n\tuint32_t tmp;\n\tI2S_CRITICAL_SECTION_ENTER();\n\ttmp = ((I2s *)hw)->CLKCTRL[index].reg;\n\ttmp &= ~I2S_CLKCTRL_SLOTSIZE_Msk;\n\ttmp |= I2S_CLKCTRL_SLOTSIZE(data);\n\t((I2s *)hw)->CLKCTRL[index].reg = tmp;\n\tI2S_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.2604131698608398, "ppl_lower": 1.921860933303833, "ppl/lowercase_ppl": -2.8227408349713063, "ppl/zlib": 0.0010616494486228088, "Min_5.0% Prob": 4.052455226580302, "Min_10.0% Prob": 2.289425167772505, "Min_20.0% Prob": 1.156586208943433, "Min_30.0% Prob": 0.7714188259770809, "Min_40.0% Prob": 0.5785905905796527, "Min_50.0% Prob": 0.46287727653237504, "Min_60.0% Prob": 0.385732169769645}}
{"hexsha": "df49518d57b38e42955f608c22e269c56472325b", "ext": "c", "lang": "C", "content": "int main()\n{\n    int i,n,x=1,temp,sum=0;\n\n    printf(\"Enter number of digit:\\n\");\n    scanf(\"%d\",&n);\n    int arr[n];\n    printf(\" Enter digit:\");\n    for( i=0; i<n; i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    for( i=n-1; i>=n/2; i--)\n    {\n        temp=arr[i];\n        arr[i]=arr[n-i-1];\n        arr[n-i-1]=temp;\n    }\n    for( i=0; i<n; i++)\n    {\n        sum+=arr[i]*x;\n        x=x*10;\n    }\n    printf(\"%d\",sum);\n\n\n\n\n    return 0;\n}", "item_id": 0, "repo": "sameerbairwa/C-language-Program", "file": "reverseNumber.c", "last_update_at": "2019-05-06T18:45:24+00:00", "question_id": "df49518d57b38e42955f608c22e269c56472325b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n    int i,n,x=1,temp,sum=0;\n    printf(\"Enter number of digit:\\n\");\n    scanf(\"%d\",&n);\n    int arr[n];\n    printf(\" Enter digit:\");\n    for( i=0; i<n; i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    for( i=n-1; i>=n/2; i--)\n    {\n        temp=arr[i];\n        arr[i]=arr[n-i-1];\n        arr[n-i-1]=temp;\n    }\n    for( i=0; i<n; i++)\n    {\n        sum+=arr[i]*x;\n        x=x*10;\n    }\n    printf(\"%d\",sum);\n    return 0;\n"]], "pred": {"ppl": 1.7960362434387207, "ppl_lower": 1.7960517406463623, "ppl/lowercase_ppl": -1.0000147349495192, "ppl/zlib": 0.0027110284711331814, "Min_5.0% Prob": 5.660036683082581, "Min_10.0% Prob": 4.103456890583038, "Min_20.0% Prob": 2.6216980742245184, "Min_30.0% Prob": 1.8728100909821448, "Min_40.0% Prob": 1.4393722722867885, "Min_50.0% Prob": 1.1624773672710245, "Min_60.0% Prob": 0.9734770249277354}}
{"hexsha": "325c05233878b4be79f49f99e632029c43ff3872", "ext": "c", "lang": "C", "content": "TEST_FUNCTION(AMQP_ProcessItem)\n{\n    // arrange\n    TRANSPORT_PROVIDER* provider = (TRANSPORT_PROVIDER*)AMQP_Protocol();\n\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(IoTHubTransport_AMQP_Common_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE));\n\n    // act\n    IOTHUB_PROCESS_ITEM_RESULT result = provider->IoTHubTransport_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE);\n\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n    ASSERT_ARE_EQUAL(int, result, IOTHUB_PROCESS_OK);\n\n    // cleanup\n}", "item_id": 22, "repo": "jadeiceman/azure-iot-sdk-c", "file": "iothub_client/tests/iothubtransportamqp_ut/iothubtransportamqp_ut.c", "last_update_at": "2019-08-18T09:38:47+00:00", "question_id": "325c05233878b4be79f49f99e632029c43ff3872_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TEST_FUNCTION(AMQP_ProcessItem)\n{\n    // arrange\n    TRANSPORT_PROVIDER* provider = (TRANSPORT_PROVIDER*)AMQP_Protocol();\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(IoTHubTransport_AMQP_Common_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE));\n    // act\n    IOTHUB_PROCESS_ITEM_RESULT result = provider->IoTHubTransport_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE);\n    // assert\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n    ASSERT_ARE_EQUAL(int, result, IOTHUB_PROCESS_OK);\n    // cleanup\n"]], "pred": {"ppl": 1.411990761756897, "ppl_lower": 3.1281847953796387, "ppl/lowercase_ppl": -3.305654861748724, "ppl/zlib": 0.0010849075358005027, "Min_5.0% Prob": 5.39520651953561, "Min_10.0% Prob": 3.2434896744530777, "Min_20.0% Prob": 1.7329504533574498, "Min_30.0% Prob": 1.1503771205104634, "Min_40.0% Prob": 0.8663964366090572, "Min_50.0% Prob": 0.6899157081117702, "Min_60.0% Prob": 0.5762926433816656}}
{"hexsha": "e6ce4d6b9eab3cdce79f531883847531ceb96d23", "ext": "c", "lang": "C", "content": "void initialize() {\n\tinitialize_sensor();\n\n\tinitialize_button();\n\n\tinitialize_poll();\n\t\n\tinitialize_timer();\n\n\tatexit(clean_up);\n}", "item_id": 12, "repo": "ioneone/UCLA-CS-111", "file": "Project 4B/lab4b.c", "last_update_at": "2019-04-23T21:26:27+00:00", "question_id": "e6ce4d6b9eab3cdce79f531883847531ceb96d23_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void initialize() {\n\tinitialize_sensor();\n\tinitialize_button();\n\tinitialize_poll();\n\t\n\tinitialize_timer();\n\tatexit(clean_up);\n"]], "pred": {"ppl": 7.387629508972168, "ppl_lower": 7.387629508972168, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.02380722515957011, "Min_5.0% Prob": 11.157372951507568, "Min_10.0% Prob": 9.226186752319336, "Min_20.0% Prob": 6.859471215142144, "Min_30.0% Prob": 5.52614084311894, "Min_40.0% Prob": 4.759183850553301, "Min_50.0% Prob": 3.9199171273604683, "Min_60.0% Prob": 3.296744325331279}}
{"hexsha": "df25e0e2a8ba617fb4a9506e49e137bd6fb744aa", "ext": "c", "lang": "C", "content": "void do_check1()\n{\n        object cart;\n        object ob = this_object();\n\n        if( living(ob) && query(\"qi\", ob)>0 )\n        {\n                remove_call_out(\"do_check1\");\n                call_out(\"do_check1\",B_TIME);\n        }\n        else\n        {\n                message_vision(HIR\"$N\u5728\u660f\u8ff7\u4e2d\u7a81\u7136\u6025\u4fc3\u5730\u547b\u541f\u4e86\u4e00\u8072\uff0c\u7136\u5f8c\u5c31\u518d\u6c92\u6709\u8072\u97f3\u4e86\u3002\\n\"NOR,ob);\n             if (objectp(cart = present(\"cart\", environment(ob)))) destruct(cart);\n\n             ob -> receive_damage(\"qi\",1000);\n        }\n}", "item_id": 6, "repo": "cantona/NT6", "file": "nitan/d/fuzhou/npc/biaotou.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "df25e0e2a8ba617fb4a9506e49e137bd6fb744aa_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void do_check1()\n{\n        object cart;\n        object ob = this_object();\n        if( living(ob) && query(\"qi\", ob)>0 )\n        {\n                remove_call_out(\"do_check1\");\n                call_out(\"do_check1\",B_TIME);\n        }\n        else\n        {\n                message_vision(HIR\"$N\u5728\u660f\u8ff7\u4e2d\u7a81\u7136\u6025\u4fc3\u5730\u547b\u541f\u4e86\u4e00\u8072\uff0c\u7136\u5f8c\u5c31\u518d\u6c92\u6709\u8072\u97f3\u4e86\u3002\\n\"NOR,ob);\n             if (objectp(cart = present(\"cart\", environment(ob)))) destruct(cart);\n             ob -> receive_damage(\"qi\",1000);\n        }\n"]], "pred": {"ppl": 4.109864711761475, "ppl_lower": 4.6651611328125, "ppl/lowercase_ppl": -1.0896654521504792, "ppl/zlib": 0.00415702973858828, "Min_5.0% Prob": 8.604067961374918, "Min_10.0% Prob": 7.091497447755602, "Min_20.0% Prob": 5.197853101266397, "Min_30.0% Prob": 4.103503889271191, "Min_40.0% Prob": 3.3529352424917995, "Min_50.0% Prob": 2.7782944277409585, "Min_60.0% Prob": 2.342500468649502}}
{"hexsha": "f7c6009053533897291195fef04dadfa06a5f34d", "ext": "c", "lang": "C", "content": "void inline_bzero(void *p, size_t l)\n{\n\tBYTE *q = (BYTE *)p;\n\tsize_t x = 0;\n\tfor (x = 0; x < l; x++)\n\t\t*(q++) = 0x00;\n}", "item_id": 0, "repo": "darkbushido/metasploit-framework", "file": "data/exploits/cve-2017-8464/src/template.c", "last_update_at": "2019-04-23T19:27:44+00:00", "question_id": "f7c6009053533897291195fef04dadfa06a5f34d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void inline_bzero(void *p, size_t l)\n{\n\tBYTE *q = (BYTE *)p;\n\tsize_t x = 0;\n\tfor (x = 0; x < l; x++)\n\t\t*(q++) = 0x00;\n"]], "pred": {"ppl": 3.158846139907837, "ppl_lower": 3.2565932273864746, "ppl/lowercase_ppl": -1.0264950711159395, "ppl/zlib": 0.011276537405079883, "Min_5.0% Prob": 8.909842173258463, "Min_10.0% Prob": 6.816159588950021, "Min_20.0% Prob": 4.706274134772165, "Min_30.0% Prob": 3.527140404496874, "Min_40.0% Prob": 2.7618434886847223, "Min_50.0% Prob": 2.255125313145774, "Min_60.0% Prob": 1.9018849125575452}}
{"hexsha": "6c3d6ae5f3149ee453405bddb6a2387bf0520225", "ext": "c", "lang": "C", "content": "const struct i915_gpu_controller_info *\nintel_gma_get_controller_info(void)\n{\n\tstruct device *dev = dev_find_slot(0, PCI_DEVFN(0x2, 0));\n\tif (!dev)\n\t\treturn NULL;\n\tstruct northbridge_intel_i945_config *chip = dev->chip_info;\n\tif (!chip)\n\t\treturn NULL;\n\treturn &chip->gfx;\n}", "item_id": 10, "repo": "fabiojna02/OpenCellular", "file": "firmware/coreboot/src/northbridge/intel/i945/gma.c", "last_update_at": "2019-11-04T07:11:25+00:00", "question_id": "6c3d6ae5f3149ee453405bddb6a2387bf0520225_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const struct i915_gpu_controller_info *\nintel_gma_get_controller_info(void)\n{\n\tstruct device *dev = dev_find_slot(0, PCI_DEVFN(0x2, 0));\n\tif (!dev)\n\t\treturn NULL;\n\tstruct northbridge_intel_i945_config *chip = dev->chip_info;\n\tif (!chip)\n\t\treturn NULL;\n\treturn &chip->gfx;\n"]], "pred": {"ppl": 2.9775516986846924, "ppl_lower": 3.5880088806152344, "ppl/lowercase_ppl": -1.170924569058038, "ppl/zlib": 0.005624233944406523, "Min_5.0% Prob": 8.910213947296143, "Min_10.0% Prob": 7.16858156522115, "Min_20.0% Prob": 4.8257942001024885, "Min_30.0% Prob": 3.4918374451431067, "Min_40.0% Prob": 2.716572409381672, "Min_50.0% Prob": 2.1730283431468473, "Min_60.0% Prob": 1.826339450287255}}
{"hexsha": "962d14ec0ed84d647e7be19511b7999551b235e5", "ext": "c", "lang": "C", "content": "static void peci_xec_bus_recovery(const struct device *dev, bool full_reset)\n{\n\tPECI_Type *base = peci_xec_config.base;\n\n\tLOG_WRN(\"%s full_reset:%d\", __func__, full_reset);\n\tif (full_reset) {\n\t\tbase->CONTROL = MCHP_PECI_CTRL_PD | MCHP_PECI_CTRL_RST;\n\n\t\tif (k_is_in_isr()) {\n\t\t\tk_busy_wait(PECI_RESET_DELAY_MS);\n\t\t} else {\n\t\t\tk_msleep(PECI_RESET_DELAY);\n\t\t}\n\n\t\tbase->CONTROL &= ~MCHP_PECI_CTRL_RST;\n\n\t\tpeci_xec_configure(dev, peci_data.bitrate);\n\t} else {\n\t\t/* Only reset internal FIFOs */\n\t\tbase->CONTROL |= MCHP_PECI_CTRL_FRST;\n\t}\n}", "item_id": 4, "repo": "eivindj-nordic/sdk-zephyr", "file": "drivers/peci/peci_mchp_xec.c", "last_update_at": "2019-02-13T10:48:26+00:00", "question_id": "962d14ec0ed84d647e7be19511b7999551b235e5_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void peci_xec_bus_recovery(const struct device *dev, bool full_reset)\n{\n\tPECI_Type *base = peci_xec_config.base;\n\tLOG_WRN(\"%s full_reset:%d\", __func__, full_reset);\n\tif (full_reset) {\n\t\tbase->CONTROL = MCHP_PECI_CTRL_PD | MCHP_PECI_CTRL_RST;\n\t\tif (k_is_in_isr()) {\n\t\t\tk_busy_wait(PECI_RESET_DELAY_MS);\n\t\t} else {\n\t\t\tk_msleep(PECI_RESET_DELAY);\n\t\t}\n\t\tbase->CONTROL &= ~MCHP_PECI_CTRL_RST;\n\t\tpeci_xec_configure(dev, peci_data.bitrate);\n\t} else {\n\t\t/* Only reset internal FIFOs */\n\t\tbase->CONTROL |= MCHP_PECI_CTRL_FRST;\n\t}\n"]], "pred": {"ppl": 2.275646448135376, "ppl_lower": 2.859490394592285, "ppl/lowercase_ppl": -1.277744391502592, "ppl/zlib": 0.002695948082182385, "Min_5.0% Prob": 6.889242208920992, "Min_10.0% Prob": 5.364010590773362, "Min_20.0% Prob": 3.6818844034986675, "Min_30.0% Prob": 2.6695405654609203, "Min_40.0% Prob": 2.058090952840054, "Min_50.0% Prob": 1.6485339984633869, "Min_60.0% Prob": 1.3716610112052876}}
{"hexsha": "3d072fd063ef6452ab2c9ae6d0059e556b57a87a", "ext": "c", "lang": "C", "content": "void *_lf_dynarray_value(LF_DYNARRAY *array, uint idx)\n{\n  void * ptr, * volatile * ptr_ptr= 0;\n  int i;\n\n  for (i= LF_DYNARRAY_LEVELS-1; idx < dynarray_idxes_in_prev_levels[i]; i--)\n    /* no-op */;\n  ptr_ptr= &array->level[i];\n  idx-= dynarray_idxes_in_prev_levels[i];\n  for (; i > 0; i--)\n  {\n    if (!(ptr= *ptr_ptr))\n      return(NULL);\n    ptr_ptr= ((void **)ptr) + idx / dynarray_idxes_in_prev_level[i];\n    idx %= dynarray_idxes_in_prev_level[i];\n  }\n  if (!(ptr= *ptr_ptr))\n    return(NULL);\n  return ((uchar*)ptr) + array->size_of_element * idx;\n}", "item_id": 3, "repo": "edsiper/duda", "file": "packages/mariadb/deps/libmariadbclient/mysys/lf_dynarray.c", "last_update_at": "2019-07-10T03:01:22+00:00", "question_id": "3d072fd063ef6452ab2c9ae6d0059e556b57a87a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *_lf_dynarray_value(LF_DYNARRAY *array, uint idx)\n{\n  void * ptr, * volatile * ptr_ptr= 0;\n  int i;\n  for (i= LF_DYNARRAY_LEVELS-1; idx < dynarray_idxes_in_prev_levels[i]; i--)\n    /* no-op */;\n  ptr_ptr= &array->level[i];\n  idx-= dynarray_idxes_in_prev_levels[i];\n  for (; i > 0; i--)\n  {\n    if (!(ptr= *ptr_ptr))\n      return(NULL);\n    ptr_ptr= ((void **)ptr) + idx / dynarray_idxes_in_prev_level[i];\n    idx %= dynarray_idxes_in_prev_level[i];\n  }\n  if (!(ptr= *ptr_ptr))\n    return(NULL);\n  return ((uchar*)ptr) + array->size_of_element * idx;\n"]], "pred": {"ppl": 2.76220703125, "ppl_lower": 2.9204776287078857, "ppl/lowercase_ppl": -1.054838109791799, "ppl/zlib": 0.0036286786042277045, "Min_5.0% Prob": 6.641690914447491, "Min_10.0% Prob": 5.683489304322463, "Min_20.0% Prob": 4.18680783877006, "Min_30.0% Prob": 3.1703580572054935, "Min_40.0% Prob": 2.4923607176886153, "Min_50.0% Prob": 2.014535989185781, "Min_60.0% Prob": 1.6910805257784713}}
{"hexsha": "0f99f6327b527ae6e12fffa6602de135952fd63a", "ext": "c", "lang": "C", "content": "static void flashRead(uint32_t addr, uint16_t len, uint8_t *pBuf)\n{\n   uint8_t  *flashPtr;\n   uint16_t flashIndex;\n\n   flashPtr = (uint8_t *)addr;\n\n   for(flashIndex = 0; flashIndex <= len; flashIndex++)\n   {\n     /* data fit into buffer */\n     pBuf[flashIndex] = *flashPtr++;\n   }\n}", "item_id": 0, "repo": "nesl/UnderwaterSensorTag", "file": "Aquamote/Firmware/ble_sdk_2_02_01_18/sap_3_00_01_07/source/ti/sbl/sbl_image_int.c", "last_update_at": "2019-03-01T00:48:59+00:00", "question_id": "0f99f6327b527ae6e12fffa6602de135952fd63a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void flashRead(uint32_t addr, uint16_t len, uint8_t *pBuf)\n{\n   uint8_t  *flashPtr;\n   uint16_t flashIndex;\n   flashPtr = (uint8_t *)addr;\n   for(flashIndex = 0; flashIndex <= len; flashIndex++)\n   {\n     /* data fit into buffer */\n     pBuf[flashIndex] = *flashPtr++;\n   }\n"]], "pred": {"ppl": 2.9273674488067627, "ppl_lower": 3.03676700592041, "ppl/lowercase_ppl": -1.0341586502829592, "ppl/zlib": 0.0062813072369385875, "Min_5.0% Prob": 8.643515300750732, "Min_10.0% Prob": 6.493347861550071, "Min_20.0% Prob": 4.477028239857066, "Min_30.0% Prob": 3.320851965862162, "Min_40.0% Prob": 2.6260107278823854, "Min_50.0% Prob": 2.1212019739966643, "Min_60.0% Prob": 1.7940240298014354}}
{"hexsha": "264569a94880afbc2c5a62ff6d1e181bfc6232b0", "ext": "c", "lang": "C", "content": "static int next(int zone)\n{\n\tif (!zone)\n\t\tzone = FIRSTZONE - 1;\n\twhile (++zone < ZONES)\n\t\tif (zone_in_use(zone))\n\t\t\treturn zone;\n\treturn 0;\n}", "item_id": 6, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/progs.gpl/busybox-1.00/util-linux/mkfs_minix.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "264569a94880afbc2c5a62ff6d1e181bfc6232b0_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int next(int zone)\n{\n\tif (!zone)\n\t\tzone = FIRSTZONE - 1;\n\twhile (++zone < ZONES)\n\t\tif (zone_in_use(zone))\n\t\t\treturn zone;\n\treturn 0;\n"]], "pred": {"ppl": 3.4565703868865967, "ppl_lower": 3.60518479347229, "ppl/lowercase_ppl": -1.0339409293258328, "ppl/zlib": 0.010879621752857041, "Min_5.0% Prob": 9.383203506469727, "Min_10.0% Prob": 7.4050155480702715, "Min_20.0% Prob": 5.088345490969145, "Min_30.0% Prob": 3.8177305340766905, "Min_40.0% Prob": 3.0091771373042353, "Min_50.0% Prob": 2.442718293298693, "Min_60.0% Prob": 2.096784227155149}}
{"hexsha": "dcc6705495968010febb8e0c802630ce73347883", "ext": "c", "lang": "C", "content": "unsigned int iterative_ackermann(unsigned int m, unsigned int n) {\n    calls++;\n    while (m != 0) {\n        if (n == 0) {\n            n = 1;\n        } else {\n            n = iterative_ackermann(m, n - 1);\n        }\n        m--;\n    }\n    return n + 1;\n}", "item_id": 0, "repo": "xbabka01/retdec-regression-tests", "file": "integration/ackermann/ackermann.c", "last_update_at": "2019-03-09T03:29:12+00:00", "question_id": "dcc6705495968010febb8e0c802630ce73347883_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned int iterative_ackermann(unsigned int m, unsigned int n) {\n    calls++;\n    while (m != 0) {\n        if (n == 0) {\n            n = 1;\n        } else {\n            n = iterative_ackermann(m, n - 1);\n        }\n        m--;\n    }\n    return n + 1;\n"]], "pred": {"ppl": 2.215894937515259, "ppl_lower": 2.215894937515259, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005893750791796601, "Min_5.0% Prob": 10.850933313369751, "Min_10.0% Prob": 6.270800908406575, "Min_20.0% Prob": 3.6244922478993735, "Min_30.0% Prob": 2.547026272173281, "Min_40.0% Prob": 1.9695902123219438, "Min_50.0% Prob": 1.5945166102714008, "Min_60.0% Prob": 1.3358945041480992}}
{"hexsha": "eb03a1b4f363c722f1ea275ac1d3a66d2f594156", "ext": "c", "lang": "C", "content": "RDB_MATRIX_T* rdbize_matrix\n  (char*          corner_string,\n   STRING_LIST_T* row_names,\n   STRING_LIST_T* col_names,\n   MATRIX_T*      matrix)\n{\n  RDB_MATRIX_T* new_matrix;\n  assert(get_num_rows(matrix) == get_num_strings(row_names));\n  assert(get_num_cols(matrix) == get_num_strings(col_names));\n\n  new_matrix = allocate_rdb_matrix(get_num_rows(matrix),\n\t\t\t\t   get_num_cols(matrix),\n\t\t\t\t   matrix);\n\n  set_corner_string(corner_string, new_matrix);\n  set_row_names(row_names, new_matrix);\n  set_col_names(col_names, new_matrix);\n  \n  return(new_matrix);\n}", "item_id": 1, "repo": "kbasecollaborations/MotifFinderSampler", "file": "deps/kb_meme/meme-5.0.1/src/rdb-matrix.c", "last_update_at": "2019-07-19T04:33:43+00:00", "question_id": "eb03a1b4f363c722f1ea275ac1d3a66d2f594156_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["RDB_MATRIX_T* rdbize_matrix\n  (char*          corner_string,\n   STRING_LIST_T* row_names,\n   STRING_LIST_T* col_names,\n   MATRIX_T*      matrix)\n{\n  RDB_MATRIX_T* new_matrix;\n  assert(get_num_rows(matrix) == get_num_strings(row_names));\n  assert(get_num_cols(matrix) == get_num_strings(col_names));\n  new_matrix = allocate_rdb_matrix(get_num_rows(matrix),\n\t\t\t\t   get_num_cols(matrix),\n\t\t\t\t   matrix);\n  set_corner_string(corner_string, new_matrix);\n  set_row_names(row_names, new_matrix);\n  set_col_names(col_names, new_matrix);\n  return(new_matrix);\n"]], "pred": {"ppl": 2.165160894393921, "ppl_lower": 2.238363265991211, "ppl/lowercase_ppl": -1.0430426774903763, "ppl/zlib": 0.003464101680764268, "Min_5.0% Prob": 8.313184261322021, "Min_10.0% Prob": 5.935326607330985, "Min_20.0% Prob": 3.6758839086346002, "Min_30.0% Prob": 2.5423364490270615, "Min_40.0% Prob": 1.9343705328321585, "Min_50.0% Prob": 1.543012496474016, "Min_60.0% Prob": 1.2907933304003174}}
{"hexsha": "917abe9355957d55c98cdb924842b74ee749c534", "ext": "c", "lang": "C", "content": "SQLRETURN WINAPI SQLNumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnCount)\n{\n        TRACE(\"\\n\");\n\n        CHECK_dmHandle();\n\n        assert (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func);\n        return (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func)\n            (StatementHandle, ColumnCount);\n}", "item_id": 43, "repo": "roytam1/wine-win31look", "file": "dlls/odbc32/proxyodbc.c", "last_update_at": "2019-10-23T04:07:16+00:00", "question_id": "917abe9355957d55c98cdb924842b74ee749c534_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SQLRETURN WINAPI SQLNumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnCount)\n{\n        TRACE(\"\\n\");\n        CHECK_dmHandle();\n        assert (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func);\n        return (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func)\n            (StatementHandle, ColumnCount);\n"]], "pred": {"ppl": 3.4350037574768066, "ppl_lower": 8.070807456970215, "ppl/lowercase_ppl": -1.6922390927954516, "ppl/zlib": 0.006296010303844006, "Min_5.0% Prob": 8.526348781585693, "Min_10.0% Prob": 7.151026439666748, "Min_20.0% Prob": 4.958490950720651, "Min_30.0% Prob": 3.729697499424219, "Min_40.0% Prob": 3.0277172596681687, "Min_50.0% Prob": 2.4693621174906784, "Min_60.0% Prob": 2.0592344549077097}}
{"hexsha": "f042e192d2feadd4f32c0188154920771d225fae", "ext": "c", "lang": "C", "content": "static int\nxen_assign_irq_vector(int irq)\n{\n\tstruct physdev_irq irq_op;\n\n\tirq_op.irq = irq;\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))\n\t\treturn -ENOSPC;\n\n\treturn irq_op.vector;\n}", "item_id": 0, "repo": "haizhenhan/Kepler", "file": "kernel/2.6.32/arch/ia64/xen/irq_xen.c", "last_update_at": "2019-07-12T08:24:31+00:00", "question_id": "f042e192d2feadd4f32c0188154920771d225fae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nxen_assign_irq_vector(int irq)\n{\n\tstruct physdev_irq irq_op;\n\tirq_op.irq = irq;\n\tif (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))\n\t\treturn -ENOSPC;\n\treturn irq_op.vector;\n"]], "pred": {"ppl": 1.7995963096618652, "ppl_lower": 3.014441728591919, "ppl/lowercase_ppl": -1.8779532347940149, "ppl/zlib": 0.003742435460759404, "Min_5.0% Prob": 6.0340989112854, "Min_10.0% Prob": 4.304340672492981, "Min_20.0% Prob": 2.769052419066429, "Min_30.0% Prob": 1.9514350349704424, "Min_40.0% Prob": 1.4890094594098628, "Min_50.0% Prob": 1.1736432817563707, "Min_60.0% Prob": 0.9820926239614787}}
{"hexsha": "bb9a32ab07be613c9f989408086e26d9d235e0f5", "ext": "h", "lang": "C", "content": "static float DistSqr(Vec2 lhs, Vec2 rhs)\n\t{\n\t\tfloat offsetX = lhs.x-rhs.x;\n\t\tfloat offsetY = lhs.y-rhs.y;\n\t\treturn offsetX*offsetX + offsetY*offsetY;\n\t}", "item_id": 1, "repo": "droune2001/glxp", "file": "src/tonemap/Core/Vec2.h", "last_update_at": "2019-03-18T02:13:13+00:00", "question_id": "bb9a32ab07be613c9f989408086e26d9d235e0f5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static float DistSqr(Vec2 lhs, Vec2 rhs)\n\t{\n\t\tfloat offsetX = lhs.x-rhs.x;\n\t\tfloat offsetY = lhs.y-rhs.y;\n\t\treturn offsetX*offsetX + offsetY*offsetY;\n"]], "pred": {"ppl": 2.2342662811279297, "ppl_lower": 2.3128247261047363, "ppl/lowercase_ppl": -1.0429856453709132, "ppl/zlib": 0.007959533547714214, "Min_5.0% Prob": 8.85185686747233, "Min_10.0% Prob": 6.564338752201626, "Min_20.0% Prob": 3.920377824987684, "Min_30.0% Prob": 2.714599692395755, "Min_40.0% Prob": 2.0598559800003255, "Min_50.0% Prob": 1.605717805162486, "Min_60.0% Prob": 1.345433497703959}}
{"hexsha": "e5fde638931f6d8597865615d8cb58e356899a60", "ext": "c", "lang": "C", "content": "int main(int argc, char** argv)\n{\n    clock_t start = clock();\n    int answer = run(argv[1]);\n    printf(\"_duration:%f\\n%d\\n\", (float)( clock () - start ) * 1000.0 /  CLOCKS_PER_SEC, answer);\n    return 0;\n}", "item_id": 1, "repo": "TPXP/adventofcode-2019", "file": "day-02/part-1/lithium.c", "last_update_at": "2019-12-05T21:21:12+00:00", "question_id": "e5fde638931f6d8597865615d8cb58e356899a60_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char** argv)\n{\n    clock_t start = clock();\n    int answer = run(argv[1]);\n    printf(\"_duration:%f\\n%d\\n\", (float)( clock () - start ) * 1000.0 /  CLOCKS_PER_SEC, answer);\n    return 0;\n"]], "pred": {"ppl": 1.857229232788086, "ppl_lower": 2.415010929107666, "ppl/lowercase_ppl": -1.4242031240324686, "ppl/zlib": 0.003774912910289538, "Min_5.0% Prob": 7.5938780307769775, "Min_10.0% Prob": 4.849911913275719, "Min_20.0% Prob": 2.9227822072365703, "Min_30.0% Prob": 2.1019670036435127, "Min_40.0% Prob": 1.5600406986606472, "Min_50.0% Prob": 1.2371561874657175, "Min_60.0% Prob": 1.0436927983628623}}
{"hexsha": "e10af0bf03fb8b8639873253027eced624fc1944", "ext": "c", "lang": "C", "content": "static void actfcn_gauss3(double *data, int N, int d, double *centroid, int K, double beta, double *A) {\r\n\tint i, j, K1, j1, it1, ik1;\r\n\tdouble dist, t;\r\n\tK1 = K + 1;\r\n\r\n\tfor (i = 0; i < N; ++i) {\r\n\t\tik1 = i * K1;\r\n\t\tA[ik1] = 1.0;\r\n\t\tit1 = i * d;\r\n\t\t//printf(\"\\n\");\r\n\t\tfor (j = 1; j < K1; ++j) {\r\n\t\t\tj1 = j - 1;\r\n\t\t\tdist = l2(data + it1, centroid + j1*d, d);\r\n\t\t\t//printf(\"%g \", dist);\r\n\t\t\tt = beta *dist;\r\n\t\t\tA[ik1 + j] = exp(-t*t);\r\n\t\t}\r\n\t}\r\n}", "item_id": 11, "repo": "rafat/rbfn", "file": "src/rbf.c", "last_update_at": "2019-07-19T14:53:22+00:00", "question_id": "e10af0bf03fb8b8639873253027eced624fc1944_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void actfcn_gauss3(double *data, int N, int d, double *centroid, int K, double beta, double *A) {\r\n\tint i, j, K1, j1, it1, ik1;\r\n\tdouble dist, t;\r\n\tK1 = K + 1;\r\n\r\n\tfor (i = 0; i < N; ++i) {\r\n\t\tik1 = i * K1;\r\n\t\tA[ik1] = 1.0;\r\n\t\tit1 = i * d;\r\n\t\t//printf(\"\\n\");\r\n\t\tfor (j = 1; j < K1; ++j) {\r\n\t\t\tj1 = j - 1;\r\n\t\t\tdist = l2(data + it1, centroid + j1*d, d);\r\n\t\t\t//printf(\"%g \", dist);\r\n\t\t\tt = beta *dist;\r\n\t\t\tA[ik1 + j] = exp(-t*t);\r\n\t\t}\r\n\t}\r\n"]], "pred": {"ppl": 2.754868268966675, "ppl_lower": 2.640778064727783, "ppl/lowercase_ppl": -0.9582619906037401, "ppl/zlib": 0.0038385213113810096, "Min_5.0% Prob": 7.478959993882612, "Min_10.0% Prob": 5.765626420145449, "Min_20.0% Prob": 4.165168019051247, "Min_30.0% Prob": 3.1032178804908, "Min_40.0% Prob": 2.461489197738627, "Min_50.0% Prob": 2.0089745906702543, "Min_60.0% Prob": 1.684712788221282}}
{"hexsha": "03ee5857587a392b2677e355fdec9ab950f578e5", "ext": "c", "lang": "C", "content": "DWORD\nVmAfdPrintCACertificates(\n    PVMAFD_CA_CERT_ARRAY pCertArray\n    )\n{\n    DWORD   dwError = 0;\n    PSTR    pszCN = NULL;\n    int     i = 0;\n    PVMAFD_CA_CERT  pCert = NULL;\n\n    if (!pCertArray || pCertArray->dwCount == 0)\n    {\n        dwError = ERROR_INVALID_PARAMETER;\n        BAIL_ON_VMAFD_ERROR(dwError);\n    }\n\n    fprintf(stdout,\n            \"Number of certificates:\\t%d\\n\",\n            pCertArray->dwCount\n            );\n\n    for (; i < pCertArray->dwCount; ++i)\n    {\n        fprintf(stdout, \"#%d:\\n\", i + 1);\n\n        pCert = &pCertArray->pCACerts[i];\n\n        dwError = VmAfdExtractCNFromDN((PSTR)pCert->pCN, &pszCN);\n        BAIL_ON_VMAFD_ERROR(dwError);\n\n        fprintf(stdout, \"CN(id):\\t\\t%s\\n\", pszCN);\n        fprintf(stdout, \"Subject DN:\\t%s\\n\", (PSTR)pCert->pSubjectDN);\n        fprintf(stdout, \"CRL present:\\t%s\\n\", (PSTR)pCert->pCrl ? \"yes\" : \"no\");\n\n        VMAFD_SAFE_FREE_MEMORY(pszCN);\n    }\n\ncleanup:\n    VMAFD_SAFE_FREE_MEMORY(pszCN);\n    return dwError;\n\nerror :\n    goto cleanup;\n}", "item_id": 18, "repo": "slachiewicz/lightwave", "file": "vmafd/common/certutil.c", "last_update_at": "2019-06-27T07:40:49+00:00", "question_id": "03ee5857587a392b2677e355fdec9ab950f578e5_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DWORD\nVmAfdPrintCACertificates(\n    PVMAFD_CA_CERT_ARRAY pCertArray\n    )\n{\n    DWORD   dwError = 0;\n    PSTR    pszCN = NULL;\n    int     i = 0;\n    PVMAFD_CA_CERT  pCert = NULL;\n    if (!pCertArray || pCertArray->dwCount == 0)\n    {\n        dwError = ERROR_INVALID_PARAMETER;\n        BAIL_ON_VMAFD_ERROR(dwError);\n    }\n    fprintf(stdout,\n            \"Number of certificates:\\t%d\\n\",\n            pCertArray->dwCount\n            );\n    for (; i < pCertArray->dwCount; ++i)\n    {\n        fprintf(stdout, \"#%d:\\n\", i + 1);\n        pCert = &pCertArray->pCACerts[i];\n        dwError = VmAfdExtractCNFromDN((PSTR)pCert->pCN, &pszCN);\n        BAIL_ON_VMAFD_ERROR(dwError);\n        fprintf(stdout, \"CN(id):\\t\\t%s\\n\", pszCN);\n        fprintf(stdout, \"Subject DN:\\t%s\\n\", (PSTR)pCert->pSubjectDN);\n        fprintf(stdout, \"CRL present:\\t%s\\n\", (PSTR)pCert->pCrl ? \"yes\" : \"no\");\n        VMAFD_SAFE_FREE_MEMORY(pszCN);\n    }\ncleanup:\n    VMAFD_SAFE_FREE_MEMORY(pszCN);\n    return dwError;\nerror :\n    goto cleanup;\n"]], "pred": {"ppl": 1.7230257987976074, "ppl_lower": 2.2750096321105957, "ppl/lowercase_ppl": -1.5107729921376716, "ppl/zlib": 0.0012281759156176294, "Min_5.0% Prob": 6.292685417901902, "Min_10.0% Prob": 4.332655479741651, "Min_20.0% Prob": 2.5824168958198066, "Min_30.0% Prob": 1.795528061403573, "Min_40.0% Prob": 1.3579695292881557, "Min_50.0% Prob": 1.0891537022857702, "Min_60.0% Prob": 0.9078684054596612}}
{"hexsha": "3177db2380bfca5943a38670efaaf8a3cf546e4a", "ext": "c", "lang": "C", "content": "void dwc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes)\n{\n\tu32 __iomem *fifo = hsotg->regs + HCFIFO(0);\n\tu32 *data_buf = (u32 *)dest;\n\tint word_count = (bytes + 3) / 4;\n\tint i;\n\n\t/*\n\t * Todo: Account for the case where dest is not dword aligned. This\n\t * requires reading data from the FIFO into a u32 temp buffer, then\n\t * moving it into the data buffer.\n\t */\n\n\tdev_vdbg(hsotg->dev, \"%s(%p,%p,%d)\\n\", __func__, hsotg, dest, bytes);\n\n\tfor (i = 0; i < word_count; i++, data_buf++)\n\t\t*data_buf = readl(fifo);\n}", "item_id": 25, "repo": "xloem/DIY-LAPTOP", "file": "SOFTWARE/A64-TERES/linux-a64/drivers/staging/dwc2/core.c", "last_update_at": "2019-08-25T09:01:38+00:00", "question_id": "3177db2380bfca5943a38670efaaf8a3cf546e4a_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void dwc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes)\n{\n\tu32 __iomem *fifo = hsotg->regs + HCFIFO(0);\n\tu32 *data_buf = (u32 *)dest;\n\tint word_count = (bytes + 3) / 4;\n\tint i;\n\t/*\n\t * Todo: Account for the case where dest is not dword aligned. This\n\t * requires reading data from the FIFO into a u32 temp buffer, then\n\t * moving it into the data buffer.\n\t */\n\tdev_vdbg(hsotg->dev, \"%s(%p,%p,%d)\\n\", __func__, hsotg, dest, bytes);\n\tfor (i = 0; i < word_count; i++, data_buf++)\n\t\t*data_buf = readl(fifo);\n"]], "pred": {"ppl": 2.4535419940948486, "ppl_lower": 2.6158604621887207, "ppl/lowercase_ppl": -1.0713738899722105, "ppl/zlib": 0.002663301757854003, "Min_5.0% Prob": 7.094781832261519, "Min_10.0% Prob": 5.282114184421042, "Min_20.0% Prob": 3.661952397097712, "Min_30.0% Prob": 2.7663106469140537, "Min_40.0% Prob": 2.17035904366483, "Min_50.0% Prob": 1.7831046357750893, "Min_60.0% Prob": 1.5005997076442987}}
{"hexsha": "2ec7b61f41330cf1975c6510fbda249126dec49a", "ext": "c", "lang": "C", "content": "noreturn void run_current(void)\n{\n    struct proc *proc;\n    int launched;\n\n    proc = get_proc(current);\n    assert(proc->state == PROC_RUNNING, \"current must be running\");\n    launched = proc->launched;\n    proc->launched = 1;\n    hvm_switch(get_page(proc->hvm), get_page(proc->stack) + PAGE_SIZE,\n               kva2pa(get_page(proc->page_table_root)), ms_to_cycles(CONFIG_PREEMPT_TIMER),\n               launched);\n    __builtin_unreachable();\n}", "item_id": 7, "repo": "ProKil/OS2018spring-projects-g10", "file": "hv6/hv6/proc.c", "last_update_at": "2019-09-10T10:25:55+00:00", "question_id": "2ec7b61f41330cf1975c6510fbda249126dec49a_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["noreturn void run_current(void)\n{\n    struct proc *proc;\n    int launched;\n    proc = get_proc(current);\n    assert(proc->state == PROC_RUNNING, \"current must be running\");\n    launched = proc->launched;\n    proc->launched = 1;\n    hvm_switch(get_page(proc->hvm), get_page(proc->stack) + PAGE_SIZE,\n               kva2pa(get_page(proc->page_table_root)), ms_to_cycles(CONFIG_PREEMPT_TIMER),\n               launched);\n    __builtin_unreachable();\n"]], "pred": {"ppl": 4.36210823059082, "ppl_lower": 5.03397798538208, "ppl/lowercase_ppl": -1.0972568729196774, "ppl/zlib": 0.005475670927955042, "Min_5.0% Prob": 9.13287490606308, "Min_10.0% Prob": 7.0383085906505585, "Min_20.0% Prob": 5.105530835688114, "Min_30.0% Prob": 4.055529919763406, "Min_40.0% Prob": 3.3380075860768557, "Min_50.0% Prob": 2.8119936496019364, "Min_60.0% Prob": 2.4089857088401914}}
{"hexsha": "d0d5c4dbe09739450255955c46046a86d4433ac4", "ext": "c", "lang": "C", "content": "static ssize_t altr_edac_a10_device_trig(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dci = file->private_data;\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\tvoid __iomem *set_addr = (drvdata->base + priv->set_err_ofst);\n\tunsigned long flags;\n\tu8 trig_type;\n\n\tif (!user_buf || get_user(trig_type, user_buf))\n\t\treturn -EFAULT;\n\n\tlocal_irq_save(flags);\n\tif (trig_type == ALTR_UE_TRIGGER_CHAR)\n\t\twritel(priv->ue_set_mask, set_addr);\n\telse\n\t\twritel(priv->ce_set_mask, set_addr);\n\t/* Ensure the interrupt test bits are set */\n\twmb();\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}", "item_id": 32, "repo": "silentghoul-spec/Fuzzing-ext4", "file": "lkl/drivers/edac/altera_edac.c", "last_update_at": "2019-12-01T08:07:48+00:00", "question_id": "d0d5c4dbe09739450255955c46046a86d4433ac4_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t altr_edac_a10_device_trig(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dci = file->private_data;\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\tvoid __iomem *set_addr = (drvdata->base + priv->set_err_ofst);\n\tunsigned long flags;\n\tu8 trig_type;\n\tif (!user_buf || get_user(trig_type, user_buf))\n\t\treturn -EFAULT;\n\tlocal_irq_save(flags);\n\tif (trig_type == ALTR_UE_TRIGGER_CHAR)\n\t\twritel(priv->ue_set_mask, set_addr);\n\telse\n\t\twritel(priv->ce_set_mask, set_addr);\n\t/* Ensure the interrupt test bits are set */\n\twmb();\n\tlocal_irq_restore(flags);\n\treturn count;\n"]], "pred": {"ppl": 2.3073275089263916, "ppl_lower": 2.502964973449707, "ppl/lowercase_ppl": -1.097341306415075, "ppl/zlib": 0.002049240029998806, "Min_5.0% Prob": 7.712573528289795, "Min_10.0% Prob": 5.963114438518401, "Min_20.0% Prob": 3.8815388198821776, "Min_30.0% Prob": 2.729380316873814, "Min_40.0% Prob": 2.0877214782834055, "Min_50.0% Prob": 1.6705311032391752, "Min_60.0% Prob": 1.3961816660594195}}
{"hexsha": "29e080eea7b8731f5776c60bd5104a9744e2b051", "ext": "c", "lang": "C", "content": "XS_EUPXS(XS_threads__shared_cond_wait)\n{\n    dVAR; dXSARGS;\n    if (items < 1 || items > 2)\n       croak_xs_usage(cv,  \"ref_cond, ref_lock= 0\");\n    {\n#line 1542 \"shared.xs\"\n        SV *ssv;\n        perl_cond* user_condition;\n        int locks;\n        user_lock *ul;\n#line 1838 \"shared.c\"\n\tSV *\tref_cond = ST(0)\n;\n\tSV *\tref_lock;\n\n\tif (items < 2)\n\t    ref_lock = 0;\n\telse {\n\t    ref_lock = ST(1)\n;\n\t}\n#line 1547 \"shared.xs\"\n        if (!SvROK(ref_cond))\n            Perl_croak(aTHX_ \"Argument to cond_wait needs to be passed as ref\");\n        ref_cond = SvRV(ref_cond);\n        if (SvROK(ref_cond))\n            ref_cond = SvRV(ref_cond);\n        ssv = Perl_sharedsv_find(aTHX_ ref_cond);\n        if (! ssv)\n            Perl_croak(aTHX_ \"cond_wait can only be used on shared values\");\n        ul = S_get_userlock(aTHX_ ssv, 1);\n\n        user_condition = &ul->user_cond;\n        if (ref_lock && (ref_cond != ref_lock)) {\n            if (!SvROK(ref_lock))\n                Perl_croak(aTHX_ \"cond_wait lock needs to be passed as ref\");\n            ref_lock = SvRV(ref_lock);\n            if (SvROK(ref_lock)) ref_lock = SvRV(ref_lock);\n            ssv = Perl_sharedsv_find(aTHX_ ref_lock);\n            if (! ssv)\n                Perl_croak(aTHX_ \"cond_wait lock must be a shared value\");\n            ul = S_get_userlock(aTHX_ ssv, 1);\n        }\n        if (ul->lock.owner != aTHX)\n            croak(\"You need a lock before you can cond_wait\");\n\n        /* Stealing the members of the lock object worries me - NI-S */\n        MUTEX_LOCK(&ul->lock.mutex);\n        ul->lock.owner = NULL;\n        locks = ul->lock.locks;\n        ul->lock.locks = 0;\n\n        /* Since we are releasing the lock here, we need to tell other\n         * people that it is ok to go ahead and use it */\n        COND_SIGNAL(&ul->lock.cond);\n        COND_WAIT(user_condition, &ul->lock.mutex);\n        while (ul->lock.owner != NULL) {\n            /* OK -- must reacquire the lock */\n            COND_WAIT(&ul->lock.cond, &ul->lock.mutex);\n        }\n        ul->lock.owner = aTHX;\n        ul->lock.locks = locks;\n        MUTEX_UNLOCK(&ul->lock.mutex);\n#line 1891 \"shared.c\"\n    }\n    XSRETURN_EMPTY;\n}", "item_id": 45, "repo": "nneesshh/openresty-win32-build", "file": "openresty-win32-build/thirdparty/perl5-5.29.6/dist/threads-shared/shared.c", "last_update_at": "2019-01-12T03:20:41+00:00", "question_id": "29e080eea7b8731f5776c60bd5104a9744e2b051_45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["XS_EUPXS(XS_threads__shared_cond_wait)\n{\n    dVAR; dXSARGS;\n    if (items < 1 || items > 2)\n       croak_xs_usage(cv,  \"ref_cond, ref_lock= 0\");\n    {\n#line 1542 \"shared.xs\"\n        SV *ssv;\n        perl_cond* user_condition;\n        int locks;\n        user_lock *ul;\n#line 1838 \"shared.c\"\n\tSV *\tref_cond = ST(0)\n;\n\tSV *\tref_lock;\n\tif (items < 2)\n\t    ref_lock = 0;\n\telse {\n\t    ref_lock = ST(1)\n;\n\t}\n#line 1547 \"shared.xs\"\n        if (!SvROK(ref_cond))\n            Perl_croak(aTHX_ \"Argument to cond_wait needs to be passed as ref\");\n        ref_cond = SvRV(ref_cond);\n        if (SvROK(ref_cond))\n            ref_cond = SvRV(ref_cond);\n        ssv = Perl_sharedsv_find(aTHX_ ref_cond);\n        if (! ssv)\n            Perl_croak(aTHX_ \"cond_wait can only be used on shared values\");\n        ul = S_get_userlock(aTHX_ ssv, 1);\n        user_condition = &ul->user_cond;\n        if (ref_lock && (ref_cond != ref_lock)) {\n            if (!SvROK(ref_lock))\n                Perl_croak(aTHX_ \"cond_wait lock needs to be passed as ref\");\n            ref_lock = SvRV(ref_lock);\n            if (SvROK(ref_lock)) ref_lock = SvRV(ref_lock);\n            ssv = Perl_sharedsv_find(aTHX_ ref_lock);\n            if (! ssv)\n                Perl_croak(aTHX_ \"cond_wait lock must be a shared value\");\n            ul = S_get_userlock(aTHX_ ssv, 1);\n        }\n        if (ul->lock.owner != aTHX)\n            croak(\"You need a lock before you can cond_wait\");\n        /* Stealing the members of the lock object worries me - NI-S */\n        MUTEX_LOCK(&ul->lock.mutex);\n        ul->lock.owner = NULL;\n        locks = ul->lock.locks;\n        ul->lock.locks = 0;\n        /* Since we are releasing the lock here, we need to tell other\n         * people that it is ok to go ahead and use it */\n        COND_SIGNAL(&ul->lock.cond);\n        COND_WAIT(user_condition, &ul->lock.mutex);\n        while (ul->lock.owner != NULL) {\n            /* OK -- must reacquire the lock */\n            COND_WAIT(&ul->lock.cond, &ul->lock.mutex);\n        }\n        ul->lock.owner = aTHX;\n        ul->lock.locks = locks;\n        MUTEX_UNLOCK(&ul->lock.mutex);\n#line 1891 \"shared.c\"\n    }\n    XSRETURN_EMPTY;\n"]], "pred": {"ppl": 2.1277177333831787, "ppl_lower": 3.077662467956543, "ppl/lowercase_ppl": -1.4888689372523856, "ppl/zlib": 0.0009680127161468474, "Min_5.0% Prob": 6.526103287208371, "Min_10.0% Prob": 5.0189480229121886, "Min_20.0% Prob": 3.339177410891562, "Min_30.0% Prob": 2.432267880150181, "Min_40.0% Prob": 1.8696106574752114, "Min_50.0% Prob": 1.5082288821887913, "Min_60.0% Prob": 1.2576107157403698}}
{"hexsha": "1aa913fa09541a70d008e4fa9d917a39c4a4c231", "ext": "h", "lang": "C", "content": "class CloudToSpatial\n{\n    public:\n        CloudToSpatial() : listener_(tfBuffer), nh_(\"~\"){};\n        ~CloudToSpatial();\n\n        void callback(const PointCloud2ConstPtr& cloud_msg_ptr, const BinInfoPtr& target_bin_ptr);\n\n        void onInit();\n\n        void subsribe();\n\n        \n        ros::Publisher dist_pub;\n        ros::Publisher height_pub;\n        tf2_ros::Buffer tfBuffer;\n        tf2_ros::TransformListener listener_;\n        ros::NodeHandle nh_;\n\n        Synchronizer<MySyncPolicy> * sync;\n\n\n    private: \n        uint8_t dist(const float x, const float y, const float z, const jsk_recognition_msgs::BoundingBox & bbox);\n        uint8_t height(const float z, const jsk_recognition_msgs::BoundingBox & bbox);\n\n}", "item_id": 0, "repo": "pazeshun/jsk_apc", "file": "jsk_apc2016_common/include/sib/cloud_to_spatial_features.h", "last_update_at": "2019-08-19T12:58:10+00:00", "question_id": "1aa913fa09541a70d008e4fa9d917a39c4a4c231_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CloudToSpatial\n{\n    public:\n        CloudToSpatial() : listener_(tfBuffer), nh_(\"~\"){};\n        ~CloudToSpatial();\n        void callback(const PointCloud2ConstPtr& cloud_msg_ptr, const BinInfoPtr& target_bin_ptr);\n        void onInit();\n        void subsribe();\n        ros::Publisher dist_pub;\n        ros::Publisher height_pub;\n        tf2_ros::Buffer tfBuffer;\n        tf2_ros::TransformListener listener_;\n        ros::NodeHandle nh_;\n        Synchronizer<MySyncPolicy> * sync;\n    private: \n        uint8_t dist(const float x, const float y, const float z, const jsk_recognition_msgs::BoundingBox & bbox);\n        uint8_t height(const float z, const jsk_recognition_msgs::BoundingBox & bbox);\n"]], "pred": {"ppl": 3.3622469902038574, "ppl_lower": 4.744480609893799, "ppl/lowercase_ppl": -1.2839928837041288, "ppl/zlib": 0.0036414699626063237, "Min_5.0% Prob": 8.800583015788686, "Min_10.0% Prob": 7.058285277822743, "Min_20.0% Prob": 4.98800959535267, "Min_30.0% Prob": 3.701594365494592, "Min_40.0% Prob": 2.930775769936141, "Min_50.0% Prob": 2.394027291964262, "Min_60.0% Prob": 2.0188056367316416}}
{"hexsha": "0af2fc52eff76578ae5c4d3cc3fd7ad67ba37d5f", "ext": "c", "lang": "C", "content": "int kvtree_util_get_int64(const kvtree* hash, const char* key, int64_t* val)\n{\n  int rc = KVTREE_FAILURE;\n\n  /* check whether this key is even set */\n  char* val_str = kvtree_get_val(hash, key);\n  if (val_str != NULL) {\n    /* convert the key string */\n    *val = (int64_t) strtoll(val_str, NULL, 0);\n    rc = KVTREE_SUCCESS;\n  }\n\n  return rc;\n}", "item_id": 13, "repo": "CamStan/KVTree", "file": "src/kvtree_util.c", "last_update_at": "2019-04-22T05:44:50+00:00", "question_id": "0af2fc52eff76578ae5c4d3cc3fd7ad67ba37d5f_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int kvtree_util_get_int64(const kvtree* hash, const char* key, int64_t* val)\n{\n  int rc = KVTREE_FAILURE;\n  /* check whether this key is even set */\n  char* val_str = kvtree_get_val(hash, key);\n  if (val_str != NULL) {\n    /* convert the key string */\n    *val = (int64_t) strtoll(val_str, NULL, 0);\n    rc = KVTREE_SUCCESS;\n  }\n  return rc;\n"]], "pred": {"ppl": 2.438171148300171, "ppl_lower": 2.9722986221313477, "ppl/lowercase_ppl": -1.2222583619423542, "ppl/zlib": 0.003891913663241684, "Min_5.0% Prob": 7.545519147600446, "Min_10.0% Prob": 5.880099739347186, "Min_20.0% Prob": 3.9325756533392546, "Min_30.0% Prob": 2.867299372499639, "Min_40.0% Prob": 2.2090498759584913, "Min_50.0% Prob": 1.7766761828616664, "Min_60.0% Prob": 1.4973488468147644}}
{"hexsha": "2ea5899817d70ead86f04794d19e7fd67b990f0c", "ext": "c", "lang": "C", "content": "static void MMC_DecodeExtendedCsd(mmc_card_t *card, uint32_t *rawExtendedCsd)\n{\n    assert(card);\n    assert(rawExtendedCsd);\n\n    uint8_t *buffer = (uint8_t *)rawExtendedCsd;\n    mmc_extended_csd_t *extendedCsd = &(card->extendedCsd);\n\n    /* Extended CSD is transferred as a data block from least byte indexed 0. */\n    extendedCsd->bootPartitionWP = buffer[173U];\n    extendedCsd->bootWPStatus = buffer[174U];\n    extendedCsd->highDensityEraseGroupDefinition = buffer[175U];\n    extendedCsd->bootDataBusConditions = buffer[177U];\n    extendedCsd->bootConfigProtect = buffer[178U];\n    extendedCsd->partitionConfig = buffer[179U];\n    extendedCsd->eraseMemoryContent = buffer[181U];\n    extendedCsd->dataBusWidth = buffer[183U];\n    extendedCsd->highSpeedTiming = buffer[185U];\n    extendedCsd->powerClass = buffer[187U];\n    extendedCsd->commandSetRevision = buffer[189U];\n    extendedCsd->commandSet = buffer[191U];\n    extendedCsd->extendecCsdVersion = buffer[192U];\n    extendedCsd->csdStructureVersion = buffer[194U];\n    extendedCsd->partitionAttribute = buffer[156U];\n    extendedCsd->extPartitionSupport = buffer[494U];\n    extendedCsd->cardType = buffer[196U];\n    /* This field define the type of the card. The only currently valid values for this field are 0x01 and 0x03. */\n    card->flags |= extendedCsd->cardType;\n\n    extendedCsd->ioDriverStrength = buffer[197U];\n\n    extendedCsd->powerClass52MHz195V = buffer[200U];\n    extendedCsd->powerClass26MHz195V = buffer[201U];\n    extendedCsd->powerClass52MHz360V = buffer[202U];\n    extendedCsd->powerClass26MHz360V = buffer[203U];\n    extendedCsd->powerClass200MHZVCCQ130VVCC360V = buffer[236U];\n    extendedCsd->powerClass200MHZVCCQ195VVCC360V = buffer[237U];\n    extendedCsd->powerClass52MHZDDR195V = buffer[238U];\n    extendedCsd->powerClass52MHZDDR360V = buffer[239U];\n    extendedCsd->powerClass200MHZDDR360V = buffer[253U];\n    extendedCsd->minimumReadPerformance4Bit26MHz = buffer[205U];\n    extendedCsd->minimumWritePerformance4Bit26MHz = buffer[206U];\n    extendedCsd->minimumReadPerformance8Bit26MHz4Bit52MHz = buffer[207U];\n    extendedCsd->minimumWritePerformance8Bit26MHz4Bit52MHz = buffer[208U];\n    extendedCsd->minimumReadPerformance8Bit52MHz = buffer[209U];\n    extendedCsd->minimumWritePerformance8Bit52MHz = buffer[210U];\n    extendedCsd->minReadPerformance8bitAt52MHZDDR = buffer[234U];\n    extendedCsd->minWritePerformance8bitAt52MHZDDR = buffer[235U];\n    /* Get user partition size. */\n    extendedCsd->sectorCount = ((((uint32_t)buffer[215U]) << 24U) + (((uint32_t)buffer[214U]) << 16U) +\n                                (((uint32_t)buffer[213U]) << 8U) + (uint32_t)buffer[212U]);\n    if (card->flags & kMMC_SupportHighCapacityFlag)\n    {\n        card->userPartitionBlocks = card->extendedCsd.sectorCount;\n    }\n\n    extendedCsd->sleepAwakeTimeout = buffer[217U];\n    extendedCsd->sleepCurrentVCCQ = buffer[219U];\n    extendedCsd->sleepCurrentVCC = buffer[220U];\n    extendedCsd->highCapacityWriteProtectGroupSize = buffer[221U];\n    extendedCsd->reliableWriteSectorCount = buffer[222U];\n    extendedCsd->highCapacityEraseTimeout = buffer[223U];\n    extendedCsd->highCapacityEraseUnitSize = buffer[224U];\n    extendedCsd->accessSize = buffer[225U];\n\n    /* Get boot partition size: 128KB * BOOT_SIZE_MULT*/\n    card->bootPartitionBlocks = ((128U * 1024U * buffer[226U]) / FSL_SDMMC_DEFAULT_BLOCK_SIZE);\n\n    /* Check if card support boot mode. */\n    if (buffer[228U] & 0x1U)\n    {\n        card->flags |= kMMC_SupportAlternateBootFlag;\n    }\n    else if (buffer[228U] & 0x2U)\n    {\n        card->flags |= kMMC_SupportDDRBootFlag;\n    }\n    else if (buffer[228U] & 0x4U)\n    {\n        card->flags |= kMMC_SupportHighSpeedBootFlag;\n    }\n    else\n    {\n    }\n    /* cache size unit 1kb */\n    extendedCsd->cacheSize = (((uint32_t)buffer[252U]) << 24) | (((uint32_t)buffer[251U]) << 16) |\n                             (((uint32_t)buffer[250U]) << 8) | (((uint32_t)buffer[249U]));\n\n    extendedCsd->supportedCommandSet = buffer[504U];\n}", "item_id": 11, "repo": "sdew/micropython-rocky", "file": "ports/nxp_rt105/sdmmc/fsl_mmc.c", "last_update_at": "2019-05-10T05:54:10+00:00", "question_id": "2ea5899817d70ead86f04794d19e7fd67b990f0c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void MMC_DecodeExtendedCsd(mmc_card_t *card, uint32_t *rawExtendedCsd)\n{\n    assert(card);\n    assert(rawExtendedCsd);\n    uint8_t *buffer = (uint8_t *)rawExtendedCsd;\n    mmc_extended_csd_t *extendedCsd = &(card->extendedCsd);\n    /* Extended CSD is transferred as a data block from least byte indexed 0. */\n    extendedCsd->bootPartitionWP = buffer[173U];\n    extendedCsd->bootWPStatus = buffer[174U];\n    extendedCsd->highDensityEraseGroupDefinition = buffer[175U];\n    extendedCsd->bootDataBusConditions = buffer[177U];\n    extendedCsd->bootConfigProtect = buffer[178U];\n    extendedCsd->partitionConfig = buffer[179U];\n    extendedCsd->eraseMemoryContent = buffer[181U];\n    extendedCsd->dataBusWidth = buffer[183U];\n    extendedCsd->highSpeedTiming = buffer[185U];\n    extendedCsd->powerClass = buffer[187U];\n    extendedCsd->commandSetRevision = buffer[189U];\n    extendedCsd->commandSet = buffer[191U];\n    extendedCsd->extendecCsdVersion = buffer[192U];\n    extendedCsd->csdStructureVersion = buffer[194U];\n    extendedCsd->partitionAttribute = buffer[156U];\n    extendedCsd->extPartitionSupport = buffer[494U];\n    extendedCsd->cardType = buffer[196U];\n    /* This field define the type of the card. The only currently valid values for this field are 0x01 and 0x03. */\n    card->flags |= extendedCsd->cardType;\n    extendedCsd->ioDriverStrength = buffer[197U];\n    extendedCsd->powerClass52MHz195V = buffer[200U];\n    extendedCsd->powerClass26MHz195V = buffer[201U];\n    extendedCsd->powerClass52MHz360V = buffer[202U];\n    extendedCsd->powerClass26MHz360V = buffer[203U];\n    extendedCsd->powerClass200MHZVCCQ130VVCC360V = buffer[236U];\n    extendedCsd->powerClass200MHZVCCQ195VVCC360V = buffer[237U];\n    extendedCsd->powerClass52MHZDDR195V = buffer[238U];\n    extendedCsd->powerClass52MHZDDR360V = buffer[239U];\n    extendedCsd->powerClass200MHZDDR360V = buffer[253U];\n    extendedCsd->minimumReadPerformance4Bit26MHz = buffer[205U];\n    extendedCsd->minimumWritePerformance4Bit26MHz = buffer[206U];\n    extendedCsd->minimumReadPerformance8Bit26MHz4Bit52MHz = buffer[207U];\n    extendedCsd->minimumWritePerformance8Bit26MHz4Bit52MHz = buffer[208U];\n    extendedCsd->minimumReadPerformance8Bit52MHz = buffer[209U];\n    extendedCsd->minimumWritePerformance8Bit52MHz = buffer[210U];\n    extendedCsd->minReadPerformance8bitAt52MHZDDR = buffer[234U];\n    extendedCsd->minWritePerformance8bitAt52MHZDDR = buffer[235U];\n    /* Get user partition size. */\n    extendedCsd->sectorCount = ((((uint32_t)buffer[215U]) << 24U) + (((uint32_t)buffer[214U]) << 16U) +\n                                (((uint32_t)buffer[213U]) << 8U) + (uint32_t)buffer[212U]);\n    if (card->flags & kMMC_SupportHighCapacityFlag)\n    {\n        card->userPartitionBlocks = card->extendedCsd.sectorCount;\n    }\n    extendedCsd->sleepAwakeTimeout = buffer[217U];\n    extendedCsd->sleepCurrentVCCQ = buffer[219U];\n    extendedCsd->sleepCurrentVCC = buffer[220U];\n    extendedCsd->highCapacityWriteProtectGroupSize = buffer[221U];\n    extendedCsd->reliableWriteSectorCount = buffer[222U];\n    extendedCsd->highCapacityEraseTimeout = buffer[223U];\n    extendedCsd->highCapacityEraseUnitSize = buffer[224U];\n    extendedCsd->accessSize = buffer[225U];\n    /* Get boot partition size: 128KB * BOOT_SIZE_MULT*/\n    card->bootPartitionBlocks = ((128U * 1024U * buffer[226U]) / FSL_SDMMC_DEFAULT_BLOCK_SIZE);\n    /* Check if card support boot mode. */\n    if (buffer[228U] & 0x1U)\n    {\n        card->flags |= kMMC_SupportAlternateBootFlag;\n    }\n    else if (buffer[228U] & 0x2U)\n    {\n        card->flags |= kMMC_SupportDDRBootFlag;\n    }\n    else if (buffer[228U] & 0x4U)\n    {\n        card->flags |= kMMC_SupportHighSpeedBootFlag;\n    }\n    else\n    {\n    }\n    /* cache size unit 1kb */\n    extendedCsd->cacheSize = (((uint32_t)buffer[252U]) << 24) | (((uint32_t)buffer[251U]) << 16) |\n                             (((uint32_t)buffer[250U]) << 8) | (((uint32_t)buffer[249U]));\n    extendedCsd->supportedCommandSet = buffer[504U];\n"]], "pred": {"ppl": 1.4012067317962646, "ppl_lower": 1.7115432024002075, "ppl/lowercase_ppl": -1.5930671476851408, "ppl/zlib": 0.00028807328491680544, "Min_5.0% Prob": 4.251265609965605, "Min_10.0% Prob": 2.857310902254254, "Min_20.0% Prob": 1.6419353842297022, "Min_30.0% Prob": 1.1171753700286928, "Min_40.0% Prob": 0.84114398851007, "Min_50.0% Prob": 0.6746276349199247, "Min_60.0% Prob": 0.5627719365860994}}
{"hexsha": "9b3a0403751119b51f3d6dd8940b316229054d56", "ext": "c", "lang": "C", "content": "static int availablePages_add(stasis_allocation_policy_t *ap, pageid_t pageid, size_t freespace) {\n  int ret = availablePages_remove(ap, pageid);\n  availablePages_pageid_freespace* tup= malloc(sizeof(*tup));\n  tup->pageid = pageid;\n  tup->freespace = freespace;\n  void_double_add(tup, ap->availablePages_key_pageid, ap->availablePages_key_freespace_pageid);\n  return ret;\n}", "item_id": 3, "repo": "Zhoutall/stasis", "file": "src/stasis/allocationPolicy.c", "last_update_at": "2019-11-21T07:21:32+00:00", "question_id": "9b3a0403751119b51f3d6dd8940b316229054d56_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int availablePages_add(stasis_allocation_policy_t *ap, pageid_t pageid, size_t freespace) {\n  int ret = availablePages_remove(ap, pageid);\n  availablePages_pageid_freespace* tup= malloc(sizeof(*tup));\n  tup->pageid = pageid;\n  tup->freespace = freespace;\n  void_double_add(tup, ap->availablePages_key_pageid, ap->availablePages_key_freespace_pageid);\n  return ret;\n"]], "pred": {"ppl": 4.584193706512451, "ppl_lower": 4.504124641418457, "ppl/lowercase_ppl": -0.9884273565481754, "ppl/zlib": 0.007971802280692287, "Min_5.0% Prob": 8.813720941543579, "Min_10.0% Prob": 7.611727494459886, "Min_20.0% Prob": 6.090391370985243, "Min_30.0% Prob": 4.709563618753014, "Min_40.0% Prob": 3.753346825087512, "Min_50.0% Prob": 3.035332117448835, "Min_60.0% Prob": 2.5339040372338966}}
{"hexsha": "648b39386988bc8b5400045912c1345e5f91f359", "ext": "c", "lang": "C", "content": "int\ngem_add_rxbuf(struct gem_softc *sc, int idx)\n{\n\tstruct gem_rxsoft *rxs = &sc->sc_rxsoft[idx];\n\tstruct mbuf *m;\n\tint error;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\treturn (ENOBUFS);\n\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\treturn (ENOBUFS);\n\t}\n\n#ifdef GEM_DEBUG\n/* bzero the packet to check dma */\n\tmemset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);\n#endif\n\n\tif (rxs->rxs_mbuf != NULL)\n\t\tbus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);\n\n\trxs->rxs_mbuf = m;\n\n\terror = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,\n\t    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,\n\t    BUS_DMA_READ|BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tprintf(\"%s: can't load rx DMA map %d, error = %d\\n\",\n\t\t    sc->sc_dev.dv_xname, idx, error);\n\t\tpanic(\"gem_add_rxbuf\");\t/* XXX */\n\t}\n\n\tbus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,\n\t    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);\n\n\tGEM_INIT_RXDESC(sc, idx);\n\n\treturn (0);\n}", "item_id": 13, "repo": "shisa/kame-shisa", "file": "openbsd/sys/dev/ic/gem.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "648b39386988bc8b5400045912c1345e5f91f359_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ngem_add_rxbuf(struct gem_softc *sc, int idx)\n{\n\tstruct gem_rxsoft *rxs = &sc->sc_rxsoft[idx];\n\tstruct mbuf *m;\n\tint error;\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL)\n\t\treturn (ENOBUFS);\n\tMCLGET(m, M_DONTWAIT);\n\tif ((m->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\treturn (ENOBUFS);\n\t}\n#ifdef GEM_DEBUG\n/* bzero the packet to check dma */\n\tmemset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);\n#endif\n\tif (rxs->rxs_mbuf != NULL)\n\t\tbus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);\n\trxs->rxs_mbuf = m;\n\terror = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,\n\t    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,\n\t    BUS_DMA_READ|BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tprintf(\"%s: can't load rx DMA map %d, error = %d\\n\",\n\t\t    sc->sc_dev.dv_xname, idx, error);\n\t\tpanic(\"gem_add_rxbuf\");\t/* XXX */\n\t}\n\tbus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,\n\t    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);\n\tGEM_INIT_RXDESC(sc, idx);\n\treturn (0);\n"]], "pred": {"ppl": 1.464057445526123, "ppl_lower": 1.9626153707504272, "ppl/lowercase_ppl": -1.7687758240595775, "ppl/zlib": 0.0007504166407808112, "Min_5.0% Prob": 4.957660083770752, "Min_10.0% Prob": 3.318322259187698, "Min_20.0% Prob": 1.8558950818116122, "Min_30.0% Prob": 1.266366326823732, "Min_40.0% Prob": 0.9512778724045815, "Min_50.0% Prob": 0.7635183900655691, "Min_60.0% Prob": 0.6352561610000109}}
{"hexsha": "c70847b21b86440e1c12f4aa8ee6c48596cf6145", "ext": "c", "lang": "C", "content": "static void\nresizeDamageRectangle(CompScreen *s,\n                      BoxPtr pBox)\n{\n   REGION reg;\n\n   reg.rects = &reg.extents;\n   reg.numRects = 1;\n\n   reg.extents = *pBox;\n\n   reg.extents.x1 -= 1;\n   reg.extents.y1 -= 1;\n   reg.extents.x2 += 1;\n   reg.extents.y2 += 1;\n\n   damageScreenRegion(s, &reg);\n}", "item_id": 3, "repo": "zmike/compiz", "file": "src/exports/plugins/resize.c", "last_update_at": "2019-09-17T07:24:13+00:00", "question_id": "c70847b21b86440e1c12f4aa8ee6c48596cf6145_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nresizeDamageRectangle(CompScreen *s,\n                      BoxPtr pBox)\n{\n   REGION reg;\n   reg.rects = &reg.extents;\n   reg.numRects = 1;\n   reg.extents = *pBox;\n   reg.extents.x1 -= 1;\n   reg.extents.y1 -= 1;\n   reg.extents.x2 += 1;\n   reg.extents.y2 += 1;\n   damageScreenRegion(s, &reg);\n"]], "pred": {"ppl": 2.1923890113830566, "ppl_lower": 2.977604389190674, "ppl/lowercase_ppl": -1.389975093171964, "ppl/zlib": 0.0046175989531571345, "Min_5.0% Prob": 6.619237105051677, "Min_10.0% Prob": 5.2219508061042195, "Min_20.0% Prob": 3.487011401741593, "Min_30.0% Prob": 2.5696881368756292, "Min_40.0% Prob": 1.957765971896825, "Min_50.0% Prob": 1.5656438280609162, "Min_60.0% Prob": 1.3168272420786966}}
{"hexsha": "40c893488931ccacb1d9056fb6e45fa75aab5224", "ext": "c", "lang": "C", "content": "void mouse_cursor_get_rel(int *x, int *y, int *z)\n{\n\tmouse_cursor_poll();\n\n\tif (x) {\n\t\t*x = mouse_rel_x / 256;\n\t\tmouse_rel_x = 0;\n\t}\n\tif (y) {\n\t\t*y = mouse_rel_y / 256;\n\t\tmouse_rel_y = 0;\n\t}\n\tif (z) {\n\t\t*z = mouse_rel_z / 256;\n\t\tmouse_rel_z = 0;\n\t}\n}", "item_id": 3, "repo": "fabiojna02/OpenCellular", "file": "firmware/coreboot/payloads/libpayload/drivers/mouse_cursor.c", "last_update_at": "2019-11-04T07:11:25+00:00", "question_id": "40c893488931ccacb1d9056fb6e45fa75aab5224_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mouse_cursor_get_rel(int *x, int *y, int *z)\n{\n\tmouse_cursor_poll();\n\tif (x) {\n\t\t*x = mouse_rel_x / 256;\n\t\tmouse_rel_x = 0;\n\t}\n\tif (y) {\n\t\t*y = mouse_rel_y / 256;\n\t\tmouse_rel_y = 0;\n\t}\n\tif (z) {\n\t\t*z = mouse_rel_z / 256;\n\t\tmouse_rel_z = 0;\n\t}\n"]], "pred": {"ppl": 1.995725393295288, "ppl_lower": 1.995725393295288, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005356647983838033, "Min_5.0% Prob": 7.624043192182269, "Min_10.0% Prob": 5.180507516860962, "Min_20.0% Prob": 3.2338367899258933, "Min_30.0% Prob": 2.2904415276315477, "Min_40.0% Prob": 1.7422980405390263, "Min_50.0% Prob": 1.380684498231858, "Min_60.0% Prob": 1.1537295933403484}}
{"hexsha": "d6464492451203d116118e70df3ddfa4c7451027", "ext": "c", "lang": "C", "content": "void WM_recover_last_session(bContext *C, ReportList *reports)\n{\n  char filepath[FILE_MAX];\n\n  BLI_make_file_string(\"/\", filepath, BKE_tempdir_base(), BLENDER_QUIT_FILE);\n  /* if reports==NULL, it's called directly without operator, we add a quick check here */\n  if (reports || BLI_exists(filepath)) {\n    G.fileflags |= G_FILE_RECOVER;\n\n    wm_file_read_opwrap(C, filepath, reports, true);\n\n    G.fileflags &= ~G_FILE_RECOVER;\n\n    /* XXX bad global... fixme */\n    Main *bmain = CTX_data_main(C);\n    if (BKE_main_blendfile_path(bmain)[0] != '\\0') {\n      G.file_loaded = 1; /* prevents splash to show */\n    }\n    else {\n      G.relbase_valid = 0;\n      G.save_over = 0; /* start with save preference untitled.blend */\n    }\n  }\n}", "item_id": 44, "repo": "BlazesRus/Bforartists", "file": "source/blender/windowmanager/intern/wm_files.c", "last_update_at": "2019-07-08T15:51:14+00:00", "question_id": "d6464492451203d116118e70df3ddfa4c7451027_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void WM_recover_last_session(bContext *C, ReportList *reports)\n{\n  char filepath[FILE_MAX];\n  BLI_make_file_string(\"/\", filepath, BKE_tempdir_base(), BLENDER_QUIT_FILE);\n  /* if reports==NULL, it's called directly without operator, we add a quick check here */\n  if (reports || BLI_exists(filepath)) {\n    G.fileflags |= G_FILE_RECOVER;\n    wm_file_read_opwrap(C, filepath, reports, true);\n    G.fileflags &= ~G_FILE_RECOVER;\n    /* XXX bad global... fixme */\n    Main *bmain = CTX_data_main(C);\n    if (BKE_main_blendfile_path(bmain)[0] != '\\0') {\n      G.file_loaded = 1; /* prevents splash to show */\n    }\n    else {\n      G.relbase_valid = 0;\n      G.save_over = 0; /* start with save preference untitled.blend */\n    }\n  }\n"]], "pred": {"ppl": 4.419254779815674, "ppl_lower": 7.642487525939941, "ppl/lowercase_ppl": -1.3686155605085415, "ppl/zlib": 0.0032587085088224984, "Min_5.0% Prob": 8.691558701651436, "Min_10.0% Prob": 7.197947638375418, "Min_20.0% Prob": 5.503405928611755, "Min_30.0% Prob": 4.353777893951961, "Min_40.0% Prob": 3.544949436826365, "Min_50.0% Prob": 2.9366158549274717, "Min_60.0% Prob": 2.4762321638298177}}
{"hexsha": "8dea57adf6a1639529d5c347d88712d3ce896f0e", "ext": "c", "lang": "C", "content": "static int dyn_buf_resize(DynBuf *s, int size)\n{\n    int new_size;\n    uint8_t *new_buf;\n\n    if (size <= s->size)\n        return 0;\n    new_size = (s->size * 3) / 2;\n    if (new_size < size)\n        new_size = size;\n    new_buf = realloc(s->buf, new_size);\n    if (!new_buf) \n        return -1;\n    s->buf = new_buf;\n    s->size = new_size;\n    return 0;\n}", "item_id": 43, "repo": "netroby/libbpg", "file": "bpgenc.c", "last_update_at": "2019-05-03T01:27:58+00:00", "question_id": "8dea57adf6a1639529d5c347d88712d3ce896f0e_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int dyn_buf_resize(DynBuf *s, int size)\n{\n    int new_size;\n    uint8_t *new_buf;\n    if (size <= s->size)\n        return 0;\n    new_size = (s->size * 3) / 2;\n    if (new_size < size)\n        new_size = size;\n    new_buf = realloc(s->buf, new_size);\n    if (!new_buf) \n        return -1;\n    s->buf = new_buf;\n    s->size = new_size;\n    return 0;\n"]], "pred": {"ppl": 1.5922306776046753, "ppl_lower": 1.7196259498596191, "ppl/lowercase_ppl": -1.1654802582371582, "ppl/zlib": 0.002627886863945636, "Min_5.0% Prob": 5.735561030251639, "Min_10.0% Prob": 3.7193960587183637, "Min_20.0% Prob": 2.16128601928552, "Min_30.0% Prob": 1.5099380870660146, "Min_40.0% Prob": 1.1603520097831885, "Min_50.0% Prob": 0.9257211031784353, "Min_60.0% Prob": 0.7757815538629235}}
{"hexsha": "acf2df8bea9358e1c836abacb2d58910c72daab9", "ext": "c", "lang": "C", "content": "void vf_define(int code, FILE * vffile)\n{\n    int i, len, lenm;\n\n    vffont.k = read_n(vffile, code - FNT_DEF_1 + 1);\n    vffont.c = read_n(vffile,4);\n    vffont.s = read_long(vffile);\n    vffont.d = read_long(vffile);\n    vffont.a = read_byte(vffile);\n    vffont.l = read_byte(vffile);\n\n    if (vffont.a == EOF || vffont.l == EOF) {\n        fprintf(stderr, \"Bad VF file\\n\");\n        exit(252);\n    }\n    vffont.n = read_str(vffile, vffont.a + vffont.l);\n}", "item_id": 13, "repo": "aminophen/dviout-util", "file": "00texjporg/chkdvifont.c", "last_update_at": "2019-11-16T00:34:09+00:00", "question_id": "acf2df8bea9358e1c836abacb2d58910c72daab9_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void vf_define(int code, FILE * vffile)\n{\n    int i, len, lenm;\n    vffont.k = read_n(vffile, code - FNT_DEF_1 + 1);\n    vffont.c = read_n(vffile,4);\n    vffont.s = read_long(vffile);\n    vffont.d = read_long(vffile);\n    vffont.a = read_byte(vffile);\n    vffont.l = read_byte(vffile);\n    if (vffont.a == EOF || vffont.l == EOF) {\n        fprintf(stderr, \"Bad VF file\\n\");\n        exit(252);\n    }\n    vffont.n = read_str(vffile, vffont.a + vffont.l);\n"]], "pred": {"ppl": 3.6659433841705322, "ppl_lower": 3.8149361610412598, "ppl/lowercase_ppl": -1.030666356297083, "ppl/zlib": 0.005851737413556713, "Min_5.0% Prob": 8.528183889389037, "Min_10.0% Prob": 7.116789363679432, "Min_20.0% Prob": 5.10205620388652, "Min_30.0% Prob": 3.9876760666186994, "Min_40.0% Prob": 3.17666733196412, "Min_50.0% Prob": 2.5813254328495865, "Min_60.0% Prob": 2.164395824643492}}
{"hexsha": "d206af568628fe6102209af84f0b5b12b8fb734c", "ext": "c", "lang": "C", "content": "static readstat_error_t xport_read_labels_v9(xport_ctx_t *ctx, int label_count) {\n    readstat_error_t retval = READSTAT_OK;\n    uint16_t labeldef[5];\n    int i;\n    for (i=0; i<label_count; i++) {\n        int index, name_len, format_len, informat_len, label_len;\n        if (read_bytes(ctx, labeldef, sizeof(labeldef)) != sizeof(labeldef)) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        if (machine_is_little_endian()) {\n            index = byteswap2(labeldef[0]);\n            name_len = byteswap2(labeldef[1]);\n            format_len = byteswap2(labeldef[2]);\n            informat_len = byteswap2(labeldef[3]);\n            label_len = byteswap2(labeldef[4]);\n        } else {\n            index = labeldef[0];\n            name_len = labeldef[1];\n            format_len = labeldef[2];\n            informat_len = labeldef[3];\n            label_len = labeldef[4];\n        }\n\n        if (index >= ctx->var_count) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n#if !defined _MSC_VER\n        char name[name_len+1];\n        char format[format_len+1];\n        char informat[informat_len+1];\n        char label[label_len+1];\n#else\n        char * name = malloc((sizeof(char))*(name_len + 1 + 1));\n        char * format = malloc((sizeof(char))*(format_len + 1 + 1));\n        char * informat = malloc((sizeof(char))*(informat_len + 1 + 1));\n        char * label = malloc((sizeof(char))*(label_len + 1 + 1));\n#endif\n\n        readstat_variable_t *variable = ctx->variables[index];\n\n        if (read_bytes(ctx, name, name_len) != name_len ||\n                read_bytes(ctx, format, format_len) != format_len ||\n                read_bytes(ctx, informat, informat_len) != informat_len ||\n                read_bytes(ctx, label, label_len) != label_len) {\n            retval = READSTAT_ERROR_READ;\n#if defined _MSC_VER\n            free(name);\n            free(format);\n            free(informat);\n            free(label);\n#endif\n            goto cleanup;\n        }\n\n        retval = readstat_convert(variable->name, sizeof(variable->name),\n                name, name_len,  NULL);\n#if defined _MSC_VER\n        free(name);\n#endif\n        if (retval != READSTAT_OK) {\n#if defined _MSC_VER\n            free(format);\n            free(informat);\n            free(label);\n#endif\n            goto cleanup;\n        }\n\n        retval = readstat_convert(variable->label, sizeof(variable->label),\n                label, label_len,  NULL);\n#if defined _MSC_VER\n        free(label);\n#endif\n        if (retval != READSTAT_OK) {\n#if defined _MSC_VER\n            free(format);\n            free(informat);\n#endif\n            goto cleanup;\n        }\n\n        retval = xport_construct_format(variable->format, sizeof(variable->format),\n                format, format_len, variable->display_width, variable->decimals);\n#if defined _MSC_VER\n        free(format);\n        free(informat);\n#endif\n        if (retval != READSTAT_OK)\n            goto cleanup;\n    }\n\n    retval = xport_skip_rest_of_record(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    retval = xport_read_obs_header_record(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\ncleanup:\n    return retval;\n}", "item_id": 12, "repo": "dfaure-kdab/ReadStat", "file": "src/sas/readstat_xport_read.c", "last_update_at": "2019-07-26T17:27:07+00:00", "question_id": "d206af568628fe6102209af84f0b5b12b8fb734c_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static readstat_error_t xport_read_labels_v9(xport_ctx_t *ctx, int label_count) {\n    readstat_error_t retval = READSTAT_OK;\n    uint16_t labeldef[5];\n    int i;\n    for (i=0; i<label_count; i++) {\n        int index, name_len, format_len, informat_len, label_len;\n        if (read_bytes(ctx, labeldef, sizeof(labeldef)) != sizeof(labeldef)) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n        if (machine_is_little_endian()) {\n            index = byteswap2(labeldef[0]);\n            name_len = byteswap2(labeldef[1]);\n            format_len = byteswap2(labeldef[2]);\n            informat_len = byteswap2(labeldef[3]);\n            label_len = byteswap2(labeldef[4]);\n        } else {\n            index = labeldef[0];\n            name_len = labeldef[1];\n            format_len = labeldef[2];\n            informat_len = labeldef[3];\n            label_len = labeldef[4];\n        }\n        if (index >= ctx->var_count) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n#if !defined _MSC_VER\n        char name[name_len+1];\n        char format[format_len+1];\n        char informat[informat_len+1];\n        char label[label_len+1];\n#else\n        char * name = malloc((sizeof(char))*(name_len + 1 + 1));\n        char * format = malloc((sizeof(char))*(format_len + 1 + 1));\n        char * informat = malloc((sizeof(char))*(informat_len + 1 + 1));\n        char * label = malloc((sizeof(char))*(label_len + 1 + 1));\n#endif\n        readstat_variable_t *variable = ctx->variables[index];\n        if (read_bytes(ctx, name, name_len) != name_len ||\n                read_bytes(ctx, format, format_len) != format_len ||\n                read_bytes(ctx, informat, informat_len) != informat_len ||\n                read_bytes(ctx, label, label_len) != label_len) {\n            retval = READSTAT_ERROR_READ;\n#if defined _MSC_VER\n            free(name);\n            free(format);\n            free(informat);\n            free(label);\n#endif\n            goto cleanup;\n        }\n        retval = readstat_convert(variable->name, sizeof(variable->name),\n                name, name_len,  NULL);\n#if defined _MSC_VER\n        free(name);\n#endif\n        if (retval != READSTAT_OK) {\n#if defined _MSC_VER\n            free(format);\n            free(informat);\n            free(label);\n#endif\n            goto cleanup;\n        }\n        retval = readstat_convert(variable->label, sizeof(variable->label),\n                label, label_len,  NULL);\n#if defined _MSC_VER\n        free(label);\n#endif\n        if (retval != READSTAT_OK) {\n#if defined _MSC_VER\n            free(format);\n            free(informat);\n#endif\n            goto cleanup;\n        }\n        retval = xport_construct_format(variable->format, sizeof(variable->format),\n                format, format_len, variable->display_width, variable->decimals);\n#if defined _MSC_VER\n        free(format);\n        free(informat);\n#endif\n        if (retval != READSTAT_OK)\n            goto cleanup;\n    }\n    retval = xport_skip_rest_of_record(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    retval = xport_read_obs_header_record(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\ncleanup:\n    return retval;\n"]], "pred": {"ppl": 1.4867963790893555, "ppl_lower": 1.5394670963287354, "ppl/lowercase_ppl": -1.087772336892097, "ppl/zlib": 0.0005137613006040076, "Min_5.0% Prob": 5.53791833858864, "Min_10.0% Prob": 3.5578616279013016, "Min_20.0% Prob": 1.961751810512414, "Min_30.0% Prob": 1.3219117334636012, "Min_40.0% Prob": 0.9911919071801316, "Min_50.0% Prob": 0.7937955374233954, "Min_60.0% Prob": 0.6618386806542628}}
{"hexsha": "dc3cae8b43d0df9079d0d86f1c458cfafc3a3bd3", "ext": "c", "lang": "C", "content": "static void sun3_trap_write(sun3 *vm)\n{\n\tsun3_memory_address sp = sun3_address_regs_read_unsigned_long(&vm->address_regs, 7);\n\tsun3_memory_address sink_addr = sp+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long sink = sun3_memory_read_unsigned_long(&vm->memory, sink_addr);\n\tsun3_memory_address str_addr = sink_addr+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long str = sun3_memory_read_unsigned_long(&vm->memory, str_addr);\n\tsun3_memory_address len_addr = str_addr+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long len = sun3_memory_read_unsigned_long(&vm->memory, len_addr);\n\tint nwritten = sun3_memory_io_write(sink, &vm->memory, str, len);\n\n\tnwritten -= len;\n\tif (nwritten) {\n\t\tsun3_sr_set_c(vm->sr, 0);\n\t} else {\n\t\tsun3_sr_set_c(vm->sr, 1);\n\t}\n\tsun3_data_regs_write_signed_long(&vm->data_regs, 0, nwritten);\n}", "item_id": 1, "repo": "nineties-retro/sun3", "file": "sun3_trap.c", "last_update_at": "2019-06-13T18:17:04+00:00", "question_id": "dc3cae8b43d0df9079d0d86f1c458cfafc3a3bd3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void sun3_trap_write(sun3 *vm)\n{\n\tsun3_memory_address sp = sun3_address_regs_read_unsigned_long(&vm->address_regs, 7);\n\tsun3_memory_address sink_addr = sp+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long sink = sun3_memory_read_unsigned_long(&vm->memory, sink_addr);\n\tsun3_memory_address str_addr = sink_addr+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long str = sun3_memory_read_unsigned_long(&vm->memory, str_addr);\n\tsun3_memory_address len_addr = str_addr+sizeof(sun3_unsigned_long);\n\tsun3_unsigned_long len = sun3_memory_read_unsigned_long(&vm->memory, len_addr);\n\tint nwritten = sun3_memory_io_write(sink, &vm->memory, str, len);\n\tnwritten -= len;\n\tif (nwritten) {\n\t\tsun3_sr_set_c(vm->sr, 0);\n\t} else {\n\t\tsun3_sr_set_c(vm->sr, 1);\n\t}\n\tsun3_data_regs_write_signed_long(&vm->data_regs, 0, nwritten);\n"]], "pred": {"ppl": 1.9097896814346313, "ppl_lower": 1.9097896814346313, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002478900848901798, "Min_5.0% Prob": 6.482654809951782, "Min_10.0% Prob": 4.612908724582557, "Min_20.0% Prob": 2.93237029151483, "Min_30.0% Prob": 2.0906906856430902, "Min_40.0% Prob": 1.6063070548980525, "Min_50.0% Prob": 1.2940258177505297, "Min_60.0% Prob": 1.0807061633894766}}
{"hexsha": "147a3c3336ab9a45f50a007dbbb75f1b4ca2fa64", "ext": "c", "lang": "C", "content": "static void xdcc_del(char *name)\n{\n\tGSList *list;\n\tfileoffer *offer;\n\n\tlist = file_list;\n\twhile(list)\n\t{\n\t\toffer = (fileoffer *) list->data;\n\t\tif(strcasecmp(name, offer->file) == 0)\n\t\t{\n\t\t\tfile_list = g_slist_remove(file_list, offer);\n\t\t\txchat_printf(ph, \"%s [%s] removed.\\n\", offer->file, offer->fullpath);\n\t\t\tfree(offer->file);\n\t\t\tfree(offer->desc);\n\t\t\tfree(offer->fullpath);\n\t\t\tfree(offer);\n\t\t\treturn;\n\t\t}\n\t\tlist = list->next;\n\t}\n}", "item_id": 2, "repo": "AlexRogalskiy/DevArtifacts", "file": "master/xchat-gnome-0.1/xchat-2.0.8/plugins/xdcc/xdcc.c", "last_update_at": "2019-03-27T09:48:12+00:00", "question_id": "147a3c3336ab9a45f50a007dbbb75f1b4ca2fa64_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void xdcc_del(char *name)\n{\n\tGSList *list;\n\tfileoffer *offer;\n\tlist = file_list;\n\twhile(list)\n\t{\n\t\toffer = (fileoffer *) list->data;\n\t\tif(strcasecmp(name, offer->file) == 0)\n\t\t{\n\t\t\tfile_list = g_slist_remove(file_list, offer);\n\t\t\txchat_printf(ph, \"%s [%s] removed.\\n\", offer->file, offer->fullpath);\n\t\t\tfree(offer->file);\n\t\t\tfree(offer->desc);\n\t\t\tfree(offer->fullpath);\n\t\t\tfree(offer);\n\t\t\treturn;\n\t\t}\n\t\tlist = list->next;\n\t}\n"]], "pred": {"ppl": 2.068566083908081, "ppl_lower": 2.1526055335998535, "ppl/lowercase_ppl": -1.0547884990961742, "ppl/zlib": 0.003028565225636774, "Min_5.0% Prob": 6.948175716400146, "Min_10.0% Prob": 5.067949366569519, "Min_20.0% Prob": 3.2963128224015237, "Min_30.0% Prob": 2.3465765812357917, "Min_40.0% Prob": 1.8125300485594773, "Min_50.0% Prob": 1.4498676547744112, "Min_60.0% Prob": 1.2143394363868494}}
{"hexsha": "c0345fcb8569c363946f6d60a55b48b065a37720", "ext": "c", "lang": "C", "content": "static void\nget_active_cb(DBusPendingCall *pending, void *data)\n{\n\tstruct launcher_ck2 *wl = data;\n\tDBusMessageIter iter;\n\tDBusMessage *m;\n\tint type;\n\n\tdbus_pending_call_unref(wl->pending_active);\n\twl->pending_active = NULL;\n\n\tm = dbus_pending_call_steal_reply(pending);\n\tif (!m)\n\t\treturn;\n\n\ttype = dbus_message_get_type(m);\n\tif (type == DBUS_MESSAGE_TYPE_METHOD_RETURN &&\n\t\t\tdbus_message_iter_init(m, &iter))\n\t\tparse_active(wl, m, &iter);\n\n\tdbus_message_unref(m);\n}", "item_id": 8, "repo": "myfreeweb/weston", "file": "libweston/launcher-ck2.c", "last_update_at": "2019-01-05T12:49:29+00:00", "question_id": "c0345fcb8569c363946f6d60a55b48b065a37720_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nget_active_cb(DBusPendingCall *pending, void *data)\n{\n\tstruct launcher_ck2 *wl = data;\n\tDBusMessageIter iter;\n\tDBusMessage *m;\n\tint type;\n\tdbus_pending_call_unref(wl->pending_active);\n\twl->pending_active = NULL;\n\tm = dbus_pending_call_steal_reply(pending);\n\tif (!m)\n\t\treturn;\n\ttype = dbus_message_get_type(m);\n\tif (type == DBUS_MESSAGE_TYPE_METHOD_RETURN &&\n\t\t\tdbus_message_iter_init(m, &iter))\n\t\tparse_active(wl, m, &iter);\n\tdbus_message_unref(m);\n"]], "pred": {"ppl": 1.9160711765289307, "ppl_lower": 2.559297561645508, "ppl/lowercase_ppl": -1.4451273539490277, "ppl/zlib": 0.0022897071385922885, "Min_5.0% Prob": 7.511417055130005, "Min_10.0% Prob": 5.079436160269237, "Min_20.0% Prob": 3.069881859279814, "Min_30.0% Prob": 2.1510879101734313, "Min_40.0% Prob": 1.6213803028359133, "Min_50.0% Prob": 1.3058030928643245, "Min_60.0% Prob": 1.0904837583492355}}
{"hexsha": "c5a2bd637231fbe5e0eee81526f7a45f4c6d506b", "ext": "c", "lang": "C", "content": "void fsof_zk_remove_listener(const char *path,watcher_fn watcher) {\n    struct provider_callback *cb = NULL;\n    struct map_object *object_val = NULL;\n\n    if (sm_exists(g_provider_map,path)) { //exist\n        sm_get(g_provider_map,path,&object_val);\n        if (object_val != NULL) {\n            cb = (struct provider_callback*)object_val->ptr;\n            if (cb != NULL && cb->watcher_cb == watcher) {\n                object_val->status = 0;\n            }\n        }\n    }\n}", "item_id": 3, "repo": "cjb21sj/dubbo-php-framework", "file": "agent/src/c/service/fsof_zookeeper.c", "last_update_at": "2019-04-23T11:07:40+00:00", "question_id": "c5a2bd637231fbe5e0eee81526f7a45f4c6d506b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void fsof_zk_remove_listener(const char *path,watcher_fn watcher) {\n    struct provider_callback *cb = NULL;\n    struct map_object *object_val = NULL;\n    if (sm_exists(g_provider_map,path)) { //exist\n        sm_get(g_provider_map,path,&object_val);\n        if (object_val != NULL) {\n            cb = (struct provider_callback*)object_val->ptr;\n            if (cb != NULL && cb->watcher_cb == watcher) {\n                object_val->status = 0;\n            }\n        }\n    }\n"]], "pred": {"ppl": 3.975660562515259, "ppl_lower": 4.223755359649658, "ppl/lowercase_ppl": -1.0438589428706462, "ppl/zlib": 0.0059490987652981685, "Min_5.0% Prob": 9.95981992994036, "Min_10.0% Prob": 7.782211430867513, "Min_20.0% Prob": 5.424160095953172, "Min_30.0% Prob": 4.1803073597990945, "Min_40.0% Prob": 3.2861095541907894, "Min_50.0% Prob": 2.715000720960753, "Min_60.0% Prob": 2.27821181209818}}
{"hexsha": "b398c39441be79a9fc2a20131dbb7451e738a1f6", "ext": "c", "lang": "C", "content": "void create()\n{\n        set_name(\"\u5c71\u7334\",({\"monkey\", \"houzi\", \"hou\"}) );\n        set(\"race\", \"\u91ce\u7378\");\n        set(\"gender\", \"\u96c4\u6027\" );\n        set(\"age\", 15);\n        set(\"long\", \"\u9019\u662f\u4e00\u96bb\u5147\u608d\u7684\u5c71\u7334\u3002\\n\");\n        set(\"combat_exp\", 20000);\n        set(\"str\", 25);\n        set(\"dex\", 25);\n        set(\"con\", 25);\n        set(\"int\", 25);\n        set(\"attitude\", \"heroism\");\n\n        set(\"max_qi\",800);\n        set(\"qi\",800);\n        set(\"max_jingli\",800);\n        set(\"jingli\",800);\n        \n        set(\"limbs\", ({ \"\u982d\u90e8\", \"\u8eab\u9ad4\", \"\u524d\u8173\", \"\u5f8c\u8173\", \"\u5c3e\u5df4\" }) );\n        set(\"verbs\", ({ \"knock\", \"hoof\" }) );\n\n        set_temp(\"apply/damage\", 20);\n        set_temp(\"apply/armor\", 20);\n\n        setup();\n}", "item_id": 0, "repo": "cantona/NT6", "file": "nitan/d/tangmen/npc/monkey.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "b398c39441be79a9fc2a20131dbb7451e738a1f6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void create()\n{\n        set_name(\"\u5c71\u7334\",({\"monkey\", \"houzi\", \"hou\"}) );\n        set(\"race\", \"\u91ce\u7378\");\n        set(\"gender\", \"\u96c4\u6027\" );\n        set(\"age\", 15);\n        set(\"long\", \"\u9019\u662f\u4e00\u96bb\u5147\u608d\u7684\u5c71\u7334\u3002\\n\");\n        set(\"combat_exp\", 20000);\n        set(\"str\", 25);\n        set(\"dex\", 25);\n        set(\"con\", 25);\n        set(\"int\", 25);\n        set(\"attitude\", \"heroism\");\n        set(\"max_qi\",800);\n        set(\"qi\",800);\n        set(\"max_jingli\",800);\n        set(\"jingli\",800);\n        set(\"limbs\", ({ \"\u982d\u90e8\", \"\u8eab\u9ad4\", \"\u524d\u8173\", \"\u5f8c\u8173\", \"\u5c3e\u5df4\" }) );\n        set(\"verbs\", ({ \"knock\", \"hoof\" }) );\n        set_temp(\"apply/damage\", 20);\n        set_temp(\"apply/armor\", 20);\n        setup();\n"]], "pred": {"ppl": 2.204272747039795, "ppl_lower": 2.204272747039795, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00233845454011731, "Min_5.0% Prob": 6.656753476460775, "Min_10.0% Prob": 5.15316596031189, "Min_20.0% Prob": 3.389238949681892, "Min_30.0% Prob": 2.507255740873106, "Min_40.0% Prob": 1.9326710001122756, "Min_50.0% Prob": 1.5722420440594618, "Min_60.0% Prob": 1.3140751372697086}}
{"hexsha": "e4d5d5ccd1f6480761d544c87ba701234d57725b", "ext": "c", "lang": "C", "content": "MX_EXPORT void\nmx_numbered_breakpoint( unsigned long breakpoint_number )\n{\n\tstatic const char fname[] = \"mx_numbered_breakpoint()\";\n\n\tif ( breakpoint_number >= MXU_MAX_NUMBERED_BREAKPOINTS ) {\n\t\t(void) mx_error( MXE_WOULD_EXCEED_LIMIT, fname,\n\t\t\"The requested breakpoint number %lu is outside the \"\n\t\t\"allowed range of values from 0 to %d\",\n\t\t\tbreakpoint_number,\n\t\t\tMXU_MAX_NUMBERED_BREAKPOINTS-1 );\n\t\treturn;\n\t}\n\n\tif ( mxp_numbered_breakpoint_array[breakpoint_number] ) {\n\t\tmx_breakpoint();\n\t}\n\treturn;\n}", "item_id": 14, "repo": "nbeaver/mx-trunk", "file": "libMx/mx_debugger.c", "last_update_at": "2019-11-14T11:35:45+00:00", "question_id": "e4d5d5ccd1f6480761d544c87ba701234d57725b_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MX_EXPORT void\nmx_numbered_breakpoint( unsigned long breakpoint_number )\n{\n\tstatic const char fname[] = \"mx_numbered_breakpoint()\";\n\tif ( breakpoint_number >= MXU_MAX_NUMBERED_BREAKPOINTS ) {\n\t\t(void) mx_error( MXE_WOULD_EXCEED_LIMIT, fname,\n\t\t\"The requested breakpoint number %lu is outside the \"\n\t\t\"allowed range of values from 0 to %d\",\n\t\t\tbreakpoint_number,\n\t\t\tMXU_MAX_NUMBERED_BREAKPOINTS-1 );\n\t\treturn;\n\t}\n\tif ( mxp_numbered_breakpoint_array[breakpoint_number] ) {\n\t\tmx_breakpoint();\n\t}\n\treturn;\n"]], "pred": {"ppl": 1.8959389925003052, "ppl_lower": 2.663095474243164, "ppl/lowercase_ppl": -1.5311354945074074, "ppl/zlib": 0.0021833250046546927, "Min_5.0% Prob": 5.643552780151367, "Min_10.0% Prob": 4.431864559650421, "Min_20.0% Prob": 2.8786653643701134, "Min_30.0% Prob": 2.092946271742544, "Min_40.0% Prob": 1.5927375223352966, "Min_50.0% Prob": 1.2773210137294462, "Min_60.0% Prob": 1.072607860070533}}
{"hexsha": "50410f384ad99deded8ac286f626c15c3357af6f", "ext": "c", "lang": "C", "content": "int getSizeOfHT(const HT** ht) {\n\tint retVal;\n\tretVal = HASH_COUNT(*ht);\n\treturn retVal;\n}", "item_id": 0, "repo": "Koldar/crashc", "file": "CUtils/src/main/c/hashtable.c", "last_update_at": "2019-07-09T17:37:41+00:00", "question_id": "50410f384ad99deded8ac286f626c15c3357af6f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int getSizeOfHT(const HT** ht) {\n\tint retVal;\n\tretVal = HASH_COUNT(*ht);\n\treturn retVal;\n"]], "pred": {"ppl": 8.142328262329102, "ppl_lower": 8.517143249511719, "ppl/lowercase_ppl": -1.0214607459440892, "ppl/zlib": 0.02621345208036991, "Min_5.0% Prob": 10.197699546813965, "Min_10.0% Prob": 8.889485994974772, "Min_20.0% Prob": 6.9017197745186945, "Min_30.0% Prob": 5.719537821683017, "Min_40.0% Prob": 4.836926205952962, "Min_50.0% Prob": 4.131211858046682, "Min_60.0% Prob": 3.51819226016169}}
{"hexsha": "31867e4b891b1e582e2490638cc417894337e736", "ext": "c", "lang": "C", "content": "static int stir_net_close(struct net_device *netdev)\n{\n\tstruct stir_cb *stir = netdev_priv(netdev);\n\n\t/* Stop transmit processing */\n\tnetif_stop_queue(netdev);\n\n\t/* Kill transmit thread */\n\tkill_proc(stir->thr_pid, SIGTERM, 1);\n\twait_for_completion(&stir->thr_exited);\n\tkfree(stir->fifo_status);\n\n\t/* Mop up receive urb's */\n\tusb_kill_urb(stir->rx_urb);\n\t\n\tkfree(stir->io_buf);\n\tusb_free_urb(stir->rx_urb);\n\tkfree_skb(stir->rx_buff.skb);\n\n\t/* Stop and remove instance of IrLAP */\n\tif (stir->irlap)\n\t\tirlap_close(stir->irlap);\n\n\tstir->irlap = NULL;\n\n\treturn 0;\n}", "item_id": 15, "repo": "ut-osa/syncchar", "file": "linux-2.6.16-unmod/drivers/net/irda/stir4200.c", "last_update_at": "2019-05-14T16:36:45+00:00", "question_id": "31867e4b891b1e582e2490638cc417894337e736_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int stir_net_close(struct net_device *netdev)\n{\n\tstruct stir_cb *stir = netdev_priv(netdev);\n\t/* Stop transmit processing */\n\tnetif_stop_queue(netdev);\n\t/* Kill transmit thread */\n\tkill_proc(stir->thr_pid, SIGTERM, 1);\n\twait_for_completion(&stir->thr_exited);\n\tkfree(stir->fifo_status);\n\t/* Mop up receive urb's */\n\tusb_kill_urb(stir->rx_urb);\n\t\n\tkfree(stir->io_buf);\n\tusb_free_urb(stir->rx_urb);\n\tkfree_skb(stir->rx_buff.skb);\n\t/* Stop and remove instance of IrLAP */\n\tif (stir->irlap)\n\t\tirlap_close(stir->irlap);\n\tstir->irlap = NULL;\n\treturn 0;\n"]], "pred": {"ppl": 2.9860973358154297, "ppl_lower": 3.2188057899475098, "ppl/lowercase_ppl": -1.0685972262389218, "ppl/zlib": 0.0034839722801869185, "Min_5.0% Prob": 8.709076205889383, "Min_10.0% Prob": 7.022994965314865, "Min_20.0% Prob": 4.748018955697819, "Min_30.0% Prob": 3.4582805150264018, "Min_40.0% Prob": 2.687105871812262, "Min_50.0% Prob": 2.1768211484436066, "Min_60.0% Prob": 1.82979884629163}}
{"hexsha": "d376225825501701f74ac7f36772240a97c23a3d", "ext": "c", "lang": "C", "content": "int client_disconnect(client_t *client) {\n\tassert(client);\n\tassert(client->socket >= 0);\n\n\t/* Interrupt any ongoing read, then close the socket */\n\tclient->running = 0;\n\tpthread_kill(client->net_thread, SIGUSR1);\n\tpthread_join(client->net_thread, NULL);\n\tclose(client->socket);\n\n\tvector_free(&client->users);\n\tvector_free(&client->chats);\n\tvector_free(&client->names);\n\n\treturn 0;\n}", "item_id": 3, "repo": "aidanholm/netchat", "file": "src/client/client.c", "last_update_at": "2019-05-28T15:14:24+00:00", "question_id": "d376225825501701f74ac7f36772240a97c23a3d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int client_disconnect(client_t *client) {\n\tassert(client);\n\tassert(client->socket >= 0);\n\t/* Interrupt any ongoing read, then close the socket */\n\tclient->running = 0;\n\tpthread_kill(client->net_thread, SIGUSR1);\n\tpthread_join(client->net_thread, NULL);\n\tclose(client->socket);\n\tvector_free(&client->users);\n\tvector_free(&client->chats);\n\tvector_free(&client->names);\n\treturn 0;\n"]], "pred": {"ppl": 2.877588987350464, "ppl_lower": 3.3117480278015137, "ppl/lowercase_ppl": -1.1329514151559745, "ppl/zlib": 0.005206663972246904, "Min_5.0% Prob": 8.514876127243042, "Min_10.0% Prob": 6.561572111569918, "Min_20.0% Prob": 4.441116028361851, "Min_30.0% Prob": 3.2939614202918075, "Min_40.0% Prob": 2.5896718247370285, "Min_50.0% Prob": 2.1019612996690515, "Min_60.0% Prob": 1.7757659078598387}}
{"hexsha": "a520e08a117637c91eeb5067473ae537f1a67a94", "ext": "c", "lang": "C", "content": "static void apply_scale_keyframes(float *matrix, float time, struct SKEL_BONE_KEYFRAME **keyframes, int n_keyframes)\n{\n  if (n_keyframes == 0)\n    return;\n  \n  if (n_keyframes == 1) {\n    float scale[16];\n    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);\n    mat4_mul_left(matrix, scale);\n    return;\n  }\n  \n  if (n_keyframes == 2) {\n    // TODO: interpolate keyframes[0] and keyframes[1]\n    float scale[16];\n    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);\n    mat4_mul_left(matrix, scale);\n    return;\n  }\n}", "item_id": 4, "repo": "moefh/baroque", "file": "src/skeleton.c", "last_update_at": "2019-03-29T00:04:25+00:00", "question_id": "a520e08a117637c91eeb5067473ae537f1a67a94_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void apply_scale_keyframes(float *matrix, float time, struct SKEL_BONE_KEYFRAME **keyframes, int n_keyframes)\n{\n  if (n_keyframes == 0)\n    return;\n  if (n_keyframes == 1) {\n    float scale[16];\n    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);\n    mat4_mul_left(matrix, scale);\n    return;\n  }\n  if (n_keyframes == 2) {\n    // TODO: interpolate keyframes[0] and keyframes[1]\n    float scale[16];\n    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);\n    mat4_mul_left(matrix, scale);\n    return;\n  }\n"]], "pred": {"ppl": 1.988351583480835, "ppl_lower": 2.000678300857544, "ppl/lowercase_ppl": -1.0089921061730294, "ppl/zlib": 0.002887840106955135, "Min_5.0% Prob": 6.107609532096169, "Min_10.0% Prob": 4.6767751652261484, "Min_20.0% Prob": 3.133909170931958, "Min_30.0% Prob": 2.2289498146151154, "Min_40.0% Prob": 1.7058940737655288, "Min_50.0% Prob": 1.3716922290936238, "Min_60.0% Prob": 1.151177398283297}}
{"hexsha": "55073c5c231e586507afbe15a6484f8f11b642c6", "ext": "c", "lang": "C", "content": "int airparse_add_packet( unsigned char *h80211, int caplen, int power )\n{\n    int i, n;\n\n    struct pcap_pkthdr pkh;\n\n    unsigned char *p;\n    unsigned char bssid[6];\n\n    ap_cur = NULL;\n\n    pkh.caplen = pkh.len = caplen;\n\n    /* skip packets smaller than a 802.11 header */\n\n    if( pkh.caplen < 24 )\n        goto write_packet;\n\n    /* skip (uninteresting) control frames */\n\n    if( ( h80211[0] & 0x0C ) == 0x04 )\n        goto write_packet;\n\n    /* skip management frames without an ESSID */\n\n    if( ( h80211[0] & 0x0C ) == 0x00 )\n        if( ( h80211[0] & 0xF0 ) != 0x00 &&\n            ( h80211[0] & 0xF0 ) != 0x50 &&\n            ( h80211[0] & 0xF0 ) != 0x80 )\n            goto write_packet;\n\n    /* locate the BSSID (AP's MAC) in the 802.11 header */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( bssid, h80211 + 16, 6 ); break;\n        case  1: memcpy( bssid, h80211 +  4, 6 ); break;\n        case  2: memcpy( bssid, h80211 + 10, 6 ); break;\n        default: memcpy( bssid, h80211 +  4, 6 ); break;\n    }\n\n    /* update our chained list of access points */\n\n    ap_cur = ap_1st;\n    ap_prv = NULL;\n\n    while( ap_cur != NULL )\n    {\n        if( ! memcmp( ap_cur->bssid, bssid, 6 ) )\n            break;\n\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n\n    /* if it's a new access point, add it */\n\n    if( ap_cur == NULL )\n    {\n        if( ! ( ap_cur = (struct AP_info *) malloc(\n                         sizeof( struct AP_info ) ) ) )\n            return( 1 );\n\n        memset( ap_cur, 0, sizeof( struct AP_info ) );\n\n        if( ap_1st == NULL )\n            ap_1st = ap_cur;\n        else\n            ap_prv->next  = ap_cur;\n\n        memcpy( ap_cur->bssid, bssid, 6 );\n\n        ap_cur->prev = ap_prv;\n\n        ap_cur->tinit = time( NULL );\n        ap_cur->tlast = time( NULL );\n        ap_cur->power = power;\n        ap_cur->chanl = -1;\n        ap_cur->speed = -1;\n        ap_cur->crypt = -1;\n\n        ap_end = ap_cur;\n    }\n\n    /* every 1s, update the last time seen & receive power */\n\n    if( time( NULL ) - ap_cur->tlast >= 1 )\n    {\n        ap_cur->tlast = time( NULL );\n        ap_cur->power = power;\n    }\n\n    ap_cur->nb_pkt++;\n\n    /* packet parsing: Beacon or Probe Response */\n\n    if( h80211[0] == 0x80 ||\n        h80211[0] == 0x50 )\n    {\n        ap_cur->crypt = ( h80211[34] & 0x10 ) >> 4;\n\n        p = h80211 + 36;\n\n        while( p < h80211 + pkh.caplen )\n        {\n            if( p + 2 + p[1] > h80211 + pkh.caplen )\n                break;\n\n            if( p[0] == 0x00 && p[2] != '\\0' )\n            {\n                /* found a non-cloaked ESSID */\n\n                n = ( p[1] > 32 ) ? 32 : p[1];\n\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < ' ' )\n                        ap_cur->essid[i] = '.';\n            }\n\n            if( p[0] == 0x03 )\n                ap_cur->chanl = p[2];\n\n            if( p[0] == 0x01 || p[0] == 0x32 )\n                ap_cur->speed = ( p[1 + p[1]] & 0x7F ) / 2;\n\n            if( p[0] == 0xDD )\n                ap_cur->crypt++;\n\n            p += 2 + p[1];\n        }\n    }\n\n    /* packet parsing: Association Request */\n\n    if( h80211[0] == 0x00 )\n    {\n        p = h80211 + 28;\n\n        while( p < h80211 + pkh.caplen )\n        {\n            if( p + 2 + p[1] > h80211 + pkh.caplen )\n                break;\n\n            if( p[0] == 0x00 && p[2] != '\\0' )\n            {\n                /* found a non-cloaked ESSID */\n\n                n = ( p[1] > 32 ) ? 32 : p[1];\n\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < ' ' )\n                        ap_cur->essid[i] = '.';\n            }\n\n            p += 2 + p[1];\n        }\n    }\n\n    /* packet parsing: non-encrypted data */\n\n    if( ( h80211[0] & 0x0C ) == 0x08 &&\n        ( h80211[1] & 0x40 ) == 0x00 )\n    {\n        if( memcmp( h80211 + 24, ARP_REQUEST_HEADER, 14 ) == 0 )\n            memcpy( ap_cur->lanip, h80211 + 46, 4 );\n    }\n\n    /* packet parsing: WEP encrypted data */\n\n    if( ( h80211[0] & 0x0C ) == 0x08 &&\n        ( h80211[1] & 0x40 ) == 0x40 )\n    {\n        int z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n\n        for( i = 0; i < 64; i++ )\n            if( ! memcmp( ap_cur->seen_ivs[i], h80211 + z, 3 ) )\n                return( 0 );\n\n        n = ap_cur->s_index;\n        memcpy( ap_cur->seen_ivs[n++], h80211 + z, 3 );\n\n        ap_cur->s_index = n % 64;\n        ap_cur->nb_ivs++;\n    }\n\nwrite_packet:\n\n    if( mac_filter != NULL )\n    {\n        /* reject packets that do not contain the specified MAC */\n\n        if( ( h80211[1] & 3 ) != 3 )\n        {\n            if( memcmp( h80211 +  4, mac_filter, 6 ) &&\n                memcmp( h80211 + 10, mac_filter, 6 ) &&\n                memcmp( h80211 + 16, mac_filter, 6 ) )\n                return( 0 );\n        }\n        else\n        {\n            if( memcmp( h80211 +  4, mac_filter, 6 ) &&\n                memcmp( h80211 + 10, mac_filter, 6 ) &&\n                memcmp( h80211 + 16, mac_filter, 6 ) &&\n                memcmp( h80211 + 24, mac_filter, 6 ) )\n                return( 0 );\n        }\n    }\n\n    /* finally append the packet to the pcap file */\n\n#ifndef WIN32\n    gettimeofday( &pkh.ts, NULL );\n#else\n    pkh.tv_sec  = time( NULL );\n    pkh.tv_usec = 0;\n#endif\n\n    n = sizeof( pkh );\n\n    if( fwrite( &pkh, 1, n, f_cap ) != (size_t) n )\n    {\n        fprintf( stderr, \"fwrite(packet header) failed\\n\" );\n        return( 1 );\n    }\n\n    n = pkh.caplen;\n\n    if( fwrite( h80211, 1, n, f_cap ) != (size_t) n )\n    {\n        fprintf( stderr, \"fwrite(packet data) failed\\n\" );\n        return( 1 );\n    }\n\n    return( 0 );\n}", "item_id": 1, "repo": "Marzooq13579/Hack-Gadgets", "file": "aircrack-2.1/airparse.c", "last_update_at": "2019-10-18T06:27:16+00:00", "question_id": "55073c5c231e586507afbe15a6484f8f11b642c6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int airparse_add_packet( unsigned char *h80211, int caplen, int power )\n{\n    int i, n;\n    struct pcap_pkthdr pkh;\n    unsigned char *p;\n    unsigned char bssid[6];\n    ap_cur = NULL;\n    pkh.caplen = pkh.len = caplen;\n    /* skip packets smaller than a 802.11 header */\n    if( pkh.caplen < 24 )\n        goto write_packet;\n    /* skip (uninteresting) control frames */\n    if( ( h80211[0] & 0x0C ) == 0x04 )\n        goto write_packet;\n    /* skip management frames without an ESSID */\n    if( ( h80211[0] & 0x0C ) == 0x00 )\n        if( ( h80211[0] & 0xF0 ) != 0x00 &&\n            ( h80211[0] & 0xF0 ) != 0x50 &&\n            ( h80211[0] & 0xF0 ) != 0x80 )\n            goto write_packet;\n    /* locate the BSSID (AP's MAC) in the 802.11 header */\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( bssid, h80211 + 16, 6 ); break;\n        case  1: memcpy( bssid, h80211 +  4, 6 ); break;\n        case  2: memcpy( bssid, h80211 + 10, 6 ); break;\n        default: memcpy( bssid, h80211 +  4, 6 ); break;\n    }\n    /* update our chained list of access points */\n    ap_cur = ap_1st;\n    ap_prv = NULL;\n    while( ap_cur != NULL )\n    {\n        if( ! memcmp( ap_cur->bssid, bssid, 6 ) )\n            break;\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n    /* if it's a new access point, add it */\n    if( ap_cur == NULL )\n    {\n        if( ! ( ap_cur = (struct AP_info *) malloc(\n                         sizeof( struct AP_info ) ) ) )\n            return( 1 );\n        memset( ap_cur, 0, sizeof( struct AP_info ) );\n        if( ap_1st == NULL )\n            ap_1st = ap_cur;\n        else\n            ap_prv->next  = ap_cur;\n        memcpy( ap_cur->bssid, bssid, 6 );\n        ap_cur->prev = ap_prv;\n        ap_cur->tinit = time( NULL );\n        ap_cur->tlast = time( NULL );\n        ap_cur->power = power;\n        ap_cur->chanl = -1;\n        ap_cur->speed = -1;\n        ap_cur->crypt = -1;\n        ap_end = ap_cur;\n    }\n    /* every 1s, update the last time seen & receive power */\n    if( time( NULL ) - ap_cur->tlast >= 1 )\n    {\n        ap_cur->tlast = time( NULL );\n        ap_cur->power = power;\n    }\n    ap_cur->nb_pkt++;\n    /* packet parsing: Beacon or Probe Response */\n    if( h80211[0] == 0x80 ||\n        h80211[0] == 0x50 )\n    {\n        ap_cur->crypt = ( h80211[34] & 0x10 ) >> 4;\n        p = h80211 + 36;\n        while( p < h80211 + pkh.caplen )\n        {\n            if( p + 2 + p[1] > h80211 + pkh.caplen )\n                break;\n            if( p[0] == 0x00 && p[2] != '\\0' )\n            {\n                /* found a non-cloaked ESSID */\n                n = ( p[1] > 32 ) ? 32 : p[1];\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < ' ' )\n                        ap_cur->essid[i] = '.';\n            }\n            if( p[0] == 0x03 )\n                ap_cur->chanl = p[2];\n            if( p[0] == 0x01 || p[0] == 0x32 )\n                ap_cur->speed = ( p[1 + p[1]] & 0x7F ) / 2;\n            if( p[0] == 0xDD )\n                ap_cur->crypt++;\n            p += 2 + p[1];\n        }\n    }\n    /* packet parsing: Association Request */\n    if( h80211[0] == 0x00 )\n    {\n        p = h80211 + 28;\n        while( p < h80211 + pkh.caplen )\n        {\n            if( p + 2 + p[1] > h80211 + pkh.caplen )\n                break;\n            if( p[0] == 0x00 && p[2] != '\\0' )\n            {\n                /* found a non-cloaked ESSID */\n                n = ( p[1] > 32 ) ? 32 : p[1];\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < ' ' )\n                        ap_cur->essid[i] = '.';\n            }\n            p += 2 + p[1];\n        }\n    }\n    /* packet parsing: non-encrypted data */\n    if( ( h80211[0] & 0x0C ) == 0x08 &&\n        ( h80211[1] & 0x40 ) == 0x00 )\n    {\n        if( memcmp( h80211 + 24, ARP_REQUEST_HEADER, 14 ) == 0 )\n            memcpy( ap_cur->lanip, h80211 + 46, 4 );\n    }\n    /* packet parsing: WEP encrypted data */\n    if( ( h80211[0] & 0x0C ) == 0x08 &&\n        ( h80211[1] & 0x40 ) == 0x40 )\n    {\n        int z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n        for( i = 0; i < 64; i++ )\n            if( ! memcmp( ap_cur->seen_ivs[i], h80211 + z, 3 ) )\n                return( 0 );\n        n = ap_cur->s_index;\n        memcpy( ap_cur->seen_ivs[n++], h80211 + z, 3 );\n        ap_cur->s_index = n % 64;\n        ap_cur->nb_ivs++;\n    }\nwrite_packet:\n    if( mac_filter != NULL )\n    {\n        /* reject packets that do not contain the specified MAC */\n        if( ( h80211[1] & 3 ) != 3 )\n        {\n            if( memcmp( h80211 +  4, mac_filter, 6 ) &&\n                memcmp( h80211 + 10, mac_filter, 6 ) &&\n                memcmp( h80211 + 16, mac_filter, 6 ) )\n                return( 0 );\n        }\n        else\n        {\n            if( memcmp( h80211 +  4, mac_filter, 6 ) &&\n                memcmp( h80211 + 10, mac_filter, 6 ) &&\n                memcmp( h80211 + 16, mac_filter, 6 ) &&\n                memcmp( h80211 + 24, mac_filter, 6 ) )\n                return( 0 );\n        }\n    }\n    /* finally append the packet to the pcap file */\n#ifndef WIN32\n    gettimeofday( &pkh.ts, NULL );\n#else\n    pkh.tv_sec  = time( NULL );\n    pkh.tv_usec = 0;\n#endif\n    n = sizeof( pkh );\n    if( fwrite( &pkh, 1, n, f_cap ) != (size_t) n )\n    {\n        fprintf( stderr, \"fwrite(packet header) failed\\n\" );\n        return( 1 );\n    }\n    n = pkh.caplen;\n    if( fwrite( h80211, 1, n, f_cap ) != (size_t) n )\n    {\n        fprintf( stderr, \"fwrite(packet data) failed\\n\" );\n        return( 1 );\n    }\n    return( 0 );\n"]], "pred": {"ppl": 1.7683885097503662, "ppl_lower": 1.766100525856018, "ppl/lowercase_ppl": -0.9977289369298147, "ppl/zlib": 0.00037186476543307225, "Min_5.0% Prob": 5.917985126083972, "Min_10.0% Prob": 4.207249341057796, "Min_20.0% Prob": 2.6285467013424517, "Min_30.0% Prob": 1.8593970066289496, "Min_40.0% Prob": 1.4150049692807687, "Min_50.0% Prob": 1.1382134967536435, "Min_60.0% Prob": 0.9505892992505824}}
{"hexsha": "203cd4a39a43e7bfbc4953442719d1df730e3d98", "ext": "c", "lang": "C", "content": "bool necro_type_bind_var_to_type_if_instance_of_constraints(NecroPagedArena* arena, NecroType* type, NecroAstSymbol* type_symbol, NecroConstraintList* constraints)\n{\n    assert(type->type == NECRO_TYPE_VAR);\n    assert(!type->var.is_rigid);\n    while (constraints != NULL)\n    {\n        if (constraints->data->type != NECRO_CONSTRAINT_CLASS)\n        {\n            constraints = constraints->next;\n            continue;\n        }\n        NecroInstanceList* instance_list = type_symbol->instance_list;\n        while (instance_list != NULL)\n        {\n            if (instance_list->data->type_class_name == constraints->data->cls.type_class->type_class_name)\n                break;\n            instance_list = instance_list->next;\n        }\n        if (instance_list != NULL)\n            constraints = constraints->next;\n        else\n            return false;\n    }\n    type->var.bound       = necro_type_con_create(arena, type_symbol, NULL);\n    type->var.bound->kind = type_symbol->type->kind;\n    return true;\n}", "item_id": 23, "repo": "ChadMcKinney/Necronomicon", "file": "source/type/type.c", "last_update_at": "2019-03-26T01:05:27+00:00", "question_id": "203cd4a39a43e7bfbc4953442719d1df730e3d98_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool necro_type_bind_var_to_type_if_instance_of_constraints(NecroPagedArena* arena, NecroType* type, NecroAstSymbol* type_symbol, NecroConstraintList* constraints)\n{\n    assert(type->type == NECRO_TYPE_VAR);\n    assert(!type->var.is_rigid);\n    while (constraints != NULL)\n    {\n        if (constraints->data->type != NECRO_CONSTRAINT_CLASS)\n        {\n            constraints = constraints->next;\n            continue;\n        }\n        NecroInstanceList* instance_list = type_symbol->instance_list;\n        while (instance_list != NULL)\n        {\n            if (instance_list->data->type_class_name == constraints->data->cls.type_class->type_class_name)\n                break;\n            instance_list = instance_list->next;\n        }\n        if (instance_list != NULL)\n            constraints = constraints->next;\n        else\n            return false;\n    }\n    type->var.bound       = necro_type_con_create(arena, type_symbol, NULL);\n    type->var.bound->kind = type_symbol->type->kind;\n    return true;\n"]], "pred": {"ppl": 2.204416275024414, "ppl_lower": 2.829399347305298, "ppl/lowercase_ppl": -1.3157665552985882, "ppl/zlib": 0.002047830948114286, "Min_5.0% Prob": 6.501449871063232, "Min_10.0% Prob": 5.041962515923284, "Min_20.0% Prob": 3.3284382858584003, "Min_30.0% Prob": 2.4693655140938295, "Min_40.0% Prob": 1.9396597829557234, "Min_50.0% Prob": 1.570883248578156, "Min_60.0% Prob": 1.3151949878621807}}
{"hexsha": "2ce0570749352574a99b73583808a6f40bedd30f", "ext": "c", "lang": "C", "content": "static void bcread_bytecode(LexState *ls, GCproto *pt, MSize sizebc)\n{\n  BCIns *bc = proto_bc(pt);\n  bc[0] = BCINS_AD((pt->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,\n\t\t   pt->framesize, 0);\n  bcread_block(ls, bc+1, (sizebc-1)*(MSize)sizeof(BCIns));\n  /* Swap bytecode instructions if the endianess differs. */\n  if (bcread_swap(ls)) {\n    MSize i;\n    for (i = 1; i < sizebc; i++) bc[i] = lj_bswap(bc[i]);\n  }\n}", "item_id": 10, "repo": "SonicMastr/LuaJIT-Vita", "file": "src/lj_bcread.c", "last_update_at": "2019-06-28T11:50:14+00:00", "question_id": "2ce0570749352574a99b73583808a6f40bedd30f_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void bcread_bytecode(LexState *ls, GCproto *pt, MSize sizebc)\n{\n  BCIns *bc = proto_bc(pt);\n  bc[0] = BCINS_AD((pt->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,\n\t\t   pt->framesize, 0);\n  bcread_block(ls, bc+1, (sizebc-1)*(MSize)sizeof(BCIns));\n  /* Swap bytecode instructions if the endianess differs. */\n  if (bcread_swap(ls)) {\n    MSize i;\n    for (i = 1; i < sizebc; i++) bc[i] = lj_bswap(bc[i]);\n  }\n"]], "pred": {"ppl": 2.7099313735961914, "ppl_lower": 4.184382438659668, "ppl/lowercase_ppl": -1.4357765653329657, "ppl/zlib": 0.003449561630362379, "Min_5.0% Prob": 6.732937918768989, "Min_10.0% Prob": 5.112217100043046, "Min_20.0% Prob": 3.834605474221079, "Min_30.0% Prob": 3.011200004610522, "Min_40.0% Prob": 2.424364189048866, "Min_50.0% Prob": 1.9655021485133268, "Min_60.0% Prob": 1.657574252642948}}
{"hexsha": "230d374b70ea8695a0bf9f05e3b53f4bca0396ac", "ext": "h", "lang": "C", "content": "static ALWAYS_INLINE uint64_t arm_arch_timer_count(void)\n{\n\tuint64_t cntvct_el0;\n\n\t__asm__ volatile(\"mrs %0, cntvct_el0\\n\\t\"\n\t\t\t : \"=r\" (cntvct_el0) : : \"memory\");\n\n\treturn cntvct_el0;\n}", "item_id": 2, "repo": "jmbrederveld/zephyr", "file": "include/arch/arm/aarch64/timer.h", "last_update_at": "2019-03-01T15:06:09+00:00", "question_id": "230d374b70ea8695a0bf9f05e3b53f4bca0396ac_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ALWAYS_INLINE uint64_t arm_arch_timer_count(void)\n{\n\tuint64_t cntvct_el0;\n\t__asm__ volatile(\"mrs %0, cntvct_el0\\n\\t\"\n\t\t\t : \"=r\" (cntvct_el0) : : \"memory\");\n\treturn cntvct_el0;\n"]], "pred": {"ppl": 2.014631748199463, "ppl_lower": 2.064770221710205, "ppl/lowercase_ppl": -1.035096010369966, "ppl/zlib": 0.0046386518109991694, "Min_5.0% Prob": 6.845532321929932, "Min_10.0% Prob": 4.907715773582458, "Min_20.0% Prob": 3.1070249408483503, "Min_30.0% Prob": 2.258555988470713, "Min_40.0% Prob": 1.7465604266151786, "Min_50.0% Prob": 1.4096341092884541, "Min_60.0% Prob": 1.1783319703148056}}
{"hexsha": "e8023ba0cee61cfeab6782ac6c287e3d0a2000eb", "ext": "c", "lang": "C", "content": "void soc_display_silicon_init_params(const SILICON_INIT_UPD *original,\n\tSILICON_INIT_UPD *params)\n{\n\t/* Display the parameters for SiliconInit */\n\tprintk(BIOS_SPEW, \"UPD values for SiliconInit:\\n\");\n\tfsp_display_upd_value(\"LogoPtr\", 4,\n\t\t\t(uint32_t)original->LogoPtr,\n\t\t\t(uint32_t)params->LogoPtr);\n\tfsp_display_upd_value(\"LogoSize\", 4,\n\t\t(uint32_t)original->LogoSize,\n\t\t(uint32_t)params->LogoSize);\n\tfsp_display_upd_value(\"GraphicsConfigPtr\", 4,\n\t\t(uint32_t)original->GraphicsConfigPtr,\n\t\t(uint32_t)params->GraphicsConfigPtr);\n\tfsp_display_upd_value(\"MicrocodeRegionBase\", 4,\n\t\t(uint32_t)original->MicrocodeRegionBase,\n\t\t(uint32_t)params->MicrocodeRegionBase);\n\tfsp_display_upd_value(\"MicrocodeRegionSize\", 4,\n\t\t(uint32_t)original->MicrocodeRegionSize,\n\t\t(uint32_t)params->MicrocodeRegionSize);\n\tfsp_display_upd_value(\"TurboMode\", 1,\n\t\t(uint32_t)original->TurboMode,\n\t\t(uint32_t)params->TurboMode);\n\tfsp_display_upd_value(\"Device4Enable\", 1,\n\t\toriginal->Device4Enable,\n\t\tparams->Device4Enable);\n\tfsp_display_upd_value(\"PcieRpEnable[0]\", 1, original->PcieRpEnable[0],\n\t\tparams->PcieRpEnable[0]);\n\tfsp_display_upd_value(\"PcieRpEnable[1]\", 1, original->PcieRpEnable[1],\n\t\tparams->PcieRpEnable[1]);\n\tfsp_display_upd_value(\"PcieRpEnable[2]\", 1, original->PcieRpEnable[2],\n\t\tparams->PcieRpEnable[2]);\n\tfsp_display_upd_value(\"PcieRpEnable[3]\", 1, original->PcieRpEnable[3],\n\t\tparams->PcieRpEnable[3]);\n\tfsp_display_upd_value(\"PcieRpEnable[4]\", 1, original->PcieRpEnable[4],\n\t\tparams->PcieRpEnable[4]);\n\tfsp_display_upd_value(\"PcieRpEnable[5]\", 1, original->PcieRpEnable[5],\n\t\tparams->PcieRpEnable[5]);\n\tfsp_display_upd_value(\"PcieRpEnable[6]\", 1, original->PcieRpEnable[6],\n\t\tparams->PcieRpEnable[6]);\n\tfsp_display_upd_value(\"PcieRpEnable[7]\", 1, original->PcieRpEnable[7],\n\t\tparams->PcieRpEnable[7]);\n\tfsp_display_upd_value(\"PcieRpEnable[8]\", 1, original->PcieRpEnable[8],\n\t\tparams->PcieRpEnable[8]);\n\tfsp_display_upd_value(\"PcieRpEnable[9]\", 1, original->PcieRpEnable[9],\n\t\tparams->PcieRpEnable[9]);\n\tfsp_display_upd_value(\"PcieRpEnable[10]\", 1, original->PcieRpEnable[10],\n\t\tparams->PcieRpEnable[10]);\n\tfsp_display_upd_value(\"PcieRpEnable[11]\", 1, original->PcieRpEnable[11],\n\t\tparams->PcieRpEnable[11]);\n\tfsp_display_upd_value(\"PcieRpEnable[12]\", 1, original->PcieRpEnable[12],\n\t\tparams->PcieRpEnable[12]);\n\tfsp_display_upd_value(\"PcieRpEnable[13]\", 1, original->PcieRpEnable[13],\n\t\tparams->PcieRpEnable[13]);\n\tfsp_display_upd_value(\"PcieRpEnable[14]\", 1, original->PcieRpEnable[14],\n\t\tparams->PcieRpEnable[14]);\n\tfsp_display_upd_value(\"PcieRpEnable[15]\", 1, original->PcieRpEnable[15],\n\t\tparams->PcieRpEnable[15]);\n\tfsp_display_upd_value(\"PcieRpEnable[16]\", 1, original->PcieRpEnable[16],\n\t\tparams->PcieRpEnable[16]);\n\tfsp_display_upd_value(\"PcieRpEnable[17]\", 1, original->PcieRpEnable[17],\n\t\tparams->PcieRpEnable[17]);\n\tfsp_display_upd_value(\"PcieRpEnable[18]\", 1, original->PcieRpEnable[18],\n\t\tparams->PcieRpEnable[18]);\n\tfsp_display_upd_value(\"PcieRpEnable[19]\", 1, original->PcieRpEnable[19],\n\t\tparams->PcieRpEnable[19]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[0]\", 1,\n\t\toriginal->PcieRpClkReqSupport[0],\n\t\tparams->PcieRpClkReqSupport[0]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[1]\", 1,\n\t\toriginal->PcieRpClkReqSupport[1],\n\t\tparams->PcieRpClkReqSupport[1]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[2]\", 1,\n\t\toriginal->PcieRpClkReqSupport[2],\n\t\tparams->PcieRpClkReqSupport[2]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[3]\", 1,\n\t\toriginal->PcieRpClkReqSupport[3],\n\t\tparams->PcieRpClkReqSupport[3]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[4]\", 1,\n\t\toriginal->PcieRpClkReqSupport[4],\n\t\tparams->PcieRpClkReqSupport[4]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[5]\", 1,\n\t\toriginal->PcieRpClkReqSupport[5],\n\t\tparams->PcieRpClkReqSupport[5]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[6]\", 1,\n\t\toriginal->PcieRpClkReqSupport[6],\n\t\tparams->PcieRpClkReqSupport[6]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[7]\", 1,\n\t\toriginal->PcieRpClkReqSupport[7],\n\t\tparams->PcieRpClkReqSupport[7]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[8]\", 1,\n\t\toriginal->PcieRpClkReqSupport[8],\n\t\tparams->PcieRpClkReqSupport[8]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[9]\", 1,\n\t\toriginal->PcieRpClkReqSupport[9],\n\t\tparams->PcieRpClkReqSupport[9]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[10]\", 1,\n\t\toriginal->PcieRpClkReqSupport[10],\n\t\tparams->PcieRpClkReqSupport[10]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[11]\", 1,\n\t\toriginal->PcieRpClkReqSupport[11],\n\t\tparams->PcieRpClkReqSupport[11]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[12]\", 1,\n\t\toriginal->PcieRpClkReqSupport[12],\n\t\tparams->PcieRpClkReqSupport[12]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[13]\", 1,\n\t\toriginal->PcieRpClkReqSupport[13],\n\t\tparams->PcieRpClkReqSupport[13]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[14]\", 1,\n\t\toriginal->PcieRpClkReqSupport[14],\n\t\tparams->PcieRpClkReqSupport[14]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[15]\", 1,\n\t\toriginal->PcieRpClkReqSupport[15],\n\t\tparams->PcieRpClkReqSupport[15]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[16]\", 1,\n\t\toriginal->PcieRpClkReqSupport[16],\n\t\tparams->PcieRpClkReqSupport[16]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[17]\", 1,\n\t\toriginal->PcieRpClkReqSupport[17],\n\t\tparams->PcieRpClkReqSupport[17]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[18]\", 1,\n\t\toriginal->PcieRpClkReqSupport[18],\n\t\tparams->PcieRpClkReqSupport[18]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[19]\", 1,\n\t\toriginal->PcieRpClkReqSupport[19],\n\t\tparams->PcieRpClkReqSupport[19]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[0]\", 1,\n\t\toriginal->PcieRpClkReqNumber[0],\n\t\tparams->PcieRpClkReqNumber[0]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[1]\", 1,\n\t\toriginal->PcieRpClkReqNumber[1],\n\t\tparams->PcieRpClkReqNumber[1]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[2]\", 1,\n\t\toriginal->PcieRpClkReqNumber[2],\n\t\tparams->PcieRpClkReqNumber[2]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[3]\", 1,\n\t\toriginal->PcieRpClkReqNumber[3],\n\t\tparams->PcieRpClkReqNumber[3]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[4]\", 1,\n\t\toriginal->PcieRpClkReqNumber[4],\n\t\tparams->PcieRpClkReqNumber[4]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[5]\", 1,\n\t\toriginal->PcieRpClkReqNumber[5],\n\t\tparams->PcieRpClkReqNumber[5]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[6]\", 1,\n\t\toriginal->PcieRpClkReqNumber[6],\n\t\tparams->PcieRpClkReqNumber[6]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[7]\", 1,\n\t\toriginal->PcieRpClkReqNumber[7],\n\t\tparams->PcieRpClkReqNumber[7]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[8]\", 1,\n\t\toriginal->PcieRpClkReqNumber[8],\n\t\tparams->PcieRpClkReqNumber[8]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[9]\", 1,\n\t\toriginal->PcieRpClkReqNumber[9],\n\t\tparams->PcieRpClkReqNumber[9]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[10]\", 1,\n\t\toriginal->PcieRpClkReqNumber[10],\n\t\tparams->PcieRpClkReqNumber[10]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[11]\", 1,\n\t\toriginal->PcieRpClkReqNumber[11],\n\t\tparams->PcieRpClkReqNumber[11]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[12]\", 1,\n\t\toriginal->PcieRpClkReqNumber[12],\n\t\tparams->PcieRpClkReqNumber[12]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[13]\", 1,\n\t\toriginal->PcieRpClkReqNumber[13],\n\t\tparams->PcieRpClkReqNumber[13]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[14]\", 1,\n\t\toriginal->PcieRpClkReqNumber[14],\n\t\tparams->PcieRpClkReqNumber[14]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[15]\", 1,\n\t\toriginal->PcieRpClkReqNumber[15],\n\t\tparams->PcieRpClkReqNumber[15]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[16]\", 1,\n\t\toriginal->PcieRpClkReqNumber[16],\n\t\tparams->PcieRpClkReqNumber[16]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[17]\", 1,\n\t\toriginal->PcieRpClkReqNumber[17],\n\t\tparams->PcieRpClkReqNumber[17]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[18]\", 1,\n\t\toriginal->PcieRpClkReqNumber[18],\n\t\tparams->PcieRpClkReqNumber[18]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[19]\", 1,\n\t\toriginal->PcieRpClkReqNumber[19],\n\t\tparams->PcieRpClkReqNumber[19]);\n\tfsp_display_upd_value(\"EnableLan\", 1, original->EnableLan,\n\t\tparams->EnableLan);\n\tfsp_display_upd_value(\"Cio2Enable\", 1, original->Cio2Enable,\n\t\tparams->Cio2Enable);\n\tfsp_display_upd_value(\"SataSalpSupport\", 1, original->SataSalpSupport,\n\t\tparams->SataSalpSupport);\n\tfsp_display_upd_value(\"SataPortsEnable[0]\", 1,\n\t\toriginal->SataPortsEnable[0], params->SataPortsEnable[0]);\n\tfsp_display_upd_value(\"SataPortsEnable[1]\", 1,\n\t\toriginal->SataPortsEnable[1], params->SataPortsEnable[1]);\n\tfsp_display_upd_value(\"SataPortsEnable[2]\", 1,\n\t\toriginal->SataPortsEnable[2], params->SataPortsEnable[2]);\n\tfsp_display_upd_value(\"SataPortsEnable[3]\", 1,\n\t\toriginal->SataPortsEnable[3], params->SataPortsEnable[3]);\n\tfsp_display_upd_value(\"SataPortsEnable[4]\", 1,\n\t\toriginal->SataPortsEnable[4], params->SataPortsEnable[4]);\n\tfsp_display_upd_value(\"SataPortsEnable[5]\", 1,\n\t\toriginal->SataPortsEnable[5], params->SataPortsEnable[5]);\n\tfsp_display_upd_value(\"SataPortsEnable[6]\", 1,\n\t\toriginal->SataPortsEnable[6], params->SataPortsEnable[6]);\n\tfsp_display_upd_value(\"SataPortsEnable[7]\", 1,\n\t\toriginal->SataPortsEnable[7], params->SataPortsEnable[7]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[0]\", 1,\n\t\toriginal->SataPortsDevSlp[0], params->SataPortsDevSlp[0]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[1]\", 1,\n\t\toriginal->SataPortsDevSlp[1], params->SataPortsDevSlp[1]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[2]\", 1,\n\t\toriginal->SataPortsDevSlp[2], params->SataPortsDevSlp[2]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[3]\", 1,\n\t\toriginal->SataPortsDevSlp[3], params->SataPortsDevSlp[3]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[4]\", 1,\n\t\toriginal->SataPortsDevSlp[4], params->SataPortsDevSlp[4]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[5]\", 1,\n\t\toriginal->SataPortsDevSlp[5], params->SataPortsDevSlp[5]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[6]\", 1,\n\t\toriginal->SataPortsDevSlp[6], params->SataPortsDevSlp[6]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[7]\", 1,\n\t\toriginal->SataPortsDevSlp[7], params->SataPortsDevSlp[7]);\n\tfsp_display_upd_value(\"EnableAzalia\", 1,\n\t\toriginal->EnableAzalia,\tparams->EnableAzalia);\n\tfsp_display_upd_value(\"DspEnable\", 1, original->DspEnable,\n\t\tparams->DspEnable);\n\tfsp_display_upd_value(\"IoBufferOwnership\", 1,\n\t\toriginal->IoBufferOwnership, params->IoBufferOwnership);\n\tfsp_display_upd_value(\"PortUsb20Enable[0]\", 1,\n\t\toriginal->PortUsb20Enable[0], params->PortUsb20Enable[0]);\n\tfsp_display_upd_value(\"PortUsb20Enable[1]\", 1,\n\t\toriginal->PortUsb20Enable[1], params->PortUsb20Enable[1]);\n\tfsp_display_upd_value(\"PortUsb20Enable[2]\", 1,\n\t\toriginal->PortUsb20Enable[2], params->PortUsb20Enable[2]);\n\tfsp_display_upd_value(\"PortUsb20Enable[3]\", 1,\n\t\toriginal->PortUsb20Enable[3], params->PortUsb20Enable[3]);\n\tfsp_display_upd_value(\"PortUsb20Enable[4]\", 1,\n\t\toriginal->PortUsb20Enable[4], params->PortUsb20Enable[4]);\n\tfsp_display_upd_value(\"PortUsb20Enable[5]\", 1,\n\t\toriginal->PortUsb20Enable[5], params->PortUsb20Enable[5]);\n\tfsp_display_upd_value(\"PortUsb20Enable[6]\", 1,\n\t\toriginal->PortUsb20Enable[6], params->PortUsb20Enable[6]);\n\tfsp_display_upd_value(\"PortUsb20Enable[7]\", 1,\n\t\toriginal->PortUsb20Enable[7], params->PortUsb20Enable[7]);\n\tfsp_display_upd_value(\"PortUsb20Enable[8]\", 1,\n\t\toriginal->PortUsb20Enable[8], params->PortUsb20Enable[8]);\n\tfsp_display_upd_value(\"PortUsb20Enable[9]\", 1,\n\t\toriginal->PortUsb20Enable[9], params->PortUsb20Enable[9]);\n\tfsp_display_upd_value(\"PortUsb20Enable[10]\", 1,\n\t\toriginal->PortUsb20Enable[10], params->PortUsb20Enable[10]);\n\tfsp_display_upd_value(\"PortUsb20Enable[11]\", 1,\n\t\toriginal->PortUsb20Enable[11], params->PortUsb20Enable[11]);\n\tfsp_display_upd_value(\"PortUsb20Enable[12]\", 1,\n\t\toriginal->PortUsb20Enable[12], params->PortUsb20Enable[12]);\n\tfsp_display_upd_value(\"PortUsb20Enable[13]\", 1,\n\t\toriginal->PortUsb20Enable[13], params->PortUsb20Enable[13]);\n\tfsp_display_upd_value(\"PortUsb20Enable[14]\", 1,\n\t\toriginal->PortUsb20Enable[14], params->PortUsb20Enable[14]);\n\tfsp_display_upd_value(\"PortUsb20Enable[15]\", 1,\n\t\toriginal->PortUsb20Enable[15], params->PortUsb20Enable[15]);\n\tfsp_display_upd_value(\"PortUsb30Enable[0]\", 1,\n\t\toriginal->PortUsb30Enable[0], params->PortUsb30Enable[0]);\n\tfsp_display_upd_value(\"PortUsb30Enable[1]\", 1,\n\t\toriginal->PortUsb30Enable[1], params->PortUsb30Enable[1]);\n\tfsp_display_upd_value(\"PortUsb30Enable[2]\", 1,\n\t\toriginal->PortUsb30Enable[2], params->PortUsb30Enable[2]);\n\tfsp_display_upd_value(\"PortUsb30Enable[3]\", 1,\n\t\toriginal->PortUsb30Enable[3], params->PortUsb30Enable[3]);\n\tfsp_display_upd_value(\"PortUsb30Enable[4]\", 1,\n\t\toriginal->PortUsb30Enable[4], params->PortUsb30Enable[4]);\n\tfsp_display_upd_value(\"PortUsb30Enable[5]\", 1,\n\t\toriginal->PortUsb30Enable[5], params->PortUsb30Enable[5]);\n\tfsp_display_upd_value(\"PortUsb30Enable[6]\", 1,\n\t\toriginal->PortUsb30Enable[6], params->PortUsb30Enable[6]);\n\tfsp_display_upd_value(\"PortUsb30Enable[7]\", 1,\n\t\toriginal->PortUsb30Enable[7], params->PortUsb30Enable[7]);\n\tfsp_display_upd_value(\"PortUsb30Enable[8]\", 1,\n\t\toriginal->PortUsb30Enable[8], params->PortUsb30Enable[8]);\n\tfsp_display_upd_value(\"PortUsb30Enable[9]\", 1,\n\t\toriginal->PortUsb30Enable[9], params->PortUsb30Enable[9]);\n\tfsp_display_upd_value(\"XdciEnable\", 1, original->XdciEnable,\n\t\tparams->XdciEnable);\n\tfsp_display_upd_value(\"SsicPortEnable\", 1, original->SsicPortEnable,\n\t\tparams->SsicPortEnable);\n\tfsp_display_upd_value(\"SmbusEnable\", 1, original->SmbusEnable,\n\t\tparams->SmbusEnable);\n\tfsp_display_upd_value(\"SerialIoDevMode[0]\", 1,\n\t\toriginal->SerialIoDevMode[0], params->SerialIoDevMode[0]);\n\tfsp_display_upd_value(\"SerialIoDevMode[1]\", 1,\n\t\toriginal->SerialIoDevMode[1], params->SerialIoDevMode[1]);\n\tfsp_display_upd_value(\"SerialIoDevMode[2]\", 1,\n\t\toriginal->SerialIoDevMode[2], params->SerialIoDevMode[2]);\n\tfsp_display_upd_value(\"SerialIoDevMode[3]\", 1,\n\t\toriginal->SerialIoDevMode[3], params->SerialIoDevMode[3]);\n\tfsp_display_upd_value(\"SerialIoDevMode[4]\", 1,\n\t\toriginal->SerialIoDevMode[4], params->SerialIoDevMode[4]);\n\tfsp_display_upd_value(\"SerialIoDevMode[5]\", 1,\n\t\toriginal->SerialIoDevMode[5], params->SerialIoDevMode[5]);\n\tfsp_display_upd_value(\"SerialIoDevMode[6]\", 1,\n\t\toriginal->SerialIoDevMode[6], params->SerialIoDevMode[6]);\n\tfsp_display_upd_value(\"SerialIoDevMode[7]\", 1,\n\t\toriginal->SerialIoDevMode[7], params->SerialIoDevMode[7]);\n\tfsp_display_upd_value(\"SerialIoDevMode[8]\", 1,\n\t\toriginal->SerialIoDevMode[8], params->SerialIoDevMode[8]);\n\tfsp_display_upd_value(\"SerialIoDevMode[9]\", 1,\n\t\toriginal->SerialIoDevMode[9], params->SerialIoDevMode[9]);\n\tfsp_display_upd_value(\"SerialIoDevMode[10]\", 1,\n\t\toriginal->SerialIoDevMode[10], params->SerialIoDevMode[10]);\n\tfsp_display_upd_value(\"ScsEmmcEnabled\", 1, original->ScsEmmcEnabled,\n\t\tparams->ScsEmmcEnabled);\n\tfsp_display_upd_value(\"ScsEmmcHs400Enabled\", 1,\n\t\toriginal->ScsEmmcHs400Enabled, params->ScsEmmcHs400Enabled);\n\tfsp_display_upd_value(\"ScsSdCardEnabled\", 1, original->ScsSdCardEnabled,\n\t\tparams->ScsSdCardEnabled);\n\tfsp_display_upd_value(\"IshEnable\", 1, original->IshEnable,\n\t\tparams->IshEnable);\n\tfsp_display_upd_value(\"ShowSpiController\", 1,\n\t\toriginal->ShowSpiController, params->ShowSpiController);\n\tfsp_display_upd_value(\"HsioMessaging\", 1, original->HsioMessaging,\n\t\tparams->HsioMessaging);\n\tfsp_display_upd_value(\"Heci3Enabled\", 1, original->Heci3Enabled,\n\t\tparams->Heci3Enabled);\n\tfsp_display_upd_value(\"EnableSata\", 1, original->EnableSata,\n\t\tparams->EnableSata);\n\tfsp_display_upd_value(\"SataMode\", 1, original->SataMode,\n\t\tparams->SataMode);\n\tfsp_display_upd_value(\"NumOfDevIntConfig\", 1,\n\t\toriginal->NumOfDevIntConfig,\n\t\tparams->NumOfDevIntConfig);\n\tfsp_display_upd_value(\"PxRcConfig[PARC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PARC],\n\t\tparams->PxRcConfig[PCH_PARC]);\n\tfsp_display_upd_value(\"PxRcConfig[PBRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PBRC],\n\t\tparams->PxRcConfig[PCH_PBRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PCRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PCRC],\n\t\tparams->PxRcConfig[PCH_PCRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PDRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PDRC],\n\t\tparams->PxRcConfig[PCH_PDRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PERC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PERC],\n\t\tparams->PxRcConfig[PCH_PERC]);\n\tfsp_display_upd_value(\"PxRcConfig[PFRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PFRC],\n\t\tparams->PxRcConfig[PCH_PFRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PGRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PGRC],\n\t\tparams->PxRcConfig[PCH_PGRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PHRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PHRC],\n\t\tparams->PxRcConfig[PCH_PHRC]);\n\tfsp_display_upd_value(\"GpioIrqRoute\", 1,\n\t\toriginal->GpioIrqRoute,\n\t\tparams->GpioIrqRoute);\n\tfsp_display_upd_value(\"SciIrqSelect\", 1,\n\t\toriginal->SciIrqSelect,\n\t\tparams->SciIrqSelect);\n\tfsp_display_upd_value(\"TcoIrqSelect\", 1,\n\t\toriginal->TcoIrqSelect,\n\t\tparams->TcoIrqSelect);\n\tfsp_display_upd_value(\"TcoIrqEnable\", 1,\n\t\toriginal->TcoIrqEnable,\n\t\tparams->TcoIrqEnable);\n\tfsp_display_upd_value(\"LockDownConfigGlobalSmi\", 1,\n\t\toriginal->LockDownConfigGlobalSmi,\n\t\tparams->LockDownConfigGlobalSmi);\n\tfsp_display_upd_value(\"LockDownConfigBiosInterface\", 1,\n\t\toriginal->LockDownConfigBiosInterface,\n\t\tparams->LockDownConfigBiosInterface);\n\tfsp_display_upd_value(\"LockDownConfigRtcLock\", 1,\n\t\toriginal->LockDownConfigRtcLock,\n\t\tparams->LockDownConfigRtcLock);\n\tfsp_display_upd_value(\"LockDownConfigBiosLock\", 1,\n\t\toriginal->LockDownConfigBiosLock,\n\t\tparams->LockDownConfigBiosLock);\n\tfsp_display_upd_value(\"LockDownConfigSpiEiss\", 1,\n\t\toriginal->LockDownConfigSpiEiss,\n\t\tparams->LockDownConfigSpiEiss);\n\tfsp_display_upd_value(\"PchConfigSubSystemVendorId\", 1,\n\t\toriginal->PchConfigSubSystemVendorId,\n\t\tparams->PchConfigSubSystemVendorId);\n\tfsp_display_upd_value(\"PchConfigSubSystemId\", 1,\n\t\toriginal->PchConfigSubSystemId,\n\t\tparams->PchConfigSubSystemId);\n\tfsp_display_upd_value(\"WakeConfigWolEnableOverride\", 1,\n\t\toriginal->WakeConfigWolEnableOverride,\n\t\tparams->WakeConfigWolEnableOverride);\n\tfsp_display_upd_value(\"WakeConfigPcieWakeFromDeepSx\", 1,\n\t\toriginal->WakeConfigPcieWakeFromDeepSx,\n\t\tparams->WakeConfigPcieWakeFromDeepSx);\n\tfsp_display_upd_value(\"PmConfigDeepSxPol\", 1,\n\t\toriginal->PmConfigDeepSxPol,\n\t\tparams->PmConfigDeepSxPol);\n\tfsp_display_upd_value(\"PmConfigSlpS3MinAssert\", 1,\n\t\toriginal->PmConfigSlpS3MinAssert,\n\t\tparams->PmConfigSlpS3MinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpS4MinAssert\", 1,\n\t\toriginal->PmConfigSlpS4MinAssert,\n\t\tparams->PmConfigSlpS4MinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpSusMinAssert\", 1,\n\t\toriginal->PmConfigSlpSusMinAssert,\n\t\tparams->PmConfigSlpSusMinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpAMinAssert\", 1,\n\t\toriginal->PmConfigSlpAMinAssert,\n\t\tparams->PmConfigSlpAMinAssert);\n\tfsp_display_upd_value(\"PmConfigPciClockRun\", 1,\n\t\toriginal->PmConfigPciClockRun,\n\t\tparams->PmConfigPciClockRun);\n\tfsp_display_upd_value(\"PmConfigSlpStrchSusUp\", 1,\n\t\toriginal->PmConfigSlpStrchSusUp,\n\t\tparams->PmConfigSlpStrchSusUp);\n\tfsp_display_upd_value(\"PmConfigPwrBtnOverridePeriod\", 1,\n\t\toriginal->PmConfigPwrBtnOverridePeriod,\n\t\tparams->PmConfigPwrBtnOverridePeriod);\n\tfsp_display_upd_value(\"PmConfigPwrCycDur\", 1,\n\t\toriginal->PmConfigPwrCycDur,\n\t\tparams->PmConfigPwrCycDur);\n\tfsp_display_upd_value(\"SerialIrqConfigSirqEnable\", 1,\n\t\toriginal->SerialIrqConfigSirqEnable,\n\t\tparams->SerialIrqConfigSirqEnable);\n\tfsp_display_upd_value(\"SerialIrqConfigSirqMode\", 1,\n\t\toriginal->SerialIrqConfigSirqMode,\n\t\tparams->SerialIrqConfigSirqMode);\n\tfsp_display_upd_value(\"SerialIrqConfigStartFramePulse\", 1,\n\t\toriginal->SerialIrqConfigStartFramePulse,\n\t\tparams->SerialIrqConfigStartFramePulse);\n\n\tfsp_display_upd_value(\"Psi1Threshold[0]\", 1,\n\t\toriginal->Psi1Threshold[0],\n\t\tparams->Psi1Threshold[0]);\n\tfsp_display_upd_value(\"Psi1Threshold[1]\", 1,\n\t\toriginal->Psi1Threshold[1],\n\t\tparams->Psi1Threshold[1]);\n\tfsp_display_upd_value(\"Psi1Threshold[2]\", 1,\n\t\toriginal->Psi1Threshold[2],\n\t\tparams->Psi1Threshold[2]);\n\tfsp_display_upd_value(\"Psi1Threshold[3]\", 1,\n\t\toriginal->Psi1Threshold[3],\n\t\tparams->Psi1Threshold[3]);\n\tfsp_display_upd_value(\"Psi1Threshold[4]\", 1,\n\t\toriginal->Psi1Threshold[4],\n\t\tparams->Psi1Threshold[4]);\n\tfsp_display_upd_value(\"Psi2Threshold[0]\", 1,\n\t\toriginal->Psi2Threshold[0],\n\t\tparams->Psi2Threshold[0]);\n\tfsp_display_upd_value(\"Psi2Threshold[1]\", 1,\n\t\toriginal->Psi2Threshold[1],\n\t\tparams->Psi2Threshold[1]);\n\tfsp_display_upd_value(\"Psi2Threshold[2]\", 1,\n\t\toriginal->Psi2Threshold[2],\n\t\tparams->Psi2Threshold[2]);\n\tfsp_display_upd_value(\"Psi2Threshold[3]\", 1,\n\t\toriginal->Psi2Threshold[3],\n\t\tparams->Psi2Threshold[3]);\n\tfsp_display_upd_value(\"Psi2Threshold[4]\", 1,\n\t\toriginal->Psi2Threshold[4],\n\t\tparams->Psi2Threshold[4]);\n\tfsp_display_upd_value(\"Psi3Threshold[0]\", 1,\n\t\toriginal->Psi3Threshold[0],\n\t\tparams->Psi3Threshold[0]);\n\tfsp_display_upd_value(\"Psi3Threshold[1]\", 1,\n\t\toriginal->Psi3Threshold[1],\n\t\tparams->Psi3Threshold[1]);\n\tfsp_display_upd_value(\"Psi3Threshold[2]\", 1,\n\t\toriginal->Psi3Threshold[2],\n\t\tparams->Psi3Threshold[2]);\n\tfsp_display_upd_value(\"Psi3Threshold[3]\", 1,\n\t\toriginal->Psi3Threshold[3],\n\t\tparams->Psi3Threshold[3]);\n\tfsp_display_upd_value(\"Psi3Threshold[4]\", 1,\n\t\toriginal->Psi3Threshold[4],\n\t\tparams->Psi3Threshold[4]);\n\tfsp_display_upd_value(\"Psi3Enable[0]\", 1,\n\t\toriginal->Psi3Enable[0],\n\t\tparams->Psi3Enable[0]);\n\tfsp_display_upd_value(\"Psi3Enable[1]\", 1,\n\t\toriginal->Psi3Enable[1],\n\t\tparams->Psi3Enable[1]);\n\tfsp_display_upd_value(\"Psi3Enable[2]\", 1,\n\t\toriginal->Psi3Enable[2],\n\t\tparams->Psi3Enable[2]);\n\tfsp_display_upd_value(\"Psi3Enable[3]\", 1,\n\t\toriginal->Psi3Enable[3],\n\t\tparams->Psi3Enable[3]);\n\tfsp_display_upd_value(\"Psi3Enable[4]\", 1,\n\t\toriginal->Psi3Enable[4],\n\t\tparams->Psi3Enable[4]);\n\tfsp_display_upd_value(\"Psi4Enable[0]\", 1,\n\t\toriginal->Psi4Enable[0],\n\t\tparams->Psi4Enable[0]);\n\tfsp_display_upd_value(\"Psi4Enable[1]\", 1,\n\t\toriginal->Psi4Enable[1],\n\t\tparams->Psi4Enable[1]);\n\tfsp_display_upd_value(\"Psi4Enable[2]\", 1,\n\t\toriginal->Psi4Enable[2],\n\t\tparams->Psi4Enable[2]);\n\tfsp_display_upd_value(\"Psi4Enable[3]\", 1,\n\t\toriginal->Psi4Enable[3],\n\t\tparams->Psi4Enable[3]);\n\tfsp_display_upd_value(\"Psi4Enable[4]\", 1,\n\t\toriginal->Psi4Enable[4],\n\t\tparams->Psi4Enable[4]);\n\tfsp_display_upd_value(\"ImonSlope[0]\", 1,\n\t\toriginal->ImonSlope[0],\n\t\tparams->ImonSlope[0]);\n\tfsp_display_upd_value(\"ImonSlope[1]\", 1,\n\t\toriginal->ImonSlope[1],\n\t\tparams->ImonSlope[1]);\n\tfsp_display_upd_value(\"ImonSlope[2]\", 1,\n\t\toriginal->ImonSlope[2],\n\t\tparams->ImonSlope[2]);\n\tfsp_display_upd_value(\"ImonSlope[3]\", 1,\n\t\toriginal->ImonSlope[3],\n\t\tparams->ImonSlope[3]);\n\tfsp_display_upd_value(\"ImonSlope[4]\", 1,\n\t\toriginal->ImonSlope[4],\n\t\tparams->ImonSlope[4]);\n\tfsp_display_upd_value(\"ImonOffse[0]t\", 1,\n\t\toriginal->ImonOffset[0],\n\t\tparams->ImonOffset[0]);\n\tfsp_display_upd_value(\"ImonOffse[1]t\", 1,\n\t\toriginal->ImonOffset[1],\n\t\tparams->ImonOffset[1]);\n\tfsp_display_upd_value(\"ImonOffse[2]t\", 1,\n\t\toriginal->ImonOffset[2],\n\t\tparams->ImonOffset[2]);\n\tfsp_display_upd_value(\"ImonOffse[3]t\", 1,\n\t\toriginal->ImonOffset[3],\n\t\tparams->ImonOffset[3]);\n\tfsp_display_upd_value(\"ImonOffse[4]t\", 1,\n\t\toriginal->ImonOffset[4],\n\t\tparams->ImonOffset[4]);\n\tfsp_display_upd_value(\"IccMax[0]\", 1,\n\t\toriginal->IccMax[0],\n\t\tparams->IccMax[0]);\n\tfsp_display_upd_value(\"IccMax[1]\", 1,\n\t\toriginal->IccMax[1],\n\t\tparams->IccMax[1]);\n\tfsp_display_upd_value(\"IccMax[2]\", 1,\n\t\toriginal->IccMax[2],\n\t\tparams->IccMax[2]);\n\tfsp_display_upd_value(\"IccMax[3]\", 1,\n\t\toriginal->IccMax[3],\n\t\tparams->IccMax[3]);\n\tfsp_display_upd_value(\"IccMax[4]\", 1,\n\t\toriginal->IccMax[4],\n\t\tparams->IccMax[4]);\n\tfsp_display_upd_value(\"VrVoltageLimit[0]\", 1,\n\t\toriginal->VrVoltageLimit[0],\n\t\tparams->VrVoltageLimit[0]);\n\tfsp_display_upd_value(\"VrVoltageLimit[1]\", 1,\n\t\toriginal->VrVoltageLimit[1],\n\t\tparams->VrVoltageLimit[1]);\n\tfsp_display_upd_value(\"VrVoltageLimit[2]\", 1,\n\t\toriginal->VrVoltageLimit[2],\n\t\tparams->VrVoltageLimit[2]);\n\tfsp_display_upd_value(\"VrVoltageLimit[3]\", 1,\n\t\toriginal->VrVoltageLimit[3],\n\t\tparams->VrVoltageLimit[3]);\n\tfsp_display_upd_value(\"VrVoltageLimit[4]\", 1,\n\t\toriginal->VrVoltageLimit[4],\n\t\tparams->VrVoltageLimit[4]);\n\tfsp_display_upd_value(\"VrConfigEnable[0]\", 1,\n\t\toriginal->VrConfigEnable[0],\n\t\tparams->VrConfigEnable[0]);\n\tfsp_display_upd_value(\"VrConfigEnable[1]\", 1,\n\t\toriginal->VrConfigEnable[1],\n\t\tparams->VrConfigEnable[1]);\n\tfsp_display_upd_value(\"VrConfigEnable[2]\", 1,\n\t\toriginal->VrConfigEnable[2],\n\t\tparams->VrConfigEnable[2]);\n\tfsp_display_upd_value(\"VrConfigEnable[3]\", 1,\n\t\toriginal->VrConfigEnable[3],\n\t\tparams->VrConfigEnable[3]);\n\tfsp_display_upd_value(\"VrConfigEnable[4]\", 1,\n\t\toriginal->VrConfigEnable[4],\n\t\tparams->VrConfigEnable[4]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[0]\", 1,\n\t\toriginal->SerialIoI2cVoltage[0],\n\t\tparams->SerialIoI2cVoltage[0]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[1]\", 1,\n\t\toriginal->SerialIoI2cVoltage[1],\n\t\tparams->SerialIoI2cVoltage[1]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[2]\", 1,\n\t\toriginal->SerialIoI2cVoltage[2],\n\t\tparams->SerialIoI2cVoltage[2]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[3]\", 1,\n\t\toriginal->SerialIoI2cVoltage[3],\n\t\tparams->SerialIoI2cVoltage[3]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[4]\", 1,\n\t\toriginal->SerialIoI2cVoltage[4],\n\t\tparams->SerialIoI2cVoltage[4]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[5]\", 1,\n\t\toriginal->SerialIoI2cVoltage[5],\n\t\tparams->SerialIoI2cVoltage[5]);\n\tfsp_display_upd_value(\"SendVrMbxCmd\", 1,\n\t\toriginal->SendVrMbxCmd,\n\t\tparams->SendVrMbxCmd);\n\tfsp_display_upd_value(\"AcousticNoiseMitigation\", 1,\n\t\toriginal->AcousticNoiseMitigation,\n\t\tparams->AcousticNoiseMitigation);\n\tfsp_display_upd_value(\"SlowSlewRateForIa\", 1,\n\t\toriginal->SlowSlewRateForIa,\n\t\tparams->SlowSlewRateForIa);\n\tfsp_display_upd_value(\"SlowSlewRateForGt\", 1,\n\t\toriginal->SlowSlewRateForGt,\n\t\tparams->SlowSlewRateForGt);\n\tfsp_display_upd_value(\"SlowSlewRateForSa\", 1,\n\t\toriginal->SlowSlewRateForSa,\n\t\tparams->SlowSlewRateForSa);\n\tfsp_display_upd_value(\"FastPkgCRampDisable\", 1,\n\t\toriginal->FastPkgCRampDisable,\n\t\tparams->FastPkgCRampDisable);\n}", "item_id": 1, "repo": "fabiojna02/OpenCellular", "file": "firmware/coreboot/src/soc/intel/skylake/chip.c", "last_update_at": "2019-11-04T07:11:25+00:00", "question_id": "e8023ba0cee61cfeab6782ac6c287e3d0a2000eb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void soc_display_silicon_init_params(const SILICON_INIT_UPD *original,\n\tSILICON_INIT_UPD *params)\n{\n\t/* Display the parameters for SiliconInit */\n\tprintk(BIOS_SPEW, \"UPD values for SiliconInit:\\n\");\n\tfsp_display_upd_value(\"LogoPtr\", 4,\n\t\t\t(uint32_t)original->LogoPtr,\n\t\t\t(uint32_t)params->LogoPtr);\n\tfsp_display_upd_value(\"LogoSize\", 4,\n\t\t(uint32_t)original->LogoSize,\n\t\t(uint32_t)params->LogoSize);\n\tfsp_display_upd_value(\"GraphicsConfigPtr\", 4,\n\t\t(uint32_t)original->GraphicsConfigPtr,\n\t\t(uint32_t)params->GraphicsConfigPtr);\n\tfsp_display_upd_value(\"MicrocodeRegionBase\", 4,\n\t\t(uint32_t)original->MicrocodeRegionBase,\n\t\t(uint32_t)params->MicrocodeRegionBase);\n\tfsp_display_upd_value(\"MicrocodeRegionSize\", 4,\n\t\t(uint32_t)original->MicrocodeRegionSize,\n\t\t(uint32_t)params->MicrocodeRegionSize);\n\tfsp_display_upd_value(\"TurboMode\", 1,\n\t\t(uint32_t)original->TurboMode,\n\t\t(uint32_t)params->TurboMode);\n\tfsp_display_upd_value(\"Device4Enable\", 1,\n\t\toriginal->Device4Enable,\n\t\tparams->Device4Enable);\n\tfsp_display_upd_value(\"PcieRpEnable[0]\", 1, original->PcieRpEnable[0],\n\t\tparams->PcieRpEnable[0]);\n\tfsp_display_upd_value(\"PcieRpEnable[1]\", 1, original->PcieRpEnable[1],\n\t\tparams->PcieRpEnable[1]);\n\tfsp_display_upd_value(\"PcieRpEnable[2]\", 1, original->PcieRpEnable[2],\n\t\tparams->PcieRpEnable[2]);\n\tfsp_display_upd_value(\"PcieRpEnable[3]\", 1, original->PcieRpEnable[3],\n\t\tparams->PcieRpEnable[3]);\n\tfsp_display_upd_value(\"PcieRpEnable[4]\", 1, original->PcieRpEnable[4],\n\t\tparams->PcieRpEnable[4]);\n\tfsp_display_upd_value(\"PcieRpEnable[5]\", 1, original->PcieRpEnable[5],\n\t\tparams->PcieRpEnable[5]);\n\tfsp_display_upd_value(\"PcieRpEnable[6]\", 1, original->PcieRpEnable[6],\n\t\tparams->PcieRpEnable[6]);\n\tfsp_display_upd_value(\"PcieRpEnable[7]\", 1, original->PcieRpEnable[7],\n\t\tparams->PcieRpEnable[7]);\n\tfsp_display_upd_value(\"PcieRpEnable[8]\", 1, original->PcieRpEnable[8],\n\t\tparams->PcieRpEnable[8]);\n\tfsp_display_upd_value(\"PcieRpEnable[9]\", 1, original->PcieRpEnable[9],\n\t\tparams->PcieRpEnable[9]);\n\tfsp_display_upd_value(\"PcieRpEnable[10]\", 1, original->PcieRpEnable[10],\n\t\tparams->PcieRpEnable[10]);\n\tfsp_display_upd_value(\"PcieRpEnable[11]\", 1, original->PcieRpEnable[11],\n\t\tparams->PcieRpEnable[11]);\n\tfsp_display_upd_value(\"PcieRpEnable[12]\", 1, original->PcieRpEnable[12],\n\t\tparams->PcieRpEnable[12]);\n\tfsp_display_upd_value(\"PcieRpEnable[13]\", 1, original->PcieRpEnable[13],\n\t\tparams->PcieRpEnable[13]);\n\tfsp_display_upd_value(\"PcieRpEnable[14]\", 1, original->PcieRpEnable[14],\n\t\tparams->PcieRpEnable[14]);\n\tfsp_display_upd_value(\"PcieRpEnable[15]\", 1, original->PcieRpEnable[15],\n\t\tparams->PcieRpEnable[15]);\n\tfsp_display_upd_value(\"PcieRpEnable[16]\", 1, original->PcieRpEnable[16],\n\t\tparams->PcieRpEnable[16]);\n\tfsp_display_upd_value(\"PcieRpEnable[17]\", 1, original->PcieRpEnable[17],\n\t\tparams->PcieRpEnable[17]);\n\tfsp_display_upd_value(\"PcieRpEnable[18]\", 1, original->PcieRpEnable[18],\n\t\tparams->PcieRpEnable[18]);\n\tfsp_display_upd_value(\"PcieRpEnable[19]\", 1, original->PcieRpEnable[19],\n\t\tparams->PcieRpEnable[19]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[0]\", 1,\n\t\toriginal->PcieRpClkReqSupport[0],\n\t\tparams->PcieRpClkReqSupport[0]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[1]\", 1,\n\t\toriginal->PcieRpClkReqSupport[1],\n\t\tparams->PcieRpClkReqSupport[1]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[2]\", 1,\n\t\toriginal->PcieRpClkReqSupport[2],\n\t\tparams->PcieRpClkReqSupport[2]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[3]\", 1,\n\t\toriginal->PcieRpClkReqSupport[3],\n\t\tparams->PcieRpClkReqSupport[3]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[4]\", 1,\n\t\toriginal->PcieRpClkReqSupport[4],\n\t\tparams->PcieRpClkReqSupport[4]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[5]\", 1,\n\t\toriginal->PcieRpClkReqSupport[5],\n\t\tparams->PcieRpClkReqSupport[5]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[6]\", 1,\n\t\toriginal->PcieRpClkReqSupport[6],\n\t\tparams->PcieRpClkReqSupport[6]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[7]\", 1,\n\t\toriginal->PcieRpClkReqSupport[7],\n\t\tparams->PcieRpClkReqSupport[7]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[8]\", 1,\n\t\toriginal->PcieRpClkReqSupport[8],\n\t\tparams->PcieRpClkReqSupport[8]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[9]\", 1,\n\t\toriginal->PcieRpClkReqSupport[9],\n\t\tparams->PcieRpClkReqSupport[9]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[10]\", 1,\n\t\toriginal->PcieRpClkReqSupport[10],\n\t\tparams->PcieRpClkReqSupport[10]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[11]\", 1,\n\t\toriginal->PcieRpClkReqSupport[11],\n\t\tparams->PcieRpClkReqSupport[11]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[12]\", 1,\n\t\toriginal->PcieRpClkReqSupport[12],\n\t\tparams->PcieRpClkReqSupport[12]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[13]\", 1,\n\t\toriginal->PcieRpClkReqSupport[13],\n\t\tparams->PcieRpClkReqSupport[13]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[14]\", 1,\n\t\toriginal->PcieRpClkReqSupport[14],\n\t\tparams->PcieRpClkReqSupport[14]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[15]\", 1,\n\t\toriginal->PcieRpClkReqSupport[15],\n\t\tparams->PcieRpClkReqSupport[15]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[16]\", 1,\n\t\toriginal->PcieRpClkReqSupport[16],\n\t\tparams->PcieRpClkReqSupport[16]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[17]\", 1,\n\t\toriginal->PcieRpClkReqSupport[17],\n\t\tparams->PcieRpClkReqSupport[17]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[18]\", 1,\n\t\toriginal->PcieRpClkReqSupport[18],\n\t\tparams->PcieRpClkReqSupport[18]);\n\tfsp_display_upd_value(\"PcieRpClkReqSupport[19]\", 1,\n\t\toriginal->PcieRpClkReqSupport[19],\n\t\tparams->PcieRpClkReqSupport[19]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[0]\", 1,\n\t\toriginal->PcieRpClkReqNumber[0],\n\t\tparams->PcieRpClkReqNumber[0]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[1]\", 1,\n\t\toriginal->PcieRpClkReqNumber[1],\n\t\tparams->PcieRpClkReqNumber[1]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[2]\", 1,\n\t\toriginal->PcieRpClkReqNumber[2],\n\t\tparams->PcieRpClkReqNumber[2]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[3]\", 1,\n\t\toriginal->PcieRpClkReqNumber[3],\n\t\tparams->PcieRpClkReqNumber[3]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[4]\", 1,\n\t\toriginal->PcieRpClkReqNumber[4],\n\t\tparams->PcieRpClkReqNumber[4]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[5]\", 1,\n\t\toriginal->PcieRpClkReqNumber[5],\n\t\tparams->PcieRpClkReqNumber[5]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[6]\", 1,\n\t\toriginal->PcieRpClkReqNumber[6],\n\t\tparams->PcieRpClkReqNumber[6]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[7]\", 1,\n\t\toriginal->PcieRpClkReqNumber[7],\n\t\tparams->PcieRpClkReqNumber[7]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[8]\", 1,\n\t\toriginal->PcieRpClkReqNumber[8],\n\t\tparams->PcieRpClkReqNumber[8]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[9]\", 1,\n\t\toriginal->PcieRpClkReqNumber[9],\n\t\tparams->PcieRpClkReqNumber[9]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[10]\", 1,\n\t\toriginal->PcieRpClkReqNumber[10],\n\t\tparams->PcieRpClkReqNumber[10]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[11]\", 1,\n\t\toriginal->PcieRpClkReqNumber[11],\n\t\tparams->PcieRpClkReqNumber[11]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[12]\", 1,\n\t\toriginal->PcieRpClkReqNumber[12],\n\t\tparams->PcieRpClkReqNumber[12]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[13]\", 1,\n\t\toriginal->PcieRpClkReqNumber[13],\n\t\tparams->PcieRpClkReqNumber[13]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[14]\", 1,\n\t\toriginal->PcieRpClkReqNumber[14],\n\t\tparams->PcieRpClkReqNumber[14]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[15]\", 1,\n\t\toriginal->PcieRpClkReqNumber[15],\n\t\tparams->PcieRpClkReqNumber[15]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[16]\", 1,\n\t\toriginal->PcieRpClkReqNumber[16],\n\t\tparams->PcieRpClkReqNumber[16]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[17]\", 1,\n\t\toriginal->PcieRpClkReqNumber[17],\n\t\tparams->PcieRpClkReqNumber[17]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[18]\", 1,\n\t\toriginal->PcieRpClkReqNumber[18],\n\t\tparams->PcieRpClkReqNumber[18]);\n\tfsp_display_upd_value(\"PcieRpClkReqNumber[19]\", 1,\n\t\toriginal->PcieRpClkReqNumber[19],\n\t\tparams->PcieRpClkReqNumber[19]);\n\tfsp_display_upd_value(\"EnableLan\", 1, original->EnableLan,\n\t\tparams->EnableLan);\n\tfsp_display_upd_value(\"Cio2Enable\", 1, original->Cio2Enable,\n\t\tparams->Cio2Enable);\n\tfsp_display_upd_value(\"SataSalpSupport\", 1, original->SataSalpSupport,\n\t\tparams->SataSalpSupport);\n\tfsp_display_upd_value(\"SataPortsEnable[0]\", 1,\n\t\toriginal->SataPortsEnable[0], params->SataPortsEnable[0]);\n\tfsp_display_upd_value(\"SataPortsEnable[1]\", 1,\n\t\toriginal->SataPortsEnable[1], params->SataPortsEnable[1]);\n\tfsp_display_upd_value(\"SataPortsEnable[2]\", 1,\n\t\toriginal->SataPortsEnable[2], params->SataPortsEnable[2]);\n\tfsp_display_upd_value(\"SataPortsEnable[3]\", 1,\n\t\toriginal->SataPortsEnable[3], params->SataPortsEnable[3]);\n\tfsp_display_upd_value(\"SataPortsEnable[4]\", 1,\n\t\toriginal->SataPortsEnable[4], params->SataPortsEnable[4]);\n\tfsp_display_upd_value(\"SataPortsEnable[5]\", 1,\n\t\toriginal->SataPortsEnable[5], params->SataPortsEnable[5]);\n\tfsp_display_upd_value(\"SataPortsEnable[6]\", 1,\n\t\toriginal->SataPortsEnable[6], params->SataPortsEnable[6]);\n\tfsp_display_upd_value(\"SataPortsEnable[7]\", 1,\n\t\toriginal->SataPortsEnable[7], params->SataPortsEnable[7]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[0]\", 1,\n\t\toriginal->SataPortsDevSlp[0], params->SataPortsDevSlp[0]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[1]\", 1,\n\t\toriginal->SataPortsDevSlp[1], params->SataPortsDevSlp[1]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[2]\", 1,\n\t\toriginal->SataPortsDevSlp[2], params->SataPortsDevSlp[2]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[3]\", 1,\n\t\toriginal->SataPortsDevSlp[3], params->SataPortsDevSlp[3]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[4]\", 1,\n\t\toriginal->SataPortsDevSlp[4], params->SataPortsDevSlp[4]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[5]\", 1,\n\t\toriginal->SataPortsDevSlp[5], params->SataPortsDevSlp[5]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[6]\", 1,\n\t\toriginal->SataPortsDevSlp[6], params->SataPortsDevSlp[6]);\n\tfsp_display_upd_value(\"SataPortsDevSlp[7]\", 1,\n\t\toriginal->SataPortsDevSlp[7], params->SataPortsDevSlp[7]);\n\tfsp_display_upd_value(\"EnableAzalia\", 1,\n\t\toriginal->EnableAzalia,\tparams->EnableAzalia);\n\tfsp_display_upd_value(\"DspEnable\", 1, original->DspEnable,\n\t\tparams->DspEnable);\n\tfsp_display_upd_value(\"IoBufferOwnership\", 1,\n\t\toriginal->IoBufferOwnership, params->IoBufferOwnership);\n\tfsp_display_upd_value(\"PortUsb20Enable[0]\", 1,\n\t\toriginal->PortUsb20Enable[0], params->PortUsb20Enable[0]);\n\tfsp_display_upd_value(\"PortUsb20Enable[1]\", 1,\n\t\toriginal->PortUsb20Enable[1], params->PortUsb20Enable[1]);\n\tfsp_display_upd_value(\"PortUsb20Enable[2]\", 1,\n\t\toriginal->PortUsb20Enable[2], params->PortUsb20Enable[2]);\n\tfsp_display_upd_value(\"PortUsb20Enable[3]\", 1,\n\t\toriginal->PortUsb20Enable[3], params->PortUsb20Enable[3]);\n\tfsp_display_upd_value(\"PortUsb20Enable[4]\", 1,\n\t\toriginal->PortUsb20Enable[4], params->PortUsb20Enable[4]);\n\tfsp_display_upd_value(\"PortUsb20Enable[5]\", 1,\n\t\toriginal->PortUsb20Enable[5], params->PortUsb20Enable[5]);\n\tfsp_display_upd_value(\"PortUsb20Enable[6]\", 1,\n\t\toriginal->PortUsb20Enable[6], params->PortUsb20Enable[6]);\n\tfsp_display_upd_value(\"PortUsb20Enable[7]\", 1,\n\t\toriginal->PortUsb20Enable[7], params->PortUsb20Enable[7]);\n\tfsp_display_upd_value(\"PortUsb20Enable[8]\", 1,\n\t\toriginal->PortUsb20Enable[8], params->PortUsb20Enable[8]);\n\tfsp_display_upd_value(\"PortUsb20Enable[9]\", 1,\n\t\toriginal->PortUsb20Enable[9], params->PortUsb20Enable[9]);\n\tfsp_display_upd_value(\"PortUsb20Enable[10]\", 1,\n\t\toriginal->PortUsb20Enable[10], params->PortUsb20Enable[10]);\n\tfsp_display_upd_value(\"PortUsb20Enable[11]\", 1,\n\t\toriginal->PortUsb20Enable[11], params->PortUsb20Enable[11]);\n\tfsp_display_upd_value(\"PortUsb20Enable[12]\", 1,\n\t\toriginal->PortUsb20Enable[12], params->PortUsb20Enable[12]);\n\tfsp_display_upd_value(\"PortUsb20Enable[13]\", 1,\n\t\toriginal->PortUsb20Enable[13], params->PortUsb20Enable[13]);\n\tfsp_display_upd_value(\"PortUsb20Enable[14]\", 1,\n\t\toriginal->PortUsb20Enable[14], params->PortUsb20Enable[14]);\n\tfsp_display_upd_value(\"PortUsb20Enable[15]\", 1,\n\t\toriginal->PortUsb20Enable[15], params->PortUsb20Enable[15]);\n\tfsp_display_upd_value(\"PortUsb30Enable[0]\", 1,\n\t\toriginal->PortUsb30Enable[0], params->PortUsb30Enable[0]);\n\tfsp_display_upd_value(\"PortUsb30Enable[1]\", 1,\n\t\toriginal->PortUsb30Enable[1], params->PortUsb30Enable[1]);\n\tfsp_display_upd_value(\"PortUsb30Enable[2]\", 1,\n\t\toriginal->PortUsb30Enable[2], params->PortUsb30Enable[2]);\n\tfsp_display_upd_value(\"PortUsb30Enable[3]\", 1,\n\t\toriginal->PortUsb30Enable[3], params->PortUsb30Enable[3]);\n\tfsp_display_upd_value(\"PortUsb30Enable[4]\", 1,\n\t\toriginal->PortUsb30Enable[4], params->PortUsb30Enable[4]);\n\tfsp_display_upd_value(\"PortUsb30Enable[5]\", 1,\n\t\toriginal->PortUsb30Enable[5], params->PortUsb30Enable[5]);\n\tfsp_display_upd_value(\"PortUsb30Enable[6]\", 1,\n\t\toriginal->PortUsb30Enable[6], params->PortUsb30Enable[6]);\n\tfsp_display_upd_value(\"PortUsb30Enable[7]\", 1,\n\t\toriginal->PortUsb30Enable[7], params->PortUsb30Enable[7]);\n\tfsp_display_upd_value(\"PortUsb30Enable[8]\", 1,\n\t\toriginal->PortUsb30Enable[8], params->PortUsb30Enable[8]);\n\tfsp_display_upd_value(\"PortUsb30Enable[9]\", 1,\n\t\toriginal->PortUsb30Enable[9], params->PortUsb30Enable[9]);\n\tfsp_display_upd_value(\"XdciEnable\", 1, original->XdciEnable,\n\t\tparams->XdciEnable);\n\tfsp_display_upd_value(\"SsicPortEnable\", 1, original->SsicPortEnable,\n\t\tparams->SsicPortEnable);\n\tfsp_display_upd_value(\"SmbusEnable\", 1, original->SmbusEnable,\n\t\tparams->SmbusEnable);\n\tfsp_display_upd_value(\"SerialIoDevMode[0]\", 1,\n\t\toriginal->SerialIoDevMode[0], params->SerialIoDevMode[0]);\n\tfsp_display_upd_value(\"SerialIoDevMode[1]\", 1,\n\t\toriginal->SerialIoDevMode[1], params->SerialIoDevMode[1]);\n\tfsp_display_upd_value(\"SerialIoDevMode[2]\", 1,\n\t\toriginal->SerialIoDevMode[2], params->SerialIoDevMode[2]);\n\tfsp_display_upd_value(\"SerialIoDevMode[3]\", 1,\n\t\toriginal->SerialIoDevMode[3], params->SerialIoDevMode[3]);\n\tfsp_display_upd_value(\"SerialIoDevMode[4]\", 1,\n\t\toriginal->SerialIoDevMode[4], params->SerialIoDevMode[4]);\n\tfsp_display_upd_value(\"SerialIoDevMode[5]\", 1,\n\t\toriginal->SerialIoDevMode[5], params->SerialIoDevMode[5]);\n\tfsp_display_upd_value(\"SerialIoDevMode[6]\", 1,\n\t\toriginal->SerialIoDevMode[6], params->SerialIoDevMode[6]);\n\tfsp_display_upd_value(\"SerialIoDevMode[7]\", 1,\n\t\toriginal->SerialIoDevMode[7], params->SerialIoDevMode[7]);\n\tfsp_display_upd_value(\"SerialIoDevMode[8]\", 1,\n\t\toriginal->SerialIoDevMode[8], params->SerialIoDevMode[8]);\n\tfsp_display_upd_value(\"SerialIoDevMode[9]\", 1,\n\t\toriginal->SerialIoDevMode[9], params->SerialIoDevMode[9]);\n\tfsp_display_upd_value(\"SerialIoDevMode[10]\", 1,\n\t\toriginal->SerialIoDevMode[10], params->SerialIoDevMode[10]);\n\tfsp_display_upd_value(\"ScsEmmcEnabled\", 1, original->ScsEmmcEnabled,\n\t\tparams->ScsEmmcEnabled);\n\tfsp_display_upd_value(\"ScsEmmcHs400Enabled\", 1,\n\t\toriginal->ScsEmmcHs400Enabled, params->ScsEmmcHs400Enabled);\n\tfsp_display_upd_value(\"ScsSdCardEnabled\", 1, original->ScsSdCardEnabled,\n\t\tparams->ScsSdCardEnabled);\n\tfsp_display_upd_value(\"IshEnable\", 1, original->IshEnable,\n\t\tparams->IshEnable);\n\tfsp_display_upd_value(\"ShowSpiController\", 1,\n\t\toriginal->ShowSpiController, params->ShowSpiController);\n\tfsp_display_upd_value(\"HsioMessaging\", 1, original->HsioMessaging,\n\t\tparams->HsioMessaging);\n\tfsp_display_upd_value(\"Heci3Enabled\", 1, original->Heci3Enabled,\n\t\tparams->Heci3Enabled);\n\tfsp_display_upd_value(\"EnableSata\", 1, original->EnableSata,\n\t\tparams->EnableSata);\n\tfsp_display_upd_value(\"SataMode\", 1, original->SataMode,\n\t\tparams->SataMode);\n\tfsp_display_upd_value(\"NumOfDevIntConfig\", 1,\n\t\toriginal->NumOfDevIntConfig,\n\t\tparams->NumOfDevIntConfig);\n\tfsp_display_upd_value(\"PxRcConfig[PARC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PARC],\n\t\tparams->PxRcConfig[PCH_PARC]);\n\tfsp_display_upd_value(\"PxRcConfig[PBRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PBRC],\n\t\tparams->PxRcConfig[PCH_PBRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PCRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PCRC],\n\t\tparams->PxRcConfig[PCH_PCRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PDRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PDRC],\n\t\tparams->PxRcConfig[PCH_PDRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PERC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PERC],\n\t\tparams->PxRcConfig[PCH_PERC]);\n\tfsp_display_upd_value(\"PxRcConfig[PFRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PFRC],\n\t\tparams->PxRcConfig[PCH_PFRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PGRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PGRC],\n\t\tparams->PxRcConfig[PCH_PGRC]);\n\tfsp_display_upd_value(\"PxRcConfig[PHRC]\", 1,\n\t\toriginal->PxRcConfig[PCH_PHRC],\n\t\tparams->PxRcConfig[PCH_PHRC]);\n\tfsp_display_upd_value(\"GpioIrqRoute\", 1,\n\t\toriginal->GpioIrqRoute,\n\t\tparams->GpioIrqRoute);\n\tfsp_display_upd_value(\"SciIrqSelect\", 1,\n\t\toriginal->SciIrqSelect,\n\t\tparams->SciIrqSelect);\n\tfsp_display_upd_value(\"TcoIrqSelect\", 1,\n\t\toriginal->TcoIrqSelect,\n\t\tparams->TcoIrqSelect);\n\tfsp_display_upd_value(\"TcoIrqEnable\", 1,\n\t\toriginal->TcoIrqEnable,\n\t\tparams->TcoIrqEnable);\n\tfsp_display_upd_value(\"LockDownConfigGlobalSmi\", 1,\n\t\toriginal->LockDownConfigGlobalSmi,\n\t\tparams->LockDownConfigGlobalSmi);\n\tfsp_display_upd_value(\"LockDownConfigBiosInterface\", 1,\n\t\toriginal->LockDownConfigBiosInterface,\n\t\tparams->LockDownConfigBiosInterface);\n\tfsp_display_upd_value(\"LockDownConfigRtcLock\", 1,\n\t\toriginal->LockDownConfigRtcLock,\n\t\tparams->LockDownConfigRtcLock);\n\tfsp_display_upd_value(\"LockDownConfigBiosLock\", 1,\n\t\toriginal->LockDownConfigBiosLock,\n\t\tparams->LockDownConfigBiosLock);\n\tfsp_display_upd_value(\"LockDownConfigSpiEiss\", 1,\n\t\toriginal->LockDownConfigSpiEiss,\n\t\tparams->LockDownConfigSpiEiss);\n\tfsp_display_upd_value(\"PchConfigSubSystemVendorId\", 1,\n\t\toriginal->PchConfigSubSystemVendorId,\n\t\tparams->PchConfigSubSystemVendorId);\n\tfsp_display_upd_value(\"PchConfigSubSystemId\", 1,\n\t\toriginal->PchConfigSubSystemId,\n\t\tparams->PchConfigSubSystemId);\n\tfsp_display_upd_value(\"WakeConfigWolEnableOverride\", 1,\n\t\toriginal->WakeConfigWolEnableOverride,\n\t\tparams->WakeConfigWolEnableOverride);\n\tfsp_display_upd_value(\"WakeConfigPcieWakeFromDeepSx\", 1,\n\t\toriginal->WakeConfigPcieWakeFromDeepSx,\n\t\tparams->WakeConfigPcieWakeFromDeepSx);\n\tfsp_display_upd_value(\"PmConfigDeepSxPol\", 1,\n\t\toriginal->PmConfigDeepSxPol,\n\t\tparams->PmConfigDeepSxPol);\n\tfsp_display_upd_value(\"PmConfigSlpS3MinAssert\", 1,\n\t\toriginal->PmConfigSlpS3MinAssert,\n\t\tparams->PmConfigSlpS3MinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpS4MinAssert\", 1,\n\t\toriginal->PmConfigSlpS4MinAssert,\n\t\tparams->PmConfigSlpS4MinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpSusMinAssert\", 1,\n\t\toriginal->PmConfigSlpSusMinAssert,\n\t\tparams->PmConfigSlpSusMinAssert);\n\tfsp_display_upd_value(\"PmConfigSlpAMinAssert\", 1,\n\t\toriginal->PmConfigSlpAMinAssert,\n\t\tparams->PmConfigSlpAMinAssert);\n\tfsp_display_upd_value(\"PmConfigPciClockRun\", 1,\n\t\toriginal->PmConfigPciClockRun,\n\t\tparams->PmConfigPciClockRun);\n\tfsp_display_upd_value(\"PmConfigSlpStrchSusUp\", 1,\n\t\toriginal->PmConfigSlpStrchSusUp,\n\t\tparams->PmConfigSlpStrchSusUp);\n\tfsp_display_upd_value(\"PmConfigPwrBtnOverridePeriod\", 1,\n\t\toriginal->PmConfigPwrBtnOverridePeriod,\n\t\tparams->PmConfigPwrBtnOverridePeriod);\n\tfsp_display_upd_value(\"PmConfigPwrCycDur\", 1,\n\t\toriginal->PmConfigPwrCycDur,\n\t\tparams->PmConfigPwrCycDur);\n\tfsp_display_upd_value(\"SerialIrqConfigSirqEnable\", 1,\n\t\toriginal->SerialIrqConfigSirqEnable,\n\t\tparams->SerialIrqConfigSirqEnable);\n\tfsp_display_upd_value(\"SerialIrqConfigSirqMode\", 1,\n\t\toriginal->SerialIrqConfigSirqMode,\n\t\tparams->SerialIrqConfigSirqMode);\n\tfsp_display_upd_value(\"SerialIrqConfigStartFramePulse\", 1,\n\t\toriginal->SerialIrqConfigStartFramePulse,\n\t\tparams->SerialIrqConfigStartFramePulse);\n\tfsp_display_upd_value(\"Psi1Threshold[0]\", 1,\n\t\toriginal->Psi1Threshold[0],\n\t\tparams->Psi1Threshold[0]);\n\tfsp_display_upd_value(\"Psi1Threshold[1]\", 1,\n\t\toriginal->Psi1Threshold[1],\n\t\tparams->Psi1Threshold[1]);\n\tfsp_display_upd_value(\"Psi1Threshold[2]\", 1,\n\t\toriginal->Psi1Threshold[2],\n\t\tparams->Psi1Threshold[2]);\n\tfsp_display_upd_value(\"Psi1Threshold[3]\", 1,\n\t\toriginal->Psi1Threshold[3],\n\t\tparams->Psi1Threshold[3]);\n\tfsp_display_upd_value(\"Psi1Threshold[4]\", 1,\n\t\toriginal->Psi1Threshold[4],\n\t\tparams->Psi1Threshold[4]);\n\tfsp_display_upd_value(\"Psi2Threshold[0]\", 1,\n\t\toriginal->Psi2Threshold[0],\n\t\tparams->Psi2Threshold[0]);\n\tfsp_display_upd_value(\"Psi2Threshold[1]\", 1,\n\t\toriginal->Psi2Threshold[1],\n\t\tparams->Psi2Threshold[1]);\n\tfsp_display_upd_value(\"Psi2Threshold[2]\", 1,\n\t\toriginal->Psi2Threshold[2],\n\t\tparams->Psi2Threshold[2]);\n\tfsp_display_upd_value(\"Psi2Threshold[3]\", 1,\n\t\toriginal->Psi2Threshold[3],\n\t\tparams->Psi2Threshold[3]);\n\tfsp_display_upd_value(\"Psi2Threshold[4]\", 1,\n\t\toriginal->Psi2Threshold[4],\n\t\tparams->Psi2Threshold[4]);\n\tfsp_display_upd_value(\"Psi3Threshold[0]\", 1,\n\t\toriginal->Psi3Threshold[0],\n\t\tparams->Psi3Threshold[0]);\n\tfsp_display_upd_value(\"Psi3Threshold[1]\", 1,\n\t\toriginal->Psi3Threshold[1],\n\t\tparams->Psi3Threshold[1]);\n\tfsp_display_upd_value(\"Psi3Threshold[2]\", 1,\n\t\toriginal->Psi3Threshold[2],\n\t\tparams->Psi3Threshold[2]);\n\tfsp_display_upd_value(\"Psi3Threshold[3]\", 1,\n\t\toriginal->Psi3Threshold[3],\n\t\tparams->Psi3Threshold[3]);\n\tfsp_display_upd_value(\"Psi3Threshold[4]\", 1,\n\t\toriginal->Psi3Threshold[4],\n\t\tparams->Psi3Threshold[4]);\n\tfsp_display_upd_value(\"Psi3Enable[0]\", 1,\n\t\toriginal->Psi3Enable[0],\n\t\tparams->Psi3Enable[0]);\n\tfsp_display_upd_value(\"Psi3Enable[1]\", 1,\n\t\toriginal->Psi3Enable[1],\n\t\tparams->Psi3Enable[1]);\n\tfsp_display_upd_value(\"Psi3Enable[2]\", 1,\n\t\toriginal->Psi3Enable[2],\n\t\tparams->Psi3Enable[2]);\n\tfsp_display_upd_value(\"Psi3Enable[3]\", 1,\n\t\toriginal->Psi3Enable[3],\n\t\tparams->Psi3Enable[3]);\n\tfsp_display_upd_value(\"Psi3Enable[4]\", 1,\n\t\toriginal->Psi3Enable[4],\n\t\tparams->Psi3Enable[4]);\n\tfsp_display_upd_value(\"Psi4Enable[0]\", 1,\n\t\toriginal->Psi4Enable[0],\n\t\tparams->Psi4Enable[0]);\n\tfsp_display_upd_value(\"Psi4Enable[1]\", 1,\n\t\toriginal->Psi4Enable[1],\n\t\tparams->Psi4Enable[1]);\n\tfsp_display_upd_value(\"Psi4Enable[2]\", 1,\n\t\toriginal->Psi4Enable[2],\n\t\tparams->Psi4Enable[2]);\n\tfsp_display_upd_value(\"Psi4Enable[3]\", 1,\n\t\toriginal->Psi4Enable[3],\n\t\tparams->Psi4Enable[3]);\n\tfsp_display_upd_value(\"Psi4Enable[4]\", 1,\n\t\toriginal->Psi4Enable[4],\n\t\tparams->Psi4Enable[4]);\n\tfsp_display_upd_value(\"ImonSlope[0]\", 1,\n\t\toriginal->ImonSlope[0],\n\t\tparams->ImonSlope[0]);\n\tfsp_display_upd_value(\"ImonSlope[1]\", 1,\n\t\toriginal->ImonSlope[1],\n\t\tparams->ImonSlope[1]);\n\tfsp_display_upd_value(\"ImonSlope[2]\", 1,\n\t\toriginal->ImonSlope[2],\n\t\tparams->ImonSlope[2]);\n\tfsp_display_upd_value(\"ImonSlope[3]\", 1,\n\t\toriginal->ImonSlope[3],\n\t\tparams->ImonSlope[3]);\n\tfsp_display_upd_value(\"ImonSlope[4]\", 1,\n\t\toriginal->ImonSlope[4],\n\t\tparams->ImonSlope[4]);\n\tfsp_display_upd_value(\"ImonOffse[0]t\", 1,\n\t\toriginal->ImonOffset[0],\n\t\tparams->ImonOffset[0]);\n\tfsp_display_upd_value(\"ImonOffse[1]t\", 1,\n\t\toriginal->ImonOffset[1],\n\t\tparams->ImonOffset[1]);\n\tfsp_display_upd_value(\"ImonOffse[2]t\", 1,\n\t\toriginal->ImonOffset[2],\n\t\tparams->ImonOffset[2]);\n\tfsp_display_upd_value(\"ImonOffse[3]t\", 1,\n\t\toriginal->ImonOffset[3],\n\t\tparams->ImonOffset[3]);\n\tfsp_display_upd_value(\"ImonOffse[4]t\", 1,\n\t\toriginal->ImonOffset[4],\n\t\tparams->ImonOffset[4]);\n\tfsp_display_upd_value(\"IccMax[0]\", 1,\n\t\toriginal->IccMax[0],\n\t\tparams->IccMax[0]);\n\tfsp_display_upd_value(\"IccMax[1]\", 1,\n\t\toriginal->IccMax[1],\n\t\tparams->IccMax[1]);\n\tfsp_display_upd_value(\"IccMax[2]\", 1,\n\t\toriginal->IccMax[2],\n\t\tparams->IccMax[2]);\n\tfsp_display_upd_value(\"IccMax[3]\", 1,\n\t\toriginal->IccMax[3],\n\t\tparams->IccMax[3]);\n\tfsp_display_upd_value(\"IccMax[4]\", 1,\n\t\toriginal->IccMax[4],\n\t\tparams->IccMax[4]);\n\tfsp_display_upd_value(\"VrVoltageLimit[0]\", 1,\n\t\toriginal->VrVoltageLimit[0],\n\t\tparams->VrVoltageLimit[0]);\n\tfsp_display_upd_value(\"VrVoltageLimit[1]\", 1,\n\t\toriginal->VrVoltageLimit[1],\n\t\tparams->VrVoltageLimit[1]);\n\tfsp_display_upd_value(\"VrVoltageLimit[2]\", 1,\n\t\toriginal->VrVoltageLimit[2],\n\t\tparams->VrVoltageLimit[2]);\n\tfsp_display_upd_value(\"VrVoltageLimit[3]\", 1,\n\t\toriginal->VrVoltageLimit[3],\n\t\tparams->VrVoltageLimit[3]);\n\tfsp_display_upd_value(\"VrVoltageLimit[4]\", 1,\n\t\toriginal->VrVoltageLimit[4],\n\t\tparams->VrVoltageLimit[4]);\n\tfsp_display_upd_value(\"VrConfigEnable[0]\", 1,\n\t\toriginal->VrConfigEnable[0],\n\t\tparams->VrConfigEnable[0]);\n\tfsp_display_upd_value(\"VrConfigEnable[1]\", 1,\n\t\toriginal->VrConfigEnable[1],\n\t\tparams->VrConfigEnable[1]);\n\tfsp_display_upd_value(\"VrConfigEnable[2]\", 1,\n\t\toriginal->VrConfigEnable[2],\n\t\tparams->VrConfigEnable[2]);\n\tfsp_display_upd_value(\"VrConfigEnable[3]\", 1,\n\t\toriginal->VrConfigEnable[3],\n\t\tparams->VrConfigEnable[3]);\n\tfsp_display_upd_value(\"VrConfigEnable[4]\", 1,\n\t\toriginal->VrConfigEnable[4],\n\t\tparams->VrConfigEnable[4]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[0]\", 1,\n\t\toriginal->SerialIoI2cVoltage[0],\n\t\tparams->SerialIoI2cVoltage[0]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[1]\", 1,\n\t\toriginal->SerialIoI2cVoltage[1],\n\t\tparams->SerialIoI2cVoltage[1]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[2]\", 1,\n\t\toriginal->SerialIoI2cVoltage[2],\n\t\tparams->SerialIoI2cVoltage[2]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[3]\", 1,\n\t\toriginal->SerialIoI2cVoltage[3],\n\t\tparams->SerialIoI2cVoltage[3]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[4]\", 1,\n\t\toriginal->SerialIoI2cVoltage[4],\n\t\tparams->SerialIoI2cVoltage[4]);\n\tfsp_display_upd_value(\"SerialIoI2cVoltage[5]\", 1,\n\t\toriginal->SerialIoI2cVoltage[5],\n\t\tparams->SerialIoI2cVoltage[5]);\n\tfsp_display_upd_value(\"SendVrMbxCmd\", 1,\n\t\toriginal->SendVrMbxCmd,\n\t\tparams->SendVrMbxCmd);\n\tfsp_display_upd_value(\"AcousticNoiseMitigation\", 1,\n\t\toriginal->AcousticNoiseMitigation,\n\t\tparams->AcousticNoiseMitigation);\n\tfsp_display_upd_value(\"SlowSlewRateForIa\", 1,\n\t\toriginal->SlowSlewRateForIa,\n\t\tparams->SlowSlewRateForIa);\n\tfsp_display_upd_value(\"SlowSlewRateForGt\", 1,\n\t\toriginal->SlowSlewRateForGt,\n\t\tparams->SlowSlewRateForGt);\n\tfsp_display_upd_value(\"SlowSlewRateForSa\", 1,\n\t\toriginal->SlowSlewRateForSa,\n\t\tparams->SlowSlewRateForSa);\n\tfsp_display_upd_value(\"FastPkgCRampDisable\", 1,\n\t\toriginal->FastPkgCRampDisable,\n\t\tparams->FastPkgCRampDisable);\n"]], "pred": {"ppl": 1.3488832712173462, "ppl_lower": 1.4839831590652466, "ppl/lowercase_ppl": -1.3189444521593756, "ppl/zlib": 0.00010172571163173767, "Min_5.0% Prob": 5.050684587628234, "Min_10.0% Prob": 2.9246779791280333, "Min_20.0% Prob": 1.4965046447765666, "Min_30.0% Prob": 0.9997364321397921, "Min_40.0% Prob": 0.748339590034163, "Min_50.0% Prob": 0.5990729852121163, "Min_60.0% Prob": 0.4994239866029979}}
{"hexsha": "daa57062031a5c79bb2b842ccb6a86febd5757ba", "ext": "c", "lang": "C", "content": "int aliyun_log_env_init(const char *json, void **context)\n{\n\tif (log_producer_env_init() != LOG_PRODUCER_OK)\n\t\treturn -1;\n\n\taliyun_env_t *aliyun_env =\n\t    (aliyun_env_t *) malloc(sizeof(aliyun_env_t));\n\tif (!aliyun_env)\n\t\treturn -2;\n\tmemset(aliyun_env, 0, sizeof(aliyun_env));\n\n\tstruct json_object *root_obj = json_tokener_parse(json);\n\tif (!root_obj)\n\t\treturn -3;\n\n\tstruct json_object *config_obj;\n\tjson_bool ret =\n\t    json_object_object_get_ex(root_obj, \"logstore_config\", &config_obj);\n\tif (ret == false) {\n\t\tjson_object_put(root_obj);\n\t\treturn -4;\n\t}\n\n\tconst char *config = json_object_get_string(config_obj);\n\tmemcpy(aliyun_env->config, config, strlen(config) + 1);\n\n\tjson_object_put(root_obj);\n\n\taliyun_env->producer =\n\t    create_log_producer_by_config_file(aliyun_env->config, NULL);\n\tif (!aliyun_env->producer)\n\t\treturn -5;\n\n\t*context = (void *)aliyun_env;\n\n\treturn 0;\n}", "item_id": 2, "repo": "geekerlw/aliyun-log-c-agent", "file": "plugins/logagent-plugin-aliyun.c", "last_update_at": "2019-12-16T09:14:37+00:00", "question_id": "daa57062031a5c79bb2b842ccb6a86febd5757ba_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int aliyun_log_env_init(const char *json, void **context)\n{\n\tif (log_producer_env_init() != LOG_PRODUCER_OK)\n\t\treturn -1;\n\taliyun_env_t *aliyun_env =\n\t    (aliyun_env_t *) malloc(sizeof(aliyun_env_t));\n\tif (!aliyun_env)\n\t\treturn -2;\n\tmemset(aliyun_env, 0, sizeof(aliyun_env));\n\tstruct json_object *root_obj = json_tokener_parse(json);\n\tif (!root_obj)\n\t\treturn -3;\n\tstruct json_object *config_obj;\n\tjson_bool ret =\n\t    json_object_object_get_ex(root_obj, \"logstore_config\", &config_obj);\n\tif (ret == false) {\n\t\tjson_object_put(root_obj);\n\t\treturn -4;\n\t}\n\tconst char *config = json_object_get_string(config_obj);\n\tmemcpy(aliyun_env->config, config, strlen(config) + 1);\n\tjson_object_put(root_obj);\n\taliyun_env->producer =\n\t    create_log_producer_by_config_file(aliyun_env->config, NULL);\n\tif (!aliyun_env->producer)\n\t\treturn -5;\n\t*context = (void *)aliyun_env;\n\treturn 0;\n"]], "pred": {"ppl": 1.790992259979248, "ppl_lower": 1.8613618612289429, "ppl/lowercase_ppl": -1.066130059794655, "ppl/zlib": 0.0014828748128488793, "Min_5.0% Prob": 5.265304803848267, "Min_10.0% Prob": 3.941022791360554, "Min_20.0% Prob": 2.6251733922339104, "Min_30.0% Prob": 1.9001589623482331, "Min_40.0% Prob": 1.4522987013900435, "Min_50.0% Prob": 1.1638355026639264, "Min_60.0% Prob": 0.9734280269363194}}
{"hexsha": "6801118186ac462869a62cbd51992e030c001343", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[]) {\n  int e = hpx_init(&argc, &argv);\n  if (e) {\n    fprintf(stderr, \"HPX: failed to initialize.\\n\");\n    return e;\n  }\n\n  // run the main action\n  e = hpx_run(&thread_create, &e, sizeof(e));\n  hpx_finalize();\n  return e;\n}", "item_id": 2, "repo": "dkogler/hpx5-measurement-tests", "file": "tests/perf/my_thread_create.c", "last_update_at": "2019-11-05T21:12:04+00:00", "question_id": "6801118186ac462869a62cbd51992e030c001343_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[]) {\n  int e = hpx_init(&argc, &argv);\n  if (e) {\n    fprintf(stderr, \"HPX: failed to initialize.\\n\");\n    return e;\n  }\n  // run the main action\n  e = hpx_run(&thread_create, &e, sizeof(e));\n  hpx_finalize();\n  return e;\n"]], "pred": {"ppl": 2.497283697128296, "ppl_lower": 2.917374610900879, "ppl/lowercase_ppl": -1.1698862226387028, "ppl/zlib": 0.005200020568371961, "Min_5.0% Prob": 7.751470470428467, "Min_10.0% Prob": 6.5338099002838135, "Min_20.0% Prob": 4.2221014380455015, "Min_30.0% Prob": 2.962596606823706, "Min_40.0% Prob": 2.2985797895164026, "Min_50.0% Prob": 1.8260852357444282, "Min_60.0% Prob": 1.5338035613869228}}
{"hexsha": "9a4ed7474e1e4b8fd22ff12127f6b367b87e1a94", "ext": "c", "lang": "C", "content": "static int acpi_video_switch_output(struct acpi_video_bus *video, int event)\n{\n\tstruct list_head *node, *next;\n\tstruct acpi_video_device *dev = NULL;\n\tstruct acpi_video_device *dev_next = NULL;\n\tstruct acpi_video_device *dev_prev = NULL;\n\tunsigned long state;\n\tint status = 0;\n\n\n\tlist_for_each_safe(node, next, &video->video_device_list) {\n\t\tdev = container_of(node, struct acpi_video_device, entry);\n\t\tstatus = acpi_video_device_get_state(dev, &state);\n\t\tif (state & 0x2) {\n\t\t\tdev_next =\n\t\t\t    container_of(node->next, struct acpi_video_device,\n\t\t\t\t\t entry);\n\t\t\tdev_prev =\n\t\t\t    container_of(node->prev, struct acpi_video_device,\n\t\t\t\t\t entry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev_next = container_of(node->next, struct acpi_video_device, entry);\n\tdev_prev = container_of(node->prev, struct acpi_video_device, entry);\n      out:\n\tswitch (event) {\n\tcase ACPI_VIDEO_NOTIFY_CYCLE:\n\tcase ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:\n\t\tacpi_video_device_set_state(dev, 0);\n\t\tacpi_video_device_set_state(dev_next, 0x80000001);\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_PREV_OUTPUT:\n\t\tacpi_video_device_set_state(dev, 0);\n\t\tacpi_video_device_set_state(dev_prev, 0x80000001);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}", "item_id": 38, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/drivers/acpi/video.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "9a4ed7474e1e4b8fd22ff12127f6b367b87e1a94_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int acpi_video_switch_output(struct acpi_video_bus *video, int event)\n{\n\tstruct list_head *node, *next;\n\tstruct acpi_video_device *dev = NULL;\n\tstruct acpi_video_device *dev_next = NULL;\n\tstruct acpi_video_device *dev_prev = NULL;\n\tunsigned long state;\n\tint status = 0;\n\tlist_for_each_safe(node, next, &video->video_device_list) {\n\t\tdev = container_of(node, struct acpi_video_device, entry);\n\t\tstatus = acpi_video_device_get_state(dev, &state);\n\t\tif (state & 0x2) {\n\t\t\tdev_next =\n\t\t\t    container_of(node->next, struct acpi_video_device,\n\t\t\t\t\t entry);\n\t\t\tdev_prev =\n\t\t\t    container_of(node->prev, struct acpi_video_device,\n\t\t\t\t\t entry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev_next = container_of(node->next, struct acpi_video_device, entry);\n\tdev_prev = container_of(node->prev, struct acpi_video_device, entry);\n      out:\n\tswitch (event) {\n\tcase ACPI_VIDEO_NOTIFY_CYCLE:\n\tcase ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:\n\t\tacpi_video_device_set_state(dev, 0);\n\t\tacpi_video_device_set_state(dev_next, 0x80000001);\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_PREV_OUTPUT:\n\t\tacpi_video_device_set_state(dev, 0);\n\t\tacpi_video_device_set_state(dev_prev, 0x80000001);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn status;\n"]], "pred": {"ppl": 1.4644453525543213, "ppl_lower": 1.5860869884490967, "ppl/lowercase_ppl": -1.2091698506613988, "ppl/zlib": 0.0009304306630325079, "Min_5.0% Prob": 4.366885471343994, "Min_10.0% Prob": 3.097134952545166, "Min_20.0% Prob": 1.8409441700666258, "Min_30.0% Prob": 1.2642873623163293, "Min_40.0% Prob": 0.9527473342398485, "Min_50.0% Prob": 0.7625585470548427, "Min_60.0% Prob": 0.6373853429783929}}
{"hexsha": "96627d0ce30ec31ab646f8c050d47752d478ec44", "ext": "h", "lang": "C", "content": "NK_API int\nnk_window_is_any_hovered(struct nk_context *ctx)\n{\n    struct nk_window *iter;\n    NK_ASSERT(ctx);\n    if (!ctx) return 0;\n    iter = ctx->begin;\n    while (iter) {\n        /* check if window is being hovered */\n        if (iter->flags & NK_WINDOW_MINIMIZED) {\n            struct nk_rect header = iter->bounds;\n            header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;\n            if (nk_input_is_mouse_hovering_rect(&ctx->input, header))\n                return 1;\n        } else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {\n            return 1;\n        }\n        /* check if window popup is being hovered */\n        if (iter->popup.active && iter->popup.win && nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))\n            return 1;\n        iter = iter->next;\n    }\n    return 0;\n}", "item_id": 386, "repo": "coderobe/nuklear-vita", "file": "nuklear.h", "last_update_at": "2019-03-04T09:58:59+00:00", "question_id": "96627d0ce30ec31ab646f8c050d47752d478ec44_386", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NK_API int\nnk_window_is_any_hovered(struct nk_context *ctx)\n{\n    struct nk_window *iter;\n    NK_ASSERT(ctx);\n    if (!ctx) return 0;\n    iter = ctx->begin;\n    while (iter) {\n        /* check if window is being hovered */\n        if (iter->flags & NK_WINDOW_MINIMIZED) {\n            struct nk_rect header = iter->bounds;\n            header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;\n            if (nk_input_is_mouse_hovering_rect(&ctx->input, header))\n                return 1;\n        } else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {\n            return 1;\n        }\n        /* check if window popup is being hovered */\n        if (iter->popup.active && iter->popup.win && nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))\n            return 1;\n        iter = iter->next;\n    }\n    return 0;\n"]], "pred": {"ppl": 1.5080313682556152, "ppl_lower": 1.6785800457000732, "ppl/lowercase_ppl": -1.2608126388844842, "ppl/zlib": 0.0011475001972065246, "Min_5.0% Prob": 4.764928562300546, "Min_10.0% Prob": 3.3170545430018983, "Min_20.0% Prob": 1.9595293731525028, "Min_30.0% Prob": 1.3431774385442787, "Min_40.0% Prob": 1.0253415524513803, "Min_50.0% Prob": 0.8197437704914585, "Min_60.0% Prob": 0.6856649278647224}}
{"hexsha": "2d18b4f4f5712ed7ccc8ba89525934e8ef7d3510", "ext": "c", "lang": "C", "content": "static GFraMe_ret ps_init(playstateCmd cmd) {\n    GFraMe_ret rv;\n    int map, plX, plY, time;\n    \n    // Read the desired fps (for update and drawing)\n    _maxUfps = read_slot(BLK_CONFIG, sv_ufps);\n    if (_maxUfps == -1)\n        _maxUfps = GAME_UFPS;\n    _maxDfps = read_slot(BLK_CONFIG, sv_dfps);\n    if (_maxDfps == -1)\n        _maxDfps = GAME_DFPS;\n    _ps_isSpeedrun = read_slot(BLK_CONFIG, sv_speedrun);\n    if (_ps_isSpeedrun == -1)\n        _ps_isSpeedrun = 0;\n    \n    if (cmd != CONTINUE) {\n        gv_init();\n        \n        plX = 16;\n        plY = 184;\n        if (cmd == MT_VERSION) {\n            map = 21;\n        }\n        else /* if (cmd == NEWGAME) */ {\n            map = 0;\n        }\n        gv_setValue(DOOR_X, 16 / 8);\n        gv_setValue(DOOR_Y, 184 / 8);\n        gv_setValue(MAP, map);\n    }\n    else {\n        rv = gv_load(SAVEFILE);\n        GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to load state\", __ret);\n        \n        plX = gv_getValue(DOOR_X) * 8;\n        plY = gv_getValue(DOOR_Y) * 8;\n        map = gv_getValue(MAP);\n    }\n    time = gv_getValue(GAME_TIME);\n    timer_init(time);\n    \n    if ((map % 21) >= 20) {\n        audio_playBoss();\n    }\n    else if ((map % 21) >= 15) {\n        audio_playTensionGoesUp();\n    }\n    else if ((map % 21) >= 4) {\n        audio_playMovingOn();\n    }\n    else {\n        audio_playIntro();\n    }\n\n    rv = ui_init();\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init ui\", __ret);\n    \n    rv = rg_init();\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to registry ui\", __ret);\n    \n    rv = map_init(&m);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init map\", __ret);\n    \n    rv = player_init(&p1, ID_PL1, 224, plX, plY);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init player\", __ret);\n    \n    rv = player_init(&p2, ID_PL2, 240, plX, plY);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init player\", __ret);\n    \n    rv = map_loadi(m, map);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init map\", __ret);\n\n    signal_init();\n    \n    _timerTilCredits = 0;\n    _ps_onOptions = 0;\n    _ps_text = 0;\n    switchState = 0;\n    transition_initFadeOut();\n    \n#ifdef DEBUG\n    _updCalls = 0;\n    _drwCalls = 0;\n    _time = 0;\n    _ltime = 0;\n#endif\n    \n    rv = GFraMe_ret_ok;\n__ret:\n    return rv;\n}", "item_id": 3, "repo": "SirGFM/big-15", "file": "src/playstate.c", "last_update_at": "2019-10-14T00:16:52+00:00", "question_id": "2d18b4f4f5712ed7ccc8ba89525934e8ef7d3510_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static GFraMe_ret ps_init(playstateCmd cmd) {\n    GFraMe_ret rv;\n    int map, plX, plY, time;\n    // Read the desired fps (for update and drawing)\n    _maxUfps = read_slot(BLK_CONFIG, sv_ufps);\n    if (_maxUfps == -1)\n        _maxUfps = GAME_UFPS;\n    _maxDfps = read_slot(BLK_CONFIG, sv_dfps);\n    if (_maxDfps == -1)\n        _maxDfps = GAME_DFPS;\n    _ps_isSpeedrun = read_slot(BLK_CONFIG, sv_speedrun);\n    if (_ps_isSpeedrun == -1)\n        _ps_isSpeedrun = 0;\n    if (cmd != CONTINUE) {\n        gv_init();\n        plX = 16;\n        plY = 184;\n        if (cmd == MT_VERSION) {\n            map = 21;\n        }\n        else /* if (cmd == NEWGAME) */ {\n            map = 0;\n        }\n        gv_setValue(DOOR_X, 16 / 8);\n        gv_setValue(DOOR_Y, 184 / 8);\n        gv_setValue(MAP, map);\n    }\n    else {\n        rv = gv_load(SAVEFILE);\n        GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to load state\", __ret);\n        plX = gv_getValue(DOOR_X) * 8;\n        plY = gv_getValue(DOOR_Y) * 8;\n        map = gv_getValue(MAP);\n    }\n    time = gv_getValue(GAME_TIME);\n    timer_init(time);\n    if ((map % 21) >= 20) {\n        audio_playBoss();\n    }\n    else if ((map % 21) >= 15) {\n        audio_playTensionGoesUp();\n    }\n    else if ((map % 21) >= 4) {\n        audio_playMovingOn();\n    }\n    else {\n        audio_playIntro();\n    }\n    rv = ui_init();\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init ui\", __ret);\n    rv = rg_init();\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to registry ui\", __ret);\n    rv = map_init(&m);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init map\", __ret);\n    rv = player_init(&p1, ID_PL1, 224, plX, plY);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init player\", __ret);\n    rv = player_init(&p2, ID_PL2, 240, plX, plY);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init player\", __ret);\n    rv = map_loadi(m, map);\n    GFraMe_assertRet(rv == GFraMe_ret_ok, \"Failed to init map\", __ret);\n    signal_init();\n    _timerTilCredits = 0;\n    _ps_onOptions = 0;\n    _ps_text = 0;\n    switchState = 0;\n    transition_initFadeOut();\n#ifdef DEBUG\n    _updCalls = 0;\n    _drwCalls = 0;\n    _time = 0;\n    _ltime = 0;\n#endif\n    rv = GFraMe_ret_ok;\n__ret:\n    return rv;\n"]], "pred": {"ppl": 2.4219155311584473, "ppl_lower": 2.7899436950683594, "ppl/lowercase_ppl": -1.1599245304711217, "ppl/zlib": 0.0012002154258692094, "Min_5.0% Prob": 8.290995798110963, "Min_10.0% Prob": 6.236287727355957, "Min_20.0% Prob": 4.058946787714958, "Min_30.0% Prob": 2.8715212613443204, "Min_40.0% Prob": 2.2002434230913543, "Min_50.0% Prob": 1.766044606955581, "Min_60.0% Prob": 1.4744984154694674}}
{"hexsha": "c759ea85bbf6abbe596ab60aceccc48c68b09d8e", "ext": "c", "lang": "C", "content": "static void restoreCallerRegs(void) {\n    Temp_tempList regs = F_callerSaveRegs();\n    int offset = -4;\n    for (; regs; regs = regs->tail) {\n        Temp_temp reg = regs->head;\n        char buf[64];\n        sprintf(buf, \"movl %d(`s0), `d0\", offset);\n        emit(AS_Oper(buf, Temp_TempList(reg, NULL), Temp_TempList(F_FP(), NULL), NULL));\n        offset -= F_wordSize;\n    }\n}", "item_id": 4, "repo": "vinx13/SE302", "file": "lab6/codegen.c", "last_update_at": "2019-07-21T10:01:03+00:00", "question_id": "c759ea85bbf6abbe596ab60aceccc48c68b09d8e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void restoreCallerRegs(void) {\n    Temp_tempList regs = F_callerSaveRegs();\n    int offset = -4;\n    for (; regs; regs = regs->tail) {\n        Temp_temp reg = regs->head;\n        char buf[64];\n        sprintf(buf, \"movl %d(`s0), `d0\", offset);\n        emit(AS_Oper(buf, Temp_TempList(reg, NULL), Temp_TempList(F_FP(), NULL), NULL));\n        offset -= F_wordSize;\n    }\n"]], "pred": {"ppl": 4.355837345123291, "ppl_lower": 5.652129650115967, "ppl/lowercase_ppl": -1.177038772570305, "ppl/zlib": 0.006370202874250618, "Min_5.0% Prob": 9.306035041809082, "Min_10.0% Prob": 7.168417930603027, "Min_20.0% Prob": 5.201761433056423, "Min_30.0% Prob": 4.194145089104062, "Min_40.0% Prob": 3.449883479092802, "Min_50.0% Prob": 2.8783716252871923, "Min_60.0% Prob": 2.444770819729283}}
{"hexsha": "aa97930c13056e7e125fa6663c952dc3e2f4d020", "ext": "c", "lang": "C", "content": "int\nikev2_validate_cp(struct iked_message *msg, size_t offset, size_t left,\n    struct ikev2_payload *pld, struct ikev2_cp *cp)\n{\n\tuint8_t\t\t*msgbuf = ibuf_data(msg->msg_data);\n\tsize_t\t\t pld_length;\n\n\tpld_length = betoh16(pld->pld_length);\n\tif (pld_length < sizeof(*pld) + sizeof(*cp)) {\n\t\tlog_debug(\"%s: malformed payload: specified length smaller \"\n\t\t    \"than minimum size (%zu < %zu)\", __func__, pld_length,\n\t\t    sizeof(*pld) + sizeof(*cp));\n\t\treturn (-1);\n\t}\n\n\t/* This will actually be caught by earlier checks. */\n\tif (left < sizeof(*cp)) {\n\t\tlog_debug(\"%s: malformed payload: too short for header \"\n\t\t    \"(%zu < %zu)\", __func__, left, sizeof(*cp));\n\t\treturn (-1);\n\t}\n\tmemcpy(cp, msgbuf + offset, sizeof(*cp));\n\n\treturn (0);\n}", "item_id": 28, "repo": "ArrogantWombatics/openbsd-src", "file": "sbin/iked/ikev2_pld.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "aa97930c13056e7e125fa6663c952dc3e2f4d020_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nikev2_validate_cp(struct iked_message *msg, size_t offset, size_t left,\n    struct ikev2_payload *pld, struct ikev2_cp *cp)\n{\n\tuint8_t\t\t*msgbuf = ibuf_data(msg->msg_data);\n\tsize_t\t\t pld_length;\n\tpld_length = betoh16(pld->pld_length);\n\tif (pld_length < sizeof(*pld) + sizeof(*cp)) {\n\t\tlog_debug(\"%s: malformed payload: specified length smaller \"\n\t\t    \"than minimum size (%zu < %zu)\", __func__, pld_length,\n\t\t    sizeof(*pld) + sizeof(*cp));\n\t\treturn (-1);\n\t}\n\t/* This will actually be caught by earlier checks. */\n\tif (left < sizeof(*cp)) {\n\t\tlog_debug(\"%s: malformed payload: too short for header \"\n\t\t    \"(%zu < %zu)\", __func__, left, sizeof(*cp));\n\t\treturn (-1);\n\t}\n\tmemcpy(cp, msgbuf + offset, sizeof(*cp));\n\treturn (0);\n"]], "pred": {"ppl": 2.1689157485961914, "ppl_lower": 2.205839157104492, "ppl/lowercase_ppl": -1.021803179823485, "ppl/zlib": 0.0021038787708108795, "Min_5.0% Prob": 7.1840843132564, "Min_10.0% Prob": 5.094393557515637, "Min_20.0% Prob": 3.3667157539005936, "Min_30.0% Prob": 2.4890715181827545, "Min_40.0% Prob": 1.914976322561757, "Min_50.0% Prob": 1.5486570906710544, "Min_60.0% Prob": 1.2951590039208531}}
{"hexsha": "fb42b21ad6454defdd361fad36d3237fa498d9a1", "ext": "c", "lang": "C", "content": "bool\nisUsedInOrderBy (Query *query, TargetEntry *te)\n{\n\tGroupClause *groupClause;\n\t\tListCell *lc;\n\n\t\tforeach(lc, query->sortClause)\n\t\t{\n\t\t\tgroupClause = (GroupClause *) lfirst(lc);\n\n\t\t\tif (groupClause->tleSortGroupRef == te->ressortgroupref)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n}", "item_id": 21, "repo": "IITDBGroup/perm", "file": "src/backend/provrewrite/util/prov_util.c", "last_update_at": "2019-03-06T10:43:44+00:00", "question_id": "fb42b21ad6454defdd361fad36d3237fa498d9a1_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\nisUsedInOrderBy (Query *query, TargetEntry *te)\n{\n\tGroupClause *groupClause;\n\t\tListCell *lc;\n\t\tforeach(lc, query->sortClause)\n\t\t{\n\t\t\tgroupClause = (GroupClause *) lfirst(lc);\n\t\t\tif (groupClause->tleSortGroupRef == te->ressortgroupref)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n"]], "pred": {"ppl": 2.7982585430145264, "ppl_lower": 3.724689483642578, "ppl/lowercase_ppl": -1.2779270854320617, "ppl/zlib": 0.005415775130354271, "Min_5.0% Prob": 10.08516518274943, "Min_10.0% Prob": 7.674178679784139, "Min_20.0% Prob": 4.728122939666112, "Min_30.0% Prob": 3.3465424411826663, "Min_40.0% Prob": 2.560439226217568, "Min_50.0% Prob": 2.066205573019882, "Min_60.0% Prob": 1.726366834404568}}
{"hexsha": "9fd18d8a38868c29af78a64547f4778536c67e87", "ext": "c", "lang": "C", "content": "int seek(int pos)\n{\n\tfseek(fp, pos + firstFrame, SEEK_SET);\n\tdataLeft = 0;\n\n\tint ret = fread(readBuf, 1, READ_BUF_SIZE, fp);\n\tdataLeft += ret;\n\treadOff = readBuf;\n\n\tfindValidSync(&readOff, &dataLeft);\n\treturn 1;\n}", "item_id": 4, "repo": "fincs/FeOSMusic", "file": "codecs/mp3/source/mp3.c", "last_update_at": "2019-04-27T20:16:58+00:00", "question_id": "9fd18d8a38868c29af78a64547f4778536c67e87_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int seek(int pos)\n{\n\tfseek(fp, pos + firstFrame, SEEK_SET);\n\tdataLeft = 0;\n\tint ret = fread(readBuf, 1, READ_BUF_SIZE, fp);\n\tdataLeft += ret;\n\treadOff = readBuf;\n\tfindValidSync(&readOff, &dataLeft);\n\treturn 1;\n"]], "pred": {"ppl": 4.25907039642334, "ppl_lower": 5.243419647216797, "ppl/lowercase_ppl": -1.1434890709646874, "ppl/zlib": 0.008782126785857549, "Min_5.0% Prob": 8.397695446014405, "Min_10.0% Prob": 7.065239763259887, "Min_20.0% Prob": 5.321927988529206, "Min_30.0% Prob": 4.156881713867188, "Min_40.0% Prob": 3.3995038002729414, "Min_50.0% Prob": 2.817635387778282, "Min_60.0% Prob": 2.39003717576464}}
{"hexsha": "370e1a8df4f2f5155b9143133a753afa4c322b08", "ext": "c", "lang": "C", "content": "void avc_style_luma_interpolation_filter_posq_c(EbByte ref_pic, uint32_t src_stride, EbByte dst,\n                                                uint32_t dst_stride, uint32_t pu_width,\n                                                uint32_t pu_height, EbByte temp_buf,\n                                                uint32_t frac_pos) {\n    uint32_t temp_buf_size = pu_width * pu_height;\n    (void)frac_pos;\n    avc_style_luma_interpolation_filter_horizontal_c(\n        ref_pic + src_stride, src_stride, temp_buf, pu_width, pu_width, pu_height, 0, 2);\n    avc_style_luma_interpolation_filter_posj_c(ref_pic,\n                                               src_stride,\n                                               temp_buf + temp_buf_size,\n                                               pu_width,\n                                               pu_width,\n                                               pu_height,\n                                               temp_buf + 2 * temp_buf_size,\n                                               2);\n    picture_average_kernel_c(temp_buf,\n                             pu_width,\n                             temp_buf + temp_buf_size,\n                             pu_width,\n                             dst,\n                             dst_stride,\n                             pu_width,\n                             pu_height);\n}", "item_id": 10, "repo": "nasirhemed/SVT-AV1", "file": "Source/Lib/Common/Codec/EbAvcStyleMcp.c", "last_update_at": "2019-08-01T06:11:30+00:00", "question_id": "370e1a8df4f2f5155b9143133a753afa4c322b08_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void avc_style_luma_interpolation_filter_posq_c(EbByte ref_pic, uint32_t src_stride, EbByte dst,\n                                                uint32_t dst_stride, uint32_t pu_width,\n                                                uint32_t pu_height, EbByte temp_buf,\n                                                uint32_t frac_pos) {\n    uint32_t temp_buf_size = pu_width * pu_height;\n    (void)frac_pos;\n    avc_style_luma_interpolation_filter_horizontal_c(\n        ref_pic + src_stride, src_stride, temp_buf, pu_width, pu_width, pu_height, 0, 2);\n    avc_style_luma_interpolation_filter_posj_c(ref_pic,\n                                               src_stride,\n                                               temp_buf + temp_buf_size,\n                                               pu_width,\n                                               pu_width,\n                                               pu_height,\n                                               temp_buf + 2 * temp_buf_size,\n                                               2);\n    picture_average_kernel_c(temp_buf,\n                             pu_width,\n                             temp_buf + temp_buf_size,\n                             pu_width,\n                             dst,\n                             dst_stride,\n                             pu_width,\n                             pu_height);\n"]], "pred": {"ppl": 1.6963452100753784, "ppl_lower": 1.8909424543380737, "ppl/lowercase_ppl": -1.2054952072411256, "ppl/zlib": 0.0018608311983592538, "Min_5.0% Prob": 6.055740819257848, "Min_10.0% Prob": 4.147109402929034, "Min_20.0% Prob": 2.4891645201614927, "Min_30.0% Prob": 1.7447910640211333, "Min_40.0% Prob": 1.324721462452518, "Min_50.0% Prob": 1.0562113649158908, "Min_60.0% Prob": 0.8814891322849151}}
{"hexsha": "e24c79949eca73d29063e6df033dd14ae4208fab", "ext": "c", "lang": "C", "content": "void print_msg(const char *fmt, ...)\r\n{\r\n\tva_list ap;\r\n\tFILE *fp;\r\n\tchar buf[1024] = {0};\r\n\tstruct stat statbuff;\r\n\r\n\tchar buffer[1024] = {0};\r\n\t\r\n\t//sprintf_s(buffer,\"[%s,%d]\",file_name,file_line);\r\n\tsprintf(buffer, \"[%02d:%02d:%02d %s,%d]\", (ptimes->tm_hour) + 8, ptimes->tm_min, ptimes->tm_sec, file_name, file_line);\r\n\r\n\tva_start(ap, fmt);\r\n\tvsprintf(buf, fmt, ap);\r\n\tfp = fopen(LOG_FILE_NAME, \"a+\");\r\n\r\n\tif(fp == NULL)\r\n\t\treturn;\r\n\r\n\tint fd = fileno(fp);\r\n\tfstat(fd, &statbuff);\r\n\t\r\n\tif(statbuff.st_size > MAX_LOG_SIZE)\r\n\t{\r\n\t\tfclose(fp);\r\n\t\tsystem(\"rm -rf \" LOG_FILE_NAME);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(buffer != NULL)\r\n\t\t{\r\n\t\t\tstrcat(buffer, buf);\r\n\r\n\t\t\tif(buffer[strnlen(buffer,1024) - 1] != '\\n') //\u5224\u65ad\u7ed3\u5c3e\u662f\u5426\u6362\u884c\uff0c\u6ca1\u6709\"\\n\"\u5219\u81ea\u52a8\u8865\u4e0a\r\n\t\t\t\tstrcat(buffer, \"\\n\");\r\n\r\n\t\t\tfputs(buffer, stdout);\r\n\t\t\tfputs(buffer, fp);\r\n\t\t}\r\n\r\n\t\t//fsync(fd);\r\n\t\tfclose(fp);\r\n\t}\r\n\r\n\tva_end(ap);\r\n\treturn;\r\n}", "item_id": 20, "repo": "Zerone216/bsdiff-modify", "file": "src/common.c", "last_update_at": "2019-12-09T01:27:27+00:00", "question_id": "e24c79949eca73d29063e6df033dd14ae4208fab_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void print_msg(const char *fmt, ...)\r\n{\r\n\tva_list ap;\r\n\tFILE *fp;\r\n\tchar buf[1024] = {0};\r\n\tstruct stat statbuff;\r\n\r\n\tchar buffer[1024] = {0};\r\n\t\r\n\t//sprintf_s(buffer,\"[%s,%d]\",file_name,file_line);\r\n\tsprintf(buffer, \"[%02d:%02d:%02d %s,%d]\", (ptimes->tm_hour) + 8, ptimes->tm_min, ptimes->tm_sec, file_name, file_line);\r\n\r\n\tva_start(ap, fmt);\r\n\tvsprintf(buf, fmt, ap);\r\n\tfp = fopen(LOG_FILE_NAME, \"a+\");\r\n\r\n\tif(fp == NULL)\r\n\t\treturn;\r\n\r\n\tint fd = fileno(fp);\r\n\tfstat(fd, &statbuff);\r\n\t\r\n\tif(statbuff.st_size > MAX_LOG_SIZE)\r\n\t{\r\n\t\tfclose(fp);\r\n\t\tsystem(\"rm -rf \" LOG_FILE_NAME);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(buffer != NULL)\r\n\t\t{\r\n\t\t\tstrcat(buffer, buf);\r\n\r\n\t\t\tif(buffer[strnlen(buffer,1024) - 1] != '\\n') //\u5224\u65ad\u7ed3\u5c3e\u662f\u5426\u6362\u884c\uff0c\u6ca1\u6709\"\\n\"\u5219\u81ea\u52a8\u8865\u4e0a\r\n\t\t\t\tstrcat(buffer, \"\\n\");\r\n\r\n\t\t\tfputs(buffer, stdout);\r\n\t\t\tfputs(buffer, fp);\r\n\t\t}\r\n\r\n\t\t//fsync(fd);\r\n\t\tfclose(fp);\r\n\t}\r\n\r\n\tva_end(ap);\r\n\treturn;\r\n"]], "pred": {"ppl": 2.1794509887695312, "ppl_lower": 2.266148805618286, "ppl/lowercase_ppl": -1.050070820035733, "ppl/zlib": 0.001492477021206896, "Min_5.0% Prob": 6.269130099903453, "Min_10.0% Prob": 4.97290114922957, "Min_20.0% Prob": 3.3421945652265226, "Min_30.0% Prob": 2.444317565480275, "Min_40.0% Prob": 1.909361970140023, "Min_50.0% Prob": 1.5472506504221881, "Min_60.0% Prob": 1.2958770866241696}}
{"hexsha": "8a7cb69dce5c6f914f3f443afe876e92d6669d0d", "ext": "c", "lang": "C", "content": "void decompress(uint8_t* source, uint8_t* decomp, int32_t decompSize)\n{\n    uint32_t srcPlace = 0, dstPlace = 0;\n    uint32_t i, dist, copyPlace, numBytes;\n    uint8_t codeByte, byte1, byte2;\n    uint8_t bitCount = 0;\n\n    source += 0x10;\n    while(dstPlace < decompSize)\n    {\n        /* If there are no more bits to test, get a new byte */\n        if(!bitCount)\n        {\n            codeByte = source[srcPlace++];\n            bitCount = 8;\n        }\n\n        /* If bit 7 is a 1, just copy 1 byte from source to destination */\n        /* Else do some decoding */\n        if(codeByte & 0x80)\n        {\n            decomp[dstPlace++] = source[srcPlace++];\n        }\n        else\n        {\n            /* Get 2 bytes from source */\n            byte1 = source[srcPlace++];\n            byte2 = source[srcPlace++];\n\n            /* Calculate distance to move in destination */\n            /* And the number of bytes to copy */\n            dist = ((byte1 & 0xF) << 8) | byte2;\n            copyPlace = dstPlace - (dist + 1);\n            numBytes = byte1 >> 4;\n\n            /* Do more calculations on the number of bytes to copy */\n            if(!numBytes)\n                numBytes = source[srcPlace++] + 0x12;\n            else\n                numBytes += 2;\n\n            /* Copy data from a previous point in destination */\n            /* to current point in destination */\n            for(i = 0; i < numBytes; i++)\n                decomp[dstPlace++] = decomp[copyPlace++];\n        }\n\n        /* Set up for the next read cycle */\n        codeByte = codeByte << 1;\n        bitCount--;\n    }\n}", "item_id": 5, "repo": "Triaphlax/OoT-Randomizer", "file": "Decompress/src/decompressor.c", "last_update_at": "2019-10-09T23:07:52+00:00", "question_id": "8a7cb69dce5c6f914f3f443afe876e92d6669d0d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void decompress(uint8_t* source, uint8_t* decomp, int32_t decompSize)\n{\n    uint32_t srcPlace = 0, dstPlace = 0;\n    uint32_t i, dist, copyPlace, numBytes;\n    uint8_t codeByte, byte1, byte2;\n    uint8_t bitCount = 0;\n    source += 0x10;\n    while(dstPlace < decompSize)\n    {\n        /* If there are no more bits to test, get a new byte */\n        if(!bitCount)\n        {\n            codeByte = source[srcPlace++];\n            bitCount = 8;\n        }\n        /* If bit 7 is a 1, just copy 1 byte from source to destination */\n        /* Else do some decoding */\n        if(codeByte & 0x80)\n        {\n            decomp[dstPlace++] = source[srcPlace++];\n        }\n        else\n        {\n            /* Get 2 bytes from source */\n            byte1 = source[srcPlace++];\n            byte2 = source[srcPlace++];\n            /* Calculate distance to move in destination */\n            /* And the number of bytes to copy */\n            dist = ((byte1 & 0xF) << 8) | byte2;\n            copyPlace = dstPlace - (dist + 1);\n            numBytes = byte1 >> 4;\n            /* Do more calculations on the number of bytes to copy */\n            if(!numBytes)\n                numBytes = source[srcPlace++] + 0x12;\n            else\n                numBytes += 2;\n            /* Copy data from a previous point in destination */\n            /* to current point in destination */\n            for(i = 0; i < numBytes; i++)\n                decomp[dstPlace++] = decomp[copyPlace++];\n        }\n        /* Set up for the next read cycle */\n        codeByte = codeByte << 1;\n        bitCount--;\n    }\n"]], "pred": {"ppl": 2.209359645843506, "ppl_lower": 2.2263216972351074, "ppl/lowercase_ppl": -1.0096480556423595, "ppl/zlib": 0.0013858439170125149, "Min_5.0% Prob": 6.4582191705703735, "Min_10.0% Prob": 4.90461128950119, "Min_20.0% Prob": 3.3623008790115514, "Min_30.0% Prob": 2.478778845277326, "Min_40.0% Prob": 1.9451879079941023, "Min_50.0% Prob": 1.5746347971014247, "Min_60.0% Prob": 1.3199814585776164}}
{"hexsha": "2755bab7718f7c9024e97160ae500b37fa3e3360", "ext": "c", "lang": "C", "content": "void\nbio_patrol(char *arg)\n{\n\tstruct bioc_patrol\tbp;\n\tstruct timing\t\ttiming;\n\tconst char\t\t*errstr;\n\n\tmemset(&bp, 0, sizeof(bp));\n\tbp.bp_bio.bio_cookie = bio_cookie;\n\n\tswitch (arg[0]) {\n\tcase 'a':\n\t\tbp.bp_opcode = BIOC_SPAUTO;\n\t\tbreak;\n\n\tcase 'm':\n\t\tbp.bp_opcode = BIOC_SPMANUAL;\n\t\tbreak;\n\n\tcase 'd':\n\t\tbp.bp_opcode = BIOC_SPDISABLE;\n\t\tbreak;\n\n\tcase 'g': /* get patrol state */\n\t\tbp.bp_opcode = BIOC_GPSTATUS;\n\t\tbreak;\n\n\tcase 's': /* start/stop patrol */\n\t\tif (strncmp(\"sta\", arg, 3) == 0)\n\t\t\tbp.bp_opcode = BIOC_SPSTART;\n\t\telse\n\t\t\tbp.bp_opcode = BIOC_SPSTOP;\n\t\tbreak;\n\n\tdefault:\n\t\terrx(1, \"invalid patrol function: %s\", arg);\n\t}\n\n\tswitch (arg[0]) {\n\tcase 'a':\n\t\terrstr = str2patrol(arg, &timing);\n\t\tif (errstr)\n\t\t\terrx(1, \"Patrol %s: %s\", arg, errstr);\n\t\tbp.bp_autoival = timing.interval;\n\t\tbp.bp_autonext = timing.start;\n\t\tbreak;\n\t}\n\n\tif (ioctl(devh, BIOCPATROL, &bp))\n\t\terr(1, \"BIOCPATROL\");\n\n\tbio_status(&bp.bp_bio.bio_status);\n\n\tif (arg[0] == 'g') {\n\t\tconst char *mode, *status;\n\t\tchar interval[40];\n\n\t\tinterval[0] = '\\0';\n\n\t\tswitch (bp.bp_mode) {\n\t\tcase BIOC_SPMAUTO:\n\t\t\tmode = \"auto\";\n\t\t\tsnprintf(interval, sizeof interval,\n\t\t\t    \" interval=%d next=%d\", bp.bp_autoival,\n\t\t\t    bp.bp_autonext - bp.bp_autonow);\n\t\t\tbreak;\n\t\tcase BIOC_SPMMANUAL:\n\t\t\tmode = \"manual\";\n\t\t\tbreak;\n\t\tcase BIOC_SPMDISABLED:\n\t\t\tmode = \"disabled\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmode = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bp.bp_status) {\n\t\tcase BIOC_SPSSTOPPED:\n\t\t\tstatus = \"stopped\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSREADY:\n\t\t\tstatus = \"ready\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSACTIVE:\n\t\t\tstatus = \"active\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSABORTED:\n\t\t\tstatus = \"aborted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"patrol mode: %s%s\\n\", mode, interval);\n\t\tprintf(\"patrol status: %s\\n\", status);\n\t}\n}", "item_id": 20, "repo": "ArrogantWombatics/openbsd-src", "file": "sbin/bioctl/bioctl.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "2755bab7718f7c9024e97160ae500b37fa3e3360_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nbio_patrol(char *arg)\n{\n\tstruct bioc_patrol\tbp;\n\tstruct timing\t\ttiming;\n\tconst char\t\t*errstr;\n\tmemset(&bp, 0, sizeof(bp));\n\tbp.bp_bio.bio_cookie = bio_cookie;\n\tswitch (arg[0]) {\n\tcase 'a':\n\t\tbp.bp_opcode = BIOC_SPAUTO;\n\t\tbreak;\n\tcase 'm':\n\t\tbp.bp_opcode = BIOC_SPMANUAL;\n\t\tbreak;\n\tcase 'd':\n\t\tbp.bp_opcode = BIOC_SPDISABLE;\n\t\tbreak;\n\tcase 'g': /* get patrol state */\n\t\tbp.bp_opcode = BIOC_GPSTATUS;\n\t\tbreak;\n\tcase 's': /* start/stop patrol */\n\t\tif (strncmp(\"sta\", arg, 3) == 0)\n\t\t\tbp.bp_opcode = BIOC_SPSTART;\n\t\telse\n\t\t\tbp.bp_opcode = BIOC_SPSTOP;\n\t\tbreak;\n\tdefault:\n\t\terrx(1, \"invalid patrol function: %s\", arg);\n\t}\n\tswitch (arg[0]) {\n\tcase 'a':\n\t\terrstr = str2patrol(arg, &timing);\n\t\tif (errstr)\n\t\t\terrx(1, \"Patrol %s: %s\", arg, errstr);\n\t\tbp.bp_autoival = timing.interval;\n\t\tbp.bp_autonext = timing.start;\n\t\tbreak;\n\t}\n\tif (ioctl(devh, BIOCPATROL, &bp))\n\t\terr(1, \"BIOCPATROL\");\n\tbio_status(&bp.bp_bio.bio_status);\n\tif (arg[0] == 'g') {\n\t\tconst char *mode, *status;\n\t\tchar interval[40];\n\t\tinterval[0] = '\\0';\n\t\tswitch (bp.bp_mode) {\n\t\tcase BIOC_SPMAUTO:\n\t\t\tmode = \"auto\";\n\t\t\tsnprintf(interval, sizeof interval,\n\t\t\t    \" interval=%d next=%d\", bp.bp_autoival,\n\t\t\t    bp.bp_autonext - bp.bp_autonow);\n\t\t\tbreak;\n\t\tcase BIOC_SPMMANUAL:\n\t\t\tmode = \"manual\";\n\t\t\tbreak;\n\t\tcase BIOC_SPMDISABLED:\n\t\t\tmode = \"disabled\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmode = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tswitch (bp.bp_status) {\n\t\tcase BIOC_SPSSTOPPED:\n\t\t\tstatus = \"stopped\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSREADY:\n\t\t\tstatus = \"ready\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSACTIVE:\n\t\t\tstatus = \"active\";\n\t\t\tbreak;\n\t\tcase BIOC_SPSABORTED:\n\t\t\tstatus = \"aborted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"patrol mode: %s%s\\n\", mode, interval);\n\t\tprintf(\"patrol status: %s\\n\", status);\n\t}\n"]], "pred": {"ppl": 1.7529062032699585, "ppl_lower": 1.8346617221832275, "ppl/lowercase_ppl": -1.0812168916475393, "ppl/zlib": 0.0008087537436619511, "Min_5.0% Prob": 6.030567700212652, "Min_10.0% Prob": 4.330333201722666, "Min_20.0% Prob": 2.671020845403779, "Min_30.0% Prob": 1.8517788473264616, "Min_40.0% Prob": 1.4003723542560154, "Min_50.0% Prob": 1.12259255462066, "Min_60.0% Prob": 0.9357947188929269}}
{"hexsha": "41b13391b8ebb5a18ff5dfe32360ed35354c432d", "ext": "c", "lang": "C", "content": "void receive_gwiz_msg(mapping info)\n{\n        string msg,id,mudname;\n        int status;\n\n        // \u4e00\u5b9a\u5fc5\u9808\u8981\u6709\u7684\u6b04\u4f4d\n        if( undefinedp(info[\"NAME\"])\n            ||  undefinedp(info[\"PORTUDP\"])\n            ||  undefinedp(info[\"WIZNAME\"])\n            ||  undefinedp(info[\"CHANNEL\"])\n            ||  undefinedp(msg = info[\"GWIZ\"])\n        )   return;\n        // \u53bb\u9664\u6700\u5f8c\u4e00\u500b \\n\n        if(msg[<1..<0] == \"\\n\") msg[<1..<0] = \"\";\n        // \u65b0\u4f86\u7684\u7ad9\u7d66\u6211\u4e56\u4e56\u6392\u968a\u56de ping :Q\n        if( compare_mud_info(info)<1 ) return;\n\n        // \u8a2d\u5b9a id\n        id = info[\"WIZNAME\"];\n        //id = info[\"WIZNAME\"] + \"@\" + info[\"NAME\"];\n        // \u6709\u7121\u4e2d\u6587 name ?\n        if( info[\"CNAME\"] ) id = info[\"CNAME\"] + \"(\" + id + \")\";\n        \n        // \u662f\u5426\u70ba Emote ?\n        if( !undefinedp(info[\"EMOTE\"]) )\n                set(\"channel_id\", id);\n        // GB \u8f49\u78bc ?\n        mudname=get_mud_name(info);\n\n        status = fetch_data(mudname)[\"STATUS\"];\n\n        if( !(status & ENCODE_CONFIRM) && strlen(msg) > 20 )\n        {\n                string mud_ip_port = info[\"HOSTADDRESS\"]+\":\"+info[\"PORTUDP\"];\n                int con = LANGUAGE_D->encode_conjecture(msg);\n\n                if( con >= 0 && con <= 15 ) mudlist[mud_ip_port][\"STATUS\"]|=GB_CODE;\n                else if( con > 30 ) mudlist[mud_ip_port][\"STATUS\"]&=~GB_CODE;\n\n                if( con != -1 ) mudlist[mud_ip_port][\"STATUS\"]|=ENCODE_CONFIRM;\n        }\n\n        /*\n        if( status & IGNORED ) // \u5982\u679c\u88ab\u5217\u5165\u9694\u7d55\u4fe1\u606f\u7ad9\u9ede\uff0c\u5247\u5c4f\u853d\u7db2\u969b\u804a\u5929\u983b\u9053\n        {\n                if( info[\"EMOTE\"] ) delete(\"channel_id\");\n                return;\n        }\n        */\n\n        if( !(status & GB_CODE) && ((status & ENCODE_CONFIRM) || (!undefinedp(mudlist[mudname][\"ENCODING\"]) && lower_case(mudlist[mudname][\"ENCODING\"])==\"big5\")) )\n        {\n                // id = (string)LANGUAGE_D->toGB(id);\n                msg = (string)LANGUAGE_D->toGB(msg);\n        }\n        \n        // \u4f5c\u70ba\u5176\u4ed6\u975eNTlib\u7684mud\uff0c\u53ef\u76f4\u63a5\u7528CHANNEL_D->do_channel(this_object(), info[\"CHANNEL\"], msg, info[\"EMOTE\"]);\u66ff\u63db\u4ee5\u4e0b\u7684\u5167\u5bb9\n        if( status & ANTI_AD ) // \u5783\u573e\u5ee3\u544a\u7ad9\u9ede\n        {\n                info[\"CHANNEL\"]=\"ad\"; // \u628a\u5c0d\u65b9\u7db2\u7d61\u983b\u9053\u6539\u6210\u5ee3\u544a\u983b\u9053\n                CHANNEL_D->channel_broadcast(info[\"CHANNEL\"], info[\"EMOTE\"]?(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ msg):(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ id+\"\uff1a\"+msg));\n\n                if( info[\"EMOTE\"] ) delete(\"channel_id\");\n                return;\n        }\n\n        // \u4ea4\u4ed8\u7d66 CHANNEL_D \u8655\u7406\n        CHANNEL_D->channel_broadcast(\"gwiz\",\"[\"+info[\"CHANNEL\"]+\"] \"+(info[\"EMOTE\"]?(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+msg):(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ id+\"\uff1a\"+msg)));\n        if( info[\"EMOTE\"] ) delete(\"channel_id\");\n\n        //NCH_CHANNEL(\"\u6536\u5230 gwizmsg \"+info[\"CHANNEL\"]+\" \u8a0a\u606f\");\n}", "item_id": 30, "repo": "cantona/NT6", "file": "nitan/adm/daemons/intermud2_d.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "41b13391b8ebb5a18ff5dfe32360ed35354c432d_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void receive_gwiz_msg(mapping info)\n{\n        string msg,id,mudname;\n        int status;\n        // \u4e00\u5b9a\u5fc5\u9808\u8981\u6709\u7684\u6b04\u4f4d\n        if( undefinedp(info[\"NAME\"])\n            ||  undefinedp(info[\"PORTUDP\"])\n            ||  undefinedp(info[\"WIZNAME\"])\n            ||  undefinedp(info[\"CHANNEL\"])\n            ||  undefinedp(msg = info[\"GWIZ\"])\n        )   return;\n        // \u53bb\u9664\u6700\u5f8c\u4e00\u500b \\n\n        if(msg[<1..<0] == \"\\n\") msg[<1..<0] = \"\";\n        // \u65b0\u4f86\u7684\u7ad9\u7d66\u6211\u4e56\u4e56\u6392\u968a\u56de ping :Q\n        if( compare_mud_info(info)<1 ) return;\n        // \u8a2d\u5b9a id\n        id = info[\"WIZNAME\"];\n        //id = info[\"WIZNAME\"] + \"@\" + info[\"NAME\"];\n        // \u6709\u7121\u4e2d\u6587 name ?\n        if( info[\"CNAME\"] ) id = info[\"CNAME\"] + \"(\" + id + \")\";\n        // \u662f\u5426\u70ba Emote ?\n        if( !undefinedp(info[\"EMOTE\"]) )\n                set(\"channel_id\", id);\n        // GB \u8f49\u78bc ?\n        mudname=get_mud_name(info);\n        status = fetch_data(mudname)[\"STATUS\"];\n        if( !(status & ENCODE_CONFIRM) && strlen(msg) > 20 )\n        {\n                string mud_ip_port = info[\"HOSTADDRESS\"]+\":\"+info[\"PORTUDP\"];\n                int con = LANGUAGE_D->encode_conjecture(msg);\n                if( con >= 0 && con <= 15 ) mudlist[mud_ip_port][\"STATUS\"]|=GB_CODE;\n                else if( con > 30 ) mudlist[mud_ip_port][\"STATUS\"]&=~GB_CODE;\n                if( con != -1 ) mudlist[mud_ip_port][\"STATUS\"]|=ENCODE_CONFIRM;\n        }\n        /*\n        if( status & IGNORED ) // \u5982\u679c\u88ab\u5217\u5165\u9694\u7d55\u4fe1\u606f\u7ad9\u9ede\uff0c\u5247\u5c4f\u853d\u7db2\u969b\u804a\u5929\u983b\u9053\n        {\n                if( info[\"EMOTE\"] ) delete(\"channel_id\");\n                return;\n        }\n        */\n        if( !(status & GB_CODE) && ((status & ENCODE_CONFIRM) || (!undefinedp(mudlist[mudname][\"ENCODING\"]) && lower_case(mudlist[mudname][\"ENCODING\"])==\"big5\")) )\n        {\n                // id = (string)LANGUAGE_D->toGB(id);\n                msg = (string)LANGUAGE_D->toGB(msg);\n        }\n        // \u4f5c\u70ba\u5176\u4ed6\u975eNTlib\u7684mud\uff0c\u53ef\u76f4\u63a5\u7528CHANNEL_D->do_channel(this_object(), info[\"CHANNEL\"], msg, info[\"EMOTE\"]);\u66ff\u63db\u4ee5\u4e0b\u7684\u5167\u5bb9\n        if( status & ANTI_AD ) // \u5783\u573e\u5ee3\u544a\u7ad9\u9ede\n        {\n                info[\"CHANNEL\"]=\"ad\"; // \u628a\u5c0d\u65b9\u7db2\u7d61\u983b\u9053\u6539\u6210\u5ee3\u544a\u983b\u9053\n                CHANNEL_D->channel_broadcast(info[\"CHANNEL\"], info[\"EMOTE\"]?(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ msg):(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ id+\"\uff1a\"+msg));\n                if( info[\"EMOTE\"] ) delete(\"channel_id\");\n                return;\n        }\n        // \u4ea4\u4ed8\u7d66 CHANNEL_D \u8655\u7406\n        CHANNEL_D->channel_broadcast(\"gwiz\",\"[\"+info[\"CHANNEL\"]+\"] \"+(info[\"EMOTE\"]?(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+msg):(\"{\"+HBGRN+mudlist[mudname][\"NAME\"]+NOR+\"} \"+ id+\"\uff1a\"+msg)));\n        if( info[\"EMOTE\"] ) delete(\"channel_id\");\n        //NCH_CHANNEL(\"\u6536\u5230 gwizmsg \"+info[\"CHANNEL\"]+\" \u8a0a\u606f\");\n"]], "pred": {"ppl": 3.740980386734009, "ppl_lower": 3.972461700439453, "ppl/lowercase_ppl": -1.045506021704472, "ppl/zlib": 0.0011403178155274956, "Min_5.0% Prob": 7.985201405543907, "Min_10.0% Prob": 6.627093922858145, "Min_20.0% Prob": 5.037042655196845, "Min_30.0% Prob": 3.935190110424765, "Min_40.0% Prob": 3.1541457348172997, "Min_50.0% Prob": 2.5976405170565715, "Min_60.0% Prob": 2.189697768265719}}
{"hexsha": "dc83a9d979b5285bb5e9704a9d32cef199a5c129", "ext": "c", "lang": "C", "content": "static int nodeid_to_addr(int nodeid, struct sockaddr *retaddr)\n{\n\tstruct sockaddr_storage addr;\n\tint error;\n\n\tif (!dlm_local_count)\n\t\treturn -1;\n\n\terror = dlm_nodeid_to_addr(nodeid, &addr);\n\tif (error)\n\t\treturn error;\n\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &addr;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) retaddr;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &addr;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) retaddr;\n\t\tmemcpy(&ret6->sin6_addr, &in6->sin6_addr,\n\t\t       sizeof(in6->sin6_addr));\n\t}\n\n\treturn 0;\n}", "item_id": 1, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/fs/dlm/lowcomms-sctp.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "dc83a9d979b5285bb5e9704a9d32cef199a5c129_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int nodeid_to_addr(int nodeid, struct sockaddr *retaddr)\n{\n\tstruct sockaddr_storage addr;\n\tint error;\n\tif (!dlm_local_count)\n\t\treturn -1;\n\terror = dlm_nodeid_to_addr(nodeid, &addr);\n\tif (error)\n\t\treturn error;\n\tif (dlm_local_addr[0]->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in4  = (struct sockaddr_in *) &addr;\n\t\tstruct sockaddr_in *ret4 = (struct sockaddr_in *) retaddr;\n\t\tret4->sin_addr.s_addr = in4->sin_addr.s_addr;\n\t} else {\n\t\tstruct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &addr;\n\t\tstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) retaddr;\n\t\tmemcpy(&ret6->sin6_addr, &in6->sin6_addr,\n\t\t       sizeof(in6->sin6_addr));\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 1.603797197341919, "ppl_lower": 1.6517539024353027, "ppl/lowercase_ppl": -1.0623735102783256, "ppl/zlib": 0.001663288964360219, "Min_5.0% Prob": 5.319326536996024, "Min_10.0% Prob": 3.638016404776738, "Min_20.0% Prob": 2.236818701028824, "Min_30.0% Prob": 1.5655573036691004, "Min_40.0% Prob": 1.1781136752816581, "Min_50.0% Prob": 0.9473072260041677, "Min_60.0% Prob": 0.7871576470190049}}
{"hexsha": "04f4f43dd5ddf58b5afd7a38aaf92c720ab94b2b", "ext": "c", "lang": "C", "content": "pwr_status_t tim5_one_shot_start\n(\n    uint64_t  planUs      /* IN */\n)\n{\n    uint64_t cnt;\n\n    krhino_spin_lock_irq_save(&tim5_spin);\n\n    /*\n     * convert microsecond into count value according\n     * current frequency.\n     */\n\n    cnt = planUs * freq_of_internal_count / 1000000;\n#ifdef TIM5_DBG\n    printf(\"planUs = %lld, cnt = %lld, tim5_irq_count = %d\\n\",\n           planUs, cnt, tim5_irq_count);\n#endif\n\n    /*\n     * if request plan time is longer than the time support,\n     * just return ERORR, it is responsibility of caller to\n     * to handle this PWR_ERR.\n     */\n    if (cnt > (uint64_t)TIMER_32BIT_MAX_COUNT) {\n        krhino_spin_unlock_irq_restore (&tim5_spin);\n        return (PWR_ERR);\n    }\n\n    /*set counter to 0, it will increase from 0 */\n    __HAL_TIM_SET_COUNTER(&Tim5Handle, 0);\n\n    /* update hardware with new one autoload value */\n    __HAL_TIM_SET_AUTORELOAD(&Tim5Handle, cnt);\n\n    one_shot_planed_cnt = cnt;\n    one_shot_enabled    = 1;\n\n    /*\n    Bit 2 URS: Update request source\n    This bit is set and cleared by software to select the UEV event sources.\n    0:  Any of the following events generate an update interrupt or DMA request\n        if enabled.\n        These events can be:\n        \u2013 Counter overflow/underflow\n        \u2013 Setting the UG bit\n        \u2013 Update generation through the slave mode controller\n    1:  Only counter overflow/underflow generates an update interrupt or DMA\n        request if enabled.\n    */\n    __HAL_TIM_URS_ENABLE(&Tim5Handle);\n\n    /* clear any pending interrupt of update interrupt */\n    __HAL_TIM_CLEAR_IT(&Tim5Handle, TIM_IT_UPDATE);\n\n    /* enable update interrupt */\n    (void)HAL_TIM_Base_Start_IT(&Tim5Handle);\n\n    krhino_spin_unlock_irq_restore (&tim5_spin);\n\n    return PWR_OK;\n\n}", "item_id": 2, "repo": "jinlongliu/AliOS-Things", "file": "board/developerkit/pwrmgmt_hal/board_cpu_pwr_timer.c", "last_update_at": "2019-10-22T06:06:53+00:00", "question_id": "04f4f43dd5ddf58b5afd7a38aaf92c720ab94b2b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pwr_status_t tim5_one_shot_start\n(\n    uint64_t  planUs      /* IN */\n)\n{\n    uint64_t cnt;\n    krhino_spin_lock_irq_save(&tim5_spin);\n    /*\n     * convert microsecond into count value according\n     * current frequency.\n     */\n    cnt = planUs * freq_of_internal_count / 1000000;\n#ifdef TIM5_DBG\n    printf(\"planUs = %lld, cnt = %lld, tim5_irq_count = %d\\n\",\n           planUs, cnt, tim5_irq_count);\n#endif\n    /*\n     * if request plan time is longer than the time support,\n     * just return ERORR, it is responsibility of caller to\n     * to handle this PWR_ERR.\n     */\n    if (cnt > (uint64_t)TIMER_32BIT_MAX_COUNT) {\n        krhino_spin_unlock_irq_restore (&tim5_spin);\n        return (PWR_ERR);\n    }\n    /*set counter to 0, it will increase from 0 */\n    __HAL_TIM_SET_COUNTER(&Tim5Handle, 0);\n    /* update hardware with new one autoload value */\n    __HAL_TIM_SET_AUTORELOAD(&Tim5Handle, cnt);\n    one_shot_planed_cnt = cnt;\n    one_shot_enabled    = 1;\n    /*\n    Bit 2 URS: Update request source\n    This bit is set and cleared by software to select the UEV event sources.\n    0:  Any of the following events generate an update interrupt or DMA request\n        if enabled.\n        These events can be:\n        \u2013 Counter overflow/underflow\n        \u2013 Setting the UG bit\n        \u2013 Update generation through the slave mode controller\n    1:  Only counter overflow/underflow generates an update interrupt or DMA\n        request if enabled.\n    */\n    __HAL_TIM_URS_ENABLE(&Tim5Handle);\n    /* clear any pending interrupt of update interrupt */\n    __HAL_TIM_CLEAR_IT(&Tim5Handle, TIM_IT_UPDATE);\n    /* enable update interrupt */\n    (void)HAL_TIM_Base_Start_IT(&Tim5Handle);\n    krhino_spin_unlock_irq_restore (&tim5_spin);\n    return PWR_OK;\n"]], "pred": {"ppl": 2.7833428382873535, "ppl_lower": 3.6529722213745117, "ppl/lowercase_ppl": -1.265606184175632, "ppl/zlib": 0.0012348041799063493, "Min_5.0% Prob": 8.40143580590525, "Min_10.0% Prob": 6.334949262558468, "Min_20.0% Prob": 4.359544839177813, "Min_30.0% Prob": 3.2335883479900462, "Min_40.0% Prob": 2.514191960058515, "Min_50.0% Prob": 2.038424260062831, "Min_60.0% Prob": 1.7060470418886295}}
{"hexsha": "5b70f723654af68b80ff894d866a2c33f8b66bec", "ext": "c", "lang": "C", "content": "void\ngetCmdOpts (\n\tint argc,\n\tchar *argv[]\n\t)\n{\n\tint i;\n\n\twhile ((i = ntp_getopt(argc, argv, \"c:dfg:hlnt\")) != EOF)\n\t\tswitch (i) {\n\t\t    case 'c':\n\t\t\tconfig_file = ntp_optarg;\n#ifdef HAVE_NETINFO\n\t\t\tcheck_netinfo = 0;\n#endif\n\t\t\tbreak;\n\t\t    case 'd':\n\t\t\t++debug;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\t++force;\n\t\t\tbreak;\n\t\t    case 'g':\n\t\t\twhile (*ntp_optarg) {\n\t\t\t\tswitch (*ntp_optarg) {\n\t\t\t\t    case 'd':\n\t\t\t\t\t++make_dh;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 'm':\n\t\t\t\t\t++make_md5;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 'r':\n\t\t\t\t\t++make_rsa;\n\t\t\t\t\tbreak;\n\t\t\t\t    default:\n\t\t\t\t\t++errflag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ntp_optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case 'h':\n\t\t\t++here;\n\t\t\t++nosymlinks;\n\t\t\tbreak;\n\t\t    case 'l':\n\t\t\t++nosymlinks;\n\t\t\tbreak;\n\t\t    case 'n':\n\t\t\t++memorex;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\t++trash;\n\t\t\tbreak;\n\t\t    case '?':\n\t\t\t++errflag;\n\t\t\tbreak;\n\t\t}\n\n\tif (errflag)\n\t\tusage();\n\n\t/* If no file type was specified, make them all. */\n\tif (!(make_dh | make_md5 | make_rsa)) {\n\t\t++make_dh;\n\t\t++make_md5;\n\t\t++make_rsa;\n\t}\n}", "item_id": 2, "repo": "impedimentToProgress/UCI-BlueChip", "file": "snapgear_linux/user/ntp/util/ntp-genkeys.c", "last_update_at": "2019-12-05T02:31:23+00:00", "question_id": "5b70f723654af68b80ff894d866a2c33f8b66bec_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ngetCmdOpts (\n\tint argc,\n\tchar *argv[]\n\t)\n{\n\tint i;\n\twhile ((i = ntp_getopt(argc, argv, \"c:dfg:hlnt\")) != EOF)\n\t\tswitch (i) {\n\t\t    case 'c':\n\t\t\tconfig_file = ntp_optarg;\n#ifdef HAVE_NETINFO\n\t\t\tcheck_netinfo = 0;\n#endif\n\t\t\tbreak;\n\t\t    case 'd':\n\t\t\t++debug;\n\t\t\tbreak;\n\t\t    case 'f':\n\t\t\t++force;\n\t\t\tbreak;\n\t\t    case 'g':\n\t\t\twhile (*ntp_optarg) {\n\t\t\t\tswitch (*ntp_optarg) {\n\t\t\t\t    case 'd':\n\t\t\t\t\t++make_dh;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 'm':\n\t\t\t\t\t++make_md5;\n\t\t\t\t\tbreak;\n\t\t\t\t    case 'r':\n\t\t\t\t\t++make_rsa;\n\t\t\t\t\tbreak;\n\t\t\t\t    default:\n\t\t\t\t\t++errflag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++ntp_optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case 'h':\n\t\t\t++here;\n\t\t\t++nosymlinks;\n\t\t\tbreak;\n\t\t    case 'l':\n\t\t\t++nosymlinks;\n\t\t\tbreak;\n\t\t    case 'n':\n\t\t\t++memorex;\n\t\t\tbreak;\n\t\t    case 't':\n\t\t\t++trash;\n\t\t\tbreak;\n\t\t    case '?':\n\t\t\t++errflag;\n\t\t\tbreak;\n\t\t}\n\tif (errflag)\n\t\tusage();\n\t/* If no file type was specified, make them all. */\n\tif (!(make_dh | make_md5 | make_rsa)) {\n\t\t++make_dh;\n\t\t++make_md5;\n\t\t++make_rsa;\n\t}\n"]], "pred": {"ppl": 1.9208904504776, "ppl_lower": 2.020228385925293, "ppl/lowercase_ppl": -1.077240461705112, "ppl/zlib": 0.001580602554041459, "Min_5.0% Prob": 7.165260844760471, "Min_10.0% Prob": 5.1886393494076195, "Min_20.0% Prob": 3.110097861344661, "Min_30.0% Prob": 2.1474273339731664, "Min_40.0% Prob": 1.6292291090507574, "Min_50.0% Prob": 1.3054549547847047, "Min_60.0% Prob": 1.087864616726775}}
{"hexsha": "30f108ae45b893375ac26a2b4135a6b379c2aca2", "ext": "c", "lang": "C", "content": "void\nfilt_hotplugrdetach(struct knote *kn)\n{\n\tint s;\n\n\ts = splbio();\n\tSLIST_REMOVE(&hotplug_sel.si_note, kn, knote, kn_selnext);\n\tsplx(s);\n}", "item_id": 10, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/dev/hotplug.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "30f108ae45b893375ac26a2b4135a6b379c2aca2_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nfilt_hotplugrdetach(struct knote *kn)\n{\n\tint s;\n\ts = splbio();\n\tSLIST_REMOVE(&hotplug_sel.si_note, kn, knote, kn_selnext);\n\tsplx(s);\n"]], "pred": {"ppl": 5.001212120056152, "ppl_lower": 7.013644218444824, "ppl/lowercase_ppl": -1.210089616797967, "ppl/zlib": 0.01257562739894827, "Min_5.0% Prob": 10.919052124023438, "Min_10.0% Prob": 9.279726573399135, "Min_20.0% Prob": 6.539734499795096, "Min_30.0% Prob": 5.042362065542312, "Min_40.0% Prob": 3.9996633572237834, "Min_50.0% Prob": 3.2473503787602698, "Min_60.0% Prob": 2.7168630674658787}}
{"hexsha": "9f3ced7329fdcf0b1d93fcaa8ab6ff0b924f4479", "ext": "h", "lang": "C", "content": "OpCase(i_new_small_map_lit_dtq):\n{\n  Eterm tmp_packed1 = BeamExtraData(I[0]);\n  Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);\n  Eterm* dst_ptr = REG_TARGET_PTR(dst);\n  Eterm res;\n  Uint n;\n  Eterm keys = I[1];\n\n  HEAVY_SWAPOUT;\n  res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I+2);\n  HEAVY_SWAPIN;\n  dst_ptr = REG_TARGET_PTR(dst);\n  *dst_ptr = res;\n  n = arityval(*tuple_val(keys));\n  SET_I((BeamInstr *) I+2+n);\n  Goto(*I);;\n}", "item_id": 112, "repo": "rsewell/Epilogue", "file": "integrations/otp_src_22.1/erts/emulator/x86_64-unknown-linux-gnu/opt/smp/beam_hot.h", "last_update_at": "2019-11-20T21:40:16+00:00", "question_id": "9f3ced7329fdcf0b1d93fcaa8ab6ff0b924f4479_112", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["OpCase(i_new_small_map_lit_dtq):\n{\n  Eterm tmp_packed1 = BeamExtraData(I[0]);\n  Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);\n  Eterm* dst_ptr = REG_TARGET_PTR(dst);\n  Eterm res;\n  Uint n;\n  Eterm keys = I[1];\n  HEAVY_SWAPOUT;\n  res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I+2);\n  HEAVY_SWAPIN;\n  dst_ptr = REG_TARGET_PTR(dst);\n  *dst_ptr = res;\n  n = arityval(*tuple_val(keys));\n  SET_I((BeamInstr *) I+2+n);\n  Goto(*I);;\n"]], "pred": {"ppl": 6.49525260925293, "ppl_lower": 8.597025871276855, "ppl/lowercase_ppl": -1.1498311347000734, "ppl/zlib": 0.006588280078330434, "Min_5.0% Prob": 10.205756823221842, "Min_10.0% Prob": 8.97690192858378, "Min_20.0% Prob": 7.011758585770925, "Min_30.0% Prob": 5.562874858578046, "Min_40.0% Prob": 4.460022325317065, "Min_50.0% Prob": 3.682587194442749, "Min_60.0% Prob": 3.1055853366851807}}
{"hexsha": "1f54462067cfd67ae26fcacee7de6447d4428814", "ext": "c", "lang": "C", "content": "static zx_status_t mbr_bind(void* ctx, zx_device_t* parent) {\n    // Make sure the MBR structs are the right size.\n    static_assert(sizeof(mbr_t) == MBR_SIZE, \"mbr_t is the wrong size\");\n    static_assert(sizeof(mbr_partition_entry_t) == MBR_PARTITION_ENTRY_SIZE,\n                  \"mbr_partition_entry_t is the wrong size\");\n\n    // create an invisible device, which will be used for the first partition\n    mbrpart_device_t* device = calloc(1, sizeof(mbrpart_device_t));\n    if (!device) {\n        return ZX_ERR_NO_MEMORY;\n    }\n    device->parent = parent;\n    device->bind_completed = SYNC_COMPLETION_INIT;\n\n    if (device_get_protocol(parent, ZX_PROTOCOL_BLOCK, &device->bp) != ZX_OK) {\n        zxlogf(ERROR, \"mbr: ERROR: block device '%s': does not support block protocol\\n\",\n               device_get_name(parent));\n        free(device);\n        return ZX_ERR_NOT_SUPPORTED;\n    }\n\n    char name[128];\n    snprintf(name, sizeof(name), \"part-%03u\", 0);\n\n    device_add_args_t args = {\n        .version = DEVICE_ADD_ARGS_VERSION,\n        .name = name,\n        .ctx = device,\n        .ops = &mbr_proto,\n        .proto_id = ZX_PROTOCOL_BLOCK_IMPL,\n        .proto_ops = &block_ops,\n        .flags = DEVICE_ADD_INVISIBLE,\n    };\n\n    zx_status_t status = device_add(parent, &args, &device->zxdev);\n    if (status != ZX_OK) {\n        free(device);\n        return status;\n    }\n\n    // Read the partition table asynchronously.\n    thrd_t t;\n    int thrd_rc = thrd_create_with_name(&t, mbr_bind_thread, device, \"mbr-init\");\n    if (thrd_rc != thrd_success) {\n        return thrd_status_to_zx_status(thrd_rc);\n    }\n    return ZX_OK;\n}", "item_id": 7, "repo": "yanyushr/fuchsia", "file": "zircon/system/dev/block/mbr/mbr.c", "last_update_at": "2019-10-09T10:50:57+00:00", "question_id": "1f54462067cfd67ae26fcacee7de6447d4428814_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static zx_status_t mbr_bind(void* ctx, zx_device_t* parent) {\n    // Make sure the MBR structs are the right size.\n    static_assert(sizeof(mbr_t) == MBR_SIZE, \"mbr_t is the wrong size\");\n    static_assert(sizeof(mbr_partition_entry_t) == MBR_PARTITION_ENTRY_SIZE,\n                  \"mbr_partition_entry_t is the wrong size\");\n    // create an invisible device, which will be used for the first partition\n    mbrpart_device_t* device = calloc(1, sizeof(mbrpart_device_t));\n    if (!device) {\n        return ZX_ERR_NO_MEMORY;\n    }\n    device->parent = parent;\n    device->bind_completed = SYNC_COMPLETION_INIT;\n    if (device_get_protocol(parent, ZX_PROTOCOL_BLOCK, &device->bp) != ZX_OK) {\n        zxlogf(ERROR, \"mbr: ERROR: block device '%s': does not support block protocol\\n\",\n               device_get_name(parent));\n        free(device);\n        return ZX_ERR_NOT_SUPPORTED;\n    }\n    char name[128];\n    snprintf(name, sizeof(name), \"part-%03u\", 0);\n    device_add_args_t args = {\n        .version = DEVICE_ADD_ARGS_VERSION,\n        .name = name,\n        .ctx = device,\n        .ops = &mbr_proto,\n        .proto_id = ZX_PROTOCOL_BLOCK_IMPL,\n        .proto_ops = &block_ops,\n        .flags = DEVICE_ADD_INVISIBLE,\n    };\n    zx_status_t status = device_add(parent, &args, &device->zxdev);\n    if (status != ZX_OK) {\n        free(device);\n        return status;\n    }\n    // Read the partition table asynchronously.\n    thrd_t t;\n    int thrd_rc = thrd_create_with_name(&t, mbr_bind_thread, device, \"mbr-init\");\n    if (thrd_rc != thrd_success) {\n        return thrd_status_to_zx_status(thrd_rc);\n    }\n    return ZX_OK;\n"]], "pred": {"ppl": 1.6609373092651367, "ppl_lower": 2.1262052059173584, "ppl/lowercase_ppl": -1.4867272937512286, "ppl/zlib": 0.0006765094495367443, "Min_5.0% Prob": 5.640494486381268, "Min_10.0% Prob": 3.9817749484110685, "Min_20.0% Prob": 2.3970065039246022, "Min_30.0% Prob": 1.6679772683029068, "Min_40.0% Prob": 1.2643535406363808, "Min_50.0% Prob": 1.013639882183556, "Min_60.0% Prob": 0.847257248914863}}
{"hexsha": "100f2c174bcf5f02e1e83b9f427ce88cc618db58", "ext": "c", "lang": "C", "content": "int sucet_kladnych(int cisla[], int lenght){\n    int posSum = 0, i = 0;\n    while(i < lenght){\n        if (cisla[i] > 0){\n            posSum+= cisla[i];\n        }\n        i++;\n    }\n\n    return posSum;\n}", "item_id": 2, "repo": "CodyM4V3R1CK/School-Stuff", "file": "3rd-grade/C/savingPrivateBMW/poleVoFunkcii.c", "last_update_at": "2019-02-12T16:50:53+00:00", "question_id": "100f2c174bcf5f02e1e83b9f427ce88cc618db58_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int sucet_kladnych(int cisla[], int lenght){\n    int posSum = 0, i = 0;\n    while(i < lenght){\n        if (cisla[i] > 0){\n            posSum+= cisla[i];\n        }\n        i++;\n    }\n    return posSum;\n"]], "pred": {"ppl": 4.030238151550293, "ppl_lower": 3.907583713531494, "ppl/lowercase_ppl": -0.9778263041625853, "ppl/zlib": 0.01088926147570361, "Min_5.0% Prob": 10.157220482826233, "Min_10.0% Prob": 8.25753116607666, "Min_20.0% Prob": 6.061141401529312, "Min_30.0% Prob": 4.416717250347137, "Min_40.0% Prob": 3.4595544076327123, "Min_50.0% Prob": 2.757041525273096, "Min_60.0% Prob": 2.3281011569499968}}
{"hexsha": "9584c6ae447c423f30992d5b21ce46db674c182e", "ext": "c", "lang": "C", "content": "static bool _table_Iridium(mavlink_message_t * msg)\n{\n\tif (NULL == iridium_task_handle || NULL == iridium_queue_handle)\n\t\treturn false;\n\n\t_ir_divider_t * const entry = _ir_divider_find_entry(msg->msgid);\n\n\tif (NULL == entry)\n\t\treturn false;\n\n\tif (0 == entry->divider)\n\t\treturn false;\n\n\tif (entry->counter + 1 >= entry->divider)\n\t{\n\t\tentry->counter = 0;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tentry->counter++;\n\t\treturn false;\n\t}\n\n\t/*\n\t * 0+1 = 1 >= 1 => true\n\t * 0+1 = 1 >= 1 => true\n\t *\n\t * 0+1 = 1 >= 2 => false\n\t * 1+1 = 2 >= 2 => true\n\t * 0+1 = 1 >= 2 => false\n\t *\n\t * 0+1 = 1 >= 3 => false\n\t * 1+1 = 2 >= 3 => false\n\t * 2+1 = 3 >= 3 => true\n\t * 0+1 = 1 >= 3 => false\n\t */\n}", "item_id": 5, "repo": "shostakovichs-spacecraft-factory/cansat-2018-2019", "file": "src/board/ICU/Src/router.c", "last_update_at": "2019-12-04T06:49:54+00:00", "question_id": "9584c6ae447c423f30992d5b21ce46db674c182e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool _table_Iridium(mavlink_message_t * msg)\n{\n\tif (NULL == iridium_task_handle || NULL == iridium_queue_handle)\n\t\treturn false;\n\t_ir_divider_t * const entry = _ir_divider_find_entry(msg->msgid);\n\tif (NULL == entry)\n\t\treturn false;\n\tif (0 == entry->divider)\n\t\treturn false;\n\tif (entry->counter + 1 >= entry->divider)\n\t{\n\t\tentry->counter = 0;\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tentry->counter++;\n\t\treturn false;\n\t}\n\t/*\n\t * 0+1 = 1 >= 1 => true\n\t * 0+1 = 1 >= 1 => true\n\t *\n\t * 0+1 = 1 >= 2 => false\n\t * 1+1 = 2 >= 2 => true\n\t * 0+1 = 1 >= 2 => false\n\t *\n\t * 0+1 = 1 >= 3 => false\n\t * 1+1 = 2 >= 3 => false\n\t * 2+1 = 3 >= 3 => true\n\t * 0+1 = 1 >= 3 => false\n\t */\n"]], "pred": {"ppl": 2.360193967819214, "ppl_lower": 2.424923896789551, "ppl/lowercase_ppl": -1.0315068773075187, "ppl/zlib": 0.0032162689341349443, "Min_5.0% Prob": 7.679330348968506, "Min_10.0% Prob": 5.7411073371768, "Min_20.0% Prob": 3.7356061544269323, "Min_30.0% Prob": 2.698158580310566, "Min_40.0% Prob": 2.0999323965967163, "Min_50.0% Prob": 1.7028686940486049, "Min_60.0% Prob": 1.4298187736517836}}
{"hexsha": "31cffd779e687a9f4dc8ece64b89776ab066cea0", "ext": "c", "lang": "C", "content": "bool\nhttp_send_advs(const adv_report_table_t *const p_reports, const uint32_t nonce, const bool flag_use_timestamps)\n{\n    const ruuvi_gw_cfg_coordinates_t coordinates       = gw_cfg_get_coordinates();\n    http_async_info_t *              p_http_async_info = &g_http_async_info;\n\n    p_http_async_info->flag_sending_advs = true;\n    p_http_async_info->cjson_str         = cjson_wrap_str_null();\n    if (!http_json_create_records_str(\n            p_reports,\n            flag_use_timestamps,\n            time(NULL),\n            gw_cfg_get_nrf52_mac_addr(),\n            coordinates.buf,\n            true,\n            nonce,\n            &p_http_async_info->cjson_str))\n    {\n        LOG_ERR(\"Not enough memory to generate json\");\n        return false;\n    }\n\n    http_init_client_config_for_http_record(&p_http_async_info->http_client_config);\n\n    p_http_async_info->p_http_client_handle = esp_http_client_init(\n        &p_http_async_info->http_client_config.esp_http_client_config);\n    if (NULL == p_http_async_info->p_http_client_handle)\n    {\n        LOG_ERR(\"HTTP POST to URL=%s: Can't init http client\", p_http_async_info->http_client_config.http_url.buf);\n        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);\n        return false;\n    }\n\n    if (!http_send_async(p_http_async_info))\n    {\n        esp_http_client_cleanup(p_http_async_info->p_http_client_handle);\n        p_http_async_info->p_http_client_handle = NULL;\n        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);\n        return false;\n    }\n    return true;\n}", "item_id": 4, "repo": "ruuvi/ruuvi.dongle_esp.c", "file": "main/http.c", "last_update_at": "2019-12-05T12:37:34+00:00", "question_id": "31cffd779e687a9f4dc8ece64b89776ab066cea0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\nhttp_send_advs(const adv_report_table_t *const p_reports, const uint32_t nonce, const bool flag_use_timestamps)\n{\n    const ruuvi_gw_cfg_coordinates_t coordinates       = gw_cfg_get_coordinates();\n    http_async_info_t *              p_http_async_info = &g_http_async_info;\n    p_http_async_info->flag_sending_advs = true;\n    p_http_async_info->cjson_str         = cjson_wrap_str_null();\n    if (!http_json_create_records_str(\n            p_reports,\n            flag_use_timestamps,\n            time(NULL),\n            gw_cfg_get_nrf52_mac_addr(),\n            coordinates.buf,\n            true,\n            nonce,\n            &p_http_async_info->cjson_str))\n    {\n        LOG_ERR(\"Not enough memory to generate json\");\n        return false;\n    }\n    http_init_client_config_for_http_record(&p_http_async_info->http_client_config);\n    p_http_async_info->p_http_client_handle = esp_http_client_init(\n        &p_http_async_info->http_client_config.esp_http_client_config);\n    if (NULL == p_http_async_info->p_http_client_handle)\n    {\n        LOG_ERR(\"HTTP POST to URL=%s: Can't init http client\", p_http_async_info->http_client_config.http_url.buf);\n        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);\n        return false;\n    }\n    if (!http_send_async(p_http_async_info))\n    {\n        esp_http_client_cleanup(p_http_async_info->p_http_client_handle);\n        p_http_async_info->p_http_client_handle = NULL;\n        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);\n        return false;\n    }\n    return true;\n"]], "pred": {"ppl": 2.2430191040039062, "ppl_lower": 2.323857069015503, "ppl/lowercase_ppl": -1.0438283785545532, "ppl/zlib": 0.001593338802106615, "Min_5.0% Prob": 7.516376883895309, "Min_10.0% Prob": 5.7341926184567535, "Min_20.0% Prob": 3.731098719618537, "Min_30.0% Prob": 2.6472941952221323, "Min_40.0% Prob": 2.0152322035790844, "Min_50.0% Prob": 1.6172484917430716, "Min_60.0% Prob": 1.3486123221185566}}
{"hexsha": "79dbafce5ddd40e746a554cef78213dccbf94672", "ext": "c", "lang": "C", "content": "static void\nhandle_prepare (int insn, int insn2, CORE_ADDR * current_pc_ptr,\n\t\tstruct prologue_info *pi, struct pifsr **pifsr_ptr)\n{\n  CORE_ADDR current_pc = *current_pc_ptr;\n  struct pifsr *pifsr = *pifsr_ptr;\n  long next = insn2 & 0xffff;\n  long list12 = ((insn & 1) << 16) + (next & 0xffe0);\n  long offset = (insn & 0x3e) << 1;\n  static struct reg_list reg_table[] =\n  {\n    {0x00800, 20},\t\t/* r20 */\n    {0x00400, 21},\t\t/* r21 */\n    {0x00200, 22},\t\t/* r22 */\n    {0x00100, 23},\t\t/* r23 */\n    {0x08000, 24},\t\t/* r24 */\n    {0x04000, 25},\t\t/* r25 */\n    {0x02000, 26},\t\t/* r26 */\n    {0x01000, 27},\t\t/* r27 */\n    {0x00080, 28},\t\t/* r28 */\n    {0x00040, 29},\t\t/* r29 */\n    {0x10000, 30},\t\t/* ep */\n    {0x00020, 31},\t\t/* lp */\n    {0, 0}\t\t\t/* end of table */\n  };\n  int i;\n\n  if ((next & 0x1f) == 0x0b)\t/* skip imm16 argument */\n    current_pc += 2;\n  else if ((next & 0x1f) == 0x13)\t/* skip imm16 argument */\n    current_pc += 2;\n  else if ((next & 0x1f) == 0x1b)\t/* skip imm32 argument */\n    current_pc += 4;\n\n  /* Calculate the total size of the saved registers, and add it\n     it to the immediate value used to adjust SP. */\n  for (i = 0; reg_table[i].mask != 0; i++)\n    if (list12 & reg_table[i].mask)\n      offset += v850_register_raw_size (reg_table[i].regno);\n  pi->frameoffset -= offset;\n\n  /* Calculate the offsets of the registers relative to the value\n     the SP will have after the registers have been pushed and the\n     imm5 value has been subtracted from it. */\n  if (pifsr)\n    {\n      for (i = 0; reg_table[i].mask != 0; i++)\n\t{\n\t  if (list12 & reg_table[i].mask)\n\t    {\n\t      int reg = reg_table[i].regno;\n\t      offset -= v850_register_raw_size (reg);\n\t      pifsr->reg = reg;\n\t      pifsr->offset = offset;\n\t      pifsr->cur_frameoffset = pi->frameoffset;\n#ifdef DEBUG\n\t      printf_filtered (\"\\tSaved register r%d, offset %d\", reg, pifsr->offset);\n#endif\n\t      pifsr++;\n\t    }\n\t}\n    }\n#ifdef DEBUG\n  printf_filtered (\"\\tfound ctret after regsave func\");\n#endif\n\n  /* Set result parameters. */\n  *current_pc_ptr = current_pc;\n  *pifsr_ptr = pifsr;\n}", "item_id": 1, "repo": "ArrogantWombatics/openbsd-src", "file": "gnu/usr.bin/binutils/gdb/v850-tdep.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "79dbafce5ddd40e746a554cef78213dccbf94672_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nhandle_prepare (int insn, int insn2, CORE_ADDR * current_pc_ptr,\n\t\tstruct prologue_info *pi, struct pifsr **pifsr_ptr)\n{\n  CORE_ADDR current_pc = *current_pc_ptr;\n  struct pifsr *pifsr = *pifsr_ptr;\n  long next = insn2 & 0xffff;\n  long list12 = ((insn & 1) << 16) + (next & 0xffe0);\n  long offset = (insn & 0x3e) << 1;\n  static struct reg_list reg_table[] =\n  {\n    {0x00800, 20},\t\t/* r20 */\n    {0x00400, 21},\t\t/* r21 */\n    {0x00200, 22},\t\t/* r22 */\n    {0x00100, 23},\t\t/* r23 */\n    {0x08000, 24},\t\t/* r24 */\n    {0x04000, 25},\t\t/* r25 */\n    {0x02000, 26},\t\t/* r26 */\n    {0x01000, 27},\t\t/* r27 */\n    {0x00080, 28},\t\t/* r28 */\n    {0x00040, 29},\t\t/* r29 */\n    {0x10000, 30},\t\t/* ep */\n    {0x00020, 31},\t\t/* lp */\n    {0, 0}\t\t\t/* end of table */\n  };\n  int i;\n  if ((next & 0x1f) == 0x0b)\t/* skip imm16 argument */\n    current_pc += 2;\n  else if ((next & 0x1f) == 0x13)\t/* skip imm16 argument */\n    current_pc += 2;\n  else if ((next & 0x1f) == 0x1b)\t/* skip imm32 argument */\n    current_pc += 4;\n  /* Calculate the total size of the saved registers, and add it\n     it to the immediate value used to adjust SP. */\n  for (i = 0; reg_table[i].mask != 0; i++)\n    if (list12 & reg_table[i].mask)\n      offset += v850_register_raw_size (reg_table[i].regno);\n  pi->frameoffset -= offset;\n  /* Calculate the offsets of the registers relative to the value\n     the SP will have after the registers have been pushed and the\n     imm5 value has been subtracted from it. */\n  if (pifsr)\n    {\n      for (i = 0; reg_table[i].mask != 0; i++)\n\t{\n\t  if (list12 & reg_table[i].mask)\n\t    {\n\t      int reg = reg_table[i].regno;\n\t      offset -= v850_register_raw_size (reg);\n\t      pifsr->reg = reg;\n\t      pifsr->offset = offset;\n\t      pifsr->cur_frameoffset = pi->frameoffset;\n#ifdef DEBUG\n\t      printf_filtered (\"\\tSaved register r%d, offset %d\", reg, pifsr->offset);\n#endif\n\t      pifsr++;\n\t    }\n\t}\n    }\n#ifdef DEBUG\n  printf_filtered (\"\\tfound ctret after regsave func\");\n#endif\n  /* Set result parameters. */\n  *current_pc_ptr = current_pc;\n  *pifsr_ptr = pifsr;\n"]], "pred": {"ppl": 2.1456525325775146, "ppl_lower": 2.2120165824890137, "ppl/lowercase_ppl": -1.039899291126169, "ppl/zlib": 0.000929894905126732, "Min_5.0% Prob": 7.224240688567466, "Min_10.0% Prob": 5.345609614723607, "Min_20.0% Prob": 3.4573845640609138, "Min_30.0% Prob": 2.4808663013734313, "Min_40.0% Prob": 1.8996269056867612, "Min_50.0% Prob": 1.5238615709607404, "Min_60.0% Prob": 1.2720231148291985}}
{"hexsha": "a9e3f9e83ada8037345117c59ce712257ef64c7b", "ext": "c", "lang": "C", "content": "int BTCLUI_TextArea_HandleInput2(int ox, int oy,\n\tBTCLUI_InputState *state, BTCLUI_Form *form, BTCLUI_Widget *obj)\n{\n\tint cx, cy;\n\tint i, j, k;\n\tunsigned short *ks;\n\tchar *s, *s2, *b, *t;\n\tvoid *p;\n\tint ch;\n\n//\tif(BTCLUI_KeyDown(K_SHIFT))printf(\"shift a1\\n\");\n\n\tch=0;\n\tks=state->keys;\n\twhile(*ks)\n\t{\n\t\tif((*ks=='x') && BTCLUI_KeyDown(state, K_CTRL))\n\t\t{\n\t\t\tch=1;\n\t\t\tb=BTCLUI_TextArea_FlattenSelection(obj);\n\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n//\t\t\tBTCLUI_ClipBoard_Export(b);\n\t\t}\n\t\tif((*ks=='c') && BTCLUI_KeyDown(state, K_CTRL))\n\t\t{\n\t\t\tb=BTCLUI_TextArea_FlattenSelection(obj);\n//\t\t\tBTCLUI_ClipBoard_Export(b);\n\t\t}\n\t\tif(((*ks=='v') && BTCLUI_KeyDown(state, K_CTRL)) ||\n\t\t\t((*ks==K_INS) && BTCLUI_KeyDown(state, K_SHIFT)))\n\t\t{\n\t\t\tch=1;\n//\t\t\tb=BTCLUI_ClipBoard_Import(\"string_t\");\n\t\t\tif(b)BTCLUI_TextArea_Insert(obj, &obj->cxpos,\n\t\t\t\t&obj->cypos, b);\n\t\t\tif(obj->cxpos<0)obj->cxpos=0;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\t\t}\n\n\t\tif(BTCLUI_KeyDown(state, K_CTRL) || BTCLUI_KeyDown(state, K_ALT))\n\t\t{\n\t\t\tif(obj->cxpos<obj->wxpos)\n\t\t\t\tobj->wxpos=obj->cxpos;\n\t\t\twhile(obj->cxpos>=(obj->wxpos+obj->cols))\n\t\t\t\tobj->wxpos++;\n\t\t\tif(obj->cypos<obj->wypos)\n\t\t\t\tobj->wypos=obj->cypos;\n\t\t\twhile(obj->cypos>=(obj->wypos+obj->rows))\n\t\t\t\tobj->wypos++;\n\n\t\t\tks++;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif((*ks<127) && (*ks>=' '))\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s++=*ks;\n\t\t\tstrcpy(s, b);\n\n\t\t\tobj->cxpos++;\n\t\t}\n\t\tif((*ks=='\\b') && (obj->sxpos<0))\n\t\t{\n\t\t\tch=1;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\tif(obj->cxpos>0)\n\t\t\t{\n\t\t\t\ts+=obj->cxpos;\n\t\t\t\tb=gcralloc(512);\n\t\t\t\tstrcpy(b, s);\n\t\t\t\ts--;\n\t\t\t\tstrcpy(s, b);\n\t\t\t\tobj->cxpos--;\n\t\t\t}else if(obj->cypos>0)\n\t\t\t{\n\t\t\t\ts2=obj->bufptrs[obj->cypos-1];\n\t\t\t\tif(!s2)\n\t\t\t\t{\n\t\t\t\t\ts2=gcalloc(512);\n\t\t\t\t\tobj->bufptrs[obj->cypos-1]=s2;\n\t\t\t\t}\n\n\t\t\t\tobj->cxpos=strlen(s2);\n\t\t\t\tobj->cypos--;\n\t\t\t\tstrcat(s2, s);\n\n\t\t\t\tfor(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)\n\t\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i+1];\n\t\t\t}\n\t\t}\n\t\tif((*ks==K_DEL) && (obj->sxpos<0))\n\t\t{\n\t\t\tch=1;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\tif(obj->cxpos<strlen(s))\n\t\t\t{\n\t\t\t\ts+=obj->cxpos;\n\t\t\t\tb=gcralloc(512);\n\t\t\t\tstrcpy(b, s+1);\n\t\t\t\tstrcpy(s, b);\n\t\t\t}else\n\t\t\t{\n\t\t\t\ts2=obj->bufptrs[obj->cypos+1];\n\t\t\t\tif(!s2)\n\t\t\t\t{\n\t\t\t\t\ts2=gcalloc(512);\n\t\t\t\t\tobj->bufptrs[obj->cypos+1]=s2;\n\t\t\t\t}\n\n\t\t\t\tstrcat(s, s2);\n\n\t\t\t\tfor(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)\n\t\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i+1];\n\t\t\t}\n\t\t}\n\t\tif(((*ks=='\\b') || (*ks==K_DEL)) && (obj->sxpos>=0))\n\t\t{\n\t\t\tch=1;\n\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t}\n\t\tif(*ks=='\\r')\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s=0;\n\n\t\t\tfor(i=(obj->nbufptrs-1); i>(obj->cypos+1); i--)\n\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i-1];\n\n\t\t\ts2=gcalloc(512);\n\t\t\tobj->bufptrs[obj->cypos+1]=s2;\n\t\t\tstrcpy(s2, b);\n\n\t\t\tobj->cxpos=0;\n\t\t\tobj->cypos++;\n\t\t}\n\t\tif(*ks=='\\t')\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s++='\\t';\n\t\t\tstrcpy(s, b);\n\n\t\t\tobj->cxpos++;\n\t\t}\n\t\tif(*ks==K_HOME)\n\t\t{\n//\t\t\tBTCLUI_TextArea_HandleSelect(obj);\n\t\t\tobj->cxpos=0;\n\t\t\tobj->wxpos=0;\n\t\t}\n\t\tif(*ks==K_END)\n\t\t{\n//\t\t\tBTCLUI_TextArea_HandleSelect(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tobj->cxpos=0;\n\t\t\tif(s)obj->cxpos=strlen(s);\n\t\t}\n\t\tif(*ks==K_UPARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos--;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t\tobj->cxpos=strlen(s);\n\t\t\t}else obj->cxpos=0;\n\t\t}\n\t\tif(*ks==K_DOWNARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos++;\n\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t\tobj->cxpos=strlen(s);\n\t\t\t}else obj->cxpos=0;\n\t\t}\n\t\tif(*ks==K_LEFTARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cxpos--;\n\t\t\tif(obj->cxpos<0)\n\t\t\t{\n\t\t\t\tobj->cypos--;\n\t\t\t\tobj->cxpos=0;\n\t\t\t\tif(obj->cypos>=0)\n\t\t\t\t{\n\t\t\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\t\t\tif(s)obj->cxpos=strlen(s);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tobj->cypos=0;\n\t\t\t\t\tobj->cxpos=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(*ks==K_RIGHTARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tobj->cxpos++;\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t{\n\t\t\t\t\tobj->cypos++;\n\t\t\t\t\tobj->cxpos=0;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tobj->cypos++;\n\t\t\t\tobj->cxpos=0;\n\t\t\t}\n\t\t}\n\t\tif(*ks==K_PGUP)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos-=obj->rows;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\t\t}\n\t\tif(*ks==K_PGDN)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos+=obj->rows;\n\t\t}\n\n\t\tif(obj->cxpos<obj->wxpos)\n\t\t\tobj->wxpos=obj->cxpos;\n\t\twhile(obj->cxpos>=(obj->wxpos+obj->cols))\n\t\t\tobj->wxpos++;\n\t\tif(obj->cypos<obj->wypos)\n\t\t\tobj->wypos=obj->cypos;\n\t\twhile(obj->cypos>=(obj->wypos+obj->rows))\n\t\t\tobj->wypos++;\n\n\t\tks++;\n\t}\n\n//\tp=NULL;\n//\tif(ch)BTCLUI_Forms_Message(obj->form, obj->id, \"changed\", 0, &p);\n\n\tif(ch)BTCLUI_Widget_AddEvent(obj, \"changed\");\n\treturn(0);\n}", "item_id": 4, "repo": "cr88192/bgbtech_engine", "file": "btgecl/base/cluiw_textarea.c", "last_update_at": "2019-07-02T22:53:52+00:00", "question_id": "a9e3f9e83ada8037345117c59ce712257ef64c7b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int BTCLUI_TextArea_HandleInput2(int ox, int oy,\n\tBTCLUI_InputState *state, BTCLUI_Form *form, BTCLUI_Widget *obj)\n{\n\tint cx, cy;\n\tint i, j, k;\n\tunsigned short *ks;\n\tchar *s, *s2, *b, *t;\n\tvoid *p;\n\tint ch;\n//\tif(BTCLUI_KeyDown(K_SHIFT))printf(\"shift a1\\n\");\n\tch=0;\n\tks=state->keys;\n\twhile(*ks)\n\t{\n\t\tif((*ks=='x') && BTCLUI_KeyDown(state, K_CTRL))\n\t\t{\n\t\t\tch=1;\n\t\t\tb=BTCLUI_TextArea_FlattenSelection(obj);\n\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n//\t\t\tBTCLUI_ClipBoard_Export(b);\n\t\t}\n\t\tif((*ks=='c') && BTCLUI_KeyDown(state, K_CTRL))\n\t\t{\n\t\t\tb=BTCLUI_TextArea_FlattenSelection(obj);\n//\t\t\tBTCLUI_ClipBoard_Export(b);\n\t\t}\n\t\tif(((*ks=='v') && BTCLUI_KeyDown(state, K_CTRL)) ||\n\t\t\t((*ks==K_INS) && BTCLUI_KeyDown(state, K_SHIFT)))\n\t\t{\n\t\t\tch=1;\n//\t\t\tb=BTCLUI_ClipBoard_Import(\"string_t\");\n\t\t\tif(b)BTCLUI_TextArea_Insert(obj, &obj->cxpos,\n\t\t\t\t&obj->cypos, b);\n\t\t\tif(obj->cxpos<0)obj->cxpos=0;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\t\t}\n\t\tif(BTCLUI_KeyDown(state, K_CTRL) || BTCLUI_KeyDown(state, K_ALT))\n\t\t{\n\t\t\tif(obj->cxpos<obj->wxpos)\n\t\t\t\tobj->wxpos=obj->cxpos;\n\t\t\twhile(obj->cxpos>=(obj->wxpos+obj->cols))\n\t\t\t\tobj->wxpos++;\n\t\t\tif(obj->cypos<obj->wypos)\n\t\t\t\tobj->wypos=obj->cypos;\n\t\t\twhile(obj->cypos>=(obj->wypos+obj->rows))\n\t\t\t\tobj->wypos++;\n\t\t\tks++;\n\t\t\tcontinue;\n\t\t}\n\t\tif((*ks<127) && (*ks>=' '))\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s++=*ks;\n\t\t\tstrcpy(s, b);\n\t\t\tobj->cxpos++;\n\t\t}\n\t\tif((*ks=='\\b') && (obj->sxpos<0))\n\t\t{\n\t\t\tch=1;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\tif(obj->cxpos>0)\n\t\t\t{\n\t\t\t\ts+=obj->cxpos;\n\t\t\t\tb=gcralloc(512);\n\t\t\t\tstrcpy(b, s);\n\t\t\t\ts--;\n\t\t\t\tstrcpy(s, b);\n\t\t\t\tobj->cxpos--;\n\t\t\t}else if(obj->cypos>0)\n\t\t\t{\n\t\t\t\ts2=obj->bufptrs[obj->cypos-1];\n\t\t\t\tif(!s2)\n\t\t\t\t{\n\t\t\t\t\ts2=gcalloc(512);\n\t\t\t\t\tobj->bufptrs[obj->cypos-1]=s2;\n\t\t\t\t}\n\t\t\t\tobj->cxpos=strlen(s2);\n\t\t\t\tobj->cypos--;\n\t\t\t\tstrcat(s2, s);\n\t\t\t\tfor(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)\n\t\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i+1];\n\t\t\t}\n\t\t}\n\t\tif((*ks==K_DEL) && (obj->sxpos<0))\n\t\t{\n\t\t\tch=1;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\tif(obj->cxpos<strlen(s))\n\t\t\t{\n\t\t\t\ts+=obj->cxpos;\n\t\t\t\tb=gcralloc(512);\n\t\t\t\tstrcpy(b, s+1);\n\t\t\t\tstrcpy(s, b);\n\t\t\t}else\n\t\t\t{\n\t\t\t\ts2=obj->bufptrs[obj->cypos+1];\n\t\t\t\tif(!s2)\n\t\t\t\t{\n\t\t\t\t\ts2=gcalloc(512);\n\t\t\t\t\tobj->bufptrs[obj->cypos+1]=s2;\n\t\t\t\t}\n\t\t\t\tstrcat(s, s2);\n\t\t\t\tfor(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)\n\t\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i+1];\n\t\t\t}\n\t\t}\n\t\tif(((*ks=='\\b') || (*ks==K_DEL)) && (obj->sxpos>=0))\n\t\t{\n\t\t\tch=1;\n\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t}\n\t\tif(*ks=='\\r')\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s=0;\n\t\t\tfor(i=(obj->nbufptrs-1); i>(obj->cypos+1); i--)\n\t\t\t\tobj->bufptrs[i]=obj->bufptrs[i-1];\n\t\t\ts2=gcalloc(512);\n\t\t\tobj->bufptrs[obj->cypos+1]=s2;\n\t\t\tstrcpy(s2, b);\n\t\t\tobj->cxpos=0;\n\t\t\tobj->cypos++;\n\t\t}\n\t\tif(*ks=='\\t')\n\t\t{\n\t\t\tch=1;\n\t\t\tif(obj->sxpos>=0)\n\t\t\t\tBTCLUI_TextArea_DeleteSelection(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(!s)\n\t\t\t{\n\t\t\t\ts=gcalloc(512);\n\t\t\t\tobj->bufptrs[obj->cypos]=s;\n\t\t\t}\n\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\tobj->cxpos=strlen(s);\n\t\t\ts+=obj->cxpos;\n\t\t\tb=gcralloc(512);\n\t\t\tstrcpy(b, s);\n\t\t\t*s++='\\t';\n\t\t\tstrcpy(s, b);\n\t\t\tobj->cxpos++;\n\t\t}\n\t\tif(*ks==K_HOME)\n\t\t{\n//\t\t\tBTCLUI_TextArea_HandleSelect(obj);\n\t\t\tobj->cxpos=0;\n\t\t\tobj->wxpos=0;\n\t\t}\n\t\tif(*ks==K_END)\n\t\t{\n//\t\t\tBTCLUI_TextArea_HandleSelect(obj);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tobj->cxpos=0;\n\t\t\tif(s)obj->cxpos=strlen(s);\n\t\t}\n\t\tif(*ks==K_UPARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos--;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t\tobj->cxpos=strlen(s);\n\t\t\t}else obj->cxpos=0;\n\t\t}\n\t\tif(*ks==K_DOWNARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos++;\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t\tobj->cxpos=strlen(s);\n\t\t\t}else obj->cxpos=0;\n\t\t}\n\t\tif(*ks==K_LEFTARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cxpos--;\n\t\t\tif(obj->cxpos<0)\n\t\t\t{\n\t\t\t\tobj->cypos--;\n\t\t\t\tobj->cxpos=0;\n\t\t\t\tif(obj->cypos>=0)\n\t\t\t\t{\n\t\t\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\t\t\tif(s)obj->cxpos=strlen(s);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tobj->cypos=0;\n\t\t\t\t\tobj->cxpos=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(*ks==K_RIGHTARROW)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\ts=obj->bufptrs[obj->cypos];\n\t\t\tobj->cxpos++;\n\t\t\tif(s)\n\t\t\t{\n\t\t\t\tif(obj->cxpos>strlen(s))\n\t\t\t\t{\n\t\t\t\t\tobj->cypos++;\n\t\t\t\t\tobj->cxpos=0;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tobj->cypos++;\n\t\t\t\tobj->cxpos=0;\n\t\t\t}\n\t\t}\n\t\tif(*ks==K_PGUP)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos-=obj->rows;\n\t\t\tif(obj->cypos<0)obj->cypos=0;\n\t\t}\n\t\tif(*ks==K_PGDN)\n\t\t{\n\t\t\tBTCLUI_TextArea_HandleSelect(obj, state);\n\t\t\tobj->cypos+=obj->rows;\n\t\t}\n\t\tif(obj->cxpos<obj->wxpos)\n\t\t\tobj->wxpos=obj->cxpos;\n\t\twhile(obj->cxpos>=(obj->wxpos+obj->cols))\n\t\t\tobj->wxpos++;\n\t\tif(obj->cypos<obj->wypos)\n\t\t\tobj->wypos=obj->cypos;\n\t\twhile(obj->cypos>=(obj->wypos+obj->rows))\n\t\t\tobj->wypos++;\n\t\tks++;\n\t}\n//\tp=NULL;\n//\tif(ch)BTCLUI_Forms_Message(obj->form, obj->id, \"changed\", 0, &p);\n\tif(ch)BTCLUI_Widget_AddEvent(obj, \"changed\");\n\treturn(0);\n"]], "pred": {"ppl": 1.7180843353271484, "ppl_lower": 1.8502253293991089, "ppl/lowercase_ppl": -1.1369108698029131, "ppl/zlib": 0.0004574893589219721, "Min_5.0% Prob": 5.4289223399816775, "Min_10.0% Prob": 3.8548404223778667, "Min_20.0% Prob": 2.461485652362599, "Min_30.0% Prob": 1.7631365863813295, "Min_40.0% Prob": 1.3446402550745564, "Min_50.0% Prob": 1.0813548300276763, "Min_60.0% Prob": 0.9026514335036381}}
{"hexsha": "8cca39ab8308063739921cad55dc77c9c9d3e989", "ext": "c", "lang": "C", "content": "static int queue_create(void)\n{\n\tASSERT(queue_init(NULL, buffer, 16, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, NULL, 16, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, buffer, 0, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, buffer, 16, 0) == -1);\n\n\tASSERT(queue_init(&queue, buffer, 16, sizeof(char)) == 0);\n\n\tASSERT(queue.buf == buffer);\n\tASSERT(queue.capacity == 16);\n\tASSERT(queue.item_size == sizeof(char));\n\tASSERT(queue.count == 0);\n\tASSERT(queue.get == NULL);\n\tASSERT(queue.put == NULL);\n\n\treturn 0;\n}", "item_id": 0, "repo": "marcinbor85/iotools", "file": "src/tests/test_queue.c", "last_update_at": "2019-11-18T19:57:58+00:00", "question_id": "8cca39ab8308063739921cad55dc77c9c9d3e989_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int queue_create(void)\n{\n\tASSERT(queue_init(NULL, buffer, 16, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, NULL, 16, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, buffer, 0, sizeof(char)) == -1);\n\tASSERT(queue_init(&queue, buffer, 16, 0) == -1);\n\tASSERT(queue_init(&queue, buffer, 16, sizeof(char)) == 0);\n\tASSERT(queue.buf == buffer);\n\tASSERT(queue.capacity == 16);\n\tASSERT(queue.item_size == sizeof(char));\n\tASSERT(queue.count == 0);\n\tASSERT(queue.get == NULL);\n\tASSERT(queue.put == NULL);\n\treturn 0;\n"]], "pred": {"ppl": 1.6635761260986328, "ppl_lower": 1.7735517024993896, "ppl/lowercase_ppl": -1.125772879826786, "ppl/zlib": 0.0026508832189450697, "Min_5.0% Prob": 5.889670085906983, "Min_10.0% Prob": 4.016980210940043, "Min_20.0% Prob": 2.4377882653890652, "Min_30.0% Prob": 1.6767815992236137, "Min_40.0% Prob": 1.2655018458421203, "Min_50.0% Prob": 1.0140378185453902, "Min_60.0% Prob": 0.8520115701624981}}
{"hexsha": "06fa456587a770cb16116fb3b937d47747efbc58", "ext": "h", "lang": "C", "content": "namespace DispSvr\n{\n\tclass CIntelFastCompositingMixer :\n\t\tpublic virtual BASE_VIDEO_MIXER,\n\t\tpublic virtual CD3D9VideoPresenter\n\t{\n\tpublic:\n\t\tCIntelFastCompositingMixer();\n\t\tvirtual ~CIntelFastCompositingMixer();\n\n\t\t// IUnkonwn\n\t\tSTDMETHOD(QueryInterface)(REFIID riid, void **ppv);\n\t\tSTDMETHOD_(ULONG, AddRef)() { return CD3D9PluginBase::AddRef();\t}\n\t\tSTDMETHOD_(ULONG, Release)() { return CD3D9PluginBase::Release(); }\n\n\t\t// IDispSvrPlugin\n\t\tSTDMETHOD(ProcessMessage)(RESOURCE_MESSAGE_TYPE msg, LPVOID ulParam);\n\n\t\t// CD3D9VideoPresenterBase\n\t\tSTDMETHOD(SetDisplayRect)(const RECT *rcDst, const RECT *rcSrc);\n\t\tSTDMETHOD(Present)(const PresentHints *pHints);\n\t\tSTDMETHOD(SetScreenCaptureDefense)(BOOL bEnable);\n\t\tSTDMETHOD(SetBackgroundColor)(COLORREF Color);\n\t\tSTDMETHOD(SetGamutMetadata)(const DWORD dwFormat, void *pGamutMetadata);\n\n\tprivate:\n\t\t// CD3D9VideoMixerBase\n\t\tSTDMETHOD(_QueryPlaneCaps)(PLANE_ID PlaneID, PLANE_FORMAT Format, PlaneCaps *pCap);\n\t\tSTDMETHOD(_CreatePlane)(DispSvr::PlaneInit *pInit);\n\t\tSTDMETHOD(_Execute)(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tSTDMETHOD(_SetDevice)(IUnknown *pDevice);\n\t\tSTDMETHOD(_ReleaseDevice)();\n\t\tSTDMETHOD(_QueryCaps)(PresenterCaps* pCaps);\n\n\t\tHRESULT ExecuteFastCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT ExecuteD3DCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT QueryCaps(FASTCOMP_CAPS **ppCaps);\n\t\tHRESULT QueryFormats(FASTCOMP_SAMPLE_FORMATS **ppFormats);\n\n\t\tHRESULT FastCompositingBlt(const FASTCOMP_BLT_PARAMS &blt);\n\t\tHRESULT PlaneToSample(PLANE_ID id, FASTCOMP_VideoSample &sample, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT CheckAndUpdateClearRects(const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT UnscrambleSurface(IDirect3DSurface9 *pRT, IDirect3DSurface9 *pSurface, ContentProtection &protection);\n\n\tprotected:\n\t\tFASTCOMP_ClearRect *m_pClearRect;\n\t\tUINT m_uClearRect;\n\t\tRECT m_rcClip;\n\t\tDXVA2_AYUVSample16 m_ayuv16BackgroundColor;\n\n\t\tCIntelSCDService *m_pSCDService;\n\t\tCIntelFastCompositingService *m_pFastCompService;\n\t\tCIntelRegistrationDevice *m_pRegistrationDevice;\n\t\tIDriverExtensionAdapter *m_pDeviceCap;\n\t}", "item_id": 0, "repo": "goodspeed24e/2011Corel", "file": "Video/Render/Core/DispSvr/Main/IntelFastCompositingMixer.h", "last_update_at": "2019-07-24T07:59:07+00:00", "question_id": "06fa456587a770cb16116fb3b937d47747efbc58_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace DispSvr\n{\n\tclass CIntelFastCompositingMixer :\n\t\tpublic virtual BASE_VIDEO_MIXER,\n\t\tpublic virtual CD3D9VideoPresenter\n\t{\n\tpublic:\n\t\tCIntelFastCompositingMixer();\n\t\tvirtual ~CIntelFastCompositingMixer();\n\t\t// IUnkonwn\n\t\tSTDMETHOD(QueryInterface)(REFIID riid, void **ppv);\n\t\tSTDMETHOD_(ULONG, AddRef)() { return CD3D9PluginBase::AddRef();\t}\n\t\tSTDMETHOD_(ULONG, Release)() { return CD3D9PluginBase::Release(); }\n\t\t// IDispSvrPlugin\n\t\tSTDMETHOD(ProcessMessage)(RESOURCE_MESSAGE_TYPE msg, LPVOID ulParam);\n\t\t// CD3D9VideoPresenterBase\n\t\tSTDMETHOD(SetDisplayRect)(const RECT *rcDst, const RECT *rcSrc);\n\t\tSTDMETHOD(Present)(const PresentHints *pHints);\n\t\tSTDMETHOD(SetScreenCaptureDefense)(BOOL bEnable);\n\t\tSTDMETHOD(SetBackgroundColor)(COLORREF Color);\n\t\tSTDMETHOD(SetGamutMetadata)(const DWORD dwFormat, void *pGamutMetadata);\n\tprivate:\n\t\t// CD3D9VideoMixerBase\n\t\tSTDMETHOD(_QueryPlaneCaps)(PLANE_ID PlaneID, PLANE_FORMAT Format, PlaneCaps *pCap);\n\t\tSTDMETHOD(_CreatePlane)(DispSvr::PlaneInit *pInit);\n\t\tSTDMETHOD(_Execute)(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tSTDMETHOD(_SetDevice)(IUnknown *pDevice);\n\t\tSTDMETHOD(_ReleaseDevice)();\n\t\tSTDMETHOD(_QueryCaps)(PresenterCaps* pCaps);\n\t\tHRESULT ExecuteFastCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT ExecuteD3DCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT QueryCaps(FASTCOMP_CAPS **ppCaps);\n\t\tHRESULT QueryFormats(FASTCOMP_SAMPLE_FORMATS **ppFormats);\n\t\tHRESULT FastCompositingBlt(const FASTCOMP_BLT_PARAMS &blt);\n\t\tHRESULT PlaneToSample(PLANE_ID id, FASTCOMP_VideoSample &sample, const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT CheckAndUpdateClearRects(const RECT &rcDst, const RECT &rcDstClip);\n\t\tHRESULT UnscrambleSurface(IDirect3DSurface9 *pRT, IDirect3DSurface9 *pSurface, ContentProtection &protection);\n\tprotected:\n\t\tFASTCOMP_ClearRect *m_pClearRect;\n\t\tUINT m_uClearRect;\n\t\tRECT m_rcClip;\n\t\tDXVA2_AYUVSample16 m_ayuv16BackgroundColor;\n\t\tCIntelSCDService *m_pSCDService;\n\t\tCIntelFastCompositingService *m_pFastCompService;\n\t\tCIntelRegistrationDevice *m_pRegistrationDevice;\n\t\tIDriverExtensionAdapter *m_pDeviceCap;\n"]], "pred": {"ppl": 2.1076323986053467, "ppl_lower": 3.81158447265625, "ppl/lowercase_ppl": -1.7946719055924774, "ppl/zlib": 0.0008609298285325135, "Min_5.0% Prob": 7.189287692942518, "Min_10.0% Prob": 5.2911711692810055, "Min_20.0% Prob": 3.381427525846582, "Min_30.0% Prob": 2.4001038727852015, "Min_40.0% Prob": 1.8437971989783088, "Min_50.0% Prob": 1.4852988813501984, "Min_60.0% Prob": 1.2420317682867439}}
{"hexsha": "a0ab78a0a08505c1c50a9da2913a67009f5efd5d", "ext": "c", "lang": "C", "content": "void *\n__inhibit_loop_to_libcall\nmemcpy(void *__restrict aa, const void *__restrict bb, size_t n)\n{\n  #define BODY(a, b, t) { \\\n    t tt = *b; \\\n    a++, b++; \\\n    *(a - 1) = tt; \\\n  }\n\n  char *a = (char *)aa;\n  const char *b = (const char *)bb;\n  char *end = a + n;\n  uintptr_t msk = sizeof (long) - 1;\n  if (unlikely ((((uintptr_t)a & msk) != ((uintptr_t)b & msk))\n\t       || n < sizeof (long)))\n    {\nsmall:\n      if (__builtin_expect (a < end, 1))\n\twhile (a < end)\n\t  BODY (a, b, char);\n      return aa;\n    }\n\n  if (unlikely (((uintptr_t)a & msk) != 0))\n    while ((uintptr_t)a & msk)\n      BODY (a, b, char);\n\n  long *la = (long *)a;\n  const long *lb = (const long *)b;\n  long *lend = (long *)((uintptr_t)end & ~msk);\n\n  if (unlikely (la < (lend - 8)))\n    {\n      while (la < (lend - 8))\n\t{\n\t  long b0 = *lb++;\n\t  long b1 = *lb++;\n\t  long b2 = *lb++;\n\t  long b3 = *lb++;\n\t  long b4 = *lb++;\n\t  long b5 = *lb++;\n\t  long b6 = *lb++;\n\t  long b7 = *lb++;\n\t  long b8 = *lb++;\n\t  *la++ = b0;\n\t  *la++ = b1;\n\t  *la++ = b2;\n\t  *la++ = b3;\n\t  *la++ = b4;\n\t  *la++ = b5;\n\t  *la++ = b6;\n\t  *la++ = b7;\n\t  *la++ = b8;\n\t}\n    }\n\n  while (la < lend)\n    BODY (la, lb, long);\n\n  a = (char *)la;\n  b = (const char *)lb;\n  if (unlikely (a < end))\n    goto small;\n  return aa;\n}", "item_id": 0, "repo": "briancostabile/tiva-bsp", "file": "third_party/newlib/newlib-3.0.0.20180831/newlib/libc/machine/riscv/memcpy.c", "last_update_at": "2019-06-20T09:21:45+00:00", "question_id": "a0ab78a0a08505c1c50a9da2913a67009f5efd5d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *\n__inhibit_loop_to_libcall\nmemcpy(void *__restrict aa, const void *__restrict bb, size_t n)\n{\n  #define BODY(a, b, t) { \\\n    t tt = *b; \\\n    a++, b++; \\\n    *(a - 1) = tt; \\\n  }\n  char *a = (char *)aa;\n  const char *b = (const char *)bb;\n  char *end = a + n;\n  uintptr_t msk = sizeof (long) - 1;\n  if (unlikely ((((uintptr_t)a & msk) != ((uintptr_t)b & msk))\n\t       || n < sizeof (long)))\n    {\nsmall:\n      if (__builtin_expect (a < end, 1))\n\twhile (a < end)\n\t  BODY (a, b, char);\n      return aa;\n    }\n  if (unlikely (((uintptr_t)a & msk) != 0))\n    while ((uintptr_t)a & msk)\n      BODY (a, b, char);\n  long *la = (long *)a;\n  const long *lb = (const long *)b;\n  long *lend = (long *)((uintptr_t)end & ~msk);\n  if (unlikely (la < (lend - 8)))\n    {\n      while (la < (lend - 8))\n\t{\n\t  long b0 = *lb++;\n\t  long b1 = *lb++;\n\t  long b2 = *lb++;\n\t  long b3 = *lb++;\n\t  long b4 = *lb++;\n\t  long b5 = *lb++;\n\t  long b6 = *lb++;\n\t  long b7 = *lb++;\n\t  long b8 = *lb++;\n\t  *la++ = b0;\n\t  *la++ = b1;\n\t  *la++ = b2;\n\t  *la++ = b3;\n\t  *la++ = b4;\n\t  *la++ = b5;\n\t  *la++ = b6;\n\t  *la++ = b7;\n\t  *la++ = b8;\n\t}\n    }\n  while (la < lend)\n    BODY (la, lb, long);\n  a = (char *)la;\n  b = (const char *)lb;\n  if (unlikely (a < end))\n    goto small;\n  return aa;\n"]], "pred": {"ppl": 1.8307996988296509, "ppl_lower": 1.8491795063018799, "ppl/lowercase_ppl": -1.0165177643321763, "ppl/zlib": 0.0012417923312018247, "Min_5.0% Prob": 6.1998932976876535, "Min_10.0% Prob": 4.487969102398042, "Min_20.0% Prob": 2.8173445367044017, "Min_30.0% Prob": 1.972657826238422, "Min_40.0% Prob": 1.5026304454752994, "Min_50.0% Prob": 1.2073471410590555, "Min_60.0% Prob": 1.0074109491661831}}
{"hexsha": "b76d88a5ae35835cdc06dc1b5a481db684518e29", "ext": "c", "lang": "C", "content": "struct mcap_mdl *mcap_mdl_ref(struct mcap_mdl *mdl)\n{\n\tmdl->ref++;\n\n\tDBG(\"mcap_mdl_ref(%p): ref=%d\", mdl, mdl->ref);\n\n\treturn mdl;\n}", "item_id": 65, "repo": "sinban04/opel-alpha", "file": "dep/bluez-4.101/health/mcap.c", "last_update_at": "2019-02-26T00:14:55+00:00", "question_id": "b76d88a5ae35835cdc06dc1b5a481db684518e29_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct mcap_mdl *mcap_mdl_ref(struct mcap_mdl *mdl)\n{\n\tmdl->ref++;\n\tDBG(\"mcap_mdl_ref(%p): ref=%d\", mdl, mdl->ref);\n\treturn mdl;\n"]], "pred": {"ppl": 2.3408191204071045, "ppl_lower": 2.5577480792999268, "ppl/lowercase_ppl": -1.1042048200439938, "ppl/zlib": 0.009244575212738271, "Min_5.0% Prob": 9.011587460835775, "Min_10.0% Prob": 6.253956249782017, "Min_20.0% Prob": 3.896175307886941, "Min_30.0% Prob": 2.7809308064835414, "Min_40.0% Prob": 2.1244384114231383, "Min_50.0% Prob": 1.715230101985591, "Min_60.0% Prob": 1.434986524416932}}
{"hexsha": "d0a71d599ac944a2689248ec5fac64ad05769501", "ext": "h", "lang": "C", "content": "static inline __opal_attribute_always_inline__ int mca_coll_ml_task_completion_processing(\n        mca_coll_ml_task_status_t **task_status_g, opal_list_t *list)\n{\n    /* local variables */\n    int ret = OMPI_SUCCESS;\n    mca_coll_ml_task_status_t *task_status = *task_status_g;\n\n    mca_coll_ml_collective_operation_progress_t *coll_op =\n        task_status->ml_coll_operation;\n\n    /* Pasha: Since all our collectives so far use the root\n       flag, I replacing the call for custom call back function\n       with setting root_flag.\n       If we will see that we need some custom functionality,\n       we will enable it later.\n     */\n\n    task_status->ml_coll_operation->variable_fn_params.root_flag = true;\n\n#if 0\n    /* process task completion function,\n       if any was defined  */\n    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {\n        ret = task_status->task_comp_fn(task_status);\n        if (ret != OMPI_SUCCESS) {\n            return ret;\n        }\n    }\n#endif\n\n    /* update dependencies */\n    ret = coll_ml_task_dependency_processing(task_status);\n    if (ret != OMPI_SUCCESS) {\n        ML_VERBOSE(3,(\"Failed to coll_ml_task_dependency_processing\"));\n        return ret;\n    }\n\n    /* process task completion function,\n       if any was defined  */\n    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {\n        ret = task_status->task_comp_fn(task_status);\n        if (ret != OMPI_SUCCESS) {\n            ML_VERBOSE(3,(\"Failed to task_comp_fn\"));\n            return ret;\n        }\n    }\n\n    /* remove the descriptor from the incomplete list\n       (Pasha: if the list was provided) */\n    /* No need to put this an any new list - it is associcated\n     * with the mca_coll_ml_collective_operation_progress_t\n     * descriptor already\n     */\n\n    if (NULL != list) {\n        (*task_status_g) = (mca_coll_ml_task_status_t *)\n            opal_list_remove_item(list, (opal_list_item_t *)(task_status));\n    }\n\n    /* update completion counter */\n    coll_op->dag_description.num_tasks_completed++;\n\n    if(coll_op->dag_description.num_tasks_completed ==\n            coll_op->coll_schedule->n_fns)\n    {\n        /* the actual fragment descriptor is not on any list, as\n         * we can get at it from the task descriptors\n         */\n        ret = coll_ml_fragment_completion_processing(coll_op);\n        if (OMPI_SUCCESS != ret) {\n            ML_VERBOSE(3,(\"Failed to coll_ml_fragment_completion_processing\"));\n            return ret;\n        }\n    }\n\n    /* return */\n    return ret;\n}", "item_id": 4, "repo": "urids/XSCALAMPI", "file": "ompi/mca/coll/ml/coll_ml_inlines.h", "last_update_at": "2019-02-25T19:56:36+00:00", "question_id": "d0a71d599ac944a2689248ec5fac64ad05769501_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline __opal_attribute_always_inline__ int mca_coll_ml_task_completion_processing(\n        mca_coll_ml_task_status_t **task_status_g, opal_list_t *list)\n{\n    /* local variables */\n    int ret = OMPI_SUCCESS;\n    mca_coll_ml_task_status_t *task_status = *task_status_g;\n    mca_coll_ml_collective_operation_progress_t *coll_op =\n        task_status->ml_coll_operation;\n    /* Pasha: Since all our collectives so far use the root\n       flag, I replacing the call for custom call back function\n       with setting root_flag.\n       If we will see that we need some custom functionality,\n       we will enable it later.\n     */\n    task_status->ml_coll_operation->variable_fn_params.root_flag = true;\n#if 0\n    /* process task completion function,\n       if any was defined  */\n    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {\n        ret = task_status->task_comp_fn(task_status);\n        if (ret != OMPI_SUCCESS) {\n            return ret;\n        }\n    }\n#endif\n    /* update dependencies */\n    ret = coll_ml_task_dependency_processing(task_status);\n    if (ret != OMPI_SUCCESS) {\n        ML_VERBOSE(3,(\"Failed to coll_ml_task_dependency_processing\"));\n        return ret;\n    }\n    /* process task completion function,\n       if any was defined  */\n    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {\n        ret = task_status->task_comp_fn(task_status);\n        if (ret != OMPI_SUCCESS) {\n            ML_VERBOSE(3,(\"Failed to task_comp_fn\"));\n            return ret;\n        }\n    }\n    /* remove the descriptor from the incomplete list\n       (Pasha: if the list was provided) */\n    /* No need to put this an any new list - it is associcated\n     * with the mca_coll_ml_collective_operation_progress_t\n     * descriptor already\n     */\n    if (NULL != list) {\n        (*task_status_g) = (mca_coll_ml_task_status_t *)\n            opal_list_remove_item(list, (opal_list_item_t *)(task_status));\n    }\n    /* update completion counter */\n    coll_op->dag_description.num_tasks_completed++;\n    if(coll_op->dag_description.num_tasks_completed ==\n            coll_op->coll_schedule->n_fns)\n    {\n        /* the actual fragment descriptor is not on any list, as\n         * we can get at it from the task descriptors\n         */\n        ret = coll_ml_fragment_completion_processing(coll_op);\n        if (OMPI_SUCCESS != ret) {\n            ML_VERBOSE(3,(\"Failed to coll_ml_fragment_completion_processing\"));\n            return ret;\n        }\n    }\n    /* return */\n    return ret;\n"]], "pred": {"ppl": 2.6741695404052734, "ppl_lower": 2.8524351119995117, "ppl/lowercase_ppl": -1.065607588396407, "ppl/zlib": 0.0011836809626507457, "Min_5.0% Prob": 7.355424344539642, "Min_10.0% Prob": 5.760773167014122, "Min_20.0% Prob": 4.126268658787012, "Min_30.0% Prob": 3.113867693642775, "Min_40.0% Prob": 2.415932299656289, "Min_50.0% Prob": 1.9590849434942974, "Min_60.0% Prob": 1.6395791169341165}}
{"hexsha": "a5bddae798c536591ff5e3a6312b5122b8e1a99c", "ext": "c", "lang": "C", "content": "static void\nsc_mcch_ModificationPeriod_r13_14_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {\n\ttd->free_struct    = asn_DEF_NativeEnumerated.free_struct;\n\ttd->print_struct   = asn_DEF_NativeEnumerated.print_struct;\n\ttd->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;\n\ttd->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;\n\ttd->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;\n\ttd->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;\n\ttd->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;\n\ttd->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;\n\ttd->aper_decoder   = asn_DEF_NativeEnumerated.aper_decoder;\n\ttd->aper_encoder   = asn_DEF_NativeEnumerated.aper_encoder;\n\ttd->compare        = asn_DEF_NativeEnumerated.compare;\n\tif(!td->per_constraints)\n\t\ttd->per_constraints = asn_DEF_NativeEnumerated.per_constraints;\n\ttd->elements       = asn_DEF_NativeEnumerated.elements;\n\ttd->elements_count = asn_DEF_NativeEnumerated.elements_count;\n     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;\t// Defined explicitly */\n}", "item_id": 4, "repo": "ThomasValerrianPasca/UE_LWA", "file": "cmake_targets/lte_noS1_build_oai/build/CMakeFiles/Rel14/SystemInformationBlockType20-r13.c", "last_update_at": "2019-02-22T21:33:57+00:00", "question_id": "a5bddae798c536591ff5e3a6312b5122b8e1a99c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsc_mcch_ModificationPeriod_r13_14_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {\n\ttd->free_struct    = asn_DEF_NativeEnumerated.free_struct;\n\ttd->print_struct   = asn_DEF_NativeEnumerated.print_struct;\n\ttd->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;\n\ttd->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;\n\ttd->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;\n\ttd->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;\n\ttd->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;\n\ttd->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;\n\ttd->aper_decoder   = asn_DEF_NativeEnumerated.aper_decoder;\n\ttd->aper_encoder   = asn_DEF_NativeEnumerated.aper_encoder;\n\ttd->compare        = asn_DEF_NativeEnumerated.compare;\n\tif(!td->per_constraints)\n\t\ttd->per_constraints = asn_DEF_NativeEnumerated.per_constraints;\n\ttd->elements       = asn_DEF_NativeEnumerated.elements;\n\ttd->elements_count = asn_DEF_NativeEnumerated.elements_count;\n     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;\t// Defined explicitly */\n"]], "pred": {"ppl": 1.1567673683166504, "ppl_lower": 1.4255603551864624, "ppl/lowercase_ppl": -2.4347079445006967, "ppl/zlib": 0.0004790439587046639, "Min_5.0% Prob": 3.025462362356484, "Min_10.0% Prob": 1.4775248079570635, "Min_20.0% Prob": 0.7298991930254334, "Min_30.0% Prob": 0.48856287945686233, "Min_40.0% Prob": 0.36495075341459743, "Min_50.0% Prob": 0.29125882651378415, "Min_60.0% Prob": 0.24330056547167744}}
{"hexsha": "d665242e82072ab525b82ff385ab0ebed09c487f", "ext": "c", "lang": "C", "content": "static int test_platform_param(struct pxa_camera_dev *pcdev,\n\t\t\t       unsigned char buswidth, unsigned long *flags)\n{\n\t/*\n\t * Platform specified synchronization and pixel clock polarities are\n\t * only a recommendation and are only used during probing. The PXA270\n\t * quick capture interface supports both.\n\t */\n\t*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?\n\t\t  V4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |\n\t\tV4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\tV4L2_MBUS_HSYNC_ACTIVE_LOW |\n\t\tV4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\tV4L2_MBUS_VSYNC_ACTIVE_LOW |\n\t\tV4L2_MBUS_DATA_ACTIVE_HIGH |\n\t\tV4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\tV4L2_MBUS_PCLK_SAMPLE_FALLING;\n\n\t/* If requested data width is supported by the platform, use it */\n\tif ((1 << (buswidth - 1)) & pcdev->width_flags)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}", "item_id": 21, "repo": "xloem/DIY-LAPTOP", "file": "SOFTWARE/A64-TERES/linux-a64/drivers/media/platform/soc_camera/pxa_camera.c", "last_update_at": "2019-08-25T09:01:38+00:00", "question_id": "d665242e82072ab525b82ff385ab0ebed09c487f_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int test_platform_param(struct pxa_camera_dev *pcdev,\n\t\t\t       unsigned char buswidth, unsigned long *flags)\n{\n\t/*\n\t * Platform specified synchronization and pixel clock polarities are\n\t * only a recommendation and are only used during probing. The PXA270\n\t * quick capture interface supports both.\n\t */\n\t*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?\n\t\t  V4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |\n\t\tV4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\tV4L2_MBUS_HSYNC_ACTIVE_LOW |\n\t\tV4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\tV4L2_MBUS_VSYNC_ACTIVE_LOW |\n\t\tV4L2_MBUS_DATA_ACTIVE_HIGH |\n\t\tV4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\tV4L2_MBUS_PCLK_SAMPLE_FALLING;\n\t/* If requested data width is supported by the platform, use it */\n\tif ((1 << (buswidth - 1)) & pcdev->width_flags)\n\t\treturn 0;\n\treturn -EINVAL;\n"]], "pred": {"ppl": 2.3082876205444336, "ppl_lower": 2.9537439346313477, "ppl/lowercase_ppl": -1.2947588517883544, "ppl/zlib": 0.0019098309585272842, "Min_5.0% Prob": 6.634376441731172, "Min_10.0% Prob": 5.270567185738507, "Min_20.0% Prob": 3.737104212028393, "Min_30.0% Prob": 2.737854038627402, "Min_40.0% Prob": 2.0879917151254155, "Min_50.0% Prob": 1.6720333261673763, "Min_60.0% Prob": 1.3981457188742905}}
{"hexsha": "b865b19cc2945d501b3ee6ca87a635df6ece0f50", "ext": "c", "lang": "C", "content": "int\nmain(int argc, char **argv)\n{\n  const unsigned OneMil = 1 * 1000 * 1000;\n  uint64_t start = rdtsc();\n  Functor_t f = functor_init(test);\n  f.param[0].i = 35;\n  f.param[2].i = 13;\n\n  // asm review\n  api_call(f);\n  manual_call(f);\n\n  // Tests\n  for (int i = 0; i < OneMil; ++i) {\n    functor_invoke(f);\n  }\n  uint64_t end1 = rdtsc();\n  for (int i = 0; i < OneMil; ++i) {\n    test(35, 0, 13);\n  }\n  uint64_t end2 = rdtsc();\n  for (int i = 0; i < OneMil; ++i) {\n    getenv(\"USERFOO\");\n  }\n  uint64_t end3 = rdtsc();\n\n  puts(\"Performance timing\");\n  printf(\"%lu functor %lu indirect %lu direct\\n\", end1 - start, end2 - end1,\n         end3 - end2);\n\n  FuncPointer call_address[] = {\n      test_d,   test_i,   test_p,   test_dd,  test_di,  test_dp,  test_id,\n      test_ii,  test_ip,  test_pd,  test_pi,  test_pp,  test_ddd, test_ddi,\n      test_ddp, test_did, test_dii, test_dip, test_dpd, test_dpi, test_dpp,\n      test_idd, test_idi, test_idp, test_iid, test_iii, test_iip, test_ipd,\n      test_ipi, test_ipp, test_pdd, test_pdi, test_pdp, test_pid, test_pii,\n      test_pip, test_ppd, test_ppi, test_ppp,\n  };\n  const char *call_name[] = {\n      \"test_d\",   \"test_i\",   \"test_p\",   \"test_dd\",  \"test_di\",  \"test_dp\",\n      \"test_id\",  \"test_ii\",  \"test_ip\",  \"test_pd\",  \"test_pi\",  \"test_pp\",\n      \"test_ddd\", \"test_ddi\", \"test_ddp\", \"test_did\", \"test_dii\", \"test_dip\",\n      \"test_dpd\", \"test_dpi\", \"test_dpp\", \"test_idd\", \"test_idi\", \"test_idp\",\n      \"test_iid\", \"test_iii\", \"test_iip\", \"test_ipd\", \"test_ipi\", \"test_ipp\",\n      \"test_pdd\", \"test_pdi\", \"test_pdp\", \"test_pid\", \"test_pii\", \"test_pip\",\n      \"test_ppd\", \"test_ppi\", \"test_ppp\",\n  };\n  clear_result();\n  for (int j = 0; j < ARRAY_LENGTH(call_address); ++j) {\n    gf = (Functor_t){.call = call_address[j]};\n    printf(\"\\n\\nTesting call %s\\n\", call_name[j]);\n    for (int i = 0; i <= PARAM_COUNT; ++i) {\n      param_choose_n(\"dip\", i, global_result);\n    }\n  }\n\n  return 0;\n}", "item_id": 41, "repo": "rufeooo/craftsman_console", "file": "functor_test.c", "last_update_at": "2019-11-20T04:25:27+00:00", "question_id": "b865b19cc2945d501b3ee6ca87a635df6ece0f50_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nmain(int argc, char **argv)\n{\n  const unsigned OneMil = 1 * 1000 * 1000;\n  uint64_t start = rdtsc();\n  Functor_t f = functor_init(test);\n  f.param[0].i = 35;\n  f.param[2].i = 13;\n  // asm review\n  api_call(f);\n  manual_call(f);\n  // Tests\n  for (int i = 0; i < OneMil; ++i) {\n    functor_invoke(f);\n  }\n  uint64_t end1 = rdtsc();\n  for (int i = 0; i < OneMil; ++i) {\n    test(35, 0, 13);\n  }\n  uint64_t end2 = rdtsc();\n  for (int i = 0; i < OneMil; ++i) {\n    getenv(\"USERFOO\");\n  }\n  uint64_t end3 = rdtsc();\n  puts(\"Performance timing\");\n  printf(\"%lu functor %lu indirect %lu direct\\n\", end1 - start, end2 - end1,\n         end3 - end2);\n  FuncPointer call_address[] = {\n      test_d,   test_i,   test_p,   test_dd,  test_di,  test_dp,  test_id,\n      test_ii,  test_ip,  test_pd,  test_pi,  test_pp,  test_ddd, test_ddi,\n      test_ddp, test_did, test_dii, test_dip, test_dpd, test_dpi, test_dpp,\n      test_idd, test_idi, test_idp, test_iid, test_iii, test_iip, test_ipd,\n      test_ipi, test_ipp, test_pdd, test_pdi, test_pdp, test_pid, test_pii,\n      test_pip, test_ppd, test_ppi, test_ppp,\n  };\n  const char *call_name[] = {\n      \"test_d\",   \"test_i\",   \"test_p\",   \"test_dd\",  \"test_di\",  \"test_dp\",\n      \"test_id\",  \"test_ii\",  \"test_ip\",  \"test_pd\",  \"test_pi\",  \"test_pp\",\n      \"test_ddd\", \"test_ddi\", \"test_ddp\", \"test_did\", \"test_dii\", \"test_dip\",\n      \"test_dpd\", \"test_dpi\", \"test_dpp\", \"test_idd\", \"test_idi\", \"test_idp\",\n      \"test_iid\", \"test_iii\", \"test_iip\", \"test_ipd\", \"test_ipi\", \"test_ipp\",\n      \"test_pdd\", \"test_pdi\", \"test_pdp\", \"test_pid\", \"test_pii\", \"test_pip\",\n      \"test_ppd\", \"test_ppi\", \"test_ppp\",\n  };\n  clear_result();\n  for (int j = 0; j < ARRAY_LENGTH(call_address); ++j) {\n    gf = (Functor_t){.call = call_address[j]};\n    printf(\"\\n\\nTesting call %s\\n\", call_name[j]);\n    for (int i = 0; i <= PARAM_COUNT; ++i) {\n      param_choose_n(\"dip\", i, global_result);\n    }\n  }\n  return 0;\n"]], "pred": {"ppl": 1.944298267364502, "ppl_lower": 1.923546314239502, "ppl/lowercase_ppl": -0.9838613553675782, "ppl/zlib": 0.0009444618238400037, "Min_5.0% Prob": 7.238108317057292, "Min_10.0% Prob": 5.208619035614861, "Min_20.0% Prob": 3.167684934205479, "Min_30.0% Prob": 2.196856063162839, "Min_40.0% Prob": 1.6602724638922761, "Min_50.0% Prob": 1.330572472702091, "Min_60.0% Prob": 1.1092406749136798}}
{"hexsha": "4bb6740ddbe2534a1b61f1f0de202d9e45d444cd", "ext": "c", "lang": "C", "content": "static void print_pkt_binary(odp_packet_t pkt)\n{\n\tuint32_t i;\n\tuint8_t *pnt = odp_packet_data(pkt);\n\n\tOFP_LOG_NO_CTX_NO_LEVEL(\"PACKET:\\n\");\n\tfor (i = 0; i < odp_packet_len(pkt); i++)\n\t\tOFP_LOG_NO_CTX_NO_LEVEL(\"%02hhx \", pnt[i]);\n\tOFP_LOG_NO_CTX_NO_LEVEL(\"\\n\");\n}", "item_id": 3, "repo": "repu1sion/ofp", "file": "src/ofp_debug_print.c", "last_update_at": "2019-10-04T12:21:04+00:00", "question_id": "4bb6740ddbe2534a1b61f1f0de202d9e45d444cd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_pkt_binary(odp_packet_t pkt)\n{\n\tuint32_t i;\n\tuint8_t *pnt = odp_packet_data(pkt);\n\tOFP_LOG_NO_CTX_NO_LEVEL(\"PACKET:\\n\");\n\tfor (i = 0; i < odp_packet_len(pkt); i++)\n\t\tOFP_LOG_NO_CTX_NO_LEVEL(\"%02hhx \", pnt[i]);\n\tOFP_LOG_NO_CTX_NO_LEVEL(\"\\n\");\n"]], "pred": {"ppl": 2.078378677368164, "ppl_lower": 2.3878583908081055, "ppl/lowercase_ppl": -1.1897362522027923, "ppl/zlib": 0.004087084400696132, "Min_5.0% Prob": 7.438686779567173, "Min_10.0% Prob": 5.667014932632446, "Min_20.0% Prob": 3.475333140293757, "Min_30.0% Prob": 2.418944537308481, "Min_40.0% Prob": 1.8347644807149968, "Min_50.0% Prob": 1.4717551195745666, "Min_60.0% Prob": 1.2271876186546353}}
{"hexsha": "2ce3df37a07bfd7340b9da043b48bf833502c7c1", "ext": "c", "lang": "C", "content": "NATIVE int IInPlcMult(hplc, cp) /* WINIGNORE - unused in WIN */\nstruct PLC **hplc;\nCP cp;\n{\n\tstruct PLC *pplc = *hplc;\n\t\t\tCP far *lprgcp = LprgcpForPlc(pplc);\n\t\t\tCP far *lpcp;\n\t\t\tint icp;\n\t\t\tlong lcp;\n\n\t\t\tif (lprgcp[0] + DcpAdjust(pplc, 0) >= cp)\n\t\t\treturn 0;\n\t\t\ticp = IInPlc(hplc, cp);\n\t\t\tlcp = icp;\n\n\t\t\tfor (lpcp = (char far *)lprgcp + sizeof(CP) * lcp;\n\t\t\ticp > 0 && *(lpcp - 1) + DcpAdjust(pplc, icp - 1)== *lpcp + DcpAdjust(pplc, icp);\n\t\t\ticp--, lpcp--)\n\t\t\t;\n\t\t\treturn(icp);\n}", "item_id": 5, "repo": "Computer-history-Museum/MS-Word-for-Windows-v1.1", "file": "Opus/wordtech/plc.c", "last_update_at": "2019-02-25T02:16:30+00:00", "question_id": "2ce3df37a07bfd7340b9da043b48bf833502c7c1_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NATIVE int IInPlcMult(hplc, cp) /* WINIGNORE - unused in WIN */\nstruct PLC **hplc;\nCP cp;\n{\n\tstruct PLC *pplc = *hplc;\n\t\t\tCP far *lprgcp = LprgcpForPlc(pplc);\n\t\t\tCP far *lpcp;\n\t\t\tint icp;\n\t\t\tlong lcp;\n\t\t\tif (lprgcp[0] + DcpAdjust(pplc, 0) >= cp)\n\t\t\treturn 0;\n\t\t\ticp = IInPlc(hplc, cp);\n\t\t\tlcp = icp;\n\t\t\tfor (lpcp = (char far *)lprgcp + sizeof(CP) * lcp;\n\t\t\ticp > 0 && *(lpcp - 1) + DcpAdjust(pplc, icp - 1)== *lpcp + DcpAdjust(pplc, icp);\n\t\t\ticp--, lpcp--)\n\t\t\t;\n\t\t\treturn(icp);\n"]], "pred": {"ppl": 3.2463266849517822, "ppl_lower": 3.823023557662964, "ppl/lowercase_ppl": -1.1388655311260414, "ppl/zlib": 0.004377413034730362, "Min_5.0% Prob": 8.101563044956752, "Min_10.0% Prob": 6.814491152763367, "Min_20.0% Prob": 4.7138193971232365, "Min_30.0% Prob": 3.6205673386068904, "Min_40.0% Prob": 2.848589543972099, "Min_50.0% Prob": 2.33156835445216, "Min_60.0% Prob": 1.9542107395609918}}
{"hexsha": "66d9f5ea111148d49b89b1aeac195b27a91c968c", "ext": "c", "lang": "C", "content": "struct BlockRequest *parseBlockRequestFromProtobufMsg(ac_protobuf_message_t *msg) {\n  struct BlockRequest *ret = malloc(sizeof(struct BlockRequest));\n  ac_protobuf_field_t *username_f = ac_find_protobuf_field_in_msg(msg, 1);\n  ret->username.value = malloc(username_f->len + 1);\n  memcpy(ret->username.value, username_f->value, username_f->len);\n  ret->username.value[username_f->len] = 0;\n  ret->username.len = username_f->len;\n  return ret;\n}", "item_id": 0, "repo": "adamyi/epoll-chat", "file": "proto/BlockRequest.pb.c", "last_update_at": "2019-12-20T04:30:39+00:00", "question_id": "66d9f5ea111148d49b89b1aeac195b27a91c968c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct BlockRequest *parseBlockRequestFromProtobufMsg(ac_protobuf_message_t *msg) {\n  struct BlockRequest *ret = malloc(sizeof(struct BlockRequest));\n  ac_protobuf_field_t *username_f = ac_find_protobuf_field_in_msg(msg, 1);\n  ret->username.value = malloc(username_f->len + 1);\n  memcpy(ret->username.value, username_f->value, username_f->len);\n  ret->username.value[username_f->len] = 0;\n  ret->username.len = username_f->len;\n  return ret;\n"]], "pred": {"ppl": 2.6832151412963867, "ppl_lower": 2.7533092498779297, "ppl/lowercase_ppl": -1.0261270365806336, "ppl/zlib": 0.004768192053480355, "Min_5.0% Prob": 8.546801430838448, "Min_10.0% Prob": 6.724405654271444, "Min_20.0% Prob": 4.40955920757786, "Min_30.0% Prob": 3.2198148175426153, "Min_40.0% Prob": 2.442937534662985, "Min_50.0% Prob": 1.9823982096821458, "Min_60.0% Prob": 1.644089764109262}}
{"hexsha": "c2e27179d979b36a02bd012b405eb5d9e011dcaf", "ext": "c", "lang": "C", "content": "int handle_message_dt_connection_ht_destroy() {\n  struct connection_node *cur_connection_node;\n  unsigned short header_errno;\n\n  memcpy(&header_errno, message->data, sizeof(short));\n  header_errno = ntohs(header_errno);\n  if ((cur_connection_node =\n           connection_node_find(message->header_origin, message->header_id))) {\n    if (verbose && header_errno) {\n      fprintf(stderr,\n              \"\\rhandle_message_dt_connection_ht_destroy(): Connection %s \"\n              \"closed: %s\\n\",\n              cur_connection_node->rhost_rport, strerror(header_errno));\n    }\n\n    connection_node_delete(cur_connection_node);\n  }\n\n  return (0);\n}", "item_id": 8, "repo": "mzpqnxow/revsh", "file": "handler.c", "last_update_at": "2019-04-13T20:30:16+00:00", "question_id": "c2e27179d979b36a02bd012b405eb5d9e011dcaf_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int handle_message_dt_connection_ht_destroy() {\n  struct connection_node *cur_connection_node;\n  unsigned short header_errno;\n  memcpy(&header_errno, message->data, sizeof(short));\n  header_errno = ntohs(header_errno);\n  if ((cur_connection_node =\n           connection_node_find(message->header_origin, message->header_id))) {\n    if (verbose && header_errno) {\n      fprintf(stderr,\n              \"\\rhandle_message_dt_connection_ht_destroy(): Connection %s \"\n              \"closed: %s\\n\",\n              cur_connection_node->rhost_rport, strerror(header_errno));\n    }\n    connection_node_delete(cur_connection_node);\n  }\n  return (0);\n"]], "pred": {"ppl": 3.5089657306671143, "ppl_lower": 3.5139434337615967, "ppl/lowercase_ppl": -1.001129242194676, "ppl/zlib": 0.004499359607269946, "Min_5.0% Prob": 8.6407310962677, "Min_10.0% Prob": 6.812792408466339, "Min_20.0% Prob": 4.752103892768302, "Min_30.0% Prob": 3.7132525150893163, "Min_40.0% Prob": 3.019660505579739, "Min_50.0% Prob": 2.502865231066358, "Min_60.0% Prob": 2.0882511901086183}}
{"hexsha": "7f60d00612ab48803cc9de6f9961d3e4ee45aeff", "ext": "c", "lang": "C", "content": "static void Xbr2X(const Image *source,const Quantum *pixels,Quantum *result,\n  const size_t channels)\n{\n#define WeightVar(M,N) const int w_##M##_##N = \\\n  PixelsEqual(pixels,M,pixels,N,channels) ? 0 : 1;\n\n  WeightVar(12,11)\n  WeightVar(12,7)\n  WeightVar(12,13)\n  WeightVar(12,17)\n  WeightVar(12,16)\n  WeightVar(12,8)\n  WeightVar(6,10)\n  WeightVar(6,2)\n  WeightVar(11,7)\n  WeightVar(11,17)\n  WeightVar(11,5)\n  WeightVar(7,13)\n  WeightVar(7,1)\n  WeightVar(12,6)\n  WeightVar(12,18)\n  WeightVar(8,14)\n  WeightVar(8,2)\n  WeightVar(13,17)\n  WeightVar(13,9)\n  WeightVar(7,3)\n  WeightVar(16,10)\n  WeightVar(16,22)\n  WeightVar(17,21)\n  WeightVar(11,15)\n  WeightVar(18,14)\n  WeightVar(18,22)\n  WeightVar(17,23)\n  WeightVar(17,19)\n#undef WeightVar\n\n  if (\n    w_12_16 + w_12_8 + w_6_10 + w_6_2 + (4 * w_11_7) <\n    w_11_17 + w_11_5 + w_7_13 + w_7_1 + (4 * w_12_6)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_7 ? 11 : 7),12,result,0,\n      channels);\n  else\n    CopyPixels(pixels,12,result,0,channels);\n  if (\n    w_12_18 + w_12_6 + w_8_14 + w_8_2 + (4 * w_7_13) <\n    w_13_17 + w_13_9 + w_11_7 + w_7_3 + (4 * w_12_8)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_7 <= w_12_13 ? 7 : 13),12,result,1,\n      channels);\n  else\n    CopyPixels(pixels,12,result,1,channels);\n  if (\n    w_12_6 + w_12_18 + w_16_10 + w_16_22 + (4 * w_11_17) <\n    w_11_7 + w_11_15 + w_13_17 + w_17_21 + (4 * w_12_16)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_17 ? 11 : 17),12,result,2,\n      channels);\n  else\n    CopyPixels(pixels,12,result,2,channels);\n  if (\n    w_12_8 + w_12_16 + w_18_14 + w_18_22 + (4 * w_13_17) <\n    w_11_17 + w_17_23 + w_17_19 + w_7_13 + (4 * w_12_18)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_13 <= w_12_17 ? 13 : 17),12,result,3,\n      channels);\n  else\n    CopyPixels(pixels,12,result,3,channels);\n}", "item_id": 40, "repo": "aditi-sinha/ImageMagick", "file": "MagickCore/resize.c", "last_update_at": "2019-08-23T14:54:00+00:00", "question_id": "7f60d00612ab48803cc9de6f9961d3e4ee45aeff_40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void Xbr2X(const Image *source,const Quantum *pixels,Quantum *result,\n  const size_t channels)\n{\n#define WeightVar(M,N) const int w_##M##_##N = \\\n  PixelsEqual(pixels,M,pixels,N,channels) ? 0 : 1;\n  WeightVar(12,11)\n  WeightVar(12,7)\n  WeightVar(12,13)\n  WeightVar(12,17)\n  WeightVar(12,16)\n  WeightVar(12,8)\n  WeightVar(6,10)\n  WeightVar(6,2)\n  WeightVar(11,7)\n  WeightVar(11,17)\n  WeightVar(11,5)\n  WeightVar(7,13)\n  WeightVar(7,1)\n  WeightVar(12,6)\n  WeightVar(12,18)\n  WeightVar(8,14)\n  WeightVar(8,2)\n  WeightVar(13,17)\n  WeightVar(13,9)\n  WeightVar(7,3)\n  WeightVar(16,10)\n  WeightVar(16,22)\n  WeightVar(17,21)\n  WeightVar(11,15)\n  WeightVar(18,14)\n  WeightVar(18,22)\n  WeightVar(17,23)\n  WeightVar(17,19)\n#undef WeightVar\n  if (\n    w_12_16 + w_12_8 + w_6_10 + w_6_2 + (4 * w_11_7) <\n    w_11_17 + w_11_5 + w_7_13 + w_7_1 + (4 * w_12_6)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_7 ? 11 : 7),12,result,0,\n      channels);\n  else\n    CopyPixels(pixels,12,result,0,channels);\n  if (\n    w_12_18 + w_12_6 + w_8_14 + w_8_2 + (4 * w_7_13) <\n    w_13_17 + w_13_9 + w_11_7 + w_7_3 + (4 * w_12_8)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_7 <= w_12_13 ? 7 : 13),12,result,1,\n      channels);\n  else\n    CopyPixels(pixels,12,result,1,channels);\n  if (\n    w_12_6 + w_12_18 + w_16_10 + w_16_22 + (4 * w_11_17) <\n    w_11_7 + w_11_15 + w_13_17 + w_17_21 + (4 * w_12_16)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_17 ? 11 : 17),12,result,2,\n      channels);\n  else\n    CopyPixels(pixels,12,result,2,channels);\n  if (\n    w_12_8 + w_12_16 + w_18_14 + w_18_22 + (4 * w_13_17) <\n    w_11_17 + w_17_23 + w_17_19 + w_7_13 + (4 * w_12_18)\n  )\n    Mix2Pixels(pixels,(ssize_t) (w_12_13 <= w_12_17 ? 13 : 17),12,result,3,\n      channels);\n  else\n    CopyPixels(pixels,12,result,3,channels);\n"]], "pred": {"ppl": 1.7508124113082886, "ppl_lower": 1.7796118259429932, "ppl/lowercase_ppl": -1.0291303964311378, "ppl/zlib": 0.0010854261923352432, "Min_5.0% Prob": 5.6972166977676695, "Min_10.0% Prob": 4.073332605408687, "Min_20.0% Prob": 2.5981457724290737, "Min_30.0% Prob": 1.8369642300835622, "Min_40.0% Prob": 1.3956864021700286, "Min_50.0% Prob": 1.1202730339224616, "Min_60.0% Prob": 0.9345049803275509}}
{"hexsha": "13793ba0ce172714355abee0ddd3291622370461", "ext": "h", "lang": "C", "content": "static inline size_t\nfilemap_copy_from_user_iovec(struct page *page, unsigned long offset,\n\t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n{\n\tchar *kaddr;\n\tsize_t copied;\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tcopied = __filemap_copy_from_user_iovec(kaddr + offset, iov,\n\t\t\t\t\t\tbase, bytes);\n\tkunmap_atomic(kaddr, KM_USER0);\n\tif (copied != bytes) {\n\t\tkaddr = kmap(page);\n\t\tcopied = __filemap_copy_from_user_iovec(kaddr + offset, iov,\n\t\t\t\t\t\t\tbase, bytes);\n\t\tkunmap(page);\n\t}\n\treturn copied;\n}", "item_id": 1, "repo": "ut-osa/syncchar", "file": "linux-2.6.16-unmod/mm/filemap.h", "last_update_at": "2019-05-14T16:36:45+00:00", "question_id": "13793ba0ce172714355abee0ddd3291622370461_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline size_t\nfilemap_copy_from_user_iovec(struct page *page, unsigned long offset,\n\t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n{\n\tchar *kaddr;\n\tsize_t copied;\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tcopied = __filemap_copy_from_user_iovec(kaddr + offset, iov,\n\t\t\t\t\t\tbase, bytes);\n\tkunmap_atomic(kaddr, KM_USER0);\n\tif (copied != bytes) {\n\t\tkaddr = kmap(page);\n\t\tcopied = __filemap_copy_from_user_iovec(kaddr + offset, iov,\n\t\t\t\t\t\t\tbase, bytes);\n\t\tkunmap(page);\n\t}\n\treturn copied;\n"]], "pred": {"ppl": 1.6872446537017822, "ppl_lower": 1.8471713066101074, "ppl/lowercase_ppl": -1.1731202078248182, "ppl/zlib": 0.002207159561140118, "Min_5.0% Prob": 6.0383265018463135, "Min_10.0% Prob": 4.269488760403225, "Min_20.0% Prob": 2.4758666421091835, "Min_30.0% Prob": 1.7136032099907215, "Min_40.0% Prob": 1.3008575227925148, "Min_50.0% Prob": 1.0434024705286693, "Min_60.0% Prob": 0.8764436690280071}}
{"hexsha": "50c60e4ba0fa067b4c7bb219f3313615ecf20c03", "ext": "c", "lang": "C", "content": "int v_gethexa( short parameter_1)\r\n{\r\n\tunsigned int unsigned_int_1 = 1;\r\n\tdouble double_1 = 1;\r\n\tint int_1 = 1;\r\n\tdouble double_2 = 1;\r\n\tunsigned int unsigned_int_2 = 1;\r\n\tunsigned int unsigned_int_3 = 1;\r\n\tunsigned_int_1 = v_esccheck(double_1,int_1,double_2);\r\n\r\n\tunsigned_int_1 = unsigned_int_1 + unsigned_int_2;\r\n\tunsigned_int_1 = unsigned_int_3 + unsigned_int_3;\r\n\treturn int_1;\r\n\tint_1 = v_luaO_hexavalue(int_1);\r\n\r\n}", "item_id": 169, "repo": "Vul4Vendetta/Vul_Tech", "file": "experiments/node2/c_source/rust-lua53_1_35_node2.c", "last_update_at": "2019-10-28T05:24:15+00:00", "question_id": "50c60e4ba0fa067b4c7bb219f3313615ecf20c03_169", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int v_gethexa( short parameter_1)\r\n{\r\n\tunsigned int unsigned_int_1 = 1;\r\n\tdouble double_1 = 1;\r\n\tint int_1 = 1;\r\n\tdouble double_2 = 1;\r\n\tunsigned int unsigned_int_2 = 1;\r\n\tunsigned int unsigned_int_3 = 1;\r\n\tunsigned_int_1 = v_esccheck(double_1,int_1,double_2);\r\n\r\n\tunsigned_int_1 = unsigned_int_1 + unsigned_int_2;\r\n\tunsigned_int_1 = unsigned_int_3 + unsigned_int_3;\r\n\treturn int_1;\r\n\tint_1 = v_luaO_hexavalue(int_1);\r\n\r\n"]], "pred": {"ppl": 2.246347427368164, "ppl_lower": 2.3172640800476074, "ppl/lowercase_ppl": -1.038405374999805, "ppl/zlib": 0.0047606207736262075, "Min_5.0% Prob": 9.63505326377021, "Min_10.0% Prob": 6.494009931882222, "Min_20.0% Prob": 3.8907641387648053, "Min_30.0% Prob": 2.6936305358454034, "Min_40.0% Prob": 2.0231589793531586, "Min_50.0% Prob": 1.6185999464001928, "Min_60.0% Prob": 1.3488404962306082}}
{"hexsha": "2cc10f9b057e6c67ea46cb6003f4b67f09ce90b8", "ext": "c", "lang": "C", "content": "u8 *\nformat_vnet_buffer_opaque2 (u8 * s, va_list * args)\n{\n  vlib_buffer_t *b = va_arg (*args, vlib_buffer_t *);\n  vnet_buffer_opaque2_t *o = (vnet_buffer_opaque2_t *) b->opaque2;\n\n  int i;\n\n  s = format (s, \"raw: \");\n\n  for (i = 0; i < ARRAY_LEN (b->opaque2); i++)\n    s = format (s, \"%08x \", b->opaque2[i]);\n  vec_add1 (s, '\\n');\n\n  s = format (s, \"qos.bits: %x, qos.source: %x\",\n\t      (u32) (o->qos.bits), (u32) (o->qos.source));\n  vec_add1 (s, '\\n');\n  s = format (s, \"loop_counter: %d\", o->loop_counter);\n  vec_add1 (s, '\\n');\n\n  s = format (s, \"gbp.flags: %x, gbp.sclass: %d\",\n\t      (u32) (o->gbp.flags), (u32) (o->gbp.sclass));\n  vec_add1 (s, '\\n');\n\n  s = format (s, \"pg_replay_timestamp: %llu\", (u32) (o->pg_replay_timestamp));\n  vec_add1 (s, '\\n');\n  return s;\n}", "item_id": 12, "repo": "lfntac/vpp", "file": "src/vnet/interface_format.c", "last_update_at": "2019-03-23T21:06:14+00:00", "question_id": "2cc10f9b057e6c67ea46cb6003f4b67f09ce90b8_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["u8 *\nformat_vnet_buffer_opaque2 (u8 * s, va_list * args)\n{\n  vlib_buffer_t *b = va_arg (*args, vlib_buffer_t *);\n  vnet_buffer_opaque2_t *o = (vnet_buffer_opaque2_t *) b->opaque2;\n  int i;\n  s = format (s, \"raw: \");\n  for (i = 0; i < ARRAY_LEN (b->opaque2); i++)\n    s = format (s, \"%08x \", b->opaque2[i]);\n  vec_add1 (s, '\\n');\n  s = format (s, \"qos.bits: %x, qos.source: %x\",\n\t      (u32) (o->qos.bits), (u32) (o->qos.source));\n  vec_add1 (s, '\\n');\n  s = format (s, \"loop_counter: %d\", o->loop_counter);\n  vec_add1 (s, '\\n');\n  s = format (s, \"gbp.flags: %x, gbp.sclass: %d\",\n\t      (u32) (o->gbp.flags), (u32) (o->gbp.sclass));\n  vec_add1 (s, '\\n');\n  s = format (s, \"pg_replay_timestamp: %llu\", (u32) (o->pg_replay_timestamp));\n  vec_add1 (s, '\\n');\n  return s;\n"]], "pred": {"ppl": 1.8042619228363037, "ppl_lower": 1.8530006408691406, "ppl/lowercase_ppl": -1.0451658386806695, "ppl/zlib": 0.0018158510804420764, "Min_5.0% Prob": 6.022195238816111, "Min_10.0% Prob": 4.512987616815065, "Min_20.0% Prob": 2.7748679727702945, "Min_30.0% Prob": 1.94821504619101, "Min_40.0% Prob": 1.4742749621310542, "Min_50.0% Prob": 1.1818674289400584, "Min_60.0% Prob": 0.9849519459150987}}
{"hexsha": "3204f412cad8c32cca0fdc81ad10696218062f5d", "ext": "c", "lang": "C", "content": "int amiga_serial_console_wait_key(struct console *co)\n{\n    int ch;\n\n    while (!(amiga_custom.intreqr & IF_RBF))\n\tbarrier();\n    ch = amiga_custom.serdatr & 0xff;\n    /* clear the interrupt, so that another character can be read */\n    amiga_custom.intreq = IF_RBF;\n    return ch;\n}", "item_id": 11, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/arch/m68k/amiga/config.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "3204f412cad8c32cca0fdc81ad10696218062f5d_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int amiga_serial_console_wait_key(struct console *co)\n{\n    int ch;\n    while (!(amiga_custom.intreqr & IF_RBF))\n\tbarrier();\n    ch = amiga_custom.serdatr & 0xff;\n    /* clear the interrupt, so that another character can be read */\n    amiga_custom.intreq = IF_RBF;\n    return ch;\n"]], "pred": {"ppl": 3.560596466064453, "ppl_lower": 4.1021318435668945, "ppl/lowercase_ppl": -1.1114856230495602, "ppl/zlib": 0.0066838319867204505, "Min_5.0% Prob": 7.6055584907531735, "Min_10.0% Prob": 6.189213800430298, "Min_20.0% Prob": 4.654967737197876, "Min_30.0% Prob": 3.674296090679784, "Min_40.0% Prob": 3.0042749163581104, "Min_50.0% Prob": 2.481320582330227, "Min_60.0% Prob": 2.1152520819056417}}
{"hexsha": "275b9425d8984fb9f24b28d4e13c1d0b913511e9", "ext": "h", "lang": "C", "content": "class PKeySummary\n{\npublic:\n    PKeySummary(std::string addr);\n    ~PKeySummary();\n    \n    std::string GetAddress();\n    SKeyTransactionMap GetTransactions();\n    SKeyTransactionMap GetUnspent();\n    Value GetBalance(int min_confirm=0, bool using_retain = true);\n    size_t GetMemoryUsage();\n    bool CanBeRemoved();\n    unsigned int LoadedBlocks();\n    \nprotected:\n    void Using();\n    void ImportBlock(CBlock block, CBlockIndex *index);\n    \n    std::string strAddress;\n    unsigned int used_time;\n    unsigned int loaded_blocks;\n    \n    SKeyTransactionMap transactions;\n    SKeyTransactionMap unspent;\n    size_t cache_balance;\n}", "item_id": 0, "repo": "beonpush/beonpush-android", "file": "BOP-mysql/src/rpcwebwallet.h", "last_update_at": "2019-03-15T08:10:16+00:00", "question_id": "275b9425d8984fb9f24b28d4e13c1d0b913511e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class PKeySummary\n{\npublic:\n    PKeySummary(std::string addr);\n    ~PKeySummary();\n    std::string GetAddress();\n    SKeyTransactionMap GetTransactions();\n    SKeyTransactionMap GetUnspent();\n    Value GetBalance(int min_confirm=0, bool using_retain = true);\n    size_t GetMemoryUsage();\n    bool CanBeRemoved();\n    unsigned int LoadedBlocks();\nprotected:\n    void Using();\n    void ImportBlock(CBlock block, CBlockIndex *index);\n    std::string strAddress;\n    unsigned int used_time;\n    unsigned int loaded_blocks;\n    SKeyTransactionMap transactions;\n    SKeyTransactionMap unspent;\n    size_t cache_balance;\n"]], "pred": {"ppl": 5.015017032623291, "ppl_lower": 5.666216850280762, "ppl/lowercase_ppl": -1.0757145047718677, "ppl/zlib": 0.005392765276735059, "Min_5.0% Prob": 9.756697442796495, "Min_10.0% Prob": 8.08328618501362, "Min_20.0% Prob": 5.879119979707818, "Min_30.0% Prob": 4.6130736522507245, "Min_40.0% Prob": 3.7828075234827243, "Min_50.0% Prob": 3.157139812645159, "Min_60.0% Prob": 2.676849391768899}}
{"hexsha": "fbb2755ac7cbe9db2b6c3c705b258971ff65a0ce", "ext": "h", "lang": "C", "content": "static bool CanExportFunction(const UClass* Class, const UFunction* Function)\n\t{\t\t\n\t\t// Delegate function is not a real function.\n\t\tif ((Function->FunctionFlags & FUNC_Delegate))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Skip unsupported type or delegate properties which are handled in dedicated code path.\n\t\tfor (TFieldIterator<FProperty> ParamIt(Function); ParamIt; ++ParamIt)\n\t\t{\n\t\t\tFProperty* Param = *ParamIt;\n\t\t\tif (Param->ArrayDim > 1 ||\n\t\t\t\tParam->IsA(FDelegateProperty::StaticClass()) ||\n\t\t\t\tParam->IsA(FMulticastDelegateProperty::StaticClass()) ||\n\t\t\t\tParam->IsA(FInterfaceProperty::StaticClass()))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "item_id": 0, "repo": "ninemcom/Unreal.js-core", "file": "Source/V8/Private/Config.h", "last_update_at": "2019-07-24T13:20:45+00:00", "question_id": "fbb2755ac7cbe9db2b6c3c705b258971ff65a0ce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool CanExportFunction(const UClass* Class, const UFunction* Function)\n\t{\t\t\n\t\t// Delegate function is not a real function.\n\t\tif ((Function->FunctionFlags & FUNC_Delegate))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t// Skip unsupported type or delegate properties which are handled in dedicated code path.\n\t\tfor (TFieldIterator<FProperty> ParamIt(Function); ParamIt; ++ParamIt)\n\t\t{\n\t\t\tFProperty* Param = *ParamIt;\n\t\t\tif (Param->ArrayDim > 1 ||\n\t\t\t\tParam->IsA(FDelegateProperty::StaticClass()) ||\n\t\t\t\tParam->IsA(FMulticastDelegateProperty::StaticClass()) ||\n\t\t\t\tParam->IsA(FInterfaceProperty::StaticClass()))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n"]], "pred": {"ppl": 2.252662420272827, "ppl_lower": 3.505969285964966, "ppl/lowercase_ppl": -1.544695519555209, "ppl/zlib": 0.0024609479229399894, "Min_5.0% Prob": 6.909175569360906, "Min_10.0% Prob": 5.552116725755774, "Min_20.0% Prob": 3.7010452682557315, "Min_30.0% Prob": 2.6461320355318594, "Min_40.0% Prob": 2.02520190268431, "Min_50.0% Prob": 1.627957864931744, "Min_60.0% Prob": 1.3586951918407357}}
{"hexsha": "96a29c05bbf6f742f44e6fe1f926d75decb3c5d7", "ext": "c", "lang": "C", "content": "unsigned long LTimeCur()\n{\n\textern long LDaysFrom1900Dttm();\n\tlong lTime;\n\tstruct DTTM dttm;\n\tstruct TIM tim;\n\n\tOsTime(&tim);\n\tdttm = DttmCur();\n\tlTime = tim.sec + 60L * \n\t\t\t((long)dttm.hr * 60L /* hours in min */ +\n\t\t\t(long) dttm.mint + 1440L * (LDaysFrom1900Dttm(dttm)-1));\n\n\treturn lTime;\n}", "item_id": 37, "repo": "Computer-history-Museum/MS-Word-for-Windows-v1.1", "file": "Opus/elmisc.c", "last_update_at": "2019-02-25T02:16:30+00:00", "question_id": "96a29c05bbf6f742f44e6fe1f926d75decb3c5d7_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned long LTimeCur()\n{\n\textern long LDaysFrom1900Dttm();\n\tlong lTime;\n\tstruct DTTM dttm;\n\tstruct TIM tim;\n\tOsTime(&tim);\n\tdttm = DttmCur();\n\tlTime = tim.sec + 60L * \n\t\t\t((long)dttm.hr * 60L /* hours in min */ +\n\t\t\t(long) dttm.mint + 1440L * (LDaysFrom1900Dttm(dttm)-1));\n\treturn lTime;\n"]], "pred": {"ppl": 4.78389835357666, "ppl_lower": 4.701993465423584, "ppl/lowercase_ppl": -0.9889671648386189, "ppl/zlib": 0.007865606880706217, "Min_5.0% Prob": 9.063683101109095, "Min_10.0% Prob": 7.424497095743815, "Min_20.0% Prob": 5.543986694018046, "Min_30.0% Prob": 4.463522280587091, "Min_40.0% Prob": 3.668961465358734, "Min_50.0% Prob": 3.052803834802226, "Min_60.0% Prob": 2.594473743340471}}
{"hexsha": "3890ef039bade14c9cfa725ec8574f56b69e6d7e", "ext": "c", "lang": "C", "content": "void SocketClose(int* fd)\n{\n    int tempFd = *fd;\n    if ( tempFd < 0 )\n      return;\n    *fd = -1;\n    close(tempFd);\n}", "item_id": 1, "repo": "MXCHIP/mxos", "file": "libraries/utilities/SocketUtils.c", "last_update_at": "2019-06-26T10:15:44+00:00", "question_id": "3890ef039bade14c9cfa725ec8574f56b69e6d7e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SocketClose(int* fd)\n{\n    int tempFd = *fd;\n    if ( tempFd < 0 )\n      return;\n    *fd = -1;\n    close(tempFd);\n"]], "pred": {"ppl": 4.801602363586426, "ppl_lower": 4.648810386657715, "ppl/lowercase_ppl": -0.979388547536473, "ppl/zlib": 0.01669095412716596, "Min_5.0% Prob": 11.456154346466064, "Min_10.0% Prob": 8.409374237060547, "Min_20.0% Prob": 6.310283589363098, "Min_30.0% Prob": 4.8145831823349, "Min_40.0% Prob": 3.8346117110479447, "Min_50.0% Prob": 3.070891191562017, "Min_60.0% Prob": 2.6218950492329895}}
{"hexsha": "2485fbfb2d0d07331bf69a6b33f14852704aafc2", "ext": "c", "lang": "C", "content": "STATIC mp_obj_t mp_lv_roller_get_selected(size_t n_args, const mp_obj_t *args)\n{\n    const lv_obj_t *roller = mp_to_lv(args[0]);\n    uint16_t res = lv_roller_get_selected(roller);\n    return mp_obj_new_int_from_uint(res);\n}", "item_id": 382, "repo": "pmp-p/lv_binding_micropython", "file": "gen/lv_mpy_example.c", "last_update_at": "2019-06-30T22:24:21+00:00", "question_id": "2485fbfb2d0d07331bf69a6b33f14852704aafc2_382", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["STATIC mp_obj_t mp_lv_roller_get_selected(size_t n_args, const mp_obj_t *args)\n{\n    const lv_obj_t *roller = mp_to_lv(args[0]);\n    uint16_t res = lv_roller_get_selected(roller);\n    return mp_obj_new_int_from_uint(res);\n"]], "pred": {"ppl": 2.8956329822540283, "ppl_lower": 2.690804958343506, "ppl/lowercase_ppl": -0.9309978495750538, "ppl/zlib": 0.007135595529161877, "Min_5.0% Prob": 9.649830102920532, "Min_10.0% Prob": 7.873435921139187, "Min_20.0% Prob": 4.999211518388045, "Min_30.0% Prob": 3.5059852605235986, "Min_40.0% Prob": 2.7042527138990793, "Min_50.0% Prob": 2.1461598293778175, "Min_60.0% Prob": 1.777520679274638}}
{"hexsha": "c8a2463d1187dcf0a04b313a80a449c070a3d457", "ext": "c", "lang": "C", "content": "static int dpt_cmp_lsn_and_page(const void *ap, const void * bp, const void * ignored) {\n  const dpt_entry * a = ap;\n  const dpt_entry * b = bp;\n\n  return (a->lsn < b->lsn) ? -1 : ((a->lsn == b->lsn) ? dpt_cmp_page(ap, bp, 0) : 1);\n}", "item_id": 1, "repo": "Zhoutall/stasis", "file": "src/stasis/dirtyPageTable.c", "last_update_at": "2019-11-21T07:21:32+00:00", "question_id": "c8a2463d1187dcf0a04b313a80a449c070a3d457_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int dpt_cmp_lsn_and_page(const void *ap, const void * bp, const void * ignored) {\n  const dpt_entry * a = ap;\n  const dpt_entry * b = bp;\n  return (a->lsn < b->lsn) ? -1 : ((a->lsn == b->lsn) ? dpt_cmp_page(ap, bp, 0) : 1);\n"]], "pred": {"ppl": 2.796969413757324, "ppl_lower": 2.796969413757324, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00719256278870951, "Min_5.0% Prob": 7.328702926635742, "Min_10.0% Prob": 6.217805433273315, "Min_20.0% Prob": 4.291466599419003, "Min_30.0% Prob": 3.2296953946352005, "Min_40.0% Prob": 2.537827294579772, "Min_50.0% Prob": 2.045331194996834, "Min_60.0% Prob": 1.732048606412718}}
{"hexsha": "648b39386988bc8b5400045912c1345e5f91f359", "ext": "c", "lang": "C", "content": "int\ngem_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct gem_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn (error);\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tgem_init(ifp);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse {\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t    ina->x_host.c_host, sizeof(sc->sc_enaddr));\n\t\t\t}\t\n\t\t\t/* Set new address. */\n\t\t\tgem_init(ifp);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tgem_init(ifp);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tgem_stop(ifp, 1);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tgem_init(ifp);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\t/*gem_stop(sc);*/\n\t\t\tgem_init(ifp);\n\t\t}\n#ifdef HMEDEBUG\n\t\tsc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tgem_init(ifp);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}", "item_id": 23, "repo": "shisa/kame-shisa", "file": "openbsd/sys/dev/ic/gem.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "648b39386988bc8b5400045912c1345e5f91f359_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ngem_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct gem_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\ts = splimp();\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn (error);\n\t}\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tgem_init(ifp);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse {\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t    ina->x_host.c_host, sizeof(sc->sc_enaddr));\n\t\t\t}\t\n\t\t\t/* Set new address. */\n\t\t\tgem_init(ifp);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tgem_init(ifp);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tgem_stop(ifp, 1);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tgem_init(ifp);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\t/*gem_stop(sc);*/\n\t\t\tgem_init(ifp);\n\t\t}\n#ifdef HMEDEBUG\n\t\tsc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;\n#endif\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tgem_init(ifp);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (error);\n"]], "pred": {"ppl": 1.2302697896957397, "ppl_lower": 1.578532338142395, "ppl/lowercase_ppl": -2.202807678608691, "ppl/zlib": 0.00023363414492514896, "Min_5.0% Prob": 3.1460170582229017, "Min_10.0% Prob": 1.8861675174797283, "Min_20.0% Prob": 1.0126050733687246, "Min_30.0% Prob": 0.6870266812871776, "Min_40.0% Prob": 0.5167517619034444, "Min_50.0% Prob": 0.4143311175401095, "Min_60.0% Prob": 0.34565959525633405}}
{"hexsha": "9e14d82287a166db7579bac1d29811bdecc77083", "ext": "c", "lang": "C", "content": "static int pasemi_msi_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\n{\n\tunsigned int virq;\n\tstruct msi_desc *entry;\n\tstruct msi_msg msg;\n\tint hwirq;\n\n\tpr_debug(\"pasemi_msi_setup_msi_irqs, pdev %p nvec %d type %d\\n\",\n\t\t pdev, nvec, type);\n\n\tmsg.address_hi = 0;\n\tmsg.address_lo = PASEMI_MSI_ADDR;\n\n\tlist_for_each_entry(entry, &pdev->msi_list, list) {\n\t\t/* Allocate 16 interrupts for now, since that's the grouping for\n\t\t * affinity. This can be changed later if it turns out 32 is too\n\t\t * few MSIs for someone, but restrictions will apply to how the\n\t\t * sources can be changed independently.\n\t\t */\n\t\thwirq = msi_bitmap_alloc_hwirqs(&msi_mpic->msi_bitmap,\n\t\t\t\t\t\tALLOC_CHUNK);\n\t\tif (hwirq < 0) {\n\t\t\tpr_debug(\"pasemi_msi: failed allocating hwirq\\n\");\n\t\t\treturn hwirq;\n\t\t}\n\n\t\tvirq = irq_create_mapping(msi_mpic->irqhost, hwirq);\n\t\tif (virq == NO_IRQ) {\n\t\t\tpr_debug(\"pasemi_msi: failed mapping hwirq 0x%x\\n\",\n\t\t\t\t  hwirq);\n\t\t\tmsi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq,\n\t\t\t\t\t       ALLOC_CHUNK);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* Vector on MSI is really an offset, the hardware adds\n\t\t * it to the value written at the magic address. So set\n\t\t * it to 0 to remain sane.\n\t\t */\n\t\tmpic_set_vector(virq, 0);\n\n\t\tirq_set_msi_desc(virq, entry);\n\t\tirq_set_chip(virq, &mpic_pasemi_msi_chip);\n\t\tirq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);\n\n\t\tpr_debug(\"pasemi_msi: allocated virq 0x%x (hw 0x%x) \" \\\n\t\t\t \"addr 0x%x\\n\", virq, hwirq, msg.address_lo);\n\n\t\t/* Likewise, the device writes [0...511] into the target\n\t\t * register to generate MSI [512...1023]\n\t\t */\n\t\tmsg.data = hwirq-0x200;\n\t\twrite_msi_msg(virq, &msg);\n\t}\n\n\treturn 0;\n}", "item_id": 3, "repo": "xloem/DIY-LAPTOP", "file": "SOFTWARE/A64-TERES/linux-a64/arch/powerpc/sysdev/mpic_pasemi_msi.c", "last_update_at": "2019-08-25T09:01:38+00:00", "question_id": "9e14d82287a166db7579bac1d29811bdecc77083_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int pasemi_msi_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\n{\n\tunsigned int virq;\n\tstruct msi_desc *entry;\n\tstruct msi_msg msg;\n\tint hwirq;\n\tpr_debug(\"pasemi_msi_setup_msi_irqs, pdev %p nvec %d type %d\\n\",\n\t\t pdev, nvec, type);\n\tmsg.address_hi = 0;\n\tmsg.address_lo = PASEMI_MSI_ADDR;\n\tlist_for_each_entry(entry, &pdev->msi_list, list) {\n\t\t/* Allocate 16 interrupts for now, since that's the grouping for\n\t\t * affinity. This can be changed later if it turns out 32 is too\n\t\t * few MSIs for someone, but restrictions will apply to how the\n\t\t * sources can be changed independently.\n\t\t */\n\t\thwirq = msi_bitmap_alloc_hwirqs(&msi_mpic->msi_bitmap,\n\t\t\t\t\t\tALLOC_CHUNK);\n\t\tif (hwirq < 0) {\n\t\t\tpr_debug(\"pasemi_msi: failed allocating hwirq\\n\");\n\t\t\treturn hwirq;\n\t\t}\n\t\tvirq = irq_create_mapping(msi_mpic->irqhost, hwirq);\n\t\tif (virq == NO_IRQ) {\n\t\t\tpr_debug(\"pasemi_msi: failed mapping hwirq 0x%x\\n\",\n\t\t\t\t  hwirq);\n\t\t\tmsi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq,\n\t\t\t\t\t       ALLOC_CHUNK);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/* Vector on MSI is really an offset, the hardware adds\n\t\t * it to the value written at the magic address. So set\n\t\t * it to 0 to remain sane.\n\t\t */\n\t\tmpic_set_vector(virq, 0);\n\t\tirq_set_msi_desc(virq, entry);\n\t\tirq_set_chip(virq, &mpic_pasemi_msi_chip);\n\t\tirq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);\n\t\tpr_debug(\"pasemi_msi: allocated virq 0x%x (hw 0x%x) \" \\\n\t\t\t \"addr 0x%x\\n\", virq, hwirq, msg.address_lo);\n\t\t/* Likewise, the device writes [0...511] into the target\n\t\t * register to generate MSI [512...1023]\n\t\t */\n\t\tmsg.data = hwirq-0x200;\n\t\twrite_msi_msg(virq, &msg);\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 2.208306074142456, "ppl_lower": 2.3784573078155518, "ppl/lowercase_ppl": -1.0936934316752103, "ppl/zlib": 0.0009696765475439937, "Min_5.0% Prob": 7.219803320734124, "Min_10.0% Prob": 5.401703336022117, "Min_20.0% Prob": 3.5935758552243633, "Min_30.0% Prob": 2.5852610041098347, "Min_40.0% Prob": 1.9717736626104, "Min_50.0% Prob": 1.5825227184758819, "Min_60.0% Prob": 1.3216498782162265}}
{"hexsha": "9f5e3f509aaf78d8dae2726fa333e21032201e92", "ext": "c", "lang": "C", "content": "static void test_generation_rate (void)\n{\n    int dimension, length, max_block_length;\n    struct block_frequency bf_x, bf_y;\n    int **x, **y;\n    double gen_rate;\n\n    dimension = 4;\n    length = 1024;\n    max_block_length = 5;\n\n    MALLOC2(x, length, dimension);\n    MALLOC2(y, length, dimension);\n\n    int *tmp;\n    MALLOC(tmp, length);\n    gen_Morse_sequence(tmp, length);\n    for (int n = 0; n < length; n++) {\n        for (int i = 0; i < dimension; i++) {\n            x[n][i] = tmp[(n+i) % length];\n            y[n][i] = tmp[(n+i+300) % length];\n        }\n    }\n    FREE(tmp);\n    for (int n = 1; n < max_block_length; n++) {\n        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);\n        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);\n        gen_rate = generation_rate(&bf_x, &bf_y);\n        assert_equal_double(1, gen_rate, 1e-3);\n        free_block_frequency(&bf_x);\n        free_block_frequency(&bf_y);\n    }\n    for (int n = 0; n < length; n++) {\n        for (int i = 0; i < dimension; i++) {\n            x[n][i] = i;\n            y[n][i] = i + 1;\n        }\n    }\n    for (int n = 1; n < max_block_length; n++) {\n        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);\n        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);\n        gen_rate = generation_rate(&bf_x, &bf_y);\n        assert_equal_double(0, gen_rate, 1e-3);\n        free_block_frequency(&bf_x);\n        free_block_frequency(&bf_y);\n    }\n    FREE2(x);\n    FREE2(y);\n}", "item_id": 3, "repo": "jnamika/rnn", "file": "src/unit-test/test_entropy.c", "last_update_at": "2019-09-29T12:48:21+00:00", "question_id": "9f5e3f509aaf78d8dae2726fa333e21032201e92_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_generation_rate (void)\n{\n    int dimension, length, max_block_length;\n    struct block_frequency bf_x, bf_y;\n    int **x, **y;\n    double gen_rate;\n    dimension = 4;\n    length = 1024;\n    max_block_length = 5;\n    MALLOC2(x, length, dimension);\n    MALLOC2(y, length, dimension);\n    int *tmp;\n    MALLOC(tmp, length);\n    gen_Morse_sequence(tmp, length);\n    for (int n = 0; n < length; n++) {\n        for (int i = 0; i < dimension; i++) {\n            x[n][i] = tmp[(n+i) % length];\n            y[n][i] = tmp[(n+i+300) % length];\n        }\n    }\n    FREE(tmp);\n    for (int n = 1; n < max_block_length; n++) {\n        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);\n        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);\n        gen_rate = generation_rate(&bf_x, &bf_y);\n        assert_equal_double(1, gen_rate, 1e-3);\n        free_block_frequency(&bf_x);\n        free_block_frequency(&bf_y);\n    }\n    for (int n = 0; n < length; n++) {\n        for (int i = 0; i < dimension; i++) {\n            x[n][i] = i;\n            y[n][i] = i + 1;\n        }\n    }\n    for (int n = 1; n < max_block_length; n++) {\n        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);\n        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);\n        gen_rate = generation_rate(&bf_x, &bf_y);\n        assert_equal_double(0, gen_rate, 1e-3);\n        free_block_frequency(&bf_x);\n        free_block_frequency(&bf_y);\n    }\n    FREE2(x);\n    FREE2(y);\n"]], "pred": {"ppl": 1.6911084651947021, "ppl_lower": 1.7036681175231934, "ppl/lowercase_ppl": -1.0140838496558127, "ppl/zlib": 0.0013101850635754415, "Min_5.0% Prob": 5.732741872469584, "Min_10.0% Prob": 4.114306604862213, "Min_20.0% Prob": 2.4750390109916527, "Min_30.0% Prob": 1.7290791305402915, "Min_40.0% Prob": 1.3112471465487032, "Min_50.0% Prob": 1.0514425835184131, "Min_60.0% Prob": 0.8768107790454653}}
{"hexsha": "270b425dd08678164b32823f7eda1813bedd212a", "ext": "c", "lang": "C", "content": "int\nOF_milliseconds(void)\n{\n\tstruct {\n\t\tcell_t name;\n\t\tcell_t nargs;\n\t\tcell_t nreturns;\n\t\tcell_t ms;\n\t} args;\n\n\targs.name = ADR2CELL(\"milliseconds\");\n\targs.nargs = 0;\n\targs.nreturns = 1;\n\topenfirmware(&args);\n\treturn args.ms;\n}", "item_id": 11, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/arch/sparc64/stand/ofwboot/Locore.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "270b425dd08678164b32823f7eda1813bedd212a_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nOF_milliseconds(void)\n{\n\tstruct {\n\t\tcell_t name;\n\t\tcell_t nargs;\n\t\tcell_t nreturns;\n\t\tcell_t ms;\n\t} args;\n\targs.name = ADR2CELL(\"milliseconds\");\n\targs.nargs = 0;\n\targs.nreturns = 1;\n\topenfirmware(&args);\n\treturn args.ms;\n"]], "pred": {"ppl": 2.718471050262451, "ppl_lower": 2.5869083404541016, "ppl/lowercase_ppl": -0.9503973161248972, "ppl/zlib": 0.00680319461488826, "Min_5.0% Prob": 9.051192283630371, "Min_10.0% Prob": 7.190263557434082, "Min_20.0% Prob": 4.626756350199382, "Min_30.0% Prob": 3.269873450510204, "Min_40.0% Prob": 2.4775003238126287, "Min_50.0% Prob": 1.9902147908039667, "Min_60.0% Prob": 1.6846511299081612}}
{"hexsha": "fd065fc6183a6a03884c3aa30a9a69b364ca802a", "ext": "c", "lang": "C", "content": "static bool torture_rpc_spoolss_printerwkn_setup(struct torture_context *tctx, void **data)\n{\n\tstruct torture_printer_context *t;\n\n\t*data = t = talloc_zero(tctx, struct torture_printer_context);\n\n\tt->ex\t\t\t= false;\n\tt->wellknown\t\t= true;\n\tt->info2.printername\t= TORTURE_WELLKNOWN_PRINTER;\n\tt->devmode\t\t= NULL;\n\n\t/* FIXME */\n\tif (t->wellknown) {\n\t\ttorture_skip(tctx, \"skipping AddPrinter level 1\");\n\t}\n\n\treturn torture_rpc_spoolss_printer_setup_common(tctx, t);\n}", "item_id": 132, "repo": "zaion520/ATtomato", "file": "release/src-rt-6.x.4708/router/samba3/source4/torture/rpc/spoolss.c", "last_update_at": "2019-02-15T03:30:28+00:00", "question_id": "fd065fc6183a6a03884c3aa30a9a69b364ca802a_132", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool torture_rpc_spoolss_printerwkn_setup(struct torture_context *tctx, void **data)\n{\n\tstruct torture_printer_context *t;\n\t*data = t = talloc_zero(tctx, struct torture_printer_context);\n\tt->ex\t\t\t= false;\n\tt->wellknown\t\t= true;\n\tt->info2.printername\t= TORTURE_WELLKNOWN_PRINTER;\n\tt->devmode\t\t= NULL;\n\t/* FIXME */\n\tif (t->wellknown) {\n\t\ttorture_skip(tctx, \"skipping AddPrinter level 1\");\n\t}\n\treturn torture_rpc_spoolss_printer_setup_common(tctx, t);\n"]], "pred": {"ppl": 3.864487886428833, "ppl_lower": 4.374013900756836, "ppl/lowercase_ppl": -1.09161803117117, "ppl/zlib": 0.004862694866846413, "Min_5.0% Prob": 10.91168794631958, "Min_10.0% Prob": 8.759719085693359, "Min_20.0% Prob": 6.002169740200043, "Min_30.0% Prob": 4.373251541455587, "Min_40.0% Prob": 3.369909809716046, "Min_50.0% Prob": 2.6942634058765846, "Min_60.0% Prob": 2.2550239976618656}}
{"hexsha": "9af5102736dc3e8731f378c8bf99d53c05b4cc13", "ext": "c", "lang": "C", "content": "static void rehashtab(lua_State *L, GCtab *t, cTValue *ek)\n{\n  uint32_t bins[LJ_MAX_ABITS];\n  uint32_t total, asize, na, i;\n  for (i = 0; i < LJ_MAX_ABITS; i++) bins[i] = 0;\n  asize = countarray(t, bins);\n  total = 1 + asize + counthash(t, bins, &asize);\n  asize += countint(ek, bins);\n  na = bestasize(bins, &asize);\n  total -= na;\n  resizetab(L, t, asize, hsize2hbits(total));\n}", "item_id": 11, "repo": "ghisguth/lua-cmake-source", "file": "libs/luajit/src/lj_tab.c", "last_update_at": "2019-12-02T03:19:01+00:00", "question_id": "9af5102736dc3e8731f378c8bf99d53c05b4cc13_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void rehashtab(lua_State *L, GCtab *t, cTValue *ek)\n{\n  uint32_t bins[LJ_MAX_ABITS];\n  uint32_t total, asize, na, i;\n  for (i = 0; i < LJ_MAX_ABITS; i++) bins[i] = 0;\n  asize = countarray(t, bins);\n  total = 1 + asize + counthash(t, bins, &asize);\n  asize += countint(ek, bins);\n  na = bestasize(bins, &asize);\n  total -= na;\n  resizetab(L, t, asize, hsize2hbits(total));\n"]], "pred": {"ppl": 3.404412269592285, "ppl_lower": 4.403809547424316, "ppl/lowercase_ppl": -1.2101081319120333, "ppl/zlib": 0.005213073687888241, "Min_5.0% Prob": 8.306857426961264, "Min_10.0% Prob": 6.944546090232001, "Min_20.0% Prob": 5.130085436073509, "Min_30.0% Prob": 3.8733747764067217, "Min_40.0% Prob": 3.016788139939308, "Min_50.0% Prob": 2.4327207184446755, "Min_60.0% Prob": 2.048166866976399}}
{"hexsha": "450c46cf27b06a9a3c56c3060dc65b6d6c0bbc38", "ext": "c", "lang": "C", "content": "int run(void) {\n    ringbuffer_t *low = rb_new((void*)low_output, sizeof(*low_output));\n    if (low == NULL) {\n        abort();\n    }\n\n    ringbuffer_t *high = rb_new((void*)high_output, sizeof(*high_output));\n    if (high == NULL) {\n        abort();\n    }\n\n    ringbuffer_t *input = rb_new((void*)char_in, sizeof(*char_in));\n    if (input == NULL) {\n        abort();\n    }\n\n    while (true) {\n        char c = (char)rb_receive_byte(input);\n//        printf(\"Switch received: %x\\n\", c);\n        if (c == SWITCH_CHAR) {\n//            printf(\"Switching!\\n\");\n            /* Swap which output we see as active. */\n            if (selected == LOW) {\n                selected = HIGH;\n            } else {\n                selected = LOW;\n            }\n        } else {\n            /* Send the character to the active output. */\n            if (selected == LOW) {\n                rb_transmit_byte(low, (unsigned char)c);\n            } else {\n                rb_transmit_byte(high, (unsigned char)c);\n            }\n        }\n    }\n    return 0;\n}", "item_id": 0, "repo": "dornerworks/camkes", "file": "apps/aeroplage/components/Switch/switch.c", "last_update_at": "2019-12-30T23:05:33+00:00", "question_id": "450c46cf27b06a9a3c56c3060dc65b6d6c0bbc38_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int run(void) {\n    ringbuffer_t *low = rb_new((void*)low_output, sizeof(*low_output));\n    if (low == NULL) {\n        abort();\n    }\n    ringbuffer_t *high = rb_new((void*)high_output, sizeof(*high_output));\n    if (high == NULL) {\n        abort();\n    }\n    ringbuffer_t *input = rb_new((void*)char_in, sizeof(*char_in));\n    if (input == NULL) {\n        abort();\n    }\n    while (true) {\n        char c = (char)rb_receive_byte(input);\n//        printf(\"Switch received: %x\\n\", c);\n        if (c == SWITCH_CHAR) {\n//            printf(\"Switching!\\n\");\n            /* Swap which output we see as active. */\n            if (selected == LOW) {\n                selected = HIGH;\n            } else {\n                selected = LOW;\n            }\n        } else {\n            /* Send the character to the active output. */\n            if (selected == LOW) {\n                rb_transmit_byte(low, (unsigned char)c);\n            } else {\n                rb_transmit_byte(high, (unsigned char)c);\n            }\n        }\n    }\n    return 0;\n"]], "pred": {"ppl": 2.258776903152466, "ppl_lower": 2.3391730785369873, "ppl/lowercase_ppl": -1.0429221902911268, "ppl/zlib": 0.0021613354734505985, "Min_5.0% Prob": 7.413920819759369, "Min_10.0% Prob": 5.673439055681229, "Min_20.0% Prob": 3.7476106001780582, "Min_30.0% Prob": 2.6564367434808185, "Min_40.0% Prob": 2.0216092887611787, "Min_50.0% Prob": 1.624775576518803, "Min_60.0% Prob": 1.3622888158294086}}
{"hexsha": "d493ac01cfb68faa62c158f3b4f1c23ae1e3991f", "ext": "c", "lang": "C", "content": "Skipkey skiplistminimumkey(Skiplist* skiplist)\n{\n  Skipnode *minelem;\n\n  /* check input parameters */\n  if(skiplist == NULL)\n  {\n    ERROR0(\"Could not return min key from skiplist. List handle is NULL.\\n\");\n    return NULL;\n  }\n  if(skiplist->headpointers == NULL)\n  {\n    ERROR0(\"Could not return min key from skiplist. Headpointer is NULL.\\n\");\n    return NULL;\n  }\n\n  minelem = skiplist->headpointers[0];\n  if(minelem != NULL) {\n    skiplist->currentelement = minelem;\n    return minelem->key;\n  } else\n  {\n    skiplist->currentelement = NULL;\n    return NULL;\n  }\n}", "item_id": 8, "repo": "gordon/vstree", "file": "src/kurtz/skiplist.c", "last_update_at": "2019-02-11T23:47:46+00:00", "question_id": "d493ac01cfb68faa62c158f3b4f1c23ae1e3991f_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Skipkey skiplistminimumkey(Skiplist* skiplist)\n{\n  Skipnode *minelem;\n  /* check input parameters */\n  if(skiplist == NULL)\n  {\n    ERROR0(\"Could not return min key from skiplist. List handle is NULL.\\n\");\n    return NULL;\n  }\n  if(skiplist->headpointers == NULL)\n  {\n    ERROR0(\"Could not return min key from skiplist. Headpointer is NULL.\\n\");\n    return NULL;\n  }\n  minelem = skiplist->headpointers[0];\n  if(minelem != NULL) {\n    skiplist->currentelement = minelem;\n    return minelem->key;\n  } else\n  {\n    skiplist->currentelement = NULL;\n    return NULL;\n  }\n"]], "pred": {"ppl": 3.076691150665283, "ppl_lower": 3.2033016681671143, "ppl/lowercase_ppl": -1.0358830467872022, "ppl/zlib": 0.004495418871110802, "Min_5.0% Prob": 9.090200328826905, "Min_10.0% Prob": 6.803006112575531, "Min_20.0% Prob": 4.735537022352219, "Min_30.0% Prob": 3.5891867329676947, "Min_40.0% Prob": 2.7936725368723274, "Min_50.0% Prob": 2.2351862459932224, "Min_60.0% Prob": 1.8720689835873516}}
{"hexsha": "aa050ef7ede87deba9543024fa37bfb8756f121c", "ext": "c", "lang": "C", "content": "uint8_t readNetworkIdFromBip32path(uint32_t bip32Path[]) {\n    uint8_t outNetworkId;\n    switch(bip32Path[2]) {\n        case 0x80000068: \n            outNetworkId = 104; //N\n            break;\n        case 0x80000098:\n           outNetworkId = 152; //T\n           break;\n        case 0x80000060:\n            outNetworkId = 96; //M\n            break;\n        case 0x80000090:\n            outNetworkId = 144; //S\n            break;\n        default:\n            THROW(0x6a80);\n    }\n    return outNetworkId;\n}", "item_id": 0, "repo": "lethlong79/ledger-app-nem", "file": "src/nemHelpers.c", "last_update_at": "2019-07-23T14:58:26+00:00", "question_id": "aa050ef7ede87deba9543024fa37bfb8756f121c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint8_t readNetworkIdFromBip32path(uint32_t bip32Path[]) {\n    uint8_t outNetworkId;\n    switch(bip32Path[2]) {\n        case 0x80000068: \n            outNetworkId = 104; //N\n            break;\n        case 0x80000098:\n           outNetworkId = 152; //T\n           break;\n        case 0x80000060:\n            outNetworkId = 96; //M\n            break;\n        case 0x80000090:\n            outNetworkId = 144; //S\n            break;\n        default:\n            THROW(0x6a80);\n    }\n    return outNetworkId;\n"]], "pred": {"ppl": 2.3143374919891357, "ppl_lower": 2.474879264831543, "ppl/lowercase_ppl": -1.079926434721943, "ppl/zlib": 0.0041133503236003765, "Min_5.0% Prob": 6.565777921676636, "Min_10.0% Prob": 5.253302001953125, "Min_20.0% Prob": 3.640433387058537, "Min_30.0% Prob": 2.6909916317853773, "Min_40.0% Prob": 2.061435323299431, "Min_50.0% Prob": 1.674643388492804, "Min_60.0% Prob": 1.3955614913891001}}
{"hexsha": "324ab52e8e239c0b500de06d801a779153266470", "ext": "c", "lang": "C", "content": "Rconnection newWpipe(const char *description, int ienc, const char *mode)\n{\n    Rconnection new;\n    char *command;\n    int len;\n\n    new = (Rconnection) malloc(sizeof(struct Rconn));\n    if(!new) error(_(\"allocation of pipe connection failed\"));\n    new->class = (char *) malloc(strlen(\"pipe\") + 1);\n    if(!new->class) {\n\tfree(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n    strcpy(new->class, \"pipe\");\n\n    len = strlen(getenv(\"COMSPEC\")) + strlen(description) + 5;\n    command = (char *) malloc(len);\n    if (command)\n\tnew->description = (char *) malloc(len);\n    else\n\tnew->description = NULL;\n\n    if(!new->description) {\n\tfree(command); free(new->class); free(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n\n    /* We always use COMSPEC here, not R_SHELL or SHELL,\n       for compatibility with Rterm.\n       We also use /c for the same reason.\n    */\n\n    strcpy(command, getenv(\"COMSPEC\"));\n    strcat(command, \" /c \");\n    strcat(command, description);\n\n    init_con(new, command, ienc, mode);\n    free(command);\n\n    new->open = &Wpipe_open;\n    new->close = &Wpipe_close;\n    new->destroy = &Wpipe_destroy;\n    new->vfprintf = &Wpipe_vfprintf;\n    new->fgetc = &Wpipe_fgetc;\n    new->seek = &null_seek;\n    new->truncate = &null_truncate;\n    new->fflush = &Wpipe_fflush;\n    new->read = &Wpipe_read;\n    new->write = &Wpipe_write;\n    new->private = (void *) malloc(sizeof(struct Wpipeconn));\n    if(!new->private) {\n\tfree(new->description); free(new->class); free(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n    return new;\n}", "item_id": 18, "repo": "lifebit-ai/exomedepth", "file": "bin/R-3.5.1/src/gnuwin32/run.c", "last_update_at": "2019-07-28T20:32:29+00:00", "question_id": "324ab52e8e239c0b500de06d801a779153266470_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Rconnection newWpipe(const char *description, int ienc, const char *mode)\n{\n    Rconnection new;\n    char *command;\n    int len;\n    new = (Rconnection) malloc(sizeof(struct Rconn));\n    if(!new) error(_(\"allocation of pipe connection failed\"));\n    new->class = (char *) malloc(strlen(\"pipe\") + 1);\n    if(!new->class) {\n\tfree(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n    strcpy(new->class, \"pipe\");\n    len = strlen(getenv(\"COMSPEC\")) + strlen(description) + 5;\n    command = (char *) malloc(len);\n    if (command)\n\tnew->description = (char *) malloc(len);\n    else\n\tnew->description = NULL;\n    if(!new->description) {\n\tfree(command); free(new->class); free(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n    /* We always use COMSPEC here, not R_SHELL or SHELL,\n       for compatibility with Rterm.\n       We also use /c for the same reason.\n    */\n    strcpy(command, getenv(\"COMSPEC\"));\n    strcat(command, \" /c \");\n    strcat(command, description);\n    init_con(new, command, ienc, mode);\n    free(command);\n    new->open = &Wpipe_open;\n    new->close = &Wpipe_close;\n    new->destroy = &Wpipe_destroy;\n    new->vfprintf = &Wpipe_vfprintf;\n    new->fgetc = &Wpipe_fgetc;\n    new->seek = &null_seek;\n    new->truncate = &null_truncate;\n    new->fflush = &Wpipe_fflush;\n    new->read = &Wpipe_read;\n    new->write = &Wpipe_write;\n    new->private = (void *) malloc(sizeof(struct Wpipeconn));\n    if(!new->private) {\n\tfree(new->description); free(new->class); free(new);\n\terror(_(\"allocation of pipe connection failed\"));\n    }\n    return new;\n"]], "pred": {"ppl": 2.060216188430786, "ppl_lower": 2.2582013607025146, "ppl/lowercase_ppl": -1.126945667604916, "ppl/zlib": 0.0012815796509490207, "Min_5.0% Prob": 6.994492248252586, "Min_10.0% Prob": 5.050265606966886, "Min_20.0% Prob": 3.2554132461547853, "Min_30.0% Prob": 2.3271781446355764, "Min_40.0% Prob": 1.7855159482156688, "Min_50.0% Prob": 1.4401600046862255, "Min_60.0% Prob": 1.2042236321972626}}
{"hexsha": "dc4251de71d74257793f4750d858d66e9c78decb", "ext": "c", "lang": "C", "content": "JNICALL\nJava_com_microsoft_sqlserver_jdbc_AuthenticationJNI_SNIIsEqualToCurrentSID(\n    JNIEnv *env,\n    jclass klass,\n    jbyteArray SID,\n    jobject logger)\n{\n    logger_log(env, logger, ENTERING, \"SNIIsEqualToCurrentSID\");\n\n    /* Do nothing */\n    \n    logger_log(env, logger, EXITING, \"SNIIsEqualToCurrentSID\");\n    \n    return 1;\n}", "item_id": 8, "repo": "ddz/libsqljdbc-auth", "file": "src/sqljdbc_auth.c", "last_update_at": "2019-04-30T07:07:44+00:00", "question_id": "dc4251de71d74257793f4750d858d66e9c78decb_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["JNICALL\nJava_com_microsoft_sqlserver_jdbc_AuthenticationJNI_SNIIsEqualToCurrentSID(\n    JNIEnv *env,\n    jclass klass,\n    jbyteArray SID,\n    jobject logger)\n{\n    logger_log(env, logger, ENTERING, \"SNIIsEqualToCurrentSID\");\n    /* Do nothing */\n    logger_log(env, logger, EXITING, \"SNIIsEqualToCurrentSID\");\n    return 1;\n"]], "pred": {"ppl": 4.147854328155518, "ppl_lower": 6.070528030395508, "ppl/lowercase_ppl": -1.2677188133936654, "ppl/zlib": 0.007007838281658732, "Min_5.0% Prob": 7.512647231419881, "Min_10.0% Prob": 6.926531155904134, "Min_20.0% Prob": 5.582377185821533, "Min_30.0% Prob": 4.438017200779271, "Min_40.0% Prob": 3.5034197998046874, "Min_50.0% Prob": 2.8293068653770854, "Min_60.0% Prob": 2.385381255423029}}
{"hexsha": "90b1e5be289ed2d61d0ad5813fc1342e6e89c1c7", "ext": "c", "lang": "C", "content": "void rendering_resource_init_empty(rendering_resource* res) {\n    res->device = VK_NULL_HANDLE;\n    res->command_pool = VK_NULL_HANDLE;\n    res->command_buffer = VK_NULL_HANDLE;\n    res->finished_render_semaphore = VK_NULL_HANDLE;\n    res->image_available_semaphore = VK_NULL_HANDLE;\n    res->fence = VK_NULL_HANDLE;\n\n    vk_framebuffer_init_empty(&res->framebuffer);\n}", "item_id": 0, "repo": "jammymalina/vkpixelcollision", "file": "src/rendering/renderer/rendering_resource.c", "last_update_at": "2019-05-14T15:01:16+00:00", "question_id": "90b1e5be289ed2d61d0ad5813fc1342e6e89c1c7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void rendering_resource_init_empty(rendering_resource* res) {\n    res->device = VK_NULL_HANDLE;\n    res->command_pool = VK_NULL_HANDLE;\n    res->command_buffer = VK_NULL_HANDLE;\n    res->finished_render_semaphore = VK_NULL_HANDLE;\n    res->image_available_semaphore = VK_NULL_HANDLE;\n    res->fence = VK_NULL_HANDLE;\n    vk_framebuffer_init_empty(&res->framebuffer);\n"]], "pred": {"ppl": 2.3791580200195312, "ppl_lower": 2.6419198513031006, "ppl/lowercase_ppl": -1.1208648652253859, "ppl/zlib": 0.0051286784141413005, "Min_5.0% Prob": 8.60834653036935, "Min_10.0% Prob": 6.617036087172372, "Min_20.0% Prob": 4.04158975543647, "Min_30.0% Prob": 2.8590358048677444, "Min_40.0% Prob": 2.156288959342858, "Min_50.0% Prob": 1.7434738029260188, "Min_60.0% Prob": 1.4442807296317757}}
{"hexsha": "d24fef90a48febf7bfc4924d3747882bf9c337ea", "ext": "c", "lang": "C", "content": "char *\nipx_phost(struct sockaddr *sa)\n{\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;\n\tstruct sockaddr_ipx work;\n\tstatic union ipx_net ipx_zeronet;\n\tchar *p;\n\tstruct ipx_addr in;\n\n\twork = *sipx;\n\tin = work.sipx_addr;\n\n\twork.sipx_addr.x_port = 0;\n\twork.sipx_addr.x_net = ipx_zeronet;\n\tp = ipx_print((struct sockaddr *)&work);\n\tif (strncmp(\"*.\", p, 2) == 0) p += 2;\n\n\treturn(p);\n}", "item_id": 20, "repo": "TrustedBSD/sebsd", "file": "usr.bin/netstat/route.c", "last_update_at": "2019-10-09T17:34:14+00:00", "question_id": "d24fef90a48febf7bfc4924d3747882bf9c337ea_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *\nipx_phost(struct sockaddr *sa)\n{\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;\n\tstruct sockaddr_ipx work;\n\tstatic union ipx_net ipx_zeronet;\n\tchar *p;\n\tstruct ipx_addr in;\n\twork = *sipx;\n\tin = work.sipx_addr;\n\twork.sipx_addr.x_port = 0;\n\twork.sipx_addr.x_net = ipx_zeronet;\n\tp = ipx_print((struct sockaddr *)&work);\n\tif (strncmp(\"*.\", p, 2) == 0) p += 2;\n\treturn(p);\n"]], "pred": {"ppl": 2.2845942974090576, "ppl_lower": 2.2845942974090576, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004151700795046272, "Min_5.0% Prob": 6.680776807996962, "Min_10.0% Prob": 5.243683137391743, "Min_20.0% Prob": 3.534099789766165, "Min_30.0% Prob": 2.6446627399017073, "Min_40.0% Prob": 2.0341394293384676, "Min_50.0% Prob": 1.6517199810939966, "Min_60.0% Prob": 1.3746692026113598}}
{"hexsha": "6220d96b4d72a4c00f134614f1c27d53d88f8623", "ext": "c", "lang": "C", "content": "static void kupyna512_2048()\n{\n    static const uint8_t expected[512/8] = {\n        0x0D, 0xD0, 0x3D, 0x73, 0x50, 0xC4, 0x09, 0xCB, 0x3C, 0x29, 0xC2, 0x58, 0x93, 0xA0, 0x72, 0x4F,\n        0x6B, 0x13, 0x3F, 0xA8, 0xB9, 0xEB, 0x90, 0xA6, 0x4D, 0x1A, 0x8F, 0xA9, 0x3B, 0x56, 0x55, 0x66,\n        0x11, 0xEB, 0x18, 0x7D, 0x71, 0x5A, 0x95, 0x6B, 0x10, 0x7E, 0x3B, 0xFC, 0x76, 0x48, 0x22, 0x98,\n        0x13, 0x3A, 0x9C, 0xE8, 0xCB, 0xC0, 0xBD, 0x5E, 0x14, 0x36, 0xA5, 0xB1, 0x97, 0x28, 0x4F, 0x7E\n    };\n\n    struct kupyna512_ctx_t ctx;\n    kupyna512_init(&ctx);\n    kupyna512_update(&ctx, test, 2048 / 8);\n    kupyna512_final(&ctx, result);\n    CU_ASSERT(!memcmp(result, expected, 64));\n\n    kupyna512_init(&ctx);\n    kupyna512_update_aligned(&ctx, test, 2048 / 8);\n    kupyna512_final(&ctx, result);\n    CU_ASSERT(!memcmp(result, expected, 64));\n}", "item_id": 11, "repo": "sjinks/kupyna-c", "file": "kupyna_test.c", "last_update_at": "2019-11-03T13:04:10+00:00", "question_id": "6220d96b4d72a4c00f134614f1c27d53d88f8623_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void kupyna512_2048()\n{\n    static const uint8_t expected[512/8] = {\n        0x0D, 0xD0, 0x3D, 0x73, 0x50, 0xC4, 0x09, 0xCB, 0x3C, 0x29, 0xC2, 0x58, 0x93, 0xA0, 0x72, 0x4F,\n        0x6B, 0x13, 0x3F, 0xA8, 0xB9, 0xEB, 0x90, 0xA6, 0x4D, 0x1A, 0x8F, 0xA9, 0x3B, 0x56, 0x55, 0x66,\n        0x11, 0xEB, 0x18, 0x7D, 0x71, 0x5A, 0x95, 0x6B, 0x10, 0x7E, 0x3B, 0xFC, 0x76, 0x48, 0x22, 0x98,\n        0x13, 0x3A, 0x9C, 0xE8, 0xCB, 0xC0, 0xBD, 0x5E, 0x14, 0x36, 0xA5, 0xB1, 0x97, 0x28, 0x4F, 0x7E\n    };\n    struct kupyna512_ctx_t ctx;\n    kupyna512_init(&ctx);\n    kupyna512_update(&ctx, test, 2048 / 8);\n    kupyna512_final(&ctx, result);\n    CU_ASSERT(!memcmp(result, expected, 64));\n    kupyna512_init(&ctx);\n    kupyna512_update_aligned(&ctx, test, 2048 / 8);\n    kupyna512_final(&ctx, result);\n    CU_ASSERT(!memcmp(result, expected, 64));\n"]], "pred": {"ppl": 2.3688430786132812, "ppl_lower": 2.43385910987854, "ppl/lowercase_ppl": -1.031396535674156, "ppl/zlib": 0.0024710649956389105, "Min_5.0% Prob": 4.930326108274789, "Min_10.0% Prob": 3.972618415437896, "Min_20.0% Prob": 3.373907609232541, "Min_30.0% Prob": 2.83802586382833, "Min_40.0% Prob": 2.1577265702974824, "Min_50.0% Prob": 1.7275445933132594, "Min_60.0% Prob": 1.4397423982032476}}
{"hexsha": "639b38d643e6d7418c94b78c8e242a8797178d51", "ext": "c", "lang": "C", "content": "static enum sess_status\ncnt_http_pipe_end(struct sess *sp)\n{\n\n\tvca_close_session(sp, \"pipe\");\n\tVBE_CloseFd(sp, &sp->vc, 0);\n\n\tAZ(sp->wrkvar.wfd);\n\tsp->wrkvar.bereq = NULL;\n\tif ((sp->flags & SESS_F_ERROR) != 0) {\n\t\tAN(sp->err_code);\n\t\tAN(sp->err_reason);\n\t\tassert((sp->flags & SESS_F_ERROR) != 0);\n\t\tsp->step = STP_HTTP_ERROR;\n\t} else\n\t\tsp->step = STP_DONE;\n\treturn (SESS_CONTINUE);\n}", "item_id": 79, "repo": "smallvil/Cache-Terminator", "file": "bin/varnishd/cache_center.c", "last_update_at": "2019-10-14T14:19:09+00:00", "question_id": "639b38d643e6d7418c94b78c8e242a8797178d51_79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum sess_status\ncnt_http_pipe_end(struct sess *sp)\n{\n\tvca_close_session(sp, \"pipe\");\n\tVBE_CloseFd(sp, &sp->vc, 0);\n\tAZ(sp->wrkvar.wfd);\n\tsp->wrkvar.bereq = NULL;\n\tif ((sp->flags & SESS_F_ERROR) != 0) {\n\t\tAN(sp->err_code);\n\t\tAN(sp->err_reason);\n\t\tassert((sp->flags & SESS_F_ERROR) != 0);\n\t\tsp->step = STP_HTTP_ERROR;\n\t} else\n\t\tsp->step = STP_DONE;\n\treturn (SESS_CONTINUE);\n"]], "pred": {"ppl": 3.2103917598724365, "ppl_lower": 4.837475299835205, "ppl/lowercase_ppl": -1.351511016006305, "ppl/zlib": 0.004684309129595105, "Min_5.0% Prob": 8.106187502543131, "Min_10.0% Prob": 6.5709889729817705, "Min_20.0% Prob": 4.680676853334582, "Min_30.0% Prob": 3.6168124292578017, "Min_40.0% Prob": 2.8751264595985413, "Min_50.0% Prob": 2.3304451869681793, "Min_60.0% Prob": 1.9476985997001155}}
{"hexsha": "150a7ce43260e5372adb8749ad4a06c04ca3e068", "ext": "c", "lang": "C", "content": "static void session_environ()\n{\n  char* path = strdup(getenv(\"PATH\"));\n  *environ = 0;\n  setenv(\"HOME\",pw.pw_dir,1);\n  setenv(\"USER\",pw.pw_name,1);\n  setenv(\"LOGNAME\",pw.pw_name,1);\n  setenv(\"LOGIN\",pw.pw_name,1); /*< Historical; only strictly needed on AIX */\n  setenv(\"SHELL\", pw.pw_shell[0] ? pw.pw_shell : \"/bin/sh\",1);\n  setenv(\"PATH\",path,1);\n  free(path);\n\n#if HAVE_PAM\n  pam_export_environ();\n#endif\n  /* Authentication mechanism other than PAM can also have environment variables\n   * to set too, pointing to cached credentials in /tmp, for example. */\n\n#if HAVE_LOGIN_CAP\n  /* Note we have already done LOGIN_SETRESOURCES, LOGIN_SETCPUMASK. We have\n   * to do them again though after setuid() or the user's personal preferences\n   * won't be read in. We had to do them the first time because the daemon\n   * might be running under reduced limits and we would need to root to raise\n   * the limits back up to the system defaults. */\n  if (setusercontext(login_class, &pw, pw.pw_uid,\n                     LOGIN_SETUMASK|LOGIN_SETPATH|LOGIN_SETENV|\n                     LOGIN_SETRESOURCES|LOGIN_SETCPUMASK) < 0)\n    perror(\"setusercontext(env) failed\");\n  login_close(login_class); login_class = 0;\n#endif\n\n  if (chdir(getenv(\"HOME\")) < 0) perror(\"chdir($HOME)\");\n}", "item_id": 2, "repo": "NWilson/netlogind", "file": "session.c", "last_update_at": "2019-01-19T17:48:46+00:00", "question_id": "150a7ce43260e5372adb8749ad4a06c04ca3e068_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void session_environ()\n{\n  char* path = strdup(getenv(\"PATH\"));\n  *environ = 0;\n  setenv(\"HOME\",pw.pw_dir,1);\n  setenv(\"USER\",pw.pw_name,1);\n  setenv(\"LOGNAME\",pw.pw_name,1);\n  setenv(\"LOGIN\",pw.pw_name,1); /*< Historical; only strictly needed on AIX */\n  setenv(\"SHELL\", pw.pw_shell[0] ? pw.pw_shell : \"/bin/sh\",1);\n  setenv(\"PATH\",path,1);\n  free(path);\n#if HAVE_PAM\n  pam_export_environ();\n#endif\n  /* Authentication mechanism other than PAM can also have environment variables\n   * to set too, pointing to cached credentials in /tmp, for example. */\n#if HAVE_LOGIN_CAP\n  /* Note we have already done LOGIN_SETRESOURCES, LOGIN_SETCPUMASK. We have\n   * to do them again though after setuid() or the user's personal preferences\n   * won't be read in. We had to do them the first time because the daemon\n   * might be running under reduced limits and we would need to root to raise\n   * the limits back up to the system defaults. */\n  if (setusercontext(login_class, &pw, pw.pw_uid,\n                     LOGIN_SETUMASK|LOGIN_SETPATH|LOGIN_SETENV|\n                     LOGIN_SETRESOURCES|LOGIN_SETCPUMASK) < 0)\n    perror(\"setusercontext(env) failed\");\n  login_close(login_class); login_class = 0;\n#endif\n  if (chdir(getenv(\"HOME\")) < 0) perror(\"chdir($HOME)\");\n"]], "pred": {"ppl": 3.711387872695923, "ppl_lower": 4.831925392150879, "ppl/lowercase_ppl": -1.2011879956790603, "ppl/zlib": 0.001980975674230661, "Min_5.0% Prob": 8.578217444212541, "Min_10.0% Prob": 6.927462318669194, "Min_20.0% Prob": 5.074280109094537, "Min_30.0% Prob": 3.962444117967633, "Min_40.0% Prob": 3.1889653390516406, "Min_50.0% Prob": 2.6026767416820897, "Min_60.0% Prob": 2.1824789250720062}}
{"hexsha": "cacd6d78d79e85ae06d191f55fcd03fe990f3a3b", "ext": "h", "lang": "C", "content": "static inline void _do_nano_timeout_add(struct tcs *tcs,\n\t\t\t\t\t struct _nano_timeout *t,\n\t\t\t\t     struct _nano_queue *wait_q,\n\t\t\t\t     int32_t timeout)\n{\n\tsys_dlist_t *timeout_q = &_nanokernel.timeout_q;\n\n\tt->tcs = tcs;\n\tt->delta_ticks_from_prev = timeout;\n\tt->wait_q = wait_q;\n\tsys_dlist_insert_at(timeout_q, (void *)t,\n\t\t\t\t\t\t_nano_timeout_insert_point_test,\n\t\t\t\t\t\t&t->delta_ticks_from_prev);\n}", "item_id": 5, "repo": "gemtara/z", "file": "kernel/nanokernel/include/timeout_q.h", "last_update_at": "2019-10-02T16:45:19+00:00", "question_id": "cacd6d78d79e85ae06d191f55fcd03fe990f3a3b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void _do_nano_timeout_add(struct tcs *tcs,\n\t\t\t\t\t struct _nano_timeout *t,\n\t\t\t\t     struct _nano_queue *wait_q,\n\t\t\t\t     int32_t timeout)\n{\n\tsys_dlist_t *timeout_q = &_nanokernel.timeout_q;\n\tt->tcs = tcs;\n\tt->delta_ticks_from_prev = timeout;\n\tt->wait_q = wait_q;\n\tsys_dlist_insert_at(timeout_q, (void *)t,\n\t\t\t\t\t\t_nano_timeout_insert_point_test,\n\t\t\t\t\t\t&t->delta_ticks_from_prev);\n"]], "pred": {"ppl": 2.598907947540283, "ppl_lower": 2.598907947540283, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00450514781423321, "Min_5.0% Prob": 6.888671927981907, "Min_10.0% Prob": 5.575311462084453, "Min_20.0% Prob": 3.9686629643311373, "Min_30.0% Prob": 2.946968749165535, "Min_40.0% Prob": 2.3130901769797005, "Min_50.0% Prob": 1.8856184699750962, "Min_60.0% Prob": 1.596411505847105}}
{"hexsha": "816a9b75073572839f53473a55caeeb7274b7743", "ext": "c", "lang": "C", "content": "void create()\n{\n        set_name(\"\u6c34\u7b19\", ({ \"shui sheng\",\"shuisheng\"}));\n        set(\"long\", \"\u5979\u8f15\u7ca7\u6de1\u62b9\uff0c\u7709\u76ee\u4e4b\u4e2d\u6df1\u6df1\u7684\u900f\u9732\u54c0\u601d\u3002\\n\");\n        set(\"gender\", \"\u5973\u6027\");\n        set(\"age\", 22);\n        set(\"attitude\", \"peaceful\");\n        set(\"shen_type\", 1);\n        set(\"per\", 25);\n\n        setup();\n        carry_object(\"/clone/cloth/cloth.c\")->wear();\n}", "item_id": 0, "repo": "cantona/NT6", "file": "nitan/d/register/npc/shuisheng.c", "last_update_at": "2019-03-27T07:25:16+00:00", "question_id": "816a9b75073572839f53473a55caeeb7274b7743_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void create()\n{\n        set_name(\"\u6c34\u7b19\", ({ \"shui sheng\",\"shuisheng\"}));\n        set(\"long\", \"\u5979\u8f15\u7ca7\u6de1\u62b9\uff0c\u7709\u76ee\u4e4b\u4e2d\u6df1\u6df1\u7684\u900f\u9732\u54c0\u601d\u3002\\n\");\n        set(\"gender\", \"\u5973\u6027\");\n        set(\"age\", 22);\n        set(\"attitude\", \"peaceful\");\n        set(\"shen_type\", 1);\n        set(\"per\", 25);\n        setup();\n        carry_object(\"/clone/cloth/cloth.c\")->wear();\n"]], "pred": {"ppl": 4.0891032218933105, "ppl_lower": 4.0891032218933105, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005701723420496721, "Min_5.0% Prob": 8.404700347355433, "Min_10.0% Prob": 6.738082981109619, "Min_20.0% Prob": 5.12414881490892, "Min_30.0% Prob": 4.05048191293757, "Min_40.0% Prob": 3.3514003561389063, "Min_50.0% Prob": 2.7779440856896915, "Min_60.0% Prob": 2.3385764419081365}}
{"hexsha": "4b80bf69ffdadf7c94a08c7e40e36a122d117c18", "ext": "c", "lang": "C", "content": "void bli_gemm3m2_cntl_init()\n{\n\t// Create blocksize objects for each dimension.\n\t// NOTE: the complex blocksizes for 3m2 are generally equal to their\n\t// corresponding real domain counterparts. However, we want to promote\n\t// similar cache footprints for the micro-panels of A and B (when\n\t// compared to executing in the real domain), and since the complex\n\t// micro-panels are three times as \"fat\" (due to storing real, imaginary\n\t// and real+imaginary parts), we reduce KC by a factor of 2 to\n\t// compensate. Ideally, we would reduce by a factor of 3, but that\n\t// could get messy vis-a-vis keeping KC a multiple of the register\n\t// blocksizes.\n\tgemm3m2_mc\n\t=\n\tbli_blksz_obj_create( 0,                   0,\n\t                      0,                   0,\n\t                      BLIS_DEFAULT_MC_S/3, BLIS_MAXIMUM_MC_S/3,\n\t                      BLIS_DEFAULT_MC_D/3, BLIS_MAXIMUM_MC_D/3 );\n\tgemm3m2_nc\n\t=\n\tbli_blksz_obj_create( 0,                   0,\n\t                      0,                   0,\n\t                      BLIS_DEFAULT_NC_S/3, BLIS_MAXIMUM_NC_S/3,\n\t                      BLIS_DEFAULT_NC_D/3, BLIS_MAXIMUM_NC_D/3 );\n\tgemm3m2_kc\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_KC_S, BLIS_MAXIMUM_KC_S,\n\t                      BLIS_DEFAULT_KC_D, BLIS_MAXIMUM_KC_D );\n\tgemm3m2_mr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_MR_S, BLIS_PACKDIM_MR_S,\n\t                      BLIS_DEFAULT_MR_D, BLIS_PACKDIM_MR_D );\n\tgemm3m2_nr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_NR_S, BLIS_PACKDIM_NR_S,\n\t                      BLIS_DEFAULT_NR_D, BLIS_PACKDIM_NR_D );\n\tgemm3m2_kr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_KR_S, BLIS_PACKDIM_KR_S,\n\t                      BLIS_DEFAULT_KR_D, BLIS_PACKDIM_KR_D );\n\n\n\t// Attach the register blksz_t objects as blocksize multiples to the cache\n\t// blksz_t objects.\n\tbli_blksz_obj_attach_mult_to( gemm3m2_mr, gemm3m2_mc );\n\tbli_blksz_obj_attach_mult_to( gemm3m2_nr, gemm3m2_nc );\n\tbli_blksz_obj_attach_mult_to( gemm3m2_kr, gemm3m2_kc );\n\n\n\t// The cache blocksizes that were scaled above need to be rounded down\n\t// to their respective nearest register blocksize multiples. Note that\n\t// this can only happen after the appropriate register blocksize is\n\t// actually attached as a multiple.\n\tbli_blksz_reduce_to_mult( gemm3m2_mc );\n\tbli_blksz_reduce_to_mult( gemm3m2_nc );\n\n\n\t// Attach the mr and nr blksz_t objects to each cache blksz_t object.\n\t// The primary example of why this is needed relates to nudging kc.\n\t// In hemm, symm, trmm, or trmm3, we need to know both mr and nr,\n\t// since the multiple we target in nudging depends on whether the\n\t// structured matrix is on the left or the right.\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_mc );\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_nc );\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_kc );\n\n\n\t// Create function pointer object for each datatype-specific gemm\n\t// micro-kernel.\n\tgemm3m2_ukrs\n\t=\n\tbli_func_obj_create(\n\t    NULL,                  FALSE,\n\t    NULL,                  FALSE,\n\t    BLIS_CGEMM3M2_UKERNEL, BLIS_CGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS,\n\t    BLIS_ZGEMM3M2_UKERNEL, BLIS_ZGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS );\n\n\n\t// Create control tree objects for packm operations.\n\tgemm3m2_packa_cntl\n\t=\n\tbli_packm_cntl_obj_create( BLIS_BLOCKED,\n\t                           BLIS_VARIANT2,\n\t                           gemm3m2_mr,\n\t                           gemm3m2_kr,\n\t                           FALSE, // do NOT invert diagonal\n\t                           FALSE, // reverse iteration if upper?\n\t                           FALSE, // reverse iteration if lower?\n\t                           BLIS_PACKED_ROW_PANELS_3MS,\n\t                           BLIS_BUFFER_FOR_A_BLOCK );\n\n\tgemm3m2_packb_cntl\n\t=\n\tbli_packm_cntl_obj_create( BLIS_BLOCKED,\n\t                           BLIS_VARIANT2,\n\t                           gemm3m2_kr,\n\t                           gemm3m2_nr,\n\t                           FALSE, // do NOT invert diagonal\n\t                           FALSE, // reverse iteration if upper?\n\t                           FALSE, // reverse iteration if lower?\n\t                           BLIS_PACKED_COL_PANELS_3MI,\n\t                           BLIS_BUFFER_FOR_B_PANEL );\n\n\n\t//\n\t// Create a control tree for packing A and B, and streaming C.\n\t//\n\n\t// Create control tree object for lowest-level block-panel kernel.\n\tgemm3m2_cntl_bp_ke\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_UNB_OPT,\n\t                          BLIS_VARIANT4,\n\t                          NULL,\n\t                          gemm3m2_ukrs,\n\t                          NULL, NULL, NULL,\n\t                          NULL, NULL, NULL );\n\n\t// Create control tree object for outer panel (to block-panel)\n\t// problem.\n\tgemm3m2_cntl_op_bp\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT1,\n\t                          gemm3m2_mc,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_packa_cntl,\n\t                          gemm3m2_packb_cntl,\n\t                          NULL,\n\t                          gemm3m2_cntl_bp_ke,\n\t                          NULL );\n\n\t// Create control tree object for general problem via multiple\n\t// rank-k (outer panel) updates.\n\tgemm3m2_cntl_mm_op\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT3,\n\t                          gemm3m2_kc,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_cntl_op_bp,\n\t                          NULL );\n\n\t// Create control tree object for very large problem via multiple\n\t// general problems.\n\tgemm3m2_cntl_vl_mm\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT2,\n\t                          gemm3m2_nc,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_cntl_mm_op,\n\t                          NULL );\n\n\t// Alias the \"master\" gemm control tree to a shorter name.\n\tgemm3m2_cntl = gemm3m2_cntl_vl_mm;\n\n}", "item_id": 0, "repo": "JamesLinus/blis", "file": "frame/ind/cntl/bli_gemm3m2_cntl.c", "last_update_at": "2019-04-22T09:09:58+00:00", "question_id": "4b80bf69ffdadf7c94a08c7e40e36a122d117c18_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bli_gemm3m2_cntl_init()\n{\n\t// Create blocksize objects for each dimension.\n\t// NOTE: the complex blocksizes for 3m2 are generally equal to their\n\t// corresponding real domain counterparts. However, we want to promote\n\t// similar cache footprints for the micro-panels of A and B (when\n\t// compared to executing in the real domain), and since the complex\n\t// micro-panels are three times as \"fat\" (due to storing real, imaginary\n\t// and real+imaginary parts), we reduce KC by a factor of 2 to\n\t// compensate. Ideally, we would reduce by a factor of 3, but that\n\t// could get messy vis-a-vis keeping KC a multiple of the register\n\t// blocksizes.\n\tgemm3m2_mc\n\t=\n\tbli_blksz_obj_create( 0,                   0,\n\t                      0,                   0,\n\t                      BLIS_DEFAULT_MC_S/3, BLIS_MAXIMUM_MC_S/3,\n\t                      BLIS_DEFAULT_MC_D/3, BLIS_MAXIMUM_MC_D/3 );\n\tgemm3m2_nc\n\t=\n\tbli_blksz_obj_create( 0,                   0,\n\t                      0,                   0,\n\t                      BLIS_DEFAULT_NC_S/3, BLIS_MAXIMUM_NC_S/3,\n\t                      BLIS_DEFAULT_NC_D/3, BLIS_MAXIMUM_NC_D/3 );\n\tgemm3m2_kc\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_KC_S, BLIS_MAXIMUM_KC_S,\n\t                      BLIS_DEFAULT_KC_D, BLIS_MAXIMUM_KC_D );\n\tgemm3m2_mr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_MR_S, BLIS_PACKDIM_MR_S,\n\t                      BLIS_DEFAULT_MR_D, BLIS_PACKDIM_MR_D );\n\tgemm3m2_nr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_NR_S, BLIS_PACKDIM_NR_S,\n\t                      BLIS_DEFAULT_NR_D, BLIS_PACKDIM_NR_D );\n\tgemm3m2_kr\n\t=\n\tbli_blksz_obj_create( 0,                 0,\n\t                      0,                 0,\n\t                      BLIS_DEFAULT_KR_S, BLIS_PACKDIM_KR_S,\n\t                      BLIS_DEFAULT_KR_D, BLIS_PACKDIM_KR_D );\n\t// Attach the register blksz_t objects as blocksize multiples to the cache\n\t// blksz_t objects.\n\tbli_blksz_obj_attach_mult_to( gemm3m2_mr, gemm3m2_mc );\n\tbli_blksz_obj_attach_mult_to( gemm3m2_nr, gemm3m2_nc );\n\tbli_blksz_obj_attach_mult_to( gemm3m2_kr, gemm3m2_kc );\n\t// The cache blocksizes that were scaled above need to be rounded down\n\t// to their respective nearest register blocksize multiples. Note that\n\t// this can only happen after the appropriate register blocksize is\n\t// actually attached as a multiple.\n\tbli_blksz_reduce_to_mult( gemm3m2_mc );\n\tbli_blksz_reduce_to_mult( gemm3m2_nc );\n\t// Attach the mr and nr blksz_t objects to each cache blksz_t object.\n\t// The primary example of why this is needed relates to nudging kc.\n\t// In hemm, symm, trmm, or trmm3, we need to know both mr and nr,\n\t// since the multiple we target in nudging depends on whether the\n\t// structured matrix is on the left or the right.\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_mc );\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_nc );\n\tbli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_kc );\n\t// Create function pointer object for each datatype-specific gemm\n\t// micro-kernel.\n\tgemm3m2_ukrs\n\t=\n\tbli_func_obj_create(\n\t    NULL,                  FALSE,\n\t    NULL,                  FALSE,\n\t    BLIS_CGEMM3M2_UKERNEL, BLIS_CGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS,\n\t    BLIS_ZGEMM3M2_UKERNEL, BLIS_ZGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS );\n\t// Create control tree objects for packm operations.\n\tgemm3m2_packa_cntl\n\t=\n\tbli_packm_cntl_obj_create( BLIS_BLOCKED,\n\t                           BLIS_VARIANT2,\n\t                           gemm3m2_mr,\n\t                           gemm3m2_kr,\n\t                           FALSE, // do NOT invert diagonal\n\t                           FALSE, // reverse iteration if upper?\n\t                           FALSE, // reverse iteration if lower?\n\t                           BLIS_PACKED_ROW_PANELS_3MS,\n\t                           BLIS_BUFFER_FOR_A_BLOCK );\n\tgemm3m2_packb_cntl\n\t=\n\tbli_packm_cntl_obj_create( BLIS_BLOCKED,\n\t                           BLIS_VARIANT2,\n\t                           gemm3m2_kr,\n\t                           gemm3m2_nr,\n\t                           FALSE, // do NOT invert diagonal\n\t                           FALSE, // reverse iteration if upper?\n\t                           FALSE, // reverse iteration if lower?\n\t                           BLIS_PACKED_COL_PANELS_3MI,\n\t                           BLIS_BUFFER_FOR_B_PANEL );\n\t//\n\t// Create a control tree for packing A and B, and streaming C.\n\t//\n\t// Create control tree object for lowest-level block-panel kernel.\n\tgemm3m2_cntl_bp_ke\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_UNB_OPT,\n\t                          BLIS_VARIANT4,\n\t                          NULL,\n\t                          gemm3m2_ukrs,\n\t                          NULL, NULL, NULL,\n\t                          NULL, NULL, NULL );\n\t// Create control tree object for outer panel (to block-panel)\n\t// problem.\n\tgemm3m2_cntl_op_bp\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT1,\n\t                          gemm3m2_mc,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_packa_cntl,\n\t                          gemm3m2_packb_cntl,\n\t                          NULL,\n\t                          gemm3m2_cntl_bp_ke,\n\t                          NULL );\n\t// Create control tree object for general problem via multiple\n\t// rank-k (outer panel) updates.\n\tgemm3m2_cntl_mm_op\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT3,\n\t                          gemm3m2_kc,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_cntl_op_bp,\n\t                          NULL );\n\t// Create control tree object for very large problem via multiple\n\t// general problems.\n\tgemm3m2_cntl_vl_mm\n\t=\n\tbli_gemm_cntl_obj_create( BLIS_BLOCKED,\n\t                          BLIS_VARIANT2,\n\t                          gemm3m2_nc,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          NULL,\n\t                          gemm3m2_cntl_mm_op,\n\t                          NULL );\n\t// Alias the \"master\" gemm control tree to a shorter name.\n\tgemm3m2_cntl = gemm3m2_cntl_vl_mm;\n"]], "pred": {"ppl": 1.8564741611480713, "ppl_lower": 2.0972750186920166, "ppl/lowercase_ppl": -1.1971293681963817, "ppl/zlib": 0.00041327927621402416, "Min_5.0% Prob": 6.63063429851158, "Min_10.0% Prob": 4.917076253423504, "Min_20.0% Prob": 3.0046103693106594, "Min_30.0% Prob": 2.0596508787324033, "Min_40.0% Prob": 1.5466966927188168, "Min_50.0% Prob": 1.2384423494932228, "Min_60.0% Prob": 1.0324482333469511}}
{"hexsha": "7a0ea0473659e6113efcc4f9833ad5488d2c8a7a", "ext": "c", "lang": "C", "content": "static int udata_gyro_service_ioctl_cb(udata_type_e type, sensor_tag_e tag)\n{\n    (void)type;\n    (void)tag;\n\n    return 0;\n}", "item_id": 4, "repo": "Justlinuxer/AliOS-Things", "file": "framework/uData/service/service_process.c", "last_update_at": "2019-09-25T07:17:27+00:00", "question_id": "7a0ea0473659e6113efcc4f9833ad5488d2c8a7a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int udata_gyro_service_ioctl_cb(udata_type_e type, sensor_tag_e tag)\n{\n    (void)type;\n    (void)tag;\n    return 0;\n"]], "pred": {"ppl": 4.892009735107422, "ppl_lower": 4.892009735107422, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.015564737331652465, "Min_5.0% Prob": 10.27128267288208, "Min_10.0% Prob": 8.182478713989259, "Min_20.0% Prob": 6.3897364573045214, "Min_30.0% Prob": 5.103210352361202, "Min_40.0% Prob": 3.8557187738743695, "Min_50.0% Prob": 3.2011791473185576, "Min_60.0% Prob": 2.638454285083395}}
{"hexsha": "384c823281800c1ef9228abd2ff6cb9e95177a83", "ext": "c", "lang": "C", "content": "int gleswIsSupported(int major, int minor)\n{\n\tif (major < 2)\n\t\treturn 0;\n\tif (version.major == major)\n\t\treturn version.minor >= minor;\n\treturn version.major >= major;\n}", "item_id": 5, "repo": "fegorsch/ogre", "file": "RenderSystems/GLES2/src/glesw.c", "last_update_at": "2019-01-22T13:17:49+00:00", "question_id": "384c823281800c1ef9228abd2ff6cb9e95177a83_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int gleswIsSupported(int major, int minor)\n{\n\tif (major < 2)\n\t\treturn 0;\n\tif (version.major == major)\n\t\treturn version.minor >= minor;\n\treturn version.major >= major;\n"]], "pred": {"ppl": 2.787702798843384, "ppl_lower": 3.878974437713623, "ppl/lowercase_ppl": -1.3222270266563996, "ppl/zlib": 0.009153731134715794, "Min_5.0% Prob": 8.063512166341146, "Min_10.0% Prob": 6.591924746831258, "Min_20.0% Prob": 4.115743895371755, "Min_30.0% Prob": 3.0229235228739286, "Min_40.0% Prob": 2.4544190096855165, "Min_50.0% Prob": 2.004085903055966, "Min_60.0% Prob": 1.7141373228085668}}
{"hexsha": "668c67bd198143148b1c901a2bf13d036d624151", "ext": "c", "lang": "C", "content": "void init_serial(uint16_t base, uint16_t divisor)\n{\n  outb(SERIAL_DATA_PORT(base) + 1, 0x00);\n  serial_conf_baud_rate(base, divisor);\n  serial_conf_line(base);\n  serial_conf_buff(base);\n  serial_conf_modem(base);\n}", "item_id": 1, "repo": "KingGamma/Micro-OS", "file": "src/serial.c", "last_update_at": "2019-03-15T07:39:16+00:00", "question_id": "668c67bd198143148b1c901a2bf13d036d624151_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void init_serial(uint16_t base, uint16_t divisor)\n{\n  outb(SERIAL_DATA_PORT(base) + 1, 0x00);\n  serial_conf_baud_rate(base, divisor);\n  serial_conf_line(base);\n  serial_conf_buff(base);\n  serial_conf_modem(base);\n"]], "pred": {"ppl": 3.5363523960113525, "ppl_lower": 3.71871280670166, "ppl/lowercase_ppl": -1.0398083735332182, "ppl/zlib": 0.009152868110979649, "Min_5.0% Prob": 11.035709857940674, "Min_10.0% Prob": 8.805648591783312, "Min_20.0% Prob": 5.325597480723732, "Min_30.0% Prob": 4.001940459012985, "Min_40.0% Prob": 3.0831813271108426, "Min_50.0% Prob": 2.5348787520160068, "Min_60.0% Prob": 2.1004491793481925}}
{"hexsha": "a5ac2ec90a5b0c885446d7e390e91e92f341f267", "ext": "c", "lang": "C", "content": "static tree\nfold_constant_for_init (node, context)\n     tree node;\n     tree context;\n{\n  tree op0, op1, val;\n  enum tree_code code = TREE_CODE (node);\n\n  switch (code)\n    {\n    case INTEGER_CST:\n      if (node == null_pointer_node)\n\treturn NULL_TREE;\n    case STRING_CST:\n    case REAL_CST:\n      return node;\n\n    case PLUS_EXPR:\n    case MINUS_EXPR:\n    case MULT_EXPR:\n    case TRUNC_MOD_EXPR:\n    case RDIV_EXPR:\n    case LSHIFT_EXPR:\n    case RSHIFT_EXPR:\n    case URSHIFT_EXPR:\n    case BIT_AND_EXPR:\n    case BIT_XOR_EXPR:\n    case BIT_IOR_EXPR:\n    case TRUTH_ANDIF_EXPR:\n    case TRUTH_ORIF_EXPR:\n    case EQ_EXPR:\n    case NE_EXPR:\n    case GT_EXPR:\n    case GE_EXPR:\n    case LT_EXPR:\n    case LE_EXPR:\n      op0 = TREE_OPERAND (node, 0);\n      op1 = TREE_OPERAND (node, 1);\n      val = fold_constant_for_init (op0, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      val = fold_constant_for_init (op1, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 1) = val;\n      return patch_binop (node, op0, op1);\n\n    case UNARY_PLUS_EXPR:\n    case NEGATE_EXPR:\n    case TRUTH_NOT_EXPR:\n    case BIT_NOT_EXPR:\n    case CONVERT_EXPR:\n      op0 = TREE_OPERAND (node, 0);\n      val = fold_constant_for_init (op0, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      return patch_unaryop (node, op0);\n      break;\n\n    case COND_EXPR:\n      val = fold_constant_for_init (TREE_OPERAND (node, 0), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      val = fold_constant_for_init (TREE_OPERAND (node, 1), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 1) = val;\n      val = fold_constant_for_init (TREE_OPERAND (node, 2), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 2) = val;\n      return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)\n\t: TREE_OPERAND (node, 2);\n\n    case VAR_DECL:\n    case FIELD_DECL:\n      if (! FIELD_FINAL (node)\n\t  || DECL_INITIAL (node) == NULL_TREE)\n\treturn NULL_TREE;\n      val = DECL_INITIAL (node);\n      /* Guard against infinite recursion. */\n      DECL_INITIAL (node) = NULL_TREE;\n      val = fold_constant_for_init (val, node);\n      if (val != NULL_TREE && TREE_CODE (val) != STRING_CST)\n\tval = try_builtin_assignconv (NULL_TREE, TREE_TYPE (node), val);\n      DECL_INITIAL (node) = val;\n      return val;\n\n    case EXPR_WITH_FILE_LOCATION:\n      /* Compare java_complete_tree and resolve_expression_name. */\n      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n\t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n\t{\n\t  tree name = EXPR_WFL_NODE (node);\n\t  tree decl;\n\t  if (PRIMARY_P (node))\n\t    return NULL_TREE;\n\t  else if (! QUALIFIED_P (name))\n\t    {\n\t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n\t      if (decl == NULL_TREE\n\t\t  || (! FIELD_STATIC (decl) && ! FIELD_FINAL (decl)))\n\t\treturn NULL_TREE;\n\t      return fold_constant_for_init (decl, decl);\n\t    }\n\t  else\n\t    {\n\t      /* Install the proper context for the field resolution.\n\t\t The prior context is restored once the name is\n\t\t properly qualified. */\n\t      tree saved_current_class = current_class;\n\t      /* Wait until the USE_COMPONENT_REF re-write.  FIXME. */\n\t      current_class = DECL_CONTEXT (context);\n\t      qualify_ambiguous_name (node);\n\t      current_class = saved_current_class;\n\t      if (resolve_field_access (node, &decl, NULL)\n\t\t  && decl != NULL_TREE)\n\t\treturn fold_constant_for_init (decl, decl);\n\t      return NULL_TREE;\n\t    }\n\t}\n      else\n\t{\n\t  op0 = TREE_OPERAND (node, 0);\n\t  val = fold_constant_for_init (op0, context);\n\t  if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\t    return NULL_TREE;\n\t  TREE_OPERAND (node, 0) = val;\n\t  return val;\n\t}\n\n#ifdef USE_COMPONENT_REF\n    case IDENTIFIER:\n    case COMPONENT_REF:\n      ?;\n#endif\n\n    default:\n      return NULL_TREE;\n    }\n}", "item_id": 220, "repo": "ArrogantWombatics/openbsd-src", "file": "gnu/usr.bin/gcc/gcc/java/parse.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "a5ac2ec90a5b0c885446d7e390e91e92f341f267_220", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static tree\nfold_constant_for_init (node, context)\n     tree node;\n     tree context;\n{\n  tree op0, op1, val;\n  enum tree_code code = TREE_CODE (node);\n  switch (code)\n    {\n    case INTEGER_CST:\n      if (node == null_pointer_node)\n\treturn NULL_TREE;\n    case STRING_CST:\n    case REAL_CST:\n      return node;\n    case PLUS_EXPR:\n    case MINUS_EXPR:\n    case MULT_EXPR:\n    case TRUNC_MOD_EXPR:\n    case RDIV_EXPR:\n    case LSHIFT_EXPR:\n    case RSHIFT_EXPR:\n    case URSHIFT_EXPR:\n    case BIT_AND_EXPR:\n    case BIT_XOR_EXPR:\n    case BIT_IOR_EXPR:\n    case TRUTH_ANDIF_EXPR:\n    case TRUTH_ORIF_EXPR:\n    case EQ_EXPR:\n    case NE_EXPR:\n    case GT_EXPR:\n    case GE_EXPR:\n    case LT_EXPR:\n    case LE_EXPR:\n      op0 = TREE_OPERAND (node, 0);\n      op1 = TREE_OPERAND (node, 1);\n      val = fold_constant_for_init (op0, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      val = fold_constant_for_init (op1, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 1) = val;\n      return patch_binop (node, op0, op1);\n    case UNARY_PLUS_EXPR:\n    case NEGATE_EXPR:\n    case TRUTH_NOT_EXPR:\n    case BIT_NOT_EXPR:\n    case CONVERT_EXPR:\n      op0 = TREE_OPERAND (node, 0);\n      val = fold_constant_for_init (op0, context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      return patch_unaryop (node, op0);\n      break;\n    case COND_EXPR:\n      val = fold_constant_for_init (TREE_OPERAND (node, 0), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 0) = val;\n      val = fold_constant_for_init (TREE_OPERAND (node, 1), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 1) = val;\n      val = fold_constant_for_init (TREE_OPERAND (node, 2), context);\n      if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\treturn NULL_TREE;\n      TREE_OPERAND (node, 2) = val;\n      return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)\n\t: TREE_OPERAND (node, 2);\n    case VAR_DECL:\n    case FIELD_DECL:\n      if (! FIELD_FINAL (node)\n\t  || DECL_INITIAL (node) == NULL_TREE)\n\treturn NULL_TREE;\n      val = DECL_INITIAL (node);\n      /* Guard against infinite recursion. */\n      DECL_INITIAL (node) = NULL_TREE;\n      val = fold_constant_for_init (val, node);\n      if (val != NULL_TREE && TREE_CODE (val) != STRING_CST)\n\tval = try_builtin_assignconv (NULL_TREE, TREE_TYPE (node), val);\n      DECL_INITIAL (node) = val;\n      return val;\n    case EXPR_WITH_FILE_LOCATION:\n      /* Compare java_complete_tree and resolve_expression_name. */\n      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n\t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n\t{\n\t  tree name = EXPR_WFL_NODE (node);\n\t  tree decl;\n\t  if (PRIMARY_P (node))\n\t    return NULL_TREE;\n\t  else if (! QUALIFIED_P (name))\n\t    {\n\t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n\t      if (decl == NULL_TREE\n\t\t  || (! FIELD_STATIC (decl) && ! FIELD_FINAL (decl)))\n\t\treturn NULL_TREE;\n\t      return fold_constant_for_init (decl, decl);\n\t    }\n\t  else\n\t    {\n\t      /* Install the proper context for the field resolution.\n\t\t The prior context is restored once the name is\n\t\t properly qualified. */\n\t      tree saved_current_class = current_class;\n\t      /* Wait until the USE_COMPONENT_REF re-write.  FIXME. */\n\t      current_class = DECL_CONTEXT (context);\n\t      qualify_ambiguous_name (node);\n\t      current_class = saved_current_class;\n\t      if (resolve_field_access (node, &decl, NULL)\n\t\t  && decl != NULL_TREE)\n\t\treturn fold_constant_for_init (decl, decl);\n\t      return NULL_TREE;\n\t    }\n\t}\n      else\n\t{\n\t  op0 = TREE_OPERAND (node, 0);\n\t  val = fold_constant_for_init (op0, context);\n\t  if (val == NULL_TREE || ! TREE_CONSTANT (val))\n\t    return NULL_TREE;\n\t  TREE_OPERAND (node, 0) = val;\n\t  return val;\n\t}\n#ifdef USE_COMPONENT_REF\n    case IDENTIFIER:\n    case COMPONENT_REF:\n      ?;\n#endif\n    default:\n      return NULL_TREE;\n    }\n"]], "pred": {"ppl": 1.3157000541687012, "ppl_lower": 1.7700649499893188, "ppl/lowercase_ppl": -2.081198973185516, "ppl/zlib": 0.0002359147760624825, "Min_5.0% Prob": 4.2522518751668, "Min_10.0% Prob": 2.5393442044071124, "Min_20.0% Prob": 1.3642194510492331, "Min_30.0% Prob": 0.9155508063937495, "Min_40.0% Prob": 0.6858716297448979, "Min_50.0% Prob": 0.5491869313775201, "Min_60.0% Prob": 0.45785771932410757}}
{"hexsha": "b1596a76f1b36cec25522acb44b4a5ce4ebadd83", "ext": "h", "lang": "C", "content": "namespace ui {\n\n\tclass Rectangle : public sf::RectangleShape, public ui::UIObject\n\t{\n\tpublic:\n\t\tRectangle(const std::string& id);\n\n\t\tvoid Draw(sf::RenderWindow& window) override;\n\t}", "item_id": 0, "repo": "NullSeile/UITools", "file": "src/Rectangle.h", "last_update_at": "2019-05-18T16:24:06+00:00", "question_id": "b1596a76f1b36cec25522acb44b4a5ce4ebadd83_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace ui {\n\tclass Rectangle : public sf::RectangleShape, public ui::UIObject\n\t{\n\tpublic:\n\t\tRectangle(const std::string& id);\n\t\tvoid Draw(sf::RenderWindow& window) override;\n"]], "pred": {"ppl": 4.62238073348999, "ppl_lower": 6.315446376800537, "ppl/lowercase_ppl": -1.20385821488148, "ppl/zlib": 0.010631318629486939, "Min_5.0% Prob": 11.57753054300944, "Min_10.0% Prob": 8.461073080698648, "Min_20.0% Prob": 5.853067398071289, "Min_30.0% Prob": 4.5552348428302345, "Min_40.0% Prob": 3.6691869869828224, "Min_50.0% Prob": 3.034569976727168, "Min_60.0% Prob": 2.567253623571661}}
{"hexsha": "ae791bf2d05771b88cb364dbc9e9f4e43436642b", "ext": "h", "lang": "C", "content": "LIBSBML_EXTERN SBMLIdConverter : public SBMLConverter\n{\npublic:\n\n  /** @cond doxygenLibsbmlInternal */\n  /**\n   * Register with the ConversionRegistry.\n   */\n  static void init();\n\n  /** @endcond */\n\n\n  /**\n   * Creates a new SBMLIdConverter object.\n   */\n  SBMLIdConverter();\n\n\n  /**\n   * Copy constructor; creates a copy of an SBMLIdConverter\n   * object.\n   *\n   * @param obj the SBMLIdConverter object to copy.\n   */\n  SBMLIdConverter(const SBMLIdConverter& obj);\n\n\n  /**\n   * Creates and returns a deep copy of this SBMLIdConverter\n   * object.\n   *\n   * @return a (deep) copy of this converter.\n   */\n  virtual SBMLIdConverter* clone() const;\n\n\n  /**\n   * Destroy this SBMLIdConverter object.\n   */\n  virtual ~SBMLIdConverter ();\n\n\n  /**\n   * Returns @c true if this converter object's properties match the given\n   * properties.\n   *\n   * A typical use of this method involves creating a ConversionProperties\n   * object, setting the options desired, and then calling this method on\n   * an SBMLIdConverter object to find out if the object's\n   * property values match the given ones.  This method is also used by\n   * SBMLConverterRegistry::getConverterFor(@if java ConversionProperties@endif)\n   * to search across all registered converters for one matching particular\n   * properties.\n   *\n   * @param props the properties to match.\n   *\n   * @return @c true if this converter's properties match, @c false\n   * otherwise.\n   */\n  virtual bool matchesProperties(const ConversionProperties &props) const;\n\n\n  /**\n   * Perform the conversion.\n   *\n   * This method causes the converter to do the actual conversion work,\n   * that is, to convert the SBMLDocument object set by\n   * SBMLConverter::setDocument(@if java SBMLDocument@endif) and\n   * with the configuration options set by\n   * SBMLConverter::setProperties(@if java ConversionProperties@endif).\n   *\n   * @copydetails doc_returns_success_code\n   * @li @sbmlconstant{LIBSBML_OPERATION_SUCCESS, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_OPERATION_FAILED, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_INVALID_OBJECT, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_UNEXPECTED_ATTRIBUTE, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_INVALID_ATTRIBUTE_VALUE, OperationReturnValues_t}\n   */\n  virtual int convert();\n\n\n  /**\n   * Returns the default properties of this converter.\n   *\n   * A given converter exposes one or more properties that can be adjusted\n   * in order to influence the behavior of the converter.  This method\n   * returns the @em default property settings for this converter.  It is\n   * meant to be called in order to discover all the settings for the\n   * converter object.\n   *\n   * @return the ConversionProperties object describing the default properties\n   * for this converter.\n   */\n  virtual ConversionProperties getDefaultProperties() const;\n\n}", "item_id": 0, "repo": "sys-bio/Libstructural", "file": "dependencies/libsbml-vs2017-release-64/include/sbml/conversion/SBMLIdConverter.h", "last_update_at": "2019-06-20T11:37:53+00:00", "question_id": "ae791bf2d05771b88cb364dbc9e9f4e43436642b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LIBSBML_EXTERN SBMLIdConverter : public SBMLConverter\n{\npublic:\n  /** @cond doxygenLibsbmlInternal */\n  /**\n   * Register with the ConversionRegistry.\n   */\n  static void init();\n  /** @endcond */\n  /**\n   * Creates a new SBMLIdConverter object.\n   */\n  SBMLIdConverter();\n  /**\n   * Copy constructor; creates a copy of an SBMLIdConverter\n   * object.\n   *\n   * @param obj the SBMLIdConverter object to copy.\n   */\n  SBMLIdConverter(const SBMLIdConverter& obj);\n  /**\n   * Creates and returns a deep copy of this SBMLIdConverter\n   * object.\n   *\n   * @return a (deep) copy of this converter.\n   */\n  virtual SBMLIdConverter* clone() const;\n  /**\n   * Destroy this SBMLIdConverter object.\n   */\n  virtual ~SBMLIdConverter ();\n  /**\n   * Returns @c true if this converter object's properties match the given\n   * properties.\n   *\n   * A typical use of this method involves creating a ConversionProperties\n   * object, setting the options desired, and then calling this method on\n   * an SBMLIdConverter object to find out if the object's\n   * property values match the given ones.  This method is also used by\n   * SBMLConverterRegistry::getConverterFor(@if java ConversionProperties@endif)\n   * to search across all registered converters for one matching particular\n   * properties.\n   *\n   * @param props the properties to match.\n   *\n   * @return @c true if this converter's properties match, @c false\n   * otherwise.\n   */\n  virtual bool matchesProperties(const ConversionProperties &props) const;\n  /**\n   * Perform the conversion.\n   *\n   * This method causes the converter to do the actual conversion work,\n   * that is, to convert the SBMLDocument object set by\n   * SBMLConverter::setDocument(@if java SBMLDocument@endif) and\n   * with the configuration options set by\n   * SBMLConverter::setProperties(@if java ConversionProperties@endif).\n   *\n   * @copydetails doc_returns_success_code\n   * @li @sbmlconstant{LIBSBML_OPERATION_SUCCESS, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_OPERATION_FAILED, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_INVALID_OBJECT, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_UNEXPECTED_ATTRIBUTE, OperationReturnValues_t}\n   * @li @sbmlconstant{LIBSBML_INVALID_ATTRIBUTE_VALUE, OperationReturnValues_t}\n   */\n  virtual int convert();\n  /**\n   * Returns the default properties of this converter.\n   *\n   * A given converter exposes one or more properties that can be adjusted\n   * in order to influence the behavior of the converter.  This method\n   * returns the @em default property settings for this converter.  It is\n   * meant to be called in order to discover all the settings for the\n   * converter object.\n   *\n   * @return the ConversionProperties object describing the default properties\n   * for this converter.\n   */\n  virtual ConversionProperties getDefaultProperties() const;\n"]], "pred": {"ppl": 1.5705705881118774, "ppl_lower": 2.0489935874938965, "ppl/lowercase_ppl": -1.5890270072069643, "ppl/zlib": 0.00046684486582546737, "Min_5.0% Prob": 5.112339036805289, "Min_10.0% Prob": 3.4465682057773366, "Min_20.0% Prob": 2.075069228866521, "Min_30.0% Prob": 1.461742331292115, "Min_40.0% Prob": 1.1186449990553013, "Min_50.0% Prob": 0.900669290269999, "Min_60.0% Prob": 0.7518923380129112}}
{"hexsha": "13c50045383df42b3610780cb834d74d1e7eeb34", "ext": "c", "lang": "C", "content": "void* USG_allocate(size_t count, size_t size) {\n    void* data = calloc(count, size);\n    printf(\"Allocated pointer   @%p; \", data);\n    ptrCounter++;\n    __drawPtrCount();\n    return data;\n}", "item_id": 0, "repo": "yShimoka/PNC", "file": "Sources/Engine/Tools/Allocator.c", "last_update_at": "2019-10-07T13:54:33+00:00", "question_id": "13c50045383df42b3610780cb834d74d1e7eeb34_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* USG_allocate(size_t count, size_t size) {\n    void* data = calloc(count, size);\n    printf(\"Allocated pointer   @%p; \", data);\n    ptrCounter++;\n    __drawPtrCount();\n    return data;\n"]], "pred": {"ppl": 8.638517379760742, "ppl_lower": 8.109455108642578, "ppl/lowercase_ppl": -0.9706894617649815, "ppl/zlib": 0.01573891217902442, "Min_5.0% Prob": 9.812586148579916, "Min_10.0% Prob": 8.983032782872518, "Min_20.0% Prob": 7.425693952120268, "Min_30.0% Prob": 6.430834770202637, "Min_40.0% Prob": 5.1700114745360155, "Min_50.0% Prob": 4.241864373286565, "Min_60.0% Prob": 3.622369185854227}}
{"hexsha": "2510435f34edfd5e10cc4252c6e7dcfa35e95e62", "ext": "c", "lang": "C", "content": "static int ksz9021_config_intr(struct phy_device *phydev)\n{\n\tint temp, rc;\n\n\t/* set the interrupt pin active low */\n\ttemp = phy_read(phydev, MII_KSZPHY_CTRL);\n\ttemp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;\n\tphy_write(phydev, MII_KSZPHY_CTRL, temp);\n\trc = kszphy_set_interrupt(phydev);\n\treturn rc < 0 ? rc : 0;\n}", "item_id": 4, "repo": "xloem/DIY-LAPTOP", "file": "SOFTWARE/A64-TERES/linux-a64/drivers/net/phy/micrel.c", "last_update_at": "2019-08-25T09:01:38+00:00", "question_id": "2510435f34edfd5e10cc4252c6e7dcfa35e95e62_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ksz9021_config_intr(struct phy_device *phydev)\n{\n\tint temp, rc;\n\t/* set the interrupt pin active low */\n\ttemp = phy_read(phydev, MII_KSZPHY_CTRL);\n\ttemp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;\n\tphy_write(phydev, MII_KSZPHY_CTRL, temp);\n\trc = kszphy_set_interrupt(phydev);\n\treturn rc < 0 ? rc : 0;\n"]], "pred": {"ppl": 2.1277434825897217, "ppl_lower": 2.5438365936279297, "ppl/lowercase_ppl": -1.2365519470277386, "ppl/zlib": 0.003432100092352687, "Min_5.0% Prob": 6.120062964303153, "Min_10.0% Prob": 4.748171755245754, "Min_20.0% Prob": 3.209350273526948, "Min_30.0% Prob": 2.414129994636358, "Min_40.0% Prob": 1.8821574267128418, "Min_50.0% Prob": 1.5075446458354795, "Min_60.0% Prob": 1.2661921216935006}}
{"hexsha": "e93cd0ef341eea0bd8549e196f180921e3cdc6e6", "ext": "c", "lang": "C", "content": "static uint16_t WriteMultipleHoldingRegisters(const uint8_t *pucQuery, uint8_t *pucResponse)\n{\n    uint16_t usDataStartAddress = 0;\n    uint16_t usNumOfData        = 0;\n    uint16_t usMbapLength       = 0;\n    uint16_t usStartAddress     = 0;\n    uint16_t usResponseLen      = 0;\n    uint8_t  ucByteCount        = 0;\n\n    usDataStartAddress  = (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET] << 8);\n    usDataStartAddress |= (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET + 1]);\n    usNumOfData         = (uint16_t)(pucQuery[NO_OF_DATA_OFFSET] << 8);\n    usNumOfData        |= (uint16_t)(pucQuery[NO_OF_DATA_OFFSET + 1]);\n    ucByteCount         = pucQuery[WRITE_BYTE_COUNT_OFFSET];\n\n    if (ucByteCount != (usNumOfData * 2) )\n    {\n        usResponseLen = 0;\n        return usResponseLen;\n    }\n\n    usStartAddress = (usDataStartAddress - m_ModbusData->usHoldingRegisterStartAddress);\n    usMbapLength   = MBAP_LEN_WRITE_HOLDING_REGISTERS;\n\n    //Copy MBAP Header and function code into response\n    memcpy(pucResponse, pucQuery, (MBAP_HEADER_LEN + 1));\n\n    //Modify Information in MBAP Header for response\n    pucResponse[MBAP_LEN_OFFSET]         = (uint8_t)(usMbapLength << 8);\n    pucResponse[MBAP_LEN_OFFSET + 1]     = (uint8_t)(usMbapLength & 0xFF);\n    pucResponse[WRITE_START_ADDRESS]     = (uint8_t)(usDataStartAddress << 8);\n    pucResponse[WRITE_START_ADDRESS + 1] = (uint8_t)(usDataStartAddress & 0xFF);\n    pucResponse[WRITE_NUM_OF_DATA ]      = (uint8_t)(usNumOfData << 8);\n    pucResponse[WRITE_NUM_OF_DATA + 1]   = (uint8_t)(usNumOfData & 0xFF);\n\n    usResponseLen = WRITE_HOLDING_REGISTERS_RESPONSE_LEN;\n\n    uint8_t ucCount = 0;\n\n    while (usNumOfData > 0)\n    {\n        uint16_t usValue;\n\n        usValue  = (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount] << 8);\n        ucCount++;\n        usValue |= (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount]);\n        m_ModbusData->psHoldingRegisters[usStartAddress] = usValue;\n        ucCount++;\n        usStartAddress++;\n        usNumOfData--;\n    }\n\n    return (usResponseLen);\n}", "item_id": 12, "repo": "yisea123/modbus-tcp-server-1", "file": "src/mbap/mbap.c", "last_update_at": "2019-12-11T05:24:14+00:00", "question_id": "e93cd0ef341eea0bd8549e196f180921e3cdc6e6_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint16_t WriteMultipleHoldingRegisters(const uint8_t *pucQuery, uint8_t *pucResponse)\n{\n    uint16_t usDataStartAddress = 0;\n    uint16_t usNumOfData        = 0;\n    uint16_t usMbapLength       = 0;\n    uint16_t usStartAddress     = 0;\n    uint16_t usResponseLen      = 0;\n    uint8_t  ucByteCount        = 0;\n    usDataStartAddress  = (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET] << 8);\n    usDataStartAddress |= (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET + 1]);\n    usNumOfData         = (uint16_t)(pucQuery[NO_OF_DATA_OFFSET] << 8);\n    usNumOfData        |= (uint16_t)(pucQuery[NO_OF_DATA_OFFSET + 1]);\n    ucByteCount         = pucQuery[WRITE_BYTE_COUNT_OFFSET];\n    if (ucByteCount != (usNumOfData * 2) )\n    {\n        usResponseLen = 0;\n        return usResponseLen;\n    }\n    usStartAddress = (usDataStartAddress - m_ModbusData->usHoldingRegisterStartAddress);\n    usMbapLength   = MBAP_LEN_WRITE_HOLDING_REGISTERS;\n    //Copy MBAP Header and function code into response\n    memcpy(pucResponse, pucQuery, (MBAP_HEADER_LEN + 1));\n    //Modify Information in MBAP Header for response\n    pucResponse[MBAP_LEN_OFFSET]         = (uint8_t)(usMbapLength << 8);\n    pucResponse[MBAP_LEN_OFFSET + 1]     = (uint8_t)(usMbapLength & 0xFF);\n    pucResponse[WRITE_START_ADDRESS]     = (uint8_t)(usDataStartAddress << 8);\n    pucResponse[WRITE_START_ADDRESS + 1] = (uint8_t)(usDataStartAddress & 0xFF);\n    pucResponse[WRITE_NUM_OF_DATA ]      = (uint8_t)(usNumOfData << 8);\n    pucResponse[WRITE_NUM_OF_DATA + 1]   = (uint8_t)(usNumOfData & 0xFF);\n    usResponseLen = WRITE_HOLDING_REGISTERS_RESPONSE_LEN;\n    uint8_t ucCount = 0;\n    while (usNumOfData > 0)\n    {\n        uint16_t usValue;\n        usValue  = (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount] << 8);\n        ucCount++;\n        usValue |= (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount]);\n        m_ModbusData->psHoldingRegisters[usStartAddress] = usValue;\n        ucCount++;\n        usStartAddress++;\n        usNumOfData--;\n    }\n    return (usResponseLen);\n"]], "pred": {"ppl": 1.6385389566421509, "ppl_lower": 1.8000868558883667, "ppl/lowercase_ppl": -1.1904192121715833, "ppl/zlib": 0.0007863136380100949, "Min_5.0% Prob": 5.240164643526077, "Min_10.0% Prob": 3.718040066000856, "Min_20.0% Prob": 2.29986521491298, "Min_30.0% Prob": 1.6207647227333406, "Min_40.0% Prob": 1.2284453590214253, "Min_50.0% Prob": 0.9871726658589808, "Min_60.0% Prob": 0.8239464340573731}}
{"hexsha": "d7af7d649b4629e65d6959061a4fba7a7ac14489", "ext": "c", "lang": "C", "content": "static int save_freemap(struct super *sb)\n{\n\tstruct blk_buffer *b;\n\tint i = sb - super;\n\tblk_t cnt;\n\tblk_t bn;\n\tchar *p;\n\tint err;\n\t\n\tif (sb->ro)\n\t\treturn 0;\n\t\n\tp = freemap[i];\n\tif (!p)\n\t\tpanic(\"no freemap\");\n\t\n\tcnt = (sb->nblocks + 4095) / 4096;\n\t\n\tfor (bn = 0; bn < cnt; bn++, p += 512)\n\t{\n\t\tif (!freedirt[i][bn])\n\t\t\tcontinue;\n\t\t\n\t\terr = blk_get(sb->dev, bn + sb->bitmap, &b);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmemcpy(b->data, p, 512);\n\t\tb->valid = 1;\n\t\tb->dirty = 1;\n\t\tblk_put(b);\n\t\t\n\t\tfreedirt[i][bn] = 0;\n\t}\n\treturn 0;\n}", "item_id": 3, "repo": "p-durlej/xenus", "file": "kern/fs/mount.c", "last_update_at": "2019-12-29T19:33:28+00:00", "question_id": "d7af7d649b4629e65d6959061a4fba7a7ac14489_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int save_freemap(struct super *sb)\n{\n\tstruct blk_buffer *b;\n\tint i = sb - super;\n\tblk_t cnt;\n\tblk_t bn;\n\tchar *p;\n\tint err;\n\t\n\tif (sb->ro)\n\t\treturn 0;\n\t\n\tp = freemap[i];\n\tif (!p)\n\t\tpanic(\"no freemap\");\n\t\n\tcnt = (sb->nblocks + 4095) / 4096;\n\t\n\tfor (bn = 0; bn < cnt; bn++, p += 512)\n\t{\n\t\tif (!freedirt[i][bn])\n\t\t\tcontinue;\n\t\t\n\t\terr = blk_get(sb->dev, bn + sb->bitmap, &b);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmemcpy(b->data, p, 512);\n\t\tb->valid = 1;\n\t\tb->dirty = 1;\n\t\tblk_put(b);\n\t\t\n\t\tfreedirt[i][bn] = 0;\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 2.3156869411468506, "ppl_lower": 2.3156869411468506, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002753135666746805, "Min_5.0% Prob": 6.444249407450358, "Min_10.0% Prob": 5.037337446212769, "Min_20.0% Prob": 3.5039178093274432, "Min_30.0% Prob": 2.6444660471545327, "Min_40.0% Prob": 2.0590873512108465, "Min_50.0% Prob": 1.672984107267975, "Min_60.0% Prob": 1.4020458789058647}}
{"hexsha": "03eae78a4081a6194255f9c35c63ed3ca836423a", "ext": "c", "lang": "C", "content": "int DYNDNS_check_info(void)\n{\n  char buf[BUFSIZ+1];\n\n  if((host == NULL) || (*host == '\\0'))\n  {\n    if(options & OPT_DAEMON)\n    {\n      return(-1);\n    }\n    if(host) { free(host); }\n    get_input(\"host\", buf, sizeof(buf));\n    host = strdup(buf);\n  }\n\n  if(address != NULL && !is_dotted_quad(address))\n  {\n    show_message(\"the IP address \\\"%s\\\" is invalid\\n\", address);\n    return(-1);\n  }\n\n  if(interface == NULL && address == NULL)\n  {\n    if(options & OPT_DAEMON)\n    {\n      show_message(\"you must provide either an interface or an address\\n\");\n      return(-1);\n    }\n    if(interface) { free(interface); }\n    get_input(\"interface\", buf, sizeof(buf));\n    option_handler(CMD_interface, buf);\n  }\n\n  warn_fields(service->fields_used);\n\n  return 0;\n}", "item_id": 20, "repo": "impedimentToProgress/UCI-BlueChip", "file": "snapgear_linux/user/ez-ipupdate/ez-ipupdate.c", "last_update_at": "2019-12-05T02:31:23+00:00", "question_id": "03eae78a4081a6194255f9c35c63ed3ca836423a_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int DYNDNS_check_info(void)\n{\n  char buf[BUFSIZ+1];\n  if((host == NULL) || (*host == '\\0'))\n  {\n    if(options & OPT_DAEMON)\n    {\n      return(-1);\n    }\n    if(host) { free(host); }\n    get_input(\"host\", buf, sizeof(buf));\n    host = strdup(buf);\n  }\n  if(address != NULL && !is_dotted_quad(address))\n  {\n    show_message(\"the IP address \\\"%s\\\" is invalid\\n\", address);\n    return(-1);\n  }\n  if(interface == NULL && address == NULL)\n  {\n    if(options & OPT_DAEMON)\n    {\n      show_message(\"you must provide either an interface or an address\\n\");\n      return(-1);\n    }\n    if(interface) { free(interface); }\n    get_input(\"interface\", buf, sizeof(buf));\n    option_handler(CMD_interface, buf);\n  }\n  warn_fields(service->fields_used);\n  return 0;\n"]], "pred": {"ppl": 3.076605796813965, "ppl_lower": 3.447849988937378, "ppl/lowercase_ppl": -1.101371360867869, "ppl/zlib": 0.0029889015300534954, "Min_5.0% Prob": 7.757434095655169, "Min_10.0% Prob": 6.294083373887198, "Min_20.0% Prob": 4.616230440991266, "Min_30.0% Prob": 3.4932542386509122, "Min_40.0% Prob": 2.7483002511518344, "Min_50.0% Prob": 2.2259438567867518, "Min_60.0% Prob": 1.8684013939776716}}
{"hexsha": "6376fdd708f58ce6a60d5d629b43f15f96e64ae6", "ext": "c", "lang": "C", "content": "void oTDF1_3_init(oTDF1_3 * filter,double * A, double * B){\n\n\tint i;\n\t//A[0] should always equal 1.0\n\t//https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html\n\t// negate A because that link says so.\n\tfor (i=0;i<3;i++) {\n\t\tfilter->B[i] =  B[i];\n\t\tif (A != NULL)\n\t\t\tfilter->A[i] = -A[i];\n\t}\n\tif (A != NULL)\n\t\tfilter->A[0] = 1;\n\n}", "item_id": 12, "repo": "nsetzer/YueMusicPlayer", "file": "bassdsp/src/filter/oDF2.c", "last_update_at": "2019-03-06T14:29:27+00:00", "question_id": "6376fdd708f58ce6a60d5d629b43f15f96e64ae6_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void oTDF1_3_init(oTDF1_3 * filter,double * A, double * B){\n\tint i;\n\t//A[0] should always equal 1.0\n\t//https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html\n\t// negate A because that link says so.\n\tfor (i=0;i<3;i++) {\n\t\tfilter->B[i] =  B[i];\n\t\tif (A != NULL)\n\t\t\tfilter->A[i] = -A[i];\n\t}\n\tif (A != NULL)\n\t\tfilter->A[0] = 1;\n"]], "pred": {"ppl": 4.551263809204102, "ppl_lower": 5.092021465301514, "ppl/lowercase_ppl": -1.0740857690725014, "ppl/zlib": 0.006135242731413992, "Min_5.0% Prob": 9.336521983146667, "Min_10.0% Prob": 7.440779536962509, "Min_20.0% Prob": 5.536981611540823, "Min_30.0% Prob": 4.405238003730774, "Min_40.0% Prob": 3.605140593918887, "Min_50.0% Prob": 2.9663381400596665, "Min_60.0% Prob": 2.5002752950787546}}
{"hexsha": "3deea9d9fe231de0d6e8a124d9718a4dc9af1f5e", "ext": "c", "lang": "C", "content": "static int\nsdhci_get_ro(device_t brdev, device_t reqdev)\n{\n\tstruct sdhci_slot *slot = device_get_ivars(reqdev);\n\tuint32_t val;\n\n\tSDHCI_LOCK(slot);\n\tval = RD4(slot, SDHCI_PRESENT_STATE);\n\tSDHCI_UNLOCK(slot);\n\treturn (!(val & SDHCI_WRITE_PROTECT));\n}", "item_id": 22, "repo": "cooljeanius/DragonFlyBSD", "file": "sys/dev/disk/sdhci/sdhci.c", "last_update_at": "2019-11-23T09:35:10+00:00", "question_id": "3deea9d9fe231de0d6e8a124d9718a4dc9af1f5e_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nsdhci_get_ro(device_t brdev, device_t reqdev)\n{\n\tstruct sdhci_slot *slot = device_get_ivars(reqdev);\n\tuint32_t val;\n\tSDHCI_LOCK(slot);\n\tval = RD4(slot, SDHCI_PRESENT_STATE);\n\tSDHCI_UNLOCK(slot);\n\treturn (!(val & SDHCI_WRITE_PROTECT));\n"]], "pred": {"ppl": 1.6385868787765503, "ppl_lower": 2.066847562789917, "ppl/lowercase_ppl": -1.4701786826394492, "ppl/zlib": 0.0027588503414065365, "Min_5.0% Prob": 5.474370241165161, "Min_10.0% Prob": 4.14336696267128, "Min_20.0% Prob": 2.355068398018678, "Min_30.0% Prob": 1.635112619234456, "Min_40.0% Prob": 1.240809824084863, "Min_50.0% Prob": 0.9951911968955149, "Min_60.0% Prob": 0.8298067489352737}}
{"hexsha": "77ddf27b512a05c85c28792ad5e6a547aa14f762", "ext": "c", "lang": "C", "content": "MagickExport MagickBooleanType NegateImage(Image *image,\n  const MagickBooleanType grayscale)\n{\n  MagickBooleanType\n    status;\n\n  status=NegateImageChannel(image,DefaultChannels,grayscale);\n  return(status);\n}", "item_id": 16, "repo": "KiiCorp/ImageMagick", "file": "magick/enhance.c", "last_update_at": "2019-10-12T09:55:12+00:00", "question_id": "77ddf27b512a05c85c28792ad5e6a547aa14f762_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MagickExport MagickBooleanType NegateImage(Image *image,\n  const MagickBooleanType grayscale)\n{\n  MagickBooleanType\n    status;\n  status=NegateImageChannel(image,DefaultChannels,grayscale);\n  return(status);\n"]], "pred": {"ppl": 2.467609405517578, "ppl_lower": 6.8527021408081055, "ppl/lowercase_ppl": -2.1307981289119584, "ppl/zlib": 0.0066415428672905895, "Min_5.0% Prob": 10.387679735819498, "Min_10.0% Prob": 7.441378752390544, "Min_20.0% Prob": 4.147627582916846, "Min_30.0% Prob": 3.0015024213414443, "Min_40.0% Prob": 2.2376109063625336, "Min_50.0% Prob": 1.830389334121719, "Min_60.0% Prob": 1.5042884189229555}}
{"hexsha": "af380d7bd145590bd9825fa6291a99ba38386d6f", "ext": "c", "lang": "C", "content": "BOOL WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPVOID path)\n{\n\tTRACE_(shell)(\"%p %p\\n\", pidl, path);\n\tif (SHELL_OsIsUnicode())\n\t  return ILGetDisplayNameExW(NULL, pidl, path, ILGDN_FORPARSING);\n\treturn ILGetDisplayNameExA(NULL, pidl, path, ILGDN_FORPARSING);\n}", "item_id": 3, "repo": "roytam1/wine-win31look", "file": "dlls/shell32/pidl.c", "last_update_at": "2019-10-23T04:07:16+00:00", "question_id": "af380d7bd145590bd9825fa6291a99ba38386d6f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPVOID path)\n{\n\tTRACE_(shell)(\"%p %p\\n\", pidl, path);\n\tif (SHELL_OsIsUnicode())\n\t  return ILGetDisplayNameExW(NULL, pidl, path, ILGDN_FORPARSING);\n\treturn ILGetDisplayNameExA(NULL, pidl, path, ILGDN_FORPARSING);\n"]], "pred": {"ppl": 3.317412853240967, "ppl_lower": 8.681926727294922, "ppl/lowercase_ppl": -1.802259938377553, "ppl/zlib": 0.007054030694556841, "Min_5.0% Prob": 9.045133590698242, "Min_10.0% Prob": 7.168261788108132, "Min_20.0% Prob": 5.244256967847997, "Min_30.0% Prob": 3.91526580398733, "Min_40.0% Prob": 2.9703742259078556, "Min_50.0% Prob": 2.4097183692668165, "Min_60.0% Prob": 2.020156000393318}}
{"hexsha": "cb6d1d6c7033204296f890d2a1eef48f245c1efc", "ext": "c", "lang": "C", "content": "void\nupdateWindowAttributes(CompWindow *w,\n                       CompStackingUpdateMode stackingMode)\n{\n   XWindowChanges xwc;\n   int mask = 0;\n\n   if (w->attrib.override_redirect || !w->managed)\n     return;\n\n   if (w->state & CompWindowStateShadedMask)\n     {\n        hideWindow(w);\n     }\n   else if (w->shaded)\n     {\n        showWindow(w);\n     }\n\n   if (stackingMode != CompStackingUpdateModeNone)\n     {\n        Bool aboveFs;\n        CompWindow *sibling;\n\n        aboveFs = (stackingMode == CompStackingUpdateModeAboveFullscreen);\n        if (w->type & CompWindowTypeFullscreenMask)\n          {\n             /* put active or soon-to-be-active fullscreen windows over\n                all others in their layer */\n             if (w->id == w->screen->display->activeWindow)\n               {\n                  aboveFs = TRUE;\n               }\n          }\n\n        /* put windows that are just mapped, over fullscreen windows */\n        if (stackingMode == CompStackingUpdateModeInitialMap)\n          aboveFs = TRUE;\n\n        sibling = findSiblingBelow(w, aboveFs);\n\n        if (sibling &&\n            (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))\n          {\n             CompWindow *p;\n\n             for (p = sibling; p; p = p->prev)\n               if (p->id == w->screen->display->activeWindow)\n                 break;\n\n             /* window is above active window so we should lower it, assuming that\n              * is allowed (if, for example, our window has the \"above\" state,\n              * then lowering beneath the active window may not be allowed.)\n              */\n             if (p && validSiblingBelow(p, w))\n               {\n                  p = findValidStackSiblingBelow(sibling, p);\n\n                  /* if we found a valid sibling under the active window, it's\n                     our new sibling we want to stack above */\n                  if (p)\n                    sibling = p;\n               }\n          }\n\n        mask |= addWindowStackChanges(w, &xwc, sibling);\n     }\n\n   if ((stackingMode == CompStackingUpdateModeInitialMap) ||\n       (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))\n     {\n        /* If we are called from the MapRequest handler, we have to\n           immediately update the internal stack. If we don't do that,\n           the internal stacking order is invalid until the ConfigureNotify\n           arrives because we put the window at the top of the stack when\n           it was created */\n        if (mask & CWStackMode)\n          {\n             Window above = (mask & CWSibling) ? xwc.sibling : 0;\n             restackWindow(w, above);\n          }\n     }\n\n   mask |= addWindowSizeChanges(w, &xwc,\n                                w->serverX, w->serverY,\n                                w->serverWidth, w->serverHeight,\n                                w->serverBorderWidth);\n\n   if (w->mapNum && (mask & (CWWidth | CWHeight)))\n     sendSyncRequest(w);\n\n   if (mask)\n     configureXWindow(w, mask, &xwc);\n}", "item_id": 78, "repo": "zmike/compiz", "file": "src/exports/window.c", "last_update_at": "2019-09-17T07:24:13+00:00", "question_id": "cb6d1d6c7033204296f890d2a1eef48f245c1efc_78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nupdateWindowAttributes(CompWindow *w,\n                       CompStackingUpdateMode stackingMode)\n{\n   XWindowChanges xwc;\n   int mask = 0;\n   if (w->attrib.override_redirect || !w->managed)\n     return;\n   if (w->state & CompWindowStateShadedMask)\n     {\n        hideWindow(w);\n     }\n   else if (w->shaded)\n     {\n        showWindow(w);\n     }\n   if (stackingMode != CompStackingUpdateModeNone)\n     {\n        Bool aboveFs;\n        CompWindow *sibling;\n        aboveFs = (stackingMode == CompStackingUpdateModeAboveFullscreen);\n        if (w->type & CompWindowTypeFullscreenMask)\n          {\n             /* put active or soon-to-be-active fullscreen windows over\n                all others in their layer */\n             if (w->id == w->screen->display->activeWindow)\n               {\n                  aboveFs = TRUE;\n               }\n          }\n        /* put windows that are just mapped, over fullscreen windows */\n        if (stackingMode == CompStackingUpdateModeInitialMap)\n          aboveFs = TRUE;\n        sibling = findSiblingBelow(w, aboveFs);\n        if (sibling &&\n            (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))\n          {\n             CompWindow *p;\n             for (p = sibling; p; p = p->prev)\n               if (p->id == w->screen->display->activeWindow)\n                 break;\n             /* window is above active window so we should lower it, assuming that\n              * is allowed (if, for example, our window has the \"above\" state,\n              * then lowering beneath the active window may not be allowed.)\n              */\n             if (p && validSiblingBelow(p, w))\n               {\n                  p = findValidStackSiblingBelow(sibling, p);\n                  /* if we found a valid sibling under the active window, it's\n                     our new sibling we want to stack above */\n                  if (p)\n                    sibling = p;\n               }\n          }\n        mask |= addWindowStackChanges(w, &xwc, sibling);\n     }\n   if ((stackingMode == CompStackingUpdateModeInitialMap) ||\n       (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))\n     {\n        /* If we are called from the MapRequest handler, we have to\n           immediately update the internal stack. If we don't do that,\n           the internal stacking order is invalid until the ConfigureNotify\n           arrives because we put the window at the top of the stack when\n           it was created */\n        if (mask & CWStackMode)\n          {\n             Window above = (mask & CWSibling) ? xwc.sibling : 0;\n             restackWindow(w, above);\n          }\n     }\n   mask |= addWindowSizeChanges(w, &xwc,\n                                w->serverX, w->serverY,\n                                w->serverWidth, w->serverHeight,\n                                w->serverBorderWidth);\n   if (w->mapNum && (mask & (CWWidth | CWHeight)))\n     sendSyncRequest(w);\n   if (mask)\n     configureXWindow(w, mask, &xwc);\n"]], "pred": {"ppl": 3.0630123615264893, "ppl_lower": 3.3753767013549805, "ppl/lowercase_ppl": -1.0867501950104939, "ppl/zlib": 0.001091032030799618, "Min_5.0% Prob": 7.583605556953244, "Min_10.0% Prob": 6.006969561059791, "Min_20.0% Prob": 4.364619143037911, "Min_30.0% Prob": 3.377782771386296, "Min_40.0% Prob": 2.6896939073880035, "Min_50.0% Prob": 2.208484077956303, "Min_60.0% Prob": 1.8601596902262973}}
{"hexsha": "c655c85926feaff8a0723b4f369c9e6324c4601c", "ext": "c", "lang": "C", "content": "SEXP attribute_hidden do_D2POSIXlt(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    SEXP x, ans, ansnames, klass;\n    R_xlen_t n;\n    int valid, day, y, tmp, mon;\n    stm tm;\n\n    checkArity(op, args);\n    PROTECT(x = coerceVector(CAR(args), REALSXP));\n    n = XLENGTH(x);\n    PROTECT(ans = allocVector(VECSXP, 9));\n    for(int i = 0; i < 9; i++)\n\tSET_VECTOR_ELT(ans, i, allocVector(i > 0 ? INTSXP : REALSXP, n));\n\n    PROTECT(ansnames = allocVector(STRSXP, 9));\n    for(int i = 0; i < 9; i++)\n\tSET_STRING_ELT(ansnames, i, mkChar(ltnames[i]));\n\n    for(R_xlen_t i = 0; i < n; i++) {\n\tif(R_FINITE(REAL(x)[i])) {\n\t    day = (int) floor(REAL(x)[i]);\n\t    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n\t    /* weekday: 1970-01-01 was a Thursday */\n\t    if ((tm.tm_wday = ((4 + day) % 7)) < 0) tm.tm_wday += 7;\n\n\t    /* year & day within year */\n\t    y = 1970;\n\t    if (day >= 0)\n\t\tfor ( ; day >= (tmp = days_in_year(y)); day -= tmp, y++);\n\t    else\n\t\tfor ( ; day < 0; --y, day += days_in_year(y) );\n\n\t    y = tm.tm_year = y - 1900;\n\t    tm.tm_yday = day;\n\n\t    /* month within year */\n\t    for (mon = 0;\n\t\t day >= (tmp = (days_in_month[mon]) +\n\t\t\t ((mon==1 && isleap(y+1900))?1:0));\n\t\t day -= tmp, mon++);\n\t    tm.tm_mon = mon;\n\t    tm.tm_mday = day + 1;\n\t    tm.tm_isdst = 0; /* no dst in GMT */\n\n\t    valid = 1;\n\t} else valid = 0;\n\tmakelt(&tm, ans, i, valid, 0.0);\n    }\n    setAttrib(ans, R_NamesSymbol, ansnames);\n    PROTECT(klass = allocVector(STRSXP, 2));\n    SET_STRING_ELT(klass, 0, mkChar(\"POSIXlt\"));\n    SET_STRING_ELT(klass, 1, mkChar(\"POSIXt\"));\n    classgets(ans, klass);\n    SEXP s_tzone = install(\"tzone\");\n    setAttrib(ans, s_tzone, mkString(\"UTC\"));\n    SEXP nm = getAttrib(x, R_NamesSymbol);\n    if(nm != R_NilValue) setAttrib(VECTOR_ELT(ans, 5), R_NamesSymbol, nm);\n    UNPROTECT(4);\n\n    return ans;\n}", "item_id": 11, "repo": "lifebit-ai/exomedepth", "file": "bin/R-3.5.1/src/main/datetime.c", "last_update_at": "2019-07-28T20:32:29+00:00", "question_id": "c655c85926feaff8a0723b4f369c9e6324c4601c_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SEXP attribute_hidden do_D2POSIXlt(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    SEXP x, ans, ansnames, klass;\n    R_xlen_t n;\n    int valid, day, y, tmp, mon;\n    stm tm;\n    checkArity(op, args);\n    PROTECT(x = coerceVector(CAR(args), REALSXP));\n    n = XLENGTH(x);\n    PROTECT(ans = allocVector(VECSXP, 9));\n    for(int i = 0; i < 9; i++)\n\tSET_VECTOR_ELT(ans, i, allocVector(i > 0 ? INTSXP : REALSXP, n));\n    PROTECT(ansnames = allocVector(STRSXP, 9));\n    for(int i = 0; i < 9; i++)\n\tSET_STRING_ELT(ansnames, i, mkChar(ltnames[i]));\n    for(R_xlen_t i = 0; i < n; i++) {\n\tif(R_FINITE(REAL(x)[i])) {\n\t    day = (int) floor(REAL(x)[i]);\n\t    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n\t    /* weekday: 1970-01-01 was a Thursday */\n\t    if ((tm.tm_wday = ((4 + day) % 7)) < 0) tm.tm_wday += 7;\n\t    /* year & day within year */\n\t    y = 1970;\n\t    if (day >= 0)\n\t\tfor ( ; day >= (tmp = days_in_year(y)); day -= tmp, y++);\n\t    else\n\t\tfor ( ; day < 0; --y, day += days_in_year(y) );\n\t    y = tm.tm_year = y - 1900;\n\t    tm.tm_yday = day;\n\t    /* month within year */\n\t    for (mon = 0;\n\t\t day >= (tmp = (days_in_month[mon]) +\n\t\t\t ((mon==1 && isleap(y+1900))?1:0));\n\t\t day -= tmp, mon++);\n\t    tm.tm_mon = mon;\n\t    tm.tm_mday = day + 1;\n\t    tm.tm_isdst = 0; /* no dst in GMT */\n\t    valid = 1;\n\t} else valid = 0;\n\tmakelt(&tm, ans, i, valid, 0.0);\n    }\n    setAttrib(ans, R_NamesSymbol, ansnames);\n    PROTECT(klass = allocVector(STRSXP, 2));\n    SET_STRING_ELT(klass, 0, mkChar(\"POSIXlt\"));\n    SET_STRING_ELT(klass, 1, mkChar(\"POSIXt\"));\n    classgets(ans, klass);\n    SEXP s_tzone = install(\"tzone\");\n    setAttrib(ans, s_tzone, mkString(\"UTC\"));\n    SEXP nm = getAttrib(x, R_NamesSymbol);\n    if(nm != R_NilValue) setAttrib(VECTOR_ELT(ans, 5), R_NamesSymbol, nm);\n    UNPROTECT(4);\n    return ans;\n"]], "pred": {"ppl": 1.9162871837615967, "ppl_lower": 2.486232280731201, "ppl/lowercase_ppl": -1.4003429431067682, "ppl/zlib": 0.0007912281696562308, "Min_5.0% Prob": 6.547297621882239, "Min_10.0% Prob": 4.733013311097788, "Min_20.0% Prob": 3.0147884029873535, "Min_30.0% Prob": 2.1200646844047766, "Min_40.0% Prob": 1.6161837254171771, "Min_50.0% Prob": 1.2983884166917543, "Min_60.0% Prob": 1.0833406361661708}}
{"hexsha": "519d9a0d712e0649e71765f6d6589195e27141bf", "ext": "c", "lang": "C", "content": "void VID_MenuDraw (void)\r\n{\r\n\tqpic_t\t\t*p;\r\n\tchar\t\t*ptr;\r\n\tint\t\t\tnummodes, i, j, column, row, dup;\r\n\tchar\t\ttemp[100];\r\n\r\n\tvid_wmodes = 0;\r\n\tnummodes = VID_NumModes ();\r\n\t\r\n\tp = Draw_CachePic (\"gfx/vidmodes.lmp\");\r\n\tM_DrawPic ( (320-p->width)/2, 4, p);\r\n\r\n\tfor (i=0 ; i<nummodes ; i++)\r\n\t{\r\n\t\tif (vid_wmodes < MAX_MODEDESCS)\r\n\t\t{\r\n\t\t\tif (i != 1)\r\n\t\t\t{\r\n\t\t\t\tptr = VID_GetModeDescription (i);\r\n\r\n\t\t\t\tif (ptr)\r\n\t\t\t\t{\r\n\t\t\t\t\tdup = 0;\r\n\r\n\t\t\t\t\tfor (j=0 ; j<vid_wmodes ; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!strcmp (modedescs[j].desc, ptr))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (modedescs[j].modenum != 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmodedescs[j].modenum = i;\r\n\t\t\t\t\t\t\t\tdup = 1;\r\n\r\n\t\t\t\t\t\t\t\tif (i == vid_modenum)\r\n\t\t\t\t\t\t\t\t\tmodedescs[j].iscur = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdup = 1;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!dup)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].modenum = i;\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].desc = ptr;\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].iscur = 0;\r\n\r\n\t\t\t\t\t\tif (i == vid_modenum)\r\n\t\t\t\t\t\t\tmodedescs[vid_wmodes].iscur = 1;\r\n\r\n\t\t\t\t\t\tvid_wmodes++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvid_column_size = (vid_wmodes + 2) / 3;\r\n\r\n\tcolumn = 16;\r\n\trow = 36;\r\n\r\n\tfor (i=0 ; i<vid_wmodes ; i++)\r\n\t{\r\n\t\tif (modedescs[i].iscur)\r\n\t\t\tM_PrintWhite (column, row, modedescs[i].desc);\r\n\t\telse\r\n\t\t\tM_Print (column, row, modedescs[i].desc);\r\n\r\n\t\trow += 8;\r\n\r\n\t\tif ((i % vid_column_size) == (vid_column_size - 1))\r\n\t\t{\r\n\t\t\tcolumn += 13*8;\r\n\t\t\trow = 36;\r\n\t\t}\r\n\t}\r\n\r\n// line cursor\r\n\tif (vid_testingmode)\r\n\t{\r\n\t\tsprintf (temp, \"TESTING %s\",\r\n\t\t\t\tmodedescs[vid_line].desc);\r\n\t\tM_Print (13*8, 36 + MAX_COLUMN_SIZE * 8 + 8*4, temp);\r\n\t\tM_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6,\r\n\t\t\t\t\"Please wait 5 seconds...\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tM_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8,\r\n\t\t\t\t\"Press Enter to set mode\");\r\n\t\tM_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*3,\r\n\t\t\t\t\"T to test mode for 5 seconds\");\r\n\t\tptr = VID_GetModeDescription (vid_modenum);\r\n\t\tsprintf (temp, \"D to make %s the default\", ptr);\r\n\t\tM_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*5, temp);\r\n\t\tptr = VID_GetModeDescription ((int)_vid_default_mode.value);\r\n\r\n\t\tif (ptr)\r\n\t\t{\r\n\t\t\tsprintf (temp, \"Current default is %s\", ptr);\r\n\t\t\tM_Print (7*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6, temp);\r\n\t\t}\r\n\r\n\t\tM_Print (15*8, 36 + MAX_COLUMN_SIZE * 8 + 8*8,\r\n\t\t\t\t\"Esc to exit\");\r\n\r\n\t\trow = 36 + (vid_line % vid_column_size) * 8;\r\n\t\tcolumn = 8 + (vid_line / vid_column_size) * 13*8;\r\n\r\n\t\tM_DrawCharacter (column, row, 12+((int)(realtime*4)&1));\r\n\t}\r\n}", "item_id": 13, "repo": "chaos4ever/chaos-old", "file": "programs/quake/q1source/WinQuake/vid_dos.c", "last_update_at": "2019-12-10T15:47:15+00:00", "question_id": "519d9a0d712e0649e71765f6d6589195e27141bf_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void VID_MenuDraw (void)\r\n{\r\n\tqpic_t\t\t*p;\r\n\tchar\t\t*ptr;\r\n\tint\t\t\tnummodes, i, j, column, row, dup;\r\n\tchar\t\ttemp[100];\r\n\r\n\tvid_wmodes = 0;\r\n\tnummodes = VID_NumModes ();\r\n\t\r\n\tp = Draw_CachePic (\"gfx/vidmodes.lmp\");\r\n\tM_DrawPic ( (320-p->width)/2, 4, p);\r\n\r\n\tfor (i=0 ; i<nummodes ; i++)\r\n\t{\r\n\t\tif (vid_wmodes < MAX_MODEDESCS)\r\n\t\t{\r\n\t\t\tif (i != 1)\r\n\t\t\t{\r\n\t\t\t\tptr = VID_GetModeDescription (i);\r\n\r\n\t\t\t\tif (ptr)\r\n\t\t\t\t{\r\n\t\t\t\t\tdup = 0;\r\n\r\n\t\t\t\t\tfor (j=0 ; j<vid_wmodes ; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!strcmp (modedescs[j].desc, ptr))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (modedescs[j].modenum != 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmodedescs[j].modenum = i;\r\n\t\t\t\t\t\t\t\tdup = 1;\r\n\r\n\t\t\t\t\t\t\t\tif (i == vid_modenum)\r\n\t\t\t\t\t\t\t\t\tmodedescs[j].iscur = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdup = 1;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!dup)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].modenum = i;\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].desc = ptr;\r\n\t\t\t\t\t\tmodedescs[vid_wmodes].iscur = 0;\r\n\r\n\t\t\t\t\t\tif (i == vid_modenum)\r\n\t\t\t\t\t\t\tmodedescs[vid_wmodes].iscur = 1;\r\n\r\n\t\t\t\t\t\tvid_wmodes++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvid_column_size = (vid_wmodes + 2) / 3;\r\n\r\n\tcolumn = 16;\r\n\trow = 36;\r\n\r\n\tfor (i=0 ; i<vid_wmodes ; i++)\r\n\t{\r\n\t\tif (modedescs[i].iscur)\r\n\t\t\tM_PrintWhite (column, row, modedescs[i].desc);\r\n\t\telse\r\n\t\t\tM_Print (column, row, modedescs[i].desc);\r\n\r\n\t\trow += 8;\r\n\r\n\t\tif ((i % vid_column_size) == (vid_column_size - 1))\r\n\t\t{\r\n\t\t\tcolumn += 13*8;\r\n\t\t\trow = 36;\r\n\t\t}\r\n\t}\r\n\r\n// line cursor\r\n\tif (vid_testingmode)\r\n\t{\r\n\t\tsprintf (temp, \"TESTING %s\",\r\n\t\t\t\tmodedescs[vid_line].desc);\r\n\t\tM_Print (13*8, 36 + MAX_COLUMN_SIZE * 8 + 8*4, temp);\r\n\t\tM_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6,\r\n\t\t\t\t\"Please wait 5 seconds...\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tM_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8,\r\n\t\t\t\t\"Press Enter to set mode\");\r\n\t\tM_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*3,\r\n\t\t\t\t\"T to test mode for 5 seconds\");\r\n\t\tptr = VID_GetModeDescription (vid_modenum);\r\n\t\tsprintf (temp, \"D to make %s the default\", ptr);\r\n\t\tM_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*5, temp);\r\n\t\tptr = VID_GetModeDescription ((int)_vid_default_mode.value);\r\n\r\n\t\tif (ptr)\r\n\t\t{\r\n\t\t\tsprintf (temp, \"Current default is %s\", ptr);\r\n\t\t\tM_Print (7*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6, temp);\r\n\t\t}\r\n\r\n\t\tM_Print (15*8, 36 + MAX_COLUMN_SIZE * 8 + 8*8,\r\n\t\t\t\t\"Esc to exit\");\r\n\r\n\t\trow = 36 + (vid_line % vid_column_size) * 8;\r\n\t\tcolumn = 8 + (vid_line / vid_column_size) * 13*8;\r\n\r\n\t\tM_DrawCharacter (column, row, 12+((int)(realtime*4)&1));\r\n\t}\r\n"]], "pred": {"ppl": 1.7097718715667725, "ppl_lower": 1.7805263996124268, "ppl/lowercase_ppl": -1.0756005314890305, "ppl/zlib": 0.0006122830515689349, "Min_5.0% Prob": 5.864513990925808, "Min_10.0% Prob": 4.089693459809995, "Min_20.0% Prob": 2.51704070980058, "Min_30.0% Prob": 1.7634571447384124, "Min_40.0% Prob": 1.3357809576180861, "Min_50.0% Prob": 1.0727780899288106, "Min_60.0% Prob": 0.8949612175411853}}
{"hexsha": "b12348cc69d6fad4b0e0936c5b53d823bd7d0731", "ext": "c", "lang": "C", "content": "static void print_qconf_table(app_args_t *args)\n{\n\tint i, j, k, qid, if_idx;\n\tchar buf[32];\n\tstruct thread_arg_s *thr_arg;\n\n\tprintf(\"Rx Queue table\\n\"\n\t       \"-----------------\\n\"\n\t       \"%-32s%-16s%-16s\\n\",\n\t       \"port/id\", \"rxq\", \"thread\");\n\n\tfor (i = 0; i < args->worker_count; i++) {\n\t\tthr_arg = &global.worker_args[i];\n\t\tfor (j = 0; j < args->if_count; j++) {\n\t\t\tif (!thr_arg->pktio[j].nb_rxq)\n\t\t\t\tcontinue;\n\n\t\t\tif_idx = thr_arg->pktio[j].if_idx;\n\t\t\tsnprintf(buf, 32, \"%s/%d\", args->if_names[if_idx],\n\t\t\t\t if_idx);\n\t\t\tfor (k = 0; k < MAX_NB_QUEUE; k++) {\n\t\t\t\tqid = thr_arg->pktio[j].rxq[k];\n\t\t\t\tif (qid != INVALID_ID)\n\t\t\t\t\tprintf(\"%-32s%-16d%-16d\\n\", buf, qid,\n\t\t\t\t\t       thr_arg->thr_idx);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tfflush(NULL);\n}", "item_id": 13, "repo": "bala-manoharan/odp-dpdk", "file": "example/l3fwd/odp_l3fwd.c", "last_update_at": "2019-02-09T08:41:27+00:00", "question_id": "b12348cc69d6fad4b0e0936c5b53d823bd7d0731_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_qconf_table(app_args_t *args)\n{\n\tint i, j, k, qid, if_idx;\n\tchar buf[32];\n\tstruct thread_arg_s *thr_arg;\n\tprintf(\"Rx Queue table\\n\"\n\t       \"-----------------\\n\"\n\t       \"%-32s%-16s%-16s\\n\",\n\t       \"port/id\", \"rxq\", \"thread\");\n\tfor (i = 0; i < args->worker_count; i++) {\n\t\tthr_arg = &global.worker_args[i];\n\t\tfor (j = 0; j < args->if_count; j++) {\n\t\t\tif (!thr_arg->pktio[j].nb_rxq)\n\t\t\t\tcontinue;\n\t\t\tif_idx = thr_arg->pktio[j].if_idx;\n\t\t\tsnprintf(buf, 32, \"%s/%d\", args->if_names[if_idx],\n\t\t\t\t if_idx);\n\t\t\tfor (k = 0; k < MAX_NB_QUEUE; k++) {\n\t\t\t\tqid = thr_arg->pktio[j].rxq[k];\n\t\t\t\tif (qid != INVALID_ID)\n\t\t\t\t\tprintf(\"%-32s%-16d%-16d\\n\", buf, qid,\n\t\t\t\t\t       thr_arg->thr_idx);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tfflush(NULL);\n"]], "pred": {"ppl": 2.2298924922943115, "ppl_lower": 2.293919086456299, "ppl/lowercase_ppl": -1.0352992737372273, "ppl/zlib": 0.001923149579319924, "Min_5.0% Prob": 6.566243849302593, "Min_10.0% Prob": 5.047160319792918, "Min_20.0% Prob": 3.4091243110125578, "Min_30.0% Prob": 2.521503322515167, "Min_40.0% Prob": 1.9801801990104626, "Min_50.0% Prob": 1.601316130880003, "Min_60.0% Prob": 1.3364387188505913}}
{"hexsha": "da53bc3a2f1845277cde5cf9b9eabcd55a18af69", "ext": "h", "lang": "C", "content": "class NxRevoluteJointDesc : public NxJointDesc\n\t{\n\tpublic:\n\t/**\n\t\\brief Optional limits for the angular motion of the joint. \n\n\t<b>Range:</b> See #NxJointLimitPairDesc<br>\n\t<b>Default:</b> See #NxJointLimitPairDesc\n\n\t@see NxJointLimitPairDesc NxJointLimitDesc NxRevoluteJointFlag\n\t*/\n\tNxJointLimitPairDesc limit;\n\n\t/**\n\t\\brief Optional motor.\n\n\t<b>Range:</b> See #NxMotorDesc<br>\n\t<b>Default:</b> See #NxMotorDesc\n\n\t@see NxMotorDesc NxRevoluteJointFlag\n\t*/\n\tNxMotorDesc\t\t\t motor; \n\n\t/**\n\t\\brief Optional spring.\n\n\t<b>Range:</b> See #NxSpringDesc<br>\n\t<b>Default:</b> See #NxSpringDesc\n\n\t@see NxSpringDesc NxRevoluteJointFlag\n\t*/\n\tNxSpringDesc\t\t spring;\n\n\t/**\n\t\\brief The distance beyond which the joint is projected.\n\t\n\tprojectionMode is NX_JPM_POINT_MINDIST, the joint gets artificially projected together when it drifts more than this distance. Sometimes it is not possible to project (for example when the joints form a cycle)\n\tShould be nonnegative. However, it may be a bad idea to always project to a very small or zero distance because the solver *needs* some error in order to produce correct motion.\n\n\t<b>Range:</b> [0,inf)<br>\n\t<b>Default:</b> 1.0\n\n\t@see projectionMode projectionAngle\n    */\n\tNxReal projectionDistance;\t\n\n\t/**\n\t\\brief The angle beyond which the joint is projected.\n\t\n\tThis similar to #projectionDistance, except this is an angle (in radians) to which angular drift is \n\tprojected.\n\n\t<b>Unit:</b> Radians\n\t<b>Range:</b> (0.2,PI)<br>\n\t<b>Default:</b> 0.0872 (about 5 degrees in radians)\n\n\t@see projectionDistance projectionMode\n\t*/\n\tNxReal projectionAngle;\n\n\t/**\n\t\\brief This is a combination of the bits defined by ::NxRevoluteJointFlag.\n\n\t<b>Default:</b> 0\n\n\t@see NxRevoluteJointFlag\n\t*/\n\tNxU32 flags;\n\n\t/**\n\t\\brief use this to enable joint projection\n\n\t<b>Default:</b> NX_JPM_NONE\n\n\t@see NxJointProjectionMode projectionDistance projectionAngle NxRevoluteJoint.setProjectionMode()\n\t*/\n\tNxJointProjectionMode projectionMode;\n\n\t/**\n\t\\brief constructor sets to default.\n\t*/\n\n\tNX_INLINE NxRevoluteJointDesc();\t\n\t/**\n\t\\brief (re)sets the structure to the default.\t\n\n\t\\param[in] fromCtor Avoid redundant work if called from constructor.\n\t*/\n\tNX_INLINE void setToDefault(bool fromCtor = false);\n\t\n\t/**\n\t\\brief Returns true if the descriptor is valid.\n\t\n\t\\return true if the current settings are valid\n\t*/\n\tNX_INLINE bool isValid() const;\n\n\t}", "item_id": 0, "repo": "uvbs/FullSource", "file": "ThirdParty/PhysX/include/NxRevoluteJointDesc.h", "last_update_at": "2019-05-31T14:32:18+00:00", "question_id": "da53bc3a2f1845277cde5cf9b9eabcd55a18af69_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class NxRevoluteJointDesc : public NxJointDesc\n\t{\n\tpublic:\n\t/**\n\t\\brief Optional limits for the angular motion of the joint. \n\t<b>Range:</b> See #NxJointLimitPairDesc<br>\n\t<b>Default:</b> See #NxJointLimitPairDesc\n\t@see NxJointLimitPairDesc NxJointLimitDesc NxRevoluteJointFlag\n\t*/\n\tNxJointLimitPairDesc limit;\n\t/**\n\t\\brief Optional motor.\n\t<b>Range:</b> See #NxMotorDesc<br>\n\t<b>Default:</b> See #NxMotorDesc\n\t@see NxMotorDesc NxRevoluteJointFlag\n\t*/\n\tNxMotorDesc\t\t\t motor; \n\t/**\n\t\\brief Optional spring.\n\t<b>Range:</b> See #NxSpringDesc<br>\n\t<b>Default:</b> See #NxSpringDesc\n\t@see NxSpringDesc NxRevoluteJointFlag\n\t*/\n\tNxSpringDesc\t\t spring;\n\t/**\n\t\\brief The distance beyond which the joint is projected.\n\t\n\tprojectionMode is NX_JPM_POINT_MINDIST, the joint gets artificially projected together when it drifts more than this distance. Sometimes it is not possible to project (for example when the joints form a cycle)\n\tShould be nonnegative. However, it may be a bad idea to always project to a very small or zero distance because the solver *needs* some error in order to produce correct motion.\n\t<b>Range:</b> [0,inf)<br>\n\t<b>Default:</b> 1.0\n\t@see projectionMode projectionAngle\n    */\n\tNxReal projectionDistance;\t\n\t/**\n\t\\brief The angle beyond which the joint is projected.\n\t\n\tThis similar to #projectionDistance, except this is an angle (in radians) to which angular drift is \n\tprojected.\n\t<b>Unit:</b> Radians\n\t<b>Range:</b> (0.2,PI)<br>\n\t<b>Default:</b> 0.0872 (about 5 degrees in radians)\n\t@see projectionDistance projectionMode\n\t*/\n\tNxReal projectionAngle;\n\t/**\n\t\\brief This is a combination of the bits defined by ::NxRevoluteJointFlag.\n\t<b>Default:</b> 0\n\t@see NxRevoluteJointFlag\n\t*/\n\tNxU32 flags;\n\t/**\n\t\\brief use this to enable joint projection\n\t<b>Default:</b> NX_JPM_NONE\n\t@see NxJointProjectionMode projectionDistance projectionAngle NxRevoluteJoint.setProjectionMode()\n\t*/\n\tNxJointProjectionMode projectionMode;\n\t/**\n\t\\brief constructor sets to default.\n\t*/\n\tNX_INLINE NxRevoluteJointDesc();\t\n\t/**\n\t\\brief (re)sets the structure to the default.\t\n\t\\param[in] fromCtor Avoid redundant work if called from constructor.\n\t*/\n\tNX_INLINE void setToDefault(bool fromCtor = false);\n\t\n\t/**\n\t\\brief Returns true if the descriptor is valid.\n\t\n\t\\return true if the current settings are valid\n\t*/\n\tNX_INLINE bool isValid() const;\n"]], "pred": {"ppl": 2.0714640617370605, "ppl_lower": 2.5315921306610107, "ppl/lowercase_ppl": -1.2754428016366286, "ppl/zlib": 0.000791582210300888, "Min_5.0% Prob": 6.924482367255471, "Min_10.0% Prob": 5.171929573470896, "Min_20.0% Prob": 3.347604881908934, "Min_30.0% Prob": 2.3795506273238165, "Min_40.0% Prob": 1.8094234453924631, "Min_50.0% Prob": 1.4535431572431636, "Min_60.0% Prob": 1.2144831887590164}}
{"hexsha": "4e04a180f12951520e38c97f3d8109f286c3e421", "ext": "h", "lang": "C", "content": "class CDSManager : public IOCP\n{\npublic:\n\tCDSManager(void);\n\t~CDSManager(void);\n\t// ----\n\tvoid OnError(const char * szMessage, ...);\n\tvoid OnMessage(const char * szMessage, ...);\n\tvoid OnRecv(int aIndex, BYTE HeadCode, LPBYTE aRecv, int iSize);\n\tvoid OnSearch(int aIndex);\n\tvoid OnConnect(int aIndex);\n\tvoid OnDisconnect(int aIndex);\n\t// ----\n}", "item_id": 0, "repo": "vuonglequoc/ServerSimulator", "file": "Source/BoR Team - CS DS JS/DataServer Source/Sources/TDSManager.h", "last_update_at": "2019-11-24T07:54:30+00:00", "question_id": "4e04a180f12951520e38c97f3d8109f286c3e421_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CDSManager : public IOCP\n{\npublic:\n\tCDSManager(void);\n\t~CDSManager(void);\n\t// ----\n\tvoid OnError(const char * szMessage, ...);\n\tvoid OnMessage(const char * szMessage, ...);\n\tvoid OnRecv(int aIndex, BYTE HeadCode, LPBYTE aRecv, int iSize);\n\tvoid OnSearch(int aIndex);\n\tvoid OnConnect(int aIndex);\n\tvoid OnDisconnect(int aIndex);\n\t// ----\n"]], "pred": {"ppl": 2.9977731704711914, "ppl_lower": 4.793213844299316, "ppl/lowercase_ppl": -1.427492791712498, "ppl/zlib": 0.006032251299642294, "Min_5.0% Prob": 8.1237313747406, "Min_10.0% Prob": 6.631428758303325, "Min_20.0% Prob": 4.5371988582611085, "Min_30.0% Prob": 3.453847619327339, "Min_40.0% Prob": 2.675686943531036, "Min_50.0% Prob": 2.164974465493172, "Min_60.0% Prob": 1.8355150816837946}}
{"hexsha": "65cff6a97d62bf0339eef634bf79d19540abfe38", "ext": "c", "lang": "C", "content": "void *\nexecute_forever(void *notused)\n{\n\tstruct sockaddr_in sin;\n\tsocklen_t slen;\n\tint nsd;\n\twhile(1) {\n\t\tslen = sizeof(sin);\n\t\tnsd = accept(sd, (struct sockaddr *)&sin, &slen);\n\t\tprocess_a_child(nsd, &sin, use_sctp);\n\t}\n}", "item_id": 1, "repo": "shkir/sctp-refimpl", "file": "APPS/incast/incast_server.c", "last_update_at": "2019-10-27T10:02:23+00:00", "question_id": "65cff6a97d62bf0339eef634bf79d19540abfe38_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *\nexecute_forever(void *notused)\n{\n\tstruct sockaddr_in sin;\n\tsocklen_t slen;\n\tint nsd;\n\twhile(1) {\n\t\tslen = sizeof(sin);\n\t\tnsd = accept(sd, (struct sockaddr *)&sin, &slen);\n\t\tprocess_a_child(nsd, &sin, use_sctp);\n\t}\n"]], "pred": {"ppl": 3.831554651260376, "ppl_lower": 3.831554651260376, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008448242987414376, "Min_5.0% Prob": 9.415177822113037, "Min_10.0% Prob": 8.0110613822937, "Min_20.0% Prob": 5.533500739506313, "Min_30.0% Prob": 4.290224921318792, "Min_40.0% Prob": 3.3097578556764695, "Min_50.0% Prob": 2.6611441697152154, "Min_60.0% Prob": 2.250923673371001}}
{"hexsha": "c9a5e613366ed59ce442191b358f3114cf0e3030", "ext": "c", "lang": "C", "content": "AUTH *\nauthunixint_create (const char *host, u_int32_t uid, u_int32_t gid,\n\t\t    u_int32_t ngroups, const u_int32_t *groups)\n{\n  char *h = (char *) host;\n  authunix_gid_t *gids;\n  size_t i;\n  AUTH *ret;\n\n  if (ngroups > 16)\n    ngroups = 16;\n  if (sizeof (gid_t) == 4) {\n    authunix_gid_t *gids = (authunix_gid_t *) groups;\n    return authunix_create (h, uid, gid, ngroups, gids);\n  }\n\n  gids = malloc (ngroups * sizeof (*gids));\n  if (!gids)\n    return NULL;\n  for (i = 0; i < ngroups; i++)\n    gids[i] = groups[i];\n  ret = authunix_create (h, uid, gid, ngroups, gids);\n  free (gids);\n  return ret;\n}", "item_id": 0, "repo": "33cn/libbft-go", "file": "bft/sfslite-1.2/arpc/authunixint.c", "last_update_at": "2019-02-12T01:30:41+00:00", "question_id": "c9a5e613366ed59ce442191b358f3114cf0e3030_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["AUTH *\nauthunixint_create (const char *host, u_int32_t uid, u_int32_t gid,\n\t\t    u_int32_t ngroups, const u_int32_t *groups)\n{\n  char *h = (char *) host;\n  authunix_gid_t *gids;\n  size_t i;\n  AUTH *ret;\n  if (ngroups > 16)\n    ngroups = 16;\n  if (sizeof (gid_t) == 4) {\n    authunix_gid_t *gids = (authunix_gid_t *) groups;\n    return authunix_create (h, uid, gid, ngroups, gids);\n  }\n  gids = malloc (ngroups * sizeof (*gids));\n  if (!gids)\n    return NULL;\n  for (i = 0; i < ngroups; i++)\n    gids[i] = groups[i];\n  ret = authunix_create (h, uid, gid, ngroups, gids);\n  free (gids);\n  return ret;\n"]], "pred": {"ppl": 2.1149230003356934, "ppl_lower": 2.145101547241211, "ppl/lowercase_ppl": -1.0189160735625333, "ppl/zlib": 0.0026560936360810108, "Min_5.0% Prob": 7.534626007080078, "Min_10.0% Prob": 5.246096363774052, "Min_20.0% Prob": 3.3232824119654567, "Min_30.0% Prob": 2.390241377324943, "Min_40.0% Prob": 1.854128573660378, "Min_50.0% Prob": 1.4973388656759434, "Min_60.0% Prob": 1.250010864848193}}
{"hexsha": "a8ab68169256adae97c52858acb68079f5488c31", "ext": "c", "lang": "C", "content": "static int ofi_restore_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\tconst char *phname, int16_t phnum, int phent,\n\t\t\t\tstruct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"releasing symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\n\tdlist_foreach_container_reverse(&intercept->dl_intercept_list,\n\t\tstruct ofi_dl_intercept, dl_entry, entry) {\n\n\t\tif (dl_entry->dl_func_addr != func_addr)\n\t\t\tcontinue;\n\n\t\tassert(*func_addr == intercept->our_func);\n\t\t*func_addr = dl_entry->dl_func;\n\t\tdlist_remove(&dl_entry->entry);\n\t\tfree(dl_entry);\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"dl symbol %s restored\\n\", intercept->symbol);\n\t\tbreak;\n\t}\n\n\treturn FI_SUCCESS;\n}", "item_id": 6, "repo": "nldias/chapel", "file": "third-party/libfabric/libfabric-src/prov/util/src/util_mem_hooks.c", "last_update_at": "2019-10-04T01:22:53+00:00", "question_id": "a8ab68169256adae97c52858acb68079f5488c31_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int ofi_restore_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\tconst char *phname, int16_t phnum, int phent,\n\t\t\t\tstruct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"releasing symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\tdlist_foreach_container_reverse(&intercept->dl_intercept_list,\n\t\tstruct ofi_dl_intercept, dl_entry, entry) {\n\t\tif (dl_entry->dl_func_addr != func_addr)\n\t\t\tcontinue;\n\t\tassert(*func_addr == intercept->our_func);\n\t\t*func_addr = dl_entry->dl_func;\n\t\tdlist_remove(&dl_entry->entry);\n\t\tfree(dl_entry);\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"dl symbol %s restored\\n\", intercept->symbol);\n\t\tbreak;\n\t}\n\treturn FI_SUCCESS;\n"]], "pred": {"ppl": 2.229640483856201, "ppl_lower": 2.5262770652770996, "ppl/lowercase_ppl": -1.1557745854595913, "ppl/zlib": 0.00157842589463249, "Min_5.0% Prob": 6.963238044218584, "Min_10.0% Prob": 5.108828078375923, "Min_20.0% Prob": 3.416007379909138, "Min_30.0% Prob": 2.5449315802577663, "Min_40.0% Prob": 1.9778046305035497, "Min_50.0% Prob": 1.602281746770448, "Min_60.0% Prob": 1.335724573654051}}
{"hexsha": "527f8d14412d17bcc8f560cc68adc228808d38c4", "ext": "c", "lang": "C", "content": "static void obd_comm_thread_fn(\n        const seL4_CPtr ep_cap)\n{\n    int err;\n    seL4_Word badge;\n    uint64_t timestamp;\n    hobd_stats_s stats = {0};\n\n    /* wait for system ready */\n    system_module_wait_for_start();\n\n    /* create a timeout id */\n    time_server_alloc_id(&g_comm.timeout_id);\n\n    /* initialize the HOBD parser */\n    hobd_parser_init(\n            &g_msg_rx_buffer[0],\n            sizeof(g_msg_rx_buffer),\n            &g_msg_parser);\n\n    /* TODO - disable char dev ? */\n\n    /* initialize UART TX GPIO */\n    err = gpio_new(\n            &g_comm.gpio_sys,\n            GPIOID(UART_TX_PORT, UART_TX_PIN),\n            GPIO_DIR_OUT,\n            &g_comm.gpio_uart_tx);\n    ZF_LOGF_IF(err != 0, \"Failed to initialize GPIO port/pin\");\n\n    /* reconfigure the serial port if starting in listen-only mode */\n    if(g_comm.listen_only != 0)\n    {\n        err = serial_configure(\n                &g_comm.char_dev,\n                HOBD_KLINE_BAUD,\n                8,\n                PARITY_NONE,\n                1);\n        ZF_LOGF_IF(err != 0, \"Failed to configure serial port\");\n    }\n\n    MODLOGD(HOBDMOD_THREAD_NAME \" thread is running\");\n\n    g_comm.state = COMM_STATE_GPIO_INIT;\n\n    while(1)\n    {\n        seL4_MessageInfo_t info = {0};\n\n        if(g_comm.enabled != 0)\n        {\n            if(g_comm.listen_only == 0)\n            {\n                /* update comms and perform a non-blocking EP recv if enabled */\n                comm_update_state(&stats);\n            }\n            else\n            {\n                /* log any messages seen on the k-line */\n                const hobd_msg_s * const hobd_msg = comm_recv_msg(\n                        1,\n                        &g_msg_parser,\n                        &g_comm);\n\n                if(hobd_msg != NULL)\n                {\n                    time_server_get_time(&timestamp);\n                    new_hobd_msg_callback(hobd_msg, &timestamp);\n                }\n            }\n\n            info = seL4_NBRecv(\n                    ep_cap,\n                    &badge);\n        }\n        else\n        {\n            /* otherwise just wait on the EP since comms are disabled */\n            info = seL4_Recv(\n                    ep_cap,\n                    &badge);\n        }\n\n        const seL4_Word msg_label = seL4_MessageInfo_get_label(info);\n\n        if((badge != 0) && (msg_label != 0))\n        {\n            ZF_LOGF_IF(badge != ENDPOINT_BADGE, \"Invalid IPC badge %u\", badge);\n\n            if(msg_label == IPC_MSG_TYPE_STATS_REQ)\n            {\n                time_server_get_time(&stats.timestamp);\n\n                stats.valid_rx_count = g_msg_parser.valid_count;\n                stats.invalid_rx_count = g_msg_parser.invalid_count;\n\n                const uint32_t resp_size_words = sizeof(stats) / sizeof(seL4_Word);\n\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_STATS_RESP,\n                            0,\n                            0,\n                            resp_size_words);\n\n                sel4_mr_send(resp_size_words, (uint32_t*) &stats, g_thread.ipc_buffer);\n\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_COMM_STATE_RESP,\n                            0,\n                            0,\n                            1);\n\n                seL4_SetMR(0, (seL4_Word) g_comm.enabled);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_SET_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_COMM_STATE_RESP,\n                            0,\n                            0,\n                            1);\n\n                const uint32_t desired_state = seL4_GetMR(0);\n\n                if(desired_state == 0)\n                {\n                    g_comm.enabled = 0;\n                }\n                else\n                {\n                    g_comm.enabled = 1;\n                }\n\n                hobd_parser_reset(&g_msg_parser);\n                g_comm.state = COMM_STATE_GPIO_INIT;\n\n                seL4_SetMR(0, (seL4_Word) g_comm.enabled);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,\n                            0,\n                            0,\n                            1);\n\n                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_SET_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,\n                            0,\n                            0,\n                            1);\n\n                const uint32_t desired_state = seL4_GetMR(0);\n\n                if(desired_state == 0)\n                {\n                    g_comm.listen_only = 0;\n                }\n                else\n                {\n                    g_comm.listen_only = 1;\n                }\n\n                hobd_parser_reset(&g_msg_parser);\n                g_comm.state = COMM_STATE_GPIO_INIT;\n\n                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);\n                seL4_Reply(resp_info);\n            }\n            else\n            {\n                ZF_LOGF(\"Invalid message label\");\n            }\n        }\n    }\n\n    /* should not get here, intentional halt */\n    seL4_DebugHalt();\n}", "item_id": 4, "repo": "jonlamb-gh/sel4-hobd-prototype", "file": "projects/hobd-system/modules/hobd/src/hobd_module.c", "last_update_at": "2019-10-21T15:14:05+00:00", "question_id": "527f8d14412d17bcc8f560cc68adc228808d38c4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void obd_comm_thread_fn(\n        const seL4_CPtr ep_cap)\n{\n    int err;\n    seL4_Word badge;\n    uint64_t timestamp;\n    hobd_stats_s stats = {0};\n    /* wait for system ready */\n    system_module_wait_for_start();\n    /* create a timeout id */\n    time_server_alloc_id(&g_comm.timeout_id);\n    /* initialize the HOBD parser */\n    hobd_parser_init(\n            &g_msg_rx_buffer[0],\n            sizeof(g_msg_rx_buffer),\n            &g_msg_parser);\n    /* TODO - disable char dev ? */\n    /* initialize UART TX GPIO */\n    err = gpio_new(\n            &g_comm.gpio_sys,\n            GPIOID(UART_TX_PORT, UART_TX_PIN),\n            GPIO_DIR_OUT,\n            &g_comm.gpio_uart_tx);\n    ZF_LOGF_IF(err != 0, \"Failed to initialize GPIO port/pin\");\n    /* reconfigure the serial port if starting in listen-only mode */\n    if(g_comm.listen_only != 0)\n    {\n        err = serial_configure(\n                &g_comm.char_dev,\n                HOBD_KLINE_BAUD,\n                8,\n                PARITY_NONE,\n                1);\n        ZF_LOGF_IF(err != 0, \"Failed to configure serial port\");\n    }\n    MODLOGD(HOBDMOD_THREAD_NAME \" thread is running\");\n    g_comm.state = COMM_STATE_GPIO_INIT;\n    while(1)\n    {\n        seL4_MessageInfo_t info = {0};\n        if(g_comm.enabled != 0)\n        {\n            if(g_comm.listen_only == 0)\n            {\n                /* update comms and perform a non-blocking EP recv if enabled */\n                comm_update_state(&stats);\n            }\n            else\n            {\n                /* log any messages seen on the k-line */\n                const hobd_msg_s * const hobd_msg = comm_recv_msg(\n                        1,\n                        &g_msg_parser,\n                        &g_comm);\n                if(hobd_msg != NULL)\n                {\n                    time_server_get_time(&timestamp);\n                    new_hobd_msg_callback(hobd_msg, &timestamp);\n                }\n            }\n            info = seL4_NBRecv(\n                    ep_cap,\n                    &badge);\n        }\n        else\n        {\n            /* otherwise just wait on the EP since comms are disabled */\n            info = seL4_Recv(\n                    ep_cap,\n                    &badge);\n        }\n        const seL4_Word msg_label = seL4_MessageInfo_get_label(info);\n        if((badge != 0) && (msg_label != 0))\n        {\n            ZF_LOGF_IF(badge != ENDPOINT_BADGE, \"Invalid IPC badge %u\", badge);\n            if(msg_label == IPC_MSG_TYPE_STATS_REQ)\n            {\n                time_server_get_time(&stats.timestamp);\n                stats.valid_rx_count = g_msg_parser.valid_count;\n                stats.invalid_rx_count = g_msg_parser.invalid_count;\n                const uint32_t resp_size_words = sizeof(stats) / sizeof(seL4_Word);\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_STATS_RESP,\n                            0,\n                            0,\n                            resp_size_words);\n                sel4_mr_send(resp_size_words, (uint32_t*) &stats, g_thread.ipc_buffer);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_COMM_STATE_RESP,\n                            0,\n                            0,\n                            1);\n                seL4_SetMR(0, (seL4_Word) g_comm.enabled);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_SET_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_COMM_STATE_RESP,\n                            0,\n                            0,\n                            1);\n                const uint32_t desired_state = seL4_GetMR(0);\n                if(desired_state == 0)\n                {\n                    g_comm.enabled = 0;\n                }\n                else\n                {\n                    g_comm.enabled = 1;\n                }\n                hobd_parser_reset(&g_msg_parser);\n                g_comm.state = COMM_STATE_GPIO_INIT;\n                seL4_SetMR(0, (seL4_Word) g_comm.enabled);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,\n                            0,\n                            0,\n                            1);\n                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);\n                seL4_Reply(resp_info);\n            }\n            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_SET_REQ)\n            {\n                const seL4_MessageInfo_t resp_info =\n                        seL4_MessageInfo_new(\n                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,\n                            0,\n                            0,\n                            1);\n                const uint32_t desired_state = seL4_GetMR(0);\n                if(desired_state == 0)\n                {\n                    g_comm.listen_only = 0;\n                }\n                else\n                {\n                    g_comm.listen_only = 1;\n                }\n                hobd_parser_reset(&g_msg_parser);\n                g_comm.state = COMM_STATE_GPIO_INIT;\n                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);\n                seL4_Reply(resp_info);\n            }\n            else\n            {\n                ZF_LOGF(\"Invalid message label\");\n            }\n        }\n    }\n    /* should not get here, intentional halt */\n    seL4_DebugHalt();\n"]], "pred": {"ppl": 2.7048444747924805, "ppl_lower": 3.126969575881958, "ppl/lowercase_ppl": -1.1457421714385763, "ppl/zlib": 0.0007321886793155797, "Min_5.0% Prob": 7.690496977637796, "Min_10.0% Prob": 6.058002270904242, "Min_20.0% Prob": 4.2090114629736135, "Min_30.0% Prob": 3.143336552615259, "Min_40.0% Prob": 2.4434904654334986, "Min_50.0% Prob": 1.9807280636230327, "Min_60.0% Prob": 1.657827533116081}}
{"hexsha": "45c988159d60b2b9990c59e950e9841fb93e0aba", "ext": "c", "lang": "C", "content": "void\nisc_stop_receiver(isc_session_t *sp)\n{\n     debug_called(8);\n     debug(3, \"sp=%p sp->sid=%d sp->soc=%p\", sp, sp ? sp->sid : 0,\n\t  sp ? sp->soc : NULL);\n     iscsi_lock_ex(&sp->io_mtx);\n     sp->flags &= ~ISC_LINK_UP;\n     if (sp->flags & ISC_CON_RUNNING) {\n\t     issleep(&sp->soc, &sp->io_mtx, 0, \"iscstpc\", 5*hz);\n     }\n     iscsi_unlock_ex(&sp->io_mtx);\n\n     if (sp->soc)\n\t  soshutdown(sp->soc, SHUT_RD);\n\n     iscsi_lock_ex(&sp->io_mtx);\n     sdebug(3, \"soshutdown\");\n     sp->flags &= ~ISC_CON_RUN;\n     while(sp->flags & ISC_CON_RUNNING) {\n\t  sdebug(3, \"waiting flags=%x\", sp->flags);\n\t  issleep(&sp->soc, &sp->io_mtx, 0, \"iscstpc\", hz);\n     }\n     iscsi_unlock_ex(&sp->io_mtx);\n\n     if (sp->fp != NULL) {\n\t  fdrop(sp->fp);\n\t  sp->fp = NULL;\n     }\n     /* sofree(sp->soc); fp deals with socket termination */\n     sp->soc = NULL;\n\n     sdebug(3, \"done\");\n}", "item_id": 7, "repo": "raJeev-M/DragonFlyBSD", "file": "sys/dev/disk/iscsi/initiator/isc_soc.c", "last_update_at": "2019-12-22T07:21:10+00:00", "question_id": "45c988159d60b2b9990c59e950e9841fb93e0aba_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nisc_stop_receiver(isc_session_t *sp)\n{\n     debug_called(8);\n     debug(3, \"sp=%p sp->sid=%d sp->soc=%p\", sp, sp ? sp->sid : 0,\n\t  sp ? sp->soc : NULL);\n     iscsi_lock_ex(&sp->io_mtx);\n     sp->flags &= ~ISC_LINK_UP;\n     if (sp->flags & ISC_CON_RUNNING) {\n\t     issleep(&sp->soc, &sp->io_mtx, 0, \"iscstpc\", 5*hz);\n     }\n     iscsi_unlock_ex(&sp->io_mtx);\n     if (sp->soc)\n\t  soshutdown(sp->soc, SHUT_RD);\n     iscsi_lock_ex(&sp->io_mtx);\n     sdebug(3, \"soshutdown\");\n     sp->flags &= ~ISC_CON_RUN;\n     while(sp->flags & ISC_CON_RUNNING) {\n\t  sdebug(3, \"waiting flags=%x\", sp->flags);\n\t  issleep(&sp->soc, &sp->io_mtx, 0, \"iscstpc\", hz);\n     }\n     iscsi_unlock_ex(&sp->io_mtx);\n     if (sp->fp != NULL) {\n\t  fdrop(sp->fp);\n\t  sp->fp = NULL;\n     }\n     /* sofree(sp->soc); fp deals with socket termination */\n     sp->soc = NULL;\n     sdebug(3, \"done\");\n"]], "pred": {"ppl": 3.025238275527954, "ppl_lower": 3.2865540981292725, "ppl/lowercase_ppl": -1.0748423949979091, "ppl/zlib": 0.0029678012256039673, "Min_5.0% Prob": 8.34896924495697, "Min_10.0% Prob": 6.523185113581215, "Min_20.0% Prob": 4.615053715476071, "Min_30.0% Prob": 3.4777518072128295, "Min_40.0% Prob": 2.7174932363325963, "Min_50.0% Prob": 2.2018412252148374, "Min_60.0% Prob": 1.8426813569617462}}
{"hexsha": "000121c48fb714241390896a883ca8cef9691445", "ext": "c", "lang": "C", "content": "static void dtDebugPrintTable(DTTable* t, int indent)\n{\n  int i;\n\n  dtSpaces(indent);\n  printf(\"table:\\n\");\n  dtSpaces(indent+2);\n  printf(\"default:\\n\");\n  dtDebugPrintNode(t->defaultEntry, indent+4);\n  for (i=0; i < t->numEntries; i++) {\n    dtSpaces(indent+2);\n    if (NULL == t->entries[i]) {\n      printf(\"entry %d: (default)\\n\", i);\n    } else {\n      printf(\"entry %d:\\n\", i);\n      dtDebugPrintNode(t->entries[i], indent+4);\n    }\n  };\n}", "item_id": 10, "repo": "ShreyaR/WorkerPoolSelection", "file": "ModelLearning/zmdp-1.1.7/src/parsers/decision-tree.c", "last_update_at": "2019-02-25T18:59:03+00:00", "question_id": "000121c48fb714241390896a883ca8cef9691445_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void dtDebugPrintTable(DTTable* t, int indent)\n{\n  int i;\n  dtSpaces(indent);\n  printf(\"table:\\n\");\n  dtSpaces(indent+2);\n  printf(\"default:\\n\");\n  dtDebugPrintNode(t->defaultEntry, indent+4);\n  for (i=0; i < t->numEntries; i++) {\n    dtSpaces(indent+2);\n    if (NULL == t->entries[i]) {\n      printf(\"entry %d: (default)\\n\", i);\n    } else {\n      printf(\"entry %d:\\n\", i);\n      dtDebugPrintNode(t->entries[i], indent+4);\n    }\n  };\n"]], "pred": {"ppl": 2.326819896697998, "ppl_lower": 2.613391637802124, "ppl/lowercase_ppl": -1.1375323032151068, "ppl/zlib": 0.0038040652437714957, "Min_5.0% Prob": 8.23347407579422, "Min_10.0% Prob": 5.872691981932697, "Min_20.0% Prob": 3.7654400362687954, "Min_30.0% Prob": 2.7006490709734896, "Min_40.0% Prob": 2.0951386764645576, "Min_50.0% Prob": 1.6785780787467957, "Min_60.0% Prob": 1.4075430288947033}}
{"hexsha": "831d986fea48baebe3d854f1df7410eed319eb28", "ext": "c", "lang": "C", "content": "static const SObject *GetFeature(const SSyllabification *self, const char *key,\n\t\t\t\t\t\t\t\t s_erc *error)\n{\n\tconst SObject *feature;\n\n\n\tS_CLR_ERR(error);\n\tif (key == NULL)\n\t{\n\t\tS_CTX_ERR(error, S_ARGERROR,\n\t\t\t\t  \"GetFeature\",\n\t\t\t\t  \"Argument \\\"key\\\" is NULL\");\n\t\treturn NULL;\n\t}\n\n\tif (self->features == NULL)\n\t\treturn NULL;\n\n\tfeature = SMapGetObjectDef(self->features, key, NULL, error);\n\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t  \"GetFeature\",\n\t\t\t\t  \"Call to \\\"SMapGetObjectDef\\\" failed\"))\n\t\treturn NULL;\n\n\treturn feature;\n}", "item_id": 12, "repo": "Oghma/speect", "file": "plugins/serialization/files/syllab_rewrites/common/src/syllab_rewrites.c", "last_update_at": "2019-04-24T14:45:55+00:00", "question_id": "831d986fea48baebe3d854f1df7410eed319eb28_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static const SObject *GetFeature(const SSyllabification *self, const char *key,\n\t\t\t\t\t\t\t\t s_erc *error)\n{\n\tconst SObject *feature;\n\tS_CLR_ERR(error);\n\tif (key == NULL)\n\t{\n\t\tS_CTX_ERR(error, S_ARGERROR,\n\t\t\t\t  \"GetFeature\",\n\t\t\t\t  \"Argument \\\"key\\\" is NULL\");\n\t\treturn NULL;\n\t}\n\tif (self->features == NULL)\n\t\treturn NULL;\n\tfeature = SMapGetObjectDef(self->features, key, NULL, error);\n\tif (S_CHK_ERR(error, S_CONTERR,\n\t\t\t\t  \"GetFeature\",\n\t\t\t\t  \"Call to \\\"SMapGetObjectDef\\\" failed\"))\n\t\treturn NULL;\n\treturn feature;\n"]], "pred": {"ppl": 1.5617886781692505, "ppl_lower": 2.9351439476013184, "ppl/lowercase_ppl": -2.4151633211614243, "ppl/zlib": 0.0016451356199292694, "Min_5.0% Prob": 5.985879768024791, "Min_10.0% Prob": 3.8316561471332204, "Min_20.0% Prob": 2.173887171867219, "Min_30.0% Prob": 1.481245920344284, "Min_40.0% Prob": 1.113641088807278, "Min_50.0% Prob": 0.8914417659112421, "Min_60.0% Prob": 0.742993643665889}}
{"hexsha": "3349269ed46107e1661ff44ee0ec66c1d83a7205", "ext": "c", "lang": "C", "content": "static void setWindowParams(STATE_T * state, int32_t x, int32_t y, VC_RECT_T * src_rect, VC_RECT_T * dst_rect) {\n\tuint32_t dx, dy, w, h, sx, sy;\n\n\t// Set source & destination rectangles so that the image is\n\t// clipped if it goes off screen (else dispman won't show it properly)\n\tif (x < (1 - (int)state->window_width)) {\t   // Too far off left\n\t\tx = 1 - (int)state->window_width;\n\t\tdx = 0;\n\t\tsx = state->window_width - 1;\n\t\tw = 1;\n\t} else if (x < 0) {\t\t\t\t   // Part of left is off\n\t\tdx = 0;\n\t\tsx = -x;\n\t\tw = state->window_width - sx;\n\t} else if (x < (int)(state->screen_width - state->window_width)) {\t// On\n\t\tdx = x;\n\t\tsx = 0;\n\t\tw = state->window_width;\n\t} else if (x < (int)state->screen_width) {\t   // Part of right is off\n\t\tdx = x;\n\t\tsx = 0;\n\t\tw = state->screen_width - x;\n\t} else {\t\t\t\t\t   // Too far off right\n\t\tx = state->screen_width - 1;\n\t\tdx = state->screen_width - 1;\n\t\tsx = 0;\n\t\tw = 1;\n\t}\n\n\tif (y < (1 - (int)state->window_height)) {\t   // Too far off top\n\t\ty = 1 - (int)state->window_height;\n\t\tdy = 0;\n\t\tsy = state->window_height - 1;\n\t\th = 1;\n\t} else if (y < 0) {\t\t\t\t   // Part of top is off\n\t\tdy = 0;\n\t\tsy = -y;\n\t\th = state->window_height - sy;\n\t} else if (y < (int)(state->screen_height - state->window_height)) {\t// On\n\t\tdy = y;\n\t\tsy = 0;\n\t\th = state->window_height;\n\t} else if (y < (int)state->screen_height) {\t   // Part of bottom is off\n\t\tdy = y;\n\t\tsy = 0;\n\t\th = state->screen_height - y;\n\t} else {\t\t\t\t\t   // Wholly off bottom\n\t\ty = state->screen_height - 1;\n\t\tdy = state->screen_height - 1;\n\t\tsy = 0;\n\t\th = 1;\n\t}\n\n\tstate->window_x = x;\n\tstate->window_y = y;\n\n\tvc_dispmanx_rect_set(dst_rect, dx, dy, w, h);\n\tvc_dispmanx_rect_set(src_rect, sx << 16, sy << 16, w << 16, h << 16);\n}", "item_id": 0, "repo": "radbis/ezwb-openvg-font", "file": "oglinit.c", "last_update_at": "2019-02-03T20:48:15+00:00", "question_id": "3349269ed46107e1661ff44ee0ec66c1d83a7205_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void setWindowParams(STATE_T * state, int32_t x, int32_t y, VC_RECT_T * src_rect, VC_RECT_T * dst_rect) {\n\tuint32_t dx, dy, w, h, sx, sy;\n\t// Set source & destination rectangles so that the image is\n\t// clipped if it goes off screen (else dispman won't show it properly)\n\tif (x < (1 - (int)state->window_width)) {\t   // Too far off left\n\t\tx = 1 - (int)state->window_width;\n\t\tdx = 0;\n\t\tsx = state->window_width - 1;\n\t\tw = 1;\n\t} else if (x < 0) {\t\t\t\t   // Part of left is off\n\t\tdx = 0;\n\t\tsx = -x;\n\t\tw = state->window_width - sx;\n\t} else if (x < (int)(state->screen_width - state->window_width)) {\t// On\n\t\tdx = x;\n\t\tsx = 0;\n\t\tw = state->window_width;\n\t} else if (x < (int)state->screen_width) {\t   // Part of right is off\n\t\tdx = x;\n\t\tsx = 0;\n\t\tw = state->screen_width - x;\n\t} else {\t\t\t\t\t   // Too far off right\n\t\tx = state->screen_width - 1;\n\t\tdx = state->screen_width - 1;\n\t\tsx = 0;\n\t\tw = 1;\n\t}\n\tif (y < (1 - (int)state->window_height)) {\t   // Too far off top\n\t\ty = 1 - (int)state->window_height;\n\t\tdy = 0;\n\t\tsy = state->window_height - 1;\n\t\th = 1;\n\t} else if (y < 0) {\t\t\t\t   // Part of top is off\n\t\tdy = 0;\n\t\tsy = -y;\n\t\th = state->window_height - sy;\n\t} else if (y < (int)(state->screen_height - state->window_height)) {\t// On\n\t\tdy = y;\n\t\tsy = 0;\n\t\th = state->window_height;\n\t} else if (y < (int)state->screen_height) {\t   // Part of bottom is off\n\t\tdy = y;\n\t\tsy = 0;\n\t\th = state->screen_height - y;\n\t} else {\t\t\t\t\t   // Wholly off bottom\n\t\ty = state->screen_height - 1;\n\t\tdy = state->screen_height - 1;\n\t\tsy = 0;\n\t\th = 1;\n\t}\n\tstate->window_x = x;\n\tstate->window_y = y;\n\tvc_dispmanx_rect_set(dst_rect, dx, dy, w, h);\n\tvc_dispmanx_rect_set(src_rect, sx << 16, sy << 16, w << 16, h << 16);\n"]], "pred": {"ppl": 1.5577101707458496, "ppl_lower": 1.5792274475097656, "ppl/lowercase_ppl": -1.0309529406707838, "ppl/zlib": 0.0008177433646947775, "Min_5.0% Prob": 5.225951617956161, "Min_10.0% Prob": 3.659904970228672, "Min_20.0% Prob": 2.1403943269513546, "Min_30.0% Prob": 1.4687329012434929, "Min_40.0% Prob": 1.1073049960454227, "Min_50.0% Prob": 0.8869826754188398, "Min_60.0% Prob": 0.7394416907404472}}
{"hexsha": "2774efe85065980b9f2089563fafc1695caa9389", "ext": "c", "lang": "C", "content": "SEXP attribute_hidden do_allnames(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    SEXP expr;\n    int i, savecount;\n    NameWalkData data = {NULL, 0, 0, 0, 0, 0};\n\n    checkArity(op, args);\n\n    expr = CAR(args);\n    args = CDR(args);\n\n    data.IncludeFunctions = asLogical(CAR(args));\n    if(data.IncludeFunctions == NA_LOGICAL)\n\tdata.IncludeFunctions = 0;\n    args = CDR(args);\n\n    data.MaxCount = asInteger(CAR(args));\n    if(data.MaxCount == -1) data.MaxCount = INT_MAX;\n    if(data.MaxCount < 0 || data.MaxCount == NA_INTEGER)\n\tdata.MaxCount = 0;\n    args = CDR(args);\n\n    data.UniqueNames = asLogical(CAR(args));\n    if(data.UniqueNames == NA_LOGICAL)\n\tdata.UniqueNames = 1;\n\n    namewalk(expr, &data);\n    savecount = data.ItemCounts;\n\n    data.ans = allocVector(STRSXP, data.ItemCounts);\n\n    data.StoreValues = 1;\n    data.ItemCounts = 0;\n    namewalk(expr, &data);\n\n    if(data.ItemCounts != savecount) {\n\tPROTECT(expr = data.ans);\n\tdata.ans = allocVector(STRSXP, data.ItemCounts);\n\tfor(i = 0 ; i < data.ItemCounts ; i++)\n\t    SET_STRING_ELT(data.ans, i, STRING_ELT(expr, i));\n\tUNPROTECT(1);\n    }\n\n    return data.ans;\n}", "item_id": 0, "repo": "lifebit-ai/exomedepth", "file": "bin/R-3.5.1/src/main/list.c", "last_update_at": "2019-07-28T20:32:29+00:00", "question_id": "2774efe85065980b9f2089563fafc1695caa9389_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SEXP attribute_hidden do_allnames(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    SEXP expr;\n    int i, savecount;\n    NameWalkData data = {NULL, 0, 0, 0, 0, 0};\n    checkArity(op, args);\n    expr = CAR(args);\n    args = CDR(args);\n    data.IncludeFunctions = asLogical(CAR(args));\n    if(data.IncludeFunctions == NA_LOGICAL)\n\tdata.IncludeFunctions = 0;\n    args = CDR(args);\n    data.MaxCount = asInteger(CAR(args));\n    if(data.MaxCount == -1) data.MaxCount = INT_MAX;\n    if(data.MaxCount < 0 || data.MaxCount == NA_INTEGER)\n\tdata.MaxCount = 0;\n    args = CDR(args);\n    data.UniqueNames = asLogical(CAR(args));\n    if(data.UniqueNames == NA_LOGICAL)\n\tdata.UniqueNames = 1;\n    namewalk(expr, &data);\n    savecount = data.ItemCounts;\n    data.ans = allocVector(STRSXP, data.ItemCounts);\n    data.StoreValues = 1;\n    data.ItemCounts = 0;\n    namewalk(expr, &data);\n    if(data.ItemCounts != savecount) {\n\tPROTECT(expr = data.ans);\n\tdata.ans = allocVector(STRSXP, data.ItemCounts);\n\tfor(i = 0 ; i < data.ItemCounts ; i++)\n\t    SET_STRING_ELT(data.ans, i, STRING_ELT(expr, i));\n\tUNPROTECT(1);\n    }\n    return data.ans;\n"]], "pred": {"ppl": 1.9693864583969116, "ppl_lower": 2.320148229598999, "ppl/lowercase_ppl": -1.2418528709019332, "ppl/zlib": 0.0015127724370614132, "Min_5.0% Prob": 7.952112591784934, "Min_10.0% Prob": 5.3438107992740385, "Min_20.0% Prob": 3.1963924708518574, "Min_30.0% Prob": 2.2143024197766477, "Min_40.0% Prob": 1.6882002873434907, "Min_50.0% Prob": 1.3527504908400372, "Min_60.0% Prob": 1.1304483163829657}}
{"hexsha": "4b486bcbffedb056942363d77ea84d9cdcbea95a", "ext": "c", "lang": "C", "content": "int\nstge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)\n{\n\tstruct stge_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\t\tstge_init(ifp);\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\terror = ENETRESET;\n\t\t\telse\n\t\t\t\tstge_init(ifp);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tstge_stop(ifp, 1);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);\n\t}\n\n\tif (error == ENETRESET) {\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tstge_iff(sc);\n\t\terror = 0;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}", "item_id": 4, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/dev/pci/if_stge.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "4b486bcbffedb056942363d77ea84d9cdcbea95a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nstge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)\n{\n\tstruct stge_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\ts = splnet();\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\t\tstge_init(ifp);\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\terror = ENETRESET;\n\t\t\telse\n\t\t\t\tstge_init(ifp);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tstge_stop(ifp, 1);\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);\n\t\tbreak;\n\tdefault:\n\t\terror = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);\n\t}\n\tif (error == ENETRESET) {\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\tstge_iff(sc);\n\t\terror = 0;\n\t}\n\tsplx(s);\n\treturn (error);\n"]], "pred": {"ppl": 1.2107487916946411, "ppl_lower": 1.585046648979187, "ppl/lowercase_ppl": -2.408576848990765, "ppl/zlib": 0.0004916169776859036, "Min_5.0% Prob": 3.0751233371821316, "Min_10.0% Prob": 1.7722896503077612, "Min_20.0% Prob": 0.9450278402202659, "Min_30.0% Prob": 0.6383057742483086, "Min_40.0% Prob": 0.4777701095785966, "Min_50.0% Prob": 0.3830759964375427, "Min_60.0% Prob": 0.3195975892944047}}
{"hexsha": "803f65fbef099f538cbdd0e4ad7dad75427487fc", "ext": "c", "lang": "C", "content": "static struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\n\treturn newfrag;\n}", "item_id": 3, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/fs/jffs2/nodelist.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "803f65fbef099f538cbdd0e4ad7dad75427487fc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\n{\n\tstruct jffs2_node_frag *newfrag;\n\tnewfrag = jffs2_alloc_node_frag();\n\tif (likely(newfrag)) {\n\t\tnewfrag->ofs = ofs;\n\t\tnewfrag->size = size;\n\t\tnewfrag->node = fn;\n\t} else {\n\t\tJFFS2_ERROR(\"cannot allocate a jffs2_node_frag object\\n\");\n\t}\n\treturn newfrag;\n"]], "pred": {"ppl": 1.739180088043213, "ppl_lower": 1.780159831047058, "ppl/lowercase_ppl": -1.0420830942089605, "ppl/zlib": 0.0026479128631678116, "Min_5.0% Prob": 6.1013453006744385, "Min_10.0% Prob": 4.27780215179219, "Min_20.0% Prob": 2.6161542377051186, "Min_30.0% Prob": 1.8476768118493698, "Min_40.0% Prob": 1.382128758571934, "Min_50.0% Prob": 1.1116755063060757, "Min_60.0% Prob": 0.929061407035723}}
{"hexsha": "ccb49971ab0343636681da3da8fd6c9d1d8d7e1b", "ext": "c", "lang": "C", "content": "static int _ge_query_ion_debug(buffer_handle_t hnd, GEHND UNUSED(ge_hnd), void *out)\n{\n\tint err;\n\tint ion_client;\n\tion_user_handle_t ion_hnd;\n\n\terr = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_CLIENT, &ion_client);\n\terr_return(err, \"get ion_client fail\");\n\terr = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_HANDLE, &ion_hnd);\n\terr_return(err, \"get ion_hnd fail\");\n\n\tif (!err) err = _ge_get_ion_debug(ion_client, ion_hnd, out);\n\n\treturn err;\n}", "item_id": 4, "repo": "DEV4WOODS/android_device_motorola_woods", "file": "libgralloc_extra/ge.c", "last_update_at": "2019-06-26T09:30:38+00:00", "question_id": "ccb49971ab0343636681da3da8fd6c9d1d8d7e1b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int _ge_query_ion_debug(buffer_handle_t hnd, GEHND UNUSED(ge_hnd), void *out)\n{\n\tint err;\n\tint ion_client;\n\tion_user_handle_t ion_hnd;\n\terr = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_CLIENT, &ion_client);\n\terr_return(err, \"get ion_client fail\");\n\terr = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_HANDLE, &ion_hnd);\n\terr_return(err, \"get ion_hnd fail\");\n\tif (!err) err = _ge_get_ion_debug(ion_client, ion_hnd, out);\n\treturn err;\n"]], "pred": {"ppl": 3.0650405883789062, "ppl_lower": 3.417562484741211, "ppl/lowercase_ppl": -1.0971971880608355, "ppl/zlib": 0.0045346591572407785, "Min_5.0% Prob": 8.90456976890564, "Min_10.0% Prob": 6.962024211883545, "Min_20.0% Prob": 4.722979611158371, "Min_30.0% Prob": 3.5270456850528715, "Min_40.0% Prob": 2.7623603768646716, "Min_50.0% Prob": 2.243256664723158, "Min_60.0% Prob": 1.874202061444521}}
{"hexsha": "3139287b0debfd0adaa6d446b5fe5e650396f138", "ext": "c", "lang": "C", "content": "int     \ndec_kn20aa_intr_map(pa, ihp)\n\tstruct pci_attach_args *pa;\n        pci_intr_handle_t *ihp;\n{\n\tpcitag_t bustag = pa->pa_intrtag;\n\tint buspin = pa->pa_intrpin;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint device;\n\tint kn20aa_irq;\n\n\tif (buspin == 0) {\n\t\t/* No IRQ used. */\n\t\treturn 1;\n\t}\n\tif (buspin > 4) {\n\t\tprintf(\"dec_kn20aa_intr_map: bad interrupt pin %d\\n\", buspin);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Slot->interrupt translation.  Appears to work, though it\n\t * may not hold up forever.\n\t *\n\t * The DEC engineers who did this hardware obviously engaged\n\t * in random drug testing.\n\t */\n\tpci_decompose_tag(pc, bustag, NULL, &device, NULL);\n\tswitch (device) {\n\tcase 11:\n\tcase 12:\n\t\tkn20aa_irq = ((device - 11) + 0) * 4;\n\t\tbreak;\n\n\tcase 7:\n\t\tkn20aa_irq = 8;\n\t\tbreak;\n\n\tcase 9:\n\t\tkn20aa_irq = 12;\n\t\tbreak;\n\n\tcase 6:\t\t\t\t\t/* 21040 on AlphaStation 500 */\n\t\tkn20aa_irq = 13;\n\t\tbreak;\n\n\tcase 8:\n\t\tkn20aa_irq = 16;\n\t\tbreak;\n\n\tdefault:\n                printf(\"dec_kn20aa_intr_map: weird device number %d\\n\",\n\t\t    device);\n                return 1;\n\t}\n\n\tkn20aa_irq += buspin - 1;\n\tif (kn20aa_irq > KN20AA_MAX_IRQ)\n\t\tpanic(\"dec_kn20aa_intr_map: kn20aa_irq too large (%d)\\n\",\n\t\t    kn20aa_irq);\n\n\t*ihp = kn20aa_irq;\n\treturn (0);\n}", "item_id": 1, "repo": "shisa/kame-shisa", "file": "netbsd/sys/arch/alpha/pci/pci_kn20aa.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "3139287b0debfd0adaa6d446b5fe5e650396f138_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int     \ndec_kn20aa_intr_map(pa, ihp)\n\tstruct pci_attach_args *pa;\n        pci_intr_handle_t *ihp;\n{\n\tpcitag_t bustag = pa->pa_intrtag;\n\tint buspin = pa->pa_intrpin;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tint device;\n\tint kn20aa_irq;\n\tif (buspin == 0) {\n\t\t/* No IRQ used. */\n\t\treturn 1;\n\t}\n\tif (buspin > 4) {\n\t\tprintf(\"dec_kn20aa_intr_map: bad interrupt pin %d\\n\", buspin);\n\t\treturn 1;\n\t}\n\t/*\n\t * Slot->interrupt translation.  Appears to work, though it\n\t * may not hold up forever.\n\t *\n\t * The DEC engineers who did this hardware obviously engaged\n\t * in random drug testing.\n\t */\n\tpci_decompose_tag(pc, bustag, NULL, &device, NULL);\n\tswitch (device) {\n\tcase 11:\n\tcase 12:\n\t\tkn20aa_irq = ((device - 11) + 0) * 4;\n\t\tbreak;\n\tcase 7:\n\t\tkn20aa_irq = 8;\n\t\tbreak;\n\tcase 9:\n\t\tkn20aa_irq = 12;\n\t\tbreak;\n\tcase 6:\t\t\t\t\t/* 21040 on AlphaStation 500 */\n\t\tkn20aa_irq = 13;\n\t\tbreak;\n\tcase 8:\n\t\tkn20aa_irq = 16;\n\t\tbreak;\n\tdefault:\n                printf(\"dec_kn20aa_intr_map: weird device number %d\\n\",\n\t\t    device);\n                return 1;\n\t}\n\tkn20aa_irq += buspin - 1;\n\tif (kn20aa_irq > KN20AA_MAX_IRQ)\n\t\tpanic(\"dec_kn20aa_intr_map: kn20aa_irq too large (%d)\\n\",\n\t\t    kn20aa_irq);\n\t*ihp = kn20aa_irq;\n\treturn (0);\n"]], "pred": {"ppl": 1.9072891473770142, "ppl_lower": 2.0363035202026367, "ppl/lowercase_ppl": -1.1013705349344276, "ppl/zlib": 0.0010888413816846087, "Min_5.0% Prob": 6.384862534205118, "Min_10.0% Prob": 4.574781308408643, "Min_20.0% Prob": 2.9217433113543714, "Min_30.0% Prob": 2.100104349802752, "Min_40.0% Prob": 1.6024247532596394, "Min_50.0% Prob": 1.2908234779108194, "Min_60.0% Prob": 1.0778266503843568}}
{"hexsha": "ec4d362d17be863c53da0db077d07c814c90561d", "ext": "c", "lang": "C", "content": "static void ADIO_FileSysType_parentdir(char *filename, char **dirnamep)\n{\n    int err;\n    char *dir, *slash;\n    struct stat statbuf;\n    \n    err = lstat(filename, &statbuf);\n\n    if (err || (!S_ISLNK(statbuf.st_mode))) {\n\t/* no such file, or file is not a link; these are the \"normal\"\n\t * cases where we can just return the parent directory.\n\t */\n\tdir = strdup(filename);\n    }\n    else {\n\t/* filename is a symlink.  we've presumably already tried\n\t * to stat it and found it to be missing (dangling link),\n\t * but this code doesn't care if the target is really there\n\t * or not.\n\t */\n\tchar *linkbuf;\n\n\tlinkbuf = ADIOI_Malloc(PATH_MAX+1);\n\terr = readlink(filename, linkbuf, PATH_MAX+1);\n\tif (err) {\n\t    /* something strange has happened between the time that\n\t     * we determined that this was a link and the time that\n\t     * we attempted to read it; punt and use the old name.\n\t     */\n\t    dir = strdup(filename);\n\t}\n\telse {\n\t    /* successfully read the link */\n\t    dir = strdup(linkbuf);\n\t    ADIOI_Free(linkbuf);\n\t}\n    }\n\n    slash = strrchr(dir, '/');\n    if (!slash) strcpy(dir, \".\");\n    else {\n\tif (slash == dir) *(dir + 1) = 0;\n\telse *slash = '\\0';\n    }\n\n    *dirnamep = dir;\n    return;\n}", "item_id": 0, "repo": "scottkwarren/config-db", "file": "NAMD_2.12_Source/charm-6.7.1/src/libs/ck-libs/ampi/romio/adio/common/ad_fstype.c", "last_update_at": "2019-01-17T20:07:23+00:00", "question_id": "ec4d362d17be863c53da0db077d07c814c90561d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void ADIO_FileSysType_parentdir(char *filename, char **dirnamep)\n{\n    int err;\n    char *dir, *slash;\n    struct stat statbuf;\n    err = lstat(filename, &statbuf);\n    if (err || (!S_ISLNK(statbuf.st_mode))) {\n\t/* no such file, or file is not a link; these are the \"normal\"\n\t * cases where we can just return the parent directory.\n\t */\n\tdir = strdup(filename);\n    }\n    else {\n\t/* filename is a symlink.  we've presumably already tried\n\t * to stat it and found it to be missing (dangling link),\n\t * but this code doesn't care if the target is really there\n\t * or not.\n\t */\n\tchar *linkbuf;\n\tlinkbuf = ADIOI_Malloc(PATH_MAX+1);\n\terr = readlink(filename, linkbuf, PATH_MAX+1);\n\tif (err) {\n\t    /* something strange has happened between the time that\n\t     * we determined that this was a link and the time that\n\t     * we attempted to read it; punt and use the old name.\n\t     */\n\t    dir = strdup(filename);\n\t}\n\telse {\n\t    /* successfully read the link */\n\t    dir = strdup(linkbuf);\n\t    ADIOI_Free(linkbuf);\n\t}\n    }\n    slash = strrchr(dir, '/');\n    if (!slash) strcpy(dir, \".\");\n    else {\n\tif (slash == dir) *(dir + 1) = 0;\n\telse *slash = '\\0';\n    }\n    *dirnamep = dir;\n    return;\n"]], "pred": {"ppl": 2.442323684692383, "ppl_lower": 2.768261671066284, "ppl/lowercase_ppl": -1.1402874332368935, "ppl/zlib": 0.001440241799868949, "Min_5.0% Prob": 6.243879681541806, "Min_10.0% Prob": 4.8375361022495085, "Min_20.0% Prob": 3.493615607654347, "Min_30.0% Prob": 2.7167729367502034, "Min_40.0% Prob": 2.1730519374560195, "Min_50.0% Prob": 1.7719513514192304, "Min_60.0% Prob": 1.4856699515380516}}
{"hexsha": "1d40528d2e773253459933cc0d1535cba194632b", "ext": "c", "lang": "C", "content": "mems_status_t LSM6DS3_ACC_GYRO_W_DRDY_TEMP_on_INT2(\n    void *handle, LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_t newValue) {\n  u8_t value;\n\n  if (!LSM6DS3_ACC_GYRO_ReadReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))\n    return MEMS_ERROR;\n\n  value &= ~LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_MASK;\n  value |= newValue;\n\n  if (!LSM6DS3_ACC_GYRO_WriteReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))\n    return MEMS_ERROR;\n\n  return MEMS_SUCCESS;\n}", "item_id": 71, "repo": "BrianBalke/bldc-controller", "file": "firmware/src/old_drivers/LSM6DS3_ACC_GYRO_driver.c", "last_update_at": "2019-12-11T08:58:39+00:00", "question_id": "1d40528d2e773253459933cc0d1535cba194632b_71", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["mems_status_t LSM6DS3_ACC_GYRO_W_DRDY_TEMP_on_INT2(\n    void *handle, LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_t newValue) {\n  u8_t value;\n  if (!LSM6DS3_ACC_GYRO_ReadReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))\n    return MEMS_ERROR;\n  value &= ~LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_MASK;\n  value |= newValue;\n  if (!LSM6DS3_ACC_GYRO_WriteReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))\n    return MEMS_ERROR;\n  return MEMS_SUCCESS;\n"]], "pred": {"ppl": 1.507553219795227, "ppl_lower": 1.9987081289291382, "ppl/lowercase_ppl": -1.6870191496873885, "ppl/zlib": 0.002062753529360834, "Min_5.0% Prob": 5.463045293634588, "Min_10.0% Prob": 3.605388610259346, "Min_20.0% Prob": 2.049665871452778, "Min_30.0% Prob": 1.3778090857913796, "Min_40.0% Prob": 1.0322895308245759, "Min_50.0% Prob": 0.8243286406020673, "Min_60.0% Prob": 0.6860346128502446}}
{"hexsha": "681cd3f21e53755bc963dddeeb27bfc97473439b", "ext": "c", "lang": "C", "content": "void HAL_MspInit (void)\n{\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n\n  /* System interrupt init*/\n  /* PendSV_IRQn interrupt configuration */\n  HAL_NVIC_SetPriority (PendSV_IRQn, 15, 0);\n}", "item_id": 0, "repo": "Goldweavers/STM32L4_IMU", "file": "Core/Src/stm32l4xx_hal_msp.c", "last_update_at": "2019-09-28T15:33:40+00:00", "question_id": "681cd3f21e53755bc963dddeeb27bfc97473439b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void HAL_MspInit (void)\n{\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n  /* System interrupt init*/\n  /* PendSV_IRQn interrupt configuration */\n  HAL_NVIC_SetPriority (PendSV_IRQn, 15, 0);\n"]], "pred": {"ppl": 1.5643465518951416, "ppl_lower": 3.669823169708252, "ppl/lowercase_ppl": -2.9055550402524504, "ppl/zlib": 0.0028320772029962146, "Min_5.0% Prob": 5.971210193634033, "Min_10.0% Prob": 3.790897274017334, "Min_20.0% Prob": 2.170886757969856, "Min_30.0% Prob": 1.49750632767876, "Min_40.0% Prob": 1.1280406817793847, "Min_50.0% Prob": 0.9035474145179614, "Min_60.0% Prob": 0.7531612846922751}}
{"hexsha": "0d5a4a866ee30ea0d48c28899c54d00ba8e2cd62", "ext": "c", "lang": "C", "content": "static void signal_retirement(const char* source, const char* buf) {\n  sexp* call = KEEP(r_parse(source));\n  sexp* msg = KEEP(r_chr(buf));\n\n  r_eval_with_x(call, r_ns_env(\"rlang\"), msg);\n\n  FREE(2);\n}", "item_id": 7, "repo": "QuLogic/rlang", "file": "src/lib/cnd.c", "last_update_at": "2019-07-11T04:42:02+00:00", "question_id": "0d5a4a866ee30ea0d48c28899c54d00ba8e2cd62_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void signal_retirement(const char* source, const char* buf) {\n  sexp* call = KEEP(r_parse(source));\n  sexp* msg = KEEP(r_chr(buf));\n  r_eval_with_x(call, r_ns_env(\"rlang\"), msg);\n  FREE(2);\n"]], "pred": {"ppl": 4.012659549713135, "ppl_lower": 5.920243263244629, "ppl/lowercase_ppl": -1.2799108273975501, "ppl/zlib": 0.009081400332248255, "Min_5.0% Prob": 9.564626455307007, "Min_10.0% Prob": 8.091611742973328, "Min_20.0% Prob": 5.4397291716407326, "Min_30.0% Prob": 4.221338310241699, "Min_40.0% Prob": 3.352824396946851, "Min_50.0% Prob": 2.7321771878835768, "Min_60.0% Prob": 2.329471543431282}}
{"hexsha": "901544a023df04690d80ab7db62eea66490519f5", "ext": "c", "lang": "C", "content": "static int\nre_newbuf_std(struct re_softc *sc, int idx, int init)\n{\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t map;\n\tstruct mbuf *m;\n\tint error, nsegs;\n\n\tm = m_getcl(init ? M_WAITOK : M_NOWAIT, MT_DATA, M_PKTHDR);\n\tif (m == NULL) {\n\t\terror = ENOBUFS;\n\n\t\tif (init) {\n\t\t\tif_printf(&sc->arpcom.ac_if, \"m_getcl failed\\n\");\n\t\t\treturn error;\n\t\t} else {\n\t\t\tgoto back;\n\t\t}\n\t}\n\tm->m_len = m->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * NOTE:\n\t * re(4) chips need address of the receive buffer to be 8-byte\n\t * aligned, so don't call m_adj(m, ETHER_ALIGN) here.\n\t */\n\n\terror = bus_dmamap_load_mbuf_segment(sc->re_ldata.re_rx_mtag,\n\t\t\tsc->re_ldata.re_rx_spare, m,\n\t\t\t&seg, 1, &nsegs, BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tm_freem(m);\n\t\tif (init) {\n\t\t\tif_printf(&sc->arpcom.ac_if, \"can't load RX mbuf\\n\");\n\t\t\treturn error;\n\t\t} else {\n\t\t\tgoto back;\n\t\t}\n\t}\n\n\tif (!init) {\n\t\tbus_dmamap_sync(sc->re_ldata.re_rx_mtag,\n\t\t\t\tsc->re_ldata.re_rx_dmamap[idx],\n\t\t\t\tBUS_DMASYNC_POSTREAD);\n\t\tbus_dmamap_unload(sc->re_ldata.re_rx_mtag,\n\t\t\t\t  sc->re_ldata.re_rx_dmamap[idx]);\n\t}\n\tsc->re_ldata.re_rx_mbuf[idx] = m;\n\tsc->re_ldata.re_rx_paddr[idx] = seg.ds_addr;\n\n\tmap = sc->re_ldata.re_rx_dmamap[idx];\n\tsc->re_ldata.re_rx_dmamap[idx] = sc->re_ldata.re_rx_spare;\n\tsc->re_ldata.re_rx_spare = map;\nback:\n\tre_setup_rxdesc(sc, idx);\n\treturn error;\n}", "item_id": 7, "repo": "strangelittlemonkey/DragonFlyBSD", "file": "sys/dev/netif/re/if_re.c", "last_update_at": "2019-01-23T07:03:52+00:00", "question_id": "901544a023df04690d80ab7db62eea66490519f5_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nre_newbuf_std(struct re_softc *sc, int idx, int init)\n{\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t map;\n\tstruct mbuf *m;\n\tint error, nsegs;\n\tm = m_getcl(init ? M_WAITOK : M_NOWAIT, MT_DATA, M_PKTHDR);\n\tif (m == NULL) {\n\t\terror = ENOBUFS;\n\t\tif (init) {\n\t\t\tif_printf(&sc->arpcom.ac_if, \"m_getcl failed\\n\");\n\t\t\treturn error;\n\t\t} else {\n\t\t\tgoto back;\n\t\t}\n\t}\n\tm->m_len = m->m_pkthdr.len = MCLBYTES;\n\t/*\n\t * NOTE:\n\t * re(4) chips need address of the receive buffer to be 8-byte\n\t * aligned, so don't call m_adj(m, ETHER_ALIGN) here.\n\t */\n\terror = bus_dmamap_load_mbuf_segment(sc->re_ldata.re_rx_mtag,\n\t\t\tsc->re_ldata.re_rx_spare, m,\n\t\t\t&seg, 1, &nsegs, BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tm_freem(m);\n\t\tif (init) {\n\t\t\tif_printf(&sc->arpcom.ac_if, \"can't load RX mbuf\\n\");\n\t\t\treturn error;\n\t\t} else {\n\t\t\tgoto back;\n\t\t}\n\t}\n\tif (!init) {\n\t\tbus_dmamap_sync(sc->re_ldata.re_rx_mtag,\n\t\t\t\tsc->re_ldata.re_rx_dmamap[idx],\n\t\t\t\tBUS_DMASYNC_POSTREAD);\n\t\tbus_dmamap_unload(sc->re_ldata.re_rx_mtag,\n\t\t\t\t  sc->re_ldata.re_rx_dmamap[idx]);\n\t}\n\tsc->re_ldata.re_rx_mbuf[idx] = m;\n\tsc->re_ldata.re_rx_paddr[idx] = seg.ds_addr;\n\tmap = sc->re_ldata.re_rx_dmamap[idx];\n\tsc->re_ldata.re_rx_dmamap[idx] = sc->re_ldata.re_rx_spare;\n\tsc->re_ldata.re_rx_spare = map;\nback:\n\tre_setup_rxdesc(sc, idx);\n\treturn error;\n"]], "pred": {"ppl": 1.5340384244918823, "ppl_lower": 1.7976032495498657, "ppl/lowercase_ppl": -1.370528414321163, "ppl/zlib": 0.0007108035734084778, "Min_5.0% Prob": 4.962674161967109, "Min_10.0% Prob": 3.417185797410853, "Min_20.0% Prob": 2.047899034554071, "Min_30.0% Prob": 1.4166349604798174, "Min_40.0% Prob": 1.0694230499287898, "Min_50.0% Prob": 0.8564416383701745, "Min_60.0% Prob": 0.7137115612585485}}
{"hexsha": "36b9a1ca8cbf2286a24ed7c5760ec03d05fb0d05", "ext": "c", "lang": "C", "content": "Oid\nts_extension_schema_oid(void)\n{\n\tDatum result;\n\tRelation rel;\n\tSysScanDesc scandesc;\n\tHeapTuple tuple;\n\tScanKeyData entry[1];\n\tbool is_null = true;\n\tOid schema = InvalidOid;\n\n\trel = table_open(ExtensionRelationId, AccessShareLock);\n\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_extension_extname,\n\t\t\t\tBTEqualStrategyNumber,\n\t\t\t\tF_NAMEEQ,\n\t\t\t\tDirectFunctionCall1(namein, CStringGetDatum(EXTENSION_NAME)));\n\n\tscandesc = systable_beginscan(rel, ExtensionNameIndexId, true, NULL, 1, entry);\n\n\ttuple = systable_getnext(scandesc);\n\n\t/* We assume that there can be at most one matching tuple */\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tresult =\n\t\t\theap_getattr(tuple, Anum_pg_extension_extnamespace, RelationGetDescr(rel), &is_null);\n\n\t\tif (!is_null)\n\t\t\tschema = DatumGetObjectId(result);\n\t}\n\n\tsystable_endscan(scandesc);\n\ttable_close(rel, AccessShareLock);\n\n\tif (schema == InvalidOid)\n\t\telog(ERROR, \"extension schema not found\");\n\treturn schema;\n}", "item_id": 3, "repo": "backwardn/timescaledb", "file": "src/extension.c", "last_update_at": "2019-06-21T21:36:01+00:00", "question_id": "36b9a1ca8cbf2286a24ed7c5760ec03d05fb0d05_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Oid\nts_extension_schema_oid(void)\n{\n\tDatum result;\n\tRelation rel;\n\tSysScanDesc scandesc;\n\tHeapTuple tuple;\n\tScanKeyData entry[1];\n\tbool is_null = true;\n\tOid schema = InvalidOid;\n\trel = table_open(ExtensionRelationId, AccessShareLock);\n\tScanKeyInit(&entry[0],\n\t\t\t\tAnum_pg_extension_extname,\n\t\t\t\tBTEqualStrategyNumber,\n\t\t\t\tF_NAMEEQ,\n\t\t\t\tDirectFunctionCall1(namein, CStringGetDatum(EXTENSION_NAME)));\n\tscandesc = systable_beginscan(rel, ExtensionNameIndexId, true, NULL, 1, entry);\n\ttuple = systable_getnext(scandesc);\n\t/* We assume that there can be at most one matching tuple */\n\tif (HeapTupleIsValid(tuple))\n\t{\n\t\tresult =\n\t\t\theap_getattr(tuple, Anum_pg_extension_extnamespace, RelationGetDescr(rel), &is_null);\n\t\tif (!is_null)\n\t\t\tschema = DatumGetObjectId(result);\n\t}\n\tsystable_endscan(scandesc);\n\ttable_close(rel, AccessShareLock);\n\tif (schema == InvalidOid)\n\t\telog(ERROR, \"extension schema not found\");\n\treturn schema;\n"]], "pred": {"ppl": 1.449599027633667, "ppl_lower": 3.4924824237823486, "ppl/lowercase_ppl": -3.3683183853356238, "ppl/zlib": 0.0007099177543476833, "Min_5.0% Prob": 5.058329078886244, "Min_10.0% Prob": 3.2802224457263947, "Min_20.0% Prob": 1.8313212954018214, "Min_30.0% Prob": 1.234410973756828, "Min_40.0% Prob": 0.9325853260170209, "Min_50.0% Prob": 0.7444029204023218, "Min_60.0% Prob": 0.6193221570799572}}
{"hexsha": "cbd8c253f0b8437c5d909c4a01fb0e612bf9cb58", "ext": "c", "lang": "C", "content": "static HRESULT WINAPI\nISF_MyComputer_fnCompareIDs (IShellFolder2 * iface, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)\n{\n    ICOM_THIS (IGenericSFImpl, iface);\n\n    int nReturn;\n\n    TRACE (\"(%p)->(0x%08lx,pidl1=%p,pidl2=%p)\\n\", This, lParam, pidl1, pidl2);\n    nReturn = SHELL32_CompareIDs (_IShellFolder_ (This), lParam, pidl1, pidl2);\n    TRACE (\"-- %i\\n\", nReturn);\n    return nReturn;\n}", "item_id": 8, "repo": "roytam1/wine-win31look", "file": "dlls/shell32/shfldr_mycomp.c", "last_update_at": "2019-10-23T04:07:16+00:00", "question_id": "cbd8c253f0b8437c5d909c4a01fb0e612bf9cb58_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static HRESULT WINAPI\nISF_MyComputer_fnCompareIDs (IShellFolder2 * iface, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)\n{\n    ICOM_THIS (IGenericSFImpl, iface);\n    int nReturn;\n    TRACE (\"(%p)->(0x%08lx,pidl1=%p,pidl2=%p)\\n\", This, lParam, pidl1, pidl2);\n    nReturn = SHELL32_CompareIDs (_IShellFolder_ (This), lParam, pidl1, pidl2);\n    TRACE (\"-- %i\\n\", nReturn);\n    return nReturn;\n"]], "pred": {"ppl": 2.2280590534210205, "ppl_lower": 4.563602924346924, "ppl/lowercase_ppl": -1.894961940893438, "ppl/zlib": 0.0031790905826980724, "Min_5.0% Prob": 6.9182891845703125, "Min_10.0% Prob": 5.298817568355137, "Min_20.0% Prob": 3.5791298813290067, "Min_30.0% Prob": 2.5933838464595653, "Min_40.0% Prob": 1.9984677041777306, "Min_50.0% Prob": 1.6068753983618485, "Min_60.0% Prob": 1.3416030007431767}}
{"hexsha": "e64e26fa7057d645cd3b531a435793a448ab7d1d", "ext": "c", "lang": "C", "content": "static int rpmnssGenerateRSA(pgpDig dig)\n{\n    rpmnss nss = dig->impl;\n    int rc = 0;\t\t/* assume failure */\n\n    {\tCK_MECHANISM_TYPE _type = CKM_RSA_PKCS_KEY_PAIR_GEN;\n\tPK11SlotInfo * _slot = PK11_GetBestSlot(_type, NULL);\n\tint _isPerm = PR_FALSE;\n\tint _isSensitive = PR_FALSE;\n\tvoid * _cx = NULL;\n\nassert(nss->nbits);\n\n\tif (_slot) {\n\t    static unsigned _pe = 0x10001;\t/* XXX FIXME: pass in e */\n\t    PK11RSAGenParams rsaparams =\n\t\t{ .keySizeInBits = nss->nbits, .pe = _pe };\n\t    void * params = &rsaparams;\n\n#ifdef\tDYING\nrpmnssDumpSLOTINFO(\"\\tGetBestSlot\", _slot, _type);\n#endif\n\n\t    nss->sec_key = PK11_GenerateKeyPair(_slot, _type, params,\n\t\t\t&nss->pub_key, _isPerm, _isSensitive, _cx);\n\n#ifdef\tDYING\nfprintf(stderr, \"<-- %p = PK11_GenerateKeyPair(%p, 0x%04X, %p, %p, %s,%s,%p)\\n\",\nnss->sec_key, _slot, (unsigned)_type, params,\n&nss->pub_key,\n(_isPerm ? \"TRUE\" : \"FALSE\"),\n(_isSensitive ? \"TRUE\" : \"FALSE\"),\n_cx);\n#endif\n\n\t    PK11_FreeSlot(_slot);\n\t}\n    }\n\n    rc = (nss->sec_key && nss->pub_key);\n\nif (1 || _pgp_debug) {\nrpmnssDumpPRVKEY(\" sec\", nss->sec_key);\nrpmnssDumpPUBKEY(\" pub\", nss->pub_key);\n}\n\nSPEW(!rc, rc, dig);\n\n    return rc;\n}", "item_id": 69, "repo": "devzero2000/RPM5", "file": "tests/trsa.c", "last_update_at": "2019-01-14T07:48:54+00:00", "question_id": "e64e26fa7057d645cd3b531a435793a448ab7d1d_69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int rpmnssGenerateRSA(pgpDig dig)\n{\n    rpmnss nss = dig->impl;\n    int rc = 0;\t\t/* assume failure */\n    {\tCK_MECHANISM_TYPE _type = CKM_RSA_PKCS_KEY_PAIR_GEN;\n\tPK11SlotInfo * _slot = PK11_GetBestSlot(_type, NULL);\n\tint _isPerm = PR_FALSE;\n\tint _isSensitive = PR_FALSE;\n\tvoid * _cx = NULL;\nassert(nss->nbits);\n\tif (_slot) {\n\t    static unsigned _pe = 0x10001;\t/* XXX FIXME: pass in e */\n\t    PK11RSAGenParams rsaparams =\n\t\t{ .keySizeInBits = nss->nbits, .pe = _pe };\n\t    void * params = &rsaparams;\n#ifdef\tDYING\nrpmnssDumpSLOTINFO(\"\\tGetBestSlot\", _slot, _type);\n#endif\n\t    nss->sec_key = PK11_GenerateKeyPair(_slot, _type, params,\n\t\t\t&nss->pub_key, _isPerm, _isSensitive, _cx);\n#ifdef\tDYING\nfprintf(stderr, \"<-- %p = PK11_GenerateKeyPair(%p, 0x%04X, %p, %p, %s,%s,%p)\\n\",\nnss->sec_key, _slot, (unsigned)_type, params,\n&nss->pub_key,\n(_isPerm ? \"TRUE\" : \"FALSE\"),\n(_isSensitive ? \"TRUE\" : \"FALSE\"),\n_cx);\n#endif\n\t    PK11_FreeSlot(_slot);\n\t}\n    }\n    rc = (nss->sec_key && nss->pub_key);\nif (1 || _pgp_debug) {\nrpmnssDumpPRVKEY(\" sec\", nss->sec_key);\nrpmnssDumpPUBKEY(\" pub\", nss->pub_key);\n}\nSPEW(!rc, rc, dig);\n    return rc;\n"]], "pred": {"ppl": 2.4397523403167725, "ppl_lower": 3.29412579536438, "ppl/lowercase_ppl": -1.336635780546412, "ppl/zlib": 0.0014431982755396032, "Min_5.0% Prob": 6.805472867829459, "Min_10.0% Prob": 5.460423520633152, "Min_20.0% Prob": 3.8457463245306696, "Min_30.0% Prob": 2.832209779038316, "Min_40.0% Prob": 2.1925715216701582, "Min_50.0% Prob": 1.7765944960527122, "Min_60.0% Prob": 1.486545269854278}}
{"hexsha": "b0b2e2d53b216c9b895a61bb1bc55b9235cbdd9c", "ext": "c", "lang": "C", "content": "static int\nfd_attach(device_t dev)\n{\n\tstruct\tfd_data *fd;\n\n\tfd = device_get_softc(dev);\n#ifdef GONE_IN_5\n\tfd->clonetag = EVENTHANDLER_REGISTER(dev_clone, fd_clone, fd, 1000);\n#endif\n\tfd->masterdev = make_dev(&fd_cdevsw, fd->fdu << 6,\n\t\t\t\t UID_ROOT, GID_OPERATOR, 0640, \"fd%d\", fd->fdu);\n\tfd->masterdev->si_drv1 = fd;\n#ifdef GONE_IN_5\n\t{\n\tint i;\n\tfor (i = 0; i < NUMDENS - 1; i++)\n\t\tfd->clonedevs[i] = NODEV;\n\t}\n#endif\n\tfd->device_stats = devstat_new_entry(device_get_name(dev), \n\t\t\t  device_get_unit(dev), 0, DEVSTAT_NO_ORDERED_TAGS,\n\t\t\t  DEVSTAT_TYPE_FLOPPY | DEVSTAT_TYPE_IF_OTHER,\n\t\t\t  DEVSTAT_PRIORITY_FD);\n\treturn (0);\n}", "item_id": 19, "repo": "shisa/kame-shisa", "file": "freebsd5/sys/pc98/pc98/fd.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "b0b2e2d53b216c9b895a61bb1bc55b9235cbdd9c_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nfd_attach(device_t dev)\n{\n\tstruct\tfd_data *fd;\n\tfd = device_get_softc(dev);\n#ifdef GONE_IN_5\n\tfd->clonetag = EVENTHANDLER_REGISTER(dev_clone, fd_clone, fd, 1000);\n#endif\n\tfd->masterdev = make_dev(&fd_cdevsw, fd->fdu << 6,\n\t\t\t\t UID_ROOT, GID_OPERATOR, 0640, \"fd%d\", fd->fdu);\n\tfd->masterdev->si_drv1 = fd;\n#ifdef GONE_IN_5\n\t{\n\tint i;\n\tfor (i = 0; i < NUMDENS - 1; i++)\n\t\tfd->clonedevs[i] = NODEV;\n\t}\n#endif\n\tfd->device_stats = devstat_new_entry(device_get_name(dev), \n\t\t\t  device_get_unit(dev), 0, DEVSTAT_NO_ORDERED_TAGS,\n\t\t\t  DEVSTAT_TYPE_FLOPPY | DEVSTAT_TYPE_IF_OTHER,\n\t\t\t  DEVSTAT_PRIORITY_FD);\n\treturn (0);\n"]], "pred": {"ppl": 2.4201221466064453, "ppl_lower": 3.522693634033203, "ppl/lowercase_ppl": -1.424757038002788, "ppl/zlib": 0.0022778814760287414, "Min_5.0% Prob": 7.961460500955582, "Min_10.0% Prob": 6.0065633672656435, "Min_20.0% Prob": 3.9839048954573544, "Min_30.0% Prob": 2.8513913467676955, "Min_40.0% Prob": 2.190286542486512, "Min_50.0% Prob": 1.7661305959703344, "Min_60.0% Prob": 1.4755592238854127}}
{"hexsha": "2c7a4de0cf58465a442a01ff7d570911fddf57f5", "ext": "c", "lang": "C", "content": "void led_on_set(homekit_value_t value)\n{\n   if(value.format != homekit_format_bool)\n   {\n      // printf(\"Invalid on-value format: %d\\n\", value.format);\n      return;\n   }\n\n   led_on = value.bool_value;\n   led_string_set();\n}", "item_id": 5, "repo": "afugs98/SmartHome", "file": "Devices/Commisioned_LedStrip/main.c", "last_update_at": "2019-06-22T05:22:42+00:00", "question_id": "2c7a4de0cf58465a442a01ff7d570911fddf57f5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void led_on_set(homekit_value_t value)\n{\n   if(value.format != homekit_format_bool)\n   {\n      // printf(\"Invalid on-value format: %d\\n\", value.format);\n      return;\n   }\n   led_on = value.bool_value;\n   led_string_set();\n"]], "pred": {"ppl": 3.4868388175964355, "ppl_lower": 3.756037473678589, "ppl/lowercase_ppl": -1.0595430431437205, "ppl/zlib": 0.008326636952142955, "Min_5.0% Prob": 10.707651138305664, "Min_10.0% Prob": 8.499084949493408, "Min_20.0% Prob": 5.216639034888324, "Min_30.0% Prob": 3.976754984855652, "Min_40.0% Prob": 3.0586775387911236, "Min_50.0% Prob": 2.507534263744241, "Min_60.0% Prob": 2.0773218592592313}}
{"hexsha": "8dcb2f12a278046542d112739d1cf6e13fa5a82a", "ext": "c", "lang": "C", "content": "int ARCONTROLLER_TESTBENCH_DeviceControllerAutoTest_initDiscoveryDevice (ARDISCOVERY_Device_t **device)\n{\n    int failed = 0;\n    \n    eARDISCOVERY_ERROR errorDiscovery = ARDISCOVERY_OK;\n    \n    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"- init discovey device  ... \");\n    \n    *device = ARDISCOVERY_Device_New (&errorDiscovery);\n    if ((errorDiscovery != ARDISCOVERY_OK) || (device == NULL))\n    {\n        failed += 1;\n        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"device : %p\", device);\n        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"Discovery error :%s\", ARDISCOVERY_Error_ToString(errorDiscovery));\n    }\n    \n    if (errorDiscovery == ARDISCOVERY_OK)\n    {\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - ARDISCOVERY_Device_InitWifi ...\");\n#if DEVICE_TYPE == TEST_BEBOP\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"ARDISCOVERY_PRODUCT_ARDRONE .....................\");\n        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_ARDRONE, \"Bebop\", FAKEDRONE_IP_ADDRESS, FAKEDRONE_DISCOVERY_PORT);\n#elif DEVICE_TYPE == TEST_JS\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"ARDISCOVERY_PRODUCT_JS .....................\");\n        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_JS, \"Js\", JS_IP_ADDRESS, JS_DISCOVERY_PORT);\n#endif\n        \n        if (errorDiscovery != ARDISCOVERY_OK)\n        {\n            failed += 1;\n            ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"Discovery error :%s\", ARDISCOVERY_Error_ToString(errorDiscovery));\n        }\n        else\n        {\n            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - (*device)->produitID = %d\", (*device)->productID );\n            \n            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - ARDISCOVERY_Device_InitWifi succeed\");\n        }\n    }\n    \n    return failed;\n}", "item_id": 2, "repo": "TXSTDroneResearch/libARController", "file": "TestBench/Common/ARCONTROLLER_TESTBENCH_DeviceControllerAutoTest.c", "last_update_at": "2019-01-04T12:40:06+00:00", "question_id": "8dcb2f12a278046542d112739d1cf6e13fa5a82a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ARCONTROLLER_TESTBENCH_DeviceControllerAutoTest_initDiscoveryDevice (ARDISCOVERY_Device_t **device)\n{\n    int failed = 0;\n    eARDISCOVERY_ERROR errorDiscovery = ARDISCOVERY_OK;\n    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"- init discovey device  ... \");\n    *device = ARDISCOVERY_Device_New (&errorDiscovery);\n    if ((errorDiscovery != ARDISCOVERY_OK) || (device == NULL))\n    {\n        failed += 1;\n        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"device : %p\", device);\n        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"Discovery error :%s\", ARDISCOVERY_Error_ToString(errorDiscovery));\n    }\n    if (errorDiscovery == ARDISCOVERY_OK)\n    {\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - ARDISCOVERY_Device_InitWifi ...\");\n#if DEVICE_TYPE == TEST_BEBOP\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"ARDISCOVERY_PRODUCT_ARDRONE .....................\");\n        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_ARDRONE, \"Bebop\", FAKEDRONE_IP_ADDRESS, FAKEDRONE_DISCOVERY_PORT);\n#elif DEVICE_TYPE == TEST_JS\n        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"ARDISCOVERY_PRODUCT_JS .....................\");\n        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_JS, \"Js\", JS_IP_ADDRESS, JS_DISCOVERY_PORT);\n#endif\n        if (errorDiscovery != ARDISCOVERY_OK)\n        {\n            failed += 1;\n            ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, \"Discovery error :%s\", ARDISCOVERY_Error_ToString(errorDiscovery));\n        }\n        else\n        {\n            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - (*device)->produitID = %d\", (*device)->productID );\n            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, \"    - ARDISCOVERY_Device_InitWifi succeed\");\n        }\n    }\n    return failed;\n"]], "pred": {"ppl": 1.900496006011963, "ppl_lower": 2.4750595092773438, "ppl/lowercase_ppl": -1.4113742396190663, "ppl/zlib": 0.0012444087362384294, "Min_5.0% Prob": 7.0965476176318, "Min_10.0% Prob": 5.056300422419673, "Min_20.0% Prob": 3.099095719448034, "Min_30.0% Prob": 2.1259397516528575, "Min_40.0% Prob": 1.6053825103566857, "Min_50.0% Prob": 1.2835449996305044, "Min_60.0% Prob": 1.0710873531713263}}
{"hexsha": "4e2eeb4a272324779364b6b14a3d1fc27aa9b2a4", "ext": "c", "lang": "C", "content": "void irq_dis(int nr)\n{\n\tunsigned int addr;\n\tunsigned char m;\n\t\n\tif (nr < 8)\n\t\taddr = A8259A_M + 1;\n\telse\n\t{\n\t\taddr = A8259A_S + 1;\n\t\tnr -= 8;\n\t\tif (nr > 7)\n\t\t\tpanic(\"irq_dis: invalid irq number\");\n\t}\n\t\n\tintr_disable();\n\tm  = inb(addr);\n\tm |= (1 << nr);\n\toutb(addr, m);\n\tintr_enable();\n}", "item_id": 5, "repo": "p-durlej/xenus", "file": "kern/intr.c", "last_update_at": "2019-12-29T19:33:28+00:00", "question_id": "4e2eeb4a272324779364b6b14a3d1fc27aa9b2a4_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void irq_dis(int nr)\n{\n\tunsigned int addr;\n\tunsigned char m;\n\t\n\tif (nr < 8)\n\t\taddr = A8259A_M + 1;\n\telse\n\t{\n\t\taddr = A8259A_S + 1;\n\t\tnr -= 8;\n\t\tif (nr > 7)\n\t\t\tpanic(\"irq_dis: invalid irq number\");\n\t}\n\t\n\tintr_disable();\n\tm  = inb(addr);\n\tm |= (1 << nr);\n\toutb(addr, m);\n\tintr_enable();\n"]], "pred": {"ppl": 2.842708110809326, "ppl_lower": 2.8911681175231934, "ppl/lowercase_ppl": -1.016179315239431, "ppl/zlib": 0.005441443531081144, "Min_5.0% Prob": 8.39745807647705, "Min_10.0% Prob": 6.718380896250407, "Min_20.0% Prob": 4.4732102809413785, "Min_30.0% Prob": 3.2765939945870257, "Min_40.0% Prob": 2.571424682935079, "Min_50.0% Prob": 2.0856729840176014, "Min_60.0% Prob": 1.7438968112006}}
{"hexsha": "11f859dfb69af00d0256bec21679a0f7e5961433", "ext": "c", "lang": "C", "content": "Returncode integration_M_f_try_catch_raise(integration_M_TestStruct* t, Ref_Manager* t_Refman) {\n    Returncode LUMI_err = OK;\n    String aux_String_0_Var = {0};\n    String* aux_String_0 = NULL;\n    Ref_Manager* aux_String_0_Refman = NULL;\n    LUMI_inc_ref(t_Refman);\n    do {\n        ++LUMI_trace_ignore_count;\n#undef RETURN_ERROR\n#define RETURN_ERROR break\n        CHECK_REF(422, t, t_Refman)\n        t->num = 1;\n\n#undef RETURN_ERROR\n#define RETURN_ERROR goto LUMI_cleanup\n    } while (false);\n    --LUMI_trace_ignore_count;\n    if (LUMI_err != OK) {\n        LUMI_err = OK;\n        INIT_STRING_CONST(424, aux_String_0, \"ignored message\");\n        USER_RAISE(424, aux_String_0, aux_String_0_Refman)\n    }\nLUMI_cleanup:\n    LUMI_var_dec_ref(aux_String_0_Refman);\n    LUMI_dec_ref(t_Refman);\n    return LUMI_err;\n}", "item_id": 37, "repo": "snudler6/lumi-lang", "file": "TL4/tests/integration-expected-single.c", "last_update_at": "2019-10-22T19:25:48+00:00", "question_id": "11f859dfb69af00d0256bec21679a0f7e5961433_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Returncode integration_M_f_try_catch_raise(integration_M_TestStruct* t, Ref_Manager* t_Refman) {\n    Returncode LUMI_err = OK;\n    String aux_String_0_Var = {0};\n    String* aux_String_0 = NULL;\n    Ref_Manager* aux_String_0_Refman = NULL;\n    LUMI_inc_ref(t_Refman);\n    do {\n        ++LUMI_trace_ignore_count;\n#undef RETURN_ERROR\n#define RETURN_ERROR break\n        CHECK_REF(422, t, t_Refman)\n        t->num = 1;\n#undef RETURN_ERROR\n#define RETURN_ERROR goto LUMI_cleanup\n    } while (false);\n    --LUMI_trace_ignore_count;\n    if (LUMI_err != OK) {\n        LUMI_err = OK;\n        INIT_STRING_CONST(424, aux_String_0, \"ignored message\");\n        USER_RAISE(424, aux_String_0, aux_String_0_Refman)\n    }\nLUMI_cleanup:\n    LUMI_var_dec_ref(aux_String_0_Refman);\n    LUMI_dec_ref(t_Refman);\n    return LUMI_err;\n"]], "pred": {"ppl": 2.033158302307129, "ppl_lower": 3.804081678390503, "ppl/lowercase_ppl": -1.8828814763839983, "ppl/zlib": 0.0018922410612624769, "Min_5.0% Prob": 7.487437528722427, "Min_10.0% Prob": 5.39532915984883, "Min_20.0% Prob": 3.326959158567821, "Min_30.0% Prob": 2.3291197679206435, "Min_40.0% Prob": 1.7666328239035518, "Min_50.0% Prob": 1.4175502622664413, "Min_60.0% Prob": 1.1823033886931964}}
{"hexsha": "ee064d7f71abd7cebbe5206046272c5b62790685", "ext": "c", "lang": "C", "content": "esk8_err_t esk8_auth_auth(\n\n    esk8_auth_hndl_t* hndl,\n    esk8_auth_key_t   key\n\n)\n{\n    esk8_auth_key_t   hash;\n    esk8_auth_cntx_t* cntx = *hndl;\n\n    if (mbedtls_md_starts(&cntx->mbtls_cntx))\n        return ESK8_AUTH_ERR_HASH;\n\n    if (mbedtls_md_update(&cntx->mbtls_cntx, key, sizeof(esk8_auth_key_t)))\n        return ESK8_AUTH_ERR_HASH;\n\n    if (mbedtls_md_finish(&cntx->mbtls_cntx, hash))\n        return ESK8_AUTH_ERR_HASH;\n\n    if (memcmp(cntx->hash, hash, sizeof(esk8_auth_key_t)) == 0)\n        return ESK8_OK;\n\n    return ESK8_AUTH_ERR_AUTH;\n}", "item_id": 2, "repo": "BernardoCovas/E_Skate-Controller", "file": "mcu/main/lib/auth/esk8_auth.c", "last_update_at": "2019-09-01T20:11:09+00:00", "question_id": "ee064d7f71abd7cebbe5206046272c5b62790685_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["esk8_err_t esk8_auth_auth(\n    esk8_auth_hndl_t* hndl,\n    esk8_auth_key_t   key\n)\n{\n    esk8_auth_key_t   hash;\n    esk8_auth_cntx_t* cntx = *hndl;\n    if (mbedtls_md_starts(&cntx->mbtls_cntx))\n        return ESK8_AUTH_ERR_HASH;\n    if (mbedtls_md_update(&cntx->mbtls_cntx, key, sizeof(esk8_auth_key_t)))\n        return ESK8_AUTH_ERR_HASH;\n    if (mbedtls_md_finish(&cntx->mbtls_cntx, hash))\n        return ESK8_AUTH_ERR_HASH;\n    if (memcmp(cntx->hash, hash, sizeof(esk8_auth_key_t)) == 0)\n        return ESK8_OK;\n    return ESK8_AUTH_ERR_AUTH;\n"]], "pred": {"ppl": 1.9023102521896362, "ppl_lower": 2.0054008960723877, "ppl/lowercase_ppl": -1.0820672641209501, "ppl/zlib": 0.002977171619179397, "Min_5.0% Prob": 6.770538788575393, "Min_10.0% Prob": 4.856605980131361, "Min_20.0% Prob": 2.9804574652151627, "Min_30.0% Prob": 2.1089872064360655, "Min_40.0% Prob": 1.604512062628527, "Min_50.0% Prob": 1.284777137866284, "Min_60.0% Prob": 1.0766710434866373}}
{"hexsha": "270bd0b3b22efefacf1648027749a69111f5fcff", "ext": "c", "lang": "C", "content": "static void\ndrmmode_output_dpms(xf86OutputPtr output, int mode)\n{\n    drmmode_output_private_ptr drmmode_output = output->driver_private;\n    xf86CrtcPtr crtc = output->crtc;\n    drmModeConnectorPtr koutput = drmmode_output->mode_output;\n    drmmode_ptr drmmode = drmmode_output->drmmode;\n\n    if (!koutput)\n        return;\n\n    drmModeConnectorSetProperty(drmmode->fd, koutput->connector_id,\n                                drmmode_output->dpms_enum_id, mode);\n\n    if (crtc) {\n        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;\n\n        if (mode == DPMSModeOn) {\n            if (drmmode_crtc->need_modeset)\n                drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation,\n                                       crtc->x, crtc->y);\n\n            if (drmmode_crtc->enable_flipping)\n                drmmode_InitSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);\n        } else {\n            if (drmmode_crtc->enable_flipping)\n                drmmode_FiniSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);\n        }\n    }\n\n    return;\n}", "item_id": 39, "repo": "NovasomIndustries/Utils-2019.01", "file": "rock/external/xserver/hw/xfree86/drivers/modesetting/drmmode_display.c", "last_update_at": "2019-06-14T07:17:22+00:00", "question_id": "270bd0b3b22efefacf1648027749a69111f5fcff_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\ndrmmode_output_dpms(xf86OutputPtr output, int mode)\n{\n    drmmode_output_private_ptr drmmode_output = output->driver_private;\n    xf86CrtcPtr crtc = output->crtc;\n    drmModeConnectorPtr koutput = drmmode_output->mode_output;\n    drmmode_ptr drmmode = drmmode_output->drmmode;\n    if (!koutput)\n        return;\n    drmModeConnectorSetProperty(drmmode->fd, koutput->connector_id,\n                                drmmode_output->dpms_enum_id, mode);\n    if (crtc) {\n        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;\n        if (mode == DPMSModeOn) {\n            if (drmmode_crtc->need_modeset)\n                drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation,\n                                       crtc->x, crtc->y);\n            if (drmmode_crtc->enable_flipping)\n                drmmode_InitSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);\n        } else {\n            if (drmmode_crtc->enable_flipping)\n                drmmode_FiniSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);\n        }\n    }\n    return;\n"]], "pred": {"ppl": 1.6033666133880615, "ppl_lower": 2.1333370208740234, "ppl/lowercase_ppl": -1.604911077577303, "ppl/zlib": 0.0013114043111806435, "Min_5.0% Prob": 5.0741956359461735, "Min_10.0% Prob": 3.4159148167341185, "Min_20.0% Prob": 2.14825449578273, "Min_30.0% Prob": 1.530461955911074, "Min_40.0% Prob": 1.1750511322886898, "Min_50.0% Prob": 0.9418730021226315, "Min_60.0% Prob": 0.7871421296961922}}
{"hexsha": "5e41487d57aa5ab28fd6afb85df508d0f3db582a", "ext": "c", "lang": "C", "content": "int\nrequest_looks_dynamic(INKMBuffer bufp, INKMLoc hdr_loc)\n{\n  INKMLoc url_loc, cookie_loc;\n  const char *path;\n  const char *query;\n  int len;\n\n  INKDebug(MED, \"In request_looks_dynamic\");\n\n  url_loc = INKHttpHdrUrlGet(bufp, hdr_loc);\n  if (url_loc == NULL) {\n    INKError(\"Could not retrieve Url\");\n    return -1;\n  }\n\n  path = INKUrlPathGet(bufp, url_loc, &len);\n  if ((path != NULL) && (len > 0)) {\n    char *str = INKmalloc(len + 1);\n    strncpy(str, path, len);\n    str[len] = '\\0';\n\n    if ((strstr(str, ASP_EXTENSION) != NULL) || (strstr(str, JSP_EXTENSION) != NULL) || (strstr(str, CGI_BIN) != NULL)) {\n      INKHandleStringRelease(bufp, url_loc, path);\n      INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n      return 1;\n    }\n    INKHandleStringRelease(bufp, url_loc, path);\n  }\n\n  query = INKUrlHttpQueryGet(bufp, url_loc, &len);\n  if ((query != NULL) && (len > 0)) {\n    INKHandleStringRelease(bufp, url_loc, query);\n    INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n    return 1;\n  }\n\n  cookie_loc = INKMimeHdrFieldRetrieve(bufp, hdr_loc, INK_MIME_FIELD_COOKIE);\n  if (cookie_loc != NULL) {\n    INKHandleMLocRelease(bufp, hdr_loc, cookie_loc);\n    INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n    return 1;\n  }\n\n  INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n  return 0;\n}", "item_id": 4, "repo": "ibrezac/trafficserver", "file": "test/plugin/assembly/headers.c", "last_update_at": "2019-06-12T09:21:10+00:00", "question_id": "5e41487d57aa5ab28fd6afb85df508d0f3db582a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nrequest_looks_dynamic(INKMBuffer bufp, INKMLoc hdr_loc)\n{\n  INKMLoc url_loc, cookie_loc;\n  const char *path;\n  const char *query;\n  int len;\n  INKDebug(MED, \"In request_looks_dynamic\");\n  url_loc = INKHttpHdrUrlGet(bufp, hdr_loc);\n  if (url_loc == NULL) {\n    INKError(\"Could not retrieve Url\");\n    return -1;\n  }\n  path = INKUrlPathGet(bufp, url_loc, &len);\n  if ((path != NULL) && (len > 0)) {\n    char *str = INKmalloc(len + 1);\n    strncpy(str, path, len);\n    str[len] = '\\0';\n    if ((strstr(str, ASP_EXTENSION) != NULL) || (strstr(str, JSP_EXTENSION) != NULL) || (strstr(str, CGI_BIN) != NULL)) {\n      INKHandleStringRelease(bufp, url_loc, path);\n      INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n      return 1;\n    }\n    INKHandleStringRelease(bufp, url_loc, path);\n  }\n  query = INKUrlHttpQueryGet(bufp, url_loc, &len);\n  if ((query != NULL) && (len > 0)) {\n    INKHandleStringRelease(bufp, url_loc, query);\n    INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n    return 1;\n  }\n  cookie_loc = INKMimeHdrFieldRetrieve(bufp, hdr_loc, INK_MIME_FIELD_COOKIE);\n  if (cookie_loc != NULL) {\n    INKHandleMLocRelease(bufp, hdr_loc, cookie_loc);\n    INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n    return 1;\n  }\n  INKHandleMLocRelease(bufp, hdr_loc, url_loc);\n  return 0;\n"]], "pred": {"ppl": 1.5299699306488037, "ppl_lower": 2.1773104667663574, "ppl/lowercase_ppl": -1.829732848068074, "ppl/zlib": 0.0009145120043881752, "Min_5.0% Prob": 5.401049808219627, "Min_10.0% Prob": 3.5440530247158475, "Min_20.0% Prob": 2.0367941889497967, "Min_30.0% Prob": 1.4026943172093915, "Min_40.0% Prob": 1.0619576637663188, "Min_50.0% Prob": 0.8494070201482186, "Min_60.0% Prob": 0.7093948740490706}}
{"hexsha": "829d178d47fe7a86885e63a83f1a808837c417d3", "ext": "c", "lang": "C", "content": "static void on_read(uv_stream_t* handle,\n                    ssize_t nread,\n                    const uv_buf_t* buf) {\n  int r;\n  uv_pipe_t* pipe;\n  uv_handle_type pending;\n  uv_buf_t outbuf;\n\n  pipe = (uv_pipe_t*) handle;\n\n  if (nread == 0) {\n    /* Everything OK, but nothing read. */\n    free(buf->base);\n    return;\n  }\n\n  if (nread < 0) {\n    if (nread == UV_EOF) {\n      free(buf->base);\n      return;\n    }\n\n    printf(\"error recving on channel: %s\\n\", uv_strerror(nread));\n    abort();\n  }\n\n  fprintf(stderr, \"got %d bytes\\n\", (int)nread);\n\n  pending = uv_pipe_pending_type(pipe);\n  if (!tcp_server_listening) {\n    ASSERT(1 == uv_pipe_pending_count(pipe));\n    ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);\n    read_cb_called++;\n\n    /* Accept the pending TCP server, and start listening on it. */\n    ASSERT(pending == UV_TCP);\n    r = uv_tcp_init(uv_default_loop(), &tcp_server);\n    ASSERT(r == 0);\n\n    r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);\n    ASSERT(r == 0);\n\n    r = uv_listen((uv_stream_t*)&tcp_server, BACKLOG, on_connection);\n    ASSERT(r == 0);\n\n    tcp_server_listening = 1;\n\n    /* Make sure that the expected data is correctly multiplexed. */\n    ASSERT(memcmp(\"hello\\n\", buf->base, nread) == 0);\n\n    outbuf = uv_buf_init(\"world\\n\", 6);\n    r = uv_write(&write_req, (uv_stream_t*)pipe, &outbuf, 1, NULL);\n    ASSERT(r == 0);\n\n    /* Create a bunch of connections to get both servers to accept. */\n    make_many_connections();\n  } else if (memcmp(\"accepted_connection\\n\", buf->base, nread) == 0) {\n    /* Remote server has accepted a connection.  Close the channel. */\n    ASSERT(0 == uv_pipe_pending_count(pipe));\n    ASSERT(pending == UV_UNKNOWN_HANDLE);\n    remote_conn_accepted = 1;\n    uv_close((uv_handle_t*)&channel, NULL);\n  }\n\n  free(buf->base);\n}", "item_id": 3, "repo": "maytrue/mediasoup", "file": "worker/deps/libuv/test/test-ipc.c", "last_update_at": "2019-04-03T16:06:22+00:00", "question_id": "829d178d47fe7a86885e63a83f1a808837c417d3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void on_read(uv_stream_t* handle,\n                    ssize_t nread,\n                    const uv_buf_t* buf) {\n  int r;\n  uv_pipe_t* pipe;\n  uv_handle_type pending;\n  uv_buf_t outbuf;\n  pipe = (uv_pipe_t*) handle;\n  if (nread == 0) {\n    /* Everything OK, but nothing read. */\n    free(buf->base);\n    return;\n  }\n  if (nread < 0) {\n    if (nread == UV_EOF) {\n      free(buf->base);\n      return;\n    }\n    printf(\"error recving on channel: %s\\n\", uv_strerror(nread));\n    abort();\n  }\n  fprintf(stderr, \"got %d bytes\\n\", (int)nread);\n  pending = uv_pipe_pending_type(pipe);\n  if (!tcp_server_listening) {\n    ASSERT(1 == uv_pipe_pending_count(pipe));\n    ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);\n    read_cb_called++;\n    /* Accept the pending TCP server, and start listening on it. */\n    ASSERT(pending == UV_TCP);\n    r = uv_tcp_init(uv_default_loop(), &tcp_server);\n    ASSERT(r == 0);\n    r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);\n    ASSERT(r == 0);\n    r = uv_listen((uv_stream_t*)&tcp_server, BACKLOG, on_connection);\n    ASSERT(r == 0);\n    tcp_server_listening = 1;\n    /* Make sure that the expected data is correctly multiplexed. */\n    ASSERT(memcmp(\"hello\\n\", buf->base, nread) == 0);\n    outbuf = uv_buf_init(\"world\\n\", 6);\n    r = uv_write(&write_req, (uv_stream_t*)pipe, &outbuf, 1, NULL);\n    ASSERT(r == 0);\n    /* Create a bunch of connections to get both servers to accept. */\n    make_many_connections();\n  } else if (memcmp(\"accepted_connection\\n\", buf->base, nread) == 0) {\n    /* Remote server has accepted a connection.  Close the channel. */\n    ASSERT(0 == uv_pipe_pending_count(pipe));\n    ASSERT(pending == UV_UNKNOWN_HANDLE);\n    remote_conn_accepted = 1;\n    uv_close((uv_handle_t*)&channel, NULL);\n  }\n  free(buf->base);\n"]], "pred": {"ppl": 1.9216868877410889, "ppl_lower": 2.071948766708374, "ppl/lowercase_ppl": -1.1152569189740023, "ppl/zlib": 0.000873266561059997, "Min_5.0% Prob": 6.0288368463516235, "Min_10.0% Prob": 4.60114691985978, "Min_20.0% Prob": 2.989370180820597, "Min_30.0% Prob": 2.1382433330520576, "Min_40.0% Prob": 1.626124639691356, "Min_50.0% Prob": 1.304623970738868, "Min_60.0% Prob": 1.0902564282210783}}
{"hexsha": "59487d51b44b3603cb3a2e43ba44b6c756aaca76", "ext": "c", "lang": "C", "content": "void test_repo_message__cleanup(void)\n{\n        cl_git_sandbox_cleanup();\n\tgit_buf_free(&_path);\n\tgit__free(_actual);\n\t_actual = NULL;\n}", "item_id": 0, "repo": "albfan/libgit2", "file": "tests-clar/repo/message.c", "last_update_at": "2019-05-26T16:54:59+00:00", "question_id": "59487d51b44b3603cb3a2e43ba44b6c756aaca76_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_repo_message__cleanup(void)\n{\n        cl_git_sandbox_cleanup();\n\tgit_buf_free(&_path);\n\tgit__free(_actual);\n\t_actual = NULL;\n"]], "pred": {"ppl": 6.7952561378479, "ppl_lower": 8.101068496704102, "ppl/lowercase_ppl": -1.091727875318949, "ppl/zlib": 0.01742022492672897, "Min_5.0% Prob": 8.66525650024414, "Min_10.0% Prob": 8.319793319702148, "Min_20.0% Prob": 6.870021343231201, "Min_30.0% Prob": 5.340264946222305, "Min_40.0% Prob": 4.484123383249555, "Min_50.0% Prob": 3.706181874981633, "Min_60.0% Prob": 3.1902162050828338}}
{"hexsha": "1e2a3b8f9454db31500fbc415138cbf114558f59", "ext": "c", "lang": "C", "content": "static long si544_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\tstruct clk_si544_muldiv settings;\n\tint err;\n\n\tif (!is_valid_frequency(data, rate))\n\t\treturn -EINVAL;\n\n\terr = si544_calc_muldiv(&settings, rate);\n\tif (err)\n\t\treturn err;\n\n\treturn si544_calc_rate(&settings);\n}", "item_id": 6, "repo": "silentghoul-spec/Fuzzing-ext4", "file": "lkl/drivers/clk/clk-si544.c", "last_update_at": "2019-12-01T08:07:48+00:00", "question_id": "1e2a3b8f9454db31500fbc415138cbf114558f59_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static long si544_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\tunsigned long *parent_rate)\n{\n\tstruct clk_si544 *data = to_clk_si544(hw);\n\tstruct clk_si544_muldiv settings;\n\tint err;\n\tif (!is_valid_frequency(data, rate))\n\t\treturn -EINVAL;\n\terr = si544_calc_muldiv(&settings, rate);\n\tif (err)\n\t\treturn err;\n\treturn si544_calc_rate(&settings);\n"]], "pred": {"ppl": 2.3176732063293457, "ppl_lower": 2.6252660751342773, "ppl/lowercase_ppl": -1.1482558558487437, "ppl/zlib": 0.003964923368409363, "Min_5.0% Prob": 8.29820271900722, "Min_10.0% Prob": 5.929444360733032, "Min_20.0% Prob": 3.7856647392114002, "Min_30.0% Prob": 2.734672008620368, "Min_40.0% Prob": 2.1012405168265103, "Min_50.0% Prob": 1.6743590303353573, "Min_60.0% Prob": 1.4025530487421778}}
{"hexsha": "aa4710dda7712b9b3bc0b2cfe7ecc7f8f4757f70", "ext": "c", "lang": "C", "content": "static void\nadhoc_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,\n\tint subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)\n{\n\tstruct ieee80211vap *vap = ni->ni_vap;\n\tstruct ieee80211com *ic = ni->ni_ic;\n\tstruct ieee80211_channel *rxchan = ic->ic_curchan;\n\tstruct ieee80211_frame *wh;\n\tuint8_t *frm, *efrm;\n\tuint8_t *ssid, *rates, *xrates;\n#if 0\n\tint ht_state_change = 0;\n#endif\n\n\twh = mtod(m0, struct ieee80211_frame *);\n\tfrm = (uint8_t *)&wh[1];\n\tefrm = mtod(m0, uint8_t *) + m0->m_len;\n\tswitch (subtype) {\n\tcase IEEE80211_FC0_SUBTYPE_PROBE_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_BEACON: {\n\t\tstruct ieee80211_scanparams scan;\n\t\tstruct ieee80211_channel *c;\n\t\t/*\n\t\t * We process beacon/probe response\n\t\t * frames to discover neighbors.\n\t\t */ \n\t\tif (rxs != NULL) {\n\t\t\tc = ieee80211_lookup_channel_rxstatus(vap, rxs);\n\t\t\tif (c != NULL)\n\t\t\t\trxchan = c;\n\t\t}\n\t\tif (ieee80211_parse_beacon(ni, m0, rxchan, &scan) != 0)\n\t\t\treturn;\n\t\t/*\n\t\t * Count frame now that we know it's to be processed.\n\t\t */\n\t\tif (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {\n\t\t\tvap->iv_stats.is_rx_beacon++;\t\t/* XXX remove */\n\t\t\tIEEE80211_NODE_STAT(ni, rx_beacons);\n\t\t} else\n\t\t\tIEEE80211_NODE_STAT(ni, rx_proberesp);\n\t\t/*\n\t\t * If scanning, just pass information to the scan module.\n\t\t */\n\t\tif (ic->ic_flags & IEEE80211_F_SCAN) {\n\t\t\tif (ic->ic_flags_ext & IEEE80211_FEXT_PROBECHAN) {\n\t\t\t\t/*\n\t\t\t\t * Actively scanning a channel marked passive;\n\t\t\t\t * send a probe request now that we know there\n\t\t\t\t * is 802.11 traffic present.\n\t\t\t\t *\n\t\t\t\t * XXX check if the beacon we recv'd gives\n\t\t\t\t * us what we need and suppress the probe req\n\t\t\t\t */\n\t\t\t\tieee80211_probe_curchan(vap, 1);\n\t\t\t\tic->ic_flags_ext &= ~IEEE80211_FEXT_PROBECHAN;\n\t\t\t}\n\t\t\tieee80211_add_scan(vap, rxchan, &scan, wh,\n\t\t\t    subtype, rssi, nf);\n\t\t\treturn;\n\t\t}\n\t\tif (scan.capinfo & IEEE80211_CAPINFO_IBSS) {\n\t\t\tif (!IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {\n\t\t\t\t/*\n\t\t\t\t * Create a new entry in the neighbor table.\n\t\t\t\t */\n\t\t\t\tni = ieee80211_add_neighbor(vap, wh, &scan);\n\t\t\t} else if (ni->ni_capinfo == 0) {\n\t\t\t\t/*\n\t\t\t\t * Update faked node created on transmit.\n\t\t\t\t * Note this also updates the tsf.\n\t\t\t\t */\n\t\t\t\tieee80211_init_neighbor(ni, wh, &scan);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Record tsf for potential resync.\n\t\t\t\t */\n\t\t\t\tmemcpy(ni->ni_tstamp.data, scan.tstamp,\n\t\t\t\t\tsizeof(ni->ni_tstamp));\n\t\t\t}\n\t\t\t/*\n\t\t\t * This isn't enabled yet - otherwise it would\n\t\t\t * update the HT parameters and channel width\n\t\t\t * from any node, which could lead to lots of\n\t\t\t * strange behaviour if the 11n nodes aren't\n\t\t\t * exactly configured to match.\n\t\t\t */\n#if 0\n\t\t\tif (scan.htcap != NULL && scan.htinfo != NULL &&\n\t\t\t    (vap->iv_flags_ht & IEEE80211_FHT_HT)) {\n\t\t\t\tif (ieee80211_ht_updateparams(ni,\n\t\t\t\t    scan.htcap, scan.htinfo))\n\t\t\t\t\tht_state_change = 1;\n\t\t\t}\n#endif\n\t\t\tif (ni != NULL) {\n\t\t\t\tIEEE80211_RSSI_LPF(ni->ni_avgrssi, rssi);\n\t\t\t\tni->ni_noise = nf;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Same here - the channel width change should\n\t\t\t * be applied to the specific peer node, not\n\t\t\t * to the ic.  Ie, the interface configuration\n\t\t\t * should stay in its current channel width;\n\t\t\t * but it should change the rate control and\n\t\t\t * any queued frames for the given node only.\n\t\t\t *\n\t\t\t * Since there's no (current) way to inform\n\t\t\t * the driver that a channel width change has\n\t\t\t * occurred for a single node, just stub this\n\t\t\t * out.\n\t\t\t */\n#if 0\n\t\t\tif (ht_state_change)\n\t\t\t\tieee80211_update_chw(ic);\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IEEE80211_FC0_SUBTYPE_PROBE_REQ:\n\t\tif (vap->iv_state != IEEE80211_S_RUN) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"wrong state %s\",\n\t\t\t    ieee80211_state_name[vap->iv_state]);\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t\treturn;\n\t\t}\n\t\tif (IEEE80211_IS_MULTICAST(wh->i_addr2)) {\n\t\t\t/* frame must be directed */\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"not unicast\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\t/* XXX stat */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * prreq frame format\n\t\t *\t[tlv] ssid\n\t\t *\t[tlv] supported rates\n\t\t *\t[tlv] extended supported rates\n\t\t */\n\t\tssid = rates = xrates = NULL;\n\t\twhile (efrm - frm > 1) {\n\t\t\tIEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);\n\t\t\tswitch (*frm) {\n\t\t\tcase IEEE80211_ELEMID_SSID:\n\t\t\t\tssid = frm;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_ELEMID_RATES:\n\t\t\t\trates = frm;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_ELEMID_XRATES:\n\t\t\t\txrates = frm;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrm += frm[1] + 2;\n\t\t}\n\t\tIEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);\n\t\tif (xrates != NULL)\n\t\t\tIEEE80211_VERIFY_ELEMENT(xrates,\n\t\t\t\tIEEE80211_RATE_MAXSIZE - rates[1], return);\n\t\tIEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);\n\t\tIEEE80211_VERIFY_SSID(vap->iv_bss, ssid, return);\n\t\tif ((vap->iv_flags & IEEE80211_F_HIDESSID) && ssid[1] == 0) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL,\n\t\t\t    \"%s\", \"no ssid with ssid suppression enabled\");\n\t\t\tvap->iv_stats.is_rx_ssidmismatch++; /*XXX*/\n\t\t\treturn;\n\t\t}\n\n\t\t/* XXX find a better class or define it's own */\n\t\tIEEE80211_NOTE_MAC(vap, IEEE80211_MSG_INPUT, wh->i_addr2,\n\t\t    \"%s\", \"recv probe req\");\n\t\t/*\n\t\t * Some legacy 11b clients cannot hack a complete\n\t\t * probe response frame.  When the request includes\n\t\t * only a bare-bones rate set, communicate this to\n\t\t * the transmit side.\n\t\t */\n\t\tieee80211_send_proberesp(vap, wh->i_addr2,\n\t\t    is11bclient(rates, xrates) ? IEEE80211_SEND_LEGACY_11B : 0);\n\t\tbreak;\n\n\tcase IEEE80211_FC0_SUBTYPE_ACTION:\n\tcase IEEE80211_FC0_SUBTYPE_ACTION_NOACK:\n\t\tif ((ni == vap->iv_bss) &&\n\t\t    !IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"unknown node\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else if (!IEEE80211_ADDR_EQ(vap->iv_myaddr, wh->i_addr1) &&\n\t\t    !IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"not for us\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else if (vap->iv_state != IEEE80211_S_RUN) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"wrong state %s\",\n\t\t\t    ieee80211_state_name[vap->iv_state]);\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else {\n\t\t\tif (ieee80211_parse_action(ni, m0) == 0)\n\t\t\t\t(void)ic->ic_recv_action(ni, wh, frm, efrm);\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_FC0_SUBTYPE_ASSOC_REQ:\n\tcase IEEE80211_FC0_SUBTYPE_ASSOC_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_REASSOC_REQ:\n\tcase IEEE80211_FC0_SUBTYPE_REASSOC_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_TIMING_ADV:\n\tcase IEEE80211_FC0_SUBTYPE_ATIM:\n\tcase IEEE80211_FC0_SUBTYPE_DISASSOC:\n\tcase IEEE80211_FC0_SUBTYPE_AUTH:\n\tcase IEEE80211_FC0_SUBTYPE_DEAUTH:\n\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t    wh, NULL, \"%s\", \"not handled\");\n\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\tbreak;\n\n\tdefault:\n\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,\n\t\t    wh, \"mgt\", \"subtype 0x%x not handled\", subtype);\n\t\tvap->iv_stats.is_rx_badsubtype++;\n\t\tbreak;\n\t}\n}", "item_id": 4, "repo": "gl00my/haiku", "file": "src/libs/compat/freebsd11_wlan/net80211/ieee80211_adhoc.c", "last_update_at": "2019-06-25T11:34:47+00:00", "question_id": "aa4710dda7712b9b3bc0b2cfe7ecc7f8f4757f70_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nadhoc_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,\n\tint subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)\n{\n\tstruct ieee80211vap *vap = ni->ni_vap;\n\tstruct ieee80211com *ic = ni->ni_ic;\n\tstruct ieee80211_channel *rxchan = ic->ic_curchan;\n\tstruct ieee80211_frame *wh;\n\tuint8_t *frm, *efrm;\n\tuint8_t *ssid, *rates, *xrates;\n#if 0\n\tint ht_state_change = 0;\n#endif\n\twh = mtod(m0, struct ieee80211_frame *);\n\tfrm = (uint8_t *)&wh[1];\n\tefrm = mtod(m0, uint8_t *) + m0->m_len;\n\tswitch (subtype) {\n\tcase IEEE80211_FC0_SUBTYPE_PROBE_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_BEACON: {\n\t\tstruct ieee80211_scanparams scan;\n\t\tstruct ieee80211_channel *c;\n\t\t/*\n\t\t * We process beacon/probe response\n\t\t * frames to discover neighbors.\n\t\t */ \n\t\tif (rxs != NULL) {\n\t\t\tc = ieee80211_lookup_channel_rxstatus(vap, rxs);\n\t\t\tif (c != NULL)\n\t\t\t\trxchan = c;\n\t\t}\n\t\tif (ieee80211_parse_beacon(ni, m0, rxchan, &scan) != 0)\n\t\t\treturn;\n\t\t/*\n\t\t * Count frame now that we know it's to be processed.\n\t\t */\n\t\tif (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {\n\t\t\tvap->iv_stats.is_rx_beacon++;\t\t/* XXX remove */\n\t\t\tIEEE80211_NODE_STAT(ni, rx_beacons);\n\t\t} else\n\t\t\tIEEE80211_NODE_STAT(ni, rx_proberesp);\n\t\t/*\n\t\t * If scanning, just pass information to the scan module.\n\t\t */\n\t\tif (ic->ic_flags & IEEE80211_F_SCAN) {\n\t\t\tif (ic->ic_flags_ext & IEEE80211_FEXT_PROBECHAN) {\n\t\t\t\t/*\n\t\t\t\t * Actively scanning a channel marked passive;\n\t\t\t\t * send a probe request now that we know there\n\t\t\t\t * is 802.11 traffic present.\n\t\t\t\t *\n\t\t\t\t * XXX check if the beacon we recv'd gives\n\t\t\t\t * us what we need and suppress the probe req\n\t\t\t\t */\n\t\t\t\tieee80211_probe_curchan(vap, 1);\n\t\t\t\tic->ic_flags_ext &= ~IEEE80211_FEXT_PROBECHAN;\n\t\t\t}\n\t\t\tieee80211_add_scan(vap, rxchan, &scan, wh,\n\t\t\t    subtype, rssi, nf);\n\t\t\treturn;\n\t\t}\n\t\tif (scan.capinfo & IEEE80211_CAPINFO_IBSS) {\n\t\t\tif (!IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {\n\t\t\t\t/*\n\t\t\t\t * Create a new entry in the neighbor table.\n\t\t\t\t */\n\t\t\t\tni = ieee80211_add_neighbor(vap, wh, &scan);\n\t\t\t} else if (ni->ni_capinfo == 0) {\n\t\t\t\t/*\n\t\t\t\t * Update faked node created on transmit.\n\t\t\t\t * Note this also updates the tsf.\n\t\t\t\t */\n\t\t\t\tieee80211_init_neighbor(ni, wh, &scan);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Record tsf for potential resync.\n\t\t\t\t */\n\t\t\t\tmemcpy(ni->ni_tstamp.data, scan.tstamp,\n\t\t\t\t\tsizeof(ni->ni_tstamp));\n\t\t\t}\n\t\t\t/*\n\t\t\t * This isn't enabled yet - otherwise it would\n\t\t\t * update the HT parameters and channel width\n\t\t\t * from any node, which could lead to lots of\n\t\t\t * strange behaviour if the 11n nodes aren't\n\t\t\t * exactly configured to match.\n\t\t\t */\n#if 0\n\t\t\tif (scan.htcap != NULL && scan.htinfo != NULL &&\n\t\t\t    (vap->iv_flags_ht & IEEE80211_FHT_HT)) {\n\t\t\t\tif (ieee80211_ht_updateparams(ni,\n\t\t\t\t    scan.htcap, scan.htinfo))\n\t\t\t\t\tht_state_change = 1;\n\t\t\t}\n#endif\n\t\t\tif (ni != NULL) {\n\t\t\t\tIEEE80211_RSSI_LPF(ni->ni_avgrssi, rssi);\n\t\t\t\tni->ni_noise = nf;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Same here - the channel width change should\n\t\t\t * be applied to the specific peer node, not\n\t\t\t * to the ic.  Ie, the interface configuration\n\t\t\t * should stay in its current channel width;\n\t\t\t * but it should change the rate control and\n\t\t\t * any queued frames for the given node only.\n\t\t\t *\n\t\t\t * Since there's no (current) way to inform\n\t\t\t * the driver that a channel width change has\n\t\t\t * occurred for a single node, just stub this\n\t\t\t * out.\n\t\t\t */\n#if 0\n\t\t\tif (ht_state_change)\n\t\t\t\tieee80211_update_chw(ic);\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\tcase IEEE80211_FC0_SUBTYPE_PROBE_REQ:\n\t\tif (vap->iv_state != IEEE80211_S_RUN) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"wrong state %s\",\n\t\t\t    ieee80211_state_name[vap->iv_state]);\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t\treturn;\n\t\t}\n\t\tif (IEEE80211_IS_MULTICAST(wh->i_addr2)) {\n\t\t\t/* frame must be directed */\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"not unicast\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\t/* XXX stat */\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * prreq frame format\n\t\t *\t[tlv] ssid\n\t\t *\t[tlv] supported rates\n\t\t *\t[tlv] extended supported rates\n\t\t */\n\t\tssid = rates = xrates = NULL;\n\t\twhile (efrm - frm > 1) {\n\t\t\tIEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);\n\t\t\tswitch (*frm) {\n\t\t\tcase IEEE80211_ELEMID_SSID:\n\t\t\t\tssid = frm;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_ELEMID_RATES:\n\t\t\t\trates = frm;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_ELEMID_XRATES:\n\t\t\t\txrates = frm;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrm += frm[1] + 2;\n\t\t}\n\t\tIEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);\n\t\tif (xrates != NULL)\n\t\t\tIEEE80211_VERIFY_ELEMENT(xrates,\n\t\t\t\tIEEE80211_RATE_MAXSIZE - rates[1], return);\n\t\tIEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);\n\t\tIEEE80211_VERIFY_SSID(vap->iv_bss, ssid, return);\n\t\tif ((vap->iv_flags & IEEE80211_F_HIDESSID) && ssid[1] == 0) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL,\n\t\t\t    \"%s\", \"no ssid with ssid suppression enabled\");\n\t\t\tvap->iv_stats.is_rx_ssidmismatch++; /*XXX*/\n\t\t\treturn;\n\t\t}\n\t\t/* XXX find a better class or define it's own */\n\t\tIEEE80211_NOTE_MAC(vap, IEEE80211_MSG_INPUT, wh->i_addr2,\n\t\t    \"%s\", \"recv probe req\");\n\t\t/*\n\t\t * Some legacy 11b clients cannot hack a complete\n\t\t * probe response frame.  When the request includes\n\t\t * only a bare-bones rate set, communicate this to\n\t\t * the transmit side.\n\t\t */\n\t\tieee80211_send_proberesp(vap, wh->i_addr2,\n\t\t    is11bclient(rates, xrates) ? IEEE80211_SEND_LEGACY_11B : 0);\n\t\tbreak;\n\tcase IEEE80211_FC0_SUBTYPE_ACTION:\n\tcase IEEE80211_FC0_SUBTYPE_ACTION_NOACK:\n\t\tif ((ni == vap->iv_bss) &&\n\t\t    !IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"unknown node\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else if (!IEEE80211_ADDR_EQ(vap->iv_myaddr, wh->i_addr1) &&\n\t\t    !IEEE80211_IS_MULTICAST(wh->i_addr1)) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"%s\", \"not for us\");\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else if (vap->iv_state != IEEE80211_S_RUN) {\n\t\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t\t    wh, NULL, \"wrong state %s\",\n\t\t\t    ieee80211_state_name[vap->iv_state]);\n\t\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\t} else {\n\t\t\tif (ieee80211_parse_action(ni, m0) == 0)\n\t\t\t\t(void)ic->ic_recv_action(ni, wh, frm, efrm);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_FC0_SUBTYPE_ASSOC_REQ:\n\tcase IEEE80211_FC0_SUBTYPE_ASSOC_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_REASSOC_REQ:\n\tcase IEEE80211_FC0_SUBTYPE_REASSOC_RESP:\n\tcase IEEE80211_FC0_SUBTYPE_TIMING_ADV:\n\tcase IEEE80211_FC0_SUBTYPE_ATIM:\n\tcase IEEE80211_FC0_SUBTYPE_DISASSOC:\n\tcase IEEE80211_FC0_SUBTYPE_AUTH:\n\tcase IEEE80211_FC0_SUBTYPE_DEAUTH:\n\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,\n\t\t    wh, NULL, \"%s\", \"not handled\");\n\t\tvap->iv_stats.is_rx_mgtdiscard++;\n\t\tbreak;\n\tdefault:\n\t\tIEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,\n\t\t    wh, \"mgt\", \"subtype 0x%x not handled\", subtype);\n\t\tvap->iv_stats.is_rx_badsubtype++;\n\t\tbreak;\n\t}\n"]], "pred": {"ppl": 1.672145128250122, "ppl_lower": 1.8496626615524292, "ppl/lowercase_ppl": -1.1962546831922647, "ppl/zlib": 0.0002161931497427816, "Min_5.0% Prob": 5.265197945576088, "Min_10.0% Prob": 3.823842434322133, "Min_20.0% Prob": 2.3977078130724383, "Min_30.0% Prob": 1.6885768030009238, "Min_40.0% Prob": 1.2819379471096695, "Min_50.0% Prob": 1.0286568424476714, "Min_60.0% Prob": 0.8578854962267274}}
{"hexsha": "8c1c6cce98951e00aff375e53d0d92186c126440", "ext": "c", "lang": "C", "content": "void*\ngetBoundsnoio_i(MetaPoolTy* MP, unsigned char* src, void *dest) {\n  void* S;\n  unsigned len;\n  int fs;\n  __sva_rt_lock_t lock;\n\n  if (!pchk_ready || !MP) return &found;\n  ++stat_boundscheck;\n\n  /* Try fail cache first */\n  __sva_rt_lock(&lock);\n#if 0\n  int i = isInCache(MP, src);\n  if (i) {\n    mtfCache(MP, i);\n    __sva_rt_unlock(&lock);\n    return &found;\n  }\n#endif\n\n#if 0\n  {\n    unsigned int index  = MP->cindex;\n    unsigned int cindex = MP->cindex;\n    do\n    {\n      if ((MP->start[index] <= src) &&\n          (MP->start[index]+MP->length[index] >= src))\n        return MP->cache[index];\n      index = (index + 1) & 3;\n    } while (index != cindex);\n  }\n#endif\n\n  /*\n   * Look in the object splay for the given pointer.\n   */\n  S = src;\n  len = 0;\n#if 0\n  if (do_profile) tsc1 = llva_save_tsc();\n  int fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);\n  if (do_profile) tsc2 = llva_save_tsc();\n  if (do_profile) pchk_profile(MP, __builtin_return_address(0), (long)(tsc2 - tsc1));\n#else\n  fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);\n#endif\n\n  if (fs) {\n#if 1\n    unsigned int index = MP->cindex;\n    MP->start[index] = S;\n    MP->length[index] = len;\n    MP->cache[index] = MP->Objs;\n    MP->cindex = (index+1) & 3u;\n#endif\n    __sva_rt_unlock(&lock);\n    return MP->Objs;\n  }\n\n  /*\n   * If the source pointer is within the first page of memory, return the zero\n   * page.\n   */\n  if (src < (unsigned char*)4096)\n    return &zero_page;\n\n  return &found;\n}", "item_id": 39, "repo": "spurious/safecode-mirror", "file": "old_runtime/SVA/PoolCheck.c", "last_update_at": "2019-11-28T01:34:01+00:00", "question_id": "8c1c6cce98951e00aff375e53d0d92186c126440_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void*\ngetBoundsnoio_i(MetaPoolTy* MP, unsigned char* src, void *dest) {\n  void* S;\n  unsigned len;\n  int fs;\n  __sva_rt_lock_t lock;\n  if (!pchk_ready || !MP) return &found;\n  ++stat_boundscheck;\n  /* Try fail cache first */\n  __sva_rt_lock(&lock);\n#if 0\n  int i = isInCache(MP, src);\n  if (i) {\n    mtfCache(MP, i);\n    __sva_rt_unlock(&lock);\n    return &found;\n  }\n#endif\n#if 0\n  {\n    unsigned int index  = MP->cindex;\n    unsigned int cindex = MP->cindex;\n    do\n    {\n      if ((MP->start[index] <= src) &&\n          (MP->start[index]+MP->length[index] >= src))\n        return MP->cache[index];\n      index = (index + 1) & 3;\n    } while (index != cindex);\n  }\n#endif\n  /*\n   * Look in the object splay for the given pointer.\n   */\n  S = src;\n  len = 0;\n#if 0\n  if (do_profile) tsc1 = llva_save_tsc();\n  int fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);\n  if (do_profile) tsc2 = llva_save_tsc();\n  if (do_profile) pchk_profile(MP, __builtin_return_address(0), (long)(tsc2 - tsc1));\n#else\n  fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);\n#endif\n  if (fs) {\n#if 1\n    unsigned int index = MP->cindex;\n    MP->start[index] = S;\n    MP->length[index] = len;\n    MP->cache[index] = MP->Objs;\n    MP->cindex = (index+1) & 3u;\n#endif\n    __sva_rt_unlock(&lock);\n    return MP->Objs;\n  }\n  /*\n   * If the source pointer is within the first page of memory, return the zero\n   * page.\n   */\n  if (src < (unsigned char*)4096)\n    return &zero_page;\n  return &found;\n"]], "pred": {"ppl": 3.576047420501709, "ppl_lower": 3.5429909229278564, "ppl/lowercase_ppl": -0.9927119521921144, "ppl/zlib": 0.0020035504999843423, "Min_5.0% Prob": 8.389702860514323, "Min_10.0% Prob": 6.841024992895908, "Min_20.0% Prob": 5.003040255569831, "Min_30.0% Prob": 3.8437047574831094, "Min_40.0% Prob": 3.0512912521759668, "Min_50.0% Prob": 2.5052662169101176, "Min_60.0% Prob": 2.1133664110650217}}
{"hexsha": "1d6a3ab85f9e9d254b4960ce51d5a249997afab2", "ext": "h", "lang": "C", "content": "class CSO2ErrorLog\n{\npublic:\n\tDLL_CLASS_IMPORT CSO2ErrorLog();\n\tDLL_CLASS_IMPORT ~CSO2ErrorLog();\n\n\tDLL_CLASS_IMPORT void AddErrorID( unsigned int iErrorID );\n\tDLL_CLASS_IMPORT unsigned int GetErrorID();\n\n\tDLL_CLASS_IMPORT void AddMsg( const char* szFormat, ... );\n\tDLL_CLASS_IMPORT const char* GetMsg( unsigned int iMsgIndex );\n\tDLL_CLASS_IMPORT const wchar_t* GetWMsg( unsigned int iMsgIndex );\n\n\tDLL_CLASS_IMPORT CSO2ErrorLog& operator=( const CSO2ErrorLog& other );\n\nprivate:\n\tunsigned int m_iErrorID;\n\tunsigned int m_iCurrentMsgIndex;\n\tchar* m_szMessages[CSO2ERRORLOG_MAX_INDEX];\t \t\n}", "item_id": 1, "repo": "CNLouisLiu/cso2-launcher", "file": "sdk/public/tier0/cso2/log.h", "last_update_at": "2019-12-01T20:21:36+00:00", "question_id": "1d6a3ab85f9e9d254b4960ce51d5a249997afab2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CSO2ErrorLog\n{\npublic:\n\tDLL_CLASS_IMPORT CSO2ErrorLog();\n\tDLL_CLASS_IMPORT ~CSO2ErrorLog();\n\tDLL_CLASS_IMPORT void AddErrorID( unsigned int iErrorID );\n\tDLL_CLASS_IMPORT unsigned int GetErrorID();\n\tDLL_CLASS_IMPORT void AddMsg( const char* szFormat, ... );\n\tDLL_CLASS_IMPORT const char* GetMsg( unsigned int iMsgIndex );\n\tDLL_CLASS_IMPORT const wchar_t* GetWMsg( unsigned int iMsgIndex );\n\tDLL_CLASS_IMPORT CSO2ErrorLog& operator=( const CSO2ErrorLog& other );\nprivate:\n\tunsigned int m_iErrorID;\n\tunsigned int m_iCurrentMsgIndex;\n\tchar* m_szMessages[CSO2ERRORLOG_MAX_INDEX];\t \t\n"]], "pred": {"ppl": 2.3132686614990234, "ppl_lower": 3.0852742195129395, "ppl/lowercase_ppl": -1.3433793038181003, "ppl/zlib": 0.0033148677048833288, "Min_5.0% Prob": 6.901094436645508, "Min_10.0% Prob": 5.480803986390431, "Min_20.0% Prob": 3.7332288064062595, "Min_30.0% Prob": 2.6909539906515016, "Min_40.0% Prob": 2.0764579931274056, "Min_50.0% Prob": 1.6775666371298332, "Min_60.0% Prob": 1.4020924490178004}}
{"hexsha": "6becac4e83c1579765b25ffcd49243daa78f87bb", "ext": "c", "lang": "C", "content": "int hwdb_delete(sqldelete *delete) {\n    debugf(\"HWDB: Executing DELETE:\\n\");\n    /* Check table exists */\n    if (!itab_table_exists(itab, delete->tablename)) {\n        errorf(\"HWDB: %s no such table\\n\", delete->tablename);\n        return 0;\n    }\n    if (itab_delete_rows(itab, delete)) {\n        return 1;\n    }\n    return 0;\n}", "item_id": 5, "repo": "fergul/Cache", "file": "src/hwdb.c", "last_update_at": "2019-06-26T23:54:44+00:00", "question_id": "6becac4e83c1579765b25ffcd49243daa78f87bb_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int hwdb_delete(sqldelete *delete) {\n    debugf(\"HWDB: Executing DELETE:\\n\");\n    /* Check table exists */\n    if (!itab_table_exists(itab, delete->tablename)) {\n        errorf(\"HWDB: %s no such table\\n\", delete->tablename);\n        return 0;\n    }\n    if (itab_delete_rows(itab, delete)) {\n        return 1;\n    }\n    return 0;\n"]], "pred": {"ppl": 3.9639816284179688, "ppl_lower": 4.0232062339782715, "ppl/lowercase_ppl": -1.0107679684118482, "ppl/zlib": 0.007210727653665084, "Min_5.0% Prob": 8.838493824005127, "Min_10.0% Prob": 7.352389216423035, "Min_20.0% Prob": 5.54434068997701, "Min_30.0% Prob": 4.272415482335621, "Min_40.0% Prob": 3.3435909839308993, "Min_50.0% Prob": 2.744588720016792, "Min_60.0% Prob": 2.3099593291543936}}
{"hexsha": "d2365ac19071830b200c77b27a3827b375ded5db", "ext": "c", "lang": "C", "content": "static void\nsighandler(int sig) {\n\tconst char* signame = \"UNKNOWN\";\n\tswitch (sig) {\n\t\tcase SIGKILL:\n\t\t\tsigname = \"SIGKILL\";\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tsigname = \"SIGTERM\";\n\t\t\tbreak;\n\t\tcase SIGQUIT:\n\t\t\tsigname = \"SIGQUIT\";\n\t\t\tbreak;\n\t\tcase SIGINT:\n\t\t\tsigname = \"SIGINT\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tlog_infof(0, STRING_CONST(\"Caught signal: %s (%d)\"), signame, sig);\n\tsystem_post_event(FOUNDATIONEVENT_TERMINATE);\n}", "item_id": 2, "repo": "rampantpixels/foundation_lib", "file": "foundation/main.c", "last_update_at": "2019-11-08T15:51:12+00:00", "question_id": "d2365ac19071830b200c77b27a3827b375ded5db_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsighandler(int sig) {\n\tconst char* signame = \"UNKNOWN\";\n\tswitch (sig) {\n\t\tcase SIGKILL:\n\t\t\tsigname = \"SIGKILL\";\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tsigname = \"SIGTERM\";\n\t\t\tbreak;\n\t\tcase SIGQUIT:\n\t\t\tsigname = \"SIGQUIT\";\n\t\t\tbreak;\n\t\tcase SIGINT:\n\t\t\tsigname = \"SIGINT\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tlog_infof(0, STRING_CONST(\"Caught signal: %s (%d)\"), signame, sig);\n\tsystem_post_event(FOUNDATIONEVENT_TERMINATE);\n"]], "pred": {"ppl": 2.116814374923706, "ppl_lower": 2.4062247276306152, "ppl/lowercase_ppl": -1.170882261928387, "ppl/zlib": 0.003111669316308145, "Min_5.0% Prob": 7.714302206039429, "Min_10.0% Prob": 5.527234053611755, "Min_20.0% Prob": 3.5671065813157616, "Min_30.0% Prob": 2.4769577895922046, "Min_40.0% Prob": 1.8718207976275898, "Min_50.0% Prob": 1.498392854270955, "Min_60.0% Prob": 1.2574166292606312}}
{"hexsha": "1e68a1ebe33f372c5ba0ba38080fb195bb244e1a", "ext": "c", "lang": "C", "content": "static void\nfree_vbdev(struct spdk_bdev *bdev)\n{\n\tCU_ASSERT(!TAILQ_EMPTY(&bdev->base_bdevs));\n\tspdk_bdev_unregister(bdev, NULL, NULL);\n\tfree(bdev);\n}", "item_id": 2, "repo": "chpchp/SPDK", "file": "test/unit/lib/bdev/bdev.c/bdev_ut.c", "last_update_at": "2019-04-24T08:44:47+00:00", "question_id": "1e68a1ebe33f372c5ba0ba38080fb195bb244e1a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nfree_vbdev(struct spdk_bdev *bdev)\n{\n\tCU_ASSERT(!TAILQ_EMPTY(&bdev->base_bdevs));\n\tspdk_bdev_unregister(bdev, NULL, NULL);\n\tfree(bdev);\n"]], "pred": {"ppl": 2.4792447090148926, "ppl_lower": 4.285058498382568, "ppl/lowercase_ppl": -1.602651969591483, "ppl/zlib": 0.007263631687797504, "Min_5.0% Prob": 8.949431737263998, "Min_10.0% Prob": 6.439301933561053, "Min_20.0% Prob": 4.139191746711731, "Min_30.0% Prob": 2.9790928619248525, "Min_40.0% Prob": 2.312990976231439, "Min_50.0% Prob": 1.8142275996764914, "Min_60.0% Prob": 1.5199678548351796}}
{"hexsha": "72562686cc1134ca6fd4dc5037c01d3cb1c86533", "ext": "c", "lang": "C", "content": "int\nisic_attach_itkix1(device_t dev)\n{\n\tsize_t unit = device_get_unit(dev);\t/* get unit */\n\tstruct l1_softc *sc = &l1_sc[unit];\n\tbus_space_tag_t    t = rman_get_bustag(sc->sc_resources.io_base[0]); \n\tbus_space_handle_t h = rman_get_bushandle(sc->sc_resources.io_base[0]);\n\n\t/* setup access routines */\n\tsc->clearirq = NULL;\n\tsc->readreg = itkix1_read_reg;\n\tsc->writereg = itkix1_write_reg;\n\tsc->readfifo = itkix1_read_fifo;\n\tsc->writefifo = itkix1_write_fifo;\n\n\t/* setup card type */\t\n\tsc->sc_cardtyp = CARD_TYPEP_ITKIX1;\n\n\t/* setup IOM bus type */\n\tsc->sc_bustyp = BUS_TYPE_IOM2;\n\n\tsc->sc_ipac = 0;\n\tsc->sc_bfifolen = HSCX_FIFO_LEN;\n\n\tbus_space_write_1(t, h, ITK_CONFIG, 1);\n\tDELAY(SEC_DELAY / 10);\n\tbus_space_write_1(t, h, ITK_CONFIG, 0);\n\tDELAY(SEC_DELAY / 10);\n\n\treturn 0;\n}", "item_id": 5, "repo": "masami256/dfly-3.0.2-bhyve", "file": "sys/net/i4b/layer1/isic/i4b_itk_ix1.c", "last_update_at": "2019-11-23T09:35:10+00:00", "question_id": "72562686cc1134ca6fd4dc5037c01d3cb1c86533_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nisic_attach_itkix1(device_t dev)\n{\n\tsize_t unit = device_get_unit(dev);\t/* get unit */\n\tstruct l1_softc *sc = &l1_sc[unit];\n\tbus_space_tag_t    t = rman_get_bustag(sc->sc_resources.io_base[0]); \n\tbus_space_handle_t h = rman_get_bushandle(sc->sc_resources.io_base[0]);\n\t/* setup access routines */\n\tsc->clearirq = NULL;\n\tsc->readreg = itkix1_read_reg;\n\tsc->writereg = itkix1_write_reg;\n\tsc->readfifo = itkix1_read_fifo;\n\tsc->writefifo = itkix1_write_fifo;\n\t/* setup card type */\t\n\tsc->sc_cardtyp = CARD_TYPEP_ITKIX1;\n\t/* setup IOM bus type */\n\tsc->sc_bustyp = BUS_TYPE_IOM2;\n\tsc->sc_ipac = 0;\n\tsc->sc_bfifolen = HSCX_FIFO_LEN;\n\tbus_space_write_1(t, h, ITK_CONFIG, 1);\n\tDELAY(SEC_DELAY / 10);\n\tbus_space_write_1(t, h, ITK_CONFIG, 0);\n\tDELAY(SEC_DELAY / 10);\n\treturn 0;\n"]], "pred": {"ppl": 1.805680751800537, "ppl_lower": 2.2865569591522217, "ppl/lowercase_ppl": -1.3995506107755071, "ppl/zlib": 0.0015036581895532238, "Min_5.0% Prob": 6.572995060368588, "Min_10.0% Prob": 4.535302425685682, "Min_20.0% Prob": 2.7294013747921237, "Min_30.0% Prob": 1.9164591313436115, "Min_40.0% Prob": 1.4717441752746507, "Min_50.0% Prob": 1.1818075863055768, "Min_60.0% Prob": 0.9850755599768961}}
{"hexsha": "a2aaca986c469fa11034717b3b094e8a6d7fc97a", "ext": "h", "lang": "C", "content": "namespace content {\n\n// Update |event|'s windowsKeyCode and keyIdentifer properties using the\n// provided |windows_key_code|.\nCONTENT_EXPORT void UpdateWindowsKeyCodeAndKeyIdentifier(\n    blink::WebKeyboardEvent* event,\n    ui::KeyboardCode windows_key_code);\n\nCONTENT_EXPORT blink::WebTouchEvent CreateWebTouchEventFromMotionEvent(\n    const ui::MotionEvent& event, bool may_cause_scrolling);\n\nCONTENT_EXPORT blink::WebGestureEvent CreateWebGestureEvent(\n    const ui::GestureEventDetails& details,\n    base::TimeDelta timestamp,\n    const gfx::PointF& location,\n    const gfx::PointF& raw_location,\n    int flags);\n\n// Convenience wrapper for |CreateWebGestureEvent| using the supplied |data|.\nCONTENT_EXPORT blink::WebGestureEvent\nCreateWebGestureEventFromGestureEventData(const ui::GestureEventData& data);\n\nint EventFlagsToWebEventModifiers(int flags);\n\nint WebEventModifiersToEventFlags(int modifiers);\n\n}", "item_id": 1, "repo": "kjthegod/chromium", "file": "content/browser/renderer_host/input/web_input_event_util.h", "last_update_at": "2019-11-28T10:46:52+00:00", "question_id": "a2aaca986c469fa11034717b3b094e8a6d7fc97a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace content {\n// Update |event|'s windowsKeyCode and keyIdentifer properties using the\n// provided |windows_key_code|.\nCONTENT_EXPORT void UpdateWindowsKeyCodeAndKeyIdentifier(\n    blink::WebKeyboardEvent* event,\n    ui::KeyboardCode windows_key_code);\nCONTENT_EXPORT blink::WebTouchEvent CreateWebTouchEventFromMotionEvent(\n    const ui::MotionEvent& event, bool may_cause_scrolling);\nCONTENT_EXPORT blink::WebGestureEvent CreateWebGestureEvent(\n    const ui::GestureEventDetails& details,\n    base::TimeDelta timestamp,\n    const gfx::PointF& location,\n    const gfx::PointF& raw_location,\n    int flags);\n// Convenience wrapper for |CreateWebGestureEvent| using the supplied |data|.\nCONTENT_EXPORT blink::WebGestureEvent\nCreateWebGestureEventFromGestureEventData(const ui::GestureEventData& data);\nint EventFlagsToWebEventModifiers(int flags);\nint WebEventModifiersToEventFlags(int modifiers);\n"]], "pred": {"ppl": 2.621572971343994, "ppl_lower": 4.210756301879883, "ppl/lowercase_ppl": -1.491679083888338, "ppl/zlib": 0.0023679963350480963, "Min_5.0% Prob": 8.593623418074388, "Min_10.0% Prob": 6.268358643238361, "Min_20.0% Prob": 4.1921612721569135, "Min_30.0% Prob": 3.114440556191191, "Min_40.0% Prob": 2.386836288250842, "Min_50.0% Prob": 1.9308097858518136, "Min_60.0% Prob": 1.6055052853804432}}
{"hexsha": "e3dd8a6fbb9e36cc7fd6d7fc7891b8f522ea1ab6", "ext": "c", "lang": "C", "content": "void printUndefinedMotionHeader(OutputStream* outputStream, PidMotionDefinition* pidMotionDefinition) {\r\n    printMotionInstructionStateHeader(outputStream, pidMotionDefinition);\r\n    appendStringHeader(outputStream, \"Idx\", PID_DEBUG_INDEX_COLUMN_LENGTH);\r\n    appendStringHeader(outputStream, \"Undefined\", PID_DEBUG_INSTRUCTION_TYPE_COLUMN_LENGTH);\r\n    appendEndOfTableColumn(outputStream, PID_DEBUG_LAST_COLUMN_LENGTH);\r\n    appendTableHeaderSeparatorLine(outputStream);\r\n}", "item_id": 4, "repo": "f4deb/cen-electronic", "file": "motion/pid/pidDebug.c", "last_update_at": "2019-07-24T08:30:33+00:00", "question_id": "e3dd8a6fbb9e36cc7fd6d7fc7891b8f522ea1ab6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void printUndefinedMotionHeader(OutputStream* outputStream, PidMotionDefinition* pidMotionDefinition) {\r\n    printMotionInstructionStateHeader(outputStream, pidMotionDefinition);\r\n    appendStringHeader(outputStream, \"Idx\", PID_DEBUG_INDEX_COLUMN_LENGTH);\r\n    appendStringHeader(outputStream, \"Undefined\", PID_DEBUG_INSTRUCTION_TYPE_COLUMN_LENGTH);\r\n    appendEndOfTableColumn(outputStream, PID_DEBUG_LAST_COLUMN_LENGTH);\r\n    appendTableHeaderSeparatorLine(outputStream);\r\n"]], "pred": {"ppl": 3.789466619491577, "ppl_lower": 8.529928207397461, "ppl/lowercase_ppl": -1.6090228764836074, "ppl/zlib": 0.0059741043746504175, "Min_5.0% Prob": 9.18561347325643, "Min_10.0% Prob": 7.560069781083327, "Min_20.0% Prob": 5.577160305447048, "Min_30.0% Prob": 4.244213628768921, "Min_40.0% Prob": 3.2845474431912103, "Min_50.0% Prob": 2.646657606038977, "Min_60.0% Prob": 2.2329773055734456}}
{"hexsha": "c5e5dc2b8f8524ed935f369c5a8c3d108a7af890", "ext": "h", "lang": "C", "content": "class SideAirbags: public Equipment {\npublic:\n    SideAirbags(std::shared_ptr<IAutomobile> pIAuto): Equipment(pIAuto) { }\n\n    int giveCosts() override;\n    void showDetails() override;\n}", "item_id": 0, "repo": "hexu1985/design_pattern", "file": "decorator/src/side_airbags.h", "last_update_at": "2019-12-03T08:44:11+00:00", "question_id": "c5e5dc2b8f8524ed935f369c5a8c3d108a7af890_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SideAirbags: public Equipment {\npublic:\n    SideAirbags(std::shared_ptr<IAutomobile> pIAuto): Equipment(pIAuto) { }\n    int giveCosts() override;\n    void showDetails() override;\n"]], "pred": {"ppl": 6.676992893218994, "ppl_lower": 13.341569900512695, "ppl/lowercase_ppl": -1.3645803787968684, "ppl/zlib": 0.013758461742810028, "Min_5.0% Prob": 8.340147018432617, "Min_10.0% Prob": 7.909278869628906, "Min_20.0% Prob": 6.281627765068641, "Min_30.0% Prob": 5.2020365476608275, "Min_40.0% Prob": 4.4560657647939825, "Min_50.0% Prob": 3.740856914809256, "Min_60.0% Prob": 3.161711714416742}}
{"hexsha": "e154941c52f2cfa148d2ab9e0b4c60bcb4166df3", "ext": "h", "lang": "C", "content": "interface TFNPagingScrollView : UIScrollView <UIGestureRecognizerDelegate>\n{\n    _Bool _panBeyondLeftExtentShouldFailRecognizer;\n    _Bool _panBeyondRightExtentShouldFailRecognizer;\n    TFNPagingViewController *_pagingViewController;\n}", "item_id": 0, "repo": "ichitaso/TwitterListEnabler", "file": "Twitter-Dumped/7.51.5/t1/TFNPagingScrollView.h", "last_update_at": "2019-10-15T09:26:49+00:00", "question_id": "e154941c52f2cfa148d2ab9e0b4c60bcb4166df3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface TFNPagingScrollView : UIScrollView <UIGestureRecognizerDelegate>\n{\n    _Bool _panBeyondLeftExtentShouldFailRecognizer;\n    _Bool _panBeyondRightExtentShouldFailRecognizer;\n    TFNPagingViewController *_pagingViewController;\n"]], "pred": {"ppl": 5.938686847686768, "ppl_lower": 8.153785705566406, "ppl/lowercase_ppl": -1.1779379241399275, "ppl/zlib": 0.01228612441049729, "Min_5.0% Prob": 9.715065956115723, "Min_10.0% Prob": 8.35507615407308, "Min_20.0% Prob": 6.698733916649451, "Min_30.0% Prob": 5.557241463661194, "Min_40.0% Prob": 4.479405091359065, "Min_50.0% Prob": 3.591635302612276, "Min_60.0% Prob": 2.9785492944531144}}
{"hexsha": "8c510c347e0dd02d71dc20bfb727fa4ea676406c", "ext": "c", "lang": "C", "content": "int\nset_snaplen(int snap)\n{\n\tif (priv_set_snaplen(snap))\n\t\treturn (1);\n\n\tif (cur_snaplen > snap)\n\t\tpurge_buffer();\n\n\tcur_snaplen = snap;\n\n\treturn (0);\n}", "item_id": 5, "repo": "TrustedBSD/sebsd", "file": "contrib/pf/pflogd/pflogd.c", "last_update_at": "2019-10-09T17:34:14+00:00", "question_id": "8c510c347e0dd02d71dc20bfb727fa4ea676406c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nset_snaplen(int snap)\n{\n\tif (priv_set_snaplen(snap))\n\t\treturn (1);\n\tif (cur_snaplen > snap)\n\t\tpurge_buffer();\n\tcur_snaplen = snap;\n\treturn (0);\n"]], "pred": {"ppl": 3.6016364097595215, "ppl_lower": 3.6016364097595215, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.012440663111148408, "Min_5.0% Prob": 9.023973147074381, "Min_10.0% Prob": 7.531050886426653, "Min_20.0% Prob": 5.133123938242594, "Min_30.0% Prob": 3.9559400623494927, "Min_40.0% Prob": 3.1106692175070445, "Min_50.0% Prob": 2.5258173221036007, "Min_60.0% Prob": 2.153366138206588}}
{"hexsha": "082f006ace0e3484e9f844f9d2a8d2b2b80de743", "ext": "h", "lang": "C", "content": "class AtlasScientificDO_DOpct : public Variable\n{\npublic:\n    AtlasScientificDO_DOpct(Sensor *parentSense,\n                            const char *uuid = \"\",\n                            const char *varCode = \"AtlasDOpct\")\n      : Variable(parentSense,\n                 (const uint8_t)ATLAS_DOPCT_VAR_NUM,\n                 (uint8_t)ATLAS_DOPCT_RESOLUTION,\n                 \"oxygenDissolvedPercentOfSaturation\", \"percent\",\n                 varCode, uuid)\n    {}\n    AtlasScientificDO_DOpct()\n      : Variable((const uint8_t)ATLAS_DOPCT_VAR_NUM,\n                 (uint8_t)ATLAS_DOPCT_RESOLUTION,\n                 \"oxygenDissolvedPercentOfSaturation\", \"percent\", \"AtlasDOpct\")\n    {}\n    ~AtlasScientificDO_DOpct(){}\n}", "item_id": 2, "repo": "ssuttles-usgs/ModularSensors", "file": "src/sensors/AtlasScientificDO.h", "last_update_at": "2019-10-03T16:36:30+00:00", "question_id": "082f006ace0e3484e9f844f9d2a8d2b2b80de743_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AtlasScientificDO_DOpct : public Variable\n{\npublic:\n    AtlasScientificDO_DOpct(Sensor *parentSense,\n                            const char *uuid = \"\",\n                            const char *varCode = \"AtlasDOpct\")\n      : Variable(parentSense,\n                 (const uint8_t)ATLAS_DOPCT_VAR_NUM,\n                 (uint8_t)ATLAS_DOPCT_RESOLUTION,\n                 \"oxygenDissolvedPercentOfSaturation\", \"percent\",\n                 varCode, uuid)\n    {}\n    AtlasScientificDO_DOpct()\n      : Variable((const uint8_t)ATLAS_DOPCT_VAR_NUM,\n                 (uint8_t)ATLAS_DOPCT_RESOLUTION,\n                 \"oxygenDissolvedPercentOfSaturation\", \"percent\", \"AtlasDOpct\")\n    {}\n    ~AtlasScientificDO_DOpct(){}\n"]], "pred": {"ppl": 1.578368902206421, "ppl_lower": 2.7100601196289062, "ppl/lowercase_ppl": -2.184461771997252, "ppl/zlib": 0.0018859172455902966, "Min_5.0% Prob": 6.225238045056661, "Min_10.0% Prob": 4.257390131553014, "Min_20.0% Prob": 2.284831538951645, "Min_30.0% Prob": 1.531245996347732, "Min_40.0% Prob": 1.1499491738334957, "Min_50.0% Prob": 0.9126499933878552, "Min_60.0% Prob": 0.7616783656493022}}
{"hexsha": "ab84b50b1c878dd3c0470f908412e7f30edf830a", "ext": "c", "lang": "C", "content": "static int irq_handler(void * private_data, uint32_t vec_index) {\n    struct host_pci_state * state = (struct host_pci_state *)private_data;\n    struct v3_irq vec;\n\n    vec.irq = vec_index;\n    vec.ack = irq_ack;\n    vec.private_data = state;\n\n    // For selective privilege, the interrupt is always delivered\n    // identically to the regular case, regardless of the current\n    // privilege level.  The idea here is that delivery of the\n    // interrupt will result in a dispatch to the privileged guest code\n    // and the entry to that code will enable privilege before any\n    // mapped bar is read or written.\n\n    PrintDebug(0, 0,\"Host PCI / Selective Privilege: Delivering vec irq %d, state %d\\n\", vec.irq, (int)(state->pci_dev->irq_type));\n    if (state->pci_dev->irq_type == IRQ_NONE) {\n\treturn 0;\n    } else if (state->pci_dev->irq_type == IRQ_INTX) {\n\tv3_pci_raise_acked_irq(state->pci_bus, state->pci_dev, vec);\n    } else {\n\tv3_pci_raise_irq(state->pci_bus, state->pci_dev, vec_index);\n    }\n\n    return 0;\n}", "item_id": 21, "repo": "PeterDinda/palacios", "file": "palacios/src/devices/host_pci_selpriv.c", "last_update_at": "2019-09-14T00:11:42+00:00", "question_id": "ab84b50b1c878dd3c0470f908412e7f30edf830a_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int irq_handler(void * private_data, uint32_t vec_index) {\n    struct host_pci_state * state = (struct host_pci_state *)private_data;\n    struct v3_irq vec;\n    vec.irq = vec_index;\n    vec.ack = irq_ack;\n    vec.private_data = state;\n    // For selective privilege, the interrupt is always delivered\n    // identically to the regular case, regardless of the current\n    // privilege level.  The idea here is that delivery of the\n    // interrupt will result in a dispatch to the privileged guest code\n    // and the entry to that code will enable privilege before any\n    // mapped bar is read or written.\n    PrintDebug(0, 0,\"Host PCI / Selective Privilege: Delivering vec irq %d, state %d\\n\", vec.irq, (int)(state->pci_dev->irq_type));\n    if (state->pci_dev->irq_type == IRQ_NONE) {\n\treturn 0;\n    } else if (state->pci_dev->irq_type == IRQ_INTX) {\n\tv3_pci_raise_acked_irq(state->pci_bus, state->pci_dev, vec);\n    } else {\n\tv3_pci_raise_irq(state->pci_bus, state->pci_dev, vec_index);\n    }\n    return 0;\n"]], "pred": {"ppl": 3.4987993240356445, "ppl_lower": 3.680100917816162, "ppl/lowercase_ppl": -1.0403381624636923, "ppl/zlib": 0.002555958896662513, "Min_5.0% Prob": 9.172683848275078, "Min_10.0% Prob": 7.020659036106533, "Min_20.0% Prob": 4.982816447950389, "Min_30.0% Prob": 3.8156697356372797, "Min_40.0% Prob": 3.0279456350493104, "Min_50.0% Prob": 2.4773317503798853, "Min_60.0% Prob": 2.0865146157301995}}
{"hexsha": "7b3c531bf922c3a151d57c033b7fbb4c54dd41f8", "ext": "c", "lang": "C", "content": "void TRI_DestroyCondition (TRI_condition_t* cond) {\n  pthread_cond_destroy(&cond->_cond);\n  pthread_mutex_destroy(cond->_mutex);\n  TRI_Free(TRI_CORE_MEM_ZONE, cond->_mutex);\n}", "item_id": 11, "repo": "asaaki/ArangoDB", "file": "lib/BasicsC/locks-posix.c", "last_update_at": "2019-10-15T17:52:58+00:00", "question_id": "7b3c531bf922c3a151d57c033b7fbb4c54dd41f8_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void TRI_DestroyCondition (TRI_condition_t* cond) {\n  pthread_cond_destroy(&cond->_cond);\n  pthread_mutex_destroy(cond->_mutex);\n  TRI_Free(TRI_CORE_MEM_ZONE, cond->_mutex);\n"]], "pred": {"ppl": 3.0862302780151367, "ppl_lower": 6.5003886222839355, "ppl/lowercase_ppl": -1.660997689598422, "ppl/zlib": 0.009799568446802378, "Min_5.0% Prob": 8.45864232381185, "Min_10.0% Prob": 7.295821530478341, "Min_20.0% Prob": 4.932475694588253, "Min_30.0% Prob": 3.6412429213523865, "Min_40.0% Prob": 2.8391914208020483, "Min_50.0% Prob": 2.24130513270696, "Min_60.0% Prob": 1.8830041399788717}}
{"hexsha": "00485776840c5879550f1bc5b83dd4ba1546c048", "ext": "h", "lang": "C", "content": "namespace onut\n{\n    unsigned int hash(const std::string &s, unsigned int seed = 0);\n    std::string sha1(const std::string& str);\n    bool validateEmail(const std::string& email);\n    std::string base64_encode(uint8_t const* buf, unsigned int bufLen);\n    std::vector<uint8_t> base64_decode(std::string const&);\n}", "item_id": 0, "repo": "Daivuk/ggj16", "file": "onut/include/crypto.h", "last_update_at": "2019-10-19T04:49:33+00:00", "question_id": "00485776840c5879550f1bc5b83dd4ba1546c048_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["namespace onut\n{\n    unsigned int hash(const std::string &s, unsigned int seed = 0);\n    std::string sha1(const std::string& str);\n    bool validateEmail(const std::string& email);\n    std::string base64_encode(uint8_t const* buf, unsigned int bufLen);\n    std::vector<uint8_t> base64_decode(std::string const&);\n"]], "pred": {"ppl": 3.232574939727783, "ppl_lower": 3.4985594749450684, "ppl/lowercase_ppl": -1.0673942767207092, "ppl/zlib": 0.006901641262385882, "Min_5.0% Prob": 9.44234733581543, "Min_10.0% Prob": 6.883796048164368, "Min_20.0% Prob": 4.82567726969719, "Min_30.0% Prob": 3.638380565245946, "Min_40.0% Prob": 2.825549899077997, "Min_50.0% Prob": 2.3326668762693217, "Min_60.0% Prob": 1.971152222425234}}
{"hexsha": "9e8502f324fe0a29e291b5d632be968a310e638e", "ext": "c", "lang": "C", "content": "static uint8_t pyb_usbdd_EP0_TxSent(USBD_HandleTypeDef *pdev) {\n    pyb_usbdd_obj_t *self = (pyb_usbdd_obj_t*)pdev->pClassData;\n    self->tx_pending = false;\n    #if !USE_USB_POLLING\n    // Process now that we have sent a response\n    dfu_process();\n    #endif\n    return USBD_OK;\n}", "item_id": 25, "repo": "pmp-p/micropython-nonlr", "file": "ports/stm32/mboot/main.c", "last_update_at": "2019-06-30T22:24:18+00:00", "question_id": "9e8502f324fe0a29e291b5d632be968a310e638e_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uint8_t pyb_usbdd_EP0_TxSent(USBD_HandleTypeDef *pdev) {\n    pyb_usbdd_obj_t *self = (pyb_usbdd_obj_t*)pdev->pClassData;\n    self->tx_pending = false;\n    #if !USE_USB_POLLING\n    // Process now that we have sent a response\n    dfu_process();\n    #endif\n    return USBD_OK;\n"]], "pred": {"ppl": 3.3256852626800537, "ppl_lower": 5.782161235809326, "ppl/lowercase_ppl": -1.4602753975302087, "ppl/zlib": 0.005641670173297992, "Min_5.0% Prob": 8.71486873626709, "Min_10.0% Prob": 7.012564875862815, "Min_20.0% Prob": 4.96941035726796, "Min_30.0% Prob": 3.779938425336565, "Min_40.0% Prob": 2.9706308556363936, "Min_50.0% Prob": 2.4106634571138077, "Min_60.0% Prob": 2.0104323890270064}}
{"hexsha": "45d98a686e1c0709d41512880be3b1c7c539327e", "ext": "c", "lang": "C", "content": "void\non_checkbutton21_toggled               (GtkToggleButton *togglebutton,\n                                        gpointer         user_data)\n{\n        GtkWidget *en1;\n        en1 = lookup_widget(GTK_WIDGET(togglebutton), \"entry29\");\n\tif (GTK_TOGGLE_BUTTON(togglebutton)->active) {\n                gtk_widget_set_sensitive(en1, FALSE);\n\t\tgtk_entry_set_text(GTK_ENTRY(en1), \"\");\n        }\n        else \n                gtk_widget_set_sensitive(en1, TRUE);\n}", "item_id": 53, "repo": "Rashminadig/SDN", "file": "packETH-1.7.3/src/callbacks.c", "last_update_at": "2019-02-04T21:41:00+00:00", "question_id": "45d98a686e1c0709d41512880be3b1c7c539327e_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\non_checkbutton21_toggled               (GtkToggleButton *togglebutton,\n                                        gpointer         user_data)\n{\n        GtkWidget *en1;\n        en1 = lookup_widget(GTK_WIDGET(togglebutton), \"entry29\");\n\tif (GTK_TOGGLE_BUTTON(togglebutton)->active) {\n                gtk_widget_set_sensitive(en1, FALSE);\n\t\tgtk_entry_set_text(GTK_ENTRY(en1), \"\");\n        }\n        else \n                gtk_widget_set_sensitive(en1, TRUE);\n"]], "pred": {"ppl": 2.41094970703125, "ppl_lower": 3.3538897037506104, "ppl/lowercase_ppl": -1.375104840134576, "ppl/zlib": 0.0036820951430343893, "Min_5.0% Prob": 7.488986151559012, "Min_10.0% Prob": 5.726713911692301, "Min_20.0% Prob": 3.734090778135484, "Min_30.0% Prob": 2.8016093645406808, "Min_40.0% Prob": 2.169239394366741, "Min_50.0% Prob": 1.753491938066406, "Min_60.0% Prob": 1.4747293967032624}}
{"hexsha": "c5b721df647b0c5d4a4223b39b040736c0039ab8", "ext": "c", "lang": "C", "content": "int mod_build_attribute_element_map(CONF_SECTION *conf, void *instance)\n{\n\trlm_couchbase_t *inst = instance;   /* our module instance */\n\tCONF_SECTION *cs;                   /* module config section */\n\tCONF_ITEM *ci;                      /* config item */\n\tCONF_PAIR *cp;                      /* conig pair */\n\tconst char *attribute, *element;    /* attribute and element names */\n\n\t/* find update section */\n\tcs = cf_section_sub_find(conf, \"update\");\n\n\t/* backwards compatibility */\n\tif (!cs) {\n\t\tcs = cf_section_sub_find(conf, \"map\");\n\t\tWARN(\"rlm_couchbase: found deprecated 'map' section - please change to 'update'\");\n\t}\n\n\t/* check section */\n\tif (!cs) {\n\t\tERROR(\"rlm_couchbase: failed to find 'update' section in config\");\n\t\t/* fail */\n\t\treturn -1;\n\t}\n\n\t/* create attribute map object */\n\tinst->map = json_object_new_object();\n\n\t/* parse update section */\n\tfor (ci = cf_item_find_next(cs, NULL); ci != NULL; ci = cf_item_find_next(cs, ci)) {\n\t\t/* validate item */\n\t\tif (!cf_item_is_pair(ci)) {\n\t\t\tERROR(\"rlm_couchbase: failed to parse invalid item in 'update' section\");\n\t\t\t/* free map */\n\t\t\tif (inst->map) {\n\t\t\t\tjson_object_put(inst->map);\n\t\t\t}\n\t\t\t/* fail */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* get value pair from item */\n\t\tcp = cf_item_to_pair(ci);\n\n\t\t/* get pair name (attribute name) */\n\t\tattribute = cf_pair_attr(cp);\n\n\t\t/* get pair value (element name) */\n\t\telement = cf_pair_value(cp);\n\n\t\t/* add pair name and value */\n\t\tjson_object_object_add(inst->map, attribute, json_object_new_string(element));\n\n\t\t/* debugging */\n\t\tDEBUG3(\"rlm_couchbase: added attribute '%s' to element '%s' mapping\", attribute, element);\n\t}\n\n\t/* debugging */\n\tDEBUG3(\"rlm_couchbase: built attribute to element mapping %s\", json_object_to_json_string(inst->map));\n\n\t/* return */\n\treturn 0;\n}", "item_id": 2, "repo": "FurqanKhan1/Dictator", "file": "Scripts/freeradius-server-3.0.11/freeradius-server-3.0.11/src/modules/rlm_couchbase/mod.c", "last_update_at": "2019-10-23T14:04:12+00:00", "question_id": "c5b721df647b0c5d4a4223b39b040736c0039ab8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int mod_build_attribute_element_map(CONF_SECTION *conf, void *instance)\n{\n\trlm_couchbase_t *inst = instance;   /* our module instance */\n\tCONF_SECTION *cs;                   /* module config section */\n\tCONF_ITEM *ci;                      /* config item */\n\tCONF_PAIR *cp;                      /* conig pair */\n\tconst char *attribute, *element;    /* attribute and element names */\n\t/* find update section */\n\tcs = cf_section_sub_find(conf, \"update\");\n\t/* backwards compatibility */\n\tif (!cs) {\n\t\tcs = cf_section_sub_find(conf, \"map\");\n\t\tWARN(\"rlm_couchbase: found deprecated 'map' section - please change to 'update'\");\n\t}\n\t/* check section */\n\tif (!cs) {\n\t\tERROR(\"rlm_couchbase: failed to find 'update' section in config\");\n\t\t/* fail */\n\t\treturn -1;\n\t}\n\t/* create attribute map object */\n\tinst->map = json_object_new_object();\n\t/* parse update section */\n\tfor (ci = cf_item_find_next(cs, NULL); ci != NULL; ci = cf_item_find_next(cs, ci)) {\n\t\t/* validate item */\n\t\tif (!cf_item_is_pair(ci)) {\n\t\t\tERROR(\"rlm_couchbase: failed to parse invalid item in 'update' section\");\n\t\t\t/* free map */\n\t\t\tif (inst->map) {\n\t\t\t\tjson_object_put(inst->map);\n\t\t\t}\n\t\t\t/* fail */\n\t\t\treturn -1;\n\t\t}\n\t\t/* get value pair from item */\n\t\tcp = cf_item_to_pair(ci);\n\t\t/* get pair name (attribute name) */\n\t\tattribute = cf_pair_attr(cp);\n\t\t/* get pair value (element name) */\n\t\telement = cf_pair_value(cp);\n\t\t/* add pair name and value */\n\t\tjson_object_object_add(inst->map, attribute, json_object_new_string(element));\n\t\t/* debugging */\n\t\tDEBUG3(\"rlm_couchbase: added attribute '%s' to element '%s' mapping\", attribute, element);\n\t}\n\t/* debugging */\n\tDEBUG3(\"rlm_couchbase: built attribute to element mapping %s\", json_object_to_json_string(inst->map));\n\t/* return */\n\treturn 0;\n"]], "pred": {"ppl": 2.0895912647247314, "ppl_lower": 2.18945574760437, "ppl/lowercase_ppl": -1.0633466931320372, "ppl/zlib": 0.0010649833522162195, "Min_5.0% Prob": 6.761556580662727, "Min_10.0% Prob": 4.97297129034996, "Min_20.0% Prob": 3.247230290900916, "Min_30.0% Prob": 2.354433432997515, "Min_40.0% Prob": 1.8220613939629402, "Min_50.0% Prob": 1.4708727854420431, "Min_60.0% Prob": 1.2288565943963476}}
{"hexsha": "dad63623be6a93672974fb43ee50b518fff59ab5", "ext": "c", "lang": "C", "content": "static int aq_ndev_set_features(struct net_device *ndev,\n\t\t\t\tnetdev_features_t features)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *aq_cfg = aq_nic_get_cfg(aq_nic);\n\tbool is_lro = false;\n\n\tif (aq_cfg->hw_features & NETIF_F_LRO) {\n\t\tis_lro = features & NETIF_F_LRO;\n\n\t\tif (aq_cfg->is_lro != is_lro) {\n\t\t\taq_cfg->is_lro = is_lro;\n\n\t\t\tif (netif_running(ndev)) {\n\t\t\t\taq_ndev_close(ndev);\n\t\t\t\taq_ndev_open(ndev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}", "item_id": 4, "repo": "yijunyu/demo-fast", "file": "datasets/linux-4.11-rc3/drivers/net/ethernet/aquantia/atlantic/aq_main.c", "last_update_at": "2019-05-03T19:27:45+00:00", "question_id": "dad63623be6a93672974fb43ee50b518fff59ab5_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int aq_ndev_set_features(struct net_device *ndev,\n\t\t\t\tnetdev_features_t features)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *aq_cfg = aq_nic_get_cfg(aq_nic);\n\tbool is_lro = false;\n\tif (aq_cfg->hw_features & NETIF_F_LRO) {\n\t\tis_lro = features & NETIF_F_LRO;\n\t\tif (aq_cfg->is_lro != is_lro) {\n\t\t\taq_cfg->is_lro = is_lro;\n\t\t\tif (netif_running(ndev)) {\n\t\t\t\taq_ndev_close(ndev);\n\t\t\t\taq_ndev_open(ndev);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n"]], "pred": {"ppl": 1.3903353214263916, "ppl_lower": 1.4925272464752197, "ppl/lowercase_ppl": -1.2152236404514576, "ppl/zlib": 0.0013904850484621966, "Min_5.0% Prob": 4.100844860076904, "Min_10.0% Prob": 2.658675398826599, "Min_20.0% Prob": 1.5986899730563164, "Min_30.0% Prob": 1.0962988354762395, "Min_40.0% Prob": 0.8279108306858689, "Min_50.0% Prob": 0.6584729167581018, "Min_60.0% Prob": 0.5498227246925975}}
{"hexsha": "36dca0f1df8519659a97de30f63b9764a12734c4", "ext": "c", "lang": "C", "content": "ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)\n{\n\tvoid *file_addr;\n\tint fd;\n\tsize_t ret;\n\n\tif (fd_get(out_fd, &fd) != fd_rsocket)\n\t\treturn real.sendfile(fd, in_fd, offset, count);\n\n\tfile_addr = mmap(NULL, count, PROT_READ, 0, in_fd, offset ? *offset : 0);\n\tif (file_addr == (void *) -1)\n\t\treturn -1;\n\n\tret = rwrite(fd, file_addr, count);\n\tif ((ret > 0) && offset)\n\t\tlseek(in_fd, ret, SEEK_CUR);\n\tmunmap(file_addr, count);\n\treturn ret;\n}", "item_id": 33, "repo": "ymaxgit/Freeflow", "file": "libraries-router/librdmacm-1.1.0mlnx/src/preload.c", "last_update_at": "2019-05-05T11:30:49+00:00", "question_id": "36dca0f1df8519659a97de30f63b9764a12734c4_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)\n{\n\tvoid *file_addr;\n\tint fd;\n\tsize_t ret;\n\tif (fd_get(out_fd, &fd) != fd_rsocket)\n\t\treturn real.sendfile(fd, in_fd, offset, count);\n\tfile_addr = mmap(NULL, count, PROT_READ, 0, in_fd, offset ? *offset : 0);\n\tif (file_addr == (void *) -1)\n\t\treturn -1;\n\tret = rwrite(fd, file_addr, count);\n\tif ((ret > 0) && offset)\n\t\tlseek(in_fd, ret, SEEK_CUR);\n\tmunmap(file_addr, count);\n\treturn ret;\n"]], "pred": {"ppl": 2.2362847328186035, "ppl_lower": 2.422797679901123, "ppl/lowercase_ppl": -1.099534629371509, "ppl/zlib": 0.003107397248820608, "Min_5.0% Prob": 7.5269208431243895, "Min_10.0% Prob": 5.82725875718253, "Min_20.0% Prob": 3.7424935485635484, "Min_30.0% Prob": 2.631844401359558, "Min_40.0% Prob": 1.9879849218270358, "Min_50.0% Prob": 1.6075374087283634, "Min_60.0% Prob": 1.3473532313231642}}
{"hexsha": "8589f1fd337e3a2b645f9adf308c8d5c6482b62c", "ext": "c", "lang": "C", "content": "void XVphy_SetPllLayoutErrorCallback(XVphy *InstancePtr,\n\t\tvoid *CallbackFunc, void *CallbackRef)\n{\n\t/* Verify arguments. */\n\tXil_AssertVoid(InstancePtr != NULL);\n\tXil_AssertVoid(CallbackFunc != NULL);\n\tXil_AssertVoid(CallbackRef != NULL);\n\n\tInstancePtr->PllLayoutErrorCallback = (XVphy_ErrorCallback)CallbackFunc;\n\tInstancePtr->PllLayoutErrorRef = CallbackRef;\n}", "item_id": 27, "repo": "fpgadeveloper/embeddedsw", "file": "XilinxProcessorIPLib/drivers/vphy/src/xvphy.c", "last_update_at": "2019-01-30T22:39:34+00:00", "question_id": "8589f1fd337e3a2b645f9adf308c8d5c6482b62c_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void XVphy_SetPllLayoutErrorCallback(XVphy *InstancePtr,\n\t\tvoid *CallbackFunc, void *CallbackRef)\n{\n\t/* Verify arguments. */\n\tXil_AssertVoid(InstancePtr != NULL);\n\tXil_AssertVoid(CallbackFunc != NULL);\n\tXil_AssertVoid(CallbackRef != NULL);\n\tInstancePtr->PllLayoutErrorCallback = (XVphy_ErrorCallback)CallbackFunc;\n\tInstancePtr->PllLayoutErrorRef = CallbackRef;\n"]], "pred": {"ppl": 2.4194047451019287, "ppl_lower": 3.960134983062744, "ppl/lowercase_ppl": -1.5577188036417844, "ppl/zlib": 0.004908452982299302, "Min_5.0% Prob": 11.18467895189921, "Min_10.0% Prob": 7.620603660742442, "Min_20.0% Prob": 4.338035866618156, "Min_30.0% Prob": 2.951438609717621, "Min_40.0% Prob": 2.2240738990173363, "Min_50.0% Prob": 1.781158210329401, "Min_60.0% Prob": 1.4846641557297617}}
{"hexsha": "5280cb67ecaf2ca53cadb8ccf97b88dabb2001d1", "ext": "c", "lang": "C", "content": "static enum cb_err fetch_mac_string_vpd(u8 *macstrbuf, const u8 device_index)\n{\n\tstruct region_device rdev;\n\tvoid *search_address;\n\tsize_t search_length;\n\tsize_t offset;\n\tchar key[] = \"ethernet_mac \"; /* Leave a space at tail to stuff an index */\n\n\t/*\n\t * The device_index 0 is treated as an special case matching to\n\t * \"ethernet_mac\" with single NIC on DUT. When there are mulitple\n\t * NICs on DUT, they are mapping to \"ethernet_macN\", where\n\t * N is [0-9].\n\t */\n\tif (device_index == 0)\n\t\tkey[DEVICE_INDEX_BYTE] = '\\0';\n\telse\n\t\t/* Translate index number from integer to ascii */\n\t\tkey[DEVICE_INDEX_BYTE] = (device_index - 1) + '0';\n\n\tif (fmap_locate_area_as_rdev(\"RO_VPD\", &rdev)) {\n\t\tprintk(BIOS_ERR, \"Error: Couldn't find RO_VPD region.\");\n\t\treturn CB_ERR;\n\t}\n\tsearch_address = rdev_mmap_full(&rdev);\n\tif (search_address == NULL) {\n\t\tprintk(BIOS_ERR, \"LAN: VPD not found.\\n\");\n\t\treturn CB_ERR;\n\t}\n\n\tsearch_length = region_device_sz(&rdev);\n\toffset = search(key, search_address, strlen(key),\n\t\t\tsearch_length);\n\n\tif (offset == search_length) {\n\t\tprintk(BIOS_ERR,\n\t\t       \"Error: Could not locate '%s' in VPD\\n\", key);\n\t\treturn CB_ERR;\n\t}\n\tprintk(BIOS_DEBUG, \"Located '%s' in VPD\\n\", key);\n\n\toffset += strlen(key) + 1;\t/* move to next character */\n\n\tif (offset + MACLEN > search_length) {\n\t\tprintk(BIOS_ERR, \"Search result too small!\\n\");\n\t\treturn CB_ERR;\n\t}\n\tmemcpy(macstrbuf, search_address + offset, MACLEN);\n\treturn CB_SUCCESS;\n}", "item_id": 2, "repo": "fabiojna02/OpenCellular", "file": "firmware/coreboot/src/drivers/net/r8168.c", "last_update_at": "2019-11-04T07:11:25+00:00", "question_id": "5280cb67ecaf2ca53cadb8ccf97b88dabb2001d1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static enum cb_err fetch_mac_string_vpd(u8 *macstrbuf, const u8 device_index)\n{\n\tstruct region_device rdev;\n\tvoid *search_address;\n\tsize_t search_length;\n\tsize_t offset;\n\tchar key[] = \"ethernet_mac \"; /* Leave a space at tail to stuff an index */\n\t/*\n\t * The device_index 0 is treated as an special case matching to\n\t * \"ethernet_mac\" with single NIC on DUT. When there are mulitple\n\t * NICs on DUT, they are mapping to \"ethernet_macN\", where\n\t * N is [0-9].\n\t */\n\tif (device_index == 0)\n\t\tkey[DEVICE_INDEX_BYTE] = '\\0';\n\telse\n\t\t/* Translate index number from integer to ascii */\n\t\tkey[DEVICE_INDEX_BYTE] = (device_index - 1) + '0';\n\tif (fmap_locate_area_as_rdev(\"RO_VPD\", &rdev)) {\n\t\tprintk(BIOS_ERR, \"Error: Couldn't find RO_VPD region.\");\n\t\treturn CB_ERR;\n\t}\n\tsearch_address = rdev_mmap_full(&rdev);\n\tif (search_address == NULL) {\n\t\tprintk(BIOS_ERR, \"LAN: VPD not found.\\n\");\n\t\treturn CB_ERR;\n\t}\n\tsearch_length = region_device_sz(&rdev);\n\toffset = search(key, search_address, strlen(key),\n\t\t\tsearch_length);\n\tif (offset == search_length) {\n\t\tprintk(BIOS_ERR,\n\t\t       \"Error: Could not locate '%s' in VPD\\n\", key);\n\t\treturn CB_ERR;\n\t}\n\tprintk(BIOS_DEBUG, \"Located '%s' in VPD\\n\", key);\n\toffset += strlen(key) + 1;\t/* move to next character */\n\tif (offset + MACLEN > search_length) {\n\t\tprintk(BIOS_ERR, \"Search result too small!\\n\");\n\t\treturn CB_ERR;\n\t}\n\tmemcpy(macstrbuf, search_address + offset, MACLEN);\n\treturn CB_SUCCESS;\n"]], "pred": {"ppl": 2.96527099609375, "ppl_lower": 3.3782620429992676, "ppl/lowercase_ppl": -1.119960211337709, "ppl/zlib": 0.0015396153351535308, "Min_5.0% Prob": 7.766288198273758, "Min_10.0% Prob": 6.198699918286554, "Min_20.0% Prob": 4.489208855180659, "Min_30.0% Prob": 3.415865010534014, "Min_40.0% Prob": 2.672345433607061, "Min_50.0% Prob": 2.1637809032974795, "Min_60.0% Prob": 1.8129282121697807}}
{"hexsha": "39666398b7b6f3903618980f42251f099eca5d67", "ext": "c", "lang": "C", "content": "char* path_to_string(unsigned short* path, int length){\n    int i;\n    char* path_string = calloc((length+1),sizeof(char));\n    for(i=0; i<length; i++){\n        strncat(path_string, (path[i] == 0?\"0\":\"1\"), 1);\n    }\n    path_string[length] = '\\0';\n    return path_string;\n}", "item_id": 16, "repo": "denysvitali/viz-fgk-compressor", "file": "fgk/utlities.c", "last_update_at": "2019-02-10T17:26:34+00:00", "question_id": "39666398b7b6f3903618980f42251f099eca5d67_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char* path_to_string(unsigned short* path, int length){\n    int i;\n    char* path_string = calloc((length+1),sizeof(char));\n    for(i=0; i<length; i++){\n        strncat(path_string, (path[i] == 0?\"0\":\"1\"), 1);\n    }\n    path_string[length] = '\\0';\n    return path_string;\n"]], "pred": {"ppl": 2.6716814041137695, "ppl_lower": 2.6716814041137695, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005746830488760125, "Min_5.0% Prob": 6.796031951904297, "Min_10.0% Prob": 5.718016600608825, "Min_20.0% Prob": 4.0210565507411955, "Min_30.0% Prob": 3.004964772732027, "Min_40.0% Prob": 2.38640631626292, "Min_50.0% Prob": 1.9314235460299711, "Min_60.0% Prob": 1.6358532388844798}}
{"hexsha": "f95ea6063246954da5f484aab781b57da03b7720", "ext": "c", "lang": "C", "content": "_Use_decl_annotations_\nvoid StrArrCat(CharPtrPtr * self_, ConstCharPtr str)\n{\n    size_t len;\n    CharPtrPtr self = *self_;\n\n    len = StrArrLen(self);\n    self = (CharPtrPtr)PAL_Realloc(self, sizeof(char*) * (len + 2));\n\n    if (self)\n    {\n        CharPtr s = PAL_Strdup(str);\n        self[len] = s;\n        self[len+1] = NULL;\n    }\n\n#ifdef _PREFAST_\n#pragma prefast (push)\n#pragma prefast (disable: 26036)\n#endif\n    /* \n        OACR does not like NULL-ing buffers by using length above, instead it wants us to walk the entire array manually.\n        This isn't necessary here. The logic is correct. \n    */\n    *self_ = self;\n#ifdef _PREFAST_\n#pragma prefast (pop)\n#endif\n}", "item_id": 0, "repo": "Beguiled/omi", "file": "Unix/base/strarr.c", "last_update_at": "2019-05-05T11:09:37+00:00", "question_id": "f95ea6063246954da5f484aab781b57da03b7720_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["_Use_decl_annotations_\nvoid StrArrCat(CharPtrPtr * self_, ConstCharPtr str)\n{\n    size_t len;\n    CharPtrPtr self = *self_;\n    len = StrArrLen(self);\n    self = (CharPtrPtr)PAL_Realloc(self, sizeof(char*) * (len + 2));\n    if (self)\n    {\n        CharPtr s = PAL_Strdup(str);\n        self[len] = s;\n        self[len+1] = NULL;\n    }\n#ifdef _PREFAST_\n#pragma prefast (push)\n#pragma prefast (disable: 26036)\n#endif\n    /* \n        OACR does not like NULL-ing buffers by using length above, instead it wants us to walk the entire array manually.\n        This isn't necessary here. The logic is correct. \n    */\n    *self_ = self;\n#ifdef _PREFAST_\n#pragma prefast (pop)\n#endif\n"]], "pred": {"ppl": 3.583397388458252, "ppl_lower": 4.251741886138916, "ppl/lowercase_ppl": -1.1339934915271557, "ppl/zlib": 0.0032810060195234076, "Min_5.0% Prob": 8.225910107294718, "Min_10.0% Prob": 7.062881350517273, "Min_20.0% Prob": 4.996311990582213, "Min_30.0% Prob": 3.8781646828393677, "Min_40.0% Prob": 3.1294245476625404, "Min_50.0% Prob": 2.5462558981848926, "Min_60.0% Prob": 2.1265694104588113}}
{"hexsha": "47807fc5914293bda72f99870b55df2c4dbb57a4", "ext": "c", "lang": "C", "content": "static void print_entropy(\n  bool logo,          // true: prints the logo, false: otherwise \n  MODEL *model,       // the model \n  DATASET *dataset,   // the dataset \n  char *str_space,    // space for printing strand direction \n  FILE *outfile       // stream for output \n)\n{\n  int i, j;\n  int w = model->w;                     // width of motif \n  THETA obs = model->obs;               // observed frequencies \n  double *rentropy = model->rentropy;   // RE of each column \n  double re = w *model->rel;            // motif relative entropy \n  ARRAY_T *back = dataset->back;        // background model \n  char restring[15];                    // print string for re \n  char *consensus;                      // consensus strings \n  double min_freq;                      // minimum background freq \n  double maxre;                         // maximum relative entropy \n  int nsteps;                           // number of steps histogram \n\n  // get minimum background frequency and maximum relative entropy \n  for (i = 0, min_freq = 1; i < alph_size_core(dataset->alph); i++) {\n    if (get_array_item(i, back) < min_freq) min_freq = get_array_item(i, back);\n  }\n  maxre = -LOG2(min_freq);              // maximum relative entropy \n\n  // create string containing RE \n  sprintf(restring, \"(%.1f bits)\", re);\n\n  // print the relative entropy of each column as a bar graph \n  nsteps = 10;\n  for (i=0; i<nsteps; i++) {\n    double level = maxre - (i * maxre/nsteps);\n    fprintf(outfile, (i==0 ? \"%*.*s %*.1f \" : \"%-*.*s %*.1f \"), IND, IND,\n      (i==0 ? \"bits\" : i==4 ? \"Relative\" : i==5 ? \"Entropy\" :\n        i==6 ? restring : \"\"), IND2, level);\n    for (j=0; j<w; j++) {\n      if (NINT(nsteps * rentropy[j] / maxre) >= nsteps-i) {\n        fputc('*', outfile);\n      } else {\n        fputc(' ', outfile);\n      }\n    }\n    fputc('\\n', outfile);\n  }\n  fprintf(outfile, \"%-*.*s %*.1f \", IND, IND, \"\", IND2,0.0);\n  for (i=0; i<w; i++) fputc('-', outfile);\n  fprintf(outfile, \"\\n\\n\");\n  // get and print the consensus sequences \n  consensus = get_consensus(obs, w, dataset, MAXDEPTH, MINCONS);\n  for (i=0; i < MAXDEPTH && i < alph_size_core(dataset->alph); i++) { // print next levels of consensus \n    fprintf(outfile, \"%-*.*s %*.0s %*.*s\\n\", IND, IND,\n      (i==0 ? \"Multilevel\" : i == 1 ? \"consensus\" : i == 2 ? \"sequence\" : \"\"),\n      IND2, \"\", w, w, consensus+(i*w));\n  }\n  // free up space \n  myfree(consensus);\n\n  // Prints a logo in EPS and PNG format to two files in the output directory \n  if(logo) print_logo(model, dataset);\n\n}", "item_id": 7, "repo": "arwyer/MotifFinderGibbs", "file": "deps/kb_meme/meme-5.0.1/src/display.c", "last_update_at": "2019-07-19T04:33:43+00:00", "question_id": "47807fc5914293bda72f99870b55df2c4dbb57a4_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void print_entropy(\n  bool logo,          // true: prints the logo, false: otherwise \n  MODEL *model,       // the model \n  DATASET *dataset,   // the dataset \n  char *str_space,    // space for printing strand direction \n  FILE *outfile       // stream for output \n)\n{\n  int i, j;\n  int w = model->w;                     // width of motif \n  THETA obs = model->obs;               // observed frequencies \n  double *rentropy = model->rentropy;   // RE of each column \n  double re = w *model->rel;            // motif relative entropy \n  ARRAY_T *back = dataset->back;        // background model \n  char restring[15];                    // print string for re \n  char *consensus;                      // consensus strings \n  double min_freq;                      // minimum background freq \n  double maxre;                         // maximum relative entropy \n  int nsteps;                           // number of steps histogram \n  // get minimum background frequency and maximum relative entropy \n  for (i = 0, min_freq = 1; i < alph_size_core(dataset->alph); i++) {\n    if (get_array_item(i, back) < min_freq) min_freq = get_array_item(i, back);\n  }\n  maxre = -LOG2(min_freq);              // maximum relative entropy \n  // create string containing RE \n  sprintf(restring, \"(%.1f bits)\", re);\n  // print the relative entropy of each column as a bar graph \n  nsteps = 10;\n  for (i=0; i<nsteps; i++) {\n    double level = maxre - (i * maxre/nsteps);\n    fprintf(outfile, (i==0 ? \"%*.*s %*.1f \" : \"%-*.*s %*.1f \"), IND, IND,\n      (i==0 ? \"bits\" : i==4 ? \"Relative\" : i==5 ? \"Entropy\" :\n        i==6 ? restring : \"\"), IND2, level);\n    for (j=0; j<w; j++) {\n      if (NINT(nsteps * rentropy[j] / maxre) >= nsteps-i) {\n        fputc('*', outfile);\n      } else {\n        fputc(' ', outfile);\n      }\n    }\n    fputc('\\n', outfile);\n  }\n  fprintf(outfile, \"%-*.*s %*.1f \", IND, IND, \"\", IND2,0.0);\n  for (i=0; i<w; i++) fputc('-', outfile);\n  fprintf(outfile, \"\\n\\n\");\n  // get and print the consensus sequences \n  consensus = get_consensus(obs, w, dataset, MAXDEPTH, MINCONS);\n  for (i=0; i < MAXDEPTH && i < alph_size_core(dataset->alph); i++) { // print next levels of consensus \n    fprintf(outfile, \"%-*.*s %*.0s %*.*s\\n\", IND, IND,\n      (i==0 ? \"Multilevel\" : i == 1 ? \"consensus\" : i == 2 ? \"sequence\" : \"\"),\n      IND2, \"\", w, w, consensus+(i*w));\n  }\n  // free up space \n  myfree(consensus);\n  // Prints a logo in EPS and PNG format to two files in the output directory \n  if(logo) print_logo(model, dataset);\n"]], "pred": {"ppl": 3.053593635559082, "ppl_lower": 3.244331121444702, "ppl/lowercase_ppl": -1.0542766514768753, "ppl/zlib": 0.001093358607448442, "Min_5.0% Prob": 7.953359083695845, "Min_10.0% Prob": 6.308125755760107, "Min_20.0% Prob": 4.4526472351404545, "Min_30.0% Prob": 3.3842504704751932, "Min_40.0% Prob": 2.68916619914537, "Min_50.0% Prob": 2.2009803325470005, "Min_60.0% Prob": 1.8510910969670709}}
{"hexsha": "65bdfdb56877ee0297d9e605384caedbcbed286c", "ext": "c", "lang": "C", "content": "int main(int argc, char **argv)\n{\n\tstruct module *mod;\n\tstruct buffer buf = { };\n\tchar fname[SZ];\n\tchar *kernel_read = NULL, *module_read = NULL;\n\tchar *dump_write = NULL;\n\tint opt;\n\tint err;\n\n\twhile ((opt = getopt(argc, argv, \"i:I:mo:aw\")) != -1) {\n\t\tswitch(opt) {\n\t\t\tcase 'i':\n\t\t\t\tkernel_read = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tmodule_read = optarg;\n\t\t\t\texternal_module = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tmodversions = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdump_write = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tall_versions = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\twarn_unresolved = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (kernel_read)\n\t\tread_dump(kernel_read, 1);\n\tif (module_read)\n\t\tread_dump(module_read, 0);\n\n\twhile (optind < argc) {\n\t\tread_symbols(argv[optind++]);\n\t}\n\n\tfor (mod = modules; mod; mod = mod->next) {\n\t\tif (mod->skip)\n\t\t\tcontinue;\n\t\tcheck_exports(mod);\n\t}\n\n\terr = 0;\n\n\tfor (mod = modules; mod; mod = mod->next) {\n\t\tif (mod->skip)\n\t\t\tcontinue;\n\n\t\tbuf.pos = 0;\n\n\t\tadd_header(&buf, mod);\n\t\terr |= add_versions(&buf, mod);\n\t\tadd_depends(&buf, mod, modules);\n\t\tadd_moddevtable(&buf, mod);\n\t\tadd_srcversion(&buf, mod);\n\n\t\tsprintf(fname, \"%s.mod.c\", mod->name);\n\t\twrite_if_changed(&buf, fname);\n\t}\n\n\tif (dump_write)\n\t\twrite_dump(dump_write);\n\n\treturn err;\n}", "item_id": 39, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/scripts/mod/modpost.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "65bdfdb56877ee0297d9e605384caedbcbed286c_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char **argv)\n{\n\tstruct module *mod;\n\tstruct buffer buf = { };\n\tchar fname[SZ];\n\tchar *kernel_read = NULL, *module_read = NULL;\n\tchar *dump_write = NULL;\n\tint opt;\n\tint err;\n\twhile ((opt = getopt(argc, argv, \"i:I:mo:aw\")) != -1) {\n\t\tswitch(opt) {\n\t\t\tcase 'i':\n\t\t\t\tkernel_read = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tmodule_read = optarg;\n\t\t\t\texternal_module = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tmodversions = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tdump_write = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tall_versions = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\twarn_unresolved = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(1);\n\t\t}\n\t}\n\tif (kernel_read)\n\t\tread_dump(kernel_read, 1);\n\tif (module_read)\n\t\tread_dump(module_read, 0);\n\twhile (optind < argc) {\n\t\tread_symbols(argv[optind++]);\n\t}\n\tfor (mod = modules; mod; mod = mod->next) {\n\t\tif (mod->skip)\n\t\t\tcontinue;\n\t\tcheck_exports(mod);\n\t}\n\terr = 0;\n\tfor (mod = modules; mod; mod = mod->next) {\n\t\tif (mod->skip)\n\t\t\tcontinue;\n\t\tbuf.pos = 0;\n\t\tadd_header(&buf, mod);\n\t\terr |= add_versions(&buf, mod);\n\t\tadd_depends(&buf, mod, modules);\n\t\tadd_moddevtable(&buf, mod);\n\t\tadd_srcversion(&buf, mod);\n\t\tsprintf(fname, \"%s.mod.c\", mod->name);\n\t\twrite_if_changed(&buf, fname);\n\t}\n\tif (dump_write)\n\t\twrite_dump(dump_write);\n\treturn err;\n"]], "pred": {"ppl": 1.7859753370285034, "ppl_lower": 1.8386201858520508, "ppl/lowercase_ppl": -1.0500904957583992, "ppl/zlib": 0.0010942729684988153, "Min_5.0% Prob": 6.201294652620951, "Min_10.0% Prob": 4.445252109746464, "Min_20.0% Prob": 2.713254101207999, "Min_30.0% Prob": 1.8959031561847592, "Min_40.0% Prob": 1.44372627369632, "Min_50.0% Prob": 1.1596995444876737, "Min_60.0% Prob": 0.9675700106579159}}
{"hexsha": "36d0c83b3cf9fa5e3fb4329e1569fb4c11296685", "ext": "c", "lang": "C", "content": "void test_dataLength(void)\r\n{\r\n\tint v, l;\r\n\tint bits;\r\n\tint err = 0;\r\n\r\n\ttestStart(\"Test dataLength\");\r\n\tfor(v=0; v<4; v++) {\r\n\t\tfor(l=0; l<3; l++) {\r\n\t\t\tbits = MQRspec_getDataLengthBit(v+1, (QRecLevel)l);\r\n\t\t\tif(bits != datalen[v][l]) {\r\n\t\t\t\tprintf(\"Error in version %d, level %d.\\n\", v, l);\r\n\t\t\t\terr++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ttestEnd(err);\r\n}", "item_id": 5, "repo": "ecoinchain/ecoin", "file": "3rd-src/qrencode/tests/test_mqrspec.c", "last_update_at": "2019-11-12T10:38:09+00:00", "question_id": "36d0c83b3cf9fa5e3fb4329e1569fb4c11296685_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void test_dataLength(void)\r\n{\r\n\tint v, l;\r\n\tint bits;\r\n\tint err = 0;\r\n\r\n\ttestStart(\"Test dataLength\");\r\n\tfor(v=0; v<4; v++) {\r\n\t\tfor(l=0; l<3; l++) {\r\n\t\t\tbits = MQRspec_getDataLengthBit(v+1, (QRecLevel)l);\r\n\t\t\tif(bits != datalen[v][l]) {\r\n\t\t\t\tprintf(\"Error in version %d, level %d.\\n\", v, l);\r\n\t\t\t\terr++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ttestEnd(err);\r\n"]], "pred": {"ppl": 3.670114040374756, "ppl_lower": 3.79352068901062, "ppl/lowercase_ppl": -1.025435483809384, "ppl/zlib": 0.0056778285382327424, "Min_5.0% Prob": 8.267396748065948, "Min_10.0% Prob": 6.949192047119141, "Min_20.0% Prob": 5.153377164493907, "Min_30.0% Prob": 3.9111890101432802, "Min_40.0% Prob": 3.152302156795155, "Min_50.0% Prob": 2.5795641503779283, "Min_60.0% Prob": 2.161558478474617}}
{"hexsha": "b1dd632eddc6c6ff8b487a9e8e30e47ab5d645c5", "ext": "h", "lang": "C", "content": "static inline void hri_sdhc_write_MC1R_RSTN_bit(const void *const hw, bool value)\n{\n\tuint8_t tmp;\n\tSDHC_CRITICAL_SECTION_ENTER();\n\ttmp = ((Sdhc *)hw)->MC1R.reg;\n\ttmp &= ~SDHC_MC1R_RSTN;\n\ttmp |= value << SDHC_MC1R_RSTN_Pos;\n\t((Sdhc *)hw)->MC1R.reg = tmp;\n\tSDHC_CRITICAL_SECTION_LEAVE();\n}", "item_id": 1094, "repo": "jinlongliu/AliOS-Things", "file": "platform/mcu/atsamd5x_e5x/Drivers/hri/hri_sdhc_e54.h", "last_update_at": "2019-09-25T07:17:27+00:00", "question_id": "b1dd632eddc6c6ff8b487a9e8e30e47ab5d645c5_1094", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_sdhc_write_MC1R_RSTN_bit(const void *const hw, bool value)\n{\n\tuint8_t tmp;\n\tSDHC_CRITICAL_SECTION_ENTER();\n\ttmp = ((Sdhc *)hw)->MC1R.reg;\n\ttmp &= ~SDHC_MC1R_RSTN;\n\ttmp |= value << SDHC_MC1R_RSTN_Pos;\n\t((Sdhc *)hw)->MC1R.reg = tmp;\n\tSDHC_CRITICAL_SECTION_LEAVE();\n"]], "pred": {"ppl": 1.413084626197815, "ppl_lower": 2.517625093460083, "ppl/lowercase_ppl": -2.6702799579560765, "ppl/zlib": 0.0018103402778063586, "Min_5.0% Prob": 4.983774832316807, "Min_10.0% Prob": 3.4668134195464, "Min_20.0% Prob": 1.7512331855130092, "Min_30.0% Prob": 1.1551079185182145, "Min_40.0% Prob": 0.8763422254748454, "Min_50.0% Prob": 0.6962832003182609, "Min_60.0% Prob": 0.5776004902007851}}
{"hexsha": "eb3ab216db77195be3d85bbf701383193b54b73e", "ext": "c", "lang": "C", "content": "static void asockReadUntil_Helper(asock *sock, struct asockReadUntilData *rud, u32 status, char *message)\n{\n  //UNBUSY()s :\n  //  if readSome returns TO US, and WITHOUT ERROR, the socket will not be UNBUSY()d yet.\n  //  if readSome returns TO US, and WITH ERROR, we'll alreday by UNBUSY()d (simply to avoid additional sock->complete checks in readSome)\n  // so, UNBUSY() any completion exit from an incoming ASOCK_STATUS_OK\n\n  // read until disconnect\n  if((status == ASOCK_STATUS_DISCONN) && (rud->untilLen == 0))\n  {\n    if(rud->readPtr) *(rud->readPtr) = rud->read;\n    *(rud->receiver) = realloc(rud->buff, rud->read);\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud);\n    complete(sock, data, ASOCK_STATUS_OK, NULL);\n    return;\n  }\n\n  // errors...\n  if((status != ASOCK_STATUS_OKAY) && (status != ASOCK_STATUS_DISCONN))\n  {\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud->buff);\n    free(rud);\n    complete((void *)sock, data, status, message);\n    return;\n  }\n  if((status == ASOCK_STATUS_DISCONN) && (rud->partial == 0))\n  {\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud->buff);\n    free(rud);\n    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    return;\n  }\n\n  // we have some data to process\n  rud->read += rud->partial;\n\n  // simple case : we're reading until disconnect\n  if(rud->untilLen == 0)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n    return;\n  }\n\n  // simple-ish case : not enough data to compare\n  if((rud->read - rud->matchOffset) < rud->untilLen)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    if(rud->read < rud->max)\n      asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n    else\n    {\n      if(rud->readPtr) *(rud->readPtr) = rud->read;\n      *(rud->receiver) = realloc(rud->buff, rud->read);\n      asockComplete complete = rud->complete;\n      void *data = rud->data;\n      free(rud);\n      UNBUSY(sock);\n      complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    }\n    return;\n  }\n\n  // we have to scan for a match...\n  u8 matched;\n  for(u32 a,b,i=rud->matchOffset; i<rud->read; i++)\n  {\n    a=i; b=0; matched=0;\n    while((a<rud->read) && (rud->buff[a] == ((u8 *)rud->until)[b]))\n    {\n      matched++;\n      // we actually found the damn thing\n      if(matched == rud->untilLen)\n      {\n        // store remaining data in our partial buffer\n        if((a+1) < rud->read) //partial data\n        {\n          u32 partial = rud->read - (a+1);\n          sock->readBuff = (u8 *)realloc(sock->readBuff, sock->readBuffLen + partial);\n          memcpy(sock->readBuff + sock->readBuffLen, rud->buff+a+1, partial);\n          sock->readBuffLen += partial;\n        }\n        // return up-to, and including, our \"until\" token\n        if(rud->readPtr) *(rud->readPtr) = rud->read;\n        *(rud->receiver) = realloc(rud->buff, rud->read);\n        asockComplete complete = rud->complete;\n        void *data = rud->data;\n        free(rud);\n        UNBUSY(sock);\n        complete(sock, data, ASOCK_STATUS_OK, NULL);\n        return;\n      }\n      a++; b++;\n    }\n    // store our matchOffset so we're not scanning the whole buffer every readSome()\n    rud->matchOffset = i;\n    if(a == rud->read)\n    {\n      // this check is important:\n      // if we have a partial match running up until the end of our data,\n      // bail early so we don't increment the matchOffset variable passed the beginning of the partial\n      break;\n    }\n  }\n  // we didn't find a match...\n\n  // have we read as much as we can?\n  if(rud->buffSize == rud->max)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    if(rud->readPtr) *(rud->readPtr) = rud->read;\n    *(rud->receiver) = realloc(rud->buff, rud->read);\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud);\n    UNBUSY(sock);\n    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    return;\n  }\n\n  // more to read then\n  u32 leftToRead = rud->max - rud->buffSize;\n  if(leftToRead > ASOCK_READ_UNTIL_CHUNK_SIZE)\n    leftToRead = ASOCK_READ_UNTIL_CHUNK_SIZE;\n  rud->buffSize += leftToRead;\n  rud->buff = (u8 *)realloc(rud->buff, rud->buffSize);\n  asockReadSome_noBusy(sock, rud->buff + rud->read, leftToRead, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n}", "item_id": 18, "repo": "daumiller/clib", "file": "source/asock_async.c", "last_update_at": "2019-03-30T17:50:52+00:00", "question_id": "eb3ab216db77195be3d85bbf701383193b54b73e_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void asockReadUntil_Helper(asock *sock, struct asockReadUntilData *rud, u32 status, char *message)\n{\n  //UNBUSY()s :\n  //  if readSome returns TO US, and WITHOUT ERROR, the socket will not be UNBUSY()d yet.\n  //  if readSome returns TO US, and WITH ERROR, we'll alreday by UNBUSY()d (simply to avoid additional sock->complete checks in readSome)\n  // so, UNBUSY() any completion exit from an incoming ASOCK_STATUS_OK\n  // read until disconnect\n  if((status == ASOCK_STATUS_DISCONN) && (rud->untilLen == 0))\n  {\n    if(rud->readPtr) *(rud->readPtr) = rud->read;\n    *(rud->receiver) = realloc(rud->buff, rud->read);\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud);\n    complete(sock, data, ASOCK_STATUS_OK, NULL);\n    return;\n  }\n  // errors...\n  if((status != ASOCK_STATUS_OKAY) && (status != ASOCK_STATUS_DISCONN))\n  {\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud->buff);\n    free(rud);\n    complete((void *)sock, data, status, message);\n    return;\n  }\n  if((status == ASOCK_STATUS_DISCONN) && (rud->partial == 0))\n  {\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud->buff);\n    free(rud);\n    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    return;\n  }\n  // we have some data to process\n  rud->read += rud->partial;\n  // simple case : we're reading until disconnect\n  if(rud->untilLen == 0)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n    return;\n  }\n  // simple-ish case : not enough data to compare\n  if((rud->read - rud->matchOffset) < rud->untilLen)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    if(rud->read < rud->max)\n      asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n    else\n    {\n      if(rud->readPtr) *(rud->readPtr) = rud->read;\n      *(rud->receiver) = realloc(rud->buff, rud->read);\n      asockComplete complete = rud->complete;\n      void *data = rud->data;\n      free(rud);\n      UNBUSY(sock);\n      complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    }\n    return;\n  }\n  // we have to scan for a match...\n  u8 matched;\n  for(u32 a,b,i=rud->matchOffset; i<rud->read; i++)\n  {\n    a=i; b=0; matched=0;\n    while((a<rud->read) && (rud->buff[a] == ((u8 *)rud->until)[b]))\n    {\n      matched++;\n      // we actually found the damn thing\n      if(matched == rud->untilLen)\n      {\n        // store remaining data in our partial buffer\n        if((a+1) < rud->read) //partial data\n        {\n          u32 partial = rud->read - (a+1);\n          sock->readBuff = (u8 *)realloc(sock->readBuff, sock->readBuffLen + partial);\n          memcpy(sock->readBuff + sock->readBuffLen, rud->buff+a+1, partial);\n          sock->readBuffLen += partial;\n        }\n        // return up-to, and including, our \"until\" token\n        if(rud->readPtr) *(rud->readPtr) = rud->read;\n        *(rud->receiver) = realloc(rud->buff, rud->read);\n        asockComplete complete = rud->complete;\n        void *data = rud->data;\n        free(rud);\n        UNBUSY(sock);\n        complete(sock, data, ASOCK_STATUS_OK, NULL);\n        return;\n      }\n      a++; b++;\n    }\n    // store our matchOffset so we're not scanning the whole buffer every readSome()\n    rud->matchOffset = i;\n    if(a == rud->read)\n    {\n      // this check is important:\n      // if we have a partial match running up until the end of our data,\n      // bail early so we don't increment the matchOffset variable passed the beginning of the partial\n      break;\n    }\n  }\n  // we didn't find a match...\n  // have we read as much as we can?\n  if(rud->buffSize == rud->max)\n  {\n    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;\n    rud->buff     = realloc(rud->buff, rud->buffSize);\n    if(rud->readPtr) *(rud->readPtr) = rud->read;\n    *(rud->receiver) = realloc(rud->buff, rud->read);\n    asockComplete complete = rud->complete;\n    void *data = rud->data;\n    free(rud);\n    UNBUSY(sock);\n    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup(\"didn't find ReadUntil token within expected length\"));\n    return;\n  }\n  // more to read then\n  u32 leftToRead = rud->max - rud->buffSize;\n  if(leftToRead > ASOCK_READ_UNTIL_CHUNK_SIZE)\n    leftToRead = ASOCK_READ_UNTIL_CHUNK_SIZE;\n  rud->buffSize += leftToRead;\n  rud->buff = (u8 *)realloc(rud->buff, rud->buffSize);\n  asockReadSome_noBusy(sock, rud->buff + rud->read, leftToRead, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);\n"]], "pred": {"ppl": 2.6203839778900146, "ppl_lower": 2.6791586875915527, "ppl/lowercase_ppl": -1.0230265533094705, "ppl/zlib": 0.0007259388571825389, "Min_5.0% Prob": 8.400853587131873, "Min_10.0% Prob": 6.477850238482158, "Min_20.0% Prob": 4.355611891138787, "Min_30.0% Prob": 3.1401825566696964, "Min_40.0% Prob": 2.393468147785856, "Min_50.0% Prob": 1.925162494415873, "Min_60.0% Prob": 1.6069171811381073}}
{"hexsha": "b21106c017ba3453412e360cb8b4f3f47f13a5ee", "ext": "c", "lang": "C", "content": "CLAUSE dfg_CreateClauseFromTerm(TERM Clause, BOOL IsAxiom, FLAGSTORE Flags,\n\t\t\t\tPRECEDENCE Precedence)\n/**************************************************************\n  INPUT:   A clause term, a boolean value, a flag store and a precedence.\n  RETURNS: The clause term converted to a CLAUSE.\n  EFFECT:  This function converts a clause stored as term into an\n           EARL clause structure.\n\t   If 'IsAxiom' is TRUE the clause is treated as axiom\n\t   clause else as conjecture clause.\n           The function deletes the literals \"false\" and \"not(true)\"\n           if they occur in <Clause>.\n\t   The contents of the flag store and the precedence are changed\n\t   because the parser read flag and precedence settings from\n  MEMORY:  The clause term is deleted.\n***************************************************************/\n{\n  LIST   literals, scan;\n  TERM   literal;\n  CLAUSE result;\n  \n  if (term_TopSymbol(Clause) == fol_All()) {\n    /* Remove and free the quantifier and the OR term */\n    literals = term_ArgumentList(term_SecondArgument(Clause));\n    term_RplacArgumentList(term_SecondArgument(Clause), list_Nil());\n  } else {\n    /* Remove and free the OR term */\n    literals = term_ArgumentList(Clause);\n    term_RplacArgumentList(Clause, list_Nil());\n  }\n  term_Delete(Clause);\n\n  for (scan = literals; !list_Empty(scan); scan = list_Cdr(scan)) {\n    literal = (TERM) list_Car(scan);\n    if (symbol_IsPredicate(term_TopSymbol(literal))) {  /* Positive literal */\n      if (fol_IsFalse(literal)) {\n\t/* Ignore this literal */\n\tterm_Delete(literal);\n\tlist_Rplaca(scan, NULL); /* Mark the actual list element */\n      }\n    } else {\n      /* Found a negative literal */\n      TERM atom;\n      atom = term_FirstArgument(literal);\n      if (fol_IsTrue(atom)) {\n\t/* Ignore this literal */\n\tterm_Delete(literal);\n\tlist_Rplaca(literals, NULL); /* Mark the actual list element */\n      }\n    }\n  }\n  \n\n  literals = list_PointerDeleteElement(literals, NULL);\n  /* Remove the special literals treated above from the list */\n  result = clause_CreateFromLiterals(literals, FALSE, !IsAxiom, FALSE, Flags, Precedence);\n  /* Don't create sorts! */\n  list_Delete(literals);\n\n  return result;\n}", "item_id": 24, "repo": "glnc/spass-wasm", "file": "src/dfgparser.c", "last_update_at": "2019-11-10T15:30:21+00:00", "question_id": "b21106c017ba3453412e360cb8b4f3f47f13a5ee_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["CLAUSE dfg_CreateClauseFromTerm(TERM Clause, BOOL IsAxiom, FLAGSTORE Flags,\n\t\t\t\tPRECEDENCE Precedence)\n/**************************************************************\n  INPUT:   A clause term, a boolean value, a flag store and a precedence.\n  RETURNS: The clause term converted to a CLAUSE.\n  EFFECT:  This function converts a clause stored as term into an\n           EARL clause structure.\n\t   If 'IsAxiom' is TRUE the clause is treated as axiom\n\t   clause else as conjecture clause.\n           The function deletes the literals \"false\" and \"not(true)\"\n           if they occur in <Clause>.\n\t   The contents of the flag store and the precedence are changed\n\t   because the parser read flag and precedence settings from\n  MEMORY:  The clause term is deleted.\n***************************************************************/\n{\n  LIST   literals, scan;\n  TERM   literal;\n  CLAUSE result;\n  if (term_TopSymbol(Clause) == fol_All()) {\n    /* Remove and free the quantifier and the OR term */\n    literals = term_ArgumentList(term_SecondArgument(Clause));\n    term_RplacArgumentList(term_SecondArgument(Clause), list_Nil());\n  } else {\n    /* Remove and free the OR term */\n    literals = term_ArgumentList(Clause);\n    term_RplacArgumentList(Clause, list_Nil());\n  }\n  term_Delete(Clause);\n  for (scan = literals; !list_Empty(scan); scan = list_Cdr(scan)) {\n    literal = (TERM) list_Car(scan);\n    if (symbol_IsPredicate(term_TopSymbol(literal))) {  /* Positive literal */\n      if (fol_IsFalse(literal)) {\n\t/* Ignore this literal */\n\tterm_Delete(literal);\n\tlist_Rplaca(scan, NULL); /* Mark the actual list element */\n      }\n    } else {\n      /* Found a negative literal */\n      TERM atom;\n      atom = term_FirstArgument(literal);\n      if (fol_IsTrue(atom)) {\n\t/* Ignore this literal */\n\tterm_Delete(literal);\n\tlist_Rplaca(literals, NULL); /* Mark the actual list element */\n      }\n    }\n  }\n  literals = list_PointerDeleteElement(literals, NULL);\n  /* Remove the special literals treated above from the list */\n  result = clause_CreateFromLiterals(literals, FALSE, !IsAxiom, FALSE, Flags, Precedence);\n  /* Don't create sorts! */\n  list_Delete(literals);\n  return result;\n"]], "pred": {"ppl": 2.7574141025543213, "ppl_lower": 3.917537212371826, "ppl/lowercase_ppl": -1.3462212219070366, "ppl/zlib": 0.0011725934348917845, "Min_5.0% Prob": 7.5691344457514145, "Min_10.0% Prob": 5.876240849494934, "Min_20.0% Prob": 4.155811749836978, "Min_30.0% Prob": 3.1549387664771547, "Min_40.0% Prob": 2.4819214524810804, "Min_50.0% Prob": 2.01620975042529, "Min_60.0% Prob": 1.688743524143801}}
{"hexsha": "10ebc3316cedbe14c8e132478528cf10b4da9ec3", "ext": "h", "lang": "C", "content": "void Do_Movement()\n\t{\n\t\t// CameraViewModel controls\n\t\tif (keys[GLFW_KEY_W])\n\t\t\tcamera.ProcessKeyboard(FORWARD, deltaTime);\n\t\tif (keys[GLFW_KEY_S])\n\t\t\tcamera.ProcessKeyboard(BACKWARD, deltaTime);\n\t\tif (keys[GLFW_KEY_A])\n\t\t\tcamera.ProcessKeyboard(LEFT, deltaTime);\n\t\tif (keys[GLFW_KEY_D])\n\t\t\tcamera.ProcessKeyboard(RIGHT, deltaTime);\n\t}", "item_id": 0, "repo": "SenonLi/VS_OpenGLSL_4.1", "file": "vsSenOpenGL/LearnOpenGL_GLFW/SenFreeSpaceAbstract.h", "last_update_at": "2019-01-02T08:14:26+00:00", "question_id": "10ebc3316cedbe14c8e132478528cf10b4da9ec3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Do_Movement()\n\t{\n\t\t// CameraViewModel controls\n\t\tif (keys[GLFW_KEY_W])\n\t\t\tcamera.ProcessKeyboard(FORWARD, deltaTime);\n\t\tif (keys[GLFW_KEY_S])\n\t\t\tcamera.ProcessKeyboard(BACKWARD, deltaTime);\n\t\tif (keys[GLFW_KEY_A])\n\t\t\tcamera.ProcessKeyboard(LEFT, deltaTime);\n\t\tif (keys[GLFW_KEY_D])\n\t\t\tcamera.ProcessKeyboard(RIGHT, deltaTime);\n"]], "pred": {"ppl": 1.889173984527588, "ppl_lower": 2.1980392932891846, "ppl/lowercase_ppl": -1.2380389828281584, "ppl/zlib": 0.004077818514845854, "Min_5.0% Prob": 8.448592117854528, "Min_10.0% Prob": 5.925878686564309, "Min_20.0% Prob": 3.1829028895189024, "Min_30.0% Prob": 2.1586648808618962, "Min_40.0% Prob": 1.601140948510247, "Min_50.0% Prob": 1.2722288352953213, "Min_60.0% Prob": 1.067527001594687}}
{"hexsha": "da8f2d18c21364800b6e64261af4b8c437f3d1d9", "ext": "c", "lang": "C", "content": "STATIC void\nS_croak_xs_usage(const CV *const cv, const char *const params)\n{\n    const GV *const gv = CvGV(cv);\n\n    PERL_ARGS_ASSERT_CROAK_XS_USAGE;\n\n    if (gv) {\n        const char *const gvname = GvNAME(gv);\n        const HV *const stash = GvSTASH(gv);\n        const char *const hvname = stash ? HvNAME(stash) : NULL;\n\n        if (hvname)\n\t    Perl_croak_nocontext(\"Usage: %s::%s(%s)\", hvname, gvname, params);\n        else\n\t    Perl_croak_nocontext(\"Usage: %s(%s)\", gvname, params);\n    } else {\n        /* Pants. I don't think that it should be possible to get here. */\n\tPerl_croak_nocontext(\"Usage: CODE(0x%\" UVxf \")(%s)\", PTR2UV(cv), params);\n    }\n}", "item_id": 17, "repo": "nneesshh/openresty-win32-build", "file": "openresty-win32-build/thirdparty/perl5-5.29.6/ext/Hash-Util-FieldHash/FieldHash.c", "last_update_at": "2019-01-12T03:20:41+00:00", "question_id": "da8f2d18c21364800b6e64261af4b8c437f3d1d9_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["STATIC void\nS_croak_xs_usage(const CV *const cv, const char *const params)\n{\n    const GV *const gv = CvGV(cv);\n    PERL_ARGS_ASSERT_CROAK_XS_USAGE;\n    if (gv) {\n        const char *const gvname = GvNAME(gv);\n        const HV *const stash = GvSTASH(gv);\n        const char *const hvname = stash ? HvNAME(stash) : NULL;\n        if (hvname)\n\t    Perl_croak_nocontext(\"Usage: %s::%s(%s)\", hvname, gvname, params);\n        else\n\t    Perl_croak_nocontext(\"Usage: %s(%s)\", gvname, params);\n    } else {\n        /* Pants. I don't think that it should be possible to get here. */\n\tPerl_croak_nocontext(\"Usage: CODE(0x%\" UVxf \")(%s)\", PTR2UV(cv), params);\n    }\n"]], "pred": {"ppl": 1.3149555921554565, "ppl_lower": 2.8357622623443604, "ppl/lowercase_ppl": -3.806792390824755, "ppl/zlib": 0.0008100677361997444, "Min_5.0% Prob": 4.282175339185274, "Min_10.0% Prob": 2.5540676506666036, "Min_20.0% Prob": 1.3723467956736404, "Min_30.0% Prob": 0.9177233672817238, "Min_40.0% Prob": 0.6877135872627634, "Min_50.0% Prob": 0.5495061366514775, "Min_60.0% Prob": 0.4574403373117093}}
{"hexsha": "65257ecbf9adae4994043ee1087a81276aed488d", "ext": "c", "lang": "C", "content": "double loggam(double x) {\n  double x0, x2, xp, gl, gl0;\n  RAND_INT_TYPE k, n;\n\n  static double a[10] = {8.333333333333333e-02, -2.777777777777778e-03,\n                         7.936507936507937e-04, -5.952380952380952e-04,\n                         8.417508417508418e-04, -1.917526917526918e-03,\n                         6.410256410256410e-03, -2.955065359477124e-02,\n                         1.796443723688307e-01, -1.39243221690590e+00};\n  x0 = x;\n  n = 0;\n  if ((x == 1.0) || (x == 2.0)) {\n    return 0.0;\n  } else if (x <= 7.0) {\n    n = (RAND_INT_TYPE)(7 - x);\n    x0 = x + n;\n  }\n  x2 = 1.0 / (x0 * x0);\n  xp = 2 * M_PI;\n  gl0 = a[9];\n  for (k = 8; k >= 0; k--) {\n    gl0 *= x2;\n    gl0 += a[k];\n  }\n  gl = gl0 / x0 + 0.5 * log(xp) + (x0 - 0.5) * log(x0) - x0;\n  if (x <= 7.0) {\n    for (k = 1; k <= n; k++) {\n      gl -= log(x0 - 1.0);\n      x0 -= 1.0;\n    }\n  }\n  return gl;\n}", "item_id": 6, "repo": "giuse/numpy", "file": "numpy/random/src/distributions/distributions.c", "last_update_at": "2019-12-14T03:08:31+00:00", "question_id": "65257ecbf9adae4994043ee1087a81276aed488d_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double loggam(double x) {\n  double x0, x2, xp, gl, gl0;\n  RAND_INT_TYPE k, n;\n  static double a[10] = {8.333333333333333e-02, -2.777777777777778e-03,\n                         7.936507936507937e-04, -5.952380952380952e-04,\n                         8.417508417508418e-04, -1.917526917526918e-03,\n                         6.410256410256410e-03, -2.955065359477124e-02,\n                         1.796443723688307e-01, -1.39243221690590e+00};\n  x0 = x;\n  n = 0;\n  if ((x == 1.0) || (x == 2.0)) {\n    return 0.0;\n  } else if (x <= 7.0) {\n    n = (RAND_INT_TYPE)(7 - x);\n    x0 = x + n;\n  }\n  x2 = 1.0 / (x0 * x0);\n  xp = 2 * M_PI;\n  gl0 = a[9];\n  for (k = 8; k >= 0; k--) {\n    gl0 *= x2;\n    gl0 += a[k];\n  }\n  gl = gl0 / x0 + 0.5 * log(xp) + (x0 - 0.5) * log(x0) - x0;\n  if (x <= 7.0) {\n    for (k = 1; k <= n; k++) {\n      gl -= log(x0 - 1.0);\n      x0 -= 1.0;\n    }\n  }\n  return gl;\n"]], "pred": {"ppl": 1.5348800420761108, "ppl_lower": 1.578343391418457, "ppl/lowercase_ppl": -1.0651731491283942, "ppl/zlib": 0.0009917875682888663, "Min_5.0% Prob": 4.5744008576428445, "Min_10.0% Prob": 3.114717370813543, "Min_20.0% Prob": 1.961610301787203, "Min_30.0% Prob": 1.3917652103033933, "Min_40.0% Prob": 1.0651548561047424, "Min_50.0% Prob": 0.8544012003045097, "Min_60.0% Prob": 0.7138344008979188}}
{"hexsha": "9e7e22d485764f0e62c8866b235081e6c8f7e152", "ext": "c", "lang": "C", "content": "int freeImageGD(imageObj *img)\n{\n  gdImagePtr ip;\n\n  if(img) {\n    ip = MS_IMAGE_GET_GDIMAGEPTR(img);\n    if(ip) gdImageDestroy(ip);\n  }\n\n  return MS_SUCCESS;\n}", "item_id": 2, "repo": "shaohuifan/mapserver", "file": "mapgd.c", "last_update_at": "2019-02-13T09:09:59+00:00", "question_id": "9e7e22d485764f0e62c8866b235081e6c8f7e152_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int freeImageGD(imageObj *img)\n{\n  gdImagePtr ip;\n  if(img) {\n    ip = MS_IMAGE_GET_GDIMAGEPTR(img);\n    if(ip) gdImageDestroy(ip);\n  }\n  return MS_SUCCESS;\n"]], "pred": {"ppl": 5.325916290283203, "ppl_lower": 7.5733537673950195, "ppl/lowercase_ppl": -1.2104833426395623, "ppl/zlib": 0.012866036692963063, "Min_5.0% Prob": 12.568721453348795, "Min_10.0% Prob": 9.608873571668353, "Min_20.0% Prob": 6.2562552769978845, "Min_30.0% Prob": 4.928701482035897, "Min_40.0% Prob": 3.963581160704295, "Min_50.0% Prob": 3.3259963046860053, "Min_60.0% Prob": 2.769713890552521}}
{"hexsha": "b5e9ba689664d80701625c617f59f3ee9eb82b65", "ext": "c", "lang": "C", "content": "int16_t testDM1 ( void )\r\n{\r\n  int32_t t[64],a;\r\n  PW_Start_Address = PW_i;\r\n\r\n  /* file size */\r\n  if ( (PW_Start_Address + 104) > PW_in_size )\r\n  {\r\n    /*printf ( \"#1 (start:%d) (size:%d)\\n\" , PW_Start_Address , PW_in_size-PW_Start_Address);*/\r\n    return BAD;\r\n  }\r\n\r\n  /* get track sizes */\r\n  for ( a=0; a<4; a++)\r\n  {\r\n    t[a] = (( in_data[PW_Start_Address+6+(a*4)]*256)+\r\n              in_data[PW_Start_Address+7+(a*4)] );\r\n    if (t[a] > 0x7fff) return BAD;\r\n  }\r\n\r\n  /* get note block size */\r\n  t[4] = (( in_data[PW_Start_Address+22]*256) + in_data[PW_Start_Address+23] );\r\n\r\n\r\n  /* get sounds sizes */\r\n  for ( a=0; a<20; a++)\r\n  {\r\n    t[a+40] = (( in_data[PW_Start_Address+25+(a*4)]*256*256)+\r\n               ( in_data[PW_Start_Address+26+(a*4)]*256)+\r\n                 in_data[PW_Start_Address+27+(a*4)] );\r\n    if (t[a+40] > 0xffff) return BAD;\r\n  }\r\n\r\n  /* file size */\r\n  PW_l = t[0] + t[1] + t[2] + t[3] + t[4] + 104;\r\n  if ( (PW_Start_Address + PW_l) > PW_in_size)\r\n  {\r\n    printf ( \"#1,3 (start:%d) (t[0]:%x)(t[1]:%x)(t[2]:%x)(t[3]:%x)(t[4]:%x)\\n\" , PW_Start_Address , t[0],t[1],t[2],t[3],t[4]);\r\n    return BAD;\r\n  }\r\n\r\n  for ( a=40; a<60; a++)PW_l += t[a];\r\n\r\n  return GOOD;\r\n}", "item_id": 0, "repo": "demozoo/open_depacker", "file": "external/prowiz/r/DM1.c", "last_update_at": "2019-05-04T11:54:25+00:00", "question_id": "b5e9ba689664d80701625c617f59f3ee9eb82b65_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int16_t testDM1 ( void )\r\n{\r\n  int32_t t[64],a;\r\n  PW_Start_Address = PW_i;\r\n\r\n  /* file size */\r\n  if ( (PW_Start_Address + 104) > PW_in_size )\r\n  {\r\n    /*printf ( \"#1 (start:%d) (size:%d)\\n\" , PW_Start_Address , PW_in_size-PW_Start_Address);*/\r\n    return BAD;\r\n  }\r\n\r\n  /* get track sizes */\r\n  for ( a=0; a<4; a++)\r\n  {\r\n    t[a] = (( in_data[PW_Start_Address+6+(a*4)]*256)+\r\n              in_data[PW_Start_Address+7+(a*4)] );\r\n    if (t[a] > 0x7fff) return BAD;\r\n  }\r\n\r\n  /* get note block size */\r\n  t[4] = (( in_data[PW_Start_Address+22]*256) + in_data[PW_Start_Address+23] );\r\n\r\n\r\n  /* get sounds sizes */\r\n  for ( a=0; a<20; a++)\r\n  {\r\n    t[a+40] = (( in_data[PW_Start_Address+25+(a*4)]*256*256)+\r\n               ( in_data[PW_Start_Address+26+(a*4)]*256)+\r\n                 in_data[PW_Start_Address+27+(a*4)] );\r\n    if (t[a+40] > 0xffff) return BAD;\r\n  }\r\n\r\n  /* file size */\r\n  PW_l = t[0] + t[1] + t[2] + t[3] + t[4] + 104;\r\n  if ( (PW_Start_Address + PW_l) > PW_in_size)\r\n  {\r\n    printf ( \"#1,3 (start:%d) (t[0]:%x)(t[1]:%x)(t[2]:%x)(t[3]:%x)(t[4]:%x)\\n\" , PW_Start_Address , t[0],t[1],t[2],t[3],t[4]);\r\n    return BAD;\r\n  }\r\n\r\n  for ( a=40; a<60; a++)PW_l += t[a];\r\n\r\n  return GOOD;\r\n"]], "pred": {"ppl": 1.8977476358413696, "ppl_lower": 2.0706098079681396, "ppl/lowercase_ppl": -1.1360696428744639, "ppl/zlib": 0.0014899249491737104, "Min_5.0% Prob": 6.163740011953538, "Min_10.0% Prob": 4.590581528602108, "Min_20.0% Prob": 2.96522980594635, "Min_30.0% Prob": 2.0922290745409247, "Min_40.0% Prob": 1.5966834339797498, "Min_50.0% Prob": 1.2810164076177932, "Min_60.0% Prob": 1.0678531768077866}}
{"hexsha": "274676231fb81d16cf84d6e2c5deb24c9fef248b", "ext": "c", "lang": "C", "content": "static PyObject *unpack_py_lsa_QueryInfoPolicy2_args_out(struct lsa_QueryInfoPolicy2 *r)\n{\n\tPyObject *result;\n\tPyObject *py_info;\n\tif (*r->out.info == NULL) {\n\t\tpy_info = Py_None;\n\t\tPy_INCREF(py_info);\n\t} else {\n\t\tpy_info = py_import_lsa_PolicyInformation(*r->out.info, r->in.level, *r->out.info);\n\t\tif (py_info == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tresult = py_info;\n\tif (NT_STATUS_IS_ERR(r->out.result)) {\n\t\tPyErr_SetNTSTATUS(r->out.result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}", "item_id": 484, "repo": "zaion520/ATtomato", "file": "release/src-rt-6.x.4708/router/samba3/source3/librpc/gen_ndr/py_lsa.c", "last_update_at": "2019-02-15T03:30:28+00:00", "question_id": "274676231fb81d16cf84d6e2c5deb24c9fef248b_484", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *unpack_py_lsa_QueryInfoPolicy2_args_out(struct lsa_QueryInfoPolicy2 *r)\n{\n\tPyObject *result;\n\tPyObject *py_info;\n\tif (*r->out.info == NULL) {\n\t\tpy_info = Py_None;\n\t\tPy_INCREF(py_info);\n\t} else {\n\t\tpy_info = py_import_lsa_PolicyInformation(*r->out.info, r->in.level, *r->out.info);\n\t\tif (py_info == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tresult = py_info;\n\tif (NT_STATUS_IS_ERR(r->out.result)) {\n\t\tPyErr_SetNTSTATUS(r->out.result);\n\t\treturn NULL;\n\t}\n\treturn result;\n"]], "pred": {"ppl": 2.502094030380249, "ppl_lower": 3.2601137161254883, "ppl/lowercase_ppl": -1.2885465120349293, "ppl/zlib": 0.003541034723648498, "Min_5.0% Prob": 8.70627303123474, "Min_10.0% Prob": 6.326068480809529, "Min_20.0% Prob": 4.152783453464508, "Min_30.0% Prob": 2.9916794155724347, "Min_40.0% Prob": 2.2966797863735873, "Min_50.0% Prob": 1.8314159548380107, "Min_60.0% Prob": 1.5324146125458356}}
{"hexsha": "68a3e9ea7b63fb29c55c822ea658d8d0c6725f7d", "ext": "h", "lang": "C", "content": "interface QRViewController : UIViewController \n{\n\t//passwordmatrixAppDelegate *appDelegate;\n\n\t//IBOutlet UIBarButtonItem *doneButton;\n\tIBOutlet UIButton *doneButton;\n    IBOutlet UITextView *textView;\n    IBOutlet UIImageView *imageViewQR;\n\t//IBOutlet UIWebView *webView;\n\tid appDelegate;\n    IBOutlet UITextView *appTextView;\n    IBOutlet UIButton *appImageButton;\n    IBOutlet UIButton *appTextButton;\n}", "item_id": 0, "repo": "chriscomeau/PasswordGrid", "file": "source/QRViewController.h", "last_update_at": "2019-04-11T22:27:32+00:00", "question_id": "68a3e9ea7b63fb29c55c822ea658d8d0c6725f7d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface QRViewController : UIViewController \n{\n\t//passwordmatrixAppDelegate *appDelegate;\n\t//IBOutlet UIBarButtonItem *doneButton;\n\tIBOutlet UIButton *doneButton;\n    IBOutlet UITextView *textView;\n    IBOutlet UIImageView *imageViewQR;\n\t//IBOutlet UIWebView *webView;\n\tid appDelegate;\n    IBOutlet UITextView *appTextView;\n    IBOutlet UIButton *appImageButton;\n    IBOutlet UIButton *appTextButton;\n"]], "pred": {"ppl": 4.157828330993652, "ppl_lower": 3.8652443885803223, "ppl/lowercase_ppl": -0.9487941372915536, "ppl/zlib": 0.007829631330473626, "Min_5.0% Prob": 10.684694004058837, "Min_10.0% Prob": 7.9661100994456895, "Min_20.0% Prob": 5.34394968074301, "Min_30.0% Prob": 4.146013062340873, "Min_40.0% Prob": 3.3465815097727676, "Min_50.0% Prob": 2.7651557457649103, "Min_60.0% Prob": 2.3749351744140896}}
{"hexsha": "39f119040c3592cb629848f414f30ab4d3b2624e", "ext": "c", "lang": "C", "content": "static int\ncreate(void)\n{\n  frame802154_t f;\n  int len;\n  struct ieee802154_ies ies;\n  int ies_len;\n\n  prepare_outgoing_frame(&f);\n  len = frame802154_hdrlen(&f);\n\n  /* add padding bytes if necessary */\n  if((len + packetbuf_datalen() + LLSEC_OVERHEAD + CRC16_FRAMER_CHECKSUM_LEN) >= CONTIKIMAC_MIN_FRAME_LENGTH) {\n    ies_len = 0;\n  } else {\n    f.fcf.ie_list_present = 1;\n    ies.padding_bytes = MAX(CONTIKIMAC_MIN_FRAME_LENGTH\n        - len\n        - packetbuf_datalen()\n        - LLSEC_OVERHEAD\n        - CRC16_FRAMER_CHECKSUM_LEN\n        - 2 /* padding IE */\n        - 2 /* HT2 IE */, 0);\n\n    /* HT2 IE */\n    if(!packetbuf_hdralloc(2)) {\n      LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n      return FRAMER_FAILED;\n    }\n    if(frame80215e_create_ie_header_list_termination_2(packetbuf_hdrptr(), 2, &ies) == FRAMER_FAILED) {\n      LOG_ERR(\"frame80215e_create_ie_header_list_termination_2 failed\\n\");\n      return FRAMER_FAILED;\n    }\n\n    /* padding IE */\n    if(!packetbuf_hdralloc(2 + ies.padding_bytes)) {\n      LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n      return FRAMER_FAILED;\n    }\n    if(frame802154e_create_ie_padding(packetbuf_hdrptr(), 2 + ies.padding_bytes, &ies) == FRAMER_FAILED) {\n      LOG_ERR(\"frame802154e_create_ie_padding failed\\n\");\n      return FRAMER_FAILED;\n    }\n\n    ies_len = 2 + ies.padding_bytes + 2;\n  }\n\n  if(!packetbuf_hdralloc(len)) {\n    LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n    return FRAMER_FAILED;\n  }\n  frame802154_create(&f, packetbuf_hdrptr());\n\n  return len + ies_len;\n}", "item_id": 3, "repo": "kkrentz/contiki-ng", "file": "os/net/mac/contikimac/contikimac-framer-original.c", "last_update_at": "2019-07-19T12:21:59+00:00", "question_id": "39f119040c3592cb629848f414f30ab4d3b2624e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ncreate(void)\n{\n  frame802154_t f;\n  int len;\n  struct ieee802154_ies ies;\n  int ies_len;\n  prepare_outgoing_frame(&f);\n  len = frame802154_hdrlen(&f);\n  /* add padding bytes if necessary */\n  if((len + packetbuf_datalen() + LLSEC_OVERHEAD + CRC16_FRAMER_CHECKSUM_LEN) >= CONTIKIMAC_MIN_FRAME_LENGTH) {\n    ies_len = 0;\n  } else {\n    f.fcf.ie_list_present = 1;\n    ies.padding_bytes = MAX(CONTIKIMAC_MIN_FRAME_LENGTH\n        - len\n        - packetbuf_datalen()\n        - LLSEC_OVERHEAD\n        - CRC16_FRAMER_CHECKSUM_LEN\n        - 2 /* padding IE */\n        - 2 /* HT2 IE */, 0);\n    /* HT2 IE */\n    if(!packetbuf_hdralloc(2)) {\n      LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n      return FRAMER_FAILED;\n    }\n    if(frame80215e_create_ie_header_list_termination_2(packetbuf_hdrptr(), 2, &ies) == FRAMER_FAILED) {\n      LOG_ERR(\"frame80215e_create_ie_header_list_termination_2 failed\\n\");\n      return FRAMER_FAILED;\n    }\n    /* padding IE */\n    if(!packetbuf_hdralloc(2 + ies.padding_bytes)) {\n      LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n      return FRAMER_FAILED;\n    }\n    if(frame802154e_create_ie_padding(packetbuf_hdrptr(), 2 + ies.padding_bytes, &ies) == FRAMER_FAILED) {\n      LOG_ERR(\"frame802154e_create_ie_padding failed\\n\");\n      return FRAMER_FAILED;\n    }\n    ies_len = 2 + ies.padding_bytes + 2;\n  }\n  if(!packetbuf_hdralloc(len)) {\n    LOG_ERR(\"packetbuf_hdralloc failed\\n\");\n    return FRAMER_FAILED;\n  }\n  frame802154_create(&f, packetbuf_hdrptr());\n  return len + ies_len;\n"]], "pred": {"ppl": 1.9542750120162964, "ppl_lower": 2.1416242122650146, "ppl/lowercase_ppl": -1.1366307415836845, "ppl/zlib": 0.0012884986284935488, "Min_5.0% Prob": 6.668884407390248, "Min_10.0% Prob": 4.8279541116772275, "Min_20.0% Prob": 3.1148565357381646, "Min_30.0% Prob": 2.193425073920183, "Min_40.0% Prob": 1.671591069971053, "Min_50.0% Prob": 1.3384993050039846, "Min_60.0% Prob": 1.117515388964535}}
{"hexsha": "da37623915e6c840c38b57c72d9c4d1930b1dfda", "ext": "c", "lang": "C", "content": "void CLS_CursorModeSet(PmodCLS *InstancePtr, uint8_t setCursor, uint8_t setBlink) {\n\tuint8_t cursorOff[]\t\t\t  = {CLS_ESC, CLS_BRACKET, '0', CLS_CURSOR_MODE_CMD};\n\tuint8_t cursorOnBlinkOff[]    = {CLS_ESC, CLS_BRACKET, '1', CLS_CURSOR_MODE_CMD};\n\tuint8_t cursorBlinkOn[]       = {CLS_ESC, CLS_BRACKET, '2', CLS_CURSOR_MODE_CMD};\n\tif (setCursor==0)\t{\n\t\t//send the command for both display and blink off\n\t\tCLS_WriteSpi(InstancePtr, cursorOff, 4);\n\t}\n\telse if ((setCursor==1)&&(setBlink==0)) {\n\t\t//send the command for display on and blink off\n\t\tCLS_WriteSpi(InstancePtr, cursorOnBlinkOff, 4);\n\t}\n\t\telse {\n\t\t\t//send the command for display and blink on\n\t\t\tCLS_WriteSpi(InstancePtr, cursorBlinkOn, 4);\n\t\t}\n}", "item_id": 3, "repo": "dzlot96/pmod-acl", "file": "ip/Pmods/PmodCLS_v1_0/drivers/PmodCLS_v1_0/src/PmodCLS.c", "last_update_at": "2019-09-02T18:12:44+00:00", "question_id": "da37623915e6c840c38b57c72d9c4d1930b1dfda_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CLS_CursorModeSet(PmodCLS *InstancePtr, uint8_t setCursor, uint8_t setBlink) {\n\tuint8_t cursorOff[]\t\t\t  = {CLS_ESC, CLS_BRACKET, '0', CLS_CURSOR_MODE_CMD};\n\tuint8_t cursorOnBlinkOff[]    = {CLS_ESC, CLS_BRACKET, '1', CLS_CURSOR_MODE_CMD};\n\tuint8_t cursorBlinkOn[]       = {CLS_ESC, CLS_BRACKET, '2', CLS_CURSOR_MODE_CMD};\n\tif (setCursor==0)\t{\n\t\t//send the command for both display and blink off\n\t\tCLS_WriteSpi(InstancePtr, cursorOff, 4);\n\t}\n\telse if ((setCursor==1)&&(setBlink==0)) {\n\t\t//send the command for display on and blink off\n\t\tCLS_WriteSpi(InstancePtr, cursorOnBlinkOff, 4);\n\t}\n\t\telse {\n\t\t\t//send the command for display and blink on\n\t\t\tCLS_WriteSpi(InstancePtr, cursorBlinkOn, 4);\n\t\t}\n"]], "pred": {"ppl": 2.2569522857666016, "ppl_lower": 2.7244491577148438, "ppl/lowercase_ppl": -1.2312621070781888, "ppl/zlib": 0.002846207542155929, "Min_5.0% Prob": 6.899951585133871, "Min_10.0% Prob": 5.4437976806394515, "Min_20.0% Prob": 3.6798884137984245, "Min_30.0% Prob": 2.660148968619685, "Min_40.0% Prob": 2.0308116987467772, "Min_50.0% Prob": 1.6232614123310225, "Min_60.0% Prob": 1.3568914331406117}}
{"hexsha": "b43b42ae6e47e648f5126bb9c404d6d8efc4d973", "ext": "c", "lang": "C", "content": "void *\nsrp_swap_locked(struct srp *srp, void *nv)\n{\n\tvoid *ov;\n\n\t/*\n\t * this doesn't have to be as careful as the caller has already\n\t * prevented concurrent updates, eg. by holding the kernel lock.\n\t * can't be mixed with non-locked updates though.\n\t */\n\n\tov = srp->ref;\n\tsrp->ref = nv;\n\n\treturn (ov);\n}", "item_id": 1, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/kern/kern_srp.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "b43b42ae6e47e648f5126bb9c404d6d8efc4d973_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *\nsrp_swap_locked(struct srp *srp, void *nv)\n{\n\tvoid *ov;\n\t/*\n\t * this doesn't have to be as careful as the caller has already\n\t * prevented concurrent updates, eg. by holding the kernel lock.\n\t * can't be mixed with non-locked updates though.\n\t */\n\tov = srp->ref;\n\tsrp->ref = nv;\n\treturn (ov);\n"]], "pred": {"ppl": 6.116193771362305, "ppl_lower": 6.116193771362305, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008542169671037162, "Min_5.0% Prob": 8.723162841796874, "Min_10.0% Prob": 7.872722062197599, "Min_20.0% Prob": 6.491001649336382, "Min_30.0% Prob": 5.123208431636586, "Min_40.0% Prob": 4.259520883030362, "Min_50.0% Prob": 3.532295805320405, "Min_60.0% Prob": 3.014925203340895}}
{"hexsha": "ec1e02f200f56545ff66dbbc1fe0a7d9566f0ded", "ext": "c", "lang": "C", "content": "void\nuslcom_break(void *vsc, int portno, int onoff)\n{\n\tstruct uslcom_softc *sc = vsc;\n\tusb_device_request_t req;\n\tint brk = onoff ? USLCOM_BREAK_ON : USLCOM_BREAK_OFF;\t\n\n\treq.bmRequestType = USLCOM_WRITE;\n\treq.bRequest = USLCOM_BREAK;\n\tUSETW(req.wValue, brk);\n\tUSETW(req.wIndex, portno);\n\tUSETW(req.wLength, 0);\n\tusbd_do_request(sc->sc_udev, &req, NULL);\n}", "item_id": 8, "repo": "ArrogantWombatics/openbsd-src", "file": "sys/dev/usb/uslcom.c", "last_update_at": "2019-02-16T13:29:23+00:00", "question_id": "ec1e02f200f56545ff66dbbc1fe0a7d9566f0ded_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nuslcom_break(void *vsc, int portno, int onoff)\n{\n\tstruct uslcom_softc *sc = vsc;\n\tusb_device_request_t req;\n\tint brk = onoff ? USLCOM_BREAK_ON : USLCOM_BREAK_OFF;\t\n\treq.bmRequestType = USLCOM_WRITE;\n\treq.bRequest = USLCOM_BREAK;\n\tUSETW(req.wValue, brk);\n\tUSETW(req.wIndex, portno);\n\tUSETW(req.wLength, 0);\n\tusbd_do_request(sc->sc_udev, &req, NULL);\n"]], "pred": {"ppl": 2.344404935836792, "ppl_lower": 3.460420846939087, "ppl/lowercase_ppl": -1.4569767103974218, "ppl/zlib": 0.0035950700885698816, "Min_5.0% Prob": 8.589412093162537, "Min_10.0% Prob": 6.244083138073192, "Min_20.0% Prob": 3.955482894883436, "Min_30.0% Prob": 2.7960150316357613, "Min_40.0% Prob": 2.136539216976667, "Min_50.0% Prob": 1.7009953110553753, "Min_60.0% Prob": 1.42461633421212}}
{"hexsha": "78b5304f7135f1e9f890f1c7017d19b7526d4834", "ext": "c", "lang": "C", "content": "int\nwxread(int fd, void *buf, size_t len, int timeout)\n{\n    time_t expire;\n    ssize_t remaining;\n    ssize_t rc;\n    char *bufp;\n\n    if (timeout <= 0 || timeout > MAX_TIMEOUT) {\n        fprintf(stderr, \"wxread - timeout %d out of range\\n\", timeout);\n        return -1;\n    }\n\n    if (len == 0 || len > MAX_READ) {\n        fprintf(stderr, \"wxread - length %zu out of range\\n\", len);\n        return -1;\n    }\n\n    expire = time((time_t *)NULL) + timeout;\n\n    remaining = len;\n    bufp = (char *)buf;\n\n    while (remaining > 0 && timeout > 0) {\n        if (wxsettimeout(fd, timeout) == -1) {\n            fprintf(stderr, \"wxread - failed to set timeout\\n\");\n            return -1;\n        }\n        if ((rc = read(fd, bufp, remaining)) != remaining) {\n            if (rc == -1) {\n                perror(\"wxread - read\");\n                return -1;\n            }\n#ifdef DEBUG_WXREAD\n            fprintf(stderr, \"wxread - read got %zd expected %zd\\n\",\n                    rc, remaining);\n#endif /*DEBUG_WXREAD*/\n        }\n        remaining -= rc;\n        bufp += rc;\n        timeout = expire - time((time_t *)NULL);\n    }\n#ifdef DEBUG_WXREAD\n    dumpbuf(stderr, buf, len - remaining);\n#endif /*DEBUG_WXREAD*/\n\n    return (len - remaining);\n}", "item_id": 3, "repo": "michaelgalassi/fwx", "file": "support.c", "last_update_at": "2019-09-07T17:52:35+00:00", "question_id": "78b5304f7135f1e9f890f1c7017d19b7526d4834_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nwxread(int fd, void *buf, size_t len, int timeout)\n{\n    time_t expire;\n    ssize_t remaining;\n    ssize_t rc;\n    char *bufp;\n    if (timeout <= 0 || timeout > MAX_TIMEOUT) {\n        fprintf(stderr, \"wxread - timeout %d out of range\\n\", timeout);\n        return -1;\n    }\n    if (len == 0 || len > MAX_READ) {\n        fprintf(stderr, \"wxread - length %zu out of range\\n\", len);\n        return -1;\n    }\n    expire = time((time_t *)NULL) + timeout;\n    remaining = len;\n    bufp = (char *)buf;\n    while (remaining > 0 && timeout > 0) {\n        if (wxsettimeout(fd, timeout) == -1) {\n            fprintf(stderr, \"wxread - failed to set timeout\\n\");\n            return -1;\n        }\n        if ((rc = read(fd, bufp, remaining)) != remaining) {\n            if (rc == -1) {\n                perror(\"wxread - read\");\n                return -1;\n            }\n#ifdef DEBUG_WXREAD\n            fprintf(stderr, \"wxread - read got %zd expected %zd\\n\",\n                    rc, remaining);\n#endif /*DEBUG_WXREAD*/\n        }\n        remaining -= rc;\n        bufp += rc;\n        timeout = expire - time((time_t *)NULL);\n    }\n#ifdef DEBUG_WXREAD\n    dumpbuf(stderr, buf, len - remaining);\n#endif /*DEBUG_WXREAD*/\n    return (len - remaining);\n"]], "pred": {"ppl": 1.8671247959136963, "ppl_lower": 1.9572079181671143, "ppl/lowercase_ppl": -1.0754632334687622, "ppl/zlib": 0.0013399135307794062, "Min_5.0% Prob": 5.940868207386562, "Min_10.0% Prob": 4.257066556385586, "Min_20.0% Prob": 2.7778179982129267, "Min_30.0% Prob": 2.0024514817632735, "Min_40.0% Prob": 1.5488648385686032, "Min_50.0% Prob": 1.2466829976880214, "Min_60.0% Prob": 1.0399253706127638}}
{"hexsha": "81b87fd3f98b6d69399aabbef827ce9c3a6bf5e0", "ext": "c", "lang": "C", "content": "static int decrypt_content_enc_key(s_recipient_info *p_recipient_info, ak_skey p_kek, ak_skey p_cek) {\n    int error;\n    struct buffer encrypted_cek;\n    struct buffer encrypted_cek_mac;\n\n    if (p_recipient_info->m_type != KEKRI)\n        return ak_error_message(ak_error_invalid_value, __func__, \"only kekri support\");\n\n    s_kekri *p_kekri = p_recipient_info->m_ri.mp_kekri;\n\n    /* \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u043a\u043b\u044e\u0447\u0430 KEK */\n    // \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043a\u043b\u044e\u0447\u0430 \u0438\u0437 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b KeyManagementInfo \u0438 KEKRI\n    if (memcmp(p_kekri->m_key_identifire.mp_value, p_kek->number.data, p_kek->number.size) != 0)\n        return ak_error_message(ak_error_invalid_value, __func__, \"id from kekri doesn't match id from key management info\");\n\n    if ((error = pkcs_15_parse_enc_key_plus_mac_seq(p_kekri->m_encrypted_key, &encrypted_cek, &encrypted_cek_mac)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with parsing CEK\");\n\n    /*TODO: \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439 \u0434\u043b\u044f \u0410\u043b\u0435\u043a\u0441\u0435\u044f \u042e\u0440\u044c\u0435\u0432\u0438\u0447\u0430: \u0437\u0434\u0435\u0441\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u044b\u0437\u0432\u0430\u0442\u044c\n            \u0444\u0443\u043d\u0446\u0438\u044e \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043b\u044e\u0447\u0430 CEK \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u044c \u0438\u043c\u0438\u0442\u043e\u0432\u0441\u0442\u0430\u0432\u043a\u0443.\n            \u0414\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 encrypted_cek. */\n\n    memcpy((ak_byte *) p_cek->key.data, (ak_byte *) encrypted_cek.data, encrypted_cek.size / 2);\n    memcpy((ak_byte *) p_cek->mask.data, (ak_byte *) encrypted_cek.data + encrypted_cek.size / 2, encrypted_cek.size / 2);\n\n    /* \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433\u0438 \u043d\u0430\u043b\u0438\u0447\u0438\u044f \u043a\u043b\u044e\u0447\u0430 \u0438 \u043c\u0430\u0441\u043a\u0438 */\n    p_cek->flags |= skey_flag_set_key | skey_flag_set_mask;\n\n    /* \u041f\u0435\u0440\u0435\u043c\u0430\u0441\u043a\u0438\u0440\u0443\u0435\u043c \u043a\u043b\u044e\u0447 */\n    if ((error = p_cek->set_mask(p_cek)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with key remasking\");\n\n    /* \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u043a\u043b\u044e\u0447\u0430 */\n    if ((error = p_cek->set_icode(p_cek)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with setting icode\");\n\n    /* \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433 \u043d\u0430\u043b\u0438\u0447\u0438\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u044b */\n    p_cek->flags |= skey_flag_set_icode;\n\n    return ak_error_ok;\n}", "item_id": 17, "repo": "anton-sakharov/asn_handler", "file": "source/pkcs_15_cryptographic_token/ak_pkcs_15_token_manager.c", "last_update_at": "2019-07-08T08:47:18+00:00", "question_id": "81b87fd3f98b6d69399aabbef827ce9c3a6bf5e0_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int decrypt_content_enc_key(s_recipient_info *p_recipient_info, ak_skey p_kek, ak_skey p_cek) {\n    int error;\n    struct buffer encrypted_cek;\n    struct buffer encrypted_cek_mac;\n    if (p_recipient_info->m_type != KEKRI)\n        return ak_error_message(ak_error_invalid_value, __func__, \"only kekri support\");\n    s_kekri *p_kekri = p_recipient_info->m_ri.mp_kekri;\n    /* \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u043a\u043b\u044e\u0447\u0430 KEK */\n    // \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043a\u043b\u044e\u0447\u0430 \u0438\u0437 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b KeyManagementInfo \u0438 KEKRI\n    if (memcmp(p_kekri->m_key_identifire.mp_value, p_kek->number.data, p_kek->number.size) != 0)\n        return ak_error_message(ak_error_invalid_value, __func__, \"id from kekri doesn't match id from key management info\");\n    if ((error = pkcs_15_parse_enc_key_plus_mac_seq(p_kekri->m_encrypted_key, &encrypted_cek, &encrypted_cek_mac)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with parsing CEK\");\n    /*TODO: \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439 \u0434\u043b\u044f \u0410\u043b\u0435\u043a\u0441\u0435\u044f \u042e\u0440\u044c\u0435\u0432\u0438\u0447\u0430: \u0437\u0434\u0435\u0441\u044c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u044b\u0437\u0432\u0430\u0442\u044c\n            \u0444\u0443\u043d\u0446\u0438\u044e \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043b\u044e\u0447\u0430 CEK \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u044c \u0438\u043c\u0438\u0442\u043e\u0432\u0441\u0442\u0430\u0432\u043a\u0443.\n            \u0414\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 encrypted_cek. */\n    memcpy((ak_byte *) p_cek->key.data, (ak_byte *) encrypted_cek.data, encrypted_cek.size / 2);\n    memcpy((ak_byte *) p_cek->mask.data, (ak_byte *) encrypted_cek.data + encrypted_cek.size / 2, encrypted_cek.size / 2);\n    /* \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433\u0438 \u043d\u0430\u043b\u0438\u0447\u0438\u044f \u043a\u043b\u044e\u0447\u0430 \u0438 \u043c\u0430\u0441\u043a\u0438 */\n    p_cek->flags |= skey_flag_set_key | skey_flag_set_mask;\n    /* \u041f\u0435\u0440\u0435\u043c\u0430\u0441\u043a\u0438\u0440\u0443\u0435\u043c \u043a\u043b\u044e\u0447 */\n    if ((error = p_cek->set_mask(p_cek)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with key remasking\");\n    /* \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u043a\u043b\u044e\u0447\u0430 */\n    if ((error = p_cek->set_icode(p_cek)) != ak_error_ok)\n        return ak_error_message(error, __func__, \"problem with setting icode\");\n    /* \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433 \u043d\u0430\u043b\u0438\u0447\u0438\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u044b */\n    p_cek->flags |= skey_flag_set_icode;\n    return ak_error_ok;\n"]], "pred": {"ppl": 2.479038953781128, "ppl_lower": 2.5551443099975586, "ppl/lowercase_ppl": -1.0333062055634636, "ppl/zlib": 0.00101324884646819, "Min_5.0% Prob": 7.249214812328941, "Min_10.0% Prob": 5.714789873593814, "Min_20.0% Prob": 3.9112978554391242, "Min_30.0% Prob": 2.886277584544508, "Min_40.0% Prob": 2.239375611966096, "Min_50.0% Prob": 1.8118738676348962, "Min_60.0% Prob": 1.514226029476163}}
{"hexsha": "f6e31f9bf4cb3d9505c19c675541b276aedd46dc", "ext": "c", "lang": "C", "content": "ANSC_STATUS\nBmc2ReqcoInitialize\n    (\n        ANSC_HANDLE                 hThisObject\n    )\n{\n    PBMC2_REQ_CONTROLLER_OBJECT     pMyObject    = (PBMC2_REQ_CONTROLLER_OBJECT)hThisObject;\n    ULONG                           i            = 0;\n\n    /*\n     * Until you have to simulate C++ object-oriented programming style with standard C, you don't\n     * appreciate all the nice little things come with C++ language and all the dirty works that\n     * have been done by the C++ compilers. Member initialization is one of these things. While in\n     * C++ you don't have to initialize all the member fields inherited from the base class since\n     * the compiler will do it for you, such is not the case with C.\n     */\n    AnscCoInitialize((ANSC_HANDLE)pMyObject);\n\n    /*\n     * Although we have initialized some of the member fields in the \"create\" member function, we\n     * repeat the work here for completeness. While this simulation approach is pretty stupid from\n     * a C++/Java programmer perspective, it's the best we can get for universal embedded network\n     * programming. Before we develop our own operating system (don't expect that to happen any\n     * time soon), this is the way things gonna be.\n     */\n    pMyObject->Oid                  = BMC2_REQ_CONTROLLER_OID;\n    pMyObject->Create               = Bmc2ReqcoCreate;\n    pMyObject->Remove               = Bmc2ReqcoRemove;\n    pMyObject->EnrollObjects        = Bmc2ReqcoEnrollObjects;\n    pMyObject->Initialize           = Bmc2ReqcoInitialize;\n\n    pMyObject->hBmc2ComDomain       = (ANSC_HANDLE)NULL;\n    pMyObject->hBmc2EnvController   = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandRequest      = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandReply        = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandProperty     = (ANSC_HANDLE)NULL;\n    pMyObject->CliArgumentCount     = 0;\n    pMyObject->bAborted             = FALSE;\n    pMyObject->bActive              = FALSE;\n\n    pMyObject->hSlapContainerReq    = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Command     = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Input       = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Output      = (ANSC_HANDLE)NULL;\n\n    pMyObject->GetBmc2PecIf         = Bmc2ReqcoGetBmc2PecIf;\n    pMyObject->GetBmc2ComDomain     = Bmc2ReqcoGetBmc2ComDomain;\n    pMyObject->SetBmc2ComDomain     = Bmc2ReqcoSetBmc2ComDomain;\n    pMyObject->GetBmc2EnvController = Bmc2ReqcoGetBmc2EnvController;\n    pMyObject->SetBmc2EnvController = Bmc2ReqcoSetBmc2EnvController;\n    pMyObject->GetCommandRequest    = Bmc2ReqcoGetCommandRequest;\n    pMyObject->SetCommandRequest    = Bmc2ReqcoSetCommandRequest;\n    pMyObject->GetCommandReply      = Bmc2ReqcoGetCommandReply;\n    pMyObject->SetCommandReply      = Bmc2ReqcoSetCommandReply;\n    pMyObject->GetCommandProperty   = Bmc2ReqcoGetCommandProperty;\n    pMyObject->SetCommandProperty   = Bmc2ReqcoSetCommandProperty;\n    pMyObject->GetCliArgumentCount  = Bmc2ReqcoGetCliArgumentCount;\n    pMyObject->GetCliArgument       = Bmc2ReqcoGetCliArgument;\n    pMyObject->AddCliArgument       = Bmc2ReqcoAddCliArgument;\n    pMyObject->RemoveCliArguments   = Bmc2ReqcoRemoveCliArguments;\n    pMyObject->Abort                = Bmc2ReqcoAbort;\n    pMyObject->Reset                = Bmc2ReqcoReset;\n\n    pMyObject->Engage               = Bmc2ReqcoEngage;\n    pMyObject->Cancel               = Bmc2ReqcoCancel;\n    pMyObject->SetupEnv             = Bmc2ReqcoSetupEnv;\n    pMyObject->CloseEnv             = Bmc2ReqcoCloseEnv;\n    pMyObject->AsyncJobTask         = Bmc2ReqcoAsyncJobTask;\n\n    pMyObject->AddControlCommand    = Bmc2ReqcoAddControlCommand;\n    pMyObject->AddControlCommand2   = Bmc2ReqcoAddControlCommand2;\n    pMyObject->PopControlCommand    = Bmc2ReqcoPopControlCommand;\n    pMyObject->ClearCcoQueue        = Bmc2ReqcoClearCcoQueue;\n    pMyObject->GetObjReference      = Bmc2ReqcoGetObjReference;\n    pMyObject->AddObjReference      = Bmc2ReqcoAddObjReference;\n    pMyObject->AddObjReference2     = Bmc2ReqcoAddObjReference2;\n    pMyObject->DelObjReference      = Bmc2ReqcoDelObjReference;\n    pMyObject->ClearOroTable        = Bmc2ReqcoClearOroTable;\n\n    pMyObject->DispatchCommands     = Bmc2ReqcoDispatchCommands;\n    pMyObject->DoReturn             = Bmc2ReqcoDoReturn;\n    pMyObject->DoTransfer           = Bmc2ReqcoDoTransfer;\n    pMyObject->DoExecute            = Bmc2ReqcoDoExecute;\n\n    pMyObject->PecGetCommand        = Bmc2ReqcoPecGetCommand;\n    pMyObject->PecGetInput          = Bmc2ReqcoPecGetInput;\n    pMyObject->PecGetOutput         = Bmc2ReqcoPecGetOutput;\n    pMyObject->PecGetDomain         = Bmc2ReqcoPecGetDomain;\n    pMyObject->PecGetTerminal       = Bmc2ReqcoPecGetTerminal;\n    pMyObject->PecGetApplication    = Bmc2ReqcoPecGetApplication;\n    pMyObject->PecGetServer         = Bmc2ReqcoPecGetServer;\n\n    pMyObject->PecGetBmc2Object     = Bmc2ReqcoPecGetBmc2Object;\n    pMyObject->PecGetCookedPage     = Bmc2ReqcoPecGetCookedPage;\n    pMyObject->PecRetCookedPage     = Bmc2ReqcoPecRetCookedPage;\n    pMyObject->PecInvokeObject      = Bmc2ReqcoPecInvokeObject;\n\n    for ( i = 0; i < BMC2_REQCO_MAX_ARGUMENT_NUMBER; i++ )\n    {\n        pMyObject->CliArgumentArray[i] = NULL;\n    }\n\n    AnscQueueInitializeHeader(&pMyObject->CcoQueue    );\n    AnscInitializeLock       (&pMyObject->CcoQueueLock);\n\n    for ( i = 0; i < BMC2_REQCO_ORO_TABLE_SIZE; i++ )\n    {\n        AnscQueueInitializeHeader(&pMyObject->OroTable[i]);\n    }\n    AnscInitializeLock(&pMyObject->OroTableLock);\n\n    return  ANSC_STATUS_SUCCESS;\n}", "item_id": 3, "repo": "lgirdk/ccsp-common-library", "file": "source/cosa/package/bmc2/components/Bmc2ReqController/bmc2_reqco_base.c", "last_update_at": "2019-12-20T07:31:39+00:00", "question_id": "f6e31f9bf4cb3d9505c19c675541b276aedd46dc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ANSC_STATUS\nBmc2ReqcoInitialize\n    (\n        ANSC_HANDLE                 hThisObject\n    )\n{\n    PBMC2_REQ_CONTROLLER_OBJECT     pMyObject    = (PBMC2_REQ_CONTROLLER_OBJECT)hThisObject;\n    ULONG                           i            = 0;\n    /*\n     * Until you have to simulate C++ object-oriented programming style with standard C, you don't\n     * appreciate all the nice little things come with C++ language and all the dirty works that\n     * have been done by the C++ compilers. Member initialization is one of these things. While in\n     * C++ you don't have to initialize all the member fields inherited from the base class since\n     * the compiler will do it for you, such is not the case with C.\n     */\n    AnscCoInitialize((ANSC_HANDLE)pMyObject);\n    /*\n     * Although we have initialized some of the member fields in the \"create\" member function, we\n     * repeat the work here for completeness. While this simulation approach is pretty stupid from\n     * a C++/Java programmer perspective, it's the best we can get for universal embedded network\n     * programming. Before we develop our own operating system (don't expect that to happen any\n     * time soon), this is the way things gonna be.\n     */\n    pMyObject->Oid                  = BMC2_REQ_CONTROLLER_OID;\n    pMyObject->Create               = Bmc2ReqcoCreate;\n    pMyObject->Remove               = Bmc2ReqcoRemove;\n    pMyObject->EnrollObjects        = Bmc2ReqcoEnrollObjects;\n    pMyObject->Initialize           = Bmc2ReqcoInitialize;\n    pMyObject->hBmc2ComDomain       = (ANSC_HANDLE)NULL;\n    pMyObject->hBmc2EnvController   = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandRequest      = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandReply        = (ANSC_HANDLE)NULL;\n    pMyObject->hCommandProperty     = (ANSC_HANDLE)NULL;\n    pMyObject->CliArgumentCount     = 0;\n    pMyObject->bAborted             = FALSE;\n    pMyObject->bActive              = FALSE;\n    pMyObject->hSlapContainerReq    = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Command     = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Input       = (ANSC_HANDLE)NULL;\n    pMyObject->hSlapBmc2Output      = (ANSC_HANDLE)NULL;\n    pMyObject->GetBmc2PecIf         = Bmc2ReqcoGetBmc2PecIf;\n    pMyObject->GetBmc2ComDomain     = Bmc2ReqcoGetBmc2ComDomain;\n    pMyObject->SetBmc2ComDomain     = Bmc2ReqcoSetBmc2ComDomain;\n    pMyObject->GetBmc2EnvController = Bmc2ReqcoGetBmc2EnvController;\n    pMyObject->SetBmc2EnvController = Bmc2ReqcoSetBmc2EnvController;\n    pMyObject->GetCommandRequest    = Bmc2ReqcoGetCommandRequest;\n    pMyObject->SetCommandRequest    = Bmc2ReqcoSetCommandRequest;\n    pMyObject->GetCommandReply      = Bmc2ReqcoGetCommandReply;\n    pMyObject->SetCommandReply      = Bmc2ReqcoSetCommandReply;\n    pMyObject->GetCommandProperty   = Bmc2ReqcoGetCommandProperty;\n    pMyObject->SetCommandProperty   = Bmc2ReqcoSetCommandProperty;\n    pMyObject->GetCliArgumentCount  = Bmc2ReqcoGetCliArgumentCount;\n    pMyObject->GetCliArgument       = Bmc2ReqcoGetCliArgument;\n    pMyObject->AddCliArgument       = Bmc2ReqcoAddCliArgument;\n    pMyObject->RemoveCliArguments   = Bmc2ReqcoRemoveCliArguments;\n    pMyObject->Abort                = Bmc2ReqcoAbort;\n    pMyObject->Reset                = Bmc2ReqcoReset;\n    pMyObject->Engage               = Bmc2ReqcoEngage;\n    pMyObject->Cancel               = Bmc2ReqcoCancel;\n    pMyObject->SetupEnv             = Bmc2ReqcoSetupEnv;\n    pMyObject->CloseEnv             = Bmc2ReqcoCloseEnv;\n    pMyObject->AsyncJobTask         = Bmc2ReqcoAsyncJobTask;\n    pMyObject->AddControlCommand    = Bmc2ReqcoAddControlCommand;\n    pMyObject->AddControlCommand2   = Bmc2ReqcoAddControlCommand2;\n    pMyObject->PopControlCommand    = Bmc2ReqcoPopControlCommand;\n    pMyObject->ClearCcoQueue        = Bmc2ReqcoClearCcoQueue;\n    pMyObject->GetObjReference      = Bmc2ReqcoGetObjReference;\n    pMyObject->AddObjReference      = Bmc2ReqcoAddObjReference;\n    pMyObject->AddObjReference2     = Bmc2ReqcoAddObjReference2;\n    pMyObject->DelObjReference      = Bmc2ReqcoDelObjReference;\n    pMyObject->ClearOroTable        = Bmc2ReqcoClearOroTable;\n    pMyObject->DispatchCommands     = Bmc2ReqcoDispatchCommands;\n    pMyObject->DoReturn             = Bmc2ReqcoDoReturn;\n    pMyObject->DoTransfer           = Bmc2ReqcoDoTransfer;\n    pMyObject->DoExecute            = Bmc2ReqcoDoExecute;\n    pMyObject->PecGetCommand        = Bmc2ReqcoPecGetCommand;\n    pMyObject->PecGetInput          = Bmc2ReqcoPecGetInput;\n    pMyObject->PecGetOutput         = Bmc2ReqcoPecGetOutput;\n    pMyObject->PecGetDomain         = Bmc2ReqcoPecGetDomain;\n    pMyObject->PecGetTerminal       = Bmc2ReqcoPecGetTerminal;\n    pMyObject->PecGetApplication    = Bmc2ReqcoPecGetApplication;\n    pMyObject->PecGetServer         = Bmc2ReqcoPecGetServer;\n    pMyObject->PecGetBmc2Object     = Bmc2ReqcoPecGetBmc2Object;\n    pMyObject->PecGetCookedPage     = Bmc2ReqcoPecGetCookedPage;\n    pMyObject->PecRetCookedPage     = Bmc2ReqcoPecRetCookedPage;\n    pMyObject->PecInvokeObject      = Bmc2ReqcoPecInvokeObject;\n    for ( i = 0; i < BMC2_REQCO_MAX_ARGUMENT_NUMBER; i++ )\n    {\n        pMyObject->CliArgumentArray[i] = NULL;\n    }\n    AnscQueueInitializeHeader(&pMyObject->CcoQueue    );\n    AnscInitializeLock       (&pMyObject->CcoQueueLock);\n    for ( i = 0; i < BMC2_REQCO_ORO_TABLE_SIZE; i++ )\n    {\n        AnscQueueInitializeHeader(&pMyObject->OroTable[i]);\n    }\n    AnscInitializeLock(&pMyObject->OroTableLock);\n    return  ANSC_STATUS_SUCCESS;\n"]], "pred": {"ppl": 1.1945627927780151, "ppl_lower": 1.741834044456482, "ppl/lowercase_ppl": -3.1214861724815717, "ppl/zlib": 0.00012467058531199376, "Min_5.0% Prob": 3.1047431616222156, "Min_10.0% Prob": 1.733039303883618, "Min_20.0% Prob": 0.889508131503438, "Min_30.0% Prob": 0.5940883811692603, "Min_40.0% Prob": 0.4446211548740998, "Min_50.0% Prob": 0.35589618437048726, "Min_60.0% Prob": 0.2966841698856205}}
{"hexsha": "5d1269d95ff9017dd7f2207131cab4f20e8d143c", "ext": "c", "lang": "C", "content": "static VALUE\npgconn_s_quote_connstr(VALUE string)\n{\n\tchar *str,*ptr;\n\tint i,j=0,len;\n\tVALUE result;\n\n\tCheck_Type(string, T_STRING);\n\n\tptr = RSTRING_PTR(string);\n\tlen = RSTRING_LEN(string);\n\tstr = ALLOC_N(char, len * 2 + 2 + 1);\n\tstr[j++] = '\\'';\n\tfor(i = 0; i < len; i++) {\n\t\tif(ptr[i] == '\\'' || ptr[i] == '\\\\')\n\t\t\tstr[j++] = '\\\\';\n\t\tstr[j++] = ptr[i];\t\n\t}\n\tstr[j++] = '\\'';\n\tresult = rb_str_new(str, j);\n\txfree(str);\n\treturn result;\n}", "item_id": 0, "repo": "jrtoocool/geo_ushelf", "file": "rmagick/ruby/1.8/gems/pg-0.9.0/ext/pg.c", "last_update_at": "2019-04-28T11:28:36+00:00", "question_id": "5d1269d95ff9017dd7f2207131cab4f20e8d143c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static VALUE\npgconn_s_quote_connstr(VALUE string)\n{\n\tchar *str,*ptr;\n\tint i,j=0,len;\n\tVALUE result;\n\tCheck_Type(string, T_STRING);\n\tptr = RSTRING_PTR(string);\n\tlen = RSTRING_LEN(string);\n\tstr = ALLOC_N(char, len * 2 + 2 + 1);\n\tstr[j++] = '\\'';\n\tfor(i = 0; i < len; i++) {\n\t\tif(ptr[i] == '\\'' || ptr[i] == '\\\\')\n\t\t\tstr[j++] = '\\\\';\n\t\tstr[j++] = ptr[i];\t\n\t}\n\tstr[j++] = '\\'';\n\tresult = rb_str_new(str, j);\n\txfree(str);\n\treturn result;\n"]], "pred": {"ppl": 1.8943355083465576, "ppl_lower": 2.5313448905944824, "ppl/lowercase_ppl": -1.4537440625065, "ppl/zlib": 0.002410823101186336, "Min_5.0% Prob": 6.601595943624323, "Min_10.0% Prob": 4.770293208685788, "Min_20.0% Prob": 2.9457563053477895, "Min_30.0% Prob": 2.0994158935817806, "Min_40.0% Prob": 1.5978124244561926, "Min_50.0% Prob": 1.2735079319660996, "Min_60.0% Prob": 1.0652499905458295}}
{"hexsha": "9446960ac742914f3c912eb15a2870bb4dc42432", "ext": "c", "lang": "C", "content": "static void bpa10x_disconnect(struct usb_interface *intf)\n{\n\tstruct bpa10x_data *data = usb_get_intfdata(intf);\n\tstruct hci_dev *hdev = data->hdev;\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (!hdev)\n\t\treturn;\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (hci_unregister_dev(hdev) < 0)\n\t\tBT_ERR(\"Can't unregister HCI device %s\", hdev->name);\n\n\thci_free_dev(hdev);\n}", "item_id": 12, "repo": "ut-osa/syncchar", "file": "linux-2.6.16-unmod/drivers/bluetooth/bpa10x.c", "last_update_at": "2019-05-14T16:36:45+00:00", "question_id": "9446960ac742914f3c912eb15a2870bb4dc42432_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void bpa10x_disconnect(struct usb_interface *intf)\n{\n\tstruct bpa10x_data *data = usb_get_intfdata(intf);\n\tstruct hci_dev *hdev = data->hdev;\n\tBT_DBG(\"intf %p\", intf);\n\tif (!hdev)\n\t\treturn;\n\tusb_set_intfdata(intf, NULL);\n\tif (hci_unregister_dev(hdev) < 0)\n\t\tBT_ERR(\"Can't unregister HCI device %s\", hdev->name);\n\thci_free_dev(hdev);\n"]], "pred": {"ppl": 1.5539880990982056, "ppl_lower": 1.896775484085083, "ppl/lowercase_ppl": -1.4521769882729203, "ppl/zlib": 0.0019505512994609216, "Min_5.0% Prob": 5.191627502441406, "Min_10.0% Prob": 3.5003801956772804, "Min_20.0% Prob": 2.1224896600752166, "Min_30.0% Prob": 1.4657634161412716, "Min_40.0% Prob": 1.1025655869561344, "Min_50.0% Prob": 0.8810674499365545, "Min_60.0% Prob": 0.7404353652033023}}
{"hexsha": "9ac1e5d407beb686653279c903d1827d44fcbe86", "ext": "c", "lang": "C", "content": "static void\nia64_libunwind_frame_prev_register (struct frame_info *next_frame,\n\t\t\t\t    void **this_cache,\n\t\t\t\t    int regnum, int *optimizedp,\n\t\t\t\t    enum lval_type *lvalp, CORE_ADDR *addrp,\n\t\t\t\t    int *realnump, void *valuep)\n{\n  int reg = regnum;\n\n  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)\n    reg = IA64_PR_REGNUM;\n  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)\n    reg = IA64_UNAT_REGNUM;\n\n  /* Let libunwind do most of the work.  */\n  libunwind_frame_prev_register (next_frame, this_cache, reg,\n\t\t\t\t optimizedp, lvalp, addrp, realnump, valuep);\n\n  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)\n    {\n      ULONGEST prN_val;\n\n      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)\n\t{\n\t  int rrb_pr = 0;\n\t  ULONGEST cfm;\n\t  unsigned char buf[MAX_REGISTER_SIZE];\n\n\t  /* Fetch predicate register rename base from current frame\n\t     marker for this frame.  */\n\t  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);\n\t  cfm = extract_unsigned_integer (buf, 8); \n\t  rrb_pr = (cfm >> 32) & 0x3f;\n\t  \n\t  /* Adjust the register number to account for register rotation.  */\n\t  regnum = VP16_REGNUM \n\t    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n\t}\n      prN_val = extract_bit_field ((unsigned char *) valuep,\n\t\t\t\t   regnum - VP0_REGNUM, 1);\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);\n    }\n  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)\n    {\n      ULONGEST unatN_val;\n\n      unatN_val = extract_bit_field ((unsigned char *) valuep,\n                                   regnum - IA64_NAT0_REGNUM, 1);\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), \n                              unatN_val);\n    }\n  else if (regnum == IA64_BSP_REGNUM)\n    {\n      char cfm_valuep[MAX_REGISTER_SIZE];\n      int  cfm_optim;\n      int  cfm_realnum;\n      enum lval_type cfm_lval;\n      CORE_ADDR cfm_addr;\n      CORE_ADDR bsp, prev_cfm, prev_bsp;\n\n      /* We want to calculate the previous bsp as the end of the previous register stack frame.\n\t This corresponds to what the hardware bsp register will be if we pop the frame\n\t back which is why we might have been called.  We know that libunwind will pass us back\n\t the beginning of the current frame so we should just add sof to it. */\n      prev_bsp = extract_unsigned_integer (valuep, 8);\n      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,\n\t\t\t\t     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);\n      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);\n      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));\n\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), \n\t\t\t      prev_bsp);\n    }\n\n  if (gdbarch_debug >= 1)\n    fprintf_unfiltered (gdb_stdlog,\n\t\t\t\"libunwind prev register <%s> is 0x%s\\n\",\n\t\t\t(((unsigned) regnum <= IA64_NAT127_REGNUM)\n\t\t\t ? ia64_register_names[regnum] : \"r??\"), \n\t\t\tpaddr_nz (extract_unsigned_integer (valuep, 8)));\n}", "item_id": 34, "repo": "dplbsd/soc2013", "file": "head/contrib/gdb/gdb/ia64-tdep.c", "last_update_at": "2019-10-09T17:34:14+00:00", "question_id": "9ac1e5d407beb686653279c903d1827d44fcbe86_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nia64_libunwind_frame_prev_register (struct frame_info *next_frame,\n\t\t\t\t    void **this_cache,\n\t\t\t\t    int regnum, int *optimizedp,\n\t\t\t\t    enum lval_type *lvalp, CORE_ADDR *addrp,\n\t\t\t\t    int *realnump, void *valuep)\n{\n  int reg = regnum;\n  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)\n    reg = IA64_PR_REGNUM;\n  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)\n    reg = IA64_UNAT_REGNUM;\n  /* Let libunwind do most of the work.  */\n  libunwind_frame_prev_register (next_frame, this_cache, reg,\n\t\t\t\t optimizedp, lvalp, addrp, realnump, valuep);\n  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)\n    {\n      ULONGEST prN_val;\n      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)\n\t{\n\t  int rrb_pr = 0;\n\t  ULONGEST cfm;\n\t  unsigned char buf[MAX_REGISTER_SIZE];\n\t  /* Fetch predicate register rename base from current frame\n\t     marker for this frame.  */\n\t  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);\n\t  cfm = extract_unsigned_integer (buf, 8); \n\t  rrb_pr = (cfm >> 32) & 0x3f;\n\t  \n\t  /* Adjust the register number to account for register rotation.  */\n\t  regnum = VP16_REGNUM \n\t    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n\t}\n      prN_val = extract_bit_field ((unsigned char *) valuep,\n\t\t\t\t   regnum - VP0_REGNUM, 1);\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);\n    }\n  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)\n    {\n      ULONGEST unatN_val;\n      unatN_val = extract_bit_field ((unsigned char *) valuep,\n                                   regnum - IA64_NAT0_REGNUM, 1);\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), \n                              unatN_val);\n    }\n  else if (regnum == IA64_BSP_REGNUM)\n    {\n      char cfm_valuep[MAX_REGISTER_SIZE];\n      int  cfm_optim;\n      int  cfm_realnum;\n      enum lval_type cfm_lval;\n      CORE_ADDR cfm_addr;\n      CORE_ADDR bsp, prev_cfm, prev_bsp;\n      /* We want to calculate the previous bsp as the end of the previous register stack frame.\n\t This corresponds to what the hardware bsp register will be if we pop the frame\n\t back which is why we might have been called.  We know that libunwind will pass us back\n\t the beginning of the current frame so we should just add sof to it. */\n      prev_bsp = extract_unsigned_integer (valuep, 8);\n      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,\n\t\t\t\t     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);\n      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);\n      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));\n      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), \n\t\t\t      prev_bsp);\n    }\n  if (gdbarch_debug >= 1)\n    fprintf_unfiltered (gdb_stdlog,\n\t\t\t\"libunwind prev register <%s> is 0x%s\\n\",\n\t\t\t(((unsigned) regnum <= IA64_NAT127_REGNUM)\n\t\t\t ? ia64_register_names[regnum] : \"r??\"), \n\t\t\tpaddr_nz (extract_unsigned_integer (valuep, 8)));\n"]], "pred": {"ppl": 1.9876583814620972, "ppl_lower": 2.1435725688934326, "ppl/lowercase_ppl": -1.1099291233994684, "ppl/zlib": 0.0006372516263054992, "Min_5.0% Prob": 6.545577189501594, "Min_10.0% Prob": 4.872746364743102, "Min_20.0% Prob": 3.160924892507347, "Min_30.0% Prob": 2.2506059874701343, "Min_40.0% Prob": 1.7088467490775079, "Min_50.0% Prob": 1.3733991350406332, "Min_60.0% Prob": 1.1460297873675167}}
{"hexsha": "ee34998d0f0af6a9dcf37da553c21af3a6f3094b", "ext": "h", "lang": "C", "content": "interface MSResizeSheet : CHSheetController\n{\n    BOOL _hasDoneFirstScale;\n    double _scale;\n    NSDictionary *_selectedObjectsBackup;\n    NSTimer *_refreshTimer;\n    NSTextField *_scalingField;\n    NSTextField *_widthField;\n    NSTextField *_heightField;\n    NSTextField *_labelField;\n    long long _scalingOriginCorner;\n    NSView *_originButtonsContainer;\n    NSTextField *_originLabel;\n    struct CGRect _originalRect;\n}", "item_id": 0, "repo": "onmyway133/SketchHeaders", "file": "Headers/MSResizeSheet.h", "last_update_at": "2019-02-12T11:00:48+00:00", "question_id": "ee34998d0f0af6a9dcf37da553c21af3a6f3094b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface MSResizeSheet : CHSheetController\n{\n    BOOL _hasDoneFirstScale;\n    double _scale;\n    NSDictionary *_selectedObjectsBackup;\n    NSTimer *_refreshTimer;\n    NSTextField *_scalingField;\n    NSTextField *_widthField;\n    NSTextField *_heightField;\n    NSTextField *_labelField;\n    long long _scalingOriginCorner;\n    NSView *_originButtonsContainer;\n    NSTextField *_originLabel;\n    struct CGRect _originalRect;\n"]], "pred": {"ppl": 5.325636863708496, "ppl_lower": 7.659351825714111, "ppl/lowercase_ppl": -1.2172723708520956, "ppl/zlib": 0.007335667996765865, "Min_5.0% Prob": 9.886784235636393, "Min_10.0% Prob": 8.427219024071327, "Min_20.0% Prob": 6.29329154226515, "Min_30.0% Prob": 5.044988659024239, "Min_40.0% Prob": 4.04261671172248, "Min_50.0% Prob": 3.2990658907767605, "Min_60.0% Prob": 2.79656312899825}}
{"hexsha": "e956b4438ff4b676e61242c13dba23140014991a", "ext": "c", "lang": "C", "content": "int\nsdp_put_off_hold (sdp_t * sdp)\n{\n  int pos;\n  int pos_media = -1;\n  char *rcvsnd;\n\n  pos = 0;\n  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n  while (rcvsnd != NULL)\n    {\n      if (rcvsnd != NULL && (0 == strcmp (rcvsnd, \"sendonly\")\n\t\t\t     || 0 == strcmp (rcvsnd, \"recvonly\")))\n\t{\n\t  sprintf (rcvsnd, \"sendrecv\");\n\t}\n      pos++;\n      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n    }\n\n  pos_media = 0;\n  while (!sdp_endof_media (sdp, pos_media))\n    {\n      pos = 0;\n      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n      while (rcvsnd != NULL)\n\t{\n\t  if (rcvsnd != NULL && (0 == strcmp (rcvsnd, \"sendonly\")\n\t\t\t\t || 0 == strcmp (rcvsnd, \"recvonly\")))\n\t    {\n\t      sprintf (rcvsnd, \"sendrecv\");\n\t    }\n\t  pos++;\n\t  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n\t}\n      pos_media++;\n    }\n\n  return 0;\n}", "item_id": 42, "repo": "goodspeed24e/2011Corel", "file": "libosip-0.9.2/libosip-0.9.2/fsm/sdp_negoc.c", "last_update_at": "2019-07-24T07:59:07+00:00", "question_id": "e956b4438ff4b676e61242c13dba23140014991a_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nsdp_put_off_hold (sdp_t * sdp)\n{\n  int pos;\n  int pos_media = -1;\n  char *rcvsnd;\n  pos = 0;\n  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n  while (rcvsnd != NULL)\n    {\n      if (rcvsnd != NULL && (0 == strcmp (rcvsnd, \"sendonly\")\n\t\t\t     || 0 == strcmp (rcvsnd, \"recvonly\")))\n\t{\n\t  sprintf (rcvsnd, \"sendrecv\");\n\t}\n      pos++;\n      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n    }\n  pos_media = 0;\n  while (!sdp_endof_media (sdp, pos_media))\n    {\n      pos = 0;\n      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n      while (rcvsnd != NULL)\n\t{\n\t  if (rcvsnd != NULL && (0 == strcmp (rcvsnd, \"sendonly\")\n\t\t\t\t || 0 == strcmp (rcvsnd, \"recvonly\")))\n\t    {\n\t      sprintf (rcvsnd, \"sendrecv\");\n\t    }\n\t  pos++;\n\t  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);\n\t}\n      pos_media++;\n    }\n  return 0;\n"]], "pred": {"ppl": 1.687666654586792, "ppl_lower": 1.7335834503173828, "ppl/lowercase_ppl": -1.051292417616221, "ppl/zlib": 0.0018492823221269437, "Min_5.0% Prob": 6.493577555606239, "Min_10.0% Prob": 4.211848402634645, "Min_20.0% Prob": 2.5102652858329724, "Min_30.0% Prob": 1.7354611150162704, "Min_40.0% Prob": 1.307482533911361, "Min_50.0% Prob": 1.0458151960105757, "Min_60.0% Prob": 0.8742370451122664}}
{"hexsha": "1e31f753c20b3dfdf1ea0d9a79eb5b271665faef", "ext": "c", "lang": "C", "content": "static int\nprocess_server_set_pointer_ex(struct mod *mod, struct stream *s)\n{\n    int rv;\n    int x;\n    int y;\n    int bpp;\n    int Bpp;\n    char cur_data[32 * (32 * 4)];\n    char cur_mask[32 * (32 / 8)];\n\n    in_sint16_le(s, x);\n    in_sint16_le(s, y);\n    in_uint16_le(s, bpp);\n    Bpp = (bpp == 0) ? 3 : (bpp + 7) / 8;\n    in_uint8a(s, cur_data, 32 * (32 * Bpp));\n    in_uint8a(s, cur_mask, 32 * (32 / 8));\n    rv = mod->server_set_cursor_ex(mod, x, y, cur_data, cur_mask, bpp);\n    return rv;\n}", "item_id": 30, "repo": "Jonesb/xrdp", "file": "xup/xup.c", "last_update_at": "2019-09-01T16:06:39+00:00", "question_id": "1e31f753c20b3dfdf1ea0d9a79eb5b271665faef_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nprocess_server_set_pointer_ex(struct mod *mod, struct stream *s)\n{\n    int rv;\n    int x;\n    int y;\n    int bpp;\n    int Bpp;\n    char cur_data[32 * (32 * 4)];\n    char cur_mask[32 * (32 / 8)];\n    in_sint16_le(s, x);\n    in_sint16_le(s, y);\n    in_uint16_le(s, bpp);\n    Bpp = (bpp == 0) ? 3 : (bpp + 7) / 8;\n    in_uint8a(s, cur_data, 32 * (32 * Bpp));\n    in_uint8a(s, cur_mask, 32 * (32 / 8));\n    rv = mod->server_set_cursor_ex(mod, x, y, cur_data, cur_mask, bpp);\n    return rv;\n"]], "pred": {"ppl": 1.78436279296875, "ppl_lower": 1.905472755432129, "ppl/lowercase_ppl": -1.1134055450584095, "ppl/zlib": 0.002412755719877236, "Min_5.0% Prob": 6.30802736679713, "Min_10.0% Prob": 4.223676743507386, "Min_20.0% Prob": 2.6443587517738343, "Min_30.0% Prob": 1.8774658240874609, "Min_40.0% Prob": 1.4376999954506755, "Min_50.0% Prob": 1.1560404646247626, "Min_60.0% Prob": 0.9646833979027967}}
{"hexsha": "9f2de810643b3dd6a5a40f58dba33c6ca570be49", "ext": "c", "lang": "C", "content": "static void\nbetty_out(hpcio_chip_t hc, int port, int onoff)\n{\n\tstruct ucbio_softc *sc = hc->hc_sc;\n\ttx_chipset_tag_t tc = sc->sc_tc;\t\n\ttxreg_t reg, pos;\n\n\tpos = 1 << port;\n\treg = txsibsf0_reg_read(tc, UCB1200_IO_DATA_REG);\n\tif (onoff)\n\t\treg |= pos;\n\telse\n\t\treg &= ~pos;\n\ttxsibsf0_reg_write(tc, UCB1200_IO_DATA_REG, reg);\n}", "item_id": 1, "repo": "shisa/kame-shisa", "file": "netbsd/sys/arch/hpcmips/dev/ucbio.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "9f2de810643b3dd6a5a40f58dba33c6ca570be49_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nbetty_out(hpcio_chip_t hc, int port, int onoff)\n{\n\tstruct ucbio_softc *sc = hc->hc_sc;\n\ttx_chipset_tag_t tc = sc->sc_tc;\t\n\ttxreg_t reg, pos;\n\tpos = 1 << port;\n\treg = txsibsf0_reg_read(tc, UCB1200_IO_DATA_REG);\n\tif (onoff)\n\t\treg |= pos;\n\telse\n\t\treg &= ~pos;\n\ttxsibsf0_reg_write(tc, UCB1200_IO_DATA_REG, reg);\n"]], "pred": {"ppl": 3.771303653717041, "ppl_lower": 3.8119208812713623, "ppl/lowercase_ppl": -1.008070155650816, "ppl/zlib": 0.006006428680669349, "Min_5.0% Prob": 10.231219291687012, "Min_10.0% Prob": 8.12476531197043, "Min_20.0% Prob": 5.624789413283853, "Min_30.0% Prob": 4.136264875531197, "Min_40.0% Prob": 3.2525646470595095, "Min_50.0% Prob": 2.634122481120044, "Min_60.0% Prob": 2.2164237244914355}}
{"hexsha": "f37abd94c43d3b49a5b9fd9fcae65bb1df404f44", "ext": "c", "lang": "C", "content": "int main()\n{\n    FILE *fp;\n    int i,n;\n    char c;\n    fp=fopen(\"file_C(i).dat\",\"ab\");\n    if (fp==NULL)\n    {\n        perror(\"Can't open file.\");\n        exit(EXIT_FAILURE);\n    }\n    do\n    {\n        do\n        {\n            printf(\"Enter the EMPLOYEE CODE of the employee [6 DIGITS]: \");\n            scanf(\"%d\",&data.empcode);\n            n=data.empcode;\n            for (i=0;n!=0;i++)\n                n/=10;\n        }while(i!=6);\n        printf(\"Enter the NAME of the employee [MAX 19 CHARACTERS]: \");\n        fflush(stdin);\n        gets(data.empname);\n        printf(\"Enter the JOIN DATE of the employee [DD/MM/YYYY] [SEPARATED BY A TAB]: \");\n        scanf(\"%d%d%d\",&data.join_date.d,&data.join_date.m,&data.join_date.y);\n        printf(\"Enter the SALARY of the employee: \");\n        scanf(\"%f\",&data.salary);\n        fwrite(&data,sizeof(struct employee),1,fp);\n        printf(\"\\nEnter another data [Y/N]: \");\n        fflush(stdin);\n        c=getchar();\n        printf(\"\\n\");\n    }while (c=='y' || c=='Y');\n    fclose(fp);\n    return 0;\n}", "item_id": 0, "repo": "OjeshManandhar/Code-Backup", "file": "{C}/Let Us C/Chapter 13_File IO/C(i)/entry.c", "last_update_at": "2019-03-22T16:13:16+00:00", "question_id": "f37abd94c43d3b49a5b9fd9fcae65bb1df404f44_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main()\n{\n    FILE *fp;\n    int i,n;\n    char c;\n    fp=fopen(\"file_C(i).dat\",\"ab\");\n    if (fp==NULL)\n    {\n        perror(\"Can't open file.\");\n        exit(EXIT_FAILURE);\n    }\n    do\n    {\n        do\n        {\n            printf(\"Enter the EMPLOYEE CODE of the employee [6 DIGITS]: \");\n            scanf(\"%d\",&data.empcode);\n            n=data.empcode;\n            for (i=0;n!=0;i++)\n                n/=10;\n        }while(i!=6);\n        printf(\"Enter the NAME of the employee [MAX 19 CHARACTERS]: \");\n        fflush(stdin);\n        gets(data.empname);\n        printf(\"Enter the JOIN DATE of the employee [DD/MM/YYYY] [SEPARATED BY A TAB]: \");\n        scanf(\"%d%d%d\",&data.join_date.d,&data.join_date.m,&data.join_date.y);\n        printf(\"Enter the SALARY of the employee: \");\n        scanf(\"%f\",&data.salary);\n        fwrite(&data,sizeof(struct employee),1,fp);\n        printf(\"\\nEnter another data [Y/N]: \");\n        fflush(stdin);\n        c=getchar();\n        printf(\"\\n\");\n    }while (c=='y' || c=='Y');\n    fclose(fp);\n    return 0;\n"]], "pred": {"ppl": 2.0253288745880127, "ppl_lower": 2.2756752967834473, "ppl/lowercase_ppl": -1.1651402117423426, "ppl/zlib": 0.001485751778054394, "Min_5.0% Prob": 5.8395508088563615, "Min_10.0% Prob": 4.502084832442434, "Min_20.0% Prob": 2.9715397012861153, "Min_30.0% Prob": 2.1992335329976, "Min_40.0% Prob": 1.714451437423888, "Min_50.0% Prob": 1.3956026734490143, "Min_60.0% Prob": 1.1708949950049843}}
{"hexsha": "0076b4403713243b0b428778ce3918b7aa34a70f", "ext": "c", "lang": "C", "content": "any plisp_adc_maxval(any ex) {\n  unsigned id;\n  u32 res;\n  any x, y;\n\n  x = cdr(ex);\n  NeedNum(ex, y = EVAL(car(x)));\n  id = unBox(y); // get id.\n  MOD_CHECK_ID(ex, adc, id);\n\n  res = platform_adc_get_maxval(id);\n  return box(res);\n}", "item_id": 0, "repo": "simplemachines-italy/hempl", "file": "src/modules/adc.c", "last_update_at": "2019-12-09T17:53:30+00:00", "question_id": "0076b4403713243b0b428778ce3918b7aa34a70f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["any plisp_adc_maxval(any ex) {\n  unsigned id;\n  u32 res;\n  any x, y;\n  x = cdr(ex);\n  NeedNum(ex, y = EVAL(car(x)));\n  id = unBox(y); // get id.\n  MOD_CHECK_ID(ex, adc, id);\n  res = platform_adc_get_maxval(id);\n  return box(res);\n"]], "pred": {"ppl": 5.4567084312438965, "ppl_lower": 7.050894260406494, "ppl/lowercase_ppl": -1.1510500861320376, "ppl/zlib": 0.009532841328923033, "Min_5.0% Prob": 9.239933395385743, "Min_10.0% Prob": 8.29291209307584, "Min_20.0% Prob": 6.436398900073508, "Min_30.0% Prob": 5.07604160378961, "Min_40.0% Prob": 4.028817665317784, "Min_50.0% Prob": 3.336037843896632, "Min_60.0% Prob": 2.793898563238158}}
{"hexsha": "0ba30253b44ed49c3cb8263906fc20d62785005c", "ext": "h", "lang": "C", "content": "void AdjustRectifyRect( const EPH_Vec2i &size, const EPH_Vec4 &K, const EPH_Mat3 &M, EPH_Vec2 &bmin, EPH_Vec2 &bmax ) {\n\tEPH_Vec2 corner[4];\n\tcorner[0] = ReprojectRay( EPH_Vec2( 0,\t\t0\t\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[1] = ReprojectRay( EPH_Vec2( size.x, 0\t\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[2] = ReprojectRay( EPH_Vec2( size.x, size.y\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[3] = ReprojectRay( EPH_Vec2( 0,\t\tsize.y\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tbmin = corner[0].Min( corner[1] ).Min( corner[2].Min( corner[3] ) );\n\tbmax = corner[0].Max( corner[1] ).Max( corner[2].Max( corner[3] ) );\n}", "item_id": 2, "repo": "Edwinzero/Fusion", "file": "moca/src/matFunc.h", "last_update_at": "2019-05-16T06:50:34+00:00", "question_id": "0ba30253b44ed49c3cb8263906fc20d62785005c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void AdjustRectifyRect( const EPH_Vec2i &size, const EPH_Vec4 &K, const EPH_Mat3 &M, EPH_Vec2 &bmin, EPH_Vec2 &bmax ) {\n\tEPH_Vec2 corner[4];\n\tcorner[0] = ReprojectRay( EPH_Vec2( 0,\t\t0\t\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[1] = ReprojectRay( EPH_Vec2( size.x, 0\t\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[2] = ReprojectRay( EPH_Vec2( size.x, size.y\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tcorner[3] = ReprojectRay( EPH_Vec2( 0,\t\tsize.y\t), K, EPH_Vec4( 1, 1, 0, 0 ), M );\n\tbmin = corner[0].Min( corner[1] ).Min( corner[2].Min( corner[3] ) );\n\tbmax = corner[0].Max( corner[1] ).Max( corner[2].Max( corner[3] ) );\n"]], "pred": {"ppl": 1.8761276006698608, "ppl_lower": 1.9517143964767456, "ppl/lowercase_ppl": -1.0627744421602223, "ppl/zlib": 0.002886283787548585, "Min_5.0% Prob": 7.240796804428101, "Min_10.0% Prob": 5.206326235085726, "Min_20.0% Prob": 3.003020338828747, "Min_30.0% Prob": 2.091697707088018, "Min_40.0% Prob": 1.5739222137570268, "Min_50.0% Prob": 1.2581254771680617, "Min_60.0% Prob": 1.0528828438418343}}
{"hexsha": "721d73ab26417b834f4b3b265642c71def6834c0", "ext": "c", "lang": "C", "content": "char *fnc(char *s)\n{\n\tchar *p,*q;\n\tunsigned int i=0;\n\tstatic char s8[13];\n\tif(!s)return NULL;\n\tif(!(p=strrchr(s,'/')))p=s; else s=p;\n\twhile(*p&&*p!='.'&&i<8) {\n\t\tif(dosallowin83(*p))s8[i++]=tolower(*p);\n\t\tp++;\n\t}\n\ts8[i]=0;\n\tif(strstr(s,\".tar.gz\"))xstrcat(s8,\".tgz\",14);\n\telse if(strstr(s,\".tar.bz2\"))xstrcat(s8,\".tb2\",14);\n\telse if(strstr(s,\".html\"))xstrcat (s8,\".htm\",14);\n\telse if(strstr(s,\".jpeg\"))xstrcat (s8,\".jpg\",14);\n\telse if(strstr(s,\".desc\"))xstrcat (s8,\".dsc\",14);\n\t    else {\n\t\tif((p=strrchr(s,'.'))) {\n\t\t\txstrcat(s8,\".\",14);\n\t\t\tq=p+4;i=strlen(s8);\n\t\t\twhile(*p&&q>p) {\n\t\t\t\tif(dosallowin83(*p))s8[i++]=tolower(*p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\ts8[i]=0;\n\t\t}\n\t}\n\treturn s8;\n}", "item_id": 13, "repo": "sisoftrg/qico", "file": "src/tools.c", "last_update_at": "2019-04-29T22:46:29+00:00", "question_id": "721d73ab26417b834f4b3b265642c71def6834c0_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *fnc(char *s)\n{\n\tchar *p,*q;\n\tunsigned int i=0;\n\tstatic char s8[13];\n\tif(!s)return NULL;\n\tif(!(p=strrchr(s,'/')))p=s; else s=p;\n\twhile(*p&&*p!='.'&&i<8) {\n\t\tif(dosallowin83(*p))s8[i++]=tolower(*p);\n\t\tp++;\n\t}\n\ts8[i]=0;\n\tif(strstr(s,\".tar.gz\"))xstrcat(s8,\".tgz\",14);\n\telse if(strstr(s,\".tar.bz2\"))xstrcat(s8,\".tb2\",14);\n\telse if(strstr(s,\".html\"))xstrcat (s8,\".htm\",14);\n\telse if(strstr(s,\".jpeg\"))xstrcat (s8,\".jpg\",14);\n\telse if(strstr(s,\".desc\"))xstrcat (s8,\".dsc\",14);\n\t    else {\n\t\tif((p=strrchr(s,'.'))) {\n\t\t\txstrcat(s8,\".\",14);\n\t\t\tq=p+4;i=strlen(s8);\n\t\t\twhile(*p&&q>p) {\n\t\t\t\tif(dosallowin83(*p))s8[i++]=tolower(*p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\ts8[i]=0;\n\t\t}\n\t}\n\treturn s8;\n"]], "pred": {"ppl": 2.213947057723999, "ppl_lower": 2.2350502014160156, "ppl/lowercase_ppl": -1.0119363906276524, "ppl/zlib": 0.002507182717665882, "Min_5.0% Prob": 7.405450177192688, "Min_10.0% Prob": 5.286985778808594, "Min_20.0% Prob": 3.4177704893052576, "Min_30.0% Prob": 2.5052415130039054, "Min_40.0% Prob": 1.9517357364296912, "Min_50.0% Prob": 1.5752832863980264, "Min_60.0% Prob": 1.320683746277915}}
{"hexsha": "65d65bb6562484eb28e69a0c8ad34735d8ae15f6", "ext": "c", "lang": "C", "content": "static int\ncmd_decode(tlist, cmd, sp)\n\tstruct tablelist *tlist;\n\tchar *cmd;\n\tchar **sp;\n{\n\tregister struct tablelist *t;\n\tregister int action = A_INVALID;\n\n\t/*\n\t * Search thru all the command tables.\n\t * Stop when we find an action which is not A_INVALID.\n\t */\n\tfor (t = tlist;  t != NULL;  t = t->t_next)\n\t{\n\t\taction = cmd_search(cmd, t->t_start, t->t_end, sp);\n\t\tif (action != A_INVALID)\n\t\t\tbreak;\n\t}\n\tif (action == A_UINVALID)\n\t\taction = A_INVALID;\n\treturn (action);\n}", "item_id": 4, "repo": "cooljeanius/DragonFlyBSD", "file": "contrib/less/decode.c", "last_update_at": "2019-11-23T09:35:10+00:00", "question_id": "65d65bb6562484eb28e69a0c8ad34735d8ae15f6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\ncmd_decode(tlist, cmd, sp)\n\tstruct tablelist *tlist;\n\tchar *cmd;\n\tchar **sp;\n{\n\tregister struct tablelist *t;\n\tregister int action = A_INVALID;\n\t/*\n\t * Search thru all the command tables.\n\t * Stop when we find an action which is not A_INVALID.\n\t */\n\tfor (t = tlist;  t != NULL;  t = t->t_next)\n\t{\n\t\taction = cmd_search(cmd, t->t_start, t->t_end, sp);\n\t\tif (action != A_INVALID)\n\t\t\tbreak;\n\t}\n\tif (action == A_UINVALID)\n\t\taction = A_INVALID;\n\treturn (action);\n"]], "pred": {"ppl": 2.7868924140930176, "ppl_lower": 3.1123836040496826, "ppl/lowercase_ppl": -1.107775191976286, "ppl/zlib": 0.003810138085462351, "Min_5.0% Prob": 8.01810598373413, "Min_10.0% Prob": 6.134739637374878, "Min_20.0% Prob": 4.144365153814617, "Min_30.0% Prob": 3.1204687963271964, "Min_40.0% Prob": 2.5028971801330515, "Min_50.0% Prob": 2.0309813161639823, "Min_60.0% Prob": 1.708762009724461}}
{"hexsha": "aa11e25e262e6a0f0c8ebc8d41e10508c79a9306", "ext": "c", "lang": "C", "content": "void initState(void) {\n\tstate.substate[SUBSTATE_POSITION].internalState = MOVEMENT_STATE_STATIONARY;\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounter = 0;\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounterToStationary = getHysteresisCountToStationary();\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounterToMoving = getHysteresisCountToMoving();\n\tstate.substate[SUBSTATE_POSITION].externalState = MOVEMENT_STATE_STATIONARY;\n\tstate.substate[SUBSTATE_GATEWAY].internalState = MOVEMENT_STATE_MOVING;\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounter = 0;\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounterToStationary = getGatewayHysteresisCountToStationary();\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounterToMoving = getGatewayHysteresisCountToMoving();\n\tstate.substate[SUBSTATE_GATEWAY].externalState = MOVEMENT_STATE_MOVING;\n\tstate.externalState = MOVEMENT_STATE_MOVING; /* must comply to AND/OR conditions of sub-states */\n}", "item_id": 0, "repo": "WachterJud/qaul.net_legacy", "file": "olsrd-0.6.6.2/lib/pud/src/state.c", "last_update_at": "2019-07-30T14:44:29+00:00", "question_id": "aa11e25e262e6a0f0c8ebc8d41e10508c79a9306_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void initState(void) {\n\tstate.substate[SUBSTATE_POSITION].internalState = MOVEMENT_STATE_STATIONARY;\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounter = 0;\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounterToStationary = getHysteresisCountToStationary();\n\tstate.substate[SUBSTATE_POSITION].hysteresisCounterToMoving = getHysteresisCountToMoving();\n\tstate.substate[SUBSTATE_POSITION].externalState = MOVEMENT_STATE_STATIONARY;\n\tstate.substate[SUBSTATE_GATEWAY].internalState = MOVEMENT_STATE_MOVING;\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounter = 0;\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounterToStationary = getGatewayHysteresisCountToStationary();\n\tstate.substate[SUBSTATE_GATEWAY].hysteresisCounterToMoving = getGatewayHysteresisCountToMoving();\n\tstate.substate[SUBSTATE_GATEWAY].externalState = MOVEMENT_STATE_MOVING;\n\tstate.externalState = MOVEMENT_STATE_MOVING; /* must comply to AND/OR conditions of sub-states */\n"]], "pred": {"ppl": 2.032883882522583, "ppl_lower": 2.417205333709717, "ppl/lowercase_ppl": -1.2440697911351506, "ppl/zlib": 0.0028041716074923826, "Min_5.0% Prob": 7.661061942577362, "Min_10.0% Prob": 5.759994066122807, "Min_20.0% Prob": 3.4434869546781885, "Min_30.0% Prob": 2.3611979161699614, "Min_40.0% Prob": 1.7813650996734698, "Min_50.0% Prob": 1.418218589305081, "Min_60.0% Prob": 1.1834104574892679}}
{"hexsha": "066a48673a3003ceadac8f638984e30da91b6568", "ext": "c", "lang": "C", "content": "void Mix4bytes(uint8_t *a, uint8_t *b, uint8_t *c, uint8_t *d) \r\n{\r\n\t/* Mix four bytes in a linear way */\r\n\tuint8_t aa, bb, cc, dd;\r\n\r\n\taa = mul(2,*a)^mul(3,*b)^(*c)^(*d);\r\n\tbb = mul(2,*b)^mul(3,*c)^(*d)^(*a);\r\n\tcc = mul(2,*c)^mul(3,*d)^(*a)^(*b);\r\n\tdd = mul(2,*d)^mul(3,*a)^(*b)^(*c);\r\n\t*a = aa;\r\n\t*b = bb;\r\n\t*c = cc;\r\n\t*d = dd;\r\n}", "item_id": 5, "repo": "devzero2000/RPM5", "file": "rpmio/echo.c", "last_update_at": "2019-01-14T07:48:54+00:00", "question_id": "066a48673a3003ceadac8f638984e30da91b6568_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void Mix4bytes(uint8_t *a, uint8_t *b, uint8_t *c, uint8_t *d) \r\n{\r\n\t/* Mix four bytes in a linear way */\r\n\tuint8_t aa, bb, cc, dd;\r\n\r\n\taa = mul(2,*a)^mul(3,*b)^(*c)^(*d);\r\n\tbb = mul(2,*b)^mul(3,*c)^(*d)^(*a);\r\n\tcc = mul(2,*c)^mul(3,*d)^(*a)^(*b);\r\n\tdd = mul(2,*d)^mul(3,*a)^(*b)^(*c);\r\n\t*a = aa;\r\n\t*b = bb;\r\n\t*c = cc;\r\n\t*d = dd;\r\n"]], "pred": {"ppl": 2.2242183685302734, "ppl_lower": 2.1506853103637695, "ppl/lowercase_ppl": -0.9579449778297342, "ppl/zlib": 0.004416605297552882, "Min_5.0% Prob": 8.633204248216417, "Min_10.0% Prob": 6.174238016730861, "Min_20.0% Prob": 3.8079503351136257, "Min_30.0% Prob": 2.642238772751992, "Min_40.0% Prob": 2.0016046220338657, "Min_50.0% Prob": 1.6057259204650396, "Min_60.0% Prob": 1.33885520798146}}
{"hexsha": "818a5b3b0965306e0b12919aa589b5656c4850d7", "ext": "c", "lang": "C", "content": "int\nhme_intr(v)\n\tvoid *v;\n{\n\tstruct hme_softc *sc = (struct hme_softc *)v;\n\tbus_space_tag_t t = sc->sc_bustag;\n\tbus_space_handle_t seb = sc->sc_seb;\n\tu_int32_t status;\n\tint r = 0;\n\n\tstatus = bus_space_read_4(t, seb, HME_SEBI_STAT);\n\n\tif ((status & HME_SEB_STAT_ALL_ERRORS) != 0)\n\t\tr |= hme_eint(sc, status);\n\n\tif ((status & (HME_SEB_STAT_TXALL | HME_SEB_STAT_HOSTTOTX)) != 0)\n\t\tr |= hme_tint(sc);\n\n\tif ((status & HME_SEB_STAT_RXTOHOST) != 0)\n\t\tr |= hme_rint(sc);\n\n\treturn (r);\n}", "item_id": 10, "repo": "shisa/kame-shisa", "file": "openbsd/sys/dev/ic/hme.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "818a5b3b0965306e0b12919aa589b5656c4850d7_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nhme_intr(v)\n\tvoid *v;\n{\n\tstruct hme_softc *sc = (struct hme_softc *)v;\n\tbus_space_tag_t t = sc->sc_bustag;\n\tbus_space_handle_t seb = sc->sc_seb;\n\tu_int32_t status;\n\tint r = 0;\n\tstatus = bus_space_read_4(t, seb, HME_SEBI_STAT);\n\tif ((status & HME_SEB_STAT_ALL_ERRORS) != 0)\n\t\tr |= hme_eint(sc, status);\n\tif ((status & (HME_SEB_STAT_TXALL | HME_SEB_STAT_HOSTTOTX)) != 0)\n\t\tr |= hme_tint(sc);\n\tif ((status & HME_SEB_STAT_RXTOHOST) != 0)\n\t\tr |= hme_rint(sc);\n\treturn (r);\n"]], "pred": {"ppl": 1.9243178367614746, "ppl_lower": 2.025407314300537, "ppl/lowercase_ppl": -1.0782180190886077, "ppl/zlib": 0.00258723926649075, "Min_5.0% Prob": 7.314827561378479, "Min_10.0% Prob": 4.98744457244873, "Min_20.0% Prob": 3.055415886289933, "Min_30.0% Prob": 2.15067945169164, "Min_40.0% Prob": 1.6312059068564073, "Min_50.0% Prob": 1.3101946672554625, "Min_60.0% Prob": 1.0926769156549727}}
{"hexsha": "929062123b09360aae400e50ca4623c999bc1418", "ext": "c", "lang": "C", "content": "void\nffs_clusteracct(ump, fs, cgp, blkno, cnt)\n\tstruct ufsmount *ump;\n\tstruct fs *fs;\n\tstruct cg *cgp;\n\tufs1_daddr_t blkno;\n\tint cnt;\n{\n\tint32_t *sump;\n\tint32_t *lp;\n\tu_char *freemapp, *mapp;\n\tint i, start, end, forw, back, map, bit;\n\n\tmtx_assert(UFS_MTX(ump), MA_OWNED);\n\n\tif (fs->fs_contigsumsize <= 0)\n\t\treturn;\n\tfreemapp = cg_clustersfree(cgp);\n\tsump = cg_clustersum(cgp);\n\t/*\n\t * Allocate or clear the actual block.\n\t */\n\tif (cnt > 0)\n\t\tsetbit(freemapp, blkno);\n\telse\n\t\tclrbit(freemapp, blkno);\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + fs->fs_contigsumsize;\n\tif (end >= cgp->cg_nclusterblks)\n\t\tend = cgp->cg_nclusterblks;\n\tmapp = &freemapp[start / NBBY];\n\tmap = *mapp++;\n\tbit = 1 << (start % NBBY);\n\tfor (i = start; i < end; i++) {\n\t\tif ((map & bit) == 0)\n\t\t\tbreak;\n\t\tif ((i & (NBBY - 1)) != (NBBY - 1)) {\n\t\t\tbit <<= 1;\n\t\t} else {\n\t\t\tmap = *mapp++;\n\t\t\tbit = 1;\n\t\t}\n\t}\n\tforw = i - start;\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - fs->fs_contigsumsize;\n\tif (end < 0)\n\t\tend = -1;\n\tmapp = &freemapp[start / NBBY];\n\tmap = *mapp--;\n\tbit = 1 << (start % NBBY);\n\tfor (i = start; i > end; i--) {\n\t\tif ((map & bit) == 0)\n\t\t\tbreak;\n\t\tif ((i & (NBBY - 1)) != 0) {\n\t\t\tbit >>= 1;\n\t\t} else {\n\t\t\tmap = *mapp--;\n\t\t\tbit = 1 << (NBBY - 1);\n\t\t}\n\t}\n\tback = start - i;\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > fs->fs_contigsumsize)\n\t\ti = fs->fs_contigsumsize;\n\tsump[i] += cnt;\n\tif (back > 0)\n\t\tsump[back] -= cnt;\n\tif (forw > 0)\n\t\tsump[forw] -= cnt;\n\t/*\n\t * Update cluster summary information.\n\t */\n\tlp = &sump[fs->fs_contigsumsize];\n\tfor (i = fs->fs_contigsumsize; i > 0; i--)\n\t\tif (*lp-- > 0)\n\t\t\tbreak;\n\tfs->fs_maxcluster[cgp->cg_cgx] = i;\n}", "item_id": 21, "repo": "TrustedBSD/sebsd", "file": "sys/ufs/ffs/ffs_alloc.c", "last_update_at": "2019-10-09T17:34:14+00:00", "question_id": "929062123b09360aae400e50ca4623c999bc1418_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nffs_clusteracct(ump, fs, cgp, blkno, cnt)\n\tstruct ufsmount *ump;\n\tstruct fs *fs;\n\tstruct cg *cgp;\n\tufs1_daddr_t blkno;\n\tint cnt;\n{\n\tint32_t *sump;\n\tint32_t *lp;\n\tu_char *freemapp, *mapp;\n\tint i, start, end, forw, back, map, bit;\n\tmtx_assert(UFS_MTX(ump), MA_OWNED);\n\tif (fs->fs_contigsumsize <= 0)\n\t\treturn;\n\tfreemapp = cg_clustersfree(cgp);\n\tsump = cg_clustersum(cgp);\n\t/*\n\t * Allocate or clear the actual block.\n\t */\n\tif (cnt > 0)\n\t\tsetbit(freemapp, blkno);\n\telse\n\t\tclrbit(freemapp, blkno);\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + fs->fs_contigsumsize;\n\tif (end >= cgp->cg_nclusterblks)\n\t\tend = cgp->cg_nclusterblks;\n\tmapp = &freemapp[start / NBBY];\n\tmap = *mapp++;\n\tbit = 1 << (start % NBBY);\n\tfor (i = start; i < end; i++) {\n\t\tif ((map & bit) == 0)\n\t\t\tbreak;\n\t\tif ((i & (NBBY - 1)) != (NBBY - 1)) {\n\t\t\tbit <<= 1;\n\t\t} else {\n\t\t\tmap = *mapp++;\n\t\t\tbit = 1;\n\t\t}\n\t}\n\tforw = i - start;\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - fs->fs_contigsumsize;\n\tif (end < 0)\n\t\tend = -1;\n\tmapp = &freemapp[start / NBBY];\n\tmap = *mapp--;\n\tbit = 1 << (start % NBBY);\n\tfor (i = start; i > end; i--) {\n\t\tif ((map & bit) == 0)\n\t\t\tbreak;\n\t\tif ((i & (NBBY - 1)) != 0) {\n\t\t\tbit >>= 1;\n\t\t} else {\n\t\t\tmap = *mapp--;\n\t\t\tbit = 1 << (NBBY - 1);\n\t\t}\n\t}\n\tback = start - i;\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > fs->fs_contigsumsize)\n\t\ti = fs->fs_contigsumsize;\n\tsump[i] += cnt;\n\tif (back > 0)\n\t\tsump[back] -= cnt;\n\tif (forw > 0)\n\t\tsump[forw] -= cnt;\n\t/*\n\t * Update cluster summary information.\n\t */\n\tlp = &sump[fs->fs_contigsumsize];\n\tfor (i = fs->fs_contigsumsize; i > 0; i--)\n\t\tif (*lp-- > 0)\n\t\t\tbreak;\n\tfs->fs_maxcluster[cgp->cg_cgx] = i;\n"]], "pred": {"ppl": 1.4251718521118164, "ppl_lower": 1.5178370475769043, "ppl/lowercase_ppl": -1.177802067487999, "ppl/zlib": 0.0004955138523391152, "Min_5.0% Prob": 4.7415283866550615, "Min_10.0% Prob": 3.089064933683561, "Min_20.0% Prob": 1.7415857910300079, "Min_30.0% Prob": 1.1802671679795005, "Min_40.0% Prob": 0.8853114119826798, "Min_50.0% Prob": 0.7091739588369638, "Min_60.0% Prob": 0.5912912170501438}}
{"hexsha": "3bdecabe855cffca5eb62cf0f97105260e1d24d9", "ext": "c", "lang": "C", "content": "static void expand(char *as ) \n{ register char *cs ;\n  register char *sgpathp ;\n  register char *oldcs ;\n  struct stat stb ;\n  char *tmp ;\n  int tmp_0__ ;\n  int tmp_1__ ;\n  int tmp_2__ ;\n  int tmp_3__ ;\n  char *tmp_4__ ;\n  int tmp_5__ ;\n\n  {\n// # 201\n  if (globerr) {\n// # 202\n    return;\n  }\n  {\n// # 203\n  sgpathp = gpathp;\n// # 204\n  cs = as;\n  }\n// # 205\n  if ((int )(*cs) == 126) {\n// # 205\n    if ((unsigned int )gpathp == (unsigned int )gpath) {\n      {\n// # 206\n      addpath('~');\n// # 207\n      cs ++;\n      }\n// # 207\n      while (1) {\n        {\n// # 207\n        tmp_0__ = letter((*cs));\n        }\n// # 207\n        if (! tmp_0__) {\n          {\n// # 207\n          tmp_1__ = digit((*cs));\n          }\n// # 207\n          if (! tmp_1__) {\n// # 207\n            if (! ((int )(*cs) == 45)) {\n// # 207\n              break;\n            }\n          }\n        }\n        {\n// # 208\n        tmp = cs;\n// # 208\n        cs ++;\n// # 208\n        addpath((*tmp));\n        }\n      }\n// # 209\n      if ((*cs)) {\n// # 209\n        if ((int )(*cs) == 47) {\n          _L: \n// # 210\n          if ((unsigned int )gpathp != (unsigned int )(gpath + 1)) {\n            {\n// # 211\n            (*gpathp) = (char )0;\n// # 212\n            tmp_2__ = gethdir(gpath + 1);\n            }\n// # 212\n            if (tmp_2__) {\n              {\n// # 213\n              globerr = \"Unknown user name after ~\";\n              }\n            }\n            {\n// # 214\n            strcpy((char */*   */)gpath,\n                   (char/*const*/  */*   */)((char/*const*/  *)(gpath + 1)));\n            }\n          } else {\n            {\n// # 217\n            strcpy((char */*   */)gpath,\n                   (char/*const*/  */*   */)((char/*const*/  *)home));\n            }\n          }\n          {\n// # 218\n          gpathp = strend(gpath);\n          }\n        }\n      } else {\n        goto _L;\n      }\n    }\n  }\n// # 221\n  while (1) {\n    {\n// # 221\n    tmp_5__ = any((int )(*cs), globchars);\n    }\n// # 221\n    if (tmp_5__) {\n// # 221\n      break;\n    }\n// # 222\n    if ((int )(*cs) == 0) {\n// # 223\n      if (globbed) {\n        {\n// # 225\n        tmp_3__ = statext__inline((char/*const*/  *)gpath, & stb);\n        }\n// # 225\n        if (tmp_3__ >= 0) {\n          {\n// # 226\n          Gcat(gpath, \"\");\n// # 227\n          globcnt ++;\n          }\n        }\n      } else {\n        {\n// # 224\n        Gcat(gpath, \"\");\n        }\n      }\n      goto endit;\n    }\n    {\n// # 231\n    tmp_4__ = cs;\n// # 231\n    cs ++;\n// # 231\n    addpath((*tmp_4__));\n    }\n  }\n  {\n// # 233\n  oldcs = cs;\n  }\n// # 234\n  while (1) {\n// # 234\n    if ((unsigned int )cs > (unsigned int )as) {\n// # 234\n      if (! ((int )(*cs) != 47)) {\n// # 234\n        break;\n      }\n    } else {\n// # 234\n      break;\n    }\n    {\n// # 235\n    cs --;\n// # 235\n    gpathp --;\n    }\n  }\n// # 236\n  if ((int )(*cs) == 47) {\n    {\n// # 237\n    cs ++;\n// # 237\n    gpathp ++;\n    }\n  }\n  {\n// # 238\n  (*gpathp) = (char )0;\n  }\n// # 239\n  if ((int )(*oldcs) == 123) {\n    {\n// # 240\n    execbrc(cs, (char *)0);\n    }\n// # 241\n    return;\n  }\n  {\n// # 243\n  matchdir(cs);\n  }\n  endit: \n  {\n// # 245\n  gpathp = sgpathp;\n// # 246\n  (*gpathp) = (char )0;\n  }\n// # 247\n  return;\n}\n}", "item_id": 73, "repo": "tracer-x/tracer", "file": "src/interpreter/tests/CFG/MACRO/wuftpd/wuftpd-instrumented.c", "last_update_at": "2019-10-08T12:16:55+00:00", "question_id": "3bdecabe855cffca5eb62cf0f97105260e1d24d9_73", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void expand(char *as ) \n{ register char *cs ;\n  register char *sgpathp ;\n  register char *oldcs ;\n  struct stat stb ;\n  char *tmp ;\n  int tmp_0__ ;\n  int tmp_1__ ;\n  int tmp_2__ ;\n  int tmp_3__ ;\n  char *tmp_4__ ;\n  int tmp_5__ ;\n  {\n// # 201\n  if (globerr) {\n// # 202\n    return;\n  }\n  {\n// # 203\n  sgpathp = gpathp;\n// # 204\n  cs = as;\n  }\n// # 205\n  if ((int )(*cs) == 126) {\n// # 205\n    if ((unsigned int )gpathp == (unsigned int )gpath) {\n      {\n// # 206\n      addpath('~');\n// # 207\n      cs ++;\n      }\n// # 207\n      while (1) {\n        {\n// # 207\n        tmp_0__ = letter((*cs));\n        }\n// # 207\n        if (! tmp_0__) {\n          {\n// # 207\n          tmp_1__ = digit((*cs));\n          }\n// # 207\n          if (! tmp_1__) {\n// # 207\n            if (! ((int )(*cs) == 45)) {\n// # 207\n              break;\n            }\n          }\n        }\n        {\n// # 208\n        tmp = cs;\n// # 208\n        cs ++;\n// # 208\n        addpath((*tmp));\n        }\n      }\n// # 209\n      if ((*cs)) {\n// # 209\n        if ((int )(*cs) == 47) {\n          _L: \n// # 210\n          if ((unsigned int )gpathp != (unsigned int )(gpath + 1)) {\n            {\n// # 211\n            (*gpathp) = (char )0;\n// # 212\n            tmp_2__ = gethdir(gpath + 1);\n            }\n// # 212\n            if (tmp_2__) {\n              {\n// # 213\n              globerr = \"Unknown user name after ~\";\n              }\n            }\n            {\n// # 214\n            strcpy((char */*   */)gpath,\n                   (char/*const*/  */*   */)((char/*const*/  *)(gpath + 1)));\n            }\n          } else {\n            {\n// # 217\n            strcpy((char */*   */)gpath,\n                   (char/*const*/  */*   */)((char/*const*/  *)home));\n            }\n          }\n          {\n// # 218\n          gpathp = strend(gpath);\n          }\n        }\n      } else {\n        goto _L;\n      }\n    }\n  }\n// # 221\n  while (1) {\n    {\n// # 221\n    tmp_5__ = any((int )(*cs), globchars);\n    }\n// # 221\n    if (tmp_5__) {\n// # 221\n      break;\n    }\n// # 222\n    if ((int )(*cs) == 0) {\n// # 223\n      if (globbed) {\n        {\n// # 225\n        tmp_3__ = statext__inline((char/*const*/  *)gpath, & stb);\n        }\n// # 225\n        if (tmp_3__ >= 0) {\n          {\n// # 226\n          Gcat(gpath, \"\");\n// # 227\n          globcnt ++;\n          }\n        }\n      } else {\n        {\n// # 224\n        Gcat(gpath, \"\");\n        }\n      }\n      goto endit;\n    }\n    {\n// # 231\n    tmp_4__ = cs;\n// # 231\n    cs ++;\n// # 231\n    addpath((*tmp_4__));\n    }\n  }\n  {\n// # 233\n  oldcs = cs;\n  }\n// # 234\n  while (1) {\n// # 234\n    if ((unsigned int )cs > (unsigned int )as) {\n// # 234\n      if (! ((int )(*cs) != 47)) {\n// # 234\n        break;\n      }\n    } else {\n// # 234\n      break;\n    }\n    {\n// # 235\n    cs --;\n// # 235\n    gpathp --;\n    }\n  }\n// # 236\n  if ((int )(*cs) == 47) {\n    {\n// # 237\n    cs ++;\n// # 237\n    gpathp ++;\n    }\n  }\n  {\n// # 238\n  (*gpathp) = (char )0;\n  }\n// # 239\n  if ((int )(*oldcs) == 123) {\n    {\n// # 240\n    execbrc(cs, (char *)0);\n    }\n// # 241\n    return;\n  }\n  {\n// # 243\n  matchdir(cs);\n  }\n  endit: \n  {\n// # 245\n  gpathp = sgpathp;\n// # 246\n  (*gpathp) = (char )0;\n  }\n// # 247\n  return;\n}\n"]], "pred": {"ppl": 1.8683651685714722, "ppl_lower": 1.8831963539123535, "ppl/lowercase_ppl": -1.0126494515128588, "ppl/zlib": 0.0007094935381259643, "Min_5.0% Prob": 6.356598980286542, "Min_10.0% Prob": 4.453307943016875, "Min_20.0% Prob": 2.7980601618102954, "Min_30.0% Prob": 2.0191832642539653, "Min_40.0% Prob": 1.5515230260516146, "Min_50.0% Prob": 1.2494524007192913, "Min_60.0% Prob": 1.042771819198799}}
{"hexsha": "2322e2298f9d357963d212a8e293745a0c4020b0", "ext": "c", "lang": "C", "content": "always_inline void\nparse_ip6_packet(ip6_header_t * ip6, uword * is_reverse, struct ip6_sig * ip6_sig)\n{\n    ip6_sig->proto = ip6->protocol;\n\n    if (ip6_address_compare(&ip6->src_address, &ip6->dst_address) < 0)\n    {\n        ip6_sig->src = ip6->src_address;\n        ip6_sig->dst = ip6->dst_address;\n        *is_reverse = 1;\n    } else {\n        ip6_sig->src = ip6->dst_address;\n        ip6_sig->dst = ip6->src_address;\n    }\n\n    if (ip6_sig->proto == IP_PROTOCOL_UDP || ip6_sig->proto == IP_PROTOCOL_TCP)\n    {\n        /* tcp and udp ports have the same offset */\n        udp_header_t * udp0 = (udp_header_t *) ip6_next_header(ip6);\n        if (*is_reverse)\n        {\n            ip6_sig->port_src = udp0->src_port;\n            ip6_sig->port_dst = udp0->dst_port;\n        } else {\n            ip6_sig->port_src = udp0->dst_port;\n            ip6_sig->port_dst = udp0->src_port;\n        }\n    } else {\n        ip6_sig->port_src = 0;\n        ip6_sig->port_dst = 0;\n    }\n}", "item_id": 2, "repo": "GabrielGanne/vpp-flowtable", "file": "src/plugins/flowtable/flowtable_node.c", "last_update_at": "2019-06-12T12:13:45+00:00", "question_id": "2322e2298f9d357963d212a8e293745a0c4020b0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["always_inline void\nparse_ip6_packet(ip6_header_t * ip6, uword * is_reverse, struct ip6_sig * ip6_sig)\n{\n    ip6_sig->proto = ip6->protocol;\n    if (ip6_address_compare(&ip6->src_address, &ip6->dst_address) < 0)\n    {\n        ip6_sig->src = ip6->src_address;\n        ip6_sig->dst = ip6->dst_address;\n        *is_reverse = 1;\n    } else {\n        ip6_sig->src = ip6->dst_address;\n        ip6_sig->dst = ip6->src_address;\n    }\n    if (ip6_sig->proto == IP_PROTOCOL_UDP || ip6_sig->proto == IP_PROTOCOL_TCP)\n    {\n        /* tcp and udp ports have the same offset */\n        udp_header_t * udp0 = (udp_header_t *) ip6_next_header(ip6);\n        if (*is_reverse)\n        {\n            ip6_sig->port_src = udp0->src_port;\n            ip6_sig->port_dst = udp0->dst_port;\n        } else {\n            ip6_sig->port_src = udp0->dst_port;\n            ip6_sig->port_dst = udp0->src_port;\n        }\n    } else {\n        ip6_sig->port_src = 0;\n        ip6_sig->port_dst = 0;\n    }\n"]], "pred": {"ppl": 1.7171202898025513, "ppl_lower": 1.7840967178344727, "ppl/lowercase_ppl": -1.070773523640608, "ppl/zlib": 0.0015625683167268915, "Min_5.0% Prob": 5.750353524559422, "Min_10.0% Prob": 4.154233956948305, "Min_20.0% Prob": 2.5625637700924506, "Min_30.0% Prob": 1.777446920482012, "Min_40.0% Prob": 1.3484761602579591, "Min_50.0% Prob": 1.0806787649981486, "Min_60.0% Prob": 0.900926974171705}}
{"hexsha": "b12058d21f82511055f0993858646d691e115fda", "ext": "c", "lang": "C", "content": "static void\nemit_time (LogBuffer *logbuffer, uint64_t value)\n{\n\tuint64_t tdiff = value - logbuffer->last_time;\n\tunsigned char *p;\n\tif (value < logbuffer->last_time)\n\t\tprintf (\"time went backwards\\n\");\n\t//if (tdiff > 1000000)\n\t//\tprintf (\"large time offset: %llu\\n\", tdiff);\n\tp = logbuffer->data;\n\tencode_uleb128 (tdiff, logbuffer->data, &logbuffer->data);\n\t/*if (tdiff != decode_uleb128 (p, &p))\n\t\tprintf (\"incorrect encoding: %llu\\n\", tdiff);*/\n\tlogbuffer->last_time = value;\n\tassert (logbuffer->data <= logbuffer->data_end);\n}", "item_id": 6, "repo": "kingsoft-topgame/mono", "file": "mono/profiler/proflog.c", "last_update_at": "2019-11-14T08:19:55+00:00", "question_id": "b12058d21f82511055f0993858646d691e115fda_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nemit_time (LogBuffer *logbuffer, uint64_t value)\n{\n\tuint64_t tdiff = value - logbuffer->last_time;\n\tunsigned char *p;\n\tif (value < logbuffer->last_time)\n\t\tprintf (\"time went backwards\\n\");\n\t//if (tdiff > 1000000)\n\t//\tprintf (\"large time offset: %llu\\n\", tdiff);\n\tp = logbuffer->data;\n\tencode_uleb128 (tdiff, logbuffer->data, &logbuffer->data);\n\t/*if (tdiff != decode_uleb128 (p, &p))\n\t\tprintf (\"incorrect encoding: %llu\\n\", tdiff);*/\n\tlogbuffer->last_time = value;\n\tassert (logbuffer->data <= logbuffer->data_end);\n"]], "pred": {"ppl": 2.683436155319214, "ppl_lower": 2.716470241546631, "ppl/lowercase_ppl": -1.0123951319601925, "ppl/zlib": 0.0036157440321638082, "Min_5.0% Prob": 6.568251848220825, "Min_10.0% Prob": 5.263259524390811, "Min_20.0% Prob": 3.881262183189392, "Min_30.0% Prob": 2.9664606272228182, "Min_40.0% Prob": 2.357195534521625, "Min_50.0% Prob": 1.9307575562170574, "Min_60.0% Prob": 1.6314778964197825}}
{"hexsha": "3128c9ecdd0b7c704bb37e328345279aed836b63", "ext": "c", "lang": "C", "content": "static void rebrick_tcpsocket_asclient_memory(void **start)\n{\n\n    unused(start);\n    const char *port = \"80\";\n    rebrick_tcpsocket_t *client;\n    rebrick_sockaddr_t addr;\n    rebrick_util_ip_port_to_addr(\"127.0.0.1\", port, &addr);\n    struct callbackdata data;\n\n    fill_zero(&data, sizeof(struct callbackdata));\n\n    char *head = \"GET / HTTP/1.0\\r\\n\\\nHost: nodejs.org\\r\\n\\\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\\r\\n\\\nAccept: text/html\\r\\n\\\n\\r\\n\";\n#define COUNTER 100\n\n    new2(rebrick_tcpsocket_callbacks_t, callbacks);\n    callbacks.callback_data = &data;\n    callbacks.on_connection_accepted = on_connection_accepted_memorytest;\n    callbacks.on_connection_closed = on_connection_closed_memorytest;\n    callbacks.on_data_received = on_datarecevied_memorytest;\n    callbacks.on_data_sended = on_datasend_memorytest;\n    callbacks.on_error_occured = on_error_occured_memorytest;\n\n    for (int i = 0; i < COUNTER; ++i)\n    {\n\n        int32_t result = rebrick_tcpsocket_new(&client, addr, 0, &callbacks);\n        assert_int_equal(result, REBRICK_SUCCESS);\n\n        //check a little\n        int counter = 1000;\n        while (--counter && !connected_to_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n\n        datasended_memorytest = 0;\n        datareceived_ok_memorytest = 0;\n        connection_closed_memorytest = 0;\n        rebrick_clean_func_t cleanfunc = {};\n        result = rebrick_tcpsocket_send(client, cast(head, uint8_t *), strlen(head) + 1, cleanfunc);\n\n        counter = 1000;\n        while (--counter && !datasended_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_int_equal(datasended_memorytest, 10); //this value is used above\n\n        counter = 1000;\n        while (--counter && !datareceived_ok_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_true(datareceived_ok_memorytest > 0);\n\n        rebrick_tcpsocket_destroy(client);\n        counter = 1000;\n        while (--counter && !connection_closed_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_true(connection_closed_memorytest != 0);\n    }\n}", "item_id": 16, "repo": "hamzakilic/rebrick.io", "file": "test/test_rebrick_tcpsocket.c", "last_update_at": "2019-06-30T13:47:06+00:00", "question_id": "3128c9ecdd0b7c704bb37e328345279aed836b63_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void rebrick_tcpsocket_asclient_memory(void **start)\n{\n    unused(start);\n    const char *port = \"80\";\n    rebrick_tcpsocket_t *client;\n    rebrick_sockaddr_t addr;\n    rebrick_util_ip_port_to_addr(\"127.0.0.1\", port, &addr);\n    struct callbackdata data;\n    fill_zero(&data, sizeof(struct callbackdata));\n    char *head = \"GET / HTTP/1.0\\r\\n\\\nHost: nodejs.org\\r\\n\\\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\\r\\n\\\nAccept: text/html\\r\\n\\\n\\r\\n\";\n#define COUNTER 100\n    new2(rebrick_tcpsocket_callbacks_t, callbacks);\n    callbacks.callback_data = &data;\n    callbacks.on_connection_accepted = on_connection_accepted_memorytest;\n    callbacks.on_connection_closed = on_connection_closed_memorytest;\n    callbacks.on_data_received = on_datarecevied_memorytest;\n    callbacks.on_data_sended = on_datasend_memorytest;\n    callbacks.on_error_occured = on_error_occured_memorytest;\n    for (int i = 0; i < COUNTER; ++i)\n    {\n        int32_t result = rebrick_tcpsocket_new(&client, addr, 0, &callbacks);\n        assert_int_equal(result, REBRICK_SUCCESS);\n        //check a little\n        int counter = 1000;\n        while (--counter && !connected_to_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        datasended_memorytest = 0;\n        datareceived_ok_memorytest = 0;\n        connection_closed_memorytest = 0;\n        rebrick_clean_func_t cleanfunc = {};\n        result = rebrick_tcpsocket_send(client, cast(head, uint8_t *), strlen(head) + 1, cleanfunc);\n        counter = 1000;\n        while (--counter && !datasended_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_int_equal(datasended_memorytest, 10); //this value is used above\n        counter = 1000;\n        while (--counter && !datareceived_ok_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_true(datareceived_ok_memorytest > 0);\n        rebrick_tcpsocket_destroy(client);\n        counter = 1000;\n        while (--counter && !connection_closed_memorytest)\n        {\n            uv_run(uv_default_loop(), UV_RUN_NOWAIT);\n            usleep(1000);\n        }\n        assert_true(connection_closed_memorytest != 0);\n    }\n"]], "pred": {"ppl": 2.04239821434021, "ppl_lower": 2.183255434036255, "ppl/lowercase_ppl": -1.093390366477848, "ppl/zlib": 0.0008624694597221141, "Min_5.0% Prob": 7.016963557763533, "Min_10.0% Prob": 5.149102090449816, "Min_20.0% Prob": 3.2751955086958473, "Min_30.0% Prob": 2.328459360817475, "Min_40.0% Prob": 1.7748907339764375, "Min_50.0% Prob": 1.425227113334196, "Min_60.0% Prob": 1.1907446930554368}}
{"hexsha": "a88826d6263aef0e881de66e56a052018fbd6e56", "ext": "c", "lang": "C", "content": "void combuf_clearwr2rd(struct combuf*cb){\n  if(combuf_state(cb)!=CBWRITE)app_message(FATAL,\"attempt to clear a CBREAD combuf to a CBWRITE combuf in combuf_clearwr2rd()\");\n  cb->state_=CBREAD;\n  cb->tmo_=NULL;\n  cb->eof_=0;\n  buf_reset(cb->buf_,RDBUF);\n}", "item_id": 5, "repo": "hansewetz/para", "file": "c/apps/para/combuf.c", "last_update_at": "2019-07-30T20:55:41+00:00", "question_id": "a88826d6263aef0e881de66e56a052018fbd6e56_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void combuf_clearwr2rd(struct combuf*cb){\n  if(combuf_state(cb)!=CBWRITE)app_message(FATAL,\"attempt to clear a CBREAD combuf to a CBWRITE combuf in combuf_clearwr2rd()\");\n  cb->state_=CBREAD;\n  cb->tmo_=NULL;\n  cb->eof_=0;\n  buf_reset(cb->buf_,RDBUF);\n"]], "pred": {"ppl": 8.23298454284668, "ppl_lower": 9.45645523071289, "ppl/lowercase_ppl": -1.0657207045322101, "ppl/zlib": 0.011978116993474279, "Min_5.0% Prob": 10.660385131835938, "Min_10.0% Prob": 9.051956220106645, "Min_20.0% Prob": 7.371629866686734, "Min_30.0% Prob": 6.046394268671672, "Min_40.0% Prob": 4.97208661924709, "Min_50.0% Prob": 4.079322893704687, "Min_60.0% Prob": 3.4715953994153153}}
{"hexsha": "79ec8a0f4e234203ffa359f6f822b8e348cc2afb", "ext": "c", "lang": "C", "content": "ret_t rtl8370_setAsicIpMulticastPortIsoLeaky( uint32 port, uint32 enabled )\n{\n    if(port > RTL8370_PORTIDMAX)\n        return RT_ERR_PORT_ID;\n\n    if(enabled > 1)\n        return RT_ERR_ENABLE;\n    \n    return rtl8370_setAsicRegBit(RTL8370_REG_IPMCAST_PORTISO_LEAKY, port, enabled);\n}", "item_id": 1, "repo": "libc0607/nodemcu-firmware", "file": "app/rtl8370/rtl8370_asicdrv_igmp.c", "last_update_at": "2019-06-28T01:30:07+00:00", "question_id": "79ec8a0f4e234203ffa359f6f822b8e348cc2afb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ret_t rtl8370_setAsicIpMulticastPortIsoLeaky( uint32 port, uint32 enabled )\n{\n    if(port > RTL8370_PORTIDMAX)\n        return RT_ERR_PORT_ID;\n    if(enabled > 1)\n        return RT_ERR_ENABLE;\n    return rtl8370_setAsicRegBit(RTL8370_REG_IPMCAST_PORTISO_LEAKY, port, enabled);\n"]], "pred": {"ppl": 2.2618610858917236, "ppl_lower": 5.619714260101318, "ppl/lowercase_ppl": -2.1150530219949526, "ppl/zlib": 0.00436464151730217, "Min_5.0% Prob": 6.699527581532796, "Min_10.0% Prob": 5.3301974810086765, "Min_20.0% Prob": 3.70684997852032, "Min_30.0% Prob": 2.6473698868201327, "Min_40.0% Prob": 2.0491122256677885, "Min_50.0% Prob": 1.6268882454570495, "Min_60.0% Prob": 1.3620708377536717}}
{"hexsha": "1fe860084db624f1b6ace61076b3d0c1ea0e92d8", "ext": "c", "lang": "C", "content": "void open_bit_stream_r(bs, bs_filenam, size)\r\nbitstream_t *bs;   /* bit stream structure */\r\nchar *bs_filenam;       /* name of the bit stream file */\r\nint size;               /* size of the buffer */\r\n{\r\n   register unsigned long n;\r\n   register unsigned char flag = 1;\r\n   unsigned char val;\r\n\t\r\n   if ((bs->pt = fopen(bs_filenam, \"rb\")) == NULL) {\r\n      printf(\"Could not find \\\"%s\\\".\\n\", bs_filenam);\r\n      exit(1);\r\n   }\r\n\r\n   do {\r\n     n = fread(&val, sizeof(unsigned char), 1, bs->pt);\r\n     switch (val) {\r\n      case 0x30:\r\n      case 0x31:\r\n      case 0x32:\r\n      case 0x33:\r\n      case 0x34:\r\n      case 0x35:\r\n      case 0x36:\r\n      case 0x37:\r\n      case 0x38:\r\n      case 0x39:\r\n      case 0x41:\r\n      case 0x42:\r\n      case 0x43:\r\n      case 0x44:\r\n      case 0x45:\r\n      case 0x46:\r\n      case 0xa:  /* \\n */\r\n      case 0xd:  /* cr */\r\n      case 0x1a:  /* sub */\r\n          break;\r\n\r\n      default: /* detection of an binary character */\r\n          flag--;\r\n          break;\r\n     }\r\n\r\n   } while (flag & n);\r\n\r\n   if (flag) {\r\n      printf (\"the bit stream file %s is an ASCII file\\n\", bs_filenam);\r\n      bs->format = ASCII;\r\n   }\r\n   else {\r\n      bs->format = BINARY;\r\n      printf (\"the bit stream file %s is a BINARY file\\n\", bs_filenam);\r\n   }\r\n\r\n   fclose(bs->pt);\r\n\r\n   if ((bs->pt = fopen(bs_filenam, \"rb\")) == NULL) {\r\n      printf(\"Could not find \\\"%s\\\".\\n\", bs_filenam);\r\n      exit(1);\r\n   }\r\n\r\n   alloc_buffer(bs, size);\r\n   bs->buf_byte_idx=0;\r\n   bs->buf_bit_idx=0;\r\n   bs->totbit=0;\r\n   bs->mode = READ_MODE;\r\n   bs->eob = FALSE;\r\n   bs->eobs = FALSE;\r\n}", "item_id": 4, "repo": "victoryckl/flex-demos", "file": "Shine-MP3-Encoder-on-AS3-Alchemy/lib/shine/bitstream.c", "last_update_at": "2019-02-16T17:19:28+00:00", "question_id": "1fe860084db624f1b6ace61076b3d0c1ea0e92d8_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void open_bit_stream_r(bs, bs_filenam, size)\r\nbitstream_t *bs;   /* bit stream structure */\r\nchar *bs_filenam;       /* name of the bit stream file */\r\nint size;               /* size of the buffer */\r\n{\r\n   register unsigned long n;\r\n   register unsigned char flag = 1;\r\n   unsigned char val;\r\n\t\r\n   if ((bs->pt = fopen(bs_filenam, \"rb\")) == NULL) {\r\n      printf(\"Could not find \\\"%s\\\".\\n\", bs_filenam);\r\n      exit(1);\r\n   }\r\n\r\n   do {\r\n     n = fread(&val, sizeof(unsigned char), 1, bs->pt);\r\n     switch (val) {\r\n      case 0x30:\r\n      case 0x31:\r\n      case 0x32:\r\n      case 0x33:\r\n      case 0x34:\r\n      case 0x35:\r\n      case 0x36:\r\n      case 0x37:\r\n      case 0x38:\r\n      case 0x39:\r\n      case 0x41:\r\n      case 0x42:\r\n      case 0x43:\r\n      case 0x44:\r\n      case 0x45:\r\n      case 0x46:\r\n      case 0xa:  /* \\n */\r\n      case 0xd:  /* cr */\r\n      case 0x1a:  /* sub */\r\n          break;\r\n\r\n      default: /* detection of an binary character */\r\n          flag--;\r\n          break;\r\n     }\r\n\r\n   } while (flag & n);\r\n\r\n   if (flag) {\r\n      printf (\"the bit stream file %s is an ASCII file\\n\", bs_filenam);\r\n      bs->format = ASCII;\r\n   }\r\n   else {\r\n      bs->format = BINARY;\r\n      printf (\"the bit stream file %s is a BINARY file\\n\", bs_filenam);\r\n   }\r\n\r\n   fclose(bs->pt);\r\n\r\n   if ((bs->pt = fopen(bs_filenam, \"rb\")) == NULL) {\r\n      printf(\"Could not find \\\"%s\\\".\\n\", bs_filenam);\r\n      exit(1);\r\n   }\r\n\r\n   alloc_buffer(bs, size);\r\n   bs->buf_byte_idx=0;\r\n   bs->buf_bit_idx=0;\r\n   bs->totbit=0;\r\n   bs->mode = READ_MODE;\r\n   bs->eob = FALSE;\r\n   bs->eobs = FALSE;\r\n"]], "pred": {"ppl": 2.2227532863616943, "ppl_lower": 2.2754714488983154, "ppl/lowercase_ppl": -1.0293467456681886, "ppl/zlib": 0.0013939732051127997, "Min_5.0% Prob": 7.08358970284462, "Min_10.0% Prob": 5.401018835604191, "Min_20.0% Prob": 3.533951822668314, "Min_30.0% Prob": 2.575117301971962, "Min_40.0% Prob": 1.977256998680677, "Min_50.0% Prob": 1.5956520865152002, "Min_60.0% Prob": 1.3331762768509616}}
{"hexsha": "4108b1a357bc57f422033dfebecfc51c36b1fe92", "ext": "c", "lang": "C", "content": "UINT32\nAnMapEtypeToBtype (\n    UINT32              Etype)\n{\n\n\n    if (Etype == ACPI_TYPE_ANY)\n    {\n        return ACPI_BTYPE_OBJECTS_AND_REFS;\n    }\n\n    /* Try the standard ACPI data types */\n\n    if (Etype <= ACPI_TYPE_EXTERNAL_MAX)\n    {\n        /*\n         * This switch statement implements the allowed operand conversion\n         * rules as per the \"ASL Data Types\" section of the ACPI\n         * specification.\n         */\n        switch (Etype)\n        {\n        case ACPI_TYPE_INTEGER:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DDB_HANDLE);\n\n        case ACPI_TYPE_STRING:\n        case ACPI_TYPE_BUFFER:\n            return (ACPI_BTYPE_COMPUTE_DATA);\n\n        case ACPI_TYPE_PACKAGE:\n            return (ACPI_BTYPE_PACKAGE);\n\n        case ACPI_TYPE_FIELD_UNIT:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);\n\n        case ACPI_TYPE_BUFFER_FIELD:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_BUFFER_FIELD);\n\n        case ACPI_TYPE_DDB_HANDLE:\n            return (ACPI_BTYPE_INTEGER | ACPI_BTYPE_DDB_HANDLE);\n\n        case ACPI_BTYPE_DEBUG_OBJECT:\n\n            /* Cannot be used as a source operand */\n\n            return (0);\n\n        default:\n            return (1 << (Etype - 1));\n        }\n    }\n\n    /* Try the internal data types */\n\n    switch (Etype)\n    {\n    case ACPI_TYPE_LOCAL_REGION_FIELD:\n    case ACPI_TYPE_LOCAL_BANK_FIELD:\n    case ACPI_TYPE_LOCAL_INDEX_FIELD:\n\n        /* Named fields can be either Integer/Buffer/String */\n\n        return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);\n\n    case ACPI_TYPE_LOCAL_ALIAS:\n\n        return (ACPI_BTYPE_INTEGER);\n\n\n    case ACPI_TYPE_LOCAL_RESOURCE:\n    case ACPI_TYPE_LOCAL_RESOURCE_FIELD:\n\n        return (ACPI_BTYPE_REFERENCE);\n\n    default:\n        printf (\"Unhandled encoded type: %X\\n\", Etype);\n        return (0);\n    }\n}", "item_id": 0, "repo": "shisa/kame-shisa", "file": "freebsd5/sys/contrib/dev/acpica/compiler/aslanalyze.c", "last_update_at": "2019-10-15T06:29:32+00:00", "question_id": "4108b1a357bc57f422033dfebecfc51c36b1fe92_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["UINT32\nAnMapEtypeToBtype (\n    UINT32              Etype)\n{\n    if (Etype == ACPI_TYPE_ANY)\n    {\n        return ACPI_BTYPE_OBJECTS_AND_REFS;\n    }\n    /* Try the standard ACPI data types */\n    if (Etype <= ACPI_TYPE_EXTERNAL_MAX)\n    {\n        /*\n         * This switch statement implements the allowed operand conversion\n         * rules as per the \"ASL Data Types\" section of the ACPI\n         * specification.\n         */\n        switch (Etype)\n        {\n        case ACPI_TYPE_INTEGER:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DDB_HANDLE);\n        case ACPI_TYPE_STRING:\n        case ACPI_TYPE_BUFFER:\n            return (ACPI_BTYPE_COMPUTE_DATA);\n        case ACPI_TYPE_PACKAGE:\n            return (ACPI_BTYPE_PACKAGE);\n        case ACPI_TYPE_FIELD_UNIT:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);\n        case ACPI_TYPE_BUFFER_FIELD:\n            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_BUFFER_FIELD);\n        case ACPI_TYPE_DDB_HANDLE:\n            return (ACPI_BTYPE_INTEGER | ACPI_BTYPE_DDB_HANDLE);\n        case ACPI_BTYPE_DEBUG_OBJECT:\n            /* Cannot be used as a source operand */\n            return (0);\n        default:\n            return (1 << (Etype - 1));\n        }\n    }\n    /* Try the internal data types */\n    switch (Etype)\n    {\n    case ACPI_TYPE_LOCAL_REGION_FIELD:\n    case ACPI_TYPE_LOCAL_BANK_FIELD:\n    case ACPI_TYPE_LOCAL_INDEX_FIELD:\n        /* Named fields can be either Integer/Buffer/String */\n        return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);\n    case ACPI_TYPE_LOCAL_ALIAS:\n        return (ACPI_BTYPE_INTEGER);\n    case ACPI_TYPE_LOCAL_RESOURCE:\n    case ACPI_TYPE_LOCAL_RESOURCE_FIELD:\n        return (ACPI_BTYPE_REFERENCE);\n    default:\n        printf (\"Unhandled encoded type: %X\\n\", Etype);\n        return (0);\n    }\n"]], "pred": {"ppl": 1.8213841915130615, "ppl_lower": 2.3913962841033936, "ppl/lowercase_ppl": -1.4541062885074865, "ppl/zlib": 0.0009749540761113337, "Min_5.0% Prob": 6.480231270645604, "Min_10.0% Prob": 4.572702564410309, "Min_20.0% Prob": 2.8520702991022993, "Min_30.0% Prob": 1.9760204638437469, "Min_40.0% Prob": 1.4978892941609523, "Min_50.0% Prob": 1.1982108902639381, "Min_60.0% Prob": 1.0001676972318063}}
{"hexsha": "884198c0eceb02740e4560694fdd1ac870263d08", "ext": "h", "lang": "C", "content": "public Loggable\n{\npublic:\n\n  SESystem(Logger* logger);\n  virtual ~SESystem();\n\n  virtual void Clear();// Deletes all members\n  \n  /** @name GetScalar\n  *   @brief - A reflextion type call that will return the Scalar associated\n  *            with the string. ex. GetScalar(\"Hematocrit\") will return the\n  *            SEScalarPercent object associated with Hematocrit\n  *   @details - Note this is an expensive call as it will string compare many times\n  *              This is best used, and intended for, you to dynamically prepopulate\n  *              a mapping data structure that will help access what you need\n  */\n  virtual const SEScalar* GetScalar(const std::string& name) = 0; \n\n  /** @name GetScalar\n  *   @brief - Look for the Scalar property in the systems contained in the provided vector\n  */\n  static const SEScalar* GetScalar(const std::string& name, std::vector<SESystem*>* systems);\n\nprotected:\n  std::stringstream m_ss;\n}", "item_id": 0, "repo": "isuhao/engine1", "file": "cdm/cpp/system/SESystem.h", "last_update_at": "2019-05-02T18:39:45+00:00", "question_id": "884198c0eceb02740e4560694fdd1ac870263d08_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["public Loggable\n{\npublic:\n  SESystem(Logger* logger);\n  virtual ~SESystem();\n  virtual void Clear();// Deletes all members\n  /** @name GetScalar\n  *   @brief - A reflextion type call that will return the Scalar associated\n  *            with the string. ex. GetScalar(\"Hematocrit\") will return the\n  *            SEScalarPercent object associated with Hematocrit\n  *   @details - Note this is an expensive call as it will string compare many times\n  *              This is best used, and intended for, you to dynamically prepopulate\n  *              a mapping data structure that will help access what you need\n  */\n  virtual const SEScalar* GetScalar(const std::string& name) = 0; \n  /** @name GetScalar\n  *   @brief - Look for the Scalar property in the systems contained in the provided vector\n  */\n  static const SEScalar* GetScalar(const std::string& name, std::vector<SESystem*>* systems);\nprotected:\n  std::stringstream m_ss;\n"]], "pred": {"ppl": 5.619093894958496, "ppl_lower": 7.48704195022583, "ppl/lowercase_ppl": -1.1662659493852903, "ppl/zlib": 0.003752544396199546, "Min_5.0% Prob": 9.1666506253756, "Min_10.0% Prob": 7.7359344870955855, "Min_20.0% Prob": 6.009844598946748, "Min_30.0% Prob": 4.874541327720735, "Min_40.0% Prob": 4.019226589334121, "Min_50.0% Prob": 3.3627642367007957, "Min_60.0% Prob": 2.864031350830706}}
{"hexsha": "8d78c26567d19d4bb954e8235f54bea150eb0aa3", "ext": "c", "lang": "C", "content": "static void box_project(texture_t* tex, float* u, float* v, float x, float y, float z, float nx, float ny, float nz)\r\n{\r\n    enum {X, Y, Z} major_axis = X;\r\n    float ax = fabs(nx);\r\n    float ay = fabs(ny);\r\n    float az = fabs(nz);\r\n    if (ax > ay) {\r\n        if (ax > az) major_axis = X; else major_axis = Z;\r\n    } else {\r\n        if (ay > az) major_axis = Y; else major_axis = Z;\r\n    }\r\n\r\n    switch (major_axis) {\r\n    case X:\r\n        if (nx > 0) {\r\n            *u = -z;\r\n            *v = -y;\r\n        } else {\r\n            *u = z;\r\n            *v = -y;\r\n        }\r\n        break;\r\n    case Y:\r\n        if (ny > 0) {\r\n            *u = x;\r\n            *v = z;\r\n        } else {\r\n            *u = x;\r\n            *v = -z;\r\n        }\r\n        break;\r\n    case Z:\r\n        if (nz > 0) {\r\n            *u = x;\r\n            *v = -y;\r\n        } else {\r\n            *u = -x;\r\n            *v = -y;\r\n        }\r\n        break;\r\n    }\r\n\r\n    *u /= (float)(tex?tex->w:1);\r\n    *v /= (float)(tex?tex->h:1);\r\n}", "item_id": 6, "repo": "dreamsxin/alithia", "file": "src/atest.c", "last_update_at": "2019-03-29T00:14:54+00:00", "question_id": "8d78c26567d19d4bb954e8235f54bea150eb0aa3_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void box_project(texture_t* tex, float* u, float* v, float x, float y, float z, float nx, float ny, float nz)\r\n{\r\n    enum {X, Y, Z} major_axis = X;\r\n    float ax = fabs(nx);\r\n    float ay = fabs(ny);\r\n    float az = fabs(nz);\r\n    if (ax > ay) {\r\n        if (ax > az) major_axis = X; else major_axis = Z;\r\n    } else {\r\n        if (ay > az) major_axis = Y; else major_axis = Z;\r\n    }\r\n\r\n    switch (major_axis) {\r\n    case X:\r\n        if (nx > 0) {\r\n            *u = -z;\r\n            *v = -y;\r\n        } else {\r\n            *u = z;\r\n            *v = -y;\r\n        }\r\n        break;\r\n    case Y:\r\n        if (ny > 0) {\r\n            *u = x;\r\n            *v = z;\r\n        } else {\r\n            *u = x;\r\n            *v = -z;\r\n        }\r\n        break;\r\n    case Z:\r\n        if (nz > 0) {\r\n            *u = x;\r\n            *v = -y;\r\n        } else {\r\n            *u = -x;\r\n            *v = -y;\r\n        }\r\n        break;\r\n    }\r\n\r\n    *u /= (float)(tex?tex->w:1);\r\n    *v /= (float)(tex?tex->h:1);\r\n"]], "pred": {"ppl": 1.6090317964553833, "ppl_lower": 1.6239203214645386, "ppl/lowercase_ppl": -1.0193648361943293, "ppl/zlib": 0.0016177980593212894, "Min_5.0% Prob": 6.110188788837856, "Min_10.0% Prob": 3.877258020478326, "Min_20.0% Prob": 2.2864847417672474, "Min_30.0% Prob": 1.575194918113736, "Min_40.0% Prob": 1.192637280151248, "Min_50.0% Prob": 0.9530113684459331, "Min_60.0% Prob": 0.7931970566716169}}
{"hexsha": "2772fee93881f1fc85d5e8a56b7a31fa3e1c5cca", "ext": "c", "lang": "C", "content": "int\nsvc_recv(struct svc_rqst *rqstp, long timeout)\n{\n\tstruct svc_sock\t\t*svsk = NULL;\n\tstruct svc_serv\t\t*serv = rqstp->rq_server;\n\tstruct svc_pool\t\t*pool = rqstp->rq_pool;\n\tint\t\t\tlen, i;\n\tint \t\t\tpages;\n\tstruct xdr_buf\t\t*arg;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tdprintk(\"svc: server %p waiting for data (to = %ld)\\n\",\n\t\trqstp, timeout);\n\n\tif (rqstp->rq_sock)\n\t\tprintk(KERN_ERR\n\t\t\t\"svc_recv: service %p, socket not NULL!\\n\",\n\t\t\t rqstp);\n\tif (waitqueue_active(&rqstp->rq_wait))\n\t\tprintk(KERN_ERR\n\t\t\t\"svc_recv: service %p, wait queue active!\\n\",\n\t\t\t rqstp);\n\n\n\t/* now allocate needed pages.  If we get a failure, sleep briefly */\n\tpages = (serv->sv_max_mesg + PAGE_SIZE) / PAGE_SIZE;\n\tfor (i=0; i < pages ; i++)\n\t\twhile (rqstp->rq_pages[i] == NULL) {\n\t\t\tstruct page *p = alloc_page(GFP_KERNEL);\n\t\t\tif (!p)\n\t\t\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(500));\n\t\t\trqstp->rq_pages[i] = p;\n\t\t}\n\trqstp->rq_pages[i++] = NULL; /* this might be seen in nfs_read_actor */\n\tBUG_ON(pages >= RPCSVC_MAXPAGES);\n\n\t/* Make arg->head point to first page and arg->pages point to rest */\n\targ = &rqstp->rq_arg;\n\targ->head[0].iov_base = page_address(rqstp->rq_pages[0]);\n\targ->head[0].iov_len = PAGE_SIZE;\n\targ->pages = rqstp->rq_pages + 1;\n\targ->page_base = 0;\n\t/* save at least one page for response */\n\targ->page_len = (pages-2)*PAGE_SIZE;\n\targ->len = (pages-1)*PAGE_SIZE;\n\targ->tail[0].iov_len = 0;\n\n\ttry_to_freeze();\n\tcond_resched();\n\tif (signalled())\n\t\treturn -EINTR;\n\n\tspin_lock_bh(&pool->sp_lock);\n\tif ((svsk = svc_sock_dequeue(pool)) != NULL) {\n\t\trqstp->rq_sock = svsk;\n\t\tatomic_inc(&svsk->sk_inuse);\n\t\trqstp->rq_reserved = serv->sv_max_mesg;\n\t\tatomic_add(rqstp->rq_reserved, &svsk->sk_reserved);\n\t} else {\n\t\t/* No data pending. Go to sleep */\n\t\tsvc_thread_enqueue(pool, rqstp);\n\n\t\t/*\n\t\t * We have to be able to interrupt this wait\n\t\t * to bring down the daemons ...\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&rqstp->rq_wait, &wait);\n\t\tspin_unlock_bh(&pool->sp_lock);\n\n\t\tschedule_timeout(timeout);\n\n\t\ttry_to_freeze();\n\n\t\tspin_lock_bh(&pool->sp_lock);\n\t\tremove_wait_queue(&rqstp->rq_wait, &wait);\n\n\t\tif (!(svsk = rqstp->rq_sock)) {\n\t\t\tsvc_thread_dequeue(pool, rqstp);\n\t\t\tspin_unlock_bh(&pool->sp_lock);\n\t\t\tdprintk(\"svc: server %p, no data yet\\n\", rqstp);\n\t\t\treturn signalled()? -EINTR : -EAGAIN;\n\t\t}\n\t}\n\tspin_unlock_bh(&pool->sp_lock);\n\n\tdprintk(\"svc: server %p, pool %u, socket %p, inuse=%d\\n\",\n\t\t rqstp, pool->sp_id, svsk, atomic_read(&svsk->sk_inuse));\n\tlen = svsk->sk_recvfrom(rqstp);\n\tdprintk(\"svc: got len=%d\\n\", len);\n\n\t/* No data, incomplete (TCP) read, or accept() */\n\tif (len == 0 || len == -EAGAIN) {\n\t\trqstp->rq_res.len = 0;\n\t\tsvc_sock_release(rqstp);\n\t\treturn -EAGAIN;\n\t}\n\tsvsk->sk_lastrecv = get_seconds();\n\tclear_bit(SK_OLD, &svsk->sk_flags);\n\n\trqstp->rq_secure = svc_port_is_privileged(svc_addr(rqstp));\n\trqstp->rq_chandle.defer = svc_defer;\n\n\tif (serv->sv_stats)\n\t\tserv->sv_stats->netcnt++;\n\treturn len;\n}", "item_id": 26, "repo": "ghsecuritylab/DIR600B2", "file": "dir600b_v2.03/kernels/rt305x/net/sunrpc/svcsock.c", "last_update_at": "2019-07-21T01:58:19+00:00", "question_id": "2772fee93881f1fc85d5e8a56b7a31fa3e1c5cca_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nsvc_recv(struct svc_rqst *rqstp, long timeout)\n{\n\tstruct svc_sock\t\t*svsk = NULL;\n\tstruct svc_serv\t\t*serv = rqstp->rq_server;\n\tstruct svc_pool\t\t*pool = rqstp->rq_pool;\n\tint\t\t\tlen, i;\n\tint \t\t\tpages;\n\tstruct xdr_buf\t\t*arg;\n\tDECLARE_WAITQUEUE(wait, current);\n\tdprintk(\"svc: server %p waiting for data (to = %ld)\\n\",\n\t\trqstp, timeout);\n\tif (rqstp->rq_sock)\n\t\tprintk(KERN_ERR\n\t\t\t\"svc_recv: service %p, socket not NULL!\\n\",\n\t\t\t rqstp);\n\tif (waitqueue_active(&rqstp->rq_wait))\n\t\tprintk(KERN_ERR\n\t\t\t\"svc_recv: service %p, wait queue active!\\n\",\n\t\t\t rqstp);\n\t/* now allocate needed pages.  If we get a failure, sleep briefly */\n\tpages = (serv->sv_max_mesg + PAGE_SIZE) / PAGE_SIZE;\n\tfor (i=0; i < pages ; i++)\n\t\twhile (rqstp->rq_pages[i] == NULL) {\n\t\t\tstruct page *p = alloc_page(GFP_KERNEL);\n\t\t\tif (!p)\n\t\t\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(500));\n\t\t\trqstp->rq_pages[i] = p;\n\t\t}\n\trqstp->rq_pages[i++] = NULL; /* this might be seen in nfs_read_actor */\n\tBUG_ON(pages >= RPCSVC_MAXPAGES);\n\t/* Make arg->head point to first page and arg->pages point to rest */\n\targ = &rqstp->rq_arg;\n\targ->head[0].iov_base = page_address(rqstp->rq_pages[0]);\n\targ->head[0].iov_len = PAGE_SIZE;\n\targ->pages = rqstp->rq_pages + 1;\n\targ->page_base = 0;\n\t/* save at least one page for response */\n\targ->page_len = (pages-2)*PAGE_SIZE;\n\targ->len = (pages-1)*PAGE_SIZE;\n\targ->tail[0].iov_len = 0;\n\ttry_to_freeze();\n\tcond_resched();\n\tif (signalled())\n\t\treturn -EINTR;\n\tspin_lock_bh(&pool->sp_lock);\n\tif ((svsk = svc_sock_dequeue(pool)) != NULL) {\n\t\trqstp->rq_sock = svsk;\n\t\tatomic_inc(&svsk->sk_inuse);\n\t\trqstp->rq_reserved = serv->sv_max_mesg;\n\t\tatomic_add(rqstp->rq_reserved, &svsk->sk_reserved);\n\t} else {\n\t\t/* No data pending. Go to sleep */\n\t\tsvc_thread_enqueue(pool, rqstp);\n\t\t/*\n\t\t * We have to be able to interrupt this wait\n\t\t * to bring down the daemons ...\n\t\t */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&rqstp->rq_wait, &wait);\n\t\tspin_unlock_bh(&pool->sp_lock);\n\t\tschedule_timeout(timeout);\n\t\ttry_to_freeze();\n\t\tspin_lock_bh(&pool->sp_lock);\n\t\tremove_wait_queue(&rqstp->rq_wait, &wait);\n\t\tif (!(svsk = rqstp->rq_sock)) {\n\t\t\tsvc_thread_dequeue(pool, rqstp);\n\t\t\tspin_unlock_bh(&pool->sp_lock);\n\t\t\tdprintk(\"svc: server %p, no data yet\\n\", rqstp);\n\t\t\treturn signalled()? -EINTR : -EAGAIN;\n\t\t}\n\t}\n\tspin_unlock_bh(&pool->sp_lock);\n\tdprintk(\"svc: server %p, pool %u, socket %p, inuse=%d\\n\",\n\t\t rqstp, pool->sp_id, svsk, atomic_read(&svsk->sk_inuse));\n\tlen = svsk->sk_recvfrom(rqstp);\n\tdprintk(\"svc: got len=%d\\n\", len);\n\t/* No data, incomplete (TCP) read, or accept() */\n\tif (len == 0 || len == -EAGAIN) {\n\t\trqstp->rq_res.len = 0;\n\t\tsvc_sock_release(rqstp);\n\t\treturn -EAGAIN;\n\t}\n\tsvsk->sk_lastrecv = get_seconds();\n\tclear_bit(SK_OLD, &svsk->sk_flags);\n\trqstp->rq_secure = svc_port_is_privileged(svc_addr(rqstp));\n\trqstp->rq_chandle.defer = svc_defer;\n\tif (serv->sv_stats)\n\t\tserv->sv_stats->netcnt++;\n\treturn len;\n"]], "pred": {"ppl": 2.015805959701538, "ppl_lower": 2.2304720878601074, "ppl/lowercase_ppl": -1.144352938301056, "ppl/zlib": 0.0005446923818405073, "Min_5.0% Prob": 6.20768934137681, "Min_10.0% Prob": 4.687518426016266, "Min_20.0% Prob": 3.1380477635299457, "Min_30.0% Prob": 2.2792592381729797, "Min_40.0% Prob": 1.7424212659738758, "Min_50.0% Prob": 1.4014863548654546, "Min_60.0% Prob": 1.1694682209321783}}
{"hexsha": "9c46c13fb622f41a797447b836e8a6e64e4ab9fb", "ext": "c", "lang": "C", "content": "unsigned int leon_smp_getbroadcast(void ) \n{\n    unsigned int mask;\n    mask = LEON_BYPASS_LOAD_PA(&(LEON3_IrqCtrl_Regs->mpbroadcast));\n    return mask;\n}", "item_id": 3, "repo": "impedimentToProgress/UCI-BlueChip", "file": "snapgear_linux/linux-2.6.21.1/arch/sparc/kernel/leon_smp.c", "last_update_at": "2019-12-05T02:31:23+00:00", "question_id": "9c46c13fb622f41a797447b836e8a6e64e4ab9fb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsigned int leon_smp_getbroadcast(void ) \n{\n    unsigned int mask;\n    mask = LEON_BYPASS_LOAD_PA(&(LEON3_IrqCtrl_Regs->mpbroadcast));\n    return mask;\n"]], "pred": {"ppl": 8.679327011108398, "ppl_lower": 9.043923377990723, "ppl/lowercase_ppl": -1.0190421824923073, "ppl/zlib": 0.01701530702664532, "Min_5.0% Prob": 9.842514991760254, "Min_10.0% Prob": 8.681041717529297, "Min_20.0% Prob": 6.980277458826701, "Min_30.0% Prob": 5.840444061491224, "Min_40.0% Prob": 4.863229036331177, "Min_50.0% Prob": 4.149916125882056, "Min_60.0% Prob": 3.5929973576519942}}
{"hexsha": "090b61fbd26c16ef7f87504170a2d3a8dc910238", "ext": "c", "lang": "C", "content": "static int list_length(struct item *head) {\n\tstruct item *current;\n\tint count=0;\n\tfor(current=head; current!=NULL; current=current->next) {\n\t\tcount++;\n\t}\n\treturn count;\n}", "item_id": 1, "repo": "leschzinerlab/myami-3.2-freeHand", "file": "modules/radermacher/radon.c", "last_update_at": "2019-09-05T20:58:37+00:00", "question_id": "090b61fbd26c16ef7f87504170a2d3a8dc910238_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int list_length(struct item *head) {\n\tstruct item *current;\n\tint count=0;\n\tfor(current=head; current!=NULL; current=current->next) {\n\t\tcount++;\n\t}\n\treturn count;\n"]], "pred": {"ppl": 2.4167468547821045, "ppl_lower": 2.6683599948883057, "ppl/lowercase_ppl": -1.1122384166767376, "ppl/zlib": 0.006948207566434122, "Min_5.0% Prob": 7.837201754252116, "Min_10.0% Prob": 5.576030095418294, "Min_20.0% Prob": 3.6388115684191384, "Min_30.0% Prob": 2.7290157708856793, "Min_40.0% Prob": 2.147147852306565, "Min_50.0% Prob": 1.7428930786748726, "Min_60.0% Prob": 1.4615565085162718}}
{"hexsha": "0952521785d1af0f4bedae9b78929238ad2d9ce5", "ext": "c", "lang": "C", "content": "static void\nmake_worst_score(DYNMODEL_T *m)\n{\n    int i;\n    int *scores = m->score;\n    int *sbp = m->sbp;\n    int *pbp = m->pbp;\n    int *wbp = m->wbp;\n\n    for (i = 0; i < NODE_CNT; i++) {\n\tscores[i] = WORST_SCORE;\n\twbp[i] = pbp[i] = sbp[i] = NO_BP;\n    }\n}", "item_id": 26, "repo": "hyu-iot/gem5", "file": "mibench/office/sphinx/src/libsphinx2/time_align.c", "last_update_at": "2019-07-08T03:42:24+00:00", "question_id": "0952521785d1af0f4bedae9b78929238ad2d9ce5_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nmake_worst_score(DYNMODEL_T *m)\n{\n    int i;\n    int *scores = m->score;\n    int *sbp = m->sbp;\n    int *pbp = m->pbp;\n    int *wbp = m->wbp;\n    for (i = 0; i < NODE_CNT; i++) {\n\tscores[i] = WORST_SCORE;\n\twbp[i] = pbp[i] = sbp[i] = NO_BP;\n    }\n"]], "pred": {"ppl": 2.712937116622925, "ppl_lower": 3.0834038257598877, "ppl/lowercase_ppl": -1.128254693986122, "ppl/zlib": 0.005905513934135414, "Min_5.0% Prob": 8.053237506321498, "Min_10.0% Prob": 6.117533990315029, "Min_20.0% Prob": 4.139711490699223, "Min_30.0% Prob": 3.0673285140877677, "Min_40.0% Prob": 2.4154765254684856, "Min_50.0% Prob": 1.9814459125910486, "Min_60.0% Prob": 1.6679766550660133}}
{"hexsha": "6560d8ac7fded798ad942b02b89a1da387353a3b", "ext": "c", "lang": "C", "content": "int pcrs_execute_list(pcrs_job *joblist , char *subject ,\n                      size_t subject_length , char **result ,\n                      size_t *result_length ) \n{ pcrs_job *job ;\n  char *old ;\n  char *new ;\n  int hits ;\n  int total_hits ;\n\n  {\n  {\n# 750\n  old = subject;\n# 751\n  (*result_length) = subject_length;\n# 752\n  total_hits = 0;\n# 752\n  hits = total_hits;\n# 754\n  job = joblist;\n  }\n# 754\n  while ((unsigned int )job != (unsigned int )((void *)0)) {\n    {\n# 756\n    hits = pcrs_execute(job, old, (*result_length), & new, result_length);\n    }\n# 758\n    if ((unsigned int )old != (unsigned int )subject) {\n      {\n# 758\n      free((void *)old);\n      }\n    }\n# 760\n    if (hits < 0) {\n# 762\n      return (hits);\n    } else {\n      {\n# 766\n      total_hits += hits;\n# 767\n      old = new;\n      }\n    }\n    {\n# 754\n    job = job->next;\n    }\n  }\n  {\n# 771\n  (*result) = new;\n  }\n# 772\n  return (total_hits);\n}\n}", "item_id": 189, "repo": "tracer-x/tracer", "file": "src/interpreter/tests/SAFETY/MACRO/fileopenclose/privoxy/privoxy-instrumented.c", "last_update_at": "2019-10-08T12:16:55+00:00", "question_id": "6560d8ac7fded798ad942b02b89a1da387353a3b_189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int pcrs_execute_list(pcrs_job *joblist , char *subject ,\n                      size_t subject_length , char **result ,\n                      size_t *result_length ) \n{ pcrs_job *job ;\n  char *old ;\n  char *new ;\n  int hits ;\n  int total_hits ;\n  {\n  {\n# 750\n  old = subject;\n# 751\n  (*result_length) = subject_length;\n# 752\n  total_hits = 0;\n# 752\n  hits = total_hits;\n# 754\n  job = joblist;\n  }\n# 754\n  while ((unsigned int )job != (unsigned int )((void *)0)) {\n    {\n# 756\n    hits = pcrs_execute(job, old, (*result_length), & new, result_length);\n    }\n# 758\n    if ((unsigned int )old != (unsigned int )subject) {\n      {\n# 758\n      free((void *)old);\n      }\n    }\n# 760\n    if (hits < 0) {\n# 762\n      return (hits);\n    } else {\n      {\n# 766\n      total_hits += hits;\n# 767\n      old = new;\n      }\n    }\n    {\n# 754\n    job = job->next;\n    }\n  }\n  {\n# 771\n  (*result) = new;\n  }\n# 772\n  return (total_hits);\n}\n"]], "pred": {"ppl": 1.885165810585022, "ppl_lower": 1.885165810585022, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0017809432028273, "Min_5.0% Prob": 5.828132772445679, "Min_10.0% Prob": 4.2334688901901245, "Min_20.0% Prob": 2.818769174814224, "Min_30.0% Prob": 2.0399054631221394, "Min_40.0% Prob": 1.5748322454761274, "Min_50.0% Prob": 1.2650305855336903, "Min_60.0% Prob": 1.057895158365569}}
{"hexsha": "1e982e12cbb976f5cac8bb03a4d42f647223af4c", "ext": "c", "lang": "C", "content": "ALL_CINT1E(int1e_spnuc)\nALL_CINT1E_FORTRAN_(int1e_spnuc)\n/* <k SIGMA DOT P i|R12 |j l> : i,j \\in electron 1; k,l \\in electron 2\n * = (SIGMA DOT P i j|R12 |k l) */\nvoid CINTgout2e_int2e_spv1(double *gout,\ndouble *g, FINT *idx, CINTEnvVars *envs, FINT gout_empty) {\nFINT nf = envs->nf;\nFINT nrys_roots = envs->nrys_roots;\nFINT ix, iy, iz, i, n;\ndouble *g0 = g;\ndouble *g1 = g0 + envs->g_size * 3;\nG2E_D_I(g1, g0, envs->i_l+0, envs->j_l, envs->k_l, envs->l_l);\ndouble s[3];\nfor (n = 0; n < nf; n++) {\nix = idx[0+n*3];\niy = idx[1+n*3];\niz = idx[2+n*3];\nswitch (nrys_roots) {\ncase 1:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0];\nbreak;\ncase 2:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1];\nbreak;\ncase 3:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2];\nbreak;\ncase 4:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2]+ g1[ix+3]*g0[iy+3]*g0[iz+3];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2]+ g0[ix+3]*g1[iy+3]*g0[iz+3];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2]+ g0[ix+3]*g0[iy+3]*g1[iz+3];\nbreak;\ndefault:\nfor (i = 0; i < 3; i++) { s[i] = 0; }\nfor (i = 0; i < nrys_roots; i++) {\ns[0] += g1[ix+i] * g0[iy+i] * g0[iz+i];\ns[1] += g0[ix+i] * g1[iy+i] * g0[iz+i];\ns[2] += g0[ix+i] * g0[iy+i] * g1[iz+i];\n} break;}\nif (gout_empty) {\ngout[n*4+0] = + s[0];\ngout[n*4+1] = + s[1];\ngout[n*4+2] = + s[2];\ngout[n*4+3] = 0;\n} else {\ngout[n*4+0] += + s[0];\ngout[n*4+1] += + s[1];\ngout[n*4+2] += + s[2];\ngout[n*4+3] += 0;\n}}}", "item_id": 8, "repo": "Minyan910/libcint", "file": "src/autocode/dkb.c", "last_update_at": "2019-07-05T07:49:59+00:00", "question_id": "1e982e12cbb976f5cac8bb03a4d42f647223af4c_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ALL_CINT1E(int1e_spnuc)\nALL_CINT1E_FORTRAN_(int1e_spnuc)\n/* <k SIGMA DOT P i|R12 |j l> : i,j \\in electron 1; k,l \\in electron 2\n * = (SIGMA DOT P i j|R12 |k l) */\nvoid CINTgout2e_int2e_spv1(double *gout,\ndouble *g, FINT *idx, CINTEnvVars *envs, FINT gout_empty) {\nFINT nf = envs->nf;\nFINT nrys_roots = envs->nrys_roots;\nFINT ix, iy, iz, i, n;\ndouble *g0 = g;\ndouble *g1 = g0 + envs->g_size * 3;\nG2E_D_I(g1, g0, envs->i_l+0, envs->j_l, envs->k_l, envs->l_l);\ndouble s[3];\nfor (n = 0; n < nf; n++) {\nix = idx[0+n*3];\niy = idx[1+n*3];\niz = idx[2+n*3];\nswitch (nrys_roots) {\ncase 1:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0];\nbreak;\ncase 2:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1];\nbreak;\ncase 3:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2];\nbreak;\ncase 4:\ns[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2]+ g1[ix+3]*g0[iy+3]*g0[iz+3];\ns[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2]+ g0[ix+3]*g1[iy+3]*g0[iz+3];\ns[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2]+ g0[ix+3]*g0[iy+3]*g1[iz+3];\nbreak;\ndefault:\nfor (i = 0; i < 3; i++) { s[i] = 0; }\nfor (i = 0; i < nrys_roots; i++) {\ns[0] += g1[ix+i] * g0[iy+i] * g0[iz+i];\ns[1] += g0[ix+i] * g1[iy+i] * g0[iz+i];\ns[2] += g0[ix+i] * g0[iy+i] * g1[iz+i];\n} break;}\nif (gout_empty) {\ngout[n*4+0] = + s[0];\ngout[n*4+1] = + s[1];\ngout[n*4+2] = + s[2];\ngout[n*4+3] = 0;\n} else {\ngout[n*4+0] += + s[0];\ngout[n*4+1] += + s[1];\ngout[n*4+2] += + s[2];\ngout[n*4+3] += 0;\n"]], "pred": {"ppl": 1.1876646280288696, "ppl_lower": 1.3203096389770508, "ppl/lowercase_ppl": -1.6156060888008494, "ppl/zlib": 0.0002885719487372664, "Min_5.0% Prob": 3.0808081486645866, "Min_10.0% Prob": 1.7052514217793941, "Min_20.0% Prob": 0.8616858232987807, "Min_30.0% Prob": 0.5749166714184647, "Min_40.0% Prob": 0.43016922290668974, "Min_50.0% Prob": 0.34431081231131216, "Min_60.0% Prob": 0.2870212643682763}}
