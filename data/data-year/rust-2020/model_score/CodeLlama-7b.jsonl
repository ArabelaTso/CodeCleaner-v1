{"hexsha": "deedddd296c95549d8c8d5421f9b150db4820830", "ext": "rs", "lang": "Rust", "content": "fn get_canvas_and_display() -> (Canvas<'static>, Display) {\n        let canvas = Canvas::new(100, 100);\n        assert!(canvas.is_ok(), \"{:?}\", canvas.err());\n        let canvas_ok = canvas.unwrap();\n        let display = Display::new(InitOptions{canvas: Some(&canvas_ok),\n                                               ..InitOptions::default()});\n        assert!(display.is_ok(), \"{:?}\", display.err());\n        (canvas_ok, display.unwrap())\n    }", "item_id": 0, "repo": "Ruin0x11/caca-rs", "file": "src/caca.rs", "last_update_at": "2020-08-06T06:39:00+00:00", "question_id": "deedddd296c95549d8c8d5421f9b150db4820830_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_canvas_and_display() -> (Canvas<'static>, Display) {\n        let canvas = Canvas::new(100, 100);\n        assert!(canvas.is_ok(), \"{:?}\", canvas.err());\n        let canvas_ok = canvas.unwrap();\n        let display = Display::new(InitOptions{canvas: Some(&canvas_ok),\n                                               ..InitOptions::default()});\n        assert!(display.is_ok(), \"{:?}\", display.err());\n        (canvas_ok, display.unwrap())\n"]], "pred": {"ppl": 2.838949680328369, "ppl_lower": 3.2922093868255615, "ppl/lowercase_ppl": -1.1419588694012572, "ppl/zlib": 0.0049451855587607585, "Min_5.0% Prob": 8.46818463007609, "Min_10.0% Prob": 6.557563424110413, "Min_20.0% Prob": 4.4802220439910885, "Min_30.0% Prob": 3.2922801469501697, "Min_40.0% Prob": 2.567523285454395, "Min_50.0% Prob": 2.0846926704980433, "Min_60.0% Prob": 1.7435476216789965}}
{"hexsha": "c1a310764c91ca1631bbc6335c1e727cc6dcd2a1", "ext": "rs", "lang": "Rust", "content": "fn parse_int_float_str() {\n    let realm = Realm::create();\n    let mut engine = Interpreter::new(realm);\n\n    assert_eq!(&forward(&mut engine, \"parseInt(\\\"100.5\\\")\"), \"NaN\");\n}", "item_id": 18, "repo": "abhijeetbhagat/boa", "file": "boa/src/builtins/number/tests.rs", "last_update_at": "2020-10-26T18:55:57+00:00", "question_id": "c1a310764c91ca1631bbc6335c1e727cc6dcd2a1_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_int_float_str() {\n    let realm = Realm::create();\n    let mut engine = Interpreter::new(realm);\n    assert_eq!(&forward(&mut engine, \"parseInt(\\\"100.5\\\")\"), \"NaN\");\n"]], "pred": {"ppl": 7.093377113342285, "ppl_lower": 9.259681701660156, "ppl/lowercase_ppl": -1.1360317259791246, "ppl/zlib": 0.013418914710822126, "Min_5.0% Prob": 10.670960744222006, "Min_10.0% Prob": 9.123701651891073, "Min_20.0% Prob": 6.696120573924138, "Min_30.0% Prob": 5.467996271033036, "Min_40.0% Prob": 4.497511286001939, "Min_50.0% Prob": 3.748977496768489, "Min_60.0% Prob": 3.2461858208362875}}
{"hexsha": "7209a9a1cf034fbaa1a7e1c8822820cc115c3197", "ext": "rs", "lang": "Rust", "content": "pub async fn list_metrics_average(\n        operation_config: &crate::OperationConfig,\n        service_name: &str,\n        metric_name: &str,\n        group_name: &str,\n    ) -> std::result::Result<models::Metrics, list_metrics_average::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/providers/Microsoft.ADHybridHealthService/services/{}/metrics/{}/groups/{}/average\",\n            operation_config.base_path(),\n            service_name,\n            metric_name,\n            group_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(list_metrics_average::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(list_metrics_average::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(list_metrics_average::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(list_metrics_average::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::Metrics = serde_json::from_slice(rsp_body)\n                    .map_err(|source| list_metrics_average::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                Err(list_metrics_average::Error::UnexpectedResponse {\n                    status_code,\n                    body: rsp_body.clone(),\n                })\n            }\n        }\n    }", "item_id": 48, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/adhybridhealthservice/src/package_2014_01/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "7209a9a1cf034fbaa1a7e1c8822820cc115c3197_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn list_metrics_average(\n        operation_config: &crate::OperationConfig,\n        service_name: &str,\n        metric_name: &str,\n        group_name: &str,\n    ) -> std::result::Result<models::Metrics, list_metrics_average::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/providers/Microsoft.ADHybridHealthService/services/{}/metrics/{}/groups/{}/average\",\n            operation_config.base_path(),\n            service_name,\n            metric_name,\n            group_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(list_metrics_average::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(list_metrics_average::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(list_metrics_average::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(list_metrics_average::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::Metrics = serde_json::from_slice(rsp_body)\n                    .map_err(|source| list_metrics_average::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                Err(list_metrics_average::Error::UnexpectedResponse {\n                    status_code,\n                    body: rsp_body.clone(),\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.1176624298095703, "ppl_lower": 2.0715653896331787, "ppl/lowercase_ppl": -6.5471822654852305, "ppl/zlib": 0.00013992375849454492, "Min_5.0% Prob": 2.2450459385008523, "Min_10.0% Prob": 1.1152697101360494, "Min_20.0% Prob": 0.5578439513105945, "Min_30.0% Prob": 0.3719022938625158, "Min_40.0% Prob": 0.27892791826911295, "Min_50.0% Prob": 0.22247853593181502, "Min_60.0% Prob": 0.18549087889204652}}
{"hexsha": "257e6edd8ba7b8e6953e6f9f6097bd7c7a3635a3", "ext": "rs", "lang": "Rust", "content": "fn parse_file(\n    path: &Path,\n    io: &dyn WitxIo,\n    root: &Path,\n    validator: &mut DocValidation,\n    definitions: &mut Vec<Definition>,\n    parsed: &mut HashSet<PathBuf>,\n) -> Result<(), WitxError> {\n    let path = io.canonicalize(&root.join(path))?;\n    if !parsed.insert(path.clone()) {\n        return Ok(());\n    }\n    let input = io.fgets(&path)?;\n\n    let adjust_err = |mut error: wast::Error| {\n        error.set_path(&path);\n        error.set_text(&input);\n        WitxError::Parse(error)\n    };\n    let buf = wast::parser::ParseBuffer::new(&input).map_err(adjust_err)?;\n    let doc = wast::parser::parse::<TopLevelDocument>(&buf).map_err(adjust_err)?;\n\n    for t in doc.items {\n        match t.item {\n            TopLevelSyntax::Decl(d) => {\n                validator\n                    .scope(&input, &path)\n                    .validate_decl(&d, &t.comments, definitions)\n                    .map_err(WitxError::Validation)?;\n            }\n            TopLevelSyntax::Use(u) => {\n                parse_file(u.as_ref(), io, root, validator, definitions, parsed)?;\n            }\n        }\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "Maistra/proxy", "file": "maistra/vendor/proxy_wasm_cpp_host__wasmtime_c_api_macros__0_19_0/crates/wasi-nn/spec/tools/witx/src/toplevel.rs", "last_update_at": "2020-06-14T16:10:12+00:00", "question_id": "257e6edd8ba7b8e6953e6f9f6097bd7c7a3635a3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_file(\n    path: &Path,\n    io: &dyn WitxIo,\n    root: &Path,\n    validator: &mut DocValidation,\n    definitions: &mut Vec<Definition>,\n    parsed: &mut HashSet<PathBuf>,\n) -> Result<(), WitxError> {\n    let path = io.canonicalize(&root.join(path))?;\n    if !parsed.insert(path.clone()) {\n        return Ok(());\n    }\n    let input = io.fgets(&path)?;\n    let adjust_err = |mut error: wast::Error| {\n        error.set_path(&path);\n        error.set_text(&input);\n        WitxError::Parse(error)\n    };\n    let buf = wast::parser::ParseBuffer::new(&input).map_err(adjust_err)?;\n    let doc = wast::parser::parse::<TopLevelDocument>(&buf).map_err(adjust_err)?;\n    for t in doc.items {\n        match t.item {\n            TopLevelSyntax::Decl(d) => {\n                validator\n                    .scope(&input, &path)\n                    .validate_decl(&d, &t.comments, definitions)\n                    .map_err(WitxError::Validation)?;\n            }\n            TopLevelSyntax::Use(u) => {\n                parse_file(u.as_ref(), io, root, validator, definitions, parsed)?;\n            }\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.47125244140625, "ppl_lower": 3.101083517074585, "ppl/lowercase_ppl": -1.2509342260901244, "ppl/zlib": 0.0018615742457321466, "Min_5.0% Prob": 8.001956277423435, "Min_10.0% Prob": 6.062771893836357, "Min_20.0% Prob": 4.001418092766324, "Min_30.0% Prob": 2.8891139465409355, "Min_40.0% Prob": 2.2250357623268293, "Min_50.0% Prob": 1.8048049759079692, "Min_60.0% Prob": 1.5117658926716968}}
{"hexsha": "375493a91064b17b938127e3f2b8852364b25a77", "ext": "rs", "lang": "Rust", "content": "pub fn test() -> RrResult<()> {\n    let output = Command::new(\"cargo\")\n        .arg(\"test\")\n        .output()?;\n\n    check_output(&output)?;\n    Ok(())\n}", "item_id": 1, "repo": "dan-t/cargo-release", "file": "src/cargo.rs", "last_update_at": "2020-11-21T06:21:25+00:00", "question_id": "375493a91064b17b938127e3f2b8852364b25a77_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test() -> RrResult<()> {\n    let output = Command::new(\"cargo\")\n        .arg(\"test\")\n        .output()?;\n    check_output(&output)?;\n    Ok(())\n"]], "pred": {"ppl": 3.6992757320404053, "ppl_lower": 5.490720748901367, "ppl/lowercase_ppl": -1.30189686756707, "ppl/zlib": 0.010901142103265263, "Min_5.0% Prob": 10.028007507324219, "Min_10.0% Prob": 8.28210735321045, "Min_20.0% Prob": 5.329348607496782, "Min_30.0% Prob": 4.037450380623341, "Min_40.0% Prob": 3.156227770176801, "Min_50.0% Prob": 2.6342106494638653, "Min_60.0% Prob": 2.1738826787155685}}
{"hexsha": "a3f678cb64c0d4b79077f4e87ebabae14aad1a08", "ext": "rs", "lang": "Rust", "content": "fn test_get_boot_id() -> Result<()> {\n        let output = std::process::Command::new(\"journalctl\")\n            .arg(\"--list-boots\")\n            .output()\n            .context(\"Failed to run journalctl --list-boots\")?;\n\n        if !output.status.success() {\n            return Err(anyhow!(\"journalctl command filed: {:?}\", output));\n        }\n\n        let stdout =\n            std::str::from_utf8(&output.stdout).context(\"Failed to convert stdout to str\")?;\n\n        for line in stdout.lines() {\n            let line = line.trim();\n            println!(\"line: '{}'\", line);\n            if line.starts_with(\"0 \") {\n                let (_, line) = line.split_once(\" \").context(\"boot entry had no space\")?;\n                let (boot_id, _) = line\n                    .split_once(\" \")\n                    .context(\"second half of boot entry has no space\")?;\n\n                assert_eq!(get_boot_id().context(\"Failed to get boot id\")?, boot_id,);\n\n                return Ok(());\n            }\n        }\n\n        Err(anyhow!(\"Unable to find bootid from journalctl: {}\", stdout))\n    }", "item_id": 13, "repo": "facebookincubator/fs_image", "file": "metalos/metalctl/src/generator.rs", "last_update_at": "2020-06-13T16:34:25+00:00", "question_id": "a3f678cb64c0d4b79077f4e87ebabae14aad1a08_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_boot_id() -> Result<()> {\n        let output = std::process::Command::new(\"journalctl\")\n            .arg(\"--list-boots\")\n            .output()\n            .context(\"Failed to run journalctl --list-boots\")?;\n        if !output.status.success() {\n            return Err(anyhow!(\"journalctl command filed: {:?}\", output));\n        }\n        let stdout =\n            std::str::from_utf8(&output.stdout).context(\"Failed to convert stdout to str\")?;\n        for line in stdout.lines() {\n            let line = line.trim();\n            println!(\"line: '{}'\", line);\n            if line.starts_with(\"0 \") {\n                let (_, line) = line.split_once(\" \").context(\"boot entry had no space\")?;\n                let (boot_id, _) = line\n                    .split_once(\" \")\n                    .context(\"second half of boot entry has no space\")?;\n                assert_eq!(get_boot_id().context(\"Failed to get boot id\")?, boot_id,);\n                return Ok(());\n            }\n        }\n        Err(anyhow!(\"Unable to find bootid from journalctl: {}\", stdout))\n"]], "pred": {"ppl": 2.0815134048461914, "ppl_lower": 2.3570704460144043, "ppl/lowercase_ppl": -1.1695881779013084, "ppl/zlib": 0.0016218920965166428, "Min_5.0% Prob": 6.44736115137736, "Min_10.0% Prob": 5.024743302663167, "Min_20.0% Prob": 3.2276667503059886, "Min_30.0% Prob": 2.3547907579731153, "Min_40.0% Prob": 1.80747547073931, "Min_50.0% Prob": 1.4656179197818826, "Min_60.0% Prob": 1.2208500290620319}}
{"hexsha": "eb4a7f0cf16db2c4d6993b96097381694a859e9d", "ext": "rs", "lang": "Rust", "content": "fn test_match_repetition_13() {\n        // r\"A{,3}\"\n        let re = Re::new(rep!(sym![sgl!('A')], None, Some(3)));\n        assert!(!re.is_match(\"AAAA\"));\n    }", "item_id": 43, "repo": "RobertDurfee/RegularExpression", "file": "regular-expression-bootstrap/src/regular_expression.rs", "last_update_at": "2020-08-12T17:06:59+00:00", "question_id": "eb4a7f0cf16db2c4d6993b96097381694a859e9d_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_match_repetition_13() {\n        // r\"A{,3}\"\n        let re = Re::new(rep!(sym![sgl!('A')], None, Some(3)));\n        assert!(!re.is_match(\"AAAA\"));\n"]], "pred": {"ppl": 10.594918251037598, "ppl_lower": 11.561161994934082, "ppl/lowercase_ppl": -1.0369758704783814, "ppl/zlib": 0.017614734894661938, "Min_5.0% Prob": 10.74543031056722, "Min_10.0% Prob": 9.441971063613892, "Min_20.0% Prob": 7.503114590278039, "Min_30.0% Prob": 6.457662469462345, "Min_40.0% Prob": 5.3330307969680195, "Min_50.0% Prob": 4.544059436768293, "Min_60.0% Prob": 3.8378148132409806}}
{"hexsha": "48755ae4c16411914f3cbd7820f618a8718b1ce0", "ext": "rs", "lang": "Rust", "content": "fn test_range_inclusive() {\n    let mut r = RangeInclusive::new(1i8, 2);\n    assert_eq!(r.next(), Some(1));\n    assert_eq!(r.next(), Some(2));\n    assert_eq!(r.next(), None);\n\n    r = RangeInclusive::new(127i8, 127);\n    assert_eq!(r.next(), Some(127));\n    assert_eq!(r.next(), None);\n\n    r = RangeInclusive::new(-128i8, -128);\n    assert_eq!(r.next_back(), Some(-128));\n    assert_eq!(r.next_back(), None);\n\n    // degenerate\n    r = RangeInclusive::new(1, -1);\n    assert_eq!(r.size_hint(), (0, Some(0)));\n    assert_eq!(r.next(), None);\n}", "item_id": 2, "repo": "Timmmm/rust", "file": "src/libcore/tests/ops.rs", "last_update_at": "2020-07-23T19:52:51+00:00", "question_id": "48755ae4c16411914f3cbd7820f618a8718b1ce0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_range_inclusive() {\n    let mut r = RangeInclusive::new(1i8, 2);\n    assert_eq!(r.next(), Some(1));\n    assert_eq!(r.next(), Some(2));\n    assert_eq!(r.next(), None);\n    r = RangeInclusive::new(127i8, 127);\n    assert_eq!(r.next(), Some(127));\n    assert_eq!(r.next(), None);\n    r = RangeInclusive::new(-128i8, -128);\n    assert_eq!(r.next_back(), Some(-128));\n    assert_eq!(r.next_back(), None);\n    // degenerate\n    r = RangeInclusive::new(1, -1);\n    assert_eq!(r.size_hint(), (0, Some(0)));\n    assert_eq!(r.next(), None);\n"]], "pred": {"ppl": 1.5148735046386719, "ppl_lower": 1.7354589700698853, "ppl/lowercase_ppl": -1.3273044067593818, "ppl/zlib": 0.0022210264181144464, "Min_5.0% Prob": 5.687713601372459, "Min_10.0% Prob": 3.6676219598106714, "Min_20.0% Prob": 2.047525633936343, "Min_30.0% Prob": 1.3928293288563904, "Min_40.0% Prob": 1.0376894062445048, "Min_50.0% Prob": 0.8333425236030899, "Min_60.0% Prob": 0.6959512216405835}}
{"hexsha": "3d3797949f684fc281ec9df1444c22b47e0158a7", "ext": "rs", "lang": "Rust", "content": "fn fill_zoneplate(\n    data: &mut [u8],\n    width: u32,\n    height: u32,\n    frames: u32,\n    t: f64,\n    cx2: f64,\n    cy2: f64,\n    cxt: f64,\n    cyt: f64,\n    ct: f64,\n) {\n    let cx = width as i32 / 2;\n    let cy = height as i32 / 2;\n\n    let f = frames as f64;\n    let h = height as f64;\n    let w = width as f64;\n\n    // originally: x=(i/W), y=(j/H) both in [0,1]\n    // phi = cx2 * x^2*W + cy2*y^2*H + cxt*x*t*F*F/2 + cyt*y*t*F*F/2 + ct*t*F\n\n    let mut index = 0;\n    let ctt = ct * frames as f64 * t;\n\n    for j in -cy..cy {\n        let cy2y2 = cy2 * (j * j) as f64 / h;\n        let cytyt = cyt * (j as f64 / h) * (t * f * f / 2.0);\n        for i in -cx..cx {\n            let mut phi: f64 = cy2y2 + cytyt + ctt;\n            if cx2 != 0.0 {\n                let cx2x2 = cx2 * (i * i) as f64 / w;\n                phi += cx2x2;\n            }\n            if cxt != 0.0 {\n                let cxtxt = cxt * (i as f64 / w) * (t * f * f / 2.0);\n                phi += cxtxt;\n            }\n\n            phi = phi * PI;\n\n            // inline trig calculation - <f64>.cos()\n            // let c = (phi.cos() * 126.0 + 127.0) as u8;\n\n            // Use the COSINE_LOOKUP (Quantized) table\n            let abs_phi = if phi < 0.0 { -phi } else { phi };\n            let i_phi = ((Q as f64 * abs_phi / (2.0 * PI)).floor()) as usize % Q;\n            let c = COSINE_LOOKUP[i_phi];\n\n            //  rust'ish color\n            // data[index + 0] = c;\n            // data[index + 1] = c / 2;\n            // data[index + 2] = 0;\n            // data[index + 3] = 255;\n\n            data[index + 0] = c;\n            data[index + 1] = c;\n            data[index + 2] = c;\n            // data[index + 3] = 255; // set in allocation (255_u8)\n            index += 4;\n        }\n    }\n}", "item_id": 2, "repo": "daneroo/im-zone", "file": "packages/zoneplate-rust/src/lib.rs", "last_update_at": "2020-12-23T03:09:08+00:00", "question_id": "3d3797949f684fc281ec9df1444c22b47e0158a7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fill_zoneplate(\n    data: &mut [u8],\n    width: u32,\n    height: u32,\n    frames: u32,\n    t: f64,\n    cx2: f64,\n    cy2: f64,\n    cxt: f64,\n    cyt: f64,\n    ct: f64,\n) {\n    let cx = width as i32 / 2;\n    let cy = height as i32 / 2;\n    let f = frames as f64;\n    let h = height as f64;\n    let w = width as f64;\n    // originally: x=(i/W), y=(j/H) both in [0,1]\n    // phi = cx2 * x^2*W + cy2*y^2*H + cxt*x*t*F*F/2 + cyt*y*t*F*F/2 + ct*t*F\n    let mut index = 0;\n    let ctt = ct * frames as f64 * t;\n    for j in -cy..cy {\n        let cy2y2 = cy2 * (j * j) as f64 / h;\n        let cytyt = cyt * (j as f64 / h) * (t * f * f / 2.0);\n        for i in -cx..cx {\n            let mut phi: f64 = cy2y2 + cytyt + ctt;\n            if cx2 != 0.0 {\n                let cx2x2 = cx2 * (i * i) as f64 / w;\n                phi += cx2x2;\n            }\n            if cxt != 0.0 {\n                let cxtxt = cxt * (i as f64 / w) * (t * f * f / 2.0);\n                phi += cxtxt;\n            }\n            phi = phi * PI;\n            // inline trig calculation - <f64>.cos()\n            // let c = (phi.cos() * 126.0 + 127.0) as u8;\n            // Use the COSINE_LOOKUP (Quantized) table\n            let abs_phi = if phi < 0.0 { -phi } else { phi };\n            let i_phi = ((Q as f64 * abs_phi / (2.0 * PI)).floor()) as usize % Q;\n            let c = COSINE_LOOKUP[i_phi];\n            //  rust'ish color\n            // data[index + 0] = c;\n            // data[index + 1] = c / 2;\n            // data[index + 2] = 0;\n            // data[index + 3] = 255;\n            data[index + 0] = c;\n            data[index + 1] = c;\n            data[index + 2] = c;\n            // data[index + 3] = 255; // set in allocation (255_u8)\n            index += 4;\n        }\n    }\n"]], "pred": {"ppl": 2.3667898178100586, "ppl_lower": 2.340614080429077, "ppl/lowercase_ppl": -0.9870913969657868, "ppl/zlib": 0.0013014116763138085, "Min_5.0% Prob": 7.666925204427619, "Min_10.0% Prob": 5.826009948002665, "Min_20.0% Prob": 3.7964484504624907, "Min_30.0% Prob": 2.7500368252591794, "Min_40.0% Prob": 2.1218572091919925, "Min_50.0% Prob": 1.7179265535041612, "Min_60.0% Prob": 1.433952221559657}}
{"hexsha": "6d44e30fb7977f64abac6ae0231baffce769296b", "ext": "rs", "lang": "Rust", "content": "fn overwriting_insert_cancels_original() {\n        let (mut reso_tx, reso_rx) = mpsc::channel(2);\n        let (make0_tx, make0_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();\n        let (make1_tx, make1_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();\n\n        let mut discover = task::spawn(Discover::new(Dx(reso_rx), Svc(vec![make1_rx, make0_rx])));\n        assert_pending!(discover.poll_next(), \"ready without updates\");\n\n        let addr = SocketAddr::from(([127, 0, 0, 1], 80));\n        reso_tx.try_send(Change::Insert(addr, ())).ok().unwrap();\n        assert_pending!(discover.poll_next(), \"ready without service being made\");\n        assert_eq!(\n            discover.make_futures.futures.len(),\n            1,\n            \"must be only one pending make\"\n        );\n        assert_eq!(\n            discover.make_futures.cancelations.len(),\n            1,\n            \"no pending cancelation\"\n        );\n\n        reso_tx\n            .try_send(Change::Insert(addr, ()))\n            .ok()\n            .expect(\"update must be sent\");\n        assert_pending!(discover.poll_next(), \"ready without service being made\");\n        assert_eq!(\n            discover.make_futures.futures.len(),\n            1,\n            \"must be only one pending make\"\n        );\n        assert_eq!(\n            discover.make_futures.cancelations.len(),\n            1,\n            \"no pending cancelation\"\n        );\n\n        make0_tx\n            .send(Svc(vec![]))\n            .expect_err(\"receiver must have been dropped\");\n\n        let (rsp1_tx, rsp1_rx) = oneshot::channel();\n        make1_tx\n            .send(Svc(vec![rsp1_rx]))\n            .expect(\"make must receive service\");\n        match assert_ready!(discover.poll_next())\n            .expect(\"discover stream mustn't end\")\n            .expect(\"discover can't fail\")\n        {\n            Change::Remove(..) => panic!(\"unexpected remove\"),\n            Change::Insert(a, svc) => {\n                assert_eq!(a, addr);\n                let mut svc = mock::Spawn::new(svc);\n                assert_ready_ok!(svc.poll_ready());\n                let mut fut = task::spawn(svc.call(()));\n                assert_pending!(fut.poll());\n                rsp1_tx.send(1).unwrap();\n                assert_eq!(assert_ready_ok!(fut.poll()), 1);\n            }\n        }\n        assert!(\n            discover.make_futures.cancelations.is_empty(),\n            \"cancelation remains\"\n        );\n    }", "item_id": 1, "repo": "aliariff/linkerd2-proxy", "file": "linkerd/proxy/discover/src/make_endpoint.rs", "last_update_at": "2020-07-08T15:31:25+00:00", "question_id": "6d44e30fb7977f64abac6ae0231baffce769296b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn overwriting_insert_cancels_original() {\n        let (mut reso_tx, reso_rx) = mpsc::channel(2);\n        let (make0_tx, make0_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();\n        let (make1_tx, make1_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();\n        let mut discover = task::spawn(Discover::new(Dx(reso_rx), Svc(vec![make1_rx, make0_rx])));\n        assert_pending!(discover.poll_next(), \"ready without updates\");\n        let addr = SocketAddr::from(([127, 0, 0, 1], 80));\n        reso_tx.try_send(Change::Insert(addr, ())).ok().unwrap();\n        assert_pending!(discover.poll_next(), \"ready without service being made\");\n        assert_eq!(\n            discover.make_futures.futures.len(),\n            1,\n            \"must be only one pending make\"\n        );\n        assert_eq!(\n            discover.make_futures.cancelations.len(),\n            1,\n            \"no pending cancelation\"\n        );\n        reso_tx\n            .try_send(Change::Insert(addr, ()))\n            .ok()\n            .expect(\"update must be sent\");\n        assert_pending!(discover.poll_next(), \"ready without service being made\");\n        assert_eq!(\n            discover.make_futures.futures.len(),\n            1,\n            \"must be only one pending make\"\n        );\n        assert_eq!(\n            discover.make_futures.cancelations.len(),\n            1,\n            \"no pending cancelation\"\n        );\n        make0_tx\n            .send(Svc(vec![]))\n            .expect_err(\"receiver must have been dropped\");\n        let (rsp1_tx, rsp1_rx) = oneshot::channel();\n        make1_tx\n            .send(Svc(vec![rsp1_rx]))\n            .expect(\"make must receive service\");\n        match assert_ready!(discover.poll_next())\n            .expect(\"discover stream mustn't end\")\n            .expect(\"discover can't fail\")\n        {\n            Change::Remove(..) => panic!(\"unexpected remove\"),\n            Change::Insert(a, svc) => {\n                assert_eq!(a, addr);\n                let mut svc = mock::Spawn::new(svc);\n                assert_ready_ok!(svc.poll_ready());\n                let mut fut = task::spawn(svc.call(()));\n                assert_pending!(fut.poll());\n                rsp1_tx.send(1).unwrap();\n                assert_eq!(assert_ready_ok!(fut.poll()), 1);\n            }\n        }\n        assert!(\n            discover.make_futures.cancelations.is_empty(),\n            \"cancelation remains\"\n        );\n"]], "pred": {"ppl": 2.0970005989074707, "ppl_lower": 2.2419207096099854, "ppl/lowercase_ppl": -1.0902419922511728, "ppl/zlib": 0.00107788651749895, "Min_5.0% Prob": 7.0466467625386, "Min_10.0% Prob": 5.219471502304077, "Min_20.0% Prob": 3.3508013060550814, "Min_30.0% Prob": 2.3966355133424244, "Min_40.0% Prob": 1.8360207157068127, "Min_50.0% Prob": 1.477401654651305, "Min_60.0% Prob": 1.2355855739827264}}
{"hexsha": "bb61e8d5a5c9814a2f692ff8a873011c91a2471b", "ext": "rs", "lang": "Rust", "content": "fn it_returns_false_when_first_queue_is_expired() {\n                let mut conf = SocketConfig::default();\n                conf.msg_drop_priority = 2;\n                conf.max_msg_age_secs = 10;\n                let mut queue = VecDeque::new();\n                let queued_at = Instant::now().sub(Duration::from_secs(100));\n                queue.push_back((queued_at, vec![1, 2, 3]));\n\n                let retain = is_queue_valid(2, &queue, &conf);\n\n                assert!(!retain);\n            }", "item_id": 2, "repo": "S-Coyle/socket-collection", "file": "src/out_queue.rs", "last_update_at": "2020-03-06T14:57:14+00:00", "question_id": "bb61e8d5a5c9814a2f692ff8a873011c91a2471b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_returns_false_when_first_queue_is_expired() {\n                let mut conf = SocketConfig::default();\n                conf.msg_drop_priority = 2;\n                conf.max_msg_age_secs = 10;\n                let mut queue = VecDeque::new();\n                let queued_at = Instant::now().sub(Duration::from_secs(100));\n                queue.push_back((queued_at, vec![1, 2, 3]));\n                let retain = is_queue_valid(2, &queue, &conf);\n                assert!(!retain);\n"]], "pred": {"ppl": 3.280756950378418, "ppl_lower": 4.113706588745117, "ppl/lowercase_ppl": -1.1904344865441616, "ppl/zlib": 0.004534634249333605, "Min_5.0% Prob": 8.654549598693848, "Min_10.0% Prob": 7.0983352343241375, "Min_20.0% Prob": 4.765752700067336, "Min_30.0% Prob": 3.6075953905997067, "Min_40.0% Prob": 2.8445364808843983, "Min_50.0% Prob": 2.354666684161533, "Min_60.0% Prob": 1.9729017254005197}}
{"hexsha": "72e1d1a09cb6ef662fb4daabc3898a177b2d86d8", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn lkm_api_debug(this_module: usize) {\n    let module = get_module(this_module);\n    module.lock.lock();\n    println!(\n        \"[LKM] Current module info: name={} version={} api_version={}\\nref_count={} dep_count={}\",\n        module.info.name,\n        module.info.version,\n        module.info.api_version,\n        Arc::strong_count(&module.using_counts),\n        module.used_counts\n    );\n}", "item_id": 1, "repo": "Loremkang/rCore", "file": "kernel/src/lkm/api.rs", "last_update_at": "2020-07-13T22:23:14+00:00", "question_id": "72e1d1a09cb6ef662fb4daabc3898a177b2d86d8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn lkm_api_debug(this_module: usize) {\n    let module = get_module(this_module);\n    module.lock.lock();\n    println!(\n        \"[LKM] Current module info: name={} version={} api_version={}\\nref_count={} dep_count={}\",\n        module.info.name,\n        module.info.version,\n        module.info.api_version,\n        Arc::strong_count(&module.using_counts),\n        module.used_counts\n    );\n"]], "pred": {"ppl": 4.658597469329834, "ppl_lower": 4.999978065490723, "ppl/lowercase_ppl": -1.045959856830632, "ppl/zlib": 0.00736227000282058, "Min_5.0% Prob": 10.5337766011556, "Min_10.0% Prob": 8.436315609858585, "Min_20.0% Prob": 6.171762924927932, "Min_30.0% Prob": 4.740599036216736, "Min_40.0% Prob": 3.729317381696881, "Min_50.0% Prob": 3.061912703243169, "Min_60.0% Prob": 2.580129331708709}}
{"hexsha": "01c450b324884e2d4835f52af116502be77ad513", "ext": "rs", "lang": "Rust", "content": "pub fn apply_filter(bpf_filter: BpfProgramRef) -> std::result::Result<(), InstallationError> {\n    // If the program is empty, don't install the filter.\n    if bpf_filter.is_empty() {\n        return Ok(());\n    }\n\n    // If the program length is greater than the limit allowed by the kernel,\n    // fail quickly. Otherwise, `prctl` will give a more cryptic error code.\n    if bpf_filter.len() > BPF_MAX_LEN {\n        return Err(InstallationError::FilterTooLarge);\n    }\n\n    unsafe {\n        {\n            let rc = libc::prctl(libc::PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n            if rc != 0 {\n                return Err(InstallationError::Prctl(*libc::__errno_location()));\n            }\n        }\n\n        let bpf_prog = sock_fprog {\n            len: bpf_filter.len() as u16,\n            filter: bpf_filter.as_ptr(),\n        };\n        let bpf_prog_ptr = &bpf_prog as *const sock_fprog;\n        {\n            let rc = libc::prctl(\n                libc::PR_SET_SECCOMP,\n                libc::SECCOMP_MODE_FILTER,\n                bpf_prog_ptr,\n            );\n            if rc != 0 {\n                return Err(InstallationError::Prctl(*libc::__errno_location()));\n            }\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "adpaco-aws/firecracker", "file": "src/seccompiler/src/lib.rs", "last_update_at": "2020-03-29T00:58:58+00:00", "question_id": "01c450b324884e2d4835f52af116502be77ad513_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn apply_filter(bpf_filter: BpfProgramRef) -> std::result::Result<(), InstallationError> {\n    // If the program is empty, don't install the filter.\n    if bpf_filter.is_empty() {\n        return Ok(());\n    }\n    // If the program length is greater than the limit allowed by the kernel,\n    // fail quickly. Otherwise, `prctl` will give a more cryptic error code.\n    if bpf_filter.len() > BPF_MAX_LEN {\n        return Err(InstallationError::FilterTooLarge);\n    }\n    unsafe {\n        {\n            let rc = libc::prctl(libc::PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n            if rc != 0 {\n                return Err(InstallationError::Prctl(*libc::__errno_location()));\n            }\n        }\n        let bpf_prog = sock_fprog {\n            len: bpf_filter.len() as u16,\n            filter: bpf_filter.as_ptr(),\n        };\n        let bpf_prog_ptr = &bpf_prog as *const sock_fprog;\n        {\n            let rc = libc::prctl(\n                libc::PR_SET_SECCOMP,\n                libc::SECCOMP_MODE_FILTER,\n                bpf_prog_ptr,\n            );\n            if rc != 0 {\n                return Err(InstallationError::Prctl(*libc::__errno_location()));\n            }\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.8740863800048828, "ppl_lower": 2.323450803756714, "ppl/lowercase_ppl": -1.342182676009687, "ppl/zlib": 0.0012897767488158102, "Min_5.0% Prob": 6.685342512632671, "Min_10.0% Prob": 4.829487323760986, "Min_20.0% Prob": 2.954324997678588, "Min_30.0% Prob": 2.0677290886890987, "Min_40.0% Prob": 1.5661325754375204, "Min_50.0% Prob": 1.2552417043114465, "Min_60.0% Prob": 1.050159314354322}}
{"hexsha": "bc62f4da116dbfeb2acadacb60d0b2a1a380ab26", "ext": "rs", "lang": "Rust", "content": "pub fn lookup(code: &str) -> Option<&'static LanguageInfo> {\n    debug!(\"language::lookup {}\", code);\n    assert!(\n        code.len() == 2 || code.len() == 3,\n        \"language code must be either 2, or 3, characters long.\"\n    );\n    match code.len() {\n        3 => match LANGUAGES.get(code) {\n            Some(v) => Some(v),\n            None => None,\n        },\n        2 => match LOOKUP.get(code) {\n            Some(v) => {\n                debug!(\"language::lookup {} -> {}\", code, v);\n                lookup(v)\n            }\n            None => None,\n        },\n        _ => None,\n    }\n}", "item_id": 0, "repo": "l4l/simple-locale", "file": "src/codes/language.rs", "last_update_at": "2020-08-19T02:14:04+00:00", "question_id": "bc62f4da116dbfeb2acadacb60d0b2a1a380ab26_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn lookup(code: &str) -> Option<&'static LanguageInfo> {\n    debug!(\"language::lookup {}\", code);\n    assert!(\n        code.len() == 2 || code.len() == 3,\n        \"language code must be either 2, or 3, characters long.\"\n    );\n    match code.len() {\n        3 => match LANGUAGES.get(code) {\n            Some(v) => Some(v),\n            None => None,\n        },\n        2 => match LOOKUP.get(code) {\n            Some(v) => {\n                debug!(\"language::lookup {} -> {}\", code, v);\n                lookup(v)\n            }\n            None => None,\n        },\n        _ => None,\n    }\n"]], "pred": {"ppl": 2.26092791557312, "ppl_lower": 2.5789217948913574, "ppl/lowercase_ppl": -1.1613141384673997, "ppl/zlib": 0.003066824477933924, "Min_5.0% Prob": 7.197223822275798, "Min_10.0% Prob": 5.219146423869663, "Min_20.0% Prob": 3.5413821472062006, "Min_30.0% Prob": 2.6132491920833236, "Min_40.0% Prob": 2.0088677661467904, "Min_50.0% Prob": 1.6304076234554197, "Min_60.0% Prob": 1.3671398677717927}}
{"hexsha": "50f2872a18d6a38ccd20c1ce6a8c4f691f8a87c3", "ext": "rs", "lang": "Rust", "content": "pub async fn query_activity_runs(\n        operation_config: &crate::OperationConfig,\n        pipeline_name: &str,\n        run_id: &str,\n        filter_parameters: &models::RunFilterParameters,\n    ) -> std::result::Result<models::ActivityRunsQueryResponse, query_activity_runs::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/pipelines/{}/pipelineruns/{}/queryActivityruns\",\n            operation_config.base_path(),\n            pipeline_name,\n            run_id\n        );\n        let mut url = url::Url::parse(url_str).map_err(query_activity_runs::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::POST);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(query_activity_runs::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        req_builder = req_builder.header(\"content-type\", \"application/json\");\n        let req_body = azure_core::to_json(filter_parameters).map_err(query_activity_runs::Error::SerializeError)?;\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(query_activity_runs::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(query_activity_runs::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ActivityRunsQueryResponse = serde_json::from_slice(rsp_body)\n                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)\n                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(query_activity_runs::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 18, "repo": "rylev/azure-sdk-for-rust", "file": "services/svc/synapse/src/package_artifacts_2019_06_01_preview/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "50f2872a18d6a38ccd20c1ce6a8c4f691f8a87c3_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn query_activity_runs(\n        operation_config: &crate::OperationConfig,\n        pipeline_name: &str,\n        run_id: &str,\n        filter_parameters: &models::RunFilterParameters,\n    ) -> std::result::Result<models::ActivityRunsQueryResponse, query_activity_runs::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/pipelines/{}/pipelineruns/{}/queryActivityruns\",\n            operation_config.base_path(),\n            pipeline_name,\n            run_id\n        );\n        let mut url = url::Url::parse(url_str).map_err(query_activity_runs::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::POST);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(query_activity_runs::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        req_builder = req_builder.header(\"content-type\", \"application/json\");\n        let req_body = azure_core::to_json(filter_parameters).map_err(query_activity_runs::Error::SerializeError)?;\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(query_activity_runs::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(query_activity_runs::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ActivityRunsQueryResponse = serde_json::from_slice(rsp_body)\n                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)\n                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(query_activity_runs::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.1102148294448853, "ppl_lower": 1.9012089967727661, "ppl/lowercase_ppl": -6.145081444011835, "ppl/zlib": 0.00012955828579705388, "Min_5.0% Prob": 2.103318237070296, "Min_10.0% Prob": 1.055264353992046, "Min_20.0% Prob": 0.5241632930363681, "Min_30.0% Prob": 0.34866606419912216, "Min_40.0% Prob": 0.26208527197858056, "Min_50.0% Prob": 0.20938736137748723, "Min_60.0% Prob": 0.17433374735439428}}
{"hexsha": "841825a3f0220ff7d076fda53cc84e105c1de042", "ext": "rs", "lang": "Rust", "content": "fn github_hook(req: HttpRequest, body: String) -> FutureResponse<&'static str> {\n    let data = middleware::validate(&req, body.as_bytes())\n        .and_then(|_| serde_json::from_str(body.as_str()).map_err(ErrorBadRequest));\n    let response = |data: GithubHookData| match (&data.issue, &data.action) {\n        (&Some(ref i), &Some(ref action)) if action == \"opened\" => {\n            let full_name = data.repository.full_name.clone();\n            let number = i.number;\n            let cloned = i.clone();\n            let jira_code = get_param(full_name.as_str(), \"jira-project-key\");\n            let jira_issue_type = get_param(full_name.as_str(), \"jira-issue-type-id\")\n                .unwrap_or(JIRA_ISSUE_ID_DEFAULT.clone());\n            github::close_issue(&full_name, number)\n                .map_err(Error::from)\n                .and_then(move |_| future::ok(jira_code).and_then(move |e| e.map(|code|\n                    jira::open_issue(\n                        code,\n                        cloned.title.clone(),\n                        cloned.body.clone(),\n                        jira_issue_type,\n                    )\n                )))\n                .map(|e| e.and_then(|k| k))\n                .and_then(move |e| {\n                    let comment = if let (Some(ref jira_issue), Some(api)) = (e, &*JIRA_API) {\n                        format!(\"{}\\n[Jira]: {}browse/{}\", *COMMENT, *api, jira_issue.key)\n                    } else {\n                        COMMENT.clone()\n                    };\n                    github::comment_issue(&full_name, number, comment).map_err(Error::from)\n                })\n                .map(|_| \"\")\n                .responder()\n        }\n        _ => futures::finished(\"\").responder()\n    };\n    futures::done(data).and_then(response).responder()\n}", "item_id": 0, "repo": "soramitsu/yozhik", "file": "src/main.rs", "last_update_at": "2020-07-31T10:13:33+00:00", "question_id": "841825a3f0220ff7d076fda53cc84e105c1de042_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn github_hook(req: HttpRequest, body: String) -> FutureResponse<&'static str> {\n    let data = middleware::validate(&req, body.as_bytes())\n        .and_then(|_| serde_json::from_str(body.as_str()).map_err(ErrorBadRequest));\n    let response = |data: GithubHookData| match (&data.issue, &data.action) {\n        (&Some(ref i), &Some(ref action)) if action == \"opened\" => {\n            let full_name = data.repository.full_name.clone();\n            let number = i.number;\n            let cloned = i.clone();\n            let jira_code = get_param(full_name.as_str(), \"jira-project-key\");\n            let jira_issue_type = get_param(full_name.as_str(), \"jira-issue-type-id\")\n                .unwrap_or(JIRA_ISSUE_ID_DEFAULT.clone());\n            github::close_issue(&full_name, number)\n                .map_err(Error::from)\n                .and_then(move |_| future::ok(jira_code).and_then(move |e| e.map(|code|\n                    jira::open_issue(\n                        code,\n                        cloned.title.clone(),\n                        cloned.body.clone(),\n                        jira_issue_type,\n                    )\n                )))\n                .map(|e| e.and_then(|k| k))\n                .and_then(move |e| {\n                    let comment = if let (Some(ref jira_issue), Some(api)) = (e, &*JIRA_API) {\n                        format!(\"{}\\n[Jira]: {}browse/{}\", *COMMENT, *api, jira_issue.key)\n                    } else {\n                        COMMENT.clone()\n                    };\n                    github::comment_issue(&full_name, number, comment).map_err(Error::from)\n                })\n                .map(|_| \"\")\n                .responder()\n        }\n        _ => futures::finished(\"\").responder()\n    };\n    futures::done(data).and_then(response).responder()\n"]], "pred": {"ppl": 2.490600109100342, "ppl_lower": 2.7340402603149414, "ppl/lowercase_ppl": -1.1021965522521615, "ppl/zlib": 0.0013380112743544765, "Min_5.0% Prob": 7.260072001704463, "Min_10.0% Prob": 5.448384042219682, "Min_20.0% Prob": 3.680190319364721, "Min_30.0% Prob": 2.787364128141692, "Min_40.0% Prob": 2.2112467951395294, "Min_50.0% Prob": 1.8082551003315233, "Min_60.0% Prob": 1.5169822007756342}}
{"hexsha": "e62e21c4291d8580cfe49d3f73df509411f2e1b3", "ext": "rs", "lang": "Rust", "content": "fn glsl_compiler_options_has_default() {\n    let compiler_options = glsl::CompilerOptions::default();\n    assert_eq!(compiler_options.vertex.invert_y, false);\n    assert_eq!(compiler_options.vertex.transform_clip_space, false);\n}", "item_id": 0, "repo": "omni-viral/spirv_cross", "file": "spirv_cross/tests/glsl_tests.rs", "last_update_at": "2020-01-24T08:25:45+00:00", "question_id": "e62e21c4291d8580cfe49d3f73df509411f2e1b3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn glsl_compiler_options_has_default() {\n    let compiler_options = glsl::CompilerOptions::default();\n    assert_eq!(compiler_options.vertex.invert_y, false);\n    assert_eq!(compiler_options.vertex.transform_clip_space, false);\n"]], "pred": {"ppl": 3.1166255474090576, "ppl_lower": 3.882174491882324, "ppl/lowercase_ppl": -1.19322138121709, "ppl/zlib": 0.008546998956396733, "Min_5.0% Prob": 8.40129311879476, "Min_10.0% Prob": 6.668031283787319, "Min_20.0% Prob": 4.642708710261753, "Min_30.0% Prob": 3.531885956014906, "Min_40.0% Prob": 2.7701324245759418, "Min_50.0% Prob": 2.2715109816619328, "Min_60.0% Prob": 1.9146596129451479}}
{"hexsha": "b08cee8d4cec59b2262025caabf2a8459d42fa86", "ext": "rs", "lang": "Rust", "content": "fn test_decimal_separator() {\n        let value = 12345.6789;\n        let opt = HumanizeOptions::builder().decimal_separator(\"_\").build();\n        assert_eq!(value.humanize(&opt), \"12_35K\".to_owned());\n    }", "item_id": 7, "repo": "msuntharesan/mer", "file": "humanize/src/lib.rs", "last_update_at": "2020-10-06T00:15:20+00:00", "question_id": "b08cee8d4cec59b2262025caabf2a8459d42fa86_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_decimal_separator() {\n        let value = 12345.6789;\n        let opt = HumanizeOptions::builder().decimal_separator(\"_\").build();\n        assert_eq!(value.humanize(&opt), \"12_35K\".to_owned());\n"]], "pred": {"ppl": 3.5162711143493652, "ppl_lower": 4.534425258636475, "ppl/lowercase_ppl": -1.2022403656744247, "ppl/zlib": 0.008272375563129982, "Min_5.0% Prob": 9.210541089375814, "Min_10.0% Prob": 7.688092776707241, "Min_20.0% Prob": 5.036771273612976, "Min_30.0% Prob": 3.820800531994213, "Min_40.0% Prob": 2.95667804479599, "Min_50.0% Prob": 2.4225612235696694, "Min_60.0% Prob": 2.0931876500447593}}
{"hexsha": "90ebf681387d823b30b2b9bbbe1f69d372064d4c", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    use std::io::Read;\n    let mut log = String::new();\n    std::io::stdin().read_to_string(&mut log).unwrap();\n    let profile: data::Profile<AnyMetadata> = log.parse().unwrap();\n    let events = IntervalTranslator::run(&profile);\n    serde_json::to_writer(std::io::stdout(), &events).unwrap();\n}", "item_id": 0, "repo": "luna/luna", "file": "lib/rust/profiler/data/src/bin/devtools.rs", "last_update_at": "2020-06-23T08:20:38+00:00", "question_id": "90ebf681387d823b30b2b9bbbe1f69d372064d4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    use std::io::Read;\n    let mut log = String::new();\n    std::io::stdin().read_to_string(&mut log).unwrap();\n    let profile: data::Profile<AnyMetadata> = log.parse().unwrap();\n    let events = IntervalTranslator::run(&profile);\n    serde_json::to_writer(std::io::stdout(), &events).unwrap();\n"]], "pred": {"ppl": 3.5043418407440186, "ppl_lower": 5.109639644622803, "ppl/lowercase_ppl": -1.3007379081236365, "ppl/zlib": 0.006430783208234368, "Min_5.0% Prob": 9.6995418548584, "Min_10.0% Prob": 8.601501226425171, "Min_20.0% Prob": 5.617115449905396, "Min_30.0% Prob": 4.039699584245682, "Min_40.0% Prob": 3.116714718565345, "Min_50.0% Prob": 2.5183067935705186, "Min_60.0% Prob": 2.1064045591900746}}
{"hexsha": "b044cac608377e976431436a46c3f1bd6a931f52", "ext": "rs", "lang": "Rust", "content": "pub fn load_random_spheres(num_spheres: u16) -> (Vec<Object>, Vec<Light>) {\n    let mut objects = vec![];\n    let mut lights = vec![];\n\n    // ground plane\n    let phong = MaterialType::new_phong(1.0, 0.0, 0.2);\n    let color = TextureType::new_flat(Color::grayscale(0.3));\n    let object = Object::new_quad(\n        (-100.0, 0.0, 10.0).into(),\n        (10.0, 0.0, 10.0).into(),\n        (10.0, 0.0, -10.0).into(),\n        (-100.0, 0.0, -10.0).into(),\n        Material::new(phong, color),\n    );\n    objects.push(object);\n\n    // back plane\n    let back_pos = -8.0;\n    let height = 4.;\n    let phong = MaterialType::new_phong(1.0, 0.0, 1.0);\n    let color = TextureType::new_flat(Color::blue() * Color::grayscale(0.5));\n    let object = Object::new_quad(\n        (10.0, -1.0, back_pos).into(),\n        (10.0, height, back_pos).into(),\n        (-10.0, height, back_pos).into(),\n        (-10.0, -1.0, back_pos).into(),\n        Material::new(phong, color),\n    );\n    objects.push(object);\n\n    let mut rng = StdRng::seed_from_u64(248);\n    for _ in 0..num_spheres {\n        let phong = MaterialType::new_phong(1.0, 0.0, 1.0);\n        let r: f32 = rng.gen_range(0.5, 1.);\n        let g: f32 = rng.gen_range(0.5, 1.);\n        let b: f32 = rng.gen_range(0.5, 1.);\n        let color = TextureType::new_flat(Color::rgb(r, g, b));\n\n        let x: f32 = rng.gen_range(-4., 4.0);\n        let y: f32 = rng.gen_range(0.1, 2.5);\n        let z: f32 = rng.gen_range(-6., 3.5);\n        let r: f32 = rng.gen_range(0.05, 0.15);\n\n        let object = Object::new_sphere((x, y, z).into(), r, Material::new(phong, color));\n        objects.push(object);\n    }\n\n    // add some reflective spheres in the middle\n    let mut add_sphere = |point, color| {\n        let phong = MaterialType::new_phong(1.0, 0.6, 1.0);\n        let mirror = MaterialType::Reflective;\n        let object = Object::new_sphere(\n            point,\n            0.5,\n            Material::new(\n                MaterialType::Composition(vec![(mirror, 0.6), (phong, 0.4)]),\n                TextureType::new_flat(color),\n            ),\n        );\n        objects.push(object);\n    };\n    add_sphere((0., 0.5, 0.).into(), Color::red());\n    add_sphere((1.5, 0.5, 0.5).into(), Color::blue());\n    add_sphere((-1.5, 0.5, -0.5).into(), Color::yellow());\n\n    let light = Light::new_point((1.0, 2.0, 2.5).into(), Color::white());\n    lights.push(light);\n    let light = Light::new_point((-2.0, 2.0, 1.).into(), Color::white());\n    lights.push(light);\n    let light = Light::new_ambient(Color::grayscale(0.2));\n    lights.push(light);\n    let light = Light::new_directional((-0.2, -1., -0.9).into(), Color::grayscale(0.3));\n    lights.push(light);\n\n    (objects, lights)\n}", "item_id": 1, "repo": "ellishg/rust-raytracer", "file": "src/scene.rs", "last_update_at": "2020-03-25T23:48:28+00:00", "question_id": "b044cac608377e976431436a46c3f1bd6a931f52_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load_random_spheres(num_spheres: u16) -> (Vec<Object>, Vec<Light>) {\n    let mut objects = vec![];\n    let mut lights = vec![];\n    // ground plane\n    let phong = MaterialType::new_phong(1.0, 0.0, 0.2);\n    let color = TextureType::new_flat(Color::grayscale(0.3));\n    let object = Object::new_quad(\n        (-100.0, 0.0, 10.0).into(),\n        (10.0, 0.0, 10.0).into(),\n        (10.0, 0.0, -10.0).into(),\n        (-100.0, 0.0, -10.0).into(),\n        Material::new(phong, color),\n    );\n    objects.push(object);\n    // back plane\n    let back_pos = -8.0;\n    let height = 4.;\n    let phong = MaterialType::new_phong(1.0, 0.0, 1.0);\n    let color = TextureType::new_flat(Color::blue() * Color::grayscale(0.5));\n    let object = Object::new_quad(\n        (10.0, -1.0, back_pos).into(),\n        (10.0, height, back_pos).into(),\n        (-10.0, height, back_pos).into(),\n        (-10.0, -1.0, back_pos).into(),\n        Material::new(phong, color),\n    );\n    objects.push(object);\n    let mut rng = StdRng::seed_from_u64(248);\n    for _ in 0..num_spheres {\n        let phong = MaterialType::new_phong(1.0, 0.0, 1.0);\n        let r: f32 = rng.gen_range(0.5, 1.);\n        let g: f32 = rng.gen_range(0.5, 1.);\n        let b: f32 = rng.gen_range(0.5, 1.);\n        let color = TextureType::new_flat(Color::rgb(r, g, b));\n        let x: f32 = rng.gen_range(-4., 4.0);\n        let y: f32 = rng.gen_range(0.1, 2.5);\n        let z: f32 = rng.gen_range(-6., 3.5);\n        let r: f32 = rng.gen_range(0.05, 0.15);\n        let object = Object::new_sphere((x, y, z).into(), r, Material::new(phong, color));\n        objects.push(object);\n    }\n    // add some reflective spheres in the middle\n    let mut add_sphere = |point, color| {\n        let phong = MaterialType::new_phong(1.0, 0.6, 1.0);\n        let mirror = MaterialType::Reflective;\n        let object = Object::new_sphere(\n            point,\n            0.5,\n            Material::new(\n                MaterialType::Composition(vec![(mirror, 0.6), (phong, 0.4)]),\n                TextureType::new_flat(color),\n            ),\n        );\n        objects.push(object);\n    };\n    add_sphere((0., 0.5, 0.).into(), Color::red());\n    add_sphere((1.5, 0.5, 0.5).into(), Color::blue());\n    add_sphere((-1.5, 0.5, -0.5).into(), Color::yellow());\n    let light = Light::new_point((1.0, 2.0, 2.5).into(), Color::white());\n    lights.push(light);\n    let light = Light::new_point((-2.0, 2.0, 1.).into(), Color::white());\n    lights.push(light);\n    let light = Light::new_ambient(Color::grayscale(0.2));\n    lights.push(light);\n    let light = Light::new_directional((-0.2, -1., -0.9).into(), Color::grayscale(0.3));\n    lights.push(light);\n    (objects, lights)\n"]], "pred": {"ppl": 1.6974507570266724, "ppl_lower": 1.7709934711456299, "ppl/lowercase_ppl": -1.0801566648105532, "ppl/zlib": 0.0007169750283395383, "Min_5.0% Prob": 5.499825412151861, "Min_10.0% Prob": 3.9461547557045433, "Min_20.0% Prob": 2.458254117007349, "Min_30.0% Prob": 1.7288431460950888, "Min_40.0% Prob": 1.3133209036859004, "Min_50.0% Prob": 1.0565404917702166, "Min_60.0% Prob": 0.8823587859085902}}
{"hexsha": "82c9ecc28a696795077789f53750c33e9777ae18", "ext": "rs", "lang": "Rust", "content": "fn no_explicit_any_test() {\n    assert_lint_err::<NoExplicitAny>(\n      \"function foo(): any { return undefined; }\",\n      16,\n    );\n    assert_lint_err::<NoExplicitAny>(\n      \"function bar(): Promise<any> { return undefined; }\",\n      24,\n    );\n    assert_lint_err::<NoExplicitAny>(\"const a: any = {};\", 9);\n  }", "item_id": 0, "repo": "sarayle18/deno_lint", "file": "src/rules/no_explicit_any.rs", "last_update_at": "2020-06-27T04:47:22+00:00", "question_id": "82c9ecc28a696795077789f53750c33e9777ae18_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn no_explicit_any_test() {\n    assert_lint_err::<NoExplicitAny>(\n      \"function foo(): any { return undefined; }\",\n      16,\n    );\n    assert_lint_err::<NoExplicitAny>(\n      \"function bar(): Promise<any> { return undefined; }\",\n      24,\n    );\n    assert_lint_err::<NoExplicitAny>(\"const a: any = {};\", 9);\n"]], "pred": {"ppl": 2.3583505153656006, "ppl_lower": 2.9169483184814453, "ppl/lowercase_ppl": -1.2477678775183285, "ppl/zlib": 0.0053622652531377735, "Min_5.0% Prob": 6.799494838714599, "Min_10.0% Prob": 5.241290547631004, "Min_20.0% Prob": 3.7798081148754465, "Min_30.0% Prob": 2.7649644468769883, "Min_40.0% Prob": 2.1469427425075662, "Min_50.0% Prob": 1.7086463595208312, "Min_60.0% Prob": 1.4324379456855023}}
{"hexsha": "f0a295479c997372d6954e123f5d62358876d817", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {\n    assert_eq!(\n        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),\n        8usize,\n        concat!(\n            \"Size of: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)\n        )\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),\n        4usize,\n        concat!(\n            \"Alignment of \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low\n                as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),\n            \"::\",\n            stringify!(__low)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high\n                as *const _ as usize\n        },\n        4usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),\n            \"::\",\n            stringify!(__high)\n        )\n    );\n}", "item_id": 10, "repo": "sticnarf/rust-papi", "file": "libpapi_sys/bindings/bindings.rs", "last_update_at": "2020-05-19T20:16:31+00:00", "question_id": "f0a295479c997372d6954e123f5d62358876d817_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {\n    assert_eq!(\n        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),\n        8usize,\n        concat!(\n            \"Size of: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)\n        )\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),\n        4usize,\n        concat!(\n            \"Alignment of \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low\n                as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),\n            \"::\",\n            stringify!(__low)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high\n                as *const _ as usize\n        },\n        4usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),\n            \"::\",\n            stringify!(__high)\n        )\n    );\n"]], "pred": {"ppl": 1.2026854753494263, "ppl_lower": 1.232403039932251, "ppl/lowercase_ppl": -1.1322572870701015, "ppl/zlib": 0.0006785182079360784, "Min_5.0% Prob": 3.620954032825387, "Min_10.0% Prob": 1.8695444573810243, "Min_20.0% Prob": 0.9265929261574232, "Min_30.0% Prob": 0.6156120099155876, "Min_40.0% Prob": 0.4633741281881529, "Min_50.0% Prob": 0.369905237920881, "Min_60.0% Prob": 0.3078143583315511}}
{"hexsha": "79aeee125fc000f48463805cd42a44a104e6d011", "ext": "rs", "lang": "Rust", "content": "fn semiconstrainted_bounds() {\n    let data = b\"\\x02\\x10\\x01\";\n    let mut d = aper::Decoder::new(data);\n    assert_eq!(4096, d.decode_int(Some(-1), None).unwrap());\n}", "item_id": 4, "repo": "vuppalac/asn1-per-tinker", "file": "tests/integers.rs", "last_update_at": "2020-07-09T05:44:32+00:00", "question_id": "79aeee125fc000f48463805cd42a44a104e6d011_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn semiconstrainted_bounds() {\n    let data = b\"\\x02\\x10\\x01\";\n    let mut d = aper::Decoder::new(data);\n    assert_eq!(4096, d.decode_int(Some(-1), None).unwrap());\n"]], "pred": {"ppl": 7.077301025390625, "ppl_lower": 9.484375, "ppl/lowercase_ppl": -1.149600995066213, "ppl/zlib": 0.013403374136460174, "Min_5.0% Prob": 10.938923517862955, "Min_10.0% Prob": 9.187981264931816, "Min_20.0% Prob": 7.075877547264099, "Min_30.0% Prob": 5.601549693516323, "Min_40.0% Prob": 4.5650040209293365, "Min_50.0% Prob": 3.821058566229684, "Min_60.0% Prob": 3.2480161026829766}}
{"hexsha": "69d79862ae718ec94527537ad649cafd3f6b37bd", "ext": "rs", "lang": "Rust", "content": "fn test_default() {\n        let default = Packet::default();\n        assert_eq!(default.length, 0);\n        assert_eq!(default.window, None);\n        assert_eq!(default.timestamp, Duration::default());\n        assert_eq!(default.flag_list, BTreeSet::default());\n        assert_eq!(default.network_protocol, 0);\n        assert_eq!(default.network_payload_length, None);\n        assert_eq!(default.network_header_length, None);\n        assert_eq!(default.position, 0);\n    }", "item_id": 0, "repo": "tigroo31/libflow", "file": "src/packet.rs", "last_update_at": "2020-12-10T17:40:21+00:00", "question_id": "69d79862ae718ec94527537ad649cafd3f6b37bd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_default() {\n        let default = Packet::default();\n        assert_eq!(default.length, 0);\n        assert_eq!(default.window, None);\n        assert_eq!(default.timestamp, Duration::default());\n        assert_eq!(default.flag_list, BTreeSet::default());\n        assert_eq!(default.network_protocol, 0);\n        assert_eq!(default.network_payload_length, None);\n        assert_eq!(default.network_header_length, None);\n        assert_eq!(default.position, 0);\n"]], "pred": {"ppl": 2.853144884109497, "ppl_lower": 3.490410089492798, "ppl/lowercase_ppl": -1.1922865101257, "ppl/zlib": 0.005990982022947013, "Min_5.0% Prob": 9.107424020767212, "Min_10.0% Prob": 7.143020483163687, "Min_20.0% Prob": 4.802678748413369, "Min_30.0% Prob": 3.3729706123107817, "Min_40.0% Prob": 2.619251563593193, "Min_50.0% Prob": 2.1015473927973822, "Min_60.0% Prob": 1.748168251363606}}
{"hexsha": "3b56425eaf37555db1d5565d434f7de1ca61b166", "ext": "rs", "lang": "Rust", "content": "fn decode_byte_short() {\n        let enc = Encoder::from_hex(\"\");\n        let mut dec = enc.as_decoder();\n        assert!(dec.decode_byte().is_none());\n    }", "item_id": 2, "repo": "martinthomson/neqo", "file": "neqo-common/src/codec.rs", "last_update_at": "2020-07-20T07:22:16+00:00", "question_id": "3b56425eaf37555db1d5565d434f7de1ca61b166_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_byte_short() {\n        let enc = Encoder::from_hex(\"\");\n        let mut dec = enc.as_decoder();\n        assert!(dec.decode_byte().is_none());\n"]], "pred": {"ppl": 4.765101909637451, "ppl_lower": 5.35128927230835, "ppl/lowercase_ppl": -1.074308068371365, "ppl/zlib": 0.013695780035085082, "Min_5.0% Prob": 8.91352891921997, "Min_10.0% Prob": 6.965001106262207, "Min_20.0% Prob": 5.639357924461365, "Min_30.0% Prob": 4.464039659500122, "Min_40.0% Prob": 3.6161064475774767, "Min_50.0% Prob": 3.0311736619472502, "Min_60.0% Prob": 2.593686606486638}}
{"hexsha": "72955ae8fcabf4d79ddb12dffc0291a2366cfd9a", "ext": "rs", "lang": "Rust", "content": "async fn get_highest_role(member: Arc<Member>, ctx: Context) -> Result<i64, Box<dyn Error + Send + Sync>> {\n    let roles = ctx.http.roles(member.guild_id).await?;\n    let roles = {\n        let mut map = HashMap::new();\n        for role in roles.iter() {\n            map.insert(role.id, role.clone());\n        }\n\n        map\n    };\n\n    let mut pos = -1;\n    for role in member.roles.iter() {\n        if let Some(role) = roles.get(role) {\n            if role.position > pos { pos = role.position }\n        }\n    }\n\n    Ok(pos)\n}", "item_id": 0, "repo": "Mishio595/momiji-rust", "file": "src/commands/mods/roles.rs", "last_update_at": "2020-08-26T16:34:19+00:00", "question_id": "72955ae8fcabf4d79ddb12dffc0291a2366cfd9a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn get_highest_role(member: Arc<Member>, ctx: Context) -> Result<i64, Box<dyn Error + Send + Sync>> {\n    let roles = ctx.http.roles(member.guild_id).await?;\n    let roles = {\n        let mut map = HashMap::new();\n        for role in roles.iter() {\n            map.insert(role.id, role.clone());\n        }\n        map\n    };\n    let mut pos = -1;\n    for role in member.roles.iter() {\n        if let Some(role) = roles.get(role) {\n            if role.position > pos { pos = role.position }\n        }\n    }\n    Ok(pos)\n"]], "pred": {"ppl": 2.1559696197509766, "ppl_lower": 2.6539790630340576, "ppl/lowercase_ppl": -1.270513554506502, "ppl/zlib": 0.002705072401136894, "Min_5.0% Prob": 7.364096283912659, "Min_10.0% Prob": 5.402081349316766, "Min_20.0% Prob": 3.4565989545413425, "Min_30.0% Prob": 2.4495722308473766, "Min_40.0% Prob": 1.8883915436519703, "Min_50.0% Prob": 1.5317396784431478, "Min_60.0% Prob": 1.2824602973969461}}
{"hexsha": "57614c17dca1f1104be2060b0b5b1fea63783202", "ext": "rs", "lang": "Rust", "content": "pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        operational_insights_resource_provider: &str,\n        workspace_name: &str,\n        metadata_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/{}/workspaces/{}/providers/Microsoft.SecurityInsights/metadata/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            operational_insights_resource_provider,\n            workspace_name,\n            metadata_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 62, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/securityinsights/src/package_2021_03_preview_only/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "57614c17dca1f1104be2060b0b5b1fea63783202_62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        operational_insights_resource_provider: &str,\n        workspace_name: &str,\n        metadata_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/{}/workspaces/{}/providers/Microsoft.SecurityInsights/metadata/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            operational_insights_resource_provider,\n            workspace_name,\n            metadata_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.0782256126403809, "ppl_lower": 2.093064069747925, "ppl/lowercase_ppl": -9.80697075669203, "ppl/zlib": 8.829629396566417e-05, "Min_5.0% Prob": 1.5367745207340429, "Min_10.0% Prob": 0.7585655404671804, "Min_20.0% Prob": 0.3765699630265266, "Min_30.0% Prob": 0.25167466240326136, "Min_40.0% Prob": 0.18829120020129383, "Min_50.0% Prob": 0.15085679927650722, "Min_60.0% Prob": 0.1255278806481073}}
{"hexsha": "f3f9622398e35a764ac99187b4628e6faac1b02b", "ext": "rs", "lang": "Rust", "content": "fn all_benches_batch_remove_then_add(c: &mut Criterion) {\n    bench_batch_addition_removal_smt(\n        c,\n        \"almost empty tree - remove then add batch\",\n        (1 << BENCH_HEIGHT as usize) / 10,\n        true,\n    );\n    bench_batch_addition_removal_smt(\n        c,\n        \"half full tree - remove then add batch\",\n        (1 << BENCH_HEIGHT as usize) / 2,\n        true,\n    );\n    bench_batch_addition_removal_smt(\n        c,\n        \"almost full tree - remove then add batch\",\n        (9 * (1 << BENCH_HEIGHT as usize)) / 10,\n        true,\n    );\n}", "item_id": 5, "repo": "ZencashOfficial/zexe", "file": "primitives/benches/crypto_primitives/smt.rs", "last_update_at": "2020-07-09T16:26:31+00:00", "question_id": "f3f9622398e35a764ac99187b4628e6faac1b02b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn all_benches_batch_remove_then_add(c: &mut Criterion) {\n    bench_batch_addition_removal_smt(\n        c,\n        \"almost empty tree - remove then add batch\",\n        (1 << BENCH_HEIGHT as usize) / 10,\n        true,\n    );\n    bench_batch_addition_removal_smt(\n        c,\n        \"half full tree - remove then add batch\",\n        (1 << BENCH_HEIGHT as usize) / 2,\n        true,\n    );\n    bench_batch_addition_removal_smt(\n        c,\n        \"almost full tree - remove then add batch\",\n        (9 * (1 << BENCH_HEIGHT as usize)) / 10,\n        true,\n    );\n"]], "pred": {"ppl": 2.2371389865875244, "ppl_lower": 2.6178669929504395, "ppl/lowercase_ppl": -1.195184397887118, "ppl/zlib": 0.004150504182332765, "Min_5.0% Prob": 7.561893796920776, "Min_10.0% Prob": 5.817708587646484, "Min_20.0% Prob": 3.7538161190544685, "Min_30.0% Prob": 2.6926452918130845, "Min_40.0% Prob": 2.0183568558678395, "Min_50.0% Prob": 1.6096093996192862, "Min_60.0% Prob": 1.348373464427934}}
{"hexsha": "174fc228c11a48d7ff661f3072db09bcfa8a0d66", "ext": "rs", "lang": "Rust", "content": "fn test_version_serialize_bytes() {\n    let version_a = Version::new(0, 0, 0, \"alphabeta\", \"buildmeta\").unwrap();\n    let res = version_a.to_bytes();\n    assert!(res.is_ok());\n\n    let version_a_bytes = res.unwrap();\n    let res = Version::from_bytes(&version_a_bytes);\n    assert!(res.is_ok());\n\n    let version_b = res.unwrap();\n    assert_eq!(version_a, version_b);\n}", "item_id": 12, "repo": "mitrid-labs/mitrid-core", "file": "tests/util/version.rs", "last_update_at": "2020-02-13T15:57:46+00:00", "question_id": "174fc228c11a48d7ff661f3072db09bcfa8a0d66_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_version_serialize_bytes() {\n    let version_a = Version::new(0, 0, 0, \"alphabeta\", \"buildmeta\").unwrap();\n    let res = version_a.to_bytes();\n    assert!(res.is_ok());\n    let version_a_bytes = res.unwrap();\n    let res = Version::from_bytes(&version_a_bytes);\n    assert!(res.is_ok());\n    let version_b = res.unwrap();\n    assert_eq!(version_a, version_b);\n"]], "pred": {"ppl": 2.2626757621765137, "ppl_lower": 2.439361810684204, "ppl/lowercase_ppl": -1.0920807672686532, "ppl/zlib": 0.00474737254950303, "Min_5.0% Prob": 7.747712691624959, "Min_10.0% Prob": 5.771868815788856, "Min_20.0% Prob": 3.567053407430649, "Min_30.0% Prob": 2.5924330789309282, "Min_40.0% Prob": 1.9915877948954421, "Min_50.0% Prob": 1.626175414432179, "Min_60.0% Prob": 1.3690285969384108}}
{"hexsha": "c99abd8418188c8f19084063d7317e1236f02481", "ext": "rs", "lang": "Rust", "content": "fn test_exchange_local_cluster() {\n    solana_logger::setup();\n\n    const NUM_NODES: usize = 1;\n\n    let mut config = Config::default();\n    config.identity = Keypair::new();\n    config.duration = Duration::from_secs(1);\n    config.fund_amount = 100_000;\n    config.threads = 1;\n    config.transfer_delay = 20; // 15\n    config.batch_size = 100; // 1000;\n    config.chunk_size = 10; // 200;\n    config.account_groups = 1; // 10;\n    let Config {\n        fund_amount,\n        batch_size,\n        account_groups,\n        ..\n    } = config;\n    let accounts_in_groups = batch_size * account_groups;\n\n    let cluster = LocalCluster::new(&ClusterConfig {\n        node_stakes: vec![100_000; NUM_NODES],\n        cluster_lamports: 100_000_000_000_000,\n        validator_configs: vec![ValidatorConfig::default(); NUM_NODES],\n        native_instruction_processors: [solana_exchange_program!()].to_vec(),\n        ..ClusterConfig::default()\n    });\n\n    let faucet_keypair = Keypair::new();\n    cluster.transfer(\n        &cluster.funding_keypair,\n        &faucet_keypair.pubkey(),\n        2_000_000_000_000,\n    );\n\n    let (addr_sender, addr_receiver) = channel();\n    run_local_faucet(faucet_keypair, addr_sender, Some(1_000_000_000_000));\n    let faucet_addr = addr_receiver.recv_timeout(Duration::from_secs(2)).unwrap();\n\n    info!(\"Connecting to the cluster\");\n    let (nodes, _) =\n        discover_cluster(&cluster.entry_point_info.gossip, NUM_NODES).unwrap_or_else(|err| {\n            error!(\"Failed to discover {} nodes: {:?}\", NUM_NODES, err);\n            exit(1);\n        });\n\n    let (client, num_clients) = get_multi_client(&nodes);\n\n    info!(\"clients: {}\", num_clients);\n    assert!(num_clients >= NUM_NODES);\n\n    const NUM_SIGNERS: u64 = 2;\n    airdrop_lamports(\n        &client,\n        &faucet_addr,\n        &config.identity,\n        fund_amount * (accounts_in_groups + 1) as u64 * NUM_SIGNERS,\n    );\n\n    do_bench_exchange(vec![client], config);\n}", "item_id": 0, "repo": "everstake/solana", "file": "bench-exchange/tests/bench_exchange.rs", "last_update_at": "2020-05-06T18:44:13+00:00", "question_id": "c99abd8418188c8f19084063d7317e1236f02481_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_exchange_local_cluster() {\n    solana_logger::setup();\n    const NUM_NODES: usize = 1;\n    let mut config = Config::default();\n    config.identity = Keypair::new();\n    config.duration = Duration::from_secs(1);\n    config.fund_amount = 100_000;\n    config.threads = 1;\n    config.transfer_delay = 20; // 15\n    config.batch_size = 100; // 1000;\n    config.chunk_size = 10; // 200;\n    config.account_groups = 1; // 10;\n    let Config {\n        fund_amount,\n        batch_size,\n        account_groups,\n        ..\n    } = config;\n    let accounts_in_groups = batch_size * account_groups;\n    let cluster = LocalCluster::new(&ClusterConfig {\n        node_stakes: vec![100_000; NUM_NODES],\n        cluster_lamports: 100_000_000_000_000,\n        validator_configs: vec![ValidatorConfig::default(); NUM_NODES],\n        native_instruction_processors: [solana_exchange_program!()].to_vec(),\n        ..ClusterConfig::default()\n    });\n    let faucet_keypair = Keypair::new();\n    cluster.transfer(\n        &cluster.funding_keypair,\n        &faucet_keypair.pubkey(),\n        2_000_000_000_000,\n    );\n    let (addr_sender, addr_receiver) = channel();\n    run_local_faucet(faucet_keypair, addr_sender, Some(1_000_000_000_000));\n    let faucet_addr = addr_receiver.recv_timeout(Duration::from_secs(2)).unwrap();\n    info!(\"Connecting to the cluster\");\n    let (nodes, _) =\n        discover_cluster(&cluster.entry_point_info.gossip, NUM_NODES).unwrap_or_else(|err| {\n            error!(\"Failed to discover {} nodes: {:?}\", NUM_NODES, err);\n            exit(1);\n        });\n    let (client, num_clients) = get_multi_client(&nodes);\n    info!(\"clients: {}\", num_clients);\n    assert!(num_clients >= NUM_NODES);\n    const NUM_SIGNERS: u64 = 2;\n    airdrop_lamports(\n        &client,\n        &faucet_addr,\n        &config.identity,\n        fund_amount * (accounts_in_groups + 1) as u64 * NUM_SIGNERS,\n    );\n    do_bench_exchange(vec![client], config);\n"]], "pred": {"ppl": 1.849846601486206, "ppl_lower": 2.1502091884613037, "ppl/lowercase_ppl": -1.2446134808687594, "ppl/zlib": 0.0007855717976203986, "Min_5.0% Prob": 6.300893478923374, "Min_10.0% Prob": 4.476979090742869, "Min_20.0% Prob": 2.7884971592702024, "Min_30.0% Prob": 1.982666031000289, "Min_40.0% Prob": 1.5236776051219223, "Min_50.0% Prob": 1.2273597574398003, "Min_60.0% Prob": 1.0260849629693545}}
{"hexsha": "a3a5ca7f1d9478030df1a39c22d53d4ee7be032c", "ext": "rs", "lang": "Rust", "content": "fn it_pushes_buffer_to_the_read_queue() {\n                let mut read_buf: VecDeque<Vec<u8>> = VecDeque::new();\n\n                let _ = handle_recv_res(Ok(vec![1, 2, 3]), &mut read_buf);\n\n                assert_eq!(read_buf[0], vec![1, 2, 3]);\n            }", "item_id": 6, "repo": "S-Coyle/socket-collection", "file": "src/udp.rs", "last_update_at": "2020-03-06T14:57:14+00:00", "question_id": "a3a5ca7f1d9478030df1a39c22d53d4ee7be032c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_pushes_buffer_to_the_read_queue() {\n                let mut read_buf: VecDeque<Vec<u8>> = VecDeque::new();\n                let _ = handle_recv_res(Ok(vec![1, 2, 3]), &mut read_buf);\n                assert_eq!(read_buf[0], vec![1, 2, 3]);\n"]], "pred": {"ppl": 3.123720645904541, "ppl_lower": 3.9105870723724365, "ppl/lowercase_ppl": -1.197241273294268, "ppl/zlib": 0.007163678025493696, "Min_5.0% Prob": 8.638033509254456, "Min_10.0% Prob": 7.319408734639485, "Min_20.0% Prob": 5.004568438780935, "Min_30.0% Prob": 3.6323027425798875, "Min_40.0% Prob": 2.799742566087307, "Min_50.0% Prob": 2.2609908010582536, "Min_60.0% Prob": 1.920684826528204}}
{"hexsha": "f1de0530e7ddf1e2d560b6098a3e1049fe5496a7", "ext": "rs", "lang": "Rust", "content": "async fn test_overwrite_data() {\n        let partition_cols = vec![\"modified\".to_string()];\n        let mut table = create_initialized_table(&partition_cols).await;\n        assert_eq!(table.version, 0);\n\n        let transaction = get_transaction(table.table_uri.clone(), 0, SaveMode::Overwrite);\n        let session_ctx = SessionContext::new();\n        let task_ctx = session_ctx.task_ctx();\n\n        let _ = collect(transaction.clone(), task_ctx.clone())\n            .await\n            .unwrap();\n        table.update().await.unwrap();\n        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);\n        assert_eq!(table.version, 1);\n\n        let transaction = get_transaction(table.table_uri.clone(), 1, SaveMode::Overwrite);\n        let _ = collect(transaction.clone(), task_ctx).await.unwrap();\n        table.update().await.unwrap();\n        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);\n        assert_eq!(table.version, 2);\n    }", "item_id": 3, "repo": "roeap/delta-rs", "file": "rust/src/operations/write.rs", "last_update_at": "2020-12-23T19:11:23+00:00", "question_id": "f1de0530e7ddf1e2d560b6098a3e1049fe5496a7_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_overwrite_data() {\n        let partition_cols = vec![\"modified\".to_string()];\n        let mut table = create_initialized_table(&partition_cols).await;\n        assert_eq!(table.version, 0);\n        let transaction = get_transaction(table.table_uri.clone(), 0, SaveMode::Overwrite);\n        let session_ctx = SessionContext::new();\n        let task_ctx = session_ctx.task_ctx();\n        let _ = collect(transaction.clone(), task_ctx.clone())\n            .await\n            .unwrap();\n        table.update().await.unwrap();\n        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);\n        assert_eq!(table.version, 1);\n        let transaction = get_transaction(table.table_uri.clone(), 1, SaveMode::Overwrite);\n        let _ = collect(transaction.clone(), task_ctx).await.unwrap();\n        table.update().await.unwrap();\n        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);\n        assert_eq!(table.version, 2);\n"]], "pred": {"ppl": 2.275264024734497, "ppl_lower": 2.762326240539551, "ppl/lowercase_ppl": -1.2359542453718397, "ppl/zlib": 0.002506390550297023, "Min_5.0% Prob": 8.076278345925468, "Min_10.0% Prob": 5.923888124268631, "Min_20.0% Prob": 3.718897749637735, "Min_30.0% Prob": 2.653553529374901, "Min_40.0% Prob": 2.0467531625823727, "Min_50.0% Prob": 1.6396859292042991, "Min_60.0% Prob": 1.3709754324597971}}
{"hexsha": "b7e1e239e00b119af94973d6f3b870dd3997375c", "ext": "rs", "lang": "Rust", "content": "fn opcode_ld_f_vx() {\n        let mut chip = Chip::default();\n\n        chip.registers[2] = 6;\n        chip.ld_f_vx(2);\n\n        assert_eq!(chip.i, (chip.registers[2] * CHARACTER_SIZE as u8) as u16);\n    }", "item_id": 38, "repo": "arturjpv/chip8vm", "file": "src/chip.rs", "last_update_at": "2020-08-30T16:53:33+00:00", "question_id": "b7e1e239e00b119af94973d6f3b870dd3997375c_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn opcode_ld_f_vx() {\n        let mut chip = Chip::default();\n        chip.registers[2] = 6;\n        chip.ld_f_vx(2);\n        assert_eq!(chip.i, (chip.registers[2] * CHARACTER_SIZE as u8) as u16);\n"]], "pred": {"ppl": 3.6550891399383545, "ppl_lower": 4.456214904785156, "ppl/lowercase_ppl": -1.152901872236093, "ppl/zlib": 0.009258003438545522, "Min_5.0% Prob": 8.622859477996826, "Min_10.0% Prob": 7.10187554359436, "Min_20.0% Prob": 5.093943988575655, "Min_30.0% Prob": 3.9022791935847354, "Min_40.0% Prob": 3.145333022730691, "Min_50.0% Prob": 2.584001689133319, "Min_60.0% Prob": 2.164783606832882}}
{"hexsha": "715abef18639025ecc91ad4eef818720c9f862e7", "ext": "rs", "lang": "Rust", "content": "fn test_valid_password() {\n        assert_eq!(Some(\"abcde\"), valid_password_old_policy(1, 3, 'a', \"abcde\"));\n        assert_eq!(None, valid_password_old_policy(1, 3, 'b', \"cdefg\"));\n        assert_eq!(Some(\"ccccccccc\"), valid_password_old_policy(2, 9, 'c', \"ccccccccc\"));\n    }", "item_id": 2, "repo": "swallez/advent-of-code-2020", "file": "src/bin/day_02.rs", "last_update_at": "2020-12-03T10:14:45+00:00", "question_id": "715abef18639025ecc91ad4eef818720c9f862e7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_valid_password() {\n        assert_eq!(Some(\"abcde\"), valid_password_old_policy(1, 3, 'a', \"abcde\"));\n        assert_eq!(None, valid_password_old_policy(1, 3, 'b', \"cdefg\"));\n        assert_eq!(Some(\"ccccccccc\"), valid_password_old_policy(2, 9, 'c', \"ccccccccc\"));\n"]], "pred": {"ppl": 1.9566737413406372, "ppl_lower": 2.1094233989715576, "ppl/lowercase_ppl": -1.1119838078084874, "ppl/zlib": 0.005163430468015422, "Min_5.0% Prob": 5.856484127044678, "Min_10.0% Prob": 4.724769568443298, "Min_20.0% Prob": 3.113799571990967, "Min_30.0% Prob": 2.2515528375102627, "Min_40.0% Prob": 1.6857722936464208, "Min_50.0% Prob": 1.3406043922142037, "Min_60.0% Prob": 1.1286845058720145}}
{"hexsha": "9626ca6cfb761352da5176bace1b356e51853881", "ext": "rs", "lang": "Rust", "content": "fn get_field_iref1() -> VM {\n    let vm = VM::new();\n\n    typedef!    ((vm) int64         = mu_int(64));\n    typedef!    ((vm) ref_int64     = mu_ref(int64));\n    typedef!    ((vm) iref_int64    = mu_iref(int64));\n    typedef!    ((vm) mystruct      = mu_struct(int64, int64, ref_int64));\n    typedef!    ((vm) ref_mystruct  = mu_ref(mystruct));\n    typedef!    ((vm) iref_mystruct = mu_iref(mystruct));\n\n    funcsig!    ((vm) sig = (ref_mystruct) -> (iref_int64));\n    funcdecl!   ((vm) <sig> get_field_iref1);\n\n    funcdef!    ((vm) <sig> get_field_iref1 VERSION get_field_iref1_v1);\n\n    block!      ((vm, get_field_iref1_v1) blk_entry);\n    ssa!        ((vm, get_field_iref1_v1) <ref_mystruct> x);\n\n    ssa!        ((vm, get_field_iref1_v1) <iref_mystruct> x_);\n    inst!       ((vm, get_field_iref1_v1) blk_entry_get_iref:\n        x_ = GETIREF x\n    );\n\n    ssa!        ((vm, get_field_iref1_v1) <iref_int64> ret);\n    inst!       ((vm, get_field_iref1_v1) blk_entry_get_field_iref1:\n        ret = GETFIELDIREF x_ (is_ptr: false, index: 1)\n    );\n\n    inst!       ((vm, get_field_iref1_v1) blk_entry_ret:\n        RET (ret)\n    );\n\n    define_block!   ((vm, get_field_iref1_v1) blk_entry(x) {\n        blk_entry_get_iref, blk_entry_get_field_iref1, blk_entry_ret\n    });\n\n    define_func_ver!((vm) get_field_iref1_v1 (entry: blk_entry) {blk_entry});\n\n    vm\n}", "item_id": 3, "repo": "qinsoon/zebu", "file": "tests/test_compiler/test_mem_inst.rs", "last_update_at": "2020-05-24T18:28:00+00:00", "question_id": "9626ca6cfb761352da5176bace1b356e51853881_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_field_iref1() -> VM {\n    let vm = VM::new();\n    typedef!    ((vm) int64         = mu_int(64));\n    typedef!    ((vm) ref_int64     = mu_ref(int64));\n    typedef!    ((vm) iref_int64    = mu_iref(int64));\n    typedef!    ((vm) mystruct      = mu_struct(int64, int64, ref_int64));\n    typedef!    ((vm) ref_mystruct  = mu_ref(mystruct));\n    typedef!    ((vm) iref_mystruct = mu_iref(mystruct));\n    funcsig!    ((vm) sig = (ref_mystruct) -> (iref_int64));\n    funcdecl!   ((vm) <sig> get_field_iref1);\n    funcdef!    ((vm) <sig> get_field_iref1 VERSION get_field_iref1_v1);\n    block!      ((vm, get_field_iref1_v1) blk_entry);\n    ssa!        ((vm, get_field_iref1_v1) <ref_mystruct> x);\n    ssa!        ((vm, get_field_iref1_v1) <iref_mystruct> x_);\n    inst!       ((vm, get_field_iref1_v1) blk_entry_get_iref:\n        x_ = GETIREF x\n    );\n    ssa!        ((vm, get_field_iref1_v1) <iref_int64> ret);\n    inst!       ((vm, get_field_iref1_v1) blk_entry_get_field_iref1:\n        ret = GETFIELDIREF x_ (is_ptr: false, index: 1)\n    );\n    inst!       ((vm, get_field_iref1_v1) blk_entry_ret:\n        RET (ret)\n    );\n    define_block!   ((vm, get_field_iref1_v1) blk_entry(x) {\n        blk_entry_get_iref, blk_entry_get_field_iref1, blk_entry_ret\n    });\n    define_func_ver!((vm) get_field_iref1_v1 (entry: blk_entry) {blk_entry});\n    vm\n"]], "pred": {"ppl": 1.4707043170928955, "ppl_lower": 1.5829755067825317, "ppl/lowercase_ppl": -1.1907103885170727, "ppl/zlib": 0.000961948661645639, "Min_5.0% Prob": 4.91294588247935, "Min_10.0% Prob": 3.2766166726748147, "Min_20.0% Prob": 1.868791172327089, "Min_30.0% Prob": 1.2786856864343632, "Min_40.0% Prob": 0.9631332106267413, "Min_50.0% Prob": 0.771115272562479, "Min_60.0% Prob": 0.644236776116496}}
{"hexsha": "e4014ad2ef49b9f8842aa1a116997512e34450ee", "ext": "rs", "lang": "Rust", "content": "fn test_match() {\n        let event: Box<Event> = Box::new(A);\n\n        let mut n: usize = 0;\n        match_event!(event:\n            A => n += 1,\n            A => n += 1,\n            B => assert!(false),\n            C => assert!(false),\n        );\n\n        assert!(n == 2);\n    }", "item_id": 0, "repo": "leod/hooks", "file": "hooks_game/src/event.rs", "last_update_at": "2020-04-08T01:47:22+00:00", "question_id": "e4014ad2ef49b9f8842aa1a116997512e34450ee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_match() {\n        let event: Box<Event> = Box::new(A);\n        let mut n: usize = 0;\n        match_event!(event:\n            A => n += 1,\n            A => n += 1,\n            B => assert!(false),\n            C => assert!(false),\n        );\n        assert!(n == 2);\n"]], "pred": {"ppl": 3.0765633583068848, "ppl_lower": 3.934983253479004, "ppl/lowercase_ppl": -1.2189807424469812, "ppl/zlib": 0.00785883343543916, "Min_5.0% Prob": 7.88284969329834, "Min_10.0% Prob": 6.468620035383436, "Min_20.0% Prob": 4.619811819659339, "Min_30.0% Prob": 3.4945099044729164, "Min_40.0% Prob": 2.6942004271455713, "Min_50.0% Prob": 2.228461453124233, "Min_60.0% Prob": 1.8854442232034423}}
{"hexsha": "1930e58121c66a8b9404a4b2df4e8c017aea6035", "ext": "rs", "lang": "Rust", "content": "fn try_read_by_range() {\n        let space = TreeObjectSpace::new();\n        assert_eq!(space.try_read_by_range::<i64, _>(\"\", 2..4), None);\n        space.write::<i64>(3);\n        space.write::<i64>(5);\n\n        assert_eq!(space.try_read_by_range::<i64, _>(\"\", 2..4), Some(3));\n        assert_ne!(space.try_read_by_range::<i64, _>(\"\", 2..4), None);\n\n        space.write(TestStruct {\n            count: 3,\n            name: String::from(\"Tuan\"),\n        });\n        space.write(TestStruct {\n            count: 5,\n            name: String::from(\"Duane\"),\n        });\n\n        assert_eq!(\n            space.try_read_by_range::<TestStruct, _>(\"count\", 2..4),\n            Some(TestStruct {\n                count: 3,\n                name: String::from(\"Tuan\"),\n            })\n        );\n        assert!(\n            space\n                .try_read_by_range::<TestStruct, _>(\"count\", 2..4)\n                .is_some()\n        );\n\n        space.write(CompoundStruct {\n            person: TestStruct {\n                count: 5,\n                name: String::from(\"Duane\"),\n            },\n            gpa: 3.0,\n        });\n        space.write(CompoundStruct {\n            person: TestStruct {\n                count: 3,\n                name: String::from(\"Tuan\"),\n            },\n            gpa: 3.5,\n        });\n\n        assert_eq!(\n            space.try_read_by_range::<CompoundStruct, _>(\"person.count\", 2..4),\n            Some(CompoundStruct {\n                person: TestStruct {\n                    count: 3,\n                    name: String::from(\"Tuan\"),\n                },\n                gpa: 3.5\n            })\n        );\n        assert!(\n            space\n                .try_read_by_range::<CompoundStruct, _>(\"person.count\", 2..4)\n                .is_some()\n        );\n    }", "item_id": 4, "repo": "tmt96/rs-object-space", "file": "src/object_space.rs", "last_update_at": "2020-03-03T20:42:12+00:00", "question_id": "1930e58121c66a8b9404a4b2df4e8c017aea6035_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_read_by_range() {\n        let space = TreeObjectSpace::new();\n        assert_eq!(space.try_read_by_range::<i64, _>(\"\", 2..4), None);\n        space.write::<i64>(3);\n        space.write::<i64>(5);\n        assert_eq!(space.try_read_by_range::<i64, _>(\"\", 2..4), Some(3));\n        assert_ne!(space.try_read_by_range::<i64, _>(\"\", 2..4), None);\n        space.write(TestStruct {\n            count: 3,\n            name: String::from(\"Tuan\"),\n        });\n        space.write(TestStruct {\n            count: 5,\n            name: String::from(\"Duane\"),\n        });\n        assert_eq!(\n            space.try_read_by_range::<TestStruct, _>(\"count\", 2..4),\n            Some(TestStruct {\n                count: 3,\n                name: String::from(\"Tuan\"),\n            })\n        );\n        assert!(\n            space\n                .try_read_by_range::<TestStruct, _>(\"count\", 2..4)\n                .is_some()\n        );\n        space.write(CompoundStruct {\n            person: TestStruct {\n                count: 5,\n                name: String::from(\"Duane\"),\n            },\n            gpa: 3.0,\n        });\n        space.write(CompoundStruct {\n            person: TestStruct {\n                count: 3,\n                name: String::from(\"Tuan\"),\n            },\n            gpa: 3.5,\n        });\n        assert_eq!(\n            space.try_read_by_range::<CompoundStruct, _>(\"person.count\", 2..4),\n            Some(CompoundStruct {\n                person: TestStruct {\n                    count: 3,\n                    name: String::from(\"Tuan\"),\n                },\n                gpa: 3.5\n            })\n        );\n        assert!(\n            space\n                .try_read_by_range::<CompoundStruct, _>(\"person.count\", 2..4)\n                .is_some()\n        );\n"]], "pred": {"ppl": 1.5977509021759033, "ppl_lower": 1.6962597370147705, "ppl/lowercase_ppl": -1.127676284982426, "ppl/zlib": 0.0013782263358884674, "Min_5.0% Prob": 5.923944711685181, "Min_10.0% Prob": 3.9052203568545254, "Min_20.0% Prob": 2.2729507528983794, "Min_30.0% Prob": 1.5556307080684297, "Min_40.0% Prob": 1.168938649243566, "Min_50.0% Prob": 0.9381549216139496, "Min_60.0% Prob": 0.7807927244652605}}
{"hexsha": "fb01b7214c51652740b8248325ecb29abac26338", "ext": "rs", "lang": "Rust", "content": "async fn _event(listeners: Listeners<Event>, event: Event) {\n    let mut listeners = listeners.all().lock().await;\n    let mut remove_listeners = Vec::new();\n\n    // Take up to the last one so that we can later get the last and *move*\n    // the event into the listener's channel, rather than clone it like we\n    // do here.\n    //\n    // This avoids a clone, and for users with only 1 listener this will\n    // entirely avoid cloning.\n    let mut last = None;\n\n    for (idx, (id, listener)) in listeners.iter().enumerate() {\n        if idx == listeners.len() - 1 {\n            last = Some(*id);\n\n            break;\n        }\n\n        let event_type = event.event_type();\n\n        if !listener.events.contains(event_type) {\n            trace!(\n                \"[ShardProcessor] Listener {} doesn't want event type {:?}\",\n                id,\n                event_type,\n            );\n\n            continue;\n        }\n\n        if !_emit_to_listener(*id, listener, event.clone()) {\n            remove_listeners.push(*id);\n        }\n    }\n\n    if let Some(id) = last {\n        if let Some(listener) = listeners.get(&id) {\n            if !_emit_to_listener(id, listener, event) {\n                remove_listeners.push(id);\n            }\n        }\n    }\n\n    for id in &remove_listeners {\n        debug!(\"[ShardProcessor] Removing listener {}\", id);\n\n        listeners.remove(id);\n    }\n}", "item_id": 0, "repo": "Mathspy/dawn", "file": "gateway/src/shard/processor/emit.rs", "last_update_at": "2020-10-09T11:26:01+00:00", "question_id": "fb01b7214c51652740b8248325ecb29abac26338_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn _event(listeners: Listeners<Event>, event: Event) {\n    let mut listeners = listeners.all().lock().await;\n    let mut remove_listeners = Vec::new();\n    // Take up to the last one so that we can later get the last and *move*\n    // the event into the listener's channel, rather than clone it like we\n    // do here.\n    //\n    // This avoids a clone, and for users with only 1 listener this will\n    // entirely avoid cloning.\n    let mut last = None;\n    for (idx, (id, listener)) in listeners.iter().enumerate() {\n        if idx == listeners.len() - 1 {\n            last = Some(*id);\n            break;\n        }\n        let event_type = event.event_type();\n        if !listener.events.contains(event_type) {\n            trace!(\n                \"[ShardProcessor] Listener {} doesn't want event type {:?}\",\n                id,\n                event_type,\n            );\n            continue;\n        }\n        if !_emit_to_listener(*id, listener, event.clone()) {\n            remove_listeners.push(*id);\n        }\n    }\n    if let Some(id) = last {\n        if let Some(listener) = listeners.get(&id) {\n            if !_emit_to_listener(id, listener, event) {\n                remove_listeners.push(id);\n            }\n        }\n    }\n    for id in &remove_listeners {\n        debug!(\"[ShardProcessor] Removing listener {}\", id);\n        listeners.remove(id);\n    }\n"]], "pred": {"ppl": 2.706294298171997, "ppl_lower": 2.91764497756958, "ppl/lowercase_ppl": -1.0755303176111757, "ppl/zlib": 0.001803587466438826, "Min_5.0% Prob": 7.549375772476196, "Min_10.0% Prob": 5.8797370254993435, "Min_20.0% Prob": 4.073537883935152, "Min_30.0% Prob": 3.0790134274269922, "Min_40.0% Prob": 2.4341934144864847, "Min_50.0% Prob": 1.9865650401478356, "Min_60.0% Prob": 1.6577510572203393}}
{"hexsha": "9918ffddd344af87248d73ef2499aa742c3d2484", "ext": "rs", "lang": "Rust", "content": "fn nonintersecting_quorums_in_broken() {\n        let fbas = Fbas::from_json_file(Path::new(\"test_data/broken.json\"));\n\n        let expected = Some(vec![bitset![3, 10], bitset![4, 6]]);\n        let actual = find_nonintersecting_quorums(&fbas);\n\n        assert_eq!(expected, actual);\n    }", "item_id": 13, "repo": "marfl/fbas_analyzer", "file": "src/analysis/quorums.rs", "last_update_at": "2020-02-18T16:36:37+00:00", "question_id": "9918ffddd344af87248d73ef2499aa742c3d2484_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn nonintersecting_quorums_in_broken() {\n        let fbas = Fbas::from_json_file(Path::new(\"test_data/broken.json\"));\n        let expected = Some(vec![bitset![3, 10], bitset![4, 6]]);\n        let actual = find_nonintersecting_quorums(&fbas);\n        assert_eq!(expected, actual);\n"]], "pred": {"ppl": 3.5272927284240723, "ppl_lower": 4.366406440734863, "ppl/lowercase_ppl": -1.1693014785229892, "ppl/zlib": 0.006634371811812028, "Min_5.0% Prob": 8.32506504058838, "Min_10.0% Prob": 6.82346019744873, "Min_20.0% Prob": 4.7399324235462, "Min_30.0% Prob": 3.7071504631350116, "Min_40.0% Prob": 2.96675076796895, "Min_50.0% Prob": 2.4837779299570966, "Min_60.0% Prob": 2.088867646834207}}
{"hexsha": "5d997087933b43733a3d66523c90a6d04f21c85f", "ext": "rs", "lang": "Rust", "content": "fn start() {\n        let (_, remote, chan) = setup_request_test();\n\n        let request: &[u8] = &[\n            0xFA, 0xCE, 0xBA, 0xD0, // transaction id\n            0x02, 0x30, 0x00, 0x00, // start\n        ];\n\n        let response_size = mem::size_of::<(AudioCommandHeader, StartResponse)>();\n\n        let r = Request::decode(request);\n        if let Ok(Request::Start { mut responder }) = r {\n            responder.0.set_channel(chan);\n\n            assert!(responder.reply(zx::Status::OK, 27).is_ok());\n\n            let expected: &[u8] = &[\n                0xFA, 0xCE, 0xBA, 0xD0, // transaction id\n                0x02, 0x30, 0x00, 0x00, // start\n                0x00, 0x00, 0x00, 0x00, // ZX_OK\n                0x00, 0x00, 0x00, 0x00, // padding\n                27, 0x00, 0x00, 0x00, // Started at 27\n                0x00, 0x00, 0x00, 0x00,\n            ];\n\n            expect_channel_recv(&remote, response_size, expected);\n        } else {\n            panic!(\"Expected Start but got {:?}\", r);\n        }\n    }", "item_id": 4, "repo": "opensource-assist/fuschia", "file": "src/connectivity/bluetooth/lib/fuchsia-audio-device-output/src/ring_buffer.rs", "last_update_at": "2020-08-07T10:10:53+00:00", "question_id": "5d997087933b43733a3d66523c90a6d04f21c85f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn start() {\n        let (_, remote, chan) = setup_request_test();\n        let request: &[u8] = &[\n            0xFA, 0xCE, 0xBA, 0xD0, // transaction id\n            0x02, 0x30, 0x00, 0x00, // start\n        ];\n        let response_size = mem::size_of::<(AudioCommandHeader, StartResponse)>();\n        let r = Request::decode(request);\n        if let Ok(Request::Start { mut responder }) = r {\n            responder.0.set_channel(chan);\n            assert!(responder.reply(zx::Status::OK, 27).is_ok());\n            let expected: &[u8] = &[\n                0xFA, 0xCE, 0xBA, 0xD0, // transaction id\n                0x02, 0x30, 0x00, 0x00, // start\n                0x00, 0x00, 0x00, 0x00, // ZX_OK\n                0x00, 0x00, 0x00, 0x00, // padding\n                27, 0x00, 0x00, 0x00, // Started at 27\n                0x00, 0x00, 0x00, 0x00,\n            ];\n            expect_channel_recv(&remote, response_size, expected);\n        } else {\n            panic!(\"Expected Start but got {:?}\", r);\n        }\n"]], "pred": {"ppl": 2.3687214851379395, "ppl_lower": 2.6973302364349365, "ppl/lowercase_ppl": -1.1506488985440437, "ppl/zlib": 0.0021721671330973626, "Min_5.0% Prob": 6.7926088094711305, "Min_10.0% Prob": 5.494677275419235, "Min_20.0% Prob": 3.806740743142587, "Min_30.0% Prob": 2.7584330129330277, "Min_40.0% Prob": 2.1395938540866344, "Min_50.0% Prob": 1.7220351133917646, "Min_60.0% Prob": 1.4365199443991068}}
{"hexsha": "64e920c37246352da58debe1839a44a5db497903", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    use std::io::Write;\n\n    //setup resource\n    let mut res = winres::WindowsResource::new();\n    res.set_manifest_file(\"./manifest.xml\");\n    res.compile().unwrap();\n}", "item_id": 0, "repo": "lokanchung/BitwigLauncher", "file": "build.rs", "last_update_at": "2020-12-19T01:23:15+00:00", "question_id": "64e920c37246352da58debe1839a44a5db497903_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    use std::io::Write;\n    //setup resource\n    let mut res = winres::WindowsResource::new();\n    res.set_manifest_file(\"./manifest.xml\");\n    res.compile().unwrap();\n"]], "pred": {"ppl": 3.526284694671631, "ppl_lower": 5.775562763214111, "ppl/lowercase_ppl": -1.3915039910225375, "ppl/zlib": 0.009132208856932658, "Min_5.0% Prob": 11.347577571868896, "Min_10.0% Prob": 8.652746963500977, "Min_20.0% Prob": 5.306471889669245, "Min_30.0% Prob": 3.9239127600894257, "Min_40.0% Prob": 3.0426728803178538, "Min_50.0% Prob": 2.4717479486917626, "Min_60.0% Prob": 2.1331345263649437}}
{"hexsha": "709fec4c126c877efca901b594fa18a4c24bcd42", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input_data: Vec<u32> = vec![0, 20, 7, 16, 1, 18, 15];\n    let last_spoken_word = play_game(&input_data, 30000000);\n    println!(\"Last spoken word: {}\", last_spoken_word);\n}", "item_id": 1, "repo": "dantrim/danny_advents_of_code", "file": "2020/rust/day_15/src/main.rs", "last_update_at": "2020-12-02T16:59:30+00:00", "question_id": "709fec4c126c877efca901b594fa18a4c24bcd42_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input_data: Vec<u32> = vec![0, 20, 7, 16, 1, 18, 15];\n    let last_spoken_word = play_game(&input_data, 30000000);\n    println!(\"Last spoken word: {}\", last_spoken_word);\n"]], "pred": {"ppl": 2.679722309112549, "ppl_lower": 2.968611717224121, "ppl/lowercase_ppl": -1.1038651383503422, "ppl/zlib": 0.006798021883803284, "Min_5.0% Prob": 7.027976393699646, "Min_10.0% Prob": 5.000660763846503, "Min_20.0% Prob": 3.6841505898369684, "Min_30.0% Prob": 2.9043216617019088, "Min_40.0% Prob": 2.35667708184984, "Min_50.0% Prob": 1.9516126741965611, "Min_60.0% Prob": 1.6497882070640724}}
{"hexsha": "b46e919bab86ce56f6aef393ba3e10addd1cd98d", "ext": "rs", "lang": "Rust", "content": "pub fn mkdtemp() -> io::Result<PathBuf> {\n    let temp_path;\n    {\n        let temp = mktemp::Temp::new_dir()?;\n        temp_path = temp.to_path_buf();\n        temp.release();\n    }\n    Ok(temp_path)\n}", "item_id": 4, "repo": "jokeyrhyme/dotfiles-rs", "file": "src/utils/fs.rs", "last_update_at": "2020-08-28T18:19:44+00:00", "question_id": "b46e919bab86ce56f6aef393ba3e10addd1cd98d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn mkdtemp() -> io::Result<PathBuf> {\n    let temp_path;\n    {\n        let temp = mktemp::Temp::new_dir()?;\n        temp_path = temp.to_path_buf();\n        temp.release();\n    }\n    Ok(temp_path)\n"]], "pred": {"ppl": 3.592740058898926, "ppl_lower": 5.726112365722656, "ppl/lowercase_ppl": -1.3644664526841699, "ppl/zlib": 0.009688751204386491, "Min_5.0% Prob": 9.509944915771484, "Min_10.0% Prob": 7.341521739959717, "Min_20.0% Prob": 5.365765523910523, "Min_30.0% Prob": 4.112757818265394, "Min_40.0% Prob": 3.1787276536226274, "Min_50.0% Prob": 2.546313409938624, "Min_60.0% Prob": 2.155723552985324}}
{"hexsha": "25795b5ed67ca5cc3a91e86b08509ed222e02ddd", "ext": "rs", "lang": "Rust", "content": "fn test_checker_digest_file_block_algo() {\n    let mut ext_table = digest_ext_table::DigestExtTable::default();\n    let pypi_file_path = Path::new(\"tests/fixtures/files/pypi.tar.gz\");\n    let correct_md5 = \"fe7daf822f1d36d1bd37ac41cf5817e7\".to_string();\n\n    ext_table.block(digest_ext_table::DigestAlgo::Md5);\n    assert_eq!(false, ext_table.is_md5(\"gz\".to_string()));\n\n    match checker::digest_file(&ext_table, &pypi_file_path) {\n        Some(shas) => {\n            println!(\"failed to block using MD5 algo for Pypi files\");\n            assert!(false);\n        }\n        None => assert!(true),\n    };\n}", "item_id": 6, "repo": "whizsid/veye-checker", "file": "tests/checker_test.rs", "last_update_at": "2020-09-09T20:01:38+00:00", "question_id": "25795b5ed67ca5cc3a91e86b08509ed222e02ddd_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_checker_digest_file_block_algo() {\n    let mut ext_table = digest_ext_table::DigestExtTable::default();\n    let pypi_file_path = Path::new(\"tests/fixtures/files/pypi.tar.gz\");\n    let correct_md5 = \"fe7daf822f1d36d1bd37ac41cf5817e7\".to_string();\n    ext_table.block(digest_ext_table::DigestAlgo::Md5);\n    assert_eq!(false, ext_table.is_md5(\"gz\".to_string()));\n    match checker::digest_file(&ext_table, &pypi_file_path) {\n        Some(shas) => {\n            println!(\"failed to block using MD5 algo for Pypi files\");\n            assert!(false);\n        }\n        None => assert!(true),\n    };\n"]], "pred": {"ppl": 5.058065414428711, "ppl_lower": 5.972884178161621, "ppl/lowercase_ppl": -1.1025585899210266, "ppl/zlib": 0.004824357384013865, "Min_5.0% Prob": 8.340466846119273, "Min_10.0% Prob": 7.05086730874103, "Min_20.0% Prob": 5.43421905455382, "Min_30.0% Prob": 4.467466872671376, "Min_40.0% Prob": 3.7423777836625294, "Min_50.0% Prob": 3.173130915082734, "Min_60.0% Prob": 2.7017108315615346}}
{"hexsha": "03e2be904c3bc8931993d545a0c442e18fb84232", "ext": "rs", "lang": "Rust", "content": "fn get_ld_search_dirs() -> Vec<String> {\n    // We need to extract from `ld --verbose` all the search paths.\n    // For example `ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\\n'` returns the following:\n    // ```\n    // SEARCH_DIR(\"=/usr/local/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/usr/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/usr/local/lib\")\n    // SEARCH_DIR(\"=/lib\")\n    // SEARCH_DIR(\"=/usr/lib\")\n    // SEARCH_DIR(\"=/usr/aarch64-linux-gnu/lib\")\n    // ```\n    let cmd = r#\"\n        ld --verbose | grep -oP '(?<=SEARCH_DIR\\(\\\"=)[^\"]+(?=\\\"\\);)'\n    \"#;\n\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .output()\n        .ok()\n        .and_then(|output| {\n            if output.status.success() {\n                return Some(output.stdout);\n            }\n            None\n        })\n        .and_then(|stdout_bytes| String::from_utf8(stdout_bytes).ok())\n        .map_or(vec![], |stdout| {\n            stdout.lines().map(|item| item.to_string()).collect()\n        })\n}", "item_id": 0, "repo": "psalaberria002/firecracker", "file": "src/libfdt-bindings/build.rs", "last_update_at": "2020-03-29T00:58:58+00:00", "question_id": "03e2be904c3bc8931993d545a0c442e18fb84232_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_ld_search_dirs() -> Vec<String> {\n    // We need to extract from `ld --verbose` all the search paths.\n    // For example `ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\\n'` returns the following:\n    // ```\n    // SEARCH_DIR(\"=/usr/local/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/usr/lib/aarch64-linux-gnu\")\n    // SEARCH_DIR(\"=/usr/local/lib\")\n    // SEARCH_DIR(\"=/lib\")\n    // SEARCH_DIR(\"=/usr/lib\")\n    // SEARCH_DIR(\"=/usr/aarch64-linux-gnu/lib\")\n    // ```\n    let cmd = r#\"\n        ld --verbose | grep -oP '(?<=SEARCH_DIR\\(\\\"=)[^\"]+(?=\\\"\\);)'\n    \"#;\n    Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(cmd)\n        .output()\n        .ok()\n        .and_then(|output| {\n            if output.status.success() {\n                return Some(output.stdout);\n            }\n            None\n        })\n        .and_then(|stdout_bytes| String::from_utf8(stdout_bytes).ok())\n        .map_or(vec![], |stdout| {\n            stdout.lines().map(|item| item.to_string()).collect()\n        })\n"]], "pred": {"ppl": 1.7606205940246582, "ppl_lower": 2.32475209236145, "ppl/lowercase_ppl": -1.4913621709443616, "ppl/zlib": 0.0012432227629427743, "Min_5.0% Prob": 5.1023948192596436, "Min_10.0% Prob": 3.9303611516952515, "Min_20.0% Prob": 2.539426718439375, "Min_30.0% Prob": 1.8469766645327859, "Min_40.0% Prob": 1.4103649990367038, "Min_50.0% Prob": 1.1298455362319175, "Min_60.0% Prob": 0.9448316575620662}}
{"hexsha": "3578a8e8be320e2e4b7f711611462efd8b2bee33", "ext": "rs", "lang": "Rust", "content": "fn create_random_filename(dir: &Path) -> PathBuf {\n    let mut filename = [0; FILENAME_LEN];\n    rand::thread_rng().fill_bytes(&mut filename);\n    dir.join(hex::encode(filename))\n}", "item_id": 0, "repo": "pranaypaine/libra", "file": "storage/backup-restore/src/adapter/local_storage/mod.rs", "last_update_at": "2020-05-23T17:59:02+00:00", "question_id": "3578a8e8be320e2e4b7f711611462efd8b2bee33_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_random_filename(dir: &Path) -> PathBuf {\n    let mut filename = [0; FILENAME_LEN];\n    rand::thread_rng().fill_bytes(&mut filename);\n    dir.join(hex::encode(filename))\n"]], "pred": {"ppl": 2.455127716064453, "ppl_lower": 3.90850567817688, "ppl/lowercase_ppl": -1.51768795663387, "ppl/zlib": 0.0061100597464638605, "Min_5.0% Prob": 7.272971153259277, "Min_10.0% Prob": 5.938934961954753, "Min_20.0% Prob": 3.9051500360171, "Min_30.0% Prob": 2.916526450051202, "Min_40.0% Prob": 2.269666086882353, "Min_50.0% Prob": 1.783648801667075, "Min_60.0% Prob": 1.5018626584394559}}
{"hexsha": "2f410f3d3514bd4ff3b9ffbc7eaee1b9d1938f83", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), String> {\n    env_logger::init();\n\n    let args: Vec<String> = env::args().collect();\n    match if args.len() > 1 { Some(&args[1]) } else { None } {\n        Some(filename) => load_file(Path::new(filename)),\n        None => repl(),\n    }?;\n\n    Ok(())\n}", "item_id": 0, "repo": "doomdavve/maldives", "file": "src/main.rs", "last_update_at": "2020-01-16T10:52:54+00:00", "question_id": "2f410f3d3514bd4ff3b9ffbc7eaee1b9d1938f83_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), String> {\n    env_logger::init();\n    let args: Vec<String> = env::args().collect();\n    match if args.len() > 1 { Some(&args[1]) } else { None } {\n        Some(filename) => load_file(Path::new(filename)),\n        None => repl(),\n    }?;\n    Ok(())\n"]], "pred": {"ppl": 2.2143874168395996, "ppl_lower": 3.4491186141967773, "ppl/lowercase_ppl": -1.5574294437987106, "ppl/zlib": 0.004140498979170597, "Min_5.0% Prob": 7.65321683883667, "Min_10.0% Prob": 5.703136920928955, "Min_20.0% Prob": 3.722012733158312, "Min_30.0% Prob": 2.642336333436625, "Min_40.0% Prob": 1.989867546448582, "Min_50.0% Prob": 1.5855298696551472, "Min_60.0% Prob": 1.337462201453092}}
{"hexsha": "1f3f96a32f4d4b1c131dc03cdf777618848d0f0c", "ext": "rs", "lang": "Rust", "content": "fn process_child_output<R>(\n    directive: Directive,\n    context: &OutputContext,\n    read: R,\n    tx_write: AsyncSender<WriteChannel>,\n) -> Result<()>\nwhere\n    R: io::Read + Send,\n{\n    enter!(\n        span,\n        always_span!(\"child.stream\", kind = %directive.span_display())\n    );\n    trace!(\"Processing child output stream\");\n\n    let mut lines = 0u64;\n    let mut bytes = 0u64;\n\n    let buffer = io::BufReader::new(read);\n    let mut sink = RecordInterface::new_sink(tx_write.sink_map_err(CrateError::from));\n\n    buffer\n        .for_byte_line(|line| {\n            let utf8 = String::from_utf8_lossy(line);\n\n            block_on(sink.send(data(context, directive, &utf8).done_unchecked()))\n                //Ugly workaround for closure's io::Error requirement,\n                //Round trips from our local error into io::Error and back\n                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))\n                .map(|o| {\n                    lines += 1;\n                    bytes += line.len() as u64;\n                    o\n                })\n                .and(Ok(true))\n        })\n        .map(|_| {\n            if bytes > 0 {\n                debug!(lines, bytes, \"Finished child stream\")\n            }\n        })\n        .map_err(|e| e.into())\n}", "item_id": 1, "repo": "emucc/dolysis", "file": "extract/src/process.rs", "last_update_at": "2020-07-02T12:02:24+00:00", "question_id": "1f3f96a32f4d4b1c131dc03cdf777618848d0f0c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn process_child_output<R>(\n    directive: Directive,\n    context: &OutputContext,\n    read: R,\n    tx_write: AsyncSender<WriteChannel>,\n) -> Result<()>\nwhere\n    R: io::Read + Send,\n{\n    enter!(\n        span,\n        always_span!(\"child.stream\", kind = %directive.span_display())\n    );\n    trace!(\"Processing child output stream\");\n    let mut lines = 0u64;\n    let mut bytes = 0u64;\n    let buffer = io::BufReader::new(read);\n    let mut sink = RecordInterface::new_sink(tx_write.sink_map_err(CrateError::from));\n    buffer\n        .for_byte_line(|line| {\n            let utf8 = String::from_utf8_lossy(line);\n            block_on(sink.send(data(context, directive, &utf8).done_unchecked()))\n                //Ugly workaround for closure's io::Error requirement,\n                //Round trips from our local error into io::Error and back\n                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))\n                .map(|o| {\n                    lines += 1;\n                    bytes += line.len() as u64;\n                    o\n                })\n                .and(Ok(true))\n        })\n        .map(|_| {\n            if bytes > 0 {\n                debug!(lines, bytes, \"Finished child stream\")\n            }\n        })\n        .map_err(|e| e.into())\n"]], "pred": {"ppl": 3.9102699756622314, "ppl_lower": 4.653270244598389, "ppl/lowercase_ppl": -1.127576278088163, "ppl/zlib": 0.0022613705125995908, "Min_5.0% Prob": 9.12944537714908, "Min_10.0% Prob": 7.440483044355344, "Min_20.0% Prob": 5.333034252509092, "Min_30.0% Prob": 4.105999090732673, "Min_40.0% Prob": 3.265872940516016, "Min_50.0% Prob": 2.691664894776685, "Min_60.0% Prob": 2.2709382886582232}}
{"hexsha": "292d7b383856fd9f963ff32ee3fe69a51b1f2e71", "ext": "rs", "lang": "Rust", "content": "fn chain_without_skips() {\n        let n: usize = 10;\n        let store = MemoryStore::open();\n        let spec = MinimalEthSpec::default_spec();\n\n        let slots: Vec<usize> = (0..n).collect();\n        let blocks_and_roots = build_chain(&store, &slots, &spec);\n\n        for source in 1..n {\n            for target in 0..=source {\n                let (source_root, _source_block) = &blocks_and_roots[source];\n                let (target_root, target_block) = &blocks_and_roots[target];\n\n                let (found_root, found_block) = store\n                    .get_block_at_preceeding_slot(*source_root, target_block.slot)\n                    .unwrap()\n                    .unwrap();\n\n                assert_eq!(found_root, *target_root);\n                assert_eq!(found_block, *target_block);\n            }\n        }\n    }", "item_id": 4, "repo": "JustinDrake/lighthouse", "file": "beacon_node/store/src/block_at_slot.rs", "last_update_at": "2020-09-23T10:34:59+00:00", "question_id": "292d7b383856fd9f963ff32ee3fe69a51b1f2e71_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn chain_without_skips() {\n        let n: usize = 10;\n        let store = MemoryStore::open();\n        let spec = MinimalEthSpec::default_spec();\n        let slots: Vec<usize> = (0..n).collect();\n        let blocks_and_roots = build_chain(&store, &slots, &spec);\n        for source in 1..n {\n            for target in 0..=source {\n                let (source_root, _source_block) = &blocks_and_roots[source];\n                let (target_root, target_block) = &blocks_and_roots[target];\n                let (found_root, found_block) = store\n                    .get_block_at_preceeding_slot(*source_root, target_block.slot)\n                    .unwrap()\n                    .unwrap();\n                assert_eq!(found_root, *target_root);\n                assert_eq!(found_block, *target_block);\n            }\n        }\n"]], "pred": {"ppl": 2.3343141078948975, "ppl_lower": 2.833695888519287, "ppl/lowercase_ppl": -1.2286889030059664, "ppl/zlib": 0.0026164139013192295, "Min_5.0% Prob": 7.971582730611165, "Min_10.0% Prob": 5.654444780349731, "Min_20.0% Prob": 3.6852758935853545, "Min_30.0% Prob": 2.688733635372237, "Min_40.0% Prob": 2.0798684171601836, "Min_50.0% Prob": 1.6947619255309498, "Min_60.0% Prob": 1.4114035760216854}}
{"hexsha": "86d11859319c0071fd4e82037bbf2051984ed409", "ext": "rs", "lang": "Rust", "content": "pub async fn get_capabilities(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        location: &str,\n    ) -> std::result::Result<models::CapabilitiesResult, get_capabilities::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/providers/Microsoft.HDInsight/locations/{}/capabilities\",\n            operation_config.base_path(),\n            subscription_id,\n            location\n        );\n        let mut url = url::Url::parse(url_str).map_err(get_capabilities::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get_capabilities::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get_capabilities::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(get_capabilities::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CapabilitiesResult = serde_json::from_slice(rsp_body)\n                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ErrorResponse = serde_json::from_slice(rsp_body)\n                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get_capabilities::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 30, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/hdinsight/src/package_2021_06/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "86d11859319c0071fd4e82037bbf2051984ed409_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get_capabilities(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        location: &str,\n    ) -> std::result::Result<models::CapabilitiesResult, get_capabilities::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/providers/Microsoft.HDInsight/locations/{}/capabilities\",\n            operation_config.base_path(),\n            subscription_id,\n            location\n        );\n        let mut url = url::Url::parse(url_str).map_err(get_capabilities::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get_capabilities::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get_capabilities::Error::BuildRequestError)?;\n        let rsp = http_client\n            .execute_request(req)\n            .await\n            .map_err(get_capabilities::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CapabilitiesResult = serde_json::from_slice(rsp_body)\n                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ErrorResponse = serde_json::from_slice(rsp_body)\n                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get_capabilities::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.0972200632095337, "ppl_lower": 2.0360028743743896, "ppl/lowercase_ppl": -7.663185014341015, "ppl/zlib": 0.00011910111134950383, "Min_5.0% Prob": 1.86497100741219, "Min_10.0% Prob": 0.9331701363546873, "Min_20.0% Prob": 0.4666214583058611, "Min_30.0% Prob": 0.309566346447989, "Min_40.0% Prob": 0.23245885595678908, "Min_50.0% Prob": 0.18555944973909305, "Min_60.0% Prob": 0.15478380096203892}}
{"hexsha": "c14635494da02a8f75fa1e12483eaa3aa6eb05a4", "ext": "rs", "lang": "Rust", "content": "pub(crate) async fn local_data_helper(\n    ctx: Context,\n    url: Url,\n    shared_args: SharedArguments<Unverified>,\n    source_args: SourceArguments<Unverified>,\n) -> Result<Option<BoxStream<CsvStream>>> {\n    let _shared_args = shared_args.verify(GsLocator::features())?;\n    let _source_args = source_args.verify(GsLocator::features())?;\n    debug!(\"getting CSV files from {}\", url);\n\n    let file_urls = storage::ls(&ctx, &url).await?;\n\n    let csv_streams = file_urls.and_then(move |item| {\n        let url = url.clone();\n        async move {\n            // Stream the file from the cloud.\n            let file_url = item.to_url_string();\n            let name = csv_stream_name(url.as_str(), &file_url)?;\n            let data = storage::download_file(&item)\n                .instrument(trace_span!(\"stream_from_gs\", stream = %name))\n                .await?;\n\n            // Assemble everything into a CSV stream.\n            Ok(CsvStream {\n                name: name.to_owned(),\n                data,\n            })\n        }\n        .boxed()\n    });\n\n    Ok(Some(csv_streams.boxed()))\n}", "item_id": 0, "repo": "faradayio/schemaconv", "file": "dbcrossbarlib/src/drivers/gs/local_data.rs", "last_update_at": "2020-03-14T16:15:26+00:00", "question_id": "c14635494da02a8f75fa1e12483eaa3aa6eb05a4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) async fn local_data_helper(\n    ctx: Context,\n    url: Url,\n    shared_args: SharedArguments<Unverified>,\n    source_args: SourceArguments<Unverified>,\n) -> Result<Option<BoxStream<CsvStream>>> {\n    let _shared_args = shared_args.verify(GsLocator::features())?;\n    let _source_args = source_args.verify(GsLocator::features())?;\n    debug!(\"getting CSV files from {}\", url);\n    let file_urls = storage::ls(&ctx, &url).await?;\n    let csv_streams = file_urls.and_then(move |item| {\n        let url = url.clone();\n        async move {\n            // Stream the file from the cloud.\n            let file_url = item.to_url_string();\n            let name = csv_stream_name(url.as_str(), &file_url)?;\n            let data = storage::download_file(&item)\n                .instrument(trace_span!(\"stream_from_gs\", stream = %name))\n                .await?;\n            // Assemble everything into a CSV stream.\n            Ok(CsvStream {\n                name: name.to_owned(),\n                data,\n            })\n        }\n        .boxed()\n    });\n    Ok(Some(csv_streams.boxed()))\n"]], "pred": {"ppl": 3.2734386920928955, "ppl_lower": 4.176869869232178, "ppl/lowercase_ppl": -1.2055259571792218, "ppl/zlib": 0.002366948144059942, "Min_5.0% Prob": 7.728784054517746, "Min_10.0% Prob": 6.352826783151338, "Min_20.0% Prob": 4.629107681672965, "Min_30.0% Prob": 3.563410029411316, "Min_40.0% Prob": 2.837499418143016, "Min_50.0% Prob": 2.3313830746781257, "Min_60.0% Prob": 1.9734338910054805}}
{"hexsha": "9ca7d9b5c1251d795bc0be19d77fbf8155a74e38", "ext": "rs", "lang": "Rust", "content": "async fn capture_url_event_should_return_a_filled_command_event() {\n        let mock_post_http_request_body = r#\"\n        {\n            \"url\":\"https://duckduckgo.com/\"\n         }\"#;\n\n        let body = Bytes::from(mock_post_http_request_body);\n        let path = \"/wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url\".to_string();\n\n        let expected_event = Some(CommandEvent {\n            event: domain::session::SessionStatus::UrlCommand,\n            session_id: \"f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string(),\n            url: \"https://duckduckgo.com/\".to_string(),\n        });\n\n        let capture_event = capture_url_event(path, &body);\n\n        assert!(capture_event == expected_event);\n    }", "item_id": 7, "repo": "voyages-sncf-technologies/soda-test-service", "file": "src/inspector.rs", "last_update_at": "2020-01-04T15:30:53+00:00", "question_id": "9ca7d9b5c1251d795bc0be19d77fbf8155a74e38_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn capture_url_event_should_return_a_filled_command_event() {\n        let mock_post_http_request_body = r#\"\n        {\n            \"url\":\"https://duckduckgo.com/\"\n         }\"#;\n        let body = Bytes::from(mock_post_http_request_body);\n        let path = \"/wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url\".to_string();\n        let expected_event = Some(CommandEvent {\n            event: domain::session::SessionStatus::UrlCommand,\n            session_id: \"f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string(),\n            url: \"https://duckduckgo.com/\".to_string(),\n        });\n        let capture_event = capture_url_event(path, &body);\n        assert!(capture_event == expected_event);\n"]], "pred": {"ppl": 3.5271377563476562, "ppl_lower": 4.11527681350708, "ppl/lowercase_ppl": -1.1223490831804968, "ppl/zlib": 0.003831266590108666, "Min_5.0% Prob": 8.537199167104868, "Min_10.0% Prob": 6.925813693266648, "Min_20.0% Prob": 5.061804357564674, "Min_30.0% Prob": 3.959780355043049, "Min_40.0% Prob": 3.1124939069433033, "Min_50.0% Prob": 2.5140762232187996, "Min_60.0% Prob": 2.107490937125945}}
{"hexsha": "159d70690da0a890d797b0ebbb4212e7b1ab6462", "ext": "rs", "lang": "Rust", "content": "pub fn generate_rust_modules(out_dir: &Path) -> CrateResult {\n    let api_defs_root = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/methods\");\n    let entries = std::fs::read_dir(api_defs_root)?;\n    let mut api = Api::default();\n\n    for entry in entries {\n        let entry = entry?;\n        if !entry.file_type()?.is_file() {\n            continue;\n        }\n\n        // https://doc.rust-lang.org/cargo/reference/build-scripts.html\n        println!(\"cargo:rerun-if-changed={}\", entry.path().to_string_lossy());\n\n        let contents = std::fs::read_to_string(entry.path())?;\n        eprintln!(\"Merging {}\", entry.path().file_name().unwrap().to_string_lossy());\n        let api_fragment: Api = toml::from_str(&contents)?;\n\n        merge(&mut api, api_fragment);\n    }\n\n    validate(&api);\n\n    rust_crate::generate_rust_crate(out_dir, &api)?;\n\n    eprintln!(\"ok: definitions generated\");\n\n    Ok(())\n}", "item_id": 0, "repo": "ever0de/prisma-engines", "file": "migration-engine/json-rpc-api-build/src/lib.rs", "last_update_at": "2020-02-10T09:21:10+00:00", "question_id": "159d70690da0a890d797b0ebbb4212e7b1ab6462_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn generate_rust_modules(out_dir: &Path) -> CrateResult {\n    let api_defs_root = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/methods\");\n    let entries = std::fs::read_dir(api_defs_root)?;\n    let mut api = Api::default();\n    for entry in entries {\n        let entry = entry?;\n        if !entry.file_type()?.is_file() {\n            continue;\n        }\n        // https://doc.rust-lang.org/cargo/reference/build-scripts.html\n        println!(\"cargo:rerun-if-changed={}\", entry.path().to_string_lossy());\n        let contents = std::fs::read_to_string(entry.path())?;\n        eprintln!(\"Merging {}\", entry.path().file_name().unwrap().to_string_lossy());\n        let api_fragment: Api = toml::from_str(&contents)?;\n        merge(&mut api, api_fragment);\n    }\n    validate(&api);\n    rust_crate::generate_rust_crate(out_dir, &api)?;\n    eprintln!(\"ok: definitions generated\");\n    Ok(())\n"]], "pred": {"ppl": 2.369673490524292, "ppl_lower": 2.8636934757232666, "ppl/lowercase_ppl": -1.2194836983707533, "ppl/zlib": 0.0018553810278385543, "Min_5.0% Prob": 8.031160704294841, "Min_10.0% Prob": 6.101353232065836, "Min_20.0% Prob": 3.8600445767243703, "Min_30.0% Prob": 2.76938298675749, "Min_40.0% Prob": 2.1343039189775785, "Min_50.0% Prob": 1.7209001351892947, "Min_60.0% Prob": 1.4371662989207026}}
{"hexsha": "7baa3902119c9564687939545f6435bfd9a95b93", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern fn Java_com_nativesigner_EthkeyBridge_ethkeyEthSign(env: JNIEnv, _: JClass, data: JString) -> jstring {\n    let data: String = env.get_string(data).expect(\"Invalid seed\").into();\n    let hex = data.from_hex().unwrap();\n    let message = format!(\"\\x19Ethereum Signed Message:\\n{}\", hex.len()).into_bytes();\n    let mut res: [u8; 32] = [0; 32];\n    let mut keccak = Keccak::new_keccak256();\n    keccak.update(&message);\n    keccak.update(&hex);\n    keccak.finalize(&mut res);\n    env.new_string(res.to_hex()).expect(\"Could not create java string\").into_inner()\n  }", "item_id": 13, "repo": "Tenzorum/IPAS-mobile-portal", "file": "rust/signer/src/lib.rs", "last_update_at": "2020-06-13T10:43:45+00:00", "question_id": "7baa3902119c9564687939545f6435bfd9a95b93_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern fn Java_com_nativesigner_EthkeyBridge_ethkeyEthSign(env: JNIEnv, _: JClass, data: JString) -> jstring {\n    let data: String = env.get_string(data).expect(\"Invalid seed\").into();\n    let hex = data.from_hex().unwrap();\n    let message = format!(\"\\x19Ethereum Signed Message:\\n{}\", hex.len()).into_bytes();\n    let mut res: [u8; 32] = [0; 32];\n    let mut keccak = Keccak::new_keccak256();\n    keccak.update(&message);\n    keccak.update(&hex);\n    keccak.finalize(&mut res);\n    env.new_string(res.to_hex()).expect(\"Could not create java string\").into_inner()\n"]], "pred": {"ppl": 2.6881401538848877, "ppl_lower": 3.5866618156433105, "ppl/lowercase_ppl": -1.2916240880115673, "ppl/zlib": 0.0028662306141559583, "Min_5.0% Prob": 8.294576978683471, "Min_10.0% Prob": 6.13462039402553, "Min_20.0% Prob": 4.13877412818727, "Min_30.0% Prob": 3.0879040521288674, "Min_40.0% Prob": 2.429022559097835, "Min_50.0% Prob": 1.9610893140845704, "Min_60.0% Prob": 1.646155807680971}}
{"hexsha": "317cff68db696221fd9b33fbc79da81ce8cce1ce", "ext": "rs", "lang": "Rust", "content": "fn with_nothing() {\n        let words = vec![];\n        let map = abbrev(&words);\n\n        assert!(map.is_empty());\n    }", "item_id": 1, "repo": "arniu/abbrev-rs", "file": "src/lib.rs", "last_update_at": "2020-01-29T15:53:32+00:00", "question_id": "317cff68db696221fd9b33fbc79da81ce8cce1ce_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn with_nothing() {\n        let words = vec![];\n        let map = abbrev(&words);\n        assert!(map.is_empty());\n"]], "pred": {"ppl": 5.69602632522583, "ppl_lower": 5.69602632522583, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01812259162294758, "Min_5.0% Prob": 10.087142944335938, "Min_10.0% Prob": 9.40163485209147, "Min_20.0% Prob": 7.567315714699881, "Min_30.0% Prob": 5.3895382339304145, "Min_40.0% Prob": 4.18978439172109, "Min_50.0% Prob": 3.4201731258317043, "Min_60.0% Prob": 2.9793569459156557}}
{"hexsha": "4274fa997a0abddad5fdba435f65220f5aaf14c4", "ext": "rs", "lang": "Rust", "content": "fn f() -> isize {\n    let mut x: isize;\n    while 1 == 1 { x = 10; }\n    return x; //~ ERROR use of possibly uninitialized variable: `x`\n}", "item_id": 0, "repo": "komaeda/rust", "file": "src/test/ui/borrowck/borrowck-while.rs", "last_update_at": "2020-07-23T19:52:51+00:00", "question_id": "4274fa997a0abddad5fdba435f65220f5aaf14c4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn f() -> isize {\n    let mut x: isize;\n    while 1 == 1 { x = 10; }\n    return x; //~ ERROR use of possibly uninitialized variable: `x`\n"]], "pred": {"ppl": 2.734009027481079, "ppl_lower": 3.4850502014160156, "ppl/lowercase_ppl": -1.2413212170690944, "ppl/zlib": 0.008111040646999494, "Min_5.0% Prob": 7.509827136993408, "Min_10.0% Prob": 5.226355981826782, "Min_20.0% Prob": 3.672745382785797, "Min_30.0% Prob": 2.909750779469808, "Min_40.0% Prob": 2.3609716097513833, "Min_50.0% Prob": 1.996978568343016, "Min_60.0% Prob": 1.7000744741770528}}
{"hexsha": "8fd46e8b247a93919db134dc8214aee6fd5d69be", "ext": "rs", "lang": "Rust", "content": "fn from_struct(ast: &syn::DeriveInput, payload: &syn::DataStruct) -> TokenStream {\n    let mut about_prog = String::new();\n    for attr in ast.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {\n        match attr {\n            syn::Meta::NameValue(value) => if value.path.is_ident(\"doc\") {\n                if let syn::Lit::Str(ref text) = value.lit {\n                    about_prog.push_str(&text.value());\n                    about_prog.push_str(\"\\n\");\n                }\n            } else {\n            },\n            _ => (),\n        }\n    }\n\n    about_prog.pop();\n\n    let mut options = Vec::new();\n    let mut arguments = Vec::new();\n\n    options.push(Opt {\n        arg: Argument {\n            field_name: \"_\".to_owned(),\n            name: \"help\".to_owned(),\n            desc: \"Prints this help information\".to_owned(),\n            required: false,\n            is_optional: false,\n            default: None,\n        },\n        short: Some(\"h\".to_owned()),\n        long: \"help\".to_owned(),\n        typ: OptValueType::Help,\n    });\n\n    let mut multi_argument = None;\n\n    for field in payload.fields.iter() {\n        let field_name = field.ident.as_ref().unwrap().to_string();\n        let name = field.ident.as_ref().unwrap().to_string().trim_matches(|ch| !char::is_alphanumeric(ch)).to_owned();\n        let mut desc = String::new();\n        let mut short = None;\n        let mut long = None;\n        let mut required = false;\n\n        let (is_optional, typ) = match field.ty {\n            syn::Type::Path(ref ty) => {\n                let ty = ty.path.segments.last().expect(\"To have at least one segment\");\n\n                if ty.ident == \"Option\" {\n                    let ty = match &ty.arguments {\n                        syn::PathArguments::AngleBracketed(ref args) => match args.args.len() {\n                            0 => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option is without type arguments. Fix it\").to_compile_error().into(),\n                            1 => match args.args.first().unwrap() {\n                                syn::GenericArgument::Type(syn::Type::Path(ty)) => parse_segment(ty.path.segments.last().expect(\"To have at least one segment\")),\n                                _ => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option should have type argument, but got some other shite. Fix it\").to_compile_error().into(),\n                            },\n                            _ => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option has too many type arguments. Fix it\").to_compile_error().into()\n                        },\n                        syn::PathArguments::None => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option is without type arguments. Fix it\").to_compile_error().into(),\n                        syn::PathArguments::Parenthesized(_) => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, you got wrong brackets for your Option . Fix it\").to_compile_error().into(),\n                    };\n\n                    (true, ty)\n                } else {\n                    (false, parse_segment(ty))\n                }\n            },\n            _ => (false, OptValueType::Value),\n        };\n\n        if is_optional && typ == OptValueType::MultiValue {\n            return syn::Error::new_spanned(field, \"Option<Vec<_>> makes no sense. Just use plain Vec<_>\").to_compile_error().into();\n        }\n\n        let mut default = None;\n\n        for attr in field.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {\n            match attr {\n                syn::Meta::NameValue(value) => if value.path.is_ident(\"doc\") {\n                    if let syn::Lit::Str(ref text) = value.lit {\n                        desc.push_str(&text.value());\n                        desc.push_str(\" \");\n                    }\n                },\n                syn::Meta::List(value) => if value.path.is_ident(\"arg\") {\n                    for value_attr in value.nested.iter() {\n                        match value_attr {\n                            syn::NestedMeta::Meta(value_attr) => {\n                                match value_attr {\n                                    syn::Meta::Path(value_attr) => if value_attr.is_ident(\"short\") {\n                                        short = Some(format!(\"{}\", name.chars().next().unwrap()).to_lowercase());\n                                    } else if value_attr.is_ident(\"long\") {\n                                        long = Some(name.to_lowercase());\n                                    } else if value_attr.is_ident(\"default_value\") {\n                                        default = Some(DEFAULT_INIT.to_owned());\n                                    } else if value_attr.is_ident(\"required\") {\n                                        if typ != OptValueType::Bool {\n                                            required = true\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr, INVALID_REQUIRED_BOOL).to_compile_error().into();\n                                        }\n                                    },\n                                    syn::Meta::NameValue(value_attr) => if value_attr.path.is_ident(\"short\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            let value_attr_text = text.value();\n\n                                            if value_attr_text.contains(ARG_INVALID_CHARS) {\n                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();\n                                            }\n\n                                            short = Some(value_attr_text);\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else if value_attr.path.is_ident(\"long\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            let value_attr_text = text.value();\n\n                                            if value_attr_text.contains(ARG_INVALID_CHARS) {\n                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();\n                                            }\n\n                                            long = Some(value_attr_text)\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else if value_attr.path.is_ident(\"default_value\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            default = Some(text.value());\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else {\n                                        return syn::Error::new_spanned(value_attr.path.clone(), UNKNOWN_ARG_ATTR).to_compile_error().into();\n                                    }\n                                    _ => {\n                                    },\n                                }\n                            },\n                            syn::NestedMeta::Lit(_) => (),\n                        }\n                    }\n                },\n                _ => (),\n            }\n        }\n\n        desc.pop();\n\n        if required && default.is_some() {\n            return syn::Error::new_spanned(field.ident.clone(), \"Marked as required, but default value is provided?\").to_compile_error().into();\n        } else if is_optional && default.is_some() {\n            return syn::Error::new_spanned(field.ident.clone(), \"Optional, but default value is provided?\").to_compile_error().into();\n        } else if !required && !is_optional && default.is_none() {\n            default = Some(DEFAULT_INIT.to_owned());\n        }\n\n        if short.is_none() && long.is_none() {\n            if typ == OptValueType::MultiValue {\n                if multi_argument.is_some() {\n                    return syn::Error::new_spanned(field.ident.clone(), \"Second argument collection. There can be only one\").to_compile_error().into();\n                }\n\n                multi_argument = Some(Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                });\n\n            } else {\n                arguments.push(Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                })\n            }\n\n        } else {\n            let long = match long {\n                Some(long) => long,\n                None => name.clone()\n            };\n\n            options.push(Opt {\n                arg: Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                },\n                short,\n                long,\n                typ\n            })\n        }\n    }\n\n    let (impl_gen, type_gen, where_clause) = ast.generics.split_for_impl();\n\n    let help_msg = {\n        use std::io::Write;\n        use tabwriter::TabWriter;\n\n        let mut tw = TabWriter::new(vec![]);\n\n        let _ = write!(tw, \"{}\n\nUSAGE:\", about_prog);\n\n        if !options.is_empty() {\n            let _ = write!(tw, \" [OPTIONS]\");\n        }\n\n        for argument in arguments.iter() {\n            let _ = if argument.required {\n                write!(tw, \" <{}>\", argument.name)\n            } else {\n                write!(tw, \" [{}]\", argument.name)\n            };\n        }\n\n        if let Some(argument) = multi_argument.as_ref() {\n            let _ = if argument.required {\n                write!(tw, \" <{}>...\", argument.name)\n            } else {\n                write!(tw, \" [{}]...\", argument.name)\n            };\n        }\n\n        if !options.is_empty() {\n            let _ = write!(tw, \"\\n\\nOPTIONS:\\n\");\n        }\n\n        for option in options.iter() {\n            let _ = write!(tw, \"\\t\");\n            if let Some(short) = option.short.as_ref() {\n                let _ = write!(tw, \"-{},\", short);\n            }\n            let _ = write!(tw, \"\\t\");\n\n            let _ = write!(tw, \"--{}\", option.long);\n\n            let _ = match option.typ {\n                OptValueType::MultiValue => write!(tw, \" <{}>...\", option.arg.name),\n                OptValueType::Value => write!(tw, \" <{}>\", option.arg.name),\n                _ => Ok(()),\n            };\n\n            let _ = write!(tw, \"\\t{}\\n\", option.arg.desc);\n        }\n\n        if !arguments.is_empty() || multi_argument.is_some() {\n            let _ = write!(tw, \"\\nARGS:\\n\");\n        }\n\n        for argument in arguments.iter() {\n            let _ = if argument.required {\n                writeln!(tw, \"\\t<{}>\\t{}\", argument.name, argument.desc)\n            } else {\n                writeln!(tw, \"\\t[{}]\\t{}\", argument.name, argument.desc)\n            };\n        }\n\n        if let Some(argument) = multi_argument.as_ref() {\n            let _ = writeln!(tw, \"\\t<{}>...\\t{}\", argument.name, argument.desc);\n        }\n\n        let _ = tw.flush();\n\n        String::from_utf8(tw.into_inner().unwrap()).unwrap()\n    };\n\n    use quote::quote;\n\n    let mut result = String::new();\n    let _ = writeln!(result, \"{} {} for {}{} {{\", quote!(impl#impl_gen), PARSER_TRAIT, ast.ident, quote!(#type_gen #where_clause));\n    let _ = writeln!(result, \"{}const HELP: &'static str = \\\"{}\\\";\", TAB, help_msg);\n\n    let _ = writeln!(result, \"{}fn from_args<'a, T: IntoIterator<Item = &'a str>>(_args_: T) -> Result<Self, arg::ParseError<'a>> {{\", TAB);\n\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n\n        let _ = match option.typ {\n            OptValueType::MultiValue => writeln!(result, \"{0}{0}let mut {1} = Vec::new();\", TAB, option.arg.field_name),\n            OptValueType::Bool => writeln!(result, \"{0}{0}let mut {1} = false;\", TAB, option.arg.field_name),\n            _ => writeln!(result, \"{0}{0}let mut {1} = None;\", TAB, option.arg.field_name),\n        };\n    }\n\n    for argument in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}let mut {1} = None;\", TAB, argument.field_name);\n    }\n\n    if let Some(argument) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}let mut {1} = Vec::new();\", TAB, argument.field_name);\n    }\n\n    let _ = writeln!(result, \"{0}{0}let mut _args_ = _args_.into_iter();\\n\", TAB);\n    let _ = writeln!(result, \"{0}{0}while let Some(_arg_) = _args_.next() {{\", TAB);\n\n    //options\n    let _ = writeln!(result, \"{0}{0}{0}if let Some(_arg_) = _arg_.strip_prefix('-') {{\", TAB);\n    let _ = writeln!(result, \"{0}{0}{0}{0}match _arg_ {{\", TAB);\n    let _ = writeln!(result, \"{0}{0}{0}{0}{0}\\\"h\\\" | \\\"-help\\\" => return Err(arg::ParseError::HelpRequested(Self::HELP)),\", TAB);\n\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n\n        let _ = write!(result, \"{0}{0}{0}{0}{0}\", TAB);\n\n        if let Some(short) = option.short.as_ref() {\n            let _ = write!(result, \"\\\"{}\\\" | \", short);\n        }\n\n        let _ = write!(result, \"\\\"-{}\\\" => \", option.long);\n\n        let _ = match option.typ {\n            OptValueType::Help => panic!(\"Option Help is invalid here. Bug report it\"),\n            OptValueType::Bool => write!(result, \"{0} = !{0},\", option.arg.field_name),\n            OptValueType::Value => write!(result, \"match _args_.next() {{\n{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{\n{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2} = Some(value),\n{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\\\"{3}\\\", _next_arg_)),\n{0}{0}{0}{0}{0}{0}}},\n{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\\\"{3}\\\")),\n{0}{0}{0}{0}{0}}}\", TAB, FROM_FN, option.arg.field_name, option.arg.name),\n            OptValueType::MultiValue => write!(result, \"match _args_.next() {{\n{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{\n{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2}.push(value),\n{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\\\"{3}\\\", _next_arg_)),\n{0}{0}{0}{0}{0}{0}}},\n{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\\\"{3}\\\")),\n{0}{0}{0}{0}{0}}}\", TAB, FROM_FN, option.arg.field_name, option.arg.name),\n        };\n        let _ = writeln!(result, \"\");\n    }\n    let _ = writeln!(result, \"{0}{0}{0}{0}{0}_ => return Err(arg::ParseError::UnknownFlag(_arg_)),\", TAB);\n\n    let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    //rest args\n    for arg in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}{0}}} else if {1}.is_none() {{\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}match {1}(_arg_) {{\", TAB, FROM_FN);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Ok(_res_) => {1} = Some(_res_),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\\\"{1}\\\", _arg_)),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    }\n    //too many args?\n    let _ = writeln!(result, \"{0}{0}{0}}} else {{\", TAB);\n\n    if let Some(arg) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}{0}{0}match {1}(_arg_) {{\", TAB, FROM_FN);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Ok(_res_) => {1}.push(_res_),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\\\"{1}\\\", _arg_)),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    } else {\n        let _ = writeln!(result, \"{0}{0}{0}{0} return Err(arg::ParseError::TooManyArgs);\", TAB);\n    }\n    let _ = writeln!(result, \"{0}{0}{0}}}\", TAB);\n    //exit args\n\n    let _ = writeln!(result, \"{0}{0}}}\", TAB);\n\n    //Set defaults\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n\n        let _ = match option.typ {\n            OptValueType::MultiValue => Ok(()),\n            OptValueType::Bool => Ok(()),\n            _ => match option.arg.default {\n                Some(ref default) => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};\", TAB, option.arg.field_name, default),\n                None => match option.arg.is_optional {\n                    true => Ok(()),\n                    false => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\\\"{2}\\\")) }};\", TAB, option.arg.field_name, option.arg.name),\n                },\n            },\n        };\n    }\n\n    for arg in arguments.iter() {\n        let _ = match arg.default {\n            Some(ref default) => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};\", TAB, arg.field_name, default),\n            None => match arg.is_optional {\n                true => Ok(()),\n                false => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\\\"{2}\\\")) }};\", TAB, arg.field_name, arg.name),\n            }\n        };\n    }\n\n    //Fill result\n    let _ = writeln!(result, \"{0}{0}Ok(Self {{\", TAB);\n\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n\n        let _ = if option.arg.is_optional && option.typ == OptValueType::Bool {\n            writeln!(result, \"{0}{0}{0}{1}: Some({1}),\", TAB, option.arg.field_name)\n        } else {\n            writeln!(result, \"{0}{0}{0}{1},\", TAB, option.arg.field_name)\n        };\n    }\n\n    for arg in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}{0}{1},\", TAB, arg.field_name);\n    }\n\n    if let Some(arg) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}{0}{1},\", TAB, arg.field_name);\n    }\n\n    let _ = writeln!(result, \"{0}{0}}})\", TAB);\n\n    //Exit fn\n    let _ = writeln!(result, \"{}}}\", TAB);\n\n    let _ = writeln!(result, \"}}\");\n\n    result.parse().expect(\"To parse generated code\")\n}", "item_id": 0, "repo": "DoumanAsh/arg.rs", "file": "arg-derive/src/lib.rs", "last_update_at": "2020-09-16T22:59:02+00:00", "question_id": "8fd46e8b247a93919db134dc8214aee6fd5d69be_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_struct(ast: &syn::DeriveInput, payload: &syn::DataStruct) -> TokenStream {\n    let mut about_prog = String::new();\n    for attr in ast.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {\n        match attr {\n            syn::Meta::NameValue(value) => if value.path.is_ident(\"doc\") {\n                if let syn::Lit::Str(ref text) = value.lit {\n                    about_prog.push_str(&text.value());\n                    about_prog.push_str(\"\\n\");\n                }\n            } else {\n            },\n            _ => (),\n        }\n    }\n    about_prog.pop();\n    let mut options = Vec::new();\n    let mut arguments = Vec::new();\n    options.push(Opt {\n        arg: Argument {\n            field_name: \"_\".to_owned(),\n            name: \"help\".to_owned(),\n            desc: \"Prints this help information\".to_owned(),\n            required: false,\n            is_optional: false,\n            default: None,\n        },\n        short: Some(\"h\".to_owned()),\n        long: \"help\".to_owned(),\n        typ: OptValueType::Help,\n    });\n    let mut multi_argument = None;\n    for field in payload.fields.iter() {\n        let field_name = field.ident.as_ref().unwrap().to_string();\n        let name = field.ident.as_ref().unwrap().to_string().trim_matches(|ch| !char::is_alphanumeric(ch)).to_owned();\n        let mut desc = String::new();\n        let mut short = None;\n        let mut long = None;\n        let mut required = false;\n        let (is_optional, typ) = match field.ty {\n            syn::Type::Path(ref ty) => {\n                let ty = ty.path.segments.last().expect(\"To have at least one segment\");\n                if ty.ident == \"Option\" {\n                    let ty = match &ty.arguments {\n                        syn::PathArguments::AngleBracketed(ref args) => match args.args.len() {\n                            0 => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option is without type arguments. Fix it\").to_compile_error().into(),\n                            1 => match args.args.first().unwrap() {\n                                syn::GenericArgument::Type(syn::Type::Path(ty)) => parse_segment(ty.path.segments.last().expect(\"To have at least one segment\")),\n                                _ => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option should have type argument, but got some other shite. Fix it\").to_compile_error().into(),\n                            },\n                            _ => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option has too many type arguments. Fix it\").to_compile_error().into()\n                        },\n                        syn::PathArguments::None => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, Option is without type arguments. Fix it\").to_compile_error().into(),\n                        syn::PathArguments::Parenthesized(_) => return syn::Error::new_spanned(&ty.ident, \"Oi, mate, you got wrong brackets for your Option . Fix it\").to_compile_error().into(),\n                    };\n                    (true, ty)\n                } else {\n                    (false, parse_segment(ty))\n                }\n            },\n            _ => (false, OptValueType::Value),\n        };\n        if is_optional && typ == OptValueType::MultiValue {\n            return syn::Error::new_spanned(field, \"Option<Vec<_>> makes no sense. Just use plain Vec<_>\").to_compile_error().into();\n        }\n        let mut default = None;\n        for attr in field.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {\n            match attr {\n                syn::Meta::NameValue(value) => if value.path.is_ident(\"doc\") {\n                    if let syn::Lit::Str(ref text) = value.lit {\n                        desc.push_str(&text.value());\n                        desc.push_str(\" \");\n                    }\n                },\n                syn::Meta::List(value) => if value.path.is_ident(\"arg\") {\n                    for value_attr in value.nested.iter() {\n                        match value_attr {\n                            syn::NestedMeta::Meta(value_attr) => {\n                                match value_attr {\n                                    syn::Meta::Path(value_attr) => if value_attr.is_ident(\"short\") {\n                                        short = Some(format!(\"{}\", name.chars().next().unwrap()).to_lowercase());\n                                    } else if value_attr.is_ident(\"long\") {\n                                        long = Some(name.to_lowercase());\n                                    } else if value_attr.is_ident(\"default_value\") {\n                                        default = Some(DEFAULT_INIT.to_owned());\n                                    } else if value_attr.is_ident(\"required\") {\n                                        if typ != OptValueType::Bool {\n                                            required = true\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr, INVALID_REQUIRED_BOOL).to_compile_error().into();\n                                        }\n                                    },\n                                    syn::Meta::NameValue(value_attr) => if value_attr.path.is_ident(\"short\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            let value_attr_text = text.value();\n                                            if value_attr_text.contains(ARG_INVALID_CHARS) {\n                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();\n                                            }\n                                            short = Some(value_attr_text);\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else if value_attr.path.is_ident(\"long\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            let value_attr_text = text.value();\n                                            if value_attr_text.contains(ARG_INVALID_CHARS) {\n                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();\n                                            }\n                                            long = Some(value_attr_text)\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else if value_attr.path.is_ident(\"default_value\") {\n                                        if let syn::Lit::Str(ref text) = value_attr.lit {\n                                            default = Some(text.value());\n                                        } else {\n                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();\n                                        }\n                                    } else {\n                                        return syn::Error::new_spanned(value_attr.path.clone(), UNKNOWN_ARG_ATTR).to_compile_error().into();\n                                    }\n                                    _ => {\n                                    },\n                                }\n                            },\n                            syn::NestedMeta::Lit(_) => (),\n                        }\n                    }\n                },\n                _ => (),\n            }\n        }\n        desc.pop();\n        if required && default.is_some() {\n            return syn::Error::new_spanned(field.ident.clone(), \"Marked as required, but default value is provided?\").to_compile_error().into();\n        } else if is_optional && default.is_some() {\n            return syn::Error::new_spanned(field.ident.clone(), \"Optional, but default value is provided?\").to_compile_error().into();\n        } else if !required && !is_optional && default.is_none() {\n            default = Some(DEFAULT_INIT.to_owned());\n        }\n        if short.is_none() && long.is_none() {\n            if typ == OptValueType::MultiValue {\n                if multi_argument.is_some() {\n                    return syn::Error::new_spanned(field.ident.clone(), \"Second argument collection. There can be only one\").to_compile_error().into();\n                }\n                multi_argument = Some(Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                });\n            } else {\n                arguments.push(Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                })\n            }\n        } else {\n            let long = match long {\n                Some(long) => long,\n                None => name.clone()\n            };\n            options.push(Opt {\n                arg: Argument {\n                    field_name,\n                    name,\n                    desc,\n                    required,\n                    is_optional,\n                    default,\n                },\n                short,\n                long,\n                typ\n            })\n        }\n    }\n    let (impl_gen, type_gen, where_clause) = ast.generics.split_for_impl();\n    let help_msg = {\n        use std::io::Write;\n        use tabwriter::TabWriter;\n        let mut tw = TabWriter::new(vec![]);\n        let _ = write!(tw, \"{}\nUSAGE:\", about_prog);\n        if !options.is_empty() {\n            let _ = write!(tw, \" [OPTIONS]\");\n        }\n        for argument in arguments.iter() {\n            let _ = if argument.required {\n                write!(tw, \" <{}>\", argument.name)\n            } else {\n                write!(tw, \" [{}]\", argument.name)\n            };\n        }\n        if let Some(argument) = multi_argument.as_ref() {\n            let _ = if argument.required {\n                write!(tw, \" <{}>...\", argument.name)\n            } else {\n                write!(tw, \" [{}]...\", argument.name)\n            };\n        }\n        if !options.is_empty() {\n            let _ = write!(tw, \"\\n\\nOPTIONS:\\n\");\n        }\n        for option in options.iter() {\n            let _ = write!(tw, \"\\t\");\n            if let Some(short) = option.short.as_ref() {\n                let _ = write!(tw, \"-{},\", short);\n            }\n            let _ = write!(tw, \"\\t\");\n            let _ = write!(tw, \"--{}\", option.long);\n            let _ = match option.typ {\n                OptValueType::MultiValue => write!(tw, \" <{}>...\", option.arg.name),\n                OptValueType::Value => write!(tw, \" <{}>\", option.arg.name),\n                _ => Ok(()),\n            };\n            let _ = write!(tw, \"\\t{}\\n\", option.arg.desc);\n        }\n        if !arguments.is_empty() || multi_argument.is_some() {\n            let _ = write!(tw, \"\\nARGS:\\n\");\n        }\n        for argument in arguments.iter() {\n            let _ = if argument.required {\n                writeln!(tw, \"\\t<{}>\\t{}\", argument.name, argument.desc)\n            } else {\n                writeln!(tw, \"\\t[{}]\\t{}\", argument.name, argument.desc)\n            };\n        }\n        if let Some(argument) = multi_argument.as_ref() {\n            let _ = writeln!(tw, \"\\t<{}>...\\t{}\", argument.name, argument.desc);\n        }\n        let _ = tw.flush();\n        String::from_utf8(tw.into_inner().unwrap()).unwrap()\n    };\n    use quote::quote;\n    let mut result = String::new();\n    let _ = writeln!(result, \"{} {} for {}{} {{\", quote!(impl#impl_gen), PARSER_TRAIT, ast.ident, quote!(#type_gen #where_clause));\n    let _ = writeln!(result, \"{}const HELP: &'static str = \\\"{}\\\";\", TAB, help_msg);\n    let _ = writeln!(result, \"{}fn from_args<'a, T: IntoIterator<Item = &'a str>>(_args_: T) -> Result<Self, arg::ParseError<'a>> {{\", TAB);\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n        let _ = match option.typ {\n            OptValueType::MultiValue => writeln!(result, \"{0}{0}let mut {1} = Vec::new();\", TAB, option.arg.field_name),\n            OptValueType::Bool => writeln!(result, \"{0}{0}let mut {1} = false;\", TAB, option.arg.field_name),\n            _ => writeln!(result, \"{0}{0}let mut {1} = None;\", TAB, option.arg.field_name),\n        };\n    }\n    for argument in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}let mut {1} = None;\", TAB, argument.field_name);\n    }\n    if let Some(argument) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}let mut {1} = Vec::new();\", TAB, argument.field_name);\n    }\n    let _ = writeln!(result, \"{0}{0}let mut _args_ = _args_.into_iter();\\n\", TAB);\n    let _ = writeln!(result, \"{0}{0}while let Some(_arg_) = _args_.next() {{\", TAB);\n    //options\n    let _ = writeln!(result, \"{0}{0}{0}if let Some(_arg_) = _arg_.strip_prefix('-') {{\", TAB);\n    let _ = writeln!(result, \"{0}{0}{0}{0}match _arg_ {{\", TAB);\n    let _ = writeln!(result, \"{0}{0}{0}{0}{0}\\\"h\\\" | \\\"-help\\\" => return Err(arg::ParseError::HelpRequested(Self::HELP)),\", TAB);\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n        let _ = write!(result, \"{0}{0}{0}{0}{0}\", TAB);\n        if let Some(short) = option.short.as_ref() {\n            let _ = write!(result, \"\\\"{}\\\" | \", short);\n        }\n        let _ = write!(result, \"\\\"-{}\\\" => \", option.long);\n        let _ = match option.typ {\n            OptValueType::Help => panic!(\"Option Help is invalid here. Bug report it\"),\n            OptValueType::Bool => write!(result, \"{0} = !{0},\", option.arg.field_name),\n            OptValueType::Value => write!(result, \"match _args_.next() {{\n{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{\n{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2} = Some(value),\n{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\\\"{3}\\\", _next_arg_)),\n{0}{0}{0}{0}{0}{0}}},\n{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\\\"{3}\\\")),\n{0}{0}{0}{0}{0}}}\", TAB, FROM_FN, option.arg.field_name, option.arg.name),\n            OptValueType::MultiValue => write!(result, \"match _args_.next() {{\n{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{\n{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2}.push(value),\n{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\\\"{3}\\\", _next_arg_)),\n{0}{0}{0}{0}{0}{0}}},\n{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\\\"{3}\\\")),\n{0}{0}{0}{0}{0}}}\", TAB, FROM_FN, option.arg.field_name, option.arg.name),\n        };\n        let _ = writeln!(result, \"\");\n    }\n    let _ = writeln!(result, \"{0}{0}{0}{0}{0}_ => return Err(arg::ParseError::UnknownFlag(_arg_)),\", TAB);\n    let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    //rest args\n    for arg in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}{0}}} else if {1}.is_none() {{\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}match {1}(_arg_) {{\", TAB, FROM_FN);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Ok(_res_) => {1} = Some(_res_),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\\\"{1}\\\", _arg_)),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    }\n    //too many args?\n    let _ = writeln!(result, \"{0}{0}{0}}} else {{\", TAB);\n    if let Some(arg) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}{0}{0}match {1}(_arg_) {{\", TAB, FROM_FN);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Ok(_res_) => {1}.push(_res_),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\\\"{1}\\\", _arg_)),\", TAB, arg.field_name);\n        let _ = writeln!(result, \"{0}{0}{0}{0}}}\", TAB);\n    } else {\n        let _ = writeln!(result, \"{0}{0}{0}{0} return Err(arg::ParseError::TooManyArgs);\", TAB);\n    }\n    let _ = writeln!(result, \"{0}{0}{0}}}\", TAB);\n    //exit args\n    let _ = writeln!(result, \"{0}{0}}}\", TAB);\n    //Set defaults\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n        let _ = match option.typ {\n            OptValueType::MultiValue => Ok(()),\n            OptValueType::Bool => Ok(()),\n            _ => match option.arg.default {\n                Some(ref default) => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};\", TAB, option.arg.field_name, default),\n                None => match option.arg.is_optional {\n                    true => Ok(()),\n                    false => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\\\"{2}\\\")) }};\", TAB, option.arg.field_name, option.arg.name),\n                },\n            },\n        };\n    }\n    for arg in arguments.iter() {\n        let _ = match arg.default {\n            Some(ref default) => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};\", TAB, arg.field_name, default),\n            None => match arg.is_optional {\n                true => Ok(()),\n                false => writeln!(result, \"{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\\\"{2}\\\")) }};\", TAB, arg.field_name, arg.name),\n            }\n        };\n    }\n    //Fill result\n    let _ = writeln!(result, \"{0}{0}Ok(Self {{\", TAB);\n    for option in options.iter() {\n        if option.arg.field_name == \"_\" {\n            continue;\n        }\n        let _ = if option.arg.is_optional && option.typ == OptValueType::Bool {\n            writeln!(result, \"{0}{0}{0}{1}: Some({1}),\", TAB, option.arg.field_name)\n        } else {\n            writeln!(result, \"{0}{0}{0}{1},\", TAB, option.arg.field_name)\n        };\n    }\n    for arg in arguments.iter() {\n        let _ = writeln!(result, \"{0}{0}{0}{1},\", TAB, arg.field_name);\n    }\n    if let Some(arg) = multi_argument.as_ref() {\n        let _ = writeln!(result, \"{0}{0}{0}{1},\", TAB, arg.field_name);\n    }\n    let _ = writeln!(result, \"{0}{0}}})\", TAB);\n    //Exit fn\n    let _ = writeln!(result, \"{}}}\", TAB);\n    let _ = writeln!(result, \"}}\");\n    result.parse().expect(\"To parse generated code\")\n"]], "pred": {"ppl": 1.853274941444397, "ppl_lower": 2.1249005794525146, "ppl/lowercase_ppl": -1.2216869217817965, "ppl/zlib": 0.00018280127783204447, "Min_5.0% Prob": 5.865245290831024, "Min_10.0% Prob": 4.367797635349572, "Min_20.0% Prob": 2.804494716665324, "Min_30.0% Prob": 2.001204186259142, "Min_40.0% Prob": 1.5301280012923524, "Min_50.0% Prob": 1.2318103323980378, "Min_60.0% Prob": 1.0287362480426714}}
{"hexsha": "e6354108f1a5237cf4e7de0edc49ee39e922dbb1", "ext": "rs", "lang": "Rust", "content": "pub fn get_source_walker(config: &Config) -> impl Iterator<Item = DirEntry> {\n    let root = config.root();\n    let target = config.target_dir();\n\n    let walker = WalkDir::new(&root).into_iter();\n    walker\n        .filter_entry(move |e| is_coverable_file_path(e.path(), &root, &target))\n        .filter_map(|e| e.ok())\n        .filter(|e| is_source_file(e))\n}", "item_id": 0, "repo": "sameer/tarpaulin", "file": "src/path_utils.rs", "last_update_at": "2020-06-22T22:52:54+00:00", "question_id": "e6354108f1a5237cf4e7de0edc49ee39e922dbb1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_source_walker(config: &Config) -> impl Iterator<Item = DirEntry> {\n    let root = config.root();\n    let target = config.target_dir();\n    let walker = WalkDir::new(&root).into_iter();\n    walker\n        .filter_entry(move |e| is_coverable_file_path(e.path(), &root, &target))\n        .filter_map(|e| e.ok())\n        .filter(|e| is_source_file(e))\n"]], "pred": {"ppl": 2.8659355640411377, "ppl_lower": 3.971928596496582, "ppl/lowercase_ppl": -1.3099615542822185, "ppl/zlib": 0.004920069375068174, "Min_5.0% Prob": 8.088246981302897, "Min_10.0% Prob": 6.0998315413792925, "Min_20.0% Prob": 4.023590636253357, "Min_30.0% Prob": 3.047866535814185, "Min_40.0% Prob": 2.4736185657978056, "Min_50.0% Prob": 2.0488049246016002, "Min_60.0% Prob": 1.7346756948452247}}
{"hexsha": "9fd5c913b01e8b859e8b16479ad5cd8468e515ea", "ext": "rs", "lang": "Rust", "content": "fn read_array<R: io::Read, A: Array<Item = Self>>(\n        state: State<Bytes>,\n        ty: u16,\n        arr: &mut A,\n        r: &mut R\n    ) -> io::Result<()> {\n        use std::usize;\n\n        let self_ty = <Self as Scalar>::ty();\n        if let Some((ty, rows, cols)) = Type::info(ty) {\n            if ty == self_ty && rows == 1 && cols == 1 {\n                let mut bytes = 0;\n                let state = state.read_bytes(&mut bytes, r)?;\n                let (_, scalar_bytes) = self_ty.scalar();\n                if bytes % scalar_bytes == 0 {\n                    let n = bytes / scalar_bytes;\n                    let mut offset = 0;\n                    let state = state.read_offset_instance_id(&mut offset, r)?;\n                    for i in offset..(offset + n) {\n                        if i > usize::MAX as u64 {\n                            return Err(io::ErrorKind::Other.into());\n                        }\n                        while i as usize >= arr.len() {\n                            arr.push(Default::default());\n                        }\n                        let mut scalar: Self = Default::default();\n                        scalar.read(r)?;\n                        arr.set(i as usize, scalar);\n                    }\n                    state.end_data().has_end_bytes(r)?;\n                    return Ok(())\n                }\n            }\n        }\n        return Err(io::ErrorKind::InvalidData.into())\n    }", "item_id": 11, "repo": "PistonDevelopers/binpool", "file": "src/read_write.rs", "last_update_at": "2020-03-05T19:02:52+00:00", "question_id": "9fd5c913b01e8b859e8b16479ad5cd8468e515ea_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_array<R: io::Read, A: Array<Item = Self>>(\n        state: State<Bytes>,\n        ty: u16,\n        arr: &mut A,\n        r: &mut R\n    ) -> io::Result<()> {\n        use std::usize;\n        let self_ty = <Self as Scalar>::ty();\n        if let Some((ty, rows, cols)) = Type::info(ty) {\n            if ty == self_ty && rows == 1 && cols == 1 {\n                let mut bytes = 0;\n                let state = state.read_bytes(&mut bytes, r)?;\n                let (_, scalar_bytes) = self_ty.scalar();\n                if bytes % scalar_bytes == 0 {\n                    let n = bytes / scalar_bytes;\n                    let mut offset = 0;\n                    let state = state.read_offset_instance_id(&mut offset, r)?;\n                    for i in offset..(offset + n) {\n                        if i > usize::MAX as u64 {\n                            return Err(io::ErrorKind::Other.into());\n                        }\n                        while i as usize >= arr.len() {\n                            arr.push(Default::default());\n                        }\n                        let mut scalar: Self = Default::default();\n                        scalar.read(r)?;\n                        arr.set(i as usize, scalar);\n                    }\n                    state.end_data().has_end_bytes(r)?;\n                    return Ok(())\n                }\n            }\n        }\n        return Err(io::ErrorKind::InvalidData.into())\n"]], "pred": {"ppl": 2.6788318157196045, "ppl_lower": 3.4151527881622314, "ppl/lowercase_ppl": -1.2464442376693157, "ppl/zlib": 0.001917083287623326, "Min_5.0% Prob": 7.09225785104852, "Min_10.0% Prob": 5.697178852863801, "Min_20.0% Prob": 4.088071696365936, "Min_30.0% Prob": 3.0753883800264132, "Min_40.0% Prob": 2.4014748503701595, "Min_50.0% Prob": 1.9585218772216497, "Min_60.0% Prob": 1.6382680199883155}}
{"hexsha": "97a8d2fc760a0e13a678d47172bf2d9ebf3dc0d6", "ext": "rs", "lang": "Rust", "content": "fn debug_impl() {\n    #[id]\n    struct FooId(String);\n\n    static_assertions::assert_impl_all!(FooId: Debug);\n}", "item_id": 0, "repo": "vbfox/stidgen.rs", "file": "stidgen/tests/debug.rs", "last_update_at": "2020-09-13T09:31:48+00:00", "question_id": "97a8d2fc760a0e13a678d47172bf2d9ebf3dc0d6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn debug_impl() {\n    #[id]\n    struct FooId(String);\n    static_assertions::assert_impl_all!(FooId: Debug);\n"]], "pred": {"ppl": 5.992804050445557, "ppl_lower": 10.18321704864502, "ppl/lowercase_ppl": -1.296098272955415, "ppl/zlib": 0.018651660672256556, "Min_5.0% Prob": 9.476152420043945, "Min_10.0% Prob": 8.379899978637695, "Min_20.0% Prob": 6.520029187202454, "Min_30.0% Prob": 5.169884741306305, "Min_40.0% Prob": 4.19259549677372, "Min_50.0% Prob": 3.4876951456069945, "Min_60.0% Prob": 2.9599977396428585}}
{"hexsha": "195874657dd67acbd631d23ffc9598c6fe2849d8", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), scalgoproto::Error> {\n    let mut args = std::env::args();\n    args.next();\n    let test = args.next().expect(\"Missing test\");\n    let file = args.next().expect(\"Missig file\");\n\n    match test.as_str() {\n        \"out_default\" => test_out_default(&file)?,\n        \"in_default\" => test_in_default(&file)?,\n        \"out\" => test_out(&file)?,\n        \"in\" => test_in(&file)?,\n        \"out_complex\" => test_out_complex(&file)?,\n        \"in_complex\" => test_in_complex(&file)?,\n        \"in_complex3\" => test_in_complex3(&file)?,\n        \"out_complex2\" => test_out_complex2(&file)?,\n        \"in_complex2\" => test_in_complex2(&file)?,\n        \"out_inplace\" => test_out_inplace(&file)?,\n        \"in_inplace\" => test_in_inplace(&file)?,\n        \"out_extend1\" => test_out_extend1(&file)?,\n        \"in_extend1\" => test_in_extend1(&file)?,\n        \"out_extend2\" => test_out_extend2(&file)?,\n        \"in_extend2\" => test_in_extend2(&file)?,\n        \"out_union\" => test_out_union(&file)?,\n        \"in_union\" => test_in_union(&file)?,\n        _ => {\n            panic!(\"Unknown test\");\n        }\n    }\n\n    Ok(())\n}", "item_id": 18, "repo": "Mortal/scalgoproto", "file": "test/test_all.rs", "last_update_at": "2020-04-14T03:31:06+00:00", "question_id": "195874657dd67acbd631d23ffc9598c6fe2849d8_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), scalgoproto::Error> {\n    let mut args = std::env::args();\n    args.next();\n    let test = args.next().expect(\"Missing test\");\n    let file = args.next().expect(\"Missig file\");\n    match test.as_str() {\n        \"out_default\" => test_out_default(&file)?,\n        \"in_default\" => test_in_default(&file)?,\n        \"out\" => test_out(&file)?,\n        \"in\" => test_in(&file)?,\n        \"out_complex\" => test_out_complex(&file)?,\n        \"in_complex\" => test_in_complex(&file)?,\n        \"in_complex3\" => test_in_complex3(&file)?,\n        \"out_complex2\" => test_out_complex2(&file)?,\n        \"in_complex2\" => test_in_complex2(&file)?,\n        \"out_inplace\" => test_out_inplace(&file)?,\n        \"in_inplace\" => test_in_inplace(&file)?,\n        \"out_extend1\" => test_out_extend1(&file)?,\n        \"in_extend1\" => test_in_extend1(&file)?,\n        \"out_extend2\" => test_out_extend2(&file)?,\n        \"in_extend2\" => test_in_extend2(&file)?,\n        \"out_union\" => test_out_union(&file)?,\n        \"in_union\" => test_in_union(&file)?,\n        _ => {\n            panic!(\"Unknown test\");\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.578118920326233, "ppl_lower": 1.6460511684417725, "ppl/lowercase_ppl": -1.0923772581780047, "ppl/zlib": 0.0014081283364432758, "Min_5.0% Prob": 6.499908423423767, "Min_10.0% Prob": 4.067931248247623, "Min_20.0% Prob": 2.235697563737631, "Min_30.0% Prob": 1.5132531098245332, "Min_40.0% Prob": 1.138550824119011, "Min_50.0% Prob": 0.9118806528951973, "Min_60.0% Prob": 0.760193871302666}}
{"hexsha": "da3b95d8d95994b47c73597b093d8bfa4dd07519", "ext": "rs", "lang": "Rust", "content": "pub async fn get_collection() -> Result<(Collection, bool), UserError> {\n    let config: ConfVars = match get_conf_vars() {\n        Ok(config) => config,\n        _ => {\n            println!(\"Impossible to see this, if you are here something is seriously wrong with this code...\");\n            return Err(UserError {\n                error_type: UserErrorType::InternalError,\n                cause: None,\n                message: Some(\n                    \"No clue what you did to get here... :) | pls contact me...\".to_string(),\n                ),\n            });\n        }\n    };\n    let client = Client::with_uri_str(\n        &format!(\n            \"mongodb+srv://{}:{}@{}/{}?retryWrites=true&w=majority\",\n            config.db_user, config.db_password, config.db_server, config.db_database\n        )[..],\n    )\n    .await?;\n    let database: Database = client.database(\"atw\");\n    let connected: bool;\n    match database.run_command(doc! {\"ping\": 1}, None).await {\n        Ok(_x) => {\n            println!(\"Connected successfully to database ...\");\n            connected = true;\n        }\n        _ => {\n            println!(\"Could not establish connection to database, please check credentials and try again\");\n            connected = false;\n        }\n    }\n    let collection: Collection = database.collection(\"questions\");\n    return Ok((collection, connected));\n}", "item_id": 0, "repo": "Ask-The-World/atw-api", "file": "src/db.rs", "last_update_at": "2020-12-02T20:31:44+00:00", "question_id": "da3b95d8d95994b47c73597b093d8bfa4dd07519_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get_collection() -> Result<(Collection, bool), UserError> {\n    let config: ConfVars = match get_conf_vars() {\n        Ok(config) => config,\n        _ => {\n            println!(\"Impossible to see this, if you are here something is seriously wrong with this code...\");\n            return Err(UserError {\n                error_type: UserErrorType::InternalError,\n                cause: None,\n                message: Some(\n                    \"No clue what you did to get here... :) | pls contact me...\".to_string(),\n                ),\n            });\n        }\n    };\n    let client = Client::with_uri_str(\n        &format!(\n            \"mongodb+srv://{}:{}@{}/{}?retryWrites=true&w=majority\",\n            config.db_user, config.db_password, config.db_server, config.db_database\n        )[..],\n    )\n    .await?;\n    let database: Database = client.database(\"atw\");\n    let connected: bool;\n    match database.run_command(doc! {\"ping\": 1}, None).await {\n        Ok(_x) => {\n            println!(\"Connected successfully to database ...\");\n            connected = true;\n        }\n        _ => {\n            println!(\"Could not establish connection to database, please check credentials and try again\");\n            connected = false;\n        }\n    }\n    let collection: Collection = database.collection(\"questions\");\n    return Ok((collection, connected));\n"]], "pred": {"ppl": 2.8214149475097656, "ppl_lower": 3.412116527557373, "ppl/lowercase_ppl": -1.1832695809952765, "ppl/zlib": 0.0016569305328265867, "Min_5.0% Prob": 8.00468641168931, "Min_10.0% Prob": 6.023473126547677, "Min_20.0% Prob": 4.204402238550321, "Min_30.0% Prob": 3.1967421959493763, "Min_40.0% Prob": 2.5311673752494626, "Min_50.0% Prob": 2.0554410248745087, "Min_60.0% Prob": 1.729877076277109}}
{"hexsha": "3bfdcd49f9728d45b839c3c9bfffd7ac8fc962e9", "ext": "rs", "lang": "Rust", "content": "pub fn rotation_y(radians: f64) -> Matrix4 {\n    let mut new_mat = Matrix4::identity();\n    new_mat[0][0] = Float(radians.cos());\n    new_mat[0][2] = Float(radians.sin());\n    new_mat[2][0] = Float(-radians.sin());\n    new_mat[2][2] = Float(radians.cos());\n    new_mat\n}", "item_id": 3, "repo": "po-gl/Raytracer", "file": "src/transformation.rs", "last_update_at": "2020-01-07T06:40:05+00:00", "question_id": "3bfdcd49f9728d45b839c3c9bfffd7ac8fc962e9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn rotation_y(radians: f64) -> Matrix4 {\n    let mut new_mat = Matrix4::identity();\n    new_mat[0][0] = Float(radians.cos());\n    new_mat[0][2] = Float(radians.sin());\n    new_mat[2][0] = Float(-radians.sin());\n    new_mat[2][2] = Float(radians.cos());\n    new_mat\n"]], "pred": {"ppl": 1.9691450595855713, "ppl_lower": 2.186223030090332, "ppl/lowercase_ppl": -1.1543329759171086, "ppl/zlib": 0.0050567124525937495, "Min_5.0% Prob": 8.748192310333252, "Min_10.0% Prob": 5.688583660125732, "Min_20.0% Prob": 3.237977677867526, "Min_30.0% Prob": 2.2665165192447603, "Min_40.0% Prob": 1.7116706281207328, "Min_50.0% Prob": 1.3667231801966275, "Min_60.0% Prob": 1.1360517131684063}}
{"hexsha": "9d224e9aad3ff84318a5246cad46fd1bd91914d9", "ext": "rs", "lang": "Rust", "content": "fn test_raw_annotation_aligned() {\n    let dl = DisplayList::from(vec![DisplayLine::Raw(DisplayRawLine::Annotation {\n        annotation: Annotation {\n            annotation_type: DisplayAnnotationType::Error,\n            id: Some(\"E0001\".to_string()),\n            label: vec![DisplayTextFragment {\n                content: String::from(\"This is an error\"),\n                style: DisplayTextStyle::Regular,\n            }],\n        },\n        source_aligned: true,\n        continuation: false,\n    })]);\n\n    let dlf = DisplayListFormatter::new(false, false);\n\n    assert_eq!(dlf.format(&dl), \" = error[E0001]: This is an error\");\n}", "item_id": 11, "repo": "oli-cosmian/annotate-snippets-rs", "file": "tests/formatter.rs", "last_update_at": "2020-04-07T21:55:56+00:00", "question_id": "9d224e9aad3ff84318a5246cad46fd1bd91914d9_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_raw_annotation_aligned() {\n    let dl = DisplayList::from(vec![DisplayLine::Raw(DisplayRawLine::Annotation {\n        annotation: Annotation {\n            annotation_type: DisplayAnnotationType::Error,\n            id: Some(\"E0001\".to_string()),\n            label: vec![DisplayTextFragment {\n                content: String::from(\"This is an error\"),\n                style: DisplayTextStyle::Regular,\n            }],\n        },\n        source_aligned: true,\n        continuation: false,\n    })]);\n    let dlf = DisplayListFormatter::new(false, false);\n    assert_eq!(dlf.format(&dl), \" = error[E0001]: This is an error\");\n"]], "pred": {"ppl": 3.8281939029693604, "ppl_lower": 5.558298587799072, "ppl/lowercase_ppl": -1.2777866770983313, "ppl/zlib": 0.0043726160461436125, "Min_5.0% Prob": 9.316104710102081, "Min_10.0% Prob": 7.344515996820786, "Min_20.0% Prob": 5.246977785655431, "Min_30.0% Prob": 3.9605474517030537, "Min_40.0% Prob": 3.1699816366316567, "Min_50.0% Prob": 2.6247824350099886, "Min_60.0% Prob": 2.2225943954191476}}
{"hexsha": "1a3e4ca9ab27ca0c6129c9f532c59062007b597d", "ext": "rs", "lang": "Rust", "content": "pub fn initialize(\n    program_id: &Pubkey,\n    token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    token_a_pubkey: &Pubkey,\n    token_b_pubkey: &Pubkey,\n    pool_pubkey: &Pubkey,\n    user_output_pubkey: &Pubkey,\n    fee: Fee,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::Initialize(fee).serialize()?;\n\n    let accounts = vec![\n        AccountMeta::new(*swap_pubkey, true),\n        AccountMeta::new(*authority_pubkey, false),\n        AccountMeta::new(*token_a_pubkey, false),\n        AccountMeta::new(*token_b_pubkey, false),\n        AccountMeta::new(*pool_pubkey, false),\n        AccountMeta::new(*user_output_pubkey, false),\n        AccountMeta::new(*token_program_id, false),\n    ];\n\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n}", "item_id": 0, "repo": "jstarry/solana-program-library", "file": "token-swap/src/lib.rs", "last_update_at": "2020-12-17T16:58:02+00:00", "question_id": "1a3e4ca9ab27ca0c6129c9f532c59062007b597d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn initialize(\n    program_id: &Pubkey,\n    token_program_id: &Pubkey,\n    swap_pubkey: &Pubkey,\n    authority_pubkey: &Pubkey,\n    token_a_pubkey: &Pubkey,\n    token_b_pubkey: &Pubkey,\n    pool_pubkey: &Pubkey,\n    user_output_pubkey: &Pubkey,\n    fee: Fee,\n) -> Result<Instruction, ProgramError> {\n    let data = SwapInstruction::Initialize(fee).serialize()?;\n    let accounts = vec![\n        AccountMeta::new(*swap_pubkey, true),\n        AccountMeta::new(*authority_pubkey, false),\n        AccountMeta::new(*token_a_pubkey, false),\n        AccountMeta::new(*token_b_pubkey, false),\n        AccountMeta::new(*pool_pubkey, false),\n        AccountMeta::new(*user_output_pubkey, false),\n        AccountMeta::new(*token_program_id, false),\n    ];\n    Ok(Instruction {\n        program_id: *program_id,\n        accounts,\n        data,\n    })\n"]], "pred": {"ppl": 1.5264561176300049, "ppl_lower": 1.8426721096038818, "ppl/lowercase_ppl": -1.4451318274242995, "ppl/zlib": 0.001505155821106014, "Min_5.0% Prob": 5.580492990357535, "Min_10.0% Prob": 3.7487088314124515, "Min_20.0% Prob": 2.0889146625995636, "Min_30.0% Prob": 1.404581003909021, "Min_40.0% Prob": 1.0629217250011207, "Min_50.0% Prob": 0.8483653887422508, "Min_60.0% Prob": 0.7056458774117514}}
{"hexsha": "427fd6006422e8553f166bb425ee7093a287f2a3", "ext": "rs", "lang": "Rust", "content": "fn npm_install() -> Result<()> {\n    let npm = npm();\n    let status = Command::new(npm)\n        .current_dir(frontend_dir())\n        .arg(\"install\")\n        .status()?;\n\n    if !status.success() {\n        return Err(anyhow!(\"'npm install' failed\"));\n    }\n\n    Ok(())\n}", "item_id": 3, "repo": "marioweid/rustorrent", "file": "xtask/src/main.rs", "last_update_at": "2020-10-06T20:33:52+00:00", "question_id": "427fd6006422e8553f166bb425ee7093a287f2a3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn npm_install() -> Result<()> {\n    let npm = npm();\n    let status = Command::new(npm)\n        .current_dir(frontend_dir())\n        .arg(\"install\")\n        .status()?;\n    if !status.success() {\n        return Err(anyhow!(\"'npm install' failed\"));\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.100233316421509, "ppl_lower": 2.936113119125366, "ppl/lowercase_ppl": -1.4515044812670954, "ppl/zlib": 0.004122491342309728, "Min_5.0% Prob": 8.174196004867554, "Min_10.0% Prob": 5.053856730461121, "Min_20.0% Prob": 3.1692544751697116, "Min_30.0% Prob": 2.3339113968390004, "Min_40.0% Prob": 1.8223645318713453, "Min_50.0% Prob": 1.4788553761939207, "Min_60.0% Prob": 1.2357577686887924}}
{"hexsha": "78a8d2f96d989b8321463b46b92fe7c8a260d4f7", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // instantiating analyzer opts\n    let analyzer_opts = AnalyzerOpts {\n        Name: String::from(\"rust\"),\n        AnalysisConfigPath: String::from(\"/toolbox/analysis_config.json\"),\n        FileFinderRegex: String::from(\"\\\\.rs$\"),\n        CodePath: String::from(\"/Users/sidntrivedi012/Code/cap\"),\n        ResultPath: String::from(\"/toolbox/analysis_results.json\"),\n    };\n\n    // rustup update\n    let output = Command::new(\"rustup\")\n        .args(&[\"update\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"ls command failed to start\");\n\n    println!(\"status: {}\", output.status);\n    io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n\n    assert!(output.status.success());\n\n    // installing clippy\n    let output = Command::new(\"rustup\")\n        .args(&[\"component\", \"add\", \"clippy\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"ls command failed to start\");\n\n    println!(\"status: {}\", output.status);\n    io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n\n    // running clippy and getting data in json format\n    let output = Command::new(\"cargo\")\n        .args(&[\n            \"clippy\",\n            \"--message-format\",\n            \"json\",\n            \"--\",\n            \"-W\",\n            \"clippy::all\",\n        ])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"clippy failed to work\");\n\n    // io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n\n    // write the output to a file\n    let mut buffer = File::create(\"foo.txt\").unwrap();\n    buffer.write_all(&output.stdout);\n    // reading the clippy out line by line\n    let mut v = Vec::new();\n    // counting lines to prevent parsing the last 3 objects (they are useless)\n    let lines_count: usize = count_lines(std::fs::File::open(\"foo.txt\").unwrap()).unwrap();\n    let mut count: usize = 0;\n\n    // iterating throughout the file of clippy data and finding the useful stuff\n    // and dumping into the analyzer object\n    if let Ok(lines) = read_lines(\"./foo.txt\") {\n        for line in lines {\n            count = count + 1;\n            if count == lines_count - 3 {\n                break;\n            }\n\n            if let Ok(ip) = line {\n                // println!(\"{}\", ip);\n                if ip.starts_with(\"{\\\"reason\\\":\\\"compiler-message\\\"\") {\n                    let _res: Report = serde_json::from_str(&ip).unwrap();\n                    // println!(\"{} hello\", _res.message.code.code);\n                    if _res.reason == \"compiler-message\" {\n                        // and make an array of objects\n                        v.push(_res)\n                    }\n                }\n            }\n        }\n    }\n\n    let mut buffer = File::create(\"results.json\").unwrap();\n    let mut result_output = serde_json::to_string_pretty(&v).unwrap();\n\n    // writing the output to a file\n    buffer\n        .write_all(&result_output.as_bytes())\n        .expect(\"Writing the analysis result failed\");\n\n    // DEPENDENCY CALCULATION\n    // command - cargo tree --prefix depth | grep -c '^[[:space:]]*1' | wc -l\n    // counting direct dependencies\n    let mut deps_index = Command::new(\"cargo\")\n        .args(&[\"tree\", \"--prefix\", \"depth\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .stdout(Stdio::piped())\n        .spawn()\n        .expect(\"Failed to run cargo command to calc direct deps\");\n\n    // we won't need deps_index anymore.\n    let deps_index_output = deps_index.stdout.expect(\"Failed to run cargo command\");\n\n    let direct_deps = Command::new(\"grep\")\n        .args(&[\"-c\", \"^[[:space:]]*1\"])\n        .stdin(Stdio::from(deps_index_output))\n        .stdout(Stdio::piped())\n        .current_dir(&analyzer_opts.CodePath)\n        .spawn()\n        .expect(\"grepping failed to work\");\n\n    let mut direct_deps_output = direct_deps.stdout.expect(\"Failed again\");\n    // let mut total_deps_output = total_deps.stdout.expect(\"Total deps stdout failed.\");\n    let mut direct_deps_op = String::new();\n    // let mut total_deps_op = String::new();\n    direct_deps_output\n        .read_to_string(&mut direct_deps_op)\n        .unwrap();\n    // total_deps_output\n    //     .read_to_string(&mut total_deps_op)\n    //     .unwrap();\n    println!(\"***********\");\n    // println!(\"Total dependencies = {}\", &total_deps_op);\n    println!(\"Number of direct deps = {}\", &direct_deps_op);\n}", "item_id": 0, "repo": "siddhant-deepsource/rust-analyzer", "file": "src/main.rs", "last_update_at": "2020-08-29T14:33:24+00:00", "question_id": "78a8d2f96d989b8321463b46b92fe7c8a260d4f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // instantiating analyzer opts\n    let analyzer_opts = AnalyzerOpts {\n        Name: String::from(\"rust\"),\n        AnalysisConfigPath: String::from(\"/toolbox/analysis_config.json\"),\n        FileFinderRegex: String::from(\"\\\\.rs$\"),\n        CodePath: String::from(\"/Users/sidntrivedi012/Code/cap\"),\n        ResultPath: String::from(\"/toolbox/analysis_results.json\"),\n    };\n    // rustup update\n    let output = Command::new(\"rustup\")\n        .args(&[\"update\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"ls command failed to start\");\n    println!(\"status: {}\", output.status);\n    io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n    assert!(output.status.success());\n    // installing clippy\n    let output = Command::new(\"rustup\")\n        .args(&[\"component\", \"add\", \"clippy\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"ls command failed to start\");\n    println!(\"status: {}\", output.status);\n    io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n    // running clippy and getting data in json format\n    let output = Command::new(\"cargo\")\n        .args(&[\n            \"clippy\",\n            \"--message-format\",\n            \"json\",\n            \"--\",\n            \"-W\",\n            \"clippy::all\",\n        ])\n        .current_dir(&analyzer_opts.CodePath)\n        .output()\n        .expect(\"clippy failed to work\");\n    // io::stdout().write_all(&output.stdout).unwrap();\n    io::stderr().write_all(&output.stderr).unwrap();\n    // write the output to a file\n    let mut buffer = File::create(\"foo.txt\").unwrap();\n    buffer.write_all(&output.stdout);\n    // reading the clippy out line by line\n    let mut v = Vec::new();\n    // counting lines to prevent parsing the last 3 objects (they are useless)\n    let lines_count: usize = count_lines(std::fs::File::open(\"foo.txt\").unwrap()).unwrap();\n    let mut count: usize = 0;\n    // iterating throughout the file of clippy data and finding the useful stuff\n    // and dumping into the analyzer object\n    if let Ok(lines) = read_lines(\"./foo.txt\") {\n        for line in lines {\n            count = count + 1;\n            if count == lines_count - 3 {\n                break;\n            }\n            if let Ok(ip) = line {\n                // println!(\"{}\", ip);\n                if ip.starts_with(\"{\\\"reason\\\":\\\"compiler-message\\\"\") {\n                    let _res: Report = serde_json::from_str(&ip).unwrap();\n                    // println!(\"{} hello\", _res.message.code.code);\n                    if _res.reason == \"compiler-message\" {\n                        // and make an array of objects\n                        v.push(_res)\n                    }\n                }\n            }\n        }\n    }\n    let mut buffer = File::create(\"results.json\").unwrap();\n    let mut result_output = serde_json::to_string_pretty(&v).unwrap();\n    // writing the output to a file\n    buffer\n        .write_all(&result_output.as_bytes())\n        .expect(\"Writing the analysis result failed\");\n    // DEPENDENCY CALCULATION\n    // command - cargo tree --prefix depth | grep -c '^[[:space:]]*1' | wc -l\n    // counting direct dependencies\n    let mut deps_index = Command::new(\"cargo\")\n        .args(&[\"tree\", \"--prefix\", \"depth\"])\n        .current_dir(&analyzer_opts.CodePath)\n        .stdout(Stdio::piped())\n        .spawn()\n        .expect(\"Failed to run cargo command to calc direct deps\");\n    // we won't need deps_index anymore.\n    let deps_index_output = deps_index.stdout.expect(\"Failed to run cargo command\");\n    let direct_deps = Command::new(\"grep\")\n        .args(&[\"-c\", \"^[[:space:]]*1\"])\n        .stdin(Stdio::from(deps_index_output))\n        .stdout(Stdio::piped())\n        .current_dir(&analyzer_opts.CodePath)\n        .spawn()\n        .expect(\"grepping failed to work\");\n    let mut direct_deps_output = direct_deps.stdout.expect(\"Failed again\");\n    // let mut total_deps_output = total_deps.stdout.expect(\"Total deps stdout failed.\");\n    let mut direct_deps_op = String::new();\n    // let mut total_deps_op = String::new();\n    direct_deps_output\n        .read_to_string(&mut direct_deps_op)\n        .unwrap();\n    // total_deps_output\n    //     .read_to_string(&mut total_deps_op)\n    //     .unwrap();\n    println!(\"***********\");\n    // println!(\"Total dependencies = {}\", &total_deps_op);\n    println!(\"Number of direct deps = {}\", &direct_deps_op);\n"]], "pred": {"ppl": 2.399548053741455, "ppl_lower": 2.6867616176605225, "ppl/lowercase_ppl": -1.1291656924862448, "ppl/zlib": 0.0006388908092555533, "Min_5.0% Prob": 7.260588711383296, "Min_10.0% Prob": 5.680825598099652, "Min_20.0% Prob": 3.8978303483888213, "Min_30.0% Prob": 2.8288708057473686, "Min_40.0% Prob": 2.16731575543111, "Min_50.0% Prob": 1.747646520934897, "Min_60.0% Prob": 1.4595989334620354}}
{"hexsha": "c9603396af00fd0155cf24f07311d8da119e1a01", "ext": "rs", "lang": "Rust", "content": "pub fn debug_game<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {\n    let resource: GameStateReference = match args[0].decode() {\n        Err(_) => return Ok((error(), bad_reference()).encode(env)),\n        Ok(r) => r,\n    };\n\n    let game_state = match resource.0.try_lock() {\n        Err(_) => return Ok((error(), lock_fail()).encode(env)),\n        Ok(guard) => guard,\n    };\n\n    Ok((ok(), serde_json::to_string(&*game_state).unwrap()).encode(env))\n}", "item_id": 2, "repo": "Szetty/seven_wonders", "file": "core/src/lib.rs", "last_update_at": "2020-05-28T15:51:47+00:00", "question_id": "c9603396af00fd0155cf24f07311d8da119e1a01_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn debug_game<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {\n    let resource: GameStateReference = match args[0].decode() {\n        Err(_) => return Ok((error(), bad_reference()).encode(env)),\n        Ok(r) => r,\n    };\n    let game_state = match resource.0.try_lock() {\n        Err(_) => return Ok((error(), lock_fail()).encode(env)),\n        Ok(guard) => guard,\n    };\n    Ok((ok(), serde_json::to_string(&*game_state).unwrap()).encode(env))\n"]], "pred": {"ppl": 3.1277565956115723, "ppl_lower": 4.223918437957764, "ppl/lowercase_ppl": -1.2634771684022013, "ppl/zlib": 0.0044370272566270855, "Min_5.0% Prob": 8.45993459224701, "Min_10.0% Prob": 7.074736803770065, "Min_20.0% Prob": 4.918902885168791, "Min_30.0% Prob": 3.6219467806319394, "Min_40.0% Prob": 2.8087348400149494, "Min_50.0% Prob": 2.27041694461368, "Min_60.0% Prob": 1.8981878579749416}}
{"hexsha": "c2915c496d585ac52bdccdeadd76833b2c4030a5", "ext": "rs", "lang": "Rust", "content": "fn spanning() {\n\t\tlet data: u8 = 0u8;\n\t\tlet bp = BitPtr::new(&data, 0u8.idx(), 8);\n\n\t\tassert!(bp.domain().is_spanning());\n\n\t\tlet data: &[u16] = &[0u16, !0u16];\n\t\tlet bp = BitPtr::new(&data[0], 0u8.idx(), 32);\n\n\t\tassert!(bp.domain().is_spanning());\n\t}", "item_id": 4, "repo": "sunjay/vecbit", "file": "src/domain.rs", "last_update_at": "2020-05-20T08:07:40+00:00", "question_id": "c2915c496d585ac52bdccdeadd76833b2c4030a5_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spanning() {\n\t\tlet data: u8 = 0u8;\n\t\tlet bp = BitPtr::new(&data, 0u8.idx(), 8);\n\t\tassert!(bp.domain().is_spanning());\n\t\tlet data: &[u16] = &[0u16, !0u16];\n\t\tlet bp = BitPtr::new(&data[0], 0u8.idx(), 32);\n\t\tassert!(bp.domain().is_spanning());\n"]], "pred": {"ppl": 2.758920907974243, "ppl_lower": 2.8602242469787598, "ppl/lowercase_ppl": -1.035533103846485, "ppl/zlib": 0.007047497416018121, "Min_5.0% Prob": 6.988491932551066, "Min_10.0% Prob": 5.486133098602295, "Min_20.0% Prob": 4.030246606239905, "Min_30.0% Prob": 3.106572634134537, "Min_40.0% Prob": 2.447338253259659, "Min_50.0% Prob": 2.002524998554817, "Min_60.0% Prob": 1.6814750209450722}}
{"hexsha": "48a5b6beb22786857e15fcc6b238a06880e3ee51", "ext": "rs", "lang": "Rust", "content": "pub fn build_rust_code_from_protobuffer_with_options(proto_filename: &PathBuf, includes: Vec<String>, rpc_generator: pb_rs::types::RpcGeneratorFunction) -> Result<PathBuf, Error> {\n\tuse pb_rs::types::Config;\n\tlog::info!(\"Building protobuf for {:?}...\", &proto_filename);\n\n\tlet out_dir = autogen_dir();\n\tstd::fs::create_dir_all(&out_dir)?;\n\tlet out_file = get_protobuf_generated_filename(proto_filename);\n\tlog::info!(\"Generating {:?}.\", out_file);\n\n    let config = Config {\n        in_file: proto_filename.to_owned(),\n        out_file: out_file.clone(), \n        single_module: true,\n        import_search_path: vec![PathBuf::from(\"./schema\")],\n        no_output: false,\n        error_cycle: false,\n        headers: true,\n\t\tdont_use_cow: true,\n        custom_struct_derive: vec![\"derive_new::new\".into()], //, \"Eq\".into(), \"Hash\".into()],\n        custom_rpc_generator: rpc_generator,\n\t\tcustom_includes: includes,\n    };\n\n    if let Err(e) = pb_rs::types::FileDescriptor::write_proto(&config) {\n\t\treturn Err(failure::format_err!(\"{:?}\", e));\n\t}\n\n\tlog::info!(\"...Pb-rs ran on {:?} and created {:?}\", proto_filename, out_file);\n\n\tOk(out_file)\n}", "item_id": 0, "repo": "zutils/protocolhandler", "file": "src/buildfunctions.rs", "last_update_at": "2020-06-07T13:12:58+00:00", "question_id": "48a5b6beb22786857e15fcc6b238a06880e3ee51_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn build_rust_code_from_protobuffer_with_options(proto_filename: &PathBuf, includes: Vec<String>, rpc_generator: pb_rs::types::RpcGeneratorFunction) -> Result<PathBuf, Error> {\n\tuse pb_rs::types::Config;\n\tlog::info!(\"Building protobuf for {:?}...\", &proto_filename);\n\tlet out_dir = autogen_dir();\n\tstd::fs::create_dir_all(&out_dir)?;\n\tlet out_file = get_protobuf_generated_filename(proto_filename);\n\tlog::info!(\"Generating {:?}.\", out_file);\n    let config = Config {\n        in_file: proto_filename.to_owned(),\n        out_file: out_file.clone(), \n        single_module: true,\n        import_search_path: vec![PathBuf::from(\"./schema\")],\n        no_output: false,\n        error_cycle: false,\n        headers: true,\n\t\tdont_use_cow: true,\n        custom_struct_derive: vec![\"derive_new::new\".into()], //, \"Eq\".into(), \"Hash\".into()],\n        custom_rpc_generator: rpc_generator,\n\t\tcustom_includes: includes,\n    };\n    if let Err(e) = pb_rs::types::FileDescriptor::write_proto(&config) {\n\t\treturn Err(failure::format_err!(\"{:?}\", e));\n\t}\n\tlog::info!(\"...Pb-rs ran on {:?} and created {:?}\", proto_filename, out_file);\n\tOk(out_file)\n"]], "pred": {"ppl": 4.084258079528809, "ppl_lower": 4.88448429107666, "ppl/lowercase_ppl": -1.1271540907816375, "ppl/zlib": 0.0024557418693517473, "Min_5.0% Prob": 8.786018347740173, "Min_10.0% Prob": 7.194084084033966, "Min_20.0% Prob": 5.366048350930214, "Min_30.0% Prob": 4.213412018616994, "Min_40.0% Prob": 3.3701467295611125, "Min_50.0% Prob": 2.774968001602301, "Min_60.0% Prob": 2.3385078542212727}}
{"hexsha": "f47d38847bc8cd54ec6fc56c4fe3713205164d4b", "ext": "rs", "lang": "Rust", "content": "fn test_sidewinder() {\n        let width = 50_usize;\n        let height = 50_usize;\n        for _i in 0..10000 {\n            let mut grid = Grid::new(height, width);\n            grid.sidewinder(None);\n\n            assert!(maze_is_perfect(&grid));\n        }\n    }", "item_id": 2, "repo": "jonstites/minotaur", "file": "src/lib.rs", "last_update_at": "2020-01-26T22:01:11+00:00", "question_id": "f47d38847bc8cd54ec6fc56c4fe3713205164d4b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sidewinder() {\n        let width = 50_usize;\n        let height = 50_usize;\n        for _i in 0..10000 {\n            let mut grid = Grid::new(height, width);\n            grid.sidewinder(None);\n            assert!(maze_is_perfect(&grid));\n        }\n"]], "pred": {"ppl": 3.230072498321533, "ppl_lower": 3.831681728363037, "ppl/lowercase_ppl": -1.145670405629006, "ppl/zlib": 0.007564545692151339, "Min_5.0% Prob": 8.64855706691742, "Min_10.0% Prob": 6.770616637335883, "Min_20.0% Prob": 4.820843365457323, "Min_30.0% Prob": 3.6573993541576244, "Min_40.0% Prob": 2.8692227784130306, "Min_50.0% Prob": 2.3049045363846035, "Min_60.0% Prob": 1.949142904037779}}
{"hexsha": "a34e87b5fe91e1353db3e23988ce555e4e970446", "ext": "rs", "lang": "Rust", "content": "fn test_deduplication() {\n        let store = Arc::new(SqliteStore::new(\":memory:\").unwrap());\n        let root_ref = DurableTree::create(store.clone(), NumComparator).unwrap().root;\n        let index = Index::new(root_ref, store, NumComparator)\n            .insert(1)\n            .insert(2)\n            .insert(2)\n            .insert(3);\n\n        assert_equal(index.range_from(1), 1..4)\n    }", "item_id": 1, "repo": "loganmhb/logos", "file": "src/index.rs", "last_update_at": "2020-05-11T20:52:33+00:00", "question_id": "a34e87b5fe91e1353db3e23988ce555e4e970446_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_deduplication() {\n        let store = Arc::new(SqliteStore::new(\":memory:\").unwrap());\n        let root_ref = DurableTree::create(store.clone(), NumComparator).unwrap().root;\n        let index = Index::new(root_ref, store, NumComparator)\n            .insert(1)\n            .insert(2)\n            .insert(2)\n            .insert(3);\n        assert_equal(index.range_from(1), 1..4)\n"]], "pred": {"ppl": 4.487273693084717, "ppl_lower": 6.035320281982422, "ppl/lowercase_ppl": -1.1974251626367822, "ppl/zlib": 0.007048100103438341, "Min_5.0% Prob": 9.140353043874105, "Min_10.0% Prob": 7.526157180468242, "Min_20.0% Prob": 5.773952086766561, "Min_30.0% Prob": 4.418688052409404, "Min_40.0% Prob": 3.575082855565207, "Min_50.0% Prob": 2.9338488218284424, "Min_60.0% Prob": 2.4951051391057066}}
{"hexsha": "6ed4e282800b650c55fea495709831deaa8f303a", "ext": "rs", "lang": "Rust", "content": "fn test_array_out_of_range() {\n  let _array = val!([\"string\", 45]);\n  assert_eq!(_array[3], Val::Undef);\n  assert_eq!(_array[0], Val::Str(\"string\".into()));\n\n}", "item_id": 1, "repo": "moshe-kabala/rust-json", "file": "tests/val_test.rs", "last_update_at": "2020-08-11T17:54:55+00:00", "question_id": "6ed4e282800b650c55fea495709831deaa8f303a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_array_out_of_range() {\n  let _array = val!([\"string\", 45]);\n  assert_eq!(_array[3], Val::Undef);\n  assert_eq!(_array[0], Val::Str(\"string\".into()));\n"]], "pred": {"ppl": 4.583847522735596, "ppl_lower": 5.936347484588623, "ppl/lowercase_ppl": -1.1698185563523789, "ppl/zlib": 0.012278538031699033, "Min_5.0% Prob": 8.32514762878418, "Min_10.0% Prob": 6.918975035349528, "Min_20.0% Prob": 5.075509676566491, "Min_30.0% Prob": 4.140282988548279, "Min_40.0% Prob": 3.4400336879950304, "Min_50.0% Prob": 2.947152215987444, "Min_60.0% Prob": 2.4899131720646834}}
{"hexsha": "b19658b8e0f532901ab2a663ce3826d0ede3475a", "ext": "rs", "lang": "Rust", "content": "fn handle_large_slice() {\n        let stadium = Stadium::with_capacity(NonZeroUsize::new(10).unwrap());\n\n        let slice: &[u64] = &[1000; 100];\n        let big_slice = stadium.store_slice(slice);\n\n        assert_eq!(&*big_slice, slice);\n    }", "item_id": 3, "repo": "Kixiron/stadium", "file": "src/lib.rs", "last_update_at": "2020-07-19T16:05:41+00:00", "question_id": "b19658b8e0f532901ab2a663ce3826d0ede3475a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn handle_large_slice() {\n        let stadium = Stadium::with_capacity(NonZeroUsize::new(10).unwrap());\n        let slice: &[u64] = &[1000; 100];\n        let big_slice = stadium.store_slice(slice);\n        assert_eq!(&*big_slice, slice);\n"]], "pred": {"ppl": 4.0897135734558105, "ppl_lower": 4.965409755706787, "ppl/lowercase_ppl": -1.1377524592182615, "ppl/zlib": 0.008285146686250177, "Min_5.0% Prob": 11.187219142913818, "Min_10.0% Prob": 7.940730571746826, "Min_20.0% Prob": 5.453628500302632, "Min_30.0% Prob": 4.153439561525981, "Min_40.0% Prob": 3.340772974822256, "Min_50.0% Prob": 2.7241160908470983, "Min_60.0% Prob": 2.3191759209741245}}
{"hexsha": "0a338848af549c370b2f659be4d9b94fe98b0e62", "ext": "rs", "lang": "Rust", "content": "fn test_parse_negation() -> Result<(), String> {\n        let input = String::from(\"int main() { return -1; }\");\n        let tokens = lexer::lex(&input)?;\n        let ast = parse(tokens)?;\n        assert_display_snapshot!(ast);\n        Ok(())\n    }", "item_id": 8, "repo": "sgmenda/dinky-c", "file": "src/parser/parser.rs", "last_update_at": "2020-04-21T02:45:40+00:00", "question_id": "0a338848af549c370b2f659be4d9b94fe98b0e62_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_negation() -> Result<(), String> {\n        let input = String::from(\"int main() { return -1; }\");\n        let tokens = lexer::lex(&input)?;\n        let ast = parse(tokens)?;\n        assert_display_snapshot!(ast);\n        Ok(())\n"]], "pred": {"ppl": 3.0150532722473145, "ppl_lower": 4.182369709014893, "ppl/lowercase_ppl": -1.2965343546184211, "ppl/zlib": 0.006569151780318285, "Min_5.0% Prob": 8.909196217854818, "Min_10.0% Prob": 6.586761883326939, "Min_20.0% Prob": 4.397769490877788, "Min_30.0% Prob": 3.308095895725748, "Min_40.0% Prob": 2.677043696244558, "Min_50.0% Prob": 2.1858249212566174, "Min_60.0% Prob": 1.830092530535615}}
{"hexsha": "7be2eacee42da78055b3ef170b5fa91fd4bef5bd", "ext": "rs", "lang": "Rust", "content": "fn it_has_windows_installer() {\n    let windows_installer_path = get_binstall_scripts_root()\n        .join(\"windows\")\n        .join(\"install.ps1\");\n    let windows_script = fs::read_to_string(&windows_installer_path)\n        .expect(\"Could not read windows installer script\");\n    assert!(!windows_script.is_empty())\n}", "item_id": 1, "repo": "ContextLogic/rover", "file": "tests/installers.rs", "last_update_at": "2020-09-24T13:43:59+00:00", "question_id": "7be2eacee42da78055b3ef170b5fa91fd4bef5bd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_has_windows_installer() {\n    let windows_installer_path = get_binstall_scripts_root()\n        .join(\"windows\")\n        .join(\"install.ps1\");\n    let windows_script = fs::read_to_string(&windows_installer_path)\n        .expect(\"Could not read windows installer script\");\n    assert!(!windows_script.is_empty())\n"]], "pred": {"ppl": 3.271742343902588, "ppl_lower": 3.273620367050171, "ppl/lowercase_ppl": -1.0004841284890438, "ppl/zlib": 0.006972486293463814, "Min_5.0% Prob": 9.232838869094849, "Min_10.0% Prob": 7.344098938835992, "Min_20.0% Prob": 4.83354491936533, "Min_30.0% Prob": 3.5635786837544936, "Min_40.0% Prob": 2.8860834374239572, "Min_50.0% Prob": 2.36137697348992, "Min_60.0% Prob": 1.9768317296844105}}
{"hexsha": "e61f023b0999b0ade1044e47506d5757090f0ac5", "ext": "rs", "lang": "Rust", "content": "pub fn root_search<'de, T>(key: &str, candidate: &'de str) -> Result<T, Error> where T: Deserialize<'de> {\n    if key.is_empty() {\n        return Error::json(\"The searched key can't be empty\");\n    }\n\n    //get candidate slice starting at the first character of the value\n    let value_begin = {\n        let mut quoted_key = String::with_capacity(key.len() + 2);\n        quoted_key.push('\"');\n        quoted_key.push_str(key);\n        quoted_key.push('\"');\n\n        let mut iter = candidate.chars();\n        let mut key_iter = quoted_key.chars();\n        let mut prev_index = 0;\n        let mut nesting_level = 0;\n        let mut key_end = None;\n\n        while key_end.is_none() {\n            if nesting_level < 0 {\n                return Error::json(\"Incorrectly formatted JSON string\");\n            }\n\n            if let Some(next) = iter.next() {\n                if next == '{' || next == '[' {\n                    nesting_level += 1\n                } else if next == '}' || next == ']' {\n                    nesting_level -= 1\n                }\n\n                if nesting_level == 1 {\n                    if let Some(key_next) = key_iter.next() {\n                        if next != key_next {\n                            key_iter = quoted_key.chars();\n                        }\n                    } else {\n                        key_end = Some(prev_index + 1);\n                        break;\n                    }\n                }\n\n                prev_index += 1;\n            } else {\n                return Error::json(\"Could not find key in candidate\");\n            }\n        }\n\n        if key_end.is_none() {\n            return Error::json(\"Could not find key in candidate\");\n        }\n\n        match candidate[key_end.unwrap()..].find(|c: char| c.is_numeric() || c == '\"') {\n            Some(i) => &candidate[key_end.unwrap() + i..],\n            None => return Error::json(\"Could not find value in candidate\")\n        }\n    };\n\n    let mut iter = value_begin.chars();\n    let mut prev_index = 0;\n    let mut nesting_level = 0;\n    let mut value = None;\n\n    while value.is_none() {\n        if let Some(next) = iter.next() {\n            if next == '{' || next == '[' {\n                nesting_level += 1\n            } else if next == '}' || next == ']' {\n                nesting_level -= 1\n            }\n\n            if next == ',' || (nesting_level == -1 && next == '}') { //reached the end of the json value/string\n                value = Some(&value_begin[..prev_index]);\n            }\n\n            prev_index += 1;\n        } else {\n            return Error::json(\"Unexpected end of string\");\n        }\n    }\n\n    if let Some(value) = value {\n        return match serde_json::from_str(value) {\n            Ok(value) => Ok(value),\n            Err(e) => Error::json(e)\n        };\n    }\n\n    Error::json(\"An error occurred while searching for key\")\n}", "item_id": 1, "repo": "mbenoukaiss/automate", "file": "src/encode/json.rs", "last_update_at": "2020-08-10T20:41:38+00:00", "question_id": "e61f023b0999b0ade1044e47506d5757090f0ac5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn root_search<'de, T>(key: &str, candidate: &'de str) -> Result<T, Error> where T: Deserialize<'de> {\n    if key.is_empty() {\n        return Error::json(\"The searched key can't be empty\");\n    }\n    //get candidate slice starting at the first character of the value\n    let value_begin = {\n        let mut quoted_key = String::with_capacity(key.len() + 2);\n        quoted_key.push('\"');\n        quoted_key.push_str(key);\n        quoted_key.push('\"');\n        let mut iter = candidate.chars();\n        let mut key_iter = quoted_key.chars();\n        let mut prev_index = 0;\n        let mut nesting_level = 0;\n        let mut key_end = None;\n        while key_end.is_none() {\n            if nesting_level < 0 {\n                return Error::json(\"Incorrectly formatted JSON string\");\n            }\n            if let Some(next) = iter.next() {\n                if next == '{' || next == '[' {\n                    nesting_level += 1\n                } else if next == '}' || next == ']' {\n                    nesting_level -= 1\n                }\n                if nesting_level == 1 {\n                    if let Some(key_next) = key_iter.next() {\n                        if next != key_next {\n                            key_iter = quoted_key.chars();\n                        }\n                    } else {\n                        key_end = Some(prev_index + 1);\n                        break;\n                    }\n                }\n                prev_index += 1;\n            } else {\n                return Error::json(\"Could not find key in candidate\");\n            }\n        }\n        if key_end.is_none() {\n            return Error::json(\"Could not find key in candidate\");\n        }\n        match candidate[key_end.unwrap()..].find(|c: char| c.is_numeric() || c == '\"') {\n            Some(i) => &candidate[key_end.unwrap() + i..],\n            None => return Error::json(\"Could not find value in candidate\")\n        }\n    };\n    let mut iter = value_begin.chars();\n    let mut prev_index = 0;\n    let mut nesting_level = 0;\n    let mut value = None;\n    while value.is_none() {\n        if let Some(next) = iter.next() {\n            if next == '{' || next == '[' {\n                nesting_level += 1\n            } else if next == '}' || next == ']' {\n                nesting_level -= 1\n            }\n            if next == ',' || (nesting_level == -1 && next == '}') { //reached the end of the json value/string\n                value = Some(&value_begin[..prev_index]);\n            }\n            prev_index += 1;\n        } else {\n            return Error::json(\"Unexpected end of string\");\n        }\n    }\n    if let Some(value) = value {\n        return match serde_json::from_str(value) {\n            Ok(value) => Ok(value),\n            Err(e) => Error::json(e)\n        };\n    }\n    Error::json(\"An error occurred while searching for key\")\n"]], "pred": {"ppl": 1.7711595296859741, "ppl_lower": 1.8552443981170654, "ppl/lowercase_ppl": -1.0811392772056097, "ppl/zlib": 0.0006789007525153279, "Min_5.0% Prob": 5.762491598361876, "Min_10.0% Prob": 4.145643489906587, "Min_20.0% Prob": 2.574167121964765, "Min_30.0% Prob": 1.8456374176415096, "Min_40.0% Prob": 1.416595464370337, "Min_50.0% Prob": 1.1409914795623486, "Min_60.0% Prob": 0.9527627334716808}}
{"hexsha": "c9619233bc98c90cf2e068779830f681f5d7e195", "ext": "rs", "lang": "Rust", "content": "pub fn optimize_obj(obj: &mut ir::Object) -> bool{\n    blocks::flat_to_blocks_obj(obj);\n\n    memory::trim_array_lengths_obj(obj);\n\n    let mut progress = false;\n    loop {\n        let mut p = false;\n        p |= memory::copy_propagation_obj(obj);\n        p |= algebraic::algebraic_reduce_obj(obj);\n        p |= constant::constant_fold_obj(obj);\n        p |= blocks::clear_dead_blocks_obj(obj);\n        p |= dead_code::dead_code_obj(obj);\n        p |= dead_code::remove_nops_obj(obj);\n        p |= blocks::peephole_select_obj(obj);\n\n        if p {\n            progress = true;\n        } else {\n            break;\n        }\n    }\n\n    blocks::remove_trivial_jumps_obj(obj);\n    blocks::blocks_to_flat_obj(obj);\n\n    progress\n}", "item_id": 0, "repo": "jekstrand/ev3opt", "file": "src/opt/mod.rs", "last_update_at": "2020-10-03T17:30:26+00:00", "question_id": "c9619233bc98c90cf2e068779830f681f5d7e195_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn optimize_obj(obj: &mut ir::Object) -> bool{\n    blocks::flat_to_blocks_obj(obj);\n    memory::trim_array_lengths_obj(obj);\n    let mut progress = false;\n    loop {\n        let mut p = false;\n        p |= memory::copy_propagation_obj(obj);\n        p |= algebraic::algebraic_reduce_obj(obj);\n        p |= constant::constant_fold_obj(obj);\n        p |= blocks::clear_dead_blocks_obj(obj);\n        p |= dead_code::dead_code_obj(obj);\n        p |= dead_code::remove_nops_obj(obj);\n        p |= blocks::peephole_select_obj(obj);\n        if p {\n            progress = true;\n        } else {\n            break;\n        }\n    }\n    blocks::remove_trivial_jumps_obj(obj);\n    blocks::blocks_to_flat_obj(obj);\n    progress\n"]], "pred": {"ppl": 2.7861392498016357, "ppl_lower": 2.8586952686309814, "ppl/lowercase_ppl": -1.0250898285785317, "ppl/zlib": 0.0034971223757354225, "Min_5.0% Prob": 9.020840326944986, "Min_10.0% Prob": 6.8140665054321286, "Min_20.0% Prob": 4.469091011028664, "Min_30.0% Prob": 3.2751321188713374, "Min_40.0% Prob": 2.526241511252581, "Min_50.0% Prob": 2.0474789340019695, "Min_60.0% Prob": 1.7047826301647362}}
{"hexsha": "debf3aaf9becab8529d7c1c1e2273dbb753ec3a5", "ext": "rs", "lang": "Rust", "content": "fn transactions_can_be_used_across_sub_databases<'a, S, X, E>(\n    env: &'a X,\n    store_a: &S,\n    store_b: &S,\n) -> Result<(), E>\nwhere\n    S: TrieStore<Vec<u8>, Vec<u8>>,\n    X: TransactionSource<'a, Handle = S::Handle>,\n    S::Error: From<X::Error>,\n    E: From<S::Error> + From<X::Error> + From<types::bytesrepr::Error>,\n{\n    let data = super::create_data();\n    let TestData(ref leaf_1_hash, ref leaf_1) = data[0];\n    let TestData(ref leaf_2_hash, ref leaf_2) = data[1];\n\n    {\n        let mut write_txn = env.create_read_write_txn()?;\n        store_a.put(&mut write_txn, leaf_1_hash, leaf_1)?;\n        store_b.put(&mut write_txn, leaf_2_hash, leaf_2)?;\n        write_txn.commit()?;\n    }\n\n    {\n        let read_txn = env.create_read_txn()?;\n        let result = store_a.get(&read_txn, leaf_1_hash)?;\n        assert_eq!(result, Some(leaf_1.to_owned()));\n        let result = store_b.get(&read_txn, leaf_2_hash)?;\n        assert_eq!(result, Some(leaf_2.to_owned()));\n        read_txn.commit()?;\n    }\n\n    Ok(())\n}", "item_id": 21, "repo": "hnjolles1/CasperLabs", "file": "execution-engine/engine-storage/src/trie_store/tests/simple.rs", "last_update_at": "2020-01-15T08:33:56+00:00", "question_id": "debf3aaf9becab8529d7c1c1e2273dbb753ec3a5_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn transactions_can_be_used_across_sub_databases<'a, S, X, E>(\n    env: &'a X,\n    store_a: &S,\n    store_b: &S,\n) -> Result<(), E>\nwhere\n    S: TrieStore<Vec<u8>, Vec<u8>>,\n    X: TransactionSource<'a, Handle = S::Handle>,\n    S::Error: From<X::Error>,\n    E: From<S::Error> + From<X::Error> + From<types::bytesrepr::Error>,\n{\n    let data = super::create_data();\n    let TestData(ref leaf_1_hash, ref leaf_1) = data[0];\n    let TestData(ref leaf_2_hash, ref leaf_2) = data[1];\n    {\n        let mut write_txn = env.create_read_write_txn()?;\n        store_a.put(&mut write_txn, leaf_1_hash, leaf_1)?;\n        store_b.put(&mut write_txn, leaf_2_hash, leaf_2)?;\n        write_txn.commit()?;\n    }\n    {\n        let read_txn = env.create_read_txn()?;\n        let result = store_a.get(&read_txn, leaf_1_hash)?;\n        assert_eq!(result, Some(leaf_1.to_owned()));\n        let result = store_b.get(&read_txn, leaf_2_hash)?;\n        assert_eq!(result, Some(leaf_2.to_owned()));\n        read_txn.commit()?;\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.9248249530792236, "ppl_lower": 2.2915279865264893, "ppl/lowercase_ppl": -1.2663018927167733, "ppl/zlib": 0.0015894054129604637, "Min_5.0% Prob": 7.429940223693848, "Min_10.0% Prob": 5.207158385253534, "Min_20.0% Prob": 3.10202756524086, "Min_30.0% Prob": 2.1612978005796912, "Min_40.0% Prob": 1.632046543355241, "Min_50.0% Prob": 1.3118119658947498, "Min_60.0% Prob": 1.094712577626837}}
{"hexsha": "d94aca502561db75c6fa50a0cec3d5f9cda5d900", "ext": "rs", "lang": "Rust", "content": "fn rename_basic() -> anyhow::Result<()> {\n    let tmp = tempdir().unwrap();\n    let tmpp = tmp.path();\n    let mut note_data = NoteData::default();\n    edit(\n        EditNoteOptions { name: \"bob\".into() },\n        tmp.path(),\n        &mut note_data,\n        MockEditor {},\n    )?;\n    // Add a dir tag\n    tag_dir(\n        TagDirOptions {\n            name: \"bob\".into(),\n            add_dir_tag: Some(tmpp.into()),\n            remove_dir_tag: None,\n        },\n        tmpp,\n        &mut note_data,\n    )?;\n    rename(\n        RenameNoteOptions {\n            name: \"bob\".into(),\n            new_name: \"bob2\".into(),\n        },\n        tmp.path(),\n        &mut note_data,\n    )?;\n    let mut b = NoteData::default();\n    b.set_dir_tag(Some(\"bob2\"), tmpp.into());\n\n    assert_eq!(b, note_data);\n    assert_eq!(files_in_dir(&tmp.path()), vec![\"bob2.md\"]);\n    Ok(())\n}", "item_id": 2, "repo": "TheImaginaryOne/minimble-notes", "file": "tests/integration.rs", "last_update_at": "2020-07-20T09:54:11+00:00", "question_id": "d94aca502561db75c6fa50a0cec3d5f9cda5d900_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rename_basic() -> anyhow::Result<()> {\n    let tmp = tempdir().unwrap();\n    let tmpp = tmp.path();\n    let mut note_data = NoteData::default();\n    edit(\n        EditNoteOptions { name: \"bob\".into() },\n        tmp.path(),\n        &mut note_data,\n        MockEditor {},\n    )?;\n    // Add a dir tag\n    tag_dir(\n        TagDirOptions {\n            name: \"bob\".into(),\n            add_dir_tag: Some(tmpp.into()),\n            remove_dir_tag: None,\n        },\n        tmpp,\n        &mut note_data,\n    )?;\n    rename(\n        RenameNoteOptions {\n            name: \"bob\".into(),\n            new_name: \"bob2\".into(),\n        },\n        tmp.path(),\n        &mut note_data,\n    )?;\n    let mut b = NoteData::default();\n    b.set_dir_tag(Some(\"bob2\"), tmpp.into());\n    assert_eq!(b, note_data);\n    assert_eq!(files_in_dir(&tmp.path()), vec![\"bob2.md\"]);\n    Ok(())\n"]], "pred": {"ppl": 2.7258315086364746, "ppl_lower": 3.3682594299316406, "ppl/lowercase_ppl": -1.2110372823298607, "ppl/zlib": 0.002856904622089043, "Min_5.0% Prob": 8.182961191449847, "Min_10.0% Prob": 6.138916212936928, "Min_20.0% Prob": 4.179385888374458, "Min_30.0% Prob": 3.1205695746989734, "Min_40.0% Prob": 2.4514947225566672, "Min_50.0% Prob": 1.9945504995900512, "Min_60.0% Prob": 1.6709119436960647}}
{"hexsha": "85ed9c718ece9892d3ddd73d08cdc6a13b30538f", "ext": "rs", "lang": "Rust", "content": "fn addThreeBytesAsOctal( mut input: Vec<u8>, bytes: &[u8] ) -> Vec<u8> {\n  // &[u8] -> &str -> u8 -> write to input\n\n  let slice: &str = from_utf8( &bytes ).unwrap();\n  match u8::from_str_radix( slice, 8 ) {\n    Ok( byte ) => input.push( byte ),\n    _ => panic!( r\"Invalid octal escape sequence: \\{}{}{}\",\n                bytes.get( 0 ).unwrap(),\n                bytes.get( 1 ).unwrap(),\n                bytes.get( 2 ).unwrap() )\n  }\n  input\n}", "item_id": 3, "repo": "Valloric/nailgun", "file": "generator/unescape.rs", "last_update_at": "2020-04-24T05:09:29+00:00", "question_id": "85ed9c718ece9892d3ddd73d08cdc6a13b30538f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn addThreeBytesAsOctal( mut input: Vec<u8>, bytes: &[u8] ) -> Vec<u8> {\n  // &[u8] -> &str -> u8 -> write to input\n  let slice: &str = from_utf8( &bytes ).unwrap();\n  match u8::from_str_radix( slice, 8 ) {\n    Ok( byte ) => input.push( byte ),\n    _ => panic!( r\"Invalid octal escape sequence: \\{}{}{}\",\n                bytes.get( 0 ).unwrap(),\n                bytes.get( 1 ).unwrap(),\n                bytes.get( 2 ).unwrap() )\n  }\n  input\n"]], "pred": {"ppl": 3.195094108581543, "ppl_lower": 3.833421468734741, "ppl/lowercase_ppl": -1.1567997607551428, "ppl/zlib": 0.004573293473822082, "Min_5.0% Prob": 8.148865699768066, "Min_10.0% Prob": 6.622415781021118, "Min_20.0% Prob": 4.696805335581303, "Min_30.0% Prob": 3.574725102633238, "Min_40.0% Prob": 2.8400029437616467, "Min_50.0% Prob": 2.3138744282536208, "Min_60.0% Prob": 1.9414279580426712}}
{"hexsha": "ec60b2ed1f1309bbff6f421e55178a3b848a5e98", "ext": "rs", "lang": "Rust", "content": "fn take_losing_turn() {\n        let mut game = Game {\n            board: vec![0; 25],\n            size: 5,\n            state: GameState::Continue(1),\n        };\n        game.board[0] = 1;\n        game.board[20] = 1;\n\n        game.take_turn(1);\n        assert_eq!(GameState::Lose, game.state);\n    }", "item_id": 2, "repo": "denialanderror/flood-it", "file": "src/lib.rs", "last_update_at": "2020-07-29T17:25:28+00:00", "question_id": "ec60b2ed1f1309bbff6f421e55178a3b848a5e98_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn take_losing_turn() {\n        let mut game = Game {\n            board: vec![0; 25],\n            size: 5,\n            state: GameState::Continue(1),\n        };\n        game.board[0] = 1;\n        game.board[20] = 1;\n        game.take_turn(1);\n        assert_eq!(GameState::Lose, game.state);\n"]], "pred": {"ppl": 2.938985824584961, "ppl_lower": 3.5271832942962646, "ppl/lowercase_ppl": -1.169224609212162, "ppl/zlib": 0.00653372463160521, "Min_5.0% Prob": 7.662504386901856, "Min_10.0% Prob": 5.870286154747009, "Min_20.0% Prob": 4.059337246985662, "Min_30.0% Prob": 3.2283689091282506, "Min_40.0% Prob": 2.5568075265203203, "Min_50.0% Prob": 2.103094033194038, "Min_60.0% Prob": 1.7956059136324458}}
{"hexsha": "05eed096b4f4427058dfd15b8faf34062971ecc1", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), String> {\n    // Create a DDlog configuration with 1 worker thread and with the self-profiling feature\n    // enabled.\n    let config = Config::new()\n        .with_timely_workers(1)\n        .with_profiling_config(ProfilingConfig::SelfProfiling);\n    // Instantiate the DDlog program with this configuration.\n    // The second argument of `run_with_config` is a Boolean flag that indicates\n    // whether DDlog will track the complete snapshot of output relations.  It\n    // should only be set for debugging in order to dump the contents of output\n    // tables using `HDDlog::dump_table()`.  Otherwise, indexes are the preferred\n    // way to achieve this.\n    let (hddlog, init_state) = tutorial_ddlog::run_with_config(config, false)?;\n\n    // Alternatively, use `tutorial_ddlog::run` to instantiate the program with default\n    // configuration.  The first argument specifies the number of workers.\n\n    // let (hddlog, init_state) = tutorial_ddlog::run(1, false)?;\n\n    println!(\"Initial state\");\n    dump_delta(&hddlog, &init_state);\n\n    /*\n     * We perform two transactions that insert in the following two DDlog relations\n     * (see `tutorial.dl`):\n     *\n     * ```\n     * input relation Word1(word: string, cat: Category)\n     * input relation Word2(word: string, cat: Category)\n     * ```\n     *\n     * The first transactio uses the type-safe API, which should be preferred when\n     * writing a client bound to a specific known DDlog program.\n     *\n     * The second transaction uses the dynamically typed record API.\n     */\n\n    // There can be at most one transaction at a time.  Attempt to start another transaction\n    // when there is one in execution will return an error.\n    hddlog.transaction_start()?;\n\n    // A transaction can consist of multiple `apply_updates()` calls, each taking\n    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n    // relation.\n    let updates = vec![\n        Update::Insert {\n            // We are going to insert..\n            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n            // `Word1` type, declared in the `types` crate has the same fields as\n            // the corresponding DDlog type.\n            v: Word1 {\n                word: \"foo-\".to_string(),\n                cat: Category::CategoryOther,\n            }\n            .into_ddvalue(),\n        },\n        Update::Insert {\n            relid: Relations::Word2 as RelId,\n            v: Word2 {\n                word: \"bar\".to_string(),\n                cat: Category::CategoryOther,\n            }\n            .into_ddvalue(),\n        },\n    ];\n    hddlog.apply_updates(&mut updates.into_iter())?;\n\n    // Commit the transaction; returns a `DeltaMap` object that contains the set\n    // of changes to output relations produced by the transaction.\n    let mut delta = hddlog.transaction_commit_dump_changes()?;\n    //assert_eq!(delta, delta_expected);\n\n    println!(\"\\nState after transaction 1\");\n    dump_delta(&hddlog, &delta);\n\n    // This shows how to extract values from `DeltaMap`.\n    println!(\"\\nEnumerating new phrases\");\n\n    // Retrieve the set of changes for a particular relation.\n    let new_phrases = delta.get_rel(Relations::Phrases as RelId);\n    for (val, weight) in new_phrases.iter() {\n        // weight = 1 - insert.\n        // weight = -1 - delete.\n        assert_eq!(*weight, 1);\n        let phrase: &Phrases = Phrases::from_ddvalue_ref(val);\n        println!(\"New phrase: {}\", phrase.phrase);\n    }\n\n    hddlog.transaction_start()?;\n\n    // `Record` type\n\n    let relid_word1 = hddlog.inventory.get_table_id(\"Word1\").unwrap() as RelId;\n\n    // `UpdCmd` is a dynamically typed representation of a DDlog command.\n    // It takes a vector or `Record`'s, which represent dynamically typed\n    // DDlog values.\n    let commands = vec![UpdCmd::Insert(\n        RelIdentifier::RelId(relid_word1),\n        Record::PosStruct(\n            // Positional struct consists of constructor name\n            // and a vector of arguments whose number and\n            // types must match those of the DDlog constructor.\n            // The alternative is `NamedStruct` where arguments\n            // are represented as (name, value) pairs.\n            Cow::from(\"Word1\"), // Constructor name.\n            // Constructor arguments.\n            vec![\n                Record::String(\"buzz\".to_string()),\n                Record::PosStruct(Cow::from(\"CategoryOther\"), vec![]),\n            ],\n        ),\n    )];\n\n    // Use `apply_updates_dynamic` instead of `apply_updates` for dynamically\n    // typed commands.\n    // This will fail if the records in `commands` don't match the DDlog type\n    // declarations (e.g., missing constructor arguments, string instead of integer, etc.)\n    hddlog.apply_updates_dynamic(&mut commands.into_iter())?;\n\n    let delta = hddlog.transaction_commit_dump_changes()?;\n\n    println!(\"\\nState after transaction 2\");\n    dump_delta(&hddlog, &delta);\n\n    hddlog.stop().unwrap();\n    Ok(())\n}", "item_id": 0, "repo": "lykahb/differential-datalog", "file": "test/datalog_tests/rust_api_test/src/main.rs", "last_update_at": "2020-04-01T19:33:59+00:00", "question_id": "05eed096b4f4427058dfd15b8faf34062971ecc1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), String> {\n    // Create a DDlog configuration with 1 worker thread and with the self-profiling feature\n    // enabled.\n    let config = Config::new()\n        .with_timely_workers(1)\n        .with_profiling_config(ProfilingConfig::SelfProfiling);\n    // Instantiate the DDlog program with this configuration.\n    // The second argument of `run_with_config` is a Boolean flag that indicates\n    // whether DDlog will track the complete snapshot of output relations.  It\n    // should only be set for debugging in order to dump the contents of output\n    // tables using `HDDlog::dump_table()`.  Otherwise, indexes are the preferred\n    // way to achieve this.\n    let (hddlog, init_state) = tutorial_ddlog::run_with_config(config, false)?;\n    // Alternatively, use `tutorial_ddlog::run` to instantiate the program with default\n    // configuration.  The first argument specifies the number of workers.\n    // let (hddlog, init_state) = tutorial_ddlog::run(1, false)?;\n    println!(\"Initial state\");\n    dump_delta(&hddlog, &init_state);\n    /*\n     * We perform two transactions that insert in the following two DDlog relations\n     * (see `tutorial.dl`):\n     *\n     * ```\n     * input relation Word1(word: string, cat: Category)\n     * input relation Word2(word: string, cat: Category)\n     * ```\n     *\n     * The first transactio uses the type-safe API, which should be preferred when\n     * writing a client bound to a specific known DDlog program.\n     *\n     * The second transaction uses the dynamically typed record API.\n     */\n    // There can be at most one transaction at a time.  Attempt to start another transaction\n    // when there is one in execution will return an error.\n    hddlog.transaction_start()?;\n    // A transaction can consist of multiple `apply_updates()` calls, each taking\n    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n    // relation.\n    let updates = vec![\n        Update::Insert {\n            // We are going to insert..\n            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n            // `Word1` type, declared in the `types` crate has the same fields as\n            // the corresponding DDlog type.\n            v: Word1 {\n                word: \"foo-\".to_string(),\n                cat: Category::CategoryOther,\n            }\n            .into_ddvalue(),\n        },\n        Update::Insert {\n            relid: Relations::Word2 as RelId,\n            v: Word2 {\n                word: \"bar\".to_string(),\n                cat: Category::CategoryOther,\n            }\n            .into_ddvalue(),\n        },\n    ];\n    hddlog.apply_updates(&mut updates.into_iter())?;\n    // Commit the transaction; returns a `DeltaMap` object that contains the set\n    // of changes to output relations produced by the transaction.\n    let mut delta = hddlog.transaction_commit_dump_changes()?;\n    //assert_eq!(delta, delta_expected);\n    println!(\"\\nState after transaction 1\");\n    dump_delta(&hddlog, &delta);\n    // This shows how to extract values from `DeltaMap`.\n    println!(\"\\nEnumerating new phrases\");\n    // Retrieve the set of changes for a particular relation.\n    let new_phrases = delta.get_rel(Relations::Phrases as RelId);\n    for (val, weight) in new_phrases.iter() {\n        // weight = 1 - insert.\n        // weight = -1 - delete.\n        assert_eq!(*weight, 1);\n        let phrase: &Phrases = Phrases::from_ddvalue_ref(val);\n        println!(\"New phrase: {}\", phrase.phrase);\n    }\n    hddlog.transaction_start()?;\n    // `Record` type\n    let relid_word1 = hddlog.inventory.get_table_id(\"Word1\").unwrap() as RelId;\n    // `UpdCmd` is a dynamically typed representation of a DDlog command.\n    // It takes a vector or `Record`'s, which represent dynamically typed\n    // DDlog values.\n    let commands = vec![UpdCmd::Insert(\n        RelIdentifier::RelId(relid_word1),\n        Record::PosStruct(\n            // Positional struct consists of constructor name\n            // and a vector of arguments whose number and\n            // types must match those of the DDlog constructor.\n            // The alternative is `NamedStruct` where arguments\n            // are represented as (name, value) pairs.\n            Cow::from(\"Word1\"), // Constructor name.\n            // Constructor arguments.\n            vec![\n                Record::String(\"buzz\".to_string()),\n                Record::PosStruct(Cow::from(\"CategoryOther\"), vec![]),\n            ],\n        ),\n    )];\n    // Use `apply_updates_dynamic` instead of `apply_updates` for dynamically\n    // typed commands.\n    // This will fail if the records in `commands` don't match the DDlog type\n    // declarations (e.g., missing constructor arguments, string instead of integer, etc.)\n    hddlog.apply_updates_dynamic(&mut commands.into_iter())?;\n    let delta = hddlog.transaction_commit_dump_changes()?;\n    println!(\"\\nState after transaction 2\");\n    dump_delta(&hddlog, &delta);\n    hddlog.stop().unwrap();\n    Ok(())\n"]], "pred": {"ppl": 3.494858503341675, "ppl_lower": 3.832075595855713, "ppl/lowercase_ppl": -1.0736148177616478, "ppl/zlib": 0.000673824926986101, "Min_5.0% Prob": 8.19985684226541, "Min_10.0% Prob": 6.6429543869168155, "Min_20.0% Prob": 4.816165539563871, "Min_30.0% Prob": 3.7285300594529294, "Min_40.0% Prob": 2.9901956392675273, "Min_50.0% Prob": 2.464644973262882, "Min_60.0% Prob": 2.0784824628012215}}
{"hexsha": "586860cbd43665456d19d61adedcb4aa23f7e82a", "ext": "rs", "lang": "Rust", "content": "pub fn server() {\n    let mut single_rt = Builder::new()\n    .basic_scheduler()\n    .enable_all()\n    .build()\n    .unwrap();\n\n    // Automatically select the best implementation for your platform.\n    let mut watcher: RecommendedWatcher = Watcher::new_immediate(|res: Result<notify::event::Event, nError>| {\n        match res {\n            Ok(event) => {\n                let watcher = Arc::clone(&FILE_WATCHER);\n                let tx = watcher.0.lock().unwrap();\n                for path in event.paths {\n                    tx.broadcast(path.into_os_string().into_string().unwrap()).unwrap();\n                }\n            },\n            Err(e) => {\n                println!(\"watch error: {:?}\", e);\n            }\n        }\n    }).unwrap();\n\n    // Add a path to be watched. All files and directories at that path and\n    // below will be monitored for changes.\n    watcher.watch(\"./control-panel\", RecursiveMode::Recursive).unwrap();\n    \n  \n    let local = tokio::task::LocalSet::new();\n    let system_fut = actix_rt::System::run_in_tokio(\"Dashboard Server\", &local);\n\n    local.block_on(&mut single_rt, async {\n      tokio::task::spawn_local(system_fut);\n\n      let server = ReloadServer::default().start();\n  \n      let _ = actix_web::HttpServer::new(move || {\n            App::new()\n            .data(server.clone())\n            .route(\"/livereload\", web::get().to(index_ws))\n            .route(\"/{filename:.*}\", web::get().to(index))\n        })\n        .workers(1)\n        .bind(\"127.0.0.1:8086\")\n        .unwrap()\n        .run()\n        .await;\n    });\n}", "item_id": 1, "repo": "UrbanConsults/deno", "file": "rws/control_panel.rs", "last_update_at": "2020-07-18T17:45:01+00:00", "question_id": "586860cbd43665456d19d61adedcb4aa23f7e82a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn server() {\n    let mut single_rt = Builder::new()\n    .basic_scheduler()\n    .enable_all()\n    .build()\n    .unwrap();\n    // Automatically select the best implementation for your platform.\n    let mut watcher: RecommendedWatcher = Watcher::new_immediate(|res: Result<notify::event::Event, nError>| {\n        match res {\n            Ok(event) => {\n                let watcher = Arc::clone(&FILE_WATCHER);\n                let tx = watcher.0.lock().unwrap();\n                for path in event.paths {\n                    tx.broadcast(path.into_os_string().into_string().unwrap()).unwrap();\n                }\n            },\n            Err(e) => {\n                println!(\"watch error: {:?}\", e);\n            }\n        }\n    }).unwrap();\n    // Add a path to be watched. All files and directories at that path and\n    // below will be monitored for changes.\n    watcher.watch(\"./control-panel\", RecursiveMode::Recursive).unwrap();\n    let local = tokio::task::LocalSet::new();\n    let system_fut = actix_rt::System::run_in_tokio(\"Dashboard Server\", &local);\n    local.block_on(&mut single_rt, async {\n      tokio::task::spawn_local(system_fut);\n      let server = ReloadServer::default().start();\n      let _ = actix_web::HttpServer::new(move || {\n            App::new()\n            .data(server.clone())\n            .route(\"/livereload\", web::get().to(index_ws))\n            .route(\"/{filename:.*}\", web::get().to(index))\n        })\n        .workers(1)\n        .bind(\"127.0.0.1:8086\")\n        .unwrap()\n        .run()\n        .await;\n    });\n"]], "pred": {"ppl": 2.4024462699890137, "ppl_lower": 3.2845232486724854, "ppl/lowercase_ppl": -1.3568037366726067, "ppl/zlib": 0.0011990253042458287, "Min_5.0% Prob": 7.869548539320628, "Min_10.0% Prob": 5.815286785364151, "Min_20.0% Prob": 3.782174208511909, "Min_30.0% Prob": 2.774927243590355, "Min_40.0% Prob": 2.152559880943348, "Min_50.0% Prob": 1.7433072227363786, "Min_60.0% Prob": 1.4592872459907085}}
{"hexsha": "fc6ad78c4d1e42f3343903b80a503255bd5a2983", "ext": "rs", "lang": "Rust", "content": "fn get_status_change_time(metadata: &Metadata) -> Option<SystemTime> {\n    use std::time::{Duration, UNIX_EPOCH};\n    use std::os::unix::fs::MetadataExt;\n\n    UNIX_EPOCH.checked_add(Duration::from_secs(metadata.ctime() as u64))\n}", "item_id": 0, "repo": "Spawek/rrg", "file": "src/action/listdir.rs", "last_update_at": "2020-08-07T17:03:39+00:00", "question_id": "fc6ad78c4d1e42f3343903b80a503255bd5a2983_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_status_change_time(metadata: &Metadata) -> Option<SystemTime> {\n    use std::time::{Duration, UNIX_EPOCH};\n    use std::os::unix::fs::MetadataExt;\n    UNIX_EPOCH.checked_add(Duration::from_secs(metadata.ctime() as u64))\n"]], "pred": {"ppl": 2.1657533645629883, "ppl_lower": 3.77292537689209, "ppl/lowercase_ppl": -1.7183037981839373, "ppl/zlib": 0.004492838809996482, "Min_5.0% Prob": 7.116632580757141, "Min_10.0% Prob": 5.434919089078903, "Min_20.0% Prob": 3.4787337990368115, "Min_30.0% Prob": 2.553334126472473, "Min_40.0% Prob": 1.919274083174327, "Min_50.0% Prob": 1.5614193536873375, "Min_60.0% Prob": 1.2874081029794087}}
{"hexsha": "654867df8315d99617244af63ec9b2c11da581f4", "ext": "rs", "lang": "Rust", "content": "fn grid_insert_column() {\n        let mut grid = Grid::from_rows(vec![vec![2],\n                                            vec![5],\n                                            vec![8]]);\n\n        assert_eq!(grid.capacity(), size!(1, 3));\n\n        // Test inserting a column the very beginning.\n        grid.insert_column(0, vec![1, 4, 7]);\n\n        assert_eq!(grid.size(), size!(2, 3));\n        assert_eq!(grid[coord!(0, 0)], 1);\n        assert_eq!(grid[coord!(0, 1)], 4);\n        assert_eq!(grid[coord!(0, 2)], 7);\n\n        assert_eq!(grid.capacity(), size!(2, 3));\n\n        // Test inserting a column at the very end\n        grid.insert_column(2, vec![3, 6, 9]);\n\n        assert_eq!(grid.size(), size!(3, 3));\n        assert_eq!(grid[coord!(2, 0)], 3);\n        assert_eq!(grid[coord!(2, 1)], 6);\n        assert_eq!(grid[coord!(2, 2)], 9);\n\n        assert_eq!(grid.capacity(), size!(3, 3));\n\n        assert_eq!(grid[coord!(1, 0)], 2);\n        assert_eq!(grid[coord!(1, 1)], 5);\n        assert_eq!(grid[coord!(1, 2)], 8);\n    }", "item_id": 28, "repo": "intjelic/ingrid", "file": "src/grid.rs", "last_update_at": "2020-11-18T11:52:31+00:00", "question_id": "654867df8315d99617244af63ec9b2c11da581f4_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn grid_insert_column() {\n        let mut grid = Grid::from_rows(vec![vec![2],\n                                            vec![5],\n                                            vec![8]]);\n        assert_eq!(grid.capacity(), size!(1, 3));\n        // Test inserting a column the very beginning.\n        grid.insert_column(0, vec![1, 4, 7]);\n        assert_eq!(grid.size(), size!(2, 3));\n        assert_eq!(grid[coord!(0, 0)], 1);\n        assert_eq!(grid[coord!(0, 1)], 4);\n        assert_eq!(grid[coord!(0, 2)], 7);\n        assert_eq!(grid.capacity(), size!(2, 3));\n        // Test inserting a column at the very end\n        grid.insert_column(2, vec![3, 6, 9]);\n        assert_eq!(grid.size(), size!(3, 3));\n        assert_eq!(grid[coord!(2, 0)], 3);\n        assert_eq!(grid[coord!(2, 1)], 6);\n        assert_eq!(grid[coord!(2, 2)], 9);\n        assert_eq!(grid.capacity(), size!(3, 3));\n        assert_eq!(grid[coord!(1, 0)], 2);\n        assert_eq!(grid[coord!(1, 1)], 5);\n        assert_eq!(grid[coord!(1, 2)], 8);\n"]], "pred": {"ppl": 1.5744346380233765, "ppl_lower": 1.60837984085083, "ppl/lowercase_ppl": -1.046995573429105, "ppl/zlib": 0.0016445516226481207, "Min_5.0% Prob": 5.626788980082462, "Min_10.0% Prob": 3.8006842889283834, "Min_20.0% Prob": 2.204346391323366, "Min_30.0% Prob": 1.50384812452223, "Min_40.0% Prob": 1.1365135645226034, "Min_50.0% Prob": 0.907233753122758, "Min_60.0% Prob": 0.7576653421927324}}
{"hexsha": "7f557e340bbc8caa4ae4983f9a1ffcbf60c55928", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn const_field<'tcx>(\n    tcx: TyCtxt<'tcx>,\n    param_env: ty::ParamEnv<'tcx>,\n    variant: Option<VariantIdx>,\n    field: mir::Field,\n    value: &'tcx ty::Const<'tcx>,\n) -> ConstValue<'tcx> {\n    trace!(\"const_field: {:?}, {:?}\", field, value);\n    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n    // get the operand again\n    let op = ecx.eval_const_to_op(value, None).unwrap();\n    // downcast\n    let down = match variant {\n        None => op,\n        Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n    };\n    // then project\n    let field = ecx.operand_field(down, field.index()).unwrap();\n    // and finally move back to the const world, always normalizing because\n    // this is not called for statics.\n    op_to_const(&ecx, field)\n}", "item_id": 0, "repo": "mendess/rust", "file": "src/librustc_mir/const_eval/mod.rs", "last_update_at": "2020-05-22T02:14:15+00:00", "question_id": "7f557e340bbc8caa4ae4983f9a1ffcbf60c55928_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn const_field<'tcx>(\n    tcx: TyCtxt<'tcx>,\n    param_env: ty::ParamEnv<'tcx>,\n    variant: Option<VariantIdx>,\n    field: mir::Field,\n    value: &'tcx ty::Const<'tcx>,\n) -> ConstValue<'tcx> {\n    trace!(\"const_field: {:?}, {:?}\", field, value);\n    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n    // get the operand again\n    let op = ecx.eval_const_to_op(value, None).unwrap();\n    // downcast\n    let down = match variant {\n        None => op,\n        Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n    };\n    // then project\n    let field = ecx.operand_field(down, field.index()).unwrap();\n    // and finally move back to the const world, always normalizing because\n    // this is not called for statics.\n    op_to_const(&ecx, field)\n"]], "pred": {"ppl": 2.7889256477355957, "ppl_lower": 3.9767820835113525, "ppl/lowercase_ppl": -1.3459409060825631, "ppl/zlib": 0.0024655203105231247, "Min_5.0% Prob": 7.250811686882606, "Min_10.0% Prob": 5.687699220798634, "Min_20.0% Prob": 4.161860011242054, "Min_30.0% Prob": 3.143575621239933, "Min_40.0% Prob": 2.4869140789464668, "Min_50.0% Prob": 2.0334392217574297, "Min_60.0% Prob": 1.7052494278407575}}
{"hexsha": "d95dd70278fa85917675234c0873306aae2a5311", "ext": "rs", "lang": "Rust", "content": "fn k_neighs_to_color_pattern(\n    k_neighs: &[(SignedCoord2D, MapId)],\n    outside_color: image::Rgba<u8>,\n    source_maps: &[ImageBuffer<'_>],\n    pattern: &mut ColorPattern,\n    is_wrap_mode: bool,\n) {\n    pattern.0.resize(k_neighs.len() * 4, 0);\n    let mut i = 0;\n\n    let wrap_dim = (\n        source_maps[0].dimensions().0 as i32,\n        source_maps[0].dimensions().1 as i32,\n    );\n\n    for (n_coord, n_map) in k_neighs {\n        let coord = if is_wrap_mode {\n            n_coord.wrap(wrap_dim)\n        } else {\n            *n_coord\n        };\n\n        let end = i + 4;\n\n        //check if he haven't gone outside the possible bounds\n        if source_maps[n_map.0 as usize].is_in_bounds(coord) {\n            pattern.0[i..end].copy_from_slice(\n                &(source_maps[n_map.0 as usize])\n                    .get_pixel(coord.x as u32, coord.y as u32)\n                    .0[..4],\n            )\n        } else {\n            // if we have gone out of bounds, then just fill as outside color\n            pattern.0[i..end].copy_from_slice(&outside_color.0[..]);\n        }\n\n        i = end;\n    }\n}", "item_id": 0, "repo": "belzecue/texture-synthesis", "file": "lib/src/multires_stochastic_texture_synthesis.rs", "last_update_at": "2020-09-15T15:49:49+00:00", "question_id": "d95dd70278fa85917675234c0873306aae2a5311_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn k_neighs_to_color_pattern(\n    k_neighs: &[(SignedCoord2D, MapId)],\n    outside_color: image::Rgba<u8>,\n    source_maps: &[ImageBuffer<'_>],\n    pattern: &mut ColorPattern,\n    is_wrap_mode: bool,\n) {\n    pattern.0.resize(k_neighs.len() * 4, 0);\n    let mut i = 0;\n    let wrap_dim = (\n        source_maps[0].dimensions().0 as i32,\n        source_maps[0].dimensions().1 as i32,\n    );\n    for (n_coord, n_map) in k_neighs {\n        let coord = if is_wrap_mode {\n            n_coord.wrap(wrap_dim)\n        } else {\n            *n_coord\n        };\n        let end = i + 4;\n        //check if he haven't gone outside the possible bounds\n        if source_maps[n_map.0 as usize].is_in_bounds(coord) {\n            pattern.0[i..end].copy_from_slice(\n                &(source_maps[n_map.0 as usize])\n                    .get_pixel(coord.x as u32, coord.y as u32)\n                    .0[..4],\n            )\n        } else {\n            // if we have gone out of bounds, then just fill as outside color\n            pattern.0[i..end].copy_from_slice(&outside_color.0[..]);\n        }\n        i = end;\n    }\n"]], "pred": {"ppl": 2.5920333862304688, "ppl_lower": 2.803675413131714, "ppl/lowercase_ppl": -1.0824076329731325, "ppl/zlib": 0.0019967351339564474, "Min_5.0% Prob": 8.445883202552796, "Min_10.0% Prob": 6.158436644077301, "Min_20.0% Prob": 4.1430083807603815, "Min_30.0% Prob": 3.028945026583359, "Min_40.0% Prob": 2.351152405142784, "Min_50.0% Prob": 1.9018249434108536, "Min_60.0% Prob": 1.5885424519565945}}
{"hexsha": "f58e2d5926d0996b99f5c3c7a5590c917f489ca5", "ext": "rs", "lang": "Rust", "content": "fn test_error_parsing_custom_fields() {\n        let data = \"\\\nfoo,bar,baz\nFoo,1,3\n\";\n        // ugly: Can deserialize_dow_field take a DeRecordWrap instead to add field info?\n        let expected = \"error parsing test.txt:2 - day of week field was not 0 or 1\";\n\n        let reader = csv::Reader::from_reader(data.as_bytes());\n        let mut iter: GTFSIterator<_, Test> = GTFSIterator::new(reader, \"test.txt\").unwrap();\n\n        let result = iter.next().unwrap().err().unwrap();\n        assert_eq!(expected, format!(\"{}\", result));\n    }", "item_id": 2, "repo": "dabreegster/transitfeed", "file": "src/gtfs/gtfs.rs", "last_update_at": "2020-07-06T21:31:03+00:00", "question_id": "f58e2d5926d0996b99f5c3c7a5590c917f489ca5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_error_parsing_custom_fields() {\n        let data = \"\\\nfoo,bar,baz\nFoo,1,3\n\";\n        // ugly: Can deserialize_dow_field take a DeRecordWrap instead to add field info?\n        let expected = \"error parsing test.txt:2 - day of week field was not 0 or 1\";\n        let reader = csv::Reader::from_reader(data.as_bytes());\n        let mut iter: GTFSIterator<_, Test> = GTFSIterator::new(reader, \"test.txt\").unwrap();\n        let result = iter.next().unwrap().err().unwrap();\n        assert_eq!(expected, format!(\"{}\", result));\n"]], "pred": {"ppl": 6.685702323913574, "ppl_lower": 8.526630401611328, "ppl/lowercase_ppl": -1.1280140358693629, "ppl/zlib": 0.005900531877976588, "Min_5.0% Prob": 9.253346681594849, "Min_10.0% Prob": 7.86210371466244, "Min_20.0% Prob": 6.289947937516605, "Min_30.0% Prob": 5.232358287362492, "Min_40.0% Prob": 4.368970967390958, "Min_50.0% Prob": 3.660014871288748, "Min_60.0% Prob": 3.123026823880626}}
{"hexsha": "d95862217fc3082ff8159cc4424b31f9b7645c45", "ext": "rs", "lang": "Rust", "content": "fn new_seed(rng: &mut StdRng) -> [u8; 32] {\n    let mut seed = [0; 32];\n    for i in 0..32 {\n        seed[i] = rng.gen::<u8>();\n    }\n    seed\n}", "item_id": 13, "repo": "10XGenomics/souporcell", "file": "souporcell/src/main.rs", "last_update_at": "2020-09-10T00:21:39+00:00", "question_id": "d95862217fc3082ff8159cc4424b31f9b7645c45_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_seed(rng: &mut StdRng) -> [u8; 32] {\n    let mut seed = [0; 32];\n    for i in 0..32 {\n        seed[i] = rng.gen::<u8>();\n    }\n    seed\n"]], "pred": {"ppl": 1.7360037565231323, "ppl_lower": 2.41191029548645, "ppl/lowercase_ppl": -1.5961598702512236, "ppl/zlib": 0.00463517462295488, "Min_5.0% Prob": 7.79326868057251, "Min_10.0% Prob": 4.589853388922555, "Min_20.0% Prob": 2.704511765922819, "Min_30.0% Prob": 1.867801709544091, "Min_40.0% Prob": 1.377771451812366, "Min_50.0% Prob": 1.1153700920856662, "Min_60.0% Prob": 0.9352681921513448}}
{"hexsha": "02704e40c6a83ae2cae2f20eeca4199dda28e947", "ext": "rs", "lang": "Rust", "content": "fn ignite_client_start_with_config() {\n    setup();\n\n    let mut cfg = ClientConfiguration::new();\n    cfg.set_endpoints(\"127.0.0.1:10800\").unwrap();\n\n    run_async(\n        async {\n            let mut node = start_test_node(\"default.xml\").await.unwrap();\n\n            IgniteClient::start(cfg).await.unwrap();\n\n            node.stop().unwrap();\n        },\n    );\n}", "item_id": 0, "repo": "isapego/ignite-rust", "file": "tests/ignite_client_test.rs", "last_update_at": "2020-06-01T12:30:45+00:00", "question_id": "02704e40c6a83ae2cae2f20eeca4199dda28e947_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ignite_client_start_with_config() {\n    setup();\n    let mut cfg = ClientConfiguration::new();\n    cfg.set_endpoints(\"127.0.0.1:10800\").unwrap();\n    run_async(\n        async {\n            let mut node = start_test_node(\"default.xml\").await.unwrap();\n            IgniteClient::start(cfg).await.unwrap();\n            node.stop().unwrap();\n        },\n    );\n"]], "pred": {"ppl": 3.9981000423431396, "ppl_lower": 5.049097061157227, "ppl/lowercase_ppl": -1.1684131369764217, "ppl/zlib": 0.006662592590684949, "Min_5.0% Prob": 8.502463261286417, "Min_10.0% Prob": 7.068142135938008, "Min_20.0% Prob": 5.364919036626816, "Min_30.0% Prob": 4.14407679438591, "Min_40.0% Prob": 3.315556043138107, "Min_50.0% Prob": 2.73347892810901, "Min_60.0% Prob": 2.307393608200881}}
{"hexsha": "155365430052eb4ba4596e5d22c7aef1ed2b0670", "ext": "rs", "lang": "Rust", "content": "fn start_udp_thread(udp_addr: &str, sender: Sender<ServerMessage>) -> JoinHandle<()> {\n    println!(\"[udp] Starting UDP server at {}\", udp_addr);\n    let socket = UdpSocket::bind(udp_addr).expect(\"[udp] Unable to create UDP socket!\");\n\n    thread::spawn(move || loop {\n        let mut buf = [0; MAX_PACKET_SIZE];\n        let (len, source) = socket.recv_from(&mut buf).unwrap();\n        // println!(\"[udp] recv {} B\", len);\n\n        let slice = &(buf)[0..len];\n\n        let message = ServerMessage::Binary {\n            ip: source.ip(),\n            data: slice.to_owned(),\n        };\n\n        sender\n            .send(message)\n            .expect(\"[udp] Packet receiver gone. Exiting thread.\");\n    })\n}", "item_id": 1, "repo": "teistiz/effectserver2-rs", "file": "src/server/mod.rs", "last_update_at": "2020-01-18T16:24:23+00:00", "question_id": "155365430052eb4ba4596e5d22c7aef1ed2b0670_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn start_udp_thread(udp_addr: &str, sender: Sender<ServerMessage>) -> JoinHandle<()> {\n    println!(\"[udp] Starting UDP server at {}\", udp_addr);\n    let socket = UdpSocket::bind(udp_addr).expect(\"[udp] Unable to create UDP socket!\");\n    thread::spawn(move || loop {\n        let mut buf = [0; MAX_PACKET_SIZE];\n        let (len, source) = socket.recv_from(&mut buf).unwrap();\n        // println!(\"[udp] recv {} B\", len);\n        let slice = &(buf)[0..len];\n        let message = ServerMessage::Binary {\n            ip: source.ip(),\n            data: slice.to_owned(),\n        };\n        sender\n            .send(message)\n            .expect(\"[udp] Packet receiver gone. Exiting thread.\");\n    })\n"]], "pred": {"ppl": 2.4744796752929688, "ppl_lower": 3.0172948837280273, "ppl/lowercase_ppl": -1.2189006140827796, "ppl/zlib": 0.00234722834640908, "Min_5.0% Prob": 7.017830805345015, "Min_10.0% Prob": 5.436094392429698, "Min_20.0% Prob": 3.7934726503160263, "Min_30.0% Prob": 2.8561026357552586, "Min_40.0% Prob": 2.243310898045699, "Min_50.0% Prob": 1.8081655127812275, "Min_60.0% Prob": 1.508898062973886}}
{"hexsha": "ba8eafbbc9189bc8b50af16030a21b28079e843c", "ext": "rs", "lang": "Rust", "content": "fn process_pattern<'a>(lines: impl Iterator<Item=&'a str>) -> TreePattern {\n    let mut peekable_lines = lines.peekable();\n    let row_width = peekable_lines.peek().unwrap().len();\n    let tree_index_rows: Vec<HashSet<usize>> = peekable_lines.map(|line| \n        line.char_indices().filter_map(|(idx, space)| {\n            if space == TREE { Some(idx) }\n            else { None }\n        }).collect()\n    ).collect();\n\n    TreePattern { tree_index_rows, row_width }\n}", "item_id": 0, "repo": "Harrison-M/aoc2020", "file": "day03/src/main.rs", "last_update_at": "2020-12-24T21:56:05+00:00", "question_id": "ba8eafbbc9189bc8b50af16030a21b28079e843c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn process_pattern<'a>(lines: impl Iterator<Item=&'a str>) -> TreePattern {\n    let mut peekable_lines = lines.peekable();\n    let row_width = peekable_lines.peek().unwrap().len();\n    let tree_index_rows: Vec<HashSet<usize>> = peekable_lines.map(|line| \n        line.char_indices().filter_map(|(idx, space)| {\n            if space == TREE { Some(idx) }\n            else { None }\n        }).collect()\n    ).collect();\n    TreePattern { tree_index_rows, row_width }\n"]], "pred": {"ppl": 2.7884228229522705, "ppl_lower": 3.675513505935669, "ppl/lowercase_ppl": -1.2693545975318365, "ppl/zlib": 0.0038991488196202543, "Min_5.0% Prob": 8.463872637067523, "Min_10.0% Prob": 6.965880982081095, "Min_20.0% Prob": 4.6831433018048605, "Min_30.0% Prob": 3.269933137556781, "Min_40.0% Prob": 2.5385099268350446, "Min_50.0% Prob": 2.0374832869350135, "Min_60.0% Prob": 1.7129272077151614}}
{"hexsha": "b39b77a7eb46da74aaa8104ef037461c1db3d62d", "ext": "rs", "lang": "Rust", "content": "pub fn fmt_align_fraction_strings(strings: &[&str]) -> Vec<String> {\n    // normalize all fractional parts\n    let strings = strings.iter()\n        .map(|x| normalize_fraction_part(x))\n        .collect::<Vec<&str>>();\n\n    let max = strings.iter()\n        .map(|x| get_whole_part(x))\n        .map(|x| x.len())\n        .max()\n        .unwrap();\n\n    // create n new strings\n    let mut new_strings = vec![String::new(); strings.len()];\n    strings.iter().enumerate().for_each(|(index, string)| {\n        let whole_part = get_whole_part(string);\n        let spaces = max - whole_part.len();\n        new_strings[index].push_str(&\" \".repeat(spaces));\n        new_strings[index].push_str(string);\n    });\n\n    // now add spaces in the end so that all are exactly same aligned, on left\n    // as well as right; technically this is not really needed, but it may\n    // help in some situations. Also this can be easily revoked with a right trim.\n    let max = new_strings.iter().map(|s| s.len()).max().unwrap();\n    for string in &mut new_strings {\n        let spaces = max - string.len();\n        string.push_str(&\" \".repeat(spaces))\n    }\n\n    new_strings\n}", "item_id": 1, "repo": "phip1611/fraction_list_fmt_align", "file": "src/lib.rs", "last_update_at": "2020-12-09T20:52:13+00:00", "question_id": "b39b77a7eb46da74aaa8104ef037461c1db3d62d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fmt_align_fraction_strings(strings: &[&str]) -> Vec<String> {\n    // normalize all fractional parts\n    let strings = strings.iter()\n        .map(|x| normalize_fraction_part(x))\n        .collect::<Vec<&str>>();\n    let max = strings.iter()\n        .map(|x| get_whole_part(x))\n        .map(|x| x.len())\n        .max()\n        .unwrap();\n    // create n new strings\n    let mut new_strings = vec![String::new(); strings.len()];\n    strings.iter().enumerate().for_each(|(index, string)| {\n        let whole_part = get_whole_part(string);\n        let spaces = max - whole_part.len();\n        new_strings[index].push_str(&\" \".repeat(spaces));\n        new_strings[index].push_str(string);\n    });\n    // now add spaces in the end so that all are exactly same aligned, on left\n    // as well as right; technically this is not really needed, but it may\n    // help in some situations. Also this can be easily revoked with a right trim.\n    let max = new_strings.iter().map(|s| s.len()).max().unwrap();\n    for string in &mut new_strings {\n        let spaces = max - string.len();\n        string.push_str(&\" \".repeat(spaces))\n    }\n    new_strings\n"]], "pred": {"ppl": 2.7921197414398193, "ppl_lower": 2.9932572841644287, "ppl/lowercase_ppl": -1.067745464793202, "ppl/zlib": 0.0021041005559747326, "Min_5.0% Prob": 7.661511084612678, "Min_10.0% Prob": 6.043690552030291, "Min_20.0% Prob": 4.24391414246089, "Min_30.0% Prob": 3.211459808192163, "Min_40.0% Prob": 2.5157791625865746, "Min_50.0% Prob": 2.041042883702543, "Min_60.0% Prob": 1.7132068503945366}}
{"hexsha": "37860bbce24be581e99cbef37a3061d9a9423a1f", "ext": "rs", "lang": "Rust", "content": "fn as_deref_cow_box_str_borrowed() {\n        let tmp = Box::from(\"bar\");\n        let input: Cow<Box<str>> = Cow::Borrowed(&tmp);\n        let output: Cow<str> = as_deref_cow(input);\n\n        assert!(matches!(output, Cow::Borrowed(_)));\n        assert_eq!(output, \"bar\");\n    }", "item_id": 3, "repo": "scileo/butcher", "file": "butcher/src/as_deref.rs", "last_update_at": "2020-09-21T05:13:25+00:00", "question_id": "37860bbce24be581e99cbef37a3061d9a9423a1f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn as_deref_cow_box_str_borrowed() {\n        let tmp = Box::from(\"bar\");\n        let input: Cow<Box<str>> = Cow::Borrowed(&tmp);\n        let output: Cow<str> = as_deref_cow(input);\n        assert!(matches!(output, Cow::Borrowed(_)));\n        assert_eq!(output, \"bar\");\n"]], "pred": {"ppl": 3.102238178253174, "ppl_lower": 4.403234481811523, "ppl/lowercase_ppl": -1.3093438392529253, "ppl/zlib": 0.0072572041279772076, "Min_5.0% Prob": 7.892659068107605, "Min_10.0% Prob": 6.314430501725939, "Min_20.0% Prob": 4.369523198981034, "Min_30.0% Prob": 3.3965866483491043, "Min_40.0% Prob": 2.714634039463141, "Min_50.0% Prob": 2.236614233985239, "Min_60.0% Prob": 1.8866814680523791}}
{"hexsha": "85718803d8cbe5d92c3b56bf3d3d9e18c1bac244", "ext": "rs", "lang": "Rust", "content": "fn get_public_key() {\n    let core = test_core_with_account();\n    let account = core.get_account().unwrap();\n\n    let result =\n        api_service::request(&account, GetPublicKeyRequest { username: account.username.clone() })\n            .unwrap()\n            .key;\n    assert_eq!(result, account.public_key());\n}", "item_id": 0, "repo": "lockbook/client", "file": "core/tests/get_public_key_tests.rs", "last_update_at": "2020-01-22T00:29:21+00:00", "question_id": "85718803d8cbe5d92c3b56bf3d3d9e18c1bac244_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_public_key() {\n    let core = test_core_with_account();\n    let account = core.get_account().unwrap();\n    let result =\n        api_service::request(&account, GetPublicKeyRequest { username: account.username.clone() })\n            .unwrap()\n            .key;\n    assert_eq!(result, account.public_key());\n"]], "pred": {"ppl": 4.702857494354248, "ppl_lower": 6.255692005157471, "ppl/lowercase_ppl": -1.1842959190915245, "ppl/zlib": 0.008413969029862694, "Min_5.0% Prob": 8.821281552314758, "Min_10.0% Prob": 7.4575850698682995, "Min_20.0% Prob": 5.71341343720754, "Min_30.0% Prob": 4.492338432206048, "Min_40.0% Prob": 3.63541735874282, "Min_50.0% Prob": 3.0081773512893255, "Min_60.0% Prob": 2.5577756508632943}}
{"hexsha": "c2c03b030e425445ac11f1c3ff7d2f895cfe7571", "ext": "rs", "lang": "Rust", "content": "fn part2(input: &(Vec<u32>, Vec<Board>)) -> u32 {\n    let (rnd, mut boards) = input.clone();\n    let mut winning_board = Vec::new();\n    for &n in rnd.iter() {\n        let mut winers = Vec::new();\n        for (id, b) in boards.iter_mut().enumerate() {\n            let set = update_board(b, n);\n            if check_vicotry(set, b) {\n                winers.push(id);\n            }\n        }\n        winers.iter().rev().for_each(|&id| {\n            let b = boards.remove(id);\n            let score = compute_score(&b, n);\n            winning_board.push(score);\n        })\n    }\n    *winning_board.last().expect(\"No one won!\")\n}", "item_id": 2, "repo": "ithinuel/advent-of-code-rust", "file": "src/day4.rs", "last_update_at": "2020-12-06T21:07:43+00:00", "question_id": "c2c03b030e425445ac11f1c3ff7d2f895cfe7571_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn part2(input: &(Vec<u32>, Vec<Board>)) -> u32 {\n    let (rnd, mut boards) = input.clone();\n    let mut winning_board = Vec::new();\n    for &n in rnd.iter() {\n        let mut winers = Vec::new();\n        for (id, b) in boards.iter_mut().enumerate() {\n            let set = update_board(b, n);\n            if check_vicotry(set, b) {\n                winers.push(id);\n            }\n        }\n        winers.iter().rev().for_each(|&id| {\n            let b = boards.remove(id);\n            let score = compute_score(&b, n);\n            winning_board.push(score);\n        })\n    }\n    *winning_board.last().expect(\"No one won!\")\n"]], "pred": {"ppl": 2.4849495887756348, "ppl_lower": 2.7211036682128906, "ppl/lowercase_ppl": -1.0997362796574988, "ppl/zlib": 0.003024094262909755, "Min_5.0% Prob": 7.708504295349121, "Min_10.0% Prob": 5.746157532646542, "Min_20.0% Prob": 3.888591993422735, "Min_30.0% Prob": 2.890290023788573, "Min_40.0% Prob": 2.2281484390006345, "Min_50.0% Prob": 1.8137622152999886, "Min_60.0% Prob": 1.5224947899756}}
{"hexsha": "6b1a2a90288e389127e6ba06a661e5314aca06b8", "ext": "rs", "lang": "Rust", "content": "fn allocate_for_10_sec(c: &mut Criterion<BytesAllocated>) {\n    let mut group = c.benchmark_group(\"allocate multi thread for 10 sec\");\n    group.sample_size(10);\n    group.warm_up_time(Duration::from_secs(1));\n    for threads in 0..3 {\n        group.throughput(Throughput::Elements(1 << threads));\n        group.bench_with_input(\n            BenchmarkId::new(\"lrmalloc-rs\", 1 << threads),\n            &(1 << threads as usize),\n            |b, &size| {\n                b.iter_custom(|_iters| {\n                    let mut vec = Vec::with_capacity(size);\n                    let output = BytesAllocated;\n                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));\n                    for _ in 0..size {\n                        let b = bytes_allocated.clone();\n                        vec.push(thread::spawn(move || {\n                            let mut temp = Vec::with_capacity(10000);\n\n                            let start = Instant::now();\n                            while start.elapsed().as_secs() < 10 {\n                                temp.push(AutoPtr::new(0usize));\n                                let mut guard = b.lock().unwrap();\n                                *guard += 8;\n                            }\n                        }));\n                    }\n                    for join in vec {\n                        join.join().unwrap();\n                    }\n                    let ret = (*bytes_allocated.lock().unwrap()).clone();\n                    output.end(ret)\n                });\n            },\n        );\n    }\n    for threads in 0..3 {\n        group.throughput(Throughput::Elements(1 << threads));\n        group.bench_with_input(\n            BenchmarkId::new(\"native\", 1 << threads),\n            &(1 << threads as usize),\n            |b, &size| {\n                let ptrs = Arc::new(Mutex::new(Vec::new()));\n                b.iter_custom(|_iters| {\n                    let mut vec = Vec::with_capacity(size);\n                    let output = BytesAllocated;\n                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));\n                    for _ in 0..size {\n                        let clone = ptrs.clone();\n                        let b = bytes_allocated.clone();\n                        vec.push(thread::spawn(move || {\n                            let mut temp = Vec::with_capacity(10000);\n\n                            let start = Instant::now();\n                            while start.elapsed().as_secs() < 10 {\n                                temp.push(Box::new(0usize));\n                                let mut guard = b.lock().unwrap();\n                                *guard += 8;\n                            }\n                            clone.lock().unwrap().extend(temp)\n                        }));\n                    }\n                    for join in vec {\n                        join.join().unwrap();\n                    }\n                    let ret = (*bytes_allocated.lock().unwrap()).clone();\n                    output.end(ret)\n                });\n            },\n        );\n    }\n}", "item_id": 0, "repo": "JoshuaRadin37/apfmalloc", "file": "benches/timed_allocation.rs", "last_update_at": "2020-06-16T20:34:44+00:00", "question_id": "6b1a2a90288e389127e6ba06a661e5314aca06b8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn allocate_for_10_sec(c: &mut Criterion<BytesAllocated>) {\n    let mut group = c.benchmark_group(\"allocate multi thread for 10 sec\");\n    group.sample_size(10);\n    group.warm_up_time(Duration::from_secs(1));\n    for threads in 0..3 {\n        group.throughput(Throughput::Elements(1 << threads));\n        group.bench_with_input(\n            BenchmarkId::new(\"lrmalloc-rs\", 1 << threads),\n            &(1 << threads as usize),\n            |b, &size| {\n                b.iter_custom(|_iters| {\n                    let mut vec = Vec::with_capacity(size);\n                    let output = BytesAllocated;\n                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));\n                    for _ in 0..size {\n                        let b = bytes_allocated.clone();\n                        vec.push(thread::spawn(move || {\n                            let mut temp = Vec::with_capacity(10000);\n                            let start = Instant::now();\n                            while start.elapsed().as_secs() < 10 {\n                                temp.push(AutoPtr::new(0usize));\n                                let mut guard = b.lock().unwrap();\n                                *guard += 8;\n                            }\n                        }));\n                    }\n                    for join in vec {\n                        join.join().unwrap();\n                    }\n                    let ret = (*bytes_allocated.lock().unwrap()).clone();\n                    output.end(ret)\n                });\n            },\n        );\n    }\n    for threads in 0..3 {\n        group.throughput(Throughput::Elements(1 << threads));\n        group.bench_with_input(\n            BenchmarkId::new(\"native\", 1 << threads),\n            &(1 << threads as usize),\n            |b, &size| {\n                let ptrs = Arc::new(Mutex::new(Vec::new()));\n                b.iter_custom(|_iters| {\n                    let mut vec = Vec::with_capacity(size);\n                    let output = BytesAllocated;\n                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));\n                    for _ in 0..size {\n                        let clone = ptrs.clone();\n                        let b = bytes_allocated.clone();\n                        vec.push(thread::spawn(move || {\n                            let mut temp = Vec::with_capacity(10000);\n                            let start = Instant::now();\n                            while start.elapsed().as_secs() < 10 {\n                                temp.push(Box::new(0usize));\n                                let mut guard = b.lock().unwrap();\n                                *guard += 8;\n                            }\n                            clone.lock().unwrap().extend(temp)\n                        }));\n                    }\n                    for join in vec {\n                        join.join().unwrap();\n                    }\n                    let ret = (*bytes_allocated.lock().unwrap()).clone();\n                    output.end(ret)\n                });\n            },\n        );\n    }\n"]], "pred": {"ppl": 1.6660898923873901, "ppl_lower": 1.8833318948745728, "ppl/lowercase_ppl": -1.2400938599283884, "ppl/zlib": 0.0007988724558752171, "Min_5.0% Prob": 6.315129935741425, "Min_10.0% Prob": 4.229389671926145, "Min_20.0% Prob": 2.450915467775898, "Min_30.0% Prob": 1.6837110159757696, "Min_40.0% Prob": 1.2722801386700644, "Min_50.0% Prob": 1.019975912006411, "Min_60.0% Prob": 0.8505696857129147}}
{"hexsha": "0e02264fd82fb73065eaf1eae34bda43a1724784", "ext": "rs", "lang": "Rust", "content": "fn parse_triples<E: From<TurtleError>>(\n    parser: &mut TurtleParser<impl BufRead>,\n    on_triple: &mut impl FnMut(Triple<'_>) -> Result<(), E>,\n) -> Result<(), E> {\n    // [6] \ttriples \t::= \tsubject predicateObjectList | blankNodePropertyList predicateObjectList?\n    match parser.read.current() {\n        Some(b'[') if !is_followed_by_space_and_closing_bracket(&mut parser.read)? => {\n            let id = parse_blank_node_property_list(parser, on_triple)?;\n            parser.triple_alloc.try_push_subject(|b| {\n                b.push_str(id.as_ref());\n                Ok(Subject::from(BlankNode { id: b }))\n            })?;\n            skip_whitespace(&mut parser.read)?;\n            if parser.read.current() != Some(b'.') && parser.read.current() != Some(b'}') {\n                parse_predicate_object_list(parser, on_triple)?;\n            }\n        }\n        _ => {\n            parse_subject(parser, on_triple)?;\n            skip_whitespace(&mut parser.read)?;\n            parse_predicate_object_list(parser, on_triple)?;\n        }\n    }\n\n    parser.triple_alloc.pop_subject();\n    Ok(())\n}", "item_id": 10, "repo": "Tpt/rio", "file": "turtle/src/turtle.rs", "last_update_at": "2020-02-13T16:21:53+00:00", "question_id": "0e02264fd82fb73065eaf1eae34bda43a1724784_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_triples<E: From<TurtleError>>(\n    parser: &mut TurtleParser<impl BufRead>,\n    on_triple: &mut impl FnMut(Triple<'_>) -> Result<(), E>,\n) -> Result<(), E> {\n    // [6] \ttriples \t::= \tsubject predicateObjectList | blankNodePropertyList predicateObjectList?\n    match parser.read.current() {\n        Some(b'[') if !is_followed_by_space_and_closing_bracket(&mut parser.read)? => {\n            let id = parse_blank_node_property_list(parser, on_triple)?;\n            parser.triple_alloc.try_push_subject(|b| {\n                b.push_str(id.as_ref());\n                Ok(Subject::from(BlankNode { id: b }))\n            })?;\n            skip_whitespace(&mut parser.read)?;\n            if parser.read.current() != Some(b'.') && parser.read.current() != Some(b'}') {\n                parse_predicate_object_list(parser, on_triple)?;\n            }\n        }\n        _ => {\n            parse_subject(parser, on_triple)?;\n            skip_whitespace(&mut parser.read)?;\n            parse_predicate_object_list(parser, on_triple)?;\n        }\n    }\n    parser.triple_alloc.pop_subject();\n    Ok(())\n"]], "pred": {"ppl": 2.3557350635528564, "ppl_lower": 3.1218719482421875, "ppl/lowercase_ppl": -1.3286211997351414, "ppl/zlib": 0.0019211946360167481, "Min_5.0% Prob": 6.1639805634816485, "Min_10.0% Prob": 4.995289736323887, "Min_20.0% Prob": 3.6395234829849668, "Min_30.0% Prob": 2.7173430274385924, "Min_40.0% Prob": 2.118315532906302, "Min_50.0% Prob": 1.706839668779419, "Min_60.0% Prob": 1.429053558805667}}
{"hexsha": "f974a1c32645636e2c2e4f5c45a0bc19fa4744a1", "ext": "rs", "lang": "Rust", "content": "pub fn default_alternative_prompt() -> BlockProducer {\n    let id = vec![\n        BlockProducer::Username(crate::block::Username::new()),\n        BlockProducer::Hostname(crate::block::Hostname::new()),\n    ];\n    let id = BlockProducer::Separated(crate::block::Separated::new(id).with_separator(\"@\"));\n    let path = BlockProducer::WorkingDirectory(\n        crate::block::WorkingDirectory::new().with_prefix(\"\"),\n    );\n    let info = vec![\n        id,\n        path,\n        BlockProducer::Elapsed(crate::block::Elapsed::new().with_prefix(\"\")),\n        BlockProducer::ExitCode(\n            crate::block::ExitCode::new().with_style(crate::color::CRIMSON).with_prefix(\"\")\n        ),\n    ];\n    let separated = crate::block::Separated::new(info);\n    let producer = BlockProducer::Sequence(crate::block::Sequence(vec![\n        BlockProducer::Separated(separated),\n        BlockProducer::Newline(crate::block::Newline),\n        BlockProducer::ExitStatusSymbol(\n            crate::block::ExitStatusSymbol::new(\"\u2192\")\n                .with_style(crate::color::DODGERBLUE)\n                .with_error_style(crate::color::CRIMSON),\n        ),\n        BlockProducer::Space(crate::block::Space),\n    ]));\n    BlockProducer::Styled(crate::block::Styled::new(producer).with_style(\n            Style::new().with_fg(crate::color::TEAL),\n    ))\n}", "item_id": 1, "repo": "stephaneyfx/eliprompt", "file": "src/config.rs", "last_update_at": "2020-09-07T07:29:29+00:00", "question_id": "f974a1c32645636e2c2e4f5c45a0bc19fa4744a1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn default_alternative_prompt() -> BlockProducer {\n    let id = vec![\n        BlockProducer::Username(crate::block::Username::new()),\n        BlockProducer::Hostname(crate::block::Hostname::new()),\n    ];\n    let id = BlockProducer::Separated(crate::block::Separated::new(id).with_separator(\"@\"));\n    let path = BlockProducer::WorkingDirectory(\n        crate::block::WorkingDirectory::new().with_prefix(\"\"),\n    );\n    let info = vec![\n        id,\n        path,\n        BlockProducer::Elapsed(crate::block::Elapsed::new().with_prefix(\"\")),\n        BlockProducer::ExitCode(\n            crate::block::ExitCode::new().with_style(crate::color::CRIMSON).with_prefix(\"\")\n        ),\n    ];\n    let separated = crate::block::Separated::new(info);\n    let producer = BlockProducer::Sequence(crate::block::Sequence(vec![\n        BlockProducer::Separated(separated),\n        BlockProducer::Newline(crate::block::Newline),\n        BlockProducer::ExitStatusSymbol(\n            crate::block::ExitStatusSymbol::new(\"\u2192\")\n                .with_style(crate::color::DODGERBLUE)\n                .with_error_style(crate::color::CRIMSON),\n        ),\n        BlockProducer::Space(crate::block::Space),\n    ]));\n    BlockProducer::Styled(crate::block::Styled::new(producer).with_style(\n            Style::new().with_fg(crate::color::TEAL),\n    ))\n"]], "pred": {"ppl": 2.5927999019622803, "ppl_lower": 2.9442408084869385, "ppl/lowercase_ppl": -1.1334182263636674, "ppl/zlib": 0.0023180981387680676, "Min_5.0% Prob": 7.819861817359924, "Min_10.0% Prob": 6.306059732669738, "Min_20.0% Prob": 4.200973457600697, "Min_30.0% Prob": 3.0809088767536226, "Min_40.0% Prob": 2.362999990313168, "Min_50.0% Prob": 1.8986428406519384, "Min_60.0% Prob": 1.5901426046293783}}
{"hexsha": "c22d1b390ddb37673011d48115f7eff877e8e036", "ext": "rs", "lang": "Rust", "content": "async fn retrieve_secret() -> ashpd::Result<Vec<u8>> {\n    let proxy = secret::SecretProxy::new().await?;\n\n    let (mut x1, x2) = std::os::unix::net::UnixStream::pair().unwrap();\n    proxy.retrieve_secret(&x2).await?;\n    drop(x2);\n    let mut buf = Vec::new();\n    x1.read_to_end(&mut buf)?;\n\n    Ok(buf)\n}", "item_id": 0, "repo": "bilelmoussaoui/libportal-rs", "file": "ashpd-demo/src/portals/desktop/secret.rs", "last_update_at": "2020-09-11T14:57:11+00:00", "question_id": "c22d1b390ddb37673011d48115f7eff877e8e036_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn retrieve_secret() -> ashpd::Result<Vec<u8>> {\n    let proxy = secret::SecretProxy::new().await?;\n    let (mut x1, x2) = std::os::unix::net::UnixStream::pair().unwrap();\n    proxy.retrieve_secret(&x2).await?;\n    drop(x2);\n    let mut buf = Vec::new();\n    x1.read_to_end(&mut buf)?;\n    Ok(buf)\n"]], "pred": {"ppl": 2.8997583389282227, "ppl_lower": 4.623566150665283, "ppl/lowercase_ppl": -1.438218007893266, "ppl/zlib": 0.00509391101490963, "Min_5.0% Prob": 9.586048316955566, "Min_10.0% Prob": 7.1808953501961446, "Min_20.0% Prob": 4.697983969812808, "Min_30.0% Prob": 3.4325396827289034, "Min_40.0% Prob": 2.646558614487344, "Min_50.0% Prob": 2.1396580267760714, "Min_60.0% Prob": 1.782842650786567}}
{"hexsha": "0d77e416beec73e8af5ac2311a94d63a5d5ff5e1", "ext": "rs", "lang": "Rust", "content": "fn search(query: web::Query<SearchQuery>) -> impl Responder {\n\n    let index_path = \"/tmp/pkgbuildsearch\";\n    let directory = std::path::Path::new(&index_path);\n    let index = Index::open_in_dir(directory).unwrap();\n    let schema = index.schema();\n    let pkgbuild = schema.get_field(\"pkgbuild\").unwrap();\n    let query_parser = QueryParser::new(schema.clone(), vec![pkgbuild], index.tokenizers().clone());\n\n    let now = Instant::now();\n    let index_query = query_parser.parse_query(&query.name.unwrap()).unwrap();\n    let searcher = index.reader().unwrap().searcher();\n\n\n    let top_docs = searcher.search(&index_query, &TopDocs::with_limit(10)).unwrap();\n\n    for (_score, doc_address) in top_docs {\n        let retrieved_doc = searcher.doc(doc_address).unwrap();\n        let foo = retrieved_doc.get_all(pkgbuild);\n        println!(\"{}\", &foo[0].text().unwrap());\n        //let values = retrieved_doc.get_all();\n        //println!(\"{}\", values[0].text);\n        println!(\"{}\", schema.to_json(&retrieved_doc));\n    }\n\n    /*\n    let results = match &query.name {\n        Some(name) => vec![name.clone()],\n        None => vec![],\n    };\n    */\n\n    HttpResponse::Ok().json(SearchResults {\n        results: results,\n    })\n}", "item_id": 0, "repo": "f0x52/pkgbuildsearch", "file": "src/searchweb.rs", "last_update_at": "2020-04-20T18:51:22+00:00", "question_id": "0d77e416beec73e8af5ac2311a94d63a5d5ff5e1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn search(query: web::Query<SearchQuery>) -> impl Responder {\n    let index_path = \"/tmp/pkgbuildsearch\";\n    let directory = std::path::Path::new(&index_path);\n    let index = Index::open_in_dir(directory).unwrap();\n    let schema = index.schema();\n    let pkgbuild = schema.get_field(\"pkgbuild\").unwrap();\n    let query_parser = QueryParser::new(schema.clone(), vec![pkgbuild], index.tokenizers().clone());\n    let now = Instant::now();\n    let index_query = query_parser.parse_query(&query.name.unwrap()).unwrap();\n    let searcher = index.reader().unwrap().searcher();\n    let top_docs = searcher.search(&index_query, &TopDocs::with_limit(10)).unwrap();\n    for (_score, doc_address) in top_docs {\n        let retrieved_doc = searcher.doc(doc_address).unwrap();\n        let foo = retrieved_doc.get_all(pkgbuild);\n        println!(\"{}\", &foo[0].text().unwrap());\n        //let values = retrieved_doc.get_all();\n        //println!(\"{}\", values[0].text);\n        println!(\"{}\", schema.to_json(&retrieved_doc));\n    }\n    /*\n    let results = match &query.name {\n        Some(name) => vec![name.clone()],\n        None => vec![],\n    };\n    */\n    HttpResponse::Ok().json(SearchResults {\n        results: results,\n    })\n"]], "pred": {"ppl": 2.3479373455047607, "ppl_lower": 2.9925451278686523, "ppl/lowercase_ppl": -1.2842137592814555, "ppl/zlib": 0.0016043932658130254, "Min_5.0% Prob": 7.178492872338546, "Min_10.0% Prob": 5.419346646258705, "Min_20.0% Prob": 3.63505588707171, "Min_30.0% Prob": 2.6613936102704, "Min_40.0% Prob": 2.073967584359803, "Min_50.0% Prob": 1.6875358220778014, "Min_60.0% Prob": 1.4183248455325763}}
{"hexsha": "d1690e4a393b78e39d79bd99061eab7595c2d2ec", "ext": "rs", "lang": "Rust", "content": "fn integer_float_greater_than_other() {\n        let mut instructions = InstructionSetBuilder::new();\n        instructions.start_expression(\"main\");\n\n        instructions.put(ExpressionValue::integer(20)).unwrap();\n        instructions.put(ExpressionValue::float(10.0)).unwrap();\n        instructions.perform_greater_than_or_equal_comparison();\n\n        instructions.end_expression();\n\n        let mut expression_runtime = ExpressionRuntime::new(&instructions);\n\n        let result = expression_runtime.execute(\"main\").unwrap();\n\n        assert_eq!(result.as_symbol().unwrap(), expression_runtime.true_value);\n    }", "item_id": 167, "repo": "garnish-lang/garnish-core", "file": "runtime/src/comparison.rs", "last_update_at": "2020-04-28T12:34:05+00:00", "question_id": "d1690e4a393b78e39d79bd99061eab7595c2d2ec_167", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn integer_float_greater_than_other() {\n        let mut instructions = InstructionSetBuilder::new();\n        instructions.start_expression(\"main\");\n        instructions.put(ExpressionValue::integer(20)).unwrap();\n        instructions.put(ExpressionValue::float(10.0)).unwrap();\n        instructions.perform_greater_than_or_equal_comparison();\n        instructions.end_expression();\n        let mut expression_runtime = ExpressionRuntime::new(&instructions);\n        let result = expression_runtime.execute(\"main\").unwrap();\n        assert_eq!(result.as_symbol().unwrap(), expression_runtime.true_value);\n"]], "pred": {"ppl": 2.7334401607513428, "ppl_lower": 3.524770498275757, "ppl/lowercase_ppl": -1.2528483029577115, "ppl/zlib": 0.0038380188856491602, "Min_5.0% Prob": 8.220555850437709, "Min_10.0% Prob": 6.172715791066488, "Min_20.0% Prob": 4.04857212497342, "Min_30.0% Prob": 3.03984797634977, "Min_40.0% Prob": 2.395037779732356, "Min_50.0% Prob": 1.9697934160881405, "Min_60.0% Prob": 1.6779704883377602}}
{"hexsha": "e7d7b502848317667755dcd4eb696832bf81644b", "ext": "rs", "lang": "Rust", "content": "fn settings_box() -> gtk::Box {\n    let b = gtk::Box::new(gtk::Orientation::Vertical, 12);\n    b.set_margin_start(12);\n    b.set_margin_end(12);\n    b\n}", "item_id": 2, "repo": "lockbook/client", "file": "clients/linux/src/app/imp_settings_dialog.rs", "last_update_at": "2020-01-22T00:29:21+00:00", "question_id": "e7d7b502848317667755dcd4eb696832bf81644b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn settings_box() -> gtk::Box {\n    let b = gtk::Box::new(gtk::Orientation::Vertical, 12);\n    b.set_margin_start(12);\n    b.set_margin_end(12);\n    b\n"]], "pred": {"ppl": 2.2186779975891113, "ppl_lower": 2.906385660171509, "ppl/lowercase_ppl": -1.3388064279164595, "ppl/zlib": 0.0069296654080364785, "Min_5.0% Prob": 8.99547004699707, "Min_10.0% Prob": 6.513705293337504, "Min_20.0% Prob": 3.729104784818796, "Min_30.0% Prob": 2.647391907478634, "Min_40.0% Prob": 1.9758095798584132, "Min_50.0% Prob": 1.6142686812090687, "Min_60.0% Prob": 1.3270417944265482}}
{"hexsha": "7fa28a5dba5e22a5347cc52f57cafb812f339909", "ext": "rs", "lang": "Rust", "content": "fn test_abstract_unix_stream() {\n        let name = generate_random_abstract_addr();\n\n        let listener = unix_stream_abstract_bind(&name).unwrap();\n\n        let mut remote = unix_stream_abstract_connect(&name).unwrap();\n        let (mut client, _addr) = listener.accept().unwrap();\n\n        let mut prefixed_name = OsString::from(\"\\0\");\n        prefixed_name.push(name);\n\n        assert_eq!(\n            get_unix_listener_raw_sockname(&listener).unwrap(),\n            prefixed_name,\n        );\n\n        assert_eq!(\n            get_unix_stream_raw_sockname(&remote).unwrap(),\n            OsString::new(),\n        );\n        assert_eq!(\n            get_unix_stream_raw_peername(&remote).unwrap(),\n            prefixed_name,\n        );\n\n        assert_eq!(\n            get_unix_stream_raw_sockname(&client).unwrap(),\n            prefixed_name,\n        );\n        assert_eq!(\n            get_unix_stream_raw_peername(&client).unwrap(),\n            OsString::new(),\n        );\n\n        let mut data = Vec::new();\n        data.resize(10, 0);\n\n        client.write_all(&[0, 1, 2, 3]).unwrap();\n        assert_eq!(remote.read(&mut data).unwrap(), 4);\n        assert_eq!(data[..4], [0, 1, 2, 3]);\n\n        remote.write_all(&[0, 1, 2, 3]).unwrap();\n        assert_eq!(client.read(&mut data).unwrap(), 4);\n        assert_eq!(data[..4], [0, 1, 2, 3]);\n    }", "item_id": 6, "repo": "cptpcrd/simple_libc", "file": "src/net/abstract_unix.rs", "last_update_at": "2020-08-29T02:29:49+00:00", "question_id": "7fa28a5dba5e22a5347cc52f57cafb812f339909_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_abstract_unix_stream() {\n        let name = generate_random_abstract_addr();\n        let listener = unix_stream_abstract_bind(&name).unwrap();\n        let mut remote = unix_stream_abstract_connect(&name).unwrap();\n        let (mut client, _addr) = listener.accept().unwrap();\n        let mut prefixed_name = OsString::from(\"\\0\");\n        prefixed_name.push(name);\n        assert_eq!(\n            get_unix_listener_raw_sockname(&listener).unwrap(),\n            prefixed_name,\n        );\n        assert_eq!(\n            get_unix_stream_raw_sockname(&remote).unwrap(),\n            OsString::new(),\n        );\n        assert_eq!(\n            get_unix_stream_raw_peername(&remote).unwrap(),\n            prefixed_name,\n        );\n        assert_eq!(\n            get_unix_stream_raw_sockname(&client).unwrap(),\n            prefixed_name,\n        );\n        assert_eq!(\n            get_unix_stream_raw_peername(&client).unwrap(),\n            OsString::new(),\n        );\n        let mut data = Vec::new();\n        data.resize(10, 0);\n        client.write_all(&[0, 1, 2, 3]).unwrap();\n        assert_eq!(remote.read(&mut data).unwrap(), 4);\n        assert_eq!(data[..4], [0, 1, 2, 3]);\n        remote.write_all(&[0, 1, 2, 3]).unwrap();\n        assert_eq!(client.read(&mut data).unwrap(), 4);\n        assert_eq!(data[..4], [0, 1, 2, 3]);\n"]], "pred": {"ppl": 1.735398530960083, "ppl_lower": 1.9022626876831055, "ppl/lowercase_ppl": -1.1665471718792235, "ppl/zlib": 0.0015227543863623476, "Min_5.0% Prob": 6.026638348897298, "Min_10.0% Prob": 4.3497572881834845, "Min_20.0% Prob": 2.6260967317749473, "Min_30.0% Prob": 1.8141130759613588, "Min_40.0% Prob": 1.3792922630029567, "Min_50.0% Prob": 1.1039806843665319, "Min_60.0% Prob": 0.9192275055452228}}
{"hexsha": "f25638d9067771249a900548652c42387f4bada2", "ext": "rs", "lang": "Rust", "content": "fn test_tile_next() {\n        assert_eq!(t(\"1m\").next(), t(\"2m\"));\n        assert_eq!(t(\"3p\").next(), t(\"4p\"));\n        assert_eq!(t(\"5s\").next(), t(\"6s\"));\n        assert_eq!(t(\"1z\").next(), t(\"2z\"));\n        assert_eq!(t(\"6z\").next(), t(\"7z\"));\n    }", "item_id": 6, "repo": "pauljxtan/toitoi", "file": "src/tile.rs", "last_update_at": "2020-09-27T16:30:42+00:00", "question_id": "f25638d9067771249a900548652c42387f4bada2_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_tile_next() {\n        assert_eq!(t(\"1m\").next(), t(\"2m\"));\n        assert_eq!(t(\"3p\").next(), t(\"4p\"));\n        assert_eq!(t(\"5s\").next(), t(\"6s\"));\n        assert_eq!(t(\"1z\").next(), t(\"2z\"));\n        assert_eq!(t(\"6z\").next(), t(\"7z\"));\n"]], "pred": {"ppl": 2.6772658824920654, "ppl_lower": 2.6772658824920654, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010366274533385275, "Min_5.0% Prob": 8.717630386352539, "Min_10.0% Prob": 6.566968083381653, "Min_20.0% Prob": 4.452789485454559, "Min_30.0% Prob": 3.2588752498229345, "Min_40.0% Prob": 2.4908833375200627, "Min_50.0% Prob": 1.9649747501620476, "Min_60.0% Prob": 1.6446174460264746}}
{"hexsha": "4bc307d018ac0d8c8acb83eeb8239039239cdee7", "ext": "rs", "lang": "Rust", "content": "fn error_overflow_subtraction_signed_negative() {\n    let input = r#\"\nfn main() {\n    let value = -42 - 100 as i8;\n}\n\"#;\n\n    let expected = Err(Error::Semantic(SemanticError::Element(\n        ElementError::Constant(ConstantError::Integer(\n            IntegerConstantError::OverflowSubtraction {\n                location: Location::test(3, 18),\n                value: BigInt::from(-142),\n                r#type: Type::integer(Some(Location::default()), true, zinc_const::bitlength::BYTE)\n                    .to_string(),\n            },\n        )),\n    )));\n\n    let result = crate::semantic::tests::compile_entry(input);\n\n    assert_eq!(result, expected);\n}", "item_id": 41, "repo": "tpscrpt/zinc", "file": "zinc-compiler/src/semantic/element/constant/integer/tests.rs", "last_update_at": "2020-11-14T03:11:05+00:00", "question_id": "4bc307d018ac0d8c8acb83eeb8239039239cdee7_41", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn error_overflow_subtraction_signed_negative() {\n    let input = r#\"\nfn main() {\n    let value = -42 - 100 as i8;\n}\n\"#;\n    let expected = Err(Error::Semantic(SemanticError::Element(\n        ElementError::Constant(ConstantError::Integer(\n            IntegerConstantError::OverflowSubtraction {\n                location: Location::test(3, 18),\n                value: BigInt::from(-142),\n                r#type: Type::integer(Some(Location::default()), true, zinc_const::bitlength::BYTE)\n                    .to_string(),\n            },\n        )),\n    )));\n    let result = crate::semantic::tests::compile_entry(input);\n    assert_eq!(result, expected);\n"]], "pred": {"ppl": 2.0614445209503174, "ppl_lower": 4.06827449798584, "ppl/lowercase_ppl": -1.939736592661137, "ppl/zlib": 0.0020787556345438817, "Min_5.0% Prob": 6.407165050506592, "Min_10.0% Prob": 4.778328871726989, "Min_20.0% Prob": 3.2272686660289764, "Min_30.0% Prob": 2.3510476936896643, "Min_40.0% Prob": 1.8142232834361494, "Min_50.0% Prob": 1.4444728228309662, "Min_60.0% Prob": 1.2071546465543306}}
{"hexsha": "f4f2bdee3209a0fbbf373c53ad5ea7497c0b3882", "ext": "rs", "lang": "Rust", "content": "pub fn setup_client(uri: &MobilecoindUri, logger: &Logger) -> MobilecoindApiClient {\n    let env = Arc::new(\n        EnvBuilder::new()\n            .name_prefix(\"gRPC-mobilecoind-tests\")\n            .build(),\n    );\n    let ch = ChannelBuilder::new(env).connect_to_uri(uri, logger);\n    MobilecoindApiClient::new(ch)\n}", "item_id": 6, "repo": "voloshyn/mobilecoin", "file": "mobilecoind/src/test_utils.rs", "last_update_at": "2020-10-02T19:51:57+00:00", "question_id": "f4f2bdee3209a0fbbf373c53ad5ea7497c0b3882_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn setup_client(uri: &MobilecoindUri, logger: &Logger) -> MobilecoindApiClient {\n    let env = Arc::new(\n        EnvBuilder::new()\n            .name_prefix(\"gRPC-mobilecoind-tests\")\n            .build(),\n    );\n    let ch = ChannelBuilder::new(env).connect_to_uri(uri, logger);\n    MobilecoindApiClient::new(ch)\n"]], "pred": {"ppl": 3.119917869567871, "ppl_lower": 5.0594940185546875, "ppl/lowercase_ppl": -1.424905050970354, "ppl/zlib": 0.005834906039069028, "Min_5.0% Prob": 9.774555206298828, "Min_10.0% Prob": 7.475343894958496, "Min_20.0% Prob": 4.954641407728195, "Min_30.0% Prob": 3.5737520821632875, "Min_40.0% Prob": 2.811282256754433, "Min_50.0% Prob": 2.256759819503014, "Min_60.0% Prob": 1.9041070821544817}}
{"hexsha": "1ee3254fb2902b809a045af1a11a6654ab97c1d8", "ext": "rs", "lang": "Rust", "content": "pub fn register(callsite: &'static dyn Callsite) {\n    let mut registry = REGISTRY.lock().unwrap();\n    registry.rebuild_callsite_interest(callsite);\n    registry.callsites.push(callsite);\n}", "item_id": 0, "repo": "mcheshkov/icfpc2020", "file": "vendor/tracing-core/src/callsite.rs", "last_update_at": "2020-07-17T17:24:03+00:00", "question_id": "1ee3254fb2902b809a045af1a11a6654ab97c1d8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn register(callsite: &'static dyn Callsite) {\n    let mut registry = REGISTRY.lock().unwrap();\n    registry.rebuild_callsite_interest(callsite);\n    registry.callsites.push(callsite);\n"]], "pred": {"ppl": 5.452775478363037, "ppl_lower": 7.014649391174316, "ppl/lowercase_ppl": -1.1485008650554815, "ppl/zlib": 0.012657647321867064, "Min_5.0% Prob": 9.830205917358398, "Min_10.0% Prob": 8.846057097117106, "Min_20.0% Prob": 6.71717369556427, "Min_30.0% Prob": 5.1168364021513195, "Min_40.0% Prob": 4.106496398647626, "Min_50.0% Prob": 3.3177286492240046, "Min_60.0% Prob": 2.8164824738695815}}
{"hexsha": "45bf57b5947e41372a9421485098ce660065bd34", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout___darwin_mcontext_avx512_32() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),\n        1112usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext_avx512_32))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),\n        4usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext_avx512_32))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize\n        },\n        12usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize\n        },\n        76usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n}", "item_id": 33, "repo": "AnderEnder/bzip2r", "file": "bzip2-sys/private_ffi.rs", "last_update_at": "2020-08-25T20:54:44+00:00", "question_id": "45bf57b5947e41372a9421485098ce660065bd34_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout___darwin_mcontext_avx512_32() {\n    assert_eq!(\n        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),\n        1112usize,\n        concat!(\"Size of: \", stringify!(__darwin_mcontext_avx512_32))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),\n        4usize,\n        concat!(\"Alignment of \", stringify!(__darwin_mcontext_avx512_32))\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize\n        },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__es)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize\n        },\n        12usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__ss)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize\n        },\n        76usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(__darwin_mcontext_avx512_32),\n            \"::\",\n            stringify!(__fs)\n        )\n    );\n"]], "pred": {"ppl": 1.1790287494659424, "ppl_lower": 1.2006096839904785, "ppl/lowercase_ppl": -1.1101365055639345, "ppl/zlib": 0.0005840106591384886, "Min_5.0% Prob": 3.1303586530685426, "Min_10.0% Prob": 1.6395314616315506, "Min_20.0% Prob": 0.8232447543642575, "Min_30.0% Prob": 0.5489467367383114, "Min_40.0% Prob": 0.41172284730298675, "Min_50.0% Prob": 0.3293808279677286, "Min_60.0% Prob": 0.27448468479970717}}
{"hexsha": "a7d785f3d9c0036eede0f2eda57b603734bb6a26", "ext": "rs", "lang": "Rust", "content": "fn lla_ecef_lla() {\n    println!(\"\");\n    println!(\"lla:   {:?}\", *TEST_LLA);\n    println!(\"ecef:  {:?}\", *TEST_ECEF);\n    let ecef2 = lla_to_ecef(&*TEST_LLA);\n    let lla2  = ecef_to_lla(&ecef2);\n    println!(\"ecef2: {:?}\", ecef2);\n    println!(\"lla2:  {:?}\", lla2);\n    assert_eq!(*TEST_LLA, lla2);\n}", "item_id": 2, "repo": "cubehub/rust-coordinate-conversion", "file": "src/test.rs", "last_update_at": "2020-03-08T20:22:13+00:00", "question_id": "a7d785f3d9c0036eede0f2eda57b603734bb6a26_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lla_ecef_lla() {\n    println!(\"\");\n    println!(\"lla:   {:?}\", *TEST_LLA);\n    println!(\"ecef:  {:?}\", *TEST_ECEF);\n    let ecef2 = lla_to_ecef(&*TEST_LLA);\n    let lla2  = ecef_to_lla(&ecef2);\n    println!(\"ecef2: {:?}\", ecef2);\n    println!(\"lla2:  {:?}\", lla2);\n    assert_eq!(*TEST_LLA, lla2);\n"]], "pred": {"ppl": 2.2053427696228027, "ppl_lower": 2.292875051498413, "ppl/lowercase_ppl": -1.0492153274041258, "ppl/zlib": 0.005307939247608347, "Min_5.0% Prob": 6.989520754132952, "Min_10.0% Prob": 5.501682911600385, "Min_20.0% Prob": 3.5173767681779533, "Min_30.0% Prob": 2.586303485687389, "Min_40.0% Prob": 1.9561896352418537, "Min_50.0% Prob": 1.5870951970832214, "Min_60.0% Prob": 1.3165204752150965}}
{"hexsha": "b23afc0340fb18d1a743462e609051c3d0abbc27", "ext": "rs", "lang": "Rust", "content": "fn find_commits_in_range(repo: &Repository, start: git2::Oid, end: git2::Oid) -> Vec<Commit> {\n    let mut commits: Vec<Commit> = Vec::new();\n    // list recent commits\n    let mut revwalk = repo.revwalk().expect(\"Failed to get revwalk\");\n\n    // left commit is hidden and right commit is shown.\n    let range = format!(\"{}..{}\", end, start);\n    revwalk.push_range(&range[..]).expect(\"Failed to push range\");\n\n    for oid in revwalk {\n        let oid = oid.expect(\"Failed to get oid\");\n        let commit = repo.find_commit(oid).expect(\"Failed to find the commit\");\n        commits.push(commit);\n    }\n\n    commits\n}", "item_id": 0, "repo": "hengfengli/gitrelease", "file": "src/main.rs", "last_update_at": "2020-02-09T13:04:23+00:00", "question_id": "b23afc0340fb18d1a743462e609051c3d0abbc27_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_commits_in_range(repo: &Repository, start: git2::Oid, end: git2::Oid) -> Vec<Commit> {\n    let mut commits: Vec<Commit> = Vec::new();\n    // list recent commits\n    let mut revwalk = repo.revwalk().expect(\"Failed to get revwalk\");\n    // left commit is hidden and right commit is shown.\n    let range = format!(\"{}..{}\", end, start);\n    revwalk.push_range(&range[..]).expect(\"Failed to push range\");\n    for oid in revwalk {\n        let oid = oid.expect(\"Failed to get oid\");\n        let commit = repo.find_commit(oid).expect(\"Failed to find the commit\");\n        commits.push(commit);\n    }\n    commits\n"]], "pred": {"ppl": 2.1822736263275146, "ppl_lower": 2.482665538787842, "ppl/lowercase_ppl": -1.1652625871848543, "ppl/zlib": 0.002636375949883096, "Min_5.0% Prob": 7.8863438500298395, "Min_10.0% Prob": 5.449861702166106, "Min_20.0% Prob": 3.4231264873554834, "Min_30.0% Prob": 2.434192418538291, "Min_40.0% Prob": 1.906166412420087, "Min_50.0% Prob": 1.544340632779082, "Min_60.0% Prob": 1.3001848072584332}}
{"hexsha": "89e4fa6ddbb83b75c88c2a34aded477bc0967a8d", "ext": "rs", "lang": "Rust", "content": "fn parse_panic() {\n        let line = \"8 10 abc\".to_string();\n        let (v1, v2, _): (usize, usize, f32) = parse_weighted_edge(line);\n        assert_eq!(v1, 8);\n        assert_eq!(v2, 10);\n    }", "item_id": 5, "repo": "kangxiaoning/algorithm-rust", "file": "src/graph/readgraph.rs", "last_update_at": "2020-06-26T14:03:26+00:00", "question_id": "89e4fa6ddbb83b75c88c2a34aded477bc0967a8d_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_panic() {\n        let line = \"8 10 abc\".to_string();\n        let (v1, v2, _): (usize, usize, f32) = parse_weighted_edge(line);\n        assert_eq!(v1, 8);\n        assert_eq!(v2, 10);\n"]], "pred": {"ppl": 3.875276565551758, "ppl_lower": 3.875276565551758, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010034200237138963, "Min_5.0% Prob": 9.772006273269653, "Min_10.0% Prob": 8.04572319984436, "Min_20.0% Prob": 5.795033782720566, "Min_30.0% Prob": 4.29387288570404, "Min_40.0% Prob": 3.381601327296459, "Min_50.0% Prob": 2.6935895166936374, "Min_60.0% Prob": 2.273178813531995}}
{"hexsha": "d37b0fe54b3361e47bfda2bcfdda3c4955aec490", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn keypair_signing_ok<A: AsymmetricKey + SigningAlgorithm>(\n        input: (KeyPair<A>, Vec<u8>),\n    ) -> bool\n    where\n        <A as AsymmetricKey>::PubAlg: VerificationAlgorithm,\n    {\n        let (sk, pk) = input.0.into_keys();\n        let data = input.1;\n\n        let signature = sk.sign(&data);\n        signature.verify(&pk, &data) == Verification::Success\n    }", "item_id": 0, "repo": "TenStrings/chain-libs", "file": "chain-crypto/src/sign.rs", "last_update_at": "2020-05-23T02:20:20+00:00", "question_id": "d37b0fe54b3361e47bfda2bcfdda3c4955aec490_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn keypair_signing_ok<A: AsymmetricKey + SigningAlgorithm>(\n        input: (KeyPair<A>, Vec<u8>),\n    ) -> bool\n    where\n        <A as AsymmetricKey>::PubAlg: VerificationAlgorithm,\n    {\n        let (sk, pk) = input.0.into_keys();\n        let data = input.1;\n        let signature = sk.sign(&data);\n        signature.verify(&pk, &data) == Verification::Success\n"]], "pred": {"ppl": 3.363285541534424, "ppl_lower": 4.521117687225342, "ppl/lowercase_ppl": -1.2439083444455294, "ppl/zlib": 0.005273557982363705, "Min_5.0% Prob": 7.326206684112549, "Min_10.0% Prob": 6.16345743338267, "Min_20.0% Prob": 4.769401359558105, "Min_30.0% Prob": 3.594736143162376, "Min_40.0% Prob": 2.8714275897717942, "Min_50.0% Prob": 2.3781859213486314, "Min_60.0% Prob": 2.0109343480367166}}
{"hexsha": "435e4f4feb6a349eda4478dc1f78333e18e5fbb3", "ext": "rs", "lang": "Rust", "content": "fn get_gradiants(blurred : &GrayImage, data : Arc<GrayImage>) -> Vec<(f64, f64)> {\n    let dims = blurred.dimensions();\n    let mut pool = simple_parallel::Pool::new(NUM_THREADS);\n    let dims = (dims.0 as usize , dims.1 as usize);\n    let CHUNK_SIZE = dims.0 * dims.1/ NUM_THREADS;\n    scope(|scope|{\n        pool.map(scope, blurred.chunks(CHUNK_SIZE).enumerate().zip(rpt(data)), |((thread_num, chunk), data)|{\n            chunk.into_iter().enumerate().map(|(i, _)|{\n                let x : i64 = ((CHUNK_SIZE * thread_num + i) % dims.0 ) as i64;\n                let y : i64 = ((CHUNK_SIZE * thread_num + i) / dims.0 ) as i64;\n                let mut gx = 0f64;\n                let mut gy = 0f64;\n                for c in -1..2 {\n                    for r in -1..2 {\n                        let (x, y) = (x + c, y + r);\n                        if (x > 0) && (x < dims.0 as i64) && (y > 0) && (y < dims.1 as i64) {\n                            let r = (r + 1) as usize;\n                            let c = (c + 1) as usize;\n                            let GX_FACTOR = GX[r][c];\n                            let GY_FACTOR = GY[r][c];\n                            let p = data[(x as u32, y as u32)];\n                            gx = gx + GX_FACTOR * p[0] as f64;\n                            gy = gy + GY_FACTOR * p[0] as f64;\n                        }\n                    }\n                }\n\n                let g = util::gradiant(gx,gy);\n                let angle = (gy).atan2(gx).to_degrees() + 180.0;\n                if util::round_angle(angle).is_nan() {\n                    println!(\"{}, {} -> {}\", gy, gx, util::round_angle(angle));\n                }\n                (g, util::round_angle(angle))\n            }).collect::<Vec<(f64, f64)>>()\n        }).flat_map(|x| x.into_iter()).collect()\n    })\n}", "item_id": 3, "repo": "sacooper/RustImageAlgos", "file": "src/canny.rs", "last_update_at": "2020-05-29T04:31:38+00:00", "question_id": "435e4f4feb6a349eda4478dc1f78333e18e5fbb3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_gradiants(blurred : &GrayImage, data : Arc<GrayImage>) -> Vec<(f64, f64)> {\n    let dims = blurred.dimensions();\n    let mut pool = simple_parallel::Pool::new(NUM_THREADS);\n    let dims = (dims.0 as usize , dims.1 as usize);\n    let CHUNK_SIZE = dims.0 * dims.1/ NUM_THREADS;\n    scope(|scope|{\n        pool.map(scope, blurred.chunks(CHUNK_SIZE).enumerate().zip(rpt(data)), |((thread_num, chunk), data)|{\n            chunk.into_iter().enumerate().map(|(i, _)|{\n                let x : i64 = ((CHUNK_SIZE * thread_num + i) % dims.0 ) as i64;\n                let y : i64 = ((CHUNK_SIZE * thread_num + i) / dims.0 ) as i64;\n                let mut gx = 0f64;\n                let mut gy = 0f64;\n                for c in -1..2 {\n                    for r in -1..2 {\n                        let (x, y) = (x + c, y + r);\n                        if (x > 0) && (x < dims.0 as i64) && (y > 0) && (y < dims.1 as i64) {\n                            let r = (r + 1) as usize;\n                            let c = (c + 1) as usize;\n                            let GX_FACTOR = GX[r][c];\n                            let GY_FACTOR = GY[r][c];\n                            let p = data[(x as u32, y as u32)];\n                            gx = gx + GX_FACTOR * p[0] as f64;\n                            gy = gy + GY_FACTOR * p[0] as f64;\n                        }\n                    }\n                }\n                let g = util::gradiant(gx,gy);\n                let angle = (gy).atan2(gx).to_degrees() + 180.0;\n                if util::round_angle(angle).is_nan() {\n                    println!(\"{}, {} -> {}\", gy, gx, util::round_angle(angle));\n                }\n                (g, util::round_angle(angle))\n            }).collect::<Vec<(f64, f64)>>()\n        }).flat_map(|x| x.into_iter()).collect()\n    })\n"]], "pred": {"ppl": 2.1443288326263428, "ppl_lower": 2.3498218059539795, "ppl/lowercase_ppl": -1.1199655237089479, "ppl/zlib": 0.0011575517524651288, "Min_5.0% Prob": 6.987938106060028, "Min_10.0% Prob": 5.150888200849295, "Min_20.0% Prob": 3.4020625228105588, "Min_30.0% Prob": 2.449297549951937, "Min_40.0% Prob": 1.882978972033184, "Min_50.0% Prob": 1.5185375592820807, "Min_60.0% Prob": 1.2717633485390814}}
{"hexsha": "2a5b818e4a462d51d4e5bb7836092beb7232643c", "ext": "rs", "lang": "Rust", "content": "fn create_reqwest_headers(\n    headers: &Vec<String>,\n) -> Result<reqwest::header::HeaderMap, Box<::std::error::Error>> {\n    let mut new_headers = reqwest::header::HeaderMap::new();\n\n    for head in headers {\n        let mut split_vect: Vec<&str> = head.split(\":\").collect();\n        let header_name = reqwest::header::HeaderName::from_bytes(split_vect[0].as_bytes())?;\n        let header_value = reqwest::header::HeaderValue::from_bytes(split_vect[1].as_bytes())?;\n\n        new_headers.insert(header_name, header_value);\n    }\n    Ok(new_headers)\n}", "item_id": 1, "repo": "ericmcbride/primarch", "file": "src/utils.rs", "last_update_at": "2020-03-20T10:27:19+00:00", "question_id": "2a5b818e4a462d51d4e5bb7836092beb7232643c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_reqwest_headers(\n    headers: &Vec<String>,\n) -> Result<reqwest::header::HeaderMap, Box<::std::error::Error>> {\n    let mut new_headers = reqwest::header::HeaderMap::new();\n    for head in headers {\n        let mut split_vect: Vec<&str> = head.split(\":\").collect();\n        let header_name = reqwest::header::HeaderName::from_bytes(split_vect[0].as_bytes())?;\n        let header_value = reqwest::header::HeaderValue::from_bytes(split_vect[1].as_bytes())?;\n        new_headers.insert(header_name, header_value);\n    }\n    Ok(new_headers)\n"]], "pred": {"ppl": 1.7334181070327759, "ppl_lower": 2.2965688705444336, "ppl/lowercase_ppl": -1.5114041128648057, "ppl/zlib": 0.002107644611597104, "Min_5.0% Prob": 6.677027808295356, "Min_10.0% Prob": 4.412936521901025, "Min_20.0% Prob": 2.642554899884595, "Min_30.0% Prob": 1.8285702722216095, "Min_40.0% Prob": 1.3720778259512496, "Min_50.0% Prob": 1.1045539556685222, "Min_60.0% Prob": 0.9231742989643554}}
{"hexsha": "e1a2afa1286ebedb732dbf8cbb2c5b57fa3c8ce4", "ext": "rs", "lang": "Rust", "content": "pub fn gru(vs: &super::var_store::Path, in_dim: i64, hidden_dim: i64, c: RNNConfig) -> GRU {\n    let num_directions = if c.bidirectional { 2 } else { 1 };\n    let gate_dim = 3 * hidden_dim;\n    let mut flat_weights = vec![];\n    for layer_idx in 0..c.num_layers {\n        for direction_idx in 0..num_directions {\n            let in_dim = if layer_idx == 0 {\n                in_dim\n            } else {\n                hidden_dim * num_directions\n            };\n            let suffix = if direction_idx == 1 { \"_reverse\" } else { \"\" };\n            let w_ih = vs.kaiming_uniform(\n                &format!(\"weight_ih_l{}{}\", layer_idx, suffix),\n                &[gate_dim, in_dim],\n            );\n            let w_hh = vs.kaiming_uniform(\n                &format!(\"weight_hh_l{}{}\", layer_idx, suffix),\n                &[gate_dim, hidden_dim],\n            );\n            flat_weights.push(w_ih);\n            flat_weights.push(w_hh);\n            if c.has_biases {\n                let b_ih = vs.zeros(&format!(\"bias_ih_l{}{}\", layer_idx, suffix), &[gate_dim]);\n                let b_hh = vs.zeros(&format!(\"bias_hh_l{}{}\", layer_idx, suffix), &[gate_dim]);\n                flat_weights.push(b_ih);\n                flat_weights.push(b_hh);\n            }\n        }\n    }\n    if vs.device().is_cuda() && crate::Cuda::cudnn_is_available() {\n        let _ = Tensor::internal_cudnn_rnn_flatten_weight(\n            &flat_weights,\n            4,\n            in_dim,\n            3, /* 3 for GRU see rnn.cpp in pytorch */\n            hidden_dim,\n            c.num_layers,\n            c.batch_first,\n            c.bidirectional,\n        );\n    }\n    GRU {\n        flat_weights,\n        hidden_dim,\n        config: c,\n        device: vs.device(),\n    }\n}", "item_id": 2, "repo": "Hakuyume/tch-rs", "file": "src/nn/rnn.rs", "last_update_at": "2020-08-15T18:16:20+00:00", "question_id": "e1a2afa1286ebedb732dbf8cbb2c5b57fa3c8ce4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn gru(vs: &super::var_store::Path, in_dim: i64, hidden_dim: i64, c: RNNConfig) -> GRU {\n    let num_directions = if c.bidirectional { 2 } else { 1 };\n    let gate_dim = 3 * hidden_dim;\n    let mut flat_weights = vec![];\n    for layer_idx in 0..c.num_layers {\n        for direction_idx in 0..num_directions {\n            let in_dim = if layer_idx == 0 {\n                in_dim\n            } else {\n                hidden_dim * num_directions\n            };\n            let suffix = if direction_idx == 1 { \"_reverse\" } else { \"\" };\n            let w_ih = vs.kaiming_uniform(\n                &format!(\"weight_ih_l{}{}\", layer_idx, suffix),\n                &[gate_dim, in_dim],\n            );\n            let w_hh = vs.kaiming_uniform(\n                &format!(\"weight_hh_l{}{}\", layer_idx, suffix),\n                &[gate_dim, hidden_dim],\n            );\n            flat_weights.push(w_ih);\n            flat_weights.push(w_hh);\n            if c.has_biases {\n                let b_ih = vs.zeros(&format!(\"bias_ih_l{}{}\", layer_idx, suffix), &[gate_dim]);\n                let b_hh = vs.zeros(&format!(\"bias_hh_l{}{}\", layer_idx, suffix), &[gate_dim]);\n                flat_weights.push(b_ih);\n                flat_weights.push(b_hh);\n            }\n        }\n    }\n    if vs.device().is_cuda() && crate::Cuda::cudnn_is_available() {\n        let _ = Tensor::internal_cudnn_rnn_flatten_weight(\n            &flat_weights,\n            4,\n            in_dim,\n            3, /* 3 for GRU see rnn.cpp in pytorch */\n            hidden_dim,\n            c.num_layers,\n            c.batch_first,\n            c.bidirectional,\n        );\n    }\n    GRU {\n        flat_weights,\n        hidden_dim,\n        config: c,\n        device: vs.device(),\n    }\n"]], "pred": {"ppl": 1.8918339014053345, "ppl_lower": 1.9809428453445435, "ppl/lowercase_ppl": -1.0721927362126564, "ppl/zlib": 0.0011011168857012535, "Min_5.0% Prob": 7.030140786335386, "Min_10.0% Prob": 4.8638834275048355, "Min_20.0% Prob": 2.955617812686953, "Min_30.0% Prob": 2.0839263412287865, "Min_40.0% Prob": 1.5850361810740212, "Min_50.0% Prob": 1.2733496872162253, "Min_60.0% Prob": 1.0622143055949274}}
{"hexsha": "862035a31be220b2f967be4209df3b38139b18f4", "ext": "rs", "lang": "Rust", "content": "fn gen_columns(options: Options) {\n    verify_columns(&options);\n    let columns = gen_columns_vec(&options);\n    let reply = Reply::ListColumns(columns);\n    let serialized = serialize(&reply, Infinite).unwrap();\n\n    let peer_reply = PeerReply::Response(0, Ok(Some(serialized)));\n    let peer_serialized = serialize(&peer_reply, Infinite).unwrap();\n\n    write(&options.output, &peer_serialized);\n}", "item_id": 1, "repo": "FCG-LLC/hyena-edge", "file": "hyena-api/src/bin/gen_test_out.rs", "last_update_at": "2020-07-03T20:15:48+00:00", "question_id": "862035a31be220b2f967be4209df3b38139b18f4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gen_columns(options: Options) {\n    verify_columns(&options);\n    let columns = gen_columns_vec(&options);\n    let reply = Reply::ListColumns(columns);\n    let serialized = serialize(&reply, Infinite).unwrap();\n    let peer_reply = PeerReply::Response(0, Ok(Some(serialized)));\n    let peer_serialized = serialize(&peer_reply, Infinite).unwrap();\n    write(&options.output, &peer_serialized);\n"]], "pred": {"ppl": 4.34896183013916, "ppl_lower": 5.5601582527160645, "ppl/lowercase_ppl": -1.1671428010018834, "ppl/zlib": 0.007538139266044621, "Min_5.0% Prob": 9.69956668217977, "Min_10.0% Prob": 7.933536330858867, "Min_20.0% Prob": 5.797068069378535, "Min_30.0% Prob": 4.444334072035712, "Min_40.0% Prob": 3.5571496997560774, "Min_50.0% Prob": 2.8930717081792894, "Min_60.0% Prob": 2.4502387510965}}
{"hexsha": "a0fb9c965c575c4711bf9568c3013f75f3d14af8", "ext": "rs", "lang": "Rust", "content": "fn generate_macos_bindings() {\n    let bindings = bindgen::Builder::default()\n        .header(\"./src/macos/bindings.h\")\n        .whitelist_function(\"_dyld_.*\")\n        .whitelist_type(\"mach_header.*\")\n        .whitelist_type(\"load_command.*\")\n        .whitelist_type(\"segment_command.*\")\n        .whitelist_var(\"MH_MAGIC.*\")\n        .whitelist_var(\"LC_SEGMENT.*\")\n        .generate()\n        .expect(\"Should generate macOS FFI bindings OK\");\n\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"macos_bindings.rs\"))\n        .expect(\"Should write macos_bindings.rs OK\");\n}", "item_id": 1, "repo": "robopsi/findshlibs", "file": "build.rs", "last_update_at": "2020-07-03T01:22:39+00:00", "question_id": "a0fb9c965c575c4711bf9568c3013f75f3d14af8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_macos_bindings() {\n    let bindings = bindgen::Builder::default()\n        .header(\"./src/macos/bindings.h\")\n        .whitelist_function(\"_dyld_.*\")\n        .whitelist_type(\"mach_header.*\")\n        .whitelist_type(\"load_command.*\")\n        .whitelist_type(\"segment_command.*\")\n        .whitelist_var(\"MH_MAGIC.*\")\n        .whitelist_var(\"LC_SEGMENT.*\")\n        .generate()\n        .expect(\"Should generate macOS FFI bindings OK\");\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"macos_bindings.rs\"))\n        .expect(\"Should write macos_bindings.rs OK\");\n"]], "pred": {"ppl": 1.7927885055541992, "ppl_lower": 2.286921262741089, "ppl/lowercase_ppl": -1.4170021129293016, "ppl/zlib": 0.0019394426313455418, "Min_5.0% Prob": 6.472976469993592, "Min_10.0% Prob": 4.6597809337434315, "Min_20.0% Prob": 2.7883225942766945, "Min_30.0% Prob": 1.9294383658812597, "Min_40.0% Prob": 1.461820085629307, "Min_50.0% Prob": 1.1711385337926379, "Min_60.0% Prob": 0.9754659435445201}}
{"hexsha": "acc1509cd17cfa153df2c3bab0cb054033a4514a", "ext": "rs", "lang": "Rust", "content": "fn count_bags(\n    lines: &[&str],\n    color: &str,\n    direction: Direction,\n    traverse_graph: fn(NodeIndex, &BagGraph) -> anyhow::Result<u64>,\n) -> anyhow::Result<u64> {\n    // build rules\n    let rules = lines\n        .iter()\n        .map(|rule| parse_rule(*rule))\n        .filter_map(Result::ok)\n        .collect::<Vec<_>>();\n\n    // build the graph, then traverse it\n    let graph = build_graph(&rules, direction)?;\n    let node_index = graph\n        .node_indices()\n        .find(|index| graph[*index].color == color)\n        .expect(\"Node not found\");\n\n    Ok(traverse_graph(node_index, &graph)?)\n}", "item_id": 2, "repo": "justahero/advent-of-code-2020", "file": "day-07/src/main.rs", "last_update_at": "2020-12-28T16:11:47+00:00", "question_id": "acc1509cd17cfa153df2c3bab0cb054033a4514a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn count_bags(\n    lines: &[&str],\n    color: &str,\n    direction: Direction,\n    traverse_graph: fn(NodeIndex, &BagGraph) -> anyhow::Result<u64>,\n) -> anyhow::Result<u64> {\n    // build rules\n    let rules = lines\n        .iter()\n        .map(|rule| parse_rule(*rule))\n        .filter_map(Result::ok)\n        .collect::<Vec<_>>();\n    // build the graph, then traverse it\n    let graph = build_graph(&rules, direction)?;\n    let node_index = graph\n        .node_indices()\n        .find(|index| graph[*index].color == color)\n        .expect(\"Node not found\");\n    Ok(traverse_graph(node_index, &graph)?)\n"]], "pred": {"ppl": 2.520923376083374, "ppl_lower": 3.365746021270752, "ppl/lowercase_ppl": -1.312585433043625, "ppl/zlib": 0.0028362737837084625, "Min_5.0% Prob": 7.210288858413696, "Min_10.0% Prob": 5.80676771402359, "Min_20.0% Prob": 3.973663219809532, "Min_30.0% Prob": 2.8962689022548864, "Min_40.0% Prob": 2.282190148109271, "Min_50.0% Prob": 1.8399880310776187, "Min_60.0% Prob": 1.5447287911885097}}
{"hexsha": "0562c4f89b1ec791019977a5891f3e5a0953d5f8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut buf = [0; 65535];\n    let mut out = [0; MAX_DATAGRAM_SIZE];\n\n    env_logger::builder()\n        .default_format_timestamp_nanos(true)\n        .init();\n\n    // Parse CLI parameters.\n    let docopt = docopt::Docopt::new(USAGE).unwrap();\n    let conn_args = CommonArgs::with_docopt(&docopt);\n    let args = ClientArgs::with_docopt(&docopt);\n\n    // Setup the event loop.\n    let poll = mio::Poll::new().unwrap();\n    let mut events = mio::Events::with_capacity(1024);\n\n    // We'll only connect to the first server provided in URL list.\n    let connect_url = &args.urls[0];\n\n    // Resolve server address.\n    let peer_addr = connect_url.to_socket_addrs().unwrap().next().unwrap();\n\n    // Bind to INADDR_ANY or IN6ADDR_ANY depending on the IP family of the\n    // server address. This is needed on macOS and BSD variants that don't\n    // support binding to IN6ADDR_ANY for both v4 and v6.\n    let bind_addr = match peer_addr {\n        std::net::SocketAddr::V4(_) => \"0.0.0.0:0\",\n        std::net::SocketAddr::V6(_) => \"[::]:0\",\n    };\n\n    // Create the UDP socket backing the QUIC connection, and register it with\n    // the event loop.\n    let socket = std::net::UdpSocket::bind(bind_addr).unwrap();\n    socket.connect(peer_addr).unwrap();\n\n    let socket = mio::net::UdpSocket::from_socket(socket).unwrap();\n    poll.register(\n        &socket,\n        mio::Token(0),\n        mio::Ready::readable(),\n        mio::PollOpt::edge(),\n    )\n    .unwrap();\n\n    // Create the configuration for the QUIC connection.\n    let mut config = quiche::Config::new(args.version).unwrap();\n\n    config.verify_peer(!args.no_verify);\n\n    config.set_application_protos(&conn_args.alpns).unwrap();\n\n    config.set_max_idle_timeout(30000);\n    config.set_max_udp_payload_size(MAX_DATAGRAM_SIZE as u64);\n    config.set_initial_max_data(conn_args.max_data);\n    config.set_initial_max_stream_data_bidi_local(conn_args.max_stream_data);\n    config.set_initial_max_stream_data_bidi_remote(conn_args.max_stream_data);\n    config.set_initial_max_stream_data_uni(conn_args.max_stream_data);\n    config.set_initial_max_streams_bidi(conn_args.max_streams_bidi);\n    config.set_initial_max_streams_uni(conn_args.max_streams_uni);\n    config.set_disable_active_migration(true);\n\n    let mut keylog = None;\n\n    if let Some(keylog_path) = std::env::var_os(\"SSLKEYLOGFILE\") {\n        let file = std::fs::OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(keylog_path)\n            .unwrap();\n\n        keylog = Some(file);\n\n        config.log_keys();\n    }\n\n    if conn_args.no_grease {\n        config.grease(false);\n    }\n\n    config\n        .set_cc_algorithm_name(&conn_args.cc_algorithm)\n        .unwrap();\n\n    if conn_args.disable_hystart {\n        config.enable_hystart(false);\n    }\n\n    if conn_args.dgrams_enabled {\n        config.enable_dgram(true, 1000, 1000);\n    }\n\n    let mut http_conn: Option<Box<dyn HttpConn>> = None;\n    let mut siduck_conn: Option<SiDuckConn> = None;\n    let mut webtrans_conn: Option<WebTransConn> = None;\n\n    let mut app_proto_selected = false;\n\n    // Generate a random source connection ID for the connection.\n    let mut scid = [0; quiche::MAX_CONN_ID_LEN];\n    SystemRandom::new().fill(&mut scid[..]).unwrap();\n\n    // Create a QUIC connection and initiate handshake.\n    let mut conn =\n        quiche::connect(connect_url.domain(), &scid, &mut config).unwrap();\n\n    if let Some(keylog) = &mut keylog {\n        if let Ok(keylog) = keylog.try_clone() {\n            conn.set_keylog(Box::new(keylog));\n        }\n    }\n\n    // Only bother with qlog if the user specified it.\n    #[cfg(feature = \"qlog\")]\n    {\n        if let Some(dir) = std::env::var_os(\"QLOGDIR\") {\n            let id = hex_dump(&scid);\n            let writer = make_qlog_writer(&dir, \"client\", &id);\n\n            conn.set_qlog(\n                std::boxed::Box::new(writer),\n                \"quiche-client qlog\".to_string(),\n                format!(\"{} id={}\", \"quiche-client qlog\", id),\n            );\n        }\n    }\n\n    info!(\n        \"connecting to {:} from {:} with scid {}\",\n        peer_addr,\n        socket.local_addr().unwrap(),\n        hex_dump(&scid)\n    );\n\n    let write = conn.send(&mut out).expect(\"initial send failed\");\n\n    while let Err(e) = socket.send(&out[..write]) {\n        if e.kind() == std::io::ErrorKind::WouldBlock {\n            trace!(\"send() would block\");\n            continue;\n        }\n\n        panic!(\"send() failed: {:?}\", e);\n    }\n\n    trace!(\"written {}\", write);\n\n    let app_data_start = std::time::Instant::now();\n\n    let mut pkt_count = 0;\n\n    loop {\n        poll.poll(&mut events, conn.timeout()).unwrap();\n\n        // Read incoming UDP packets from the socket and feed them to quiche,\n        // until there are no more packets to read.\n        'read: loop {\n            // If the event loop reported no events, it means that the timeout\n            // has expired, so handle it without attempting to read packets. We\n            // will then proceed with the send loop.\n            if events.is_empty() {\n                trace!(\"timed out\");\n\n                conn.on_timeout();\n\n                break 'read;\n            }\n\n            let len = match socket.recv(&mut buf) {\n                Ok(v) => v,\n\n                Err(e) => {\n                    // There are no more UDP packets to read, so end the read\n                    // loop.\n                    if e.kind() == std::io::ErrorKind::WouldBlock {\n                        trace!(\"recv() would block\");\n                        break 'read;\n                    }\n\n                    panic!(\"recv() failed: {:?}\", e);\n                },\n            };\n\n            trace!(\"got {} bytes\", len);\n\n            if let Some(target_path) = conn_args.dump_packet_path.as_ref() {\n                let path = format!(\"{}/{}.pkt\", target_path, pkt_count);\n\n                if let Ok(f) = std::fs::File::create(&path) {\n                    let mut f = std::io::BufWriter::new(f);\n                    f.write_all(&buf[..len]).ok();\n                }\n            }\n\n            pkt_count += 1;\n\n            // Process potentially coalesced packets.\n            let read = match conn.recv(&mut buf[..len]) {\n                Ok(v) => v,\n\n                Err(e) => {\n                    error!(\"recv failed: {:?}\", e);\n                    continue 'read;\n                },\n            };\n\n            trace!(\"processed {} bytes\", read);\n        }\n\n        trace!(\"done reading\");\n\n        if conn.is_closed() {\n            info!(\"connection closed, {:?}\", conn.stats());\n\n            if let Some(h_conn) = http_conn {\n                h_conn.report_incomplete(&app_data_start);\n            }\n\n            if let Some(si_conn) = siduck_conn {\n                si_conn.report_incomplete(&app_data_start);\n            }\n\n            break;\n        }\n\n        // Create a new application protocol session once the QUIC connection is\n        // established.\n        if conn.is_established() && !app_proto_selected {\n            // At this stage the ALPN negotiation succeeded and selected a\n            // single application protocol name. We'll use this to construct\n            // the correct type of HttpConn but `application_proto()`\n            // returns a slice, so we have to convert it to a str in order\n            // to compare to our lists of protocols. We `unwrap()` because\n            // we need the value and if something fails at this stage, there\n            // is not much anyone can do to recover.\n\n            let app_proto = conn.application_proto();\n            let app_proto = &std::str::from_utf8(&app_proto).unwrap();\n\n            if alpns::HTTP_09.contains(app_proto) {\n                http_conn =\n                    Some(Http09Conn::with_urls(&args.urls, args.reqs_cardinal));\n\n                app_proto_selected = true;\n            } else if alpns::HTTP_3.contains(app_proto) {\n                let dgram_sender = if conn_args.dgrams_enabled {\n                    Some(Http3DgramSender::new(\n                        conn_args.dgram_count,\n                        conn_args.dgram_data.clone(),\n                        0,\n                    ))\n                } else {\n                    None\n                };\n\n                http_conn = Some(Http3Conn::with_urls(\n                    &mut conn,\n                    &args.urls,\n                    args.reqs_cardinal,\n                    &args.req_headers,\n                    &args.body,\n                    &args.method,\n                    args.dump_json,\n                    dgram_sender,\n                ));\n\n                app_proto_selected = true;\n            } else if alpns::SIDUCK.contains(app_proto) {\n                siduck_conn = Some(SiDuckConn::new(\n                    conn_args.dgram_count,\n                    conn_args.dgram_data.clone(),\n                ));\n\n                app_proto_selected = true;\n            } else if alpns::QUICTRANSPORT.contains(app_proto) {\n                webtrans_conn = Some(WebTransConn::with_url(\n                    args.urls[0].clone(),\n                    conn_args.dgram_count,\n                    conn_args.dgram_data.clone(),\n                ));\n\n                app_proto_selected = true;\n            }\n        }\n\n        // If we have an HTTP connection, first issue the requests then\n        // process received data.\n        if let Some(h_conn) = http_conn.as_mut() {\n            h_conn.send_requests(&mut conn, &args.dump_response_path);\n            h_conn.handle_responses(&mut conn, &mut buf, &app_data_start);\n        }\n\n        // If we have a siduck connection, first issue the quacks then\n        // process received data.\n        if let Some(si_conn) = siduck_conn.as_mut() {\n            si_conn.send_quacks(&mut conn);\n            si_conn.handle_quack_acks(&mut conn, &mut buf, &app_data_start);\n        }\n\n        // If we have a webtransport connection, first issue stuff then process\n        // receeived data.\n        if let Some(webtrans_conn) = webtrans_conn.as_mut() {\n            webtrans_conn.send_client_indication(&mut conn);\n            webtrans_conn.send_datagrams(&mut conn);\n            webtrans_conn.send_honks(&mut conn);\n            webtrans_conn.handle_dgram_echoes(\n                &mut conn,\n                &mut buf,\n                &app_data_start,\n            );\n            webtrans_conn.handle_responses(&mut conn, &mut buf, &app_data_start);\n        }\n\n        // Generate outgoing QUIC packets and send them on the UDP socket, until\n        // quiche reports that there are no more packets to be sent.\n        loop {\n            let write = match conn.send(&mut out) {\n                Ok(v) => v,\n\n                Err(quiche::Error::Done) => {\n                    trace!(\"done writing\");\n                    break;\n                },\n\n                Err(e) => {\n                    error!(\"send failed: {:?}\", e);\n\n                    conn.close(false, 0x1, b\"fail\").ok();\n                    break;\n                },\n            };\n\n            if let Err(e) = socket.send(&out[..write]) {\n                if e.kind() == std::io::ErrorKind::WouldBlock {\n                    trace!(\"send() would block\");\n                    break;\n                }\n\n                panic!(\"send() failed: {:?}\", e);\n            }\n\n            trace!(\"written {}\", write);\n        }\n\n        if conn.is_closed() {\n            info!(\"connection closed, {:?}\", conn.stats());\n\n            if let Some(h_conn) = http_conn {\n                h_conn.report_incomplete(&app_data_start);\n            }\n\n            break;\n        }\n    }\n}", "item_id": 0, "repo": "LPardue/quiche", "file": "tools/apps/src/bin/quiche-client.rs", "last_update_at": "2020-07-13T15:58:18+00:00", "question_id": "0562c4f89b1ec791019977a5891f3e5a0953d5f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut buf = [0; 65535];\n    let mut out = [0; MAX_DATAGRAM_SIZE];\n    env_logger::builder()\n        .default_format_timestamp_nanos(true)\n        .init();\n    // Parse CLI parameters.\n    let docopt = docopt::Docopt::new(USAGE).unwrap();\n    let conn_args = CommonArgs::with_docopt(&docopt);\n    let args = ClientArgs::with_docopt(&docopt);\n    // Setup the event loop.\n    let poll = mio::Poll::new().unwrap();\n    let mut events = mio::Events::with_capacity(1024);\n    // We'll only connect to the first server provided in URL list.\n    let connect_url = &args.urls[0];\n    // Resolve server address.\n    let peer_addr = connect_url.to_socket_addrs().unwrap().next().unwrap();\n    // Bind to INADDR_ANY or IN6ADDR_ANY depending on the IP family of the\n    // server address. This is needed on macOS and BSD variants that don't\n    // support binding to IN6ADDR_ANY for both v4 and v6.\n    let bind_addr = match peer_addr {\n        std::net::SocketAddr::V4(_) => \"0.0.0.0:0\",\n        std::net::SocketAddr::V6(_) => \"[::]:0\",\n    };\n    // Create the UDP socket backing the QUIC connection, and register it with\n    // the event loop.\n    let socket = std::net::UdpSocket::bind(bind_addr).unwrap();\n    socket.connect(peer_addr).unwrap();\n    let socket = mio::net::UdpSocket::from_socket(socket).unwrap();\n    poll.register(\n        &socket,\n        mio::Token(0),\n        mio::Ready::readable(),\n        mio::PollOpt::edge(),\n    )\n    .unwrap();\n    // Create the configuration for the QUIC connection.\n    let mut config = quiche::Config::new(args.version).unwrap();\n    config.verify_peer(!args.no_verify);\n    config.set_application_protos(&conn_args.alpns).unwrap();\n    config.set_max_idle_timeout(30000);\n    config.set_max_udp_payload_size(MAX_DATAGRAM_SIZE as u64);\n    config.set_initial_max_data(conn_args.max_data);\n    config.set_initial_max_stream_data_bidi_local(conn_args.max_stream_data);\n    config.set_initial_max_stream_data_bidi_remote(conn_args.max_stream_data);\n    config.set_initial_max_stream_data_uni(conn_args.max_stream_data);\n    config.set_initial_max_streams_bidi(conn_args.max_streams_bidi);\n    config.set_initial_max_streams_uni(conn_args.max_streams_uni);\n    config.set_disable_active_migration(true);\n    let mut keylog = None;\n    if let Some(keylog_path) = std::env::var_os(\"SSLKEYLOGFILE\") {\n        let file = std::fs::OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(keylog_path)\n            .unwrap();\n        keylog = Some(file);\n        config.log_keys();\n    }\n    if conn_args.no_grease {\n        config.grease(false);\n    }\n    config\n        .set_cc_algorithm_name(&conn_args.cc_algorithm)\n        .unwrap();\n    if conn_args.disable_hystart {\n        config.enable_hystart(false);\n    }\n    if conn_args.dgrams_enabled {\n        config.enable_dgram(true, 1000, 1000);\n    }\n    let mut http_conn: Option<Box<dyn HttpConn>> = None;\n    let mut siduck_conn: Option<SiDuckConn> = None;\n    let mut webtrans_conn: Option<WebTransConn> = None;\n    let mut app_proto_selected = false;\n    // Generate a random source connection ID for the connection.\n    let mut scid = [0; quiche::MAX_CONN_ID_LEN];\n    SystemRandom::new().fill(&mut scid[..]).unwrap();\n    // Create a QUIC connection and initiate handshake.\n    let mut conn =\n        quiche::connect(connect_url.domain(), &scid, &mut config).unwrap();\n    if let Some(keylog) = &mut keylog {\n        if let Ok(keylog) = keylog.try_clone() {\n            conn.set_keylog(Box::new(keylog));\n        }\n    }\n    // Only bother with qlog if the user specified it.\n    #[cfg(feature = \"qlog\")]\n    {\n        if let Some(dir) = std::env::var_os(\"QLOGDIR\") {\n            let id = hex_dump(&scid);\n            let writer = make_qlog_writer(&dir, \"client\", &id);\n            conn.set_qlog(\n                std::boxed::Box::new(writer),\n                \"quiche-client qlog\".to_string(),\n                format!(\"{} id={}\", \"quiche-client qlog\", id),\n            );\n        }\n    }\n    info!(\n        \"connecting to {:} from {:} with scid {}\",\n        peer_addr,\n        socket.local_addr().unwrap(),\n        hex_dump(&scid)\n    );\n    let write = conn.send(&mut out).expect(\"initial send failed\");\n    while let Err(e) = socket.send(&out[..write]) {\n        if e.kind() == std::io::ErrorKind::WouldBlock {\n            trace!(\"send() would block\");\n            continue;\n        }\n        panic!(\"send() failed: {:?}\", e);\n    }\n    trace!(\"written {}\", write);\n    let app_data_start = std::time::Instant::now();\n    let mut pkt_count = 0;\n    loop {\n        poll.poll(&mut events, conn.timeout()).unwrap();\n        // Read incoming UDP packets from the socket and feed them to quiche,\n        // until there are no more packets to read.\n        'read: loop {\n            // If the event loop reported no events, it means that the timeout\n            // has expired, so handle it without attempting to read packets. We\n            // will then proceed with the send loop.\n            if events.is_empty() {\n                trace!(\"timed out\");\n                conn.on_timeout();\n                break 'read;\n            }\n            let len = match socket.recv(&mut buf) {\n                Ok(v) => v,\n                Err(e) => {\n                    // There are no more UDP packets to read, so end the read\n                    // loop.\n                    if e.kind() == std::io::ErrorKind::WouldBlock {\n                        trace!(\"recv() would block\");\n                        break 'read;\n                    }\n                    panic!(\"recv() failed: {:?}\", e);\n                },\n            };\n            trace!(\"got {} bytes\", len);\n            if let Some(target_path) = conn_args.dump_packet_path.as_ref() {\n                let path = format!(\"{}/{}.pkt\", target_path, pkt_count);\n                if let Ok(f) = std::fs::File::create(&path) {\n                    let mut f = std::io::BufWriter::new(f);\n                    f.write_all(&buf[..len]).ok();\n                }\n            }\n            pkt_count += 1;\n            // Process potentially coalesced packets.\n            let read = match conn.recv(&mut buf[..len]) {\n                Ok(v) => v,\n                Err(e) => {\n                    error!(\"recv failed: {:?}\", e);\n                    continue 'read;\n                },\n            };\n            trace!(\"processed {} bytes\", read);\n        }\n        trace!(\"done reading\");\n        if conn.is_closed() {\n            info!(\"connection closed, {:?}\", conn.stats());\n            if let Some(h_conn) = http_conn {\n                h_conn.report_incomplete(&app_data_start);\n            }\n            if let Some(si_conn) = siduck_conn {\n                si_conn.report_incomplete(&app_data_start);\n            }\n            break;\n        }\n        // Create a new application protocol session once the QUIC connection is\n        // established.\n        if conn.is_established() && !app_proto_selected {\n            // At this stage the ALPN negotiation succeeded and selected a\n            // single application protocol name. We'll use this to construct\n            // the correct type of HttpConn but `application_proto()`\n            // returns a slice, so we have to convert it to a str in order\n            // to compare to our lists of protocols. We `unwrap()` because\n            // we need the value and if something fails at this stage, there\n            // is not much anyone can do to recover.\n            let app_proto = conn.application_proto();\n            let app_proto = &std::str::from_utf8(&app_proto).unwrap();\n            if alpns::HTTP_09.contains(app_proto) {\n                http_conn =\n                    Some(Http09Conn::with_urls(&args.urls, args.reqs_cardinal));\n                app_proto_selected = true;\n            } else if alpns::HTTP_3.contains(app_proto) {\n                let dgram_sender = if conn_args.dgrams_enabled {\n                    Some(Http3DgramSender::new(\n                        conn_args.dgram_count,\n                        conn_args.dgram_data.clone(),\n                        0,\n                    ))\n                } else {\n                    None\n                };\n                http_conn = Some(Http3Conn::with_urls(\n                    &mut conn,\n                    &args.urls,\n                    args.reqs_cardinal,\n                    &args.req_headers,\n                    &args.body,\n                    &args.method,\n                    args.dump_json,\n                    dgram_sender,\n                ));\n                app_proto_selected = true;\n            } else if alpns::SIDUCK.contains(app_proto) {\n                siduck_conn = Some(SiDuckConn::new(\n                    conn_args.dgram_count,\n                    conn_args.dgram_data.clone(),\n                ));\n                app_proto_selected = true;\n            } else if alpns::QUICTRANSPORT.contains(app_proto) {\n                webtrans_conn = Some(WebTransConn::with_url(\n                    args.urls[0].clone(),\n                    conn_args.dgram_count,\n                    conn_args.dgram_data.clone(),\n                ));\n                app_proto_selected = true;\n            }\n        }\n        // If we have an HTTP connection, first issue the requests then\n        // process received data.\n        if let Some(h_conn) = http_conn.as_mut() {\n            h_conn.send_requests(&mut conn, &args.dump_response_path);\n            h_conn.handle_responses(&mut conn, &mut buf, &app_data_start);\n        }\n        // If we have a siduck connection, first issue the quacks then\n        // process received data.\n        if let Some(si_conn) = siduck_conn.as_mut() {\n            si_conn.send_quacks(&mut conn);\n            si_conn.handle_quack_acks(&mut conn, &mut buf, &app_data_start);\n        }\n        // If we have a webtransport connection, first issue stuff then process\n        // receeived data.\n        if let Some(webtrans_conn) = webtrans_conn.as_mut() {\n            webtrans_conn.send_client_indication(&mut conn);\n            webtrans_conn.send_datagrams(&mut conn);\n            webtrans_conn.send_honks(&mut conn);\n            webtrans_conn.handle_dgram_echoes(\n                &mut conn,\n                &mut buf,\n                &app_data_start,\n            );\n            webtrans_conn.handle_responses(&mut conn, &mut buf, &app_data_start);\n        }\n        // Generate outgoing QUIC packets and send them on the UDP socket, until\n        // quiche reports that there are no more packets to be sent.\n        loop {\n            let write = match conn.send(&mut out) {\n                Ok(v) => v,\n                Err(quiche::Error::Done) => {\n                    trace!(\"done writing\");\n                    break;\n                },\n                Err(e) => {\n                    error!(\"send failed: {:?}\", e);\n                    conn.close(false, 0x1, b\"fail\").ok();\n                    break;\n                },\n            };\n            if let Err(e) = socket.send(&out[..write]) {\n                if e.kind() == std::io::ErrorKind::WouldBlock {\n                    trace!(\"send() would block\");\n                    break;\n                }\n                panic!(\"send() failed: {:?}\", e);\n            }\n            trace!(\"written {}\", write);\n        }\n        if conn.is_closed() {\n            info!(\"connection closed, {:?}\", conn.stats());\n            if let Some(h_conn) = http_conn {\n                h_conn.report_incomplete(&app_data_start);\n            }\n            break;\n        }\n    }\n"]], "pred": {"ppl": 1.5195837020874023, "ppl_lower": 2.056640863418579, "ppl/lowercase_ppl": -1.7232582382488308, "ppl/zlib": 0.0001257320964965432, "Min_5.0% Prob": 4.783873894635369, "Min_10.0% Prob": 3.2799579840080413, "Min_20.0% Prob": 1.9805073707419283, "Min_30.0% Prob": 1.3809153982042488, "Min_40.0% Prob": 1.043444150366563, "Min_50.0% Prob": 0.8371805939622908, "Min_60.0% Prob": 0.6982024106677344}}
{"hexsha": "d9e36f59ae1cb4330409c2bd19837d2013ac8458", "ext": "rs", "lang": "Rust", "content": "pub fn test_term_u64() {\n        let mut schema_builder = Schema::builder();\n        let count_field = schema_builder.add_u64_field(\"count\", INDEXED);\n        let term = Term::from_field_u64(count_field, 983u64);\n        assert_eq!(term.field(), count_field);\n        assert_eq!(term.typ(), Type::U64);\n        assert_eq!(term.as_slice().len(), super::FAST_VALUE_TERM_LEN);\n        assert_eq!(term.as_u64(), Some(983u64))\n    }", "item_id": 2, "repo": "StyMaar/tantivy", "file": "src/schema/term.rs", "last_update_at": "2020-09-02T17:49:27+00:00", "question_id": "d9e36f59ae1cb4330409c2bd19837d2013ac8458_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_term_u64() {\n        let mut schema_builder = Schema::builder();\n        let count_field = schema_builder.add_u64_field(\"count\", INDEXED);\n        let term = Term::from_field_u64(count_field, 983u64);\n        assert_eq!(term.field(), count_field);\n        assert_eq!(term.typ(), Type::U64);\n        assert_eq!(term.as_slice().len(), super::FAST_VALUE_TERM_LEN);\n        assert_eq!(term.as_u64(), Some(983u64))\n"]], "pred": {"ppl": 2.7399442195892334, "ppl_lower": 3.672346830368042, "ppl/lowercase_ppl": -1.290586807721181, "ppl/zlib": 0.004459900718489413, "Min_5.0% Prob": 9.58114515032087, "Min_10.0% Prob": 7.454371484120687, "Min_20.0% Prob": 4.780920684337616, "Min_30.0% Prob": 3.308922820902885, "Min_40.0% Prob": 2.5119085905570833, "Min_50.0% Prob": 2.0179478960418247, "Min_60.0% Prob": 1.6843015351185673}}
{"hexsha": "35e67874667ba915a65f0521157201b4621d6f1c", "ext": "rs", "lang": "Rust", "content": "fn ordered() {\n            let options = EncOptionSet::new(vec![\n                EncOption::HideMeta,\n                EncOption::Fast,\n                EncOption::PadSize,\n            ]);\n            let mut options_iter = options.iter();\n            assert_eq!(options_iter.next(), Some(&EncOption::Fast));\n            assert_eq!(options_iter.next(), Some(&EncOption::HideMeta));\n            assert_eq!(options_iter.next(), Some(&EncOption::PadSize));\n        }", "item_id": 0, "repo": "mverleg/file_endec", "file": "src/util/option.rs", "last_update_at": "2020-03-29T18:07:27+00:00", "question_id": "35e67874667ba915a65f0521157201b4621d6f1c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ordered() {\n            let options = EncOptionSet::new(vec![\n                EncOption::HideMeta,\n                EncOption::Fast,\n                EncOption::PadSize,\n            ]);\n            let mut options_iter = options.iter();\n            assert_eq!(options_iter.next(), Some(&EncOption::Fast));\n            assert_eq!(options_iter.next(), Some(&EncOption::HideMeta));\n            assert_eq!(options_iter.next(), Some(&EncOption::PadSize));\n"]], "pred": {"ppl": 2.7096505165100098, "ppl_lower": 3.2167723178863525, "ppl/lowercase_ppl": -1.172106160298308, "ppl/zlib": 0.00615320781406204, "Min_5.0% Prob": 8.613848288853964, "Min_10.0% Prob": 6.7961079676946, "Min_20.0% Prob": 4.593620533744494, "Min_30.0% Prob": 3.290518977575832, "Min_40.0% Prob": 2.5210401569493115, "Min_50.0% Prob": 1.9916210144330733, "Min_60.0% Prob": 1.6654698920295867}}
{"hexsha": "fb3c2a80f57eac3c9e182aba268833366b9795da", "ext": "rs", "lang": "Rust", "content": "pub fn apply(weights: &[[(([b64; 8], [b64; 8]), u32); 64]; 4], input: &[b64; 8]) -> [b64; 4] {\n    let mut target = [b64(0); 4];\n    for w in 0..4 {\n        for b in 0..64 {\n            let sign = masked_hamming_dist(input, &weights[w][b].0) > weights[w][b].1;\n            target[w].set_bit_in_place(b, sign);\n        }\n    }\n    target\n}", "item_id": 0, "repo": "is8ac/bnn", "file": "src/layer.rs", "last_update_at": "2020-08-15T17:22:02+00:00", "question_id": "fb3c2a80f57eac3c9e182aba268833366b9795da_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn apply(weights: &[[(([b64; 8], [b64; 8]), u32); 64]; 4], input: &[b64; 8]) -> [b64; 4] {\n    let mut target = [b64(0); 4];\n    for w in 0..4 {\n        for b in 0..64 {\n            let sign = masked_hamming_dist(input, &weights[w][b].0) > weights[w][b].1;\n            target[w].set_bit_in_place(b, sign);\n        }\n    }\n    target\n"]], "pred": {"ppl": 3.2995688915252686, "ppl_lower": 3.2995688915252686, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005823374736617997, "Min_5.0% Prob": 9.172459874834333, "Min_10.0% Prob": 7.362426026662191, "Min_20.0% Prob": 5.022973129826207, "Min_30.0% Prob": 3.722530612286101, "Min_40.0% Prob": 2.9028841408472212, "Min_50.0% Prob": 2.357495518613465, "Min_60.0% Prob": 1.9968080341498902}}
{"hexsha": "7392e796f420ee773a24d88ffc85f80979640067", "ext": "rs", "lang": "Rust", "content": "fn discover_plugins<P: AsRef<Path>>(base_dir: P) -> Result<Vec<Plugin>, Error> {\n    use std::fs;\n    use std::io::Read;\n\n    #[derive(Deserialize)]\n    struct Manifest {\n        triggers: Vec<CallbackTrigger>,\n        enabled: bool,\n    }\n\n    let base_dir = base_dir.as_ref();\n    debug!(\"discovering plugins in {}\", base_dir.display());\n    if !base_dir.exists() {\n        return Err(format_err!(\n            \"plugins directory {} not found\",\n            base_dir.display()\n        ));\n    }\n\n    let dir = fs::read_dir(base_dir)\n        .map_err(|e| format_err!(\"failed to open plugins directory: {}\", e))?;\n\n    trace!(\"discovering toml manifest files\");\n    let toml_file_paths = dir\n        .flat_map(|r| match r {\n            Ok(entry) => Some(entry),\n            Err(e) => {\n                warn!(\n                    \"failed to read item in the directory {}: {}\",\n                    base_dir.display(),\n                    e\n                );\n                None\n            }\n        })\n        .map(|d| d.path().to_path_buf())\n        .filter(|path| path.extension().map(|e| e == \"toml\").unwrap_or(false));\n\n    let mut plugins = Vec::new();\n    for toml_file_path in toml_file_paths {\n        let toml = toml_file_path\n            .to_str()\n            .expect(\"non-unicode paths are not supported\");\n        let plugin = toml.trim_right_matches(\".toml\");\n\n        debug!(\"probing manifest({}) and plugin({})\", toml, plugin);\n\n        // This block may throw errors, but we don't want to trow from the function\n        // in-place lambda will catch 'em all!\n        let result = || -> Result<Manifest, Error> {\n            let mut toml_file = fs::File::open(toml)?;\n            let mut contents = String::new();\n            toml_file.read_to_string(&mut contents)?;\n            Ok(toml::from_str(&contents)?)\n        }();\n\n        let manifest = match result {\n            Ok(manifest) => manifest,\n            Err(e) => {\n                warn!(\"failed to process plugin manifest at {}: {}\", toml, e);\n                continue;\n            }\n        };\n\n        // Check that plugin file exists\n        if !Path::new(plugin).exists() {\n            warn!(\n                \"plugin manifest found at {}, but there's no plugin file at {}\",\n                toml, plugin\n            );\n            continue;\n        }\n\n        // Skip loading disabled plugins\n        if !manifest.enabled {\n            warn!(\"plugin {} is disabled, skipping\", plugin);\n            continue;\n        }\n\n        for trigger in manifest.triggers {\n            plugins.push(Plugin {\n                trigger,\n                path: PathBuf::from(plugin),\n            })\n        }\n    }\n\n    Ok(plugins)\n}", "item_id": 0, "repo": "mersinvald/disciplinator", "file": "driver/drivers/executor/src/main.rs", "last_update_at": "2020-03-31T15:05:04+00:00", "question_id": "7392e796f420ee773a24d88ffc85f80979640067_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn discover_plugins<P: AsRef<Path>>(base_dir: P) -> Result<Vec<Plugin>, Error> {\n    use std::fs;\n    use std::io::Read;\n    #[derive(Deserialize)]\n    struct Manifest {\n        triggers: Vec<CallbackTrigger>,\n        enabled: bool,\n    }\n    let base_dir = base_dir.as_ref();\n    debug!(\"discovering plugins in {}\", base_dir.display());\n    if !base_dir.exists() {\n        return Err(format_err!(\n            \"plugins directory {} not found\",\n            base_dir.display()\n        ));\n    }\n    let dir = fs::read_dir(base_dir)\n        .map_err(|e| format_err!(\"failed to open plugins directory: {}\", e))?;\n    trace!(\"discovering toml manifest files\");\n    let toml_file_paths = dir\n        .flat_map(|r| match r {\n            Ok(entry) => Some(entry),\n            Err(e) => {\n                warn!(\n                    \"failed to read item in the directory {}: {}\",\n                    base_dir.display(),\n                    e\n                );\n                None\n            }\n        })\n        .map(|d| d.path().to_path_buf())\n        .filter(|path| path.extension().map(|e| e == \"toml\").unwrap_or(false));\n    let mut plugins = Vec::new();\n    for toml_file_path in toml_file_paths {\n        let toml = toml_file_path\n            .to_str()\n            .expect(\"non-unicode paths are not supported\");\n        let plugin = toml.trim_right_matches(\".toml\");\n        debug!(\"probing manifest({}) and plugin({})\", toml, plugin);\n        // This block may throw errors, but we don't want to trow from the function\n        // in-place lambda will catch 'em all!\n        let result = || -> Result<Manifest, Error> {\n            let mut toml_file = fs::File::open(toml)?;\n            let mut contents = String::new();\n            toml_file.read_to_string(&mut contents)?;\n            Ok(toml::from_str(&contents)?)\n        }();\n        let manifest = match result {\n            Ok(manifest) => manifest,\n            Err(e) => {\n                warn!(\"failed to process plugin manifest at {}: {}\", toml, e);\n                continue;\n            }\n        };\n        // Check that plugin file exists\n        if !Path::new(plugin).exists() {\n            warn!(\n                \"plugin manifest found at {}, but there's no plugin file at {}\",\n                toml, plugin\n            );\n            continue;\n        }\n        // Skip loading disabled plugins\n        if !manifest.enabled {\n            warn!(\"plugin {} is disabled, skipping\", plugin);\n            continue;\n        }\n        for trigger in manifest.triggers {\n            plugins.push(Plugin {\n                trigger,\n                path: PathBuf::from(plugin),\n            })\n        }\n    }\n    Ok(plugins)\n"]], "pred": {"ppl": 1.9963148832321167, "ppl_lower": 2.37675142288208, "ppl/lowercase_ppl": -1.252323082472157, "ppl/zlib": 0.000672473660094595, "Min_5.0% Prob": 6.252341383381894, "Min_10.0% Prob": 4.68900474121696, "Min_20.0% Prob": 3.0671635419130325, "Min_30.0% Prob": 2.2221395973312226, "Min_40.0% Prob": 1.7102922539618846, "Min_50.0% Prob": 1.3789935830588405, "Min_60.0% Prob": 1.1514995642039074}}
{"hexsha": "3d8aa3780748940ebfb8f69f7d249ae0908906f6", "ext": "rs", "lang": "Rust", "content": "fn _build_get_attrib_request(command_handle: IndyHandle, submitter_did: Option<&str>, target_did: &str, raw: Option<&str>, hash: Option<&str>, enc: Option<&str>, cb: Option<ResponseStringCB>) -> ErrorCode {\n    let submitter_did_str = opt_c_str!(submitter_did);\n    let target_did = c_str!(target_did);\n\n    let raw_str = opt_c_str!(raw);\n    let hash_str = opt_c_str!(hash);\n    let enc_str = opt_c_str!(enc);\n\n    ErrorCode::from(unsafe {\n        ledger::indy_build_get_attrib_request(command_handle,\n                                              opt_c_ptr!(submitter_did, submitter_did_str),\n                                              target_did.as_ptr(),\n                                              opt_c_ptr!(raw, raw_str),\n                                              opt_c_ptr!(hash, hash_str),\n                                              opt_c_ptr!(enc, enc_str),\n                                              cb)\n    })\n}", "item_id": 20, "repo": "nekia/indy-sdk", "file": "wrappers/rust/src/ledger.rs", "last_update_at": "2020-11-04T04:12:02+00:00", "question_id": "3d8aa3780748940ebfb8f69f7d249ae0908906f6_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _build_get_attrib_request(command_handle: IndyHandle, submitter_did: Option<&str>, target_did: &str, raw: Option<&str>, hash: Option<&str>, enc: Option<&str>, cb: Option<ResponseStringCB>) -> ErrorCode {\n    let submitter_did_str = opt_c_str!(submitter_did);\n    let target_did = c_str!(target_did);\n    let raw_str = opt_c_str!(raw);\n    let hash_str = opt_c_str!(hash);\n    let enc_str = opt_c_str!(enc);\n    ErrorCode::from(unsafe {\n        ledger::indy_build_get_attrib_request(command_handle,\n                                              opt_c_ptr!(submitter_did, submitter_did_str),\n                                              target_did.as_ptr(),\n                                              opt_c_ptr!(raw, raw_str),\n                                              opt_c_ptr!(hash, hash_str),\n                                              opt_c_ptr!(enc, enc_str),\n                                              cb)\n    })\n"]], "pred": {"ppl": 1.395761489868164, "ppl_lower": 1.8085862398147583, "ppl/lowercase_ppl": -1.7770669783501445, "ppl/zlib": 0.0011537721010839313, "Min_5.0% Prob": 4.841786769720224, "Min_10.0% Prob": 3.1229294030754655, "Min_20.0% Prob": 1.6544760084965013, "Min_30.0% Prob": 1.119250965350103, "Min_40.0% Prob": 0.8359149366892367, "Min_50.0% Prob": 0.6666744803390601, "Min_60.0% Prob": 0.5576998598878907}}
{"hexsha": "0590099249d796094a169a4df930df285e65c447", "ext": "rs", "lang": "Rust", "content": "pub fn file_to_lines(path: &str) -> Vec<String> {\n    let path = Path::new(path);\n    let file = File::open(&path).unwrap();\n    let lines = io::BufReader::new(file).lines();\n    let mut str_lines: Vec<String> = vec![];\n\n    for line in lines {\n        if let Ok(line) = line {\n            str_lines.push(line);\n        };\n    }\n    str_lines\n}", "item_id": 0, "repo": "aniljava/aoc-2020", "file": "src/utils.rs", "last_update_at": "2020-12-09T11:45:51+00:00", "question_id": "0590099249d796094a169a4df930df285e65c447_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn file_to_lines(path: &str) -> Vec<String> {\n    let path = Path::new(path);\n    let file = File::open(&path).unwrap();\n    let lines = io::BufReader::new(file).lines();\n    let mut str_lines: Vec<String> = vec![];\n    for line in lines {\n        if let Ok(line) = line {\n            str_lines.push(line);\n        };\n    }\n    str_lines\n"]], "pred": {"ppl": 1.9829238653182983, "ppl_lower": 3.02768611907959, "ppl/lowercase_ppl": -1.6182343628385076, "ppl/zlib": 0.0034228622755670523, "Min_5.0% Prob": 7.8718061447143555, "Min_10.0% Prob": 5.321539835496382, "Min_20.0% Prob": 3.1587322224741397, "Min_30.0% Prob": 2.2168117804186687, "Min_40.0% Prob": 1.6915070833043848, "Min_50.0% Prob": 1.3615501419467442, "Min_60.0% Prob": 1.151821857557765}}
{"hexsha": "17b229ba0da0e6feb3f30d7b840a29d54de9fde6", "ext": "rs", "lang": "Rust", "content": "fn main() {\r\n    let points = include_str!(\"input.txt\").lines().map(|line| {\r\n        let nums: Vec<_> = line\r\n            .split(|c| c == '<' || c == ',' || c == '>' || c == '=')\r\n            .filter_map(|n| n.parse::<i32>().ok())\r\n            .collect();\r\n        (Vec3::new(nums[0], nums[1], nums[2]), nums[3])\r\n    });\r\n    let strong_point = points.clone().max_by_key(|p| p.1).unwrap();\r\n    let center = strong_point.0;\r\n    let range = strong_point.1;\r\n\r\n    println!(\r\n        \"{:?}\",\r\n        points\r\n            .filter(|p| Vec3::distance(&p.0, &center) <= range)\r\n            .count()\r\n    );\r\n}", "item_id": 0, "repo": "ckuenzi/AoC", "file": "aoc_2018/aoc_23_1/src/main.rs", "last_update_at": "2020-12-11T18:08:04+00:00", "question_id": "17b229ba0da0e6feb3f30d7b840a29d54de9fde6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\r\n    let points = include_str!(\"input.txt\").lines().map(|line| {\r\n        let nums: Vec<_> = line\r\n            .split(|c| c == '<' || c == ',' || c == '>' || c == '=')\r\n            .filter_map(|n| n.parse::<i32>().ok())\r\n            .collect();\r\n        (Vec3::new(nums[0], nums[1], nums[2]), nums[3])\r\n    });\r\n    let strong_point = points.clone().max_by_key(|p| p.1).unwrap();\r\n    let center = strong_point.0;\r\n    let range = strong_point.1;\r\n\r\n    println!(\r\n        \"{:?}\",\r\n        points\r\n            .filter(|p| Vec3::distance(&p.0, &center) <= range)\r\n            .count()\r\n    );\r\n"]], "pred": {"ppl": 1.9505332708358765, "ppl_lower": 2.087322473526001, "ppl/lowercase_ppl": -1.101450440470841, "ppl/zlib": 0.0021482405383037597, "Min_5.0% Prob": 6.244967460632324, "Min_10.0% Prob": 4.559560569849881, "Min_20.0% Prob": 2.9478093196045267, "Min_30.0% Prob": 2.125789030934825, "Min_40.0% Prob": 1.6555132481523536, "Min_50.0% Prob": 1.337909745086323, "Min_60.0% Prob": 1.1174439474954412}}
{"hexsha": "7b614ef4b62ab4bfee944759a60885f347c6a719", "ext": "rs", "lang": "Rust", "content": "pub async fn update_source_control(\n    operation_config: &crate::OperationConfig,\n    source_control_type: &str,\n    request_message: &models::SourceControl,\n) -> std::result::Result<models::SourceControl, update_source_control::Error> {\n    let http_client = operation_config.http_client();\n    let url_str = &format!(\n        \"{}/providers/Microsoft.Web/sourcecontrols/{}\",\n        operation_config.base_path(),\n        source_control_type\n    );\n    let mut url = url::Url::parse(url_str).map_err(update_source_control::Error::ParseUrlError)?;\n    let mut req_builder = http::request::Builder::new();\n    req_builder = req_builder.method(http::Method::PUT);\n    if let Some(token_credential) = operation_config.token_credential() {\n        let token_response = token_credential\n            .get_token(operation_config.token_credential_resource())\n            .await\n            .map_err(update_source_control::Error::GetTokenError)?;\n        req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n    }\n    url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n    req_builder = req_builder.header(\"content-type\", \"application/json\");\n    let req_body = azure_core::to_json(request_message).map_err(update_source_control::Error::SerializeError)?;\n    req_builder = req_builder.uri(url.as_str());\n    let req = req_builder\n        .body(req_body)\n        .map_err(update_source_control::Error::BuildRequestError)?;\n    let rsp = http_client\n        .execute_request(req)\n        .await\n        .map_err(update_source_control::Error::ExecuteRequestError)?;\n    match rsp.status() {\n        http::StatusCode::OK => {\n            let rsp_body = rsp.body();\n            let rsp_value: models::SourceControl = serde_json::from_slice(rsp_body)\n                .map_err(|source| update_source_control::Error::DeserializeError(source, rsp_body.clone()))?;\n            Ok(rsp_value)\n        }\n        status_code => {\n            let rsp_body = rsp.body();\n            Err(update_source_control::Error::UnexpectedResponse {\n                status_code,\n                body: rsp_body.clone(),\n            })\n        }\n    }\n}", "item_id": 51, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/web/src/package_2016_03_only/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "7b614ef4b62ab4bfee944759a60885f347c6a719_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn update_source_control(\n    operation_config: &crate::OperationConfig,\n    source_control_type: &str,\n    request_message: &models::SourceControl,\n) -> std::result::Result<models::SourceControl, update_source_control::Error> {\n    let http_client = operation_config.http_client();\n    let url_str = &format!(\n        \"{}/providers/Microsoft.Web/sourcecontrols/{}\",\n        operation_config.base_path(),\n        source_control_type\n    );\n    let mut url = url::Url::parse(url_str).map_err(update_source_control::Error::ParseUrlError)?;\n    let mut req_builder = http::request::Builder::new();\n    req_builder = req_builder.method(http::Method::PUT);\n    if let Some(token_credential) = operation_config.token_credential() {\n        let token_response = token_credential\n            .get_token(operation_config.token_credential_resource())\n            .await\n            .map_err(update_source_control::Error::GetTokenError)?;\n        req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n    }\n    url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n    req_builder = req_builder.header(\"content-type\", \"application/json\");\n    let req_body = azure_core::to_json(request_message).map_err(update_source_control::Error::SerializeError)?;\n    req_builder = req_builder.uri(url.as_str());\n    let req = req_builder\n        .body(req_body)\n        .map_err(update_source_control::Error::BuildRequestError)?;\n    let rsp = http_client\n        .execute_request(req)\n        .await\n        .map_err(update_source_control::Error::ExecuteRequestError)?;\n    match rsp.status() {\n        http::StatusCode::OK => {\n            let rsp_body = rsp.body();\n            let rsp_value: models::SourceControl = serde_json::from_slice(rsp_body)\n                .map_err(|source| update_source_control::Error::DeserializeError(source, rsp_body.clone()))?;\n            Ok(rsp_value)\n        }\n        status_code => {\n            let rsp_body = rsp.body();\n            Err(update_source_control::Error::UnexpectedResponse {\n                status_code,\n                body: rsp_body.clone(),\n            })\n        }\n    }\n"]], "pred": {"ppl": 1.1090768575668335, "ppl_lower": 1.9438464641571045, "ppl/lowercase_ppl": -6.4201825871468134, "ppl/zlib": 0.0001327282172482427, "Min_5.0% Prob": 2.1226830697851256, "Min_10.0% Prob": 1.049428599084226, "Min_20.0% Prob": 0.5207907639056805, "Min_30.0% Prob": 0.3463172957379121, "Min_40.0% Prob": 0.2594097401233627, "Min_50.0% Prob": 0.20737037846933581, "Min_60.0% Prob": 0.1727212602262523}}
{"hexsha": "0d12d4dabbe103e589461731bba78fdfb38c0526", "ext": "rs", "lang": "Rust", "content": "pub fn get_volumes() -> Result<Vec<Volume>, ScannerError> {\n    let mut mounts = get_mounts()?;\n\n    let mut sc = ScannerAscii::scan_path(\"/proc/diskstats\")?;\n\n    let mut volumes = Vec::with_capacity(1);\n\n    loop {\n        if sc.drop_next()?.is_none() {\n            break;\n        }\n\n        sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n\n        let device =\n            unsafe { String::from_utf8_unchecked(sc.next_raw()?.ok_or(ErrorKind::UnexpectedEof)?) };\n\n        if let Some(points) = mounts.remove(&device) {\n            for _ in 0..2 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n\n            let read_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n\n            for _ in 0..3 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n\n            let write_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n\n            for _ in 0..2 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n\n            let time_spent = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n\n            if time_spent > 0 {\n                let (size, used) = {\n                    let path = CString::new(points[0].as_bytes()).unwrap();\n\n                    let mut stats: libc::statvfs = unsafe { zeroed() };\n\n                    let rtn = unsafe { libc::statvfs(path.as_ptr(), &mut stats as *mut _) };\n\n                    if rtn != 0 {\n                        return Err(io::Error::last_os_error().into());\n                    }\n\n                    (\n                        stats.f_bsize as u64 * stats.f_blocks as u64,\n                        stats.f_bsize as u64 * (stats.f_blocks - stats.f_bavail) as u64,\n                    )\n                };\n\n                let stat = VolumeStat {\n                    read_bytes,\n                    write_bytes,\n                };\n\n                let volume = Volume {\n                    device,\n                    stat,\n                    size,\n                    used,\n                    points,\n                };\n\n                volumes.push(volume);\n            }\n\n            sc.drop_next_line()?.ok_or(ErrorKind::UnexpectedEof)?;\n        }\n    }\n\n    Ok(volumes)\n}", "item_id": 0, "repo": "magiclen/m-prober-lib", "file": "src/volume/volume.rs", "last_update_at": "2020-11-10T06:42:57+00:00", "question_id": "0d12d4dabbe103e589461731bba78fdfb38c0526_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_volumes() -> Result<Vec<Volume>, ScannerError> {\n    let mut mounts = get_mounts()?;\n    let mut sc = ScannerAscii::scan_path(\"/proc/diskstats\")?;\n    let mut volumes = Vec::with_capacity(1);\n    loop {\n        if sc.drop_next()?.is_none() {\n            break;\n        }\n        sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n        let device =\n            unsafe { String::from_utf8_unchecked(sc.next_raw()?.ok_or(ErrorKind::UnexpectedEof)?) };\n        if let Some(points) = mounts.remove(&device) {\n            for _ in 0..2 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n            let read_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n            for _ in 0..3 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n            let write_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n            for _ in 0..2 {\n                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;\n            }\n            let time_spent = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;\n            if time_spent > 0 {\n                let (size, used) = {\n                    let path = CString::new(points[0].as_bytes()).unwrap();\n                    let mut stats: libc::statvfs = unsafe { zeroed() };\n                    let rtn = unsafe { libc::statvfs(path.as_ptr(), &mut stats as *mut _) };\n                    if rtn != 0 {\n                        return Err(io::Error::last_os_error().into());\n                    }\n                    (\n                        stats.f_bsize as u64 * stats.f_blocks as u64,\n                        stats.f_bsize as u64 * (stats.f_blocks - stats.f_bavail) as u64,\n                    )\n                };\n                let stat = VolumeStat {\n                    read_bytes,\n                    write_bytes,\n                };\n                let volume = Volume {\n                    device,\n                    stat,\n                    size,\n                    used,\n                    points,\n                };\n                volumes.push(volume);\n            }\n            sc.drop_next_line()?.ok_or(ErrorKind::UnexpectedEof)?;\n        }\n    }\n    Ok(volumes)\n"]], "pred": {"ppl": 1.7322278022766113, "ppl_lower": 1.9473779201507568, "ppl/lowercase_ppl": -1.213093756611304, "ppl/zlib": 0.0008452435800851971, "Min_5.0% Prob": 6.079253680365426, "Min_10.0% Prob": 4.231102630070278, "Min_20.0% Prob": 2.6020417234727313, "Min_30.0% Prob": 1.8076606764679863, "Min_40.0% Prob": 1.3714361164984958, "Min_50.0% Prob": 1.09955093883111, "Min_60.0% Prob": 0.9168024623134573}}
{"hexsha": "44ad0129cdca67f9d6cd7cb20b61d7c23ba8944e", "ext": "rs", "lang": "Rust", "content": "fn invalid_type() {\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\".to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\\\n                  type\\tcommit\\n\\n\"\n            .to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\\\n                  tpye commit\\n\"\n            .to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n    }", "item_id": 2, "repo": "rust-git/rsgit", "file": "core/src/object/check_tag.rs", "last_update_at": "2020-11-18T20:21:45+00:00", "question_id": "44ad0129cdca67f9d6cd7cb20b61d7c23ba8944e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn invalid_type() {\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\".to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\\\n                  type\\tcommit\\n\\n\"\n            .to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n        let cs = \"object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\\n\\\n                  tpye commit\\n\"\n            .to_string();\n        assert_eq!(tag_is_valid(&cs).unwrap(), false);\n"]], "pred": {"ppl": 2.284261703491211, "ppl_lower": 2.284261703491211, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004693425377517913, "Min_5.0% Prob": 8.000573873519897, "Min_10.0% Prob": 5.784156580766042, "Min_20.0% Prob": 3.822049591690302, "Min_30.0% Prob": 2.7183430292126207, "Min_40.0% Prob": 2.0596751467091963, "Min_50.0% Prob": 1.6504509718700622, "Min_60.0% Prob": 1.3762650858795193}}
{"hexsha": "99dfcbf5c0548870980fbec0661eaaa6486405a4", "ext": "rs", "lang": "Rust", "content": "fn type_parser(text: Span) -> IResult<Span, &str, GSError> {\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\"(\")(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\"<-\")(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, type_name) = identifier(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\")\")(text)?;\n    let (text, _) = multispace0(text)?;\n    Ok((text, type_name))\n}", "item_id": 1, "repo": "capra314cabra/kaprino", "file": "src/kgen/src/parsers/statements/let_object.rs", "last_update_at": "2020-05-16T10:22:36+00:00", "question_id": "99dfcbf5c0548870980fbec0661eaaa6486405a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn type_parser(text: Span) -> IResult<Span, &str, GSError> {\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\"(\")(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\"<-\")(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, type_name) = identifier(text)?;\n    let (text, _) = multispace0(text)?;\n    let (text, _) = tag(\")\")(text)?;\n    let (text, _) = multispace0(text)?;\n    Ok((text, type_name))\n"]], "pred": {"ppl": 1.6356338262557983, "ppl_lower": 2.030719518661499, "ppl/lowercase_ppl": -1.439728493512948, "ppl/zlib": 0.0032802026036434177, "Min_5.0% Prob": 6.8982256054878235, "Min_10.0% Prob": 4.404001053641824, "Min_20.0% Prob": 2.4143046979393277, "Min_30.0% Prob": 1.652620190826173, "Min_40.0% Prob": 1.233830940630287, "Min_50.0% Prob": 0.9833216101290997, "Min_60.0% Prob": 0.8245742752039361}}
{"hexsha": "8dd9ecc743b62c7ecf17d9e21c3da8039a7ec29a", "ext": "rs", "lang": "Rust", "content": "fn iterate_once(tiles: Tiles) -> Tiles {\n    let mut counter = HashMap::new();\n\n    tiles\n        .iter()\n        .flat_map(|(x, y)| {\n            NEIGHBORS\n                .iter()\n                .map(move |neigh| (x + neigh.0, y + neigh.1))\n        })\n        .for_each(|(x, y)| *counter.entry((x, y)).or_insert(0) += 1);\n\n    counter\n        .iter()\n        .filter(|&(k, &c)| (c == 2 || (c == 1 && tiles.contains(&k))))\n        .map(|(k, _)| k)\n        .cloned()\n        .collect()\n}", "item_id": 0, "repo": "tacgomes/advent-of-code-2020", "file": "24/main.rs", "last_update_at": "2020-12-01T19:06:12+00:00", "question_id": "8dd9ecc743b62c7ecf17d9e21c3da8039a7ec29a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn iterate_once(tiles: Tiles) -> Tiles {\n    let mut counter = HashMap::new();\n    tiles\n        .iter()\n        .flat_map(|(x, y)| {\n            NEIGHBORS\n                .iter()\n                .map(move |neigh| (x + neigh.0, y + neigh.1))\n        })\n        .for_each(|(x, y)| *counter.entry((x, y)).or_insert(0) += 1);\n    counter\n        .iter()\n        .filter(|&(k, &c)| (c == 2 || (c == 1 && tiles.contains(&k))))\n        .map(|(k, _)| k)\n        .cloned()\n        .collect()\n"]], "pred": {"ppl": 1.973083257675171, "ppl_lower": 2.1955478191375732, "ppl/lowercase_ppl": -1.1572021357933384, "ppl/zlib": 0.002603821550451029, "Min_5.0% Prob": 6.760250780317518, "Min_10.0% Prob": 4.960174216164483, "Min_20.0% Prob": 3.080365641249551, "Min_30.0% Prob": 2.2162290507996523, "Min_40.0% Prob": 1.7033864229710565, "Min_50.0% Prob": 1.3561557162716822, "Min_60.0% Prob": 1.1339246806081966}}
{"hexsha": "6d6017573603d469698c5278c79502c5f9833975", "ext": "rs", "lang": "Rust", "content": "fn delete_twice() {\n        let mut world = World::new();\n\n        let e = world.create_entity().build();\n\n        world.delete_entity(e).unwrap();\n        assert!(world.entities().delete(e).is_err());\n    }", "item_id": 4, "repo": "tommilligan/cargo-raze", "file": "examples/vendored/complicated_cargo_library/cargo/vendor/specs-0.10.0/src/world.rs", "last_update_at": "2020-06-20T17:38:50+00:00", "question_id": "6d6017573603d469698c5278c79502c5f9833975_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn delete_twice() {\n        let mut world = World::new();\n        let e = world.create_entity().build();\n        world.delete_entity(e).unwrap();\n        assert!(world.entities().delete(e).is_err());\n"]], "pred": {"ppl": 2.484727144241333, "ppl_lower": 2.86604380607605, "ppl/lowercase_ppl": -1.1568617761592679, "ppl/zlib": 0.006895173124317282, "Min_5.0% Prob": 8.499687512715658, "Min_10.0% Prob": 6.186203042666118, "Min_20.0% Prob": 3.8186159630616507, "Min_30.0% Prob": 2.7389021578587984, "Min_40.0% Prob": 2.216545646190643, "Min_50.0% Prob": 1.7856650846078992, "Min_60.0% Prob": 1.5229983402318077}}
{"hexsha": "d6da04f2ad54b77b73638ecff4dd44a9e9641e40", "ext": "rs", "lang": "Rust", "content": "fn test_sub_without_overflow() {\n        let mut vm = VM::new();\n        vm.registers.v[1] = 150;\n        vm.registers.v[2] = 100;\n        vm.registers.v[0xF] = 4;\n        vm.registers.program_counter = 0x200;\n\n        vm.sub(1, 2);\n\n        assert_eq!(vm.registers.v[1], 50);\n        assert_eq!(vm.registers.v[2], 100);\n        assert_eq!(vm.registers.v[0xF], 1);\n        assert_eq!(vm.registers.program_counter, 0x202);\n    }", "item_id": 21, "repo": "opilar/chip-8-emulator", "file": "emulator/src/vm.rs", "last_update_at": "2020-09-16T13:51:11+00:00", "question_id": "d6da04f2ad54b77b73638ecff4dd44a9e9641e40_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sub_without_overflow() {\n        let mut vm = VM::new();\n        vm.registers.v[1] = 150;\n        vm.registers.v[2] = 100;\n        vm.registers.v[0xF] = 4;\n        vm.registers.program_counter = 0x200;\n        vm.sub(1, 2);\n        assert_eq!(vm.registers.v[1], 50);\n        assert_eq!(vm.registers.v[2], 100);\n        assert_eq!(vm.registers.v[0xF], 1);\n        assert_eq!(vm.registers.program_counter, 0x202);\n"]], "pred": {"ppl": 1.6904809474945068, "ppl_lower": 1.8227165937423706, "ppl/lowercase_ppl": -1.1434534743694844, "ppl/zlib": 0.0029661755523436315, "Min_5.0% Prob": 5.205526881747776, "Min_10.0% Prob": 3.7312335901790195, "Min_20.0% Prob": 2.378511528711061, "Min_30.0% Prob": 1.7163136024366725, "Min_40.0% Prob": 1.3036610274198088, "Min_50.0% Prob": 1.0454200269073568, "Min_60.0% Prob": 0.8779610173004839}}
{"hexsha": "496d03aa691db875aa6d6a23f7747f7aaf5057d7", "ext": "rs", "lang": "Rust", "content": "pub fn test_interface_writes_messages() {\n        let mut interface = TestInterface::new(VecDeque::new());\n        assert_eq!(interface.written, String::new());\n        interface.write(\"foo\");\n        assert_eq!(interface.written, \"foo\");\n        interface.write(\" bar\");\n        assert_eq!(interface.written, \"foo bar\");\n    }", "item_id": 0, "repo": "Mattachoo/Text-Adventurers", "file": "src/io.rs", "last_update_at": "2020-05-09T18:19:10+00:00", "question_id": "496d03aa691db875aa6d6a23f7747f7aaf5057d7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_interface_writes_messages() {\n        let mut interface = TestInterface::new(VecDeque::new());\n        assert_eq!(interface.written, String::new());\n        interface.write(\"foo\");\n        assert_eq!(interface.written, \"foo\");\n        interface.write(\" bar\");\n        assert_eq!(interface.written, \"foo bar\");\n"]], "pred": {"ppl": 3.1039490699768066, "ppl_lower": 4.062154293060303, "ppl/lowercase_ppl": -1.2375246266304576, "ppl/zlib": 0.007920805554671782, "Min_5.0% Prob": 9.384170055389404, "Min_10.0% Prob": 7.409568607807159, "Min_20.0% Prob": 5.027011394500732, "Min_30.0% Prob": 3.6002283486036153, "Min_40.0% Prob": 2.7879166305065155, "Min_50.0% Prob": 2.271592264486985, "Min_60.0% Prob": 1.8989007792101715}}
{"hexsha": "a3e1cc779be440c1ba82f2dd31af7e55ab36bb91", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Error> {\n    let event_loop = EventLoop::new();\n    let mut world = Context::new();\n    let cpus = num_cpus::get();\n    let mut deepness: f64 = 0.0;\n    if (world.height % cpus as u32) != 0 {\n        println!(\"WARNING: HardCoded resolution height({}) should be divisable by the number of threads:{}\",world.height,cpus)\n    }\n\n    let window = {\n        let size =\n            LogicalSize::new(world.width as f64, world.height as f64).to_physical::<f64>(1.0);\n        WindowBuilder::new()\n            .with_title(\"Rusty Mandelbrot\")\n            .with_inner_size(size)\n            .with_min_inner_size(size)\n            .with_resizable(false)\n            .build(&event_loop)\n            .unwrap()\n    };\n\n    let mut pixels = {\n        let surface = Surface::create(&window);\n        let surface_texture = SurfaceTexture::new(world.width, world.height, surface);\n        Pixels::new(world.width, world.height, surface_texture)?\n    };\n\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Wait;\n\n        match event {\n            Event::WindowEvent {\n                event: WindowEvent::CloseRequested,\n                ..\n            } => *control_flow = ControlFlow::Exit,\n            Event::WindowEvent {\n                event: WindowEvent::CursorMoved { position, .. },\n                ..\n            } => match world.left_button {\n                ButtonState::JustPressed => {\n                    world.coordenate_clicked.x = position.x;\n                    world.coordenate_clicked.y = position.y;\n                    world.left_button = ButtonState::Pressed;\n                }\n                ButtonState::Pressed => {\n                    world.delta.x = world.k_x * (position.x - world.coordenate_clicked.x);\n                    world.delta.y = world.k_y * (world.coordenate_clicked.y - position.y);\n                    window.request_redraw();\n                }\n                _ => (),\n            },\n            Event::WindowEvent {\n                event: WindowEvent::MouseInput { state, button, .. },\n                ..\n            } => {\n                if button == winit::event::MouseButton::Left {\n                    if state == winit::event::ElementState::Pressed {\n                        world.left_button = ButtonState::JustPressed;\n                    } else {\n                        world.left_button = ButtonState::Releassed;\n                        world.up_left = Point {\n                            x: world.up_left.x - world.delta.x,\n                            y: world.up_left.y - world.delta.y,\n                        };\n                        world.down_right = Point {\n                            x: world.down_right.x - world.delta.x,\n                            y: world.down_right.y - world.delta.y,\n                        };\n                        window.request_redraw();\n                    }\n                }\n            }\n            Event::WindowEvent {\n                event: WindowEvent::MouseWheel { delta, .. },\n                ..\n            } => {\n                let width_excursion = (world.down_right.x - world.up_left.x) / world.zoom_factor;\n                let height_excursion = (world.up_left.y - world.down_right.y) / world.zoom_factor;\n\n                if delta == winit::event::MouseScrollDelta::LineDelta(0.0, 1.0) {\n                    deepness = width_excursion / world.zoom_factor;\n                    world.up_left = Point {\n                        x: world.up_left.x + width_excursion / world.zoom_factor,\n                        y: world.up_left.y - height_excursion / world.zoom_factor,\n                    };\n                    world.down_right = Point {\n                        x: world.down_right.x - height_excursion / world.zoom_factor,\n                        y: world.down_right.y + height_excursion / world.zoom_factor,\n                    };\n                } else {\n                    deepness = width_excursion * world.zoom_factor;\n                    world.up_left = Point {\n                        x: world.up_left.x - width_excursion * world.zoom_factor,\n                        y: world.up_left.y + height_excursion * world.zoom_factor,\n                    };\n                    world.down_right = Point {\n                        x: world.down_right.x + height_excursion * world.zoom_factor,\n                        y: world.down_right.y - height_excursion * world.zoom_factor,\n                    };\n                }\n                world.k_x = (world.down_right.x - world.up_left.x) / (world.width as f64);\n                world.k_y = (world.up_left.y - world.down_right.y) / (world.width as f64);\n                println!(\"Deepness: {}\", deepness);\n                window.request_redraw();\n            }\n            Event::RedrawRequested(_) => {\n                let start = Instant::now();\n                if world.left_button == ButtonState::Pressed {\n                    let snapshot_up_left = Point {\n                        x: world.up_left.x - world.delta.x,\n                        y: world.up_left.y - world.delta.y,\n                    };\n                    let snapshot_donw_right = Point {\n                        x: world.down_right.x - world.delta.x,\n                        y: world.down_right.y - world.delta.y,\n                    };\n\n                    world.parallel_draw_low_res(\n                        pixels.get_frame(),\n                        snapshot_up_left,\n                        snapshot_donw_right,\n                        cpus as u32,\n                    );\n                } else {\n                    world.parallel_draw(pixels.get_frame(), cpus as u32);\n                }\n                let duration = start.elapsed();\n                pixels.render();\n                println!(\"Frame time: {:?}\", duration);\n            }\n            _ => (),\n        }\n    });\n}", "item_id": 0, "repo": "jgobbic/rusty_mandelbrot", "file": "src/main.rs", "last_update_at": "2020-05-06T19:50:23+00:00", "question_id": "a3e1cc779be440c1ba82f2dd31af7e55ab36bb91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Error> {\n    let event_loop = EventLoop::new();\n    let mut world = Context::new();\n    let cpus = num_cpus::get();\n    let mut deepness: f64 = 0.0;\n    if (world.height % cpus as u32) != 0 {\n        println!(\"WARNING: HardCoded resolution height({}) should be divisable by the number of threads:{}\",world.height,cpus)\n    }\n    let window = {\n        let size =\n            LogicalSize::new(world.width as f64, world.height as f64).to_physical::<f64>(1.0);\n        WindowBuilder::new()\n            .with_title(\"Rusty Mandelbrot\")\n            .with_inner_size(size)\n            .with_min_inner_size(size)\n            .with_resizable(false)\n            .build(&event_loop)\n            .unwrap()\n    };\n    let mut pixels = {\n        let surface = Surface::create(&window);\n        let surface_texture = SurfaceTexture::new(world.width, world.height, surface);\n        Pixels::new(world.width, world.height, surface_texture)?\n    };\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Wait;\n        match event {\n            Event::WindowEvent {\n                event: WindowEvent::CloseRequested,\n                ..\n            } => *control_flow = ControlFlow::Exit,\n            Event::WindowEvent {\n                event: WindowEvent::CursorMoved { position, .. },\n                ..\n            } => match world.left_button {\n                ButtonState::JustPressed => {\n                    world.coordenate_clicked.x = position.x;\n                    world.coordenate_clicked.y = position.y;\n                    world.left_button = ButtonState::Pressed;\n                }\n                ButtonState::Pressed => {\n                    world.delta.x = world.k_x * (position.x - world.coordenate_clicked.x);\n                    world.delta.y = world.k_y * (world.coordenate_clicked.y - position.y);\n                    window.request_redraw();\n                }\n                _ => (),\n            },\n            Event::WindowEvent {\n                event: WindowEvent::MouseInput { state, button, .. },\n                ..\n            } => {\n                if button == winit::event::MouseButton::Left {\n                    if state == winit::event::ElementState::Pressed {\n                        world.left_button = ButtonState::JustPressed;\n                    } else {\n                        world.left_button = ButtonState::Releassed;\n                        world.up_left = Point {\n                            x: world.up_left.x - world.delta.x,\n                            y: world.up_left.y - world.delta.y,\n                        };\n                        world.down_right = Point {\n                            x: world.down_right.x - world.delta.x,\n                            y: world.down_right.y - world.delta.y,\n                        };\n                        window.request_redraw();\n                    }\n                }\n            }\n            Event::WindowEvent {\n                event: WindowEvent::MouseWheel { delta, .. },\n                ..\n            } => {\n                let width_excursion = (world.down_right.x - world.up_left.x) / world.zoom_factor;\n                let height_excursion = (world.up_left.y - world.down_right.y) / world.zoom_factor;\n                if delta == winit::event::MouseScrollDelta::LineDelta(0.0, 1.0) {\n                    deepness = width_excursion / world.zoom_factor;\n                    world.up_left = Point {\n                        x: world.up_left.x + width_excursion / world.zoom_factor,\n                        y: world.up_left.y - height_excursion / world.zoom_factor,\n                    };\n                    world.down_right = Point {\n                        x: world.down_right.x - height_excursion / world.zoom_factor,\n                        y: world.down_right.y + height_excursion / world.zoom_factor,\n                    };\n                } else {\n                    deepness = width_excursion * world.zoom_factor;\n                    world.up_left = Point {\n                        x: world.up_left.x - width_excursion * world.zoom_factor,\n                        y: world.up_left.y + height_excursion * world.zoom_factor,\n                    };\n                    world.down_right = Point {\n                        x: world.down_right.x + height_excursion * world.zoom_factor,\n                        y: world.down_right.y - height_excursion * world.zoom_factor,\n                    };\n                }\n                world.k_x = (world.down_right.x - world.up_left.x) / (world.width as f64);\n                world.k_y = (world.up_left.y - world.down_right.y) / (world.width as f64);\n                println!(\"Deepness: {}\", deepness);\n                window.request_redraw();\n            }\n            Event::RedrawRequested(_) => {\n                let start = Instant::now();\n                if world.left_button == ButtonState::Pressed {\n                    let snapshot_up_left = Point {\n                        x: world.up_left.x - world.delta.x,\n                        y: world.up_left.y - world.delta.y,\n                    };\n                    let snapshot_donw_right = Point {\n                        x: world.down_right.x - world.delta.x,\n                        y: world.down_right.y - world.delta.y,\n                    };\n                    world.parallel_draw_low_res(\n                        pixels.get_frame(),\n                        snapshot_up_left,\n                        snapshot_donw_right,\n                        cpus as u32,\n                    );\n                } else {\n                    world.parallel_draw(pixels.get_frame(), cpus as u32);\n                }\n                let duration = start.elapsed();\n                pixels.render();\n                println!(\"Frame time: {:?}\", duration);\n            }\n            _ => (),\n        }\n    });\n"]], "pred": {"ppl": 1.6247600317001343, "ppl_lower": 1.8806263208389282, "ppl/lowercase_ppl": -1.3013118074601675, "ppl/zlib": 0.0003812726881988075, "Min_5.0% Prob": 5.662067932241103, "Min_10.0% Prob": 3.864830235640208, "Min_20.0% Prob": 2.3163986524530484, "Min_30.0% Prob": 1.6031161416443735, "Min_40.0% Prob": 1.2100633657184454, "Min_50.0% Prob": 0.970807437042281, "Min_60.0% Prob": 0.8097394694719269}}
{"hexsha": "cb54cbbdf614ba38d218811de5528a5f00b5179b", "ext": "rs", "lang": "Rust", "content": "fn test_angular_converter_from_dms_to_radian() {\n        let conv = AngularConverter::new(187.625, AngularUnit::DMS);\n        let res = conv.convert(AngularUnit::Radian);\n\n        assert!(res.is_ok());\n        let res = res.unwrap();\n        assert!(is_close(3.274_674, res.scalar()));\n        assert_eq!(&AngularUnit::Radian, res.unit());\n    }", "item_id": 0, "repo": "timgluz/CelestialCalculations.github.io", "file": "rust/ast_utils/src/angular.rs", "last_update_at": "2020-01-19T14:17:47+00:00", "question_id": "cb54cbbdf614ba38d218811de5528a5f00b5179b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_angular_converter_from_dms_to_radian() {\n        let conv = AngularConverter::new(187.625, AngularUnit::DMS);\n        let res = conv.convert(AngularUnit::Radian);\n        assert!(res.is_ok());\n        let res = res.unwrap();\n        assert!(is_close(3.274_674, res.scalar()));\n        assert_eq!(&AngularUnit::Radian, res.unit());\n"]], "pred": {"ppl": 3.5968210697174072, "ppl_lower": 4.034433841705322, "ppl/lowercase_ppl": -1.0896961237985496, "ppl/zlib": 0.0067018346553211015, "Min_5.0% Prob": 7.67205278078715, "Min_10.0% Prob": 6.06739862759908, "Min_20.0% Prob": 4.375786324342092, "Min_30.0% Prob": 3.5931032366222806, "Min_40.0% Prob": 2.964650325629176, "Min_50.0% Prob": 2.489694249923112, "Min_60.0% Prob": 2.125833393163877}}
{"hexsha": "812f36c89c4559955aca02adfcdf70fe9153a5d7", "ext": "rs", "lang": "Rust", "content": "unsafe fn transform(chaining_value: &[u32; 8], block: &[u8], block_len: usize, counter: u64, flags: u32) -> [u8; DIGEST_LEN] {\n    debug_assert!(block.len() == BLOCK_LEN);\n    \n    let t0   = 0i32;\n    let t1   = 0i32;\n    let blen = block_len as u32 as i32;\n\n    let mut va = _mm_setr_epi32(0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32);\n    let mut vb = _mm_setr_epi32(0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32);\n    let mut vc = va.clone();\n    let mut vd = _mm_setr_epi32(t0, t1, blen, flags as i32);\n\n    let w = _mm256_load_si256(block.as_ptr().add( 0) as *const __m256i);\n    let w0 = _mm256_extract_epi32::<0>(w);\n    let w1 = _mm256_extract_epi32::<1>(w);\n    let w2 = _mm256_extract_epi32::<2>(w);\n    let w3 = _mm256_extract_epi32::<3>(w);\n    let w4 = _mm256_extract_epi32::<4>(w);\n    let w5 = _mm256_extract_epi32::<5>(w);\n    let w6 = _mm256_extract_epi32::<6>(w);\n    let w7 = _mm256_extract_epi32::<7>(w);\n    drop(w);\n\n    let w = _mm256_load_si256(block.as_ptr().add(32) as *const __m256i);\n    let w8  = _mm256_extract_epi32::<0>(w);\n    let w9  = _mm256_extract_epi32::<1>(w);\n    let w10 = _mm256_extract_epi32::<2>(w);\n    let w11 = _mm256_extract_epi32::<3>(w);\n    let w12 = _mm256_extract_epi32::<4>(w);\n    let w13 = _mm256_extract_epi32::<5>(w);\n    let w14 = _mm256_extract_epi32::<6>(w);\n    let w15 = _mm256_extract_epi32::<7>(w);\n    drop(w);\n\n    let mut vmx: __m128i;\n    let mut vmy: __m128i;\n\n    // VG!(va, vb, vc, vd,  w0, w2, w4, w6,  w1, w3, w5, w7,  );\n\n    // Round-1\n    vmx = _mm_setr_epi32(w0, w2, w4, w6);\n    vmy = _mm_setr_epi32(w1, w3, w5, w7);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w8, w10, w12, w14);\n    vmy = _mm_setr_epi32(w9, w11, w13, w15);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-2\n    vmx = _mm_setr_epi32(w2, w3, w7, w4);\n    vmy = _mm_setr_epi32(w6, w10, w0, w13);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w1, w12, w9, w15);\n    vmy = _mm_setr_epi32(w11, w5, w14, w8);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-3\n    vmx = _mm_setr_epi32(w3, w10, w13, w7);\n    vmy = _mm_setr_epi32(w4, w12, w2, w14);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w6, w9, w11, w8);\n    vmy = _mm_setr_epi32(w5, w0, w15, w1);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-4\n    vmx = _mm_setr_epi32(w10, w12, w14, w13);\n    vmy = _mm_setr_epi32(w7, w9, w3, w15);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w4, w11, w5, w1);\n    vmy = _mm_setr_epi32(w0, w2, w8, w6);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-5\n    vmx = _mm_setr_epi32(w12, w9, w15, w14);\n    vmy = _mm_setr_epi32(w13, w11, w10, w8);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w7, w5, w0, w6);\n    vmy = _mm_setr_epi32(w2, w3, w1, w4);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-6\n    vmx = _mm_setr_epi32(w9, w11, w8, w15);\n    vmy = _mm_setr_epi32(w14, w5, w12, w1);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w13, w0, w2, w4);\n    vmy = _mm_setr_epi32(w3, w10, w6, w7);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // Round-7\n    vmx = _mm_setr_epi32(w11, w5, w1, w8);\n    vmy = _mm_setr_epi32(w15, w0, w9, w6);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w14, w2, w3, w7);\n    vmy = _mm_setr_epi32(w10, w12, w4, w13);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n\n    // let mut lo = _mm256_setr_m128i(va, vb);\n    // let mut hi = _mm256_setr_m128i(vc, vd);\n    // \n    // lo = _mm256_xor_si256(lo, hi);\n    // hi = _mm256_xor_si256(hi, \n    //         _mm256_setr_epi32(\n    //             0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32, \n    //             0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32,\n    //         ),\n    // );\n    // \n    // let mut v = [0u32; 16];\n    // _mm256_storeu_si256(v.as_mut_ptr() as *mut __m256i, lo);\n    // _mm256_storeu_si256(v.as_mut_ptr().add(8) as *mut __m256i, hi);\n    // \n    // v\n\n    let mut out = [0u8; DIGEST_LEN];\n\n    let mut lo = _mm256_setr_m128i(va, vb);\n    let mut hi = _mm256_setr_m128i(vc, vd);\n\n    lo = _mm256_xor_si256(lo, hi);\n    _mm256_storeu_si256(out.as_mut_ptr() as *mut __m256i, lo);\n\n    out\n}", "item_id": 0, "repo": "onlyrico/crypto2", "file": "src/hash/blake3/x86.rs", "last_update_at": "2020-11-19T09:07:03+00:00", "question_id": "812f36c89c4559955aca02adfcdf70fe9153a5d7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn transform(chaining_value: &[u32; 8], block: &[u8], block_len: usize, counter: u64, flags: u32) -> [u8; DIGEST_LEN] {\n    debug_assert!(block.len() == BLOCK_LEN);\n    let t0   = 0i32;\n    let t1   = 0i32;\n    let blen = block_len as u32 as i32;\n    let mut va = _mm_setr_epi32(0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32);\n    let mut vb = _mm_setr_epi32(0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32);\n    let mut vc = va.clone();\n    let mut vd = _mm_setr_epi32(t0, t1, blen, flags as i32);\n    let w = _mm256_load_si256(block.as_ptr().add( 0) as *const __m256i);\n    let w0 = _mm256_extract_epi32::<0>(w);\n    let w1 = _mm256_extract_epi32::<1>(w);\n    let w2 = _mm256_extract_epi32::<2>(w);\n    let w3 = _mm256_extract_epi32::<3>(w);\n    let w4 = _mm256_extract_epi32::<4>(w);\n    let w5 = _mm256_extract_epi32::<5>(w);\n    let w6 = _mm256_extract_epi32::<6>(w);\n    let w7 = _mm256_extract_epi32::<7>(w);\n    drop(w);\n    let w = _mm256_load_si256(block.as_ptr().add(32) as *const __m256i);\n    let w8  = _mm256_extract_epi32::<0>(w);\n    let w9  = _mm256_extract_epi32::<1>(w);\n    let w10 = _mm256_extract_epi32::<2>(w);\n    let w11 = _mm256_extract_epi32::<3>(w);\n    let w12 = _mm256_extract_epi32::<4>(w);\n    let w13 = _mm256_extract_epi32::<5>(w);\n    let w14 = _mm256_extract_epi32::<6>(w);\n    let w15 = _mm256_extract_epi32::<7>(w);\n    drop(w);\n    let mut vmx: __m128i;\n    let mut vmy: __m128i;\n    // VG!(va, vb, vc, vd,  w0, w2, w4, w6,  w1, w3, w5, w7,  );\n    // Round-1\n    vmx = _mm_setr_epi32(w0, w2, w4, w6);\n    vmy = _mm_setr_epi32(w1, w3, w5, w7);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w8, w10, w12, w14);\n    vmy = _mm_setr_epi32(w9, w11, w13, w15);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-2\n    vmx = _mm_setr_epi32(w2, w3, w7, w4);\n    vmy = _mm_setr_epi32(w6, w10, w0, w13);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w1, w12, w9, w15);\n    vmy = _mm_setr_epi32(w11, w5, w14, w8);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-3\n    vmx = _mm_setr_epi32(w3, w10, w13, w7);\n    vmy = _mm_setr_epi32(w4, w12, w2, w14);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w6, w9, w11, w8);\n    vmy = _mm_setr_epi32(w5, w0, w15, w1);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-4\n    vmx = _mm_setr_epi32(w10, w12, w14, w13);\n    vmy = _mm_setr_epi32(w7, w9, w3, w15);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w4, w11, w5, w1);\n    vmy = _mm_setr_epi32(w0, w2, w8, w6);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-5\n    vmx = _mm_setr_epi32(w12, w9, w15, w14);\n    vmy = _mm_setr_epi32(w13, w11, w10, w8);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w7, w5, w0, w6);\n    vmy = _mm_setr_epi32(w2, w3, w1, w4);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-6\n    vmx = _mm_setr_epi32(w9, w11, w8, w15);\n    vmy = _mm_setr_epi32(w14, w5, w12, w1);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w13, w0, w2, w4);\n    vmy = _mm_setr_epi32(w3, w10, w6, w7);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // Round-7\n    vmx = _mm_setr_epi32(w11, w5, w1, w8);\n    vmy = _mm_setr_epi32(w15, w0, w9, w6);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vmx = _mm_setr_epi32(w14, w2, w3, w7);\n    vmy = _mm_setr_epi32(w10, w12, w4, w13);\n    VG!(va, vb, vc, vd, vmx, vmy);\n    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)\n    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)\n    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)\n    // let mut lo = _mm256_setr_m128i(va, vb);\n    // let mut hi = _mm256_setr_m128i(vc, vd);\n    // \n    // lo = _mm256_xor_si256(lo, hi);\n    // hi = _mm256_xor_si256(hi, \n    //         _mm256_setr_epi32(\n    //             0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32, \n    //             0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32,\n    //         ),\n    // );\n    // \n    // let mut v = [0u32; 16];\n    // _mm256_storeu_si256(v.as_mut_ptr() as *mut __m256i, lo);\n    // _mm256_storeu_si256(v.as_mut_ptr().add(8) as *mut __m256i, hi);\n    // \n    // v\n    let mut out = [0u8; DIGEST_LEN];\n    let mut lo = _mm256_setr_m128i(va, vb);\n    let mut hi = _mm256_setr_m128i(vc, vd);\n    lo = _mm256_xor_si256(lo, hi);\n    _mm256_storeu_si256(out.as_mut_ptr() as *mut __m256i, lo);\n    out\n"]], "pred": {"ppl": 1.545182704925537, "ppl_lower": 1.5639104843139648, "ppl/lowercase_ppl": -1.0276857715806758, "ppl/zlib": 0.00040179331391809704, "Min_5.0% Prob": 5.734658311395084, "Min_10.0% Prob": 3.820673617662168, "Min_20.0% Prob": 2.138356739472525, "Min_30.0% Prob": 1.448688493158936, "Min_40.0% Prob": 1.0873688263294894, "Min_50.0% Prob": 0.8709317636131646, "Min_60.0% Prob": 0.7261327353982577}}
{"hexsha": "98a03b76f858f57830553b494984ec682beb500c", "ext": "rs", "lang": "Rust", "content": "fn test_tc_aggregation_keep_last_only() {\n    ::libra_logger::Logger::new().environment_only(true).init();\n\n    let (signers, validator) = random_validator_verifier(4, Some(2), false);\n    let mut pending_votes = PendingVotes::new();\n\n    let li1 = random_ledger_info();\n    let vote_round_1 = random_vote_data(1);\n    let mut vote_round_1_author_0 = Vote::new(vote_round_1, signers[0].author(), li1, &signers[0]);\n    let timeout = vote_round_1_author_0.timeout();\n    let signature = timeout.sign(&signers[0]);\n    vote_round_1_author_0.add_timeout_signature(signature);\n\n    // first time a new vote is added the result is VoteAdded\n    assert_eq!(\n        pending_votes.insert_vote(&vote_round_1_author_0, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n\n    // A vote for round 2 overrides the previous vote\n    let li2 = random_ledger_info();\n    let vote_round_2 = random_vote_data(2);\n    let mut vote_round_2_author_0 = Vote::new(vote_round_2, signers[0].author(), li2, &signers[0]);\n    let timeout = vote_round_2_author_0.timeout();\n    let signature = timeout.sign(&signers[0]);\n    vote_round_2_author_0.add_timeout_signature(signature);\n    assert_eq!(\n        pending_votes.insert_vote(&vote_round_2_author_0, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n\n    // a new vote for round 1 cannot form a TC\n    let li3 = random_ledger_info();\n    let vote3_round_1 = random_vote_data(1);\n    let mut vote3_round_1_author_1 =\n        Vote::new(vote3_round_1, signers[1].author(), li3, &signers[1]);\n    let timeout = vote3_round_1_author_1.timeout();\n    let signature = timeout.sign(&signers[1]);\n    vote3_round_1_author_1.add_timeout_signature(signature);\n    assert_eq!(\n        pending_votes.insert_vote(&vote3_round_1_author_1, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n\n    // a new vote for round 2 should form a TC\n    let li4 = random_ledger_info();\n    let vote4_round_2 = random_vote_data(2);\n    let mut vote4_round_2_author_1 =\n        Vote::new(vote4_round_2, signers[1].author(), li4, &signers[1]);\n    let timeout = vote4_round_2_author_1.timeout();\n    let signature = timeout.sign(&signers[1]);\n    vote4_round_2_author_1.add_timeout_signature(signature);\n    match pending_votes.insert_vote(&vote4_round_2_author_1, &validator) {\n        VoteReceptionResult::NewTimeoutCertificate(tc) => {\n            assert!(validator.check_voting_power(tc.signatures().keys()).is_ok());\n        }\n        _ => {\n            panic!(\"No TC formed.\");\n        }\n    };\n}", "item_id": 3, "repo": "pranaypaine/libra", "file": "consensus/src/chained_bft/block_storage/pending_votes_test.rs", "last_update_at": "2020-08-18T07:16:13+00:00", "question_id": "98a03b76f858f57830553b494984ec682beb500c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_tc_aggregation_keep_last_only() {\n    ::libra_logger::Logger::new().environment_only(true).init();\n    let (signers, validator) = random_validator_verifier(4, Some(2), false);\n    let mut pending_votes = PendingVotes::new();\n    let li1 = random_ledger_info();\n    let vote_round_1 = random_vote_data(1);\n    let mut vote_round_1_author_0 = Vote::new(vote_round_1, signers[0].author(), li1, &signers[0]);\n    let timeout = vote_round_1_author_0.timeout();\n    let signature = timeout.sign(&signers[0]);\n    vote_round_1_author_0.add_timeout_signature(signature);\n    // first time a new vote is added the result is VoteAdded\n    assert_eq!(\n        pending_votes.insert_vote(&vote_round_1_author_0, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n    // A vote for round 2 overrides the previous vote\n    let li2 = random_ledger_info();\n    let vote_round_2 = random_vote_data(2);\n    let mut vote_round_2_author_0 = Vote::new(vote_round_2, signers[0].author(), li2, &signers[0]);\n    let timeout = vote_round_2_author_0.timeout();\n    let signature = timeout.sign(&signers[0]);\n    vote_round_2_author_0.add_timeout_signature(signature);\n    assert_eq!(\n        pending_votes.insert_vote(&vote_round_2_author_0, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n    // a new vote for round 1 cannot form a TC\n    let li3 = random_ledger_info();\n    let vote3_round_1 = random_vote_data(1);\n    let mut vote3_round_1_author_1 =\n        Vote::new(vote3_round_1, signers[1].author(), li3, &signers[1]);\n    let timeout = vote3_round_1_author_1.timeout();\n    let signature = timeout.sign(&signers[1]);\n    vote3_round_1_author_1.add_timeout_signature(signature);\n    assert_eq!(\n        pending_votes.insert_vote(&vote3_round_1_author_1, &validator),\n        VoteReceptionResult::VoteAdded(1)\n    );\n    // a new vote for round 2 should form a TC\n    let li4 = random_ledger_info();\n    let vote4_round_2 = random_vote_data(2);\n    let mut vote4_round_2_author_1 =\n        Vote::new(vote4_round_2, signers[1].author(), li4, &signers[1]);\n    let timeout = vote4_round_2_author_1.timeout();\n    let signature = timeout.sign(&signers[1]);\n    vote4_round_2_author_1.add_timeout_signature(signature);\n    match pending_votes.insert_vote(&vote4_round_2_author_1, &validator) {\n        VoteReceptionResult::NewTimeoutCertificate(tc) => {\n            assert!(validator.check_voting_power(tc.signatures().keys()).is_ok());\n        }\n        _ => {\n            panic!(\"No TC formed.\");\n        }\n    };\n"]], "pred": {"ppl": 1.684936761856079, "ppl_lower": 1.8381038904190063, "ppl/lowercase_ppl": -1.166766030199786, "ppl/zlib": 0.0008063802674564382, "Min_5.0% Prob": 5.927796260877089, "Min_10.0% Prob": 4.128060938267225, "Min_20.0% Prob": 2.514685706053366, "Min_30.0% Prob": 1.7328910965707887, "Min_40.0% Prob": 1.3051095102955186, "Min_50.0% Prob": 1.0443319347407047, "Min_60.0% Prob": 0.870135049973243}}
{"hexsha": "714cc595eff48deb7a8fe66630a0b2ec594d73d0", "ext": "rs", "lang": "Rust", "content": "fn argfile_build_fails_if_arg_contains_newline() {\n        let mut cmd = ProcessBuilder::new(\"echo\");\n        cmd.arg(\"foo\\n\");\n        let err = cmd.build_command_with_argfile().unwrap_err();\n        assert_eq!(\n            err.to_string(),\n            \"argument for argfile contains newlines: `foo\\n`\"\n        );\n    }", "item_id": 3, "repo": "orium/cargo", "file": "crates/cargo-util/src/process_builder.rs", "last_update_at": "2020-11-18T06:26:00+00:00", "question_id": "714cc595eff48deb7a8fe66630a0b2ec594d73d0_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn argfile_build_fails_if_arg_contains_newline() {\n        let mut cmd = ProcessBuilder::new(\"echo\");\n        cmd.arg(\"foo\\n\");\n        let err = cmd.build_command_with_argfile().unwrap_err();\n        assert_eq!(\n            err.to_string(),\n            \"argument for argfile contains newlines: `foo\\n`\"\n        );\n"]], "pred": {"ppl": 3.328603506088257, "ppl_lower": 3.7732813358306885, "ppl/lowercase_ppl": -1.1042716379743254, "ppl/zlib": 0.006135473716796576, "Min_5.0% Prob": 9.268694639205933, "Min_10.0% Prob": 6.93922922346327, "Min_20.0% Prob": 4.663770801142642, "Min_30.0% Prob": 3.602994705068654, "Min_40.0% Prob": 2.895100468244308, "Min_50.0% Prob": 2.3703265424285616, "Min_60.0% Prob": 2.000251417190342}}
{"hexsha": "5f93ce57b3f820ff6e951b817fd18b7956deca2a", "ext": "rs", "lang": "Rust", "content": "fn test_read_default_header() -> Result<()> {\n        let mut proto_header = proto::Header::default();\n        proto_header.set_num_docs(17);\n        proto_header.set_num_postings_lists(1234);\n\n        let buffer = header_to_buf(&proto_header)?;\n\n        let mut input = CodedInputStream::from_bytes(&buffer);\n        let header = Header::from_stream(&mut input)?;\n        assert_eq!(header.protobuf_header, proto_header);\n        assert_eq!(header.num_documents, 17);\n        assert_eq!(header.num_postings_lists, 1234);\n        Ok(())\n    }", "item_id": 14, "repo": "pisa-engine/common-index-format", "file": "src/lib.rs", "last_update_at": "2020-02-18T03:23:03+00:00", "question_id": "5f93ce57b3f820ff6e951b817fd18b7956deca2a_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_read_default_header() -> Result<()> {\n        let mut proto_header = proto::Header::default();\n        proto_header.set_num_docs(17);\n        proto_header.set_num_postings_lists(1234);\n        let buffer = header_to_buf(&proto_header)?;\n        let mut input = CodedInputStream::from_bytes(&buffer);\n        let header = Header::from_stream(&mut input)?;\n        assert_eq!(header.protobuf_header, proto_header);\n        assert_eq!(header.num_documents, 17);\n        assert_eq!(header.num_postings_lists, 1234);\n        Ok(())\n"]], "pred": {"ppl": 2.5256052017211914, "ppl_lower": 3.0652310848236084, "ppl/lowercase_ppl": -1.2090083902214364, "ppl/zlib": 0.0037059228714308597, "Min_5.0% Prob": 8.19259399175644, "Min_10.0% Prob": 6.214340069714715, "Min_20.0% Prob": 4.004649901390076, "Min_30.0% Prob": 2.9522335208379307, "Min_40.0% Prob": 2.2822420043604716, "Min_50.0% Prob": 1.8426526772196998, "Min_60.0% Prob": 1.5508070373109408}}
{"hexsha": "11075a0348f32450e695baae613d19a55c6e2794", "ext": "rs", "lang": "Rust", "content": "pub fn doit<'a>(lines: impl Iterator<Item = &'a String>, validate: bool) -> usize {\n    let mut result = 0;\n\n    for p in split_passports(lines) {\n        result += match get_passport(&p) {\n            Some(p) => match validate {\n                true => match p.validate() {\n                    Ok(_) => 1,\n                    Err(_) => 0,\n                },\n                false => 1,\n            },\n            None => 0,\n        };\n    }\n\n    result\n}", "item_id": 3, "repo": "syphar/advent_of_code_2020", "file": "d04/src/main.rs", "last_update_at": "2020-12-09T08:12:21+00:00", "question_id": "11075a0348f32450e695baae613d19a55c6e2794_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn doit<'a>(lines: impl Iterator<Item = &'a String>, validate: bool) -> usize {\n    let mut result = 0;\n    for p in split_passports(lines) {\n        result += match get_passport(&p) {\n            Some(p) => match validate {\n                true => match p.validate() {\n                    Ok(_) => 1,\n                    Err(_) => 0,\n                },\n                false => 1,\n            },\n            None => 0,\n        };\n    }\n    result\n"]], "pred": {"ppl": 2.425546646118164, "ppl_lower": 3.0912764072418213, "ppl/lowercase_ppl": -1.2737151043419175, "ppl/zlib": 0.0039912473876828275, "Min_5.0% Prob": 9.160034338633219, "Min_10.0% Prob": 6.5721572912656345, "Min_20.0% Prob": 4.017089574425309, "Min_30.0% Prob": 2.885997439920902, "Min_40.0% Prob": 2.186887656373006, "Min_50.0% Prob": 1.7767897398391765, "Min_60.0% Prob": 1.474182279792005}}
{"hexsha": "db20bcf4643175c89522cfcad15dd73d361c2e77", "ext": "rs", "lang": "Rust", "content": "pub async fn ws_index(r: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {\n  debug!(\"{:?}\", r);\n  let res = ws::start(WebSocket::new(), &r, stream);\n  debug!(\"{:?}\", res);\n  res\n}", "item_id": 0, "repo": "PedroGao/rust-restapi", "file": "src/websocket/ws.rs", "last_update_at": "2020-05-01T13:06:34+00:00", "question_id": "db20bcf4643175c89522cfcad15dd73d361c2e77_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn ws_index(r: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {\n  debug!(\"{:?}\", r);\n  let res = ws::start(WebSocket::new(), &r, stream);\n  debug!(\"{:?}\", res);\n  res\n"]], "pred": {"ppl": 3.0468437671661377, "ppl_lower": 5.252529144287109, "ppl/lowercase_ppl": -1.4888254513632861, "ppl/zlib": 0.007051305217565149, "Min_5.0% Prob": 9.72575855255127, "Min_10.0% Prob": 7.151735510144915, "Min_20.0% Prob": 4.736651386533465, "Min_30.0% Prob": 3.4323412151563737, "Min_40.0% Prob": 2.6834746854645863, "Min_50.0% Prob": 2.194658604690007, "Min_60.0% Prob": 1.8458537700630369}}
{"hexsha": "1f90815901232e23886b4e9b6e8a7e53b984794b", "ext": "rs", "lang": "Rust", "content": "fn test_irregular() {\n        let epsilon = 0.0001;\n\n        let points = vec![\n            Tup { x: 12.0, y: 0.0 },\n            Tup { x: 14.0, y: 0.4 },\n            Tup { x: 16.0, y: 0.4 }, // this point is redundant\n            Tup { x: 20.0, y: 0.4 },\n            Tup { x: 30.0, y: 0.7 },\n            Tup { x: 13.0, y: 0.0 }, // This point is out-of-order within the Vec, but in-order regaring x and y\n            Tup { x: 40.0, y: 1.0 },\n        ];\n        let mut c = IrregularDynamicCurve::<f32, f32>::new(points);\n\n        // Test x bounds\n        assert_eq!(c.min_x(), 12.0);\n        assert_eq!(c.max_x(), 40.0);\n\n        // Test x outside of bounds\n        assert_eq!(c.y_at_x(0.0), 0.0);\n        assert_eq!(c.y_at_x(100.0), 1.0);\n\n        // Test x equal to the actual points\n        assert_approx_eq!(c.y_at_x(12.0), 0.0, epsilon);\n        assert_approx_eq!(c.y_at_x(13.0), 0.0, epsilon);\n        assert_approx_eq!(c.y_at_x(14.0), 0.4, epsilon);\n        assert_approx_eq!(c.y_at_x(40.0), 1.0, epsilon);\n\n        // Test arbitrary \"integer\" x values\n        assert_approx_eq!(c.y_at_x(25.0), 0.55, epsilon);\n        assert_approx_eq!(c.y_at_x(35.0), 0.85, epsilon);\n    \n        // Test arbitrary \"float\" x values\n        assert_approx_eq!(c.y_at_x(13.5), 0.2, epsilon);\n        assert_approx_eq!(c.y_at_x(15.5), 0.4, epsilon);\n    \n        // Test y queries\n        assert_approx_eq!(c.x_at_y(0.0), 12.0, epsilon);\n        assert_approx_eq!(c.x_at_y(1.0), 40.0, epsilon);\n        assert!(c.x_at_y(0.4) >= 14.0);\n        assert!(c.x_at_y(0.4) <= 20.0);\n        assert_approx_eq!(c.x_at_y(0.7), 30.0, epsilon);\n        \n        assert_approx_eq!(c.x_at_y(0.2), 13.5, epsilon);\n\n        c.add_point(35.0, 0.9);\n        assert_approx_eq!(c.y_at_x(35.0), 0.9, epsilon);\n        assert_approx_eq!(c.y_at_x(32.5), 0.8, epsilon);\n\n        // let mut fg = Figure::new();\n        // let axes = fg.axes2d();\n        \n        assert_eq!(c.len(), 8);\n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C original\"), Color(\"grey\")]);\n\n        c.simplify(0.0);\n        assert_eq!(c.len(), 7); // should only remove the redundant point\n        // TODO if the curve begins with multuple 0.0 values or ends with mutluple 0.1 \n        \n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C pseudo-simplified\"), Color(\"black\")]);\n\n        c.simplify(0.1);\n        assert!(c.len() < 7); // should remove at least one more point\n\n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C simplified\"), Color(\"red\")]);\n\n        // fg.show();\n    }", "item_id": 0, "repo": "dystonse/dystonse-curves", "file": "src/irregular_dynamic.rs", "last_update_at": "2020-12-02T12:01:03+00:00", "question_id": "1f90815901232e23886b4e9b6e8a7e53b984794b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_irregular() {\n        let epsilon = 0.0001;\n        let points = vec![\n            Tup { x: 12.0, y: 0.0 },\n            Tup { x: 14.0, y: 0.4 },\n            Tup { x: 16.0, y: 0.4 }, // this point is redundant\n            Tup { x: 20.0, y: 0.4 },\n            Tup { x: 30.0, y: 0.7 },\n            Tup { x: 13.0, y: 0.0 }, // This point is out-of-order within the Vec, but in-order regaring x and y\n            Tup { x: 40.0, y: 1.0 },\n        ];\n        let mut c = IrregularDynamicCurve::<f32, f32>::new(points);\n        // Test x bounds\n        assert_eq!(c.min_x(), 12.0);\n        assert_eq!(c.max_x(), 40.0);\n        // Test x outside of bounds\n        assert_eq!(c.y_at_x(0.0), 0.0);\n        assert_eq!(c.y_at_x(100.0), 1.0);\n        // Test x equal to the actual points\n        assert_approx_eq!(c.y_at_x(12.0), 0.0, epsilon);\n        assert_approx_eq!(c.y_at_x(13.0), 0.0, epsilon);\n        assert_approx_eq!(c.y_at_x(14.0), 0.4, epsilon);\n        assert_approx_eq!(c.y_at_x(40.0), 1.0, epsilon);\n        // Test arbitrary \"integer\" x values\n        assert_approx_eq!(c.y_at_x(25.0), 0.55, epsilon);\n        assert_approx_eq!(c.y_at_x(35.0), 0.85, epsilon);\n        // Test arbitrary \"float\" x values\n        assert_approx_eq!(c.y_at_x(13.5), 0.2, epsilon);\n        assert_approx_eq!(c.y_at_x(15.5), 0.4, epsilon);\n        // Test y queries\n        assert_approx_eq!(c.x_at_y(0.0), 12.0, epsilon);\n        assert_approx_eq!(c.x_at_y(1.0), 40.0, epsilon);\n        assert!(c.x_at_y(0.4) >= 14.0);\n        assert!(c.x_at_y(0.4) <= 20.0);\n        assert_approx_eq!(c.x_at_y(0.7), 30.0, epsilon);\n        assert_approx_eq!(c.x_at_y(0.2), 13.5, epsilon);\n        c.add_point(35.0, 0.9);\n        assert_approx_eq!(c.y_at_x(35.0), 0.9, epsilon);\n        assert_approx_eq!(c.y_at_x(32.5), 0.8, epsilon);\n        // let mut fg = Figure::new();\n        // let axes = fg.axes2d();\n        assert_eq!(c.len(), 8);\n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C original\"), Color(\"grey\")]);\n        c.simplify(0.0);\n        assert_eq!(c.len(), 7); // should only remove the redundant point\n        // TODO if the curve begins with multuple 0.0 values or ends with mutluple 0.1 \n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C pseudo-simplified\"), Color(\"black\")]);\n        c.simplify(0.1);\n        assert!(c.len() < 7); // should remove at least one more point\n        //let c_plot = c.get_values_as_vectors();\n        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption(\"C simplified\"), Color(\"red\")]);\n        // fg.show();\n"]], "pred": {"ppl": 2.0319864749908447, "ppl_lower": 2.0641438961029053, "ppl/lowercase_ppl": -1.022145812924717, "ppl/zlib": 0.0009256055792240752, "Min_5.0% Prob": 6.927597167445164, "Min_10.0% Prob": 5.124889944113937, "Min_20.0% Prob": 3.2536057496772095, "Min_30.0% Prob": 2.3146903004521637, "Min_40.0% Prob": 1.7614241027817459, "Min_50.0% Prob": 1.4165080787355186, "Min_60.0% Prob": 1.182474586836155}}
{"hexsha": "730344198d26fb3588e47d36a33d118c8f38cb34", "ext": "rs", "lang": "Rust", "content": "fn sign_tx(tx: TransactionView, key: &Privkey) -> TransactionView {\n    const SIGNATURE_SIZE: usize = 65;\n\n    let witnesses_len = tx.witnesses().len();\n    let tx_hash = tx.hash();\n    let mut signed_witnesses: Vec<packed::Bytes> = Vec::new();\n    let mut blake2b = new_blake2b();\n    let mut message = [0u8; 32];\n    blake2b.update(&tx_hash.raw_data());\n    // digest the first witness\n    let witness = WitnessArgs::default();\n    let zero_lock: Bytes = {\n        let mut buf = Vec::new();\n        buf.resize(SIGNATURE_SIZE, 0);\n        buf.into()\n    };\n    let witness_for_digest = witness\n        .clone()\n        .as_builder()\n        .lock(Some(zero_lock).pack())\n        .build();\n    let witness_len = witness_for_digest.as_bytes().len() as u64;\n    blake2b.update(&witness_len.to_le_bytes());\n    blake2b.update(&witness_for_digest.as_bytes());\n    (1..witnesses_len).for_each(|n| {\n        let witness = tx.witnesses().get(n).unwrap();\n        let witness_len = witness.raw_data().len() as u64;\n        blake2b.update(&witness_len.to_le_bytes());\n        blake2b.update(&witness.raw_data());\n    });\n    blake2b.finalize(&mut message);\n    let message = H256::from(message);\n    let sig = key.sign_recoverable(&message).expect(\"sign\");\n    signed_witnesses.push(\n        witness\n            .as_builder()\n            .lock(Some(Bytes::from(sig.serialize())).pack())\n            .build()\n            .as_bytes()\n            .pack(),\n    );\n    for i in 1..witnesses_len {\n        signed_witnesses.push(tx.witnesses().get(i).unwrap());\n    }\n    tx.as_advanced_builder()\n        .set_witnesses(signed_witnesses)\n        .build()\n}", "item_id": 1, "repo": "yuche/ckb-dex-contract", "file": "tests/src/order_book_tests.rs", "last_update_at": "2020-10-19T03:49:40+00:00", "question_id": "730344198d26fb3588e47d36a33d118c8f38cb34_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sign_tx(tx: TransactionView, key: &Privkey) -> TransactionView {\n    const SIGNATURE_SIZE: usize = 65;\n    let witnesses_len = tx.witnesses().len();\n    let tx_hash = tx.hash();\n    let mut signed_witnesses: Vec<packed::Bytes> = Vec::new();\n    let mut blake2b = new_blake2b();\n    let mut message = [0u8; 32];\n    blake2b.update(&tx_hash.raw_data());\n    // digest the first witness\n    let witness = WitnessArgs::default();\n    let zero_lock: Bytes = {\n        let mut buf = Vec::new();\n        buf.resize(SIGNATURE_SIZE, 0);\n        buf.into()\n    };\n    let witness_for_digest = witness\n        .clone()\n        .as_builder()\n        .lock(Some(zero_lock).pack())\n        .build();\n    let witness_len = witness_for_digest.as_bytes().len() as u64;\n    blake2b.update(&witness_len.to_le_bytes());\n    blake2b.update(&witness_for_digest.as_bytes());\n    (1..witnesses_len).for_each(|n| {\n        let witness = tx.witnesses().get(n).unwrap();\n        let witness_len = witness.raw_data().len() as u64;\n        blake2b.update(&witness_len.to_le_bytes());\n        blake2b.update(&witness.raw_data());\n    });\n    blake2b.finalize(&mut message);\n    let message = H256::from(message);\n    let sig = key.sign_recoverable(&message).expect(\"sign\");\n    signed_witnesses.push(\n        witness\n            .as_builder()\n            .lock(Some(Bytes::from(sig.serialize())).pack())\n            .build()\n            .as_bytes()\n            .pack(),\n    );\n    for i in 1..witnesses_len {\n        signed_witnesses.push(tx.witnesses().get(i).unwrap());\n    }\n    tx.as_advanced_builder()\n        .set_witnesses(signed_witnesses)\n        .build()\n"]], "pred": {"ppl": 1.6168848276138306, "ppl_lower": 1.8703922033309937, "ppl/lowercase_ppl": -1.3031142171603558, "ppl/zlib": 0.0008062103223033684, "Min_5.0% Prob": 5.236625071229605, "Min_10.0% Prob": 3.698011319516069, "Min_20.0% Prob": 2.242861972886975, "Min_30.0% Prob": 1.5765920446746136, "Min_40.0% Prob": 1.195208684376934, "Min_50.0% Prob": 0.961433858444494, "Min_60.0% Prob": 0.800642736117859}}
{"hexsha": "da59c534a3163c9bd36b0aa327759dc9a387ef39", "ext": "rs", "lang": "Rust", "content": "pub fn with_repo<F>(file_contents: &str, file: &str, callback: F)\n    where\n        F: Fn(&Repository, &str),\n    {\n        let dir = tempfile::Builder::new()\n            .prefix(\"testgitrepo\")\n            .tempdir()\n            .expect(\"can't create tmp dir\");\n\n        let repo = Repository::init(&dir).expect(\"can't initialise repository\");\n\n        let path = dir.path().join(file);\n        path.parent().map(|parent| fs::create_dir_all(&parent));\n        fs::File::create(path)\n            .and_then(|mut file| file.write_all(file_contents.as_bytes()))\n            .expect(\"can't write file contents\");\n\n        let time = Time::new(123_456_789, 0);\n        let sig = Signature::new(\"Foo McBarson\", \"foo.mcbarson@iamarealboy.net\", &time)\n            .expect(\"couldn't create signature for commit\");\n\n        let commit_oid = repo\n            .index()\n            .and_then(|mut index| {\n                index\n                    .add_path(Path::new(file))\n                    .expect(\"can't add file to index\");\n\n                index\n                    .write_tree()\n                    .and_then(|tid| repo.find_tree(tid))\n                    .and_then(|tree| {\n                        repo.commit(Some(\"HEAD\"), &sig, &sig, \"Initial commit\", &tree, &[])\n                    })\n            })\n            .expect(\"can't do first commit\");\n\n        let commit = repo\n            .find_object(commit_oid, None)\n            .expect(\"Could not find first commit.\");\n        repo.tag(\"this-is-a-tag\", &commit, &sig, \"This is a tag.\", false)\n            .expect(\"Could not create tag.\");\n\n        let commit_sha = format!(\"{}\", commit_oid);\n\n        callback(&repo, &commit_sha);\n        dir.close().expect(\"couldn't close the dir\");\n    }", "item_id": 0, "repo": "intenthq/gitkv", "file": "git/src/lib.rs", "last_update_at": "2020-05-22T12:49:23+00:00", "question_id": "da59c534a3163c9bd36b0aa327759dc9a387ef39_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn with_repo<F>(file_contents: &str, file: &str, callback: F)\n    where\n        F: Fn(&Repository, &str),\n    {\n        let dir = tempfile::Builder::new()\n            .prefix(\"testgitrepo\")\n            .tempdir()\n            .expect(\"can't create tmp dir\");\n        let repo = Repository::init(&dir).expect(\"can't initialise repository\");\n        let path = dir.path().join(file);\n        path.parent().map(|parent| fs::create_dir_all(&parent));\n        fs::File::create(path)\n            .and_then(|mut file| file.write_all(file_contents.as_bytes()))\n            .expect(\"can't write file contents\");\n        let time = Time::new(123_456_789, 0);\n        let sig = Signature::new(\"Foo McBarson\", \"foo.mcbarson@iamarealboy.net\", &time)\n            .expect(\"couldn't create signature for commit\");\n        let commit_oid = repo\n            .index()\n            .and_then(|mut index| {\n                index\n                    .add_path(Path::new(file))\n                    .expect(\"can't add file to index\");\n                index\n                    .write_tree()\n                    .and_then(|tid| repo.find_tree(tid))\n                    .and_then(|tree| {\n                        repo.commit(Some(\"HEAD\"), &sig, &sig, \"Initial commit\", &tree, &[])\n                    })\n            })\n            .expect(\"can't do first commit\");\n        let commit = repo\n            .find_object(commit_oid, None)\n            .expect(\"Could not find first commit.\");\n        repo.tag(\"this-is-a-tag\", &commit, &sig, \"This is a tag.\", false)\n            .expect(\"Could not create tag.\");\n        let commit_sha = format!(\"{}\", commit_oid);\n        callback(&repo, &commit_sha);\n        dir.close().expect(\"couldn't close the dir\");\n"]], "pred": {"ppl": 2.0810372829437256, "ppl_lower": 2.663733959197998, "ppl/lowercase_ppl": -1.3368450213171637, "ppl/zlib": 0.0010889546257500482, "Min_5.0% Prob": 6.720837516784668, "Min_10.0% Prob": 4.86639957334481, "Min_20.0% Prob": 3.199478607551724, "Min_30.0% Prob": 2.333675428738002, "Min_40.0% Prob": 1.8071110239069836, "Min_50.0% Prob": 1.4580957561847754, "Min_60.0% Prob": 1.220591762646159}}
{"hexsha": "4bafbac85b82b48627cb5e5d752ebe33d43c9991", "ext": "rs", "lang": "Rust", "content": "fn test_merge_uint_max(mut x: IncrementOnlyUintProp, y: IncrementOnlyUintProp) {\n        init_test_env();\n        x.merge_property(&y);\n        assert_eq!(x.clone(), std::cmp::max(x, y));\n    }", "item_id": 6, "repo": "insanitybit/grapl", "file": "src/rust/rust-proto-new/src/graplinc/grapl/api/graph/v1beta1.rs", "last_update_at": "2020-04-21T20:31:39+00:00", "question_id": "4bafbac85b82b48627cb5e5d752ebe33d43c9991_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_merge_uint_max(mut x: IncrementOnlyUintProp, y: IncrementOnlyUintProp) {\n        init_test_env();\n        x.merge_property(&y);\n        assert_eq!(x.clone(), std::cmp::max(x, y));\n"]], "pred": {"ppl": 6.851927757263184, "ppl_lower": 9.107453346252441, "ppl/lowercase_ppl": -1.1478610802318563, "ppl/zlib": 0.014047664504377324, "Min_5.0% Prob": 10.214284261067709, "Min_10.0% Prob": 9.207266194479805, "Min_20.0% Prob": 7.050566843577793, "Min_30.0% Prob": 5.547353886422657, "Min_40.0% Prob": 4.538613247019904, "Min_50.0% Prob": 3.7451790009226116, "Min_60.0% Prob": 3.1699084990790913}}
{"hexsha": "382a1ed431703e0a3e85583574917dc47b1f2aa2", "ext": "rs", "lang": "Rust", "content": "async fn check_add_documents_with_primary_key_param() {\n    let mut server = common::Server::with_uid(\"movies\");\n\n    // 1 - Create the index with no primary_key\n\n    let body = json!({\n        \"uid\": \"movies\",\n    });\n    let (response, status_code) = server.create_index(body).await;\n    assert_eq!(status_code, 201);\n    assert_eq!(response[\"primaryKey\"], json!(null));\n\n    // 2 - Add documents\n\n    let body = json!([{\n      \"title\": \"Test\",\n      \"comment\": \"comment test\"\n    }]);\n\n    let url = \"/indexes/movies/documents?primaryKey=title\";\n    let (response, status_code) = server.post_request(&url, body).await;\n    eprintln!(\"{:#?}\", response);\n    assert_eq!(status_code, 202);\n    let update_id = response[\"updateId\"].as_u64().unwrap();\n    server.wait_update_id(update_id).await;\n\n    // 3 - Check update success\n\n    let (response, status_code) = server.get_update_status(update_id).await;\n    assert_eq!(status_code, 200);\n    assert_eq!(response[\"status\"], \"processed\");\n}", "item_id": 0, "repo": "hah/MeiliSearch", "file": "meilisearch-http/tests/documents_add.rs", "last_update_at": "2020-12-13T05:15:03+00:00", "question_id": "382a1ed431703e0a3e85583574917dc47b1f2aa2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn check_add_documents_with_primary_key_param() {\n    let mut server = common::Server::with_uid(\"movies\");\n    // 1 - Create the index with no primary_key\n    let body = json!({\n        \"uid\": \"movies\",\n    });\n    let (response, status_code) = server.create_index(body).await;\n    assert_eq!(status_code, 201);\n    assert_eq!(response[\"primaryKey\"], json!(null));\n    // 2 - Add documents\n    let body = json!([{\n      \"title\": \"Test\",\n      \"comment\": \"comment test\"\n    }]);\n    let url = \"/indexes/movies/documents?primaryKey=title\";\n    let (response, status_code) = server.post_request(&url, body).await;\n    eprintln!(\"{:#?}\", response);\n    assert_eq!(status_code, 202);\n    let update_id = response[\"updateId\"].as_u64().unwrap();\n    server.wait_update_id(update_id).await;\n    // 3 - Check update success\n    let (response, status_code) = server.get_update_status(update_id).await;\n    assert_eq!(status_code, 200);\n    assert_eq!(response[\"status\"], \"processed\");\n"]], "pred": {"ppl": 1.9430551528930664, "ppl_lower": 2.2071824073791504, "ppl/lowercase_ppl": -1.1918750481107137, "ppl/zlib": 0.0015270380584454489, "Min_5.0% Prob": 6.2788947224617, "Min_10.0% Prob": 4.5964390581304375, "Min_20.0% Prob": 2.998443819693665, "Min_30.0% Prob": 2.1460186475515366, "Min_40.0% Prob": 1.6345940059356725, "Min_50.0% Prob": 1.3235273315699514, "Min_60.0% Prob": 1.1046535118357903}}
{"hexsha": "2e4e2eee00e584d2429df7e1c6ac746c0896b2d1", "ext": "rs", "lang": "Rust", "content": "pub fn main() {\n    let mut sys = actix::System::new(\"HttpServerClient\");\n\n    let mut clients = ClientMap::new();\n    // Register a dummy client instance\n    let client = Client::public(\n        \"LocalClient\",                                     // Client id\n        \"http://localhost:8021/endpoint\".parse().unwrap(), // Redirection url\n        \"default\".parse().unwrap(),\n    ); // Allowed client scope\n    clients.register_client(client);\n\n    // Authorization tokens are 16 byte random keys to a memory hash map.\n    let authorizer = AuthMap::new(RandomGenerator::new(16));\n\n    // Bearer tokens are also random generated but 256-bit tokens, since they live longer and this\n    // example is somewhat paranoid.\n    //\n    // We could also use a `TokenSigner::ephemeral` here to create signed tokens which can be read\n    // and parsed by anyone, but not maliciously created. However, they can not be revoked and thus\n    // don't offer even longer lived refresh tokens.\n    let issuer = TokenMap::new(RandomGenerator::new(16));\n\n    let scopes = vec![\"default\".parse().unwrap()].into_boxed_slice();\n    // Emulate static initialization for complex type\n    let scopes: &'static _ = Box::leak(scopes);\n\n    let state = State {\n        registrar: AsActor(clients).start(),\n        authorizer: AsActor(authorizer).start(),\n        issuer: AsActor(issuer).start(),\n        scopes,\n    };\n\n    // Create the main server instance\n    server::new(move || {\n        App::with_state(state.clone())\n            .middleware(Logger::default())\n            .resource(\"/authorize\", |r| {\n                r.get().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            authorization(\n                                state.registrar,\n                                state.authorizer,\n                                FnSolicitor(|_: &mut _, grant: &_| in_progress_response(grant)),\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(|response| response.get_or_consent_with(consent_form))\n                        .map_err(OAuthFailure::from)\n                });\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    let allowed = req.query_string().contains(\"allow\");\n                    req.oauth2()\n                        .and_then(move |request| {\n                            authorization(\n                                state.registrar,\n                                state.authorizer,\n                                FnSolicitor(move |_: &mut _, grant: &_| {\n                                    consent_decision(allowed, grant)\n                                }),\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                });\n            })\n            .resource(\"/token\", |r| {\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            access_token(\n                                state.registrar,\n                                state.authorizer,\n                                state.issuer,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                })\n            })\n            .resource(\"/refresh\", |r| {\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            refresh(\n                                state.registrar,\n                                state.issuer,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                })\n            })\n            .resource(\"/\", |r| {\n                r.get().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .map_err(ResourceProtection::Error)\n                        .and_then(|request| {\n                            resource(\n                                state.issuer,\n                                state.scopes,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        // Any accepted grant is good enough.\n                        .map(|_grant| {\n                            HttpResponse::Ok()\n                                .content_type(\"text/plain\")\n                                .body(\"HELLO BILL \ud83e\udd80\")\n                        })\n                        .or_else(|result| match result {\n                            ResourceProtection::Respond(response) => {\n                                let mut response = response.unwrap();\n                                response.set_body(DENY_TEXT);\n                                Ok(response)\n                            }\n                            ResourceProtection::Error(err) => Err(OAuthFailure::from(err)),\n                        })\n                })\n            })\n    })\n    .bind(\"0.0.0.0:8020\")\n    .expect(\"Failed to bind to socket\")\n    .start();\n\n    server::new(support::dummy_client)\n        .bind(\"0.0.0.0:8021\")\n        .expect(\"Failed to start dummy client\")\n        .start();\n\n    // Start, then open in browser, don't care about this finishing.\n    let _: Result<(), ()> = sys.block_on(future::lazy(|| {\n        let _ = thread::spawn(support::open_in_browser);\n        future::ok(())\n    }));\n\n    // Run the rest of the system.\n    let _ = sys.run();\n}", "item_id": 0, "repo": "Terkwood/linkedin-rs", "file": "oauth-endpoint/src/main.rs", "last_update_at": "2020-08-02T17:11:12+00:00", "question_id": "2e4e2eee00e584d2429df7e1c6ac746c0896b2d1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main() {\n    let mut sys = actix::System::new(\"HttpServerClient\");\n    let mut clients = ClientMap::new();\n    // Register a dummy client instance\n    let client = Client::public(\n        \"LocalClient\",                                     // Client id\n        \"http://localhost:8021/endpoint\".parse().unwrap(), // Redirection url\n        \"default\".parse().unwrap(),\n    ); // Allowed client scope\n    clients.register_client(client);\n    // Authorization tokens are 16 byte random keys to a memory hash map.\n    let authorizer = AuthMap::new(RandomGenerator::new(16));\n    // Bearer tokens are also random generated but 256-bit tokens, since they live longer and this\n    // example is somewhat paranoid.\n    //\n    // We could also use a `TokenSigner::ephemeral` here to create signed tokens which can be read\n    // and parsed by anyone, but not maliciously created. However, they can not be revoked and thus\n    // don't offer even longer lived refresh tokens.\n    let issuer = TokenMap::new(RandomGenerator::new(16));\n    let scopes = vec![\"default\".parse().unwrap()].into_boxed_slice();\n    // Emulate static initialization for complex type\n    let scopes: &'static _ = Box::leak(scopes);\n    let state = State {\n        registrar: AsActor(clients).start(),\n        authorizer: AsActor(authorizer).start(),\n        issuer: AsActor(issuer).start(),\n        scopes,\n    };\n    // Create the main server instance\n    server::new(move || {\n        App::with_state(state.clone())\n            .middleware(Logger::default())\n            .resource(\"/authorize\", |r| {\n                r.get().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            authorization(\n                                state.registrar,\n                                state.authorizer,\n                                FnSolicitor(|_: &mut _, grant: &_| in_progress_response(grant)),\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(|response| response.get_or_consent_with(consent_form))\n                        .map_err(OAuthFailure::from)\n                });\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    let allowed = req.query_string().contains(\"allow\");\n                    req.oauth2()\n                        .and_then(move |request| {\n                            authorization(\n                                state.registrar,\n                                state.authorizer,\n                                FnSolicitor(move |_: &mut _, grant: &_| {\n                                    consent_decision(allowed, grant)\n                                }),\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                });\n            })\n            .resource(\"/token\", |r| {\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            access_token(\n                                state.registrar,\n                                state.authorizer,\n                                state.issuer,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                })\n            })\n            .resource(\"/refresh\", |r| {\n                r.post().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .and_then(|request| {\n                            refresh(\n                                state.registrar,\n                                state.issuer,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        .map(OAuthResponse::unwrap)\n                        .map_err(OAuthFailure::from)\n                })\n            })\n            .resource(\"/\", |r| {\n                r.get().a(|req: &HttpRequest<State>| {\n                    let state = req.state().clone();\n                    req.oauth2()\n                        .map_err(ResourceProtection::Error)\n                        .and_then(|request| {\n                            resource(\n                                state.issuer,\n                                state.scopes,\n                                request,\n                                OAuthResponse::default(),\n                            )\n                        })\n                        // Any accepted grant is good enough.\n                        .map(|_grant| {\n                            HttpResponse::Ok()\n                                .content_type(\"text/plain\")\n                                .body(\"HELLO BILL \ud83e\udd80\")\n                        })\n                        .or_else(|result| match result {\n                            ResourceProtection::Respond(response) => {\n                                let mut response = response.unwrap();\n                                response.set_body(DENY_TEXT);\n                                Ok(response)\n                            }\n                            ResourceProtection::Error(err) => Err(OAuthFailure::from(err)),\n                        })\n                })\n            })\n    })\n    .bind(\"0.0.0.0:8020\")\n    .expect(\"Failed to bind to socket\")\n    .start();\n    server::new(support::dummy_client)\n        .bind(\"0.0.0.0:8021\")\n        .expect(\"Failed to start dummy client\")\n        .start();\n    // Start, then open in browser, don't care about this finishing.\n    let _: Result<(), ()> = sys.block_on(future::lazy(|| {\n        let _ = thread::spawn(support::open_in_browser);\n        future::ok(())\n    }));\n    // Run the rest of the system.\n    let _ = sys.run();\n"]], "pred": {"ppl": 2.8808953762054443, "ppl_lower": 3.123922109603882, "ppl/lowercase_ppl": -1.0765410368888693, "ppl/zlib": 0.0006933821365307655, "Min_5.0% Prob": 8.109218634811102, "Min_10.0% Prob": 6.40970967797672, "Min_20.0% Prob": 4.499177396881814, "Min_30.0% Prob": 3.3791634882587234, "Min_40.0% Prob": 2.6131351000303744, "Min_50.0% Prob": 2.1110649184996366, "Min_60.0% Prob": 1.7641605180103277}}
{"hexsha": "c6b861b282fbccbc0bcd5e5afd4592250621131a", "ext": "rs", "lang": "Rust", "content": "fn share_from_u8_slice_works() {\n        let bytes = [1, 2, 3];\n        let share = Share::from(&bytes[..]);\n        assert_eq!(share.x, GF256(1));\n        assert_eq!(share.y, vec![GF256(2), GF256(3)]);\n    }", "item_id": 1, "repo": "l4l/sharks", "file": "src/share.rs", "last_update_at": "2020-05-02T20:51:53+00:00", "question_id": "c6b861b282fbccbc0bcd5e5afd4592250621131a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn share_from_u8_slice_works() {\n        let bytes = [1, 2, 3];\n        let share = Share::from(&bytes[..]);\n        assert_eq!(share.x, GF256(1));\n        assert_eq!(share.y, vec![GF256(2), GF256(3)]);\n"]], "pred": {"ppl": 2.7549774646759033, "ppl_lower": 3.4068658351898193, "ppl/lowercase_ppl": -1.2095732728717485, "ppl/zlib": 0.0075067352798552775, "Min_5.0% Prob": 9.37434470653534, "Min_10.0% Prob": 7.207405991024441, "Min_20.0% Prob": 4.464044080840217, "Min_30.0% Prob": 3.18796396807388, "Min_40.0% Prob": 2.4677253224783473, "Min_50.0% Prob": 2.0070572012000616, "Min_60.0% Prob": 1.6848549753151558}}
{"hexsha": "3d46be9cadb53c64b97ee5ea210ca153b317f178", "ext": "rs", "lang": "Rust", "content": "fn statfs_call() {\n        check_statfs(\"/tmp\");\n        check_statfs(\"/dev\");\n        check_statfs(\"/run\");\n        check_statfs(\"/\");\n    }", "item_id": 0, "repo": "hadfl/nix", "file": "src/sys/statfs.rs", "last_update_at": "2020-06-25T16:06:59+00:00", "question_id": "3d46be9cadb53c64b97ee5ea210ca153b317f178_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn statfs_call() {\n        check_statfs(\"/tmp\");\n        check_statfs(\"/dev\");\n        check_statfs(\"/run\");\n        check_statfs(\"/\");\n"]], "pred": {"ppl": 4.527816295623779, "ppl_lower": 4.527816295623779, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.024758029005301652, "Min_5.0% Prob": 9.111403465270996, "Min_10.0% Prob": 7.752710938453674, "Min_20.0% Prob": 5.776724338531494, "Min_30.0% Prob": 4.666743663641123, "Min_40.0% Prob": 3.648258854945501, "Min_50.0% Prob": 3.047068627043204, "Min_60.0% Prob": 2.509336621535045}}
{"hexsha": "f9778364422044466a50e9d53c1dc70d0a36c152", "ext": "rs", "lang": "Rust", "content": "pub fn format_event(request: &CsmlRequest) -> Result<Event, EngineError> {\n    let step_limit = request.step_limit;\n    let json_event = json!(request);\n\n    let content_type = match json_event[\"payload\"][\"content_type\"].as_str() {\n        Some(content_type) => content_type.to_string(),\n        None => {\n            return Err(EngineError::Interpreter(\n                \"no content_type in event payload\".to_owned(),\n            ))\n        }\n    };\n    let content = json_event[\"payload\"][\"content\"].to_owned();\n\n    let content_value = get_event_content(&content_type, &content)?;\n\n    Ok(Event {\n        content_type,\n        content_value,\n        content,\n        ttl_duration: json_event[\"ttl_duration\"].as_i64(),\n        low_data_mode: json_event[\"low_data_mode\"].as_bool(),\n        step_limit,\n        secure: json_event[\"payload\"][\"secure\"].as_bool().unwrap_or(false),\n    })\n}", "item_id": 1, "repo": "CSML-by-Clevy/csml-interpreter", "file": "csml_engine/src/utils.rs", "last_update_at": "2020-06-24T11:21:52+00:00", "question_id": "f9778364422044466a50e9d53c1dc70d0a36c152_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn format_event(request: &CsmlRequest) -> Result<Event, EngineError> {\n    let step_limit = request.step_limit;\n    let json_event = json!(request);\n    let content_type = match json_event[\"payload\"][\"content_type\"].as_str() {\n        Some(content_type) => content_type.to_string(),\n        None => {\n            return Err(EngineError::Interpreter(\n                \"no content_type in event payload\".to_owned(),\n            ))\n        }\n    };\n    let content = json_event[\"payload\"][\"content\"].to_owned();\n    let content_value = get_event_content(&content_type, &content)?;\n    Ok(Event {\n        content_type,\n        content_value,\n        content,\n        ttl_duration: json_event[\"ttl_duration\"].as_i64(),\n        low_data_mode: json_event[\"low_data_mode\"].as_bool(),\n        step_limit,\n        secure: json_event[\"payload\"][\"secure\"].as_bool().unwrap_or(false),\n    })\n"]], "pred": {"ppl": 2.4735093116760254, "ppl_lower": 3.0092148780822754, "ppl/lowercase_ppl": -1.2164676269825585, "ppl/zlib": 0.0024676782459221915, "Min_5.0% Prob": 8.007014861473671, "Min_10.0% Prob": 6.010268017097756, "Min_20.0% Prob": 3.9495867556995816, "Min_30.0% Prob": 2.87201358506709, "Min_40.0% Prob": 2.228182894488176, "Min_50.0% Prob": 1.8080069776486467, "Min_60.0% Prob": 1.5124718468567286}}
{"hexsha": "6c04827b6e07d59df5ffb7cf16bbc97e1dbb54ba", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = 939601;\n    let mut board = vec![3, 7];\n    let mut elfo = 0;\n    let mut twinkels = 1;\n\n    let mut score;\n    let mut print_count = 10;\n\n    for _ in 0..input + 10 {\n        score = board[elfo] + board[twinkels];\n\n        let mut digits = vec![];\n        if score >= 10 {\n            digits.push(score / 10);\n            score %= 10;\n        }\n        digits.push(score);\n\n        for digit in digits {\n            board.push(digit);\n            if board.len() > input {\n                print_count -= 1;\n                print!(\"{}\", board[board.len() - 1]);\n                if print_count == 0 {\n                    break;\n                }\n            }\n        }\n\n        if board.len() > input {\n            print_count -= 1;\n            print!(\"{}\", board[board.len() - 1]);\n            if print_count == 0 {\n                break;\n            }\n        }\n\n        elfo = (elfo + board[elfo] + 1) % board.len();\n        twinkels = (twinkels + board[twinkels] + 1) % board.len();\n    }\n}", "item_id": 0, "repo": "ckuenzi/AoC", "file": "aoc_2018/aoc_14_1/src/main.rs", "last_update_at": "2020-12-11T18:08:04+00:00", "question_id": "6c04827b6e07d59df5ffb7cf16bbc97e1dbb54ba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input = 939601;\n    let mut board = vec![3, 7];\n    let mut elfo = 0;\n    let mut twinkels = 1;\n    let mut score;\n    let mut print_count = 10;\n    for _ in 0..input + 10 {\n        score = board[elfo] + board[twinkels];\n        let mut digits = vec![];\n        if score >= 10 {\n            digits.push(score / 10);\n            score %= 10;\n        }\n        digits.push(score);\n        for digit in digits {\n            board.push(digit);\n            if board.len() > input {\n                print_count -= 1;\n                print!(\"{}\", board[board.len() - 1]);\n                if print_count == 0 {\n                    break;\n                }\n            }\n        }\n        if board.len() > input {\n            print_count -= 1;\n            print!(\"{}\", board[board.len() - 1]);\n            if print_count == 0 {\n                break;\n            }\n        }\n        elfo = (elfo + board[elfo] + 1) % board.len();\n        twinkels = (twinkels + board[twinkels] + 1) % board.len();\n    }\n"]], "pred": {"ppl": 1.9623479843139648, "ppl_lower": 1.9623479843139648, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0021066928357876403, "Min_5.0% Prob": 6.56362085044384, "Min_10.0% Prob": 4.61843157898296, "Min_20.0% Prob": 2.9587402397127294, "Min_30.0% Prob": 2.1522482553921125, "Min_40.0% Prob": 1.659362562718215, "Min_50.0% Prob": 1.3414261873216318, "Min_60.0% Prob": 1.1260955789181781}}
{"hexsha": "991abc68fc1bdcdf03c433f0c42ff7a2a97cdd8e", "ext": "rs", "lang": "Rust", "content": "pub fn analyze(repository: &git2::Repository) -> Result<BranchStatus, git2::Error> {\n    let head = match repository.head() {\n        Ok(h) => h,\n        Err(_e) => {\n            return Ok(BranchStatus {\n                name: \"detached\".to_string(),\n                local: None,\n                upstream: None,\n            })\n        }\n    };\n\n    let branch_name = head.name().unwrap();\n\n    let hr_name = if branch_name == \"refs/heads/master\" {\n        \"\ud83c\udd7c\"\n    } else {\n        head.shorthand().unwrap()\n    };\n\n    let local = repository\n        .find_branch(\"master\", git2::BranchType::Local)\n        .and_then(|master: git2::Branch| {\n            repository.graph_ahead_behind(head.target().unwrap(), master.get().target().unwrap())\n        })\n        .ok();\n\n    let upstream = repository\n        .branch_upstream_name(branch_name)\n        .ok()\n        .and_then(|bname_buf: git2::Buf| bname_buf.as_str().map(|s| s.to_string()))\n        .and_then(|bname| {\n            repository\n                .graph_ahead_behind(\n                    head.target().unwrap(),\n                    repository.refname_to_id(&bname).unwrap(),\n                )\n                .ok()\n        });\n\n    Ok(BranchStatus {\n        name: hr_name.to_string(),\n        local,\n        upstream,\n    })\n}", "item_id": 0, "repo": "piotrkowalczuk/rustygitprompt", "file": "src/branch.rs", "last_update_at": "2020-02-28T10:11:17+00:00", "question_id": "991abc68fc1bdcdf03c433f0c42ff7a2a97cdd8e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn analyze(repository: &git2::Repository) -> Result<BranchStatus, git2::Error> {\n    let head = match repository.head() {\n        Ok(h) => h,\n        Err(_e) => {\n            return Ok(BranchStatus {\n                name: \"detached\".to_string(),\n                local: None,\n                upstream: None,\n            })\n        }\n    };\n    let branch_name = head.name().unwrap();\n    let hr_name = if branch_name == \"refs/heads/master\" {\n        \"\ud83c\udd7c\"\n    } else {\n        head.shorthand().unwrap()\n    };\n    let local = repository\n        .find_branch(\"master\", git2::BranchType::Local)\n        .and_then(|master: git2::Branch| {\n            repository.graph_ahead_behind(head.target().unwrap(), master.get().target().unwrap())\n        })\n        .ok();\n    let upstream = repository\n        .branch_upstream_name(branch_name)\n        .ok()\n        .and_then(|bname_buf: git2::Buf| bname_buf.as_str().map(|s| s.to_string()))\n        .and_then(|bname| {\n            repository\n                .graph_ahead_behind(\n                    head.target().unwrap(),\n                    repository.refname_to_id(&bname).unwrap(),\n                )\n                .ok()\n        });\n    Ok(BranchStatus {\n        name: hr_name.to_string(),\n        local,\n        upstream,\n    })\n"]], "pred": {"ppl": 1.977052092552185, "ppl_lower": 2.2951173782348633, "ppl/lowercase_ppl": -1.2188608944148611, "ppl/zlib": 0.0014502274322006486, "Min_5.0% Prob": 6.7775139808654785, "Min_10.0% Prob": 4.82814761919853, "Min_20.0% Prob": 3.1016216163451853, "Min_30.0% Prob": 2.201956662965023, "Min_40.0% Prob": 1.6940655075725477, "Min_50.0% Prob": 1.3601012589495043, "Min_60.0% Prob": 1.137124237740586}}
{"hexsha": "80fa18313a8e7a9ec805fe85d9ad56f76fee9834", "ext": "rs", "lang": "Rust", "content": "pub fn get_skill_name_on_skillbar(ecs: &World, index: usize) -> Option<String> {\n    let skills_component = ecs.read_storage::<SkillsComponent>();\n    let skills = &skills_component.grab(find_player(&ecs)).skills;\n    skills.get(index).map(|s| get_current_skill_on_skillbar(ecs, s))\n}", "item_id": 1, "repo": "chamons/ArenaGS", "file": "src/props/skillbar.rs", "last_update_at": "2020-11-24T15:53:49+00:00", "question_id": "80fa18313a8e7a9ec805fe85d9ad56f76fee9834_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_skill_name_on_skillbar(ecs: &World, index: usize) -> Option<String> {\n    let skills_component = ecs.read_storage::<SkillsComponent>();\n    let skills = &skills_component.grab(find_player(&ecs)).skills;\n    skills.get(index).map(|s| get_current_skill_on_skillbar(ecs, s))\n"]], "pred": {"ppl": 3.72428035736084, "ppl_lower": 5.0469279289245605, "ppl/lowercase_ppl": -1.2311294997455655, "ppl/zlib": 0.007031409842313423, "Min_5.0% Prob": 9.263014793395996, "Min_10.0% Prob": 7.941612386703492, "Min_20.0% Prob": 5.4480965705144975, "Min_30.0% Prob": 4.058010151609778, "Min_40.0% Prob": 3.2261178145805993, "Min_50.0% Prob": 2.606685721930468, "Min_60.0% Prob": 2.1818960707169026}}
{"hexsha": "358c80ac6a11f86317dc01f1b171bb92ac7be63b", "ext": "rs", "lang": "Rust", "content": "fn serialize_list() -> Result<()> {\n        assert_eq!(to_string(&Vec::<u8>::default())?, \"the empty list\");\n        assert_eq!(\n            to_string(&vec![1, 2, 3])?,\n            \"the list where an item is 1 and another item is 2 and another item is 3\"\n        );\n        assert_eq!(to_string(&vec![vec![1, 2], vec![], vec![3, 4]])?, \"the list henceforth `the list` where an item is the list where an item is 1 and another item is 2 and another item of `the list` is the empty list and another item is the list where an item is 3 and another item is 4\");\n        Ok(())\n    }", "item_id": 6, "repo": "RiddleAndCode/nlsd", "file": "nlsd/src/ser.rs", "last_update_at": "2020-09-12T15:55:24+00:00", "question_id": "358c80ac6a11f86317dc01f1b171bb92ac7be63b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn serialize_list() -> Result<()> {\n        assert_eq!(to_string(&Vec::<u8>::default())?, \"the empty list\");\n        assert_eq!(\n            to_string(&vec![1, 2, 3])?,\n            \"the list where an item is 1 and another item is 2 and another item is 3\"\n        );\n        assert_eq!(to_string(&vec![vec![1, 2], vec![], vec![3, 4]])?, \"the list henceforth `the list` where an item is the list where an item is 1 and another item is 2 and another item of `the list` is the empty list and another item is the list where an item is 3 and another item is 4\");\n        Ok(())\n"]], "pred": {"ppl": 2.4677023887634277, "ppl_lower": 2.8462111949920654, "ppl/lowercase_ppl": -1.1579798149787406, "ppl/zlib": 0.0038113397078081007, "Min_5.0% Prob": 9.688492986891005, "Min_10.0% Prob": 6.783311367034912, "Min_20.0% Prob": 4.092018158899413, "Min_30.0% Prob": 2.9085000494012125, "Min_40.0% Prob": 2.2478135774532952, "Min_50.0% Prob": 1.7980761937387697, "Min_60.0% Prob": 1.5058139265438013}}
{"hexsha": "f3b29f7af5592a86eb8162081a5ed8cc14da1f3e", "ext": "rs", "lang": "Rust", "content": "pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        network_manager_name: &str,\n        configuration_name: &str,\n        rule_collection_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = & format ! (\"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Network/networkManagers/{}/securityUserConfigurations/{}/ruleCollections/{}\" , operation_config . base_path () , subscription_id , resource_group_name , network_manager_name , configuration_name , rule_collection_name) ;\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 42, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/network/src/package_2021_02_preview_only/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "f3b29f7af5592a86eb8162081a5ed8cc14da1f3e_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        network_manager_name: &str,\n        configuration_name: &str,\n        rule_collection_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = & format ! (\"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Network/networkManagers/{}/securityUserConfigurations/{}/ruleCollections/{}\" , operation_config . base_path () , subscription_id , resource_group_name , network_manager_name , configuration_name , rule_collection_name) ;\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.0865293741226196, "ppl_lower": 2.059413194656372, "ppl/lowercase_ppl": -8.705068758624074, "ppl/zlib": 9.605156932480736e-05, "Min_5.0% Prob": 1.6992808068171144, "Min_10.0% Prob": 0.8398407783923456, "Min_20.0% Prob": 0.41682967325331594, "Min_30.0% Prob": 0.2771874706980404, "Min_40.0% Prob": 0.20762840139048788, "Min_50.0% Prob": 0.16597689854983516, "Min_60.0% Prob": 0.13859505814574843}}
{"hexsha": "587de4efbea5c97b02c5aa9942f9045a64223ae0", "ext": "rs", "lang": "Rust", "content": "fn into_weighted_edge() {\n        // Test with tuple.\n        assert_eq!((1, 2).into_weighted_edge(), (1, 2, f32::default()));\n\n        // Test with triple.\n        assert_eq!((1, 2, 3).into_weighted_edge(), (1, 2, 3));\n\n        // Test with triple having edge weight as reference.\n        assert_eq!((1, 2, &3).into_weighted_edge(), (1, 2, 3));\n\n        // Test with tuple as reference.\n        assert_eq!((&(1, 2)).into_weighted_edge(), (1, 2, f32::default()));\n\n        // Test with triple as reference.\n        assert_eq!((&(1, 2, 3)).into_weighted_edge(), (1, 2, 3));\n    }", "item_id": 9, "repo": "songzhi/rs-data-structure", "file": "src/graph/edge.rs", "last_update_at": "2020-12-30T18:58:32+00:00", "question_id": "587de4efbea5c97b02c5aa9942f9045a64223ae0_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn into_weighted_edge() {\n        // Test with tuple.\n        assert_eq!((1, 2).into_weighted_edge(), (1, 2, f32::default()));\n        // Test with triple.\n        assert_eq!((1, 2, 3).into_weighted_edge(), (1, 2, 3));\n        // Test with triple having edge weight as reference.\n        assert_eq!((1, 2, &3).into_weighted_edge(), (1, 2, 3));\n        // Test with tuple as reference.\n        assert_eq!((&(1, 2)).into_weighted_edge(), (1, 2, f32::default()));\n        // Test with triple as reference.\n        assert_eq!((&(1, 2, 3)).into_weighted_edge(), (1, 2, 3));\n"]], "pred": {"ppl": 1.8162283897399902, "ppl_lower": 1.8655626773834229, "ppl/lowercase_ppl": -1.0449101518701815, "ppl/zlib": 0.0036837162811520826, "Min_5.0% Prob": 6.672514390945435, "Min_10.0% Prob": 4.911914008004325, "Min_20.0% Prob": 2.9284861482853115, "Min_30.0% Prob": 1.9927826300263405, "Min_40.0% Prob": 1.4981979373842478, "Min_50.0% Prob": 1.1979967417844801, "Min_60.0% Prob": 0.9973610486961432}}
{"hexsha": "2a0795c121d8c9a18f56c74abd8b7ef5a982cf3c", "ext": "rs", "lang": "Rust", "content": "fn test_json_options() {\n        {\n            let json_options: JsonObjectOptions = (STORED | TEXT).into();\n            assert!(json_options.is_stored());\n            assert!(json_options.is_indexed());\n        }\n        {\n            let json_options: JsonObjectOptions = TEXT.into();\n            assert!(!json_options.is_stored());\n            assert!(json_options.is_indexed());\n        }\n        {\n            let json_options: JsonObjectOptions = STORED.into();\n            assert!(json_options.is_stored());\n            assert!(!json_options.is_indexed());\n        }\n    }", "item_id": 0, "repo": "arastoul/tantivy", "file": "src/schema/json_object_options.rs", "last_update_at": "2020-09-02T17:49:27+00:00", "question_id": "2a0795c121d8c9a18f56c74abd8b7ef5a982cf3c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_json_options() {\n        {\n            let json_options: JsonObjectOptions = (STORED | TEXT).into();\n            assert!(json_options.is_stored());\n            assert!(json_options.is_indexed());\n        }\n        {\n            let json_options: JsonObjectOptions = TEXT.into();\n            assert!(!json_options.is_stored());\n            assert!(json_options.is_indexed());\n        }\n        {\n            let json_options: JsonObjectOptions = STORED.into();\n            assert!(json_options.is_stored());\n            assert!(!json_options.is_indexed());\n        }\n"]], "pred": {"ppl": 1.8252111673355103, "ppl_lower": 2.013498306274414, "ppl/lowercase_ppl": -1.1631688136308, "ppl/zlib": 0.004237293580773467, "Min_5.0% Prob": 7.1785977482795715, "Min_10.0% Prob": 5.054899126291275, "Min_20.0% Prob": 2.976873670704663, "Min_30.0% Prob": 2.036070788356786, "Min_40.0% Prob": 1.507521955898175, "Min_50.0% Prob": 1.2104171452106747, "Min_60.0% Prob": 1.0109538420423934}}
{"hexsha": "0ff40e66345a25521016013896ad94c66b3d3645", "ext": "rs", "lang": "Rust", "content": "fn roundtrip<T: Vlq>(value: T) -> T {\n        let mut buf = vec![];\n        buf.write_vlq(value).expect(\"successful write\");\n        Cursor::new(buf).read_vlq().expect(\"successful read\")\n    }", "item_id": 0, "repo": "bbqsrc/vlq-rust", "file": "src/lib.rs", "last_update_at": "2020-01-20T15:26:11+00:00", "question_id": "0ff40e66345a25521016013896ad94c66b3d3645_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn roundtrip<T: Vlq>(value: T) -> T {\n        let mut buf = vec![];\n        buf.write_vlq(value).expect(\"successful write\");\n        Cursor::new(buf).read_vlq().expect(\"successful read\")\n"]], "pred": {"ppl": 3.2765190601348877, "ppl_lower": 4.345824718475342, "ppl/lowercase_ppl": -1.2379830909162406, "ppl/zlib": 0.008416890756770443, "Min_5.0% Prob": 9.649040222167969, "Min_10.0% Prob": 7.906182765960693, "Min_20.0% Prob": 5.237881440382737, "Min_30.0% Prob": 3.7351025342941284, "Min_40.0% Prob": 2.967753903223918, "Min_50.0% Prob": 2.3791519326694086, "Min_60.0% Prob": 1.9804799061268568}}
{"hexsha": "0c30ef963a29b9de24edc4ae4170076b2d60e040", "ext": "rs", "lang": "Rust", "content": "async fn verify_valid_message_duplicate_account_name() {\n    let (_db, connector, mut api, injector) = new_env().await;\n    let mut stream = api.ws_at(\"/api/account_status\").await.unwrap();\n\n    // Insert judgement requests.\n    connector.inject(alice_judgement_request()).await;\n    // Note: Bob specified the same Matrix handle as Alice.\n    connector\n        .inject(WatcherMessage::new_judgement_request({\n            let mut req = JudgementRequest::bob();\n            req.accounts\n                .entry(AccountType::Matrix)\n                .and_modify(|e| *e = \"@alice:matrix.org\".to_string());\n            req\n        }))\n        .await;\n\n    let states = connector.inserted_states().await;\n    let mut alice = states[0].clone();\n    let mut bob = states[1].clone();\n\n    // Subscribe to endpoint.\n    stream.send(IdentityContext::alice().to_ws()).await.unwrap();\n\n    // Check current state.\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(\n        resp,\n        JsonResult::Ok(ResponseAccountState::with_no_notifications(alice.clone()))\n    );\n\n    // Send valid message.\n    injector\n        .send(ExternalMessage {\n            origin: ExternalMessageType::Matrix(\"@alice:matrix.org\".to_string()),\n            id: MessageId::from(0u32),\n            timestamp: Timestamp::now(),\n            values: alice\n                .get_field(&F::ALICE_MATRIX())\n                .expected_message()\n                .to_message_parts(),\n        })\n        .await;\n\n    // Email account of Alice is now verified\n    alice\n        .get_field_mut(&F::ALICE_MATRIX())\n        .expected_message_mut()\n        .set_verified();\n\n    // The expected message (field verified successfully).\n    let expected = ResponseAccountState {\n        state: alice.clone().into(),\n        notifications: vec![NotificationMessage::FieldVerified {\n            context: alice.context.clone(),\n            field: F::ALICE_MATRIX(),\n        }],\n    };\n\n    // Check response\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(resp, JsonResult::Ok(expected));\n\n    // Other judgement states must be unaffected (Bob), but will receive a \"failed attempt\".\n    stream.send(IdentityContext::bob().to_ws()).await.unwrap();\n\n    *bob.get_field_mut(&F::ALICE_MATRIX()).failed_attempts_mut() = 1;\n\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(\n        resp,\n        JsonResult::Ok(ResponseAccountState::with_no_notifications(bob.clone()))\n    );\n\n    // Empty stream.\n    assert!(stream.next().now_or_never().is_none());\n}", "item_id": 8, "repo": "w3f/polkadot-registrar-bot", "file": "src/tests/api_judgement_state.rs", "last_update_at": "2020-09-14T12:50:51+00:00", "question_id": "0c30ef963a29b9de24edc4ae4170076b2d60e040_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn verify_valid_message_duplicate_account_name() {\n    let (_db, connector, mut api, injector) = new_env().await;\n    let mut stream = api.ws_at(\"/api/account_status\").await.unwrap();\n    // Insert judgement requests.\n    connector.inject(alice_judgement_request()).await;\n    // Note: Bob specified the same Matrix handle as Alice.\n    connector\n        .inject(WatcherMessage::new_judgement_request({\n            let mut req = JudgementRequest::bob();\n            req.accounts\n                .entry(AccountType::Matrix)\n                .and_modify(|e| *e = \"@alice:matrix.org\".to_string());\n            req\n        }))\n        .await;\n    let states = connector.inserted_states().await;\n    let mut alice = states[0].clone();\n    let mut bob = states[1].clone();\n    // Subscribe to endpoint.\n    stream.send(IdentityContext::alice().to_ws()).await.unwrap();\n    // Check current state.\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(\n        resp,\n        JsonResult::Ok(ResponseAccountState::with_no_notifications(alice.clone()))\n    );\n    // Send valid message.\n    injector\n        .send(ExternalMessage {\n            origin: ExternalMessageType::Matrix(\"@alice:matrix.org\".to_string()),\n            id: MessageId::from(0u32),\n            timestamp: Timestamp::now(),\n            values: alice\n                .get_field(&F::ALICE_MATRIX())\n                .expected_message()\n                .to_message_parts(),\n        })\n        .await;\n    // Email account of Alice is now verified\n    alice\n        .get_field_mut(&F::ALICE_MATRIX())\n        .expected_message_mut()\n        .set_verified();\n    // The expected message (field verified successfully).\n    let expected = ResponseAccountState {\n        state: alice.clone().into(),\n        notifications: vec![NotificationMessage::FieldVerified {\n            context: alice.context.clone(),\n            field: F::ALICE_MATRIX(),\n        }],\n    };\n    // Check response\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(resp, JsonResult::Ok(expected));\n    // Other judgement states must be unaffected (Bob), but will receive a \"failed attempt\".\n    stream.send(IdentityContext::bob().to_ws()).await.unwrap();\n    *bob.get_field_mut(&F::ALICE_MATRIX()).failed_attempts_mut() = 1;\n    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();\n    assert_eq!(\n        resp,\n        JsonResult::Ok(ResponseAccountState::with_no_notifications(bob.clone()))\n    );\n    // Empty stream.\n    assert!(stream.next().now_or_never().is_none());\n"]], "pred": {"ppl": 3.2487502098083496, "ppl_lower": 3.5816595554351807, "ppl/lowercase_ppl": -1.0827958393689066, "ppl/zlib": 0.0012481677664775584, "Min_5.0% Prob": 8.557755909467998, "Min_10.0% Prob": 6.773491017230145, "Min_20.0% Prob": 4.957409436826582, "Min_30.0% Prob": 3.7011143079605597, "Min_40.0% Prob": 2.8984272453005646, "Min_50.0% Prob": 2.3460697000918462, "Min_60.0% Prob": 1.9637533625555705}}
{"hexsha": "f80c6b4ebb0991825a6a7bd67624779b98009564", "ext": "rs", "lang": "Rust", "content": "fn bench_update_depth4(bench: &mut Bencher) {\n    static mut TEST_HUNK: [u8; 256*1024*1024] = [0; 256*1024*1024];\n    let slab = Slab::new(unsafe { Block::from_slice(&mut TEST_HUNK) }, 4096);\n    let pool = &Pool::new(&slab);\n\n    bench_update!(bench, pool, 1 << 20);\n}", "item_id": 4, "repo": "swimos/swim-kernel", "file": "lib/collections/benches/hash_trie_map_benches.rs", "last_update_at": "2020-11-19T06:12:10+00:00", "question_id": "f80c6b4ebb0991825a6a7bd67624779b98009564_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_update_depth4(bench: &mut Bencher) {\n    static mut TEST_HUNK: [u8; 256*1024*1024] = [0; 256*1024*1024];\n    let slab = Slab::new(unsafe { Block::from_slice(&mut TEST_HUNK) }, 4096);\n    let pool = &Pool::new(&slab);\n    bench_update!(bench, pool, 1 << 20);\n"]], "pred": {"ppl": 3.1985960006713867, "ppl_lower": 4.135530948638916, "ppl/lowercase_ppl": -1.2209521945664132, "ppl/zlib": 0.006055791477794986, "Min_5.0% Prob": 7.837481260299683, "Min_10.0% Prob": 6.769825605245737, "Min_20.0% Prob": 4.682892415258619, "Min_30.0% Prob": 3.5112089005912224, "Min_40.0% Prob": 2.802969463445522, "Min_50.0% Prob": 2.293122153071796, "Min_60.0% Prob": 1.9303441674607555}}
{"hexsha": "e19ee678d407c34b2970d249b036274abf46995f", "ext": "rs", "lang": "Rust", "content": "fn input_files_content_to_digest(context: Context, args: Vec<Value>) -> NodeFuture<Value> {\n  let file_values = externs::project_multi(&args[0], \"dependencies\");\n  let digests: Vec<_> = file_values\n    .iter()\n    .map(|file| {\n      let filename = externs::project_str(&file, \"path\");\n      let path: PathBuf = filename.into();\n      let bytes = bytes::Bytes::from(externs::project_bytes(&file, \"content\"));\n      let is_executable = externs::project_bool(&file, \"is_executable\");\n\n      let store = context.core.store();\n      async move {\n        let digest = store.store_file_bytes(bytes, true).await?;\n        let snapshot = store\n          .snapshot_of_one_file(path, digest, is_executable)\n          .await?;\n        let res: Result<_, String> = Ok(snapshot.digest);\n        res\n      }\n    })\n    .collect();\n\n  Box::pin(async move {\n    let digests = future03::try_join_all(digests).await?;\n    let digest = store::Snapshot::merge_directories(context.core.store(), digests).await?;\n    let res: Result<_, String> = Ok(Snapshot::store_directory(&context.core, &digest));\n    res\n  })\n  .compat()\n  .map_err(|err: String| throw(&err))\n  .to_boxed()\n}", "item_id": 3, "repo": "pyranja/pants", "file": "src/rust/engine/src/intrinsics.rs", "last_update_at": "2020-05-19T02:47:47+00:00", "question_id": "e19ee678d407c34b2970d249b036274abf46995f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn input_files_content_to_digest(context: Context, args: Vec<Value>) -> NodeFuture<Value> {\n  let file_values = externs::project_multi(&args[0], \"dependencies\");\n  let digests: Vec<_> = file_values\n    .iter()\n    .map(|file| {\n      let filename = externs::project_str(&file, \"path\");\n      let path: PathBuf = filename.into();\n      let bytes = bytes::Bytes::from(externs::project_bytes(&file, \"content\"));\n      let is_executable = externs::project_bool(&file, \"is_executable\");\n      let store = context.core.store();\n      async move {\n        let digest = store.store_file_bytes(bytes, true).await?;\n        let snapshot = store\n          .snapshot_of_one_file(path, digest, is_executable)\n          .await?;\n        let res: Result<_, String> = Ok(snapshot.digest);\n        res\n      }\n    })\n    .collect();\n  Box::pin(async move {\n    let digests = future03::try_join_all(digests).await?;\n    let digest = store::Snapshot::merge_directories(context.core.store(), digests).await?;\n    let res: Result<_, String> = Ok(Snapshot::store_directory(&context.core, &digest));\n    res\n  })\n  .compat()\n  .map_err(|err: String| throw(&err))\n  .to_boxed()\n"]], "pred": {"ppl": 2.6290016174316406, "ppl_lower": 3.1383872032165527, "ppl/lowercase_ppl": -1.1832237896280098, "ppl/zlib": 0.0019027640964064975, "Min_5.0% Prob": 7.543713066313002, "Min_10.0% Prob": 5.848248346431835, "Min_20.0% Prob": 3.9755240360895794, "Min_30.0% Prob": 2.9786871239147357, "Min_40.0% Prob": 2.345905417440743, "Min_50.0% Prob": 1.912905421167139, "Min_60.0% Prob": 1.611886385729355}}
{"hexsha": "11a41c56ce12ae30a52a9a4634b7c114286542f4", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn lv2_atom_sequence_append_event(\n    seq: *mut LV2AtomSequence,\n    capacity: u32,\n    event: *const LV2AtomEvent,\n) -> *const LV2AtomEvent {\n    let total_size = size_of::<LV2AtomEvent>() as u32 + (*event).body.size;\n\n    if (capacity - (*seq).atom.size) < total_size {\n        return 0 as *const LV2AtomEvent;\n    }\n\n    let e = lv2_atom_sequence_end(&(*seq).body, (*seq).atom.size);\n    memcpy(\n        e as *mut c_void,\n        event as *const c_void,\n        total_size as usize,\n    );\n\n    (*seq).atom.size += lv2_atom_pad_size(total_size);\n\n    e\n}", "item_id": 1, "repo": "wmedrano/lv2_raw", "file": "src/atomutils.rs", "last_update_at": "2020-12-27T10:37:29+00:00", "question_id": "11a41c56ce12ae30a52a9a4634b7c114286542f4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn lv2_atom_sequence_append_event(\n    seq: *mut LV2AtomSequence,\n    capacity: u32,\n    event: *const LV2AtomEvent,\n) -> *const LV2AtomEvent {\n    let total_size = size_of::<LV2AtomEvent>() as u32 + (*event).body.size;\n    if (capacity - (*seq).atom.size) < total_size {\n        return 0 as *const LV2AtomEvent;\n    }\n    let e = lv2_atom_sequence_end(&(*seq).body, (*seq).atom.size);\n    memcpy(\n        e as *mut c_void,\n        event as *const c_void,\n        total_size as usize,\n    );\n    (*seq).atom.size += lv2_atom_pad_size(total_size);\n    e\n"]], "pred": {"ppl": 2.0347177982330322, "ppl_lower": 2.2816860675811768, "ppl/lowercase_ppl": -1.161267526046936, "ppl/zlib": 0.0026212440412968856, "Min_5.0% Prob": 6.680903651497581, "Min_10.0% Prob": 5.134851336479187, "Min_20.0% Prob": 3.1754899726973638, "Min_30.0% Prob": 2.277060815202656, "Min_40.0% Prob": 1.7430767771270541, "Min_50.0% Prob": 1.418678647905056, "Min_60.0% Prob": 1.1821715990909272}}
{"hexsha": "dee4790211cb9d439272aee714df70f4aeb4a1d7", "ext": "rs", "lang": "Rust", "content": "pub fn get_scores_for_user(\n    conn: &PgConnection,\n    user_id: i64,\n    mode: i16,\n) -> Result<(Vec<Map>, Vec<DBScore>), diesel::result::Error> {\n    use schema::{maps, scores};\n\n    let scores: Vec<DBScore> = scores::table\n        .filter(\n            scores::dsl::user_id\n                .eq(user_id)\n                .and(scores::dsl::mode.eq(mode)),\n        )\n        .order_by(scores::dsl::performance_rating.desc())\n        .load(conn)?;\n    let all_map_ids: Vec<i64> = scores.iter().map(|score| score.map_id).collect();\n\n    let maps: Vec<Map> = maps::table\n        .filter(maps::dsl::id.eq_any(all_map_ids))\n        .load(conn)?;\n\n    Ok((maps, scores))\n}", "item_id": 2, "repo": "Ameobea/quavertrack", "file": "libquavertrack/src/db_util/mod.rs", "last_update_at": "2020-08-14T13:57:10+00:00", "question_id": "dee4790211cb9d439272aee714df70f4aeb4a1d7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_scores_for_user(\n    conn: &PgConnection,\n    user_id: i64,\n    mode: i16,\n) -> Result<(Vec<Map>, Vec<DBScore>), diesel::result::Error> {\n    use schema::{maps, scores};\n    let scores: Vec<DBScore> = scores::table\n        .filter(\n            scores::dsl::user_id\n                .eq(user_id)\n                .and(scores::dsl::mode.eq(mode)),\n        )\n        .order_by(scores::dsl::performance_rating.desc())\n        .load(conn)?;\n    let all_map_ids: Vec<i64> = scores.iter().map(|score| score.map_id).collect();\n    let maps: Vec<Map> = maps::table\n        .filter(maps::dsl::id.eq_any(all_map_ids))\n        .load(conn)?;\n    Ok((maps, scores))\n"]], "pred": {"ppl": 1.8233002424240112, "ppl_lower": 2.441446304321289, "ppl/lowercase_ppl": -1.4860456462645073, "ppl/zlib": 0.0018312444482376214, "Min_5.0% Prob": 6.056686917940776, "Min_10.0% Prob": 4.382618556420009, "Min_20.0% Prob": 2.793939697499178, "Min_30.0% Prob": 1.9786707818099898, "Min_40.0% Prob": 1.4971567966348054, "Min_50.0% Prob": 1.1987289334912368, "Min_60.0% Prob": 1.0043799147630732}}
{"hexsha": "92c73223280ce2b740f9f98dfa60a10b1d2c21dd", "ext": "rs", "lang": "Rust", "content": "pub fn write_test_file(len: usize) -> (TempDir, PathBuf, Vec<u8>) {\n    use ::std::fs;\n    let dir = TempDir::new().unwrap();\n    let pth = NamedTempFile::new_in(dir.path()).unwrap().path().to_owned();\n    let big = generate_test_file_content_for_test(len);\n    fs::write(&pth, &big).unwrap();\n    (dir, pth, big)\n}", "item_id": 2, "repo": "mverleg/file_endec", "file": "src/files/mockfile.rs", "last_update_at": "2020-03-29T18:07:27+00:00", "question_id": "92c73223280ce2b740f9f98dfa60a10b1d2c21dd_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn write_test_file(len: usize) -> (TempDir, PathBuf, Vec<u8>) {\n    use ::std::fs;\n    let dir = TempDir::new().unwrap();\n    let pth = NamedTempFile::new_in(dir.path()).unwrap().path().to_owned();\n    let big = generate_test_file_content_for_test(len);\n    fs::write(&pth, &big).unwrap();\n    (dir, pth, big)\n"]], "pred": {"ppl": 2.9509708881378174, "ppl_lower": 4.407993793487549, "ppl/lowercase_ppl": -1.370827778641717, "ppl/zlib": 0.005253078790429027, "Min_5.0% Prob": 8.595329443613688, "Min_10.0% Prob": 6.642796814441681, "Min_20.0% Prob": 4.5650069018205, "Min_30.0% Prob": 3.393547319703632, "Min_40.0% Prob": 2.6450096691648164, "Min_50.0% Prob": 2.147174789259831, "Min_60.0% Prob": 1.7989597180340853}}
{"hexsha": "4fb08bb8f5eeb5cdb8e1e954d4f82ebaa9179e58", "ext": "rs", "lang": "Rust", "content": "fn mac_to_u64(mac: &MacAddress) -> Result<u64, Error> {\n    let mac_bytes = mac.as_bytes();\n\n    let padded = vec![\n        0,\n        0,\n        mac_bytes[0],\n        mac_bytes[1],\n        mac_bytes[2],\n        mac_bytes[3],\n        mac_bytes[4],\n        mac_bytes[5],\n    ];\n\n    let mut padded_mac = &padded[..8];\n    let mac_num = padded_mac.read_u64::<NetworkEndian>().context(format!(\n        \"could not read_u64 from padded MAC byte array: {:?}\",\n        padded_mac\n    ))?;\n    Ok(mac_num)\n}", "item_id": 0, "repo": "AidoP/rs-oui", "file": "src/lib.rs", "last_update_at": "2020-12-17T03:37:48+00:00", "question_id": "4fb08bb8f5eeb5cdb8e1e954d4f82ebaa9179e58_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mac_to_u64(mac: &MacAddress) -> Result<u64, Error> {\n    let mac_bytes = mac.as_bytes();\n    let padded = vec![\n        0,\n        0,\n        mac_bytes[0],\n        mac_bytes[1],\n        mac_bytes[2],\n        mac_bytes[3],\n        mac_bytes[4],\n        mac_bytes[5],\n    ];\n    let mut padded_mac = &padded[..8];\n    let mac_num = padded_mac.read_u64::<NetworkEndian>().context(format!(\n        \"could not read_u64 from padded MAC byte array: {:?}\",\n        padded_mac\n    ))?;\n    Ok(mac_num)\n"]], "pred": {"ppl": 1.9729429483413696, "ppl_lower": 2.298332929611206, "ppl/lowercase_ppl": -1.2246531652302584, "ppl/zlib": 0.0026858747447605098, "Min_5.0% Prob": 6.250028663211399, "Min_10.0% Prob": 4.514553910807559, "Min_20.0% Prob": 3.025182990651382, "Min_30.0% Prob": 2.2202452520529428, "Min_40.0% Prob": 1.707294032908976, "Min_50.0% Prob": 1.3572264908289071, "Min_60.0% Prob": 1.134182381056978}}
{"hexsha": "cfaa057bd35dba2c18daa5014834a8d12586166a", "ext": "rs", "lang": "Rust", "content": "fn should_return_ok_of_none_when_block_results_has_no_account_event() {\n            let block_results = BlockResults {\n                height: Height::default().increment(),\n                results: Results {\n                    deliver_tx: Some(vec![DeliverTx {\n                        events: vec![Event {\n                            event_type: TendermintEventType::ValidTransactions.to_string(),\n                            attributes: vec![Attribute {\n                                key: TendermintEventKey::TxId.to_base64_string(),\n                                value: \"MDc2NmQ0ZTFjMDkxMjRhZjlhZWI0YTdlZDk5ZDgxNjU0YTg0NDczZjEzMzk0OGNlYTA1MGRhYTE3ZmYwZTdmZg==\".to_owned(),\n                            }],\n                        }],\n                    }]),\n                    end_block: None,\n                },\n            };\n\n            let target_account = StakedStateAddress::from(\n                RedeemAddress::from_str(\"0x0e7c045110b8dbf29765047380898919c5cb56f4\").unwrap(),\n            );\n            let result = block_results.contains_account(&target_account);\n            assert!(result.is_ok());\n            assert_eq!(false, result.unwrap());\n        }", "item_id": 3, "repo": "calvinlauco/chain", "file": "client-common/src/tendermint/types/block_results.rs", "last_update_at": "2020-10-02T14:05:14+00:00", "question_id": "cfaa057bd35dba2c18daa5014834a8d12586166a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_return_ok_of_none_when_block_results_has_no_account_event() {\n            let block_results = BlockResults {\n                height: Height::default().increment(),\n                results: Results {\n                    deliver_tx: Some(vec![DeliverTx {\n                        events: vec![Event {\n                            event_type: TendermintEventType::ValidTransactions.to_string(),\n                            attributes: vec![Attribute {\n                                key: TendermintEventKey::TxId.to_base64_string(),\n                                value: \"MDc2NmQ0ZTFjMDkxMjRhZjlhZWI0YTdlZDk5ZDgxNjU0YTg0NDczZjEzMzk0OGNlYTA1MGRhYTE3ZmYwZTdmZg==\".to_owned(),\n                            }],\n                        }],\n                    }]),\n                    end_block: None,\n                },\n            };\n            let target_account = StakedStateAddress::from(\n                RedeemAddress::from_str(\"0x0e7c045110b8dbf29765047380898919c5cb56f4\").unwrap(),\n            );\n            let result = block_results.contains_account(&target_account);\n            assert!(result.is_ok());\n            assert_eq!(false, result.unwrap());\n"]], "pred": {"ppl": 3.448172092437744, "ppl_lower": 6.339878559112549, "ppl/lowercase_ppl": -1.4919967476658125, "ppl/zlib": 0.002366815033184998, "Min_5.0% Prob": 7.491611507203844, "Min_10.0% Prob": 5.985960861047109, "Min_20.0% Prob": 4.388258013460371, "Min_30.0% Prob": 3.562420301967197, "Min_40.0% Prob": 2.9593756832182407, "Min_50.0% Prob": 2.4467518135077424, "Min_60.0% Prob": 2.0564666989569864}}
{"hexsha": "2dbcd10154d2cec77fa501a1abb1b55b16017288", "ext": "rs", "lang": "Rust", "content": "pub fn occluded<B: Bitmap>(p0: Point3i, p1: Point3i, solid: &B) -> bool {\n    // 3d bresenham, ripped from http://www.cobrabytes.com/index.php?topic=1150.0\n\n    // println!(\"{} {}\", DisplayWrap::from(p0), DisplayWrap::from(p1));\n\n    let mut x0 = p0.x;\n    let mut y0 = p0.y;\n    let mut z0 = p0.z;\n\n    let mut x1 = p1.x;\n    let mut y1 = p1.y;\n    let mut z1 = p1.z;\n\n    //'steep' xy Line, make longest delta x plane\n    let swap_xy = (y1 - y0).abs() > (x1 - x0).abs();\n    if swap_xy {\n        std::mem::swap(&mut x0, &mut y0);\n        std::mem::swap(&mut x1, &mut y1);\n    }\n\n    // do same for xz\n    let swap_xz = (z1 - z0).abs() > (x1 - x0).abs();\n    if swap_xz {\n        std::mem::swap(&mut x0, &mut z0);\n        std::mem::swap(&mut x1, &mut z1);\n    }\n\n    // delta is Length in each plane\n    let delta_x = (x1 - x0).abs();\n    let delta_y = (y1 - y0).abs();\n    let delta_z = (z1 - z0).abs();\n\n    // drift controls when to step in 'shallow' planes\n    // starting value keeps Line centred\n    let mut drift_xy = delta_x / 2;\n    let mut drift_xz = delta_x / 2;\n\n    // direction of line\n    let step_x = if x0 > x1 { -1 } else { 1 };\n    let step_y = if y0 > y1 { -1 } else { 1 };\n    let step_z = if z0 > z1 { -1 } else { 1 };\n\n    // starting point\n    let mut y = y0;\n    let mut z = z0;\n\n    // step through longest delta (which we have swapped to x)\n    let mut x = x0;\n    while x != x1 {\n        // copy position\n        let mut cx = x;\n        let mut cy = y;\n        let mut cz = z;\n\n        // unswap (in reverse)\n        if swap_xz {\n            std::mem::swap(&mut cx, &mut cz);\n        }\n\n        if swap_xy {\n            std::mem::swap(&mut cx, &mut cy);\n        }\n\n        if solid.get(Point3i::new(cx, cy, cz)) {\n            // println!(\"stop {}\", DisplayWrap::from(Point3i::new(cx, cy, cz)));\n            return true;\n        }\n        // update progress in other planes\n        drift_xy -= delta_y;\n        drift_xz -= delta_z;\n\n        // step in y plane\n        if drift_xy < 0 {\n            y += step_y;\n            drift_xy += delta_x;\n        }\n\n        // same in z\n        if drift_xz < 0 {\n            z += step_z;\n            drift_xz += delta_x;\n        }\n\n        x += step_x;\n    }\n\n    // return false;\n    false\n}", "item_id": 0, "repo": "sim82/crystal_planes", "file": "src/util.rs", "last_update_at": "2020-12-30T07:04:43+00:00", "question_id": "2dbcd10154d2cec77fa501a1abb1b55b16017288_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn occluded<B: Bitmap>(p0: Point3i, p1: Point3i, solid: &B) -> bool {\n    // 3d bresenham, ripped from http://www.cobrabytes.com/index.php?topic=1150.0\n    // println!(\"{} {}\", DisplayWrap::from(p0), DisplayWrap::from(p1));\n    let mut x0 = p0.x;\n    let mut y0 = p0.y;\n    let mut z0 = p0.z;\n    let mut x1 = p1.x;\n    let mut y1 = p1.y;\n    let mut z1 = p1.z;\n    //'steep' xy Line, make longest delta x plane\n    let swap_xy = (y1 - y0).abs() > (x1 - x0).abs();\n    if swap_xy {\n        std::mem::swap(&mut x0, &mut y0);\n        std::mem::swap(&mut x1, &mut y1);\n    }\n    // do same for xz\n    let swap_xz = (z1 - z0).abs() > (x1 - x0).abs();\n    if swap_xz {\n        std::mem::swap(&mut x0, &mut z0);\n        std::mem::swap(&mut x1, &mut z1);\n    }\n    // delta is Length in each plane\n    let delta_x = (x1 - x0).abs();\n    let delta_y = (y1 - y0).abs();\n    let delta_z = (z1 - z0).abs();\n    // drift controls when to step in 'shallow' planes\n    // starting value keeps Line centred\n    let mut drift_xy = delta_x / 2;\n    let mut drift_xz = delta_x / 2;\n    // direction of line\n    let step_x = if x0 > x1 { -1 } else { 1 };\n    let step_y = if y0 > y1 { -1 } else { 1 };\n    let step_z = if z0 > z1 { -1 } else { 1 };\n    // starting point\n    let mut y = y0;\n    let mut z = z0;\n    // step through longest delta (which we have swapped to x)\n    let mut x = x0;\n    while x != x1 {\n        // copy position\n        let mut cx = x;\n        let mut cy = y;\n        let mut cz = z;\n        // unswap (in reverse)\n        if swap_xz {\n            std::mem::swap(&mut cx, &mut cz);\n        }\n        if swap_xy {\n            std::mem::swap(&mut cx, &mut cy);\n        }\n        if solid.get(Point3i::new(cx, cy, cz)) {\n            // println!(\"stop {}\", DisplayWrap::from(Point3i::new(cx, cy, cz)));\n            return true;\n        }\n        // update progress in other planes\n        drift_xy -= delta_y;\n        drift_xz -= delta_z;\n        // step in y plane\n        if drift_xy < 0 {\n            y += step_y;\n            drift_xy += delta_x;\n        }\n        // same in z\n        if drift_xz < 0 {\n            z += step_z;\n            drift_xz += delta_x;\n        }\n        x += step_x;\n    }\n    // return false;\n    false\n"]], "pred": {"ppl": 2.0126149654388428, "ppl_lower": 2.0372495651245117, "ppl/lowercase_ppl": -1.0173937448461425, "ppl/zlib": 0.0008921362938301896, "Min_5.0% Prob": 7.492923514787541, "Min_10.0% Prob": 5.440569452855779, "Min_20.0% Prob": 3.3292472934585877, "Min_30.0% Prob": 2.314840961176317, "Min_40.0% Prob": 1.744406895717355, "Min_50.0% Prob": 1.3991351923883952, "Min_60.0% Prob": 1.1671622314705847}}
{"hexsha": "5bcfae6b0fb9e21d768d8c08bcfd046d8f5475b3", "ext": "rs", "lang": "Rust", "content": "fn regexp_builder_with_escaped_non_ascii_chars(test_cases: Vec<&str>, expected_output: &str) {\n        let regexp = RegExpBuilder::from(&test_cases)\n            .with_escaped_non_ascii_chars(false)\n            .build();\n        test_if_regexp_is_correct(regexp, expected_output);\n        test_if_regexp_matches_test_cases(expected_output, test_cases);\n    }", "item_id": 2, "repo": "lexxvir/grex", "file": "src/regexp.rs", "last_update_at": "2020-03-25T19:14:30+00:00", "question_id": "5bcfae6b0fb9e21d768d8c08bcfd046d8f5475b3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn regexp_builder_with_escaped_non_ascii_chars(test_cases: Vec<&str>, expected_output: &str) {\n        let regexp = RegExpBuilder::from(&test_cases)\n            .with_escaped_non_ascii_chars(false)\n            .build();\n        test_if_regexp_is_correct(regexp, expected_output);\n        test_if_regexp_matches_test_cases(expected_output, test_cases);\n"]], "pred": {"ppl": 2.7892839908599854, "ppl_lower": 3.4423038959503174, "ppl/lowercase_ppl": -1.2050683819816916, "ppl/zlib": 0.005698805159981914, "Min_5.0% Prob": 7.197726329167684, "Min_10.0% Prob": 5.784392058849335, "Min_20.0% Prob": 4.011952365438144, "Min_30.0% Prob": 3.0896502633889518, "Min_40.0% Prob": 2.446290373802185, "Min_50.0% Prob": 2.0298700904259914, "Min_60.0% Prob": 1.7174261628764949}}
{"hexsha": "01172475354df749ec1a58f3a232d7a5ac9dcc9e", "ext": "rs", "lang": "Rust", "content": "fn test_import() {\n    check_valid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (func (;0;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n\n    // only import runtime function is valid\n    check_invalid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (import \"env\" \"add\" (func (type 0)))\n    (func (;1;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n\n    // only import from `env` is valid\n    check_invalid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (import \"othermodule\" \"add\" (func (type 0)))\n    (func (;1;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n}", "item_id": 5, "repo": "orange-protocol/wasm-build-optimise", "file": "src/test.rs", "last_update_at": "2020-07-20T19:23:52+00:00", "question_id": "01172475354df749ec1a58f3a232d7a5ac9dcc9e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_import() {\n    check_valid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (func (;0;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n    // only import runtime function is valid\n    check_invalid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (import \"env\" \"add\" (func (type 0)))\n    (func (;1;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n    // only import from `env` is valid\n    check_invalid_contract(\n        r#\"\n    (module\n    (type (;0;) (func))\n    (import \"othermodule\" \"add\" (func (type 0)))\n    (func (;1;))\n    (export \"invoke\" (func 0))\n    )\n    \"#,\n    );\n"]], "pred": {"ppl": 1.9268860816955566, "ppl_lower": 1.9268860816955566, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0034888578232178786, "Min_5.0% Prob": 6.863110621770223, "Min_10.0% Prob": 4.919026403427124, "Min_20.0% Prob": 3.08905956864357, "Min_30.0% Prob": 2.155511322716872, "Min_40.0% Prob": 1.6322466595843435, "Min_50.0% Prob": 1.309663852110505, "Min_60.0% Prob": 1.0925410043541341}}
{"hexsha": "0f833ac7da86190578bfb623643bd61aad9703cb", "ext": "rs", "lang": "Rust", "content": "fn test_sub_integer() -> Result<(), Error> {\n        let mut vm = VM::test_vm(2);\n        vm.stack[1] = CompoundValue::SimpleValue(Value::Integer(1));\n        vm.stack[0] = CompoundValue::SimpleValue(Value::Integer(2));\n        vm.execute_instruction(create_instruction(InstructionType::Minus))?;\n        assert_eq!(vm.sp, 1);\n        assert_eq!(vm.stack[0], CompoundValue::SimpleValue(Value::Integer(1)));\n        Ok(())\n    }", "item_id": 9, "repo": "AgustinCB/emulators", "file": "smoked/src/cpu.rs", "last_update_at": "2020-07-19T01:21:35+00:00", "question_id": "0f833ac7da86190578bfb623643bd61aad9703cb_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sub_integer() -> Result<(), Error> {\n        let mut vm = VM::test_vm(2);\n        vm.stack[1] = CompoundValue::SimpleValue(Value::Integer(1));\n        vm.stack[0] = CompoundValue::SimpleValue(Value::Integer(2));\n        vm.execute_instruction(create_instruction(InstructionType::Minus))?;\n        assert_eq!(vm.sp, 1);\n        assert_eq!(vm.stack[0], CompoundValue::SimpleValue(Value::Integer(1)));\n        Ok(())\n"]], "pred": {"ppl": 2.5736143589019775, "ppl_lower": 3.0895955562591553, "ppl/lowercase_ppl": -1.1933002628468132, "ppl/zlib": 0.004633878805064397, "Min_5.0% Prob": 7.852495465959821, "Min_10.0% Prob": 6.193845731871469, "Min_20.0% Prob": 4.087053149938583, "Min_30.0% Prob": 3.0172172444207326, "Min_40.0% Prob": 2.3386392071843147, "Min_50.0% Prob": 1.8908630520637546, "Min_60.0% Prob": 1.5826470325700939}}
{"hexsha": "41fe300c7ff809a844807c8a62763858d244809a", "ext": "rs", "lang": "Rust", "content": "pub fn libra_LibraAccountResource_from_safe(\n    blob: AccountStateBlob,\n) -> Result<LibraAccountResource, LibraStatus> {\n    clear_error();\n    if let Ok(account_state) = AccountState::try_from(&blob) {\n        if let Ok(Some(account_resource)) = account_state.get_account_resource() {\n            if let Ok(Some(balance_resource)) = account_state.get_balance_resource() {\n                let mut authentication_key = [0u8; ED25519_PUBLIC_KEY_LENGTH];\n                authentication_key.copy_from_slice(account_resource.authentication_key());\n\n                let sent_events = LibraEventHandle {\n                    count: account_resource.sent_events().count(),\n                    key: account_resource.sent_events().key().into(),\n                };\n                let received_events = LibraEventHandle {\n                    count: account_resource.received_events().count(),\n                    key: account_resource.received_events().key().into(),\n                };\n\n                return Ok(LibraAccountResource {\n                    balance: balance_resource.coin(),\n                    sequence: account_resource.sequence_number(),\n                    delegated_key_rotation_capability: account_resource\n                        .delegated_key_rotation_capability(),\n                    delegated_withdrawal_capability: account_resource\n                        .delegated_withdrawal_capability(),\n                    sent_events,\n                    received_events,\n                    authentication_key,\n                });\n            }\n        }\n    }\n    update_last_error(format!(\n        \"Error deserializing account state blob: {:?}\",\n        blob\n    ));\n    Err(LibraStatus::InvalidArgument)\n}", "item_id": 0, "repo": "relab/libra-bbchain-port", "file": "client/libra-dev/src/account_resource.rs", "last_update_at": "2020-04-30T14:20:45+00:00", "question_id": "41fe300c7ff809a844807c8a62763858d244809a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn libra_LibraAccountResource_from_safe(\n    blob: AccountStateBlob,\n) -> Result<LibraAccountResource, LibraStatus> {\n    clear_error();\n    if let Ok(account_state) = AccountState::try_from(&blob) {\n        if let Ok(Some(account_resource)) = account_state.get_account_resource() {\n            if let Ok(Some(balance_resource)) = account_state.get_balance_resource() {\n                let mut authentication_key = [0u8; ED25519_PUBLIC_KEY_LENGTH];\n                authentication_key.copy_from_slice(account_resource.authentication_key());\n                let sent_events = LibraEventHandle {\n                    count: account_resource.sent_events().count(),\n                    key: account_resource.sent_events().key().into(),\n                };\n                let received_events = LibraEventHandle {\n                    count: account_resource.received_events().count(),\n                    key: account_resource.received_events().key().into(),\n                };\n                return Ok(LibraAccountResource {\n                    balance: balance_resource.coin(),\n                    sequence: account_resource.sequence_number(),\n                    delegated_key_rotation_capability: account_resource\n                        .delegated_key_rotation_capability(),\n                    delegated_withdrawal_capability: account_resource\n                        .delegated_withdrawal_capability(),\n                    sent_events,\n                    received_events,\n                    authentication_key,\n                });\n            }\n        }\n    }\n    update_last_error(format!(\n        \"Error deserializing account state blob: {:?}\",\n        blob\n    ));\n    Err(LibraStatus::InvalidArgument)\n"]], "pred": {"ppl": 1.8076300621032715, "ppl_lower": 2.015929698944092, "ppl/lowercase_ppl": -1.1842242992343597, "ppl/zlib": 0.0011341314738804922, "Min_5.0% Prob": 7.243779977162679, "Min_10.0% Prob": 4.9563857012016825, "Min_20.0% Prob": 2.851764839613575, "Min_30.0% Prob": 1.9579200857809482, "Min_40.0% Prob": 1.483108935406667, "Min_50.0% Prob": 1.1860704799588564, "Min_60.0% Prob": 0.9872687555172388}}
{"hexsha": "12b26aafa5ab2a08f5e787850541b93ead0996b2", "ext": "rs", "lang": "Rust", "content": "fn join2() {\n    let (c1, p1) = oneshot::channel::<i32>();\n    let (c2, p2) = oneshot::channel::<i32>();\n    let (tx, rx) = mpsc::channel();\n    run(future::try_join(p1, p2).map_ok(move |v| tx.send(v).unwrap()));\n    assert!(rx.try_recv().is_err());\n    c1.send(1).unwrap();\n    assert!(rx.try_recv().is_err());\n    c2.send(2).unwrap();\n    assert_eq!(rx.recv(), Ok((1, 2)));\n    assert!(rx.recv().is_err());\n}", "item_id": 1, "repo": "obiesie/futures-rs", "file": "futures/tests/eventual.rs", "last_update_at": "2020-08-07T10:10:53+00:00", "question_id": "12b26aafa5ab2a08f5e787850541b93ead0996b2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn join2() {\n    let (c1, p1) = oneshot::channel::<i32>();\n    let (c2, p2) = oneshot::channel::<i32>();\n    let (tx, rx) = mpsc::channel();\n    run(future::try_join(p1, p2).map_ok(move |v| tx.send(v).unwrap()));\n    assert!(rx.try_recv().is_err());\n    c1.send(1).unwrap();\n    assert!(rx.try_recv().is_err());\n    c2.send(2).unwrap();\n    assert_eq!(rx.recv(), Ok((1, 2)));\n    assert!(rx.recv().is_err());\n"]], "pred": {"ppl": 1.7966042757034302, "ppl_lower": 1.8850622177124023, "ppl/lowercase_ppl": -1.0820320722651722, "ppl/zlib": 0.0029442129130465944, "Min_5.0% Prob": 6.05112902323405, "Min_10.0% Prob": 4.309954855177137, "Min_20.0% Prob": 2.666729506519106, "Min_30.0% Prob": 1.9074120474634346, "Min_40.0% Prob": 1.456444402018355, "Min_50.0% Prob": 1.1737449437586798, "Min_60.0% Prob": 0.9806428737076068}}
{"hexsha": "82070af704513251627f4b5ee54d804f155f7d4d", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"Enter the chars you want to have at the beginning of the address and the amount of addresses you want to generate, in millions\");\n    println!(\"For example write \\\"Test 3\\\" to search for an address that has the chars from \\\"Test\\\" at the beginning and generate 3 million addresses to find such an address\");\n    println!(\n        \"Upper and lower case is ignored, output will look like this if an address was found:\"\n    );\n    println!(\"Found address TesTsEhMde7MmxvZxch9kWJgVtsrnL4ua4qoexAe51gi with seed FYrwHApFHSXMeuR6bovqomGgfrvtLmb7NtR62qfnRfSd\");\n\n    let user_input = get_user_input();\n    println!(\n        \"Searching for {} in {} million addresses...\",\n        user_input[0], user_input[1]\n    );\n    println!(\"Abort with Ctrl+C\");\n\n    let time_start = Instant::now();\n    let threads = 8;\n    let total_addresses = user_input[1].parse::<usize>().unwrap() * 1000000;\n    let amount = total_addresses / threads;\n\n    let beginning = user_input[0].to_ascii_uppercase();\n    let arc_beginning = std::sync::Arc::new(beginning);\n\n    let mut pool = vec![];\n    for _ in 0..threads {\n        let s = arc_beginning.clone();\n        pool.push(thread::spawn(move || find_address(s, amount)));\n    }\n    for worker in pool {\n        worker.join().unwrap();\n    }\n    println!(\"Done after {:.2?}\", time_start.elapsed());\n}", "item_id": 0, "repo": "Thoralf-M/iota-vanitygen", "file": "src/main.rs", "last_update_at": "2020-09-06T18:23:17+00:00", "question_id": "82070af704513251627f4b5ee54d804f155f7d4d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    println!(\"Enter the chars you want to have at the beginning of the address and the amount of addresses you want to generate, in millions\");\n    println!(\"For example write \\\"Test 3\\\" to search for an address that has the chars from \\\"Test\\\" at the beginning and generate 3 million addresses to find such an address\");\n    println!(\n        \"Upper and lower case is ignored, output will look like this if an address was found:\"\n    );\n    println!(\"Found address TesTsEhMde7MmxvZxch9kWJgVtsrnL4ua4qoexAe51gi with seed FYrwHApFHSXMeuR6bovqomGgfrvtLmb7NtR62qfnRfSd\");\n    let user_input = get_user_input();\n    println!(\n        \"Searching for {} in {} million addresses...\",\n        user_input[0], user_input[1]\n    );\n    println!(\"Abort with Ctrl+C\");\n    let time_start = Instant::now();\n    let threads = 8;\n    let total_addresses = user_input[1].parse::<usize>().unwrap() * 1000000;\n    let amount = total_addresses / threads;\n    let beginning = user_input[0].to_ascii_uppercase();\n    let arc_beginning = std::sync::Arc::new(beginning);\n    let mut pool = vec![];\n    for _ in 0..threads {\n        let s = arc_beginning.clone();\n        pool.push(thread::spawn(move || find_address(s, amount)));\n    }\n    for worker in pool {\n        worker.join().unwrap();\n    }\n    println!(\"Done after {:.2?}\", time_start.elapsed());\n"]], "pred": {"ppl": 5.826606273651123, "ppl_lower": 5.9087395668029785, "ppl/lowercase_ppl": -1.007942320189657, "ppl/zlib": 0.0026703556311690087, "Min_5.0% Prob": 8.969554034146396, "Min_10.0% Prob": 7.909387675198642, "Min_20.0% Prob": 6.198868794874712, "Min_30.0% Prob": 5.1616667057528645, "Min_40.0% Prob": 4.202480039474639, "Min_50.0% Prob": 3.4687219787727703, "Min_60.0% Prob": 2.923493348146704}}
{"hexsha": "3087206e07a80507111e7ffe863394e5cde07c18", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn preadv2(\n    fd: BorrowedFd<'_>,\n    bufs: &mut [IoSliceMut<'_>],\n    pos: u64,\n    flags: ReadWriteFlags,\n) -> io::Result<usize> {\n    let (bufs_addr, bufs_len) = slice(&bufs[..cmp::min(bufs.len(), max_iov())]);\n\n    #[cfg(target_pointer_width = \"32\")]\n    unsafe {\n        ret_usize(syscall6(\n            nr(__NR_preadv2),\n            borrowed_fd(fd),\n            bufs_addr,\n            bufs_len,\n            hi(pos),\n            lo(pos),\n            c_uint(flags.bits()),\n        ))\n    }\n    #[cfg(target_pointer_width = \"64\")]\n    unsafe {\n        ret_usize(syscall5(\n            nr(__NR_preadv2),\n            borrowed_fd(fd),\n            bufs_addr,\n            bufs_len,\n            loff_t_from_u64(pos),\n            c_uint(flags.bits()),\n        ))\n    }\n}", "item_id": 2, "repo": "sunfishcode/posish", "file": "src/imp/linux_raw/io/syscalls.rs", "last_update_at": "2020-09-21T03:51:08+00:00", "question_id": "3087206e07a80507111e7ffe863394e5cde07c18_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn preadv2(\n    fd: BorrowedFd<'_>,\n    bufs: &mut [IoSliceMut<'_>],\n    pos: u64,\n    flags: ReadWriteFlags,\n) -> io::Result<usize> {\n    let (bufs_addr, bufs_len) = slice(&bufs[..cmp::min(bufs.len(), max_iov())]);\n    #[cfg(target_pointer_width = \"32\")]\n    unsafe {\n        ret_usize(syscall6(\n            nr(__NR_preadv2),\n            borrowed_fd(fd),\n            bufs_addr,\n            bufs_len,\n            hi(pos),\n            lo(pos),\n            c_uint(flags.bits()),\n        ))\n    }\n    #[cfg(target_pointer_width = \"64\")]\n    unsafe {\n        ret_usize(syscall5(\n            nr(__NR_preadv2),\n            borrowed_fd(fd),\n            bufs_addr,\n            bufs_len,\n            loff_t_from_u64(pos),\n            c_uint(flags.bits()),\n        ))\n    }\n"]], "pred": {"ppl": 1.7590863704681396, "ppl_lower": 2.2262825965881348, "ppl/lowercase_ppl": -1.417034165695237, "ppl/zlib": 0.0017272005094142527, "Min_5.0% Prob": 7.009920920644488, "Min_10.0% Prob": 4.5948282398026565, "Min_20.0% Prob": 2.752755873162171, "Min_30.0% Prob": 1.8712747509760612, "Min_40.0% Prob": 1.4165468427838168, "Min_50.0% Prob": 1.1290142743366764, "Min_60.0% Prob": 0.9433046263299978}}
{"hexsha": "c2d8bc782facadf12bbcce78f65f207c27226f82", "ext": "rs", "lang": "Rust", "content": "fn test_diff_none() {\n  let (one, two) = (\"test_diff_none_1\", \"test_diff_none_2\");\n  let mut con = std::net::TcpStream::connect(get_redis_url()).expect(\"connection\");\n  execute(&mut con, SetCommand::Add(one, Arity::One(\"one\"))).expect(\"executed\");\n  execute(&mut con, SetCommand::Add(two, Arity::One(\"two\"))).expect(\"executed\");\n  execute(&mut con, SetCommand::Add(two, Arity::One(\"one\"))).expect(\"executed\");\n  let result = execute(&mut con, SetCommand::Diff::<_, &str>(Arity::Many(vec![one, two]))).expect(\"executed\");\n  execute(&mut con, Command::Del::<_, &str>(Arity::One(one))).expect(\"executed\");\n  execute(&mut con, Command::Del::<_, &str>(Arity::One(two))).expect(\"executed\");\n  assert_eq!(result, Response::Array(vec![]));\n}", "item_id": 11, "repo": "sizethree/kramer", "file": "tests/execute_sync_test.rs", "last_update_at": "2020-09-06T11:28:42+00:00", "question_id": "c2d8bc782facadf12bbcce78f65f207c27226f82_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_diff_none() {\n  let (one, two) = (\"test_diff_none_1\", \"test_diff_none_2\");\n  let mut con = std::net::TcpStream::connect(get_redis_url()).expect(\"connection\");\n  execute(&mut con, SetCommand::Add(one, Arity::One(\"one\"))).expect(\"executed\");\n  execute(&mut con, SetCommand::Add(two, Arity::One(\"two\"))).expect(\"executed\");\n  execute(&mut con, SetCommand::Add(two, Arity::One(\"one\"))).expect(\"executed\");\n  let result = execute(&mut con, SetCommand::Diff::<_, &str>(Arity::Many(vec![one, two]))).expect(\"executed\");\n  execute(&mut con, Command::Del::<_, &str>(Arity::One(one))).expect(\"executed\");\n  execute(&mut con, Command::Del::<_, &str>(Arity::One(two))).expect(\"executed\");\n  assert_eq!(result, Response::Array(vec![]));\n"]], "pred": {"ppl": 2.45308780670166, "ppl_lower": 2.802234649658203, "ppl/lowercase_ppl": -1.1482921820458603, "ppl/zlib": 0.0033608522856718157, "Min_5.0% Prob": 8.065391818682352, "Min_10.0% Prob": 5.882412166595459, "Min_20.0% Prob": 3.9901651892007566, "Min_30.0% Prob": 2.9114214028967056, "Min_40.0% Prob": 2.2237796313768508, "Min_50.0% Prob": 1.7880778350518085, "Min_60.0% Prob": 1.5001973650156477}}
{"hexsha": "659ec4d3c1188e5cebd895d328d759425bd5e3d3", "ext": "rs", "lang": "Rust", "content": "fn multi_gaussian_dist(x_v: & DVector<f64>, mean_v: & DVector<f64>, std_d_mat: & DMatrix<f64>) -> f64 {\n    let n_dim: usize = mean_v.nrows();\n\n    let x_minus_mean = x_v - mean_v;\n\n    let mut std_d_mat_cp = DMatrix::from_diagonal_element(n_dim, n_dim, 1.0);\n    std_d_mat_cp.copy_from(std_d_mat);\n\n    let std_d_mat_inv = match std_d_mat_cp.try_inverse() {\n        Some(mat_inv) => mat_inv,\n        None => panic!(\"Not regular matrix!\"),\n    };\n\n    let mut in_exp = 0.0;\n    let quad_form = x_minus_mean.transpose() * std_d_mat_inv * x_minus_mean;\n    for &i in quad_form.iter() {in_exp = (-0.5) * i; break;}\n\n    let det: f64 = std_d_mat.determinant();\n\n    let base :f64 = (2.0 * PI).sqrt().powi(n_dim as i32) * det.sqrt();\n\n    let density: f64 = (1.0_f64.exp()).powf(in_exp) / base;\n\n    density\n}", "item_id": 1, "repo": "MonadicDavidHuang/monte_carlo", "file": "src/main.rs", "last_update_at": "2020-05-09T11:35:45+00:00", "question_id": "659ec4d3c1188e5cebd895d328d759425bd5e3d3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn multi_gaussian_dist(x_v: & DVector<f64>, mean_v: & DVector<f64>, std_d_mat: & DMatrix<f64>) -> f64 {\n    let n_dim: usize = mean_v.nrows();\n    let x_minus_mean = x_v - mean_v;\n    let mut std_d_mat_cp = DMatrix::from_diagonal_element(n_dim, n_dim, 1.0);\n    std_d_mat_cp.copy_from(std_d_mat);\n    let std_d_mat_inv = match std_d_mat_cp.try_inverse() {\n        Some(mat_inv) => mat_inv,\n        None => panic!(\"Not regular matrix!\"),\n    };\n    let mut in_exp = 0.0;\n    let quad_form = x_minus_mean.transpose() * std_d_mat_inv * x_minus_mean;\n    for &i in quad_form.iter() {in_exp = (-0.5) * i; break;}\n    let det: f64 = std_d_mat.determinant();\n    let base :f64 = (2.0 * PI).sqrt().powi(n_dim as i32) * det.sqrt();\n    let density: f64 = (1.0_f64.exp()).powf(in_exp) / base;\n    density\n"]], "pred": {"ppl": 2.2928221225738525, "ppl_lower": 2.5629782676696777, "ppl/lowercase_ppl": -1.1342356785380758, "ppl/zlib": 0.002023862016488453, "Min_5.0% Prob": 7.083037032021417, "Min_10.0% Prob": 5.32029879755444, "Min_20.0% Prob": 3.6289027515384884, "Min_30.0% Prob": 2.6301851811212136, "Min_40.0% Prob": 2.0440120143109355, "Min_50.0% Prob": 1.649519593997316, "Min_60.0% Prob": 1.3830104837057378}}
{"hexsha": "0b91ab6d8a99f812d9dd46487d32a82685a9a436", "ext": "rs", "lang": "Rust", "content": "fn vector_sub() {\n\tlet v = Vector3::fill(3.2);\n\tlet v2 = Vector3 { x: 1.0, y: 32.0, z: 2.0 };\n\tlet res = Vector3 {x: 2.2, y: -28.8, z: 1.2};\n\tassert_eq!(v - v2, res);\n}", "item_id": 3, "repo": "HedbergMartin/rust_3dm", "file": "src/tests/vector_tests.rs", "last_update_at": "2020-09-01T23:05:10+00:00", "question_id": "0b91ab6d8a99f812d9dd46487d32a82685a9a436_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn vector_sub() {\n\tlet v = Vector3::fill(3.2);\n\tlet v2 = Vector3 { x: 1.0, y: 32.0, z: 2.0 };\n\tlet res = Vector3 {x: 2.2, y: -28.8, z: 1.2};\n\tassert_eq!(v - v2, res);\n"]], "pred": {"ppl": 2.7696685791015625, "ppl_lower": 3.1107680797576904, "ppl/lowercase_ppl": -1.114006916659979, "ppl/zlib": 0.008021477689033841, "Min_5.0% Prob": 7.7253782749176025, "Min_10.0% Prob": 5.926105790668064, "Min_20.0% Prob": 4.081469284860711, "Min_30.0% Prob": 3.1437085760491237, "Min_40.0% Prob": 2.4355433065640297, "Min_50.0% Prob": 1.986785770393908, "Min_60.0% Prob": 1.7010632859248864}}
{"hexsha": "3aa039a0205741105e001eb14b832d797b1f7f82", "ext": "rs", "lang": "Rust", "content": "fn get_param_key_value(dir: &str, file: &str) -> Result<HashMap<String, String>> {\n    let mut m = HashMap::new();\n    let p = format!(\"{}/{}\", dir, file);\n\n    for l in fs::read_to_string(p.as_str())?.lines() {\n        let t: Vec<&str> = l.split(' ').collect();\n        if t.len() != 2 {\n            continue;\n        }\n\n        m.insert(t[0].to_string(), t[1].to_string());\n    }\n\n    Ok(m)\n}", "item_id": 6, "repo": "ericho/kata-containers", "file": "src/agent/rustjail/src/cgroups/fs/mod.rs", "last_update_at": "2020-04-26T05:49:47+00:00", "question_id": "3aa039a0205741105e001eb14b832d797b1f7f82_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_param_key_value(dir: &str, file: &str) -> Result<HashMap<String, String>> {\n    let mut m = HashMap::new();\n    let p = format!(\"{}/{}\", dir, file);\n    for l in fs::read_to_string(p.as_str())?.lines() {\n        let t: Vec<&str> = l.split(' ').collect();\n        if t.len() != 2 {\n            continue;\n        }\n        m.insert(t[0].to_string(), t[1].to_string());\n    }\n    Ok(m)\n"]], "pred": {"ppl": 1.8651586771011353, "ppl_lower": 2.3894479274749756, "ppl/lowercase_ppl": -1.3973975343841896, "ppl/zlib": 0.0024638186997316884, "Min_5.0% Prob": 6.0456008570534845, "Min_10.0% Prob": 4.245976909001668, "Min_20.0% Prob": 2.713823350270589, "Min_30.0% Prob": 1.9803016265233357, "Min_40.0% Prob": 1.5322993122041226, "Min_50.0% Prob": 1.240285218556722, "Min_60.0% Prob": 1.0372212847591273}}
{"hexsha": "9b304d44d3c999562230e60592aa2f68bccc8d87", "ext": "rs", "lang": "Rust", "content": "async fn execute_stdin(fiber: &mut Fiber) {\n    let mut stdin = std::io::stdin();\n    let mut source = String::new();\n\n    if let Err(e) = stdin.read_to_string(&mut source) {\n        log::error!(\"{}\", e);\n        exit::set(1);\n        return;\n    }\n\n    if let Err(e) = fiber.execute(None, SourceFile::named(\"<stdin>\", source)).await {\n        log::error!(\"{}\", e);\n        exit::set(1);\n    }\n}", "item_id": 2, "repo": "AakashOfficial/riptide", "file": "src/main.rs", "last_update_at": "2020-01-10T04:05:20+00:00", "question_id": "9b304d44d3c999562230e60592aa2f68bccc8d87_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn execute_stdin(fiber: &mut Fiber) {\n    let mut stdin = std::io::stdin();\n    let mut source = String::new();\n    if let Err(e) = stdin.read_to_string(&mut source) {\n        log::error!(\"{}\", e);\n        exit::set(1);\n        return;\n    }\n    if let Err(e) = fiber.execute(None, SourceFile::named(\"<stdin>\", source)).await {\n        log::error!(\"{}\", e);\n        exit::set(1);\n    }\n"]], "pred": {"ppl": 2.674039125442505, "ppl_lower": 3.541457414627075, "ppl/lowercase_ppl": -1.2856354777544887, "ppl/zlib": 0.004728798607577824, "Min_5.0% Prob": 8.03170210974557, "Min_10.0% Prob": 6.701348440987723, "Min_20.0% Prob": 4.307427372251238, "Min_30.0% Prob": 3.1144625012363707, "Min_40.0% Prob": 2.4161735230258534, "Min_50.0% Prob": 1.9579325689801148, "Min_60.0% Prob": 1.6368788815369564}}
{"hexsha": "be6d94a55f2f641746fad8009f7428e4e3705a5f", "ext": "rs", "lang": "Rust", "content": "pub fn setup(\n    mut commands: Commands,\n    asset_server: ResMut<AssetServer>,\n    mut atlases: ResMut<Assets<TextureAtlas>>,\n    textures: ResMut<Assets<Texture>>,\n) {\n    let icon_handle = asset_server.load(assets::LOADING).unwrap();\n    let icon_tex = textures.get(&icon_handle).unwrap();\n    let atlas = load_spritesheet(icon_handle, icon_tex.size, Vec2::new(16.0, 16.0), Vec2::new(0.0, 0.0));\n    let atlas_handle = atlases.add(atlas);\n\n    commands\n        .spawn(SpriteSheetComponents {\n            texture_atlas: atlas_handle,\n            transform: Transform::from_scale(1.0),\n            ..Default::default()\n        }).with_bundle((AnimSprite::new(1.0 / 12.0), LoadingScreen))\n    ;\n    println!(\"loading screen up!\");\n}", "item_id": 0, "repo": "thebluefish/bevy_sandbox", "file": "src/systems/loading_screen.rs", "last_update_at": "2020-10-17T19:17:57+00:00", "question_id": "be6d94a55f2f641746fad8009f7428e4e3705a5f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn setup(\n    mut commands: Commands,\n    asset_server: ResMut<AssetServer>,\n    mut atlases: ResMut<Assets<TextureAtlas>>,\n    textures: ResMut<Assets<Texture>>,\n) {\n    let icon_handle = asset_server.load(assets::LOADING).unwrap();\n    let icon_tex = textures.get(&icon_handle).unwrap();\n    let atlas = load_spritesheet(icon_handle, icon_tex.size, Vec2::new(16.0, 16.0), Vec2::new(0.0, 0.0));\n    let atlas_handle = atlases.add(atlas);\n    commands\n        .spawn(SpriteSheetComponents {\n            texture_atlas: atlas_handle,\n            transform: Transform::from_scale(1.0),\n            ..Default::default()\n        }).with_bundle((AnimSprite::new(1.0 / 12.0), LoadingScreen))\n    ;\n    println!(\"loading screen up!\");\n"]], "pred": {"ppl": 2.421128034591675, "ppl_lower": 3.667264699935913, "ppl/lowercase_ppl": -1.4695733427268103, "ppl/zlib": 0.002415938692787749, "Min_5.0% Prob": 7.341636498769124, "Min_10.0% Prob": 5.683400173187255, "Min_20.0% Prob": 3.8169229334475947, "Min_30.0% Prob": 2.8104472911203064, "Min_40.0% Prob": 2.18331147976292, "Min_50.0% Prob": 1.7666504900296067, "Min_60.0% Prob": 1.4754405084757074}}
{"hexsha": "1a7bd68e9dd578cc962b00f9049ccb88792a8a01", "ext": "rs", "lang": "Rust", "content": "fn test_verkey_from_qualified_address() {\n        let verkey = gen_random_base58_verkey();\n        let address = qualified_address_from_verkey(&verkey).unwrap();\n        let result = validate_address(&address);\n        let verkey_extracted = result.unwrap();\n        assert_eq!(verkey_extracted, verkey);\n    }", "item_id": 10, "repo": "VladimirWork/libsovtoken", "file": "libsovtoken/src/logic/address.rs", "last_update_at": "2020-06-21T16:11:43+00:00", "question_id": "1a7bd68e9dd578cc962b00f9049ccb88792a8a01_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_verkey_from_qualified_address() {\n        let verkey = gen_random_base58_verkey();\n        let address = qualified_address_from_verkey(&verkey).unwrap();\n        let result = validate_address(&address);\n        let verkey_extracted = result.unwrap();\n        assert_eq!(verkey_extracted, verkey);\n"]], "pred": {"ppl": 4.259133815765381, "ppl_lower": 4.259133815765381, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009409518246587449, "Min_5.0% Prob": 9.92743468284607, "Min_10.0% Prob": 8.669036971198189, "Min_20.0% Prob": 6.361170291900635, "Min_30.0% Prob": 4.641183062835976, "Min_40.0% Prob": 3.5850786194205284, "Min_50.0% Prob": 2.8615645286829574, "Min_60.0% Prob": 2.4114106821742927}}
{"hexsha": "d7d3695b841947b65b593e809ddeb154937c534f", "ext": "rs", "lang": "Rust", "content": "pub fn diskread(start_lba: u32, sectors: u32) -> Result<(), BIOError> {\n    let mut param_region = MemoryRegion::new(((INIT_SEG << 4) + 0x6100) as u64, 16);\n    let param = param_region.as_mut_slice::<u32>(0, 4);\n    // save start_lba and sectors\n    param[0] = start_lba;\n    param[1] = sectors;\n//loop {}\n    unsafe {\n        llvm_asm!(\"start:\");\n        scratch_push!();\n        preserved_push!();\n        \n        llvm_asm!(\"cli\");\n\n        // save return address and stack pointer\n        llvm_asm!(\"movl $$continue, %eax\":\"={eax}\"(param[2]));\n        llvm_asm!(\"movl %esp, %eax\":\"={eax}\"(param[3]));\n        \n        // setup gdt & idt\n        llvm_asm!(\"\n            movl  $$GDT16, %eax\n            movl  %eax, (GDTR16+2)\n            lgdt  GDTR16\n            lidt IDTR16\"\n         :::\n        );\n        // set up new stack for real mode 0x07C0:0xFFF0\n        llvm_asm!(\"\n            movl $$0xFFF0, %eax\n            movl %eax, %esp\n            movl %eax, %ebp\"\n         :::\"eax\"\n        );\n        // setup segment\n        llvm_asm!(\"\n            movw  $$0x18, %ax\n            movw  %ax, %ds\n            movw  %ax, %es\n            movw  %ax, %fs\n            movw  %ax, %gs\n            movw  %ax, %ss\"\n        );\n\n        // goto real mode\n        llvm_asm!(\"jmp  $$0x10, $$0xDD10\");\n\n        // return point\n        llvm_asm!(\"\n          continue:\n            sti\"\n        );\n        preserved_pop!();\n        scratch_pop!();\n        llvm_asm!(\"end:\")\n    }\n    //loop {}\n    if param[0] == 1 {\n        Ok(())\n    } else {\n        Err(BIOError::IOError)\n    }\n}", "item_id": 0, "repo": "Tapiocapybara/krabs", "file": "src/bios/stage_4th/src/svm/rm.rs", "last_update_at": "2020-06-08T12:26:25+00:00", "question_id": "d7d3695b841947b65b593e809ddeb154937c534f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn diskread(start_lba: u32, sectors: u32) -> Result<(), BIOError> {\n    let mut param_region = MemoryRegion::new(((INIT_SEG << 4) + 0x6100) as u64, 16);\n    let param = param_region.as_mut_slice::<u32>(0, 4);\n    // save start_lba and sectors\n    param[0] = start_lba;\n    param[1] = sectors;\n//loop {}\n    unsafe {\n        llvm_asm!(\"start:\");\n        scratch_push!();\n        preserved_push!();\n        llvm_asm!(\"cli\");\n        // save return address and stack pointer\n        llvm_asm!(\"movl $$continue, %eax\":\"={eax}\"(param[2]));\n        llvm_asm!(\"movl %esp, %eax\":\"={eax}\"(param[3]));\n        // setup gdt & idt\n        llvm_asm!(\"\n            movl  $$GDT16, %eax\n            movl  %eax, (GDTR16+2)\n            lgdt  GDTR16\n            lidt IDTR16\"\n         :::\n        );\n        // set up new stack for real mode 0x07C0:0xFFF0\n        llvm_asm!(\"\n            movl $$0xFFF0, %eax\n            movl %eax, %esp\n            movl %eax, %ebp\"\n         :::\"eax\"\n        );\n        // setup segment\n        llvm_asm!(\"\n            movw  $$0x18, %ax\n            movw  %ax, %ds\n            movw  %ax, %es\n            movw  %ax, %fs\n            movw  %ax, %gs\n            movw  %ax, %ss\"\n        );\n        // goto real mode\n        llvm_asm!(\"jmp  $$0x10, $$0xDD10\");\n        // return point\n        llvm_asm!(\"\n          continue:\n            sti\"\n        );\n        preserved_pop!();\n        scratch_pop!();\n        llvm_asm!(\"end:\")\n    }\n    //loop {}\n    if param[0] == 1 {\n        Ok(())\n    } else {\n        Err(BIOError::IOError)\n    }\n"]], "pred": {"ppl": 2.8366174697875977, "ppl_lower": 2.992560863494873, "ppl/lowercase_ppl": -1.0513299006859564, "ppl/zlib": 0.0017611694435239293, "Min_5.0% Prob": 7.978931640756541, "Min_10.0% Prob": 6.1632735365528175, "Min_20.0% Prob": 4.340445219460181, "Min_30.0% Prob": 3.2321530146113897, "Min_40.0% Prob": 2.5306904448543563, "Min_50.0% Prob": 2.0638630036832923, "Min_60.0% Prob": 1.7330384007365691}}
{"hexsha": "4cb44c3e9bbaf7828d4d6aed2083f377e083a8ff", "ext": "rs", "lang": "Rust", "content": "fn error_reference_loop_implementation_function_between_modules_indirect() {\n    let third = r#\"\nuse crate::Call;\n\nstruct Third { value: u8 }\n\nimpl Third {\n    pub fn call() -> u8 { Call::call() }\n}\n\"#;\n\n    let second = r#\"\nmod third;\n\nstruct Second { value: u8 }\n\nimpl Second {\n    pub fn call() -> u8 { third::Third::call() }\n}\n\"#;\n\n    let first = r#\"\nmod second;\n\nstruct First { value: u8 }\n\nimpl First {\n    pub fn call() -> u8 { second::Second::call() }\n}\n\"#;\n\n    let entry = r#\"\nmod first;\n\nstruct Call { value: u8 }\n\nimpl Call {\n    pub fn call() -> u8 { self::first::First::Call() }\n}\n\nfn main() -> u8 { Call { value: 42 }.call() }\n\"#;\n\n    let expected = Err(Error::Semantic(SemanticError::Scope(\n        ScopeError::ReferenceLoop {\n            location: Location::test(7, 5),\n        },\n    )));\n    let result = crate::semantic::tests::compile_entry_with_dependencies(\n        entry,\n        vec![(\n            \"first\".to_owned(),\n            Source::test(\n                first,\n                PathBuf::from(\"first.zn\"),\n                vec![(\n                    \"second\".to_owned(),\n                    Source::test(\n                        second,\n                        PathBuf::from(\"first/second.zn\"),\n                        vec![(\n                            \"third\".to_owned(),\n                            Source::test(\n                                third,\n                                PathBuf::from(\"first/second/third.zn\"),\n                                HashMap::new(),\n                            )\n                            .expect(zinc_const::panic::TEST_DATA_VALID),\n                        )]\n                        .into_iter()\n                        .collect::<HashMap<String, Source>>(),\n                    )\n                    .expect(zinc_const::panic::TEST_DATA_VALID),\n                )]\n                .into_iter()\n                .collect::<HashMap<String, Source>>(),\n            )\n            .expect(zinc_const::panic::TEST_DATA_VALID),\n        )]\n        .into_iter()\n        .collect::<HashMap<String, Source>>(),\n    );\n\n    assert_eq!(result, expected);\n}", "item_id": 33, "repo": "tpscrpt/zinc", "file": "zinc-compiler/src/semantic/scope/tests.rs", "last_update_at": "2020-11-14T03:11:05+00:00", "question_id": "4cb44c3e9bbaf7828d4d6aed2083f377e083a8ff_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn error_reference_loop_implementation_function_between_modules_indirect() {\n    let third = r#\"\nuse crate::Call;\nstruct Third { value: u8 }\nimpl Third {\n    pub fn call() -> u8 { Call::call() }\n}\n\"#;\n    let second = r#\"\nmod third;\nstruct Second { value: u8 }\nimpl Second {\n    pub fn call() -> u8 { third::Third::call() }\n}\n\"#;\n    let first = r#\"\nmod second;\nstruct First { value: u8 }\nimpl First {\n    pub fn call() -> u8 { second::Second::call() }\n}\n\"#;\n    let entry = r#\"\nmod first;\nstruct Call { value: u8 }\nimpl Call {\n    pub fn call() -> u8 { self::first::First::Call() }\n}\nfn main() -> u8 { Call { value: 42 }.call() }\n\"#;\n    let expected = Err(Error::Semantic(SemanticError::Scope(\n        ScopeError::ReferenceLoop {\n            location: Location::test(7, 5),\n        },\n    )));\n    let result = crate::semantic::tests::compile_entry_with_dependencies(\n        entry,\n        vec![(\n            \"first\".to_owned(),\n            Source::test(\n                first,\n                PathBuf::from(\"first.zn\"),\n                vec![(\n                    \"second\".to_owned(),\n                    Source::test(\n                        second,\n                        PathBuf::from(\"first/second.zn\"),\n                        vec![(\n                            \"third\".to_owned(),\n                            Source::test(\n                                third,\n                                PathBuf::from(\"first/second/third.zn\"),\n                                HashMap::new(),\n                            )\n                            .expect(zinc_const::panic::TEST_DATA_VALID),\n                        )]\n                        .into_iter()\n                        .collect::<HashMap<String, Source>>(),\n                    )\n                    .expect(zinc_const::panic::TEST_DATA_VALID),\n                )]\n                .into_iter()\n                .collect::<HashMap<String, Source>>(),\n            )\n            .expect(zinc_const::panic::TEST_DATA_VALID),\n        )]\n        .into_iter()\n        .collect::<HashMap<String, Source>>(),\n    );\n    assert_eq!(result, expected);\n"]], "pred": {"ppl": 1.6919580698013306, "ppl_lower": 2.099177360534668, "ppl/lowercase_ppl": -1.4100867086352025, "ppl/zlib": 0.0008523281676429053, "Min_5.0% Prob": 6.377837800979615, "Min_10.0% Prob": 4.305821707991303, "Min_20.0% Prob": 2.536295557852651, "Min_30.0% Prob": 1.7379394967943593, "Min_40.0% Prob": 1.311625364694561, "Min_50.0% Prob": 1.0509684763192275, "Min_60.0% Prob": 0.8762657777842038}}
{"hexsha": "2b705743da96c4959e1e3738566afdb2bd9ab8d9", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn get_claims_output(claims: GetClaimsResponse) -> CommandOutput {\n    let mut map = HashMap::new();\n    map.insert(\"claims\".to_string(), json!(claims));\n    CommandOutput::new(claims_table(claims), map)\n}", "item_id": 2, "repo": "mattwilkinsonn/wash", "file": "src/ctl/output.rs", "last_update_at": "2020-12-02T18:12:56+00:00", "question_id": "2b705743da96c4959e1e3738566afdb2bd9ab8d9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn get_claims_output(claims: GetClaimsResponse) -> CommandOutput {\n    let mut map = HashMap::new();\n    map.insert(\"claims\".to_string(), json!(claims));\n    CommandOutput::new(claims_table(claims), map)\n"]], "pred": {"ppl": 4.249997615814209, "ppl_lower": 5.345196723937988, "ppl/lowercase_ppl": -1.158460852800654, "ppl/zlib": 0.00915771153133719, "Min_5.0% Prob": 9.361088752746582, "Min_10.0% Prob": 8.318255696977888, "Min_20.0% Prob": 5.983307790756226, "Min_30.0% Prob": 4.436258502628492, "Min_40.0% Prob": 3.4964712935109294, "Min_50.0% Prob": 2.869214973388574, "Min_60.0% Prob": 2.417208473099039}}
{"hexsha": "1deff9684a140abedbe5d1da5facb0f7bba1486f", "ext": "rs", "lang": "Rust", "content": "fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n    let mut eq = SpanlessEq::new(cx);\n    let mut eq = eq.inter_expr();\n    let mut moved_locals = Vec::new();\n\n    let start_end_eq = block\n        .stmts\n        .iter()\n        .enumerate()\n        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))\n        .map_or(block.stmts.len(), |(i, _)| i);\n\n    // Walk backwards through the final expression/statements so long as their hashes are equal. Note\n    // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block\n    // to match those in other blocks. e.g. If each block ends with the following the hash value will be\n    // the same even though each `x` binding will have a different `HirId`:\n    //     let x = foo();\n    //     x + 50\n    let expr_hash_eq = if let Some(e) = block.expr {\n        let hash = hash_expr(cx, e);\n        blocks\n            .iter()\n            .all(|b| b.expr.map_or(false, |e| hash_expr(cx, e) == hash))\n    } else {\n        blocks.iter().all(|b| b.expr.is_none())\n    };\n    if !expr_hash_eq {\n        return BlockEq {\n            start_end_eq,\n            end_begin_eq: None,\n            moved_locals,\n        };\n    }\n    let end_search_start = block.stmts[start_end_eq..]\n        .iter()\n        .rev()\n        .enumerate()\n        .find(|&(offset, stmt)| {\n            let hash = hash_stmt(cx, stmt);\n            blocks.iter().any(|b| {\n                b.stmts\n                    // the bounds check will catch the underflow\n                    .get(b.stmts.len().wrapping_sub(offset + 1))\n                    .map_or(true, |s| hash != hash_stmt(cx, s))\n            })\n        })\n        .map_or(block.stmts.len() - start_end_eq, |(i, _)| i);\n\n    let moved_locals_at_start = moved_locals.len();\n    let mut i = end_search_start;\n    let end_begin_eq = block.stmts[block.stmts.len() - end_search_start..]\n        .iter()\n        .zip(iter::repeat_with(move || {\n            let x = i;\n            i -= 1;\n            x\n        }))\n        .fold(end_search_start, |init, (stmt, offset)| {\n            if eq_stmts(\n                stmt,\n                blocks,\n                |b| b.stmts.get(b.stmts.len() - offset),\n                &mut eq,\n                &mut moved_locals,\n            ) {\n                init\n            } else {\n                // Clear out all locals seen at the end so far. None of them can be moved.\n                let stmts = &blocks[0].stmts;\n                for stmt in &stmts[stmts.len() - init..=stmts.len() - offset] {\n                    if let StmtKind::Local(l) = stmt.kind {\n                        l.pat.each_binding_or_first(&mut |_, id, _, _| {\n                            eq.locals.remove(&id);\n                        });\n                    }\n                }\n                moved_locals.truncate(moved_locals_at_start);\n                offset - 1\n            }\n        });\n    if let Some(e) = block.expr {\n        for block in blocks {\n            if block.expr.map_or(false, |expr| !eq.eq_expr(expr, e)) {\n                moved_locals.truncate(moved_locals_at_start);\n                return BlockEq {\n                    start_end_eq,\n                    end_begin_eq: None,\n                    moved_locals,\n                };\n            }\n        }\n    }\n\n    BlockEq {\n        start_end_eq,\n        end_begin_eq: Some(end_begin_eq),\n        moved_locals,\n    }\n}", "item_id": 1, "repo": "ghishadow/rust", "file": "src/tools/clippy/clippy_lints/src/copies.rs", "last_update_at": "2020-02-19T13:45:02+00:00", "question_id": "1deff9684a140abedbe5d1da5facb0f7bba1486f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n    let mut eq = SpanlessEq::new(cx);\n    let mut eq = eq.inter_expr();\n    let mut moved_locals = Vec::new();\n    let start_end_eq = block\n        .stmts\n        .iter()\n        .enumerate()\n        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))\n        .map_or(block.stmts.len(), |(i, _)| i);\n    // Walk backwards through the final expression/statements so long as their hashes are equal. Note\n    // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block\n    // to match those in other blocks. e.g. If each block ends with the following the hash value will be\n    // the same even though each `x` binding will have a different `HirId`:\n    //     let x = foo();\n    //     x + 50\n    let expr_hash_eq = if let Some(e) = block.expr {\n        let hash = hash_expr(cx, e);\n        blocks\n            .iter()\n            .all(|b| b.expr.map_or(false, |e| hash_expr(cx, e) == hash))\n    } else {\n        blocks.iter().all(|b| b.expr.is_none())\n    };\n    if !expr_hash_eq {\n        return BlockEq {\n            start_end_eq,\n            end_begin_eq: None,\n            moved_locals,\n        };\n    }\n    let end_search_start = block.stmts[start_end_eq..]\n        .iter()\n        .rev()\n        .enumerate()\n        .find(|&(offset, stmt)| {\n            let hash = hash_stmt(cx, stmt);\n            blocks.iter().any(|b| {\n                b.stmts\n                    // the bounds check will catch the underflow\n                    .get(b.stmts.len().wrapping_sub(offset + 1))\n                    .map_or(true, |s| hash != hash_stmt(cx, s))\n            })\n        })\n        .map_or(block.stmts.len() - start_end_eq, |(i, _)| i);\n    let moved_locals_at_start = moved_locals.len();\n    let mut i = end_search_start;\n    let end_begin_eq = block.stmts[block.stmts.len() - end_search_start..]\n        .iter()\n        .zip(iter::repeat_with(move || {\n            let x = i;\n            i -= 1;\n            x\n        }))\n        .fold(end_search_start, |init, (stmt, offset)| {\n            if eq_stmts(\n                stmt,\n                blocks,\n                |b| b.stmts.get(b.stmts.len() - offset),\n                &mut eq,\n                &mut moved_locals,\n            ) {\n                init\n            } else {\n                // Clear out all locals seen at the end so far. None of them can be moved.\n                let stmts = &blocks[0].stmts;\n                for stmt in &stmts[stmts.len() - init..=stmts.len() - offset] {\n                    if let StmtKind::Local(l) = stmt.kind {\n                        l.pat.each_binding_or_first(&mut |_, id, _, _| {\n                            eq.locals.remove(&id);\n                        });\n                    }\n                }\n                moved_locals.truncate(moved_locals_at_start);\n                offset - 1\n            }\n        });\n    if let Some(e) = block.expr {\n        for block in blocks {\n            if block.expr.map_or(false, |expr| !eq.eq_expr(expr, e)) {\n                moved_locals.truncate(moved_locals_at_start);\n                return BlockEq {\n                    start_end_eq,\n                    end_begin_eq: None,\n                    moved_locals,\n                };\n            }\n        }\n    }\n    BlockEq {\n        start_end_eq,\n        end_begin_eq: Some(end_begin_eq),\n        moved_locals,\n    }\n"]], "pred": {"ppl": 2.4314615726470947, "ppl_lower": 2.6659932136535645, "ppl/lowercase_ppl": -1.103640857545949, "ppl/zlib": 0.0007606956736017816, "Min_5.0% Prob": 6.842572539460425, "Min_10.0% Prob": 5.5067207906760425, "Min_20.0% Prob": 3.815589049283196, "Min_30.0% Prob": 2.8402639197952606, "Min_40.0% Prob": 2.195084124512078, "Min_50.0% Prob": 1.77312487017531, "Min_60.0% Prob": 1.4816330874317476}}
{"hexsha": "a9a03adb351f7cf0f5d6e58d7a4defffdc648980", "ext": "rs", "lang": "Rust", "content": "fn decrypt(cipher_text: &[u8], key: &[u8]) -> Result<Vec<u8>> {\n    if cipher_text.len() <= aes::BLOCK_SIZE {\n        return Err(Error::CipherTextTooShort(cipher_text.len()));\n    }\n    let iv = &cipher_text[..aes::BLOCK_SIZE];\n    let cipher_text = &cipher_text[aes::BLOCK_SIZE..];\n    let cipher: Cbc<Aes128, Pkcs7> = Cbc::new_from_slices(key, iv)?;\n\n    Ok(cipher.decrypt_vec(cipher_text)?)\n}", "item_id": 1, "repo": "SfietKonstantin/acfunliveapi", "file": "danmaku/src/proto.rs", "last_update_at": "2020-12-09T05:13:53+00:00", "question_id": "a9a03adb351f7cf0f5d6e58d7a4defffdc648980_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decrypt(cipher_text: &[u8], key: &[u8]) -> Result<Vec<u8>> {\n    if cipher_text.len() <= aes::BLOCK_SIZE {\n        return Err(Error::CipherTextTooShort(cipher_text.len()));\n    }\n    let iv = &cipher_text[..aes::BLOCK_SIZE];\n    let cipher_text = &cipher_text[aes::BLOCK_SIZE..];\n    let cipher: Cbc<Aes128, Pkcs7> = Cbc::new_from_slices(key, iv)?;\n    Ok(cipher.decrypt_vec(cipher_text)?)\n"]], "pred": {"ppl": 1.688918948173523, "ppl_lower": 2.277010917663574, "ppl/lowercase_ppl": -1.5700847251650656, "ppl/zlib": 0.0021928395339676264, "Min_5.0% Prob": 5.285160005092621, "Min_10.0% Prob": 3.688020811361425, "Min_20.0% Prob": 2.346806931145051, "Min_30.0% Prob": 1.682252792751088, "Min_40.0% Prob": 1.3030030650689322, "Min_50.0% Prob": 1.0432327794300955, "Min_60.0% Prob": 0.8742322559215273}}
{"hexsha": "87bace40d95a766d815e6538c887f3bd27ea21f7", "ext": "rs", "lang": "Rust", "content": "fn session_forward_stdin() {\n        let mut session: Session<MockWindow> = Session::new(WINSZ);\n        let (first, _) = session.new_window().unwrap();\n        let (second, _) = session.new_window().unwrap();\n\n        session.select_window(second);\n        assert_eq!(session.selected_window_idx(), Some(second));\n        session.receive_stdin(b\"Hello\").unwrap();\n\n        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;\n        assert!(recv.try_next().is_err(), \"other window received byte\");\n        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;\n        for byte in b\"Hello\" {\n            assert_eq!(recv.try_next().unwrap(), Some(*byte), \"failed to recv byte\");\n        }\n        assert!(recv.try_next().is_err(), \"recv too many bytes\");\n\n        session.select_window(first);\n        session.receive_stdin(b\"World\").unwrap();\n\n        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;\n        for byte in b\"World\" {\n            assert_eq!(recv.try_next().unwrap(), Some(*byte), \"failed to recv byte\");\n        }\n        assert!(recv.try_next().is_err(), \"recv too many bytes\");\n        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;\n        assert!(recv.try_next().is_err(), \"other window received byte\");\n    }", "item_id": 2, "repo": "nw0/session-manager", "file": "src/session.rs", "last_update_at": "2020-12-21T22:31:56+00:00", "question_id": "87bace40d95a766d815e6538c887f3bd27ea21f7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn session_forward_stdin() {\n        let mut session: Session<MockWindow> = Session::new(WINSZ);\n        let (first, _) = session.new_window().unwrap();\n        let (second, _) = session.new_window().unwrap();\n        session.select_window(second);\n        assert_eq!(session.selected_window_idx(), Some(second));\n        session.receive_stdin(b\"Hello\").unwrap();\n        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;\n        assert!(recv.try_next().is_err(), \"other window received byte\");\n        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;\n        for byte in b\"Hello\" {\n            assert_eq!(recv.try_next().unwrap(), Some(*byte), \"failed to recv byte\");\n        }\n        assert!(recv.try_next().is_err(), \"recv too many bytes\");\n        session.select_window(first);\n        session.receive_stdin(b\"World\").unwrap();\n        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;\n        for byte in b\"World\" {\n            assert_eq!(recv.try_next().unwrap(), Some(*byte), \"failed to recv byte\");\n        }\n        assert!(recv.try_next().is_err(), \"recv too many bytes\");\n        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;\n        assert!(recv.try_next().is_err(), \"other window received byte\");\n"]], "pred": {"ppl": 1.8873331546783447, "ppl_lower": 1.9874067306518555, "ppl/lowercase_ppl": -1.0813424088303758, "ppl/zlib": 0.001841057401048074, "Min_5.0% Prob": 6.6762585043907166, "Min_10.0% Prob": 4.641307685433365, "Min_20.0% Prob": 2.922357895025393, "Min_30.0% Prob": 2.0732158588442378, "Min_40.0% Prob": 1.581625689025514, "Min_50.0% Prob": 1.2691248466919471, "Min_60.0% Prob": 1.0583038261629703}}
{"hexsha": "eda2cabe8ce35831fb8145103a09875819b7480f", "ext": "rs", "lang": "Rust", "content": "fn parse_mv10() {\n        let mut m = Parser::new(\"[mvl2l100,5,1,left]\");\n        assert_eq!(\n            m.next(),\n            Some(Ok(Value::MovingText(\n                MovingTextMode::Linear(2),\n                MovingTextDirection::Left,\n                100,\n                5,\n                1,\n                \"left\".into()\n            )))\n        );\n        assert_eq!(m.next(), None);\n    }", "item_id": 97, "repo": "mnit-rtmc/ntcip", "file": "src/dms/multi.rs", "last_update_at": "2020-12-22T04:57:54+00:00", "question_id": "eda2cabe8ce35831fb8145103a09875819b7480f_97", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_mv10() {\n        let mut m = Parser::new(\"[mvl2l100,5,1,left]\");\n        assert_eq!(\n            m.next(),\n            Some(Ok(Value::MovingText(\n                MovingTextMode::Linear(2),\n                MovingTextDirection::Left,\n                100,\n                5,\n                1,\n                \"left\".into()\n            )))\n        );\n        assert_eq!(m.next(), None);\n"]], "pred": {"ppl": 4.248752117156982, "ppl_lower": 5.944633483886719, "ppl/lowercase_ppl": -1.232170384437991, "ppl/zlib": 0.0074568315480887, "Min_5.0% Prob": 8.279120206832886, "Min_10.0% Prob": 6.8063777685165405, "Min_20.0% Prob": 5.280075212319692, "Min_30.0% Prob": 4.1369232469134865, "Min_40.0% Prob": 3.4222491992016635, "Min_50.0% Prob": 2.8580700953801474, "Min_60.0% Prob": 2.4127326468005776}}
{"hexsha": "36cc440f5f94818fef36063cb5a8a6642e02b2d7", "ext": "rs", "lang": "Rust", "content": "fn produces_predictable_results_one_d6_parsed_with_disadvantage_equals_two() {\n        let rng = rand_pcg::Pcg64Mcg::seed_from_u64(SEED);\n        let dice = Roll::from_str(\"1d6 d\").expect(\"No error parsing dice\");\n        let result = dice.roll_from_rng(rng);\n        let expected = vec![DiceSetResults::new(\n            vec![RollResult::new(vec![2], Some(vec![6]), 2)],\n            2,\n        )];\n        assert_eq!(result, expected);\n    }", "item_id": 2, "repo": "arranf/dice_roller", "file": "src/roll.rs", "last_update_at": "2020-06-25T03:23:26+00:00", "question_id": "36cc440f5f94818fef36063cb5a8a6642e02b2d7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn produces_predictable_results_one_d6_parsed_with_disadvantage_equals_two() {\n        let rng = rand_pcg::Pcg64Mcg::seed_from_u64(SEED);\n        let dice = Roll::from_str(\"1d6 d\").expect(\"No error parsing dice\");\n        let result = dice.roll_from_rng(rng);\n        let expected = vec![DiceSetResults::new(\n            vec![RollResult::new(vec![2], Some(vec![6]), 2)],\n            2,\n        )];\n        assert_eq!(result, expected);\n"]], "pred": {"ppl": 4.42332124710083, "ppl_lower": 6.418129920959473, "ppl/lowercase_ppl": -1.2503451844448086, "ppl/zlib": 0.005632162224587689, "Min_5.0% Prob": 8.822226388113839, "Min_10.0% Prob": 7.4448018074035645, "Min_20.0% Prob": 5.46617716358554, "Min_30.0% Prob": 4.328796783219213, "Min_40.0% Prob": 3.4882991342775282, "Min_50.0% Prob": 2.8943433673718038, "Min_60.0% Prob": 2.468753255503152}}
{"hexsha": "5977d053b57db8f8b1825db7da2e083b4c98bdf1", "ext": "rs", "lang": "Rust", "content": "fn load_file_yields_correct_pixel_channel_count() {\n    let result = tex_atlas::load_file(SAMPLE_DATA).unwrap().multi_atlas;\n    let expected = multi_atlas();\n    for page_name in result.page_names() {\n        let result_page = result.by_page_name(page_name).unwrap();\n        let expected_page = expected.by_page_name(page_name).unwrap();\n\n        assert_eq!(result_page.channel_count, expected_page.channel_count);\n    }\n}", "item_id": 5, "repo": "lambdaxymox/tex_atlas", "file": "tests/integration_tests.rs", "last_update_at": "2020-04-27T06:18:08+00:00", "question_id": "5977d053b57db8f8b1825db7da2e083b4c98bdf1_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_file_yields_correct_pixel_channel_count() {\n    let result = tex_atlas::load_file(SAMPLE_DATA).unwrap().multi_atlas;\n    let expected = multi_atlas();\n    for page_name in result.page_names() {\n        let result_page = result.by_page_name(page_name).unwrap();\n        let expected_page = expected.by_page_name(page_name).unwrap();\n        assert_eq!(result_page.channel_count, expected_page.channel_count);\n    }\n"]], "pred": {"ppl": 3.484184503555298, "ppl_lower": 3.6286909580230713, "ppl/lowercase_ppl": -1.0325563557360755, "ppl/zlib": 0.0061489360343867676, "Min_5.0% Prob": 8.738026959555489, "Min_10.0% Prob": 6.946156467710223, "Min_20.0% Prob": 5.152284400803702, "Min_30.0% Prob": 3.9366963704427085, "Min_40.0% Prob": 3.065262750855514, "Min_50.0% Prob": 2.4834431519465787, "Min_60.0% Prob": 2.076692328500074}}
{"hexsha": "06a709739f18bb1172822e63adabd91f21901a5b", "ext": "rs", "lang": "Rust", "content": "fn basic_transfer_between_actors(\n        sender_balance: u64,\n        recipient_balance: u64,\n        replica_count: u8,\n    ) -> Result<Option<()>> {\n        // --- Filter ---\n        if 0 == sender_balance || 2 >= replica_count {\n            return Ok(None);\n        }\n\n        // --- Arrange ---\n        let section_count = 2;\n        let sender_index = 0;\n        let recipient_index = 1;\n        let recipient_final = sender_balance + recipient_balance;\n        let section_configs = vec![vec![sender_balance], vec![recipient_balance]];\n        let Network {\n            mut actors,\n            mut sections,\n            ..\n        } = setup_new_network(section_count, replica_count, section_configs)?;\n        let mut sender_section = sections.remove(0);\n        let mut recipient_section = sections.remove(0);\n        let mut sender = actors.remove(0);\n        let mut recipient = actors.remove(0);\n\n        // --- Act ---\n        // 1. Init transfer at Sender Actor.\n        let transfer = init_transfer(&mut sender, recipient.actor.id())?;\n        // 2. Validate at Sender Replicas.\n        let debit_proof = validate_at_sender_replicas(transfer, &mut sender)?\n            .ok_or(Error::SenderValidationFailed)?;\n        // 3. Register at Sender Replicas.\n        register_at_debiting_replicas(&debit_proof, &mut sender_section)?;\n        // 4. Propagate to Recipient Replicas.\n        let events =\n            propagate_to_crediting_replicas(debit_proof.credit_proof(), &mut recipient_section);\n        // 5. Synch at Recipient Actor.\n        synch(&mut recipient)?;\n\n        // --- Assert ---\n        // Actor and Replicas have the correct balance.\n        assert_balance(sender, Token::zero());\n        assert_balance(recipient, Token::from_nano(recipient_final));\n        Ok(Some(()))\n    }", "item_id": 3, "repo": "oetyng/sn_transfers", "file": "src/lib.rs", "last_update_at": "2020-08-06T05:19:17+00:00", "question_id": "06a709739f18bb1172822e63adabd91f21901a5b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn basic_transfer_between_actors(\n        sender_balance: u64,\n        recipient_balance: u64,\n        replica_count: u8,\n    ) -> Result<Option<()>> {\n        // --- Filter ---\n        if 0 == sender_balance || 2 >= replica_count {\n            return Ok(None);\n        }\n        // --- Arrange ---\n        let section_count = 2;\n        let sender_index = 0;\n        let recipient_index = 1;\n        let recipient_final = sender_balance + recipient_balance;\n        let section_configs = vec![vec![sender_balance], vec![recipient_balance]];\n        let Network {\n            mut actors,\n            mut sections,\n            ..\n        } = setup_new_network(section_count, replica_count, section_configs)?;\n        let mut sender_section = sections.remove(0);\n        let mut recipient_section = sections.remove(0);\n        let mut sender = actors.remove(0);\n        let mut recipient = actors.remove(0);\n        // --- Act ---\n        // 1. Init transfer at Sender Actor.\n        let transfer = init_transfer(&mut sender, recipient.actor.id())?;\n        // 2. Validate at Sender Replicas.\n        let debit_proof = validate_at_sender_replicas(transfer, &mut sender)?\n            .ok_or(Error::SenderValidationFailed)?;\n        // 3. Register at Sender Replicas.\n        register_at_debiting_replicas(&debit_proof, &mut sender_section)?;\n        // 4. Propagate to Recipient Replicas.\n        let events =\n            propagate_to_crediting_replicas(debit_proof.credit_proof(), &mut recipient_section);\n        // 5. Synch at Recipient Actor.\n        synch(&mut recipient)?;\n        // --- Assert ---\n        // Actor and Replicas have the correct balance.\n        assert_balance(sender, Token::zero());\n        assert_balance(recipient, Token::from_nano(recipient_final));\n        Ok(Some(()))\n"]], "pred": {"ppl": 2.745654582977295, "ppl_lower": 3.0802018642425537, "ppl/lowercase_ppl": -1.113835053411163, "ppl/zlib": 0.0016083113220979935, "Min_5.0% Prob": 7.976601759592692, "Min_10.0% Prob": 6.062928628921509, "Min_20.0% Prob": 4.15666615637866, "Min_30.0% Prob": 3.136372377714479, "Min_40.0% Prob": 2.4662177644973426, "Min_50.0% Prob": 2.003020732976254, "Min_60.0% Prob": 1.6809374795418726}}
{"hexsha": "14c0b56b1253a93b9b138316f07553e5dd34580d", "ext": "rs", "lang": "Rust", "content": "pub fn test_with_data(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let function = syn::parse_macro_input!(item as ItemFn);\n    let source = syn::parse_macro_input!(attr as Expr);\n    test_with_data_impl(function, &source).into()\n}", "item_id": 0, "repo": "jgreat/mobilecoin", "file": "util/test-with-data/src/lib.rs", "last_update_at": "2020-10-02T19:51:57+00:00", "question_id": "14c0b56b1253a93b9b138316f07553e5dd34580d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_with_data(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let function = syn::parse_macro_input!(item as ItemFn);\n    let source = syn::parse_macro_input!(attr as Expr);\n    test_with_data_impl(function, &source).into()\n"]], "pred": {"ppl": 3.05698823928833, "ppl_lower": 4.874025344848633, "ppl/lowercase_ppl": -1.4174667565006454, "ppl/zlib": 0.007209227069417826, "Min_5.0% Prob": 9.521388053894043, "Min_10.0% Prob": 7.597286428724017, "Min_20.0% Prob": 4.968195803960165, "Min_30.0% Prob": 3.492541095484858, "Min_40.0% Prob": 2.7828354517618816, "Min_50.0% Prob": 2.2431578593034494, "Min_60.0% Prob": 1.8654714161125214}}
{"hexsha": "99767cca585400c697da62c19bc41eb694ddee56", "ext": "rs", "lang": "Rust", "content": "pub fn deserialize() {\n        let stream_json = \"{\\\"infoHash\\\":\\\"07a9de9750158471c3302e4e95edb1107f980fa6\\\",\\\"fileIdx\\\":1,\\\"title\\\":\\\"test stream\\\"}\";\n        let stream: Stream = serde_json::from_str(&stream_json).unwrap();\n        assert_eq!(\n            stream,\n            Stream {\n                title: Some(\"test stream\".into()),\n                thumbnail: None,\n                subtitles: Default::default(),\n                behavior_hints: Default::default(),\n                source: StreamSource::Torrent {\n                    info_hash: [\n                        0x07, 0xa9, 0xde, 0x97, 0x50, 0x15, 0x84, 0x71, 0xc3, 0x30, 0x2e, 0x4e,\n                        0x95, 0xed, 0xb1, 0x10, 0x7f, 0x98, 0x0f, 0xa6\n                    ],\n                    file_idx: Some(1),\n                }\n            }\n        )\n    }", "item_id": 0, "repo": "nklhrstv/stremio-core", "file": "src/types/stream.rs", "last_update_at": "2020-01-17T17:51:20+00:00", "question_id": "99767cca585400c697da62c19bc41eb694ddee56_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn deserialize() {\n        let stream_json = \"{\\\"infoHash\\\":\\\"07a9de9750158471c3302e4e95edb1107f980fa6\\\",\\\"fileIdx\\\":1,\\\"title\\\":\\\"test stream\\\"}\";\n        let stream: Stream = serde_json::from_str(&stream_json).unwrap();\n        assert_eq!(\n            stream,\n            Stream {\n                title: Some(\"test stream\".into()),\n                thumbnail: None,\n                subtitles: Default::default(),\n                behavior_hints: Default::default(),\n                source: StreamSource::Torrent {\n                    info_hash: [\n                        0x07, 0xa9, 0xde, 0x97, 0x50, 0x15, 0x84, 0x71, 0xc3, 0x30, 0x2e, 0x4e,\n                        0x95, 0xed, 0xb1, 0x10, 0x7f, 0x98, 0x0f, 0xa6\n                    ],\n                    file_idx: Some(1),\n                }\n            }\n        )\n"]], "pred": {"ppl": 2.538888692855835, "ppl_lower": 2.894779682159424, "ppl/lowercase_ppl": -1.1407951235634473, "ppl/zlib": 0.0025113920829968935, "Min_5.0% Prob": 7.665343761444092, "Min_10.0% Prob": 5.591272131089242, "Min_20.0% Prob": 4.127608253109839, "Min_30.0% Prob": 3.07263332733544, "Min_40.0% Prob": 2.3258938410282135, "Min_50.0% Prob": 1.8683117600814558, "Min_60.0% Prob": 1.559276933026037}}
{"hexsha": "077543156117a60cab3077fec32714ae6f939d88", "ext": "rs", "lang": "Rust", "content": "async fn rename_dir_should_return_success_if_renamed_directory() {\n        let root = tempfile::tempdir().unwrap();\n        let mut fsm = FileSystemManager::new();\n\n        let origin = root.as_ref().join(\"origin\");\n        fs::create_dir(origin.as_path()).await.unwrap();\n\n        let destination = root.as_ref().join(\"destination\");\n\n        match fsm.rename_dir(origin, destination).await {\n            Ok(_) => (),\n            x => panic!(\"Unexpected result: {:?}\", x),\n        }\n    }", "item_id": 5, "repo": "chipsenkbeil/over-there", "file": "src/core/server/fs/mod.rs", "last_update_at": "2020-07-29T16:21:21+00:00", "question_id": "077543156117a60cab3077fec32714ae6f939d88_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn rename_dir_should_return_success_if_renamed_directory() {\n        let root = tempfile::tempdir().unwrap();\n        let mut fsm = FileSystemManager::new();\n        let origin = root.as_ref().join(\"origin\");\n        fs::create_dir(origin.as_path()).await.unwrap();\n        let destination = root.as_ref().join(\"destination\");\n        match fsm.rename_dir(origin, destination).await {\n            Ok(_) => (),\n            x => panic!(\"Unexpected result: {:?}\", x),\n        }\n"]], "pred": {"ppl": 2.636298418045044, "ppl_lower": 3.2822086811065674, "ppl/lowercase_ppl": -1.2260637731961928, "ppl/zlib": 0.0036858396155863126, "Min_5.0% Prob": 8.272283349718366, "Min_10.0% Prob": 6.0798192875725885, "Min_20.0% Prob": 4.059825169629064, "Min_30.0% Prob": 3.0515544539274173, "Min_40.0% Prob": 2.3626324608922005, "Min_50.0% Prob": 1.9318684154293604, "Min_60.0% Prob": 1.6100394641873481}}
{"hexsha": "436299bc1ff0feb946e5eaa0307e794c5b3c4921", "ext": "rs", "lang": "Rust", "content": "pub fn render(\n    gui: &mut GuiProgram,\n    frame: &wgpu::SwapChainOutput,\n    device: &wgpu::Device,\n) -> Vec<wgpu::CommandBuffer> {\n\n    // Draw the tree itself\n    // This function returns a list of vertices that when drawn makes up the background of the tree\n    // It will also fill the text buffer with the appropriate sections - all we need to do is flush it\n    let mut vertices = render_file_tree(gui);\n    vertices.append(&mut super::Vertex::rect(0.0, 0.0, gui.align.win_width, 32.0, [0.0,0.0,0.0,1.0]));\n\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });\n\n    if !vertices.is_empty() {\n        let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);\n\n        let rpass_color_attachment = {\n            wgpu::RenderPassColorAttachmentDescriptor {\n                attachment: &frame.view,\n                resolve_target: None,\n                load_op: wgpu::LoadOp::Clear,\n                store_op: wgpu::StoreOp::Store,\n                clear_color: wgpu::Color::BLACK,\n            }\n        };\n\n        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {\n            color_attachments: &[rpass_color_attachment],\n            depth_stencil_attachment: None,\n        });\n\n        rpass.set_pipeline(&gui.pipeline);\n        rpass.set_bind_group(0, &gui.uniforms, &[]);\n        rpass.set_vertex_buffer(0, &buffer, 0, 0);\n\n        rpass.draw(0..vertices.len() as u32, 0..1);\n    }\n    let cb1 = encoder.finish();\n\n    ////// Images\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });\n\n    let vertices = gui.align.image(Anchor::TopRight, 0.0, 0.0, 64.0, 32.0, 0.0, Some([0.0,588.0,128.0,64.0]));\n    let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);\n\n    let rpass_color_attachment =  {\n        wgpu::RenderPassColorAttachmentDescriptor {\n            attachment: &frame.view,\n            resolve_target: None,\n            load_op: wgpu::LoadOp::Load,\n            store_op: wgpu::StoreOp::Store,\n            clear_color: wgpu::Color::WHITE,\n        }\n    };\n\n    {\n        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {\n            color_attachments: &[rpass_color_attachment],\n            depth_stencil_attachment: None,\n        });\n\n        rpass.set_pipeline(&gui.tex_pipeline);\n        rpass.set_bind_group(0, &gui.uniforms, &[]);\n        rpass.set_bind_group(1, &gui.texture_bind_group, &[]);\n        rpass.set_vertex_buffer(0, &buffer, 0, 0);\n\n        rpass.draw(0..vertices.len() as u32, 0..1);\n    }\n\n    gui.state_manager.text_handler.lock().unwrap().draw(\"File tree\", 0.0, 0.0, 32.0, f32::INFINITY, [1.0,1.0,1.0,1.0]);\n    let cb2 = encoder.finish();\n\n\n    ///// Render text\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some(\"Text\") });\n\n    // Draw on top of previous (i.e. on the background of the tree)\n    {\n        let _ = encoder.begin_render_pass(\n            &wgpu::RenderPassDescriptor {\n                color_attachments: &[\n                    wgpu::RenderPassColorAttachmentDescriptor {\n                        attachment: &frame.view,\n                        resolve_target: None,\n                        load_op: wgpu::LoadOp::Load,\n                        store_op: wgpu::StoreOp::Store,\n                        clear_color: wgpu::Color::BLACK,\n                    },\n                ],\n                depth_stencil_attachment: None,\n            },\n        );\n    }\n\n    gui.state_manager.text_handler.lock().unwrap().flush(&device,&mut encoder, frame, (gui.sc_desc.width,gui.sc_desc.height));\n\n    let cb3 = encoder.finish();\n\n    vec![cb1,cb2,cb3]\n}", "item_id": 0, "repo": "KongouDesu/BackupGUI", "file": "src/ui/filetree.rs", "last_update_at": "2020-10-01T00:43:08+00:00", "question_id": "436299bc1ff0feb946e5eaa0307e794c5b3c4921_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn render(\n    gui: &mut GuiProgram,\n    frame: &wgpu::SwapChainOutput,\n    device: &wgpu::Device,\n) -> Vec<wgpu::CommandBuffer> {\n    // Draw the tree itself\n    // This function returns a list of vertices that when drawn makes up the background of the tree\n    // It will also fill the text buffer with the appropriate sections - all we need to do is flush it\n    let mut vertices = render_file_tree(gui);\n    vertices.append(&mut super::Vertex::rect(0.0, 0.0, gui.align.win_width, 32.0, [0.0,0.0,0.0,1.0]));\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });\n    if !vertices.is_empty() {\n        let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);\n        let rpass_color_attachment = {\n            wgpu::RenderPassColorAttachmentDescriptor {\n                attachment: &frame.view,\n                resolve_target: None,\n                load_op: wgpu::LoadOp::Clear,\n                store_op: wgpu::StoreOp::Store,\n                clear_color: wgpu::Color::BLACK,\n            }\n        };\n        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {\n            color_attachments: &[rpass_color_attachment],\n            depth_stencil_attachment: None,\n        });\n        rpass.set_pipeline(&gui.pipeline);\n        rpass.set_bind_group(0, &gui.uniforms, &[]);\n        rpass.set_vertex_buffer(0, &buffer, 0, 0);\n        rpass.draw(0..vertices.len() as u32, 0..1);\n    }\n    let cb1 = encoder.finish();\n    ////// Images\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });\n    let vertices = gui.align.image(Anchor::TopRight, 0.0, 0.0, 64.0, 32.0, 0.0, Some([0.0,588.0,128.0,64.0]));\n    let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);\n    let rpass_color_attachment =  {\n        wgpu::RenderPassColorAttachmentDescriptor {\n            attachment: &frame.view,\n            resolve_target: None,\n            load_op: wgpu::LoadOp::Load,\n            store_op: wgpu::StoreOp::Store,\n            clear_color: wgpu::Color::WHITE,\n        }\n    };\n    {\n        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {\n            color_attachments: &[rpass_color_attachment],\n            depth_stencil_attachment: None,\n        });\n        rpass.set_pipeline(&gui.tex_pipeline);\n        rpass.set_bind_group(0, &gui.uniforms, &[]);\n        rpass.set_bind_group(1, &gui.texture_bind_group, &[]);\n        rpass.set_vertex_buffer(0, &buffer, 0, 0);\n        rpass.draw(0..vertices.len() as u32, 0..1);\n    }\n    gui.state_manager.text_handler.lock().unwrap().draw(\"File tree\", 0.0, 0.0, 32.0, f32::INFINITY, [1.0,1.0,1.0,1.0]);\n    let cb2 = encoder.finish();\n    ///// Render text\n    let mut encoder =\n        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some(\"Text\") });\n    // Draw on top of previous (i.e. on the background of the tree)\n    {\n        let _ = encoder.begin_render_pass(\n            &wgpu::RenderPassDescriptor {\n                color_attachments: &[\n                    wgpu::RenderPassColorAttachmentDescriptor {\n                        attachment: &frame.view,\n                        resolve_target: None,\n                        load_op: wgpu::LoadOp::Load,\n                        store_op: wgpu::StoreOp::Store,\n                        clear_color: wgpu::Color::BLACK,\n                    },\n                ],\n                depth_stencil_attachment: None,\n            },\n        );\n    }\n    gui.state_manager.text_handler.lock().unwrap().flush(&device,&mut encoder, frame, (gui.sc_desc.width,gui.sc_desc.height));\n    let cb3 = encoder.finish();\n    vec![cb1,cb2,cb3]\n"]], "pred": {"ppl": 1.9105474948883057, "ppl_lower": 2.073718547821045, "ppl/lowercase_ppl": -1.126590721782784, "ppl/zlib": 0.0005933912442911537, "Min_5.0% Prob": 7.009430025138107, "Min_10.0% Prob": 4.984012805948071, "Min_20.0% Prob": 3.0589722348194495, "Min_30.0% Prob": 2.136854402307007, "Min_40.0% Prob": 1.6135148668438561, "Min_50.0% Prob": 1.2945895599558541, "Min_60.0% Prob": 1.080068312378731}}
{"hexsha": "d86e9a5334b449ce47e35f00c7245dcd8a241d55", "ext": "rs", "lang": "Rust", "content": "pub extern fn vcx_credential_release(handle: u32) -> u32 {\n    info!(\"vcx_credential_release >>>\");\n\n    let source_id = credential::get_source_id(handle).unwrap_or_default();\n    match credential::release(handle) {\n        Ok(_) => trace!(\"vcx_credential_release(handle: {}, rc: {}), source_id: {:?}\",\n                       handle, error_string(0), source_id),\n        Err(e) => error!(\"vcx_credential_release(handle: {}, rc: {}), source_id: {:?}\",\n                         handle, error_string(e.to_error_code()), source_id),\n    };\n    error::SUCCESS.code_num\n}", "item_id": 10, "repo": "ssyijiu/indy-sdk", "file": "vcx/libvcx/src/api/credential.rs", "last_update_at": "2020-01-22T06:43:05+00:00", "question_id": "d86e9a5334b449ce47e35f00c7245dcd8a241d55_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern fn vcx_credential_release(handle: u32) -> u32 {\n    info!(\"vcx_credential_release >>>\");\n    let source_id = credential::get_source_id(handle).unwrap_or_default();\n    match credential::release(handle) {\n        Ok(_) => trace!(\"vcx_credential_release(handle: {}, rc: {}), source_id: {:?}\",\n                       handle, error_string(0), source_id),\n        Err(e) => error!(\"vcx_credential_release(handle: {}, rc: {}), source_id: {:?}\",\n                         handle, error_string(e.to_error_code()), source_id),\n    };\n    error::SUCCESS.code_num\n"]], "pred": {"ppl": 1.976024866104126, "ppl_lower": 2.4263553619384766, "ppl/lowercase_ppl": -1.3014343862581403, "ppl/zlib": 0.0027799476869685303, "Min_5.0% Prob": 7.218095461527507, "Min_10.0% Prob": 5.190262052747938, "Min_20.0% Prob": 3.175968004239572, "Min_30.0% Prob": 2.261768170649355, "Min_40.0% Prob": 1.6965986066875425, "Min_50.0% Prob": 1.368019251861488, "Min_60.0% Prob": 1.134714334563411}}
{"hexsha": "1213a07d1721fd569530d4817ce8547700f95d30", "ext": "rs", "lang": "Rust", "content": "fn test_salt_from_hex_odd_length() {\n        let hex = \"a83e8f932\";\n\n        let err = Salt::from_hex(&hex).unwrap_err();\n\n        assert_eq!(SaltFromStrError::InvalidHexLength, err);\n    }", "item_id": 10, "repo": "rowans329/hsh", "file": "src/bcrypt.rs", "last_update_at": "2020-11-25T02:39:50+00:00", "question_id": "1213a07d1721fd569530d4817ce8547700f95d30_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_salt_from_hex_odd_length() {\n        let hex = \"a83e8f932\";\n        let err = Salt::from_hex(&hex).unwrap_err();\n        assert_eq!(SaltFromStrError::InvalidHexLength, err);\n"]], "pred": {"ppl": 4.571115970611572, "ppl_lower": 7.045277118682861, "ppl/lowercase_ppl": -1.2846507729835477, "ppl/zlib": 0.010199713892466968, "Min_5.0% Prob": 7.346037069956462, "Min_10.0% Prob": 5.990236214229038, "Min_20.0% Prob": 4.903784581593105, "Min_30.0% Prob": 4.190512112208775, "Min_40.0% Prob": 3.596707603761128, "Min_50.0% Prob": 2.940843027498987, "Min_60.0% Prob": 2.5133103936217553}}
{"hexsha": "811539c937bf292e3f12a0cd8284cc05e2d69526", "ext": "rs", "lang": "Rust", "content": "fn test_mode_and_permissions() {\n        use std::os::unix::fs::{symlink, PermissionsExt};\n        use std::fs::{set_permissions, Permissions};\n\n        let dir = tempdir().unwrap();\n\n        let unavailable_dir_path = dir.path().join(\"unavailable\");\n        let unavailable_file_path = unavailable_dir_path.join(\"file\");\n        let readonly_path = dir.path().join(\"readonly.txt\");\n        let symlink_path = dir.path().join(\"writeonly.txt\");\n        create_dir(&unavailable_dir_path).unwrap();\n        write(&unavailable_file_path, \"foo\").unwrap();\n        write(&readonly_path, \"foo\").unwrap();\n        symlink(&readonly_path, &symlink_path).unwrap();\n\n        set_permissions(&unavailable_dir_path, Permissions::from_mode(0o000)).unwrap();\n        set_permissions(&readonly_path, Permissions::from_mode(0o444)).unwrap();\n\n        let mut session = session::test::Fake::new();\n        assert!(handle(&mut session, Request { root: PathBuf::from(dir.path()) }).is_ok());\n\n        let mut entries = entries_from_session_response(&session);\n        entries.sort_by(|a, b| a.path.cmp(&b.path));\n        assert_eq!(entries.len(), 4);\n        assert_eq!(entries[2].mode, Some(0o040000));\n        assert_eq!(entries[1].mode, Some(0o100444));\n        // Drop mode bits because symlinks have actual modes on some unix systems.\n        assert_eq!(entries[3].mode.unwrap() & 0o120000, 0o120000);\n    }", "item_id": 9, "repo": "Spawek/rrg", "file": "src/action/timeline.rs", "last_update_at": "2020-08-07T17:03:39+00:00", "question_id": "811539c937bf292e3f12a0cd8284cc05e2d69526_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_mode_and_permissions() {\n        use std::os::unix::fs::{symlink, PermissionsExt};\n        use std::fs::{set_permissions, Permissions};\n        let dir = tempdir().unwrap();\n        let unavailable_dir_path = dir.path().join(\"unavailable\");\n        let unavailable_file_path = unavailable_dir_path.join(\"file\");\n        let readonly_path = dir.path().join(\"readonly.txt\");\n        let symlink_path = dir.path().join(\"writeonly.txt\");\n        create_dir(&unavailable_dir_path).unwrap();\n        write(&unavailable_file_path, \"foo\").unwrap();\n        write(&readonly_path, \"foo\").unwrap();\n        symlink(&readonly_path, &symlink_path).unwrap();\n        set_permissions(&unavailable_dir_path, Permissions::from_mode(0o000)).unwrap();\n        set_permissions(&readonly_path, Permissions::from_mode(0o444)).unwrap();\n        let mut session = session::test::Fake::new();\n        assert!(handle(&mut session, Request { root: PathBuf::from(dir.path()) }).is_ok());\n        let mut entries = entries_from_session_response(&session);\n        entries.sort_by(|a, b| a.path.cmp(&b.path));\n        assert_eq!(entries.len(), 4);\n        assert_eq!(entries[2].mode, Some(0o040000));\n        assert_eq!(entries[1].mode, Some(0o100444));\n        // Drop mode bits because symlinks have actual modes on some unix systems.\n        assert_eq!(entries[3].mode.unwrap() & 0o120000, 0o120000);\n"]], "pred": {"ppl": 2.075652837753296, "ppl_lower": 2.4147727489471436, "ppl/lowercase_ppl": -1.2072223585121467, "ppl/zlib": 0.001466417118080273, "Min_5.0% Prob": 6.62045262076638, "Min_10.0% Prob": 4.901428201463488, "Min_20.0% Prob": 3.216126942372584, "Min_30.0% Prob": 2.3278589422685387, "Min_40.0% Prob": 1.8048328022052953, "Min_50.0% Prob": 1.4571836611844207, "Min_60.0% Prob": 1.216514868722943}}
{"hexsha": "6178f7789e51d39c95384c36ca843b828e53c045", "ext": "rs", "lang": "Rust", "content": "fn parse_chest(i: &[u8]) -> IResult<&[u8], Chest> {\n    let (i, item_id) = le_u8(i)?;\n    let (i, arg) = le_u8(i)?;\n    let (i, text) = le_u8(i)?;\n    let (i, unknown) = le_u8(i)?;\n\n    Ok((\n        i,\n        Chest {\n            item_id,\n            arg,\n            text,\n            unknown,\n        },\n    ))\n}", "item_id": 0, "repo": "konkers/neutopia", "file": "neutopia/src/rom/chest.rs", "last_update_at": "2020-07-02T21:01:53+00:00", "question_id": "6178f7789e51d39c95384c36ca843b828e53c045_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_chest(i: &[u8]) -> IResult<&[u8], Chest> {\n    let (i, item_id) = le_u8(i)?;\n    let (i, arg) = le_u8(i)?;\n    let (i, text) = le_u8(i)?;\n    let (i, unknown) = le_u8(i)?;\n    Ok((\n        i,\n        Chest {\n            item_id,\n            arg,\n            text,\n            unknown,\n        },\n    ))\n"]], "pred": {"ppl": 1.7305831909179688, "ppl_lower": 2.1060678958892822, "ppl/lowercase_ppl": -1.3580292981682411, "ppl/zlib": 0.003632175207149447, "Min_5.0% Prob": 6.619502623875936, "Min_10.0% Prob": 4.583681060717656, "Min_20.0% Prob": 2.5924392210112677, "Min_30.0% Prob": 1.827471401169896, "Min_40.0% Prob": 1.3752513596857037, "Min_50.0% Prob": 1.0954738136189168, "Min_60.0% Prob": 0.920410636421523}}
{"hexsha": "113040ce8788a67a5081fee45d7aaef46ef743d8", "ext": "rs", "lang": "Rust", "content": "pub async fn main(matches: &clap::ArgMatches<'_>) -> Result<(), failure::Error> {\n    use crate::model::config::Config;\n\n    let config = matches.value_of(\"config\").unwrap();\n    let mut cfg_fi = File::open(&config).unwrap();\n    let mut cfg_by = Vec::new();\n    cfg_fi.read_to_end(&mut cfg_by).unwrap();\n    let config: Config = toml::de::from_slice(&cfg_by).unwrap();\n\n    // let control_socket = matches.value_of_os(\"control-socket\").unwrap();\n    // let control_socket = Path::new(control_socket).to_owned();\n    let mount_point = matches.value_of_os(\"mount-point\").unwrap();\n    let mount_point = Path::new(mount_point).to_owned();\n\n    let states = build_storage_engine_states(&config).unwrap();\n\n    let mut fs_impl = FilesystemImplMutable {\n        storage_backend: states.storage_engine,\n        content_info: states.content_info_manager,\n        vfs: Vfs {\n            inodes: Default::default(),\n            inode_seq: 3,\n        },\n    };\n    fs_impl.vfs.inodes.insert(\n        1,\n        FileEntry {\n            info_hash_owner_counter: 1,\n            inode: 1,\n            size: 0,\n            data: FileEntryData::Dir(Directory {\n                parent: 1,\n                child_inodes: Default::default(),\n            }),\n        },\n    );\n    for t in states.path_to_torrent.values() {\n        if let Err(err) = fs_impl.add_torrent(t) {\n            event!(\n                Level::ERROR,\n                \"{}:{}: failed to add torrent: {}\",\n                file!(),\n                line!(),\n                err\n            );\n        }\n        event!(Level::INFO, \"added {:?} to filesystem\", t.info_hash);\n    }\n\n    event!(\n        Level::INFO,\n        \"mounting with {} known inodes\",\n        fs_impl.vfs.inodes.len()\n    );\n\n    tokio::task::spawn_blocking(move || {\n        let options = [\"-o\", \"ro\", \"-o\", \"fsname=magnetite\"]\n            .iter()\n            .map(|o| o.as_ref())\n            .collect::<Vec<&OsStr>>();\n\n        let fs_impl = FilesystemImpl {\n            mutable: Arc::new(Mutex::new(fs_impl)),\n        };\n\n        fuse::mount(fs_impl, &mount_point, &options).unwrap();\n    })\n    .await?;\n\n    Ok(())\n}", "item_id": 1, "repo": "infinityb/magnetite", "file": "magnetite/src/cmdlet/fuse_mount/mod.rs", "last_update_at": "2020-06-24T02:59:58+00:00", "question_id": "113040ce8788a67a5081fee45d7aaef46ef743d8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn main(matches: &clap::ArgMatches<'_>) -> Result<(), failure::Error> {\n    use crate::model::config::Config;\n    let config = matches.value_of(\"config\").unwrap();\n    let mut cfg_fi = File::open(&config).unwrap();\n    let mut cfg_by = Vec::new();\n    cfg_fi.read_to_end(&mut cfg_by).unwrap();\n    let config: Config = toml::de::from_slice(&cfg_by).unwrap();\n    // let control_socket = matches.value_of_os(\"control-socket\").unwrap();\n    // let control_socket = Path::new(control_socket).to_owned();\n    let mount_point = matches.value_of_os(\"mount-point\").unwrap();\n    let mount_point = Path::new(mount_point).to_owned();\n    let states = build_storage_engine_states(&config).unwrap();\n    let mut fs_impl = FilesystemImplMutable {\n        storage_backend: states.storage_engine,\n        content_info: states.content_info_manager,\n        vfs: Vfs {\n            inodes: Default::default(),\n            inode_seq: 3,\n        },\n    };\n    fs_impl.vfs.inodes.insert(\n        1,\n        FileEntry {\n            info_hash_owner_counter: 1,\n            inode: 1,\n            size: 0,\n            data: FileEntryData::Dir(Directory {\n                parent: 1,\n                child_inodes: Default::default(),\n            }),\n        },\n    );\n    for t in states.path_to_torrent.values() {\n        if let Err(err) = fs_impl.add_torrent(t) {\n            event!(\n                Level::ERROR,\n                \"{}:{}: failed to add torrent: {}\",\n                file!(),\n                line!(),\n                err\n            );\n        }\n        event!(Level::INFO, \"added {:?} to filesystem\", t.info_hash);\n    }\n    event!(\n        Level::INFO,\n        \"mounting with {} known inodes\",\n        fs_impl.vfs.inodes.len()\n    );\n    tokio::task::spawn_blocking(move || {\n        let options = [\"-o\", \"ro\", \"-o\", \"fsname=magnetite\"]\n            .iter()\n            .map(|o| o.as_ref())\n            .collect::<Vec<&OsStr>>();\n        let fs_impl = FilesystemImpl {\n            mutable: Arc::new(Mutex::new(fs_impl)),\n        };\n        fuse::mount(fs_impl, &mount_point, &options).unwrap();\n    })\n    .await?;\n    Ok(())\n"]], "pred": {"ppl": 2.4407548904418945, "ppl_lower": 2.933450937271118, "ppl/lowercase_ppl": -1.2060636918248715, "ppl/zlib": 0.001049773379747319, "Min_5.0% Prob": 6.971065941978903, "Min_10.0% Prob": 5.413591546170852, "Min_20.0% Prob": 3.7553984216030907, "Min_30.0% Prob": 2.775548249190929, "Min_40.0% Prob": 2.1785467240740273, "Min_50.0% Prob": 1.7721055198241682, "Min_60.0% Prob": 1.4843280393785487}}
{"hexsha": "34946611d14328ca306a0c075bb69003942cb86f", "ext": "rs", "lang": "Rust", "content": "fn load_json() {\n        let json = r#\"\n        {\n            \"description\": \"Expected description\",\n            \"metadata\": [\n                {\n                    \"label\": \"size\",\n                    \"value\": \"53 MB\"\n                },\n                {\n                    \"label\": \"colors\",\n                    \"value\": [\"red\", \"green\", \"blue\"]\n                },\n                {\n                    \"label\": \"quality\",\n                    \"value\": [{\"@value\": \"high\", \"@language\": \"en\"}]\n                }\n            ]\n        }\"#;\n        let actual: Meta = serde_json::from_str(json).unwrap();\n        assert_eq!(actual.description, Some(\"Expected description\".to_owned()));\n        assert_eq!(actual.metadata[0], Metadata::key_value(\"size\", \"53 MB\"));\n        assert_eq!(\n            actual.metadata[1],\n            Metadata::list(\n                \"colors\",\n                vec![\"red\".to_owned(), \"green\".to_owned(), \"blue\".to_owned()]\n            )\n        );\n        assert_eq!(\n            actual.metadata[2],\n            Metadata::localized(\"quality\", vec![LocalizedValue::new(\"high\", \"en\")])\n        );\n    }", "item_id": 0, "repo": "bitzl/iiif-presenter", "file": "src/meta.rs", "last_update_at": "2020-09-29T09:56:40+00:00", "question_id": "34946611d14328ca306a0c075bb69003942cb86f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_json() {\n        let json = r#\"\n        {\n            \"description\": \"Expected description\",\n            \"metadata\": [\n                {\n                    \"label\": \"size\",\n                    \"value\": \"53 MB\"\n                },\n                {\n                    \"label\": \"colors\",\n                    \"value\": [\"red\", \"green\", \"blue\"]\n                },\n                {\n                    \"label\": \"quality\",\n                    \"value\": [{\"@value\": \"high\", \"@language\": \"en\"}]\n                }\n            ]\n        }\"#;\n        let actual: Meta = serde_json::from_str(json).unwrap();\n        assert_eq!(actual.description, Some(\"Expected description\".to_owned()));\n        assert_eq!(actual.metadata[0], Metadata::key_value(\"size\", \"53 MB\"));\n        assert_eq!(\n            actual.metadata[1],\n            Metadata::list(\n                \"colors\",\n                vec![\"red\".to_owned(), \"green\".to_owned(), \"blue\".to_owned()]\n            )\n        );\n        assert_eq!(\n            actual.metadata[2],\n            Metadata::localized(\"quality\", vec![LocalizedValue::new(\"high\", \"en\")])\n        );\n"]], "pred": {"ppl": 1.9205749034881592, "ppl_lower": 2.1305124759674072, "ppl/lowercase_ppl": -1.1589550630752576, "ppl/zlib": 0.0017734363318475182, "Min_5.0% Prob": 6.398038387298584, "Min_10.0% Prob": 4.825137456258138, "Min_20.0% Prob": 3.053247206409772, "Min_30.0% Prob": 2.137424070139726, "Min_40.0% Prob": 1.6286394067729513, "Min_50.0% Prob": 1.3021060058982759, "Min_60.0% Prob": 1.088043256724531}}
{"hexsha": "cf88d730f7b68a3d650705d734139cd2ec730ff8", "ext": "rs", "lang": "Rust", "content": "fn kill_input() {\n    let input = Path::new(&env::current_dir().unwrap()).join(\"INPUT\");\n    if input.is_dir() {\n        fs::remove_dir_all(&input).unwrap();\n    }\n    assert_eq!(input.is_dir(), false);\n}", "item_id": 2, "repo": "vegizombie/lal-build-manager", "file": "tests/testmain.rs", "last_update_at": "2020-01-31T22:15:29+00:00", "question_id": "cf88d730f7b68a3d650705d734139cd2ec730ff8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn kill_input() {\n    let input = Path::new(&env::current_dir().unwrap()).join(\"INPUT\");\n    if input.is_dir() {\n        fs::remove_dir_all(&input).unwrap();\n    }\n    assert_eq!(input.is_dir(), false);\n"]], "pred": {"ppl": 2.9880542755126953, "ppl_lower": 3.028927803039551, "ppl/lowercase_ppl": -1.012411827605171, "ppl/zlib": 0.007249155176166528, "Min_5.0% Prob": 8.807455062866211, "Min_10.0% Prob": 6.477593217577253, "Min_20.0% Prob": 4.507619551249912, "Min_30.0% Prob": 3.3931512123062495, "Min_40.0% Prob": 2.682836862547057, "Min_50.0% Prob": 2.1912205427885056, "Min_60.0% Prob": 1.8416235412337951}}
{"hexsha": "1c68ac60b7e9e8ca7a99bcec601782d40b2a5bfb", "ext": "rs", "lang": "Rust", "content": "fn new_row_data(types: &[column::Type], values: &[column::Value]) -> Vec<u8> {\n        let mut buf = Vec::<u8>::new();\n        push_row_data(&mut buf, types, values);\n        buf\n    }", "item_id": 2, "repo": "halcyon/rust-vnf", "file": "src/lib.rs", "last_update_at": "2020-08-07T13:35:32+00:00", "question_id": "1c68ac60b7e9e8ca7a99bcec601782d40b2a5bfb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_row_data(types: &[column::Type], values: &[column::Value]) -> Vec<u8> {\n        let mut buf = Vec::<u8>::new();\n        push_row_data(&mut buf, types, values);\n        buf\n"]], "pred": {"ppl": 3.09951114654541, "ppl_lower": 4.182158946990967, "ppl/lowercase_ppl": -1.2648262410298614, "ppl/zlib": 0.009122938745106605, "Min_5.0% Prob": 8.396450360616049, "Min_10.0% Prob": 7.4306873480478925, "Min_20.0% Prob": 4.913203376990098, "Min_30.0% Prob": 3.6332075658597445, "Min_40.0% Prob": 2.754558781018624, "Min_50.0% Prob": 2.2754581053741276, "Min_60.0% Prob": 1.879733590839001}}
{"hexsha": "0e89c1b2d1c5e343ab62fa81c01e1dcb7ccb7918", "ext": "rs", "lang": "Rust", "content": "fn test_run_ldx_imm() {\n    let mut b = MockBus::new();\n    let mut r = Register::new();\n    r.set_PC(0x80);\n    b.memory[0x80] = 0xA2;\n    b.memory[0x81] = 0xFF;\n    run(&mut r ,&mut b, &mut false);\n    assert_eq!(r.get_X(), 0xFF)\n  }", "item_id": 5, "repo": "196Ikuchil/nes_emulator", "file": "src/nes/cpu/mod.rs", "last_update_at": "2020-03-02T09:48:10+00:00", "question_id": "0e89c1b2d1c5e343ab62fa81c01e1dcb7ccb7918_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_run_ldx_imm() {\n    let mut b = MockBus::new();\n    let mut r = Register::new();\n    r.set_PC(0x80);\n    b.memory[0x80] = 0xA2;\n    b.memory[0x81] = 0xFF;\n    run(&mut r ,&mut b, &mut false);\n    assert_eq!(r.get_X(), 0xFF)\n"]], "pred": {"ppl": 3.308948040008545, "ppl_lower": 4.009923458099365, "ppl/lowercase_ppl": -1.1605690771708874, "ppl/zlib": 0.007296526379204736, "Min_5.0% Prob": 9.30046787261963, "Min_10.0% Prob": 7.397457339546897, "Min_20.0% Prob": 4.988694864770641, "Min_30.0% Prob": 3.7065626838627983, "Min_40.0% Prob": 2.8926586165376333, "Min_50.0% Prob": 2.3823475576283637, "Min_60.0% Prob": 1.9836730170941008}}
{"hexsha": "fa4775d1e69a995dad314f27ae74b7183b9a6144", "ext": "rs", "lang": "Rust", "content": "fn try_from_degrees_works_with_180_as_input() {\n        let degrees = 180.0;\n        let radians = Radians::try_from_degrees(degrees).unwrap();\n        let expected = PI;\n        assert_nearly_eq!(expected, radians.value())\n    }", "item_id": 3, "repo": "bash/thales", "file": "src/radians.rs", "last_update_at": "2020-01-21T14:40:02+00:00", "question_id": "fa4775d1e69a995dad314f27ae74b7183b9a6144_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn try_from_degrees_works_with_180_as_input() {\n        let degrees = 180.0;\n        let radians = Radians::try_from_degrees(degrees).unwrap();\n        let expected = PI;\n        assert_nearly_eq!(expected, radians.value())\n"]], "pred": {"ppl": 3.0846328735351562, "ppl_lower": 3.436452627182007, "ppl/lowercase_ppl": -1.0958841880703745, "ppl/zlib": 0.007559950648050525, "Min_5.0% Prob": 7.976909399032593, "Min_10.0% Prob": 6.166170835494995, "Min_20.0% Prob": 4.3957179337739944, "Min_30.0% Prob": 3.4076322889328003, "Min_40.0% Prob": 2.751620695446477, "Min_50.0% Prob": 2.2123793768031255, "Min_60.0% Prob": 1.8823372918367385}}
{"hexsha": "b9ff2cf5e460e2568ada2a3711a22814d685b671", "ext": "rs", "lang": "Rust", "content": "pub fn draw_shaded_circle() {\n    let canvas_pixels = 500;\n\n    let mut shape_list = ShapeList::new();\n\n    let mut material = Material::new();\n    material.color = Color::from_hex(\"19647E\");\n    let shape = Sphere::new_with_material(material, &mut shape_list);\n\n    let light = Light::point_light(&point(-10.0, 10.0, -10.0), &Color::new(1.0, 1.0, 1.0));\n\n    let wall_z = 10.0;\n    let wall_size = 7.0;\n\n    let pixel_size = wall_size / canvas_pixels as f64;\n    let half = wall_size / 2.0;\n\n    let ray_origin = point(0.0, 0.0, -5.0);\n    let canvas = &mut Canvas::new(canvas_pixels, canvas_pixels);\n\n    // Each row of pixels\n    for y in 0..canvas_pixels {\n        // World y coordinate top = +half and bottom = -half\n        let world_y = half - pixel_size * y as f64;\n\n        // Each col of pixels\n        for x in 0..canvas_pixels {\n            // World x coordinate left = -half and right = +half\n            let world_x = -half + pixel_size * x as f64;\n\n            // the point on the wall that the ray will target\n            let position = point(world_x, world_y, wall_z);\n\n            let ray = Ray::new(ray_origin, (position - ray_origin).normalize());\n            let xs = shape.intersects(&ray, &mut shape_list);\n            let hit = hit(xs);\n            if hit != None {\n                let point = &ray.position(hit.as_ref().unwrap().t.value());\n                let normal = shape::normal_at(hit.as_ref().unwrap().object.clone(), *point, &mut shape_list);\n                let eye = -&ray.direction;\n                let object = hit.as_ref().unwrap().object.clone();\n\n                let color = Light::lighting(&object.material(), Some(object), None, &light, point, None, &eye, &normal, false, None);\n                canvas.write_pixel(x, y, &color);\n            }\n        }\n    }\n    file::write_to_file(canvas.to_ppm(), String::from(\"shaded_circle.ppm\"))\n}", "item_id": 20, "repo": "po-gl/Raytracer", "file": "src/examples.rs", "last_update_at": "2020-01-07T06:40:05+00:00", "question_id": "b9ff2cf5e460e2568ada2a3711a22814d685b671_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn draw_shaded_circle() {\n    let canvas_pixels = 500;\n    let mut shape_list = ShapeList::new();\n    let mut material = Material::new();\n    material.color = Color::from_hex(\"19647E\");\n    let shape = Sphere::new_with_material(material, &mut shape_list);\n    let light = Light::point_light(&point(-10.0, 10.0, -10.0), &Color::new(1.0, 1.0, 1.0));\n    let wall_z = 10.0;\n    let wall_size = 7.0;\n    let pixel_size = wall_size / canvas_pixels as f64;\n    let half = wall_size / 2.0;\n    let ray_origin = point(0.0, 0.0, -5.0);\n    let canvas = &mut Canvas::new(canvas_pixels, canvas_pixels);\n    // Each row of pixels\n    for y in 0..canvas_pixels {\n        // World y coordinate top = +half and bottom = -half\n        let world_y = half - pixel_size * y as f64;\n        // Each col of pixels\n        for x in 0..canvas_pixels {\n            // World x coordinate left = -half and right = +half\n            let world_x = -half + pixel_size * x as f64;\n            // the point on the wall that the ray will target\n            let position = point(world_x, world_y, wall_z);\n            let ray = Ray::new(ray_origin, (position - ray_origin).normalize());\n            let xs = shape.intersects(&ray, &mut shape_list);\n            let hit = hit(xs);\n            if hit != None {\n                let point = &ray.position(hit.as_ref().unwrap().t.value());\n                let normal = shape::normal_at(hit.as_ref().unwrap().object.clone(), *point, &mut shape_list);\n                let eye = -&ray.direction;\n                let object = hit.as_ref().unwrap().object.clone();\n                let color = Light::lighting(&object.material(), Some(object), None, &light, point, None, &eye, &normal, false, None);\n                canvas.write_pixel(x, y, &color);\n            }\n        }\n    }\n    file::write_to_file(canvas.to_ppm(), String::from(\"shaded_circle.ppm\"))\n"]], "pred": {"ppl": 2.0685160160064697, "ppl_lower": 2.143653392791748, "ppl/lowercase_ppl": -1.049089946015845, "ppl/zlib": 0.0010052993771801938, "Min_5.0% Prob": 6.26353733770309, "Min_10.0% Prob": 4.701014310594589, "Min_20.0% Prob": 3.101021782273338, "Min_30.0% Prob": 2.28667249834096, "Min_40.0% Prob": 1.7777591287618568, "Min_50.0% Prob": 1.4443667871005172, "Min_60.0% Prob": 1.2108388750821273}}
{"hexsha": "3ea494108ae1e12fec175111c3d63bc66fabc03c", "ext": "rs", "lang": "Rust", "content": "pub fn line_start_utf8_byte_offsets_raw(text: &str) -> Vec<usize> {\n    let mut offsets = vec![0];\n    offsets.append(\n        &mut text\n            .bytes()\n            .enumerate()\n            .filter(|(_, it)| it == &b'\\n')\n            .map(|(index, _)| index + 1)\n            .collect(),\n    );\n    offsets\n}", "item_id": 3, "repo": "JonasWanke/candy", "file": "new-new-packages/compiler/src/language_server/utils.rs", "last_update_at": "2020-11-08T02:55:57+00:00", "question_id": "3ea494108ae1e12fec175111c3d63bc66fabc03c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn line_start_utf8_byte_offsets_raw(text: &str) -> Vec<usize> {\n    let mut offsets = vec![0];\n    offsets.append(\n        &mut text\n            .bytes()\n            .enumerate()\n            .filter(|(_, it)| it == &b'\\n')\n            .map(|(index, _)| index + 1)\n            .collect(),\n    );\n    offsets\n"]], "pred": {"ppl": 2.584634304046631, "ppl_lower": 3.0913355350494385, "ppl/lowercase_ppl": -1.1885237898521401, "ppl/zlib": 0.004894763038653981, "Min_5.0% Prob": 8.552041625976562, "Min_10.0% Prob": 6.5695161581039425, "Min_20.0% Prob": 4.224468146051679, "Min_30.0% Prob": 3.0658461432303152, "Min_40.0% Prob": 2.3417009423886026, "Min_50.0% Prob": 1.8867051563454125, "Min_60.0% Prob": 1.5945040007964486}}
{"hexsha": "003458e0f21354b51a889b03e9b3f5a6615a3142", "ext": "rs", "lang": "Rust", "content": "pub fn bench(c: &mut Criterion) {\n    setup();\n    let mut group = c.benchmark_group(\"sched_exec_tests\");\n    // try to limit the length of test runs\n    // group.significance_level(0.1).sample_size(10).measurement_time(Duration::from_secs(30));\n    // group.significance_level(0.1).sample_size(10);\n    group.significance_level(0.1);\n\n    log::info!(\"create_destroy_2000_machines: setup complete\");\n    group.bench_function(\"create_destroy_2000_machines\", |b| b.iter(create_destroy_2000_machines));\n    log::info!(\"create_destroy_2000_machines: tear-down complete\");\n\n    let mut send_cmd = DaisyChainDriver::default();\n    send_cmd.machine_count = 1;\n    send_cmd.message_count = 200;\n    send_cmd.duration = Duration::from_secs(30);\n    send_cmd.setup();\n    group.bench_function(\"send 200 cmds\", |b| b.iter(|| send_cmd.run()));\n    DaisyChainDriver::teardown(send_cmd);\n\n    let mut fanout_fanin = FanoutFaninDriver::default();\n    fanout_fanin.setup();\n    group.bench_function(\"fanout_fanin_bound\", |b| b.iter(|| fanout_fanin.run()));\n    FanoutFaninDriver::teardown(fanout_fanin);\n\n    let mut fanout_fanin = FanoutFaninDriver::default();\n    fanout_fanin.bound_queue = false;\n    fanout_fanin.setup();\n    group.bench_function(\"fanout_fanin_unbound\", |b| b.iter(|| fanout_fanin.run()));\n    FanoutFaninDriver::teardown(fanout_fanin);\n\n    let mut daisy_chain = DaisyChainDriver::default();\n    daisy_chain.duration = Duration::from_secs(30);\n    daisy_chain.setup();\n    group.bench_function(\"daisy_chain_bound 200 cmds 4000 machines\", |b| b.iter(|| daisy_chain.run()));\n    DaisyChainDriver::teardown(daisy_chain);\n\n    let mut daisy_chain = DaisyChainDriver::default();\n    daisy_chain.bound_queue = false;\n    daisy_chain.duration = Duration::from_secs(30);\n    daisy_chain.setup();\n    group.bench_function(\"daisy_chain_unbound 200 cmds 4000 machines\", |b| b.iter(|| daisy_chain.run()));\n    DaisyChainDriver::teardown(daisy_chain);\n\n    let mut chaos_monkey = ChaosMonkeyDriver::default();\n    chaos_monkey.setup();\n    group.bench_function(\"chaos_monkey_bound\", |b| b.iter(|| chaos_monkey.run()));\n    ChaosMonkeyDriver::teardown(chaos_monkey);\n\n    let mut chaos_monkey = ChaosMonkeyDriver::default();\n    chaos_monkey.bound_queue = false;\n    chaos_monkey.setup();\n    group.bench_function(\"chaos_monkey_unbound\", |b| b.iter(|| chaos_monkey.run()));\n    ChaosMonkeyDriver::teardown(chaos_monkey);\n    group.finish();\n    teardown();\n}", "item_id": 0, "repo": "BruceBrown/d3", "file": "benches/forwarder.rs", "last_update_at": "2020-12-31T09:17:33+00:00", "question_id": "003458e0f21354b51a889b03e9b3f5a6615a3142_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn bench(c: &mut Criterion) {\n    setup();\n    let mut group = c.benchmark_group(\"sched_exec_tests\");\n    // try to limit the length of test runs\n    // group.significance_level(0.1).sample_size(10).measurement_time(Duration::from_secs(30));\n    // group.significance_level(0.1).sample_size(10);\n    group.significance_level(0.1);\n    log::info!(\"create_destroy_2000_machines: setup complete\");\n    group.bench_function(\"create_destroy_2000_machines\", |b| b.iter(create_destroy_2000_machines));\n    log::info!(\"create_destroy_2000_machines: tear-down complete\");\n    let mut send_cmd = DaisyChainDriver::default();\n    send_cmd.machine_count = 1;\n    send_cmd.message_count = 200;\n    send_cmd.duration = Duration::from_secs(30);\n    send_cmd.setup();\n    group.bench_function(\"send 200 cmds\", |b| b.iter(|| send_cmd.run()));\n    DaisyChainDriver::teardown(send_cmd);\n    let mut fanout_fanin = FanoutFaninDriver::default();\n    fanout_fanin.setup();\n    group.bench_function(\"fanout_fanin_bound\", |b| b.iter(|| fanout_fanin.run()));\n    FanoutFaninDriver::teardown(fanout_fanin);\n    let mut fanout_fanin = FanoutFaninDriver::default();\n    fanout_fanin.bound_queue = false;\n    fanout_fanin.setup();\n    group.bench_function(\"fanout_fanin_unbound\", |b| b.iter(|| fanout_fanin.run()));\n    FanoutFaninDriver::teardown(fanout_fanin);\n    let mut daisy_chain = DaisyChainDriver::default();\n    daisy_chain.duration = Duration::from_secs(30);\n    daisy_chain.setup();\n    group.bench_function(\"daisy_chain_bound 200 cmds 4000 machines\", |b| b.iter(|| daisy_chain.run()));\n    DaisyChainDriver::teardown(daisy_chain);\n    let mut daisy_chain = DaisyChainDriver::default();\n    daisy_chain.bound_queue = false;\n    daisy_chain.duration = Duration::from_secs(30);\n    daisy_chain.setup();\n    group.bench_function(\"daisy_chain_unbound 200 cmds 4000 machines\", |b| b.iter(|| daisy_chain.run()));\n    DaisyChainDriver::teardown(daisy_chain);\n    let mut chaos_monkey = ChaosMonkeyDriver::default();\n    chaos_monkey.setup();\n    group.bench_function(\"chaos_monkey_bound\", |b| b.iter(|| chaos_monkey.run()));\n    ChaosMonkeyDriver::teardown(chaos_monkey);\n    let mut chaos_monkey = ChaosMonkeyDriver::default();\n    chaos_monkey.bound_queue = false;\n    chaos_monkey.setup();\n    group.bench_function(\"chaos_monkey_unbound\", |b| b.iter(|| chaos_monkey.run()));\n    ChaosMonkeyDriver::teardown(chaos_monkey);\n    group.finish();\n    teardown();\n"]], "pred": {"ppl": 1.6006786823272705, "ppl_lower": 1.6998306512832642, "ppl/lowercase_ppl": -1.1277580198427242, "ppl/zlib": 0.0008491475013770385, "Min_5.0% Prob": 6.149209447529005, "Min_10.0% Prob": 4.009437063688873, "Min_20.0% Prob": 2.290252447769206, "Min_30.0% Prob": 1.5627106931661405, "Min_40.0% Prob": 1.1768050344375474, "Min_50.0% Prob": 0.9404370024612437, "Min_60.0% Prob": 0.7842368569690734}}
{"hexsha": "4ed46b47ff05c500927cb8a6912a113988143ea4", "ext": "rs", "lang": "Rust", "content": "fn into_vec_ok() -> Result<()> {\n        let x: Vec<Result<()>> = vec![Ok(()), Ok(())];\n\n        let y: Result<Vec<()>> = x.into_iter().bcollect();\n\n        assert!(y.is_ok());\n\n        Ok(())\n    }", "item_id": 4, "repo": "tarquin-the-brave/beau-collector", "file": "src/lib.rs", "last_update_at": "2020-05-18T08:07:29+00:00", "question_id": "4ed46b47ff05c500927cb8a6912a113988143ea4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn into_vec_ok() -> Result<()> {\n        let x: Vec<Result<()>> = vec![Ok(()), Ok(())];\n        let y: Result<Vec<()>> = x.into_iter().bcollect();\n        assert!(y.is_ok());\n        Ok(())\n"]], "pred": {"ppl": 3.0178894996643066, "ppl_lower": 3.6581227779388428, "ppl/lowercase_ppl": -1.174180452249482, "ppl/zlib": 0.008431738518417572, "Min_5.0% Prob": 9.990386009216309, "Min_10.0% Prob": 6.876769781112671, "Min_20.0% Prob": 4.4771717151006065, "Min_30.0% Prob": 3.4362945556640625, "Min_40.0% Prob": 2.722786822915077, "Min_50.0% Prob": 2.1932903065493234, "Min_60.0% Prob": 1.8605293916331398}}
{"hexsha": "9f9b27c2e456cf11cbf1d4c220fbb713b5da6596", "ext": "rs", "lang": "Rust", "content": "fn main () {\n\n    let start = ::std::time::Instant::now();\n\n    let send = Arc::new(Mutex::new(0));\n    let send2 = send.clone();\n\n    let inspect = ::std::env::args().find(|x| x == \"inspect\").is_some();\n\n    timely::execute_from_args(std::env::args(), move |root| {\n\n        let send = send.clone();\n\n        // used to partition graph loading\n        let index = root.index();\n        let peers = root.peers();\n\n        let plan_filename = std::env::args().nth(3).unwrap();\n        let plan = count_vertex_labeled_query_plan::read_plan(&plan_filename);\n\n        // handles to input and probe, but also both indices so we can compact them.\n        let (mut input, forward_probe, reverse_probe, probe, handles) = root.dataflow::<u32,_,_>(|builder| {\n\n            // Please see triangles for more information on \"graph\" and dG.\n            let (graph, dG) = builder.new_input::<((u32, u32), i32)>();\n            //let dG_init = dG.map(|((src,dst),wgt)| (vec![src,dst],wgt));\n            // Our query is K3 = A(x,y) B(x,z) C(y,z): triangles..\n\n            let (graph_index, handles) = GraphStreamIndex::from(Vec::new().to_stream(builder), dG, |k| k as u64, |k| k as u64);\n\n            let mut probe = ProbeHandle::new();\n\n            plan.track_motif(&graph_index, &mut probe, send);\n\n            (graph, graph_index.forward.handle , graph_index.reverse.handle, probe, handles)\n        });\n\n        // load fragment of input graph into memory to avoid io while running.\n        let filename = std::env::args().nth(1).unwrap();\n        let graph = GraphMMap::new(&filename);\n\n        let nodes = graph.nodes();\n        let mut edges = Vec::new();\n\n        for node in 0 .. graph.nodes() {\n            if node % peers == index {\n                edges.push(graph.edges(node).to_vec());\n            }\n        }\n\n        drop(graph);\n\n        // synchronize with other workers.\n        let prev = input.time().clone();\n        input.advance_to(prev.inner + 1);\n        root.step_while(|| probe.less_than(input.time()));\n\n        // number of nodes introduced at a time\n        let batch: usize = std::env::args().nth(2).unwrap().parse().unwrap();\n\n        // start the experiment!\n        let start = ::std::time::Instant::now();\n        let mut batch_start = ::std::time::Instant::now();\n        let mut batch_mid: std::time::Instant;\n        let mut batch_end: std::time::Instant;\n        for node in 0 .. nodes {\n\n            // introduce the node if it is this worker's responsibility\n            if node % peers == index {\n                for &edge in &edges[node / peers] {\n                    if node as u32 != edge{\n                        input.send(((node as u32, edge), 1));\n                    }\n                }\n            }\n\n            // if at a batch boundary, advance time and do work.\n            if node % batch == (batch - 1) {\n                let prev = input.time().clone();\n                input.advance_to(prev.inner + 1);\n\n                root.step_while(|| forward_probe.less_than(inputQ.time()) ||reverse_probe.less_than(inputQ.time()));\n                batch_mid = ::std::time::Instant::now();\n\n                root.step_while(|| probe.less_than(input.time()));\n                batch_end = ::std::time::Instant::now();\n\n                println!(\"After io: {:?}\", batch_mid.duration_since(batch_start));\n                println!(\"After batch: {:?}\", batch_end.duration_since(batch_start));\n\n                batch_start = ::std::time::Instant::now();\n                // merge all of the indices we maintain.\n                handles.merge_to(&prev);\n\n\n            }\n        }\n\n        input.close();\n        while root.step() { }\n\n        if inspect {\n            println!(\"worker {} elapsed: {:?}\", index, start.elapsed());\n        }\n\n    }).unwrap();\n\n    let total = if let Ok(lock) = send2.lock() {\n        *lock\n    }\n    else { 0 };\n\n    if inspect {\n        println!(\"elapsed: {:?}\\ttotal triangles at this process: {:?}\", start.elapsed(), total);\n    }\n}", "item_id": 0, "repo": "SheilaCecilia/dataflow-join", "file": "examples/wings_plan.rs", "last_update_at": "2020-03-01T18:11:58+00:00", "question_id": "9f9b27c2e456cf11cbf1d4c220fbb713b5da6596_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main () {\n    let start = ::std::time::Instant::now();\n    let send = Arc::new(Mutex::new(0));\n    let send2 = send.clone();\n    let inspect = ::std::env::args().find(|x| x == \"inspect\").is_some();\n    timely::execute_from_args(std::env::args(), move |root| {\n        let send = send.clone();\n        // used to partition graph loading\n        let index = root.index();\n        let peers = root.peers();\n        let plan_filename = std::env::args().nth(3).unwrap();\n        let plan = count_vertex_labeled_query_plan::read_plan(&plan_filename);\n        // handles to input and probe, but also both indices so we can compact them.\n        let (mut input, forward_probe, reverse_probe, probe, handles) = root.dataflow::<u32,_,_>(|builder| {\n            // Please see triangles for more information on \"graph\" and dG.\n            let (graph, dG) = builder.new_input::<((u32, u32), i32)>();\n            //let dG_init = dG.map(|((src,dst),wgt)| (vec![src,dst],wgt));\n            // Our query is K3 = A(x,y) B(x,z) C(y,z): triangles..\n            let (graph_index, handles) = GraphStreamIndex::from(Vec::new().to_stream(builder), dG, |k| k as u64, |k| k as u64);\n            let mut probe = ProbeHandle::new();\n            plan.track_motif(&graph_index, &mut probe, send);\n            (graph, graph_index.forward.handle , graph_index.reverse.handle, probe, handles)\n        });\n        // load fragment of input graph into memory to avoid io while running.\n        let filename = std::env::args().nth(1).unwrap();\n        let graph = GraphMMap::new(&filename);\n        let nodes = graph.nodes();\n        let mut edges = Vec::new();\n        for node in 0 .. graph.nodes() {\n            if node % peers == index {\n                edges.push(graph.edges(node).to_vec());\n            }\n        }\n        drop(graph);\n        // synchronize with other workers.\n        let prev = input.time().clone();\n        input.advance_to(prev.inner + 1);\n        root.step_while(|| probe.less_than(input.time()));\n        // number of nodes introduced at a time\n        let batch: usize = std::env::args().nth(2).unwrap().parse().unwrap();\n        // start the experiment!\n        let start = ::std::time::Instant::now();\n        let mut batch_start = ::std::time::Instant::now();\n        let mut batch_mid: std::time::Instant;\n        let mut batch_end: std::time::Instant;\n        for node in 0 .. nodes {\n            // introduce the node if it is this worker's responsibility\n            if node % peers == index {\n                for &edge in &edges[node / peers] {\n                    if node as u32 != edge{\n                        input.send(((node as u32, edge), 1));\n                    }\n                }\n            }\n            // if at a batch boundary, advance time and do work.\n            if node % batch == (batch - 1) {\n                let prev = input.time().clone();\n                input.advance_to(prev.inner + 1);\n                root.step_while(|| forward_probe.less_than(inputQ.time()) ||reverse_probe.less_than(inputQ.time()));\n                batch_mid = ::std::time::Instant::now();\n                root.step_while(|| probe.less_than(input.time()));\n                batch_end = ::std::time::Instant::now();\n                println!(\"After io: {:?}\", batch_mid.duration_since(batch_start));\n                println!(\"After batch: {:?}\", batch_end.duration_since(batch_start));\n                batch_start = ::std::time::Instant::now();\n                // merge all of the indices we maintain.\n                handles.merge_to(&prev);\n            }\n        }\n        input.close();\n        while root.step() { }\n        if inspect {\n            println!(\"worker {} elapsed: {:?}\", index, start.elapsed());\n        }\n    }).unwrap();\n    let total = if let Ok(lock) = send2.lock() {\n        *lock\n    }\n    else { 0 };\n    if inspect {\n        println!(\"elapsed: {:?}\\ttotal triangles at this process: {:?}\", start.elapsed(), total);\n    }\n"]], "pred": {"ppl": 2.7740566730499268, "ppl_lower": 3.019491672515869, "ppl/lowercase_ppl": -1.0830901222462783, "ppl/zlib": 0.0007420441831031526, "Min_5.0% Prob": 8.536813539617201, "Min_10.0% Prob": 6.371806913731145, "Min_20.0% Prob": 4.264843774192474, "Min_30.0% Prob": 3.173310200568118, "Min_40.0% Prob": 2.485895354255196, "Min_50.0% Prob": 2.0249799838008946, "Min_60.0% Prob": 1.698346318795572}}
{"hexsha": "fce0772a0a7905475a77d33819d2513a777217be", "ext": "rs", "lang": "Rust", "content": "fn with_deps() {\n    if !cargo_test_support::is_nightly() {\n        return;\n    }\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"test\"\n                version = \"0.0.0\"\n\n                [dependencies]\n                bar = \"*\"\n\n                [profile.release]\n                lto = true\n            \"#,\n        )\n        .file(\"src/main.rs\", \"extern crate bar; fn main() {}\")\n        .build();\n    p.cargo(\"build -v --release\")\n        .with_stderr_contains(\"[..]`rustc[..]--crate-name bar[..]-Clinker-plugin-lto[..]`\")\n        .with_stderr_contains(\"[..]`rustc[..]--crate-name test[..]-C lto[..]`\")\n        .run();\n}", "item_id": 0, "repo": "windy1/cargo", "file": "tests/testsuite/lto.rs", "last_update_at": "2020-11-03T13:05:28+00:00", "question_id": "fce0772a0a7905475a77d33819d2513a777217be_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn with_deps() {\n    if !cargo_test_support::is_nightly() {\n        return;\n    }\n    Package::new(\"bar\", \"0.0.1\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"test\"\n                version = \"0.0.0\"\n                [dependencies]\n                bar = \"*\"\n                [profile.release]\n                lto = true\n            \"#,\n        )\n        .file(\"src/main.rs\", \"extern crate bar; fn main() {}\")\n        .build();\n    p.cargo(\"build -v --release\")\n        .with_stderr_contains(\"[..]`rustc[..]--crate-name bar[..]-Clinker-plugin-lto[..]`\")\n        .with_stderr_contains(\"[..]`rustc[..]--crate-name test[..]-C lto[..]`\")\n        .run();\n"]], "pred": {"ppl": 1.6568046808242798, "ppl_lower": 2.0679914951324463, "ppl/lowercase_ppl": -1.4390790305361547, "ppl/zlib": 0.0014762890535529704, "Min_5.0% Prob": 5.897160609563191, "Min_10.0% Prob": 3.9548524522781374, "Min_20.0% Prob": 2.347164927744398, "Min_30.0% Prob": 1.651838144189433, "Min_40.0% Prob": 1.2541610989354404, "Min_50.0% Prob": 1.0115248739030065, "Min_60.0% Prob": 0.8408859477993222}}
{"hexsha": "f21cd6bd27999d5a412fbd51eaee0dbae21db4e9", "ext": "rs", "lang": "Rust", "content": "fn sla_hl_carry() {\n    let mut gb = GB::new();\n    let addr = 0xC000;\n    gb.set_hl(addr);\n    gb.mem_write(addr, 0b11001100);\n    gb.set_cy(0);\n    gb.shift_mem(&GB::sla);\n    assert_eq!(gb.mem_read(addr), 0b10011000);\n    assert_eq!(gb.get_cy(), 1);\n}", "item_id": 18, "repo": "JVehaun/gb-emu", "file": "src/gb.rs", "last_update_at": "2020-12-08T16:39:34+00:00", "question_id": "f21cd6bd27999d5a412fbd51eaee0dbae21db4e9_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sla_hl_carry() {\n    let mut gb = GB::new();\n    let addr = 0xC000;\n    gb.set_hl(addr);\n    gb.mem_write(addr, 0b11001100);\n    gb.set_cy(0);\n    gb.shift_mem(&GB::sla);\n    assert_eq!(gb.mem_read(addr), 0b10011000);\n    assert_eq!(gb.get_cy(), 1);\n"]], "pred": {"ppl": 3.2584192752838135, "ppl_lower": 3.58573055267334, "ppl/lowercase_ppl": -1.0810333743137541, "ppl/zlib": 0.007476216410770007, "Min_5.0% Prob": 9.71776294708252, "Min_10.0% Prob": 7.633975395789514, "Min_20.0% Prob": 5.0819771996250855, "Min_30.0% Prob": 3.749316783249378, "Min_40.0% Prob": 2.887748271226883, "Min_50.0% Prob": 2.3613315518222637, "Min_60.0% Prob": 1.962490727826033}}
{"hexsha": "f5e8d4f4ac2f1235aafda3a6b82f7876630db0f5", "ext": "rs", "lang": "Rust", "content": "async fn main() -> Result<(), Box<dyn Error>> {\n    let consumer_key = std::env::var(\"POCKET_CONSUMER_KEY\")?;\n    println!(\"consumer key: {}\", consumer_key);\n    let auth = PocketAuthentication::new(&consumer_key, \"rustapi:finishauth\");\n    let state = Some(format!(\"{:?}\", Instant::now()));\n    let code = auth.request(state.as_deref()).await?;\n    let url = auth.authorize_url(&code);\n    println!(\n        \"Follow auth URL to provide access and press enter when finished: {}\",\n        url\n    );\n    let _ = io::stdin().read_line(&mut String::new());\n    let user = auth.authorize(&code, state.as_deref()).await?;\n    println!(\"username: {}\", user.username);\n    println!(\"access token: {:?}\", user.access_token);\n    Ok(())\n}", "item_id": 0, "repo": "mgabs/rust-pocket", "file": "examples/auth.rs", "last_update_at": "2020-08-15T05:32:16+00:00", "question_id": "f5e8d4f4ac2f1235aafda3a6b82f7876630db0f5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() -> Result<(), Box<dyn Error>> {\n    let consumer_key = std::env::var(\"POCKET_CONSUMER_KEY\")?;\n    println!(\"consumer key: {}\", consumer_key);\n    let auth = PocketAuthentication::new(&consumer_key, \"rustapi:finishauth\");\n    let state = Some(format!(\"{:?}\", Instant::now()));\n    let code = auth.request(state.as_deref()).await?;\n    let url = auth.authorize_url(&code);\n    println!(\n        \"Follow auth URL to provide access and press enter when finished: {}\",\n        url\n    );\n    let _ = io::stdin().read_line(&mut String::new());\n    let user = auth.authorize(&code, state.as_deref()).await?;\n    println!(\"username: {}\", user.username);\n    println!(\"access token: {:?}\", user.access_token);\n    Ok(())\n"]], "pred": {"ppl": 2.7373995780944824, "ppl_lower": 3.7082200050354004, "ppl/lowercase_ppl": -1.3014310154640325, "ppl/zlib": 0.0025365451150343825, "Min_5.0% Prob": 7.70272345976396, "Min_10.0% Prob": 5.964563349018926, "Min_20.0% Prob": 4.212309671484905, "Min_30.0% Prob": 3.1233517868178233, "Min_40.0% Prob": 2.4683644024915594, "Min_50.0% Prob": 1.9941748539224649, "Min_60.0% Prob": 1.6769093445103083}}
{"hexsha": "c5c3519079250bd716bd41cbebaafd7699a932a9", "ext": "rs", "lang": "Rust", "content": "fn format_event<S, N>(\n    ctx: &FmtContext<'_, S, N>,\n    writer: &mut dyn std::fmt::Write,\n    event: &Event<'_>,\n) -> std::fmt::Result\nwhere\n    S: Subscriber + for<'a> LookupSpan<'a>,\n    N: for<'writer> FormatFields<'writer> + 'static,\n{\n    let now = chrono::offset::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);\n    let mut parents = vec![];\n    ctx.visit_spans::<(), _>(|span| {\n        let meta = span.metadata();\n        let name = meta.name();\n        let file = meta.file();\n        let line = meta.line();\n        let module_path = meta.module_path();\n        let level = meta.level();\n        let target = meta.target();\n        let id = span.id();\n        let json = json!({\"id\": id.as_serde(), \"name\": name, \"level\": level.as_serde(), \"target\": target, \"module_path\": module_path, \"file\": file, \"line\": line});\n        parents.push(json);\n        Ok(())\n    })\n    .ok();\n    let meta = event.metadata();\n    let name = meta.name();\n    let file = meta.file();\n    let line = meta.line();\n    let module_path = meta.module_path();\n    let level = meta.level();\n    let target = meta.target();\n    let mut values = EventFieldVisitor::new();\n    event.record(&mut values);\n    let json = json!({\"time\": now, \"name\": name, \"level\": level.as_serde(), \"target\": target, \"module_path\": module_path, \"file\": file, \"line\": line, \"fields\": values.json, \"spans\": parents});\n    writeln!(writer, \"{}\", json)\n}", "item_id": 0, "repo": "holochain/holochain-tracing", "file": "crates/tracing/src/structured.rs", "last_update_at": "2020-07-12T09:20:21+00:00", "question_id": "c5c3519079250bd716bd41cbebaafd7699a932a9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn format_event<S, N>(\n    ctx: &FmtContext<'_, S, N>,\n    writer: &mut dyn std::fmt::Write,\n    event: &Event<'_>,\n) -> std::fmt::Result\nwhere\n    S: Subscriber + for<'a> LookupSpan<'a>,\n    N: for<'writer> FormatFields<'writer> + 'static,\n{\n    let now = chrono::offset::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);\n    let mut parents = vec![];\n    ctx.visit_spans::<(), _>(|span| {\n        let meta = span.metadata();\n        let name = meta.name();\n        let file = meta.file();\n        let line = meta.line();\n        let module_path = meta.module_path();\n        let level = meta.level();\n        let target = meta.target();\n        let id = span.id();\n        let json = json!({\"id\": id.as_serde(), \"name\": name, \"level\": level.as_serde(), \"target\": target, \"module_path\": module_path, \"file\": file, \"line\": line});\n        parents.push(json);\n        Ok(())\n    })\n    .ok();\n    let meta = event.metadata();\n    let name = meta.name();\n    let file = meta.file();\n    let line = meta.line();\n    let module_path = meta.module_path();\n    let level = meta.level();\n    let target = meta.target();\n    let mut values = EventFieldVisitor::new();\n    event.record(&mut values);\n    let json = json!({\"time\": now, \"name\": name, \"level\": level.as_serde(), \"target\": target, \"module_path\": module_path, \"file\": file, \"line\": line, \"fields\": values.json, \"spans\": parents});\n    writeln!(writer, \"{}\", json)\n"]], "pred": {"ppl": 1.6925891637802124, "ppl_lower": 2.2679731845855713, "ppl/lowercase_ppl": -1.5560511658320584, "ppl/zlib": 0.0009465097232345524, "Min_5.0% Prob": 5.530632008676943, "Min_10.0% Prob": 4.0926162486380715, "Min_20.0% Prob": 2.4697732279175204, "Min_30.0% Prob": 1.7272786831522322, "Min_40.0% Prob": 1.311383377214533, "Min_50.0% Prob": 1.0524214337303237, "Min_60.0% Prob": 0.8777111989757507}}
{"hexsha": "9b32525383c276e69e721bcae92f142fa88731fc", "ext": "rs", "lang": "Rust", "content": "fn test_get_least_entry() {\n    let mut cache = LruCache::<usize, &str>::new(3, 60);\n\n    cache.put(1, \"one\");\n    cache.put(2, \"two\");\n    cache.put(3, \"three\");\n\n    let cache_head = cache.get(&1);\n    assert_eq!(cache_head, Some(&\"one\"));\n    let mut iter = cache.storage.iter();\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 0 }\n            && item.prev().is_null()\n            && item.next() == Pointer::InternalPointer { slab: 0, pos: 2 }\n    } else {\n        false\n    });\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 2 }\n            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 0 }\n            && item.next() == Pointer::InternalPointer { slab: 0, pos: 1 }\n    } else {\n        false\n    });\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 1 }\n            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 2 }\n            && item.next().is_null()\n    } else {\n        false\n    });\n    assert!(iter.next().is_none());\n}", "item_id": 6, "repo": "abastian/aba-cache", "file": "src/lru/tests.rs", "last_update_at": "2020-07-29T07:06:37+00:00", "question_id": "9b32525383c276e69e721bcae92f142fa88731fc_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_least_entry() {\n    let mut cache = LruCache::<usize, &str>::new(3, 60);\n    cache.put(1, \"one\");\n    cache.put(2, \"two\");\n    cache.put(3, \"three\");\n    let cache_head = cache.get(&1);\n    assert_eq!(cache_head, Some(&\"one\"));\n    let mut iter = cache.storage.iter();\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 0 }\n            && item.prev().is_null()\n            && item.next() == Pointer::InternalPointer { slab: 0, pos: 2 }\n    } else {\n        false\n    });\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 2 }\n            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 0 }\n            && item.next() == Pointer::InternalPointer { slab: 0, pos: 1 }\n    } else {\n        false\n    });\n    assert!(if let Some(item) = iter.next() {\n        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 1 }\n            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 2 }\n            && item.next().is_null()\n    } else {\n        false\n    });\n    assert!(iter.next().is_none());\n"]], "pred": {"ppl": 1.68567955493927, "ppl_lower": 1.9303146600723267, "ppl/lowercase_ppl": -1.259521924960561, "ppl/zlib": 0.001626694016205399, "Min_5.0% Prob": 6.4787397384643555, "Min_10.0% Prob": 4.410363525152206, "Min_20.0% Prob": 2.5221499022096396, "Min_30.0% Prob": 1.7267990774164597, "Min_40.0% Prob": 1.3032823437824845, "Min_50.0% Prob": 1.043858627662994, "Min_60.0% Prob": 0.8701478329171853}}
{"hexsha": "b581d1eb07e3b93f9e0d7ce65b17b2bd1f7554ac", "ext": "rs", "lang": "Rust", "content": "fn generate_cookie() -> [u8; 16] {\n    let mut rand = OsRng::new().unwrap();\n    let mut cookie: [u8; 16] = [0; 16];\n    rand.try_fill(&mut cookie).unwrap();\n    cookie\n}", "item_id": 0, "repo": "lholznagel/rust-ssh", "file": "src/kex.rs", "last_update_at": "2020-01-17T21:04:03+00:00", "question_id": "b581d1eb07e3b93f9e0d7ce65b17b2bd1f7554ac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_cookie() -> [u8; 16] {\n    let mut rand = OsRng::new().unwrap();\n    let mut cookie: [u8; 16] = [0; 16];\n    rand.try_fill(&mut cookie).unwrap();\n    cookie\n"]], "pred": {"ppl": 2.171779155731201, "ppl_lower": 2.655740737915039, "ppl/lowercase_ppl": -1.2594000968686527, "ppl/zlib": 0.006517199319848742, "Min_5.0% Prob": 8.018020629882812, "Min_10.0% Prob": 6.3534096876780195, "Min_20.0% Prob": 3.7687240563906155, "Min_30.0% Prob": 2.583775043487549, "Min_40.0% Prob": 1.94985872865827, "Min_50.0% Prob": 1.5665115652715458, "Min_60.0% Prob": 1.3037031579808127}}
{"hexsha": "4c664f96cd5e66433faf89b8d7b582913d0ee8d4", "ext": "rs", "lang": "Rust", "content": "fn test_include2() {\n        let mut p = Lexer::<Context<TestIncludeLocator>>::new(\n            concat!(\n                \"#include <path2>\\n\",\n                \"#define test1 foo\\n\",\n                \"#define test2 bar(456)\\n\",\n            )\n            .as_bytes(),\n        );\n        p.consume_all();\n        assert_eq!(eval!(\"test1\", p), \"123 \");\n        assert_eq!(eval!(\"test2\", p), \"123 456 \");\n    }", "item_id": 1, "repo": "mozilla/rust-cpp-parser", "file": "src/lexer/preprocessor/include.rs", "last_update_at": "2020-04-13T14:53:22+00:00", "question_id": "4c664f96cd5e66433faf89b8d7b582913d0ee8d4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_include2() {\n        let mut p = Lexer::<Context<TestIncludeLocator>>::new(\n            concat!(\n                \"#include <path2>\\n\",\n                \"#define test1 foo\\n\",\n                \"#define test2 bar(456)\\n\",\n            )\n            .as_bytes(),\n        );\n        p.consume_all();\n        assert_eq!(eval!(\"test1\", p), \"123 \");\n        assert_eq!(eval!(\"test2\", p), \"123 456 \");\n"]], "pred": {"ppl": 4.388646125793457, "ppl_lower": 5.443134784698486, "ppl/lowercase_ppl": -1.1455925197804402, "ppl/zlib": 0.007250101862405288, "Min_5.0% Prob": 8.517402331034342, "Min_10.0% Prob": 7.194366345038781, "Min_20.0% Prob": 5.604578650914705, "Min_30.0% Prob": 4.396265219419431, "Min_40.0% Prob": 3.5383918377069326, "Min_50.0% Prob": 2.9186484634876253, "Min_60.0% Prob": 2.4643707694724584}}
{"hexsha": "9ae7426d18ea491c251c84423079064641640467", "ext": "rs", "lang": "Rust", "content": "fn test_make_slice() {\n    const BUF: &[u8] = &[0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0xca, 0xfe];\n    let s0 = make_slice!(BUF, 1, 2);\n    let s1 = make_slice!(BUF, 3, 2);\n    let s2 = make_slice!(BUF, 5, 2);\n    assert_eq!(s0, &[0xad, 0xbe]);\n    assert_eq!(s1, &[0xef, 0xba]);\n    assert_eq!(s2, &[0xbe, 0xca]);\n}", "item_id": 0, "repo": "jeandudey/rust-rfc5444", "file": "src/buf.rs", "last_update_at": "2020-05-03T18:33:26+00:00", "question_id": "9ae7426d18ea491c251c84423079064641640467_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_make_slice() {\n    const BUF: &[u8] = &[0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0xca, 0xfe];\n    let s0 = make_slice!(BUF, 1, 2);\n    let s1 = make_slice!(BUF, 3, 2);\n    let s2 = make_slice!(BUF, 5, 2);\n    assert_eq!(s0, &[0xad, 0xbe]);\n    assert_eq!(s1, &[0xef, 0xba]);\n    assert_eq!(s2, &[0xbe, 0xca]);\n"]], "pred": {"ppl": 1.6096656322479248, "ppl_lower": 1.6588248014450073, "ppl/lowercase_ppl": -1.0631959075062967, "ppl/zlib": 0.003051451766627732, "Min_5.0% Prob": 5.1664670838250055, "Min_10.0% Prob": 3.584032356739044, "Min_20.0% Prob": 2.18157287604279, "Min_30.0% Prob": 1.5506224361834702, "Min_40.0% Prob": 1.1865041288029816, "Min_50.0% Prob": 0.9546348269200987, "Min_60.0% Prob": 0.7969948209485866}}
{"hexsha": "c39b3b198cf7b572f6922a56376abacb5ac5391c", "ext": "rs", "lang": "Rust", "content": "fn prepare_headers(custom_node_attr_keys: &[String]) -> Vec<String> {\n  let mut headers: Vec<String> = NEXTCLADE_CSV_HEADERS\n    .iter()\n    .copied()\n    .map(ToOwned::to_owned)\n    .collect_vec();\n\n  let index_of_clade_col = headers\n    .iter()\n    .position(|header| header == \"clade\")\n    .unwrap_or(headers.len());\n\n  custom_node_attr_keys.iter().rev().for_each(|key| {\n    headers.insert(index_of_clade_col + 1, key.clone());\n  });\n\n  headers\n}", "item_id": 0, "repo": "neherlab/webclades", "file": "packages_rs/nextclade/src/io/nextclade_csv.rs", "last_update_at": "2020-09-03T20:15:48+00:00", "question_id": "c39b3b198cf7b572f6922a56376abacb5ac5391c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prepare_headers(custom_node_attr_keys: &[String]) -> Vec<String> {\n  let mut headers: Vec<String> = NEXTCLADE_CSV_HEADERS\n    .iter()\n    .copied()\n    .map(ToOwned::to_owned)\n    .collect_vec();\n  let index_of_clade_col = headers\n    .iter()\n    .position(|header| header == \"clade\")\n    .unwrap_or(headers.len());\n  custom_node_attr_keys.iter().rev().for_each(|key| {\n    headers.insert(index_of_clade_col + 1, key.clone());\n  });\n  headers\n"]], "pred": {"ppl": 2.485105037689209, "ppl_lower": 2.9551026821136475, "ppl/lowercase_ppl": -1.19028411630799, "ppl/zlib": 0.003409419203532235, "Min_5.0% Prob": 7.749043703079224, "Min_10.0% Prob": 6.135258267907536, "Min_20.0% Prob": 4.142203288919785, "Min_30.0% Prob": 2.9853887359301248, "Min_40.0% Prob": 2.2638621319463286, "Min_50.0% Prob": 1.8274579082160842, "Min_60.0% Prob": 1.5280858455632713}}
{"hexsha": "990f96416e7b850332ecd16b9e9bac2a40c3f1f9", "ext": "rs", "lang": "Rust", "content": "fn mix_columns(state: &[u8; 16]) -> [u8; 16] {\n    let mut tmp_state: [u8; 16] = [0; 16];\n    // MixColumns\n    for col in 0..4 {\n        let tmp = state[12 + col];\n        tmp_state[12 + col] = state[col] ^ state[8 + col];\n        tmp_state[8 + col] = state[4 + col] ^ state[8 + col];\n        tmp_state[4 + col] = state[col];\n        tmp_state[col] = tmp ^ tmp_state[12 + col];\n    }\n    tmp_state\n}", "item_id": 4, "repo": "kste/rust_skinny", "file": "src/skinny128.rs", "last_update_at": "2020-05-17T08:13:24+00:00", "question_id": "990f96416e7b850332ecd16b9e9bac2a40c3f1f9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mix_columns(state: &[u8; 16]) -> [u8; 16] {\n    let mut tmp_state: [u8; 16] = [0; 16];\n    // MixColumns\n    for col in 0..4 {\n        let tmp = state[12 + col];\n        tmp_state[12 + col] = state[col] ^ state[8 + col];\n        tmp_state[8 + col] = state[4 + col] ^ state[8 + col];\n        tmp_state[4 + col] = state[col];\n        tmp_state[col] = tmp ^ tmp_state[12 + col];\n    }\n    tmp_state\n"]], "pred": {"ppl": 1.934167504310608, "ppl_lower": 1.9426348209381104, "ppl/lowercase_ppl": -1.006621730240964, "ppl/zlib": 0.003973957852865589, "Min_5.0% Prob": 6.150259613990784, "Min_10.0% Prob": 4.591102316975594, "Min_20.0% Prob": 2.9951219016855415, "Min_30.0% Prob": 2.1610173523426055, "Min_40.0% Prob": 1.646252088915946, "Min_50.0% Prob": 1.3223709390676093, "Min_60.0% Prob": 1.1024329853659072}}
{"hexsha": "5286d674984a2d668f57d2d8044bdf7ce46bd44e", "ext": "rs", "lang": "Rust", "content": "fn next_pos<F>(pos: i32, result_events: &[Rc<SweepEvent<F>>], processed: &mut HashSet<i32>, orig_index: i32) -> i32\nwhere\n    F: Float,\n{\n    let p = result_events[pos as usize].point;\n    let mut new_pos = pos + 1;\n    let length = result_events.len() as i32;\n    let mut p1 = if new_pos < length {\n        result_events[new_pos as usize].point\n    } else {\n        p\n    };\n\n    while new_pos < length && p == p1 {\n        if !processed.contains(&new_pos) {\n            return new_pos;\n        } else {\n            new_pos += 1;\n        }\n        if new_pos < length {\n            p1 = result_events[new_pos as usize].point;\n        }\n    }\n\n    new_pos = pos - 1;\n\n    while processed.contains(&new_pos) && new_pos >= orig_index as i32 {\n        new_pos -= 1;\n    }\n    new_pos\n}", "item_id": 1, "repo": "bluenote10/rust-geo-booleanop", "file": "lib/src/boolean/connect_edges.rs", "last_update_at": "2020-08-25T18:34:07+00:00", "question_id": "5286d674984a2d668f57d2d8044bdf7ce46bd44e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn next_pos<F>(pos: i32, result_events: &[Rc<SweepEvent<F>>], processed: &mut HashSet<i32>, orig_index: i32) -> i32\nwhere\n    F: Float,\n{\n    let p = result_events[pos as usize].point;\n    let mut new_pos = pos + 1;\n    let length = result_events.len() as i32;\n    let mut p1 = if new_pos < length {\n        result_events[new_pos as usize].point\n    } else {\n        p\n    };\n    while new_pos < length && p == p1 {\n        if !processed.contains(&new_pos) {\n            return new_pos;\n        } else {\n            new_pos += 1;\n        }\n        if new_pos < length {\n            p1 = result_events[new_pos as usize].point;\n        }\n    }\n    new_pos = pos - 1;\n    while processed.contains(&new_pos) && new_pos >= orig_index as i32 {\n        new_pos -= 1;\n    }\n    new_pos\n"]], "pred": {"ppl": 2.073531150817871, "ppl_lower": 2.386871814727783, "ppl/lowercase_ppl": -1.192979138922863, "ppl/zlib": 0.0022789156996688015, "Min_5.0% Prob": 7.286991732461112, "Min_10.0% Prob": 5.157809674739838, "Min_20.0% Prob": 3.3248473008473716, "Min_30.0% Prob": 2.3749349318271458, "Min_40.0% Prob": 1.819970093343569, "Min_50.0% Prob": 1.4616356697062858, "Min_60.0% Prob": 1.2178686720916647}}
{"hexsha": "a9c2d6e2f1cb5c737398e9dd04a1fff8534a01e2", "ext": "rs", "lang": "Rust", "content": "fn json() -> serde_json::Result<()> {\n        assert!(serde_json::from_str::<IpLocationService>(\"-1\").is_err());\n\n        let json = \"[1,2]\";\n        let e1: Vec<IpLocationService> = serde_json::from_str(json)?;\n        assert_eq!(\n            e1,\n            vec![IpLocationService::Ip2Location, IpLocationService::Neustar]\n        );\n        assert_eq!(serde_json::to_string(&e1)?, json);\n\n        Ok(())\n    }", "item_id": 0, "repo": "mechiru/openrtb2", "file": "src/ip_location_service.rs", "last_update_at": "2020-11-12T02:24:29+00:00", "question_id": "a9c2d6e2f1cb5c737398e9dd04a1fff8534a01e2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn json() -> serde_json::Result<()> {\n        assert!(serde_json::from_str::<IpLocationService>(\"-1\").is_err());\n        let json = \"[1,2]\";\n        let e1: Vec<IpLocationService> = serde_json::from_str(json)?;\n        assert_eq!(\n            e1,\n            vec![IpLocationService::Ip2Location, IpLocationService::Neustar]\n        );\n        assert_eq!(serde_json::to_string(&e1)?, json);\n        Ok(())\n"]], "pred": {"ppl": 2.439602851867676, "ppl_lower": 3.3519339561462402, "ppl/lowercase_ppl": -1.3562341984809003, "ppl/zlib": 0.004329297380724982, "Min_5.0% Prob": 8.361652442387172, "Min_10.0% Prob": 6.157122611999512, "Min_20.0% Prob": 4.012357276061485, "Min_30.0% Prob": 2.9435910672642462, "Min_40.0% Prob": 2.227637125371859, "Min_50.0% Prob": 1.7796465797630483, "Min_60.0% Prob": 1.4955797845540546}}
{"hexsha": "8d8fadecd8509910e7928c25323c57d0b1591180", "ext": "rs", "lang": "Rust", "content": "fn assert_create_poll_result(\n        poll_id: u64,\n        quorum: u8,\n        end_height: u64,\n        start_height: u64,\n        creator: &str,\n        handle_res: HandleResponse,\n        deps: &mut Extern<MockStorage, MockApi, MockQuerier>,\n    ) {\n        assert_eq!(\n            handle_res.log,\n            vec![\n                log(\"action\", \"create_poll\"),\n                log(\"creator\", creator),\n                log(\"poll_id\", poll_id.to_string()),\n                log(\"quorum_percentage\", quorum.to_string()),\n                log(\"end_height\", end_height.to_string()),\n                log(\"start_height\", start_height.to_string()),\n            ]\n        );\n\n        //confirm poll count\n        let state = config_read(&deps.storage).load().unwrap();\n        assert_eq!(\n            state,\n            State {\n                denom: String::from(VOTING_TOKEN),\n                owner: deps\n                    .api\n                    .canonical_address(&HumanAddr::from(TEST_CREATOR))\n                    .unwrap(),\n                poll_count: 1,\n                staked_tokens: Uint128::zero(),\n            }\n        );\n    }", "item_id": 24, "repo": "levackt/cosmwasm-examples", "file": "voting/src/tests.rs", "last_update_at": "2020-06-03T14:15:26+00:00", "question_id": "8d8fadecd8509910e7928c25323c57d0b1591180_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assert_create_poll_result(\n        poll_id: u64,\n        quorum: u8,\n        end_height: u64,\n        start_height: u64,\n        creator: &str,\n        handle_res: HandleResponse,\n        deps: &mut Extern<MockStorage, MockApi, MockQuerier>,\n    ) {\n        assert_eq!(\n            handle_res.log,\n            vec![\n                log(\"action\", \"create_poll\"),\n                log(\"creator\", creator),\n                log(\"poll_id\", poll_id.to_string()),\n                log(\"quorum_percentage\", quorum.to_string()),\n                log(\"end_height\", end_height.to_string()),\n                log(\"start_height\", start_height.to_string()),\n            ]\n        );\n        //confirm poll count\n        let state = config_read(&deps.storage).load().unwrap();\n        assert_eq!(\n            state,\n            State {\n                denom: String::from(VOTING_TOKEN),\n                owner: deps\n                    .api\n                    .canonical_address(&HumanAddr::from(TEST_CREATOR))\n                    .unwrap(),\n                poll_count: 1,\n                staked_tokens: Uint128::zero(),\n            }\n        );\n"]], "pred": {"ppl": 1.7318041324615479, "ppl_lower": 2.3643529415130615, "ppl/lowercase_ppl": -1.5669359817016801, "ppl/zlib": 0.0012122819343312098, "Min_5.0% Prob": 5.9493429362773895, "Min_10.0% Prob": 4.084441401741722, "Min_20.0% Prob": 2.54806434024464, "Min_30.0% Prob": 1.7977710539343381, "Min_40.0% Prob": 1.367041322938872, "Min_50.0% Prob": 1.0987888044593008, "Min_60.0% Prob": 0.9173073915769393}}
{"hexsha": "b10dfb238fb0a19786f0768489ec9eef949ec872", "ext": "rs", "lang": "Rust", "content": "fn iter_collect_backwards() {\n        let mut list: List<i32> = List::new();\n        list.push(3);\n        list.push(2);\n        list.push(1);\n\n        let mut it = list.iter();\n        assert_eq!(it.next(), Some(&1));\n        assert_eq!(it.next(), Some(&2));\n        assert_eq!(it.next(), Some(&3));\n        assert_eq!(it.next(), None);\n\n        // Ensure the data is still there.\n        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n    }", "item_id": 6, "repo": "jesyspa/jesyspa-s-toy-projects", "file": "ll-rust/src/second.rs", "last_update_at": "2020-09-20T18:28:15+00:00", "question_id": "b10dfb238fb0a19786f0768489ec9eef949ec872_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn iter_collect_backwards() {\n        let mut list: List<i32> = List::new();\n        list.push(3);\n        list.push(2);\n        list.push(1);\n        let mut it = list.iter();\n        assert_eq!(it.next(), Some(&1));\n        assert_eq!(it.next(), Some(&2));\n        assert_eq!(it.next(), Some(&3));\n        assert_eq!(it.next(), None);\n        // Ensure the data is still there.\n        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n"]], "pred": {"ppl": 1.826371192932129, "ppl_lower": 2.2168102264404297, "ppl/lowercase_ppl": -1.3216475163992791, "ppl/zlib": 0.00286824306435172, "Min_5.0% Prob": 6.614580273628235, "Min_10.0% Prob": 4.483591064810753, "Min_20.0% Prob": 2.7373794931918383, "Min_30.0% Prob": 1.9442137784014146, "Min_40.0% Prob": 1.491592679405585, "Min_50.0% Prob": 1.2008307696785778, "Min_60.0% Prob": 1.002867648882481}}
{"hexsha": "96e0cdf28795914d09d8687e1ce841c73a6d5d6b", "ext": "rs", "lang": "Rust", "content": "pub fn compress_xof(\n    cv: &[Word; 8],\n    block: &[u8; BLOCK_LEN],\n    block_len: u8,\n    offset: u64,\n    flags: u8,\n) -> [u8; 64] {\n    let state = compress_inner(cv, block, block_len, offset, flags);\n    let mut output = [0u8; 64];\n    for i in 0..8 {\n        output[i * 4..][..4].copy_from_slice(&(state[i] ^ state[i + 8]).to_le_bytes());\n    }\n    for i in 8..16 {\n        output[i * 4..][..4].copy_from_slice(&(state[i] ^ cv[i - 8]).to_le_bytes());\n    }\n    output\n}", "item_id": 3, "repo": "oconnor663/baokeshed", "file": "src/portable.rs", "last_update_at": "2020-01-10T04:22:16+00:00", "question_id": "96e0cdf28795914d09d8687e1ce841c73a6d5d6b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn compress_xof(\n    cv: &[Word; 8],\n    block: &[u8; BLOCK_LEN],\n    block_len: u8,\n    offset: u64,\n    flags: u8,\n) -> [u8; 64] {\n    let state = compress_inner(cv, block, block_len, offset, flags);\n    let mut output = [0u8; 64];\n    for i in 0..8 {\n        output[i * 4..][..4].copy_from_slice(&(state[i] ^ state[i + 8]).to_le_bytes());\n    }\n    for i in 8..16 {\n        output[i * 4..][..4].copy_from_slice(&(state[i] ^ cv[i - 8]).to_le_bytes());\n    }\n    output\n"]], "pred": {"ppl": 2.1201510429382324, "ppl_lower": 2.22340726852417, "ppl/lowercase_ppl": -1.0632791665591772, "ppl/zlib": 0.0029703056633002974, "Min_5.0% Prob": 7.267065525054932, "Min_10.0% Prob": 5.173920324870518, "Min_20.0% Prob": 3.3605894034817103, "Min_30.0% Prob": 2.4246612886587777, "Min_40.0% Prob": 1.8488182438647045, "Min_50.0% Prob": 1.4984519523129147, "Min_60.0% Prob": 1.2566719359798928}}
{"hexsha": "9af7d4769d7c68e805ac826101567da7e99b3c17", "ext": "rs", "lang": "Rust", "content": "fn convert_tracker_mode(\n    rawkeys: &HashMap<String, Vec<u8>>,\n    label: &str,\n) -> Result<TrackerOperationMode, VEError> {\n    let raw = rawkeys\n        .get(label)\n        .ok_or_else(|| VEError::MissingField(label.into()))?;\n    let cleaned = from_utf8(raw)\n        .map_err(|e| VEError::Parse(format!(\"Failed to parse {} from {:?} - {}\", label, &raw, e)))?\n        .parse::<usize>()?;\n    Ok(TrackerOperationMode::from_repr(cleaned).unwrap_or(TrackerOperationMode::Off))\n}", "item_id": 10, "repo": "dbr/vedirect-rs", "file": "src/data.rs", "last_update_at": "2020-10-12T14:06:46+00:00", "question_id": "9af7d4769d7c68e805ac826101567da7e99b3c17_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn convert_tracker_mode(\n    rawkeys: &HashMap<String, Vec<u8>>,\n    label: &str,\n) -> Result<TrackerOperationMode, VEError> {\n    let raw = rawkeys\n        .get(label)\n        .ok_or_else(|| VEError::MissingField(label.into()))?;\n    let cleaned = from_utf8(raw)\n        .map_err(|e| VEError::Parse(format!(\"Failed to parse {} from {:?} - {}\", label, &raw, e)))?\n        .parse::<usize>()?;\n    Ok(TrackerOperationMode::from_repr(cleaned).unwrap_or(TrackerOperationMode::Off))\n"]], "pred": {"ppl": 3.0100817680358887, "ppl_lower": 3.8356311321258545, "ppl/lowercase_ppl": -1.219940066630012, "ppl/zlib": 0.0037998870477663383, "Min_5.0% Prob": 8.496024906635284, "Min_10.0% Prob": 6.682393845389871, "Min_20.0% Prob": 4.652135884060579, "Min_30.0% Prob": 3.49581802592558, "Min_40.0% Prob": 2.7017502007277114, "Min_50.0% Prob": 2.2064788983485033, "Min_60.0% Prob": 1.8489250301392477}}
{"hexsha": "c4ad96a4e0b62e626c3149faf453d8b1b59465e2", "ext": "rs", "lang": "Rust", "content": "fn test_parse_select1() {\n    let binary_operators = BinaryOperators::new();\n    let unary_operators = UnaryOperators::new();\n\n    let mut parser = Parser::from_plain_tokens(\n        &binary_operators,\n        &unary_operators,\n        vec![\n            Token::Keyword(Keyword::Select),\n            Token::Identifier(\"x\".to_string()),\n            Token::Keyword(Keyword::From),\n            Token::Identifier(\"test\".to_string()),\n            Token::End\n        ]\n    );\n\n    let tree = parser.parse().unwrap();\n\n    assert_eq!(\n        ParserOperationTree::Select {\n            location: Default::default(),\n            projections: vec![(None, ParserExpressionTreeData::ColumnAccess(\"x\".to_owned()).with_location(Default::default()))],\n            from: (\"test\".to_string(), None),\n            filter: None,\n            group_by: None,\n            having: None,\n            join: None\n        },\n        tree\n    );\n}", "item_id": 15, "repo": "svenslaggare/sqlgrep", "file": "src/parsing/parser.rs", "last_update_at": "2020-11-26T11:14:16+00:00", "question_id": "c4ad96a4e0b62e626c3149faf453d8b1b59465e2_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_select1() {\n    let binary_operators = BinaryOperators::new();\n    let unary_operators = UnaryOperators::new();\n    let mut parser = Parser::from_plain_tokens(\n        &binary_operators,\n        &unary_operators,\n        vec![\n            Token::Keyword(Keyword::Select),\n            Token::Identifier(\"x\".to_string()),\n            Token::Keyword(Keyword::From),\n            Token::Identifier(\"test\".to_string()),\n            Token::End\n        ]\n    );\n    let tree = parser.parse().unwrap();\n    assert_eq!(\n        ParserOperationTree::Select {\n            location: Default::default(),\n            projections: vec![(None, ParserExpressionTreeData::ColumnAccess(\"x\".to_owned()).with_location(Default::default()))],\n            from: (\"test\".to_string(), None),\n            filter: None,\n            group_by: None,\n            having: None,\n            join: None\n        },\n        tree\n    );\n"]], "pred": {"ppl": 2.5376040935516357, "ppl_lower": 3.4833312034606934, "ppl/lowercase_ppl": -1.3401651471298188, "ppl/zlib": 0.00251002793966533, "Min_5.0% Prob": 7.722983002662659, "Min_10.0% Prob": 5.907992362976074, "Min_20.0% Prob": 4.048614452866947, "Min_30.0% Prob": 2.945368007609719, "Min_40.0% Prob": 2.275149227357378, "Min_50.0% Prob": 1.8557935084296961, "Min_60.0% Prob": 1.5492250243920127}}
{"hexsha": "03201f2b2afd5dfeb31262c5c1a7609fc1ea1597", "ext": "rs", "lang": "Rust", "content": "fn read_file(file_name: &str) -> std::io::Result<[u8; AVAILABLE_MEMORY]> {\n    let mut f = File::open(file_name)?;\n    let mut memory = [0; AVAILABLE_MEMORY];\n    f.read_exact(&mut memory)?;\n    Ok(memory)\n}", "item_id": 0, "repo": "AgustinCB/emulators", "file": "mos6502cpu/src/main.rs", "last_update_at": "2020-07-19T01:21:35+00:00", "question_id": "03201f2b2afd5dfeb31262c5c1a7609fc1ea1597_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_file(file_name: &str) -> std::io::Result<[u8; AVAILABLE_MEMORY]> {\n    let mut f = File::open(file_name)?;\n    let mut memory = [0; AVAILABLE_MEMORY];\n    f.read_exact(&mut memory)?;\n    Ok(memory)\n"]], "pred": {"ppl": 1.9339497089385986, "ppl_lower": 3.175929307937622, "ppl/lowercase_ppl": -1.7520659045914813, "ppl/zlib": 0.004456516169201431, "Min_5.0% Prob": 7.956919431686401, "Min_10.0% Prob": 5.440645545721054, "Min_20.0% Prob": 3.160861744600184, "Min_30.0% Prob": 2.171013213120974, "Min_40.0% Prob": 1.6405979516250746, "Min_50.0% Prob": 1.313194015148011, "Min_60.0% Prob": 1.1142377097947667}}
{"hexsha": "2afdd4248c765d2779b17e977ddbce15b85a65a3", "ext": "rs", "lang": "Rust", "content": "fn plan_view_select(\n    qcx: &QueryContext,\n    s: &Select,\n) -> Result<(RelationExpr, Scope), failure::Error> {\n    // Step 1. Handle FROM clause, including joins.\n    let (left, left_scope) = {\n        let typ = RelationType::new(vec![]);\n        (\n            RelationExpr::constant(vec![vec![]], typ),\n            Scope::from_source(\n                None,\n                iter::empty::<Option<ColumnName>>(),\n                Some(qcx.outer_scope.clone()),\n            ),\n        )\n    };\n    let (mut relation_expr, from_scope) =\n        s.from.iter().fold(Ok((left, left_scope)), |l, twj| {\n            let (left, left_scope) = l?;\n            plan_table_with_joins(qcx, left, left_scope, &JoinOperator::CrossJoin, twj)\n        })?;\n\n    // Step 2. Handle WHERE clause.\n    if let Some(selection) = &s.selection {\n        let ecx = &ExprContext {\n            qcx,\n            name: \"WHERE clause\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let expr = plan_expr(ecx, &selection, Some(ScalarType::Bool))?;\n        let typ = ecx.column_type(&expr);\n        if typ.scalar_type != ScalarType::Bool && typ.scalar_type != ScalarType::Unknown {\n            bail!(\n                \"WHERE clause must have boolean type, not {:?}\",\n                typ.scalar_type\n            );\n        }\n        relation_expr = relation_expr.filter(vec![expr]);\n    }\n\n    // Step 3. Handle GROUP BY clause.\n    let (group_scope, select_all_mapping) = {\n        // gather group columns\n        let ecx = &ExprContext {\n            qcx,\n            name: \"GROUP BY clause\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let mut group_key = vec![];\n        let mut group_exprs = vec![];\n        let mut group_scope = Scope::empty(Some(qcx.outer_scope.clone()));\n        let mut select_all_mapping = BTreeMap::new();\n        for group_expr in &s.group_by {\n            let (expr, maybe_name) =\n                plan_expr_or_col_index(ecx, group_expr, Some(ScalarType::String), \"GROUP BY\")?;\n            let new_column = group_key.len();\n            // repeated exprs in GROUP BY confuse name resolution later, and dropping them doesn't change the result\n            if group_exprs\n                .iter()\n                .find(|existing_expr| **existing_expr == expr)\n                .is_none()\n            {\n                let scope_item = if let ScalarExpr::Column(ColumnRef {\n                    level: 0,\n                    column: old_column,\n                }) = &expr\n                {\n                    // If we later have `SELECT foo.*` then we have to find all the `foo` items in `from_scope` and figure out where they ended up in `group_scope`.\n                    // This is really hard to do right using SQL name resolution, so instead we just track the movement here.\n                    select_all_mapping.insert(*old_column, new_column);\n                    let mut scope_item = ecx.scope.items[*old_column].clone();\n                    scope_item.expr = Some(group_expr.clone());\n                    scope_item\n                } else {\n                    ScopeItem {\n                        names: maybe_name.into_iter().collect(),\n                        expr: Some(group_expr.clone()),\n                        nameable: true,\n                    }\n                };\n\n                group_key.push(from_scope.len() + group_exprs.len());\n                group_exprs.push(expr);\n                group_scope.items.push(scope_item);\n            }\n        }\n        // gather aggregates\n        let mut aggregate_visitor = AggregateFuncVisitor::new();\n        for p in &s.projection {\n            aggregate_visitor.visit_select_item(p);\n        }\n        if let Some(having) = &s.having {\n            aggregate_visitor.visit_expr(having);\n        }\n        let ecx = &ExprContext {\n            qcx,\n            name: \"aggregate function\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr.clone().map(group_exprs.clone())),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let mut aggregates = vec![];\n        for sql_function in aggregate_visitor.into_result()? {\n            aggregates.push(plan_aggregate(ecx, sql_function)?);\n            group_scope.items.push(ScopeItem {\n                names: vec![ScopeItemName {\n                    table_name: None,\n                    column_name: Some(sql_function.name.to_string().into()),\n                }],\n                expr: Some(Expr::Function(sql_function.clone())),\n                nameable: true,\n            });\n        }\n        if !aggregates.is_empty() || !group_key.is_empty() || s.having.is_some() {\n            // apply GROUP BY / aggregates\n            relation_expr = relation_expr.map(group_exprs).reduce(group_key, aggregates);\n            (group_scope, select_all_mapping)\n        } else {\n            // if no GROUP BY, aggregates or having then all columns remain in scope\n            (\n                from_scope.clone(),\n                (0..from_scope.len()).map(|i| (i, i)).collect(),\n            )\n        }\n    };\n\n    // Step 4. Handle HAVING clause.\n    if let Some(having) = &s.having {\n        let ecx = &ExprContext {\n            qcx,\n            name: \"HAVING clause\",\n            scope: &group_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: true,\n            allow_subqueries: true,\n        };\n        let expr = plan_expr(ecx, having, Some(ScalarType::Bool))?;\n        let typ = ecx.column_type(&expr);\n        if typ.scalar_type != ScalarType::Bool {\n            bail!(\n                \"HAVING clause must have boolean type, not {:?}\",\n                typ.scalar_type\n            );\n        }\n        relation_expr = relation_expr.filter(vec![expr]);\n    }\n\n    // Step 5. Handle projections.\n    let project_scope = {\n        let mut project_exprs = vec![];\n        let mut project_key = vec![];\n        let mut project_scope = Scope::empty(Some(qcx.outer_scope.clone()));\n        for p in &s.projection {\n            let ecx = &ExprContext {\n                qcx,\n                name: \"SELECT clause\",\n                scope: &group_scope,\n                relation_type: &qcx.relation_type(&relation_expr),\n                allow_aggregates: true,\n                allow_subqueries: true,\n            };\n            for (expr, scope_item) in plan_select_item(ecx, p, &from_scope, &select_all_mapping)? {\n                project_key.push(group_scope.len() + project_exprs.len());\n                project_exprs.push(expr);\n                project_scope.items.push(scope_item);\n            }\n        }\n        relation_expr = relation_expr.map(project_exprs).project(project_key);\n        project_scope\n    };\n\n    // Step 6. Handle DISTINCT.\n    if s.distinct {\n        relation_expr = relation_expr.distinct();\n    }\n\n    Ok((relation_expr, project_scope))\n}", "item_id": 4, "repo": "cuongdo/materialize", "file": "src/sql/query.rs", "last_update_at": "2020-11-25T19:50:12+00:00", "question_id": "2afdd4248c765d2779b17e977ddbce15b85a65a3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn plan_view_select(\n    qcx: &QueryContext,\n    s: &Select,\n) -> Result<(RelationExpr, Scope), failure::Error> {\n    // Step 1. Handle FROM clause, including joins.\n    let (left, left_scope) = {\n        let typ = RelationType::new(vec![]);\n        (\n            RelationExpr::constant(vec![vec![]], typ),\n            Scope::from_source(\n                None,\n                iter::empty::<Option<ColumnName>>(),\n                Some(qcx.outer_scope.clone()),\n            ),\n        )\n    };\n    let (mut relation_expr, from_scope) =\n        s.from.iter().fold(Ok((left, left_scope)), |l, twj| {\n            let (left, left_scope) = l?;\n            plan_table_with_joins(qcx, left, left_scope, &JoinOperator::CrossJoin, twj)\n        })?;\n    // Step 2. Handle WHERE clause.\n    if let Some(selection) = &s.selection {\n        let ecx = &ExprContext {\n            qcx,\n            name: \"WHERE clause\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let expr = plan_expr(ecx, &selection, Some(ScalarType::Bool))?;\n        let typ = ecx.column_type(&expr);\n        if typ.scalar_type != ScalarType::Bool && typ.scalar_type != ScalarType::Unknown {\n            bail!(\n                \"WHERE clause must have boolean type, not {:?}\",\n                typ.scalar_type\n            );\n        }\n        relation_expr = relation_expr.filter(vec![expr]);\n    }\n    // Step 3. Handle GROUP BY clause.\n    let (group_scope, select_all_mapping) = {\n        // gather group columns\n        let ecx = &ExprContext {\n            qcx,\n            name: \"GROUP BY clause\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let mut group_key = vec![];\n        let mut group_exprs = vec![];\n        let mut group_scope = Scope::empty(Some(qcx.outer_scope.clone()));\n        let mut select_all_mapping = BTreeMap::new();\n        for group_expr in &s.group_by {\n            let (expr, maybe_name) =\n                plan_expr_or_col_index(ecx, group_expr, Some(ScalarType::String), \"GROUP BY\")?;\n            let new_column = group_key.len();\n            // repeated exprs in GROUP BY confuse name resolution later, and dropping them doesn't change the result\n            if group_exprs\n                .iter()\n                .find(|existing_expr| **existing_expr == expr)\n                .is_none()\n            {\n                let scope_item = if let ScalarExpr::Column(ColumnRef {\n                    level: 0,\n                    column: old_column,\n                }) = &expr\n                {\n                    // If we later have `SELECT foo.*` then we have to find all the `foo` items in `from_scope` and figure out where they ended up in `group_scope`.\n                    // This is really hard to do right using SQL name resolution, so instead we just track the movement here.\n                    select_all_mapping.insert(*old_column, new_column);\n                    let mut scope_item = ecx.scope.items[*old_column].clone();\n                    scope_item.expr = Some(group_expr.clone());\n                    scope_item\n                } else {\n                    ScopeItem {\n                        names: maybe_name.into_iter().collect(),\n                        expr: Some(group_expr.clone()),\n                        nameable: true,\n                    }\n                };\n                group_key.push(from_scope.len() + group_exprs.len());\n                group_exprs.push(expr);\n                group_scope.items.push(scope_item);\n            }\n        }\n        // gather aggregates\n        let mut aggregate_visitor = AggregateFuncVisitor::new();\n        for p in &s.projection {\n            aggregate_visitor.visit_select_item(p);\n        }\n        if let Some(having) = &s.having {\n            aggregate_visitor.visit_expr(having);\n        }\n        let ecx = &ExprContext {\n            qcx,\n            name: \"aggregate function\",\n            scope: &from_scope,\n            relation_type: &qcx.relation_type(&relation_expr.clone().map(group_exprs.clone())),\n            allow_aggregates: false,\n            allow_subqueries: true,\n        };\n        let mut aggregates = vec![];\n        for sql_function in aggregate_visitor.into_result()? {\n            aggregates.push(plan_aggregate(ecx, sql_function)?);\n            group_scope.items.push(ScopeItem {\n                names: vec![ScopeItemName {\n                    table_name: None,\n                    column_name: Some(sql_function.name.to_string().into()),\n                }],\n                expr: Some(Expr::Function(sql_function.clone())),\n                nameable: true,\n            });\n        }\n        if !aggregates.is_empty() || !group_key.is_empty() || s.having.is_some() {\n            // apply GROUP BY / aggregates\n            relation_expr = relation_expr.map(group_exprs).reduce(group_key, aggregates);\n            (group_scope, select_all_mapping)\n        } else {\n            // if no GROUP BY, aggregates or having then all columns remain in scope\n            (\n                from_scope.clone(),\n                (0..from_scope.len()).map(|i| (i, i)).collect(),\n            )\n        }\n    };\n    // Step 4. Handle HAVING clause.\n    if let Some(having) = &s.having {\n        let ecx = &ExprContext {\n            qcx,\n            name: \"HAVING clause\",\n            scope: &group_scope,\n            relation_type: &qcx.relation_type(&relation_expr),\n            allow_aggregates: true,\n            allow_subqueries: true,\n        };\n        let expr = plan_expr(ecx, having, Some(ScalarType::Bool))?;\n        let typ = ecx.column_type(&expr);\n        if typ.scalar_type != ScalarType::Bool {\n            bail!(\n                \"HAVING clause must have boolean type, not {:?}\",\n                typ.scalar_type\n            );\n        }\n        relation_expr = relation_expr.filter(vec![expr]);\n    }\n    // Step 5. Handle projections.\n    let project_scope = {\n        let mut project_exprs = vec![];\n        let mut project_key = vec![];\n        let mut project_scope = Scope::empty(Some(qcx.outer_scope.clone()));\n        for p in &s.projection {\n            let ecx = &ExprContext {\n                qcx,\n                name: \"SELECT clause\",\n                scope: &group_scope,\n                relation_type: &qcx.relation_type(&relation_expr),\n                allow_aggregates: true,\n                allow_subqueries: true,\n            };\n            for (expr, scope_item) in plan_select_item(ecx, p, &from_scope, &select_all_mapping)? {\n                project_key.push(group_scope.len() + project_exprs.len());\n                project_exprs.push(expr);\n                project_scope.items.push(scope_item);\n            }\n        }\n        relation_expr = relation_expr.map(project_exprs).project(project_key);\n        project_scope\n    };\n    // Step 6. Handle DISTINCT.\n    if s.distinct {\n        relation_expr = relation_expr.distinct();\n    }\n    Ok((relation_expr, project_scope))\n"]], "pred": {"ppl": 2.0262162685394287, "ppl_lower": 2.486586809158325, "ppl/lowercase_ppl": -1.2899313501386103, "ppl/zlib": 0.0003790499982253677, "Min_5.0% Prob": 6.338616090662339, "Min_10.0% Prob": 4.744021039383084, "Min_20.0% Prob": 3.1321826729119993, "Min_30.0% Prob": 2.288461162471304, "Min_40.0% Prob": 1.750332264379942, "Min_50.0% Prob": 1.4103626272624719, "Min_60.0% Prob": 1.1778351128045135}}
{"hexsha": "0b596157697b3f80ac1442fdec27367b058934db", "ext": "rs", "lang": "Rust", "content": "fn test_part1() {\n        let input = \"\\\n            ..##.........##.........##.........##.........##.........##.......  --->\\n\\\n            #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\\n\\\n            .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\\n\\\n            ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\\n\\\n            .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\\n\\\n            ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  --->\\n\\\n            .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\\n\\\n            .#........#.#........#.#........#.#........#.#........#.#........#\\n\\\n            #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...\\n\\\n            #...##....##...##....##...##....##...##....##...##....##...##....#\\n\\\n            .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\\n\\\n            \";\n        let expected_output = \"\\\n            ..##.........##.........##.........##.........##.........##.......  --->\\n\\\n            #..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\\n\\\n            .#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\\n\\\n            ..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\\n\\\n            .#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\\n\\\n            ..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  --->\\n\\\n            .#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\\n\\\n            .#........#.#........X.#........#.#........#.#........#.#........#\\n\\\n            #.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...\\n\\\n            #...##....##...##....##...#X....##...##....##...##....##...##....#\\n\\\n            .#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\\n\\\n            \";\n\n        let output = solve(mk_input(false, input)).unwrap();\n\n        assert_eq!(expected_output.to_string(), output.runs[0].rendered);\n        assert_eq!(7, output.product);\n    }", "item_id": 4, "repo": "spraints/advent-of-code-2020", "file": "api_server/src/day3.rs", "last_update_at": "2020-12-02T19:24:20+00:00", "question_id": "0b596157697b3f80ac1442fdec27367b058934db_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_part1() {\n        let input = \"\\\n            ..##.........##.........##.........##.........##.........##.......  --->\\n\\\n            #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\\n\\\n            .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\\n\\\n            ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\\n\\\n            .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\\n\\\n            ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  --->\\n\\\n            .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\\n\\\n            .#........#.#........#.#........#.#........#.#........#.#........#\\n\\\n            #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...\\n\\\n            #...##....##...##....##...##....##...##....##...##....##...##....#\\n\\\n            .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\\n\\\n            \";\n        let expected_output = \"\\\n            ..##.........##.........##.........##.........##.........##.......  --->\\n\\\n            #..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\\n\\\n            .#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\\n\\\n            ..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\\n\\\n            .#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\\n\\\n            ..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  --->\\n\\\n            .#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\\n\\\n            .#........#.#........X.#........#.#........#.#........#.#........#\\n\\\n            #.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...\\n\\\n            #...##....##...##....##...#X....##...##....##...##....##...##....#\\n\\\n            .#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\\n\\\n            \";\n        let output = solve(mk_input(false, input)).unwrap();\n        assert_eq!(expected_output.to_string(), output.runs[0].rendered);\n        assert_eq!(7, output.product);\n"]], "pred": {"ppl": 1.1952241659164429, "ppl_lower": 1.2539935111999512, "ppl/lowercase_ppl": -1.2691555144066262, "ppl/zlib": 0.000596433960977509, "Min_5.0% Prob": 3.210061638939137, "Min_10.0% Prob": 1.7598609092588327, "Min_20.0% Prob": 0.8899319136070872, "Min_30.0% Prob": 0.5952505591879914, "Min_40.0% Prob": 0.4457862832642064, "Min_50.0% Prob": 0.3570147266612374, "Min_60.0% Prob": 0.29721778791820014}}
{"hexsha": "f10930d029c57cb4dbb180e719e5438b2b069303", "ext": "rs", "lang": "Rust", "content": "fn impl_struct(\n    name: syn::Ident,\n    vis: syn::Visibility,\n    data: syn::DataStruct,\n    derive: Vec<syn::Ident>,\n) -> TokenStream {\n    let mut field_names = Vec::new();\n    let mut member_names = Vec::new();\n    let mut field_types = Vec::new();\n    let mut unnamed_count: u32 = 0;\n    for field in data.fields.iter() {\n        if let Some(ref x) = field.ident {\n            field_names.push(to_camel_case(x));\n            member_names.push(syn::Member::Named(x.clone()));\n            field_types.push(field.ty.clone());\n        } else {\n            let ident = format_ident!(\"{}\", get_name(unnamed_count));\n            field_names.push(ident);\n            member_names.push(to_tuple_index(unnamed_count));\n            unnamed_count += 1;\n            field_types.push(field.ty.clone());\n        }\n    }\n    let patch_name = format_ident!(\"{}Patch\", name);\n    let patch_error_name = format_ident!(\"{}PatchError\", name);\n    let mod_name = format_ident!(\"__{}_mod\", to_snake_case(&name));\n\n    let derive_tag = quote! {\n        #[derive(#(#derive,)*)]\n    };\n\n    let stream = quote! {\n        #derive_tag\n        #vis enum #patch_name {\n            #(#field_names (<#field_types as Patchable>::Patch),)*\n        }\n        #vis enum #patch_error_name {\n            #(#field_names (<#field_types as Patchable>::Error),)*\n        }\n\n        mod #mod_name{\n            use std::fmt;\n            use super::#patch_error_name;\n\n            impl fmt::Display for #patch_error_name{\n                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n                    match *self{\n                        #(#patch_error_name::#field_names(ref x) => {\n                            write!(fmt, \"within `#name.#field_names` => {}\",x)\n                        })*\n                    }\n                }\n            }\n        }\n\n        impl Patchable for #name{\n            type Patch = Vec<#patch_name>;\n            type Error = #patch_error_name;\n\n            fn produce(&self, other: &Self) -> Option<Self::Patch>{\n                let mut res = Vec::new();\n                #(if let Some(x) = self.#member_names.produce(&other.#member_names) {\n                    res.push(#patch_name::#field_names(x));\n                })*\n                if res.len() == 0{\n                    None\n                }else{\n                    Some(res)\n                }\n            }\n\n            fn apply(&mut self, patch: Self::Patch) -> Result<(),Self::Error>{\n                for p in patch {\n                    match p{\n                        #(#patch_name::#field_names(x) => {\n                            self.#member_names.apply(x).map_err(#patch_error_name::#field_names)?;\n                        })*\n                    }\n                }\n                Ok(())\n            }\n        }\n    };\n    proc_macro::TokenStream::from(stream)\n}", "item_id": 3, "repo": "DelSkayn/immers", "file": "immers_derive/src/lib.rs", "last_update_at": "2020-12-30T17:06:34+00:00", "question_id": "f10930d029c57cb4dbb180e719e5438b2b069303_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn impl_struct(\n    name: syn::Ident,\n    vis: syn::Visibility,\n    data: syn::DataStruct,\n    derive: Vec<syn::Ident>,\n) -> TokenStream {\n    let mut field_names = Vec::new();\n    let mut member_names = Vec::new();\n    let mut field_types = Vec::new();\n    let mut unnamed_count: u32 = 0;\n    for field in data.fields.iter() {\n        if let Some(ref x) = field.ident {\n            field_names.push(to_camel_case(x));\n            member_names.push(syn::Member::Named(x.clone()));\n            field_types.push(field.ty.clone());\n        } else {\n            let ident = format_ident!(\"{}\", get_name(unnamed_count));\n            field_names.push(ident);\n            member_names.push(to_tuple_index(unnamed_count));\n            unnamed_count += 1;\n            field_types.push(field.ty.clone());\n        }\n    }\n    let patch_name = format_ident!(\"{}Patch\", name);\n    let patch_error_name = format_ident!(\"{}PatchError\", name);\n    let mod_name = format_ident!(\"__{}_mod\", to_snake_case(&name));\n    let derive_tag = quote! {\n        #[derive(#(#derive,)*)]\n    };\n    let stream = quote! {\n        #derive_tag\n        #vis enum #patch_name {\n            #(#field_names (<#field_types as Patchable>::Patch),)*\n        }\n        #vis enum #patch_error_name {\n            #(#field_names (<#field_types as Patchable>::Error),)*\n        }\n        mod #mod_name{\n            use std::fmt;\n            use super::#patch_error_name;\n            impl fmt::Display for #patch_error_name{\n                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n                    match *self{\n                        #(#patch_error_name::#field_names(ref x) => {\n                            write!(fmt, \"within `#name.#field_names` => {}\",x)\n                        })*\n                    }\n                }\n            }\n        }\n        impl Patchable for #name{\n            type Patch = Vec<#patch_name>;\n            type Error = #patch_error_name;\n            fn produce(&self, other: &Self) -> Option<Self::Patch>{\n                let mut res = Vec::new();\n                #(if let Some(x) = self.#member_names.produce(&other.#member_names) {\n                    res.push(#patch_name::#field_names(x));\n                })*\n                if res.len() == 0{\n                    None\n                }else{\n                    Some(res)\n                }\n            }\n            fn apply(&mut self, patch: Self::Patch) -> Result<(),Self::Error>{\n                for p in patch {\n                    match p{\n                        #(#patch_name::#field_names(x) => {\n                            self.#member_names.apply(x).map_err(#patch_error_name::#field_names)?;\n                        })*\n                    }\n                }\n                Ok(())\n            }\n        }\n    };\n    proc_macro::TokenStream::from(stream)\n"]], "pred": {"ppl": 1.6892783641815186, "ppl_lower": 1.8924082517623901, "ppl/lowercase_ppl": -1.2165715817495075, "ppl/zlib": 0.0006047306047291384, "Min_5.0% Prob": 5.807654386474972, "Min_10.0% Prob": 4.01191412125315, "Min_20.0% Prob": 2.4383000460054194, "Min_30.0% Prob": 1.7100795065108023, "Min_40.0% Prob": 1.304111150974955, "Min_50.0% Prob": 1.0462839893171325, "Min_60.0% Prob": 0.8739017942384725}}
{"hexsha": "dec557fbd88aa369ae7364c3771e2af1b0335fd1", "ext": "rs", "lang": "Rust", "content": "fn make_producer<'a>(\n    config: &'a Config,\n    reused_producers: &mut ReusedProducersMap<'a>,\n    kafka_topic: KafkaTopic,\n) -> Result<Producer, ServerError> {\n    let (config_name, kafka_config) = config\n        .kafka_config(kafka_topic)\n        .context(ServerErrorKind::KafkaError)?;\n\n    if let Some(producer) = reused_producers.get(&config_name) {\n        return Ok(Arc::clone(producer));\n    }\n\n    let mut client_config = ClientConfig::new();\n\n    for config_p in kafka_config {\n        client_config.set(config_p.name.as_str(), config_p.value.as_str());\n    }\n\n    let producer = Arc::new(\n        client_config\n            .create_with_context(CaptureErrorContext)\n            .context(ServerErrorKind::KafkaError)?,\n    );\n\n    reused_producers.insert(config_name, Arc::clone(&producer));\n    Ok(producer)\n}", "item_id": 0, "repo": "getsentry/semaphore", "file": "relay-server/src/actors/store.rs", "last_update_at": "2020-01-02T14:51:18+00:00", "question_id": "dec557fbd88aa369ae7364c3771e2af1b0335fd1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_producer<'a>(\n    config: &'a Config,\n    reused_producers: &mut ReusedProducersMap<'a>,\n    kafka_topic: KafkaTopic,\n) -> Result<Producer, ServerError> {\n    let (config_name, kafka_config) = config\n        .kafka_config(kafka_topic)\n        .context(ServerErrorKind::KafkaError)?;\n    if let Some(producer) = reused_producers.get(&config_name) {\n        return Ok(Arc::clone(producer));\n    }\n    let mut client_config = ClientConfig::new();\n    for config_p in kafka_config {\n        client_config.set(config_p.name.as_str(), config_p.value.as_str());\n    }\n    let producer = Arc::new(\n        client_config\n            .create_with_context(CaptureErrorContext)\n            .context(ServerErrorKind::KafkaError)?,\n    );\n    reused_producers.insert(config_name, Arc::clone(&producer));\n    Ok(producer)\n"]], "pred": {"ppl": 2.0522680282592773, "ppl_lower": 2.74731183052063, "ppl/lowercase_ppl": -1.4057016361313641, "ppl/zlib": 0.0020424589114738743, "Min_5.0% Prob": 7.0331429701585035, "Min_10.0% Prob": 5.112825808701692, "Min_20.0% Prob": 3.2324926411664046, "Min_30.0% Prob": 2.3193824651037773, "Min_40.0% Prob": 1.7895423438434208, "Min_50.0% Prob": 1.4343007423636251, "Min_60.0% Prob": 1.2005502575065758}}
{"hexsha": "ea8735d3ac575c1d83d4fdc7748ffa7833302ff3", "ext": "rs", "lang": "Rust", "content": "fn gen_retry_list(res: &RawTestResults) -> String {\n    use std::fmt::Write;\n\n    let mut out = String::new();\n\n    let regressed_crates = res\n        .crates\n        .iter()\n        .filter(|crate_res| crate_res.res == Comparison::Regressed)\n        .map(|crate_res| &crate_res.krate);\n\n    for krate in regressed_crates {\n        match krate {\n            Crate::Registry(details) => writeln!(out, \"{}\", details.name).unwrap(),\n            Crate::GitHub(repo) => writeln!(out, \"{}/{}\", repo.org, repo.name).unwrap(),\n            Crate::Local(_) | Crate::Git(_) | Crate::Path(_) => {}\n        }\n    }\n\n    out\n}", "item_id": 4, "repo": "jyn514/crater", "file": "src/report/mod.rs", "last_update_at": "2020-09-05T14:02:56+00:00", "question_id": "ea8735d3ac575c1d83d4fdc7748ffa7833302ff3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gen_retry_list(res: &RawTestResults) -> String {\n    use std::fmt::Write;\n    let mut out = String::new();\n    let regressed_crates = res\n        .crates\n        .iter()\n        .filter(|crate_res| crate_res.res == Comparison::Regressed)\n        .map(|crate_res| &crate_res.krate);\n    for krate in regressed_crates {\n        match krate {\n            Crate::Registry(details) => writeln!(out, \"{}\", details.name).unwrap(),\n            Crate::GitHub(repo) => writeln!(out, \"{}/{}\", repo.org, repo.name).unwrap(),\n            Crate::Local(_) | Crate::Git(_) | Crate::Path(_) => {}\n        }\n    }\n    out\n"]], "pred": {"ppl": 2.494230270385742, "ppl_lower": 2.9497196674346924, "ppl/lowercase_ppl": -1.1835159778177127, "ppl/zlib": 0.003026424413051002, "Min_5.0% Prob": 7.461535882949829, "Min_10.0% Prob": 5.722676004682269, "Min_20.0% Prob": 3.9260838400749933, "Min_30.0% Prob": 2.933759161404201, "Min_40.0% Prob": 2.2525773437584147, "Min_50.0% Prob": 1.8280128529471047, "Min_60.0% Prob": 1.5317045565415908}}
{"hexsha": "8a4950eb324ae19844fbcc58b2d2ce721ea65aef", "ext": "rs", "lang": "Rust", "content": "pub fn load() -> Templates<'static> {\n    let mut hb = Handlebars::new();\n\n    hb.register_template_file(\"layout\", \"templates/_layout.handlebars\")\n        .expect(\"register layout\");\n    hb.register_template_file(\"index\", \"templates/index.handlebars\")\n        .expect(\"register index\");\n    hb.register_template_file(\"dashboard\", \"templates/dashboard.handlebars\")\n        .expect(\"register dashboard\");\n\n    Templates { hb }\n}", "item_id": 0, "repo": "frigus02/github-status-stats", "file": "crates/ghss_website/src/templates.rs", "last_update_at": "2020-07-06T20:12:32+00:00", "question_id": "8a4950eb324ae19844fbcc58b2d2ce721ea65aef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load() -> Templates<'static> {\n    let mut hb = Handlebars::new();\n    hb.register_template_file(\"layout\", \"templates/_layout.handlebars\")\n        .expect(\"register layout\");\n    hb.register_template_file(\"index\", \"templates/index.handlebars\")\n        .expect(\"register index\");\n    hb.register_template_file(\"dashboard\", \"templates/dashboard.handlebars\")\n        .expect(\"register dashboard\");\n    Templates { hb }\n"]], "pred": {"ppl": 2.1820685863494873, "ppl_lower": 2.5128743648529053, "ppl/lowercase_ppl": -1.1809032039790366, "ppl/zlib": 0.00431090231882686, "Min_5.0% Prob": 8.649206638336182, "Min_10.0% Prob": 6.193181872367859, "Min_20.0% Prob": 3.634603087902069, "Min_30.0% Prob": 2.6084538766661205, "Min_40.0% Prob": 1.9535623885691167, "Min_50.0% Prob": 1.5564077373239256, "Min_60.0% Prob": 1.3094455860555172}}
{"hexsha": "4bc2be147005de2b36cddf8d20a314bd4db118e5", "ext": "rs", "lang": "Rust", "content": "pub fn render() -> Result<()> {\n  let config = config::get_config()?;\n  let vars = config.vars();\n\n  for (remote_name, render_to) in config.templates().iter() {\n    render_template(config.dest(remote_name), render_to, &vars)?;\n  }\n\n  Ok(())\n}", "item_id": 1, "repo": "enricozb/rot", "file": "src/cmd/render.rs", "last_update_at": "2020-09-19T20:54:36+00:00", "question_id": "4bc2be147005de2b36cddf8d20a314bd4db118e5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn render() -> Result<()> {\n  let config = config::get_config()?;\n  let vars = config.vars();\n  for (remote_name, render_to) in config.templates().iter() {\n    render_template(config.dest(remote_name), render_to, &vars)?;\n  }\n  Ok(())\n"]], "pred": {"ppl": 4.3097357749938965, "ppl_lower": 5.158370494842529, "ppl/lowercase_ppl": -1.1230385490936374, "ppl/zlib": 0.009548213053141156, "Min_5.0% Prob": 9.216276288032532, "Min_10.0% Prob": 7.892446339130402, "Min_20.0% Prob": 5.626489569159115, "Min_30.0% Prob": 4.393374319076538, "Min_40.0% Prob": 3.4613713762339424, "Min_50.0% Prob": 2.8488982804985934, "Min_60.0% Prob": 2.4417999494893876}}
{"hexsha": "2c25046f8a938d688e5173e9f517bd93b2b9eeb2", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn muentry_alloc_large(\n    mutator: *mut Mutator,\n    size: usize,\n    align: usize,\n) -> ObjectReference {\n    let m = mutator_ref(mutator);\n    let res = m.lo.alloc(size, align);\n    unsafe { res.to_object_reference() }\n}", "item_id": 6, "repo": "qinsoon/zebu", "file": "src/gc/src/lib.rs", "last_update_at": "2020-05-24T18:28:00+00:00", "question_id": "2c25046f8a938d688e5173e9f517bd93b2b9eeb2_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn muentry_alloc_large(\n    mutator: *mut Mutator,\n    size: usize,\n    align: usize,\n) -> ObjectReference {\n    let m = mutator_ref(mutator);\n    let res = m.lo.alloc(size, align);\n    unsafe { res.to_object_reference() }\n"]], "pred": {"ppl": 4.870697975158691, "ppl_lower": 6.247478485107422, "ppl/lowercase_ppl": -1.1572352419253307, "ppl/zlib": 0.009713111952225713, "Min_5.0% Prob": 10.707520961761475, "Min_10.0% Prob": 8.985064387321472, "Min_20.0% Prob": 6.341932983959422, "Min_30.0% Prob": 4.894298143386841, "Min_40.0% Prob": 3.8176120326799503, "Min_50.0% Prob": 3.1161261900912884, "Min_60.0% Prob": 2.656169881715494}}
{"hexsha": "35c25f8a0913567c1d2b5889c5a5ed641666c27b", "ext": "rs", "lang": "Rust", "content": "fn point_add_sub() {\n        let p0 = super::Point::origin();\n\n        assert_eq!(0, p0.x);\n        assert_eq!(0, p0.y);\n\n        let p1 = p(1, -1);\n\n        assert_eq!(1, p1.x);\n        assert_eq!(-1, p1.y);\n\n        let p2 = p1.add(1, 2);\n\n        assert_eq!(2, p2.x);\n        assert_eq!(1, p2.y);\n\n        let p2 = p2 + p2;\n\n        assert_eq!(4, p2.x);\n        assert_eq!(2, p2.y);\n\n        let p2 = p2 - p1;\n\n        assert_eq!(3, p2.x);\n        assert_eq!(3, p2.y);\n    }", "item_id": 0, "repo": "nielsutrecht/adventofrust", "file": "src/calc/point.rs", "last_update_at": "2020-12-03T03:25:24+00:00", "question_id": "35c25f8a0913567c1d2b5889c5a5ed641666c27b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn point_add_sub() {\n        let p0 = super::Point::origin();\n        assert_eq!(0, p0.x);\n        assert_eq!(0, p0.y);\n        let p1 = p(1, -1);\n        assert_eq!(1, p1.x);\n        assert_eq!(-1, p1.y);\n        let p2 = p1.add(1, 2);\n        assert_eq!(2, p2.x);\n        assert_eq!(1, p2.y);\n        let p2 = p2 + p2;\n        assert_eq!(4, p2.x);\n        assert_eq!(2, p2.y);\n        let p2 = p2 - p1;\n        assert_eq!(3, p2.x);\n        assert_eq!(3, p2.y);\n"]], "pred": {"ppl": 1.7396830320358276, "ppl_lower": 1.7680107355117798, "ppl/lowercase_ppl": -1.0291710667853944, "ppl/zlib": 0.0033762373849733993, "Min_5.0% Prob": 6.672479104995728, "Min_10.0% Prob": 4.5455889247712635, "Min_20.0% Prob": 2.6289946180443433, "Min_30.0% Prob": 1.841479534865357, "Min_40.0% Prob": 1.3855682087325774, "Min_50.0% Prob": 1.1061260754078697, "Min_60.0% Prob": 0.9267381138651986}}
{"hexsha": "643b923dc58756132022016e5b5e7cb8cbd18248", "ext": "rs", "lang": "Rust", "content": "pub fn main() {\n    let counter = Arc::from(Mutex::from(0));\n\n    let mut server = AIOServer::new(\"0.0.0.0:7878\".parse().unwrap(), move |_request| {\n        let lock = counter.clone();\n        let mut counter = lock.lock().unwrap();\n\n        let body = counter.to_string();\n        *counter += 1;\n\n        ResponseBuilder::empty_200()\n            .body(body.as_bytes())\n            .content_type(\"text/plain\")\n            .build()\n            .unwrap()\n    });\n\n    server.start();\n}", "item_id": 0, "repo": "LMatteo/mini-async-http", "file": "examples/counter.rs", "last_update_at": "2020-09-11T14:47:57+00:00", "question_id": "643b923dc58756132022016e5b5e7cb8cbd18248_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main() {\n    let counter = Arc::from(Mutex::from(0));\n    let mut server = AIOServer::new(\"0.0.0.0:7878\".parse().unwrap(), move |_request| {\n        let lock = counter.clone();\n        let mut counter = lock.lock().unwrap();\n        let body = counter.to_string();\n        *counter += 1;\n        ResponseBuilder::empty_200()\n            .body(body.as_bytes())\n            .content_type(\"text/plain\")\n            .build()\n            .unwrap()\n    });\n    server.start();\n"]], "pred": {"ppl": 2.5678279399871826, "ppl_lower": 3.1795847415924072, "ppl/lowercase_ppl": -1.2265923008896908, "ppl/zlib": 0.003572198416743887, "Min_5.0% Prob": 7.811327389308384, "Min_10.0% Prob": 5.705219809214274, "Min_20.0% Prob": 3.801898637125569, "Min_30.0% Prob": 2.8948028774365135, "Min_40.0% Prob": 2.2705529880139137, "Min_50.0% Prob": 1.871383231181603, "Min_60.0% Prob": 1.5638901574076505}}
{"hexsha": "ca93521b29d4b5d20540e715c94e80681eb6986e", "ext": "rs", "lang": "Rust", "content": "fn size_from_tuple_first_item_should_be_rows() {\n        // A nonzero value is used so we test non default behavior.\n        let expected_rows = 1;\n\n        let actual = Size::from((expected_rows, 0));\n\n        assert_eq!(expected_rows, actual.rows);\n    }", "item_id": 18, "repo": "j-richey/open_ttt_lib", "file": "src/board.rs", "last_update_at": "2020-10-05T11:37:09+00:00", "question_id": "ca93521b29d4b5d20540e715c94e80681eb6986e_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn size_from_tuple_first_item_should_be_rows() {\n        // A nonzero value is used so we test non default behavior.\n        let expected_rows = 1;\n        let actual = Size::from((expected_rows, 0));\n        assert_eq!(expected_rows, actual.rows);\n"]], "pred": {"ppl": 5.767534255981445, "ppl_lower": 6.15613317489624, "ppl/lowercase_ppl": -1.037211812025406, "ppl/zlib": 0.010430027681746602, "Min_5.0% Prob": 9.777345975240072, "Min_10.0% Prob": 8.204208987099785, "Min_20.0% Prob": 6.1754520257314045, "Min_30.0% Prob": 4.981890211934629, "Min_40.0% Prob": 4.130917506833231, "Min_50.0% Prob": 3.45290322181506, "Min_60.0% Prob": 2.9160732452539686}}
{"hexsha": "e7dbfb99a370bb801aa52bcdcce1fecf1606026c", "ext": "rs", "lang": "Rust", "content": "pub async fn bridge<TRng>(xors: Xors<TRng>, clear_stream: TcpStream, clear_stream_name: String, encrypted_stream: TcpStream, encrypted_stream_name: String) where\nTRng: CryptoRng + RngCore + Clone + Any {\n\n    let write_future = task::spawn(run_bridge_loop(\n        xors.write_xor,\n        clear_stream.clone(),\n        clear_stream_name.clone(),\n        encrypted_stream.clone(),\n        encrypted_stream_name.clone()));\n\n    let read_future = task::spawn(run_bridge_loop(\n        xors.read_xor,\n        encrypted_stream.clone(),\n        encrypted_stream_name.clone(),\n        clear_stream.clone(),\n        clear_stream_name.clone()));\n\n    match select(write_future, read_future).await {\n        Either::Left(r) => match r.0 {\n            Ok(()) => {\n                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Write, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;\n            },\n            Err(err) => {\n                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Both, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;\n                log::error!(\"{} -> {} ended in error: {}\", clear_stream_name, encrypted_stream_name, err);\n            }\n        },\n        Either::Right(r) => match r.0 {\n            Ok(()) => {\n                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Write, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;\n            },\n            Err(err) => {\n                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;\n                log::error!(\"{} -> {} ended in error: {}\", encrypted_stream_name, clear_stream_name, err);\n            }\n        },\n    };\n}", "item_id": 1, "repo": "GWBasic/bounce", "file": "src/bridge.rs", "last_update_at": "2020-11-30T21:06:02+00:00", "question_id": "e7dbfb99a370bb801aa52bcdcce1fecf1606026c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn bridge<TRng>(xors: Xors<TRng>, clear_stream: TcpStream, clear_stream_name: String, encrypted_stream: TcpStream, encrypted_stream_name: String) where\nTRng: CryptoRng + RngCore + Clone + Any {\n    let write_future = task::spawn(run_bridge_loop(\n        xors.write_xor,\n        clear_stream.clone(),\n        clear_stream_name.clone(),\n        encrypted_stream.clone(),\n        encrypted_stream_name.clone()));\n    let read_future = task::spawn(run_bridge_loop(\n        xors.read_xor,\n        encrypted_stream.clone(),\n        encrypted_stream_name.clone(),\n        clear_stream.clone(),\n        clear_stream_name.clone()));\n    match select(write_future, read_future).await {\n        Either::Left(r) => match r.0 {\n            Ok(()) => {\n                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Write, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;\n            },\n            Err(err) => {\n                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Both, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;\n                log::error!(\"{} -> {} ended in error: {}\", clear_stream_name, encrypted_stream_name, err);\n            }\n        },\n        Either::Right(r) => match r.0 {\n            Ok(()) => {\n                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Write, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;\n            },\n            Err(err) => {\n                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;\n                log::error!(\"{} -> {} ended in error: {}\", encrypted_stream_name, clear_stream_name, err);\n            }\n        },\n    };\n"]], "pred": {"ppl": 1.8078432083129883, "ppl_lower": 2.023958683013916, "ppl/lowercase_ppl": -1.190701256993421, "ppl/zlib": 0.0014234003296722854, "Min_5.0% Prob": 6.960259190312138, "Min_10.0% Prob": 4.9065815320721375, "Min_20.0% Prob": 2.8641308671837553, "Min_30.0% Prob": 1.9679870586270936, "Min_40.0% Prob": 1.4780831770510028, "Min_50.0% Prob": 1.1858855702337356, "Min_60.0% Prob": 0.9867616240971149}}
{"hexsha": "eae1227b582379cf3931a0bdc1d191a1375469e6", "ext": "rs", "lang": "Rust", "content": "pub fn init(\n    ipfs_path: &Path,\n    bits: NonZeroU16,\n    mut profiles: Vec<Profile>,\n) -> Result<String, InitializationError> {\n    use multibase::Base::Base64Pad;\n    use prost::Message;\n    use std::fs::OpenOptions;\n    use std::io::{BufWriter, Write};\n\n    match profiles.len() {\n        0 => profiles.push(Profile::Default),\n        1 => {}\n        _ => unimplemented!(\"Multiple profiles are currently unsupported!\"),\n    };\n\n    let bits = bits.get();\n\n    if !(2048..=16 * 1024).contains(&bits) {\n        // Ring won't accept less than a 2048 bit key.\n        return Err(InitializationError::InvalidRsaKeyLength(bits));\n    }\n\n    let pk = openssl::rsa::Rsa::generate(bits as u32)\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n\n    // sadly the pkcs8 to der functions are not yet exposed via the nicer interface\n    // https://github.com/sfackler/rust-openssl/issues/880\n    let pkcs8 = openssl::pkey::PKey::from_rsa(pk.clone())\n        .and_then(|pk| pk.private_key_to_pem_pkcs8())\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n\n    let mut pkcs8 = pem_to_der(&pkcs8);\n\n    let kp = ipfs::Keypair::rsa_from_pkcs8(&mut pkcs8)\n        .expect(\"Failed to turn pkcs#8 into libp2p::identity::Keypair\");\n\n    let peer_id = kp.public().to_peer_id().to_string();\n\n    // TODO: this part could be PR'd to rust-libp2p as they already have some public key\n    // import/export but probably not if ring does not support these required conversions.\n\n    let pkcs1 = pk\n        .private_key_to_der()\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n\n    let key_desc = keys_proto::PrivateKey {\n        r#type: keys_proto::KeyType::Rsa as i32,\n        data: pkcs1,\n    };\n\n    let private_key = {\n        let mut buf = Vec::with_capacity(key_desc.encoded_len());\n        key_desc\n            .encode(&mut buf)\n            .map_err(InitializationError::PrivateKeyEncodingFailed)?;\n        buf\n    };\n\n    let private_key = Base64Pad.encode(&private_key);\n\n    let api_addr = match profiles[0] {\n        Profile::Test => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(0u16)),\n        Profile::Default => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(4004u16)),\n    };\n\n    let config_contents = CompatibleConfigFile {\n        identity: Identity {\n            peer_id: peer_id.clone(),\n            private_key,\n        },\n        addresses: Addresses {\n            swarm: vec![\"/ip4/127.0.0.1/tcp/0\".parse().unwrap()],\n            api: api_addr,\n        },\n    };\n\n    let config_path = ipfs_path.join(\"config\");\n\n    let config_file = fs::create_dir_all(&ipfs_path)\n        .map_err(InitializationError::DirectoryCreationFailed)\n        .and_then(|_| {\n            OpenOptions::new()\n                .write(true)\n                .create_new(true)\n                .open(&config_path)\n                .map_err(InitializationError::ConfigCreationFailed)\n        })?;\n\n    let mut writer = BufWriter::new(config_file);\n\n    serde_json::to_writer_pretty(&mut writer, &config_contents)\n        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;\n\n    writer\n        .flush()\n        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;\n\n    Ok(peer_id)\n}", "item_id": 0, "repo": "ipfs-rust/rust-ipfs", "file": "http/src/config.rs", "last_update_at": "2020-05-12T16:49:12+00:00", "question_id": "eae1227b582379cf3931a0bdc1d191a1375469e6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init(\n    ipfs_path: &Path,\n    bits: NonZeroU16,\n    mut profiles: Vec<Profile>,\n) -> Result<String, InitializationError> {\n    use multibase::Base::Base64Pad;\n    use prost::Message;\n    use std::fs::OpenOptions;\n    use std::io::{BufWriter, Write};\n    match profiles.len() {\n        0 => profiles.push(Profile::Default),\n        1 => {}\n        _ => unimplemented!(\"Multiple profiles are currently unsupported!\"),\n    };\n    let bits = bits.get();\n    if !(2048..=16 * 1024).contains(&bits) {\n        // Ring won't accept less than a 2048 bit key.\n        return Err(InitializationError::InvalidRsaKeyLength(bits));\n    }\n    let pk = openssl::rsa::Rsa::generate(bits as u32)\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n    // sadly the pkcs8 to der functions are not yet exposed via the nicer interface\n    // https://github.com/sfackler/rust-openssl/issues/880\n    let pkcs8 = openssl::pkey::PKey::from_rsa(pk.clone())\n        .and_then(|pk| pk.private_key_to_pem_pkcs8())\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n    let mut pkcs8 = pem_to_der(&pkcs8);\n    let kp = ipfs::Keypair::rsa_from_pkcs8(&mut pkcs8)\n        .expect(\"Failed to turn pkcs#8 into libp2p::identity::Keypair\");\n    let peer_id = kp.public().to_peer_id().to_string();\n    // TODO: this part could be PR'd to rust-libp2p as they already have some public key\n    // import/export but probably not if ring does not support these required conversions.\n    let pkcs1 = pk\n        .private_key_to_der()\n        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;\n    let key_desc = keys_proto::PrivateKey {\n        r#type: keys_proto::KeyType::Rsa as i32,\n        data: pkcs1,\n    };\n    let private_key = {\n        let mut buf = Vec::with_capacity(key_desc.encoded_len());\n        key_desc\n            .encode(&mut buf)\n            .map_err(InitializationError::PrivateKeyEncodingFailed)?;\n        buf\n    };\n    let private_key = Base64Pad.encode(&private_key);\n    let api_addr = match profiles[0] {\n        Profile::Test => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(0u16)),\n        Profile::Default => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(4004u16)),\n    };\n    let config_contents = CompatibleConfigFile {\n        identity: Identity {\n            peer_id: peer_id.clone(),\n            private_key,\n        },\n        addresses: Addresses {\n            swarm: vec![\"/ip4/127.0.0.1/tcp/0\".parse().unwrap()],\n            api: api_addr,\n        },\n    };\n    let config_path = ipfs_path.join(\"config\");\n    let config_file = fs::create_dir_all(&ipfs_path)\n        .map_err(InitializationError::DirectoryCreationFailed)\n        .and_then(|_| {\n            OpenOptions::new()\n                .write(true)\n                .create_new(true)\n                .open(&config_path)\n                .map_err(InitializationError::ConfigCreationFailed)\n        })?;\n    let mut writer = BufWriter::new(config_file);\n    serde_json::to_writer_pretty(&mut writer, &config_contents)\n        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;\n    writer\n        .flush()\n        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;\n    Ok(peer_id)\n"]], "pred": {"ppl": 2.255772113800049, "ppl_lower": 2.6800425052642822, "ppl/lowercase_ppl": -1.2118524492661664, "ppl/zlib": 0.0006167492912411778, "Min_5.0% Prob": 6.933233868842032, "Min_10.0% Prob": 5.212139552714778, "Min_20.0% Prob": 3.5034703699981464, "Min_30.0% Prob": 2.59057547444222, "Min_40.0% Prob": 2.006695836235958, "Min_50.0% Prob": 1.6224119007776978, "Min_60.0% Prob": 1.3562523568668943}}
{"hexsha": "74b154db2512ce302700a7de694b2faf7d8ee6c7", "ext": "rs", "lang": "Rust", "content": "fn after_mount(url: Url, orders: &mut impl Orders<Msg>) -> AfterMount<Model> {\n    // try to rehydrate stored jwt\n    orders.send_msg(Msg::Rehydrate);\n    let mut m: Model = Default::default();\n\n    // same code as `routes`\n    if url.path.is_empty() {\n        m.page = Pages::Home;\n    }\n\n    m.page = match url.path[0].as_ref() {\n        \"meals\" => match url.path.get(1).as_ref() {\n            Some(page) => match page.as_ref() {\n                \"create\" => Pages::CreateMeal,\n                _ => match page.parse::<Uuid>() {\n                    Ok(m_id) => match url.path.get(2).as_ref() {\n                        Some(i) => match i.as_ref() {\n                            \"edit\" => Pages::EditMeal { meal_id: m_id },\n                            _ => Pages::ViewSpecificMeal { meal_id: m_id },\n                        },\n                        None => Pages::ViewSpecificMeal { meal_id: m_id },\n                    },\n                    Err(_) => Pages::Meals,\n                },\n            },\n            None => Pages::Meals,\n        },\n        \"login\" => Pages::Login,\n        _ => Pages::Home,\n    };\n\n    // This duplicates requests on a new page load or refresh. Figure out why.\n    // orders.send_msg(routes(url).unwrap());\n    AfterMount::new(m)\n}", "item_id": 4, "repo": "matthewkmayer/refeed-rampage", "file": "frontend/src/lib.rs", "last_update_at": "2020-08-06T09:52:08+00:00", "question_id": "74b154db2512ce302700a7de694b2faf7d8ee6c7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn after_mount(url: Url, orders: &mut impl Orders<Msg>) -> AfterMount<Model> {\n    // try to rehydrate stored jwt\n    orders.send_msg(Msg::Rehydrate);\n    let mut m: Model = Default::default();\n    // same code as `routes`\n    if url.path.is_empty() {\n        m.page = Pages::Home;\n    }\n    m.page = match url.path[0].as_ref() {\n        \"meals\" => match url.path.get(1).as_ref() {\n            Some(page) => match page.as_ref() {\n                \"create\" => Pages::CreateMeal,\n                _ => match page.parse::<Uuid>() {\n                    Ok(m_id) => match url.path.get(2).as_ref() {\n                        Some(i) => match i.as_ref() {\n                            \"edit\" => Pages::EditMeal { meal_id: m_id },\n                            _ => Pages::ViewSpecificMeal { meal_id: m_id },\n                        },\n                        None => Pages::ViewSpecificMeal { meal_id: m_id },\n                    },\n                    Err(_) => Pages::Meals,\n                },\n            },\n            None => Pages::Meals,\n        },\n        \"login\" => Pages::Login,\n        _ => Pages::Home,\n    };\n    // This duplicates requests on a new page load or refresh. Figure out why.\n    // orders.send_msg(routes(url).unwrap());\n    AfterMount::new(m)\n"]], "pred": {"ppl": 2.3936893939971924, "ppl_lower": 2.9532370567321777, "ppl/lowercase_ppl": -1.240670705351634, "ppl/zlib": 0.0017849403991650487, "Min_5.0% Prob": 7.809146547317505, "Min_10.0% Prob": 5.887660700082779, "Min_20.0% Prob": 3.8916562989354135, "Min_30.0% Prob": 2.824400012691816, "Min_40.0% Prob": 2.166001018323004, "Min_50.0% Prob": 1.7449400478228927, "Min_60.0% Prob": 1.4573684277633825}}
{"hexsha": "9576b435cabfbb8be880b325ec7f0f9b19b2c5ca", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"MEFF-Music\")\n        .version(\"0.1.0\")\n        .arg(\n            Arg::with_name(\"own-name\")\n                .short(\"n\")\n                .takes_value(true)\n                .required(true)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(\"port\")\n                .short(\"p\")\n                .takes_value(true)\n                .required(false)\n                .index(2),\n        )\n        .arg(\n            Arg::with_name(\"ip-address\")\n                .short(\"ip\")\n                .takes_value(true)\n                .required(false)\n                .index(3),\n        )\n        .get_matches();\n    let name = matches.value_of(\"own-name\").unwrap_or(\"Fridolin\");\n    let port = matches.value_of(\"port\").unwrap_or(\"34521\");\n    if matches.is_present(\"ip-address\") {\n        // TODO: Join existing p2p network on given ip address\n        let addr;\n        match matches.value_of(\"ip-address\") {\n            Some(ip) => {\n                addr = match ip.parse::<SocketAddr>() {\n                    Ok(socket_addr) => socket_addr,\n                    Err(_) => {\n                        //  error!(\"Could not parse ip address of remote Peer\");\n                        return;\n                    }\n                }\n            }\n            None => {\n                //  error!(\"Could not parse ip-address\");\n                return;\n            }\n        }\n        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };\n        let appl_rc = Arc::new(Mutex::new(appl.clone()));\n        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), Some(addr)) {\n            Ok(p) => p,\n            Err(e) => {\n                println!(\"{}\", e);\n                return;\n            } // error!(\"Could not join network {:?}\", e);\n        };\n        startup(peer, appl_rc);\n    } else {\n        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };\n        let appl_rc = Arc::new(Mutex::new(appl.clone()));\n        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), None ) {\n            Ok(p) => p,\n            Err(e) => {\n                println!(\"{}\", e);\n                return;\n            } // error!(\"Could not join network {:?}\", e);\n        };\n        startup(peer, appl_rc);\n    }\n}", "item_id": 0, "repo": "marcel-baur/rust-project", "file": "shell-app/src/main.rs", "last_update_at": "2020-12-08T21:47:59+00:00", "question_id": "9576b435cabfbb8be880b325ec7f0f9b19b2c5ca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let matches = App::new(\"MEFF-Music\")\n        .version(\"0.1.0\")\n        .arg(\n            Arg::with_name(\"own-name\")\n                .short(\"n\")\n                .takes_value(true)\n                .required(true)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(\"port\")\n                .short(\"p\")\n                .takes_value(true)\n                .required(false)\n                .index(2),\n        )\n        .arg(\n            Arg::with_name(\"ip-address\")\n                .short(\"ip\")\n                .takes_value(true)\n                .required(false)\n                .index(3),\n        )\n        .get_matches();\n    let name = matches.value_of(\"own-name\").unwrap_or(\"Fridolin\");\n    let port = matches.value_of(\"port\").unwrap_or(\"34521\");\n    if matches.is_present(\"ip-address\") {\n        // TODO: Join existing p2p network on given ip address\n        let addr;\n        match matches.value_of(\"ip-address\") {\n            Some(ip) => {\n                addr = match ip.parse::<SocketAddr>() {\n                    Ok(socket_addr) => socket_addr,\n                    Err(_) => {\n                        //  error!(\"Could not parse ip address of remote Peer\");\n                        return;\n                    }\n                }\n            }\n            None => {\n                //  error!(\"Could not parse ip-address\");\n                return;\n            }\n        }\n        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };\n        let appl_rc = Arc::new(Mutex::new(appl.clone()));\n        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), Some(addr)) {\n            Ok(p) => p,\n            Err(e) => {\n                println!(\"{}\", e);\n                return;\n            } // error!(\"Could not join network {:?}\", e);\n        };\n        startup(peer, appl_rc);\n    } else {\n        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };\n        let appl_rc = Arc::new(Mutex::new(appl.clone()));\n        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), None ) {\n            Ok(p) => p,\n            Err(e) => {\n                println!(\"{}\", e);\n                return;\n            } // error!(\"Could not join network {:?}\", e);\n        };\n        startup(peer, appl_rc);\n    }\n"]], "pred": {"ppl": 1.858327865600586, "ppl_lower": 2.0085391998291016, "ppl/lowercase_ppl": -1.1254372751624957, "ppl/zlib": 0.0010208848210807788, "Min_5.0% Prob": 7.011879082882043, "Min_10.0% Prob": 4.9433659012637925, "Min_20.0% Prob": 2.9541838149229687, "Min_30.0% Prob": 2.0460066046233814, "Min_40.0% Prob": 1.5433468875164786, "Min_50.0% Prob": 1.2394240846254971, "Min_60.0% Prob": 1.032283283509659}}
{"hexsha": "a6f149c9ca62b1df3e2b3ff99125c7ffcde62cf6", "ext": "rs", "lang": "Rust", "content": "fn test_categorize_bookings() {\n        //given\n        let bookings = generate_test_bookings();\n        let rules = generate_test_rules();\n\n        //when\n        let categorized_bookings = categorize_bookings(bookings, &rules);\n\n        //then\n        let categories = categorized_bookings\n            .into_iter()\n            .map(|booking| booking.category)\n            .collect_vec();\n\n        assert!(categories.contains(&\"Multiple Matches\".to_owned()));\n        assert!(categories.contains(&\"Andere Ausgaben\".to_owned()));\n        assert!(categories.contains(&\"Warmmiete\".to_owned()));\n    }", "item_id": 0, "repo": "seriq/expense-categorizer", "file": "src/categorizer.rs", "last_update_at": "2020-12-03T23:06:57+00:00", "question_id": "a6f149c9ca62b1df3e2b3ff99125c7ffcde62cf6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_categorize_bookings() {\n        //given\n        let bookings = generate_test_bookings();\n        let rules = generate_test_rules();\n        //when\n        let categorized_bookings = categorize_bookings(bookings, &rules);\n        //then\n        let categories = categorized_bookings\n            .into_iter()\n            .map(|booking| booking.category)\n            .collect_vec();\n        assert!(categories.contains(&\"Multiple Matches\".to_owned()));\n        assert!(categories.contains(&\"Andere Ausgaben\".to_owned()));\n        assert!(categories.contains(&\"Warmmiete\".to_owned()));\n"]], "pred": {"ppl": 2.538703441619873, "ppl_lower": 2.6592020988464355, "ppl/lowercase_ppl": -1.0497745358915305, "ppl/zlib": 0.004068355871826342, "Min_5.0% Prob": 7.967420399188995, "Min_10.0% Prob": 6.372050493955612, "Min_20.0% Prob": 4.150273221911806, "Min_30.0% Prob": 2.9684733366966247, "Min_40.0% Prob": 2.3083329196229125, "Min_50.0% Prob": 1.8601468952305347, "Min_60.0% Prob": 1.5527692955359818}}
{"hexsha": "fcd05303490c8be808ec77e0a51092e507f2c099", "ext": "rs", "lang": "Rust", "content": "fn get_input() -> std::io::Result<String> {\n    let mut file = File::open(\"08.txt\")?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n\n    Ok(contents)\n}", "item_id": 0, "repo": "yishn/adventofcode2016", "file": "2015/08.rs", "last_update_at": "2020-11-05T15:50:31+00:00", "question_id": "fcd05303490c8be808ec77e0a51092e507f2c099_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_input() -> std::io::Result<String> {\n    let mut file = File::open(\"08.txt\")?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n"]], "pred": {"ppl": 1.7830452919006348, "ppl_lower": 3.1324079036712646, "ppl/lowercase_ppl": -1.9743335803116209, "ppl/zlib": 0.0041308767188134735, "Min_5.0% Prob": 6.3121592203776045, "Min_10.0% Prob": 4.946148196856181, "Min_20.0% Prob": 2.7806777770702658, "Min_30.0% Prob": 1.9547225472174192, "Min_40.0% Prob": 1.4404961471804059, "Min_50.0% Prob": 1.1734978626482189, "Min_60.0% Prob": 0.9636130787145633}}
{"hexsha": "740b6f7e0e1fa9f5e293e0d3be76047f420fc794", "ext": "rs", "lang": "Rust", "content": "fn insert_axis_f() {\n    defmac!(test_insert_f orig, index, new => {\n        let res = orig.insert_axis(Axis(index));\n        assert_eq!(res, new);\n        assert!(res.t().is_standard_layout());\n    });\n\n    test_insert_f!(Array0::from_shape_vec(().f(), vec![1]).unwrap(), 0, arr1(&[1]));\n    assert!(::std::panic::catch_unwind(\n        || Array0::from_shape_vec(().f(), vec![1]).unwrap().insert_axis(Axis(1))).is_err());\n\n    test_insert_f!(Array1::<u8>::zeros((3).f()), 0, Array2::<u8>::zeros((1, 3)));\n    test_insert_f!(Array1::<u8>::zeros((3).f()), 1, Array2::<u8>::zeros((3, 1)));\n    assert!(::std::panic::catch_unwind(\n        || Array1::<u8>::zeros((3).f()).insert_axis(Axis(2))).is_err());\n\n    test_insert_f!(Array3::<u8>::zeros((3, 4, 5).f()), 1, Array4::<u8>::zeros((3, 1, 4, 5)));\n    assert!(::std::panic::catch_unwind(\n        || Array3::<u8>::zeros((3, 4, 5).f()).insert_axis(Axis(4))).is_err());\n\n    test_insert_f!(ArrayD::<u8>::zeros(vec![3, 4, 5].f()), 1,\n                   ArrayD::<u8>::zeros(vec![3, 1, 4, 5]));\n    assert!(::std::panic::catch_unwind(\n        || ArrayD::<u8>::zeros(vec![3, 4, 5].f()).insert_axis(Axis(4))).is_err());\n}", "item_id": 47, "repo": "mfarrugi/cargo-raze-example-stdx", "file": "cargo/vendor/ndarray-0.10.13/tests/array.rs", "last_update_at": "2020-07-14T21:08:34+00:00", "question_id": "740b6f7e0e1fa9f5e293e0d3be76047f420fc794_47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn insert_axis_f() {\n    defmac!(test_insert_f orig, index, new => {\n        let res = orig.insert_axis(Axis(index));\n        assert_eq!(res, new);\n        assert!(res.t().is_standard_layout());\n    });\n    test_insert_f!(Array0::from_shape_vec(().f(), vec![1]).unwrap(), 0, arr1(&[1]));\n    assert!(::std::panic::catch_unwind(\n        || Array0::from_shape_vec(().f(), vec![1]).unwrap().insert_axis(Axis(1))).is_err());\n    test_insert_f!(Array1::<u8>::zeros((3).f()), 0, Array2::<u8>::zeros((1, 3)));\n    test_insert_f!(Array1::<u8>::zeros((3).f()), 1, Array2::<u8>::zeros((3, 1)));\n    assert!(::std::panic::catch_unwind(\n        || Array1::<u8>::zeros((3).f()).insert_axis(Axis(2))).is_err());\n    test_insert_f!(Array3::<u8>::zeros((3, 4, 5).f()), 1, Array4::<u8>::zeros((3, 1, 4, 5)));\n    assert!(::std::panic::catch_unwind(\n        || Array3::<u8>::zeros((3, 4, 5).f()).insert_axis(Axis(4))).is_err());\n    test_insert_f!(ArrayD::<u8>::zeros(vec![3, 4, 5].f()), 1,\n                   ArrayD::<u8>::zeros(vec![3, 1, 4, 5]));\n    assert!(::std::panic::catch_unwind(\n        || ArrayD::<u8>::zeros(vec![3, 4, 5].f()).insert_axis(Axis(4))).is_err());\n"]], "pred": {"ppl": 1.6330205202102661, "ppl_lower": 1.7222740650177002, "ppl/lowercase_ppl": -1.1085048198806, "ppl/zlib": 0.0014816658002051325, "Min_5.0% Prob": 6.255863964557648, "Min_10.0% Prob": 4.117412810422937, "Min_20.0% Prob": 2.3661538052438487, "Min_30.0% Prob": 1.6215848044661068, "Min_40.0% Prob": 1.2256007903073, "Min_50.0% Prob": 0.9817106285558856, "Min_60.0% Prob": 0.8181858531177593}}
{"hexsha": "5bd7dd325a3f42cc36d54f7d84f6d54d0c589ff7", "ext": "rs", "lang": "Rust", "content": "fn total_up(input: &String) -> usize {\n    let mut total = 0;\n    for number in input.lines() {\n        total += match number.trim().parse::<usize>() {\n            Ok(number) => number,\n            _ => continue,\n        }\n    }\n    total\n}", "item_id": 1, "repo": "XAMPPRocky/numcount", "file": "src/main.rs", "last_update_at": "2020-01-16T12:04:07+00:00", "question_id": "5bd7dd325a3f42cc36d54f7d84f6d54d0c589ff7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn total_up(input: &String) -> usize {\n    let mut total = 0;\n    for number in input.lines() {\n        total += match number.trim().parse::<usize>() {\n            Ok(number) => number,\n            _ => continue,\n        }\n    }\n    total\n"]], "pred": {"ppl": 2.4786605834960938, "ppl_lower": 3.170300006866455, "ppl/lowercase_ppl": -1.2711280454626475, "ppl/zlib": 0.005894274850501611, "Min_5.0% Prob": 8.765511194864908, "Min_10.0% Prob": 6.378560679299491, "Min_20.0% Prob": 4.070049782594045, "Min_30.0% Prob": 2.971470528028228, "Min_40.0% Prob": 2.242478715876738, "Min_50.0% Prob": 1.830430374254246, "Min_60.0% Prob": 1.50892943288717}}
{"hexsha": "688e72049589907b30b8055c4ce17ed68d95cad1", "ext": "rs", "lang": "Rust", "content": "fn test_error_kind_wo_arg() {\n    #[derive(Debug, Error)]\n    enum E {\n        #[error_kind(\"custom\")]\n        Custom,\n    }\n\n    assert_eq!(E::Custom.to_string().as_str(), \"custom\");\n}", "item_id": 0, "repo": "and-cesbo/error-rules", "file": "tests/macro.rs", "last_update_at": "2020-12-13T19:06:07+00:00", "question_id": "688e72049589907b30b8055c4ce17ed68d95cad1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_error_kind_wo_arg() {\n    #[derive(Debug, Error)]\n    enum E {\n        #[error_kind(\"custom\")]\n        Custom,\n    }\n    assert_eq!(E::Custom.to_string().as_str(), \"custom\");\n"]], "pred": {"ppl": 3.31250262260437, "ppl_lower": 4.257564067840576, "ppl/lowercase_ppl": -1.2095619637105472, "ppl/zlib": 0.00874236483972006, "Min_5.0% Prob": 8.594918886820475, "Min_10.0% Prob": 7.1275208791097, "Min_20.0% Prob": 5.142879027586717, "Min_30.0% Prob": 3.693135344982147, "Min_40.0% Prob": 2.9653835743665695, "Min_50.0% Prob": 2.393152080702059, "Min_60.0% Prob": 1.9952960044145585}}
{"hexsha": "818ad2ea6f5b99878c825b782daa13bf632c8773", "ext": "rs", "lang": "Rust", "content": "async fn api_server_publish_dummy() {\n    let prover_timeout = time::Duration::from_secs(1);\n    let rounds_interval = time::Duration::from_secs(10);\n    let addr = spawn_server(prover_timeout, rounds_interval).await;\n\n    let client = reqwest::Client::new();\n    let res = client\n        .post(&format!(\"http://{}/publish\", &addr))\n        .json(&client::PublishReq {\n            block: 1,\n            proof: EncodedProofPlonk::default(),\n        })\n        .send()\n        .await\n        .expect(\"failed to send publish request\");\n\n    assert_eq!(res.status(), reqwest::StatusCode::OK);\n}", "item_id": 4, "repo": "EPICKnowledgeSociety/zksync", "file": "core/bin/server/tests/prover_server.rs", "last_update_at": "2020-11-26T02:05:08+00:00", "question_id": "818ad2ea6f5b99878c825b782daa13bf632c8773_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn api_server_publish_dummy() {\n    let prover_timeout = time::Duration::from_secs(1);\n    let rounds_interval = time::Duration::from_secs(10);\n    let addr = spawn_server(prover_timeout, rounds_interval).await;\n    let client = reqwest::Client::new();\n    let res = client\n        .post(&format!(\"http://{}/publish\", &addr))\n        .json(&client::PublishReq {\n            block: 1,\n            proof: EncodedProofPlonk::default(),\n        })\n        .send()\n        .await\n        .expect(\"failed to send publish request\");\n    assert_eq!(res.status(), reqwest::StatusCode::OK);\n"]], "pred": {"ppl": 3.005244255065918, "ppl_lower": 5.138092517852783, "ppl/lowercase_ppl": -1.4874074114386056, "ppl/zlib": 0.003460247948326193, "Min_5.0% Prob": 8.832159996032715, "Min_10.0% Prob": 7.1787956555684405, "Min_20.0% Prob": 4.668775482310189, "Min_30.0% Prob": 3.4152030966900013, "Min_40.0% Prob": 2.686688963737753, "Min_50.0% Prob": 2.175052813448749, "Min_60.0% Prob": 1.8324962399831606}}
{"hexsha": "319d241ba710f1536ec13495d411ac51c407e1ae", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), ParseIntError> {\n    let (stats_tx, stats_rx) = unbounded::<stats::Bucket>();\n    let cmd = args::Cmd::new();\n\n    let mut client = udp::Client::new(stats_tx.clone());\n    let mut server = udp::Server::new(stats_tx.clone());\n    let mut stats = stats::Stats::new(stats_rx);\n\n    let mode = cmd.init(&mut client, &mut server, &mut stats)?;\n\n    match mode {\n        0 => {\n            println!(\"cput server mode enabled\");\n            thread::spawn(move || server.start());\n        }\n        1 => {\n            println!(\"cput client mode enabled\");\n            thread::spawn(move || client.start());\n        }\n        _ => {\n            println!(\"cput loopback mode enabled\");\n            thread::spawn(move || server.start());\n            thread::spawn(move || client.start());\n        }\n    };\n\n    stats.start().unwrap();\n\n    Ok(())\n}", "item_id": 0, "repo": "mehrdadrad/cput", "file": "src/main.rs", "last_update_at": "2020-05-13T00:11:47+00:00", "question_id": "319d241ba710f1536ec13495d411ac51c407e1ae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), ParseIntError> {\n    let (stats_tx, stats_rx) = unbounded::<stats::Bucket>();\n    let cmd = args::Cmd::new();\n    let mut client = udp::Client::new(stats_tx.clone());\n    let mut server = udp::Server::new(stats_tx.clone());\n    let mut stats = stats::Stats::new(stats_rx);\n    let mode = cmd.init(&mut client, &mut server, &mut stats)?;\n    match mode {\n        0 => {\n            println!(\"cput server mode enabled\");\n            thread::spawn(move || server.start());\n        }\n        1 => {\n            println!(\"cput client mode enabled\");\n            thread::spawn(move || client.start());\n        }\n        _ => {\n            println!(\"cput loopback mode enabled\");\n            thread::spawn(move || server.start());\n            thread::spawn(move || client.start());\n        }\n    };\n    stats.start().unwrap();\n    Ok(())\n"]], "pred": {"ppl": 2.426494836807251, "ppl_lower": 2.8373913764953613, "ppl/lowercase_ppl": -1.176476658117561, "ppl/zlib": 0.002814119879445739, "Min_5.0% Prob": 8.19968855381012, "Min_10.0% Prob": 6.217072792053223, "Min_20.0% Prob": 3.9298493581659653, "Min_30.0% Prob": 2.858820137616835, "Min_40.0% Prob": 2.1948406186466123, "Min_50.0% Prob": 1.765795254817931, "Min_60.0% Prob": 1.481256130510588}}
{"hexsha": "3ca056d372b38f8b3c1e7c3d1f5bd313aae131be", "ext": "rs", "lang": "Rust", "content": "fn multi_thread_load_std(b: &mut Bencher) {\n    let v = Arc::new(StdAtomicImmut::new(vec![0, 1, 2]));\n    let thread_count = 8;\n    let barrier = Arc::new(Barrier::new(thread_count));\n    for _ in 0..thread_count {\n        let v = Arc::clone(&v);\n        let barrier = Arc::clone(&barrier);\n        thread::spawn(move || {\n            while !v.load().is_empty() {}\n            barrier.wait();\n        });\n    }\n    thread::sleep(Duration::from_millis(10));\n    b.iter(|| {\n        test::black_box(v.load());\n    });\n    v.store(vec![]);\n    barrier.wait();\n    assert_eq!(Arc::strong_count(&v.load()), 2);\n}", "item_id": 1, "repo": "sile/atomic_immut", "file": "benches/lib.rs", "last_update_at": "2020-02-17T02:43:49+00:00", "question_id": "3ca056d372b38f8b3c1e7c3d1f5bd313aae131be_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn multi_thread_load_std(b: &mut Bencher) {\n    let v = Arc::new(StdAtomicImmut::new(vec![0, 1, 2]));\n    let thread_count = 8;\n    let barrier = Arc::new(Barrier::new(thread_count));\n    for _ in 0..thread_count {\n        let v = Arc::clone(&v);\n        let barrier = Arc::clone(&barrier);\n        thread::spawn(move || {\n            while !v.load().is_empty() {}\n            barrier.wait();\n        });\n    }\n    thread::sleep(Duration::from_millis(10));\n    b.iter(|| {\n        test::black_box(v.load());\n    });\n    v.store(vec![]);\n    barrier.wait();\n    assert_eq!(Arc::strong_count(&v.load()), 2);\n"]], "pred": {"ppl": 2.1231493949890137, "ppl_lower": 2.604382038116455, "ppl/lowercase_ppl": -1.2713437725760768, "ppl/zlib": 0.002484820297029317, "Min_5.0% Prob": 7.109166058627042, "Min_10.0% Prob": 5.493554516272112, "Min_20.0% Prob": 3.409714272287157, "Min_30.0% Prob": 2.4393211821121956, "Min_40.0% Prob": 1.8574248337911234, "Min_50.0% Prob": 1.505280669944893, "Min_60.0% Prob": 1.2533964914649174}}
{"hexsha": "70a37d1c0571f6c3accfbb97552c384895700dd0", "ext": "rs", "lang": "Rust", "content": "fn t_compute_alm_infeasibility() {\n        let (tolerance, nx, n1, n2, lbfgs_mem) = (1e-6, 5, 4, 0, 3);\n        let panoc_cache = PANOCCache::new(nx, tolerance, lbfgs_mem);\n        let mut alm_cache = AlmCache::new(panoc_cache, n1, n2);\n        let psi = void_parameteric_cost;\n        let d_psi = void_parameteric_gradient;\n        let f1 = Some(void_mapping);\n        let set_c = Some(Ball2::new(None, 1.0));\n        let bounds = Ball2::new(None, 10.0);\n        let set_y = Some(Ball2::new(None, 2.0));\n        let alm_problem = AlmProblem::new(bounds, set_c, set_y, psi, d_psi, f1, NO_MAPPING, n1, n2);\n        // Set y0 = [2, 3, 4, 10]\n        let mut alm_optimizer = AlmOptimizer::new(&mut alm_cache, alm_problem)\n            .with_initial_penalty(10.0)\n            .with_initial_lagrange_multipliers(&vec![2., 3., 4., 10.]);\n        {\n            let cache = &mut alm_optimizer.alm_cache;\n            // Set y1 = [10, 20, 11, 100]\n            if let Some(y_plus) = &mut cache.y_plus {\n                y_plus.copy_from_slice(&vec![10., 20., 11., 100.]);\n            }\n        }\n        assert!(alm_optimizer.compute_alm_infeasibility().is_ok());\n        unit_test_utils::assert_nearly_equal(\n            92.2062904578641,\n            alm_optimizer.alm_cache.delta_y_norm_plus,\n            1e-10,\n            1e-12,\n            \"delta_y_plus is wrong\",\n        );\n    }", "item_id": 4, "repo": "gmsanchez/optimization-engine", "file": "src/alm/alm_optimizer.rs", "last_update_at": "2020-05-26T03:40:05+00:00", "question_id": "70a37d1c0571f6c3accfbb97552c384895700dd0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn t_compute_alm_infeasibility() {\n        let (tolerance, nx, n1, n2, lbfgs_mem) = (1e-6, 5, 4, 0, 3);\n        let panoc_cache = PANOCCache::new(nx, tolerance, lbfgs_mem);\n        let mut alm_cache = AlmCache::new(panoc_cache, n1, n2);\n        let psi = void_parameteric_cost;\n        let d_psi = void_parameteric_gradient;\n        let f1 = Some(void_mapping);\n        let set_c = Some(Ball2::new(None, 1.0));\n        let bounds = Ball2::new(None, 10.0);\n        let set_y = Some(Ball2::new(None, 2.0));\n        let alm_problem = AlmProblem::new(bounds, set_c, set_y, psi, d_psi, f1, NO_MAPPING, n1, n2);\n        // Set y0 = [2, 3, 4, 10]\n        let mut alm_optimizer = AlmOptimizer::new(&mut alm_cache, alm_problem)\n            .with_initial_penalty(10.0)\n            .with_initial_lagrange_multipliers(&vec![2., 3., 4., 10.]);\n        {\n            let cache = &mut alm_optimizer.alm_cache;\n            // Set y1 = [10, 20, 11, 100]\n            if let Some(y_plus) = &mut cache.y_plus {\n                y_plus.copy_from_slice(&vec![10., 20., 11., 100.]);\n            }\n        }\n        assert!(alm_optimizer.compute_alm_infeasibility().is_ok());\n        unit_test_utils::assert_nearly_equal(\n            92.2062904578641,\n            alm_optimizer.alm_cache.delta_y_norm_plus,\n            1e-10,\n            1e-12,\n            \"delta_y_plus is wrong\",\n        );\n"]], "pred": {"ppl": 2.8884263038635254, "ppl_lower": 3.16018009185791, "ppl/lowercase_ppl": -1.0847706162055974, "ppl/zlib": 0.0018608979338212098, "Min_5.0% Prob": 7.916372511121962, "Min_10.0% Prob": 6.09092735377225, "Min_20.0% Prob": 4.234077609337128, "Min_30.0% Prob": 3.259325580065509, "Min_40.0% Prob": 2.568755533512648, "Min_50.0% Prob": 2.0913873998274046, "Min_60.0% Prob": 1.7616585907680136}}
{"hexsha": "f31d53b497e1ea5034a1388cecb4dfd0f3ef1182", "ext": "rs", "lang": "Rust", "content": "fn decrease_lives(game_state : &mut GameState, game_time : GameTime) {\n    let ball : &mut Ball = &mut game_state.ball;\n\n    game_state.lives = max(game_state.lives, 1) - 1;\n\n    if game_state.lives != 0 {\n        ball.reset_position();\n    }\n    else {\n        game_state.stage = GameStage::GameOver;\n        game_state.game_over_time = game_time.real_time;\n    }\n}", "item_id": 1, "repo": "ciechowoj/breakout", "file": "breakout/src/game/mod.rs", "last_update_at": "2020-08-07T08:51:41+00:00", "question_id": "f31d53b497e1ea5034a1388cecb4dfd0f3ef1182_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decrease_lives(game_state : &mut GameState, game_time : GameTime) {\n    let ball : &mut Ball = &mut game_state.ball;\n    game_state.lives = max(game_state.lives, 1) - 1;\n    if game_state.lives != 0 {\n        ball.reset_position();\n    }\n    else {\n        game_state.stage = GameStage::GameOver;\n        game_state.game_over_time = game_time.real_time;\n    }\n"]], "pred": {"ppl": 2.6545064449310303, "ppl_lower": 3.0415992736816406, "ppl/lowercase_ppl": -1.1394350772802229, "ppl/zlib": 0.005138203899816805, "Min_5.0% Prob": 7.502683162689209, "Min_10.0% Prob": 5.882825282903818, "Min_20.0% Prob": 4.040984795643733, "Min_30.0% Prob": 2.9849942073225977, "Min_40.0% Prob": 2.3727205047067605, "Min_50.0% Prob": 1.9208336997388014, "Min_60.0% Prob": 1.6253822024911642}}
{"hexsha": "31c31cf725f85efbe01a963ef9302e300570b386", "ext": "rs", "lang": "Rust", "content": "fn oxygen_spread_time(grid: &HashMap<(i64, i64), Tile>) -> i64 {\n    let mut queue: VecDeque<(i64, i64)> = VecDeque::new();\n    let mut discovered: HashSet<(i64, i64)> = HashSet::new();\n    let mut distances: HashMap<(i64, i64), i64> = HashMap::new();\n\n    let start_pos = *grid\n        .iter()\n        .filter(|(_, v)| **v == Tile::Oxygen)\n        .map(|(k, _)| k)\n        .next()\n        .unwrap();\n\n    discovered.insert(start_pos);\n    queue.push_back(start_pos);\n    distances.insert(start_pos, 0);\n    while !queue.is_empty() {\n        let v = queue.pop_front().unwrap();\n        for npos in vec![\n            (v.0 + 1, v.1),\n            (v.0 - 1, v.1),\n            (v.0, v.1 - 1),\n            (v.0, v.1 + 1),\n        ] {\n            if *grid.get(&npos).unwrap_or(&Tile::Wall) == Tile::Wall {\n                continue;\n            } else if discovered.contains(&npos) {\n                continue;\n            }\n            discovered.insert(npos);\n            queue.push_back(npos);\n            distances.insert(npos, distances.get(&v).unwrap_or(&0) + 1);\n        }\n    }\n    *distances.values().max().unwrap()\n}", "item_id": 2, "repo": "bcongdon/advent_of_code_2019", "file": "Day10-19/day15.rs", "last_update_at": "2020-05-26T04:57:55+00:00", "question_id": "31c31cf725f85efbe01a963ef9302e300570b386_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn oxygen_spread_time(grid: &HashMap<(i64, i64), Tile>) -> i64 {\n    let mut queue: VecDeque<(i64, i64)> = VecDeque::new();\n    let mut discovered: HashSet<(i64, i64)> = HashSet::new();\n    let mut distances: HashMap<(i64, i64), i64> = HashMap::new();\n    let start_pos = *grid\n        .iter()\n        .filter(|(_, v)| **v == Tile::Oxygen)\n        .map(|(k, _)| k)\n        .next()\n        .unwrap();\n    discovered.insert(start_pos);\n    queue.push_back(start_pos);\n    distances.insert(start_pos, 0);\n    while !queue.is_empty() {\n        let v = queue.pop_front().unwrap();\n        for npos in vec![\n            (v.0 + 1, v.1),\n            (v.0 - 1, v.1),\n            (v.0, v.1 - 1),\n            (v.0, v.1 + 1),\n        ] {\n            if *grid.get(&npos).unwrap_or(&Tile::Wall) == Tile::Wall {\n                continue;\n            } else if discovered.contains(&npos) {\n                continue;\n            }\n            discovered.insert(npos);\n            queue.push_back(npos);\n            distances.insert(npos, distances.get(&v).unwrap_or(&0) + 1);\n        }\n    }\n    *distances.values().max().unwrap()\n"]], "pred": {"ppl": 1.5264692306518555, "ppl_lower": 1.6515111923217773, "ppl/lowercase_ppl": -1.1861496479958913, "ppl/zlib": 0.0009634564378001516, "Min_5.0% Prob": 5.525253057479858, "Min_10.0% Prob": 3.6729635536670684, "Min_20.0% Prob": 2.0575314399636824, "Min_30.0% Prob": 1.402779057835702, "Min_40.0% Prob": 1.0609637452864353, "Min_50.0% Prob": 0.8476118386087691, "Min_60.0% Prob": 0.7054143696834932}}
{"hexsha": "426553cbaf283768b0505666ad164b8410887b5b", "ext": "rs", "lang": "Rust", "content": "fn make_rows_query_result(rows_num: usize) -> QueryResult {\n        let mut res = make_not_rows_query_result();\n        res.rows = Some(make_rows(rows_num));\n        res\n    }", "item_id": 3, "repo": "numberly/scylla-rust-driver", "file": "scylla/src/transport/query_result.rs", "last_update_at": "2020-10-28T10:55:49+00:00", "question_id": "426553cbaf283768b0505666ad164b8410887b5b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_rows_query_result(rows_num: usize) -> QueryResult {\n        let mut res = make_not_rows_query_result();\n        res.rows = Some(make_rows(rows_num));\n        res\n"]], "pred": {"ppl": 4.078025817871094, "ppl_lower": 5.569892406463623, "ppl/lowercase_ppl": -1.2217984134298838, "ppl/zlib": 0.013014935214307799, "Min_5.0% Prob": 9.50435495376587, "Min_10.0% Prob": 7.621415805816651, "Min_20.0% Prob": 5.644545121626421, "Min_30.0% Prob": 4.284355086438796, "Min_40.0% Prob": 3.3868458763412805, "Min_50.0% Prob": 2.7664004831478515, "Min_60.0% Prob": 2.383163384874077}}
{"hexsha": "595052fe31465e8ff5b737b3569a1d9f92cd12c4", "ext": "rs", "lang": "Rust", "content": "fn camera(distance: f32) -> ArcBall\n{\n  let eye = Point3::new(0.0, 0.0, distance);\n  let at = Point3::origin();\n  return ArcBall::new(eye, at);\n}", "item_id": 1, "repo": "diodesign/rustinvaders", "file": "src/main.rs", "last_update_at": "2020-06-16T12:57:22+00:00", "question_id": "595052fe31465e8ff5b737b3569a1d9f92cd12c4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn camera(distance: f32) -> ArcBall\n{\n  let eye = Point3::new(0.0, 0.0, distance);\n  let at = Point3::origin();\n  return ArcBall::new(eye, at);\n"]], "pred": {"ppl": 3.130012273788452, "ppl_lower": 3.9601805210113525, "ppl/lowercase_ppl": -1.2061744708891504, "ppl/zlib": 0.010009095841074886, "Min_5.0% Prob": 9.47496509552002, "Min_10.0% Prob": 7.896140813827515, "Min_20.0% Prob": 5.220984717210134, "Min_30.0% Prob": 3.773830584353871, "Min_40.0% Prob": 2.887872166931629, "Min_50.0% Prob": 2.2587888733513894, "Min_60.0% Prob": 1.9028235132227074}}
{"hexsha": "00531fd4fe2d656d52fd30c1dad5dd37814e2487", "ext": "rs", "lang": "Rust", "content": "fn seats_to_shuffle(input: &Vec<Vec<SeatFill>>) -> Vec<(usize, usize)> {\n    let mut seats_to_change: Vec<(usize, usize)> = Vec::new();\n    for i in 0..input.len() {\n        let line = input.get(i).unwrap();\n        for j in 0..line.len() {\n            let current_seat = line.get(j).unwrap();\n            if *current_seat == SeatFill::Floor {\n                continue;\n            }\n\n            let mut n_occupied = 0;\n            for sx in -1..=1 {\n                for sy in -1..=1 {\n                    if sx == 0 && sy == 0 {\n                        continue;\n                    }\n\n                    if occupied_seat_visible(&input, (j, i), (sx, sy)) {\n                        n_occupied += 1;\n                    }\n                }\n            }\n\n\n            if (*current_seat == SeatFill::Empty && n_occupied <= MAX_OCCUPIED_TO_FILL) ||\n                *current_seat == SeatFill::Occupied && n_occupied >= MIN_OCCUPIED_TO_EMPTY {\n                seats_to_change.push((i, j));\n            }\n        }\n    }\n\n    seats_to_change\n}", "item_id": 2, "repo": "Minhaul/advent-of-code-2020", "file": "d11/src/bin/p2.rs", "last_update_at": "2020-12-08T23:33:26+00:00", "question_id": "00531fd4fe2d656d52fd30c1dad5dd37814e2487_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn seats_to_shuffle(input: &Vec<Vec<SeatFill>>) -> Vec<(usize, usize)> {\n    let mut seats_to_change: Vec<(usize, usize)> = Vec::new();\n    for i in 0..input.len() {\n        let line = input.get(i).unwrap();\n        for j in 0..line.len() {\n            let current_seat = line.get(j).unwrap();\n            if *current_seat == SeatFill::Floor {\n                continue;\n            }\n            let mut n_occupied = 0;\n            for sx in -1..=1 {\n                for sy in -1..=1 {\n                    if sx == 0 && sy == 0 {\n                        continue;\n                    }\n                    if occupied_seat_visible(&input, (j, i), (sx, sy)) {\n                        n_occupied += 1;\n                    }\n                }\n            }\n            if (*current_seat == SeatFill::Empty && n_occupied <= MAX_OCCUPIED_TO_FILL) ||\n                *current_seat == SeatFill::Occupied && n_occupied >= MIN_OCCUPIED_TO_EMPTY {\n                seats_to_change.push((i, j));\n            }\n        }\n    }\n    seats_to_change\n"]], "pred": {"ppl": 1.8957998752593994, "ppl_lower": 2.099271774291992, "ppl/lowercase_ppl": -1.1593857922682747, "ppl/zlib": 0.001648558884635065, "Min_5.0% Prob": 6.991943695965936, "Min_10.0% Prob": 5.037300446454217, "Min_20.0% Prob": 3.016553580329038, "Min_30.0% Prob": 2.1064489507704107, "Min_40.0% Prob": 1.5896123866078213, "Min_50.0% Prob": 1.2802349397165398, "Min_60.0% Prob": 1.0652917159838233}}
{"hexsha": "90b6936df788397fc5d6af5f3593e71e3edc2b4a", "ext": "rs", "lang": "Rust", "content": "pub async fn get(\n        operation_config: &crate::OperationConfig,\n        application_resource_name: &str,\n    ) -> std::result::Result<models::ApplicationResourceDescription, get::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/Resources/Applications/{}\",\n            operation_config.base_path(),\n            application_resource_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ApplicationResourceDescription =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::FabricError =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 230, "repo": "jesinity/azure-sdk-for-rust", "file": "services/svc/servicefabric/src/v8_0/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "90b6936df788397fc5d6af5f3593e71e3edc2b4a_230", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get(\n        operation_config: &crate::OperationConfig,\n        application_resource_name: &str,\n    ) -> std::result::Result<models::ApplicationResourceDescription, get::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/Resources/Applications/{}\",\n            operation_config.base_path(),\n            application_resource_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::ApplicationResourceDescription =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::FabricError =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.102345585823059, "ppl_lower": 2.200007438659668, "ppl/lowercase_ppl": -8.091734761204808, "ppl/zlib": 0.0001320328730615443, "Min_5.0% Prob": 1.9696642800324387, "Min_10.0% Prob": 0.9868543116143912, "Min_20.0% Prob": 0.4895317392111028, "Min_30.0% Prob": 0.3254901335221464, "Min_40.0% Prob": 0.24379428018973742, "Min_50.0% Prob": 0.1948804289433008, "Min_60.0% Prob": 0.16274596526806176}}
{"hexsha": "b5810c4d2a6a7e1bcd3c499568e7b5fdb6c61400", "ext": "rs", "lang": "Rust", "content": "pub extern fn cash_flow_class(cash_in: f64, cash_out: f64, reinvest_rate: f64, term: i32, year: i32) -> f64 {\n  let cash: f64 = cash_in - cash_out;\n  let reinvestment = 1.0 + (reinvest_rate / 100.0);\n  let power: i32 = term - year;\n\n  cash * reinvestment.powi(power.into())\n}", "item_id": 0, "repo": "bbugh/ruby-rust-extension-benchmark", "file": "crates/cash_flow_rust_ffi/src/lib.rs", "last_update_at": "2020-09-24T02:06:50+00:00", "question_id": "b5810c4d2a6a7e1bcd3c499568e7b5fdb6c61400_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern fn cash_flow_class(cash_in: f64, cash_out: f64, reinvest_rate: f64, term: i32, year: i32) -> f64 {\n  let cash: f64 = cash_in - cash_out;\n  let reinvestment = 1.0 + (reinvest_rate / 100.0);\n  let power: i32 = term - year;\n  cash * reinvestment.powi(power.into())\n"]], "pred": {"ppl": 3.017221689224243, "ppl_lower": 3.017221689224243, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006458107821629785, "Min_5.0% Prob": 8.298938353856405, "Min_10.0% Prob": 6.211271341030415, "Min_20.0% Prob": 4.363719257024618, "Min_30.0% Prob": 3.3913713724185257, "Min_40.0% Prob": 2.7075511194192448, "Min_50.0% Prob": 2.1822016311414316, "Min_60.0% Prob": 1.8389097048040433}}
{"hexsha": "cca470ffd0202f2319badd9066feb0fc30bd27c6", "ext": "rs", "lang": "Rust", "content": "fn generate_id(length: usize) -> String {\n    thread_local!(static KEYGEN: RefCell<gpw::PasswordGenerator> = RefCell::new(gpw::PasswordGenerator::default()));\n\n    // removed 0/o, i/1/l, u/v as they are too similar. with 4 char this gives us >700'000 unique ids\n    const CHARSET: &[u8] = b\"abcdefghjkmnpqrstwxyz23456789\";\n\n    (0..length)\n        .map(|_| {\n            let idx = thread_rng().gen_range(0..CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect::<String>()\n}", "item_id": 0, "repo": "Blizarre/bibin", "file": "src/io.rs", "last_update_at": "2020-08-24T08:40:40+00:00", "question_id": "cca470ffd0202f2319badd9066feb0fc30bd27c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_id(length: usize) -> String {\n    thread_local!(static KEYGEN: RefCell<gpw::PasswordGenerator> = RefCell::new(gpw::PasswordGenerator::default()));\n    // removed 0/o, i/1/l, u/v as they are too similar. with 4 char this gives us >700'000 unique ids\n    const CHARSET: &[u8] = b\"abcdefghjkmnpqrstwxyz23456789\";\n    (0..length)\n        .map(|_| {\n            let idx = thread_rng().gen_range(0..CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect::<String>()\n"]], "pred": {"ppl": 3.293982744216919, "ppl_lower": 4.019828796386719, "ppl/lowercase_ppl": -1.1670517205271322, "ppl/zlib": 0.003537380988700045, "Min_5.0% Prob": 8.030600176917183, "Min_10.0% Prob": 6.412364721298218, "Min_20.0% Prob": 4.814943492412567, "Min_30.0% Prob": 3.762894332408905, "Min_40.0% Prob": 2.9472371460232014, "Min_50.0% Prob": 2.3873036487416908, "Min_60.0% Prob": 1.9988706215464194}}
{"hexsha": "abc597115d931393fe9f8cdf6f615d6e2b70ef55", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    debug!(\"executing; cmd=albino-gen; args={}\", os::args());\n\n    let mut opts = vec!();\n    let cmd = GenerateCommand::new(\"gen\",\n                                \"[-s syntax] [-o output] [file]\",\n                                &mut opts, CommandBody);\n    cmd.exec();\n}", "item_id": 0, "repo": "faultier/albino", "file": "src/bin/albino-gen.rs", "last_update_at": "2020-07-09T10:25:06+00:00", "question_id": "abc597115d931393fe9f8cdf6f615d6e2b70ef55_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    debug!(\"executing; cmd=albino-gen; args={}\", os::args());\n    let mut opts = vec!();\n    let cmd = GenerateCommand::new(\"gen\",\n                                \"[-s syntax] [-o output] [file]\",\n                                &mut opts, CommandBody);\n    cmd.exec();\n"]], "pred": {"ppl": 9.480196952819824, "ppl_lower": 10.558670997619629, "ppl/lowercase_ppl": -1.0479024018726097, "ppl/zlib": 0.012707373399237434, "Min_5.0% Prob": 9.997472047805786, "Min_10.0% Prob": 9.077242136001587, "Min_20.0% Prob": 7.410559415817261, "Min_30.0% Prob": 6.078211456537247, "Min_40.0% Prob": 5.010889233964862, "Min_50.0% Prob": 4.284034378644897, "Min_60.0% Prob": 3.698414668744924}}
{"hexsha": "94918172b440365c4024fa325e96d422712b7d9d", "ext": "rs", "lang": "Rust", "content": "fn test_add_vector() {\n    let p = Point3::new(1.0, 2.0, 3.0);\n    let r = Vec3::new(2.0, 2.0, 2.0);\n\n    assert_eq!(p + r, Point3::new(3.0, 4.0, 5.0));\n  }", "item_id": 2, "repo": "GarfieldZHU/ray-tracer-rs", "file": "src/core/point3.rs", "last_update_at": "2020-12-23T09:43:57+00:00", "question_id": "94918172b440365c4024fa325e96d422712b7d9d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_add_vector() {\n    let p = Point3::new(1.0, 2.0, 3.0);\n    let r = Vec3::new(2.0, 2.0, 2.0);\n    assert_eq!(p + r, Point3::new(3.0, 4.0, 5.0));\n"]], "pred": {"ppl": 2.074279546737671, "ppl_lower": 2.2411155700683594, "ppl/lowercase_ppl": -1.1060285153888858, "ppl/zlib": 0.006344468582618111, "Min_5.0% Prob": 7.094751954078674, "Min_10.0% Prob": 5.738872170448303, "Min_20.0% Prob": 3.507422257872189, "Min_30.0% Prob": 2.438617898294559, "Min_40.0% Prob": 1.8376773368035044, "Min_50.0% Prob": 1.4705400336957113, "Min_60.0% Prob": 1.2237264966803059}}
{"hexsha": "fe35eadc50e83f0737806f78602fbd77b0a8e5a3", "ext": "rs", "lang": "Rust", "content": "async fn presigned_url_is_valid() {\n        let aws_credentials = aws_credentials().await;\n        let url = generate_presigned_url(&aws_credentials, \"foobar\", None, None).unwrap();\n\n        // We try to make the call to the pre-signed URL and it should succeed with 200\n        let client = reqwest::Client::new();\n        let response = client\n            .get(&url)\n            .header(\"x-k8s-aws-id\", \"foobar\")\n            .send()\n            .await\n            .unwrap();\n        assert!(response.status().is_success());\n    }", "item_id": 3, "repo": "basisai/vault-gke-helper", "file": "src/aws.rs", "last_update_at": "2020-12-08T16:44:51+00:00", "question_id": "fe35eadc50e83f0737806f78602fbd77b0a8e5a3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn presigned_url_is_valid() {\n        let aws_credentials = aws_credentials().await;\n        let url = generate_presigned_url(&aws_credentials, \"foobar\", None, None).unwrap();\n        // We try to make the call to the pre-signed URL and it should succeed with 200\n        let client = reqwest::Client::new();\n        let response = client\n            .get(&url)\n            .header(\"x-k8s-aws-id\", \"foobar\")\n            .send()\n            .await\n            .unwrap();\n        assert!(response.status().is_success());\n"]], "pred": {"ppl": 2.9028375148773193, "ppl_lower": 3.338059425354004, "ppl/lowercase_ppl": -1.131089795887296, "ppl/zlib": 0.003752425042341146, "Min_5.0% Prob": 7.888484137398856, "Min_10.0% Prob": 5.940573978424072, "Min_20.0% Prob": 4.22302352587382, "Min_30.0% Prob": 3.25552429623074, "Min_40.0% Prob": 2.6059123054146767, "Min_50.0% Prob": 2.1062115985704097, "Min_60.0% Prob": 1.7728502416758092}}
{"hexsha": "5f14129104d731d773f38090ea2af93123c90cb1", "ext": "rs", "lang": "Rust", "content": "fn get_options() -> Options {\n    let kdf_options: ScryptKDFOptions = Default::default();\n    let mut opts = Options::new();\n    opts.optopt(\n        \"i\",\n        \"iterations\",\n        &format!(\n            \"set the number of required iterations (default: {})\",\n            kdf_options.iterations\n        ),\n        \"ITER\",\n    );\n    opts.optopt(\n        \"n\",\n        \"workFactor\",\n        &format!(\"set the work factor (default: {})\", kdf_options.n),\n        \"N\",\n    );\n    opts.optopt(\n        \"r\",\n        \"blocksize\",\n        &format!(\"set the blocksize parameter (default: {})\", kdf_options.r),\n        \"R\",\n    );\n    opts.optopt(\n        \"p\",\n        \"parallel\",\n        &format!(\"set the parallelization parameter (default: {})\", kdf_options.p),\n        \"P\",\n    );\n    opts.optopt(\n        \"k\",\n        \"keysize\",\n        &format!(\"set the length of the derived (default: {})\", kdf_options.keysize),\n        \"SIZE\",\n    );\n    opts.optflag(\"t\", \"test\", \"print test vectors\");\n    opts.optflag(\"h\", \"help\", \"print this help menu\");\n    opts.optflag(\"v\", \"version\", \"print version information\");\n\n    opts\n}", "item_id": 0, "repo": "lbeder/scrypt-kdf", "file": "src/main.rs", "last_update_at": "2020-06-21T10:21:24+00:00", "question_id": "5f14129104d731d773f38090ea2af93123c90cb1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_options() -> Options {\n    let kdf_options: ScryptKDFOptions = Default::default();\n    let mut opts = Options::new();\n    opts.optopt(\n        \"i\",\n        \"iterations\",\n        &format!(\n            \"set the number of required iterations (default: {})\",\n            kdf_options.iterations\n        ),\n        \"ITER\",\n    );\n    opts.optopt(\n        \"n\",\n        \"workFactor\",\n        &format!(\"set the work factor (default: {})\", kdf_options.n),\n        \"N\",\n    );\n    opts.optopt(\n        \"r\",\n        \"blocksize\",\n        &format!(\"set the blocksize parameter (default: {})\", kdf_options.r),\n        \"R\",\n    );\n    opts.optopt(\n        \"p\",\n        \"parallel\",\n        &format!(\"set the parallelization parameter (default: {})\", kdf_options.p),\n        \"P\",\n    );\n    opts.optopt(\n        \"k\",\n        \"keysize\",\n        &format!(\"set the length of the derived (default: {})\", kdf_options.keysize),\n        \"SIZE\",\n    );\n    opts.optflag(\"t\", \"test\", \"print test vectors\");\n    opts.optflag(\"h\", \"help\", \"print this help menu\");\n    opts.optflag(\"v\", \"version\", \"print version information\");\n    opts\n"]], "pred": {"ppl": 1.752453327178955, "ppl_lower": 1.8879212141036987, "ppl/lowercase_ppl": -1.1327226597951545, "ppl/zlib": 0.0015328325339738333, "Min_5.0% Prob": 6.403615025913014, "Min_10.0% Prob": 4.3707999501909525, "Min_20.0% Prob": 2.6236696200711385, "Min_30.0% Prob": 1.8243170153527033, "Min_40.0% Prob": 1.3891464536743505, "Min_50.0% Prob": 1.1190388062809196, "Min_60.0% Prob": 0.9344175785802127}}
{"hexsha": "429d41722b6d0fb98edc10ab90f3adccacd8e751", "ext": "rs", "lang": "Rust", "content": "pub fn instr_branch_subroutine_byte\n    <T: VAXBus>\n    (cpu: &mut VAXCPU<T>, _cycle_count: &mut Cycles)\n    -> Result<(), Error>\n{\n    let displ = read_data::<u8, T>(cpu)?;\n    push(cpu, cpu.regfile.get_pc())?;\n    jump_with_byte_displacement(cpu, displ);\n    Ok(())\n}", "item_id": 4, "repo": "moonheart08/emutk", "file": "emutk-vax/src/cpu/instrs/impls/control.rs", "last_update_at": "2020-05-01T19:58:22+00:00", "question_id": "429d41722b6d0fb98edc10ab90f3adccacd8e751_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn instr_branch_subroutine_byte\n    <T: VAXBus>\n    (cpu: &mut VAXCPU<T>, _cycle_count: &mut Cycles)\n    -> Result<(), Error>\n{\n    let displ = read_data::<u8, T>(cpu)?;\n    push(cpu, cpu.regfile.get_pc())?;\n    jump_with_byte_displacement(cpu, displ);\n    Ok(())\n"]], "pred": {"ppl": 4.773065567016602, "ppl_lower": 6.83980655670166, "ppl/lowercase_ppl": -1.2301812276649722, "ppl/zlib": 0.0077760635571916875, "Min_5.0% Prob": 8.76054048538208, "Min_10.0% Prob": 7.220320874994451, "Min_20.0% Prob": 5.590574119402015, "Min_30.0% Prob": 4.496156850281884, "Min_40.0% Prob": 3.616900892361351, "Min_50.0% Prob": 3.038780687148111, "Min_60.0% Prob": 2.5688953291678773}}
{"hexsha": "48623c43b4c2865a58a5fc6d05b2564c92c075e0", "ext": "rs", "lang": "Rust", "content": "fn test_update_value() {\n        let mut val = Value::Object(serde_json::Map::new());\n\n        update_nested_value(&mut val, &[\"x\", \"y\", \"z\"], \"xx\");\n\n        insta::assert_json_snapshot!(val, @r###\"\n       \u22ee{\n       \u22ee  \"x\": {\n       \u22ee    \"y\": {\n       \u22ee      \"z\": \"xx\"\n       \u22ee    }\n       \u22ee  }\n       \u22ee}\n        \"###);\n\n        update_nested_value(&mut val, &[\"x\", \"y\", \"k\"], \"kk\");\n        update_nested_value(&mut val, &[\"w\", \"\"], \"w\");\n        update_nested_value(&mut val, &[\"z1\"], \"val1\");\n        insta::assert_json_snapshot!(val, @r###\"\n       \u22ee{\n       \u22ee  \"w\": {\n       \u22ee    \"\": \"w\"\n       \u22ee  },\n       \u22ee  \"x\": {\n       \u22ee    \"y\": {\n       \u22ee      \"k\": \"kk\",\n       \u22ee      \"z\": \"xx\"\n       \u22ee    }\n       \u22ee  },\n       \u22ee  \"z1\": \"val1\"\n       \u22ee}\n        \"###);\n    }", "item_id": 2, "repo": "getsentry/semaphore", "file": "relay-server/src/utils/param_parser.rs", "last_update_at": "2020-01-02T14:51:18+00:00", "question_id": "48623c43b4c2865a58a5fc6d05b2564c92c075e0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_update_value() {\n        let mut val = Value::Object(serde_json::Map::new());\n        update_nested_value(&mut val, &[\"x\", \"y\", \"z\"], \"xx\");\n        insta::assert_json_snapshot!(val, @r###\"\n       \u22ee{\n       \u22ee  \"x\": {\n       \u22ee    \"y\": {\n       \u22ee      \"z\": \"xx\"\n       \u22ee    }\n       \u22ee  }\n       \u22ee}\n        \"###);\n        update_nested_value(&mut val, &[\"x\", \"y\", \"k\"], \"kk\");\n        update_nested_value(&mut val, &[\"w\", \"\"], \"w\");\n        update_nested_value(&mut val, &[\"z1\"], \"val1\");\n        insta::assert_json_snapshot!(val, @r###\"\n       \u22ee{\n       \u22ee  \"w\": {\n       \u22ee    \"\": \"w\"\n       \u22ee  },\n       \u22ee  \"x\": {\n       \u22ee    \"y\": {\n       \u22ee      \"k\": \"kk\",\n       \u22ee      \"z\": \"xx\"\n       \u22ee    }\n       \u22ee  },\n       \u22ee  \"z1\": \"val1\"\n       \u22ee}\n        \"###);\n"]], "pred": {"ppl": 1.6689471006393433, "ppl_lower": 1.8090832233428955, "ppl/lowercase_ppl": -1.1574157976072093, "ppl/zlib": 0.0019852439881175945, "Min_5.0% Prob": 6.5749361094306495, "Min_10.0% Prob": 4.499468438765582, "Min_20.0% Prob": 2.52353779664811, "Min_30.0% Prob": 1.7079347490935641, "Min_40.0% Prob": 1.2832796857384143, "Min_50.0% Prob": 1.027133599837201, "Min_60.0% Prob": 0.8560907438973206}}
{"hexsha": "de7e5924959c374c850f9b9254c62b6fbe9ac8da", "ext": "rs", "lang": "Rust", "content": "fn anoncreds_works_for_single_issuer_single_prover() {\n        Setup::empty();\n\n        //1. Create Issuer wallet, gets wallet handle\n        let (issuer_wallet_handle, issuer_wallet_config) = wallet::create_and_open_default_wallet(\"anoncreds_works_for_single_issuer_single_prover\").unwrap();\n\n        //2. Create Prover wallet, gets wallet handle\n        let (prover_wallet_handle, prover_wallet_config) = wallet::create_and_open_default_wallet(\"anoncreds_works_for_single_issuer_single_prover\").unwrap();\n\n        //3. Issuer creates Schema and Credential Definition\n        let (schema_id, schema_json, cred_def_id, cred_def_json) = anoncreds::multi_steps_issuer_preparation(issuer_wallet_handle,\n                                                                                                             ISSUER_DID,\n                                                                                                             GVT_SCHEMA_NAME,\n                                                                                                             GVT_SCHEMA_ATTRIBUTES);\n\n        //4. Prover creates Master Secret\n        anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();\n\n        //5. Issuance credential for Prover\n        anoncreds::multi_steps_create_credential(COMMON_MASTER_SECRET,\n                                                 prover_wallet_handle,\n                                                 issuer_wallet_handle,\n                                                 CREDENTIAL1_ID,\n                                                 &anoncreds::gvt_credential_values_json(),\n                                                 &cred_def_id,\n                                                 &cred_def_json);\n\n        //6. Proof request\n        let nonce = anoncreds::generate_nonce().unwrap();\n        let proof_req_json = json!({\n                                       \"nonce\": nonce,\n                                       \"name\":\"proof_req_1\",\n                                       \"version\":\"0.1\",\n                                       \"requested_attributes\":{\n                                            \"attr1_referent\":{\n                                                \"name\":\"name\"\n                                            },\n                                            \"attr2_referent\":{\n                                                \"name\":\"sex\"\n                                            },\n                                            \"attr3_referent\":{\"name\":\"phone\"}\n                                       },\n                                       \"requested_predicates\":{\n                                            \"predicate1_referent\":{\"name\":\"age\",\"p_type\":\">=\",\"p_value\":18}\n                                       }\n                                    }).to_string();\n\n        //7. Prover gets Credentials for Proof Request\n        let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_req_json).unwrap();\n        let credential = anoncreds::get_credential_for_attr_referent(&credentials_json, \"attr1_referent\");\n\n        //8. Prover creates Proof\n        let self_attested_value = \"8-800-300\";\n        let requested_credentials_json = format!(r#\"{{\n                                                  \"self_attested_attributes\":{{\"attr3_referent\":\"{}\"}},\n                                                  \"requested_attributes\":{{\n                                                        \"attr1_referent\":{{ \"cred_id\":\"{}\", \"revealed\":true }},\n                                                        \"attr2_referent\":{{ \"cred_id\":\"{}\", \"revealed\":false }}\n                                                  }},\n                                                  \"requested_predicates\":{{\n                                                        \"predicate1_referent\":{{ \"cred_id\":\"{}\" }}\n                                                  }}\n                                                }}\"#, self_attested_value, credential.referent, credential.referent, credential.referent);\n\n        let schemas_json = json!({schema_id: serde_json::from_str::<Schema>(&schema_json).unwrap()}).to_string();\n        let cred_defs_json = json!({cred_def_id: serde_json::from_str::<CredentialDefinition>(&cred_def_json).unwrap()}).to_string();\n        let rev_states_json = json!({}).to_string();\n\n        let proof_json = anoncreds::prover_create_proof(prover_wallet_handle,\n                                                        &proof_req_json,\n                                                        &requested_credentials_json,\n                                                        COMMON_MASTER_SECRET,\n                                                        &schemas_json,\n                                                        &cred_defs_json,\n                                                        &rev_states_json).unwrap();\n\n        let proof: Proof = serde_json::from_str(&proof_json).unwrap();\n\n        //9. Verifier verifies proof\n        assert_eq!(\"Alex\", proof.requested_proof.revealed_attrs.get(\"attr1_referent\").unwrap().raw);\n        assert_eq!(0, proof.requested_proof.unrevealed_attrs.get(\"attr2_referent\").unwrap().sub_proof_index);\n        assert_eq!(self_attested_value, proof.requested_proof.self_attested_attrs.get(\"attr3_referent\").unwrap());\n\n        let rev_reg_defs_json = json!({}).to_string();\n        let rev_regs_json = json!({}).to_string();\n\n        let valid = anoncreds::verifier_verify_proof(&proof_req_json,\n                                                     &proof_json,\n                                                     &schemas_json,\n                                                     &cred_defs_json,\n                                                     &rev_reg_defs_json,\n                                                     &rev_regs_json).unwrap();\n        assert!(valid);\n\n        wallet::close_and_delete_wallet(issuer_wallet_handle, &issuer_wallet_config).unwrap();\n        wallet::close_and_delete_wallet(prover_wallet_handle, &prover_wallet_config).unwrap();\n    }", "item_id": 0, "repo": "multixo-informatie-techne/indy-sdk", "file": "libindy/tests/anoncreds_demos.rs", "last_update_at": "2020-11-18T10:09:41+00:00", "question_id": "de7e5924959c374c850f9b9254c62b6fbe9ac8da_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn anoncreds_works_for_single_issuer_single_prover() {\n        Setup::empty();\n        //1. Create Issuer wallet, gets wallet handle\n        let (issuer_wallet_handle, issuer_wallet_config) = wallet::create_and_open_default_wallet(\"anoncreds_works_for_single_issuer_single_prover\").unwrap();\n        //2. Create Prover wallet, gets wallet handle\n        let (prover_wallet_handle, prover_wallet_config) = wallet::create_and_open_default_wallet(\"anoncreds_works_for_single_issuer_single_prover\").unwrap();\n        //3. Issuer creates Schema and Credential Definition\n        let (schema_id, schema_json, cred_def_id, cred_def_json) = anoncreds::multi_steps_issuer_preparation(issuer_wallet_handle,\n                                                                                                             ISSUER_DID,\n                                                                                                             GVT_SCHEMA_NAME,\n                                                                                                             GVT_SCHEMA_ATTRIBUTES);\n        //4. Prover creates Master Secret\n        anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();\n        //5. Issuance credential for Prover\n        anoncreds::multi_steps_create_credential(COMMON_MASTER_SECRET,\n                                                 prover_wallet_handle,\n                                                 issuer_wallet_handle,\n                                                 CREDENTIAL1_ID,\n                                                 &anoncreds::gvt_credential_values_json(),\n                                                 &cred_def_id,\n                                                 &cred_def_json);\n        //6. Proof request\n        let nonce = anoncreds::generate_nonce().unwrap();\n        let proof_req_json = json!({\n                                       \"nonce\": nonce,\n                                       \"name\":\"proof_req_1\",\n                                       \"version\":\"0.1\",\n                                       \"requested_attributes\":{\n                                            \"attr1_referent\":{\n                                                \"name\":\"name\"\n                                            },\n                                            \"attr2_referent\":{\n                                                \"name\":\"sex\"\n                                            },\n                                            \"attr3_referent\":{\"name\":\"phone\"}\n                                       },\n                                       \"requested_predicates\":{\n                                            \"predicate1_referent\":{\"name\":\"age\",\"p_type\":\">=\",\"p_value\":18}\n                                       }\n                                    }).to_string();\n        //7. Prover gets Credentials for Proof Request\n        let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_req_json).unwrap();\n        let credential = anoncreds::get_credential_for_attr_referent(&credentials_json, \"attr1_referent\");\n        //8. Prover creates Proof\n        let self_attested_value = \"8-800-300\";\n        let requested_credentials_json = format!(r#\"{{\n                                                  \"self_attested_attributes\":{{\"attr3_referent\":\"{}\"}},\n                                                  \"requested_attributes\":{{\n                                                        \"attr1_referent\":{{ \"cred_id\":\"{}\", \"revealed\":true }},\n                                                        \"attr2_referent\":{{ \"cred_id\":\"{}\", \"revealed\":false }}\n                                                  }},\n                                                  \"requested_predicates\":{{\n                                                        \"predicate1_referent\":{{ \"cred_id\":\"{}\" }}\n                                                  }}\n                                                }}\"#, self_attested_value, credential.referent, credential.referent, credential.referent);\n        let schemas_json = json!({schema_id: serde_json::from_str::<Schema>(&schema_json).unwrap()}).to_string();\n        let cred_defs_json = json!({cred_def_id: serde_json::from_str::<CredentialDefinition>(&cred_def_json).unwrap()}).to_string();\n        let rev_states_json = json!({}).to_string();\n        let proof_json = anoncreds::prover_create_proof(prover_wallet_handle,\n                                                        &proof_req_json,\n                                                        &requested_credentials_json,\n                                                        COMMON_MASTER_SECRET,\n                                                        &schemas_json,\n                                                        &cred_defs_json,\n                                                        &rev_states_json).unwrap();\n        let proof: Proof = serde_json::from_str(&proof_json).unwrap();\n        //9. Verifier verifies proof\n        assert_eq!(\"Alex\", proof.requested_proof.revealed_attrs.get(\"attr1_referent\").unwrap().raw);\n        assert_eq!(0, proof.requested_proof.unrevealed_attrs.get(\"attr2_referent\").unwrap().sub_proof_index);\n        assert_eq!(self_attested_value, proof.requested_proof.self_attested_attrs.get(\"attr3_referent\").unwrap());\n        let rev_reg_defs_json = json!({}).to_string();\n        let rev_regs_json = json!({}).to_string();\n        let valid = anoncreds::verifier_verify_proof(&proof_req_json,\n                                                     &proof_json,\n                                                     &schemas_json,\n                                                     &cred_defs_json,\n                                                     &rev_reg_defs_json,\n                                                     &rev_regs_json).unwrap();\n        assert!(valid);\n        wallet::close_and_delete_wallet(issuer_wallet_handle, &issuer_wallet_config).unwrap();\n        wallet::close_and_delete_wallet(prover_wallet_handle, &prover_wallet_config).unwrap();\n"]], "pred": {"ppl": 1.1914840936660767, "ppl_lower": 1.3334836959838867, "ppl/lowercase_ppl": -1.6426677172277702, "ppl/zlib": 0.00014860022699568815, "Min_5.0% Prob": 2.789113528588239, "Min_10.0% Prob": 1.6176526029320324, "Min_20.0% Prob": 0.8646262724171666, "Min_30.0% Prob": 0.5833403160460781, "Min_40.0% Prob": 0.4377168224000743, "Min_50.0% Prob": 0.3506109855735106, "Min_60.0% Prob": 0.29234848917351974}}
{"hexsha": "47bb5d497aadfaf65504194eb55eb364a0fbaa96", "ext": "rs", "lang": "Rust", "content": "pub fn pretty_print(ast: Block) -> String {\n    // Start indent level at -1 so the block representing the top chunk isn't indented\n    let mut writer = StringWriter::new(-1);\n    ast.print(&mut writer);\n    return writer.buf;\n}", "item_id": 0, "repo": "weswigham/lua-rust", "file": "src/printer.rs", "last_update_at": "2020-05-28T06:15:42+00:00", "question_id": "47bb5d497aadfaf65504194eb55eb364a0fbaa96_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn pretty_print(ast: Block) -> String {\n    // Start indent level at -1 so the block representing the top chunk isn't indented\n    let mut writer = StringWriter::new(-1);\n    ast.print(&mut writer);\n    return writer.buf;\n"]], "pred": {"ppl": 7.740522861480713, "ppl_lower": 9.390016555786133, "ppl/lowercase_ppl": -1.0943956616755361, "ppl/zlib": 0.012555026002962617, "Min_5.0% Prob": 10.522548993428549, "Min_10.0% Prob": 9.502152045567831, "Min_20.0% Prob": 7.2816775395320015, "Min_30.0% Prob": 5.933850639744809, "Min_40.0% Prob": 4.770577050172365, "Min_50.0% Prob": 4.028399677947164, "Min_60.0% Prob": 3.371141329025611}}
{"hexsha": "1899237223e6bf0e0c2b2613f2863e9d0541b46f", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let args: Vec<String> = env::args().skip(1).collect();\n    let arguments = unwrap_or_exit(Arguments::parse(args));\n\n    // Sets a local variable to the value of the command line argument\n    // with the same name as the variable.\n    macro_rules! arg_var {\n        ($name:ident, $default:expr) => (\n            let $name = unwrap_or_exit(arguments.value(stringify!($name), $default));\n        );\n        ($name:ident, $default:expr, $min:expr, $max:expr) => (\n            arg_var!($name, $default);\n            if !($min <= $name && $name <= $max) {\n                exit!(\"Invalid value '{}' for argument '{}': Value must be between {} and {}.\",\n                        $name, stringify!($name), $min, $max);\n            }\n        );\n    }\n\n    // Seed value for random number generation\n    arg_var!(seed, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32);\n\n    // Linear speed of the model along its path, in blocks/second\n    arg_var!(speed, 30.0, 0.0, 1000.0);\n    // Animation frames per second\n    arg_var!(fps, 30.0, 0.1, 600.0);\n\n    // Coloration gradient of the model, from its spine (`0`) to its outline (`1`)\n    arg_var!(gradient, Gradient(vec![\n        (0.4, Color::new(1.0, 1.0, 1.0)),\n        (0.6, Color::new(0.15, 0.15, 0.7)),\n        (1.0, Color::new(0.3, 0.1, 0.3)),\n    ]));\n\n    // Use 24-bit RGB terminal colors (`true`) or the 256-color palette (`false`)\n    arg_var!(true_color, true);\n\n    // Dimensions of the arena, in blocks\n    arg_var!(width, 60, 1, 500);\n    arg_var!(height, 40, 1, 500);\n    if height % 2 != 0 {\n        exit!(\"Invalid height '{}': Height must be a multiple of 2.\", height);\n    }\n\n    // Minimum and maximum length of the model, in blocks.\n    // The program will animate between the two for a \"creeping\" motion.\n    let length_range = unwrap_or_exit(arguments.value(\"length\", Range::new(10.0, 20.0)));\n    if !(1.0 <= length_range.from && length_range.to <= 1000.0) {\n        exit!(\"Invalid length '{} to {}': Length must be between 1 and 1000.\", length_range.from, length_range.to);\n    }\n\n    // Coefficients of the function determining the model's thickness,\n    // in blocks.\n    //\n    // The function has the form\n    //\n    // ```\n    // f(o, t) = a + b * sin(PI * (c * o + d * t + e)) + ...\n    // ```\n    //\n    // where `o` is the offset (between `0` and `1`) from the head\n    // of the model to its tail, and `t` is the time in seconds\n    // since the program was started.\n    let coefficients = unwrap_or_exit(arguments.values(\"thickness\", vec![4.0, 1.0, 3.5, 0.0, 0.0]));\n    if coefficients.len() % 4 != 1 {\n        exit!(\"Invalid thickness specification: There must be 1, or 5, or 9, ... coefficients; {} were supplied.\",\n                coefficients.len());\n    }\n\n    let thickness = |offset: f64, time: f64| {\n        assert!(0.0 <= offset && offset <= 1.0);\n        let mut thickness = coefficients[0];\n        for i in 0..((coefficients.len() - 1) / 4) {\n            thickness += coefficients[4 * i + 1] * (\n                PI * (\n                    (coefficients[4 * i + 2] * offset) +\n                    (coefficients[4 * i + 3] * time) +\n                    coefficients[4 * i + 4]\n                )\n            ).sin();\n        }\n        thickness\n    };\n\n    // Calculate upper bound for value of thickness function\n    let mut max_thickness = coefficients[0];\n    for i in 0..((coefficients.len() - 1) / 4) {\n        max_thickness += coefficients[4 * i + 1].abs();\n    }\n    if !(0.5 <= max_thickness && max_thickness <= 1000.0) {\n        exit!(\"Invalid thickness specification: Maximum thickness is {}; must be between 0.5 and 1000.\", max_thickness);\n    }\n\n    let max_padding = 0.8 * ((min!(width, height) as f64) / 2.0);\n    // Minimum distance between the path and the boundary of the arena, in blocks\n    arg_var!(padding, min!(max_thickness, max_padding), 0.0, max_padding);\n\n    let max_radius = 0.8 * (((min!(width, height) as f64) / 2.0) - padding);\n    // Minimum and maximum radius of the arcs comprising the path, in blocks\n    let radius_range = unwrap_or_exit(arguments.value(\"radius\",\n            Range::new(min!(1.2 * max_thickness, max_radius), max_radius)));\n    if !(0.5 <= radius_range.from && radius_range.to <= max_radius) {\n        exit!(\"Invalid radius '{} to {}': For the configured width, height, and padding, \\\n                radius must be between 0.5 and {}.\", radius_range.from, radius_range.to, max_radius);\n    }\n\n    // The dimensions of the arena must be such that it is always possible\n    // to generate a new arc that is tangential to the last arc in the path\n    // and whose radius lies within the permitted range (see `Path` for details).\n    // In the worst case, an arc of the maximum permitted radius is placed\n    // at the center of the arena, minimizing the available space for the next arc,\n    // which must be at least the minimum radius specified above.\n    let min_size = (2.0 * radius_range.to) + (4.0 * radius_range.from) + (2.0 * padding);\n    if (width as f64) < min_size && (height as f64) < min_size {\n        exit!(\"Insufficient arena size for path generation: For the configured radius and padding, \\\n                either width or height must be at least {}.\", min_size);\n    }\n\n    let mut path = Path {\n        random: Random(seed),\n        x_range: Range::new(padding, (width as f64) - padding),\n        y_range: Range::new(padding, (height as f64) - padding),\n        radius_range,\n        start_position: 0.0,\n        arcs: VecDeque::new(),\n    };\n\n    let mut last_position = 0.0;\n    let mut path_range = Range::new(0.0, length_range.from);\n    let mut expand_path = true;\n\n    let start_time = Instant::now();\n\n    // Rendering loop\n    loop {\n        let time = seconds(start_time.elapsed());\n\n        let position = speed * time;\n\n        if length_range.to > length_range.from {\n            // \"Creeping\" motion\n            let mut delta = position - last_position;\n            last_position = position;\n\n            while delta > 0.0 {\n                let length = path_range.to - path_range.from;\n\n                let max_delta = if expand_path {\n                    length_range.to - length\n                } else {\n                    length - length_range.from\n                };\n\n                let actual_delta = min!(delta, max_delta);\n\n                if expand_path {\n                    path_range.to += actual_delta;\n                } else {\n                    path_range.from += actual_delta;\n                }\n\n                if delta >= max_delta {\n                    expand_path = !expand_path;\n                }\n\n                delta -= actual_delta;\n            }\n        } else {\n            // Linear motion\n            path_range.from = position;\n            path_range.to = path_range.from + length_range.from;\n        }\n\n        let model = Model::new(\n            path.generate(path_range.from, path_range.to),\n            |offset| thickness(offset, time),\n            max_thickness,\n        );\n\n        let canvas = rasterize(&model, &gradient, width, height);\n        let output = render(&canvas, true_color);\n\n        // Hide cursor while printing canvas to avoid flickering\n        print!(\"\\x1B[?25l{}\\x1B[?25h\\n\", output);\n\n        // Sleep to compensate for difference between rendering time and frame time\n        let sleep_time = (1.0 / fps) - (seconds(start_time.elapsed()) - time);\n        if sleep_time > 0.0 {\n            thread::sleep(Duration::new(sleep_time.trunc() as u64, (sleep_time.fract() * 1_000_000_000.0) as u32));\n        }\n\n        // Move cursor up to enable drawing of next frame over the current one\n        print!(\"\\x1B[{}A\", height / 2);\n    }\n}", "item_id": 0, "repo": "mgzme/wsl-dotfiles", "file": "utils/src/ternimal/ternimal.rs", "last_update_at": "2020-10-23T14:02:16+00:00", "question_id": "1899237223e6bf0e0c2b2613f2863e9d0541b46f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let args: Vec<String> = env::args().skip(1).collect();\n    let arguments = unwrap_or_exit(Arguments::parse(args));\n    // Sets a local variable to the value of the command line argument\n    // with the same name as the variable.\n    macro_rules! arg_var {\n        ($name:ident, $default:expr) => (\n            let $name = unwrap_or_exit(arguments.value(stringify!($name), $default));\n        );\n        ($name:ident, $default:expr, $min:expr, $max:expr) => (\n            arg_var!($name, $default);\n            if !($min <= $name && $name <= $max) {\n                exit!(\"Invalid value '{}' for argument '{}': Value must be between {} and {}.\",\n                        $name, stringify!($name), $min, $max);\n            }\n        );\n    }\n    // Seed value for random number generation\n    arg_var!(seed, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32);\n    // Linear speed of the model along its path, in blocks/second\n    arg_var!(speed, 30.0, 0.0, 1000.0);\n    // Animation frames per second\n    arg_var!(fps, 30.0, 0.1, 600.0);\n    // Coloration gradient of the model, from its spine (`0`) to its outline (`1`)\n    arg_var!(gradient, Gradient(vec![\n        (0.4, Color::new(1.0, 1.0, 1.0)),\n        (0.6, Color::new(0.15, 0.15, 0.7)),\n        (1.0, Color::new(0.3, 0.1, 0.3)),\n    ]));\n    // Use 24-bit RGB terminal colors (`true`) or the 256-color palette (`false`)\n    arg_var!(true_color, true);\n    // Dimensions of the arena, in blocks\n    arg_var!(width, 60, 1, 500);\n    arg_var!(height, 40, 1, 500);\n    if height % 2 != 0 {\n        exit!(\"Invalid height '{}': Height must be a multiple of 2.\", height);\n    }\n    // Minimum and maximum length of the model, in blocks.\n    // The program will animate between the two for a \"creeping\" motion.\n    let length_range = unwrap_or_exit(arguments.value(\"length\", Range::new(10.0, 20.0)));\n    if !(1.0 <= length_range.from && length_range.to <= 1000.0) {\n        exit!(\"Invalid length '{} to {}': Length must be between 1 and 1000.\", length_range.from, length_range.to);\n    }\n    // Coefficients of the function determining the model's thickness,\n    // in blocks.\n    //\n    // The function has the form\n    //\n    // ```\n    // f(o, t) = a + b * sin(PI * (c * o + d * t + e)) + ...\n    // ```\n    //\n    // where `o` is the offset (between `0` and `1`) from the head\n    // of the model to its tail, and `t` is the time in seconds\n    // since the program was started.\n    let coefficients = unwrap_or_exit(arguments.values(\"thickness\", vec![4.0, 1.0, 3.5, 0.0, 0.0]));\n    if coefficients.len() % 4 != 1 {\n        exit!(\"Invalid thickness specification: There must be 1, or 5, or 9, ... coefficients; {} were supplied.\",\n                coefficients.len());\n    }\n    let thickness = |offset: f64, time: f64| {\n        assert!(0.0 <= offset && offset <= 1.0);\n        let mut thickness = coefficients[0];\n        for i in 0..((coefficients.len() - 1) / 4) {\n            thickness += coefficients[4 * i + 1] * (\n                PI * (\n                    (coefficients[4 * i + 2] * offset) +\n                    (coefficients[4 * i + 3] * time) +\n                    coefficients[4 * i + 4]\n                )\n            ).sin();\n        }\n        thickness\n    };\n    // Calculate upper bound for value of thickness function\n    let mut max_thickness = coefficients[0];\n    for i in 0..((coefficients.len() - 1) / 4) {\n        max_thickness += coefficients[4 * i + 1].abs();\n    }\n    if !(0.5 <= max_thickness && max_thickness <= 1000.0) {\n        exit!(\"Invalid thickness specification: Maximum thickness is {}; must be between 0.5 and 1000.\", max_thickness);\n    }\n    let max_padding = 0.8 * ((min!(width, height) as f64) / 2.0);\n    // Minimum distance between the path and the boundary of the arena, in blocks\n    arg_var!(padding, min!(max_thickness, max_padding), 0.0, max_padding);\n    let max_radius = 0.8 * (((min!(width, height) as f64) / 2.0) - padding);\n    // Minimum and maximum radius of the arcs comprising the path, in blocks\n    let radius_range = unwrap_or_exit(arguments.value(\"radius\",\n            Range::new(min!(1.2 * max_thickness, max_radius), max_radius)));\n    if !(0.5 <= radius_range.from && radius_range.to <= max_radius) {\n        exit!(\"Invalid radius '{} to {}': For the configured width, height, and padding, \\\n                radius must be between 0.5 and {}.\", radius_range.from, radius_range.to, max_radius);\n    }\n    // The dimensions of the arena must be such that it is always possible\n    // to generate a new arc that is tangential to the last arc in the path\n    // and whose radius lies within the permitted range (see `Path` for details).\n    // In the worst case, an arc of the maximum permitted radius is placed\n    // at the center of the arena, minimizing the available space for the next arc,\n    // which must be at least the minimum radius specified above.\n    let min_size = (2.0 * radius_range.to) + (4.0 * radius_range.from) + (2.0 * padding);\n    if (width as f64) < min_size && (height as f64) < min_size {\n        exit!(\"Insufficient arena size for path generation: For the configured radius and padding, \\\n                either width or height must be at least {}.\", min_size);\n    }\n    let mut path = Path {\n        random: Random(seed),\n        x_range: Range::new(padding, (width as f64) - padding),\n        y_range: Range::new(padding, (height as f64) - padding),\n        radius_range,\n        start_position: 0.0,\n        arcs: VecDeque::new(),\n    };\n    let mut last_position = 0.0;\n    let mut path_range = Range::new(0.0, length_range.from);\n    let mut expand_path = true;\n    let start_time = Instant::now();\n    // Rendering loop\n    loop {\n        let time = seconds(start_time.elapsed());\n        let position = speed * time;\n        if length_range.to > length_range.from {\n            // \"Creeping\" motion\n            let mut delta = position - last_position;\n            last_position = position;\n            while delta > 0.0 {\n                let length = path_range.to - path_range.from;\n                let max_delta = if expand_path {\n                    length_range.to - length\n                } else {\n                    length - length_range.from\n                };\n                let actual_delta = min!(delta, max_delta);\n                if expand_path {\n                    path_range.to += actual_delta;\n                } else {\n                    path_range.from += actual_delta;\n                }\n                if delta >= max_delta {\n                    expand_path = !expand_path;\n                }\n                delta -= actual_delta;\n            }\n        } else {\n            // Linear motion\n            path_range.from = position;\n            path_range.to = path_range.from + length_range.from;\n        }\n        let model = Model::new(\n            path.generate(path_range.from, path_range.to),\n            |offset| thickness(offset, time),\n            max_thickness,\n        );\n        let canvas = rasterize(&model, &gradient, width, height);\n        let output = render(&canvas, true_color);\n        // Hide cursor while printing canvas to avoid flickering\n        print!(\"\\x1B[?25l{}\\x1B[?25h\\n\", output);\n        // Sleep to compensate for difference between rendering time and frame time\n        let sleep_time = (1.0 / fps) - (seconds(start_time.elapsed()) - time);\n        if sleep_time > 0.0 {\n            thread::sleep(Duration::new(sleep_time.trunc() as u64, (sleep_time.fract() * 1_000_000_000.0) as u32));\n        }\n        // Move cursor up to enable drawing of next frame over the current one\n        print!(\"\\x1B[{}A\", height / 2);\n    }\n"]], "pred": {"ppl": 2.3442230224609375, "ppl_lower": 2.4693565368652344, "ppl/lowercase_ppl": -1.061040374491286, "ppl/zlib": 0.0003362091607299706, "Min_5.0% Prob": 6.43218189127305, "Min_10.0% Prob": 5.008148046100841, "Min_20.0% Prob": 3.477474291534985, "Min_30.0% Prob": 2.6292245105590695, "Min_40.0% Prob": 2.067225765008798, "Min_50.0% Prob": 1.6875513756899219, "Min_60.0% Prob": 1.4177553540742902}}
{"hexsha": "114bebab9763c771b32c9f9028a6f983098f6429", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let app = Server::new(|_request, mut response| {\n        let motivation = templates::motivation();\n        Ok(response.header(\"Content-Type\", \"text/html; charset=utf-8\").body(motivation)?)\n    });\n \n    let host = \"0.0.0.0\";\n    let port = get_server_port();\n    let address = format!(\"{}:{}\", host, port);\n\n    println!(\"* Running on http://{}\", address);\n    app.listen(host, &port);\n}", "item_id": 0, "repo": "XAMPPRocky/rust-emergency-compliment", "file": "src/main.rs", "last_update_at": "2020-01-16T11:51:47+00:00", "question_id": "114bebab9763c771b32c9f9028a6f983098f6429_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let app = Server::new(|_request, mut response| {\n        let motivation = templates::motivation();\n        Ok(response.header(\"Content-Type\", \"text/html; charset=utf-8\").body(motivation)?)\n    });\n    let host = \"0.0.0.0\";\n    let port = get_server_port();\n    let address = format!(\"{}:{}\", host, port);\n    println!(\"* Running on http://{}\", address);\n    app.listen(host, &port);\n"]], "pred": {"ppl": 3.1815385818481445, "ppl_lower": 3.4151363372802734, "ppl/lowercase_ppl": -1.0612188118847308, "ppl/zlib": 0.004503365410714301, "Min_5.0% Prob": 9.866660753885904, "Min_10.0% Prob": 7.511892502124493, "Min_20.0% Prob": 5.044318355046785, "Min_30.0% Prob": 3.644132675230503, "Min_40.0% Prob": 2.8430144775588557, "Min_50.0% Prob": 2.291170887315451, "Min_60.0% Prob": 1.9303762886207552}}
{"hexsha": "beb69f9080d408564948685850a6a8d0ac107ee1", "ext": "rs", "lang": "Rust", "content": "fn prefs_messaging() {\n        let pants = build_pants();\n\n        match tokio_test::block_on(pants.prefs_messaging()) {\n            Ok(response) => println!(\"Response to prefs_messaging is: {:#?}\", response),\n            Err(e) => panic!(\"An error ocurred: {}\", e),\n        };\n    }", "item_id": 6, "repo": "tobymurray/mr_splashy_pants", "file": "src/lib.rs", "last_update_at": "2020-11-09T01:26:57+00:00", "question_id": "beb69f9080d408564948685850a6a8d0ac107ee1_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prefs_messaging() {\n        let pants = build_pants();\n        match tokio_test::block_on(pants.prefs_messaging()) {\n            Ok(response) => println!(\"Response to prefs_messaging is: {:#?}\", response),\n            Err(e) => panic!(\"An error ocurred: {}\", e),\n        };\n"]], "pred": {"ppl": 3.980301856994629, "ppl_lower": 4.590692043304443, "ppl/lowercase_ppl": -1.103284709620121, "ppl/zlib": 0.007984726357724643, "Min_5.0% Prob": 9.191888689994812, "Min_10.0% Prob": 7.430936919318305, "Min_20.0% Prob": 5.424279477861193, "Min_30.0% Prob": 4.252936703187448, "Min_40.0% Prob": 3.3186769147177, "Min_50.0% Prob": 2.7524726831394695, "Min_60.0% Prob": 2.325824262337251}}
{"hexsha": "32308decbf7c9a16eaf72aeafae4a2116235fee3", "ext": "rs", "lang": "Rust", "content": "fn test_temp_dir() {\n        let tmpdir = user::temp_dir(\"foo\").unwrap();\n        assert_eq!(tmpdir.exists(), true);\n        assert!(sys::remove_all(&tmpdir).is_ok());\n        assert_eq!(tmpdir.exists(), false);\n    }", "item_id": 5, "repo": "phR0ze/rs", "file": "src/sys/user.rs", "last_update_at": "2020-12-26T19:40:04+00:00", "question_id": "32308decbf7c9a16eaf72aeafae4a2116235fee3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_temp_dir() {\n        let tmpdir = user::temp_dir(\"foo\").unwrap();\n        assert_eq!(tmpdir.exists(), true);\n        assert!(sys::remove_all(&tmpdir).is_ok());\n        assert_eq!(tmpdir.exists(), false);\n"]], "pred": {"ppl": 3.2526307106018066, "ppl_lower": 3.2526307106018066, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009072800910231438, "Min_5.0% Prob": 9.89546267191569, "Min_10.0% Prob": 7.308198383876255, "Min_20.0% Prob": 4.8268207141331265, "Min_30.0% Prob": 3.624348509879339, "Min_40.0% Prob": 2.8522527856486186, "Min_50.0% Prob": 2.329017178075654, "Min_60.0% Prob": 1.9557990814071327}}
{"hexsha": "865c5bccaf2cdeb98a4bb42827dbd136bcefa4c7", "ext": "rs", "lang": "Rust", "content": "fn op_mkdir_sync(\n  state: &mut OpState,\n  args: Value,\n  _zero_copy: &mut [ZeroCopyBuf],\n) -> Result<Value, AnyError> {\n  let args: MkdirArgs = serde_json::from_value(args)?;\n  let path = Path::new(&args.path).to_path_buf();\n  let mode = args.mode.unwrap_or(0o777) & 0o777;\n  state.borrow::<Permissions>().check_write(&path)?;\n  debug!(\"op_mkdir {} {:o} {}\", path.display(), mode, args.recursive);\n  let mut builder = std::fs::DirBuilder::new();\n  builder.recursive(args.recursive);\n  #[cfg(unix)]\n  {\n    use std::os::unix::fs::DirBuilderExt;\n    builder.mode(mode);\n  }\n  builder.create(path)?;\n  Ok(json!({}))\n}", "item_id": 15, "repo": "Preta-Crowz/deno", "file": "cli/ops/fs.rs", "last_update_at": "2020-12-08T16:27:54+00:00", "question_id": "865c5bccaf2cdeb98a4bb42827dbd136bcefa4c7_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn op_mkdir_sync(\n  state: &mut OpState,\n  args: Value,\n  _zero_copy: &mut [ZeroCopyBuf],\n) -> Result<Value, AnyError> {\n  let args: MkdirArgs = serde_json::from_value(args)?;\n  let path = Path::new(&args.path).to_path_buf();\n  let mode = args.mode.unwrap_or(0o777) & 0o777;\n  state.borrow::<Permissions>().check_write(&path)?;\n  debug!(\"op_mkdir {} {:o} {}\", path.display(), mode, args.recursive);\n  let mut builder = std::fs::DirBuilder::new();\n  builder.recursive(args.recursive);\n  #[cfg(unix)]\n  {\n    use std::os::unix::fs::DirBuilderExt;\n    builder.mode(mode);\n  }\n  builder.create(path)?;\n  Ok(json!({}))\n"]], "pred": {"ppl": 1.5912797451019287, "ppl_lower": 2.7962028980255127, "ppl/lowercase_ppl": -2.2135135153277328, "ppl/zlib": 0.0012555096314333957, "Min_5.0% Prob": 5.521303117275238, "Min_10.0% Prob": 3.7109053979317346, "Min_20.0% Prob": 2.197821404784918, "Min_30.0% Prob": 1.5433896966278553, "Min_40.0% Prob": 1.1587447785993212, "Min_50.0% Prob": 0.9318842633996806, "Min_60.0% Prob": 0.7782450212791947}}
{"hexsha": "13686ca21e0d7b6115c0bd2d364a4da0a2c26e7e", "ext": "rs", "lang": "Rust", "content": "pub fn get_rest_message_log_command(host: &str) -> Command {\n    let mut command = get_jcli_command();\n    command\n        .arg(\"rest\")\n        .arg(\"v0\")\n        .arg(\"message\")\n        .arg(\"logs\")\n        .arg(\"--host\")\n        .arg(&host);\n    command\n}", "item_id": 22, "repo": "fruicz/jormungandr", "file": "jormungandr-integration-tests/src/common/jcli_wrapper/jcli_commands.rs", "last_update_at": "2020-02-25T19:55:24+00:00", "question_id": "13686ca21e0d7b6115c0bd2d364a4da0a2c26e7e_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_rest_message_log_command(host: &str) -> Command {\n    let mut command = get_jcli_command();\n    command\n        .arg(\"rest\")\n        .arg(\"v0\")\n        .arg(\"message\")\n        .arg(\"logs\")\n        .arg(\"--host\")\n        .arg(&host);\n    command\n"]], "pred": {"ppl": 3.070972442626953, "ppl_lower": 3.5692975521087646, "ppl/lowercase_ppl": -1.1340243427318726, "ppl/zlib": 0.008373091552226493, "Min_5.0% Prob": 8.74162757396698, "Min_10.0% Prob": 7.611383259296417, "Min_20.0% Prob": 4.858149612651152, "Min_30.0% Prob": 3.6207881665229795, "Min_40.0% Prob": 2.7568493415327633, "Min_50.0% Prob": 2.2603667594847225, "Min_60.0% Prob": 1.867890019590656}}
{"hexsha": "4de5d4efcf4916b2324e1dc1497ca441069da132", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn datetime_set(\n    year: c_int,\n    month: c_int,\n    day: c_int,\n    hour: c_int,\n    minute: c_int,\n    second: c_int,\n) -> c_int {\n    let mut time: libc::tm = mem::zeroed();\n    time.tm_year = year - 1900;\n    time.tm_mon = month - 1;\n    time.tm_mday = day;\n    time.tm_hour = hour;\n    time.tm_min = minute;\n    time.tm_sec = second;\n    if time.tm_year < 0 {\n        time.tm_year = 0;\n    }\n    let t: time_t = mktime(&mut time);\n    if t == -1 {\n        return -1;\n    }\n    let tv: timeval = timeval {\n        tv_sec: t,\n        tv_usec: 0,\n    };\n    if settimeofday(&tv, ptr::null()) == -1 {\n        if Error::last_os_error().kind() == ErrorKind::PermissionDenied {\n            return -2;\n        } else {\n            return -3;\n        }\n    };\n    0\n}", "item_id": 0, "repo": "duallsistemas/libduallutils", "file": "src/linux.rs", "last_update_at": "2020-05-28T23:56:15+00:00", "question_id": "4de5d4efcf4916b2324e1dc1497ca441069da132_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn datetime_set(\n    year: c_int,\n    month: c_int,\n    day: c_int,\n    hour: c_int,\n    minute: c_int,\n    second: c_int,\n) -> c_int {\n    let mut time: libc::tm = mem::zeroed();\n    time.tm_year = year - 1900;\n    time.tm_mon = month - 1;\n    time.tm_mday = day;\n    time.tm_hour = hour;\n    time.tm_min = minute;\n    time.tm_sec = second;\n    if time.tm_year < 0 {\n        time.tm_year = 0;\n    }\n    let t: time_t = mktime(&mut time);\n    if t == -1 {\n        return -1;\n    }\n    let tv: timeval = timeval {\n        tv_sec: t,\n        tv_usec: 0,\n    };\n    if settimeofday(&tv, ptr::null()) == -1 {\n        if Error::last_os_error().kind() == ErrorKind::PermissionDenied {\n            return -2;\n        } else {\n            return -3;\n        }\n    };\n    0\n"]], "pred": {"ppl": 1.604764461517334, "ppl_lower": 1.7246087789535522, "ppl/lowercase_ppl": -1.1522764070442941, "ppl/zlib": 0.0014118716204895821, "Min_5.0% Prob": 5.447626193364461, "Min_10.0% Prob": 3.7787391781806945, "Min_20.0% Prob": 2.2476186503152378, "Min_30.0% Prob": 1.5693357577035716, "Min_40.0% Prob": 1.1813892538460795, "Min_50.0% Prob": 0.9445422810618005, "Min_60.0% Prob": 0.7905127815545989}}
{"hexsha": "c2a9e41d38d20412f29645384be77fbf4fc5263f", "ext": "rs", "lang": "Rust", "content": "async fn test_modify_policies_api() {\n        let m = DefaultModel::from_file(\"examples/rbac_model.conf\")\n            .await\n            .unwrap();\n\n        let adapter = FileAdapter::new(\"examples/rbac_policy.csv\");\n        let mut e = Enforcer::new(m, adapter).await.unwrap();\n\n        assert_eq!(\n            vec![\n                vec![\"alice\", \"data1\", \"read\"],\n                vec![\"bob\", \"data2\", \"write\"],\n                vec![\"data2_admin\", \"data2\", \"read\"],\n                vec![\"data2_admin\", \"data2\", \"write\"],\n            ],\n            sort_unstable(e.get_policy())\n        );\n\n        e.remove_policies(vec![\n            vec![\"alice\", \"data1\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n            vec![\"bob\", \"data2\", \"write\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n        ])\n        .await\n        .unwrap();\n        e.remove_policies(vec![vec![\"alice\", \"data1\", \"read\"]\n            .iter()\n            .map(|s| s.to_string())\n            .collect()])\n            .await\n            .unwrap();\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"alice\", \"data1\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"bob\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        e.add_policies(vec![vec![\"eve\", \"data3\", \"read\"]\n            .iter()\n            .map(|s| s.to_string())\n            .collect()])\n            .await\n            .unwrap();\n        e.add_policies(vec![\n            vec![\"eve\", \"data3\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n            vec![\"eve\", \"data3\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n        ])\n        .await\n        .unwrap();\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"alice\", \"data1\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"bob\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"eve\", \"data3\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n\n        let named_policy = vec![\"eve\".to_string(), \"data3\".to_string(), \"read\".to_string()];\n        e.remove_named_policies(\"p\", vec![named_policy.clone()])\n            .await\n            .unwrap();\n        e.add_named_policies(\"p\", vec![named_policy.clone()])\n            .await\n            .unwrap();\n\n        assert_eq!(\n            vec![\n                vec![\"data2_admin\", \"data2\", \"read\"],\n                vec![\"data2_admin\", \"data2\", \"write\"],\n                vec![\"eve\", \"data3\", \"read\"],\n            ],\n            sort_unstable(e.get_policy())\n        );\n\n        e.remove_filtered_policy(1, vec![\"data2\"].iter().map(|s| s.to_string()).collect())\n            .await\n            .unwrap();\n        assert_eq!(vec![vec![\"eve\", \"data3\", \"read\"],], e.get_policy());\n    }", "item_id": 4, "repo": "somewheve/casbin-rs", "file": "src/management_api.rs", "last_update_at": "2020-06-15T02:56:52+00:00", "question_id": "c2a9e41d38d20412f29645384be77fbf4fc5263f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_modify_policies_api() {\n        let m = DefaultModel::from_file(\"examples/rbac_model.conf\")\n            .await\n            .unwrap();\n        let adapter = FileAdapter::new(\"examples/rbac_policy.csv\");\n        let mut e = Enforcer::new(m, adapter).await.unwrap();\n        assert_eq!(\n            vec![\n                vec![\"alice\", \"data1\", \"read\"],\n                vec![\"bob\", \"data2\", \"write\"],\n                vec![\"data2_admin\", \"data2\", \"read\"],\n                vec![\"data2_admin\", \"data2\", \"write\"],\n            ],\n            sort_unstable(e.get_policy())\n        );\n        e.remove_policies(vec![\n            vec![\"alice\", \"data1\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n            vec![\"bob\", \"data2\", \"write\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n        ])\n        .await\n        .unwrap();\n        e.remove_policies(vec![vec![\"alice\", \"data1\", \"read\"]\n            .iter()\n            .map(|s| s.to_string())\n            .collect()])\n            .await\n            .unwrap();\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"alice\", \"data1\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"bob\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        e.add_policies(vec![vec![\"eve\", \"data3\", \"read\"]\n            .iter()\n            .map(|s| s.to_string())\n            .collect()])\n            .await\n            .unwrap();\n        e.add_policies(vec![\n            vec![\"eve\", \"data3\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n            vec![\"eve\", \"data3\", \"read\"]\n                .iter()\n                .map(|s| s.to_string())\n                .collect(),\n        ])\n        .await\n        .unwrap();\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"alice\", \"data1\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            false,\n            e.has_policy(\n                vec![\"bob\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"eve\", \"data3\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"read\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        assert_eq!(\n            true,\n            e.has_policy(\n                vec![\"data2_admin\", \"data2\", \"write\"]\n                    .iter()\n                    .map(|s| s.to_string())\n                    .collect()\n            )\n        );\n        let named_policy = vec![\"eve\".to_string(), \"data3\".to_string(), \"read\".to_string()];\n        e.remove_named_policies(\"p\", vec![named_policy.clone()])\n            .await\n            .unwrap();\n        e.add_named_policies(\"p\", vec![named_policy.clone()])\n            .await\n            .unwrap();\n        assert_eq!(\n            vec![\n                vec![\"data2_admin\", \"data2\", \"read\"],\n                vec![\"data2_admin\", \"data2\", \"write\"],\n                vec![\"eve\", \"data3\", \"read\"],\n            ],\n            sort_unstable(e.get_policy())\n        );\n        e.remove_filtered_policy(1, vec![\"data2\"].iter().map(|s| s.to_string()).collect())\n            .await\n            .unwrap();\n        assert_eq!(vec![vec![\"eve\", \"data3\", \"read\"],], e.get_policy());\n"]], "pred": {"ppl": 1.2079156637191772, "ppl_lower": 1.2468184232711792, "ppl/lowercase_ppl": -1.1678104121031732, "ppl/zlib": 0.0003361143812694856, "Min_5.0% Prob": 3.1013074458814134, "Min_10.0% Prob": 1.7998406716129358, "Min_20.0% Prob": 0.9421516408522924, "Min_30.0% Prob": 0.6307892938938868, "Min_40.0% Prob": 0.4723149818797484, "Min_50.0% Prob": 0.3781223807315269, "Min_60.0% Prob": 0.31522661408627733}}
{"hexsha": "f30a3d3e230c2bd76483305c5568d339dbc94463", "ext": "rs", "lang": "Rust", "content": "fn test_getrlimit() {\n    let lim = rustix::process::getrlimit(Resource::Stack);\n    assert_ne!(lim.current, Some(0));\n    assert_ne!(lim.maximum, Some(0));\n}", "item_id": 0, "repo": "sunfishcode/posish", "file": "tests/process/rlimit.rs", "last_update_at": "2020-09-21T03:51:08+00:00", "question_id": "f30a3d3e230c2bd76483305c5568d339dbc94463_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_getrlimit() {\n    let lim = rustix::process::getrlimit(Resource::Stack);\n    assert_ne!(lim.current, Some(0));\n    assert_ne!(lim.maximum, Some(0));\n"]], "pred": {"ppl": 3.237581491470337, "ppl_lower": 4.63183069229126, "ppl/lowercase_ppl": -1.304832722290585, "ppl/zlib": 0.010041252972815367, "Min_5.0% Prob": 10.470241069793701, "Min_10.0% Prob": 7.421642303466797, "Min_20.0% Prob": 5.30975324457342, "Min_30.0% Prob": 3.7394605576992035, "Min_40.0% Prob": 2.968715186823498, "Min_50.0% Prob": 2.371249277942947, "Min_60.0% Prob": 1.9648307978230364}}
{"hexsha": "6e7799b4e39a5ea34926c9e1935bd9f63932f2ee", "ext": "rs", "lang": "Rust", "content": "fn test_float_iterator_count() {\n        assert_eq!(FloatIterator::new_with_step(-1.0, 1.0, 0.1).count(), 20);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 0.0, 0.5).count(), 4);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.75).count(), 4);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.75, 0.66667).count(), 6);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.33333).count(), 9);\n    }", "item_id": 2, "repo": "hexagram30/noise", "file": "src/util.rs", "last_update_at": "2020-04-29T16:40:59+00:00", "question_id": "6e7799b4e39a5ea34926c9e1935bd9f63932f2ee_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_float_iterator_count() {\n        assert_eq!(FloatIterator::new_with_step(-1.0, 1.0, 0.1).count(), 20);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 0.0, 0.5).count(), 4);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.75).count(), 4);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.75, 0.66667).count(), 6);\n        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.33333).count(), 9);\n"]], "pred": {"ppl": 1.9295493364334106, "ppl_lower": 2.0477349758148193, "ppl/lowercase_ppl": -1.0904443098330967, "ppl/zlib": 0.004728679649005329, "Min_5.0% Prob": 6.063860575358073, "Min_10.0% Prob": 4.431718700810483, "Min_20.0% Prob": 2.920489435133181, "Min_30.0% Prob": 2.105440781034272, "Min_40.0% Prob": 1.6286679499528625, "Min_50.0% Prob": 1.306830458304624, "Min_60.0% Prob": 1.097121153412194}}
{"hexsha": "fc5e6e319a1544d07c2486f8536d6696f920fe8c", "ext": "rs", "lang": "Rust", "content": "async fn test_notify_on_change() {\n        let data1 = LightData { illuminance: 10.0 };\n        let data2 = LightData { illuminance: 15.0 };\n\n        let (light_sender, light_receiver) = unbounded::<LightData>();\n\n        let (notifier_sender, mut notifier_receiver) = unbounded::<SettingType>();\n\n        let data: Arc<RwLock<LightData>> = Arc::new(RwLock::new(data1));\n\n        let aborter =\n            notify_on_change(light_receiver, Arc::new(RwLock::new(Some(notifier_sender))), data)\n                .await;\n\n        light_sender.unbounded_send(data2).unwrap();\n\n        assert_eq!(notifier_receiver.next().await.unwrap(), SettingType::LightSensor);\n\n        let next = notifier_receiver.try_next();\n        if let Ok(_) = next {\n            panic!(\"Only one change should have happened\")\n        };\n\n        aborter.abort();\n\n        let sleep_duration = zx::Duration::from_millis(5);\n        fasync::Timer::new(sleep_duration.after_now()).await;\n        assert_eq!(light_sender.is_closed(), true);\n    }", "item_id": 4, "repo": "winksaville/Fuchsia", "file": "garnet/bin/setui/src/display/light_sensor_controller.rs", "last_update_at": "2020-08-07T10:10:53+00:00", "question_id": "fc5e6e319a1544d07c2486f8536d6696f920fe8c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_notify_on_change() {\n        let data1 = LightData { illuminance: 10.0 };\n        let data2 = LightData { illuminance: 15.0 };\n        let (light_sender, light_receiver) = unbounded::<LightData>();\n        let (notifier_sender, mut notifier_receiver) = unbounded::<SettingType>();\n        let data: Arc<RwLock<LightData>> = Arc::new(RwLock::new(data1));\n        let aborter =\n            notify_on_change(light_receiver, Arc::new(RwLock::new(Some(notifier_sender))), data)\n                .await;\n        light_sender.unbounded_send(data2).unwrap();\n        assert_eq!(notifier_receiver.next().await.unwrap(), SettingType::LightSensor);\n        let next = notifier_receiver.try_next();\n        if let Ok(_) = next {\n            panic!(\"Only one change should have happened\")\n        };\n        aborter.abort();\n        let sleep_duration = zx::Duration::from_millis(5);\n        fasync::Timer::new(sleep_duration.after_now()).await;\n        assert_eq!(light_sender.is_closed(), true);\n"]], "pred": {"ppl": 2.3948445320129395, "ppl_lower": 3.087554454803467, "ppl/lowercase_ppl": -1.2909145718933337, "ppl/zlib": 0.0020597130075268094, "Min_5.0% Prob": 7.592599391937256, "Min_10.0% Prob": 5.752700947225094, "Min_20.0% Prob": 3.8296607583761215, "Min_30.0% Prob": 2.7983501087874174, "Min_40.0% Prob": 2.162783039850183, "Min_50.0% Prob": 1.747309019952081, "Min_60.0% Prob": 1.4590416155406274}}
{"hexsha": "b8b95c19692c50b7c43ca18799f2a5027deb90ab", "ext": "rs", "lang": "Rust", "content": "pub async fn download_and_display_offers(\n    network_str: Option<String>,\n    maker_address: Option<String>,\n) {\n    let mut rpc_network: Option<(Client, Network)> = None;\n\n    let maker_addresses = if let Some(maker_addr) = maker_address {\n        vec![MakerAddress::Tor {\n            address: maker_addr,\n        }]\n    } else {\n        let network = match get_bitcoin_rpc() {\n            Ok((rpc, network)) => {\n                rpc_network = Some((rpc, network));\n                network\n            }\n            Err(error) => {\n                if let Some(net_str) = network_str {\n                    str_to_bitcoin_network(net_str.as_str())\n                } else {\n                    panic!(\n                        \"network string not provided, and error connecting to bitcoin node: {:?}\",\n                        error\n                    );\n                }\n            }\n        };\n        get_advertised_maker_addresses(network)\n            .await\n            .expect(\"unable to sync maker addresses from directory servers\")\n    };\n    let offers_addresses = sync_offerbook_with_addresses(maker_addresses.clone()).await;\n    let mut addresses_offers_map = HashMap::new();\n    for offer_address in offers_addresses.iter() {\n        let address_str = match &offer_address.address {\n            MakerAddress::Clearnet { address } => address,\n            MakerAddress::Tor { address } => address,\n        };\n        addresses_offers_map.insert(address_str, offer_address);\n    }\n\n    println!(\n        \"{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}\",\n        \"n\",\n        \"maker address\",\n        \"max size\",\n        \"min size\",\n        \"abs fee\",\n        \"amt rel fee\",\n        \"time rel fee\",\n        \"minlocktime\",\n        \"fidelity bond value\",\n    );\n    let block_count = rpc_network\n        .as_ref()\n        .map(|(rpc, _)| rpc.get_block_count().unwrap())\n        .unwrap_or(0);\n    let median_time = rpc_network\n        .as_ref()\n        .map(|(rpc, _)| rpc.get_blockchain_info().unwrap().median_time)\n        .unwrap_or(0);\n\n    for (ii, address) in maker_addresses.iter().enumerate() {\n        let address_str = match &address {\n            MakerAddress::Clearnet { address } => address,\n            MakerAddress::Tor { address } => address,\n        };\n        if let Some(offer_address) = addresses_offers_map.get(&address_str) {\n            let o = &offer_address.offer;\n            let fidelity_bond_value_str = if rpc_network.is_some() {\n                let (rpc, network) = rpc_network.as_ref().unwrap();\n                let onion_hostname = if *network != Network::Regtest {\n                    address_str\n                } else {\n                    REGTEST_DUMMY_ONION_HOSTNAME\n                };\n                let txo_data = o\n                    .fidelity_bond_proof\n                    .verify_and_get_txo(&rpc, block_count, onion_hostname)\n                    .unwrap();\n                let value = o\n                    .fidelity_bond_proof\n                    .calculate_fidelity_bond_value(&rpc, block_count, &txo_data, median_time)\n                    .unwrap();\n                format!(\"{:.4e}\", value)\n            } else {\n                String::from(\"unknown\")\n            };\n\n            println!(\n                \"{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}\",\n                ii,\n                address_str,\n                o.max_size,\n                o.min_size,\n                o.absolute_fee_sat,\n                o.amount_relative_fee_ppb,\n                o.time_relative_fee_ppb,\n                o.minimum_locktime,\n                fidelity_bond_value_str\n            );\n        } else {\n            println!(\"{:<3} {:<70} UNREACHABLE\", ii, address_str);\n        }\n    }\n}", "item_id": 9, "repo": "invisible-unlinked-transactions/invisible-unlinked-transactions", "file": "src/lib.rs", "last_update_at": "2020-06-14T22:46:28+00:00", "question_id": "b8b95c19692c50b7c43ca18799f2a5027deb90ab_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn download_and_display_offers(\n    network_str: Option<String>,\n    maker_address: Option<String>,\n) {\n    let mut rpc_network: Option<(Client, Network)> = None;\n    let maker_addresses = if let Some(maker_addr) = maker_address {\n        vec![MakerAddress::Tor {\n            address: maker_addr,\n        }]\n    } else {\n        let network = match get_bitcoin_rpc() {\n            Ok((rpc, network)) => {\n                rpc_network = Some((rpc, network));\n                network\n            }\n            Err(error) => {\n                if let Some(net_str) = network_str {\n                    str_to_bitcoin_network(net_str.as_str())\n                } else {\n                    panic!(\n                        \"network string not provided, and error connecting to bitcoin node: {:?}\",\n                        error\n                    );\n                }\n            }\n        };\n        get_advertised_maker_addresses(network)\n            .await\n            .expect(\"unable to sync maker addresses from directory servers\")\n    };\n    let offers_addresses = sync_offerbook_with_addresses(maker_addresses.clone()).await;\n    let mut addresses_offers_map = HashMap::new();\n    for offer_address in offers_addresses.iter() {\n        let address_str = match &offer_address.address {\n            MakerAddress::Clearnet { address } => address,\n            MakerAddress::Tor { address } => address,\n        };\n        addresses_offers_map.insert(address_str, offer_address);\n    }\n    println!(\n        \"{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}\",\n        \"n\",\n        \"maker address\",\n        \"max size\",\n        \"min size\",\n        \"abs fee\",\n        \"amt rel fee\",\n        \"time rel fee\",\n        \"minlocktime\",\n        \"fidelity bond value\",\n    );\n    let block_count = rpc_network\n        .as_ref()\n        .map(|(rpc, _)| rpc.get_block_count().unwrap())\n        .unwrap_or(0);\n    let median_time = rpc_network\n        .as_ref()\n        .map(|(rpc, _)| rpc.get_blockchain_info().unwrap().median_time)\n        .unwrap_or(0);\n    for (ii, address) in maker_addresses.iter().enumerate() {\n        let address_str = match &address {\n            MakerAddress::Clearnet { address } => address,\n            MakerAddress::Tor { address } => address,\n        };\n        if let Some(offer_address) = addresses_offers_map.get(&address_str) {\n            let o = &offer_address.offer;\n            let fidelity_bond_value_str = if rpc_network.is_some() {\n                let (rpc, network) = rpc_network.as_ref().unwrap();\n                let onion_hostname = if *network != Network::Regtest {\n                    address_str\n                } else {\n                    REGTEST_DUMMY_ONION_HOSTNAME\n                };\n                let txo_data = o\n                    .fidelity_bond_proof\n                    .verify_and_get_txo(&rpc, block_count, onion_hostname)\n                    .unwrap();\n                let value = o\n                    .fidelity_bond_proof\n                    .calculate_fidelity_bond_value(&rpc, block_count, &txo_data, median_time)\n                    .unwrap();\n                format!(\"{:.4e}\", value)\n            } else {\n                String::from(\"unknown\")\n            };\n            println!(\n                \"{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}\",\n                ii,\n                address_str,\n                o.max_size,\n                o.min_size,\n                o.absolute_fee_sat,\n                o.amount_relative_fee_ppb,\n                o.time_relative_fee_ppb,\n                o.minimum_locktime,\n                fidelity_bond_value_str\n            );\n        } else {\n            println!(\"{:<3} {:<70} UNREACHABLE\", ii, address_str);\n        }\n    }\n"]], "pred": {"ppl": 2.118110418319702, "ppl_lower": 2.3193929195404053, "ppl/lowercase_ppl": -1.1209568965838084, "ppl/zlib": 0.000679822807170057, "Min_5.0% Prob": 6.920286122490378, "Min_10.0% Prob": 5.220657332270753, "Min_20.0% Prob": 3.3720919939817167, "Min_30.0% Prob": 2.4167571057096806, "Min_40.0% Prob": 1.8583510124778106, "Min_50.0% Prob": 1.4984295352301953, "Min_60.0% Prob": 1.251767307710583}}
{"hexsha": "a5df90a6da461ddf854634bd30388390f3510e87", "ext": "rs", "lang": "Rust", "content": "pub fn reload_config(app_state: &Arc<RwLock<AppState>>) {\n    let old_config = app_state.read().config.clone();\n    let new_config = Config::read(&app_state.read().config_path);\n    app_state.write().config = new_config.clone();\n\n    for task in new_config.tasks.keys() {\n        if !old_config.tasks.contains_key(task) {\n            app_state.write().tasks.insert(task.to_owned(), Arc::new(RwLock::new(TaskState::new(task))));\n        }\n    }\n    send_message(&app_state.read().events, Event::UpdateConfig);\n}", "item_id": 0, "repo": "Mewp/taru", "file": "src/app_state.rs", "last_update_at": "2020-08-15T08:02:38+00:00", "question_id": "a5df90a6da461ddf854634bd30388390f3510e87_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn reload_config(app_state: &Arc<RwLock<AppState>>) {\n    let old_config = app_state.read().config.clone();\n    let new_config = Config::read(&app_state.read().config_path);\n    app_state.write().config = new_config.clone();\n    for task in new_config.tasks.keys() {\n        if !old_config.tasks.contains_key(task) {\n            app_state.write().tasks.insert(task.to_owned(), Arc::new(RwLock::new(TaskState::new(task))));\n        }\n    }\n    send_message(&app_state.read().events, Event::UpdateConfig);\n"]], "pred": {"ppl": 2.201857566833496, "ppl_lower": 2.877943754196167, "ppl/lowercase_ppl": -1.3392553570859582, "ppl/zlib": 0.0031074856404064155, "Min_5.0% Prob": 7.220788359642029, "Min_10.0% Prob": 4.954288426567526, "Min_20.0% Prob": 3.278831625685972, "Min_30.0% Prob": 2.4532881799866173, "Min_40.0% Prob": 1.938509014161194, "Min_50.0% Prob": 1.5623882656353851, "Min_60.0% Prob": 1.3139884526506789}}
{"hexsha": "310cc916e5f0219818b9a9a024731a78f12a3ae8", "ext": "rs", "lang": "Rust", "content": "pub fn flush_storage(storage: &mut Storage, buffer: KVBuffer) -> std::io::Result<()> {\n    let tx = storage.get_or_create_tx();\n    for ((col, key), value) in buffer.into_iter() {\n        if let Some(val) = &value {\n            tx.put(col, &key, val);\n        } else {\n            tx.delete(col, &key);\n        }\n    }\n    storage.persist_write()\n}", "item_id": 1, "repo": "trevor-crypto/thaler", "file": "chain-storage/src/buffer.rs", "last_update_at": "2020-10-06T00:11:30+00:00", "question_id": "310cc916e5f0219818b9a9a024731a78f12a3ae8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn flush_storage(storage: &mut Storage, buffer: KVBuffer) -> std::io::Result<()> {\n    let tx = storage.get_or_create_tx();\n    for ((col, key), value) in buffer.into_iter() {\n        if let Some(val) = &value {\n            tx.put(col, &key, val);\n        } else {\n            tx.delete(col, &key);\n        }\n    }\n    storage.persist_write()\n"]], "pred": {"ppl": 3.512589454650879, "ppl_lower": 4.5142107009887695, "ppl/lowercase_ppl": -1.1996865152270368, "ppl/zlib": 0.005954281999297806, "Min_5.0% Prob": 9.097698307037353, "Min_10.0% Prob": 7.547073971141469, "Min_20.0% Prob": 5.298378674880318, "Min_30.0% Prob": 3.912183431216649, "Min_40.0% Prob": 3.0776044130325317, "Min_50.0% Prob": 2.5066018248513595, "Min_60.0% Prob": 2.098137496013037}}
{"hexsha": "47236b1fbcbd9d978773b10e5314f7fa6a9b586d", "ext": "rs", "lang": "Rust", "content": "fn test_accessor() {\n    assert_eq!(Foo::hoge(), \"hoge\");\n    assert_eq!(Foo::piyo(), \"piyo\");\n    assert_eq!(accessor_name!(Foo::hoge), \"hoge\");\n}", "item_id": 4, "repo": "myuon/debil", "file": "debil/tests/lib.rs", "last_update_at": "2020-04-12T03:53:34+00:00", "question_id": "47236b1fbcbd9d978773b10e5314f7fa6a9b586d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_accessor() {\n    assert_eq!(Foo::hoge(), \"hoge\");\n    assert_eq!(Foo::piyo(), \"piyo\");\n    assert_eq!(accessor_name!(Foo::hoge), \"hoge\");\n"]], "pred": {"ppl": 3.6598546504974365, "ppl_lower": 3.942094326019287, "ppl/lowercase_ppl": -1.0572586415039857, "ppl/zlib": 0.015086318995881991, "Min_5.0% Prob": 9.39741563796997, "Min_10.0% Prob": 8.077595520019532, "Min_20.0% Prob": 5.593898036263206, "Min_30.0% Prob": 4.119697157074423, "Min_40.0% Prob": 3.196451752082161, "Min_50.0% Prob": 2.5898669860486327, "Min_60.0% Prob": 2.1677616419536725}}
{"hexsha": "2be006f9732f7fccae11a7aae05d5e02f090aa85", "ext": "rs", "lang": "Rust", "content": "fn newly_started() {\n        trace_init();\n\n        let message = \"9\";\n        let name = \"vector_test_newly_started\";\n        let label = \"vector_test_label_newly_started\";\n\n        let mut rt = runtime();\n        let out = source_with(&[name], None, &mut rt);\n\n        rt.block_on_std(async move {\n            let docker = docker().unwrap();\n\n            let id = container_log_n(1, name, Some(label), message, &docker).await;\n            let events = collect_n(out, 1).compat().await.ok().unwrap();\n            container_remove(&id, &docker).await;\n\n            let log = events[0].as_log();\n            assert_eq!(log[&event::log_schema().message_key()], message.into());\n            assert_eq!(log[&super::CONTAINER], id.into());\n            assert!(log.get(&super::CREATED_AT).is_some());\n            assert_eq!(log[&super::IMAGE], \"busybox\".into());\n            assert!(log.get(&format!(\"label.{}\", label).into()).is_some());\n            assert_eq!(events[0].as_log()[&super::NAME], name.into());\n            assert_eq!(\n                events[0].as_log()[event::log_schema().source_type_key()],\n                \"docker\".into()\n            );\n        });\n    }", "item_id": 7, "repo": "adamncasey/vector", "file": "src/sources/docker.rs", "last_update_at": "2020-12-17T10:32:55+00:00", "question_id": "2be006f9732f7fccae11a7aae05d5e02f090aa85_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn newly_started() {\n        trace_init();\n        let message = \"9\";\n        let name = \"vector_test_newly_started\";\n        let label = \"vector_test_label_newly_started\";\n        let mut rt = runtime();\n        let out = source_with(&[name], None, &mut rt);\n        rt.block_on_std(async move {\n            let docker = docker().unwrap();\n            let id = container_log_n(1, name, Some(label), message, &docker).await;\n            let events = collect_n(out, 1).compat().await.ok().unwrap();\n            container_remove(&id, &docker).await;\n            let log = events[0].as_log();\n            assert_eq!(log[&event::log_schema().message_key()], message.into());\n            assert_eq!(log[&super::CONTAINER], id.into());\n            assert!(log.get(&super::CREATED_AT).is_some());\n            assert_eq!(log[&super::IMAGE], \"busybox\".into());\n            assert!(log.get(&format!(\"label.{}\", label).into()).is_some());\n            assert_eq!(events[0].as_log()[&super::NAME], name.into());\n            assert_eq!(\n                events[0].as_log()[event::log_schema().source_type_key()],\n                \"docker\".into()\n            );\n        });\n"]], "pred": {"ppl": 2.686065673828125, "ppl_lower": 2.824415683746338, "ppl/lowercase_ppl": -1.050829975299881, "ppl/zlib": 0.0021715990070816284, "Min_5.0% Prob": 7.780773745642768, "Min_10.0% Prob": 6.028531054655711, "Min_20.0% Prob": 4.151395171880722, "Min_30.0% Prob": 3.081468693636082, "Min_40.0% Prob": 2.4059512054340706, "Min_50.0% Prob": 1.9566307433363463, "Min_60.0% Prob": 1.6416593491686162}}
{"hexsha": "2976c40b2e4add1ef6c832ab97ae9705d039cb04", "ext": "rs", "lang": "Rust", "content": "fn test_uniprot_cask_bovin() {\n        let entry = UniProtKB {\n            database: Database::SwissProt,\n            identifier: \"P02668\".to_string(),\n            entry_name: \"CASK_BOVIN\".to_string(),\n            protein_name: \"Kappa-casein\".to_string(),\n            organism_name: \"Bos taurus\".to_string(),\n            organism_identifier: \"9913\".to_string(),\n            gene_name: Some(\"CSN3\".to_string()),\n            protein_existence: ProteinExistence::ExperimentalEvidenceProtein,\n            sequence_version: \"1\".to_string(),\n        };\n        let test_header =\n            \">sp|P02668|CASK_BOVIN Kappa-casein OS=Bos taurus OX=9913 GN=CSN3 PE=1 SV=1\".as_bytes();\n        assert_eq!(uniprotkb(test_header).unwrap(), entry)\n    }", "item_id": 5, "repo": "TianyiShi2001/uniprot-fasta-header", "file": "src/uniprotkb.rs", "last_update_at": "2020-09-02T08:16:51+00:00", "question_id": "2976c40b2e4add1ef6c832ab97ae9705d039cb04_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_uniprot_cask_bovin() {\n        let entry = UniProtKB {\n            database: Database::SwissProt,\n            identifier: \"P02668\".to_string(),\n            entry_name: \"CASK_BOVIN\".to_string(),\n            protein_name: \"Kappa-casein\".to_string(),\n            organism_name: \"Bos taurus\".to_string(),\n            organism_identifier: \"9913\".to_string(),\n            gene_name: Some(\"CSN3\".to_string()),\n            protein_existence: ProteinExistence::ExperimentalEvidenceProtein,\n            sequence_version: \"1\".to_string(),\n        };\n        let test_header =\n            \">sp|P02668|CASK_BOVIN Kappa-casein OS=Bos taurus OX=9913 GN=CSN3 PE=1 SV=1\".as_bytes();\n        assert_eq!(uniprotkb(test_header).unwrap(), entry)\n"]], "pred": {"ppl": 2.56614089012146, "ppl_lower": 3.715500593185425, "ppl/lowercase_ppl": -1.392730264894943, "ppl/zlib": 0.0027395441023333844, "Min_5.0% Prob": 6.776231325589693, "Min_10.0% Prob": 5.540425373957707, "Min_20.0% Prob": 4.0212881060747, "Min_30.0% Prob": 3.029207069140214, "Min_40.0% Prob": 2.338721902029855, "Min_50.0% Prob": 1.887842208317673, "Min_60.0% Prob": 1.577665472243005}}
{"hexsha": "536aef5f082d0783eb75594c9d42c7bff10a4397", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn create_batch(signer: &Signer, transaction: Transaction) -> Batch {\n    // Construct BatchHeader\n    let mut batch_header = BatchHeader::new();\n    // set signer public key\n    let public_key = signer\n        .get_public_key()\n        .expect(\"Unable to get public key\")\n        .as_hex();\n    let transaction_ids = vec![transaction.clone()]\n        .iter()\n        .map(|trans| String::from(trans.get_header_signature()))\n        .collect();\n    batch_header.set_transaction_ids(RepeatedField::from_vec(transaction_ids));\n    batch_header.set_signer_public_key(public_key);\n\n    // Construct Batch\n    let batch_header_bytes = batch_header\n        .write_to_bytes()\n        .expect(\"Error converting batch header to bytes\");\n    let signature = signer\n        .sign(&batch_header_bytes)\n        .expect(\"Error signing the batch header\");\n    let mut batch = Batch::new();\n    batch.set_header_signature(signature);\n    batch.set_header(batch_header_bytes);\n    batch.set_transactions(RepeatedField::from_vec(vec![transaction]));\n    batch\n}", "item_id": 1, "repo": "manju956/produce-consume", "file": "cli/src/sawtooth_helper.rs", "last_update_at": "2020-05-27T12:25:38+00:00", "question_id": "536aef5f082d0783eb75594c9d42c7bff10a4397_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn create_batch(signer: &Signer, transaction: Transaction) -> Batch {\n    // Construct BatchHeader\n    let mut batch_header = BatchHeader::new();\n    // set signer public key\n    let public_key = signer\n        .get_public_key()\n        .expect(\"Unable to get public key\")\n        .as_hex();\n    let transaction_ids = vec![transaction.clone()]\n        .iter()\n        .map(|trans| String::from(trans.get_header_signature()))\n        .collect();\n    batch_header.set_transaction_ids(RepeatedField::from_vec(transaction_ids));\n    batch_header.set_signer_public_key(public_key);\n    // Construct Batch\n    let batch_header_bytes = batch_header\n        .write_to_bytes()\n        .expect(\"Error converting batch header to bytes\");\n    let signature = signer\n        .sign(&batch_header_bytes)\n        .expect(\"Error signing the batch header\");\n    let mut batch = Batch::new();\n    batch.set_header_signature(signature);\n    batch.set_header(batch_header_bytes);\n    batch.set_transactions(RepeatedField::from_vec(vec![transaction]));\n    batch\n"]], "pred": {"ppl": 1.8949016332626343, "ppl_lower": 2.3762714862823486, "ppl/lowercase_ppl": -1.3541574479565668, "ppl/zlib": 0.0016263789532278948, "Min_5.0% Prob": 6.572942574818929, "Min_10.0% Prob": 5.073523848287521, "Min_20.0% Prob": 2.9942472141886514, "Min_30.0% Prob": 2.0910785695439893, "Min_40.0% Prob": 1.5923177151112107, "Min_50.0% Prob": 1.276767876309653, "Min_60.0% Prob": 1.069369697557321}}
{"hexsha": "5f9d49cf2a7c6ac8c6616f9095fce308430a93a7", "ext": "rs", "lang": "Rust", "content": "fn error_cannot_return_value() {\n    let input = r#\"\n#[test]\nfn test() -> u8 {\n    require(true);\n    42\n}\n\nfn main() {\n    let value = test();\n}\n\"#;\n\n    let expected = Err(Error::Semantic(SemanticError::Element(ElementError::Type(\n        TypeError::Function(FunctionError::Test(TestFunctionError::CannotReturnValue {\n            location: Location::test(3, 1),\n            function: \"test\".to_owned(),\n        })),\n    ))));\n\n    let result = crate::semantic::tests::compile_entry(input);\n\n    assert_eq!(result, expected);\n}", "item_id": 5, "repo": "tpscrpt/zinc", "file": "zinc-compiler/src/semantic/element/type/function/test/tests.rs", "last_update_at": "2020-11-14T03:11:05+00:00", "question_id": "5f9d49cf2a7c6ac8c6616f9095fce308430a93a7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn error_cannot_return_value() {\n    let input = r#\"\n#[test]\nfn test() -> u8 {\n    require(true);\n    42\n}\nfn main() {\n    let value = test();\n}\n\"#;\n    let expected = Err(Error::Semantic(SemanticError::Element(ElementError::Type(\n        TypeError::Function(FunctionError::Test(TestFunctionError::CannotReturnValue {\n            location: Location::test(3, 1),\n            function: \"test\".to_owned(),\n        })),\n    ))));\n    let result = crate::semantic::tests::compile_entry(input);\n    assert_eq!(result, expected);\n"]], "pred": {"ppl": 2.1618826389312744, "ppl_lower": 4.0762715339660645, "ppl/lowercase_ppl": -1.8225943113435557, "ppl/zlib": 0.002658549773027784, "Min_5.0% Prob": 6.949594020843506, "Min_10.0% Prob": 5.133425698560827, "Min_20.0% Prob": 3.3282059325891384, "Min_30.0% Prob": 2.4321413525179323, "Min_40.0% Prob": 1.8945809510700844, "Min_50.0% Prob": 1.5387043760979877, "Min_60.0% Prob": 1.2906111300941192}}
{"hexsha": "3bba89cc0000c2071e29b960b0c9464964d35ebc", "ext": "rs", "lang": "Rust", "content": "fn info_with_compiled_source() {\n  let _g = util::http_server();\n  let module_path = \"http://127.0.0.1:4545/cli/tests/048_media_types_jsx.ts\";\n  let t = TempDir::new().expect(\"tempdir fail\");\n\n  let mut deno = util::deno_cmd()\n    .env(\"DENO_DIR\", t.path())\n    .current_dir(util::root_path())\n    .arg(\"cache\")\n    .arg(&module_path)\n    .spawn()\n    .expect(\"failed to spawn script\");\n  let status = deno.wait().expect(\"failed to wait for the child process\");\n  assert!(status.success());\n\n  let output = util::deno_cmd()\n    .env(\"DENO_DIR\", t.path())\n    .env(\"NO_COLOR\", \"1\")\n    .current_dir(util::root_path())\n    .arg(\"info\")\n    .arg(&module_path)\n    .output()\n    .expect(\"failed to spawn script\");\n\n  let str_output = std::str::from_utf8(&output.stdout).unwrap().trim();\n  eprintln!(\"{}\", str_output);\n  // check the output of the test.ts program.\n  assert!(str_output.contains(\"emit: \"));\n  assert_eq!(output.stderr, b\"\");\n}", "item_id": 0, "repo": "dalanad/deno", "file": "cli/tests/integration/info_tests.rs", "last_update_at": "2020-10-19T16:24:45+00:00", "question_id": "3bba89cc0000c2071e29b960b0c9464964d35ebc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn info_with_compiled_source() {\n  let _g = util::http_server();\n  let module_path = \"http://127.0.0.1:4545/cli/tests/048_media_types_jsx.ts\";\n  let t = TempDir::new().expect(\"tempdir fail\");\n  let mut deno = util::deno_cmd()\n    .env(\"DENO_DIR\", t.path())\n    .current_dir(util::root_path())\n    .arg(\"cache\")\n    .arg(&module_path)\n    .spawn()\n    .expect(\"failed to spawn script\");\n  let status = deno.wait().expect(\"failed to wait for the child process\");\n  assert!(status.success());\n  let output = util::deno_cmd()\n    .env(\"DENO_DIR\", t.path())\n    .env(\"NO_COLOR\", \"1\")\n    .current_dir(util::root_path())\n    .arg(\"info\")\n    .arg(&module_path)\n    .output()\n    .expect(\"failed to spawn script\");\n  let str_output = std::str::from_utf8(&output.stdout).unwrap().trim();\n  eprintln!(\"{}\", str_output);\n  // check the output of the test.ts program.\n  assert!(str_output.contains(\"emit: \"));\n  assert_eq!(output.stderr, b\"\");\n"]], "pred": {"ppl": 1.7788349390029907, "ppl_lower": 2.0288538932800293, "ppl/lowercase_ppl": -1.2283365901500445, "ppl/zlib": 0.0012799080474591056, "Min_5.0% Prob": 5.679645762724035, "Min_10.0% Prob": 4.2642909218283265, "Min_20.0% Prob": 2.715996363888616, "Min_30.0% Prob": 1.898437916372831, "Min_40.0% Prob": 1.4372453475974019, "Min_50.0% Prob": 1.1511877209681418, "Min_60.0% Prob": 0.9634861211681989}}
{"hexsha": "ed4f3e56fc96f1e3be0d9609cf06066243b68581", "ext": "rs", "lang": "Rust", "content": "fn render_readme_package_list(database: &Database) -> Result<String> {\n    let mut body = String::new();\n\n    let mut packages: Vec<database::Package> = database.query_package(None)?;\n    packages\n        .sort_by(|a, b| (&a.group, &a.name, &b.version).cmp(&((&b.group, &b.name, &a.version))));\n    packages.dedup_by(|a, b| (&a.group, &a.name).eq(&(&b.group, &b.name)));\n    // packages.sort_by(|a, b| b.version.cmp(&a.version));\n\n    for package in packages {\n        let user_name = database.query_user(package.user_id)?.unwrap().name;\n        let package_link = if let Some(url) = package.homepage.or(package.repository) {\n            format!(\n                \"[`{}/{} {}`]({})\",\n                package.group, package.name, package.version, url\n            )\n        } else {\n            format!(\"`{}/{} {}`\", package.group, package.name, package.version)\n        };\n        let package_description = if let Some(description) = package.description {\n            format!(\" *{}* \", description)\n        } else {\n            format!(\" \")\n        };\n        writeln!(\n            &mut body,\n            \"- {}{}[@{}]({})\",\n            package_link,\n            package_description,\n            &user_name,\n            github::url::user_profile(&user_name)\n        )\n        .unwrap();\n    }\n\n    Ok(body)\n}", "item_id": 1, "repo": "elba/elba-bot", "file": "src/controller/mod.rs", "last_update_at": "2020-03-07T13:10:21+00:00", "question_id": "ed4f3e56fc96f1e3be0d9609cf06066243b68581_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn render_readme_package_list(database: &Database) -> Result<String> {\n    let mut body = String::new();\n    let mut packages: Vec<database::Package> = database.query_package(None)?;\n    packages\n        .sort_by(|a, b| (&a.group, &a.name, &b.version).cmp(&((&b.group, &b.name, &a.version))));\n    packages.dedup_by(|a, b| (&a.group, &a.name).eq(&(&b.group, &b.name)));\n    // packages.sort_by(|a, b| b.version.cmp(&a.version));\n    for package in packages {\n        let user_name = database.query_user(package.user_id)?.unwrap().name;\n        let package_link = if let Some(url) = package.homepage.or(package.repository) {\n            format!(\n                \"[`{}/{} {}`]({})\",\n                package.group, package.name, package.version, url\n            )\n        } else {\n            format!(\"`{}/{} {}`\", package.group, package.name, package.version)\n        };\n        let package_description = if let Some(description) = package.description {\n            format!(\" *{}* \", description)\n        } else {\n            format!(\" \")\n        };\n        writeln!(\n            &mut body,\n            \"- {}{}[@{}]({})\",\n            package_link,\n            package_description,\n            &user_name,\n            github::url::user_profile(&user_name)\n        )\n        .unwrap();\n    }\n    Ok(body)\n"]], "pred": {"ppl": 2.112253427505493, "ppl_lower": 2.3177309036254883, "ppl/lowercase_ppl": -1.1241492892245104, "ppl/zlib": 0.001554584932909233, "Min_5.0% Prob": 6.736223769187927, "Min_10.0% Prob": 4.869186419248581, "Min_20.0% Prob": 3.2150925979018212, "Min_30.0% Prob": 2.3593738364676633, "Min_40.0% Prob": 1.843716044910252, "Min_50.0% Prob": 1.4887064779501649, "Min_60.0% Prob": 1.2461624291041455}}
{"hexsha": "2f1a92a4bb6b1233b02b72bac79594797b690120", "ext": "rs", "lang": "Rust", "content": "pub fn poll_messages(sqs: &dyn Sqs, opt: &Opt) -> Result<Vec<Message>> {\n    let queue_url = resolve_queue_url(sqs, opt)?;\n    let request = ReceiveMessageRequest {\n        queue_url: queue_url.clone(),\n        wait_time_seconds: Some(20),\n        ..Default::default()\n    };\n    let messages = sqs\n        .receive_message(request)\n        .sync()\n        .with_context(|| PollingMessage {\n            queue_url: queue_url.clone(),\n        })?\n        .messages\n        .unwrap_or_else(Vec::new);\n    Ok(messages)\n}", "item_id": 1, "repo": "bittrance/swarm-deployer", "file": "src/sqs.rs", "last_update_at": "2020-04-05T12:19:44+00:00", "question_id": "2f1a92a4bb6b1233b02b72bac79594797b690120_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn poll_messages(sqs: &dyn Sqs, opt: &Opt) -> Result<Vec<Message>> {\n    let queue_url = resolve_queue_url(sqs, opt)?;\n    let request = ReceiveMessageRequest {\n        queue_url: queue_url.clone(),\n        wait_time_seconds: Some(20),\n        ..Default::default()\n    };\n    let messages = sqs\n        .receive_message(request)\n        .sync()\n        .with_context(|| PollingMessage {\n            queue_url: queue_url.clone(),\n        })?\n        .messages\n        .unwrap_or_else(Vec::new);\n    Ok(messages)\n"]], "pred": {"ppl": 2.0728917121887207, "ppl_lower": 3.025390863418579, "ppl/lowercase_ppl": -1.518689214537026, "ppl/zlib": 0.0027301295687006556, "Min_5.0% Prob": 7.949868440628052, "Min_10.0% Prob": 5.568096816539764, "Min_20.0% Prob": 3.323249419530233, "Min_30.0% Prob": 2.333473527431488, "Min_40.0% Prob": 1.7942906406833166, "Min_50.0% Prob": 1.450248912021163, "Min_60.0% Prob": 1.2227345199137927}}
{"hexsha": "33f7c609ec8dbc44e870594fb88e7f3a553f8966", "ext": "rs", "lang": "Rust", "content": "fn test_basic_fault_tolerance() {\n    // A configuration with 4 validators should tolerate single node failure.\n    let (mut env, client_proxy) = setup_swarm_and_client_proxy(4, 1);\n    // kill the first validator\n    env.validator_swarm.kill_node(0);\n    // run the script for the smoke test by submitting requests to the second validator\n    test_smoke_script(client_proxy);\n}", "item_id": 1, "repo": "xshl202007/libra", "file": "testsuite/smoke-test/src/client.rs", "last_update_at": "2020-09-30T10:19:22+00:00", "question_id": "33f7c609ec8dbc44e870594fb88e7f3a553f8966_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_basic_fault_tolerance() {\n    // A configuration with 4 validators should tolerate single node failure.\n    let (mut env, client_proxy) = setup_swarm_and_client_proxy(4, 1);\n    // kill the first validator\n    env.validator_swarm.kill_node(0);\n    // run the script for the smoke test by submitting requests to the second validator\n    test_smoke_script(client_proxy);\n"]], "pred": {"ppl": 2.8653879165649414, "ppl_lower": 2.9241573810577393, "ppl/lowercase_ppl": -1.0192861715183366, "ppl/zlib": 0.004557159045251716, "Min_5.0% Prob": 7.402013683319092, "Min_10.0% Prob": 5.571630044416948, "Min_20.0% Prob": 3.960963389147883, "Min_30.0% Prob": 3.15308534748414, "Min_40.0% Prob": 2.5215038216632344, "Min_50.0% Prob": 2.0986433481438116, "Min_60.0% Prob": 1.7506186190074768}}
{"hexsha": "f96689d9fe0baeefae8f3df677f31d76ee06b14e", "ext": "rs", "lang": "Rust", "content": "fn parse_wire(s: &str) -> Wire {\n    let mut horiz = Vec::new();\n    let mut vert = Vec::new();\n    let mut y = 0;\n    let mut x = 0;\n    let mut total_length = 0;\n\n    for seg in s.split(',') {\n        let dir = seg.chars().next().unwrap();\n        let length: i32 = seg[1..].parse().expect(\"can't parse integer\");\n\n        let old_y = y;\n        let old_x = x;\n        let old_length = total_length;\n\n        total_length += length;\n\n        match dir {\n            'U' => {\n                y -= length;\n                vert.push((x, y, old_y, total_length, -1));\n            }\n            'D' => {\n                y += length;\n                vert.push((x, old_y, y, old_length, 1));\n            }\n            'L' => {\n                x -= length;\n                horiz.push((y, x, old_x, total_length, -1));\n            }\n            'R' => {\n                x += length;\n                horiz.push((y, old_x, x, old_length, 1));\n            }\n            _ => panic!(\"Unknown direction {} of {}\", dir, seg),\n        }\n    }\n    (horiz, vert)\n}", "item_id": 1, "repo": "petertseng/adventofcode-rs-2019", "file": "src/bin/03_crossed_wires.rs", "last_update_at": "2020-01-05T10:55:21+00:00", "question_id": "f96689d9fe0baeefae8f3df677f31d76ee06b14e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_wire(s: &str) -> Wire {\n    let mut horiz = Vec::new();\n    let mut vert = Vec::new();\n    let mut y = 0;\n    let mut x = 0;\n    let mut total_length = 0;\n    for seg in s.split(',') {\n        let dir = seg.chars().next().unwrap();\n        let length: i32 = seg[1..].parse().expect(\"can't parse integer\");\n        let old_y = y;\n        let old_x = x;\n        let old_length = total_length;\n        total_length += length;\n        match dir {\n            'U' => {\n                y -= length;\n                vert.push((x, y, old_y, total_length, -1));\n            }\n            'D' => {\n                y += length;\n                vert.push((x, old_y, y, old_length, 1));\n            }\n            'L' => {\n                x -= length;\n                horiz.push((y, x, old_x, total_length, -1));\n            }\n            'R' => {\n                x += length;\n                horiz.push((y, old_x, x, old_length, 1));\n            }\n            _ => panic!(\"Unknown direction {} of {}\", dir, seg),\n        }\n    }\n    (horiz, vert)\n"]], "pred": {"ppl": 1.612434983253479, "ppl_lower": 1.7668908834457397, "ppl/lowercase_ppl": -1.191474331962801, "ppl/zlib": 0.0013053154328195083, "Min_5.0% Prob": 5.6662295425639435, "Min_10.0% Prob": 3.825706232996548, "Min_20.0% Prob": 2.2734451070427895, "Min_30.0% Prob": 1.5773913623655544, "Min_40.0% Prob": 1.196201649508165, "Min_50.0% Prob": 0.9545754174516694, "Min_60.0% Prob": 0.7967972614734274}}
{"hexsha": "aa63833f6517ba9e68bc10395dbf87eba8352503", "ext": "rs", "lang": "Rust", "content": "pub async fn send_ping<S>(mut stream: S) -> io::Result<(S, Duration)>\nwhere\n    S: AsyncRead + AsyncWrite + Unpin\n{\n    let payload: [u8; PING_SIZE] = thread_rng().sample(distributions::Standard);\n    log::debug!(\"Preparing ping payload {:?}\", payload);\n    stream.write_all(&payload).await?;\n    stream.flush().await?;\n    let started = Instant::now();\n    let mut recv_payload = [0u8; PING_SIZE];\n    log::debug!(\"Awaiting pong for {:?}\", payload);\n    stream.read_exact(&mut recv_payload).await?;\n    if recv_payload == payload {\n        Ok((stream, started.elapsed()))\n    } else {\n        Err(io::Error::new(io::ErrorKind::InvalidData, \"Ping payload mismatch\"))\n    }\n}", "item_id": 0, "repo": "jgraef/rust-libp2p", "file": "protocols/ping/src/protocol.rs", "last_update_at": "2020-11-16T08:43:55+00:00", "question_id": "aa63833f6517ba9e68bc10395dbf87eba8352503_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn send_ping<S>(mut stream: S) -> io::Result<(S, Duration)>\nwhere\n    S: AsyncRead + AsyncWrite + Unpin\n{\n    let payload: [u8; PING_SIZE] = thread_rng().sample(distributions::Standard);\n    log::debug!(\"Preparing ping payload {:?}\", payload);\n    stream.write_all(&payload).await?;\n    stream.flush().await?;\n    let started = Instant::now();\n    let mut recv_payload = [0u8; PING_SIZE];\n    log::debug!(\"Awaiting pong for {:?}\", payload);\n    stream.read_exact(&mut recv_payload).await?;\n    if recv_payload == payload {\n        Ok((stream, started.elapsed()))\n    } else {\n        Err(io::Error::new(io::ErrorKind::InvalidData, \"Ping payload mismatch\"))\n    }\n"]], "pred": {"ppl": 2.0606002807617188, "ppl_lower": 3.250715970993042, "ppl/lowercase_ppl": -1.630538879760987, "ppl/zlib": 0.001954046861570899, "Min_5.0% Prob": 6.474769678982821, "Min_10.0% Prob": 4.919582269408486, "Min_20.0% Prob": 3.24850744538837, "Min_30.0% Prob": 2.3613031635533517, "Min_40.0% Prob": 1.7925808443791336, "Min_50.0% Prob": 1.4486815210631383, "Min_60.0% Prob": 1.2039369622279925}}
{"hexsha": "c22f47f48cb8222fd049be9f83196b0bea3aed08", "ext": "rs", "lang": "Rust", "content": "fn clear_components(&mut self) -> result::Result<(), ClearComponentsError> {\n        let mut err = ClearComponentsError::new();\n        for type_id in self.components_attached().iter() {\n            if let Err(e) = self\n                .component_manager()\n                .delete_component_by_id(&self, type_id)\n            {\n                err.push(e);\n            }\n        }\n\n        self.components_attached_mut().clear();\n\n        if err.len() > 0 {\n            Err(err)\n        } else {\n            Ok(())\n        }\n    }", "item_id": 2, "repo": "stmobo/akashi", "file": "akashi/src/ecs/entity.rs", "last_update_at": "2020-01-28T18:40:31+00:00", "question_id": "c22f47f48cb8222fd049be9f83196b0bea3aed08_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn clear_components(&mut self) -> result::Result<(), ClearComponentsError> {\n        let mut err = ClearComponentsError::new();\n        for type_id in self.components_attached().iter() {\n            if let Err(e) = self\n                .component_manager()\n                .delete_component_by_id(&self, type_id)\n            {\n                err.push(e);\n            }\n        }\n        self.components_attached_mut().clear();\n        if err.len() > 0 {\n            Err(err)\n        } else {\n            Ok(())\n        }\n"]], "pred": {"ppl": 2.4811646938323975, "ppl_lower": 3.121317148208618, "ppl/lowercase_ppl": -1.252580496833253, "ppl/zlib": 0.003755074729516157, "Min_5.0% Prob": 7.934865406581333, "Min_10.0% Prob": 5.975169028554644, "Min_20.0% Prob": 3.8471963570035737, "Min_30.0% Prob": 2.8385288498618384, "Min_40.0% Prob": 2.2465055775025795, "Min_50.0% Prob": 1.8211985182476371, "Min_60.0% Prob": 1.516627949831838}}
{"hexsha": "2e0077dc429ff52d794f204d90700dcbf97629cc", "ext": "rs", "lang": "Rust", "content": "fn dir_to_symlink2file() {\n            let id = function_name!();\n\n            prepare_test(id).unwrap();\n            mkdir(id, \"d1\").unwrap();\n            mkfile(id, \"f1\").unwrap();\n            mklink(id, \"f1\", \"lf1\").unwrap();\n\n            let dry_run = false;\n            let sources: Vec<PathBuf> = vec![mkpathbuf(id, \"d1\")];\n            let dests: Vec<String> = vec![mkpathstring(id, \"lf1\")];\n            let num_errors = move_files(&sources, &dests, dry_run, false, false, None);\n\n            assert_eq!(num_errors, 1);\n            assert!(mkpathbuf(id, \"d1\").is_dir());\n            assert!(mkpathbuf(id, \"f1\").is_file());\n        }", "item_id": 11, "repo": "sgryjp/pmv", "file": "src/fsutil.rs", "last_update_at": "2020-06-25T12:39:06+00:00", "question_id": "2e0077dc429ff52d794f204d90700dcbf97629cc_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dir_to_symlink2file() {\n            let id = function_name!();\n            prepare_test(id).unwrap();\n            mkdir(id, \"d1\").unwrap();\n            mkfile(id, \"f1\").unwrap();\n            mklink(id, \"f1\", \"lf1\").unwrap();\n            let dry_run = false;\n            let sources: Vec<PathBuf> = vec![mkpathbuf(id, \"d1\")];\n            let dests: Vec<String> = vec![mkpathstring(id, \"lf1\")];\n            let num_errors = move_files(&sources, &dests, dry_run, false, false, None);\n            assert_eq!(num_errors, 1);\n            assert!(mkpathbuf(id, \"d1\").is_dir());\n            assert!(mkpathbuf(id, \"f1\").is_file());\n"]], "pred": {"ppl": 2.799241304397583, "ppl_lower": 3.1505327224731445, "ppl/lowercase_ppl": -1.1148524027400373, "ppl/zlib": 0.003756746050178759, "Min_5.0% Prob": 8.010752964019776, "Min_10.0% Prob": 6.208779675619943, "Min_20.0% Prob": 4.242536982824636, "Min_30.0% Prob": 3.195197876600119, "Min_40.0% Prob": 2.5280235794394517, "Min_50.0% Prob": 2.0494606209987842, "Min_60.0% Prob": 1.7136398566313662}}
{"hexsha": "b277ed30c270a78437515a2b34f644a6c6eb1844", "ext": "rs", "lang": "Rust", "content": "fn jmp_not_eq() {\n        let mut mem = Memory::new(14);\n        mem.set_u8(0, instruction::MOVE_LIT_REG.opcode);\n        mem.set_u16(1, 0x1234);\n        mem.set_u8(3, register::ACC as u8);\n        mem.set_u8(4, instruction::JNE_LIT_MEM.opcode);\n        mem.set_u16(5, 0x1234);\n        mem.set_u16(7, 0x0);\n        mem.set_u8(9, instruction::JNE_LIT_MEM.opcode);\n        mem.set_u16(10, 0x12AB);\n        mem.set_u16(12, 0x2);\n\n        let mut cpu = CPU::new(Box::new(mem));\n        cpu.step();\n        assert_eq!(cpu.get_register(register::ACC), 0x1234);\n        cpu.step();\n        assert_eq!(cpu.get_register(register::IP), 0x9);\n        cpu.step();\n        assert_eq!(cpu.get_register(register::IP), 0x2);\n    }", "item_id": 32, "repo": "AndreiKazakov/rust-16-bit-vm", "file": "src/cpu.rs", "last_update_at": "2020-08-28T13:05:23+00:00", "question_id": "b277ed30c270a78437515a2b34f644a6c6eb1844_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn jmp_not_eq() {\n        let mut mem = Memory::new(14);\n        mem.set_u8(0, instruction::MOVE_LIT_REG.opcode);\n        mem.set_u16(1, 0x1234);\n        mem.set_u8(3, register::ACC as u8);\n        mem.set_u8(4, instruction::JNE_LIT_MEM.opcode);\n        mem.set_u16(5, 0x1234);\n        mem.set_u16(7, 0x0);\n        mem.set_u8(9, instruction::JNE_LIT_MEM.opcode);\n        mem.set_u16(10, 0x12AB);\n        mem.set_u16(12, 0x2);\n        let mut cpu = CPU::new(Box::new(mem));\n        cpu.step();\n        assert_eq!(cpu.get_register(register::ACC), 0x1234);\n        cpu.step();\n        assert_eq!(cpu.get_register(register::IP), 0x9);\n        cpu.step();\n        assert_eq!(cpu.get_register(register::IP), 0x2);\n"]], "pred": {"ppl": 1.8880892992019653, "ppl_lower": 2.068824291229248, "ppl/lowercase_ppl": -1.1438327366510472, "ppl/zlib": 0.002502225846105925, "Min_5.0% Prob": 6.484013716379802, "Min_10.0% Prob": 4.789988763870731, "Min_20.0% Prob": 2.9027469432543196, "Min_30.0% Prob": 2.0666536706242153, "Min_40.0% Prob": 1.571479289215945, "Min_50.0% Prob": 1.269880261829799, "Min_60.0% Prob": 1.0576338762584976}}
{"hexsha": "d9ee3bc90fb8c60e7053fba4d19d4490501bcd5e", "ext": "rs", "lang": "Rust", "content": "fn install_sh(\n    builder: &Builder<'_>,\n    package: &str,\n    name: &str,\n    stage: u32,\n    host: Option<TargetSelection>,\n) {\n    builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n\n    let prefix_default = PathBuf::from(\"/usr/local\");\n    let sysconfdir_default = PathBuf::from(\"/etc\");\n    let datadir_default = PathBuf::from(\"share\");\n    let docdir_default = datadir_default.join(\"doc/rust\");\n    let libdir_default = PathBuf::from(\"lib\");\n    let mandir_default = datadir_default.join(\"man\");\n    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n        fs::create_dir_all(p)\n            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n        fs::canonicalize(p)\n            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n    });\n    let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n    let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n    let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n    let bindir = &builder.config.bindir;\n    let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n    let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n\n    let sysconfdir = prefix.join(sysconfdir);\n    let datadir = prefix.join(datadir);\n    let docdir = prefix.join(docdir);\n    let bindir = prefix.join(bindir);\n    let libdir = prefix.join(libdir);\n    let mandir = prefix.join(mandir);\n\n    let destdir = env::var_os(\"DESTDIR\").map(PathBuf::from);\n\n    let prefix = add_destdir(&prefix, &destdir);\n    let sysconfdir = add_destdir(&sysconfdir, &destdir);\n    let datadir = add_destdir(&datadir, &destdir);\n    let docdir = add_destdir(&docdir, &destdir);\n    let bindir = add_destdir(&bindir, &destdir);\n    let libdir = add_destdir(&libdir, &destdir);\n    let mandir = add_destdir(&mandir, &destdir);\n\n    let empty_dir = builder.out.join(\"tmp/empty_dir\");\n\n    t!(fs::create_dir_all(&empty_dir));\n    let package_name = if let Some(host) = host {\n        format!(\"{}-{}\", pkgname(builder, name), host.triple)\n    } else {\n        pkgname(builder, name)\n    };\n\n    let mut cmd = Command::new(\"sh\");\n    cmd.current_dir(&empty_dir)\n        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n        .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n        .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n        .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n        .arg(format!(\"--docdir={}\", sanitize_sh(&docdir)))\n        .arg(format!(\"--bindir={}\", sanitize_sh(&bindir)))\n        .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n        .arg(format!(\"--mandir={}\", sanitize_sh(&mandir)))\n        .arg(\"--disable-ldconfig\");\n    builder.run(&mut cmd);\n    t!(fs::remove_dir_all(&empty_dir));\n}", "item_id": 0, "repo": "albins/rust", "file": "src/bootstrap/install.rs", "last_update_at": "2020-08-13T13:14:45+00:00", "question_id": "d9ee3bc90fb8c60e7053fba4d19d4490501bcd5e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn install_sh(\n    builder: &Builder<'_>,\n    package: &str,\n    name: &str,\n    stage: u32,\n    host: Option<TargetSelection>,\n) {\n    builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n    let prefix_default = PathBuf::from(\"/usr/local\");\n    let sysconfdir_default = PathBuf::from(\"/etc\");\n    let datadir_default = PathBuf::from(\"share\");\n    let docdir_default = datadir_default.join(\"doc/rust\");\n    let libdir_default = PathBuf::from(\"lib\");\n    let mandir_default = datadir_default.join(\"man\");\n    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n        fs::create_dir_all(p)\n            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n        fs::canonicalize(p)\n            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n    });\n    let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n    let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n    let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n    let bindir = &builder.config.bindir;\n    let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n    let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n    let sysconfdir = prefix.join(sysconfdir);\n    let datadir = prefix.join(datadir);\n    let docdir = prefix.join(docdir);\n    let bindir = prefix.join(bindir);\n    let libdir = prefix.join(libdir);\n    let mandir = prefix.join(mandir);\n    let destdir = env::var_os(\"DESTDIR\").map(PathBuf::from);\n    let prefix = add_destdir(&prefix, &destdir);\n    let sysconfdir = add_destdir(&sysconfdir, &destdir);\n    let datadir = add_destdir(&datadir, &destdir);\n    let docdir = add_destdir(&docdir, &destdir);\n    let bindir = add_destdir(&bindir, &destdir);\n    let libdir = add_destdir(&libdir, &destdir);\n    let mandir = add_destdir(&mandir, &destdir);\n    let empty_dir = builder.out.join(\"tmp/empty_dir\");\n    t!(fs::create_dir_all(&empty_dir));\n    let package_name = if let Some(host) = host {\n        format!(\"{}-{}\", pkgname(builder, name), host.triple)\n    } else {\n        pkgname(builder, name)\n    };\n    let mut cmd = Command::new(\"sh\");\n    cmd.current_dir(&empty_dir)\n        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n        .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n        .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n        .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n        .arg(format!(\"--docdir={}\", sanitize_sh(&docdir)))\n        .arg(format!(\"--bindir={}\", sanitize_sh(&bindir)))\n        .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n        .arg(format!(\"--mandir={}\", sanitize_sh(&mandir)))\n        .arg(\"--disable-ldconfig\");\n    builder.run(&mut cmd);\n    t!(fs::remove_dir_all(&empty_dir));\n"]], "pred": {"ppl": 1.5022573471069336, "ppl_lower": 1.5939170122146606, "ppl/lowercase_ppl": -1.1455286757827197, "ppl/zlib": 0.0004932956060062145, "Min_5.0% Prob": 4.983322591781616, "Min_10.0% Prob": 3.4698530860466534, "Min_20.0% Prob": 1.9780616611979975, "Min_30.0% Prob": 1.3497478781089727, "Min_40.0% Prob": 1.0168215979840423, "Min_50.0% Prob": 0.8143766894277259, "Min_60.0% Prob": 0.6788635374654489}}
{"hexsha": "2bf348d25487b4251a1de16083e19907a7e81be9", "ext": "rs", "lang": "Rust", "content": "fn format_count_internal<T>(count: T, zero: &str) -> String\nwhere\n    T: num::ToPrimitive,\n{\n    let format_count_helper = |count: u64, zeroes: u32, suffix: &str| -> Option<String> {\n        let unit: u64 = 10_u64.pow(zeroes);\n\n        if (count as f64 / unit as f64) < 99.95 {\n            Some(format!(\n                \"{:.1}{}\",\n                (count as f64 / unit as f64).max(0.1),\n                suffix\n            ))\n        } else if (count as f64 / unit as f64) < 1000.0 {\n            Some(format!(\"{:.0}{}\", count as f64 / unit as f64, suffix))\n        } else {\n            None\n        }\n    };\n\n    let count = count.to_u64().unwrap();\n\n    if count == 0 {\n        zero.to_string()\n    } else if count < 1000 {\n        format!(\"{}\", count)\n    } else {\n        format_count_helper(count, 3, \"k\")\n            .or_else(|| format_count_helper(count, 6, \"m\"))\n            .or_else(|| format_count_helper(count, 9, \"g\"))\n            .or_else(|| format_count_helper(count, 12, \"p\"))\n            .or_else(|| format_count_helper(count, 15, \"e\"))\n            .unwrap_or_else(|| \"INF\".into())\n    }\n}", "item_id": 6, "repo": "htejun/resctl-demo", "file": "rd-util/src/lib.rs", "last_update_at": "2020-12-08T23:45:12+00:00", "question_id": "2bf348d25487b4251a1de16083e19907a7e81be9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn format_count_internal<T>(count: T, zero: &str) -> String\nwhere\n    T: num::ToPrimitive,\n{\n    let format_count_helper = |count: u64, zeroes: u32, suffix: &str| -> Option<String> {\n        let unit: u64 = 10_u64.pow(zeroes);\n        if (count as f64 / unit as f64) < 99.95 {\n            Some(format!(\n                \"{:.1}{}\",\n                (count as f64 / unit as f64).max(0.1),\n                suffix\n            ))\n        } else if (count as f64 / unit as f64) < 1000.0 {\n            Some(format!(\"{:.0}{}\", count as f64 / unit as f64, suffix))\n        } else {\n            None\n        }\n    };\n    let count = count.to_u64().unwrap();\n    if count == 0 {\n        zero.to_string()\n    } else if count < 1000 {\n        format!(\"{}\", count)\n    } else {\n        format_count_helper(count, 3, \"k\")\n            .or_else(|| format_count_helper(count, 6, \"m\"))\n            .or_else(|| format_count_helper(count, 9, \"g\"))\n            .or_else(|| format_count_helper(count, 12, \"p\"))\n            .or_else(|| format_count_helper(count, 15, \"e\"))\n            .unwrap_or_else(|| \"INF\".into())\n    }\n"]], "pred": {"ppl": 1.681038737297058, "ppl_lower": 1.8926228284835815, "ppl/lowercase_ppl": -1.2282421889144888, "ppl/zlib": 0.001321658774450626, "Min_5.0% Prob": 5.529564321041107, "Min_10.0% Prob": 3.771951067447662, "Min_20.0% Prob": 2.3427323669563105, "Min_30.0% Prob": 1.6751493689466694, "Min_40.0% Prob": 1.2939354645111312, "Min_50.0% Prob": 1.0393920597377155, "Min_60.0% Prob": 0.8660239527731004}}
{"hexsha": "f2f6d6c35e246d108a6225776f3b04f86b19240e", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let args: Vec<String> = env::args().collect();\n    let usage = format!(\"Usage: {} <input>\", args[0]);\n\n    if args.len() != 2 {\n        println!(\"Wrong argument count.\");\n        println!(\"{}\", usage);\n        return;\n    }\n\n    let input: String = match args[1].parse() {\n        Ok(num) => num,\n        Err(_) => {\n            println!(\"Not a String.\");\n            println!(\"{}\", usage);\n            return;\n        }\n    };\n\n    let mut output = String::new();\n    let mut chars = input.chars().peekable();\n    while let Some(c) = chars.next() {\n        // Copy anything that's not a letter.\n        if !c.is_ascii_alphabetic() {\n            output.push(c);\n            continue;\n        }\n\n        // Build a suffix depending on if we found a vowel or a consonant. If\n        // that's a vowel, copy it. For words beginning with an uppercase\n        // consonant, remember that we have to start the \"pig-latin word\" with\n        // an uppercase letter.\n        let lowercase_c = c.to_ascii_lowercase();\n        let mut uppercase_consonant = false;\n        let suffix = if let 'a' | 'e' | 'i' | 'o' | 'u' = lowercase_c {\n            output.push(c);\n            String::from(\"-hay\")\n        } else {\n            uppercase_consonant = c != lowercase_c;\n            format!(\"-{}ay\", lowercase_c)\n        };\n\n        // Copy the rest of the word and append the suffix.\n        while let Some(&c) = chars.peek() {\n            if !c.is_ascii_alphabetic() {\n                break;\n            }\n            chars.next();\n            if uppercase_consonant {\n                output.push(c.to_ascii_uppercase());\n                uppercase_consonant = false;\n            } else {\n                output.push(c);\n            }\n        }\n        output += &suffix;\n    }\n    println!(\"{}\", output);\n}", "item_id": 0, "repo": "lorancou/rust-book-practice", "file": "ch08-ex2-pig-latin/src/main.rs", "last_update_at": "2020-12-15T07:21:28+00:00", "question_id": "f2f6d6c35e246d108a6225776f3b04f86b19240e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let args: Vec<String> = env::args().collect();\n    let usage = format!(\"Usage: {} <input>\", args[0]);\n    if args.len() != 2 {\n        println!(\"Wrong argument count.\");\n        println!(\"{}\", usage);\n        return;\n    }\n    let input: String = match args[1].parse() {\n        Ok(num) => num,\n        Err(_) => {\n            println!(\"Not a String.\");\n            println!(\"{}\", usage);\n            return;\n        }\n    };\n    let mut output = String::new();\n    let mut chars = input.chars().peekable();\n    while let Some(c) = chars.next() {\n        // Copy anything that's not a letter.\n        if !c.is_ascii_alphabetic() {\n            output.push(c);\n            continue;\n        }\n        // Build a suffix depending on if we found a vowel or a consonant. If\n        // that's a vowel, copy it. For words beginning with an uppercase\n        // consonant, remember that we have to start the \"pig-latin word\" with\n        // an uppercase letter.\n        let lowercase_c = c.to_ascii_lowercase();\n        let mut uppercase_consonant = false;\n        let suffix = if let 'a' | 'e' | 'i' | 'o' | 'u' = lowercase_c {\n            output.push(c);\n            String::from(\"-hay\")\n        } else {\n            uppercase_consonant = c != lowercase_c;\n            format!(\"-{}ay\", lowercase_c)\n        };\n        // Copy the rest of the word and append the suffix.\n        while let Some(&c) = chars.peek() {\n            if !c.is_ascii_alphabetic() {\n                break;\n            }\n            chars.next();\n            if uppercase_consonant {\n                output.push(c.to_ascii_uppercase());\n                uppercase_consonant = false;\n            } else {\n                output.push(c);\n            }\n        }\n        output += &suffix;\n    }\n    println!(\"{}\", output);\n"]], "pred": {"ppl": 1.859270453453064, "ppl_lower": 2.0345160961151123, "ppl/lowercase_ppl": -1.145237207344972, "ppl/zlib": 0.0008975169051472619, "Min_5.0% Prob": 6.147034574438025, "Min_10.0% Prob": 4.469145247229823, "Min_20.0% Prob": 2.835467937367934, "Min_30.0% Prob": 2.028832941327566, "Min_40.0% Prob": 1.5459402243054852, "Min_50.0% Prob": 1.2378076881967568, "Min_60.0% Prob": 1.0336173544379954}}
{"hexsha": "bf7c64adab8e49291f4a1d82a774bbea7a114b2a", "ext": "rs", "lang": "Rust", "content": "fn init_map(world: &mut World, sprites: &[SpriteRender], dimensions: &ScreenDimensions) {\n    let file = File::open(&Path::new(\"assets/tilemaps/1-1.tmx\")).unwrap();\n    let reader = BufReader::new(file);\n    // let map = parse(reader).unwrap();\n\n    for (i, sprite) in sprites.iter().enumerate() {\n        // Center around center of window\n        let x = (i as f32 - 1.) * 100. + dimensions.width() * 0.5;\n        let y = (i as f32 - 1.) * 100. + dimensions.height() * 0.5;\n        let mut transform = Transform::default();\n        transform.set_translation_xyz(x, y, 0.);\n\n        world\n            .create_entity()\n            .with(sprite.clone())\n            .with(transform)\n            .build();\n    }\n}", "item_id": 2, "repo": "CodeChroma/Purple", "file": "src/states/menu.rs", "last_update_at": "2020-05-14T12:32:42+00:00", "question_id": "bf7c64adab8e49291f4a1d82a774bbea7a114b2a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init_map(world: &mut World, sprites: &[SpriteRender], dimensions: &ScreenDimensions) {\n    let file = File::open(&Path::new(\"assets/tilemaps/1-1.tmx\")).unwrap();\n    let reader = BufReader::new(file);\n    // let map = parse(reader).unwrap();\n    for (i, sprite) in sprites.iter().enumerate() {\n        // Center around center of window\n        let x = (i as f32 - 1.) * 100. + dimensions.width() * 0.5;\n        let y = (i as f32 - 1.) * 100. + dimensions.height() * 0.5;\n        let mut transform = Transform::default();\n        transform.set_translation_xyz(x, y, 0.);\n        world\n            .create_entity()\n            .with(sprite.clone())\n            .with(transform)\n            .build();\n    }\n"]], "pred": {"ppl": 2.145047187805176, "ppl_lower": 2.793064594268799, "ppl/lowercase_ppl": -1.3459003698429814, "ppl/zlib": 0.0020738085628118972, "Min_5.0% Prob": 6.750457525253296, "Min_10.0% Prob": 5.262057423591614, "Min_20.0% Prob": 3.336574743191401, "Min_30.0% Prob": 2.4349559218519263, "Min_40.0% Prob": 1.8856618339195848, "Min_50.0% Prob": 1.5250626185288032, "Min_60.0% Prob": 1.2746986279962584}}
{"hexsha": "f76339f5613494bc65221331245b35603fbcbfe8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut vida_goku = 1000;\n    let recursos = Arc::new(Mutex::new(vida_goku));\n\n    for cell in 1..5 {\n        let mutex = recursos.clone();\n        thread::spawn(move || {\n          let mut vida_goku = mutex.lock().expect(\"Goku se defendeu atrav\u00e9s do lock\");\n          *vida_goku -= cell * 50;\n      }).join().expect(\"Uni\u00e3o dos golpes falhou\");\n    }\n    thread::sleep(Duration::new(2, 0));\n    vida_goku = *recursos.lock().unwrap();\n    println!(\"A vida de Goku apos os ataque: {}\", vida_goku);\n}", "item_id": 0, "repo": "naomijub/livro-rust", "file": "p3c11/src/main.rs", "last_update_at": "2020-11-10T06:10:12+00:00", "question_id": "f76339f5613494bc65221331245b35603fbcbfe8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut vida_goku = 1000;\n    let recursos = Arc::new(Mutex::new(vida_goku));\n    for cell in 1..5 {\n        let mutex = recursos.clone();\n        thread::spawn(move || {\n          let mut vida_goku = mutex.lock().expect(\"Goku se defendeu atrav\u00e9s do lock\");\n          *vida_goku -= cell * 50;\n      }).join().expect(\"Uni\u00e3o dos golpes falhou\");\n    }\n    thread::sleep(Duration::new(2, 0));\n    vida_goku = *recursos.lock().unwrap();\n    println!(\"A vida de Goku apos os ataque: {}\", vida_goku);\n"]], "pred": {"ppl": 3.468695640563965, "ppl_lower": 4.135460376739502, "ppl/lowercase_ppl": -1.141359585867997, "ppl/zlib": 0.004216198736274733, "Min_5.0% Prob": 9.903044806586372, "Min_10.0% Prob": 7.6877303388383655, "Min_20.0% Prob": 5.187834907222438, "Min_30.0% Prob": 3.8742660294686044, "Min_40.0% Prob": 3.0330756135781605, "Min_50.0% Prob": 2.468014033709435, "Min_60.0% Prob": 2.0709729321894392}}
{"hexsha": "524f1f1b952081f904dad4722674f61e98cb791f", "ext": "rs", "lang": "Rust", "content": "pub fn atan2(y: f64, x: f64) -> f64 {\n    let mut r = atan2k(fabsk(y), x);\n\n    r = if y == 0. {\n        (if sign(x) == -1. { PI } else { 0. })\n    } else if y.is_infinite() {\n        FRAC_PI_2\n            - (if x.is_infinite() {\n                sign(x) * FRAC_PI_4\n            } else {\n                0.\n            })\n    } else if x.is_infinite() || (x == 0.) {\n        FRAC_PI_2\n            - (if x.is_infinite() {\n                (sign(x) * FRAC_PI_2)\n            } else {\n                0.\n            })\n    } else {\n        mulsign(r, x)\n    };\n    if x.is_nan() || y.is_nan() {\n        f64::NAN\n    } else {\n        mulsign(r, y)\n    }\n}", "item_id": 5, "repo": "burrbull/sleef-rs", "file": "src/f64/u35.rs", "last_update_at": "2020-04-26T22:14:14+00:00", "question_id": "524f1f1b952081f904dad4722674f61e98cb791f_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn atan2(y: f64, x: f64) -> f64 {\n    let mut r = atan2k(fabsk(y), x);\n    r = if y == 0. {\n        (if sign(x) == -1. { PI } else { 0. })\n    } else if y.is_infinite() {\n        FRAC_PI_2\n            - (if x.is_infinite() {\n                sign(x) * FRAC_PI_4\n            } else {\n                0.\n            })\n    } else if x.is_infinite() || (x == 0.) {\n        FRAC_PI_2\n            - (if x.is_infinite() {\n                (sign(x) * FRAC_PI_2)\n            } else {\n                0.\n            })\n    } else {\n        mulsign(r, x)\n    };\n    if x.is_nan() || y.is_nan() {\n        f64::NAN\n    } else {\n        mulsign(r, y)\n    }\n"]], "pred": {"ppl": 2.3300247192382812, "ppl_lower": 2.5394246578216553, "ppl/lowercase_ppl": -1.101738757692664, "ppl/zlib": 0.003599484581431809, "Min_5.0% Prob": 7.920189820803129, "Min_10.0% Prob": 5.579777534191425, "Min_20.0% Prob": 3.690920020525272, "Min_30.0% Prob": 2.7043844770926695, "Min_40.0% Prob": 2.08111849909737, "Min_50.0% Prob": 1.6894341286641497, "Min_60.0% Prob": 1.41444192359307}}
{"hexsha": "c6c013b8a8496fc871b61771bf9a35c2086851e6", "ext": "rs", "lang": "Rust", "content": "pub(crate) async fn add_item<A>(request: Request<AppData<A>>) -> tide::Result<Response>\nwhere\n    A: Authentication + Clone + Send + Sync + 'static,\n{\n    #[derive(Deserialize)]\n    struct Q {\n        internal_list_id: String,\n        problem_id: String,\n    }\n    let (query, conn, _) = request.post_unpack::<Q>().await?;\n    conn.add_item(&query.internal_list_id, &query.problem_id)?;\n    let response = Response::ok().body_json(&serde_json::json!({}))?;\n    Ok(response)\n}", "item_id": 5, "repo": "DAyamaCTF/AtCoderProblems", "file": "atcoder-problems-backend/src/server/problem_list.rs", "last_update_at": "2020-07-19T14:43:20+00:00", "question_id": "c6c013b8a8496fc871b61771bf9a35c2086851e6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) async fn add_item<A>(request: Request<AppData<A>>) -> tide::Result<Response>\nwhere\n    A: Authentication + Clone + Send + Sync + 'static,\n{\n    #[derive(Deserialize)]\n    struct Q {\n        internal_list_id: String,\n        problem_id: String,\n    }\n    let (query, conn, _) = request.post_unpack::<Q>().await?;\n    conn.add_item(&query.internal_list_id, &query.problem_id)?;\n    let response = Response::ok().body_json(&serde_json::json!({}))?;\n    Ok(response)\n"]], "pred": {"ppl": 3.495267391204834, "ppl_lower": 4.8067779541015625, "ppl/lowercase_ppl": -1.2546065212632556, "ppl/zlib": 0.004227736079533033, "Min_5.0% Prob": 9.822007298469543, "Min_10.0% Prob": 7.649681091308594, "Min_20.0% Prob": 5.340865662603667, "Min_30.0% Prob": 3.941192821264267, "Min_40.0% Prob": 3.097983866704233, "Min_50.0% Prob": 2.495041585650789, "Min_60.0% Prob": 2.0841335882246494}}
{"hexsha": "127e757263ba1bc29f653736130c32acc1767e8f", "ext": "rs", "lang": "Rust", "content": "fn start_send_past_cap() {\n    let mut t1 = task::spawn(());\n    let mut t2 = task::spawn(());\n    let mut t3 = task::spawn(());\n\n    let (mut tx1, mut rx) = mpsc::channel(1);\n    let mut tx2 = tx1.clone();\n\n    assert_ok!(tx1.try_send(()));\n\n    t1.enter(|cx, _| {\n        assert_pending!(tx1.poll_ready(cx));\n    });\n\n    t2.enter(|cx, _| {\n        assert_pending!(tx2.poll_ready(cx));\n    });\n\n    drop(tx1);\n\n    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));\n    assert!(val.is_some());\n\n    assert!(t2.is_woken());\n    assert!(!t1.is_woken());\n\n    drop(tx2);\n\n    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));\n    assert!(val.is_none());\n}", "item_id": 3, "repo": "goriunov/tokio", "file": "tokio/tests/sync_mpsc.rs", "last_update_at": "2020-07-09T22:58:29+00:00", "question_id": "127e757263ba1bc29f653736130c32acc1767e8f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn start_send_past_cap() {\n    let mut t1 = task::spawn(());\n    let mut t2 = task::spawn(());\n    let mut t3 = task::spawn(());\n    let (mut tx1, mut rx) = mpsc::channel(1);\n    let mut tx2 = tx1.clone();\n    assert_ok!(tx1.try_send(()));\n    t1.enter(|cx, _| {\n        assert_pending!(tx1.poll_ready(cx));\n    });\n    t2.enter(|cx, _| {\n        assert_pending!(tx2.poll_ready(cx));\n    });\n    drop(tx1);\n    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));\n    assert!(val.is_some());\n    assert!(t2.is_woken());\n    assert!(!t1.is_woken());\n    drop(tx2);\n    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));\n    assert!(val.is_none());\n"]], "pred": {"ppl": 1.7388781309127808, "ppl_lower": 1.7388781309127808, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0022308070682874183, "Min_5.0% Prob": 4.884312765938895, "Min_10.0% Prob": 3.679247055734907, "Min_20.0% Prob": 2.4884102553652045, "Min_30.0% Prob": 1.7864567377539569, "Min_40.0% Prob": 1.3804774402657098, "Min_50.0% Prob": 1.10743827960239, "Min_60.0% Prob": 0.9223250365967668}}
{"hexsha": "f4c1ebf3f00004d0795c5c6cb8096be693eeebe6", "ext": "rs", "lang": "Rust", "content": "async fn quit(ctx: &Context, msg: &Message) -> CommandResult {\n    let data = ctx.data.read().await;\n\n    if let Some(manager) = data.get::<ShardManagerContainer>() {\n        msg.reply(ctx, \"Shutting down!\").await?;\n        manager.lock().await.shutdown_all().await;\n    } else {\n        msg.reply(ctx, \"There was a problem getting the shard manager\")\n            .await?;\n        return Ok(());\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "theProgrammerDavid/pls.give", "file": "src/commands/admin.rs", "last_update_at": "2020-11-28T16:24:51+00:00", "question_id": "f4c1ebf3f00004d0795c5c6cb8096be693eeebe6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn quit(ctx: &Context, msg: &Message) -> CommandResult {\n    let data = ctx.data.read().await;\n    if let Some(manager) = data.get::<ShardManagerContainer>() {\n        msg.reply(ctx, \"Shutting down!\").await?;\n        manager.lock().await.shutdown_all().await;\n    } else {\n        msg.reply(ctx, \"There was a problem getting the shard manager\")\n            .await?;\n        return Ok(());\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.783105492591858, "ppl_lower": 2.6890177726745605, "ppl/lowercase_ppl": -1.7103222349535128, "ppl/zlib": 0.002332082673041164, "Min_5.0% Prob": 7.059926668802897, "Min_10.0% Prob": 4.677767175894517, "Min_20.0% Prob": 2.716430633156388, "Min_30.0% Prob": 1.914290800690651, "Min_40.0% Prob": 1.435692708456406, "Min_50.0% Prob": 1.1622235987669052, "Min_60.0% Prob": 0.9629821965562892}}
{"hexsha": "f401d58f942ac67fe1a55447e3659714a798c8ff", "ext": "rs", "lang": "Rust", "content": "pub fn sp_write(newval: u64) {\n    // bits 3..3\n    let val = reg_rawrd();\n    reg_rawwr(val & !(0x1 << 3) | ((newval & 0x1) << 3));\n}", "item_id": 20, "repo": "achreto/rust-aarch64", "file": "src/registers/dbgvcr32_el2.rs", "last_update_at": "2020-10-06T23:59:27+00:00", "question_id": "f401d58f942ac67fe1a55447e3659714a798c8ff_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn sp_write(newval: u64) {\n    // bits 3..3\n    let val = reg_rawrd();\n    reg_rawwr(val & !(0x1 << 3) | ((newval & 0x1) << 3));\n"]], "pred": {"ppl": 6.002877712249756, "ppl_lower": 6.002877712249756, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.015721394499614544, "Min_5.0% Prob": 9.378896077473959, "Min_10.0% Prob": 8.528639157613119, "Min_20.0% Prob": 6.58682184952956, "Min_30.0% Prob": 5.244070103293971, "Min_40.0% Prob": 4.199873823385972, "Min_50.0% Prob": 3.472495969497796, "Min_60.0% Prob": 2.9987128109504013}}
{"hexsha": "d3fd36c14dbc79aaae7d0ed2023e0bd4206daa79", "ext": "rs", "lang": "Rust", "content": "fn test_index_of_hit() {\n        let cache = mock_cache();\n        assert_eq!(cache.index_of(1), Some(0));\n        assert_eq!(cache.index_of(2), Some(1));\n    }", "item_id": 0, "repo": "winksaville/Fuchsia", "file": "src/fonts/src/font_service/asset/cache.rs", "last_update_at": "2020-08-07T10:10:53+00:00", "question_id": "d3fd36c14dbc79aaae7d0ed2023e0bd4206daa79_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_index_of_hit() {\n        let cache = mock_cache();\n        assert_eq!(cache.index_of(1), Some(0));\n        assert_eq!(cache.index_of(2), Some(1));\n"]], "pred": {"ppl": 3.031522750854492, "ppl_lower": 3.49471116065979, "ppl/lowercase_ppl": -1.1282031898799676, "ppl/zlib": 0.011552760951240278, "Min_5.0% Prob": 9.155526161193848, "Min_10.0% Prob": 7.750852775573731, "Min_20.0% Prob": 4.847987532615662, "Min_30.0% Prob": 3.4803864465040317, "Min_40.0% Prob": 2.7065886829210366, "Min_50.0% Prob": 2.198601876353395, "Min_60.0% Prob": 1.8857239496839397}}
{"hexsha": "3961a0edac9c4d3a2fd997d41c0751f467697244", "ext": "rs", "lang": "Rust", "content": "pub fn e29_29_29_write(newval: u64) {\n    // bits 29..29\n    let val = reg_rawrd();\n    reg_rawwr(val & !(0x1 << 29) | ((newval & 0x1) << 29));\n}", "item_id": 40, "repo": "achreto/rust-aarch64", "file": "src/registers/pmsevfr_el1.rs", "last_update_at": "2020-10-06T23:59:27+00:00", "question_id": "3961a0edac9c4d3a2fd997d41c0751f467697244_40", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn e29_29_29_write(newval: u64) {\n    // bits 29..29\n    let val = reg_rawrd();\n    reg_rawwr(val & !(0x1 << 29) | ((newval & 0x1) << 29));\n"]], "pred": {"ppl": 5.807882785797119, "ppl_lower": 5.807882785797119, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0149086109814414, "Min_5.0% Prob": 10.151040077209473, "Min_10.0% Prob": 8.801373481750488, "Min_20.0% Prob": 6.87236377398173, "Min_30.0% Prob": 5.247279954993206, "Min_40.0% Prob": 4.198101901238965, "Min_50.0% Prob": 3.446363274103556, "Min_60.0% Prob": 2.9607190094564273}}
{"hexsha": "ab9a84dc67ec85ee5af20790dc20a79849447df0", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"pdb-harvester\")\n        .version(\"1.0\")\n        .author(\"Orhan B. <orhanbalci@gmail.com>\")\n        .about(\"Harvests odb files online and transforms them\")\n        .subcommand(\n            SubCommand::with_name(\"download\")\n                .about(\"Downloads pdb files from ncsb\")\n                .version(\"1.0\")\n                .author(\"Orhan B. <orhanbalci@gmail.com>\")\n                .arg(\n                    Arg::with_name(\"count\")\n                        .short(\"c\")\n                        .help(\"Number of files to be downloaded\"),\n                ),\n        )\n        .subcommand(\n            SubCommand::with_name(\"extract\")\n                .about(\"Extracts parts of files and stores them in other files\")\n                .version(\"1.0\")\n                .arg(\n                    Arg::with_name(\"tag\")\n                        .short(\"d\")\n                        .help(\"Which tags will be extracted\"),\n                ),\n        )\n        .get_matches();\n\n    if matches.is_present(\"download\") {\n        download_command();\n    }\n\n    if matches.is_present(\"extract\") {}\n}", "item_id": 0, "repo": "orhanbalci/rust-protein", "file": "pdb-harvester/src/main.rs", "last_update_at": "2020-04-15T04:51:34+00:00", "question_id": "ab9a84dc67ec85ee5af20790dc20a79849447df0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let matches = App::new(\"pdb-harvester\")\n        .version(\"1.0\")\n        .author(\"Orhan B. <orhanbalci@gmail.com>\")\n        .about(\"Harvests odb files online and transforms them\")\n        .subcommand(\n            SubCommand::with_name(\"download\")\n                .about(\"Downloads pdb files from ncsb\")\n                .version(\"1.0\")\n                .author(\"Orhan B. <orhanbalci@gmail.com>\")\n                .arg(\n                    Arg::with_name(\"count\")\n                        .short(\"c\")\n                        .help(\"Number of files to be downloaded\"),\n                ),\n        )\n        .subcommand(\n            SubCommand::with_name(\"extract\")\n                .about(\"Extracts parts of files and stores them in other files\")\n                .version(\"1.0\")\n                .arg(\n                    Arg::with_name(\"tag\")\n                        .short(\"d\")\n                        .help(\"Which tags will be extracted\"),\n                ),\n        )\n        .get_matches();\n    if matches.is_present(\"download\") {\n        download_command();\n    }\n    if matches.is_present(\"extract\") {}\n"]], "pred": {"ppl": 2.2551820278167725, "ppl_lower": 2.4150819778442383, "ppl/lowercase_ppl": -1.084235065091771, "ppl/zlib": 0.00211778825928847, "Min_5.0% Prob": 7.536393324534099, "Min_10.0% Prob": 5.841647831598918, "Min_20.0% Prob": 3.8024033159017563, "Min_30.0% Prob": 2.6764506563544272, "Min_40.0% Prob": 2.0311744986101985, "Min_50.0% Prob": 1.6298625371977686, "Min_60.0% Prob": 1.3592645531533183}}
{"hexsha": "3e24e349f9fab0f9572e82396936ce22ca87c8a7", "ext": "rs", "lang": "Rust", "content": "async fn update(\n    uuid: web::Path<String>,\n    post: web::Json<PostRequest>,\n    db_pool: web::Data<DbPool>,\n) -> impl Responder {\n    let uuid_;\n    match Uuid::parse_str(uuid.as_str()) {\n        Ok(u) => uuid_ = u,\n        Err(_) => return HttpResponse::BadRequest().body(\"Invalid Post ID\"),\n    }\n    let result = Post::update(uuid_, post.into_inner(), db_pool.get_ref()).await;\n    match result {\n        Ok(post) => HttpResponse::Ok().json(post),\n        _ => HttpResponse::BadRequest().body(\"Post not found\"),\n    }\n}", "item_id": 2, "repo": "nic96/minipress", "file": "src/handlers/post_handlers.rs", "last_update_at": "2020-12-25T06:53:54+00:00", "question_id": "3e24e349f9fab0f9572e82396936ce22ca87c8a7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn update(\n    uuid: web::Path<String>,\n    post: web::Json<PostRequest>,\n    db_pool: web::Data<DbPool>,\n) -> impl Responder {\n    let uuid_;\n    match Uuid::parse_str(uuid.as_str()) {\n        Ok(u) => uuid_ = u,\n        Err(_) => return HttpResponse::BadRequest().body(\"Invalid Post ID\"),\n    }\n    let result = Post::update(uuid_, post.into_inner(), db_pool.get_ref()).await;\n    match result {\n        Ok(post) => HttpResponse::Ok().json(post),\n        _ => HttpResponse::BadRequest().body(\"Post not found\"),\n    }\n"]], "pred": {"ppl": 2.0903589725494385, "ppl_lower": 3.573458671569824, "ppl/lowercase_ppl": -1.7272102179224946, "ppl/zlib": 0.0025251226316055776, "Min_5.0% Prob": 7.979809880256653, "Min_10.0% Prob": 5.2132987835827995, "Min_20.0% Prob": 3.242903751485488, "Min_30.0% Prob": 2.364305894748837, "Min_40.0% Prob": 1.8147627022387325, "Min_50.0% Prob": 1.473272220339886, "Min_60.0% Prob": 1.2364195383976675}}
{"hexsha": "94b5fabe04d18a5f810706d7eb2d68f8ab5d8b8c", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn _start(boot_info: &'static BootInfo) -> ! {\n    arch_init(boot_info);\n\n    println!(\n        \"{} {} on {} {}\",\n        version_info::OPERATING_SYSTEM_NAME,\n        version_info::VERSION_STRING,\n        version_info::PROCESSOR_NAME,\n        version_info::MACHINE_NAME\n    );\n    println!(\"The system is coming up.\");\n    kalloc::init();\n    timer::register_timer(timer::TICKS_PER_SECOND / 2, false, Box::new(|| {\n        print!(\".\")\n    })).unwrap();\n    timer::register_timer(timer::TICKS_PER_SECOND * 4, true, Box::new(|| {\n        print!(\"!\")\n    })).unwrap();\n\n    loop {\n        spin_loop_hint();\n    }\n}", "item_id": 0, "repo": "PatchMixolydic/spinel", "file": "src/main.rs", "last_update_at": "2020-02-23T17:11:49+00:00", "question_id": "94b5fabe04d18a5f810706d7eb2d68f8ab5d8b8c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn _start(boot_info: &'static BootInfo) -> ! {\n    arch_init(boot_info);\n    println!(\n        \"{} {} on {} {}\",\n        version_info::OPERATING_SYSTEM_NAME,\n        version_info::VERSION_STRING,\n        version_info::PROCESSOR_NAME,\n        version_info::MACHINE_NAME\n    );\n    println!(\"The system is coming up.\");\n    kalloc::init();\n    timer::register_timer(timer::TICKS_PER_SECOND / 2, false, Box::new(|| {\n        print!(\".\")\n    })).unwrap();\n    timer::register_timer(timer::TICKS_PER_SECOND * 4, true, Box::new(|| {\n        print!(\"!\")\n    })).unwrap();\n    loop {\n        spin_loop_hint();\n    }\n"]], "pred": {"ppl": 3.1149330139160156, "ppl_lower": 3.841841459274292, "ppl/lowercase_ppl": -1.184600192690848, "ppl/zlib": 0.0036070084052297296, "Min_5.0% Prob": 8.08113345232877, "Min_10.0% Prob": 6.292237487706271, "Min_20.0% Prob": 4.583320102908394, "Min_30.0% Prob": 3.5131490700172656, "Min_40.0% Prob": 2.7673889554359694, "Min_50.0% Prob": 2.2635703989050606, "Min_60.0% Prob": 1.898240896901398}}
{"hexsha": "a73c4f4e5cf0b4ee29ba1d79c7c8c09f883b78cf", "ext": "rs", "lang": "Rust", "content": "fn impl_deserial(ast: &syn::DeriveInput) -> syn::Result<TokenStream> {\n    let data_name = &ast.ident;\n\n    let span = ast.span();\n\n    let read_ident = format_ident!(\"__R\", span = span);\n\n    let (impl_generics, ty_generics, where_clauses) = ast.generics.split_for_impl();\n\n    let source_ident = Ident::new(\"________________source\", Span::call_site());\n\n    let body_tokens = match ast.data {\n        syn::Data::Struct(ref data) => {\n            let mut names = proc_macro2::TokenStream::new();\n            let mut field_tokens = proc_macro2::TokenStream::new();\n            let return_tokens = match data.fields {\n                syn::Fields::Named(_) => {\n                    for field in data.fields.iter() {\n                        let field_ident = field.ident.clone().unwrap(); // safe since named fields.\n                        field_tokens.extend(impl_deserial_field(\n                            field,\n                            &field_ident,\n                            &source_ident,\n                        ));\n                        names.extend(quote!(#field_ident,))\n                    }\n                    quote!(Ok(#data_name{#names}))\n                }\n                syn::Fields::Unnamed(_) => {\n                    for (i, f) in data.fields.iter().enumerate() {\n                        let field_ident = format_ident!(\"x_{}\", i);\n                        field_tokens.extend(impl_deserial_field(f, &field_ident, &source_ident));\n                        names.extend(quote!(#field_ident,))\n                    }\n                    quote!(Ok(#data_name(#names)))\n                }\n                _ => quote!(Ok(#data_name{})),\n            };\n            quote! {\n                #field_tokens\n                #return_tokens\n            }\n        }\n        syn::Data::Enum(ref data) => {\n            let mut matches_tokens = proc_macro2::TokenStream::new();\n            let source = Ident::new(\"________________source\", Span::call_site());\n            let size = if data.variants.len() <= 256 {\n                format_ident!(\"u8\")\n            } else if data.variants.len() <= 256 * 256 {\n                format_ident!(\"u16\")\n            } else {\n                return Err(syn::Error::new(\n                    ast.span(),\n                    \"[derive(Deserial)]: Too many variants. Maximum 65536 are supported.\",\n                ));\n            };\n            for (i, variant) in data.variants.iter().enumerate() {\n                let (field_names, pattern) = match variant.fields {\n                    syn::Fields::Named(_) => {\n                        let field_names: Vec<_> = variant\n                            .fields\n                            .iter()\n                            .map(|field| field.ident.clone().unwrap())\n                            .collect();\n                        (field_names.clone(), quote! { {#(#field_names),*} })\n                    }\n                    syn::Fields::Unnamed(_) => {\n                        let field_names: Vec<_> = variant\n                            .fields\n                            .iter()\n                            .enumerate()\n                            .map(|(i, _)| format_ident!(\"x_{}\", i))\n                            .collect();\n                        (field_names.clone(), quote! { ( #(#field_names),* ) })\n                    }\n                    syn::Fields::Unit => (Vec::new(), proc_macro2::TokenStream::new()),\n                };\n\n                let field_tokens: proc_macro2::TokenStream = field_names\n                    .iter()\n                    .zip(variant.fields.iter())\n                    .map(|(name, field)| impl_deserial_field(field, name, &source))\n                    .collect::<syn::Result<proc_macro2::TokenStream>>()?;\n                let idx_lit = syn::LitInt::new(i.to_string().as_str(), Span::call_site());\n                let variant_ident = &variant.ident;\n                matches_tokens.extend(quote! {\n                    #idx_lit => {\n                        #field_tokens\n                        Ok(#data_name::#variant_ident#pattern)\n                    },\n                })\n            }\n            quote! {\n                let idx = #size::deserial(#source)?;\n                match idx {\n                    #matches_tokens\n                    _ => Err(Default::default())\n                }\n            }\n        }\n        _ => unimplemented!(\"#[derive(Deserial)] is not implemented for union.\"),\n    };\n    let gen = quote! {\n        #[automatically_derived]\n        impl #impl_generics Deserial for #data_name #ty_generics #where_clauses {\n            fn deserial<#read_ident: Read>(#source_ident: &mut #read_ident) -> ParseResult<Self> {\n                #body_tokens\n            }\n        }\n    };\n    Ok(gen.into())\n}", "item_id": 10, "repo": "Concordium/concordium-std", "file": "concordium-std-derive/src/lib.rs", "last_update_at": "2020-12-14T10:45:16+00:00", "question_id": "a73c4f4e5cf0b4ee29ba1d79c7c8c09f883b78cf_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn impl_deserial(ast: &syn::DeriveInput) -> syn::Result<TokenStream> {\n    let data_name = &ast.ident;\n    let span = ast.span();\n    let read_ident = format_ident!(\"__R\", span = span);\n    let (impl_generics, ty_generics, where_clauses) = ast.generics.split_for_impl();\n    let source_ident = Ident::new(\"________________source\", Span::call_site());\n    let body_tokens = match ast.data {\n        syn::Data::Struct(ref data) => {\n            let mut names = proc_macro2::TokenStream::new();\n            let mut field_tokens = proc_macro2::TokenStream::new();\n            let return_tokens = match data.fields {\n                syn::Fields::Named(_) => {\n                    for field in data.fields.iter() {\n                        let field_ident = field.ident.clone().unwrap(); // safe since named fields.\n                        field_tokens.extend(impl_deserial_field(\n                            field,\n                            &field_ident,\n                            &source_ident,\n                        ));\n                        names.extend(quote!(#field_ident,))\n                    }\n                    quote!(Ok(#data_name{#names}))\n                }\n                syn::Fields::Unnamed(_) => {\n                    for (i, f) in data.fields.iter().enumerate() {\n                        let field_ident = format_ident!(\"x_{}\", i);\n                        field_tokens.extend(impl_deserial_field(f, &field_ident, &source_ident));\n                        names.extend(quote!(#field_ident,))\n                    }\n                    quote!(Ok(#data_name(#names)))\n                }\n                _ => quote!(Ok(#data_name{})),\n            };\n            quote! {\n                #field_tokens\n                #return_tokens\n            }\n        }\n        syn::Data::Enum(ref data) => {\n            let mut matches_tokens = proc_macro2::TokenStream::new();\n            let source = Ident::new(\"________________source\", Span::call_site());\n            let size = if data.variants.len() <= 256 {\n                format_ident!(\"u8\")\n            } else if data.variants.len() <= 256 * 256 {\n                format_ident!(\"u16\")\n            } else {\n                return Err(syn::Error::new(\n                    ast.span(),\n                    \"[derive(Deserial)]: Too many variants. Maximum 65536 are supported.\",\n                ));\n            };\n            for (i, variant) in data.variants.iter().enumerate() {\n                let (field_names, pattern) = match variant.fields {\n                    syn::Fields::Named(_) => {\n                        let field_names: Vec<_> = variant\n                            .fields\n                            .iter()\n                            .map(|field| field.ident.clone().unwrap())\n                            .collect();\n                        (field_names.clone(), quote! { {#(#field_names),*} })\n                    }\n                    syn::Fields::Unnamed(_) => {\n                        let field_names: Vec<_> = variant\n                            .fields\n                            .iter()\n                            .enumerate()\n                            .map(|(i, _)| format_ident!(\"x_{}\", i))\n                            .collect();\n                        (field_names.clone(), quote! { ( #(#field_names),* ) })\n                    }\n                    syn::Fields::Unit => (Vec::new(), proc_macro2::TokenStream::new()),\n                };\n                let field_tokens: proc_macro2::TokenStream = field_names\n                    .iter()\n                    .zip(variant.fields.iter())\n                    .map(|(name, field)| impl_deserial_field(field, name, &source))\n                    .collect::<syn::Result<proc_macro2::TokenStream>>()?;\n                let idx_lit = syn::LitInt::new(i.to_string().as_str(), Span::call_site());\n                let variant_ident = &variant.ident;\n                matches_tokens.extend(quote! {\n                    #idx_lit => {\n                        #field_tokens\n                        Ok(#data_name::#variant_ident#pattern)\n                    },\n                })\n            }\n            quote! {\n                let idx = #size::deserial(#source)?;\n                match idx {\n                    #matches_tokens\n                    _ => Err(Default::default())\n                }\n            }\n        }\n        _ => unimplemented!(\"#[derive(Deserial)] is not implemented for union.\"),\n    };\n    let gen = quote! {\n        #[automatically_derived]\n        impl #impl_generics Deserial for #data_name #ty_generics #where_clauses {\n            fn deserial<#read_ident: Read>(#source_ident: &mut #read_ident) -> ParseResult<Self> {\n                #body_tokens\n            }\n        }\n    };\n    Ok(gen.into())\n"]], "pred": {"ppl": 1.6171988248825073, "ppl_lower": 1.8367283344268799, "ppl/lowercase_ppl": -1.2648045783374693, "ppl/zlib": 0.0004077146159008741, "Min_5.0% Prob": 5.551923087998932, "Min_10.0% Prob": 3.801380947524426, "Min_20.0% Prob": 2.2744397821964, "Min_30.0% Prob": 1.5814683251082897, "Min_40.0% Prob": 1.197754961691232, "Min_50.0% Prob": 0.9614054801465611, "Min_60.0% Prob": 0.8019749452865137}}
{"hexsha": "32ebf28a490bb53048432bc3da7d5c9a52d6abae", "ext": "rs", "lang": "Rust", "content": "fn when_the_problem_is_solved_best_lb_is_best_value() {\n        let problem = Knapsack {\n            capacity: 50,\n            profit  : vec![60, 100, 120],\n            weight  : vec![10,  20,  30]\n        };\n        let mdd        = mdd_builder(&problem, KPRelax).into_deep();\n        let mut solver = ParallelSolver::new(mdd);\n        let _ = solver.maximize();\n        assert_eq!(220, solver.best_lower_bound());\n    }", "item_id": 2, "repo": "lcpz/ddo", "file": "src/implementation/solver/parallel.rs", "last_update_at": "2020-11-26T11:55:00+00:00", "question_id": "32ebf28a490bb53048432bc3da7d5c9a52d6abae_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn when_the_problem_is_solved_best_lb_is_best_value() {\n        let problem = Knapsack {\n            capacity: 50,\n            profit  : vec![60, 100, 120],\n            weight  : vec![10,  20,  30]\n        };\n        let mdd        = mdd_builder(&problem, KPRelax).into_deep();\n        let mut solver = ParallelSolver::new(mdd);\n        let _ = solver.maximize();\n        assert_eq!(220, solver.best_lower_bound());\n"]], "pred": {"ppl": 4.668287754058838, "ppl_lower": 5.3263258934021, "ppl/lowercase_ppl": -1.0855853922275185, "ppl/zlib": 0.006263383562991347, "Min_5.0% Prob": 9.741704532078334, "Min_10.0% Prob": 8.180204073588053, "Min_20.0% Prob": 6.283668438593547, "Min_30.0% Prob": 4.762340633765511, "Min_40.0% Prob": 3.760325514879383, "Min_50.0% Prob": 3.0446760760886327, "Min_60.0% Prob": 2.5676095028124424}}
{"hexsha": "a8f9000b36f8219f3b50c55ce44197b58c095f5a", "ext": "rs", "lang": "Rust", "content": "async fn new_(depot: &mut Depot, res: &mut Response) {\n    let mut web = depot.remove::<Context>(WEB).unwrap();\n\n    match Tags::view_list_tag().await {\n        Ok(tags_) => web.insert(\"tags\", &tags_),\n        Err(e) => tracing::info!(\"can't find tags with: {:?}\", e),\n    }\n\n    render(res, \"admin/article_new.html\", &web);\n}", "item_id": 0, "repo": "driftluo/MyBlog", "file": "src/web/admin.rs", "last_update_at": "2020-09-05T03:13:21+00:00", "question_id": "a8f9000b36f8219f3b50c55ce44197b58c095f5a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn new_(depot: &mut Depot, res: &mut Response) {\n    let mut web = depot.remove::<Context>(WEB).unwrap();\n    match Tags::view_list_tag().await {\n        Ok(tags_) => web.insert(\"tags\", &tags_),\n        Err(e) => tracing::info!(\"can't find tags with: {:?}\", e),\n    }\n    render(res, \"admin/article_new.html\", &web);\n"]], "pred": {"ppl": 6.385596752166748, "ppl_lower": 7.580373764038086, "ppl/lowercase_ppl": -1.0925099260891473, "ppl/zlib": 0.007822974458623908, "Min_5.0% Prob": 10.24079933166504, "Min_10.0% Prob": 8.6425067728216, "Min_20.0% Prob": 6.617138178452201, "Min_30.0% Prob": 5.304767860685076, "Min_40.0% Prob": 4.374214242333951, "Min_50.0% Prob": 3.6174330176978278, "Min_60.0% Prob": 3.0649467127663748}}
{"hexsha": "fd8c747767a7d7ab57e24f0e01c8da640ca43a11", "ext": "rs", "lang": "Rust", "content": "fn unknown_field() {\n  let mut directory = Directory::new();\n  directory.mut_unknown_fields().add_fixed32(42, 42);\n  let error = verify_directory_canonical(&directory).expect_err(\"Want error\");\n  assert!(\n    error.contains(\"unknown\"),\n    format!(\"Bad error message: {}\", error)\n  );\n}", "item_id": 1, "repo": "anthonyjpratti/pants", "file": "src/rust/engine/process_execution/bazel_protos/src/verification_tests.rs", "last_update_at": "2020-06-13T22:01:39+00:00", "question_id": "fd8c747767a7d7ab57e24f0e01c8da640ca43a11_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unknown_field() {\n  let mut directory = Directory::new();\n  directory.mut_unknown_fields().add_fixed32(42, 42);\n  let error = verify_directory_canonical(&directory).expect_err(\"Want error\");\n  assert!(\n    error.contains(\"unknown\"),\n    format!(\"Bad error message: {}\", error)\n  );\n"]], "pred": {"ppl": 4.015125751495361, "ppl_lower": 4.382455348968506, "ppl/lowercase_ppl": -1.0629756529329388, "ppl/zlib": 0.007316150880686882, "Min_5.0% Prob": 9.44289255142212, "Min_10.0% Prob": 7.438423792521159, "Min_20.0% Prob": 5.322625067498949, "Min_30.0% Prob": 4.061088142571626, "Min_40.0% Prob": 3.284725879629453, "Min_50.0% Prob": 2.720267332262463, "Min_60.0% Prob": 2.3091478364335165}}
{"hexsha": "0951ed0507a489ccf48578ccf666a4f4d0fb455e", "ext": "rs", "lang": "Rust", "content": "fn memchr_unalign_words_ascii(b: &mut Bencher) {\n    let words = &*WORDS_ASCII;\n    let pat = b'a';\n    b.iter(|| {\n        words.iter().map(|w|\n            memchr_unalign(pat, w.as_bytes()).unwrap_or(0)\n        ).sum::<usize>()\n    });\n    b.bytes = words.iter().map(|w| w.len() as u64).sum::<u64>()\n}", "item_id": 15, "repo": "tommilligan/cargo-raze", "file": "examples/vendored/complicated_cargo_library/cargo/vendor/odds-0.2.26/benches/bench.rs", "last_update_at": "2020-06-20T17:38:50+00:00", "question_id": "0951ed0507a489ccf48578ccf666a4f4d0fb455e_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn memchr_unalign_words_ascii(b: &mut Bencher) {\n    let words = &*WORDS_ASCII;\n    let pat = b'a';\n    b.iter(|| {\n        words.iter().map(|w|\n            memchr_unalign(pat, w.as_bytes()).unwrap_or(0)\n        ).sum::<usize>()\n    });\n    b.bytes = words.iter().map(|w| w.len() as u64).sum::<u64>()\n"]], "pred": {"ppl": 2.8553547859191895, "ppl_lower": 3.2829840183258057, "ppl/lowercase_ppl": -1.1330129480573925, "ppl/zlib": 0.005325868546498642, "Min_5.0% Prob": 7.283321301142375, "Min_10.0% Prob": 6.025682270526886, "Min_20.0% Prob": 4.193209571838379, "Min_30.0% Prob": 3.256533729063498, "Min_40.0% Prob": 2.5502695453166964, "Min_50.0% Prob": 2.0657070191606643, "Min_60.0% Prob": 1.7526648739973705}}
{"hexsha": "7eccdf0c15b0f08a4c6966cd78842acd695182b9", "ext": "rs", "lang": "Rust", "content": "fn buffer_extend(&mut self, len: usize) -> Result<&mut [u8], Error> {\n        let pos = self.as_ref().len();\n        let end = pos + len;\n        self.buffer_resize(end)?;\n        Ok(&mut self.as_mut()[pos..end])\n    }", "item_id": 0, "repo": "hyperledger-cicd/aries-askar", "file": "askar-crypto/src/buffer/mod.rs", "last_update_at": "2020-12-01T13:00:10+00:00", "question_id": "7eccdf0c15b0f08a4c6966cd78842acd695182b9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn buffer_extend(&mut self, len: usize) -> Result<&mut [u8], Error> {\n        let pos = self.as_ref().len();\n        let end = pos + len;\n        self.buffer_resize(end)?;\n        Ok(&mut self.as_mut()[pos..end])\n"]], "pred": {"ppl": 2.4857189655303955, "ppl_lower": 3.3292527198791504, "ppl/lowercase_ppl": -1.3208852882265565, "ppl/zlib": 0.006111153958711675, "Min_5.0% Prob": 8.52920659383138, "Min_10.0% Prob": 5.950976610183716, "Min_20.0% Prob": 3.937951445579529, "Min_30.0% Prob": 2.8618164127287655, "Min_40.0% Prob": 2.2653240248560906, "Min_50.0% Prob": 1.8216750551211207, "Min_60.0% Prob": 1.5156629692115213}}
{"hexsha": "754e17eea7b90f3609e13e49901cf843b4a96d0c", "ext": "rs", "lang": "Rust", "content": "fn parse_masked_ipv6_strings() {\n    const FE80_ONE_10: &str = \"fe80::1/10\";\n    const LOCALHOST_128: &str = \"::/128\";\n    const FFFF_AAAA_16: &str = \"ffff::aaaa/16\";\n\n    let net: MaskedIpv6 = FE80_ONE_10.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), FE80_ONE_10);\n    assert_eq!(net.mask.len(), 10);\n    let net: MaskedIpv6 = LOCALHOST_128.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), LOCALHOST_128);\n    assert_eq!(net.mask.len(), 128);\n    let net: MaskedIpv6 = FFFF_AAAA_16.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), FFFF_AAAA_16);\n    assert_eq!(net.mask.len(), 16);\n}", "item_id": 7, "repo": "TyPR124/ipstuff", "file": "src/tests/ipmask.rs", "last_update_at": "2020-01-31T08:19:04+00:00", "question_id": "754e17eea7b90f3609e13e49901cf843b4a96d0c_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_masked_ipv6_strings() {\n    const FE80_ONE_10: &str = \"fe80::1/10\";\n    const LOCALHOST_128: &str = \"::/128\";\n    const FFFF_AAAA_16: &str = \"ffff::aaaa/16\";\n    let net: MaskedIpv6 = FE80_ONE_10.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), FE80_ONE_10);\n    assert_eq!(net.mask.len(), 10);\n    let net: MaskedIpv6 = LOCALHOST_128.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), LOCALHOST_128);\n    assert_eq!(net.mask.len(), 128);\n    let net: MaskedIpv6 = FFFF_AAAA_16.parse().unwrap();\n    assert_eq!(format!(\"{}\", net), FFFF_AAAA_16);\n    assert_eq!(net.mask.len(), 16);\n"]], "pred": {"ppl": 1.78798246383667, "ppl_lower": 1.9740391969680786, "ppl/lowercase_ppl": -1.1703596542086463, "ppl/zlib": 0.002472714336194105, "Min_5.0% Prob": 6.909341958852915, "Min_10.0% Prob": 4.939697570270962, "Min_20.0% Prob": 2.8470593349500137, "Min_30.0% Prob": 1.9397198571318603, "Min_40.0% Prob": 1.4588652089959733, "Min_50.0% Prob": 1.1659968832454128, "Min_60.0% Prob": 0.9707019512303184}}
{"hexsha": "90b6936df788397fc5d6af5f3593e71e3edc2b4a", "ext": "rs", "lang": "Rust", "content": "pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        network_resource_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\"{}/Resources/Networks/{}\", operation_config.base_path(), network_resource_name);\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::FabricError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 228, "repo": "jesinity/azure-sdk-for-rust", "file": "services/svc/servicefabric/src/v8_0/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "90b6936df788397fc5d6af5f3593e71e3edc2b4a_228", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        network_resource_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\"{}/Resources/Networks/{}\", operation_config.base_path(), network_resource_name);\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::FabricError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.1261340379714966, "ppl_lower": 2.1689460277557373, "ppl/lowercase_ppl": -6.517700876992985, "ppl/zlib": 0.00015387378456473537, "Min_5.0% Prob": 2.4272602447148026, "Min_10.0% Prob": 1.1976437210499988, "Min_20.0% Prob": 0.593934532272207, "Min_30.0% Prob": 0.3970766563939894, "Min_40.0% Prob": 0.29697525707114775, "Min_50.0% Prob": 0.23798076316071926, "Min_60.0% Prob": 0.19798421095309482}}
{"hexsha": "78e1922a871dec3605dc670bcfa1786cab8a8741", "ext": "rs", "lang": "Rust", "content": "fn solve(input: &str) -> (usize, usize) {\n    let g = SimpleGrid::create_from(input);\n\n    // prepare and run the simulation using the adjacency rules\n    let (mut seats, adjacency_map) = adjacency_map(&g);\n    run_simulation(&mut seats, &adjacency_map, 4);\n    let occupied_adj = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();\n\n    // prepare and run the simulation using the visibility rules\n    let (mut seats, visibility_map) = visibility_map(&g);\n    run_simulation(&mut seats, &visibility_map, 5);\n    let occupied_vis = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();\n\n    (occupied_adj, occupied_vis)\n}", "item_id": 3, "repo": "gr-g/advent-of-code-2020", "file": "src/bin/11.rs", "last_update_at": "2020-12-24T08:08:52+00:00", "question_id": "78e1922a871dec3605dc670bcfa1786cab8a8741_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn solve(input: &str) -> (usize, usize) {\n    let g = SimpleGrid::create_from(input);\n    // prepare and run the simulation using the adjacency rules\n    let (mut seats, adjacency_map) = adjacency_map(&g);\n    run_simulation(&mut seats, &adjacency_map, 4);\n    let occupied_adj = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();\n    // prepare and run the simulation using the visibility rules\n    let (mut seats, visibility_map) = visibility_map(&g);\n    run_simulation(&mut seats, &visibility_map, 5);\n    let occupied_vis = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();\n    (occupied_adj, occupied_vis)\n"]], "pred": {"ppl": 2.3680431842803955, "ppl_lower": 2.6901726722717285, "ppl/lowercase_ppl": -1.14794891726639, "ppl/zlib": 0.0032653937631074662, "Min_5.0% Prob": 8.00098533630371, "Min_10.0% Prob": 6.192481684684753, "Min_20.0% Prob": 3.9301284609771354, "Min_30.0% Prob": 2.7994956758714493, "Min_40.0% Prob": 2.1374115291309645, "Min_50.0% Prob": 1.7188067364398962, "Min_60.0% Prob": 1.444928455925096}}
{"hexsha": "e7728e99feaced6ce2286e7cd7dd14e7216273ad", "ext": "rs", "lang": "Rust", "content": "fn test_struct() {\n    #[derive(PartialEq, Debug, Serialize, Deserialize)]\n    struct TestStruct {\n        int_field: u8,\n        string_field: String,\n        bool_field: bool,\n    }\n\n    test_roundtrip(TestStruct {\n        int_field: 42,\n        string_field: String::from(\"foo\"),\n        bool_field: false,\n    });\n}", "item_id": 5, "repo": "aprilabank/datastore.rs", "file": "src/serde_ds/roundtrip_tests.rs", "last_update_at": "2020-01-27T08:21:26+00:00", "question_id": "e7728e99feaced6ce2286e7cd7dd14e7216273ad_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_struct() {\n    #[derive(PartialEq, Debug, Serialize, Deserialize)]\n    struct TestStruct {\n        int_field: u8,\n        string_field: String,\n        bool_field: bool,\n    }\n    test_roundtrip(TestStruct {\n        int_field: 42,\n        string_field: String::from(\"foo\"),\n        bool_field: false,\n    });\n"]], "pred": {"ppl": 1.8421299457550049, "ppl_lower": 2.5935802459716797, "ppl/lowercase_ppl": -1.560000302168309, "ppl/zlib": 0.0036149259251914275, "Min_5.0% Prob": 5.530902910232544, "Min_10.0% Prob": 4.133723056316375, "Min_20.0% Prob": 2.7259277389163064, "Min_30.0% Prob": 2.0095295954135155, "Min_40.0% Prob": 1.5249622476597626, "Min_50.0% Prob": 1.2179520341725845, "Min_60.0% Prob": 1.0268235655708446}}
{"hexsha": "0a9cb98cf636d83c0e9b3f90a37fa1e1bf944679", "ext": "rs", "lang": "Rust", "content": "fn select_string(items: &[String], default: usize) -> UIResult<usize> {\n    // Add an option to return from the selection menu.\n    let mut select = Select::new();\n    for item in items {\n        select.item(&item);\n    }\n\n    // Add an option to return without selecting an index\n    // TODO: This should be optional, somehow. Could use a separate function?\n    select.item(\"(Return)\");\n\n    let index = select.default(default).interact()?;\n\n    if index < items.len() {\n        Ok(index)\n    } else {\n        Err(UIErrorKind::Abort)\n    }\n}", "item_id": 2, "repo": "pjohansson/create_system", "file": "src/bin/ui/utils.rs", "last_update_at": "2020-05-31T10:55:55+00:00", "question_id": "0a9cb98cf636d83c0e9b3f90a37fa1e1bf944679_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn select_string(items: &[String], default: usize) -> UIResult<usize> {\n    // Add an option to return from the selection menu.\n    let mut select = Select::new();\n    for item in items {\n        select.item(&item);\n    }\n    // Add an option to return without selecting an index\n    // TODO: This should be optional, somehow. Could use a separate function?\n    select.item(\"(Return)\");\n    let index = select.default(default).interact()?;\n    if index < items.len() {\n        Ok(index)\n    } else {\n        Err(UIErrorKind::Abort)\n    }\n"]], "pred": {"ppl": 3.2793307304382324, "ppl_lower": 4.890688419342041, "ppl/lowercase_ppl": -1.336544689799964, "ppl/zlib": 0.003906708407821767, "Min_5.0% Prob": 7.609002649784088, "Min_10.0% Prob": 5.9211452305316925, "Min_20.0% Prob": 4.297314278781414, "Min_30.0% Prob": 3.44182068357865, "Min_40.0% Prob": 2.832319057546556, "Min_50.0% Prob": 2.347441565617919, "Min_60.0% Prob": 1.980760176666081}}
{"hexsha": "16da93b7c0c56e8daf2f7bfd9019f1ffe2f1fd82", "ext": "rs", "lang": "Rust", "content": "async fn _check_software_update() -> hbb_common::ResultType<()> {\n    sleep(3.).await;\n\n    let rendezvous_server = socket_client::get_target_addr(&get_rendezvous_server(1_000).await)?;\n    let mut socket =\n        socket_client::new_udp(Config::get_any_listen_addr(), RENDEZVOUS_TIMEOUT).await?;\n\n    let mut msg_out = RendezvousMessage::new();\n    msg_out.set_software_update(SoftwareUpdate {\n        url: crate::VERSION.to_owned(),\n        ..Default::default()\n    });\n    socket.send(&msg_out, rendezvous_server).await?;\n    use hbb_common::protobuf::Message;\n    if let Some(Ok((bytes, _))) = socket.next_timeout(30_000).await {\n        if let Ok(msg_in) = RendezvousMessage::parse_from_bytes(&bytes) {\n            if let Some(rendezvous_message::Union::software_update(su)) = msg_in.union {\n                let version = hbb_common::get_version_from_url(&su.url);\n                if get_version_number(&version) > get_version_number(crate::VERSION) {\n                    *SOFTWARE_UPDATE_URL.lock().unwrap() = su.url;\n                }\n            }\n        }\n    }\n    Ok(())\n}", "item_id": 8, "repo": "wx-chevalier/dd-electron-screen-sharing", "file": "rust-rdp/rust-desk/src/common.rs", "last_update_at": "2020-10-15T18:43:24+00:00", "question_id": "16da93b7c0c56e8daf2f7bfd9019f1ffe2f1fd82_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn _check_software_update() -> hbb_common::ResultType<()> {\n    sleep(3.).await;\n    let rendezvous_server = socket_client::get_target_addr(&get_rendezvous_server(1_000).await)?;\n    let mut socket =\n        socket_client::new_udp(Config::get_any_listen_addr(), RENDEZVOUS_TIMEOUT).await?;\n    let mut msg_out = RendezvousMessage::new();\n    msg_out.set_software_update(SoftwareUpdate {\n        url: crate::VERSION.to_owned(),\n        ..Default::default()\n    });\n    socket.send(&msg_out, rendezvous_server).await?;\n    use hbb_common::protobuf::Message;\n    if let Some(Ok((bytes, _))) = socket.next_timeout(30_000).await {\n        if let Ok(msg_in) = RendezvousMessage::parse_from_bytes(&bytes) {\n            if let Some(rendezvous_message::Union::software_update(su)) = msg_in.union {\n                let version = hbb_common::get_version_from_url(&su.url);\n                if get_version_number(&version) > get_version_number(crate::VERSION) {\n                    *SOFTWARE_UPDATE_URL.lock().unwrap() = su.url;\n                }\n            }\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 3.2898192405700684, "ppl_lower": 4.3913092613220215, "ppl/lowercase_ppl": -1.2425150214187057, "ppl/zlib": 0.0023580843983998854, "Min_5.0% Prob": 8.705998102823893, "Min_10.0% Prob": 6.717794524298774, "Min_20.0% Prob": 4.833951582511266, "Min_30.0% Prob": 3.6328929487718353, "Min_40.0% Prob": 2.891724353617635, "Min_50.0% Prob": 2.357254073678792, "Min_60.0% Prob": 1.983326864625336}}
{"hexsha": "f37a273ed626f0978738e190fd043f8d593d27cb", "ext": "rs", "lang": "Rust", "content": "pub fn parse_stmt(tokens: &[Token]) -> (Option<Stmt>, &[Token]) {\n    if let Some(&Token::Keyword(Keyword::Break)) = tokens.get(0) {\n        return (Some(Stmt::Break), &tokens[1..]);\n    }\n\n    match parse_returnstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Return(s)), remain),\n        _ => (),\n    }\n    match parse_ifstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::If(s)), remain),\n        _ => (),\n    }\n\n    match parse_whilestmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::While(s)), remain),\n        _ => (),\n    }\n\n    match parse_assignstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Assign(s)), remain),\n        _ => (),\n    }\n\n    match parse_declstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Decl(s)), remain),\n        _ => (),\n    }\n\n    match parse_expr(tokens) {\n        (Some(e), remain) => return (Some(Stmt::Expr(e)), remain),\n        _ => (),\n    }\n\n    (None, tokens)\n}", "item_id": 3, "repo": "justinas/mylang", "file": "src/parser/mod.rs", "last_update_at": "2020-06-22T16:32:19+00:00", "question_id": "f37a273ed626f0978738e190fd043f8d593d27cb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_stmt(tokens: &[Token]) -> (Option<Stmt>, &[Token]) {\n    if let Some(&Token::Keyword(Keyword::Break)) = tokens.get(0) {\n        return (Some(Stmt::Break), &tokens[1..]);\n    }\n    match parse_returnstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Return(s)), remain),\n        _ => (),\n    }\n    match parse_ifstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::If(s)), remain),\n        _ => (),\n    }\n    match parse_whilestmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::While(s)), remain),\n        _ => (),\n    }\n    match parse_assignstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Assign(s)), remain),\n        _ => (),\n    }\n    match parse_declstmt(tokens) {\n        (Some(s), remain) => return (Some(Stmt::Decl(s)), remain),\n        _ => (),\n    }\n    match parse_expr(tokens) {\n        (Some(e), remain) => return (Some(Stmt::Expr(e)), remain),\n        _ => (),\n    }\n    (None, tokens)\n"]], "pred": {"ppl": 1.4012008905410767, "ppl_lower": 1.5640169382095337, "ppl/lowercase_ppl": -1.3258765569822883, "ppl/zlib": 0.001282622235349808, "Min_5.0% Prob": 4.887469544130213, "Min_10.0% Prob": 3.0696403179849896, "Min_20.0% Prob": 1.6535642418852994, "Min_30.0% Prob": 1.1227156923170079, "Min_40.0% Prob": 0.8412642135173345, "Min_50.0% Prob": 0.6758747632433739, "Min_60.0% Prob": 0.5620086042854296}}
{"hexsha": "f5b69259f35cd2b94ebfaa0e7718268cdd889d00", "ext": "rs", "lang": "Rust", "content": "pub fn pathconf<P: AsRef<ffi::OsStr>>(path: P, name: Int) -> Option<Long> {\n    let c_path = ffi::CString::new(path.as_ref().as_bytes()).ok()?;\n\n    let val = unsafe { libc::pathconf(c_path.as_ptr(), name) };\n\n    if val >= 0 {\n        Some(val)\n    } else {\n        None\n    }\n}", "item_id": 1, "repo": "cptpcrd/simple_libc", "file": "src/lib.rs", "last_update_at": "2020-08-29T02:29:49+00:00", "question_id": "f5b69259f35cd2b94ebfaa0e7718268cdd889d00_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn pathconf<P: AsRef<ffi::OsStr>>(path: P, name: Int) -> Option<Long> {\n    let c_path = ffi::CString::new(path.as_ref().as_bytes()).ok()?;\n    let val = unsafe { libc::pathconf(c_path.as_ptr(), name) };\n    if val >= 0 {\n        Some(val)\n    } else {\n        None\n    }\n"]], "pred": {"ppl": 2.1925618648529053, "ppl_lower": 4.039113521575928, "ppl/lowercase_ppl": -1.7782160397775753, "ppl/zlib": 0.003965003340639865, "Min_5.0% Prob": 8.48876495361328, "Min_10.0% Prob": 5.902604514902288, "Min_20.0% Prob": 3.8161299635063517, "Min_30.0% Prob": 2.6492317307627564, "Min_40.0% Prob": 1.9618911828431818, "Min_50.0% Prob": 1.5810049609613739, "Min_60.0% Prob": 1.3231707893159073}}
{"hexsha": "6c8b777cd28da371d38c70147322697079db1af8", "ext": "rs", "lang": "Rust", "content": "fn inverted_dashed() {\n    assert_eq!(ColorAttribute::from_str(\"no-bold\"), Ok(ColorAttribute::NoBold));\n    assert_eq!(ColorAttribute::from_str(\"no-dim\"), Ok(ColorAttribute::NoDim));\n    assert_eq!(ColorAttribute::from_str(\"no-ul\"), Ok(ColorAttribute::NoUl));\n    assert_eq!(ColorAttribute::from_str(\"no-blink\"), Ok(ColorAttribute::NoBlink));\n    assert_eq!(ColorAttribute::from_str(\"no-reverse\"), Ok(ColorAttribute::NoReverse));\n    assert_eq!(ColorAttribute::from_str(\"no-italic\"), Ok(ColorAttribute::NoItalic));\n    assert_eq!(ColorAttribute::from_str(\"no-strike\"), Ok(ColorAttribute::NoStrike));\n}", "item_id": 2, "repo": "Byron/grit", "file": "git-config/tests/values/color_attribute.rs", "last_update_at": "2020-07-30T15:12:14+00:00", "question_id": "6c8b777cd28da371d38c70147322697079db1af8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn inverted_dashed() {\n    assert_eq!(ColorAttribute::from_str(\"no-bold\"), Ok(ColorAttribute::NoBold));\n    assert_eq!(ColorAttribute::from_str(\"no-dim\"), Ok(ColorAttribute::NoDim));\n    assert_eq!(ColorAttribute::from_str(\"no-ul\"), Ok(ColorAttribute::NoUl));\n    assert_eq!(ColorAttribute::from_str(\"no-blink\"), Ok(ColorAttribute::NoBlink));\n    assert_eq!(ColorAttribute::from_str(\"no-reverse\"), Ok(ColorAttribute::NoReverse));\n    assert_eq!(ColorAttribute::from_str(\"no-italic\"), Ok(ColorAttribute::NoItalic));\n    assert_eq!(ColorAttribute::from_str(\"no-strike\"), Ok(ColorAttribute::NoStrike));\n"]], "pred": {"ppl": 1.624377727508545, "ppl_lower": 1.8904000520706177, "ppl/lowercase_ppl": -1.3126281467846863, "ppl/zlib": 0.003013197549843586, "Min_5.0% Prob": 7.4849979347652855, "Min_10.0% Prob": 4.5422748201771785, "Min_20.0% Prob": 2.4495341736627254, "Min_30.0% Prob": 1.620222770625019, "Min_40.0% Prob": 1.2218398645235975, "Min_50.0% Prob": 0.9701481187582909, "Min_60.0% Prob": 0.8113045595348702}}
{"hexsha": "1991061eef27150f53894ae41cc1429fa310d664", "ext": "rs", "lang": "Rust", "content": "pub async fn run(port: u16, memtable: Arc<RwLock<Memtable>>) {\n    let addr = SocketAddr::from(([127, 0, 0, 1], port));\n\n    println!(\"Listening on {}\", addr);\n\n    let serve_future =\n        Server::bind(&addr).serve(make_service_fn(move |_| {\n            let cloned_memtable = memtable.clone();\n            async move {\n                Ok::<_, hyper::Error>(service_fn(move |req| router(cloned_memtable.clone(), req)))\n            }\n        }));\n\n    // Wait for the server to complete serving or exit with an error.\n    // If an error occurred, print it to stderr.\n    if let Err(e) = serve_future.await {\n        eprintln!(\"server error: {}\", e);\n    }\n}", "item_id": 0, "repo": "nimrodshn/orpheus", "file": "src/server.rs", "last_update_at": "2020-10-15T07:42:45+00:00", "question_id": "1991061eef27150f53894ae41cc1429fa310d664_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn run(port: u16, memtable: Arc<RwLock<Memtable>>) {\n    let addr = SocketAddr::from(([127, 0, 0, 1], port));\n    println!(\"Listening on {}\", addr);\n    let serve_future =\n        Server::bind(&addr).serve(make_service_fn(move |_| {\n            let cloned_memtable = memtable.clone();\n            async move {\n                Ok::<_, hyper::Error>(service_fn(move |req| router(cloned_memtable.clone(), req)))\n            }\n        }));\n    // Wait for the server to complete serving or exit with an error.\n    // If an error occurred, print it to stderr.\n    if let Err(e) = serve_future.await {\n        eprintln!(\"server error: {}\", e);\n    }\n"]], "pred": {"ppl": 1.9096171855926514, "ppl_lower": 2.9380533695220947, "ppl/lowercase_ppl": -1.6660111073994186, "ppl/zlib": 0.0017772054823604483, "Min_5.0% Prob": 7.296469783782959, "Min_10.0% Prob": 4.79630978902181, "Min_20.0% Prob": 3.0163226070858182, "Min_30.0% Prob": 2.1131301959976554, "Min_40.0% Prob": 1.6158676965271725, "Min_50.0% Prob": 1.2904880060596722, "Min_60.0% Prob": 1.0806241858917929}}
{"hexsha": "f890906438d887dd1cf10bd56de8bc224216d572", "ext": "rs", "lang": "Rust", "content": "fn test_eval_result_new_dump_items() {\n    let dump_items = DumpItems::default();\n    let res = StoreEvalResult::new_dump_items(&dump_items);\n    assert!(res.is_ok());\n\n    let result = res.unwrap();\n\n    match result {\n        StoreEvalResult::DumpItems(result) => assert_eq!(result, dump_items),\n        _ => panic!(\"invalid variant\"),\n    }\n}", "item_id": 2, "repo": "mitrid-labs/mitrid-core", "file": "tests/io/store/eval/eval_result.rs", "last_update_at": "2020-02-13T15:57:46+00:00", "question_id": "f890906438d887dd1cf10bd56de8bc224216d572_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_eval_result_new_dump_items() {\n    let dump_items = DumpItems::default();\n    let res = StoreEvalResult::new_dump_items(&dump_items);\n    assert!(res.is_ok());\n    let result = res.unwrap();\n    match result {\n        StoreEvalResult::DumpItems(result) => assert_eq!(result, dump_items),\n        _ => panic!(\"invalid variant\"),\n    }\n"]], "pred": {"ppl": 2.9007887840270996, "ppl_lower": 4.085908889770508, "ppl/lowercase_ppl": -1.3216592206312534, "ppl/zlib": 0.005518045049226611, "Min_5.0% Prob": 8.907397556304932, "Min_10.0% Prob": 6.724364757537842, "Min_20.0% Prob": 4.702677575024691, "Min_30.0% Prob": 3.403573456135663, "Min_40.0% Prob": 2.622594252906062, "Min_50.0% Prob": 2.096885653744851, "Min_60.0% Prob": 1.769688123197698}}
{"hexsha": "5bcfe78371064597e2f1a7135e136797931b2073", "ext": "rs", "lang": "Rust", "content": "pub fn index(input: &str, base: &str, ignore_body: bool) -> Result<(), std::io::Error> {\n    let file_index: Vec<_> = WalkDir::new(input).into_iter().collect();\n    let file_index_len = file_index.len();\n\n    let items: Vec<Vec<u8>> = file_index\n        .into_par_iter()\n        .enumerate()\n        .map(|(i, entry)| {\n            let file_path = entry.expect(\"Couldn't read file, aborting...\");\n            let mut new_item: Vec<u8> = Vec::new();\n\n            if file_path\n                .path()\n                .extension()\n                .unwrap_or(std::ffi::OsStr::new(\"\"))\n                == \"html\"\n            {\n                // parse html document, convert it so it can be query-selectored-ed\n                let html = Html::parse_document(\n                    read_to_string(file_path.path())\n                        .expect(\"Failed to read file!\")\n                        .as_str(),\n                );\n\n                let title_selector =\n                    Selector::parse(\"head title\").expect(\"Failed to read HTML title, aborting...\");\n                let title: Vec<_> = html\n                    .select(&title_selector)\n                    .next()\n                    .expect(\"Failed to get HTML title, aborting...\")\n                    .text()\n                    .collect();\n\n                let mut body_text = String::new();\n                if ignore_body == false {\n                    let body_selector = Selector::parse(\"body,body *\")\n                        .expect(\"Failed to read HTML body, aborting...\");\n                    let body_elements: Vec<_> = html.select(&body_selector).collect();\n\n                    for element in body_elements.iter() {\n                        let element_text: Vec<_> = element.text().collect();\n                        if element_text.len() != 0 {\n                            body_text.push_str(element_text[0]);\n                        }\n                    }\n                }\n\n                new_item = to_vec_pretty(\n                    &Item::new(\n                        title[0],\n                        &format!(\n                            \"{}/{}\",\n                            base,\n                            file_path\n                                .path()\n                                .strip_prefix(\"./\")\n                                .unwrap_or(file_path.path())\n                                .display()\n                        )[..],\n                        match body_text.len() {\n                            0 => None,\n                            _ => Some(body_text),\n                        },\n                    )\n                    .expect(\"Failed to parse URL.\"),\n                )\n                .expect(\"Failed to index file.\");\n            }\n\n            if new_item.len() > 0 && i != file_index_len - 1 {\n                [new_item, \",\".as_bytes().to_vec()].concat()\n            } else {\n                new_item\n            }\n        })\n        .collect();\n\n    let idx = Index { items };\n\n    let output_file = File::create(\"index.json\").expect(\"Failed to generate index file!\");\n    let mut stream = BufWriter::new(output_file);\n\n    stream.write(&\"[\".as_bytes()).unwrap();\n    for i in 0..idx.items.len() {\n        stream.write(&idx.items[i]).unwrap();\n    }\n    stream.write(&\"]\".as_bytes()).unwrap();\n\n    stream.flush()\n}", "item_id": 0, "repo": "EthanJustice/tini", "file": "src/lib.rs", "last_update_at": "2020-10-05T23:47:03+00:00", "question_id": "5bcfe78371064597e2f1a7135e136797931b2073_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn index(input: &str, base: &str, ignore_body: bool) -> Result<(), std::io::Error> {\n    let file_index: Vec<_> = WalkDir::new(input).into_iter().collect();\n    let file_index_len = file_index.len();\n    let items: Vec<Vec<u8>> = file_index\n        .into_par_iter()\n        .enumerate()\n        .map(|(i, entry)| {\n            let file_path = entry.expect(\"Couldn't read file, aborting...\");\n            let mut new_item: Vec<u8> = Vec::new();\n            if file_path\n                .path()\n                .extension()\n                .unwrap_or(std::ffi::OsStr::new(\"\"))\n                == \"html\"\n            {\n                // parse html document, convert it so it can be query-selectored-ed\n                let html = Html::parse_document(\n                    read_to_string(file_path.path())\n                        .expect(\"Failed to read file!\")\n                        .as_str(),\n                );\n                let title_selector =\n                    Selector::parse(\"head title\").expect(\"Failed to read HTML title, aborting...\");\n                let title: Vec<_> = html\n                    .select(&title_selector)\n                    .next()\n                    .expect(\"Failed to get HTML title, aborting...\")\n                    .text()\n                    .collect();\n                let mut body_text = String::new();\n                if ignore_body == false {\n                    let body_selector = Selector::parse(\"body,body *\")\n                        .expect(\"Failed to read HTML body, aborting...\");\n                    let body_elements: Vec<_> = html.select(&body_selector).collect();\n                    for element in body_elements.iter() {\n                        let element_text: Vec<_> = element.text().collect();\n                        if element_text.len() != 0 {\n                            body_text.push_str(element_text[0]);\n                        }\n                    }\n                }\n                new_item = to_vec_pretty(\n                    &Item::new(\n                        title[0],\n                        &format!(\n                            \"{}/{}\",\n                            base,\n                            file_path\n                                .path()\n                                .strip_prefix(\"./\")\n                                .unwrap_or(file_path.path())\n                                .display()\n                        )[..],\n                        match body_text.len() {\n                            0 => None,\n                            _ => Some(body_text),\n                        },\n                    )\n                    .expect(\"Failed to parse URL.\"),\n                )\n                .expect(\"Failed to index file.\");\n            }\n            if new_item.len() > 0 && i != file_index_len - 1 {\n                [new_item, \",\".as_bytes().to_vec()].concat()\n            } else {\n                new_item\n            }\n        })\n        .collect();\n    let idx = Index { items };\n    let output_file = File::create(\"index.json\").expect(\"Failed to generate index file!\");\n    let mut stream = BufWriter::new(output_file);\n    stream.write(&\"[\".as_bytes()).unwrap();\n    for i in 0..idx.items.len() {\n        stream.write(&idx.items[i]).unwrap();\n    }\n    stream.write(&\"]\".as_bytes()).unwrap();\n    stream.flush()\n"]], "pred": {"ppl": 2.080620288848877, "ppl_lower": 2.3800430297851562, "ppl/lowercase_ppl": -1.1835113002050266, "ppl/zlib": 0.0007268512550083976, "Min_5.0% Prob": 6.196568625313895, "Min_10.0% Prob": 4.631423198475558, "Min_20.0% Prob": 3.135687804222107, "Min_30.0% Prob": 2.3312831447404974, "Min_40.0% Prob": 1.8073727966578474, "Min_50.0% Prob": 1.4620339903071033, "Min_60.0% Prob": 1.2220293304549417}}
{"hexsha": "84118592c564c37e68a3625889149946e8e9d8ec", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Parse args.\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <config file>\", args[0]);\n        std::process::exit(1);\n    }\n    let file_name = &args[1];\n\n    // Load config.\n    let file = File::open(file_name).expect(\"failed to open config\");\n    let reader = BufReader::new(file);\n    let realm = config::Realm::from_reader(reader).unwrap();\n\n    for svc in realm.services {\n        println!(\"{:?}\", svc);\n    }\n}", "item_id": 0, "repo": "jhillyerd/service-uptimer", "file": "src/main.rs", "last_update_at": "2020-12-15T04:23:00+00:00", "question_id": "84118592c564c37e68a3625889149946e8e9d8ec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Parse args.\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <config file>\", args[0]);\n        std::process::exit(1);\n    }\n    let file_name = &args[1];\n    // Load config.\n    let file = File::open(file_name).expect(\"failed to open config\");\n    let reader = BufReader::new(file);\n    let realm = config::Realm::from_reader(reader).unwrap();\n    for svc in realm.services {\n        println!(\"{:?}\", svc);\n    }\n"]], "pred": {"ppl": 1.9326186180114746, "ppl_lower": 2.4607176780700684, "ppl/lowercase_ppl": -1.3666504929284922, "ppl/zlib": 0.0022798473363209336, "Min_5.0% Prob": 6.551079422235489, "Min_10.0% Prob": 4.639889195561409, "Min_20.0% Prob": 2.938155835494399, "Min_30.0% Prob": 2.099660652024405, "Min_40.0% Prob": 1.6354786291718484, "Min_50.0% Prob": 1.3109495590281923, "Min_60.0% Prob": 1.1010170471379344}}
{"hexsha": "5fc3fcbc481bd8f38b28174bf6c6713146c44534", "ext": "rs", "lang": "Rust", "content": "fn test_pool_send_revoc_reg_def_def_requests(pool: TestPool) {\n        let identity = helpers::new_ledger_identity(&pool, Some(String::from(\"TRUSTEE\")));\n\n        let schema = helpers::schema::default_schema(&identity.did);\n        let (_schema_id, schema_seq_no) = helpers::schema::publish(&identity, &pool, &schema);\n\n        let cred_def = helpers::cred_def::build(&identity.did, schema_seq_no);\n        let cred_def_id = helpers::cred_def::publish(&identity, &pool, cred_def);\n\n        let revoc_reg_def = helpers::revoc_reg::build(&identity.did, &cred_def_id);\n        let revoc_reg_id = revoc_reg_def.id.clone();\n\n        // Send Revocation Registry Definition\n        let mut revoc_reg_def = pool\n            .request_builder()\n            .build_revoc_reg_def_request(\n                &identity.did,\n                RevocationRegistryDefinition::RevocationRegistryDefinitionV1(revoc_reg_def),\n            )\n            .unwrap();\n\n        let revoc_reg_def_response =\n            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_def).unwrap();\n\n        // Get Revocation Registry Definition\n        let get_revoc_reg_def_request = pool\n            .request_builder()\n            .build_get_revoc_reg_def_request(None, &revoc_reg_id)\n            .unwrap();\n\n        let response = pool\n            .send_request_with_retries(&get_revoc_reg_def_request, &revoc_reg_def_response)\n            .unwrap();\n        assert_eq!(\n            json!(helpers::revoc_reg::build(&identity.did, &cred_def_id)),\n            helpers::get_response_data(&response).unwrap()\n        );\n\n        // Send Revocation Registry Entry\n        let mut revoc_reg_delta_request = pool\n            .request_builder()\n            .build_revoc_reg_entry_request(\n                &identity.did,\n                &revoc_reg_id,\n                &REVOC_DEF_TYPE,\n                revoc_reg_delta(),\n            )\n            .unwrap();\n\n        let revoc_reg_entry_response =\n            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_delta_request).unwrap();\n\n        _get_revocation_registry_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);\n        _get_revocation_registry_delta_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);\n    }", "item_id": 6, "repo": "Patrik-Stas/indy-vdr", "file": "libindy_vdr/tests/revoc_reg.rs", "last_update_at": "2020-04-21T09:56:32+00:00", "question_id": "5fc3fcbc481bd8f38b28174bf6c6713146c44534_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_pool_send_revoc_reg_def_def_requests(pool: TestPool) {\n        let identity = helpers::new_ledger_identity(&pool, Some(String::from(\"TRUSTEE\")));\n        let schema = helpers::schema::default_schema(&identity.did);\n        let (_schema_id, schema_seq_no) = helpers::schema::publish(&identity, &pool, &schema);\n        let cred_def = helpers::cred_def::build(&identity.did, schema_seq_no);\n        let cred_def_id = helpers::cred_def::publish(&identity, &pool, cred_def);\n        let revoc_reg_def = helpers::revoc_reg::build(&identity.did, &cred_def_id);\n        let revoc_reg_id = revoc_reg_def.id.clone();\n        // Send Revocation Registry Definition\n        let mut revoc_reg_def = pool\n            .request_builder()\n            .build_revoc_reg_def_request(\n                &identity.did,\n                RevocationRegistryDefinition::RevocationRegistryDefinitionV1(revoc_reg_def),\n            )\n            .unwrap();\n        let revoc_reg_def_response =\n            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_def).unwrap();\n        // Get Revocation Registry Definition\n        let get_revoc_reg_def_request = pool\n            .request_builder()\n            .build_get_revoc_reg_def_request(None, &revoc_reg_id)\n            .unwrap();\n        let response = pool\n            .send_request_with_retries(&get_revoc_reg_def_request, &revoc_reg_def_response)\n            .unwrap();\n        assert_eq!(\n            json!(helpers::revoc_reg::build(&identity.did, &cred_def_id)),\n            helpers::get_response_data(&response).unwrap()\n        );\n        // Send Revocation Registry Entry\n        let mut revoc_reg_delta_request = pool\n            .request_builder()\n            .build_revoc_reg_entry_request(\n                &identity.did,\n                &revoc_reg_id,\n                &REVOC_DEF_TYPE,\n                revoc_reg_delta(),\n            )\n            .unwrap();\n        let revoc_reg_entry_response =\n            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_delta_request).unwrap();\n        _get_revocation_registry_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);\n        _get_revocation_registry_delta_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);\n"]], "pred": {"ppl": 1.8229081630706787, "ppl_lower": 1.9825739860534668, "ppl/lowercase_ppl": -1.1398371830688132, "ppl/zlib": 0.001083814291723824, "Min_5.0% Prob": 5.959559104021857, "Min_10.0% Prob": 4.386966356332751, "Min_20.0% Prob": 2.7873711953128595, "Min_30.0% Prob": 1.96315153065511, "Min_40.0% Prob": 1.4914630953531833, "Min_50.0% Prob": 1.200107831884757, "Min_60.0% Prob": 1.002104208404086}}
{"hexsha": "3996a02b568d788a269bc90728cd0fdf9727f94f", "ext": "rs", "lang": "Rust", "content": "fn run_tests_run_failed() {\n        init();\n        let plugin = RPlugin {};\n        let temp = copy_test(\"tests/data/simple_run_fail\");\n\n        let mut run = plugin.run_tests(temp.path(), &mut vec![]).unwrap();\n        assert_eq!(run.status, RunStatus::CompileFailed);\n        assert!(run.test_results.is_empty());\n        assert!(!run.logs.is_empty());\n        let logs = run.logs.remove(\"compiler_output\").unwrap();\n        assert!(logs.contains(\"unexpected 'in'\"))\n    }", "item_id": 4, "repo": "rangigo/tmc-langs-rust", "file": "plugins/r/src/plugin.rs", "last_update_at": "2020-11-23T08:21:58+00:00", "question_id": "3996a02b568d788a269bc90728cd0fdf9727f94f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_tests_run_failed() {\n        init();\n        let plugin = RPlugin {};\n        let temp = copy_test(\"tests/data/simple_run_fail\");\n        let mut run = plugin.run_tests(temp.path(), &mut vec![]).unwrap();\n        assert_eq!(run.status, RunStatus::CompileFailed);\n        assert!(run.test_results.is_empty());\n        assert!(!run.logs.is_empty());\n        let logs = run.logs.remove(\"compiler_output\").unwrap();\n        assert!(logs.contains(\"unexpected 'in'\"))\n"]], "pred": {"ppl": 4.3098602294921875, "ppl_lower": 5.042157173156738, "ppl/lowercase_ppl": -1.1074186725900936, "ppl/zlib": 0.005890747879990536, "Min_5.0% Prob": 7.279319695063999, "Min_10.0% Prob": 6.226873465946743, "Min_20.0% Prob": 4.9672191228185385, "Min_30.0% Prob": 4.01646166346794, "Min_40.0% Prob": 3.362906431942655, "Min_50.0% Prob": 2.8060984234842987, "Min_60.0% Prob": 2.4056347560050875}}
{"hexsha": "b736d88346fa2c54323eb41b0316cdb5f4af0069", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let on_lock = |ready: bool| {\n        if !ready {\n            println!(\"waiting for apt and dpkg lock to be available\")\n        }\n    };\n\n    let on_ready = || println!(\"Now ready to use apt\");\n    wait_for_apt_locks(3000, on_lock, on_ready);\n}", "item_id": 0, "repo": "hixio-mh/apt-cli-wrappers", "file": "examples/locking.rs", "last_update_at": "2020-01-31T17:54:49+00:00", "question_id": "b736d88346fa2c54323eb41b0316cdb5f4af0069_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let on_lock = |ready: bool| {\n        if !ready {\n            println!(\"waiting for apt and dpkg lock to be available\")\n        }\n    };\n    let on_ready = || println!(\"Now ready to use apt\");\n    wait_for_apt_locks(3000, on_lock, on_ready);\n"]], "pred": {"ppl": 4.81580924987793, "ppl_lower": 4.726754188537598, "ppl/lowercase_ppl": -0.9881256428031269, "ppl/zlib": 0.009469301805052002, "Min_5.0% Prob": 9.665396213531494, "Min_10.0% Prob": 8.592311263084412, "Min_20.0% Prob": 5.854655490202062, "Min_30.0% Prob": 4.454071989426246, "Min_40.0% Prob": 3.6020457880837577, "Min_50.0% Prob": 3.0114640444517136, "Min_60.0% Prob": 2.610266405229385}}
{"hexsha": "f4f362a9c0691983634a5909192b4c0ad764335c", "ext": "rs", "lang": "Rust", "content": "fn test_evolution() {\n        // Let's create an evolution machine\n        let mut machine = Machine::new(&pokemon_op_sys);\n\n        // You have a Charmander\n        let my_creature = Charmander;\n\n        // Put the Charmander into the machine\n        let result = machine.operate(&Item::Value(my_creature)).unwrap();\n\n        // There should obviously be a Charmander in the machine\n        assert_eq!(result, &Charmander);\n        // And there should be nothing else in the machine\n        assert_eq!(machine.stack_length(), 1);\n\n        // Let's make it evolute!\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n\n        // Charmander should have turned into Charmaleon!\n        assert_eq!(result, &Charmaleon);\n        // And again there should be only 1 creature in the machine\n        assert_eq!(machine.stack_length(), 1);\n\n        // Let's evolute it again\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n\n        // Meet our blazing Charizard!\n        assert_eq!(result, &Charizard);\n\n        // What if we try to evolute Charizard?\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n\n        // Good try... but it should still be a Charizard\n        assert_eq!(result, &Charizard);\n\n        // Ok, we already got Charizard, let's just close the machine and make sure we don't leave\n        // any creature behind\n        machine.operate(&Item::Operator(Close));\n        assert_eq!(machine.stack_length(), 0);\n    }", "item_id": 1, "repo": "aesedepece/scriptful", "file": "src/op_systems/pokemon.rs", "last_update_at": "2020-12-12T13:38:01+00:00", "question_id": "f4f362a9c0691983634a5909192b4c0ad764335c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_evolution() {\n        // Let's create an evolution machine\n        let mut machine = Machine::new(&pokemon_op_sys);\n        // You have a Charmander\n        let my_creature = Charmander;\n        // Put the Charmander into the machine\n        let result = machine.operate(&Item::Value(my_creature)).unwrap();\n        // There should obviously be a Charmander in the machine\n        assert_eq!(result, &Charmander);\n        // And there should be nothing else in the machine\n        assert_eq!(machine.stack_length(), 1);\n        // Let's make it evolute!\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n        // Charmander should have turned into Charmaleon!\n        assert_eq!(result, &Charmaleon);\n        // And again there should be only 1 creature in the machine\n        assert_eq!(machine.stack_length(), 1);\n        // Let's evolute it again\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n        // Meet our blazing Charizard!\n        assert_eq!(result, &Charizard);\n        // What if we try to evolute Charizard?\n        let result = machine.operate(&Item::Operator(Evolute)).unwrap();\n        // Good try... but it should still be a Charizard\n        assert_eq!(result, &Charizard);\n        // Ok, we already got Charizard, let's just close the machine and make sure we don't leave\n        // any creature behind\n        machine.operate(&Item::Operator(Close));\n        assert_eq!(machine.stack_length(), 0);\n"]], "pred": {"ppl": 2.9473392963409424, "ppl_lower": 3.216620683670044, "ppl/lowercase_ppl": -1.0808847002774407, "ppl/zlib": 0.002237894057808026, "Min_5.0% Prob": 7.850526571273804, "Min_10.0% Prob": 6.183821055947281, "Min_20.0% Prob": 4.466865907232445, "Min_30.0% Prob": 3.4054976293156223, "Min_40.0% Prob": 2.653643118688859, "Min_50.0% Prob": 2.1566266185347587, "Min_60.0% Prob": 1.798991118763465}}
{"hexsha": "c15966f183f430907c8bbdb89d55eae8b1ea391a", "ext": "rs", "lang": "Rust", "content": "pub fn init() {\n    extern \"C\" {\n        fn trap_entry();\n    }\n    // Set the exception vector address\n    cp0::ebase::write_u32(trap_entry as u32);\n    println!(\"Set ebase = {:x}\", trap_entry as u32);\n\n    let mut status = cp0::status::read();\n    // Enable IPI\n    status.enable_soft_int0();\n    status.enable_soft_int1();\n    // Enable clock interrupt\n    status.enable_hard_int5();\n    // Enable serial interrupt\n    #[cfg(feature = \"board_thinpad\")]\n    status.enable_hard_int0();\n\n    cp0::status::write(status);\n    info!(\"interrupt: init end\");\n}", "item_id": 0, "repo": "EatenBagpipe/rCore", "file": "kernel/src/arch/mipsel/interrupt.rs", "last_update_at": "2020-04-08T06:58:40+00:00", "question_id": "c15966f183f430907c8bbdb89d55eae8b1ea391a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init() {\n    extern \"C\" {\n        fn trap_entry();\n    }\n    // Set the exception vector address\n    cp0::ebase::write_u32(trap_entry as u32);\n    println!(\"Set ebase = {:x}\", trap_entry as u32);\n    let mut status = cp0::status::read();\n    // Enable IPI\n    status.enable_soft_int0();\n    status.enable_soft_int1();\n    // Enable clock interrupt\n    status.enable_hard_int5();\n    // Enable serial interrupt\n    #[cfg(feature = \"board_thinpad\")]\n    status.enable_hard_int0();\n    cp0::status::write(status);\n    info!(\"interrupt: init end\");\n"]], "pred": {"ppl": 3.6219613552093506, "ppl_lower": 3.7838797569274902, "ppl/lowercase_ppl": -1.0339810807074943, "ppl/zlib": 0.004547758621704946, "Min_5.0% Prob": 8.597873899671766, "Min_10.0% Prob": 7.251584476894802, "Min_20.0% Prob": 5.264807578679678, "Min_30.0% Prob": 4.0110664410250525, "Min_40.0% Prob": 3.1716776549816132, "Min_50.0% Prob": 2.570798850994795, "Min_60.0% Prob": 2.1477581414567157}}
{"hexsha": "9772642bfbdc99d2ae3e94efb752408466f8e2b0", "ext": "rs", "lang": "Rust", "content": "fn get_time_plateau() {\n        let values = [1.0, 2.0, 2.0, 3.0].to_vec();\n        let grid = [4.0, 5.0, 6.0, 7.0].to_vec();\n        let spline = MonotoneCubicSpline::new(values, grid).unwrap();\n        assert_eq!(spline.get_time(2.0), None);\n    }", "item_id": 1, "repo": "AudioSceneDescriptionFormat/asdfspline-rust", "file": "src/monotonecubicspline.rs", "last_update_at": "2020-12-17T00:00:59+00:00", "question_id": "9772642bfbdc99d2ae3e94efb752408466f8e2b0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_time_plateau() {\n        let values = [1.0, 2.0, 2.0, 3.0].to_vec();\n        let grid = [4.0, 5.0, 6.0, 7.0].to_vec();\n        let spline = MonotoneCubicSpline::new(values, grid).unwrap();\n        assert_eq!(spline.get_time(2.0), None);\n"]], "pred": {"ppl": 2.9159839153289795, "ppl_lower": 3.5712645053863525, "ppl/lowercase_ppl": -1.1894141803132599, "ppl/zlib": 0.006565688945558574, "Min_5.0% Prob": 9.344451808929444, "Min_10.0% Prob": 7.241688966751099, "Min_20.0% Prob": 4.621174866502935, "Min_30.0% Prob": 3.386807019060308, "Min_40.0% Prob": 2.584132812420527, "Min_50.0% Prob": 2.122935372005616, "Min_60.0% Prob": 1.7951506306208782}}
{"hexsha": "4288f64500675406d8b3af363a3524b27723b533", "ext": "rs", "lang": "Rust", "content": "fn singleton_enum_serialize() {\n        // This test is basically just here so that we can provide a reference for how the\n        // Phoenix/Elixir website needs to send arena control messages\n\n        let query = ArenaControlCommand::QueryMechs;\n        let s = serde_json::to_string(&query).unwrap();\n        assert_eq!(\"\\\"QueryMechs\\\"\", s);\n\n        let sm = ArenaControlCommand::StartMatch(CreateMatch {\n            actors: Vec::new(),\n            aps_per_turn: 4,\n            match_id: \"test\".to_string(),\n            board_height: 10,\n            board_width: 20,\n            max_turns: 100,\n        });\n        let s2 = serde_json::to_string(&sm).unwrap();\n        assert_eq!(\n            \"{\\\"StartMatch\\\":{\\\"match_id\\\":\\\"test\\\",\\\"actors\\\":[],\\\"board_height\\\":10,\\\"board_width\\\":20,\\\"max_turns\\\":100,\\\"aps_per_turn\\\":4}}\", \n            s2);\n    }", "item_id": 0, "repo": "bacongobbler/wasmdome", "file": "engine-provider/src/store.rs", "last_update_at": "2020-08-21T08:41:20+00:00", "question_id": "4288f64500675406d8b3af363a3524b27723b533_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn singleton_enum_serialize() {\n        // This test is basically just here so that we can provide a reference for how the\n        // Phoenix/Elixir website needs to send arena control messages\n        let query = ArenaControlCommand::QueryMechs;\n        let s = serde_json::to_string(&query).unwrap();\n        assert_eq!(\"\\\"QueryMechs\\\"\", s);\n        let sm = ArenaControlCommand::StartMatch(CreateMatch {\n            actors: Vec::new(),\n            aps_per_turn: 4,\n            match_id: \"test\".to_string(),\n            board_height: 10,\n            board_width: 20,\n            max_turns: 100,\n        });\n        let s2 = serde_json::to_string(&sm).unwrap();\n        assert_eq!(\n            \"{\\\"StartMatch\\\":{\\\"match_id\\\":\\\"test\\\",\\\"actors\\\":[],\\\"board_height\\\":10,\\\"board_width\\\":20,\\\"max_turns\\\":100,\\\"aps_per_turn\\\":4}}\", \n            s2);\n"]], "pred": {"ppl": 3.2773005962371826, "ppl_lower": 3.9163591861724854, "ppl/lowercase_ppl": -1.1500752593739594, "ppl/zlib": 0.0028881267508580172, "Min_5.0% Prob": 9.395679253798265, "Min_10.0% Prob": 7.276551317285608, "Min_20.0% Prob": 4.968406390260767, "Min_30.0% Prob": 3.721872040519008, "Min_40.0% Prob": 2.9212604812173932, "Min_50.0% Prob": 2.3647240646735384, "Min_60.0% Prob": 1.976349705065612}}
{"hexsha": "4f523374d95bdb6a4051fcc807ce4d02a5d3a681", "ext": "rs", "lang": "Rust", "content": "fn hook_macro() {\n        let dest = setup(unsafe { add_one_before::len() });\n\n        let hook = unsafe { add_one_before::copy_to(dest) };\n\n        for _ in 0..2 {\n            unsafe { hook.hook(square) };\n\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n\n            unsafe { hook.toggle() };\n\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 25);\n            assert_eq!(square(5), 36);\n            assert_eq!(unsafe { hook.trampoline() }(4), 16);\n            assert_eq!(unsafe { hook.trampoline() }(5), 25);\n\n            unsafe { hook.toggle() };\n\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n\n            unsafe { hook.unhook() };\n\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n        }\n    }", "item_id": 1, "repo": "cppio/ezhook", "file": "src/remote/trampoline.rs", "last_update_at": "2020-06-15T20:59:54+00:00", "question_id": "4f523374d95bdb6a4051fcc807ce4d02a5d3a681_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hook_macro() {\n        let dest = setup(unsafe { add_one_before::len() });\n        let hook = unsafe { add_one_before::copy_to(dest) };\n        for _ in 0..2 {\n            unsafe { hook.hook(square) };\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n            unsafe { hook.toggle() };\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 25);\n            assert_eq!(square(5), 36);\n            assert_eq!(unsafe { hook.trampoline() }(4), 16);\n            assert_eq!(unsafe { hook.trampoline() }(5), 25);\n            unsafe { hook.toggle() };\n            assert!(unsafe { hook.target() } == square);\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n            unsafe { hook.unhook() };\n            assert_eq!(square(4), 16);\n            assert_eq!(square(5), 25);\n        }\n"]], "pred": {"ppl": 2.116584539413452, "ppl_lower": 2.116584539413452, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0032742520664045026, "Min_5.0% Prob": 7.947599744796753, "Min_10.0% Prob": 5.382222975454023, "Min_20.0% Prob": 3.432241877240519, "Min_30.0% Prob": 2.4578131142482964, "Min_40.0% Prob": 1.875788077531803, "Min_50.0% Prob": 1.4965952659169068, "Min_60.0% Prob": 1.2502284223950881}}
{"hexsha": "ca5a4db29deff36bfc93b6731d0b4191b0b92f4b", "ext": "rs", "lang": "Rust", "content": "pub fn put_in_memory(input: &[u8]) -> *mut u8 {\n    let bytes_length = input.len() as u32;\n    let mut bytes = to_bytes(&bytes_length);\n    bytes.extend_from_slice(input);\n    let ptr = bytes.as_mut_ptr();\n    #[cfg(feature = \"std\")]\n    ::std::mem::forget(bytes);\n    #[cfg(not(feature = \"std\"))]\n    core::mem::forget(bytes);\n    ptr\n}", "item_id": 3, "repo": "Concordium/concordium-std", "file": "concordium-std/src/impls.rs", "last_update_at": "2020-12-14T10:45:16+00:00", "question_id": "ca5a4db29deff36bfc93b6731d0b4191b0b92f4b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn put_in_memory(input: &[u8]) -> *mut u8 {\n    let bytes_length = input.len() as u32;\n    let mut bytes = to_bytes(&bytes_length);\n    bytes.extend_from_slice(input);\n    let ptr = bytes.as_mut_ptr();\n    #[cfg(feature = \"std\")]\n    ::std::mem::forget(bytes);\n    #[cfg(not(feature = \"std\"))]\n    core::mem::forget(bytes);\n    ptr\n"]], "pred": {"ppl": 2.4549574851989746, "ppl_lower": 2.4549574851989746, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004582191038054284, "Min_5.0% Prob": 7.931182463963826, "Min_10.0% Prob": 6.207529187202454, "Min_20.0% Prob": 4.005054717063904, "Min_30.0% Prob": 2.8599836842009894, "Min_40.0% Prob": 2.238941694200039, "Min_50.0% Prob": 1.7998331380741937, "Min_60.0% Prob": 1.4981940670036955}}
{"hexsha": "4851154e3a4d1a8c37f052f71a12d696c4f561f9", "ext": "rs", "lang": "Rust", "content": "pub fn latest_version_fuzzy(\n    name: &str,\n    source_id: SourceId,\n    version_req: VersionReq,\n    allow_prerelease: bool,\n) -> DargoResult<Option<(String, Version)>> {\n    if let Some(version) = latest_version(name, source_id, version_req.clone(), allow_prerelease)? {\n        return Ok(Some((name.to_string(), version)));\n    }\n\n    let mut name = name.to_string();\n    let positions: Vec<usize> = name\n        .bytes()\n        .enumerate()\n        .filter(|(_, item)| *item == b'-' || *item == b'_')\n        .map(|(index, _)| index)\n        .collect::<Vec<_>>();\n    match positions.len() {\n        0 => return Ok(None),\n        1..=127 => {}\n        _ => return Err(format_err!(\"crate name contain too many '-' or '_'\")),\n    }\n\n    for mask in 0..u128::pow(2, positions.len() as u32) {\n        positions.iter().enumerate().for_each(|(index, item)| {\n            #[allow(unsafe_code)]\n            unsafe {\n                name.as_bytes_mut()[*item] = match (mask >> index) & 1 {\n                    0 => b'_',\n                    1 => b'-',\n                    _ => unreachable!(),\n                }\n            };\n        });\n        if let Some(version) =\n            latest_version(&name, source_id, version_req.clone(), allow_prerelease)?\n        {\n            return Ok(Some((name, version)));\n        }\n    }\n\n    Ok(None)\n}", "item_id": 1, "repo": "DCjanus/dargo", "file": "src/crates.rs", "last_update_at": "2020-08-28T09:46:43+00:00", "question_id": "4851154e3a4d1a8c37f052f71a12d696c4f561f9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn latest_version_fuzzy(\n    name: &str,\n    source_id: SourceId,\n    version_req: VersionReq,\n    allow_prerelease: bool,\n) -> DargoResult<Option<(String, Version)>> {\n    if let Some(version) = latest_version(name, source_id, version_req.clone(), allow_prerelease)? {\n        return Ok(Some((name.to_string(), version)));\n    }\n    let mut name = name.to_string();\n    let positions: Vec<usize> = name\n        .bytes()\n        .enumerate()\n        .filter(|(_, item)| *item == b'-' || *item == b'_')\n        .map(|(index, _)| index)\n        .collect::<Vec<_>>();\n    match positions.len() {\n        0 => return Ok(None),\n        1..=127 => {}\n        _ => return Err(format_err!(\"crate name contain too many '-' or '_'\")),\n    }\n    for mask in 0..u128::pow(2, positions.len() as u32) {\n        positions.iter().enumerate().for_each(|(index, item)| {\n            #[allow(unsafe_code)]\n            unsafe {\n                name.as_bytes_mut()[*item] = match (mask >> index) & 1 {\n                    0 => b'_',\n                    1 => b'-',\n                    _ => unreachable!(),\n                }\n            };\n        });\n        if let Some(version) =\n            latest_version(&name, source_id, version_req.clone(), allow_prerelease)?\n        {\n            return Ok(Some((name, version)));\n        }\n    }\n    Ok(None)\n"]], "pred": {"ppl": 1.9605705738067627, "ppl_lower": 2.228987693786621, "ppl/lowercase_ppl": -1.190590047392432, "ppl/zlib": 0.0011936800353962423, "Min_5.0% Prob": 7.163835139501662, "Min_10.0% Prob": 5.0164269379207065, "Min_20.0% Prob": 3.0882320158621845, "Min_30.0% Prob": 2.1937231748597696, "Min_40.0% Prob": 1.6743261533522467, "Min_50.0% Prob": 1.3458021495090884, "Min_60.0% Prob": 1.1228923709023062}}
{"hexsha": "4d4debbb8219d618ce0dad2dfac8439d6f6e6dc7", "ext": "rs", "lang": "Rust", "content": "fn get_sr_paths(target_dir: &Path) -> Vec<PathBuf> {\n    let mut sr_paths = Vec::new();\n\n    let walker = globwalk::GlobWalkerBuilder::from_patterns(target_dir, &[\".sr\"])\n        .max_depth(100)\n        .follow_links(false)\n        .sort_by(path_cmp)\n        .build()\n        .expect(\"Could not build globwalk directory walker.\")\n        .into_iter()\n        .filter_map(Result::ok);\n\n    for sr_file in walker {\n        sr_paths.push(sr_file.path().to_path_buf());\n    }\n\n    sr_paths\n}", "item_id": 28, "repo": "7BIndustries/sliderule-rs", "file": "src/lib.rs", "last_update_at": "2020-05-28T21:43:12+00:00", "question_id": "4d4debbb8219d618ce0dad2dfac8439d6f6e6dc7_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_sr_paths(target_dir: &Path) -> Vec<PathBuf> {\n    let mut sr_paths = Vec::new();\n    let walker = globwalk::GlobWalkerBuilder::from_patterns(target_dir, &[\".sr\"])\n        .max_depth(100)\n        .follow_links(false)\n        .sort_by(path_cmp)\n        .build()\n        .expect(\"Could not build globwalk directory walker.\")\n        .into_iter()\n        .filter_map(Result::ok);\n    for sr_file in walker {\n        sr_paths.push(sr_file.path().to_path_buf());\n    }\n    sr_paths\n"]], "pred": {"ppl": 2.248638868331909, "ppl_lower": 3.211495876312256, "ppl/lowercase_ppl": -1.439837978842358, "ppl/zlib": 0.0028734932118928223, "Min_5.0% Prob": 7.619512498378754, "Min_10.0% Prob": 5.66045867695528, "Min_20.0% Prob": 3.5446084788867407, "Min_30.0% Prob": 2.606905247729558, "Min_40.0% Prob": 2.0015943190881185, "Min_50.0% Prob": 1.625124089334203, "Min_60.0% Prob": 1.3497549664672641}}
{"hexsha": "2d76a0f507fb07674d7b808d897fa38cd3734408", "ext": "rs", "lang": "Rust", "content": "fn encrypt_always_returns_constant_length_byte_array_for_4_byte_input_with_authenticated_encryption(\n        ) {\n            let (_, sk1) = gen_encrypt_keypair();\n            let (pk2, _) = gen_encrypt_keypair();\n            let enc_ctx = EncryptContext::authenticated(sk1.shared_secret(&pk2));\n\n            for size in &[0u32, 25000, DEFAULT_MAX_PAYLOAD_SIZE as u32, MAX_U32] {\n                let encrypted = unwrap!(enc_ctx.encrypt(&size));\n                assert_that!(&encrypted, len(ENCRYPTED_U32_LEN));\n            }\n        }", "item_id": 1, "repo": "S-Coyle/socket-collection", "file": "src/crypto.rs", "last_update_at": "2020-03-06T14:57:14+00:00", "question_id": "2d76a0f507fb07674d7b808d897fa38cd3734408_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encrypt_always_returns_constant_length_byte_array_for_4_byte_input_with_authenticated_encryption(\n        ) {\n            let (_, sk1) = gen_encrypt_keypair();\n            let (pk2, _) = gen_encrypt_keypair();\n            let enc_ctx = EncryptContext::authenticated(sk1.shared_secret(&pk2));\n            for size in &[0u32, 25000, DEFAULT_MAX_PAYLOAD_SIZE as u32, MAX_U32] {\n                let encrypted = unwrap!(enc_ctx.encrypt(&size));\n                assert_that!(&encrypted, len(ENCRYPTED_U32_LEN));\n            }\n"]], "pred": {"ppl": 4.275553226470947, "ppl_lower": 5.221777439117432, "ppl/lowercase_ppl": -1.1376023729461333, "ppl/zlib": 0.004826955161849889, "Min_5.0% Prob": 9.192585733201769, "Min_10.0% Prob": 7.259787241617839, "Min_20.0% Prob": 5.3805450267261925, "Min_30.0% Prob": 4.206126347455111, "Min_40.0% Prob": 3.4403210184345507, "Min_50.0% Prob": 2.844818891066572, "Min_60.0% Prob": 2.417610037936406}}
{"hexsha": "acb80b20fd9b318a89bf6ee92e1bf91c92ce0e90", "ext": "rs", "lang": "Rust", "content": "async fn round_trip_client(payload: &[u8], port: u16) -> anyhow::Result<()> {\n    let (mut reader, mut writer) = ws_connect(port).await.context(\"Connect\")?.into_erased_split();\n    let write_fut = write_payload(&mut writer, payload).map(|res| res.context(\"Write payload\"));\n    let read_fut = read_assert_payload(&mut reader, payload).map(|res| res.context(\"Assert payload\"));\n    tokio::try_join!(write_fut, read_fut)?;\n    writer.shutdown().await.context(\"Shutdown operation\")?;\n    Ok(())\n}", "item_id": 0, "repo": "Devolutions/devolutions-jet", "file": "crates/transport/tests/websocket.rs", "last_update_at": "2020-09-04T16:38:49+00:00", "question_id": "acb80b20fd9b318a89bf6ee92e1bf91c92ce0e90_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn round_trip_client(payload: &[u8], port: u16) -> anyhow::Result<()> {\n    let (mut reader, mut writer) = ws_connect(port).await.context(\"Connect\")?.into_erased_split();\n    let write_fut = write_payload(&mut writer, payload).map(|res| res.context(\"Write payload\"));\n    let read_fut = read_assert_payload(&mut reader, payload).map(|res| res.context(\"Assert payload\"));\n    tokio::try_join!(write_fut, read_fut)?;\n    writer.shutdown().await.context(\"Shutdown operation\")?;\n    Ok(())\n"]], "pred": {"ppl": 2.963277816772461, "ppl_lower": 3.4453985691070557, "ppl/lowercase_ppl": -1.1387684046580175, "ppl/zlib": 0.003950167367944467, "Min_5.0% Prob": 9.681776344776154, "Min_10.0% Prob": 7.340827509760857, "Min_20.0% Prob": 4.804806572018248, "Min_30.0% Prob": 3.468371204137802, "Min_40.0% Prob": 2.6961653661547285, "Min_50.0% Prob": 2.1703479298087487, "Min_60.0% Prob": 1.8104747714102267}}
{"hexsha": "0d385749b1bd8f6191152aaf95ada3052fa2fce4", "ext": "rs", "lang": "Rust", "content": "fn approx_derivate<T: Copy>(cost: &impl Cost<T>, prediction: f64, truth: T) -> f64 {\n        let epsilon = 0.00001;\n        let f_plus_epsilon = cost.cost(prediction + epsilon, truth);\n        let f_minus_epsilon = cost.cost(prediction - epsilon, truth);\n        println!(\n            \"f_x_plus_epsilon: {}, f_x_minus_epsilon:: {}\",\n            f_plus_epsilon, f_minus_epsilon\n        );\n        (f_plus_epsilon - f_minus_epsilon) / (2.0 * epsilon)\n    }", "item_id": 0, "repo": "vishalbelsare/vikos", "file": "src/cost.rs", "last_update_at": "2020-04-13T13:35:50+00:00", "question_id": "0d385749b1bd8f6191152aaf95ada3052fa2fce4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn approx_derivate<T: Copy>(cost: &impl Cost<T>, prediction: f64, truth: T) -> f64 {\n        let epsilon = 0.00001;\n        let f_plus_epsilon = cost.cost(prediction + epsilon, truth);\n        let f_minus_epsilon = cost.cost(prediction - epsilon, truth);\n        println!(\n            \"f_x_plus_epsilon: {}, f_x_minus_epsilon:: {}\",\n            f_plus_epsilon, f_minus_epsilon\n        );\n        (f_plus_epsilon - f_minus_epsilon) / (2.0 * epsilon)\n"]], "pred": {"ppl": 2.530083656311035, "ppl_lower": 2.9026663303375244, "ppl/lowercase_ppl": -1.1479957128613658, "ppl/zlib": 0.0045502567055311595, "Min_5.0% Prob": 8.624226331710815, "Min_10.0% Prob": 6.477457091212273, "Min_20.0% Prob": 4.196251265704632, "Min_30.0% Prob": 3.005744017660618, "Min_40.0% Prob": 2.3093401808291674, "Min_50.0% Prob": 1.8624650608748197, "Min_60.0% Prob": 1.5554906323183484}}
{"hexsha": "544a63ec876f81d9453cedfde72d9d6d583a51e9", "ext": "rs", "lang": "Rust", "content": "pub async fn get(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        gallery_name: &str,\n        select: Option<&str>,\n    ) -> std::result::Result<models::Gallery, get::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Compute/galleries/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            gallery_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        if let Some(select) = select {\n            url.query_pairs_mut().append_pair(\"$select\", select);\n        }\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::Gallery =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 36, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/compute/src/package_2020_09_30_only/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "544a63ec876f81d9453cedfde72d9d6d583a51e9_36", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        gallery_name: &str,\n        select: Option<&str>,\n    ) -> std::result::Result<models::Gallery, get::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Compute/galleries/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            gallery_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::GET);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(get::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        if let Some(select) = select {\n            url.query_pairs_mut().append_pair(\"$select\", select);\n        }\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::Gallery =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Ok(rsp_value)\n            }\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(get::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.0763193368911743, "ppl_lower": 1.8322075605392456, "ppl/lowercase_ppl": -8.233101513158163, "ppl/zlib": 8.947347835285825e-05, "Min_5.0% Prob": 1.497821552615746, "Min_10.0% Prob": 0.7385336801089579, "Min_20.0% Prob": 0.36928475710802033, "Min_30.0% Prob": 0.24619202020941794, "Min_40.0% Prob": 0.18399657684686013, "Min_50.0% Prob": 0.14730074854556618, "Min_60.0% Prob": 0.12280815088924339}}
{"hexsha": "7b988240c3d2edf85d1db4303bcc43a0fdfa1e64", "ext": "rs", "lang": "Rust", "content": "fn parse_execute_arguments(\n    execute_arguments: Pair<'_, Rule>,\n) -> ParseResult<Option<ExecuteArguments>, Rule> {\n    let mut execute_arguments_elements = execute_arguments.into_inner();\n\n    let execute_argument_delimiter =\n        next_match(&mut execute_arguments_elements, Rule::execute_argument_delimiter)?;\n    let parsed_execute_argument_delimiter =\n        parse_execute_argument_delimiter(execute_argument_delimiter)?;\n\n    let arguments = next_match(&mut execute_arguments_elements, Rule::arguments)?;\n    let parsed_arguments = ARGUMENTS_PARSER.parse_arguments(arguments)?;\n\n    Ok(Some(ExecuteArguments {\n        nonstandard_delimiter: parsed_execute_argument_delimiter,\n        arguments: parsed_arguments,\n    }))\n}", "item_id": 3, "repo": "EnderNightLord-ChromeBook/zircon-rpi", "file": "src/connectivity/lib/at-commands/src/parser/command_parser.rs", "last_update_at": "2020-12-29T17:07:06+00:00", "question_id": "7b988240c3d2edf85d1db4303bcc43a0fdfa1e64_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_execute_arguments(\n    execute_arguments: Pair<'_, Rule>,\n) -> ParseResult<Option<ExecuteArguments>, Rule> {\n    let mut execute_arguments_elements = execute_arguments.into_inner();\n    let execute_argument_delimiter =\n        next_match(&mut execute_arguments_elements, Rule::execute_argument_delimiter)?;\n    let parsed_execute_argument_delimiter =\n        parse_execute_argument_delimiter(execute_argument_delimiter)?;\n    let arguments = next_match(&mut execute_arguments_elements, Rule::arguments)?;\n    let parsed_arguments = ARGUMENTS_PARSER.parse_arguments(arguments)?;\n    Ok(Some(ExecuteArguments {\n        nonstandard_delimiter: parsed_execute_argument_delimiter,\n        arguments: parsed_arguments,\n    }))\n"]], "pred": {"ppl": 2.2356717586517334, "ppl_lower": 2.883861541748047, "ppl/lowercase_ppl": -1.3164390963596007, "ppl/zlib": 0.0030475066138659613, "Min_5.0% Prob": 8.558973026275634, "Min_10.0% Prob": 6.174284541606903, "Min_20.0% Prob": 3.7463853374123572, "Min_30.0% Prob": 2.6209018933276336, "Min_40.0% Prob": 2.006852900236845, "Min_50.0% Prob": 1.6030593632102603, "Min_60.0% Prob": 1.3421112951122163}}
{"hexsha": "94076d324b7a312413af2bf95e86ece18511af88", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), pa::Error> {\n    println!(\"blocking sine wave\");\n    println!(\n        \"sample_rate: {}, msecs: {}, freq: {}\",\n        SAMPLE_RATE, MSECS, FREQ\n    );\n    println!(\"buffer size: {}, buffers: {}\", BUFFER_SIZE, BUFFERS);\n    println!(\n        \"last buffer nominal size: {}\",\n        BUFFER_SIZE * (BUFFERS + 1) - FRAMES\n    );\n\n    // Set up the stream.\n    let pa = pa::PortAudio::new()?;\n    let settings = pa.default_output_stream_settings(\n        1, // 1 channel\n        SAMPLE_RATE as f64,\n        BUFFER_SIZE as u32,\n    )?;\n    let mut stream = pa.open_blocking_stream(settings)?;\n    stream.start()?;\n\n    // State for the sine generator.\n    let mut angle: f32 = 0.0;\n\n    // Bump the state forward by the given number of frames.\n    let advance_state = |angle: &mut f32, advance| {\n        *angle += advance as f32 * 2.0 * PI * FREQ / SAMPLE_RATE;\n        while *angle >= 2.0 * PI {\n            *angle -= 2.0 * PI;\n        }\n        assert!(*angle >= 0.0 && *angle < 2.0 * PI);\n    };\n\n    // Write all the frames.\n    let mut written = 0;\n    while written < FRAMES {\n        let status = stream.write(BUFFER_SIZE as u32, |buffer| {\n            assert_eq!(buffer.len(), BUFFER_SIZE);\n            for sample in buffer.iter_mut() {\n                *sample = 0.8 * angle.sin();\n                advance_state(&mut angle, 1);\n            }\n        });\n\n        // On underflow, do not panic, but skip ahead to the\n        // next buffer.\n        match status {\n            Ok(_) => (),\n            Err(pa::Error::OutputUnderflowed) => {\n                eprintln!(\"underflow: written = {}\", written);\n                advance_state(&mut angle, BUFFER_SIZE);\n            }\n            _ => {\n                status?;\n            }\n        }\n\n        // Advance to next buffer.\n        written += BUFFER_SIZE;\n    }\n\n    // Tear down the stream.\n    stream.stop()?;\n    stream.close()?;\n    Ok(())\n}", "item_id": 0, "repo": "BartMassey/portaudio-rs-demos", "file": "src/bsine.rs", "last_update_at": "2020-05-11T06:31:34+00:00", "question_id": "94076d324b7a312413af2bf95e86ece18511af88_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), pa::Error> {\n    println!(\"blocking sine wave\");\n    println!(\n        \"sample_rate: {}, msecs: {}, freq: {}\",\n        SAMPLE_RATE, MSECS, FREQ\n    );\n    println!(\"buffer size: {}, buffers: {}\", BUFFER_SIZE, BUFFERS);\n    println!(\n        \"last buffer nominal size: {}\",\n        BUFFER_SIZE * (BUFFERS + 1) - FRAMES\n    );\n    // Set up the stream.\n    let pa = pa::PortAudio::new()?;\n    let settings = pa.default_output_stream_settings(\n        1, // 1 channel\n        SAMPLE_RATE as f64,\n        BUFFER_SIZE as u32,\n    )?;\n    let mut stream = pa.open_blocking_stream(settings)?;\n    stream.start()?;\n    // State for the sine generator.\n    let mut angle: f32 = 0.0;\n    // Bump the state forward by the given number of frames.\n    let advance_state = |angle: &mut f32, advance| {\n        *angle += advance as f32 * 2.0 * PI * FREQ / SAMPLE_RATE;\n        while *angle >= 2.0 * PI {\n            *angle -= 2.0 * PI;\n        }\n        assert!(*angle >= 0.0 && *angle < 2.0 * PI);\n    };\n    // Write all the frames.\n    let mut written = 0;\n    while written < FRAMES {\n        let status = stream.write(BUFFER_SIZE as u32, |buffer| {\n            assert_eq!(buffer.len(), BUFFER_SIZE);\n            for sample in buffer.iter_mut() {\n                *sample = 0.8 * angle.sin();\n                advance_state(&mut angle, 1);\n            }\n        });\n        // On underflow, do not panic, but skip ahead to the\n        // next buffer.\n        match status {\n            Ok(_) => (),\n            Err(pa::Error::OutputUnderflowed) => {\n                eprintln!(\"underflow: written = {}\", written);\n                advance_state(&mut angle, BUFFER_SIZE);\n            }\n            _ => {\n                status?;\n            }\n        }\n        // Advance to next buffer.\n        written += BUFFER_SIZE;\n    }\n    // Tear down the stream.\n    stream.stop()?;\n    stream.close()?;\n    Ok(())\n"]], "pred": {"ppl": 2.1150424480438232, "ppl_lower": 2.4347167015075684, "ppl/lowercase_ppl": -1.1879058108195903, "ppl/zlib": 0.0009566729020356592, "Min_5.0% Prob": 6.441697463393211, "Min_10.0% Prob": 4.82801128923893, "Min_20.0% Prob": 3.207600683439523, "Min_30.0% Prob": 2.3770810342393816, "Min_40.0% Prob": 1.8448269516811706, "Min_50.0% Prob": 1.4927507112501188, "Min_60.0% Prob": 1.2487432885027374}}
{"hexsha": "541258c0504077e7afd0314195800180a60c4cb2", "ext": "rs", "lang": "Rust", "content": "async fn run(event_loop: EventLoop<()>, window: Window) {\n    let surface = Surface::create(&window);\n    let adapter = Adapter::request(\n        &RequestAdapterOptions {\n            power_preference: PowerPreference::Default,\n            compatible_surface: Some(&surface),\n        },\n        BackendBit::PRIMARY,\n    )\n    .await\n    .unwrap();\n    let (device, queue) = adapter\n        .request_device(&DeviceDescriptor {\n            extensions: Extensions {\n                anisotropic_filtering: false,\n            },\n            limits: Limits::default(),\n        })\n        .await;\n    let mut screen_size = window.inner_size();\n\n    let mut swap_chain_descriptor = SwapChainDescriptor {\n        usage: TextureUsage::OUTPUT_ATTACHMENT,\n        format: TextureFormat::Bgra8Unorm,\n        width: screen_size.width,\n        height: screen_size.height,\n        present_mode: PresentMode::Mailbox,\n    };\n    let mut swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);\n\n    let mut msaa_texture_descriptor = TextureDescriptor {\n        size: Extent3d {\n            width: screen_size.width,\n            height: screen_size.height,\n            depth: 1,\n        },\n        array_layer_count: 1,\n        mip_level_count: 1,\n        sample_count: 16,\n        dimension: TextureDimension::D2,\n        format: swap_chain_descriptor.format,\n        usage: TextureUsage::OUTPUT_ATTACHMENT,\n        label: None,\n    };\n    let mut msaa_texture = device\n        .create_texture(&msaa_texture_descriptor)\n        .create_default_view();\n\n    let vertex_shader = include_bytes!(\"../metaballs_vert.spv\");\n    let vertex_shader = read_spirv(Cursor::new(&vertex_shader[..])).unwrap();\n    let vertex_shader = device.create_shader_module(&vertex_shader);\n\n    let fragment_shader = include_bytes!(\"../metaballs_frag.spv\");\n    let fragment_shader = read_spirv(Cursor::new(&fragment_shader[..])).unwrap();\n    let fragment_shader = device.create_shader_module(&fragment_shader);\n\n    let time = Instant::now();\n    let mut time_uniform = TimeUniform {\n        time: time.elapsed().as_secs_f32(),\n    };\n    let time_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[time_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n\n    let mut zoom_uniform = ZoomUniform { zoom: 1.0 };\n    let zoom_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[zoom_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n\n    let mut screen_size_uniform = ScreenSizeUniform {\n        screen_size: [screen_size.width as f32, screen_size.height as f32],\n    };\n    let screen_size_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[screen_size_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n\n    let bind_group_layout = device.create_bind_group_layout(&BindGroupLayoutDescriptor {\n        bindings: &[\n            BindGroupLayoutEntry {\n                binding: 0,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n            BindGroupLayoutEntry {\n                binding: 1,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n            BindGroupLayoutEntry {\n                binding: 2,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n        ],\n        label: None,\n    });\n    let bind_group = device.create_bind_group(&BindGroupDescriptor {\n        layout: &bind_group_layout,\n        bindings: &[\n            Binding {\n                binding: 0,\n                resource: BindingResource::Buffer {\n                    buffer: &time_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&time_uniform) as BufferAddress,\n                },\n            },\n            Binding {\n                binding: 1,\n                resource: BindingResource::Buffer {\n                    buffer: &zoom_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&zoom_uniform) as BufferAddress,\n                },\n            },\n            Binding {\n                binding: 2,\n                resource: BindingResource::Buffer {\n                    buffer: &screen_size_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&screen_size_uniform) as BufferAddress,\n                },\n            },\n        ],\n        label: None,\n    });\n\n    let pipeline_layout = device.create_pipeline_layout(&PipelineLayoutDescriptor {\n        bind_group_layouts: &[&bind_group_layout],\n    });\n    let pipeline = device.create_render_pipeline(&RenderPipelineDescriptor {\n        layout: &pipeline_layout,\n        vertex_stage: ProgrammableStageDescriptor {\n            module: &vertex_shader,\n            entry_point: \"main\",\n        },\n        fragment_stage: Some(ProgrammableStageDescriptor {\n            module: &fragment_shader,\n            entry_point: \"main\",\n        }),\n        rasterization_state: Some(RasterizationStateDescriptor {\n            front_face: FrontFace::Ccw,\n            cull_mode: CullMode::None,\n            depth_bias: 0,\n            depth_bias_slope_scale: 0.0,\n            depth_bias_clamp: 0.0,\n        }),\n        primitive_topology: PrimitiveTopology::TriangleList,\n        color_states: &[ColorStateDescriptor {\n            format: swap_chain_descriptor.format,\n            color_blend: BlendDescriptor::REPLACE,\n            alpha_blend: BlendDescriptor::REPLACE,\n            write_mask: ColorWrite::ALL,\n        }],\n        depth_stencil_state: None,\n        vertex_state: VertexStateDescriptor {\n            index_format: IndexFormat::Uint16,\n            vertex_buffers: &[],\n        },\n        sample_count: msaa_texture_descriptor.sample_count,\n        sample_mask: !0,\n        alpha_to_coverage_enabled: false,\n    });\n\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Poll;\n        match event {\n            Event::MainEventsCleared => window.request_redraw(),\n            Event::WindowEvent {\n                event: WindowEvent::Resized(new_size),\n                ..\n            } => {\n                screen_size = new_size;\n\n                swap_chain_descriptor.width = screen_size.width;\n                swap_chain_descriptor.height = screen_size.height;\n                swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);\n\n                msaa_texture_descriptor.size = Extent3d {\n                    width: screen_size.width,\n                    height: screen_size.height,\n                    depth: 1,\n                };\n                msaa_texture = device\n                    .create_texture(&msaa_texture_descriptor)\n                    .create_default_view();\n\n                let mut encoder =\n                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });\n                screen_size_uniform.screen_size =\n                    [screen_size.width as f32, screen_size.height as f32];\n                let staging_buffer = device.create_buffer_with_data(\n                    bytemuck::cast_slice(&[screen_size_uniform]),\n                    BufferUsage::COPY_SRC,\n                );\n                encoder.copy_buffer_to_buffer(\n                    &staging_buffer,\n                    0,\n                    &screen_size_uniform_buffer,\n                    0,\n                    std::mem::size_of::<ScreenSizeUniform>() as BufferAddress,\n                );\n                queue.submit(&[encoder.finish()]);\n            }\n            Event::RedrawRequested(_) => {\n                let display_texture = &swap_chain.get_next_texture().unwrap().view;\n                let mut encoder =\n                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });\n                {\n                    time_uniform.time = time.elapsed().as_secs_f32();\n                    let staging_buffer = device.create_buffer_with_data(\n                        bytemuck::cast_slice(&[time_uniform]),\n                        BufferUsage::COPY_SRC,\n                    );\n                    encoder.copy_buffer_to_buffer(\n                        &staging_buffer,\n                        0,\n                        &time_uniform_buffer,\n                        0,\n                        std::mem::size_of::<TimeUniform>() as BufferAddress,\n                    );\n\n                    let mut render_pass = encoder.begin_render_pass(&RenderPassDescriptor {\n                        color_attachments: &[RenderPassColorAttachmentDescriptor {\n                            attachment: &msaa_texture,\n                            resolve_target: Some(display_texture),\n                            load_op: LoadOp::Clear,\n                            store_op: StoreOp::Store,\n                            clear_color: Color::BLACK,\n                        }],\n                        depth_stencil_attachment: None,\n                    });\n                    render_pass.set_bind_group(0, &bind_group, &[]);\n                    render_pass.set_pipeline(&pipeline);\n                    render_pass.draw(0..6, 0..1);\n                }\n                queue.submit(&[encoder.finish()]);\n            }\n            Event::WindowEvent { event, .. } => match event {\n                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,\n                WindowEvent::KeyboardInput { input, .. } => {\n                    if input.state == ElementState::Pressed {\n                        match input.virtual_keycode {\n                            Some(VirtualKeyCode::Equals) => {\n                                zoom_uniform.zoom *= 2.0;\n                                let mut encoder =\n                                    device.create_command_encoder(&CommandEncoderDescriptor {\n                                        label: None,\n                                    });\n                                let staging_buffer = device.create_buffer_with_data(\n                                    bytemuck::cast_slice(&[zoom_uniform]),\n                                    BufferUsage::COPY_SRC,\n                                );\n                                encoder.copy_buffer_to_buffer(\n                                    &staging_buffer,\n                                    0,\n                                    &zoom_uniform_buffer,\n                                    0,\n                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,\n                                );\n                                queue.submit(&[encoder.finish()]);\n                            }\n                            Some(VirtualKeyCode::Minus) => {\n                                zoom_uniform.zoom /= 2.0;\n                                if zoom_uniform.zoom < 1.0 {\n                                    zoom_uniform.zoom = 1.0;\n                                }\n                                let mut encoder =\n                                    device.create_command_encoder(&CommandEncoderDescriptor {\n                                        label: None,\n                                    });\n                                let staging_buffer = device.create_buffer_with_data(\n                                    bytemuck::cast_slice(&[zoom_uniform]),\n                                    BufferUsage::COPY_SRC,\n                                );\n                                encoder.copy_buffer_to_buffer(\n                                    &staging_buffer,\n                                    0,\n                                    &zoom_uniform_buffer,\n                                    0,\n                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,\n                                );\n                                queue.submit(&[encoder.finish()]);\n                            }\n                            _ => {}\n                        }\n                    }\n                }\n                _ => {}\n            },\n            _ => {}\n        }\n    });\n}", "item_id": 1, "repo": "JMS55/metaballs", "file": "src/main.rs", "last_update_at": "2020-12-29T23:10:22+00:00", "question_id": "541258c0504077e7afd0314195800180a60c4cb2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn run(event_loop: EventLoop<()>, window: Window) {\n    let surface = Surface::create(&window);\n    let adapter = Adapter::request(\n        &RequestAdapterOptions {\n            power_preference: PowerPreference::Default,\n            compatible_surface: Some(&surface),\n        },\n        BackendBit::PRIMARY,\n    )\n    .await\n    .unwrap();\n    let (device, queue) = adapter\n        .request_device(&DeviceDescriptor {\n            extensions: Extensions {\n                anisotropic_filtering: false,\n            },\n            limits: Limits::default(),\n        })\n        .await;\n    let mut screen_size = window.inner_size();\n    let mut swap_chain_descriptor = SwapChainDescriptor {\n        usage: TextureUsage::OUTPUT_ATTACHMENT,\n        format: TextureFormat::Bgra8Unorm,\n        width: screen_size.width,\n        height: screen_size.height,\n        present_mode: PresentMode::Mailbox,\n    };\n    let mut swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);\n    let mut msaa_texture_descriptor = TextureDescriptor {\n        size: Extent3d {\n            width: screen_size.width,\n            height: screen_size.height,\n            depth: 1,\n        },\n        array_layer_count: 1,\n        mip_level_count: 1,\n        sample_count: 16,\n        dimension: TextureDimension::D2,\n        format: swap_chain_descriptor.format,\n        usage: TextureUsage::OUTPUT_ATTACHMENT,\n        label: None,\n    };\n    let mut msaa_texture = device\n        .create_texture(&msaa_texture_descriptor)\n        .create_default_view();\n    let vertex_shader = include_bytes!(\"../metaballs_vert.spv\");\n    let vertex_shader = read_spirv(Cursor::new(&vertex_shader[..])).unwrap();\n    let vertex_shader = device.create_shader_module(&vertex_shader);\n    let fragment_shader = include_bytes!(\"../metaballs_frag.spv\");\n    let fragment_shader = read_spirv(Cursor::new(&fragment_shader[..])).unwrap();\n    let fragment_shader = device.create_shader_module(&fragment_shader);\n    let time = Instant::now();\n    let mut time_uniform = TimeUniform {\n        time: time.elapsed().as_secs_f32(),\n    };\n    let time_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[time_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n    let mut zoom_uniform = ZoomUniform { zoom: 1.0 };\n    let zoom_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[zoom_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n    let mut screen_size_uniform = ScreenSizeUniform {\n        screen_size: [screen_size.width as f32, screen_size.height as f32],\n    };\n    let screen_size_uniform_buffer = device.create_buffer_with_data(\n        bytemuck::cast_slice(&[screen_size_uniform]),\n        BufferUsage::UNIFORM | BufferUsage::COPY_DST,\n    );\n    let bind_group_layout = device.create_bind_group_layout(&BindGroupLayoutDescriptor {\n        bindings: &[\n            BindGroupLayoutEntry {\n                binding: 0,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n            BindGroupLayoutEntry {\n                binding: 1,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n            BindGroupLayoutEntry {\n                binding: 2,\n                visibility: ShaderStage::FRAGMENT,\n                ty: BindingType::UniformBuffer { dynamic: false },\n            },\n        ],\n        label: None,\n    });\n    let bind_group = device.create_bind_group(&BindGroupDescriptor {\n        layout: &bind_group_layout,\n        bindings: &[\n            Binding {\n                binding: 0,\n                resource: BindingResource::Buffer {\n                    buffer: &time_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&time_uniform) as BufferAddress,\n                },\n            },\n            Binding {\n                binding: 1,\n                resource: BindingResource::Buffer {\n                    buffer: &zoom_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&zoom_uniform) as BufferAddress,\n                },\n            },\n            Binding {\n                binding: 2,\n                resource: BindingResource::Buffer {\n                    buffer: &screen_size_uniform_buffer,\n                    range: 0..std::mem::size_of_val(&screen_size_uniform) as BufferAddress,\n                },\n            },\n        ],\n        label: None,\n    });\n    let pipeline_layout = device.create_pipeline_layout(&PipelineLayoutDescriptor {\n        bind_group_layouts: &[&bind_group_layout],\n    });\n    let pipeline = device.create_render_pipeline(&RenderPipelineDescriptor {\n        layout: &pipeline_layout,\n        vertex_stage: ProgrammableStageDescriptor {\n            module: &vertex_shader,\n            entry_point: \"main\",\n        },\n        fragment_stage: Some(ProgrammableStageDescriptor {\n            module: &fragment_shader,\n            entry_point: \"main\",\n        }),\n        rasterization_state: Some(RasterizationStateDescriptor {\n            front_face: FrontFace::Ccw,\n            cull_mode: CullMode::None,\n            depth_bias: 0,\n            depth_bias_slope_scale: 0.0,\n            depth_bias_clamp: 0.0,\n        }),\n        primitive_topology: PrimitiveTopology::TriangleList,\n        color_states: &[ColorStateDescriptor {\n            format: swap_chain_descriptor.format,\n            color_blend: BlendDescriptor::REPLACE,\n            alpha_blend: BlendDescriptor::REPLACE,\n            write_mask: ColorWrite::ALL,\n        }],\n        depth_stencil_state: None,\n        vertex_state: VertexStateDescriptor {\n            index_format: IndexFormat::Uint16,\n            vertex_buffers: &[],\n        },\n        sample_count: msaa_texture_descriptor.sample_count,\n        sample_mask: !0,\n        alpha_to_coverage_enabled: false,\n    });\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Poll;\n        match event {\n            Event::MainEventsCleared => window.request_redraw(),\n            Event::WindowEvent {\n                event: WindowEvent::Resized(new_size),\n                ..\n            } => {\n                screen_size = new_size;\n                swap_chain_descriptor.width = screen_size.width;\n                swap_chain_descriptor.height = screen_size.height;\n                swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);\n                msaa_texture_descriptor.size = Extent3d {\n                    width: screen_size.width,\n                    height: screen_size.height,\n                    depth: 1,\n                };\n                msaa_texture = device\n                    .create_texture(&msaa_texture_descriptor)\n                    .create_default_view();\n                let mut encoder =\n                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });\n                screen_size_uniform.screen_size =\n                    [screen_size.width as f32, screen_size.height as f32];\n                let staging_buffer = device.create_buffer_with_data(\n                    bytemuck::cast_slice(&[screen_size_uniform]),\n                    BufferUsage::COPY_SRC,\n                );\n                encoder.copy_buffer_to_buffer(\n                    &staging_buffer,\n                    0,\n                    &screen_size_uniform_buffer,\n                    0,\n                    std::mem::size_of::<ScreenSizeUniform>() as BufferAddress,\n                );\n                queue.submit(&[encoder.finish()]);\n            }\n            Event::RedrawRequested(_) => {\n                let display_texture = &swap_chain.get_next_texture().unwrap().view;\n                let mut encoder =\n                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });\n                {\n                    time_uniform.time = time.elapsed().as_secs_f32();\n                    let staging_buffer = device.create_buffer_with_data(\n                        bytemuck::cast_slice(&[time_uniform]),\n                        BufferUsage::COPY_SRC,\n                    );\n                    encoder.copy_buffer_to_buffer(\n                        &staging_buffer,\n                        0,\n                        &time_uniform_buffer,\n                        0,\n                        std::mem::size_of::<TimeUniform>() as BufferAddress,\n                    );\n                    let mut render_pass = encoder.begin_render_pass(&RenderPassDescriptor {\n                        color_attachments: &[RenderPassColorAttachmentDescriptor {\n                            attachment: &msaa_texture,\n                            resolve_target: Some(display_texture),\n                            load_op: LoadOp::Clear,\n                            store_op: StoreOp::Store,\n                            clear_color: Color::BLACK,\n                        }],\n                        depth_stencil_attachment: None,\n                    });\n                    render_pass.set_bind_group(0, &bind_group, &[]);\n                    render_pass.set_pipeline(&pipeline);\n                    render_pass.draw(0..6, 0..1);\n                }\n                queue.submit(&[encoder.finish()]);\n            }\n            Event::WindowEvent { event, .. } => match event {\n                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,\n                WindowEvent::KeyboardInput { input, .. } => {\n                    if input.state == ElementState::Pressed {\n                        match input.virtual_keycode {\n                            Some(VirtualKeyCode::Equals) => {\n                                zoom_uniform.zoom *= 2.0;\n                                let mut encoder =\n                                    device.create_command_encoder(&CommandEncoderDescriptor {\n                                        label: None,\n                                    });\n                                let staging_buffer = device.create_buffer_with_data(\n                                    bytemuck::cast_slice(&[zoom_uniform]),\n                                    BufferUsage::COPY_SRC,\n                                );\n                                encoder.copy_buffer_to_buffer(\n                                    &staging_buffer,\n                                    0,\n                                    &zoom_uniform_buffer,\n                                    0,\n                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,\n                                );\n                                queue.submit(&[encoder.finish()]);\n                            }\n                            Some(VirtualKeyCode::Minus) => {\n                                zoom_uniform.zoom /= 2.0;\n                                if zoom_uniform.zoom < 1.0 {\n                                    zoom_uniform.zoom = 1.0;\n                                }\n                                let mut encoder =\n                                    device.create_command_encoder(&CommandEncoderDescriptor {\n                                        label: None,\n                                    });\n                                let staging_buffer = device.create_buffer_with_data(\n                                    bytemuck::cast_slice(&[zoom_uniform]),\n                                    BufferUsage::COPY_SRC,\n                                );\n                                encoder.copy_buffer_to_buffer(\n                                    &staging_buffer,\n                                    0,\n                                    &zoom_uniform_buffer,\n                                    0,\n                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,\n                                );\n                                queue.submit(&[encoder.finish()]);\n                            }\n                            _ => {}\n                        }\n                    }\n                }\n                _ => {}\n            },\n            _ => {}\n        }\n    });\n"]], "pred": {"ppl": 1.3641612529754639, "ppl_lower": 1.5491468906402588, "ppl/lowercase_ppl": -1.4094954147683958, "ppl/zlib": 0.00012675092779194192, "Min_5.0% Prob": 4.146080561712677, "Min_10.0% Prob": 2.650577562112434, "Min_20.0% Prob": 1.5107338950037956, "Min_30.0% Prob": 1.0317817617548641, "Min_40.0% Prob": 0.7756581582711932, "Min_50.0% Prob": 0.6214597178764327, "Min_60.0% Prob": 0.5181873371507661}}
{"hexsha": "f9ad4795b3816d5f10ab42dfdc78b7a3de427600", "ext": "rs", "lang": "Rust", "content": "pub fn establish_connection() -> PgConnection {\n    dotenv().ok();\n\n    let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    PgConnection::establish(&database_url).expect(&format!(\"Error connecting to {}\", database_url))\n}", "item_id": 0, "repo": "N-of-1/meme-quicksilver", "file": "src/database.rs", "last_update_at": "2020-01-18T11:37:12+00:00", "question_id": "f9ad4795b3816d5f10ab42dfdc78b7a3de427600_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn establish_connection() -> PgConnection {\n    dotenv().ok();\n    let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    PgConnection::establish(&database_url).expect(&format!(\"Error connecting to {}\", database_url))\n"]], "pred": {"ppl": 1.6593033075332642, "ppl_lower": 3.1099984645843506, "ppl/lowercase_ppl": -2.240574875410034, "ppl/zlib": 0.002927155028989003, "Min_5.0% Prob": 10.138190269470215, "Min_10.0% Prob": 4.8845299397196085, "Min_20.0% Prob": 2.590873611824853, "Min_30.0% Prob": 1.68735402145169, "Min_40.0% Prob": 1.2879247009625723, "Min_50.0% Prob": 1.011383266490255, "Min_60.0% Prob": 0.8510936329681003}}
{"hexsha": "05860734373d40c5d5847bede6857e2a4dd82493", "ext": "rs", "lang": "Rust", "content": "fn one_plus_one_v2() {\n        let engine = RebEngine::new();\n        let one = engine.integer(1);\n        let two = engine.value3(&one, &CUtf8::new(\"+\"), &one);\n        assert_eq!(2, two.unbox_integer());\n    }", "item_id": 3, "repo": "zsx/renc-rs", "file": "src/lib.rs", "last_update_at": "2020-03-18T21:48:36+00:00", "question_id": "05860734373d40c5d5847bede6857e2a4dd82493_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn one_plus_one_v2() {\n        let engine = RebEngine::new();\n        let one = engine.integer(1);\n        let two = engine.value3(&one, &CUtf8::new(\"+\"), &one);\n        assert_eq!(2, two.unbox_integer());\n"]], "pred": {"ppl": 6.165838241577148, "ppl_lower": 7.3098626136779785, "ppl/lowercase_ppl": -1.093566866183169, "ppl/zlib": 0.01299302925134389, "Min_5.0% Prob": 10.13660971323649, "Min_10.0% Prob": 9.086515562874931, "Min_20.0% Prob": 7.025386985143026, "Min_30.0% Prob": 5.5465059930628, "Min_40.0% Prob": 4.291541425387065, "Min_50.0% Prob": 3.569799718824593, "Min_60.0% Prob": 2.985720874534713}}
{"hexsha": "bdbb1559e3345747dd5df3cab78aa3ddf706f28a", "ext": "rs", "lang": "Rust", "content": "async fn fetch(url: &str) -> Result<JsValue, JsValue> {\n    let window = web_sys::window().expect(\"window should exist\");\n    let resp = JsFuture::from(window.fetch_with_str(url)).await?;\n    let resp: Response = resp.dyn_into().expect(\"failed to convert response\");\n\n    JsFuture::from(resp.text()?).await\n}", "item_id": 0, "repo": "bs-community/blessing-skin-shell", "file": "src/programs/curl.rs", "last_update_at": "2020-04-01T12:16:56+00:00", "question_id": "bdbb1559e3345747dd5df3cab78aa3ddf706f28a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn fetch(url: &str) -> Result<JsValue, JsValue> {\n    let window = web_sys::window().expect(\"window should exist\");\n    let resp = JsFuture::from(window.fetch_with_str(url)).await?;\n    let resp: Response = resp.dyn_into().expect(\"failed to convert response\");\n    JsFuture::from(resp.text()?).await\n"]], "pred": {"ppl": 2.089902877807617, "ppl_lower": 3.6604983806610107, "ppl/lowercase_ppl": -1.7603694669821277, "ppl/zlib": 0.0036133215438649492, "Min_5.0% Prob": 7.3711957931518555, "Min_10.0% Prob": 5.324665546417236, "Min_20.0% Prob": 3.2378910332918167, "Min_30.0% Prob": 2.3448037485281628, "Min_40.0% Prob": 1.8114491928368808, "Min_50.0% Prob": 1.466073777973652, "Min_60.0% Prob": 1.2266362893084686}}
{"hexsha": "34b345b5688d6ed0d6f0732c4efadb7e3f764f3e", "ext": "rs", "lang": "Rust", "content": "fn test_fq() {\n    use crate::fields::tests::*;\n\n    field_test::<_, Fq, FqGadget>();\n    frobenius_tests::<Fq, Fq, FqGadget>(13);\n    equ_verdict_fp_gadget_test::<Fq>();\n    even_odd_fp_gadget_test::<Fq>();\n    from_bits_fp_gadget_test::<Fq>();\n    bit_fp_gadgets_test::<Fq>();\n}", "item_id": 0, "repo": "ZencashOfficial/zexe", "file": "r1cs/gadgets/std/src/instantiated/tweedle/fields.rs", "last_update_at": "2020-07-09T16:26:31+00:00", "question_id": "34b345b5688d6ed0d6f0732c4efadb7e3f764f3e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_fq() {\n    use crate::fields::tests::*;\n    field_test::<_, Fq, FqGadget>();\n    frobenius_tests::<Fq, Fq, FqGadget>(13);\n    equ_verdict_fp_gadget_test::<Fq>();\n    even_odd_fp_gadget_test::<Fq>();\n    from_bits_fp_gadget_test::<Fq>();\n    bit_fp_gadgets_test::<Fq>();\n"]], "pred": {"ppl": 3.2214510440826416, "ppl_lower": 3.3542191982269287, "ppl/lowercase_ppl": -1.034523868706626, "ppl/zlib": 0.007904269546346073, "Min_5.0% Prob": 7.854055484135945, "Min_10.0% Prob": 6.373019768641545, "Min_20.0% Prob": 4.9272171809123115, "Min_30.0% Prob": 3.7007916525006292, "Min_40.0% Prob": 2.901533212864174, "Min_50.0% Prob": 2.327696324729208, "Min_60.0% Prob": 1.9566682775039226}}
{"hexsha": "020612929287927557a65376d349b8788eb72c48", "ext": "rs", "lang": "Rust", "content": "fn extract_source(out_dir_path: &Path, version: &str) -> String {\n    let archive_dir_path = out_dir_path.join(\"archive\");\n    if !archive_dir_path.exists() {\n        std::fs::create_dir(&archive_dir_path)\n            .expect(&format!(\"Failed to create {:?}\", archive_dir_path));\n    }\n\n    let archive_file_path = archive_dir_path.join(format!(\"openh264-{}.tar.gz\", version));\n    if !archive_file_path.exists() {\n        let url = format!(\n            \"https://github.com/cisco/openh264/archive/v{}.tar.gz\",\n            version\n        );\n        let mut response = reqwest::get(&url).expect(&format!(\"Failed to download {}\", url));\n        assert!(\n            response.status().is_success(),\n            format!(\"Request to {} doesn't succeed: {}\", url, response.status())\n        );\n        let mut file_buf = Vec::new();\n        response\n            .copy_to(&mut file_buf)\n            .expect(&format!(\"Failed to download {}\", url));\n        let mut file = File::create(&archive_file_path)\n            .expect(&format!(\"Failed to create {:?}\", archive_file_path));\n        file.write_all(&file_buf).expect(&format!(\n            \"Failed to save {} to {:?}\",\n            url, archive_file_path\n        ));\n    }\n\n    let mut archive_file =\n        File::open(&archive_file_path).expect(&format!(\"Failed to open {:?}\", archive_file_path));\n\n    let mut gzip_decoder = gzip::Decoder::new(&mut archive_file).expect(&format!(\n        \"Failed to create gzip decoder for {:?}\",\n        archive_file_path\n    ));\n    let mut tar_vec = Vec::new();\n    std::io::copy(&mut gzip_decoder, &mut tar_vec).expect(&format!(\n        \"Failed to extract gzip archive {:?}\",\n        archive_file_path\n    ));\n\n    let mut tar_archive = Archive::new(&tar_vec[..]);\n    let tar_extract_dir_path = out_dir_path.join(\"src\");\n    if tar_extract_dir_path.exists() {\n        std::fs::remove_dir_all(tar_extract_dir_path.clone()).expect(&format!(\n            \"Failed to remove old archive extraction dir: {:?}\",\n            tar_extract_dir_path.clone()\n        ));\n    }\n    for mut entry in tar_archive\n        .entries()\n        .expect(&format!(\n            \"Failed to read tar archive entries in {:?}\",\n            archive_file_path\n        ))\n        .map(|entry| {\n            entry.expect(&format!(\n                \"Failed to extract tar archive entry in {:?}\",\n                archive_file_path\n            ))\n        }) {\n        entry\n            .unpack_in(tar_extract_dir_path.clone())\n            .expect(&format!(\n                \"Failed to unpack file in {:?} for {:?}\",\n                archive_file_path,\n                entry.path()\n            ));\n    }\n\n    let openh264_src_dir_path = std::fs::read_dir(&tar_extract_dir_path)\n        .expect(&format!(\"Failed to read dir {:?}\", tar_extract_dir_path))\n        .map(|entry| {\n            entry.expect(&format!(\n                \"Failed to read dir entry in {:?}\",\n                tar_extract_dir_path\n            ))\n        })\n        .find(|entry| {\n            entry\n                .file_type()\n                .expect(&format!(\n                    \"Failed to read file type for {:?} in {:?}\",\n                    entry, tar_extract_dir_path\n                ))\n                .is_dir()\n        }).expect(\n            &format!(\"Failed to find openh264 extracted src path in {:?}, perhaps downloaded archive {:?} was broken.\",\n            tar_extract_dir_path, archive_file_path)\n        ).path();\n    openh264_src_dir_path\n        .to_str()\n        .expect(&format!(\n            \"Failed to extract rust string from {:?}\",\n            openh264_src_dir_path\n        ))\n        .to_string()\n}", "item_id": 1, "repo": "saturday06/effective-octo-fortnight", "file": "build.rs", "last_update_at": "2020-05-22T04:35:57+00:00", "question_id": "020612929287927557a65376d349b8788eb72c48_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn extract_source(out_dir_path: &Path, version: &str) -> String {\n    let archive_dir_path = out_dir_path.join(\"archive\");\n    if !archive_dir_path.exists() {\n        std::fs::create_dir(&archive_dir_path)\n            .expect(&format!(\"Failed to create {:?}\", archive_dir_path));\n    }\n    let archive_file_path = archive_dir_path.join(format!(\"openh264-{}.tar.gz\", version));\n    if !archive_file_path.exists() {\n        let url = format!(\n            \"https://github.com/cisco/openh264/archive/v{}.tar.gz\",\n            version\n        );\n        let mut response = reqwest::get(&url).expect(&format!(\"Failed to download {}\", url));\n        assert!(\n            response.status().is_success(),\n            format!(\"Request to {} doesn't succeed: {}\", url, response.status())\n        );\n        let mut file_buf = Vec::new();\n        response\n            .copy_to(&mut file_buf)\n            .expect(&format!(\"Failed to download {}\", url));\n        let mut file = File::create(&archive_file_path)\n            .expect(&format!(\"Failed to create {:?}\", archive_file_path));\n        file.write_all(&file_buf).expect(&format!(\n            \"Failed to save {} to {:?}\",\n            url, archive_file_path\n        ));\n    }\n    let mut archive_file =\n        File::open(&archive_file_path).expect(&format!(\"Failed to open {:?}\", archive_file_path));\n    let mut gzip_decoder = gzip::Decoder::new(&mut archive_file).expect(&format!(\n        \"Failed to create gzip decoder for {:?}\",\n        archive_file_path\n    ));\n    let mut tar_vec = Vec::new();\n    std::io::copy(&mut gzip_decoder, &mut tar_vec).expect(&format!(\n        \"Failed to extract gzip archive {:?}\",\n        archive_file_path\n    ));\n    let mut tar_archive = Archive::new(&tar_vec[..]);\n    let tar_extract_dir_path = out_dir_path.join(\"src\");\n    if tar_extract_dir_path.exists() {\n        std::fs::remove_dir_all(tar_extract_dir_path.clone()).expect(&format!(\n            \"Failed to remove old archive extraction dir: {:?}\",\n            tar_extract_dir_path.clone()\n        ));\n    }\n    for mut entry in tar_archive\n        .entries()\n        .expect(&format!(\n            \"Failed to read tar archive entries in {:?}\",\n            archive_file_path\n        ))\n        .map(|entry| {\n            entry.expect(&format!(\n                \"Failed to extract tar archive entry in {:?}\",\n                archive_file_path\n            ))\n        }) {\n        entry\n            .unpack_in(tar_extract_dir_path.clone())\n            .expect(&format!(\n                \"Failed to unpack file in {:?} for {:?}\",\n                archive_file_path,\n                entry.path()\n            ));\n    }\n    let openh264_src_dir_path = std::fs::read_dir(&tar_extract_dir_path)\n        .expect(&format!(\"Failed to read dir {:?}\", tar_extract_dir_path))\n        .map(|entry| {\n            entry.expect(&format!(\n                \"Failed to read dir entry in {:?}\",\n                tar_extract_dir_path\n            ))\n        })\n        .find(|entry| {\n            entry\n                .file_type()\n                .expect(&format!(\n                    \"Failed to read file type for {:?} in {:?}\",\n                    entry, tar_extract_dir_path\n                ))\n                .is_dir()\n        }).expect(\n            &format!(\"Failed to find openh264 extracted src path in {:?}, perhaps downloaded archive {:?} was broken.\",\n            tar_extract_dir_path, archive_file_path)\n        ).path();\n    openh264_src_dir_path\n        .to_str()\n        .expect(&format!(\n            \"Failed to extract rust string from {:?}\",\n            openh264_src_dir_path\n        ))\n        .to_string()\n"]], "pred": {"ppl": 1.6046664714813232, "ppl_lower": 1.697158932685852, "ppl/lowercase_ppl": -1.118498245577609, "ppl/zlib": 0.0005157207514249676, "Min_5.0% Prob": 5.13155821725434, "Min_10.0% Prob": 3.6144782082707274, "Min_20.0% Prob": 2.2169932091937348, "Min_30.0% Prob": 1.5541991312665489, "Min_40.0% Prob": 1.1781324953851826, "Min_50.0% Prob": 0.9458642974350083, "Min_60.0% Prob": 0.7890624516492795}}
{"hexsha": "231a609c136c60aaef94ec0274a5df7acb8cffbb", "ext": "rs", "lang": "Rust", "content": "fn test_oldest_free() {\n        use super::VoiceArray;\n        let mut voices = VoiceArray::new(vec![1,2]);\n        let v1 = voices.note_on(1).clone();\n        let v2 = voices.note_on(2).clone();\n\n        voices.note_off(1);\n        voices.note_off(2);\n        let v3 = voices.note_on(3).clone();\n        assert_eq!(v3, v1);\n\n        voices.note_off(3);\n        let v4 = voices.note_on(4).clone();\n        assert_eq!(v4, v2);\n    }", "item_id": 2, "repo": "oxcable/oxcable", "file": "src/voice_array.rs", "last_update_at": "2020-11-06T10:53:37+00:00", "question_id": "231a609c136c60aaef94ec0274a5df7acb8cffbb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_oldest_free() {\n        use super::VoiceArray;\n        let mut voices = VoiceArray::new(vec![1,2]);\n        let v1 = voices.note_on(1).clone();\n        let v2 = voices.note_on(2).clone();\n        voices.note_off(1);\n        voices.note_off(2);\n        let v3 = voices.note_on(3).clone();\n        assert_eq!(v3, v1);\n        voices.note_off(3);\n        let v4 = voices.note_on(4).clone();\n        assert_eq!(v4, v2);\n"]], "pred": {"ppl": 2.2614755630493164, "ppl_lower": 2.4553239345550537, "ppl/lowercase_ppl": -1.1007836189515354, "ppl/zlib": 0.004636463092268331, "Min_5.0% Prob": 7.855692028999329, "Min_10.0% Prob": 5.590973764657974, "Min_20.0% Prob": 3.5588985942304134, "Min_30.0% Prob": 2.5729902517050505, "Min_40.0% Prob": 2.0001290589571, "Min_50.0% Prob": 1.6206421594135463, "Min_60.0% Prob": 1.3568754567531869}}
{"hexsha": "bc94764c8105cd5f7283f593f2741e4a2b0d7150", "ext": "rs", "lang": "Rust", "content": "fn solver_017_test() {\n    assert_eq!(Solver017::default().solve(), 21124);\n\n    assert_eq!(Solver017 { n: 5 }.solve(), 19);\n    assert_eq!(Solver017 { n: 19 }.solve(), 106);\n    assert_eq!(Solver017 { n: 19999 }.solve(), 737203);\n\n    // for a more comprehensive set of tests on the algorithm, check the java version\n}", "item_id": 16, "repo": "barreiro/euler", "file": "src/main/rust/euler/solver_test.rs", "last_update_at": "2020-11-28T18:51:23+00:00", "question_id": "bc94764c8105cd5f7283f593f2741e4a2b0d7150_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn solver_017_test() {\n    assert_eq!(Solver017::default().solve(), 21124);\n    assert_eq!(Solver017 { n: 5 }.solve(), 19);\n    assert_eq!(Solver017 { n: 19 }.solve(), 106);\n    assert_eq!(Solver017 { n: 19999 }.solve(), 737203);\n    // for a more comprehensive set of tests on the algorithm, check the java version\n"]], "pred": {"ppl": 3.386002779006958, "ppl_lower": 3.6554198265075684, "ppl/lowercase_ppl": -1.0627727948326031, "ppl/zlib": 0.007009483358879824, "Min_5.0% Prob": 7.199512890407017, "Min_10.0% Prob": 5.785975132669721, "Min_20.0% Prob": 4.3878964100565225, "Min_30.0% Prob": 3.591287070796603, "Min_40.0% Prob": 2.933777442103938, "Min_50.0% Prob": 2.437735480112089, "Min_60.0% Prob": 2.0493958365391283}}
{"hexsha": "9dd3103e46981a906d29bb4d37bd6b406cd472e8", "ext": "rs", "lang": "Rust", "content": "pub fn evaluate_blake2s<ConstraintF: PrimeField>(\n    input: &[Boolean<ConstraintF>],\n) -> Result<Vec<UInt32<ConstraintF>>, SynthesisError> {\n    assert!(input.len() % 8 == 0);\n    let mut parameters = [0; 8];\n    parameters[0] = 0x01010000 ^ 32;\n    evaluate_blake2s_with_parameters(input, &parameters)\n}", "item_id": 2, "repo": "weikengchen/new_zexe_for_documentation_search", "file": "crypto-primitives/src/prf/blake2s/constraints.rs", "last_update_at": "2020-08-25T01:13:37+00:00", "question_id": "9dd3103e46981a906d29bb4d37bd6b406cd472e8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn evaluate_blake2s<ConstraintF: PrimeField>(\n    input: &[Boolean<ConstraintF>],\n) -> Result<Vec<UInt32<ConstraintF>>, SynthesisError> {\n    assert!(input.len() % 8 == 0);\n    let mut parameters = [0; 8];\n    parameters[0] = 0x01010000 ^ 32;\n    evaluate_blake2s_with_parameters(input, &parameters)\n"]], "pred": {"ppl": 2.8024210929870605, "ppl_lower": 5.210232734680176, "ppl/lowercase_ppl": -1.6017958305276518, "ppl/zlib": 0.004837951735356674, "Min_5.0% Prob": 9.205753517150878, "Min_10.0% Prob": 7.001003091985529, "Min_20.0% Prob": 4.292192412459332, "Min_30.0% Prob": 3.134200758593423, "Min_40.0% Prob": 2.4613297784582095, "Min_50.0% Prob": 2.0142160020137236, "Min_60.0% Prob": 1.7211794574345862}}
{"hexsha": "a589569c4a9fd60dec9a6441ab9ec8a9d358d990", "ext": "rs", "lang": "Rust", "content": "fn output_files(gcds: &Vec<Integer>, vulns: &Vec<String>, infile: &String) -> std::io::Result<()> {\n    println!(\"Writing to files...\");\n    let gcdfilename = infile.clone() + \".gcd\";\n    let vulfilename = infile.clone() + \".vuln\";\n    println!(\"GCD Filename: {}\\nVulnerable Moduli Filename: {}\", gcdfilename, vulfilename);\n    \n    let gcdfile = File::create(gcdfilename)?;\n    let mut gcdfile = LineWriter::new(gcdfile);\n    let vulfile = File::create(vulfilename)?;\n    let mut vulfile = LineWriter::new(vulfile);\n    \n    for (gcd, vuln) in gcds.iter().zip(vulns.iter()) {\n        gcdfile.write_all((gcd.to_string_radix(16) + \"\\n\").as_bytes())?;\n        vulfile.write_all((vuln.clone() + \"\\n\").as_bytes())?;\n    }\n\n    gcdfile.flush()?;\n    vulfile.flush()?;\n    println!(\"All done! Phew!\");\n    Ok(())\n}", "item_id": 3, "repo": "ForeverAnApple/Tetanus", "file": "src/main.rs", "last_update_at": "2020-02-10T20:23:18+00:00", "question_id": "a589569c4a9fd60dec9a6441ab9ec8a9d358d990_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn output_files(gcds: &Vec<Integer>, vulns: &Vec<String>, infile: &String) -> std::io::Result<()> {\n    println!(\"Writing to files...\");\n    let gcdfilename = infile.clone() + \".gcd\";\n    let vulfilename = infile.clone() + \".vuln\";\n    println!(\"GCD Filename: {}\\nVulnerable Moduli Filename: {}\", gcdfilename, vulfilename);\n    let gcdfile = File::create(gcdfilename)?;\n    let mut gcdfile = LineWriter::new(gcdfile);\n    let vulfile = File::create(vulfilename)?;\n    let mut vulfile = LineWriter::new(vulfile);\n    for (gcd, vuln) in gcds.iter().zip(vulns.iter()) {\n        gcdfile.write_all((gcd.to_string_radix(16) + \"\\n\").as_bytes())?;\n        vulfile.write_all((vuln.clone() + \"\\n\").as_bytes())?;\n    }\n    gcdfile.flush()?;\n    vulfile.flush()?;\n    println!(\"All done! Phew!\");\n    Ok(())\n"]], "pred": {"ppl": 2.0056979656219482, "ppl_lower": 2.3152546882629395, "ppl/lowercase_ppl": -1.2062201319278443, "ppl/zlib": 0.0019068277060577366, "Min_5.0% Prob": 6.876323541005452, "Min_10.0% Prob": 5.029762736956278, "Min_20.0% Prob": 3.20761516836823, "Min_30.0% Prob": 2.2773052244396, "Min_40.0% Prob": 1.7283579250339602, "Min_50.0% Prob": 1.3933634012386105, "Min_60.0% Prob": 1.1590460966051113}}
{"hexsha": "8e11e181147c744687c5a3d27ceb882e495bc0ce", "ext": "rs", "lang": "Rust", "content": "fn decode_footer_deser() {\n    let mut message = p!(Message, \"message_footer_1\");\n\n    assert_eq!(\n        message.embeds.remove(0).footer.unwrap().text,\n        \"2005-09-26 - 2013-09-26\"\n    );\n\n    p!(Message, \"message_footer_2\");\n}", "item_id": 3, "repo": "inspier/serenity", "file": "tests/test_deser.rs", "last_update_at": "2020-04-03T08:47:31+00:00", "question_id": "8e11e181147c744687c5a3d27ceb882e495bc0ce_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_footer_deser() {\n    let mut message = p!(Message, \"message_footer_1\");\n    assert_eq!(\n        message.embeds.remove(0).footer.unwrap().text,\n        \"2005-09-26 - 2013-09-26\"\n    );\n    p!(Message, \"message_footer_2\");\n"]], "pred": {"ppl": 4.92015266418457, "ppl_lower": 5.119515895843506, "ppl/lowercase_ppl": -1.024928976015746, "ppl/zlib": 0.010413984047899508, "Min_5.0% Prob": 10.26509428024292, "Min_10.0% Prob": 8.122587733798557, "Min_20.0% Prob": 5.645437014730353, "Min_30.0% Prob": 4.450068188565118, "Min_40.0% Prob": 3.6329641342163086, "Min_50.0% Prob": 3.090094863100255, "Min_60.0% Prob": 2.6150070256308506}}
{"hexsha": "f36293d646d0388e8ab67dec3255bee342cf2802", "ext": "rs", "lang": "Rust", "content": "fn generate_hash(server_id: &str, shared_secret: &[u8], public_key: &[u8]) -> String {\n        let mut sha1 = Sha1::new();\n        sha1.update(server_id.as_bytes());\n        sha1.update(shared_secret);\n        sha1.update(public_key);\n        finish_hash(sha1)\n    }", "item_id": 1, "repo": "DomWilliams0/minecraft-server-rs", "file": "mc/src/connection/login.rs", "last_update_at": "2020-04-06T18:59:10+00:00", "question_id": "f36293d646d0388e8ab67dec3255bee342cf2802_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_hash(server_id: &str, shared_secret: &[u8], public_key: &[u8]) -> String {\n        let mut sha1 = Sha1::new();\n        sha1.update(server_id.as_bytes());\n        sha1.update(shared_secret);\n        sha1.update(public_key);\n        finish_hash(sha1)\n"]], "pred": {"ppl": 2.16727614402771, "ppl_lower": 2.7027971744537354, "ppl/lowercase_ppl": -1.2854871607365592, "ppl/zlib": 0.004926567808410117, "Min_5.0% Prob": 9.285205125808716, "Min_10.0% Prob": 6.529396666420831, "Min_20.0% Prob": 3.7180523464554236, "Min_30.0% Prob": 2.562376283366105, "Min_40.0% Prob": 1.9449463159992144, "Min_50.0% Prob": 1.5581248740152436, "Min_60.0% Prob": 1.2966849415768253}}
{"hexsha": "8e75ec91ae6cfa026d9457ae1c8ca940ebb822f0", "ext": "rs", "lang": "Rust", "content": "fn bench_encode(bencher: &mut test::Bencher) {\n            let s = testutils::KOREAN_TEXT;\n            bencher.bytes = s.len() as u64;\n            bencher.iter(|| {\n                test::black_box({\n                    UTF8Encoding.encode(s, EncoderTrap::Strict)\n                })\n            })\n        }", "item_id": 17, "repo": "hsivonen/encoding_rs_compat", "file": "src/codec/utf_8.rs", "last_update_at": "2020-01-15T07:52:14+00:00", "question_id": "8e75ec91ae6cfa026d9457ae1c8ca940ebb822f0_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_encode(bencher: &mut test::Bencher) {\n            let s = testutils::KOREAN_TEXT;\n            bencher.bytes = s.len() as u64;\n            bencher.iter(|| {\n                test::black_box({\n                    UTF8Encoding.encode(s, EncoderTrap::Strict)\n                })\n            })\n"]], "pred": {"ppl": 2.693060874938965, "ppl_lower": 4.7928547859191895, "ppl/lowercase_ppl": -1.5818717692962678, "ppl/zlib": 0.005759758246819232, "Min_5.0% Prob": 8.318284153938293, "Min_10.0% Prob": 6.407145182291667, "Min_20.0% Prob": 4.321730587217543, "Min_30.0% Prob": 3.203479574786292, "Min_40.0% Prob": 2.451632438881977, "Min_50.0% Prob": 1.9958183682807114, "Min_60.0% Prob": 1.6733369476077231}}
{"hexsha": "41be272e8bf8ef00205d4693fece991dbaa2f42a", "ext": "rs", "lang": "Rust", "content": "pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        private_cloud_name: &str,\n        global_reach_connection_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            private_cloud_name,\n            global_reach_connection_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n    }", "item_id": 32, "repo": "rylev/azure-sdk-for-rust", "file": "services/mgmt/vmware/src/package_2021_06_01/operations.rs", "last_update_at": "2020-06-17T18:39:15+00:00", "question_id": "41be272e8bf8ef00205d4693fece991dbaa2f42a_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn delete(\n        operation_config: &crate::OperationConfig,\n        subscription_id: &str,\n        resource_group_name: &str,\n        private_cloud_name: &str,\n        global_reach_connection_name: &str,\n    ) -> std::result::Result<delete::Response, delete::Error> {\n        let http_client = operation_config.http_client();\n        let url_str = &format!(\n            \"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}\",\n            operation_config.base_path(),\n            subscription_id,\n            resource_group_name,\n            private_cloud_name,\n            global_reach_connection_name\n        );\n        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;\n        let mut req_builder = http::request::Builder::new();\n        req_builder = req_builder.method(http::Method::DELETE);\n        if let Some(token_credential) = operation_config.token_credential() {\n            let token_response = token_credential\n                .get_token(operation_config.token_credential_resource())\n                .await\n                .map_err(delete::Error::GetTokenError)?;\n            req_builder = req_builder.header(http::header::AUTHORIZATION, format!(\"Bearer {}\", token_response.token.secret()));\n        }\n        url.query_pairs_mut().append_pair(\"api-version\", super::API_VERSION);\n        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);\n        req_builder = req_builder.uri(url.as_str());\n        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;\n        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;\n        match rsp.status() {\n            http::StatusCode::OK => Ok(delete::Response::Ok200),\n            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),\n            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),\n            status_code => {\n                let rsp_body = rsp.body();\n                let rsp_value: models::CloudError =\n                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;\n                Err(delete::Error::DefaultResponse {\n                    status_code,\n                    value: rsp_value,\n                })\n            }\n        }\n"]], "pred": {"ppl": 1.072945237159729, "ppl_lower": 2.1844747066497803, "ppl/lowercase_ppl": -11.097911738541773, "ppl/zlib": 8.120810290233783e-05, "Min_5.0% Prob": 1.4134984881589736, "Min_10.0% Prob": 0.7071129203237326, "Min_20.0% Prob": 0.35358340388714116, "Min_30.0% Prob": 0.235725341802478, "Min_40.0% Prob": 0.1761470118546158, "Min_50.0% Prob": 0.14102110329944592, "Min_60.0% Prob": 0.1175751081479216}}
{"hexsha": "c98dcadf2bc4e73f23b41cb7a7f7b606a779e521", "ext": "rs", "lang": "Rust", "content": "pub fn init(context: &PyContext) {\n    let ref generator_type = context.generator_type;\n    context.set_attr(\n        &generator_type,\n        \"__iter__\",\n        context.new_rustfunc(generator_iter),\n    );\n    context.set_attr(\n        &generator_type,\n        \"__next__\",\n        context.new_rustfunc(generator_next),\n    );\n    context.set_attr(\n        &generator_type,\n        \"send\",\n        context.new_rustfunc(generator_send),\n    );\n}", "item_id": 0, "repo": "idbentley/RustPython", "file": "vm/src/obj/objgenerator.rs", "last_update_at": "2020-12-04T23:52:08+00:00", "question_id": "c98dcadf2bc4e73f23b41cb7a7f7b606a779e521_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init(context: &PyContext) {\n    let ref generator_type = context.generator_type;\n    context.set_attr(\n        &generator_type,\n        \"__iter__\",\n        context.new_rustfunc(generator_iter),\n    );\n    context.set_attr(\n        &generator_type,\n        \"__next__\",\n        context.new_rustfunc(generator_next),\n    );\n    context.set_attr(\n        &generator_type,\n        \"send\",\n        context.new_rustfunc(generator_send),\n    );\n"]], "pred": {"ppl": 1.9447556734085083, "ppl_lower": 2.17465877532959, "ppl/lowercase_ppl": -1.1679887374936522, "ppl/zlib": 0.004434242342633375, "Min_5.0% Prob": 8.312942584355673, "Min_10.0% Prob": 5.365936196767366, "Min_20.0% Prob": 3.165357483757867, "Min_30.0% Prob": 2.2254774832144015, "Min_40.0% Prob": 1.6760344963520766, "Min_50.0% Prob": 1.3385212432957538, "Min_60.0% Prob": 1.1134623900779623}}
{"hexsha": "95d93e3810ae0d32dee62d3381b1713f7e428fde", "ext": "rs", "lang": "Rust", "content": "fn invalid_input_in_null_with_unexpected_end_of_input() {\n    let input = r#\"{\n        \"key\": n\"#;\n    let err: ParseDiag = parse_node_err!(input);\n\n    assert_err!(err, JsonParseErrorDetail::UnexpectedEoi {..});\n}", "item_id": 32, "repo": "Kodegenix/kg-tree", "file": "tests/tests/serial/json.rs", "last_update_at": "2020-10-03T16:35:47+00:00", "question_id": "95d93e3810ae0d32dee62d3381b1713f7e428fde_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn invalid_input_in_null_with_unexpected_end_of_input() {\n    let input = r#\"{\n        \"key\": n\"#;\n    let err: ParseDiag = parse_node_err!(input);\n    assert_err!(err, JsonParseErrorDetail::UnexpectedEoi {..});\n"]], "pred": {"ppl": 7.460052490234375, "ppl_lower": 13.416379928588867, "ppl/lowercase_ppl": -1.2920605391731983, "ppl/zlib": 0.012638757549782154, "Min_5.0% Prob": 9.27848744392395, "Min_10.0% Prob": 7.997544288635254, "Min_20.0% Prob": 6.356675207614899, "Min_30.0% Prob": 5.284100989500682, "Min_40.0% Prob": 4.479857422411442, "Min_50.0% Prob": 3.81183216124773, "Min_60.0% Prob": 3.2617188009123006}}
{"hexsha": "665fa328276b0ec718ea476beed61dde34e99284", "ext": "rs", "lang": "Rust", "content": "fn test_matrix_rows() {\n        let mut a = Matrix::new(3, 3, (0..9).collect::<Vec<usize>>());\n\n        let data = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];\n\n        for (i, row) in a.iter_rows().enumerate() {\n            assert_eq!(data[i], *row);\n        }\n\n        for (i, row) in a.iter_rows_mut().enumerate() {\n            assert_eq!(data[i], *row);\n        }\n\n        for row in a.iter_rows_mut() {\n            for r in row {\n                *r = 0;\n            }\n        }\n\n        assert_eq!(a.into_vec(), vec![0; 9]);\n    }", "item_id": 0, "repo": "tafia/rulinalg", "file": "src/matrix/iter.rs", "last_update_at": "2020-06-08T11:03:44+00:00", "question_id": "665fa328276b0ec718ea476beed61dde34e99284_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_matrix_rows() {\n        let mut a = Matrix::new(3, 3, (0..9).collect::<Vec<usize>>());\n        let data = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];\n        for (i, row) in a.iter_rows().enumerate() {\n            assert_eq!(data[i], *row);\n        }\n        for (i, row) in a.iter_rows_mut().enumerate() {\n            assert_eq!(data[i], *row);\n        }\n        for row in a.iter_rows_mut() {\n            for r in row {\n                *r = 0;\n            }\n        }\n        assert_eq!(a.into_vec(), vec![0; 9]);\n"]], "pred": {"ppl": 1.7320983409881592, "ppl_lower": 1.9516745805740356, "ppl/lowercase_ppl": -1.2172708508482166, "ppl/zlib": 0.002317863237932104, "Min_5.0% Prob": 5.541058492660523, "Min_10.0% Prob": 3.7124217092990874, "Min_20.0% Prob": 2.3756847769021987, "Min_30.0% Prob": 1.7445239136616388, "Min_40.0% Prob": 1.3545204864814877, "Min_50.0% Prob": 1.097625870294869, "Min_60.0% Prob": 0.918452164134942}}
{"hexsha": "cfbd8611df1a82b1527afff643ee2da12766a721", "ext": "rs", "lang": "Rust", "content": "pub fn builder_from_image_view<T>(image: &T) -> wgpu::TextureBuilder\nwhere\n    T: image::GenericImageView,\n    T::Pixel: Pixel,\n{\n    let (width, height) = image.dimensions();\n    let format = <T::Pixel as Pixel>::TEXTURE_FORMAT;\n    wgpu::TextureBuilder::new()\n        .size([width, height])\n        .format(format)\n}", "item_id": 0, "repo": "freesig/nannou", "file": "src/wgpu/texture/image.rs", "last_update_at": "2020-08-28T10:28:07+00:00", "question_id": "cfbd8611df1a82b1527afff643ee2da12766a721_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn builder_from_image_view<T>(image: &T) -> wgpu::TextureBuilder\nwhere\n    T: image::GenericImageView,\n    T::Pixel: Pixel,\n{\n    let (width, height) = image.dimensions();\n    let format = <T::Pixel as Pixel>::TEXTURE_FORMAT;\n    wgpu::TextureBuilder::new()\n        .size([width, height])\n        .format(format)\n"]], "pred": {"ppl": 2.79677152633667, "ppl_lower": 4.433513164520264, "ppl/lowercase_ppl": -1.4479746597829286, "ppl/zlib": 0.004874245145149662, "Min_5.0% Prob": 8.785755920410157, "Min_10.0% Prob": 6.795297884941101, "Min_20.0% Prob": 4.466605788185483, "Min_30.0% Prob": 3.283660940825939, "Min_40.0% Prob": 2.5470233639312343, "Min_50.0% Prob": 2.048144585004559, "Min_60.0% Prob": 1.7331901639408898}}
{"hexsha": "84e1d0d1670aff82560e05159db64a924e781719", "ext": "rs", "lang": "Rust", "content": "fn package_created_correctly() {\n        let pkg = Package::new(\n            \"Python\",\n            \"3.8\",\n            \"https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz\",\n            \"tar.xz\",\n            \"Python-3.8.0.tar.xz\",\n            \"make\",\n            \"Python-3.8.0\",\n        )\n        .unwrap();\n\n        assert_eq!(pkg.name, String::from(\"Python\"));\n        assert_eq!(pkg.version, String::from(\"3.8\"));\n        assert_eq!(\n            pkg.url,\n            String::from(\"https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz\")\n        );\n        let mut f_type = None;\n        if let FileTypes::TarXz = pkg.file_type {\n            f_type = Some(\"tar.xz\");\n        };\n        assert_eq!(f_type.unwrap(), String::from(\"tar.xz\"));\n        assert_eq!(pkg.file, String::from(\"Python-3.8.0.tar.xz\"));\n        assert_eq!(pkg.install_target, String::from(\"Python-3.8.0\"));\n    }", "item_id": 0, "repo": "rvillegasm/sage", "file": "src/packages.rs", "last_update_at": "2020-01-28T16:39:05+00:00", "question_id": "84e1d0d1670aff82560e05159db64a924e781719_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn package_created_correctly() {\n        let pkg = Package::new(\n            \"Python\",\n            \"3.8\",\n            \"https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz\",\n            \"tar.xz\",\n            \"Python-3.8.0.tar.xz\",\n            \"make\",\n            \"Python-3.8.0\",\n        )\n        .unwrap();\n        assert_eq!(pkg.name, String::from(\"Python\"));\n        assert_eq!(pkg.version, String::from(\"3.8\"));\n        assert_eq!(\n            pkg.url,\n            String::from(\"https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz\")\n        );\n        let mut f_type = None;\n        if let FileTypes::TarXz = pkg.file_type {\n            f_type = Some(\"tar.xz\");\n        };\n        assert_eq!(f_type.unwrap(), String::from(\"tar.xz\"));\n        assert_eq!(pkg.file, String::from(\"Python-3.8.0.tar.xz\"));\n        assert_eq!(pkg.install_target, String::from(\"Python-3.8.0\"));\n"]], "pred": {"ppl": 1.7378807067871094, "ppl_lower": 1.923287272453308, "ppl/lowercase_ppl": -1.1834188931022127, "ppl/zlib": 0.0017885643568778004, "Min_5.0% Prob": 6.54539330303669, "Min_10.0% Prob": 4.348096359521151, "Min_20.0% Prob": 2.600583160761744, "Min_30.0% Prob": 1.8219676214891176, "Min_40.0% Prob": 1.3812409229576588, "Min_50.0% Prob": 1.1078260479524034, "Min_60.0% Prob": 0.9237505290663345}}
{"hexsha": "3abc27595315290123361fc74b3923d80d4cc5f7", "ext": "rs", "lang": "Rust", "content": "fn rom_bank_switching_zero() {\n        let mut mbc = MBC5::new(&[]);\n        mbc.write_rom(0x2000, 0);\n        assert_eq!(mbc.rom_bank(), 0);\n    }", "item_id": 1, "repo": "flix477/rustyboy", "file": "packages/core/src/cartridge/mbc/mbc5.rs", "last_update_at": "2020-05-20T20:35:58+00:00", "question_id": "3abc27595315290123361fc74b3923d80d4cc5f7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rom_bank_switching_zero() {\n        let mut mbc = MBC5::new(&[]);\n        mbc.write_rom(0x2000, 0);\n        assert_eq!(mbc.rom_bank(), 0);\n"]], "pred": {"ppl": 3.6960606575012207, "ppl_lower": 3.971609592437744, "ppl/lowercase_ppl": -1.0550031898855745, "ppl/zlib": 0.011467259344792573, "Min_5.0% Prob": 9.803276697794596, "Min_10.0% Prob": 7.499473849932353, "Min_20.0% Prob": 5.170246660709381, "Min_30.0% Prob": 3.7690186375065853, "Min_40.0% Prob": 3.0562751483917237, "Min_50.0% Prob": 2.5020883781835437, "Min_60.0% Prob": 2.1577626803987906}}
{"hexsha": "f4ea981c0063b63bca8a9d5ffc2c44aa0fbd5ad5", "ext": "rs", "lang": "Rust", "content": "fn test_error_helpers() {\n        let r: HttpResponse = ErrorBadRequest(\"err\").into();\n        assert_eq!(r.status(), StatusCode::BAD_REQUEST);\n\n        let r: HttpResponse = ErrorUnauthorized(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNAUTHORIZED);\n\n        let r: HttpResponse = ErrorPaymentRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PAYMENT_REQUIRED);\n\n        let r: HttpResponse = ErrorForbidden(\"err\").into();\n        assert_eq!(r.status(), StatusCode::FORBIDDEN);\n\n        let r: HttpResponse = ErrorNotFound(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_FOUND);\n\n        let r: HttpResponse = ErrorMethodNotAllowed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::METHOD_NOT_ALLOWED);\n\n        let r: HttpResponse = ErrorNotAcceptable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_ACCEPTABLE);\n\n        let r: HttpResponse = ErrorProxyAuthenticationRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PROXY_AUTHENTICATION_REQUIRED);\n\n        let r: HttpResponse = ErrorRequestTimeout(\"err\").into();\n        assert_eq!(r.status(), StatusCode::REQUEST_TIMEOUT);\n\n        let r: HttpResponse = ErrorConflict(\"err\").into();\n        assert_eq!(r.status(), StatusCode::CONFLICT);\n\n        let r: HttpResponse = ErrorGone(\"err\").into();\n        assert_eq!(r.status(), StatusCode::GONE);\n\n        let r: HttpResponse = ErrorLengthRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LENGTH_REQUIRED);\n\n        let r: HttpResponse = ErrorPreconditionFailed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PRECONDITION_FAILED);\n\n        let r: HttpResponse = ErrorPayloadTooLarge(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PAYLOAD_TOO_LARGE);\n\n        let r: HttpResponse = ErrorUriTooLong(\"err\").into();\n        assert_eq!(r.status(), StatusCode::URI_TOO_LONG);\n\n        let r: HttpResponse = ErrorUnsupportedMediaType(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);\n\n        let r: HttpResponse = ErrorRangeNotSatisfiable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::RANGE_NOT_SATISFIABLE);\n\n        let r: HttpResponse = ErrorExpectationFailed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::EXPECTATION_FAILED);\n\n        let r: HttpResponse = ErrorImATeapot(\"err\").into();\n        assert_eq!(r.status(), StatusCode::IM_A_TEAPOT);\n\n        let r: HttpResponse = ErrorMisdirectedRequest(\"err\").into();\n        assert_eq!(r.status(), StatusCode::MISDIRECTED_REQUEST);\n\n        let r: HttpResponse = ErrorUnprocessableEntity(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNPROCESSABLE_ENTITY);\n\n        let r: HttpResponse = ErrorLocked(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LOCKED);\n\n        let r: HttpResponse = ErrorFailedDependency(\"err\").into();\n        assert_eq!(r.status(), StatusCode::FAILED_DEPENDENCY);\n\n        let r: HttpResponse = ErrorUpgradeRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UPGRADE_REQUIRED);\n\n        let r: HttpResponse = ErrorPreconditionRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PRECONDITION_REQUIRED);\n\n        let r: HttpResponse = ErrorTooManyRequests(\"err\").into();\n        assert_eq!(r.status(), StatusCode::TOO_MANY_REQUESTS);\n\n        let r: HttpResponse = ErrorRequestHeaderFieldsTooLarge(\"err\").into();\n        assert_eq!(r.status(), StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE);\n\n        let r: HttpResponse = ErrorUnavailableForLegalReasons(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS);\n\n        let r: HttpResponse = ErrorInternalServerError(\"err\").into();\n        assert_eq!(r.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\n        let r: HttpResponse = ErrorNotImplemented(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_IMPLEMENTED);\n\n        let r: HttpResponse = ErrorBadGateway(\"err\").into();\n        assert_eq!(r.status(), StatusCode::BAD_GATEWAY);\n\n        let r: HttpResponse = ErrorServiceUnavailable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::SERVICE_UNAVAILABLE);\n\n        let r: HttpResponse = ErrorGatewayTimeout(\"err\").into();\n        assert_eq!(r.status(), StatusCode::GATEWAY_TIMEOUT);\n\n        let r: HttpResponse = ErrorHttpVersionNotSupported(\"err\").into();\n        assert_eq!(r.status(), StatusCode::HTTP_VERSION_NOT_SUPPORTED);\n\n        let r: HttpResponse = ErrorVariantAlsoNegotiates(\"err\").into();\n        assert_eq!(r.status(), StatusCode::VARIANT_ALSO_NEGOTIATES);\n\n        let r: HttpResponse = ErrorInsufficientStorage(\"err\").into();\n        assert_eq!(r.status(), StatusCode::INSUFFICIENT_STORAGE);\n\n        let r: HttpResponse = ErrorLoopDetected(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LOOP_DETECTED);\n\n        let r: HttpResponse = ErrorNotExtended(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_EXTENDED);\n\n        let r: HttpResponse = ErrorNetworkAuthenticationRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NETWORK_AUTHENTICATION_REQUIRED);\n    }", "item_id": 11, "repo": "ethanpailes/actix-web", "file": "src/error.rs", "last_update_at": "2020-10-22T14:41:40+00:00", "question_id": "f4ea981c0063b63bca8a9d5ffc2c44aa0fbd5ad5_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_error_helpers() {\n        let r: HttpResponse = ErrorBadRequest(\"err\").into();\n        assert_eq!(r.status(), StatusCode::BAD_REQUEST);\n        let r: HttpResponse = ErrorUnauthorized(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNAUTHORIZED);\n        let r: HttpResponse = ErrorPaymentRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PAYMENT_REQUIRED);\n        let r: HttpResponse = ErrorForbidden(\"err\").into();\n        assert_eq!(r.status(), StatusCode::FORBIDDEN);\n        let r: HttpResponse = ErrorNotFound(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_FOUND);\n        let r: HttpResponse = ErrorMethodNotAllowed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::METHOD_NOT_ALLOWED);\n        let r: HttpResponse = ErrorNotAcceptable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_ACCEPTABLE);\n        let r: HttpResponse = ErrorProxyAuthenticationRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PROXY_AUTHENTICATION_REQUIRED);\n        let r: HttpResponse = ErrorRequestTimeout(\"err\").into();\n        assert_eq!(r.status(), StatusCode::REQUEST_TIMEOUT);\n        let r: HttpResponse = ErrorConflict(\"err\").into();\n        assert_eq!(r.status(), StatusCode::CONFLICT);\n        let r: HttpResponse = ErrorGone(\"err\").into();\n        assert_eq!(r.status(), StatusCode::GONE);\n        let r: HttpResponse = ErrorLengthRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LENGTH_REQUIRED);\n        let r: HttpResponse = ErrorPreconditionFailed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PRECONDITION_FAILED);\n        let r: HttpResponse = ErrorPayloadTooLarge(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PAYLOAD_TOO_LARGE);\n        let r: HttpResponse = ErrorUriTooLong(\"err\").into();\n        assert_eq!(r.status(), StatusCode::URI_TOO_LONG);\n        let r: HttpResponse = ErrorUnsupportedMediaType(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);\n        let r: HttpResponse = ErrorRangeNotSatisfiable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::RANGE_NOT_SATISFIABLE);\n        let r: HttpResponse = ErrorExpectationFailed(\"err\").into();\n        assert_eq!(r.status(), StatusCode::EXPECTATION_FAILED);\n        let r: HttpResponse = ErrorImATeapot(\"err\").into();\n        assert_eq!(r.status(), StatusCode::IM_A_TEAPOT);\n        let r: HttpResponse = ErrorMisdirectedRequest(\"err\").into();\n        assert_eq!(r.status(), StatusCode::MISDIRECTED_REQUEST);\n        let r: HttpResponse = ErrorUnprocessableEntity(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNPROCESSABLE_ENTITY);\n        let r: HttpResponse = ErrorLocked(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LOCKED);\n        let r: HttpResponse = ErrorFailedDependency(\"err\").into();\n        assert_eq!(r.status(), StatusCode::FAILED_DEPENDENCY);\n        let r: HttpResponse = ErrorUpgradeRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UPGRADE_REQUIRED);\n        let r: HttpResponse = ErrorPreconditionRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::PRECONDITION_REQUIRED);\n        let r: HttpResponse = ErrorTooManyRequests(\"err\").into();\n        assert_eq!(r.status(), StatusCode::TOO_MANY_REQUESTS);\n        let r: HttpResponse = ErrorRequestHeaderFieldsTooLarge(\"err\").into();\n        assert_eq!(r.status(), StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE);\n        let r: HttpResponse = ErrorUnavailableForLegalReasons(\"err\").into();\n        assert_eq!(r.status(), StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS);\n        let r: HttpResponse = ErrorInternalServerError(\"err\").into();\n        assert_eq!(r.status(), StatusCode::INTERNAL_SERVER_ERROR);\n        let r: HttpResponse = ErrorNotImplemented(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_IMPLEMENTED);\n        let r: HttpResponse = ErrorBadGateway(\"err\").into();\n        assert_eq!(r.status(), StatusCode::BAD_GATEWAY);\n        let r: HttpResponse = ErrorServiceUnavailable(\"err\").into();\n        assert_eq!(r.status(), StatusCode::SERVICE_UNAVAILABLE);\n        let r: HttpResponse = ErrorGatewayTimeout(\"err\").into();\n        assert_eq!(r.status(), StatusCode::GATEWAY_TIMEOUT);\n        let r: HttpResponse = ErrorHttpVersionNotSupported(\"err\").into();\n        assert_eq!(r.status(), StatusCode::HTTP_VERSION_NOT_SUPPORTED);\n        let r: HttpResponse = ErrorVariantAlsoNegotiates(\"err\").into();\n        assert_eq!(r.status(), StatusCode::VARIANT_ALSO_NEGOTIATES);\n        let r: HttpResponse = ErrorInsufficientStorage(\"err\").into();\n        assert_eq!(r.status(), StatusCode::INSUFFICIENT_STORAGE);\n        let r: HttpResponse = ErrorLoopDetected(\"err\").into();\n        assert_eq!(r.status(), StatusCode::LOOP_DETECTED);\n        let r: HttpResponse = ErrorNotExtended(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NOT_EXTENDED);\n        let r: HttpResponse = ErrorNetworkAuthenticationRequired(\"err\").into();\n        assert_eq!(r.status(), StatusCode::NETWORK_AUTHENTICATION_REQUIRED);\n"]], "pred": {"ppl": 1.070231318473816, "ppl_lower": 1.192124366760254, "ppl/lowercase_ppl": -2.5891327899279237, "ppl/zlib": 7.114760020822515e-05, "Min_5.0% Prob": 1.3518274613090007, "Min_10.0% Prob": 0.6791563373077295, "Min_20.0% Prob": 0.34016316482031433, "Min_30.0% Prob": 0.22686337607573556, "Min_40.0% Prob": 0.16975261932383567, "Min_50.0% Prob": 0.1358761741119277, "Min_60.0% Prob": 0.1132701913452699}}
{"hexsha": "1e70aaf4c4126e8dc5e222de9a8bc0272cfe5f00", "ext": "rs", "lang": "Rust", "content": "fn when_i_pop_a_node_off_the_frontier_for_which_multiple_copies_have_been_added_then_i_retrieve_the_one_with_longest_path(){\n        let pe = Arc::new(PartialAssignment::SingleExtension {\n            decision: Decision {variable: Variable(0), value: 4},\n            parent: Arc::new(PartialAssignment::Empty) });\n\n        let pf = Arc::new(PartialAssignment::SingleExtension {\n            decision: Decision {variable: Variable(1), value: 5},\n            parent: Arc::new(PartialAssignment::Empty) });\n\n        let ne = FrontierNode{\n            state: Arc::new(5),\n            path: Arc::clone(&pe),\n            lp_len: 4,\n            ub: 5\n        };\n        let nf = FrontierNode{\n            state: Arc::new(5),\n            path: Arc::clone(&pf),\n            lp_len: 5,\n            ub: 5\n        };\n\n        let mut frontier = empty_frontier();\n        frontier.push(ne);\n        frontier.push(nf.clone());\n\n        assert_eq!(frontier.pop(), Some(nf));\n    }", "item_id": 26, "repo": "lcpz/ddo", "file": "src/implementation/frontier.rs", "last_update_at": "2020-11-26T11:55:00+00:00", "question_id": "1e70aaf4c4126e8dc5e222de9a8bc0272cfe5f00_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn when_i_pop_a_node_off_the_frontier_for_which_multiple_copies_have_been_added_then_i_retrieve_the_one_with_longest_path(){\n        let pe = Arc::new(PartialAssignment::SingleExtension {\n            decision: Decision {variable: Variable(0), value: 4},\n            parent: Arc::new(PartialAssignment::Empty) });\n        let pf = Arc::new(PartialAssignment::SingleExtension {\n            decision: Decision {variable: Variable(1), value: 5},\n            parent: Arc::new(PartialAssignment::Empty) });\n        let ne = FrontierNode{\n            state: Arc::new(5),\n            path: Arc::clone(&pe),\n            lp_len: 4,\n            ub: 5\n        };\n        let nf = FrontierNode{\n            state: Arc::new(5),\n            path: Arc::clone(&pf),\n            lp_len: 5,\n            ub: 5\n        };\n        let mut frontier = empty_frontier();\n        frontier.push(ne);\n        frontier.push(nf.clone());\n        assert_eq!(frontier.pop(), Some(nf));\n"]], "pred": {"ppl": 2.764389753341675, "ppl_lower": 3.347825288772583, "ppl/lowercase_ppl": -1.1883234776254255, "ppl/zlib": 0.002973157621578999, "Min_5.0% Prob": 8.701130867004395, "Min_10.0% Prob": 6.871143627166748, "Min_20.0% Prob": 4.5304009230410465, "Min_30.0% Prob": 3.2723023800746254, "Min_40.0% Prob": 2.527049818901512, "Min_50.0% Prob": 2.0333113811136068, "Min_60.0% Prob": 1.6963046549945264}}
{"hexsha": "f000ff15acdef3d14518700b93d4e9b8a049273f", "ext": "rs", "lang": "Rust", "content": "unsafe fn next_test_constructor_counter() -> u64 {\n  let res = TEST_CONSTRUCTOR_COUNTER;\n  TEST_CONSTRUCTOR_COUNTER += 1;\n  res\n}", "item_id": 0, "repo": "achien/chesser", "file": "src/zobrist_hash.rs", "last_update_at": "2020-04-08T15:30:40+00:00", "question_id": "f000ff15acdef3d14518700b93d4e9b8a049273f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn next_test_constructor_counter() -> u64 {\n  let res = TEST_CONSTRUCTOR_COUNTER;\n  TEST_CONSTRUCTOR_COUNTER += 1;\n  res\n"]], "pred": {"ppl": 3.342285394668579, "ppl_lower": 4.9300055503845215, "ppl/lowercase_ppl": -1.322118043718778, "ppl/zlib": 0.01117272984164029, "Min_5.0% Prob": 10.651216983795166, "Min_10.0% Prob": 8.453415489196777, "Min_20.0% Prob": 5.666535290804776, "Min_30.0% Prob": 4.163291469216347, "Min_40.0% Prob": 3.0621254247697918, "Min_50.0% Prob": 2.411297115197937, "Min_60.0% Prob": 2.0469584986708607}}
{"hexsha": "ed40fb87bf68c186d25e479eac8e98993f88f1f4", "ext": "rs", "lang": "Rust", "content": "pub fn random_word(file_contents: &str) -> String {\n    let mut words: Vec<String> = Vec::new();\n\n    for word in file_contents.split(\" \") {\n        words.push(word.trim().to_string());\n    }\n\n    String::from(&words[rand::thread_rng().gen_range(0, words.len())])\n}", "item_id": 0, "repo": "chrmi/rpgdk", "file": "src/reader/mod.rs", "last_update_at": "2020-01-03T20:26:55+00:00", "question_id": "ed40fb87bf68c186d25e479eac8e98993f88f1f4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn random_word(file_contents: &str) -> String {\n    let mut words: Vec<String> = Vec::new();\n    for word in file_contents.split(\" \") {\n        words.push(word.trim().to_string());\n    }\n    String::from(&words[rand::thread_rng().gen_range(0, words.len())])\n"]], "pred": {"ppl": 2.2035274505615234, "ppl_lower": 2.9648427963256836, "ppl/lowercase_ppl": -1.3756230540203893, "ppl/zlib": 0.0042705916915199505, "Min_5.0% Prob": 8.143850564956665, "Min_10.0% Prob": 5.910575045479669, "Min_20.0% Prob": 3.6220105985800424, "Min_30.0% Prob": 2.55649295007741, "Min_40.0% Prob": 1.9727374696069293, "Min_50.0% Prob": 1.5901354062474435, "Min_60.0% Prob": 1.3291360539280705}}
{"hexsha": "bc89e9e9e326b85be9632e14d15e420ea8bd26a0", "ext": "rs", "lang": "Rust", "content": "pub fn version_text() -> String\n{\n    let version_c = unsafe { ll::Pa_GetVersionText() };\n    let version_s = String::from_utf8_lossy(unsafe { CStr::from_ptr(version_c).to_bytes() });\n    version_s.into_owned()\n}", "item_id": 0, "repo": "forslund/portaudio-rs", "file": "src/pa.rs", "last_update_at": "2020-05-10T11:46:00+00:00", "question_id": "bc89e9e9e326b85be9632e14d15e420ea8bd26a0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn version_text() -> String\n{\n    let version_c = unsafe { ll::Pa_GetVersionText() };\n    let version_s = String::from_utf8_lossy(unsafe { CStr::from_ptr(version_c).to_bytes() });\n    version_s.into_owned()\n"]], "pred": {"ppl": 3.3259220123291016, "ppl_lower": 5.316281318664551, "ppl/lowercase_ppl": -1.3902877663772328, "ppl/zlib": 0.00834546480978618, "Min_5.0% Prob": 9.72263209025065, "Min_10.0% Prob": 7.979887417384556, "Min_20.0% Prob": 5.097125887870789, "Min_30.0% Prob": 3.872594020583413, "Min_40.0% Prob": 2.972673948605855, "Min_50.0% Prob": 2.38988689470448, "Min_60.0% Prob": 2.0264657468431526}}
{"hexsha": "8da842d9a7ccd51097a379d4dd91a7f6af8c32f5", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn yarray_iter_next(iterator: *mut ArrayIter) -> *mut YOutput {\n    assert!(!iterator.is_null());\n\n    let iter = iterator.as_mut().unwrap();\n    if let Some(v) = iter.next() {\n        let out = YOutput::from(v);\n        Box::into_raw(Box::new(out))\n    } else {\n        std::ptr::null_mut()\n    }\n}", "item_id": 23, "repo": "yjs/Yrs", "file": "yffi/src/lib.rs", "last_update_at": "2020-10-17T12:35:39+00:00", "question_id": "8da842d9a7ccd51097a379d4dd91a7f6af8c32f5_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn yarray_iter_next(iterator: *mut ArrayIter) -> *mut YOutput {\n    assert!(!iterator.is_null());\n    let iter = iterator.as_mut().unwrap();\n    if let Some(v) = iter.next() {\n        let out = YOutput::from(v);\n        Box::into_raw(Box::new(out))\n    } else {\n        std::ptr::null_mut()\n    }\n"]], "pred": {"ppl": 2.6404595375061035, "ppl_lower": 3.930753469467163, "ppl/lowercase_ppl": -1.4097810845322707, "ppl/zlib": 0.004713363928385638, "Min_5.0% Prob": 9.133141326904298, "Min_10.0% Prob": 6.385427605022084, "Min_20.0% Prob": 4.24329461292787, "Min_30.0% Prob": 3.13615210128553, "Min_40.0% Prob": 2.4275776025923816, "Min_50.0% Prob": 1.9305892283363002, "Min_60.0% Prob": 1.620503135998525}}
{"hexsha": "b9c203f0b0253606b8cc6eb3e34c618fb7426327", "ext": "rs", "lang": "Rust", "content": "async fn consume_from_queues_should_be_ok() {\n    let client = new_client(3, 10);\n    let pairs = [\n        (new_queue(\"rustqueue1\"), b\"hello1\"),\n        (new_queue(\"rustqueue2\"), b\"hello2\"),\n    ];\n    let mut last_job_id = String::from(\"\");\n    // Firstly, publish 4 messages\n    for (queue, msg) in pairs.iter() {\n        let _ret = client\n            .publish(String::from(queue), \"\".to_string(), msg.to_vec(), 0, 1, 0)\n            .await\n            .map(|(job_id, _request_id)| {\n                last_job_id = job_id.clone();\n            })\n            .map_err(|e| {\n                println!(\"err: {:#?}\", e);\n                assert!(false, \"should succeed\");\n            });\n    }\n\n    println!(\"last job id: {:#?}\", last_job_id);\n    let mut queues = pairs\n        .iter()\n        .map(|(queue, _msg)| queue.clone())\n        .collect::<Vec<String>>();\n    // Reverse queue vector\n    queues.reverse();\n    let _ret = client\n        .consume_from_queues(queues, 10, 1)\n        .await\n        .map(|jobs| {\n            let job = &jobs[0];\n            let decoded_message = &decode(job.data.clone()).unwrap()[..];\n            assert_eq!(b\"hello2\", decoded_message, \"message content should match\");\n        })\n        .map_err(|e| {\n            println!(\"err: {:#?}\", e);\n            assert!(false, \"should succeed\");\n        });\n}", "item_id": 6, "repo": "vjoke/lmstfy-client", "file": "src/api_test.rs", "last_update_at": "2020-06-01T13:28:31+00:00", "question_id": "b9c203f0b0253606b8cc6eb3e34c618fb7426327_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn consume_from_queues_should_be_ok() {\n    let client = new_client(3, 10);\n    let pairs = [\n        (new_queue(\"rustqueue1\"), b\"hello1\"),\n        (new_queue(\"rustqueue2\"), b\"hello2\"),\n    ];\n    let mut last_job_id = String::from(\"\");\n    // Firstly, publish 4 messages\n    for (queue, msg) in pairs.iter() {\n        let _ret = client\n            .publish(String::from(queue), \"\".to_string(), msg.to_vec(), 0, 1, 0)\n            .await\n            .map(|(job_id, _request_id)| {\n                last_job_id = job_id.clone();\n            })\n            .map_err(|e| {\n                println!(\"err: {:#?}\", e);\n                assert!(false, \"should succeed\");\n            });\n    }\n    println!(\"last job id: {:#?}\", last_job_id);\n    let mut queues = pairs\n        .iter()\n        .map(|(queue, _msg)| queue.clone())\n        .collect::<Vec<String>>();\n    // Reverse queue vector\n    queues.reverse();\n    let _ret = client\n        .consume_from_queues(queues, 10, 1)\n        .await\n        .map(|jobs| {\n            let job = &jobs[0];\n            let decoded_message = &decode(job.data.clone()).unwrap()[..];\n            assert_eq!(b\"hello2\", decoded_message, \"message content should match\");\n        })\n        .map_err(|e| {\n            println!(\"err: {:#?}\", e);\n            assert!(false, \"should succeed\");\n        });\n"]], "pred": {"ppl": 2.5286052227020264, "ppl_lower": 2.7358598709106445, "ppl/lowercase_ppl": -1.0849204010646063, "ppl/zlib": 0.0017307236107193403, "Min_5.0% Prob": 6.730480602809361, "Min_10.0% Prob": 5.305237698000531, "Min_20.0% Prob": 3.72098437020945, "Min_30.0% Prob": 2.82330820772999, "Min_40.0% Prob": 2.2426068073063226, "Min_50.0% Prob": 1.841795475670585, "Min_60.0% Prob": 1.5468450073857565}}
{"hexsha": "0334f617d2ed1adf468721f8fa69216e5aff3cc4", "ext": "rs", "lang": "Rust", "content": "pub fn inc<T: CpuRegister, U: CpuBus>(operand: Word, register: &mut T, bus: &mut U) {\n  let computed = bus.read(operand) as i8 +1;\n  register\n    .update_status_negative_by(computed as Data)\n    .update_status_zero_by(computed as Data);\n  bus.write(operand, computed as Data)\n}", "item_id": 8, "repo": "196Ikuchil/nes_emulator", "file": "src/nes/cpu/instructions.rs", "last_update_at": "2020-03-02T09:48:10+00:00", "question_id": "0334f617d2ed1adf468721f8fa69216e5aff3cc4_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn inc<T: CpuRegister, U: CpuBus>(operand: Word, register: &mut T, bus: &mut U) {\n  let computed = bus.read(operand) as i8 +1;\n  register\n    .update_status_negative_by(computed as Data)\n    .update_status_zero_by(computed as Data);\n  bus.write(operand, computed as Data)\n"]], "pred": {"ppl": 5.545380592346191, "ppl_lower": 6.406704425811768, "ppl/lowercase_ppl": -1.0842864457655184, "ppl/zlib": 0.009959100322555776, "Min_5.0% Prob": 10.756109809875488, "Min_10.0% Prob": 9.083699417114257, "Min_20.0% Prob": 6.843753516674042, "Min_30.0% Prob": 5.19515601793925, "Min_40.0% Prob": 4.149862253665924, "Min_50.0% Prob": 3.367523961207446, "Min_60.0% Prob": 2.8466460273646916}}
{"hexsha": "d3608c0dff2e07fabd9c1227d9667486d71be599", "ext": "rs", "lang": "Rust", "content": "async fn exec_cmd_to_sleep_without_limit() {\n        let app = RetryApp::<TestE, TestS> {\n            state: State::ExecuteCommand(TestE {\n                output: Box::new(|| Ok(Exit::new(1))),\n            }),\n            count: None,\n        };\n\n        let next = app.handle().await;\n\n        assert!(match &next {\n            Transition::Next(a) => match a.state {\n                State::Sleep(_) => true,\n                _ => false,\n            },\n            _ => false,\n        });\n    }", "item_id": 0, "repo": "tmtmtoo/cx", "file": "src/app/retry.rs", "last_update_at": "2020-12-17T22:42:32+00:00", "question_id": "d3608c0dff2e07fabd9c1227d9667486d71be599_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn exec_cmd_to_sleep_without_limit() {\n        let app = RetryApp::<TestE, TestS> {\n            state: State::ExecuteCommand(TestE {\n                output: Box::new(|| Ok(Exit::new(1))),\n            }),\n            count: None,\n        };\n        let next = app.handle().await;\n        assert!(match &next {\n            Transition::Next(a) => match a.state {\n                State::Sleep(_) => true,\n                _ => false,\n            },\n            _ => false,\n        });\n"]], "pred": {"ppl": 4.81243896484375, "ppl_lower": 8.149682998657227, "ppl/lowercase_ppl": -1.3352683725698105, "ppl/zlib": 0.006161584380014146, "Min_5.0% Prob": 9.230468886239189, "Min_10.0% Prob": 7.4568526063646585, "Min_20.0% Prob": 5.791493560586657, "Min_30.0% Prob": 4.630593683038439, "Min_40.0% Prob": 3.7390499418241934, "Min_50.0% Prob": 3.1114391063300655, "Min_60.0% Prob": 2.6305335647919597}}
{"hexsha": "a09c08bbc1ac3358c30c069b564486afa149a899", "ext": "rs", "lang": "Rust", "content": "fn fr_validator_requires_min_len_of_15() {\n        let validator = super::validator::france::FranceValidator;\n        assert_eq!(false, validator.validate_id(\"123\"));\n        assert_eq!(false, validator.validate_id(\"123 456 789 0\"));\n    }", "item_id": 0, "repo": "reducktion/socrates-rs", "file": "src/validator/france.rs", "last_update_at": "2020-09-30T18:13:44+00:00", "question_id": "a09c08bbc1ac3358c30c069b564486afa149a899_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fr_validator_requires_min_len_of_15() {\n        let validator = super::validator::france::FranceValidator;\n        assert_eq!(false, validator.validate_id(\"123\"));\n        assert_eq!(false, validator.validate_id(\"123 456 789 0\"));\n"]], "pred": {"ppl": 4.177878379821777, "ppl_lower": 4.701542854309082, "ppl/lowercase_ppl": -1.0825897854462074, "ppl/zlib": 0.010436522285008711, "Min_5.0% Prob": 8.235987663269043, "Min_10.0% Prob": 7.023310601711273, "Min_20.0% Prob": 5.282857319887946, "Min_30.0% Prob": 4.131546249756446, "Min_40.0% Prob": 3.3573377166475566, "Min_50.0% Prob": 2.7825915427370504, "Min_60.0% Prob": 2.3994773912888308}}
{"hexsha": "f6599a6e0e0c2f05481fa8dc4f1d8630b599deb2", "ext": "rs", "lang": "Rust", "content": "fn histogram_from_categories(vals: &Vec<String>) -> (Vec<(String, usize)>, Option<f32>, Option<f32>, Option<f32>, f32) {\n    let ret: Vec<(String, usize)> = vals.iter()\n        .sorted()\n        .group_by(|e| (**e).to_owned())\n        .into_iter()\n        .map(|(k, group_k)| (k, group_k.count()))\n        .sorted_by(|(_, i), (_, j)| i.cmp(j))\n        .collect();\n    let total = ret.iter().fold(0.0, |t, (_s, x)| t + *x as f32);\n    (ret, None, None, None, total)\n}", "item_id": 2, "repo": "singhgurjeet/hist2", "file": "src/data.rs", "last_update_at": "2020-05-28T19:32:09+00:00", "question_id": "f6599a6e0e0c2f05481fa8dc4f1d8630b599deb2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn histogram_from_categories(vals: &Vec<String>) -> (Vec<(String, usize)>, Option<f32>, Option<f32>, Option<f32>, f32) {\n    let ret: Vec<(String, usize)> = vals.iter()\n        .sorted()\n        .group_by(|e| (**e).to_owned())\n        .into_iter()\n        .map(|(k, group_k)| (k, group_k.count()))\n        .sorted_by(|(_, i), (_, j)| i.cmp(j))\n        .collect();\n    let total = ret.iter().fold(0.0, |t, (_s, x)| t + *x as f32);\n    (ret, None, None, None, total)\n"]], "pred": {"ppl": 2.4944911003112793, "ppl_lower": 2.9621593952178955, "ppl/lowercase_ppl": -1.1879845265488649, "ppl/zlib": 0.003542964110806622, "Min_5.0% Prob": 7.929813914828831, "Min_10.0% Prob": 5.868570691660831, "Min_20.0% Prob": 3.9618682139798214, "Min_30.0% Prob": 2.905502836955221, "Min_40.0% Prob": 2.248587743232125, "Min_50.0% Prob": 1.8232255455694701, "Min_60.0% Prob": 1.527376133000903}}
{"hexsha": "91271359992952c355f0c48a18187b49f634eebe", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_alt_CResourceErrorEvent() {\n    assert_eq!(\n        ::std::mem::size_of::<alt_CResourceErrorEvent>(),\n        24usize,\n        concat!(\"Size of: \", stringify!(alt_CResourceErrorEvent))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<alt_CResourceErrorEvent>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(alt_CResourceErrorEvent))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).vtable as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(vtable)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).type_ as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).cancelled as *const _ as usize\n        },\n        12usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(cancelled)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).resource as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(resource)\n        )\n    );\n}", "item_id": 53, "repo": "DimaaIO/altv-rs", "file": "altv-sdk/src/natives.rs", "last_update_at": "2020-07-25T03:17:14+00:00", "question_id": "91271359992952c355f0c48a18187b49f634eebe_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_alt_CResourceErrorEvent() {\n    assert_eq!(\n        ::std::mem::size_of::<alt_CResourceErrorEvent>(),\n        24usize,\n        concat!(\"Size of: \", stringify!(alt_CResourceErrorEvent))\n    );\n    assert_eq!(\n        ::std::mem::align_of::<alt_CResourceErrorEvent>(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(alt_CResourceErrorEvent))\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).vtable as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(vtable)\n        )\n    );\n    assert_eq!(\n        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).type_ as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).cancelled as *const _ as usize\n        },\n        12usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(cancelled)\n        )\n    );\n    assert_eq!(\n        unsafe {\n            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).resource as *const _ as usize\n        },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(alt_CResourceErrorEvent),\n            \"::\",\n            stringify!(resource)\n        )\n    );\n"]], "pred": {"ppl": 1.2397950887680054, "ppl_lower": 1.2737199068069458, "ppl/lowercase_ppl": -1.1255922427116483, "ppl/zlib": 0.0006956184950419145, "Min_5.0% Prob": 4.17287956426541, "Min_10.0% Prob": 2.1563809259357503, "Min_20.0% Prob": 1.0811502322773163, "Min_30.0% Prob": 0.7208497203855029, "Min_40.0% Prob": 0.5379051907465172, "Min_50.0% Prob": 0.43076427286444124, "Min_60.0% Prob": 0.359214483219948}}
{"hexsha": "5492ce4ad7930821249d1f335880ca34bf0881d1", "ext": "rs", "lang": "Rust", "content": "pub fn validate_port(input: String) -> bool {\n    // Check for digits\n    lazy_static! {\n        static ref RE_IP: Regex = Regex::new(r\"^(\\d*)$\").unwrap();\n    }\n    // Shortes \"0\" = 1, longest \"65534\" =\n    if input.is_empty() || input.len() > 5 {\n        log(\"Port length invalid\".to_string(), LOG_STDERR);\n        return false;\n    }\n    //Check regex\n    if RE_IP.is_match(&input) {\n        // Parse if only digits\n        let value: i32 = input.parse().unwrap();\n        // Check range from 0 to 65534\n        value < 65535 && value > 0\n    } else {\n        false\n    }\n}", "item_id": 4, "repo": "houseos/kvs", "file": "src/utils/input_validation.rs", "last_update_at": "2020-12-18T20:03:23+00:00", "question_id": "5492ce4ad7930821249d1f335880ca34bf0881d1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn validate_port(input: String) -> bool {\n    // Check for digits\n    lazy_static! {\n        static ref RE_IP: Regex = Regex::new(r\"^(\\d*)$\").unwrap();\n    }\n    // Shortes \"0\" = 1, longest \"65534\" =\n    if input.is_empty() || input.len() > 5 {\n        log(\"Port length invalid\".to_string(), LOG_STDERR);\n        return false;\n    }\n    //Check regex\n    if RE_IP.is_match(&input) {\n        // Parse if only digits\n        let value: i32 = input.parse().unwrap();\n        // Check range from 0 to 65534\n        value < 65535 && value > 0\n    } else {\n        false\n    }\n"]], "pred": {"ppl": 3.404898166656494, "ppl_lower": 3.848071575164795, "ppl/lowercase_ppl": -1.0998658177400757, "ppl/zlib": 0.0035930059593893087, "Min_5.0% Prob": 8.01873459815979, "Min_10.0% Prob": 6.791254162788391, "Min_20.0% Prob": 5.080130082368851, "Min_30.0% Prob": 3.8557166238625844, "Min_40.0% Prob": 3.0136313922703266, "Min_50.0% Prob": 2.4280814730589935, "Min_60.0% Prob": 2.0385040350196775}}
{"hexsha": "30a7f586689cb6caa74ef86e2e08e067ec229f1c", "ext": "rs", "lang": "Rust", "content": "fn has_cmd(cmd: &str) -> bool {\n    let cmd = format!(\"{}{}\", cmd, env::consts::EXE_SUFFIX);\n    let path = env::var_os(\"PATH\").unwrap_or_default();\n    env::split_paths(&path)\n        .map(|p| p.join(&cmd))\n        .any(|p| p.exists())\n}", "item_id": 0, "repo": "ContextLogic/rover", "file": "installers/binstall/src/system/unix.rs", "last_update_at": "2020-09-24T13:43:59+00:00", "question_id": "30a7f586689cb6caa74ef86e2e08e067ec229f1c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn has_cmd(cmd: &str) -> bool {\n    let cmd = format!(\"{}{}\", cmd, env::consts::EXE_SUFFIX);\n    let path = env::var_os(\"PATH\").unwrap_or_default();\n    env::split_paths(&path)\n        .map(|p| p.join(&cmd))\n        .any(|p| p.exists())\n"]], "pred": {"ppl": 1.8241569995880127, "ppl_lower": 2.3696720600128174, "ppl/lowercase_ppl": -1.4352450407452002, "ppl/zlib": 0.003284797608106502, "Min_5.0% Prob": 7.286744475364685, "Min_10.0% Prob": 4.220238089561462, "Min_20.0% Prob": 2.6647925674915314, "Min_30.0% Prob": 1.9316740146389715, "Min_40.0% Prob": 1.5005058844884236, "Min_50.0% Prob": 1.1952695085302643, "Min_60.0% Prob": 1.0039916531267492}}
